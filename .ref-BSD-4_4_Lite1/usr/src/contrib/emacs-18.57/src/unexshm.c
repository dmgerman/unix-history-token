begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Attempted unexec for AIX.    Copyright (c) 1990  Free Software Foundation, Inc.    This file is not used because it occasionally fails to work.  This   happens because the bss address when Emacs is run is not always the   same.  If it happens to be different from what it was   when Emacs was dumped, the dumped data won't work.   No one has been able to prevent the address from varying.  This file is part of GNU Emacs.  GNU Emacs is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version.  GNU Emacs is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU Emacs; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* This is based on a public domain program written by IBM.  */
end_comment

begin_comment
comment|/*************** SYSTEM DEFINES *********************************/
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"paths.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/mode.h>
end_include

begin_include
include|#
directive|include
file|<sys/ipc.h>
end_include

begin_include
include|#
directive|include
file|<sys/shm.h>
end_include

begin_include
include|#
directive|include
file|<malloc.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_comment
comment|/* MWW */
end_comment

begin_include
include|#
directive|include
file|"lisp.h"
end_include

begin_comment
comment|/*************** LOCAL DEFINES **********************************/
end_comment

begin_struct
struct|struct
name|data_header
comment|/* saved data header		*/
block|{
name|char
modifier|*
name|start
decl_stmt|;
comment|/* dump _data addr		*/
name|char
modifier|*
name|end
decl_stmt|;
comment|/* dump _end addr		*/
name|char
modifier|*
name|sbrk1
decl_stmt|;
comment|/* dump original sbrk addr	*/
name|char
modifier|*
name|sbrk2
decl_stmt|;
comment|/* dump final sbrk addr	*/
name|int
name|puresize
decl_stmt|;
comment|/* size of pure data dumped  */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|EMACSSHMKEY
value|"EMACSSHMKEY"
end_define

begin_define
define|#
directive|define
name|EMACS_DATA_FILE
value|"EMACS-DATA"
end_define

begin_define
define|#
directive|define
name|NEW_SHMGET_FLAGS
value|(IPC_CREAT | S_IWUSR | S_IRUSR \       | S_IWGRP | S_IRGRP | S_IWOTH | S_IROTH)
end_define

begin_define
define|#
directive|define
name|OLD_SHMAT_FLAGS
value|SHM_RDONLY
end_define

begin_define
define|#
directive|define
name|OLD_SHMGET_FLAGS
value|(S_IRUSR | S_IRGRP | S_IROTH)
end_define

begin_define
define|#
directive|define
name|OLD_OPEN_FLAGS
value|O_RDONLY
end_define

begin_define
define|#
directive|define
name|NEW_OPEN_FLAGS
value|(O_RDWR | O_CREAT | O_TRUNC)
end_define

begin_comment
comment|/*************** EXTERNAL / GLOBAL DATA AREA ********************/
end_comment

begin_decl_stmt
specifier|extern
name|char
name|_data
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* start of data addr		*/
end_comment

begin_decl_stmt
specifier|extern
name|char
name|_end
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* end of all data + 1 addr	*/
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|original_sbrk
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* sbrk when dump first run	*/
end_comment

begin_function
name|void
name|map_in_data
parameter_list|(
name|use_dumped_data
parameter_list|)
name|int
name|use_dumped_data
decl_stmt|;
block|{
name|int
name|bufsize
decl_stmt|;
comment|/* malloc buffer size		*/
name|struct
name|data_header
name|dh
decl_stmt|;
comment|/* saved data header		*/
name|int
name|fd
decl_stmt|;
comment|/* saved data file descriptor	*/
name|char
modifier|*
name|finaladdr
decl_stmt|;
comment|/* last addr in bucket		*/
name|char
modifier|*
name|ipckey
init|=
name|getenv
argument_list|(
name|EMACSSHMKEY
argument_list|)
decl_stmt|;
comment|/* env ipc key string	*/
name|int
name|length
decl_stmt|;
comment|/* dumped data lengths		*/
name|char
modifier|*
name|newaddr
decl_stmt|;
comment|/* new malloc buffer addr	*/
name|int
name|numblks
decl_stmt|;
comment|/* number of remaining mallocs	*/
name|int
name|shmid
decl_stmt|;
comment|/* shared memory id		*/
name|key_t
name|shmkey
decl_stmt|;
comment|/* shared memory key		*/
comment|/* Note that using malloc here may not be safe.  */
name|char
name|name
index|[
sizeof|sizeof
argument_list|(
name|PATH_EXEC
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|EMACS_DATA_FILE
argument_list|)
operator|+
literal|2
index|]
decl_stmt|;
comment|/* Consume remaining malloc space without increasing		*/
comment|/* the end of data space					*/
name|original_sbrk
operator|=
name|sbrk
argument_list|(
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|bufsize
operator|=
literal|16
init|;
name|bufsize
operator|<
name|getpagesize
argument_list|()
condition|;
name|bufsize
operator|*=
literal|2
control|)
block|{
while|while
condition|(
operator|(
name|newaddr
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|bufsize
operator|-
literal|8
argument_list|)
operator|)
operator|<
name|original_sbrk
condition|)
empty_stmt|;
for|for
control|(
name|numblks
operator|=
operator|(
name|getpagesize
argument_list|()
operator|/
name|bufsize
operator|)
operator|-
literal|1
init|;
name|numblks
operator|>
literal|0
condition|;
name|numblks
operator|--
control|)
name|malloc
argument_list|(
name|bufsize
operator|-
literal|8
argument_list|)
expr_stmt|;
name|finaladdr
operator|=
name|sbrk
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|original_sbrk
operator|=
name|sbrk
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Determine ipc key from environment or default		*/
if|if
condition|(
name|ipckey
operator|&&
operator|*
name|ipckey
condition|)
name|shmkey
operator|=
name|atoi
argument_list|(
name|ipckey
argument_list|)
expr_stmt|;
else|else
name|shmkey
operator|=
name|SHMKEY
expr_stmt|;
comment|/* If we don't want the dumped data, get an unshared segment.  */
if|if
condition|(
operator|!
name|use_dumped_data
condition|)
block|{
name|shmid
operator|=
name|shmget
argument_list|(
name|IPC_PRIVATE
argument_list|,
name|PURESIZE
argument_list|,
name|NEW_SHMGET_FLAGS
argument_list|)
expr_stmt|;
if|if
condition|(
name|shmid
operator|==
operator|-
literal|1
operator|||
name|shmat
argument_list|(
name|shmid
argument_list|,
operator|(
name|char
operator|*
operator|)
name|PURE_SEG_BITS
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"emacs: failure obtaining new unshared memory segment.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
comment|/* Compute the file name with the dumped data.  */
name|strcpy
argument_list|(
name|name
argument_list|,
name|PATH_EXEC
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|name
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|name
argument_list|,
name|EMACS_DATA_FILE
argument_list|)
expr_stmt|;
comment|/* Open the file and make sure the addresses have not changed.  */
name|fd
operator|=
name|open
argument_list|(
name|name
argument_list|,
name|OLD_OPEN_FLAGS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"emacs: failure opening `%s'\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|read
argument_list|(
name|fd
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|dh
argument_list|,
sizeof|sizeof
argument_list|(
name|dh
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|dh
argument_list|)
operator|||
name|dh
operator|.
name|start
operator|!=
operator|&
name|_data
operator|||
name|dh
operator|.
name|end
operator|!=
operator|&
name|_end
operator|||
name|dh
operator|.
name|sbrk1
operator|!=
name|original_sbrk
operator|||
name|dh
operator|.
name|puresize
operator|!=
name|PURESIZE
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"emacs: header mismatch in `%s'\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Load in the unshared contents.  */
if|if
condition|(
operator|!
operator|(
name|length
operator|=
name|dh
operator|.
name|end
operator|-
name|dh
operator|.
name|start
operator|)
operator|||
name|read
argument_list|(
name|fd
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|_data
argument_list|,
name|length
argument_list|)
operator|!=
name|length
operator|||
operator|!
operator|(
name|length
operator|=
name|dh
operator|.
name|sbrk2
operator|-
name|dh
operator|.
name|sbrk1
operator|)
operator|||
name|brk
argument_list|(
name|dh
operator|.
name|sbrk2
argument_list|)
operator|==
operator|-
literal|1
operator|||
name|read
argument_list|(
name|fd
argument_list|,
name|dh
operator|.
name|sbrk1
argument_list|,
name|length
argument_list|)
operator|!=
name|length
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"emacs: failure loading unshared data.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Attach to "pure data" shared memory segment		*/
if|if
condition|(
operator|(
name|shmid
operator|=
name|shmget
argument_list|(
name|shmkey
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
operator|-
literal|1
operator|||
operator|(
name|newaddr
operator|=
name|shmat
argument_list|(
name|shmid
argument_list|,
operator|(
name|char
operator|*
operator|)
name|PURE_SEG_BITS
argument_list|,
name|OLD_SHMAT_FLAGS
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* We were unable to open an existing segment.  Make a new one.  */
name|struct
name|shmid_ds
name|buf
decl_stmt|;
comment|/* First get rid of the one we tried to get.  */
name|shmdt
argument_list|(
operator|(
name|char
operator|*
operator|)
name|PURE_SEG_BITS
argument_list|)
expr_stmt|;
name|shmctl
argument_list|(
name|shmid
argument_list|,
name|IPC_RMID
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If we could not write the data file, 	 don't make a shared segment that we could write. 	 Make an unshared segment instead.  */
if|if
condition|(
name|access
argument_list|(
name|name
argument_list|,
name|W_OK
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|shmid
operator|=
name|shmget
argument_list|(
name|IPC_PRIVATE
argument_list|,
name|PURESIZE
argument_list|,
name|NEW_SHMGET_FLAGS
argument_list|)
expr_stmt|;
if|if
condition|(
name|shmid
operator|==
operator|-
literal|1
operator|||
name|shmat
argument_list|(
name|shmid
argument_list|,
operator|(
name|char
operator|*
operator|)
name|PURE_SEG_BITS
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"emacs: failure obtaining new unshared memory segment.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Load the proper data into it.  */
if|if
condition|(
name|read
argument_list|(
name|fd
argument_list|,
name|PURE_SEG_BITS
argument_list|,
name|PURESIZE
argument_list|)
operator|!=
name|PURESIZE
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"emacs: failure loading shared memory data.\n"
argument_list|)
expr_stmt|;
name|shmdt
argument_list|(
operator|(
name|char
operator|*
operator|)
name|PURE_SEG_BITS
argument_list|)
expr_stmt|;
name|shmctl
argument_list|(
name|shmid
argument_list|,
name|IPC_RMID
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Allocate the new shared segment and arrange to write it.  */
if|if
condition|(
operator|(
name|shmid
operator|=
name|shmget
argument_list|(
name|shmkey
argument_list|,
name|PURESIZE
argument_list|,
name|NEW_SHMGET_FLAGS
argument_list|)
operator|)
operator|==
operator|-
literal|1
operator|||
name|shmat
argument_list|(
name|shmid
argument_list|,
operator|(
name|char
operator|*
operator|)
name|PURE_SEG_BITS
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"emacs: failure obtaining new shared memory segment.\n"
argument_list|)
expr_stmt|;
name|shmdt
argument_list|(
operator|(
name|char
operator|*
operator|)
name|PURE_SEG_BITS
argument_list|)
expr_stmt|;
name|shmctl
argument_list|(
name|shmid
argument_list|,
name|IPC_RMID
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Load the proper data into it.  */
if|if
condition|(
name|read
argument_list|(
name|fd
argument_list|,
name|PURE_SEG_BITS
argument_list|,
name|PURESIZE
argument_list|)
operator|!=
name|PURESIZE
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"emacs: failure loading shared memory data.\n"
argument_list|)
expr_stmt|;
name|shmdt
argument_list|(
operator|(
name|char
operator|*
operator|)
name|PURE_SEG_BITS
argument_list|)
expr_stmt|;
name|shmctl
argument_list|(
name|shmid
argument_list|,
name|IPC_RMID
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Detach from the segment and bring it back readonly.  */
name|shmdt
argument_list|(
operator|(
name|char
operator|*
operator|)
name|PURE_SEG_BITS
argument_list|)
expr_stmt|;
name|shmctl
argument_list|(
name|shmid
argument_list|,
name|IPC_STAT
argument_list|,
operator|&
name|buf
argument_list|)
expr_stmt|;
name|buf
operator|.
name|shm_perm
operator|.
name|mode
operator|=
name|OLD_SHMGET_FLAGS
expr_stmt|;
name|shmctl
argument_list|(
name|shmid
argument_list|,
name|IPC_SET
argument_list|,
operator|&
name|buf
argument_list|)
expr_stmt|;
name|newaddr
operator|=
name|shmat
argument_list|(
name|shmid
argument_list|,
operator|(
name|char
operator|*
operator|)
name|PURE_SEG_BITS
argument_list|,
name|OLD_SHMAT_FLAGS
argument_list|)
expr_stmt|;
if|if
condition|(
name|newaddr
operator|==
operator|-
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"emacs: failure reattaching shared memory segment.\n"
argument_list|)
expr_stmt|;
name|shmctl
argument_list|(
name|shmid
argument_list|,
name|IPC_RMID
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Dump the appropriate parts of memory into a file named NEW    from which the shared segment can be initialized.  */
end_comment

begin_function
name|void
name|map_out_data
parameter_list|(
name|new
parameter_list|)
name|char
modifier|*
name|new
decl_stmt|;
block|{
name|struct
name|data_header
name|dh
decl_stmt|;
comment|/* saved data header			*/
name|int
name|fd
decl_stmt|;
comment|/* saved data file descriptor		*/
name|int
name|length
decl_stmt|;
comment|/* dumped data length; */
name|int
name|shmid
decl_stmt|;
name|key_t
name|shmkey
decl_stmt|;
comment|/* shared memory key		*/
name|char
modifier|*
name|ipckey
init|=
name|getenv
argument_list|(
name|EMACSSHMKEY
argument_list|)
decl_stmt|;
comment|/* env ipc key string	*/
comment|/* Determine ipc key from environment or default		*/
if|if
condition|(
name|ipckey
operator|&&
operator|*
name|ipckey
condition|)
name|shmkey
operator|=
name|atoi
argument_list|(
name|ipckey
argument_list|)
expr_stmt|;
else|else
name|shmkey
operator|=
name|SHMKEY
expr_stmt|;
comment|/* Create "saved data" file header */
name|dh
operator|.
name|start
operator|=
operator|&
name|_data
expr_stmt|;
name|dh
operator|.
name|end
operator|=
operator|&
name|_end
expr_stmt|;
name|dh
operator|.
name|sbrk1
operator|=
name|original_sbrk
expr_stmt|;
name|dh
operator|.
name|sbrk2
operator|=
name|sbrk
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|dh
operator|.
name|puresize
operator|=
name|PURESIZE
expr_stmt|;
comment|/* Create new "saved data" dump file				*/
name|unlink
argument_list|(
name|new
argument_list|)
expr_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|new
argument_list|,
name|NEW_OPEN_FLAGS
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
name|report_file_error
argument_list|(
literal|"Opening dump file"
argument_list|,
name|Fcons
argument_list|(
name|build_string
argument_list|(
name|new
argument_list|)
argument_list|,
name|Qnil
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Delete obsolete shared segment.  */
name|shmid
operator|=
name|shmget
argument_list|(
name|shmkey
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|shmid
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|shmctl
argument_list|(
name|shmid
argument_list|,
name|IPC_RMID
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Destroying existing shared segment\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Write saved header and data				*/
name|length
operator|=
sizeof|sizeof
argument_list|(
name|dh
argument_list|)
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|fd
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|dh
argument_list|,
name|length
argument_list|)
operator|!=
name|length
condition|)
name|report_file_error
argument_list|(
literal|"Writing dump file header"
argument_list|,
name|Fcons
argument_list|(
name|build_string
argument_list|(
name|new
argument_list|)
argument_list|,
name|Qnil
argument_list|)
argument_list|)
expr_stmt|;
name|length
operator|=
name|dh
operator|.
name|end
operator|-
name|dh
operator|.
name|start
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|fd
argument_list|,
name|dh
operator|.
name|start
argument_list|,
name|length
argument_list|)
operator|!=
name|length
condition|)
name|report_file_error
argument_list|(
literal|"Writing low core in dump file"
argument_list|,
name|Fcons
argument_list|(
name|build_string
argument_list|(
name|new
argument_list|)
argument_list|,
name|Qnil
argument_list|)
argument_list|)
expr_stmt|;
name|length
operator|=
name|dh
operator|.
name|sbrk2
operator|-
name|dh
operator|.
name|sbrk1
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|fd
argument_list|,
name|dh
operator|.
name|sbrk1
argument_list|,
name|length
argument_list|)
operator|!=
name|length
condition|)
name|report_file_error
argument_list|(
literal|"Writing heap in dump file"
argument_list|,
name|Fcons
argument_list|(
name|build_string
argument_list|(
name|new
argument_list|)
argument_list|,
name|Qnil
argument_list|)
argument_list|)
expr_stmt|;
name|length
operator|=
name|PURESIZE
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|fd
argument_list|,
name|PURE_SEG_BITS
argument_list|,
name|length
argument_list|)
operator|!=
name|length
condition|)
name|report_file_error
argument_list|(
literal|"Writing pure data in dump file"
argument_list|,
name|Fcons
argument_list|(
name|build_string
argument_list|(
name|new
argument_list|)
argument_list|,
name|Qnil
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

