begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Markers: examining, setting and killing.    Copyright (C) 1985 Free Software Foundation, Inc.  This file is part of GNU Emacs.  GNU Emacs is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version.  GNU Emacs is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU Emacs; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"lisp.h"
end_include

begin_include
include|#
directive|include
file|"buffer.h"
end_include

begin_comment
comment|/* Operations on markers. */
end_comment

begin_expr_stmt
name|DEFUN
argument_list|(
literal|"marker-buffer"
argument_list|,
name|Fmarker_buffer
argument_list|,
name|Smarker_buffer
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Return the buffer that MARKER points into, or nil if none.\n\ Returns nil if MARKER points into a dead buffer."
argument_list|)
argument_list|(
name|marker
argument_list|)
specifier|register
name|Lisp_Object
name|marker
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|Lisp_Object
name|buf
decl_stmt|;
name|CHECK_MARKER
argument_list|(
name|marker
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|XMARKER
argument_list|(
name|marker
argument_list|)
operator|->
name|buffer
condition|)
block|{
name|XSET
argument_list|(
name|buf
argument_list|,
name|Lisp_Buffer
argument_list|,
name|XMARKER
argument_list|(
name|marker
argument_list|)
operator|->
name|buffer
argument_list|)
expr_stmt|;
comment|/* Return marker's buffer only if it is not dead.  */
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|XBUFFER
argument_list|(
name|buf
argument_list|)
operator|->
name|name
argument_list|)
condition|)
return|return
name|buf
return|;
block|}
return|return
name|Qnil
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"marker-position"
argument_list|,
argument|Fmarker_position
argument_list|,
argument|Smarker_position
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Return the position MARKER points at, as a character number."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|marker
operator|)
name|Lisp_Object
name|marker
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|Lisp_Object
name|pos
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|buffer
modifier|*
name|buf
decl_stmt|;
name|CHECK_MARKER
argument_list|(
name|marker
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|XMARKER
argument_list|(
name|marker
argument_list|)
operator|->
name|buffer
condition|)
block|{
name|buf
operator|=
name|XMARKER
argument_list|(
name|marker
argument_list|)
operator|->
name|buffer
expr_stmt|;
name|i
operator|=
name|XMARKER
argument_list|(
name|marker
argument_list|)
operator|->
name|bufpos
expr_stmt|;
if|if
condition|(
name|i
operator|>
name|BUF_GPT
argument_list|(
name|buf
argument_list|)
operator|+
name|BUF_GAP_SIZE
argument_list|(
name|buf
argument_list|)
condition|)
name|i
operator|-=
name|BUF_GAP_SIZE
argument_list|(
name|buf
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|>
name|BUF_GPT
argument_list|(
name|buf
argument_list|)
condition|)
name|i
operator|=
name|BUF_GPT
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|BUF_BEG
argument_list|(
name|buf
argument_list|)
operator|||
name|i
operator|>
name|BUF_Z
argument_list|(
name|buf
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|XFASTINT
argument_list|(
name|pos
argument_list|)
operator|=
name|i
expr_stmt|;
return|return
name|pos
return|;
block|}
return|return
name|Qnil
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"set-marker"
argument_list|,
argument|Fset_marker
argument_list|,
argument|Sset_marker
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|,
literal|"Position MARKER before character number NUMBER in BUFFER.\n\ BUFFER defaults to the current buffer.\n\ If NUMBER is nil, makes marker point nowhere.\n\ Then it no longer slows down editing in any buffer.\n\ Returns MARKER."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|marker
operator|,
name|pos
operator|,
name|buffer
operator|)
name|Lisp_Object
name|marker
operator|,
name|pos
operator|,
name|buffer
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|charno
decl_stmt|;
specifier|register
name|struct
name|buffer
modifier|*
name|b
decl_stmt|;
specifier|register
name|struct
name|Lisp_Marker
modifier|*
name|m
decl_stmt|;
name|CHECK_MARKER
argument_list|(
name|marker
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If position is nil or a marker that points nowhere,      make this marker point nowhere.  */
if|if
condition|(
name|NULL
argument_list|(
name|pos
argument_list|)
operator|||
operator|(
name|XTYPE
argument_list|(
name|pos
argument_list|)
operator|==
name|Lisp_Marker
operator|&&
operator|!
name|XMARKER
argument_list|(
name|pos
argument_list|)
operator|->
name|buffer
operator|)
condition|)
block|{
if|if
condition|(
name|XMARKER
argument_list|(
name|marker
argument_list|)
operator|->
name|buffer
condition|)
name|unchain_marker
argument_list|(
name|marker
argument_list|)
expr_stmt|;
return|return
name|marker
return|;
block|}
name|CHECK_NUMBER_COERCE_MARKER
argument_list|(
name|pos
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|buffer
argument_list|)
condition|)
name|b
operator|=
name|current_buffer
expr_stmt|;
else|else
block|{
name|CHECK_BUFFER
argument_list|(
name|buffer
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|b
operator|=
name|XBUFFER
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
comment|/* If buffer is dead, set marker to point nowhere.  */
if|if
condition|(
name|EQ
argument_list|(
name|b
operator|->
name|name
argument_list|,
name|Qnil
argument_list|)
condition|)
block|{
if|if
condition|(
name|XMARKER
argument_list|(
name|marker
argument_list|)
operator|->
name|buffer
condition|)
name|unchain_marker
argument_list|(
name|marker
argument_list|)
expr_stmt|;
return|return
name|marker
return|;
block|}
block|}
name|charno
operator|=
name|XINT
argument_list|(
name|pos
argument_list|)
expr_stmt|;
name|m
operator|=
name|XMARKER
argument_list|(
name|marker
argument_list|)
expr_stmt|;
if|if
condition|(
name|charno
operator|<
name|BUF_BEG
argument_list|(
name|b
argument_list|)
condition|)
name|charno
operator|=
name|BUF_BEG
argument_list|(
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|charno
operator|>
name|BUF_Z
argument_list|(
name|b
argument_list|)
condition|)
name|charno
operator|=
name|BUF_Z
argument_list|(
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|charno
operator|>
name|BUF_GPT
argument_list|(
name|b
argument_list|)
condition|)
name|charno
operator|+=
name|BUF_GAP_SIZE
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|m
operator|->
name|bufpos
operator|=
name|charno
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|buffer
operator|!=
name|b
condition|)
block|{
if|if
condition|(
name|m
operator|->
name|buffer
operator|!=
literal|0
condition|)
name|unchain_marker
argument_list|(
name|marker
argument_list|)
expr_stmt|;
name|m
operator|->
name|chain
operator|=
name|b
operator|->
name|markers
expr_stmt|;
name|b
operator|->
name|markers
operator|=
name|marker
expr_stmt|;
name|m
operator|->
name|buffer
operator|=
name|b
expr_stmt|;
block|}
return|return
name|marker
return|;
block|}
end_block

begin_comment
comment|/* This version of Fset_marker won't let the position be outside the visible part.  */
end_comment

begin_function
name|Lisp_Object
name|set_marker_restricted
parameter_list|(
name|marker
parameter_list|,
name|pos
parameter_list|,
name|buffer
parameter_list|)
name|Lisp_Object
name|marker
decl_stmt|,
name|pos
decl_stmt|,
name|buffer
decl_stmt|;
block|{
specifier|register
name|int
name|charno
decl_stmt|;
specifier|register
name|struct
name|buffer
modifier|*
name|b
decl_stmt|;
specifier|register
name|struct
name|Lisp_Marker
modifier|*
name|m
decl_stmt|;
name|CHECK_MARKER
argument_list|(
name|marker
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If position is nil or a marker that points nowhere,      make this marker point nowhere.  */
if|if
condition|(
name|NULL
argument_list|(
name|pos
argument_list|)
operator|||
operator|(
name|XTYPE
argument_list|(
name|pos
argument_list|)
operator|==
name|Lisp_Marker
operator|&&
operator|!
name|XMARKER
argument_list|(
name|pos
argument_list|)
operator|->
name|buffer
operator|)
condition|)
block|{
if|if
condition|(
name|XMARKER
argument_list|(
name|marker
argument_list|)
operator|->
name|buffer
condition|)
name|unchain_marker
argument_list|(
name|marker
argument_list|)
expr_stmt|;
return|return
name|marker
return|;
block|}
name|CHECK_NUMBER_COERCE_MARKER
argument_list|(
name|pos
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|buffer
argument_list|)
condition|)
name|b
operator|=
name|current_buffer
expr_stmt|;
else|else
block|{
name|CHECK_BUFFER
argument_list|(
name|buffer
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|b
operator|=
name|XBUFFER
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
comment|/* If buffer is dead, set marker to point nowhere.  */
if|if
condition|(
name|EQ
argument_list|(
name|b
operator|->
name|name
argument_list|,
name|Qnil
argument_list|)
condition|)
block|{
if|if
condition|(
name|XMARKER
argument_list|(
name|marker
argument_list|)
operator|->
name|buffer
condition|)
name|unchain_marker
argument_list|(
name|marker
argument_list|)
expr_stmt|;
return|return
name|marker
return|;
block|}
block|}
name|charno
operator|=
name|XINT
argument_list|(
name|pos
argument_list|)
expr_stmt|;
name|m
operator|=
name|XMARKER
argument_list|(
name|marker
argument_list|)
expr_stmt|;
if|if
condition|(
name|charno
operator|<
name|BUF_BEGV
argument_list|(
name|b
argument_list|)
condition|)
name|charno
operator|=
name|BUF_BEGV
argument_list|(
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|charno
operator|>
name|BUF_ZV
argument_list|(
name|b
argument_list|)
condition|)
name|charno
operator|=
name|BUF_ZV
argument_list|(
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|charno
operator|>
name|BUF_GPT
argument_list|(
name|b
argument_list|)
condition|)
name|charno
operator|+=
name|BUF_GAP_SIZE
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|m
operator|->
name|bufpos
operator|=
name|charno
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|buffer
operator|!=
name|b
condition|)
block|{
if|if
condition|(
name|m
operator|->
name|buffer
operator|!=
literal|0
condition|)
name|unchain_marker
argument_list|(
name|marker
argument_list|)
expr_stmt|;
name|m
operator|->
name|chain
operator|=
name|b
operator|->
name|markers
expr_stmt|;
name|b
operator|->
name|markers
operator|=
name|marker
expr_stmt|;
name|m
operator|->
name|buffer
operator|=
name|b
expr_stmt|;
block|}
return|return
name|marker
return|;
block|}
end_function

begin_comment
comment|/* This is called during garbage collection,  so we must be careful to ignore and preserve mark bits,  including those in chain fields of markers.  */
end_comment

begin_expr_stmt
name|unchain_marker
argument_list|(
name|marker
argument_list|)
specifier|register
name|Lisp_Object
name|marker
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|Lisp_Object
name|tail
decl_stmt|,
name|prev
decl_stmt|,
name|next
decl_stmt|;
specifier|register
name|int
name|omark
decl_stmt|;
specifier|register
name|struct
name|buffer
modifier|*
name|b
decl_stmt|;
name|b
operator|=
name|XMARKER
argument_list|(
name|marker
argument_list|)
operator|->
name|buffer
expr_stmt|;
if|if
condition|(
name|EQ
argument_list|(
name|b
operator|->
name|name
argument_list|,
name|Qnil
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|tail
operator|=
name|b
operator|->
name|markers
expr_stmt|;
name|prev
operator|=
name|Qnil
expr_stmt|;
while|while
condition|(
name|XSYMBOL
argument_list|(
name|tail
argument_list|)
operator|!=
name|XSYMBOL
argument_list|(
name|Qnil
argument_list|)
condition|)
block|{
name|next
operator|=
name|XMARKER
argument_list|(
name|tail
argument_list|)
operator|->
name|chain
expr_stmt|;
name|XUNMARK
argument_list|(
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
name|XMARKER
argument_list|(
name|marker
argument_list|)
operator|==
name|XMARKER
argument_list|(
name|tail
argument_list|)
condition|)
block|{
if|if
condition|(
name|NULL
argument_list|(
name|prev
argument_list|)
condition|)
block|{
name|b
operator|->
name|markers
operator|=
name|next
expr_stmt|;
comment|/* Deleting first marker from the buffer's chain. 		 Crash if new first marker in chain does not say 		 it belongs to this buffer.  */
if|if
condition|(
operator|!
name|EQ
argument_list|(
name|next
argument_list|,
name|Qnil
argument_list|)
operator|&&
name|b
operator|!=
name|XMARKER
argument_list|(
name|next
argument_list|)
operator|->
name|buffer
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|omark
operator|=
name|XMARKBIT
argument_list|(
name|XMARKER
argument_list|(
name|prev
argument_list|)
operator|->
name|chain
argument_list|)
expr_stmt|;
name|XMARKER
argument_list|(
name|prev
argument_list|)
operator|->
name|chain
operator|=
name|next
expr_stmt|;
name|XSETMARKBIT
argument_list|(
name|XMARKER
argument_list|(
name|prev
argument_list|)
operator|->
name|chain
argument_list|,
name|omark
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
else|else
name|prev
operator|=
name|tail
expr_stmt|;
name|tail
operator|=
name|next
expr_stmt|;
block|}
name|XMARKER
argument_list|(
name|marker
argument_list|)
operator|->
name|buffer
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_macro
name|marker_position
argument_list|(
argument|marker
argument_list|)
end_macro

begin_decl_stmt
name|Lisp_Object
name|marker
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|Lisp_Marker
modifier|*
name|m
init|=
name|XMARKER
argument_list|(
name|marker
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|buffer
modifier|*
name|buf
init|=
name|m
operator|->
name|buffer
decl_stmt|;
specifier|register
name|int
name|i
init|=
name|m
operator|->
name|bufpos
decl_stmt|;
if|if
condition|(
operator|!
name|buf
condition|)
name|error
argument_list|(
literal|"Marker does not point anywhere"
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
name|BUF_GPT
argument_list|(
name|buf
argument_list|)
operator|+
name|BUF_GAP_SIZE
argument_list|(
name|buf
argument_list|)
condition|)
name|i
operator|-=
name|BUF_GAP_SIZE
argument_list|(
name|buf
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|>
name|BUF_GPT
argument_list|(
name|buf
argument_list|)
condition|)
name|i
operator|=
name|BUF_GPT
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|BUF_BEG
argument_list|(
name|buf
argument_list|)
operator|||
name|i
operator|>
name|BUF_Z
argument_list|(
name|buf
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|i
return|;
block|}
end_block

begin_expr_stmt
name|DEFUN
argument_list|(
literal|"copy-marker"
argument_list|,
name|Fcopy_marker
argument_list|,
name|Scopy_marker
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Return a new marker pointing at the same place as MARKER.\n\ If argument is a number, makes a new marker pointing\n\ at that position in the current buffer."
argument_list|)
argument_list|(
name|marker
argument_list|)
specifier|register
name|Lisp_Object
name|marker
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|Lisp_Object
name|new
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|XTYPE
argument_list|(
name|marker
argument_list|)
operator|==
name|Lisp_Int
operator|||
name|XTYPE
argument_list|(
name|marker
argument_list|)
operator|==
name|Lisp_Marker
condition|)
block|{
name|new
operator|=
name|Fmake_marker
argument_list|()
expr_stmt|;
name|Fset_marker
argument_list|(
name|new
argument_list|,
name|marker
argument_list|,
operator|(
operator|(
name|XTYPE
argument_list|(
name|marker
argument_list|)
operator|==
name|Lisp_Marker
operator|)
condition|?
name|Fmarker_buffer
argument_list|(
name|marker
argument_list|)
else|:
name|Qnil
operator|)
argument_list|)
expr_stmt|;
return|return
name|new
return|;
block|}
else|else
name|marker
operator|=
name|wrong_type_argument
argument_list|(
name|Qinteger_or_marker_p
argument_list|,
name|marker
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_macro
name|syms_of_marker
argument_list|()
end_macro

begin_block
block|{
name|defsubr
argument_list|(
operator|&
name|Smarker_position
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Smarker_buffer
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sset_marker
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Scopy_marker
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

