begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Lisp functions pertaining to editing.    Copyright (C) 1985, 1986, 1987, 1990 Free Software Foundation, Inc.  This file is part of GNU Emacs.  GNU Emacs is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version.  GNU Emacs is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU Emacs; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|hpux
end_ifdef

begin_comment
comment|/* needed by<pwd.h> */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_undef
undef|#
directive|undef
name|NULL
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|"lisp.h"
end_include

begin_include
include|#
directive|include
file|"buffer.h"
end_include

begin_include
include|#
directive|include
file|"window.h"
end_include

begin_define
define|#
directive|define
name|min
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)< (b) ? (a) : (b))
end_define

begin_define
define|#
directive|define
name|max
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)> (b) ? (a) : (b))
end_define

begin_comment
comment|/* Some static data, and a function to initialize it for each run */
end_comment

begin_decl_stmt
specifier|static
name|Lisp_Object
name|Vsystem_name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Lisp_Object
name|Vuser_real_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* login name of current user ID */
end_comment

begin_decl_stmt
specifier|static
name|Lisp_Object
name|Vuser_full_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* full name of current user */
end_comment

begin_decl_stmt
specifier|static
name|Lisp_Object
name|Vuser_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* user name from USER or LOGNAME.  */
end_comment

begin_function
name|void
name|init_editfns
parameter_list|()
block|{
name|char
modifier|*
name|user_name
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|struct
name|passwd
modifier|*
name|pw
decl_stmt|;
comment|/* password entry for the current user */
name|Lisp_Object
name|tem
decl_stmt|;
specifier|extern
name|char
modifier|*
name|index
parameter_list|()
function_decl|;
comment|/* Set up system_name even when dumping.  */
name|Vsystem_name
operator|=
name|build_string
argument_list|(
name|get_system_name
argument_list|()
argument_list|)
expr_stmt|;
name|p
operator|=
name|XSTRING
argument_list|(
name|Vsystem_name
argument_list|)
operator|->
name|data
expr_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
condition|)
operator|*
name|p
operator|=
literal|'-'
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|CANNOT_DUMP
comment|/* Don't bother with this on initial start when just dumping out */
if|if
condition|(
operator|!
name|initialized
condition|)
return|return;
endif|#
directive|endif
comment|/* not CANNOT_DUMP */
name|pw
operator|=
operator|(
expr|struct
name|passwd
operator|*
operator|)
name|getpwuid
argument_list|(
name|getuid
argument_list|()
argument_list|)
expr_stmt|;
name|Vuser_real_name
operator|=
name|build_string
argument_list|(
name|pw
condition|?
name|pw
operator|->
name|pw_name
else|:
literal|"unknown"
argument_list|)
expr_stmt|;
name|user_name
operator|=
operator|(
name|char
operator|*
operator|)
name|getenv
argument_list|(
literal|"USER"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|user_name
condition|)
name|user_name
operator|=
operator|(
name|char
operator|*
operator|)
name|getenv
argument_list|(
literal|"LOGNAME"
argument_list|)
expr_stmt|;
comment|/* USG equivalent */
if|if
condition|(
name|user_name
condition|)
name|Vuser_name
operator|=
name|build_string
argument_list|(
name|user_name
argument_list|)
expr_stmt|;
else|else
name|Vuser_name
operator|=
name|Vuser_real_name
expr_stmt|;
name|tem
operator|=
name|Fstring_equal
argument_list|(
name|Vuser_name
argument_list|,
name|Vuser_real_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|tem
argument_list|)
condition|)
name|pw
operator|=
operator|(
expr|struct
name|passwd
operator|*
operator|)
name|getpwnam
argument_list|(
name|user_name
argument_list|)
expr_stmt|;
name|p
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|(
name|pw
condition|?
name|USER_FULL_NAME
else|:
literal|"unknown"
operator|)
expr_stmt|;
name|q
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|index
argument_list|(
name|p
argument_list|,
literal|','
argument_list|)
expr_stmt|;
name|Vuser_full_name
operator|=
name|make_string
argument_list|(
name|p
argument_list|,
name|q
condition|?
name|q
operator|-
name|p
else|:
name|strlen
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AMPERSAND_FULL_NAME
name|p
operator|=
name|XSTRING
argument_list|(
name|Vuser_full_name
argument_list|)
operator|->
name|data
expr_stmt|;
name|q
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|index
argument_list|(
name|p
argument_list|,
literal|'&'
argument_list|)
expr_stmt|;
comment|/* Substitute the login name for the&, upcasing the first character.  */
if|if
condition|(
name|q
condition|)
block|{
name|char
modifier|*
name|r
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|p
argument_list|)
operator|+
name|XSTRING
argument_list|(
name|Vuser_name
argument_list|)
operator|->
name|size
operator|+
literal|1
argument_list|)
decl_stmt|;
name|bcopy
argument_list|(
name|p
argument_list|,
name|r
argument_list|,
name|q
operator|-
name|p
argument_list|)
expr_stmt|;
name|r
index|[
name|q
operator|-
name|p
index|]
operator|=
literal|0
expr_stmt|;
name|strcat
argument_list|(
name|r
argument_list|,
name|XSTRING
argument_list|(
name|Vuser_real_name
argument_list|)
operator|->
name|data
argument_list|)
expr_stmt|;
name|r
index|[
name|q
operator|-
name|p
index|]
operator|=
name|UPCASE
argument_list|(
name|r
index|[
name|q
operator|-
name|p
index|]
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|r
argument_list|,
name|q
operator|+
literal|1
argument_list|)
expr_stmt|;
name|Vuser_full_name
operator|=
name|build_string
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* AMPERSAND_FULL_NAME */
block|}
end_function

begin_escape
end_escape

begin_macro
name|DEFUN
argument_list|(
literal|"char-to-string"
argument_list|,
argument|Fchar_to_string
argument_list|,
argument|Schar_to_string
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Convert arg CHAR to a string containing that character."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|n
operator|)
name|Lisp_Object
name|n
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|char
name|c
decl_stmt|;
name|CHECK_NUMBER
argument_list|(
name|n
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|c
operator|=
name|XINT
argument_list|(
name|n
argument_list|)
expr_stmt|;
return|return
name|make_string
argument_list|(
operator|&
name|c
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_block

begin_expr_stmt
name|DEFUN
argument_list|(
literal|"string-to-char"
argument_list|,
name|Fstring_to_char
argument_list|,
name|Sstring_to_char
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Convert arg STRING to a character, the first character of that string."
argument_list|)
argument_list|(
name|str
argument_list|)
specifier|register
name|Lisp_Object
name|str
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|Lisp_Object
name|val
decl_stmt|;
specifier|register
name|struct
name|Lisp_String
modifier|*
name|p
decl_stmt|;
name|CHECK_STRING
argument_list|(
name|str
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|p
operator|=
name|XSTRING
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|size
condition|)
name|XFASTINT
argument_list|(
name|val
argument_list|)
operator|=
operator|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|p
operator|->
name|data
operator|)
index|[
literal|0
index|]
expr_stmt|;
else|else
name|XFASTINT
argument_list|(
name|val
argument_list|)
operator|=
literal|0
expr_stmt|;
return|return
name|val
return|;
block|}
end_block

begin_escape
end_escape

begin_function
specifier|static
name|Lisp_Object
name|buildmark
parameter_list|(
name|val
parameter_list|)
name|int
name|val
decl_stmt|;
block|{
specifier|register
name|Lisp_Object
name|mark
decl_stmt|;
name|mark
operator|=
name|Fmake_marker
argument_list|()
expr_stmt|;
name|Fset_marker
argument_list|(
name|mark
argument_list|,
name|make_number
argument_list|(
name|val
argument_list|)
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
return|return
name|mark
return|;
block|}
end_function

begin_macro
name|DEFUN
argument_list|(
literal|"point"
argument_list|,
argument|Fpoint
argument_list|,
argument|Spoint
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Return value of point, as an integer.\n\ Beginning of buffer is position (point-min)"
argument_list|)
end_macro

begin_expr_stmt
operator|(
operator|)
block|{
name|Lisp_Object
name|temp
block|;
name|XFASTINT
argument_list|(
name|temp
argument_list|)
operator|=
name|point
block|;
return|return
name|temp
return|;
block|}
end_expr_stmt

begin_macro
name|DEFUN
argument_list|(
literal|"point-marker"
argument_list|,
argument|Fpoint_marker
argument_list|,
argument|Spoint_marker
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Return value of point, as a marker object."
argument_list|)
end_macro

begin_expr_stmt
operator|(
operator|)
block|{
return|return
name|buildmark
argument_list|(
name|point
argument_list|)
return|;
block|}
end_expr_stmt

begin_function
name|int
name|in_accessible_range
parameter_list|(
name|loc
parameter_list|)
name|int
name|loc
decl_stmt|;
block|{
if|if
condition|(
name|loc
operator|<
name|BEGV
condition|)
return|return
name|BEGV
return|;
if|if
condition|(
name|loc
operator|>
name|ZV
condition|)
return|return
name|ZV
return|;
return|return
name|loc
return|;
block|}
end_function

begin_expr_stmt
name|DEFUN
argument_list|(
literal|"goto-char"
argument_list|,
name|Fgoto_char
argument_list|,
name|Sgoto_char
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|"NGoto char: "
argument_list|,
literal|"One arg, a number.  Set point to that number.\n\ Beginning of buffer is position (point-min), end is (point-max)."
argument_list|)
argument_list|(
name|n
argument_list|)
specifier|register
name|Lisp_Object
name|n
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|charno
decl_stmt|;
name|CHECK_NUMBER_COERCE_MARKER
argument_list|(
name|n
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|charno
operator|=
name|XINT
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|SET_PT
argument_list|(
name|in_accessible_range
argument_list|(
name|charno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|n
return|;
block|}
end_block

begin_function
specifier|static
name|Lisp_Object
name|region_limit
parameter_list|(
name|beginningp
parameter_list|)
name|int
name|beginningp
decl_stmt|;
block|{
specifier|register
name|Lisp_Object
name|m
decl_stmt|;
name|m
operator|=
name|Fmarker_position
argument_list|(
name|current_buffer
operator|->
name|mark
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|m
argument_list|)
condition|)
name|error
argument_list|(
literal|"There is no region now"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|point
operator|<
name|XFASTINT
argument_list|(
name|m
argument_list|)
operator|)
operator|==
name|beginningp
condition|)
return|return
operator|(
name|make_number
argument_list|(
name|point
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
name|m
operator|)
return|;
block|}
end_function

begin_macro
name|DEFUN
argument_list|(
literal|"region-beginning"
argument_list|,
argument|Fregion_beginning
argument_list|,
argument|Sregion_beginning
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Return position of beginning of region, as an integer."
argument_list|)
end_macro

begin_expr_stmt
operator|(
operator|)
block|{
return|return
operator|(
name|region_limit
argument_list|(
literal|1
argument_list|)
operator|)
return|;
block|}
end_expr_stmt

begin_macro
name|DEFUN
argument_list|(
literal|"region-end"
argument_list|,
argument|Fregion_end
argument_list|,
argument|Sregion_end
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Return position of end of region, as an integer."
argument_list|)
end_macro

begin_expr_stmt
operator|(
operator|)
block|{
return|return
operator|(
name|region_limit
argument_list|(
literal|0
argument_list|)
operator|)
return|;
block|}
end_expr_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* now in lisp code */
end_comment

begin_endif
unit|DEFUN ("mark", Fmark, Smark, 0, 0, 0,   "Return this buffer's mark value as integer, or nil if no mark.\n\ If you are using this in an editing command, you are most likely making\n\ a mistake; see the documentation of `set-mark'.")   () {   return Fmarker_position (current_buffer->mark); }
endif|#
directive|endif
end_endif

begin_comment
comment|/* commented out code */
end_comment

begin_macro
name|DEFUN
argument_list|(
literal|"mark-marker"
argument_list|,
argument|Fmark_marker
argument_list|,
argument|Smark_marker
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Return this buffer's mark, as a marker object.\n\ Watch out!  Moving this marker changes the mark position.\n\ The marker will not point anywhere if mark is not set."
argument_list|)
end_macro

begin_expr_stmt
operator|(
operator|)
block|{
return|return
name|current_buffer
operator|->
name|mark
return|;
block|}
end_expr_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* this is now in lisp code */
end_comment

begin_endif
unit|DEFUN ("set-mark", Fset_mark, Sset_mark, 1, 1, 0,   "Set this buffer's mark to POS.  Don't use this function!\n\ That is to say, don't use this function unless you want\n\ the user to see that the mark has moved, and you want the previous\n\ mark position to be lost.\n\ \n\ Normally, when a new mark is set, the old one should go on the stack.\n\ This is why most applications should use push-mark, not set-mark.\n\ \n\ Novice programmers often try to use the mark for the wrong purposes.\n\ The mark saves a location for the user's convenience.\n\ Most editing commands should not alter the mark.\n\ To remember a location for internal use in the Lisp program,\n\ store it in a Lisp variable.  Example:\n\ \n\    (let ((beg (point))) (forward-line 1) (delete-region beg (point))).")   (pos)      Lisp_Object pos; {   if (NULL (pos))     {       current_buffer->mark = Qnil;       return Qnil;     }   CHECK_NUMBER_COERCE_MARKER (pos, 0);    if (NULL (current_buffer->mark))     current_buffer->mark = Fmake_marker ();    Fset_marker (current_buffer->mark, pos, Qnil);   return pos; }
endif|#
directive|endif
end_endif

begin_comment
comment|/* commented-out code */
end_comment

begin_function
name|Lisp_Object
name|save_excursion_save
parameter_list|()
block|{
specifier|register
name|int
name|visible
init|=
name|XBUFFER
argument_list|(
name|XWINDOW
argument_list|(
name|selected_window
argument_list|)
operator|->
name|buffer
argument_list|)
operator|==
name|current_buffer
decl_stmt|;
return|return
name|Fcons
argument_list|(
name|Fpoint_marker
argument_list|()
argument_list|,
name|Fcons
argument_list|(
name|Fcopy_marker
argument_list|(
name|current_buffer
operator|->
name|mark
argument_list|)
argument_list|,
name|visible
condition|?
name|Qt
else|:
name|Qnil
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|Lisp_Object
name|save_excursion_restore
parameter_list|(
name|info
parameter_list|)
specifier|register
name|Lisp_Object
name|info
decl_stmt|;
block|{
specifier|register
name|Lisp_Object
name|tem
decl_stmt|;
name|tem
operator|=
name|Fmarker_buffer
argument_list|(
name|Fcar
argument_list|(
name|info
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If buffer being returned to is now deleted, avoid error */
comment|/* Otherwise could get error here while unwinding to top level      and crash */
comment|/* In that case, Fmarker_buffer returns nil now.  */
if|if
condition|(
name|NULL
argument_list|(
name|tem
argument_list|)
condition|)
return|return
name|Qnil
return|;
name|Fset_buffer
argument_list|(
name|tem
argument_list|)
expr_stmt|;
name|tem
operator|=
name|Fcar
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|Fgoto_char
argument_list|(
name|tem
argument_list|)
expr_stmt|;
name|unchain_marker
argument_list|(
name|tem
argument_list|)
expr_stmt|;
name|tem
operator|=
name|Fcar
argument_list|(
name|Fcdr
argument_list|(
name|info
argument_list|)
argument_list|)
expr_stmt|;
name|Fset_marker
argument_list|(
name|current_buffer
operator|->
name|mark
argument_list|,
name|tem
argument_list|,
name|Fcurrent_buffer
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|XMARKER
argument_list|(
name|tem
argument_list|)
operator|->
name|buffer
condition|)
name|unchain_marker
argument_list|(
name|tem
argument_list|)
expr_stmt|;
name|tem
operator|=
name|Fcdr
argument_list|(
name|Fcdr
argument_list|(
name|info
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|tem
argument_list|)
operator|&&
name|current_buffer
operator|!=
name|XBUFFER
argument_list|(
name|XWINDOW
argument_list|(
name|selected_window
argument_list|)
operator|->
name|buffer
argument_list|)
condition|)
name|Fswitch_to_buffer
argument_list|(
name|Fcurrent_buffer
argument_list|()
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
return|return
name|Qnil
return|;
block|}
end_function

begin_macro
name|DEFUN
argument_list|(
literal|"save-excursion"
argument_list|,
argument|Fsave_excursion
argument_list|,
argument|Ssave_excursion
argument_list|,
literal|0
argument_list|,
argument|UNEVALLED
argument_list|,
literal|0
argument_list|,
literal|"Save point (and mark), execute BODY, then restore point and mark.\n\ Executes BODY just like PROGN.  Point and mark values are restored\n\ even in case of abnormal exit (throw or error)."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|args
operator|)
name|Lisp_Object
name|args
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|Lisp_Object
name|val
decl_stmt|;
name|int
name|count
init|=
name|specpdl_ptr
operator|-
name|specpdl
decl_stmt|;
name|record_unwind_protect
argument_list|(
name|save_excursion_restore
argument_list|,
name|save_excursion_save
argument_list|()
argument_list|)
expr_stmt|;
name|val
operator|=
name|Fprogn
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|unbind_to
argument_list|(
name|count
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_block

begin_escape
end_escape

begin_macro
name|DEFUN
argument_list|(
literal|"buffer-size"
argument_list|,
argument|Fbufsize
argument_list|,
argument|Sbufsize
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Return the number of characters in the current buffer."
argument_list|)
end_macro

begin_expr_stmt
operator|(
operator|)
block|{
name|Lisp_Object
name|temp
block|;
name|XFASTINT
argument_list|(
name|temp
argument_list|)
operator|=
name|Z
operator|-
name|BEG
block|;
return|return
name|temp
return|;
block|}
end_expr_stmt

begin_macro
name|DEFUN
argument_list|(
literal|"point-min"
argument_list|,
argument|Fpoint_min
argument_list|,
argument|Spoint_min
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Return the minimum permissible value of point in the current buffer.\n\ This is 1, unless a clipping restriction is in effect."
argument_list|)
end_macro

begin_expr_stmt
operator|(
operator|)
block|{
name|Lisp_Object
name|temp
block|;
name|XFASTINT
argument_list|(
name|temp
argument_list|)
operator|=
name|BEGV
block|;
return|return
name|temp
return|;
block|}
end_expr_stmt

begin_macro
name|DEFUN
argument_list|(
literal|"point-min-marker"
argument_list|,
argument|Fpoint_min_marker
argument_list|,
argument|Spoint_min_marker
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Return a marker to the beginning of the currently visible part of the buffer.\n\ This is the beginning, unless a clipping restriction is in effect."
argument_list|)
end_macro

begin_expr_stmt
operator|(
operator|)
block|{
return|return
name|buildmark
argument_list|(
name|BEGV
argument_list|)
return|;
block|}
end_expr_stmt

begin_macro
name|DEFUN
argument_list|(
literal|"point-max"
argument_list|,
argument|Fpoint_max
argument_list|,
argument|Spoint_max
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Return the maximum permissible value of point in the current buffer.\n\ This is (1+ (buffer-size)), unless a clipping restriction is in effect,\n\ in which case it is less."
argument_list|)
end_macro

begin_expr_stmt
operator|(
operator|)
block|{
name|Lisp_Object
name|temp
block|;
name|XFASTINT
argument_list|(
name|temp
argument_list|)
operator|=
name|ZV
block|;
return|return
name|temp
return|;
block|}
end_expr_stmt

begin_macro
name|DEFUN
argument_list|(
literal|"point-max-marker"
argument_list|,
argument|Fpoint_max_marker
argument_list|,
argument|Spoint_max_marker
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Return a marker to the end of the currently visible part of the buffer.\n\ This is the actual end, unless a clipping restriction is in effect."
argument_list|)
end_macro

begin_expr_stmt
operator|(
operator|)
block|{
return|return
name|buildmark
argument_list|(
name|ZV
argument_list|)
return|;
block|}
end_expr_stmt

begin_macro
name|DEFUN
argument_list|(
literal|"following-char"
argument_list|,
argument|Ffollchar
argument_list|,
argument|Sfollchar
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Return the character following point, as a number."
argument_list|)
end_macro

begin_expr_stmt
operator|(
operator|)
block|{
name|Lisp_Object
name|temp
block|;
name|XFASTINT
argument_list|(
name|temp
argument_list|)
operator|=
name|FETCH_CHAR
argument_list|(
name|point
argument_list|)
block|;
return|return
name|temp
return|;
block|}
end_expr_stmt

begin_macro
name|DEFUN
argument_list|(
literal|"preceding-char"
argument_list|,
argument|Fprevchar
argument_list|,
argument|Sprevchar
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Return the character preceding point, as a number."
argument_list|)
end_macro

begin_expr_stmt
operator|(
operator|)
block|{
name|Lisp_Object
name|temp
block|;
if|if
condition|(
name|point
operator|<=
name|BEGV
condition|)
name|XFASTINT
argument_list|(
name|temp
argument_list|)
operator|=
literal|0
expr_stmt|;
else|else
name|XFASTINT
argument_list|(
name|temp
argument_list|)
operator|=
name|FETCH_CHAR
argument_list|(
name|point
operator|-
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|temp
return|;
end_return

begin_expr_stmt
unit|}  DEFUN
operator|(
literal|"bobp"
operator|,
name|Fbobp
operator|,
name|Sbobp
operator|,
literal|0
operator|,
literal|0
operator|,
literal|0
operator|,
literal|"Return T if point is at the beginning of the buffer.\n\ If the buffer is narrowed, this means the beginning of the narrowed part."
operator|)
operator|(
operator|)
block|{
if|if
condition|(
name|point
operator|==
name|BEGV
condition|)
return|return
name|Qt
return|;
end_expr_stmt

begin_return
return|return
name|Qnil
return|;
end_return

begin_expr_stmt
unit|}  DEFUN
operator|(
literal|"eobp"
operator|,
name|Feobp
operator|,
name|Seobp
operator|,
literal|0
operator|,
literal|0
operator|,
literal|0
operator|,
literal|"Return T if point is at the end of the buffer.\n\ If the buffer is narrowed, this means the end of the narrowed part."
operator|)
operator|(
operator|)
block|{
if|if
condition|(
name|point
operator|==
name|ZV
condition|)
return|return
name|Qt
return|;
end_expr_stmt

begin_return
return|return
name|Qnil
return|;
end_return

begin_expr_stmt
unit|}  DEFUN
operator|(
literal|"bolp"
operator|,
name|Fbolp
operator|,
name|Sbolp
operator|,
literal|0
operator|,
literal|0
operator|,
literal|0
operator|,
literal|"Return T if point is at the beginning of a line."
operator|)
operator|(
operator|)
block|{
if|if
condition|(
name|point
operator|==
name|BEGV
operator|||
name|FETCH_CHAR
argument_list|(
name|point
operator|-
literal|1
argument_list|)
operator|==
literal|'\n'
condition|)
return|return
name|Qt
return|;
end_expr_stmt

begin_return
return|return
name|Qnil
return|;
end_return

begin_expr_stmt
unit|}  DEFUN
operator|(
literal|"eolp"
operator|,
name|Feolp
operator|,
name|Seolp
operator|,
literal|0
operator|,
literal|0
operator|,
literal|0
operator|,
literal|"Return T if point is at the end of a line.\n\ `End of a line' includes point being at the end of the buffer."
operator|)
operator|(
operator|)
block|{
if|if
condition|(
name|point
operator|==
name|ZV
operator|||
name|FETCH_CHAR
argument_list|(
name|point
argument_list|)
operator|==
literal|'\n'
condition|)
return|return
name|Qt
return|;
end_expr_stmt

begin_return
return|return
name|Qnil
return|;
end_return

begin_expr_stmt
unit|}  DEFUN
operator|(
literal|"char-after"
operator|,
name|Fchar_after
operator|,
name|Schar_after
operator|,
literal|1
operator|,
literal|1
operator|,
literal|0
operator|,
literal|"One arg, POS, a number.  Return the character in the current buffer\n\ at position POS.\n\ If POS is out of range, the value is NIL."
operator|)
operator|(
name|pos
operator|)
name|Lisp_Object
name|pos
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|Lisp_Object
name|val
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
name|CHECK_NUMBER_COERCE_MARKER
argument_list|(
name|pos
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|n
operator|=
name|XINT
argument_list|(
name|pos
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
name|BEGV
operator|||
name|n
operator|>=
name|ZV
condition|)
return|return
name|Qnil
return|;
name|XFASTINT
argument_list|(
name|val
argument_list|)
operator|=
name|FETCH_CHAR
argument_list|(
name|n
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_block

begin_escape
end_escape

begin_macro
name|DEFUN
argument_list|(
literal|"user-login-name"
argument_list|,
argument|Fuser_login_name
argument_list|,
argument|Suser_login_name
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Return the name under which user logged in, as a string.\n\ This is based on the effective uid, not the real uid."
argument_list|)
end_macro

begin_expr_stmt
operator|(
operator|)
block|{
return|return
name|Vuser_name
return|;
block|}
end_expr_stmt

begin_macro
name|DEFUN
argument_list|(
literal|"user-real-login-name"
argument_list|,
argument|Fuser_real_login_name
argument_list|,
argument|Suser_real_login_name
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Return the name of the user's real uid, as a string.\n\ Differs from user-login-name when running under su."
argument_list|)
end_macro

begin_expr_stmt
operator|(
operator|)
block|{
return|return
name|Vuser_real_name
return|;
block|}
end_expr_stmt

begin_macro
name|DEFUN
argument_list|(
literal|"user-uid"
argument_list|,
argument|Fuser_uid
argument_list|,
argument|Suser_uid
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Return the effective uid of Emacs, as an integer."
argument_list|)
end_macro

begin_expr_stmt
operator|(
operator|)
block|{
return|return
name|make_number
argument_list|(
name|geteuid
argument_list|()
argument_list|)
return|;
block|}
end_expr_stmt

begin_macro
name|DEFUN
argument_list|(
literal|"user-real-uid"
argument_list|,
argument|Fuser_real_uid
argument_list|,
argument|Suser_real_uid
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Return the real uid of Emacs, as an integer."
argument_list|)
end_macro

begin_expr_stmt
operator|(
operator|)
block|{
return|return
name|make_number
argument_list|(
name|getuid
argument_list|()
argument_list|)
return|;
block|}
end_expr_stmt

begin_macro
name|DEFUN
argument_list|(
literal|"user-full-name"
argument_list|,
argument|Fuser_full_name
argument_list|,
argument|Suser_full_name
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Return the full name of the user logged in, as a string."
argument_list|)
end_macro

begin_expr_stmt
operator|(
operator|)
block|{
return|return
name|Vuser_full_name
return|;
block|}
end_expr_stmt

begin_macro
name|DEFUN
argument_list|(
literal|"system-name"
argument_list|,
argument|Fsystem_name
argument_list|,
argument|Ssystem_name
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Return the name of the machine you are running on, as a string."
argument_list|)
end_macro

begin_expr_stmt
operator|(
operator|)
block|{
return|return
name|Vsystem_name
return|;
block|}
end_expr_stmt

begin_macro
name|DEFUN
argument_list|(
literal|"current-time-string"
argument_list|,
argument|Fcurrent_time_string
argument_list|,
argument|Scurrent_time_string
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Return the current time, as a human-readable string."
argument_list|)
end_macro

begin_expr_stmt
operator|(
operator|)
block|{
name|long
name|current_time
operator|=
name|time
argument_list|(
literal|0
argument_list|)
block|;
specifier|register
name|char
operator|*
name|tem
operator|=
operator|(
name|char
operator|*
operator|)
name|ctime
argument_list|(
operator|&
name|current_time
argument_list|)
block|;
name|tem
index|[
literal|24
index|]
operator|=
literal|0
block|;
return|return
name|build_string
argument_list|(
name|tem
argument_list|)
return|;
block|}
end_expr_stmt

begin_escape
end_escape

begin_macro
name|insert1
argument_list|(
argument|arg
argument_list|)
end_macro

begin_decl_stmt
name|Lisp_Object
name|arg
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|Finsert
argument_list|(
literal|1
argument_list|,
operator|&
name|arg
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"insert"
argument_list|,
argument|Finsert
argument_list|,
argument|Sinsert
argument_list|,
literal|0
argument_list|,
argument|MANY
argument_list|,
literal|0
argument_list|,
literal|"Any number of args, strings or chars.  Insert them after point, moving point forward."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|nargs
operator|,
name|args
operator|)
name|int
name|nargs
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|Lisp_Object
modifier|*
name|args
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|argnum
decl_stmt|;
specifier|register
name|Lisp_Object
name|tem
decl_stmt|;
name|char
name|str
index|[
literal|1
index|]
decl_stmt|;
for|for
control|(
name|argnum
operator|=
literal|0
init|;
name|argnum
operator|<
name|nargs
condition|;
name|argnum
operator|++
control|)
block|{
name|tem
operator|=
name|args
index|[
name|argnum
index|]
expr_stmt|;
name|retry
label|:
if|if
condition|(
name|XTYPE
argument_list|(
name|tem
argument_list|)
operator|==
name|Lisp_Int
condition|)
block|{
name|str
index|[
literal|0
index|]
operator|=
name|XINT
argument_list|(
name|tem
argument_list|)
expr_stmt|;
name|insert
argument_list|(
name|str
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|XTYPE
argument_list|(
name|tem
argument_list|)
operator|==
name|Lisp_String
condition|)
block|{
name|insert
argument_list|(
name|XSTRING
argument_list|(
name|tem
argument_list|)
operator|->
name|data
argument_list|,
name|XSTRING
argument_list|(
name|tem
argument_list|)
operator|->
name|size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tem
operator|=
name|wrong_type_argument
argument_list|(
name|Qchar_or_string_p
argument_list|,
name|tem
argument_list|)
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
block|}
return|return
name|Qnil
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"insert-before-markers"
argument_list|,
argument|Finsert_before_markers
argument_list|,
argument|Sinsert_before_markers
argument_list|,
literal|0
argument_list|,
argument|MANY
argument_list|,
literal|0
argument_list|,
literal|"Any number of args, strings or chars.  Insert them after point,\n\ moving point forward.  Also, any markers pointing at the insertion point\n\ get relocated to point after the newly inserted text."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|nargs
operator|,
name|args
operator|)
name|int
name|nargs
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|Lisp_Object
modifier|*
name|args
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|argnum
decl_stmt|;
specifier|register
name|Lisp_Object
name|tem
decl_stmt|;
name|char
name|str
index|[
literal|1
index|]
decl_stmt|;
for|for
control|(
name|argnum
operator|=
literal|0
init|;
name|argnum
operator|<
name|nargs
condition|;
name|argnum
operator|++
control|)
block|{
name|tem
operator|=
name|args
index|[
name|argnum
index|]
expr_stmt|;
name|retry
label|:
if|if
condition|(
name|XTYPE
argument_list|(
name|tem
argument_list|)
operator|==
name|Lisp_Int
condition|)
block|{
name|str
index|[
literal|0
index|]
operator|=
name|XINT
argument_list|(
name|tem
argument_list|)
expr_stmt|;
name|insert_before_markers
argument_list|(
name|str
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|XTYPE
argument_list|(
name|tem
argument_list|)
operator|==
name|Lisp_String
condition|)
block|{
name|insert_before_markers
argument_list|(
name|XSTRING
argument_list|(
name|tem
argument_list|)
operator|->
name|data
argument_list|,
name|XSTRING
argument_list|(
name|tem
argument_list|)
operator|->
name|size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tem
operator|=
name|wrong_type_argument
argument_list|(
name|Qchar_or_string_p
argument_list|,
name|tem
argument_list|)
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
block|}
return|return
name|Qnil
return|;
block|}
end_block

begin_escape
end_escape

begin_macro
name|DEFUN
argument_list|(
literal|"insert-char"
argument_list|,
argument|Finsert_char
argument_list|,
argument|Sinsert_char
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"Insert COUNT (second arg) copies of CHAR (first arg).\n\ Both arguments are required."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|chr
operator|,
name|count
operator|)
name|Lisp_Object
name|chr
operator|,
name|count
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|unsigned
name|char
modifier|*
name|string
decl_stmt|;
specifier|register
name|int
name|strlen
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
name|CHECK_NUMBER
argument_list|(
name|chr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK_NUMBER
argument_list|(
name|count
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|n
operator|=
name|XINT
argument_list|(
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<=
literal|0
condition|)
return|return
name|Qnil
return|;
name|strlen
operator|=
name|max
argument_list|(
name|n
argument_list|,
literal|256
argument_list|)
expr_stmt|;
name|string
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|strlen
condition|;
name|i
operator|++
control|)
name|string
index|[
name|i
index|]
operator|=
name|XFASTINT
argument_list|(
name|chr
argument_list|)
expr_stmt|;
while|while
condition|(
name|n
operator|>=
name|strlen
condition|)
block|{
name|insert
argument_list|(
name|string
argument_list|,
name|strlen
argument_list|)
expr_stmt|;
name|n
operator|-=
name|strlen
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|>
literal|0
condition|)
name|insert
argument_list|(
name|string
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return
name|Qnil
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Return a string with the contents of the current region */
end_comment

begin_macro
name|DEFUN
argument_list|(
literal|"buffer-substring"
argument_list|,
argument|Fbuffer_substring
argument_list|,
argument|Sbuffer_substring
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"Return the contents of part of the current buffer as a string.\n\ The two arguments specify the start and end, as character numbers."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|b
operator|,
name|e
operator|)
name|Lisp_Object
name|b
operator|,
name|e
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|beg
decl_stmt|,
name|end
decl_stmt|;
name|validate_region
argument_list|(
operator|&
name|b
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
name|beg
operator|=
name|XINT
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|end
operator|=
name|XINT
argument_list|(
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|beg
operator|<
name|GPT
operator|&&
name|end
operator|>
name|GPT
condition|)
name|move_gap
argument_list|(
name|beg
argument_list|)
expr_stmt|;
return|return
name|make_string
argument_list|(
operator|&
name|FETCH_CHAR
argument_list|(
name|beg
argument_list|)
argument_list|,
name|end
operator|-
name|beg
argument_list|)
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"buffer-string"
argument_list|,
argument|Fbuffer_string
argument_list|,
argument|Sbuffer_string
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Return the contents of the current buffer as a string."
argument_list|)
end_macro

begin_expr_stmt
operator|(
operator|)
block|{
if|if
condition|(
name|BEGV
operator|<
name|GPT
operator|&&
name|ZV
operator|>
name|GPT
condition|)
name|move_gap
argument_list|(
name|BEGV
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|make_string
argument_list|(
name|BEGV_ADDR
argument_list|,
name|ZV
operator|-
name|BEGV
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  DEFUN
operator|(
literal|"insert-buffer-substring"
operator|,
name|Finsert_buffer_substring
operator|,
name|Sinsert_buffer_substring
operator|,
literal|1
operator|,
literal|3
operator|,
literal|0
operator|,
literal|"Insert before point a substring of the contents buffer BUFFER.\n\ BUFFER may be a buffer or a buffer name.\n\ Arguments START and END are character numbers specifying the substring.\n\ They default to the beginning and the end of BUFFER."
operator|)
operator|(
name|buf
operator|,
name|b
operator|,
name|e
operator|)
name|Lisp_Object
name|buf
operator|,
name|b
operator|,
name|e
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|beg
decl_stmt|,
name|end
decl_stmt|,
name|exch
decl_stmt|;
specifier|register
name|struct
name|buffer
modifier|*
name|bp
decl_stmt|;
name|buf
operator|=
name|Fget_buffer
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|bp
operator|=
name|XBUFFER
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|b
argument_list|)
condition|)
name|beg
operator|=
name|BUF_BEGV
argument_list|(
name|bp
argument_list|)
expr_stmt|;
else|else
block|{
name|CHECK_NUMBER_COERCE_MARKER
argument_list|(
name|b
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|beg
operator|=
name|XINT
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|NULL
argument_list|(
name|e
argument_list|)
condition|)
name|end
operator|=
name|BUF_ZV
argument_list|(
name|bp
argument_list|)
expr_stmt|;
else|else
block|{
name|CHECK_NUMBER_COERCE_MARKER
argument_list|(
name|e
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|end
operator|=
name|XINT
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|beg
operator|>
name|end
condition|)
name|exch
operator|=
name|beg
operator|,
name|beg
operator|=
name|end
operator|,
name|end
operator|=
name|exch
expr_stmt|;
comment|/* Move the gap or create enough gap in the current buffer.  */
if|if
condition|(
name|point
operator|!=
name|GPT
condition|)
name|move_gap
argument_list|(
name|point
argument_list|)
expr_stmt|;
if|if
condition|(
name|GAP_SIZE
operator|<
name|end
operator|-
name|beg
condition|)
name|make_gap
argument_list|(
name|end
operator|-
name|beg
operator|-
name|GAP_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|BUF_BEGV
argument_list|(
name|bp
argument_list|)
operator|<=
name|beg
operator|&&
name|beg
operator|<=
name|end
operator|&&
name|end
operator|<=
name|BUF_ZV
argument_list|(
name|bp
argument_list|)
operator|)
condition|)
name|args_out_of_range
argument_list|(
name|b
argument_list|,
name|e
argument_list|)
expr_stmt|;
comment|/* Now the actual insertion will not do any gap motion,      so it matters not if BUF is the current buffer.  */
if|if
condition|(
name|beg
operator|<
name|BUF_GPT
argument_list|(
name|bp
argument_list|)
condition|)
block|{
name|insert
argument_list|(
name|BUF_CHAR_ADDRESS
argument_list|(
name|bp
argument_list|,
name|beg
argument_list|)
argument_list|,
name|min
argument_list|(
name|end
argument_list|,
name|BUF_GPT
argument_list|(
name|bp
argument_list|)
argument_list|)
operator|-
name|beg
argument_list|)
expr_stmt|;
name|beg
operator|=
name|min
argument_list|(
name|end
argument_list|,
name|BUF_GPT
argument_list|(
name|bp
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|beg
operator|<
name|end
condition|)
name|insert
argument_list|(
name|BUF_CHAR_ADDRESS
argument_list|(
name|bp
argument_list|,
name|beg
argument_list|)
argument_list|,
name|end
operator|-
name|beg
argument_list|)
expr_stmt|;
return|return
name|Qnil
return|;
block|}
end_block

begin_escape
end_escape

begin_macro
name|DEFUN
argument_list|(
literal|"subst-char-in-region"
argument_list|,
argument|Fsubst_char_in_region
argument_list|,
argument|Ssubst_char_in_region
argument_list|,
literal|4
argument_list|,
literal|5
argument_list|,
literal|0
argument_list|,
literal|"From START to END, replace FROMCHAR with TOCHAR each time it occurs.\n\ If optional arg NOUNDO is non-nil, don't record this change for undo\n\ and don't mark the buffer as really changed."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|start
operator|,
name|end
operator|,
name|fromchar
operator|,
name|tochar
operator|,
name|noundo
operator|)
name|Lisp_Object
name|start
operator|,
name|end
operator|,
name|fromchar
operator|,
name|tochar
operator|,
name|noundo
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|pos
decl_stmt|,
name|stop
decl_stmt|,
name|look
decl_stmt|;
name|validate_region
argument_list|(
operator|&
name|start
argument_list|,
operator|&
name|end
argument_list|)
expr_stmt|;
name|CHECK_NUMBER
argument_list|(
name|fromchar
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|CHECK_NUMBER
argument_list|(
name|tochar
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|pos
operator|=
name|XINT
argument_list|(
name|start
argument_list|)
expr_stmt|;
name|stop
operator|=
name|XINT
argument_list|(
name|end
argument_list|)
expr_stmt|;
name|look
operator|=
name|XINT
argument_list|(
name|fromchar
argument_list|)
expr_stmt|;
name|modify_region
argument_list|(
name|pos
argument_list|,
name|stop
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|noundo
argument_list|)
condition|)
block|{
if|if
condition|(
name|MODIFF
operator|-
literal|1
operator|==
name|current_buffer
operator|->
name|save_modified
condition|)
name|current_buffer
operator|->
name|save_modified
operator|++
expr_stmt|;
if|if
condition|(
name|MODIFF
operator|-
literal|1
operator|==
name|current_buffer
operator|->
name|auto_save_modified
condition|)
name|current_buffer
operator|->
name|auto_save_modified
operator|++
expr_stmt|;
block|}
while|while
condition|(
name|pos
operator|<
name|stop
condition|)
block|{
if|if
condition|(
name|FETCH_CHAR
argument_list|(
name|pos
argument_list|)
operator|==
name|look
condition|)
block|{
if|if
condition|(
name|NULL
argument_list|(
name|noundo
argument_list|)
condition|)
name|record_change
argument_list|(
name|pos
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|FETCH_CHAR
argument_list|(
name|pos
argument_list|)
operator|=
name|XINT
argument_list|(
name|tochar
argument_list|)
expr_stmt|;
block|}
name|pos
operator|++
expr_stmt|;
block|}
return|return
name|Qnil
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"delete-region"
argument_list|,
argument|Fdelete_region
argument_list|,
argument|Sdelete_region
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|"r"
argument_list|,
literal|"Delete the text between point and mark.\n\ When called from a program, expects two arguments,\n\ character numbers specifying the stretch to be deleted."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|b
operator|,
name|e
operator|)
name|Lisp_Object
name|b
operator|,
name|e
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|validate_region
argument_list|(
operator|&
name|b
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
name|del_range
argument_list|(
name|XINT
argument_list|(
name|b
argument_list|)
argument_list|,
name|XINT
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|Qnil
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"widen"
argument_list|,
argument|Fwiden
argument_list|,
argument|Swiden
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|,
literal|"Remove restrictions from current buffer, allowing full text to be seen and edited."
argument_list|)
end_macro

begin_expr_stmt
operator|(
operator|)
block|{
name|BEGV
operator|=
name|BEG
block|;
name|SET_BUF_ZV
argument_list|(
name|current_buffer
argument_list|,
name|Z
argument_list|)
block|;
name|clip_changed
operator|=
literal|1
block|;
return|return
name|Qnil
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|DEFUN
argument_list|(
literal|"narrow-to-region"
argument_list|,
name|Fnarrow_to_region
argument_list|,
name|Snarrow_to_region
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|"r"
argument_list|,
literal|"Restrict editing in this buffer to the current region.\n\ The rest of the text becomes temporarily invisible and untouchable\n\ but is not deleted; if you save the buffer in a file, the invisible\n\ text is included in the file.  \\[widen] makes all visible again.\n\ \n\ When calling from a program, pass two arguments; character numbers\n\ bounding the text that should remain visible."
argument_list|)
argument_list|(
name|b
argument_list|,
name|e
argument_list|)
specifier|register
name|Lisp_Object
name|b
operator|,
name|e
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|CHECK_NUMBER_COERCE_MARKER
argument_list|(
name|b
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK_NUMBER_COERCE_MARKER
argument_list|(
name|e
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|XINT
argument_list|(
name|b
argument_list|)
operator|>
name|XINT
argument_list|(
name|e
argument_list|)
condition|)
block|{
name|i
operator|=
name|XFASTINT
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|b
operator|=
name|e
expr_stmt|;
name|XFASTINT
argument_list|(
name|e
argument_list|)
operator|=
name|i
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|BEG
operator|<=
name|XINT
argument_list|(
name|b
argument_list|)
operator|&&
name|XINT
argument_list|(
name|b
argument_list|)
operator|<=
name|XINT
argument_list|(
name|e
argument_list|)
operator|&&
name|XINT
argument_list|(
name|e
argument_list|)
operator|<=
name|Z
operator|)
condition|)
name|args_out_of_range
argument_list|(
name|b
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|BEGV
operator|=
name|XFASTINT
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|SET_BUF_ZV
argument_list|(
name|current_buffer
argument_list|,
name|XFASTINT
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|point
operator|<
name|XFASTINT
argument_list|(
name|b
argument_list|)
condition|)
name|SET_PT
argument_list|(
name|XFASTINT
argument_list|(
name|b
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|point
operator|>
name|XFASTINT
argument_list|(
name|e
argument_list|)
condition|)
name|SET_PT
argument_list|(
name|XFASTINT
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
name|clip_changed
operator|=
literal|1
expr_stmt|;
return|return
name|Qnil
return|;
block|}
end_block

begin_function
name|Lisp_Object
name|save_restriction_save
parameter_list|()
block|{
specifier|register
name|Lisp_Object
name|bottom
decl_stmt|,
name|top
decl_stmt|;
comment|/* Note: I tried using markers here, but it does not win      because insertion at the end of the saved region      does not advance top and is considered "outside" the saved region. */
name|XFASTINT
argument_list|(
name|bottom
argument_list|)
operator|=
name|BEGV
operator|-
name|BEG
expr_stmt|;
name|XFASTINT
argument_list|(
name|top
argument_list|)
operator|=
name|Z
operator|-
name|ZV
expr_stmt|;
return|return
name|Fcons
argument_list|(
name|Fcurrent_buffer
argument_list|()
argument_list|,
name|Fcons
argument_list|(
name|bottom
argument_list|,
name|top
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|Lisp_Object
name|save_restriction_restore
parameter_list|(
name|data
parameter_list|)
name|Lisp_Object
name|data
decl_stmt|;
block|{
specifier|register
name|struct
name|buffer
modifier|*
name|buf
decl_stmt|;
specifier|register
name|int
name|newhead
decl_stmt|,
name|newtail
decl_stmt|;
specifier|register
name|Lisp_Object
name|tem
decl_stmt|;
name|buf
operator|=
name|XBUFFER
argument_list|(
name|XCONS
argument_list|(
name|data
argument_list|)
operator|->
name|car
argument_list|)
expr_stmt|;
name|data
operator|=
name|XCONS
argument_list|(
name|data
argument_list|)
operator|->
name|cdr
expr_stmt|;
name|tem
operator|=
name|XCONS
argument_list|(
name|data
argument_list|)
operator|->
name|car
expr_stmt|;
name|newhead
operator|=
name|XINT
argument_list|(
name|tem
argument_list|)
expr_stmt|;
name|tem
operator|=
name|XCONS
argument_list|(
name|data
argument_list|)
operator|->
name|cdr
expr_stmt|;
name|newtail
operator|=
name|XINT
argument_list|(
name|tem
argument_list|)
expr_stmt|;
if|if
condition|(
name|newhead
operator|+
name|newtail
operator|>
name|BUF_Z
argument_list|(
name|buf
argument_list|)
operator|-
name|BUF_BEG
argument_list|(
name|buf
argument_list|)
condition|)
block|{
name|newhead
operator|=
literal|0
expr_stmt|;
name|newtail
operator|=
literal|0
expr_stmt|;
block|}
name|BUF_BEGV
argument_list|(
name|buf
argument_list|)
operator|=
name|BUF_BEG
argument_list|(
name|buf
argument_list|)
operator|+
name|newhead
expr_stmt|;
name|SET_BUF_ZV
argument_list|(
name|buf
argument_list|,
name|BUF_Z
argument_list|(
name|buf
argument_list|)
operator|-
name|newtail
argument_list|)
expr_stmt|;
name|clip_changed
operator|=
literal|1
expr_stmt|;
comment|/* If point is outside the new visible range, move it inside. */
name|SET_BUF_PT
argument_list|(
name|buf
argument_list|,
name|in_accessible_range
argument_list|(
name|BUF_PT
argument_list|(
name|buf
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|Qnil
return|;
block|}
end_function

begin_macro
name|DEFUN
argument_list|(
literal|"save-restriction"
argument_list|,
argument|Fsave_restriction
argument_list|,
argument|Ssave_restriction
argument_list|,
literal|0
argument_list|,
argument|UNEVALLED
argument_list|,
literal|0
argument_list|,
literal|"Execute the body, undoing at the end any changes to current buffer's restrictions.\n\ Changes to restrictions are made by narrow-to-region or by widen.\n\ Thus, the restrictions are the same after this function as they were before it.\n\ The value returned is that returned by the last form in the body.\n\ \n\ This function can be confused if, within the body, you widen\n\ and then make changes outside the area within the saved restrictions.\n\ \n\ Note: if you are using both save-excursion and save-restriction,\n\ use save-excursion outermost."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|body
operator|)
name|Lisp_Object
name|body
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|Lisp_Object
name|val
decl_stmt|;
name|int
name|count
init|=
name|specpdl_ptr
operator|-
name|specpdl
decl_stmt|;
name|record_unwind_protect
argument_list|(
name|save_restriction_restore
argument_list|,
name|save_restriction_save
argument_list|()
argument_list|)
expr_stmt|;
name|val
operator|=
name|Fprogn
argument_list|(
name|body
argument_list|)
expr_stmt|;
name|unbind_to
argument_list|(
name|count
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_block

begin_escape
end_escape

begin_macro
name|DEFUN
argument_list|(
literal|"message"
argument_list|,
argument|Fmessage
argument_list|,
argument|Smessage
argument_list|,
literal|1
argument_list|,
argument|MANY
argument_list|,
literal|0
argument_list|,
literal|"Print a one-line message at the bottom of the screen.\n\ The first argument is a control string.\n\ It may contain %s or %d or %c to print successive following arguments.\n\ %s means print an argument as a string, %d means print as number in decimal,\n\ %c means print a number as a single character.\n\ The argument used by %s must be a string or a symbol;\n\ the argument used by %d or %c must be a number."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|nargs
operator|,
name|args
operator|)
name|int
name|nargs
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|Lisp_Object
modifier|*
name|args
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|Lisp_Object
name|val
decl_stmt|;
name|val
operator|=
name|Fformat
argument_list|(
name|nargs
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|message
argument_list|(
literal|"%s"
argument_list|,
name|XSTRING
argument_list|(
name|val
argument_list|)
operator|->
name|data
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"format"
argument_list|,
argument|Fformat
argument_list|,
argument|Sformat
argument_list|,
literal|1
argument_list|,
argument|MANY
argument_list|,
literal|0
argument_list|,
literal|"Format a string out of a control-string and arguments.\n\ The first argument is a control string.\n\ It, and subsequent arguments substituted into it, become the value, which is a string.\n\ It may contain %s or %d or %c to substitute successive following arguments.\n\ %s means print an argument as a string, %d means print as number in decimal,\n\ %c means print a number as a single character.\n\ The argument used by %s must be a string or a symbol;\n\ the argument used by %d, %b, %o, %x or %c must be a number."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|nargs
operator|,
name|args
operator|)
name|int
name|nargs
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|Lisp_Object
modifier|*
name|args
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|n
decl_stmt|;
specifier|register
name|int
name|total
init|=
literal|5
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|format
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
modifier|*
name|strings
decl_stmt|;
specifier|extern
name|char
modifier|*
name|index
parameter_list|()
function_decl|;
comment|/* It should not be necessary to GCPRO ARGS, because      the caller in the interpreter should take care of that.  */
name|CHECK_STRING
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|format
operator|=
name|XSTRING
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|)
operator|->
name|data
expr_stmt|;
comment|/* We have to do so much work in order to prepare to call doprnt      that we might as well do all of it ourself...  (Which would also      circumvent C asciz cretinism by allowing ascii 000 chars to appear)    */
name|n
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|format
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|index
argument_list|(
name|format
argument_list|,
literal|'%'
argument_list|)
condition|)
block|{
name|format
operator|++
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|format
operator|>=
literal|'0'
operator|&&
operator|*
name|format
operator|<=
literal|'9'
operator|)
operator|||
operator|*
name|format
operator|==
literal|'-'
operator|||
operator|*
name|format
operator|==
literal|' '
condition|)
name|format
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|format
operator|==
literal|'%'
condition|)
name|format
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|++
name|n
operator|>=
name|nargs
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|XTYPE
argument_list|(
name|args
index|[
name|n
index|]
argument_list|)
operator|==
name|Lisp_Symbol
condition|)
block|{
name|XSET
argument_list|(
name|args
index|[
name|n
index|]
argument_list|,
name|Lisp_String
argument_list|,
name|XSYMBOL
argument_list|(
name|args
index|[
name|n
index|]
argument_list|)
operator|->
name|name
argument_list|)
expr_stmt|;
goto|goto
name|string
goto|;
block|}
elseif|else
if|if
condition|(
name|XTYPE
argument_list|(
name|args
index|[
name|n
index|]
argument_list|)
operator|==
name|Lisp_String
condition|)
block|{
name|string
label|:
name|total
operator|+=
name|XSTRING
argument_list|(
name|args
index|[
name|n
index|]
argument_list|)
operator|->
name|size
expr_stmt|;
block|}
comment|/* would get MPV otherwise, since Lisp_Int's `point' to low memory */
elseif|else
if|if
condition|(
name|XTYPE
argument_list|(
name|args
index|[
name|n
index|]
argument_list|)
operator|==
name|Lisp_Int
operator|&&
operator|*
name|format
operator|!=
literal|'s'
condition|)
name|total
operator|+=
literal|10
expr_stmt|;
else|else
block|{
specifier|register
name|Lisp_Object
name|tem
decl_stmt|;
name|tem
operator|=
name|Fprin1_to_string
argument_list|(
name|args
index|[
name|n
index|]
argument_list|)
expr_stmt|;
name|args
index|[
name|n
index|]
operator|=
name|tem
expr_stmt|;
goto|goto
name|string
goto|;
block|}
block|}
name|strings
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|*
operator|)
name|alloca
argument_list|(
operator|(
name|n
operator|+
literal|1
operator|)
operator|*
expr|sizeof
operator|(
name|unsigned
name|char
operator|*
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|n
operator|>=
literal|0
condition|;
name|n
operator|--
control|)
block|{
if|if
condition|(
name|n
operator|>=
name|nargs
condition|)
name|strings
index|[
name|n
index|]
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
literal|""
expr_stmt|;
elseif|else
if|if
condition|(
name|XTYPE
argument_list|(
name|args
index|[
name|n
index|]
argument_list|)
operator|==
name|Lisp_Int
condition|)
comment|/* We checked above that the correspondiong format effector 	   isn't %s, which would cause MPV */
name|strings
index|[
name|n
index|]
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|XINT
argument_list|(
name|args
index|[
name|n
index|]
argument_list|)
expr_stmt|;
else|else
name|strings
index|[
name|n
index|]
operator|=
name|XSTRING
argument_list|(
name|args
index|[
name|n
index|]
argument_list|)
operator|->
name|data
expr_stmt|;
block|}
comment|/* Format it in bigger and bigger buf's until it all fits. */
while|while
condition|(
literal|1
condition|)
block|{
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|total
operator|+
literal|1
argument_list|)
expr_stmt|;
name|buf
index|[
name|total
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|doprnt
argument_list|(
name|buf
argument_list|,
name|total
operator|+
literal|1
argument_list|,
name|strings
index|[
literal|0
index|]
argument_list|,
name|nargs
argument_list|,
name|strings
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
index|[
name|total
operator|-
literal|1
index|]
operator|==
literal|0
condition|)
break|break;
name|total
operator|*=
literal|2
expr_stmt|;
block|}
comment|/*   UNGCPRO;  */
return|return
name|build_string
argument_list|(
name|buf
argument_list|)
return|;
block|}
end_block

begin_comment
comment|/* VARARGS 1 */
end_comment

begin_function
name|Lisp_Object
ifdef|#
directive|ifdef
name|NO_ARG_ARRAY
name|format1
parameter_list|(
name|string1
parameter_list|,
name|arg0
parameter_list|,
name|arg1
parameter_list|,
name|arg2
parameter_list|,
name|arg3
parameter_list|,
name|arg4
parameter_list|)
name|int
name|arg0
decl_stmt|,
name|arg1
decl_stmt|,
name|arg2
decl_stmt|,
name|arg3
decl_stmt|,
name|arg4
decl_stmt|;
else|#
directive|else
function|format1
parameter_list|(
name|string1
parameter_list|)
endif|#
directive|endif
name|char
modifier|*
name|string1
decl_stmt|;
block|{
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|NO_ARG_ARRAY
name|int
name|args
index|[
literal|5
index|]
decl_stmt|;
name|args
index|[
literal|0
index|]
operator|=
name|arg0
expr_stmt|;
name|args
index|[
literal|1
index|]
operator|=
name|arg1
expr_stmt|;
name|args
index|[
literal|2
index|]
operator|=
name|arg2
expr_stmt|;
name|args
index|[
literal|3
index|]
operator|=
name|arg3
expr_stmt|;
name|args
index|[
literal|4
index|]
operator|=
name|arg4
expr_stmt|;
name|doprnt
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|string1
argument_list|,
literal|5
argument_list|,
name|args
argument_list|)
expr_stmt|;
else|#
directive|else
name|doprnt
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|string1
argument_list|,
literal|5
argument_list|,
operator|&
name|string1
operator|+
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|build_string
argument_list|(
name|buf
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_expr_stmt
name|DEFUN
argument_list|(
literal|"char-equal"
argument_list|,
name|Fchar_equal
argument_list|,
name|Schar_equal
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"T if args (both characters (numbers)) match.  May ignore case.\n\ Case is ignored if the current buffer specifies to do so."
argument_list|)
argument_list|(
name|c1
argument_list|,
name|c2
argument_list|)
specifier|register
name|Lisp_Object
name|c1
operator|,
name|c2
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|CHECK_NUMBER
argument_list|(
name|c1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK_NUMBER
argument_list|(
name|c2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|current_buffer
operator|->
name|case_fold_search
argument_list|)
condition|?
name|downcase_table
index|[
literal|0xff
operator|&
name|XFASTINT
argument_list|(
name|c1
argument_list|)
index|]
operator|==
name|downcase_table
index|[
literal|0xff
operator|&
name|XFASTINT
argument_list|(
name|c2
argument_list|)
index|]
else|:
name|XINT
argument_list|(
name|c1
argument_list|)
operator|==
name|XINT
argument_list|(
name|c2
argument_list|)
condition|)
return|return
name|Qt
return|;
return|return
name|Qnil
return|;
block|}
end_block

begin_ifndef
ifndef|#
directive|ifndef
name|MAINTAIN_ENVIRONMENT
end_ifndef

begin_comment
comment|/* it is done in environ.c in that case */
end_comment

begin_macro
name|DEFUN
argument_list|(
literal|"getenv"
argument_list|,
argument|Fgetenv
argument_list|,
argument|Sgetenv
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"One arg VAR, a string.  Return the value of environment variable VAR, as a string."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|str
operator|)
name|Lisp_Object
name|str
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|val
decl_stmt|;
name|CHECK_STRING
argument_list|(
name|str
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|val
operator|=
operator|(
name|char
operator|*
operator|)
name|egetenv
argument_list|(
name|XSTRING
argument_list|(
name|str
argument_list|)
operator|->
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|val
condition|)
return|return
name|Qnil
return|;
return|return
name|build_string
argument_list|(
name|val
argument_list|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
endif|MAINTAIN_ENVIRONMENT
end_endif

begin_escape
end_escape

begin_function
name|void
name|syms_of_editfns
parameter_list|()
block|{
name|staticpro
argument_list|(
operator|&
name|Vsystem_name
argument_list|)
expr_stmt|;
name|staticpro
argument_list|(
operator|&
name|Vuser_name
argument_list|)
expr_stmt|;
name|staticpro
argument_list|(
operator|&
name|Vuser_full_name
argument_list|)
expr_stmt|;
name|staticpro
argument_list|(
operator|&
name|Vuser_real_name
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Schar_equal
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sgoto_char
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sstring_to_char
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Schar_to_string
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sbuffer_substring
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sbuffer_string
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Spoint_marker
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Smark_marker
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Spoint
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sregion_beginning
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sregion_end
argument_list|)
expr_stmt|;
comment|/*  defsubr (&Smark); */
comment|/*  defsubr (&Sset_mark); */
name|defsubr
argument_list|(
operator|&
name|Ssave_excursion
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sbufsize
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Spoint_max
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Spoint_min
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Spoint_min_marker
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Spoint_max_marker
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sbobp
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Seobp
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sbolp
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Seolp
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sfollchar
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sprevchar
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Schar_after
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sinsert
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sinsert_before_markers
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sinsert_char
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Suser_login_name
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Suser_real_login_name
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Suser_uid
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Suser_real_uid
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Suser_full_name
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Scurrent_time_string
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Ssystem_name
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Smessage
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sformat
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|MAINTAIN_ENVIRONMENT
comment|/* in environ.c */
name|defsubr
argument_list|(
operator|&
name|Sgetenv
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|defsubr
argument_list|(
operator|&
name|Sinsert_buffer_substring
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Ssubst_char_in_region
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sdelete_region
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Swiden
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Snarrow_to_region
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Ssave_restriction
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

