begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Keyboard input; editor command loop.    Copyright (C) 1985, 1986, 1987, 1988, 1990 Free Software Foundation, Inc.  This file is part of GNU Emacs.  GNU Emacs is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version.  GNU Emacs is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU Emacs; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/*** For version 19, can simplify this by making interrupt_input 1 on VMS.  */
end_comment

begin_comment
comment|/* Allow config.h to undefine symbols found here.  */
end_comment

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_undef
undef|#
directive|undef
name|NULL
end_undef

begin_include
include|#
directive|include
file|"termchar.h"
end_include

begin_include
include|#
directive|include
file|"termopts.h"
end_include

begin_include
include|#
directive|include
file|"termhooks.h"
end_include

begin_include
include|#
directive|include
file|"lisp.h"
end_include

begin_include
include|#
directive|include
file|"macros.h"
end_include

begin_include
include|#
directive|include
file|"window.h"
end_include

begin_include
include|#
directive|include
file|"commands.h"
end_include

begin_include
include|#
directive|include
file|"buffer.h"
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Get FIONREAD, if it is available.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|USG
end_ifdef

begin_include
include|#
directive|include
file|<termio.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* not USG */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|VMS
end_ifndef

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not VMS */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not USG */
end_comment

begin_comment
comment|/* Allow m- file to inhibit use of FIONREAD.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|BROKEN_FIONREAD
end_ifdef

begin_undef
undef|#
directive|undef
name|FIONREAD
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Make all keyboard buffers much bigger when using X windows.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_X_WINDOWS
end_ifdef

begin_define
define|#
directive|define
name|BUFFER_SIZE_FACTOR
value|16
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|BUFFER_SIZE_FACTOR
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Following definition copied from eval.c */
end_comment

begin_struct
struct|struct
name|backtrace
block|{
name|struct
name|backtrace
modifier|*
name|next
decl_stmt|;
name|Lisp_Object
modifier|*
name|function
decl_stmt|;
name|Lisp_Object
modifier|*
name|args
decl_stmt|;
comment|/* Points to vector of args. */
name|int
name|nargs
decl_stmt|;
comment|/* length of vector */
comment|/* if nargs is UNEVALLED, args points to slot holding list of unevalled args */
name|char
name|evalargs
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Non-nil disable property on a command means  do not execute it; call disabled-command-hook's value instead. */
end_comment

begin_decl_stmt
name|Lisp_Object
name|Qdisabled
decl_stmt|,
name|Vdisabled_command_hook
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|recent_keys_index
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Index for storing next element into recent_keys */
end_comment

begin_decl_stmt
name|int
name|total_keys
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Total number of elements stored into recent_keys */
end_comment

begin_decl_stmt
name|char
name|recent_keys
index|[
literal|100
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Holds last 100 keystrokes */
end_comment

begin_comment
comment|/* Buffer holding the key that invoked the current command.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|this_command_keys
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|this_command_key_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Size in use.  */
end_comment

begin_decl_stmt
name|int
name|this_command_keys_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Size allocated.  */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|backtrace
modifier|*
name|backtrace_list
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|jmp_buf
name|getcjmp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* for longjmp to where kbd input is being done. */
end_comment

begin_decl_stmt
name|int
name|waiting_for_input
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* True while doing kbd input */
end_comment

begin_comment
comment|/* True while displaying for echoing.   Delays C-g throwing. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|echoing
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|immediate_quit
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means C-G should cause immediate error-signal. */
end_comment

begin_decl_stmt
name|int
name|help_char
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Character to recognize as the help char.  */
end_comment

begin_decl_stmt
name|Lisp_Object
name|Vhelp_form
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Form to execute when help char is typed.  */
end_comment

begin_comment
comment|/* Character that causes a quit.  Normally C-g.  */
end_comment

begin_decl_stmt
name|int
name|quit_char
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|Lisp_Object
name|global_map
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current depth in recursive edits.  */
end_comment

begin_decl_stmt
name|int
name|command_loop_level
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Last input character read as a command.  */
end_comment

begin_decl_stmt
name|int
name|last_command_char
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Last input character read for any purpose.  */
end_comment

begin_decl_stmt
name|int
name|last_input_char
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If not -1, a character to be read as the next command input */
end_comment

begin_decl_stmt
name|int
name|unread_command_char
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Char to use as prefix when a meta character is typed in.  This is bound on entry to minibuffer in case Esc is changed there.  */
end_comment

begin_decl_stmt
name|int
name|meta_prefix_char
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Total number of times read_command_char has returned.  */
end_comment

begin_decl_stmt
name|int
name|num_input_chars
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Auto-save automatically when this many characters have been typed    since the last time.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|auto_save_interval
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Value of num_input_chars as of last auto save.  */
end_comment

begin_decl_stmt
name|int
name|last_auto_save
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Last command executed by the editor command loop, not counting    commands that set the prefix argument.  */
end_comment

begin_decl_stmt
name|Lisp_Object
name|last_command
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The command being executed by the command loop.    Commands may set this, and the value set will be copied into last_command    instead of the actual command.  */
end_comment

begin_decl_stmt
name|Lisp_Object
name|this_command
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Lisp_Object
name|Qself_insert_command
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Lisp_Object
name|Qforward_char
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Lisp_Object
name|Qbackward_char
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* read_key_sequence stores here the command definition of the    key sequence that it reads.  */
end_comment

begin_decl_stmt
name|Lisp_Object
name|read_key_sequence_cmd
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Form to evaluate (if non-nil) when Emacs is started */
end_comment

begin_decl_stmt
name|Lisp_Object
name|Vtop_level
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* User-supplied string to translate input characters through */
end_comment

begin_decl_stmt
name|Lisp_Object
name|Vkeyboard_translate_table
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|dribble
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* File in which we write all commands we read */
end_comment

begin_comment
comment|/* Nonzero if input is available */
end_comment

begin_decl_stmt
name|int
name|input_pending
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if should obey 0200 bit in input chars as "Meta" */
end_comment

begin_decl_stmt
name|int
name|meta_key
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|pending_malloc_warning
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Buffer for pre-read keyboard input */
end_comment

begin_decl_stmt
name|unsigned
name|char
name|kbd_buffer
index|[
literal|256
operator|*
name|BUFFER_SIZE_FACTOR
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of characters available in kbd_buffer.  */
end_comment

begin_decl_stmt
name|int
name|kbd_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointer to next available character in kbd_buffer.  */
end_comment

begin_decl_stmt
name|unsigned
name|char
modifier|*
name|kbd_ptr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Address (if not 0) of word to zero out  if a SIGIO interrupt happens */
end_comment

begin_decl_stmt
name|long
modifier|*
name|input_available_clear_word
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means use SIGIO interrupts; zero means use CBREAK mode.    Default is 1 if INTERRUPT_INPUT is defined.  */
end_comment

begin_decl_stmt
name|int
name|interrupt_input
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero while interrupts are temporarily deferred during redisplay.  */
end_comment

begin_decl_stmt
name|int
name|interrupts_deferred
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* nonzero means use ^S/^Q for flow control.  */
end_comment

begin_decl_stmt
name|int
name|flow_control
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|BSD4_1
end_ifndef

begin_define
define|#
directive|define
name|sigfree
parameter_list|()
value|sigsetmask (0)
end_define

begin_define
define|#
directive|define
name|sigholdx
parameter_list|(
name|sig
parameter_list|)
value|sigsetmask (1<< ((sig) - 1))
end_define

begin_define
define|#
directive|define
name|sigblockx
parameter_list|(
name|sig
parameter_list|)
value|sigblock (1<< ((sig) - 1))
end_define

begin_define
define|#
directive|define
name|sigunblockx
parameter_list|(
name|sig
parameter_list|)
value|sigblock (0)
end_define

begin_define
define|#
directive|define
name|sigpausex
parameter_list|(
name|sig
parameter_list|)
value|sigpause (0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not BSD4_1 */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|BSD4_1
end_ifdef

begin_define
define|#
directive|define
name|SIGIO
value|SIGTINT
end_define

begin_comment
comment|/* sigfree and sigholdx are in sysdep.c */
end_comment

begin_define
define|#
directive|define
name|sigblockx
parameter_list|(
name|sig
parameter_list|)
value|sighold (sig)
end_define

begin_define
define|#
directive|define
name|sigunblockx
parameter_list|(
name|sig
parameter_list|)
value|sigrelse (sig)
end_define

begin_define
define|#
directive|define
name|sigpausex
parameter_list|(
name|sig
parameter_list|)
value|sigpause (sig)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* BSD4_1 */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|sigmask
end_ifndef

begin_define
define|#
directive|define
name|sigmask
parameter_list|(
name|no
parameter_list|)
value|(1L<< ((no) - 1))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* We are unable to use interrupts if FIONREAD is not available,    so flush SIGIO so we won't try. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|FIONREAD
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|SIGIO
end_ifdef

begin_undef
undef|#
directive|undef
name|SIGIO
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* If we support X Windows, and won't get an interrupt when input    arrives from the server, poll periodically so we can detect C-g.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_X_WINDOWS
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|SIGIO
end_ifndef

begin_define
define|#
directive|define
name|POLL_FOR_INPUT
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Function for init_keyboard to call with no args (if nonzero).  */
end_comment

begin_function_decl
name|void
function_decl|(
modifier|*
name|keyboard_init_hook
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|read_avail_input
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|get_input_pending
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Non-zero tells input_available_signal to call read_socket_hook    even if FIONREAD returns zero.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|force_input
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|echo_keystrokes
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*> 0 if we are to echo keystrokes */
end_comment

begin_comment
comment|/* Nonzero means echo each character as typed.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|immediate_echo
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|min
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)<(b)?(a):(b))
end_define

begin_define
define|#
directive|define
name|max
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)>(b)?(a):(b))
end_define

begin_decl_stmt
specifier|static
name|char
name|echobuf
index|[
literal|100
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|echoptr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Install the string STR as the beginning of the string of echoing,    so that it serves as a prompt for the next character.    Also start echoing.  */
end_comment

begin_macro
name|echo_prompt
argument_list|(
argument|str
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|str
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|str
argument_list|)
decl_stmt|;
if|if
condition|(
name|len
operator|>
sizeof|sizeof
name|echobuf
operator|-
literal|4
condition|)
name|len
operator|=
sizeof|sizeof
name|echobuf
operator|-
literal|4
expr_stmt|;
name|bcopy
argument_list|(
name|str
argument_list|,
name|echobuf
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|echoptr
operator|=
name|echobuf
operator|+
name|len
expr_stmt|;
name|echo
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Add the character C to the echo string,    if echoing is going on.  */
end_comment

begin_macro
name|echo_char
argument_list|(
argument|c
argument_list|)
end_macro

begin_decl_stmt
name|int
name|c
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|extern
name|char
modifier|*
name|push_key_description
parameter_list|()
function_decl|;
if|if
condition|(
name|immediate_echo
condition|)
block|{
name|char
modifier|*
name|ptr
init|=
name|echoptr
decl_stmt|;
if|if
condition|(
name|ptr
operator|-
name|echobuf
operator|>
sizeof|sizeof
name|echobuf
operator|-
literal|6
condition|)
return|return;
name|ptr
operator|=
name|push_key_description
argument_list|(
name|c
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
literal|' '
expr_stmt|;
if|if
condition|(
name|echoptr
operator|==
name|echobuf
operator|&&
name|c
operator|==
name|help_char
condition|)
block|{
name|strcpy
argument_list|(
name|ptr
argument_list|,
literal|"(Type ? for further options) "
argument_list|)
expr_stmt|;
name|ptr
operator|+=
name|strlen
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
block|}
operator|*
name|ptr
operator|=
literal|0
expr_stmt|;
name|echoptr
operator|=
name|ptr
expr_stmt|;
name|echo
argument_list|()
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Temporarily add a dash to the end of the echo string,    so that it serves as a mini-prompt for the very next character.  */
end_comment

begin_macro
name|echo_dash
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
operator|!
name|immediate_echo
operator|&&
name|echoptr
operator|==
name|echobuf
condition|)
return|return;
comment|/* Put a dash at the end of the buffer temporarily,      but make it go away when the next character is added.  */
name|echoptr
index|[
literal|0
index|]
operator|=
literal|'-'
expr_stmt|;
name|echoptr
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|echo
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Display the current echo string, and begin echoing if not already    doing so.  */
end_comment

begin_macro
name|echo
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
operator|!
name|immediate_echo
condition|)
block|{
name|int
name|i
decl_stmt|;
name|immediate_echo
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|this_command_key_count
condition|;
name|i
operator|++
control|)
name|echo_char
argument_list|(
name|this_command_keys
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|echo_dash
argument_list|()
expr_stmt|;
block|}
name|echoing
operator|=
literal|1
expr_stmt|;
name|message1
argument_list|(
name|echobuf
argument_list|)
expr_stmt|;
name|echoing
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|waiting_for_input
operator|&&
operator|!
name|NULL
argument_list|(
name|Vquit_flag
argument_list|)
condition|)
name|quit_throw_to_read_command_char
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Turn off echoing, for the start of a new command.  */
end_comment

begin_macro
name|cancel_echoing
argument_list|()
end_macro

begin_block
block|{
name|immediate_echo
operator|=
literal|0
expr_stmt|;
name|echoptr
operator|=
name|echobuf
expr_stmt|;
block|}
end_block

begin_comment
comment|/* When an auto-save happens, record the "time", and don't do again soon.  */
end_comment

begin_macro
name|record_auto_save
argument_list|()
end_macro

begin_block
block|{
name|last_auto_save
operator|=
name|num_input_chars
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_decl_stmt
name|Lisp_Object
name|recursive_edit_unwind
argument_list|()
decl_stmt|,
name|command_loop
argument_list|()
decl_stmt|;
end_decl_stmt

begin_macro
name|DEFUN
argument_list|(
literal|"recursive-edit"
argument_list|,
argument|Frecursive_edit
argument_list|,
argument|Srecursive_edit
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|,
literal|"Invoke the editor command loop recursively.\n\ Do (throw 'exit nil) within the command loop to make this function return,\n\ or (throw 'exit t) to make this function signal an error.\n\ This function is called by the editor initialization\n\ to begin editing."
argument_list|)
end_macro

begin_expr_stmt
operator|(
operator|)
block|{
name|int
name|count
operator|=
name|specpdl_ptr
operator|-
name|specpdl
block|;
name|command_loop_level
operator|++
block|;
name|update_mode_lines
operator|=
literal|1
block|;
name|record_unwind_protect
argument_list|(
name|recursive_edit_unwind
argument_list|,
operator|(
name|current_buffer
operator|!=
name|XBUFFER
argument_list|(
name|XWINDOW
argument_list|(
name|selected_window
argument_list|)
operator|->
name|buffer
argument_list|)
condition|?
name|Fcurrent_buffer
argument_list|()
else|:
name|Qnil
operator|)
argument_list|)
block|;
name|recursive_edit_1
argument_list|()
block|;
name|unbind_to
argument_list|(
name|count
argument_list|)
block|;
return|return
name|Qnil
return|;
block|}
end_expr_stmt

begin_function
name|Lisp_Object
name|recursive_edit_1
parameter_list|()
block|{
name|int
name|count
init|=
name|specpdl_ptr
operator|-
name|specpdl
decl_stmt|;
name|Lisp_Object
name|val
decl_stmt|;
if|if
condition|(
name|command_loop_level
operator|>
literal|0
condition|)
block|{
name|specbind
argument_list|(
name|Qstandard_output
argument_list|,
name|Qt
argument_list|)
expr_stmt|;
name|specbind
argument_list|(
name|Qstandard_input
argument_list|,
name|Qt
argument_list|)
expr_stmt|;
block|}
name|val
operator|=
name|command_loop
argument_list|()
expr_stmt|;
if|if
condition|(
name|EQ
argument_list|(
name|val
argument_list|,
name|Qt
argument_list|)
condition|)
name|Fsignal
argument_list|(
name|Qquit
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
name|unbind_to
argument_list|(
name|count
argument_list|)
expr_stmt|;
return|return
name|Qnil
return|;
block|}
end_function

begin_function
name|Lisp_Object
name|recursive_edit_unwind
parameter_list|(
name|buffer
parameter_list|)
name|Lisp_Object
name|buffer
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|buffer
argument_list|)
condition|)
name|Fset_buffer
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|command_loop_level
operator|--
expr_stmt|;
name|update_mode_lines
operator|=
literal|1
expr_stmt|;
return|return
name|Qnil
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|Lisp_Object
name|cmd_error
parameter_list|(
name|data
parameter_list|)
name|Lisp_Object
name|data
decl_stmt|;
block|{
name|Lisp_Object
name|errmsg
decl_stmt|,
name|tail
decl_stmt|,
name|errname
decl_stmt|,
name|file_error
decl_stmt|;
name|struct
name|gcpro
name|gcpro1
decl_stmt|;
name|int
name|i
decl_stmt|;
name|Vquit_flag
operator|=
name|Qnil
expr_stmt|;
name|Vinhibit_quit
operator|=
name|Qt
expr_stmt|;
name|Vstandard_output
operator|=
name|Qt
expr_stmt|;
name|Vstandard_input
operator|=
name|Qt
expr_stmt|;
name|Vexecuting_macro
operator|=
name|Qnil
expr_stmt|;
name|echo_area_contents
operator|=
literal|0
expr_stmt|;
name|Fdiscard_input
argument_list|()
expr_stmt|;
name|bell
argument_list|()
expr_stmt|;
name|errname
operator|=
name|Fcar
argument_list|(
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|EQ
argument_list|(
name|errname
argument_list|,
name|Qerror
argument_list|)
condition|)
block|{
name|data
operator|=
name|Fcdr
argument_list|(
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CONSP
argument_list|(
name|data
argument_list|)
condition|)
name|data
operator|=
name|Qnil
expr_stmt|;
name|errmsg
operator|=
name|Fcar
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|file_error
operator|=
name|Qnil
expr_stmt|;
block|}
else|else
block|{
name|errmsg
operator|=
name|Fget
argument_list|(
name|errname
argument_list|,
name|Qerror_message
argument_list|)
expr_stmt|;
name|file_error
operator|=
name|Fmemq
argument_list|(
name|Qfile_error
argument_list|,
name|Fget
argument_list|(
name|errname
argument_list|,
name|Qerror_conditions
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Print an error message including the data items.      This is done by printing it into a scratch buffer      and then making a copy of the text in the buffer. */
if|if
condition|(
operator|!
name|CONSP
argument_list|(
name|data
argument_list|)
condition|)
name|data
operator|=
name|Qnil
expr_stmt|;
name|tail
operator|=
name|Fcdr
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|GCPRO1
argument_list|(
name|tail
argument_list|)
expr_stmt|;
comment|/* For file-error, make error message by concatenating      all the data items.  They are all strings.  */
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|file_error
argument_list|)
condition|)
name|errmsg
operator|=
name|XCONS
argument_list|(
name|tail
argument_list|)
operator|->
name|car
operator|,
name|tail
operator|=
name|XCONS
argument_list|(
name|tail
argument_list|)
operator|->
name|cdr
expr_stmt|;
if|if
condition|(
name|XTYPE
argument_list|(
name|errmsg
argument_list|)
operator|==
name|Lisp_String
condition|)
name|Fprinc
argument_list|(
name|errmsg
argument_list|,
name|Qt
argument_list|)
expr_stmt|;
else|else
name|write_string_1
argument_list|(
literal|"peculiar error"
argument_list|,
operator|-
literal|1
argument_list|,
name|Qt
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|CONSP
argument_list|(
name|tail
argument_list|)
condition|;
name|tail
operator|=
name|Fcdr
argument_list|(
name|tail
argument_list|)
operator|,
name|i
operator|++
control|)
block|{
name|write_string_1
argument_list|(
name|i
condition|?
literal|", "
else|:
literal|": "
argument_list|,
literal|2
argument_list|,
name|Qt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|file_error
argument_list|)
condition|)
name|Fprinc
argument_list|(
name|Fcar
argument_list|(
name|tail
argument_list|)
argument_list|,
name|Qt
argument_list|)
expr_stmt|;
else|else
name|Fprin1
argument_list|(
name|Fcar
argument_list|(
name|tail
argument_list|)
argument_list|,
name|Qt
argument_list|)
expr_stmt|;
block|}
name|UNGCPRO
expr_stmt|;
comment|/* In -batch mode, force out the error message and newlines after it      and then die.  */
if|if
condition|(
name|noninteractive
condition|)
block|{
name|message
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|Fkill_emacs
argument_list|(
name|make_number
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|Vquit_flag
operator|=
name|Qnil
expr_stmt|;
name|Vinhibit_quit
operator|=
name|Qnil
expr_stmt|;
return|return
name|make_number
argument_list|(
literal|0
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_function_decl
name|Lisp_Object
name|command_loop_1
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|Lisp_Object
name|command_loop_2
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|Lisp_Object
name|cmd_error
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|Lisp_Object
name|top_level_1
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Entry to editor-command-loop.    This level has the catches for exiting/returning to editor command loop.    It returns nil to exit recursive edit, t to abort it.  */
end_comment

begin_function
name|Lisp_Object
name|command_loop
parameter_list|()
block|{
if|if
condition|(
name|command_loop_level
operator|>
literal|0
operator|||
name|minibuf_level
operator|>
literal|0
condition|)
block|{
return|return
name|internal_catch
argument_list|(
name|Qexit
argument_list|,
name|command_loop_2
argument_list|,
name|Qnil
argument_list|)
return|;
block|}
else|else
while|while
condition|(
literal|1
condition|)
block|{
name|internal_catch
argument_list|(
name|Qtop_level
argument_list|,
name|top_level_1
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
name|internal_catch
argument_list|(
name|Qtop_level
argument_list|,
name|command_loop_2
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
comment|/* End of file in -batch run causes exit here.  */
if|if
condition|(
name|noninteractive
condition|)
name|Fkill_emacs
argument_list|(
name|Qt
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Here we catch errors in execution of commands within the    editing loop, and reenter the editing loop.    When there is an error, cmd_error runs and returns a non-nil    value to us.  A value of nil means that cmd_loop_1 itself    returned due to end of file (or end of kbd macro).  */
end_comment

begin_function
name|Lisp_Object
name|command_loop_2
parameter_list|()
block|{
specifier|register
name|Lisp_Object
name|val
decl_stmt|;
do|do
name|val
operator|=
name|internal_condition_case
argument_list|(
name|command_loop_1
argument_list|,
name|Qerror
argument_list|,
name|cmd_error
argument_list|)
expr_stmt|;
do|while
condition|(
operator|!
name|NULL
argument_list|(
name|val
argument_list|)
condition|)
do|;
return|return
name|Qnil
return|;
block|}
end_function

begin_function
name|Lisp_Object
name|top_level_2
parameter_list|()
block|{
return|return
name|Feval
argument_list|(
name|Vtop_level
argument_list|)
return|;
block|}
end_function

begin_function
name|Lisp_Object
name|top_level_1
parameter_list|()
block|{
comment|/* On entry to the outer level, run the startup file */
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|Vtop_level
argument_list|)
condition|)
name|internal_condition_case
argument_list|(
name|top_level_2
argument_list|,
name|Qerror
argument_list|,
name|cmd_error
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|Vpurify_flag
argument_list|)
condition|)
name|message
argument_list|(
literal|"Bare impure Emacs (standard Lisp code not loaded)"
argument_list|)
expr_stmt|;
else|else
name|message
argument_list|(
literal|"Bare Emacs (standard Lisp code not loaded)"
argument_list|)
expr_stmt|;
return|return
name|Qnil
return|;
block|}
end_function

begin_macro
name|DEFUN
argument_list|(
literal|"top-level"
argument_list|,
argument|Ftop_level
argument_list|,
argument|Stop_level
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|,
literal|"Exit all recursive editing levels."
argument_list|)
end_macro

begin_expr_stmt
operator|(
operator|)
block|{
name|Fthrow
argument_list|(
name|Qtop_level
argument_list|,
name|Qnil
argument_list|)
block|; }
name|DEFUN
argument_list|(
literal|"exit-recursive-edit"
argument_list|,
argument|Fexit_recursive_edit
argument_list|,
argument|Sexit_recursive_edit
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|,
literal|"Exit from the innermost recursive edit or minibuffer."
argument_list|)
operator|(
operator|)
block|{
if|if
condition|(
name|command_loop_level
operator|>
literal|0
operator|||
name|minibuf_level
operator|>
literal|0
condition|)
name|Fthrow
argument_list|(
name|Qexit
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"No recursive edit is in progress"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|}  DEFUN
operator|(
literal|"abort-recursive-edit"
operator|,
name|Fabort_recursive_edit
operator|,
name|Sabort_recursive_edit
operator|,
literal|0
operator|,
literal|0
operator|,
literal|""
operator|,
literal|"Abort the command that requested this recursive edit or minibuffer input."
operator|)
operator|(
operator|)
block|{
if|if
condition|(
name|command_loop_level
operator|>
literal|0
operator|||
name|minibuf_level
operator|>
literal|0
condition|)
name|Fthrow
argument_list|(
name|Qexit
argument_list|,
name|Qt
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"No recursive edit is in progress"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_escape
unit|}
end_escape

begin_comment
comment|/* This is the actual command reading loop,  sans error-handling encapsulation */
end_comment

begin_expr_stmt
unit|Lisp_Object
name|Fcommand_execute
argument_list|()
expr_stmt|;
end_expr_stmt

begin_function
name|Lisp_Object
name|command_loop_1
parameter_list|()
block|{
name|Lisp_Object
name|cmd
decl_stmt|;
name|int
name|lose
decl_stmt|;
name|int
name|nonundocount
decl_stmt|;
name|char
name|keybuf
index|[
literal|30
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|no_redisplay
decl_stmt|;
name|int
name|no_direct
decl_stmt|;
name|Vprefix_arg
operator|=
name|Qnil
expr_stmt|;
name|waiting_for_input
operator|=
literal|0
expr_stmt|;
name|cancel_echoing
argument_list|()
expr_stmt|;
name|last_command
operator|=
name|Qt
expr_stmt|;
name|nonundocount
operator|=
literal|0
expr_stmt|;
name|no_redisplay
operator|=
literal|0
expr_stmt|;
name|this_command_key_count
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
comment|/* Install chars successfully executed in kbd macro */
if|if
condition|(
name|defining_kbd_macro
operator|&&
name|NULL
argument_list|(
name|Vprefix_arg
argument_list|)
condition|)
name|finalize_kbd_macro_chars
argument_list|()
expr_stmt|;
comment|/* Make sure current window's buffer is selected.  */
if|if
condition|(
name|XBUFFER
argument_list|(
name|XWINDOW
argument_list|(
name|selected_window
argument_list|)
operator|->
name|buffer
argument_list|)
operator|!=
name|current_buffer
condition|)
name|set_buffer_internal
argument_list|(
name|XBUFFER
argument_list|(
name|XWINDOW
argument_list|(
name|selected_window
argument_list|)
operator|->
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Display any malloc warning that just came out. 	 Use while because displaying one warning can cause another.  */
while|while
condition|(
name|pending_malloc_warning
condition|)
name|display_malloc_warning
argument_list|()
expr_stmt|;
name|no_direct
operator|=
literal|0
expr_stmt|;
comment|/* If minibuffer on and echo area in use, 	 wait 2 sec and redraw minibufer.  */
if|if
condition|(
name|minibuf_level
operator|&&
name|echo_area_contents
condition|)
block|{
name|int
name|count
init|=
name|specpdl_ptr
operator|-
name|specpdl
decl_stmt|;
name|specbind
argument_list|(
name|Qinhibit_quit
argument_list|,
name|Qt
argument_list|)
expr_stmt|;
name|Fsit_for
argument_list|(
name|make_number
argument_list|(
literal|2
argument_list|)
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
name|unbind_to
argument_list|(
name|count
argument_list|)
expr_stmt|;
name|echo_area_contents
operator|=
literal|0
expr_stmt|;
name|no_direct
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|Vquit_flag
argument_list|)
condition|)
block|{
name|Vquit_flag
operator|=
name|Qnil
expr_stmt|;
name|unread_command_char
operator|=
name|quit_char
expr_stmt|;
block|}
block|}
name|i
operator|=
literal|0
expr_stmt|;
if|#
directive|if
literal|0
comment|/* If prev. command was directly displayed, we don't need 	 redisplay.  Try shortcut for reading single-char key sequence.  */
block|if (no_redisplay) 	i = fast_read_one_key (keybuf);
endif|#
directive|endif
comment|/* 0 */
comment|/* Shortcut not applicable or found a prefix key. 	 Take full precautions and read key sequence the hard way.  */
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|C_ALLOCA
name|alloca
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Cause a garbage collection now */
comment|/* Since we can free the most stuff here.  */
endif|#
directive|endif
comment|/* C_ALLOCA */
comment|/* Read next key sequence; i gets its length.  */
name|i
operator|=
name|read_key_sequence
argument_list|(
name|keybuf
argument_list|,
sizeof|sizeof
name|keybuf
argument_list|,
literal|0
argument_list|,
name|no_redisplay
operator|&&
name|buffer_shared
operator|<=
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Now we have read a key sequence of length I, 	 or else I is 0 and we found end of file.  */
if|if
condition|(
name|i
operator|==
literal|0
condition|)
comment|/* End of file -- happens only in */
return|return
name|Qnil
return|;
comment|/* a kbd macro, at the end */
name|last_command_char
operator|=
name|keybuf
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
name|cmd
operator|=
name|read_key_sequence_cmd
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|Vexecuting_macro
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|Vquit_flag
argument_list|)
condition|)
block|{
name|Vexecuting_macro
operator|=
name|Qt
expr_stmt|;
name|QUIT
expr_stmt|;
comment|/* Make some noise. */
comment|/* Will return since macro now empty. */
block|}
block|}
comment|/* Do redisplay processing after this command except in special 	 cases identified below that set no_redisplay to 1.  */
name|no_redisplay
operator|=
literal|0
expr_stmt|;
comment|/* Execute the command.  */
if|if
condition|(
name|NULL
argument_list|(
name|cmd
argument_list|)
condition|)
block|{
comment|/* nil means key is undefined.  */
name|bell
argument_list|()
expr_stmt|;
name|defining_kbd_macro
operator|=
literal|0
expr_stmt|;
name|update_mode_lines
operator|++
expr_stmt|;
name|Vprefix_arg
operator|=
name|Qnil
expr_stmt|;
block|}
else|else
block|{
name|this_command
operator|=
name|cmd
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|Vprefix_arg
argument_list|)
operator|&&
operator|!
name|no_direct
condition|)
block|{
if|if
condition|(
name|EQ
argument_list|(
name|cmd
argument_list|,
name|Qforward_char
argument_list|)
operator|&&
name|point
operator|<
name|ZV
condition|)
block|{
name|lose
operator|=
name|FETCH_CHAR
argument_list|(
name|point
argument_list|)
expr_stmt|;
name|SET_PT
argument_list|(
name|point
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|lose
operator|>=
literal|' '
operator|&&
name|lose
operator|<
literal|0177
operator|&&
operator|(
name|XFASTINT
argument_list|(
name|XWINDOW
argument_list|(
name|selected_window
argument_list|)
operator|->
name|last_modified
argument_list|)
operator|>=
name|MODIFF
operator|)
operator|&&
operator|(
name|XFASTINT
argument_list|(
name|XWINDOW
argument_list|(
name|selected_window
argument_list|)
operator|->
name|last_point
argument_list|)
operator|==
name|point
operator|)
operator|&&
operator|!
name|windows_or_buffers_changed
operator|&&
name|EQ
argument_list|(
name|current_buffer
operator|->
name|selective_display
argument_list|,
name|Qnil
argument_list|)
operator|&&
operator|!
name|detect_input_pending
argument_list|()
operator|&&
name|NULL
argument_list|(
name|Vexecuting_macro
argument_list|)
condition|)
name|no_redisplay
operator|=
name|direct_output_forward_char
argument_list|(
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|directly_done
goto|;
block|}
elseif|else
if|if
condition|(
name|EQ
argument_list|(
name|cmd
argument_list|,
name|Qbackward_char
argument_list|)
operator|&&
name|point
operator|>
name|BEGV
condition|)
block|{
name|SET_PT
argument_list|(
name|point
operator|-
literal|1
argument_list|)
expr_stmt|;
name|lose
operator|=
name|FETCH_CHAR
argument_list|(
name|point
argument_list|)
expr_stmt|;
if|if
condition|(
name|lose
operator|>=
literal|' '
operator|&&
name|lose
operator|<
literal|0177
operator|&&
operator|(
name|XFASTINT
argument_list|(
name|XWINDOW
argument_list|(
name|selected_window
argument_list|)
operator|->
name|last_modified
argument_list|)
operator|>=
name|MODIFF
operator|)
operator|&&
operator|(
name|XFASTINT
argument_list|(
name|XWINDOW
argument_list|(
name|selected_window
argument_list|)
operator|->
name|last_point
argument_list|)
operator|==
name|point
operator|)
operator|&&
operator|!
name|windows_or_buffers_changed
operator|&&
name|EQ
argument_list|(
name|current_buffer
operator|->
name|selective_display
argument_list|,
name|Qnil
argument_list|)
operator|&&
operator|!
name|detect_input_pending
argument_list|()
operator|&&
name|NULL
argument_list|(
name|Vexecuting_macro
argument_list|)
condition|)
name|no_redisplay
operator|=
name|direct_output_forward_char
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|directly_done
goto|;
block|}
elseif|else
if|if
condition|(
name|EQ
argument_list|(
name|cmd
argument_list|,
name|Qself_insert_command
argument_list|)
condition|)
block|{
if|if
condition|(
name|NULL
argument_list|(
name|Vexecuting_macro
argument_list|)
operator|&&
operator|!
name|EQ
argument_list|(
name|minibuf_window
argument_list|,
name|selected_window
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|nonundocount
operator|||
name|nonundocount
operator|>=
literal|20
condition|)
block|{
name|Fundo_boundary
argument_list|()
expr_stmt|;
name|nonundocount
operator|=
literal|0
expr_stmt|;
block|}
name|nonundocount
operator|++
expr_stmt|;
block|}
name|lose
operator|=
operator|(
name|XFASTINT
argument_list|(
name|XWINDOW
argument_list|(
name|selected_window
argument_list|)
operator|->
name|last_modified
argument_list|)
operator|<
name|MODIFF
operator|)
operator|||
operator|(
name|XFASTINT
argument_list|(
name|XWINDOW
argument_list|(
name|selected_window
argument_list|)
operator|->
name|last_point
argument_list|)
operator|!=
name|point
operator|)
operator|||
name|MODIFF
operator|<=
name|current_buffer
operator|->
name|save_modified
operator|||
name|windows_or_buffers_changed
operator|||
operator|!
name|EQ
argument_list|(
name|current_buffer
operator|->
name|selective_display
argument_list|,
name|Qnil
argument_list|)
operator|||
name|detect_input_pending
argument_list|()
operator|||
operator|!
name|NULL
argument_list|(
name|Vexecuting_macro
argument_list|)
expr_stmt|;
if|if
condition|(
name|self_insert_internal
argument_list|(
name|last_command_char
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|lose
operator|=
literal|1
expr_stmt|;
name|nonundocount
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|lose
operator|&&
operator|(
name|point
operator|==
name|ZV
operator|||
name|FETCH_CHAR
argument_list|(
name|point
argument_list|)
operator|==
literal|'\n'
operator|)
operator|&&
name|last_command_char
operator|>=
literal|' '
operator|&&
name|last_command_char
operator|<
literal|0177
condition|)
name|no_redisplay
operator|=
name|direct_output_for_insert
argument_list|(
name|last_command_char
argument_list|)
expr_stmt|;
goto|goto
name|directly_done
goto|;
block|}
block|}
comment|/* Here for a command that isn't executed directly */
name|nonundocount
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|Vprefix_arg
argument_list|)
condition|)
name|Fundo_boundary
argument_list|()
expr_stmt|;
name|Fcommand_execute
argument_list|(
name|cmd
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
name|directly_done
label|:
empty_stmt|;
block|}
if|if
condition|(
name|NULL
argument_list|(
name|Vprefix_arg
argument_list|)
condition|)
block|{
name|last_command
operator|=
name|this_command
expr_stmt|;
name|this_command_key_count
operator|=
literal|0
expr_stmt|;
name|cancel_echoing
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Input of single characters from keyboard */
end_comment

begin_function_decl
name|Lisp_Object
name|print_help
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|echo_flag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|echo_now
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Alarm interrupt calls this and requests echoing at earliest safe time. */
end_comment

begin_macro
name|request_echo
argument_list|()
end_macro

begin_block
block|{
name|int
name|old_errno
init|=
name|errno
decl_stmt|;
comment|/* Note: no need to reestablish handler on USG systems      because it is established, if approriate, each time an alarm is requested.  */
ifdef|#
directive|ifdef
name|subprocesses
ifdef|#
directive|ifdef
name|BSD4_1
specifier|extern
name|int
name|select_alarmed
decl_stmt|;
if|if
condition|(
name|select_alarmed
operator|==
literal|0
condition|)
block|{
name|select_alarmed
operator|=
literal|1
expr_stmt|;
name|sigrelse
argument_list|(
name|SIGALRM
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
endif|#
directive|endif
ifdef|#
directive|ifdef
name|BSD4_1
name|sigisheld
argument_list|(
name|SIGALRM
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|echo_now
condition|)
name|echo
argument_list|()
expr_stmt|;
else|else
name|echo_flag
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|BSD4_1
name|sigunhold
argument_list|(
name|SIGALRM
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|errno
operator|=
name|old_errno
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Nonzero means polling for input is temporarily suppresed.  */
end_comment

begin_decl_stmt
name|int
name|poll_suppress_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of seconds between polling for input.  */
end_comment

begin_decl_stmt
name|int
name|polling_period
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|POLL_FOR_INPUT
end_ifdef

begin_decl_stmt
name|int
name|polling_for_input
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Handle an alarm once each second and read pending input    so as to handle a C-g if it comces in.  */
end_comment

begin_macro
name|input_poll_signal
argument_list|()
end_macro

begin_block
block|{
name|int
name|junk
decl_stmt|;
if|if
condition|(
operator|!
name|waiting_for_input
condition|)
name|read_avail_input
argument_list|(
operator|&
name|junk
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|input_poll_signal
argument_list|)
expr_stmt|;
name|alarm
argument_list|(
name|polling_period
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Begin signals to poll for input, if they are appropriate.    This function is called unconditionally from various places.  */
end_comment

begin_macro
name|start_polling
argument_list|()
end_macro

begin_block
block|{
ifdef|#
directive|ifdef
name|POLL_FOR_INPUT
if|if
condition|(
name|read_socket_hook
condition|)
block|{
name|poll_suppress_count
operator|--
expr_stmt|;
if|if
condition|(
name|poll_suppress_count
operator|==
literal|0
condition|)
block|{
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|input_poll_signal
argument_list|)
expr_stmt|;
name|polling_for_input
operator|=
literal|1
expr_stmt|;
name|alarm
argument_list|(
name|polling_period
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
end_block

begin_comment
comment|/* Turn off polling.  */
end_comment

begin_macro
name|stop_polling
argument_list|()
end_macro

begin_block
block|{
ifdef|#
directive|ifdef
name|POLL_FOR_INPUT
if|if
condition|(
name|read_socket_hook
condition|)
block|{
if|if
condition|(
name|poll_suppress_count
operator|==
literal|0
condition|)
block|{
name|polling_for_input
operator|=
literal|0
expr_stmt|;
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|poll_suppress_count
operator|++
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_block

begin_comment
comment|/* read a character from the keyboard; call the redisplay if needed */
end_comment

begin_comment
comment|/* commandflag 0 means do not do auto-saving, but do do redisplay.    -1 means do not do redisplay, but do do autosaving.    1 means do both.  */
end_comment

begin_macro
name|read_command_char
argument_list|(
argument|commandflag
argument_list|)
end_macro

begin_decl_stmt
name|int
name|commandflag
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|c
decl_stmt|;
name|int
name|alarmtime
decl_stmt|;
name|int
name|count
decl_stmt|;
name|Lisp_Object
name|tem
decl_stmt|;
name|jmp_buf
name|save_jump
decl_stmt|;
extern|extern request_echo (
block|)
end_block

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_if
if|if
condition|(
name|unread_command_char
operator|>=
literal|0
condition|)
block|{
name|c
operator|=
name|unread_command_char
expr_stmt|;
name|unread_command_char
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|this_command_key_count
operator|==
literal|0
condition|)
goto|goto
name|reread_first
goto|;
goto|goto
name|reread
goto|;
block|}
end_if

begin_if
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|Vexecuting_macro
argument_list|)
condition|)
block|{
if|if
condition|(
name|XTYPE
argument_list|(
name|Vexecuting_macro
argument_list|)
operator|!=
name|Lisp_String
operator|||
name|XSTRING
argument_list|(
name|Vexecuting_macro
argument_list|)
operator|->
name|size
operator|<=
name|executing_macro_index
condition|)
return|return
operator|-
literal|1
return|;
name|QUIT
expr_stmt|;
name|c
operator|=
name|XSTRING
argument_list|(
name|Vexecuting_macro
argument_list|)
operator|->
name|data
index|[
name|executing_macro_index
operator|++
index|]
expr_stmt|;
goto|goto
name|from_macro
goto|;
block|}
end_if

begin_comment
comment|/* Save outer setjmp data, in case called recursively.  */
end_comment

begin_expr_stmt
name|bcopy
argument_list|(
name|getcjmp
argument_list|,
name|save_jump
argument_list|,
sizeof|sizeof
name|getcjmp
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|stop_polling
argument_list|()
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|commandflag
operator|>=
literal|0
operator|&&
operator|!
name|detect_input_pending
argument_list|()
condition|)
name|redisplay
argument_list|()
expr_stmt|;
end_if

begin_if
if|if
condition|(
name|commandflag
operator|!=
literal|0
operator|&&
name|auto_save_interval
operator|>
literal|0
operator|&&
name|num_input_chars
operator|-
name|last_auto_save
operator|>
name|max
argument_list|(
name|auto_save_interval
argument_list|,
literal|20
argument_list|)
operator|&&
operator|!
name|detect_input_pending
argument_list|()
condition|)
name|Fdo_auto_save
argument_list|(
name|Qnil
argument_list|)
expr_stmt|;
end_if

begin_if
if|if
condition|(
name|_setjmp
argument_list|(
name|getcjmp
argument_list|)
condition|)
block|{
name|c
operator|=
name|quit_char
expr_stmt|;
name|waiting_for_input
operator|=
literal|0
expr_stmt|;
name|input_available_clear_word
operator|=
literal|0
expr_stmt|;
goto|goto
name|non_reread
goto|;
block|}
end_if

begin_comment
comment|/* Message turns off echoing unless more keystrokes turn it on again. */
end_comment

begin_if
if|if
condition|(
name|echo_area_contents
operator|&&
operator|*
name|echo_area_contents
operator|&&
name|echo_area_contents
operator|!=
name|echobuf
condition|)
name|cancel_echoing
argument_list|()
expr_stmt|;
else|else
comment|/* If already echoing, continue, and prompt.  */
name|echo_dash
argument_list|()
expr_stmt|;
end_if

begin_comment
comment|/* If in middle of key sequence and minibuffer not active,      start echoing if enough time elapses.  */
end_comment

begin_if
if|if
condition|(
name|minibuf_level
operator|==
literal|0
operator|&&
operator|!
name|immediate_echo
operator|&&
name|this_command_key_count
operator|>
literal|0
operator|&&
name|echo_keystrokes
operator|>
literal|0
operator|&&
operator|(
name|echo_area_contents
operator|==
literal|0
operator|||
operator|*
name|echo_area_contents
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* Else start echoing if user waits more than `alarmtime' seconds. */
comment|/* This interrupt either calls echo right away 	 or sets echo_flag, which causes echo to be called 	 by set_waiting_for_input's next invocation.  */
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|request_echo
argument_list|)
expr_stmt|;
name|echo_flag
operator|=
literal|0
expr_stmt|;
name|echo_now
operator|=
literal|0
expr_stmt|;
name|alarmtime
operator|=
name|echo_keystrokes
expr_stmt|;
name|alarm
argument_list|(
operator|(
name|unsigned
operator|)
name|alarmtime
argument_list|)
expr_stmt|;
block|}
end_if

begin_expr_stmt
name|c
operator|=
name|kbd_buffer_read_command_char
argument_list|()
expr_stmt|;
end_expr_stmt

begin_label
name|non_reread
label|:
end_label

begin_expr_stmt
name|bcopy
argument_list|(
name|save_jump
argument_list|,
name|getcjmp
argument_list|,
sizeof|sizeof
name|getcjmp
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Cancel alarm if it was set and has not already gone off. */
end_comment

begin_if
if|if
condition|(
name|alarmtime
operator|>
literal|0
condition|)
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
end_if

begin_expr_stmt
name|echo_area_contents
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|c
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
end_if

begin_expr_stmt
name|c
operator|&=
name|meta_key
condition|?
literal|0377
else|:
literal|0177
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|XTYPE
argument_list|(
name|Vkeyboard_translate_table
argument_list|)
operator|==
name|Lisp_String
operator|&&
name|XSTRING
argument_list|(
name|Vkeyboard_translate_table
argument_list|)
operator|->
name|size
operator|>
name|c
condition|)
name|c
operator|=
name|XSTRING
argument_list|(
name|Vkeyboard_translate_table
argument_list|)
operator|->
name|data
index|[
name|c
index|]
expr_stmt|;
end_if

begin_expr_stmt
name|total_keys
operator|++
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|recent_keys
index|[
name|recent_keys_index
index|]
operator|=
name|c
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|recent_keys_index
operator|=
operator|(
name|recent_keys_index
operator|+
literal|1
operator|)
operator|%
sizeof|sizeof
name|recent_keys
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|dribble
condition|)
block|{
name|putc
argument_list|(
name|c
argument_list|,
name|dribble
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|dribble
argument_list|)
expr_stmt|;
block|}
end_if

begin_expr_stmt
name|store_kbd_macro_char
argument_list|(
name|c
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|start_polling
argument_list|()
expr_stmt|;
end_expr_stmt

begin_label
name|from_macro
label|:
end_label

begin_label
name|reread_first
label|:
end_label

begin_comment
comment|/* Rereading a char and it is the first in a command.  */
end_comment

begin_expr_stmt
name|echo_char
argument_list|(
name|c
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Record this character as part of the current key.  */
end_comment

begin_if
if|if
condition|(
name|this_command_key_count
operator|==
name|this_command_keys_size
condition|)
block|{
name|this_command_keys_size
operator|*=
literal|2
expr_stmt|;
name|this_command_keys
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|this_command_keys
argument_list|,
name|this_command_keys_size
argument_list|)
expr_stmt|;
block|}
end_if

begin_expr_stmt
name|this_command_keys
index|[
name|this_command_key_count
operator|++
index|]
operator|=
name|c
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Rereading in the middle of a command.  */
end_comment

begin_label
name|reread
label|:
end_label

begin_expr_stmt
name|last_input_char
operator|=
name|c
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|num_input_chars
operator|++
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Process the help character specially if enabled */
end_comment

begin_if
if|if
condition|(
name|c
operator|==
name|help_char
operator|&&
operator|!
name|NULL
argument_list|(
name|Vhelp_form
argument_list|)
condition|)
block|{
name|count
operator|=
name|specpdl_ptr
operator|-
name|specpdl
expr_stmt|;
name|record_unwind_protect
argument_list|(
name|Fset_window_configuration
argument_list|,
name|Fcurrent_window_configuration
argument_list|()
argument_list|)
expr_stmt|;
name|tem
operator|=
name|Feval
argument_list|(
name|Vhelp_form
argument_list|)
expr_stmt|;
if|if
condition|(
name|XTYPE
argument_list|(
name|tem
argument_list|)
operator|==
name|Lisp_String
condition|)
name|internal_with_output_to_temp_buffer
argument_list|(
literal|"*Help*"
argument_list|,
name|print_help
argument_list|,
name|tem
argument_list|)
expr_stmt|;
name|cancel_echoing
argument_list|()
expr_stmt|;
name|c
operator|=
name|read_command_char
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Remove the help from the screen */
name|unbind_to
argument_list|(
name|count
argument_list|)
expr_stmt|;
name|redisplay
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|040
condition|)
block|{
name|cancel_echoing
argument_list|()
expr_stmt|;
name|c
operator|=
name|read_command_char
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_if

begin_return
return|return
name|c
return|;
end_return

begin_macro
unit|}  Lisp_Object
name|print_help
argument_list|(
argument|object
argument_list|)
end_macro

begin_decl_stmt
name|Lisp_Object
name|object
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|Fprinc
argument_list|(
name|object
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
return|return
name|Qnil
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Low level keyboard input.  Read characters into kbd_buffer  from which they are obtained by kbd_buffer_read_command_char.  */
end_comment

begin_comment
comment|/* Set this for debugging, to have a way to get out */
end_comment

begin_decl_stmt
name|int
name|stop_character
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Store a character obtained at interrupt level into kbd_buffer, fifo */
end_comment

begin_expr_stmt
name|kbd_buffer_store_char
argument_list|(
name|c
argument_list|)
specifier|register
name|int
name|c
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|c
operator|&=
literal|0377
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|quit_char
operator|||
operator|(
operator|(
name|c
operator|==
operator|(
literal|0200
operator||
name|quit_char
operator|)
operator|)
operator|&&
operator|!
name|meta_key
operator|)
condition|)
block|{
name|interrupt_signal
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|c
operator|&&
name|c
operator|==
name|stop_character
condition|)
block|{
name|sys_suspend
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|kbd_ptr
operator|!=
name|kbd_buffer
condition|)
block|{
name|bcopy
argument_list|(
name|kbd_ptr
argument_list|,
name|kbd_buffer
argument_list|,
name|kbd_count
argument_list|)
expr_stmt|;
name|kbd_ptr
operator|=
name|kbd_buffer
expr_stmt|;
block|}
if|if
condition|(
name|kbd_count
operator|<
sizeof|sizeof
name|kbd_buffer
condition|)
block|{
name|kbd_buffer
index|[
name|kbd_count
operator|++
index|]
operator|=
name|c
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|kbd_buffer_read_command_char
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|c
decl_stmt|;
if|if
condition|(
name|noninteractive
condition|)
block|{
name|c
operator|=
name|getchar
argument_list|()
expr_stmt|;
return|return
name|c
return|;
block|}
comment|/* Either ordinary input buffer or C-g buffered means we can return.  */
while|while
condition|(
operator|!
name|kbd_count
condition|)
block|{
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|Vquit_flag
argument_list|)
condition|)
name|quit_throw_to_read_command_char
argument_list|()
expr_stmt|;
comment|/* One way or another, wait until input is available; then, if 	 interrupt handlers have not read it, read it now.  */
ifdef|#
directive|ifdef
name|VMS
name|wait_for_kbd_input
argument_list|()
expr_stmt|;
else|#
directive|else
comment|/* Note SIGIO has been undef'd if FIONREAD is missing.  */
ifdef|#
directive|ifdef
name|SIGIO
name|gobble_input
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* SIGIO */
if|if
condition|(
operator|!
name|kbd_count
condition|)
block|{
ifdef|#
directive|ifdef
name|subprocesses
name|wait_reading_process_input
argument_list|(
literal|0
argument_list|,
operator|-
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* Note SIGIO has been undef'd if FIONREAD is missing.  */
ifdef|#
directive|ifdef
name|SIGIO
if|if
condition|(
name|interrupt_input
condition|)
block|{
name|sigblockx
argument_list|(
name|SIGIO
argument_list|)
expr_stmt|;
name|set_waiting_for_input
argument_list|(
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|kbd_count
condition|)
name|sigpausex
argument_list|(
name|SIGIO
argument_list|)
expr_stmt|;
name|clear_waiting_for_input
argument_list|()
expr_stmt|;
name|sigunblockx
argument_list|(
name|SIGIO
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|interrupt_input
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* not SIGIO */
endif|#
directive|endif
comment|/* subprocesses */
if|if
condition|(
operator|!
name|interrupt_input
operator|&&
operator|!
name|kbd_count
condition|)
block|{
name|read_avail_input
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* not VMS */
block|}
name|input_pending
operator|=
operator|--
name|kbd_count
operator|>
literal|0
expr_stmt|;
name|c
operator|=
operator|*
name|kbd_ptr
expr_stmt|;
comment|/* *kbd_ptr++ would have a timing error. */
name|kbd_ptr
operator|++
expr_stmt|;
comment|/* See kbd_buffer_store_char. */
return|return
operator|(
name|c
operator|&
operator|(
name|meta_key
condition|?
literal|0377
else|:
literal|0177
operator|)
operator|)
return|;
comment|/* Clean up if sign was extended. */
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Force an attempt to read input regardless of what FIONREAD says.  */
end_comment

begin_macro
name|force_input_read
argument_list|()
end_macro

begin_block
block|{
name|force_input
operator|=
literal|1
expr_stmt|;
name|detect_input_pending
argument_list|()
expr_stmt|;
name|force_input
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Store into *addr the number of terminal input chars available.    Equivalent to ioctl (0, FIONREAD, addr) but works    even if FIONREAD does not exist.  */
end_comment

begin_function
specifier|static
name|void
name|get_input_pending
parameter_list|(
name|addr
parameter_list|)
name|int
modifier|*
name|addr
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|VMS
comment|/* On VMS, we always have something in the buffer      if any input is available.  */
comment|/*** It might be simpler to make interrupt_input 1 on VMS ***/
operator|*
name|addr
operator|=
name|kbd_count
operator||
operator|!
name|NULL
argument_list|(
name|Vquit_flag
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* First of all, have we already counted some input?  */
operator|*
name|addr
operator|=
name|kbd_count
operator||
operator|!
name|NULL
argument_list|(
name|Vquit_flag
argument_list|)
expr_stmt|;
comment|/* If input is being read as it arrives, and we have none, there is none.  */
if|if
condition|(
operator|*
name|addr
operator|>
literal|0
operator|||
operator|(
name|interrupt_input
operator|&&
operator|!
name|interrupts_deferred
operator|&&
operator|!
name|force_input
operator|)
condition|)
return|return;
ifdef|#
directive|ifdef
name|FIONREAD
if|if
condition|(
operator|!
name|force_input
condition|)
block|{
comment|/* If we can count the input without reading it, do so.  */
if|if
condition|(
name|ioctl
argument_list|(
literal|0
argument_list|,
name|FIONREAD
argument_list|,
name|addr
argument_list|)
operator|<
literal|0
condition|)
operator|*
name|addr
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|addr
operator|==
literal|0
operator|||
name|read_socket_hook
operator|==
literal|0
condition|)
return|return;
comment|/* If the input consists of window-events, not all of them 	 are necessarily kbd chars.  So process all the input 	 and see how many kbd chars we got.  */
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGIO
block|{
comment|/* It seems there is a timing error such that a SIGIO can be handled here        and cause kbd_count to become nonzero even though raising of SIGIO        has already been turned off.  */
name|int
name|mask
init|=
name|sigblock
argument_list|(
name|sigmask
argument_list|(
name|SIGIO
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|kbd_count
operator|==
literal|0
condition|)
name|read_avail_input
argument_list|(
operator|*
name|addr
argument_list|)
expr_stmt|;
name|sigsetmask
argument_list|(
name|mask
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* If we can't count the input, read it (if any) and see what we got.  */
name|read_avail_input
argument_list|(
operator|*
name|addr
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|*
name|addr
operator|=
name|kbd_count
operator||
operator|!
name|NULL
argument_list|(
name|Vquit_flag
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Read pending any input out of the system and into Emacs.  */
end_comment

begin_comment
comment|/* This function is temporary in Emacs 18.  It is used only    with X windows.  X windows always turns on interrupt input    if possible, so this function has nothing to do except    on systems that don't have SIGIO.  And they also don't have FIONREAD.  */
end_comment

begin_function
name|void
name|consume_available_input
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|SIGIO
if|if
condition|(
operator|!
name|interrupt_input
operator|||
name|interrupts_deferred
condition|)
endif|#
directive|endif
name|read_avail_input
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Read any terminal input already buffered up by the system    into the kbd_buffer, assuming the buffer is currently empty.    Never waits.     If NREAD is nonzero, assume it contains # chars of raw data waiting.    If it is zero, we determine that datum.     Input gets into the kbd_buffer either through this function    (at main program level) or at interrupt level if input    is interrupt-driven.  */
end_comment

begin_function
specifier|static
name|void
name|read_avail_input
parameter_list|(
name|nread
parameter_list|)
name|int
name|nread
decl_stmt|;
block|{
comment|/* This function is not used on VMS.  */
ifndef|#
directive|ifndef
name|VMS
name|char
name|buf
index|[
literal|256
operator|*
name|BUFFER_SIZE_FACTOR
index|]
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|FIONREAD
if|if
condition|(
operator|!
name|force_input
condition|)
block|{
if|if
condition|(
name|nread
operator|==
literal|0
condition|)
name|get_input_pending
argument_list|(
operator|&
name|nread
argument_list|)
expr_stmt|;
if|if
condition|(
name|nread
operator|==
literal|0
condition|)
return|return;
block|}
if|if
condition|(
name|nread
operator|>
sizeof|sizeof
name|buf
condition|)
name|nread
operator|=
sizeof|sizeof
name|buf
expr_stmt|;
comment|/* Read what is waiting.  */
if|if
condition|(
name|read_socket_hook
condition|)
name|nread
operator|=
call|(
modifier|*
name|read_socket_hook
call|)
argument_list|(
literal|0
argument_list|,
name|buf
argument_list|,
name|nread
argument_list|)
expr_stmt|;
else|else
name|nread
operator|=
name|read
argument_list|(
literal|0
argument_list|,
name|buf
argument_list|,
name|nread
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* no FIONREAD */
ifdef|#
directive|ifdef
name|USG
name|fcntl
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
name|F_SETFL
argument_list|,
name|O_NDELAY
argument_list|)
expr_stmt|;
if|if
condition|(
name|read_socket_hook
condition|)
block|{
name|nread
operator|=
call|(
modifier|*
name|read_socket_hook
call|)
argument_list|(
literal|0
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nread
operator|=
name|read
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|EBADSLT
if|if
condition|(
name|nread
operator|==
operator|-
literal|1
operator|&&
operator|(
name|errno
operator|==
name|EAGAIN
operator|||
name|errno
operator|==
name|EBADSLT
operator|)
condition|)
else|#
directive|else
if|if
condition|(
name|nread
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|==
name|EAGAIN
condition|)
endif|#
directive|endif
name|nread
operator|=
literal|0
expr_stmt|;
name|fcntl
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
name|F_SETFL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* not USG */
name|you
name|lose
endif|#
directive|endif
comment|/* not USG */
endif|#
directive|endif
comment|/* no FIONREAD */
comment|/* Scan the chars for C-g and store them in kbd_buffer.  */
if|if
condition|(
name|kbd_count
operator|==
literal|0
condition|)
name|kbd_ptr
operator|=
name|kbd_buffer
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nread
condition|;
name|i
operator|++
control|)
block|{
name|kbd_buffer_store_char
argument_list|(
name|buf
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* Don't look at input that follows a C-g too closely. 	 This reduces lossage due to autorepeat on C-g.  */
if|if
condition|(
name|buf
index|[
name|i
index|]
operator|==
name|quit_char
condition|)
break|break;
block|}
endif|#
directive|endif
comment|/* not VMS */
block|}
end_function

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|SIGIO
end_ifdef

begin_comment
comment|/* for entire page */
end_comment

begin_comment
comment|/* Note SIGIO has been undef'd if FIONREAD is missing.  */
end_comment

begin_comment
comment|/* If using interrupt input and some input chars snuck into the    buffer before we enabled interrupts, fake an interrupt for them.  */
end_comment

begin_macro
name|gobble_input
argument_list|()
end_macro

begin_block
block|{
name|int
name|nread
decl_stmt|;
if|if
condition|(
name|interrupt_input
condition|)
block|{
if|if
condition|(
name|ioctl
argument_list|(
literal|0
argument_list|,
name|FIONREAD
argument_list|,
operator|&
name|nread
argument_list|)
operator|<
literal|0
condition|)
name|nread
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|nread
condition|)
block|{
name|sigholdx
argument_list|(
name|SIGIO
argument_list|)
expr_stmt|;
name|input_available_signal
argument_list|(
name|SIGIO
argument_list|)
expr_stmt|;
name|sigfree
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_block

begin_macro
name|input_available_signal
argument_list|(
argument|signo
argument_list|)
end_macro

begin_decl_stmt
name|int
name|signo
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|unsigned
name|char
name|buf
index|[
literal|256
operator|*
name|BUFFER_SIZE_FACTOR
index|]
decl_stmt|;
name|int
name|nread
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
comment|/* Must preserve main program's value of errno.  */
name|int
name|old_errno
init|=
name|errno
decl_stmt|;
ifdef|#
directive|ifdef
name|BSD4_1
specifier|extern
name|int
name|select_alarmed
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|USG
comment|/* USG systems forget handlers when they are used;      must reestablish each time */
name|signal
argument_list|(
name|signo
argument_list|,
name|input_available_signal
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* USG */
ifdef|#
directive|ifdef
name|BSD4_1
name|sigisheld
argument_list|(
name|SIGIO
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|input_available_clear_word
condition|)
operator|*
name|input_available_clear_word
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|ioctl
argument_list|(
literal|0
argument_list|,
name|FIONREAD
argument_list|,
operator|&
name|nread
argument_list|)
operator|<
literal|0
condition|)
comment|/* Formerly simply exited the loop, but that sometimes led to 	   a failure of Emacs to terminate. 	   SIGHUP seems appropriate if we can't reach the terminal.  */
name|kill
argument_list|(
name|getpid
argument_list|()
argument_list|,
name|SIGHUP
argument_list|)
expr_stmt|;
if|if
condition|(
name|nread
operator|<=
literal|0
condition|)
break|break;
ifdef|#
directive|ifdef
name|BSD4_1
name|select_alarmed
operator|=
literal|1
expr_stmt|;
comment|/* Force the select emulator back to life */
endif|#
directive|endif
if|if
condition|(
name|read_socket_hook
condition|)
block|{
name|nread
operator|=
call|(
modifier|*
name|read_socket_hook
call|)
argument_list|(
literal|0
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nread
condition|)
continue|continue;
block|}
else|else
block|{
if|if
condition|(
name|nread
operator|>
sizeof|sizeof
name|buf
condition|)
name|nread
operator|=
sizeof|sizeof
name|buf
expr_stmt|;
name|nread
operator|=
name|read
argument_list|(
literal|0
argument_list|,
name|buf
argument_list|,
name|nread
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nread
condition|;
name|i
operator|++
control|)
block|{
name|kbd_buffer_store_char
argument_list|(
name|buf
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* Don't look at input that follows a C-g too closely. 	     This reduces lossage due to autorepeat on C-g.  */
if|if
condition|(
name|buf
index|[
name|i
index|]
operator|==
name|quit_char
condition|)
break|break;
block|}
block|}
ifdef|#
directive|ifdef
name|BSD4_1
name|sigfree
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|errno
operator|=
name|old_errno
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SIGIO */
end_comment

begin_escape
end_escape

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* This is turned off because it didn't produce much speedup.  */
end_comment

begin_comment
comment|/* Read a single-char key sequence.  Do not redisplay.    Return 1 if successful, or 0 if what follows is not    a single-char key.  (In that case, a char has been unread.)    This is used instead of read_key_sequence as an optimization    just after a direct-updating command is done, since at such    times we know that no redisplay is required.  */
end_comment

begin_comment
unit|int fast_read_one_key (keybuf)      char *keybuf; {   register Lisp_Object map;   register int c;   register Lisp_Object tem;    keys_prompt = 0;
comment|/* Read a character, and do not redisplay.  */
end_comment

begin_comment
unit|c = read_command_char (-1);   Vquit_flag = Qnil;
comment|/* Assume until further notice that we are unlucky      and will return zero, so this char will be      reread by read_key_sequence.  */
end_comment

begin_comment
unit|unread_command_char = c;    if (c< 0 || c>= 0200)     return 0;    map = current_buffer->keymap;   if (!EQ (map, Qnil))     {       tem = get_keyelt (access_keymap (map, c));       if (!EQ (tem, Qnil)) 	return 0;     }    XSET (map, Lisp_Vector, global_map);   tem = !NULL (map)     ? get_keyelt (access_keymap (map, c))       : Qnil;    read_key_sequence_cmd = tem;
comment|/* trace symbols to their function definitions */
end_comment

begin_comment
unit|while (XTYPE (tem) == Lisp_Symbol&& !NULL (tem)&& !EQ (tem, Qunbound))     tem = XSYMBOL (tem)->function;
comment|/* Is the definition a prefix character?  */
end_comment

begin_endif
unit|if (XTYPE (tem) == Lisp_Vector ||       (CONSP (tem)&& EQ (XCONS (tem)->car, Qkeymap)))     return 0;    unread_command_char = -1;   keybuf[0] = c;   return 1; }
endif|#
directive|endif
end_endif

begin_comment
comment|/* 0 */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Read a sequence of keys that ends with a non prefix character,  and store them in KEYBUF, a buffer of size BUFSIZE.  Prompt with PROMPT.  Echo starting immediately unless `prompt' is 0.  Return the length of the key sequence stored.  NODISPLAY nonzero means don't do redisplay before the first character  (just for speedup).  */
end_comment

begin_function
name|int
name|read_key_sequence
parameter_list|(
name|keybuf
parameter_list|,
name|bufsize
parameter_list|,
name|prompt
parameter_list|,
name|nodisplay
parameter_list|)
name|char
modifier|*
name|keybuf
decl_stmt|;
name|int
name|bufsize
decl_stmt|;
name|unsigned
name|char
modifier|*
name|prompt
decl_stmt|;
name|int
name|nodisplay
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|Lisp_Object
name|nextlocal
decl_stmt|,
name|nextglobal
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|,
name|nextc
decl_stmt|;
name|Lisp_Object
name|local
decl_stmt|,
name|global
decl_stmt|;
if|if
condition|(
name|FROM_KBD
condition|)
block|{
if|if
condition|(
name|prompt
condition|)
name|echo_prompt
argument_list|(
name|prompt
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|cursor_in_echo_area
condition|)
name|echo_dash
argument_list|()
expr_stmt|;
block|}
name|nextc
operator|=
name|read_command_char
argument_list|(
name|nodisplay
condition|?
operator|-
literal|1
else|:
operator|!
name|prompt
argument_list|)
expr_stmt|;
name|nextlocal
operator|=
name|current_buffer
operator|->
name|keymap
expr_stmt|;
name|XSET
argument_list|(
name|nextglobal
argument_list|,
name|Lisp_Vector
argument_list|,
name|global_map
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
name|NULL
argument_list|(
name|nextlocal
argument_list|)
operator|||
operator|!
name|NULL
argument_list|(
name|nextglobal
argument_list|)
condition|)
block|{
if|if
condition|(
name|i
operator|==
name|bufsize
condition|)
name|error
argument_list|(
literal|"key sequence too long"
argument_list|)
expr_stmt|;
if|if
condition|(
name|nextc
operator|>=
literal|0
condition|)
block|{
name|c
operator|=
name|nextc
expr_stmt|;
name|nextc
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
name|c
operator|=
name|read_command_char
argument_list|(
operator|!
name|prompt
argument_list|)
expr_stmt|;
name|Vquit_flag
operator|=
name|Qnil
expr_stmt|;
name|nodisplay
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|c
operator|<
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|c
operator|>=
literal|0200
condition|)
block|{
name|nextc
operator|=
name|c
operator|&
literal|0177
expr_stmt|;
name|c
operator|=
name|meta_prefix_char
expr_stmt|;
block|}
name|keybuf
index|[
name|i
index|]
operator|=
name|c
expr_stmt|;
name|global
operator|=
operator|!
name|NULL
argument_list|(
name|nextglobal
argument_list|)
condition|?
name|get_keyelt
argument_list|(
name|access_keymap
argument_list|(
name|nextglobal
argument_list|,
name|c
argument_list|)
argument_list|)
else|:
name|Qnil
expr_stmt|;
name|local
operator|=
operator|!
name|NULL
argument_list|(
name|nextlocal
argument_list|)
condition|?
name|get_keyelt
argument_list|(
name|access_keymap
argument_list|(
name|nextlocal
argument_list|,
name|c
argument_list|)
argument_list|)
else|:
name|Qnil
expr_stmt|;
comment|/* If C is not defined in either keymap 	 and it is an uppercase letter, try corresponding lowercase.  */
if|if
condition|(
name|NULL
argument_list|(
name|global
argument_list|)
operator|&&
name|NULL
argument_list|(
name|local
argument_list|)
operator|&&
name|UPPERCASEP
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|global
operator|=
operator|!
name|NULL
argument_list|(
name|nextglobal
argument_list|)
condition|?
name|get_keyelt
argument_list|(
name|access_keymap
argument_list|(
name|nextglobal
argument_list|,
name|DOWNCASE
argument_list|(
name|c
argument_list|)
argument_list|)
argument_list|)
else|:
name|Qnil
expr_stmt|;
name|local
operator|=
operator|!
name|NULL
argument_list|(
name|nextlocal
argument_list|)
condition|?
name|get_keyelt
argument_list|(
name|access_keymap
argument_list|(
name|nextlocal
argument_list|,
name|DOWNCASE
argument_list|(
name|c
argument_list|)
argument_list|)
argument_list|)
else|:
name|Qnil
expr_stmt|;
comment|/* If that has worked better that the original char, 	     downcase it permanently.  */
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|global
argument_list|)
operator|||
operator|!
name|NULL
argument_list|(
name|local
argument_list|)
condition|)
block|{
name|keybuf
index|[
name|i
index|]
operator|=
name|c
operator|=
name|DOWNCASE
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
block|}
name|i
operator|++
expr_stmt|;
name|nextlocal
operator|=
name|Qnil
expr_stmt|;
name|nextglobal
operator|=
name|Qnil
expr_stmt|;
name|read_key_sequence_cmd
operator|=
operator|!
name|NULL
argument_list|(
name|local
argument_list|)
condition|?
name|local
else|:
name|global
expr_stmt|;
comment|/* trace symbols to their function definitions */
while|while
condition|(
name|XTYPE
argument_list|(
name|global
argument_list|)
operator|==
name|Lisp_Symbol
operator|&&
operator|!
name|NULL
argument_list|(
name|global
argument_list|)
operator|&&
operator|!
name|EQ
argument_list|(
name|global
argument_list|,
name|Qunbound
argument_list|)
condition|)
name|global
operator|=
name|XSYMBOL
argument_list|(
name|global
argument_list|)
operator|->
name|function
expr_stmt|;
while|while
condition|(
name|XTYPE
argument_list|(
name|local
argument_list|)
operator|==
name|Lisp_Symbol
operator|&&
operator|!
name|NULL
argument_list|(
name|local
argument_list|)
operator|&&
operator|!
name|EQ
argument_list|(
name|local
argument_list|,
name|Qunbound
argument_list|)
condition|)
name|local
operator|=
name|XSYMBOL
argument_list|(
name|local
argument_list|)
operator|->
name|function
expr_stmt|;
comment|/* Are the definitions prefix characters? */
if|if
condition|(
name|XTYPE
argument_list|(
name|local
argument_list|)
operator|==
name|Lisp_Vector
operator|||
operator|(
name|CONSP
argument_list|(
name|local
argument_list|)
operator|&&
name|EQ
argument_list|(
name|XCONS
argument_list|(
name|local
argument_list|)
operator|->
name|car
argument_list|,
name|Qkeymap
argument_list|)
operator|)
operator|||
comment|/* If nextc is set, we are processing a prefix char 	     that represents a meta-bit. 	     Let a global prefix definition override a local non-prefix. 	     This is for minibuffers that redefine Escape for completion. 	     A real Escape gets completion, but Meta bits get ESC-prefix.  */
operator|(
operator|(
name|NULL
argument_list|(
name|local
argument_list|)
operator|||
name|nextc
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|XTYPE
argument_list|(
name|global
argument_list|)
operator|==
name|Lisp_Vector
operator|||
operator|(
name|CONSP
argument_list|(
name|global
argument_list|)
operator|&&
name|EQ
argument_list|(
name|XCONS
argument_list|(
name|global
argument_list|)
operator|->
name|car
argument_list|,
name|Qkeymap
argument_list|)
operator|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|XTYPE
argument_list|(
name|local
argument_list|)
operator|==
name|Lisp_Vector
operator|||
operator|(
name|CONSP
argument_list|(
name|local
argument_list|)
operator|&&
name|EQ
argument_list|(
name|XCONS
argument_list|(
name|local
argument_list|)
operator|->
name|car
argument_list|,
name|Qkeymap
argument_list|)
operator|)
condition|)
name|nextlocal
operator|=
name|local
expr_stmt|;
else|else
name|nextlocal
operator|=
name|Qnil
expr_stmt|;
if|if
condition|(
name|XTYPE
argument_list|(
name|global
argument_list|)
operator|==
name|Lisp_Vector
operator|||
operator|(
name|CONSP
argument_list|(
name|global
argument_list|)
operator|&&
name|EQ
argument_list|(
name|XCONS
argument_list|(
name|global
argument_list|)
operator|->
name|car
argument_list|,
name|Qkeymap
argument_list|)
operator|)
condition|)
name|nextglobal
operator|=
name|global
expr_stmt|;
else|else
name|nextglobal
operator|=
name|Qnil
expr_stmt|;
block|}
block|}
return|return
name|i
return|;
block|}
end_function

begin_macro
name|DEFUN
argument_list|(
literal|"read-key-sequence"
argument_list|,
argument|Fread_key_sequence
argument_list|,
argument|Sread_key_sequence
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Read a sequence of keystrokes and return as a string.\n\ The sequence is sufficient to specify a non-prefix command\n\ starting from the current local and global keymaps.\n\ A C-g typed while in this function is treated like\n\ any other character, and quit-flag is not set.\n\ One arg, PROMPT, a prompt string or  nil, meaning do not prompt specially."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|prompt
operator|)
name|Lisp_Object
name|prompt
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|char
name|keybuf
index|[
literal|30
index|]
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|prompt
argument_list|)
condition|)
name|CHECK_STRING
argument_list|(
name|prompt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|QUIT
expr_stmt|;
name|this_command_key_count
operator|=
literal|0
expr_stmt|;
name|i
operator|=
name|read_key_sequence
argument_list|(
name|keybuf
argument_list|,
sizeof|sizeof
name|keybuf
argument_list|,
operator|(
name|NULL
argument_list|(
name|prompt
argument_list|)
operator|)
condition|?
literal|0
else|:
name|XSTRING
argument_list|(
name|prompt
argument_list|)
operator|->
name|data
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|make_string
argument_list|(
name|keybuf
argument_list|,
name|i
argument_list|)
return|;
block|}
end_block

begin_escape
end_escape

begin_macro
name|DEFUN
argument_list|(
literal|"command-execute"
argument_list|,
argument|Fcommand_execute
argument_list|,
argument|Scommand_execute
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"Execute CMD as an editor command.\n\ CMD must be a symbol that satisfies the `commandp' predicate.\n\ Optional second arg RECORD-FLAG non-nil\n\ means unconditionally put this command in the command-history.\n\ Otherwise, this is done only if an arg is read using the minibuffer."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|cmd
operator|,
name|record
operator|)
name|Lisp_Object
name|cmd
operator|,
name|record
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|Lisp_Object
name|final
decl_stmt|;
specifier|register
name|Lisp_Object
name|tem
decl_stmt|;
name|Lisp_Object
name|prefixarg
decl_stmt|;
name|struct
name|backtrace
name|backtrace
decl_stmt|;
specifier|extern
name|int
name|debug_on_next_call
decl_stmt|;
name|prefixarg
operator|=
name|Vprefix_arg
operator|,
name|Vprefix_arg
operator|=
name|Qnil
expr_stmt|;
name|Vcurrent_prefix_arg
operator|=
name|prefixarg
expr_stmt|;
name|debug_on_next_call
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|XTYPE
argument_list|(
name|cmd
argument_list|)
operator|==
name|Lisp_Symbol
condition|)
block|{
name|tem
operator|=
name|Fget
argument_list|(
name|cmd
argument_list|,
name|Qdisabled
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|tem
argument_list|)
condition|)
return|return
name|call0
argument_list|(
name|Vdisabled_command_hook
argument_list|)
return|;
block|}
while|while
condition|(
literal|1
condition|)
block|{
name|final
operator|=
name|cmd
expr_stmt|;
while|while
condition|(
name|XTYPE
argument_list|(
name|final
argument_list|)
operator|==
name|Lisp_Symbol
condition|)
block|{
if|if
condition|(
name|EQ
argument_list|(
name|Qunbound
argument_list|,
name|XSYMBOL
argument_list|(
name|final
argument_list|)
operator|->
name|function
argument_list|)
condition|)
name|Fsymbol_function
argument_list|(
name|final
argument_list|)
expr_stmt|;
comment|/* Get an error! */
name|final
operator|=
name|XSYMBOL
argument_list|(
name|final
argument_list|)
operator|->
name|function
expr_stmt|;
block|}
if|if
condition|(
name|CONSP
argument_list|(
name|final
argument_list|)
operator|&&
operator|(
name|tem
operator|=
name|Fcar
argument_list|(
name|final
argument_list|)
operator|,
name|EQ
argument_list|(
name|tem
argument_list|,
name|Qautoload
argument_list|)
operator|)
condition|)
name|do_autoload
argument_list|(
name|final
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
else|else
break|break;
block|}
if|if
condition|(
name|CONSP
argument_list|(
name|final
argument_list|)
operator|||
name|XTYPE
argument_list|(
name|final
argument_list|)
operator|==
name|Lisp_Subr
condition|)
block|{
name|backtrace
operator|.
name|next
operator|=
name|backtrace_list
expr_stmt|;
name|backtrace_list
operator|=
operator|&
name|backtrace
expr_stmt|;
name|backtrace
operator|.
name|function
operator|=
operator|&
name|Qcall_interactively
expr_stmt|;
name|backtrace
operator|.
name|args
operator|=
operator|&
name|cmd
expr_stmt|;
name|backtrace
operator|.
name|nargs
operator|=
literal|1
expr_stmt|;
name|backtrace
operator|.
name|evalargs
operator|=
literal|0
expr_stmt|;
name|tem
operator|=
name|Fcall_interactively
argument_list|(
name|cmd
argument_list|,
name|record
argument_list|)
expr_stmt|;
name|backtrace_list
operator|=
name|backtrace
operator|.
name|next
expr_stmt|;
return|return
name|tem
return|;
block|}
if|if
condition|(
name|XTYPE
argument_list|(
name|final
argument_list|)
operator|==
name|Lisp_String
condition|)
block|{
return|return
name|Fexecute_kbd_macro
argument_list|(
name|final
argument_list|,
name|prefixarg
argument_list|)
return|;
block|}
return|return
name|Qnil
return|;
block|}
end_block

begin_escape
end_escape

begin_macro
name|DEFUN
argument_list|(
literal|"execute-extended-command"
argument_list|,
argument|Fexecute_extended_command
argument_list|,
argument|Sexecute_extended_command
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|"P"
argument_list|,
literal|"Read function name, then read its arguments and call it."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|prefixarg
operator|)
name|Lisp_Object
name|prefixarg
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|Lisp_Object
name|function
decl_stmt|;
name|char
name|buf
index|[
literal|40
index|]
decl_stmt|;
name|Lisp_Object
name|saved_keys
decl_stmt|;
name|struct
name|gcpro
name|gcpro1
decl_stmt|;
name|saved_keys
operator|=
name|Fthis_command_keys
argument_list|()
expr_stmt|;
name|GCPRO1
argument_list|(
name|saved_keys
argument_list|)
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|EQ
argument_list|(
name|prefixarg
argument_list|,
name|Qminus
argument_list|)
condition|)
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|"- "
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|CONSP
argument_list|(
name|prefixarg
argument_list|)
operator|&&
name|XINT
argument_list|(
name|XCONS
argument_list|(
name|prefixarg
argument_list|)
operator|->
name|car
argument_list|)
operator|==
literal|4
condition|)
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|"C-u "
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|CONSP
argument_list|(
name|prefixarg
argument_list|)
operator|&&
name|XTYPE
argument_list|(
name|XCONS
argument_list|(
name|prefixarg
argument_list|)
operator|->
name|car
argument_list|)
operator|==
name|Lisp_Int
condition|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%d "
argument_list|,
name|XINT
argument_list|(
name|XCONS
argument_list|(
name|prefixarg
argument_list|)
operator|->
name|car
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|XTYPE
argument_list|(
name|prefixarg
argument_list|)
operator|==
name|Lisp_Int
condition|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%d "
argument_list|,
name|XINT
argument_list|(
name|prefixarg
argument_list|)
argument_list|)
expr_stmt|;
comment|/* This isn't strictly correct if execute-extended-command      is bound to anything else */
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"M-x "
argument_list|)
expr_stmt|;
name|function
operator|=
name|Fcompleting_read
argument_list|(
name|build_string
argument_list|(
name|buf
argument_list|)
argument_list|,
name|Vobarray
argument_list|,
name|Qcommandp
argument_list|,
name|Qt
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
name|saved_keys
operator|=
name|concat2
argument_list|(
name|saved_keys
argument_list|,
name|function
argument_list|)
expr_stmt|;
if|if
condition|(
name|this_command_keys_size
operator|<
name|XSTRING
argument_list|(
name|function
argument_list|)
operator|->
name|size
condition|)
block|{
name|this_command_keys_size
operator|+=
name|XSTRING
argument_list|(
name|function
argument_list|)
operator|->
name|size
expr_stmt|;
name|this_command_keys
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|this_command_keys
argument_list|,
name|this_command_keys_size
argument_list|)
expr_stmt|;
block|}
name|bcopy
argument_list|(
name|XSTRING
argument_list|(
name|function
argument_list|)
operator|->
name|data
argument_list|,
name|this_command_keys
argument_list|,
name|XSTRING
argument_list|(
name|function
argument_list|)
operator|->
name|size
operator|+
literal|1
argument_list|)
expr_stmt|;
name|this_command_key_count
operator|=
name|XSTRING
argument_list|(
name|saved_keys
argument_list|)
operator|->
name|size
expr_stmt|;
name|UNGCPRO
expr_stmt|;
name|function
operator|=
name|Fintern
argument_list|(
name|function
argument_list|,
name|Vobarray
argument_list|)
expr_stmt|;
name|Vprefix_arg
operator|=
name|prefixarg
expr_stmt|;
name|this_command
operator|=
name|function
expr_stmt|;
return|return
name|Fcommand_execute
argument_list|(
name|function
argument_list|,
name|Qt
argument_list|)
return|;
block|}
end_block

begin_escape
end_escape

begin_macro
name|detect_input_pending
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
operator|!
name|input_pending
condition|)
name|get_input_pending
argument_list|(
operator|&
name|input_pending
argument_list|)
expr_stmt|;
return|return
name|input_pending
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"input-pending-p"
argument_list|,
argument|Finput_pending_p
argument_list|,
argument|Sinput_pending_p
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"T if command input is currently available with no waiting.\n\ Actually, the value is NIL only if we can be sure that no input is available."
argument_list|)
end_macro

begin_expr_stmt
operator|(
operator|)
block|{
if|if
condition|(
name|unread_command_char
operator|>=
literal|0
condition|)
return|return
name|Qt
return|;
end_expr_stmt

begin_return
return|return
name|detect_input_pending
argument_list|()
condition|?
name|Qt
else|:
name|Qnil
return|;
end_return

begin_expr_stmt
unit|}  DEFUN
operator|(
literal|"recent-keys"
operator|,
name|Frecent_keys
operator|,
name|Srecent_keys
operator|,
literal|0
operator|,
literal|0
operator|,
literal|0
operator|,
literal|"Return string of last 100 chars read from terminal."
operator|)
operator|(
operator|)
block|{
name|Lisp_Object
name|val
block|;
if|if
condition|(
name|total_keys
operator|<
sizeof|sizeof
name|recent_keys
condition|)
return|return
name|make_string
argument_list|(
name|recent_keys
argument_list|,
name|total_keys
argument_list|)
return|;
name|val
operator|=
name|make_string
argument_list|(
name|recent_keys
argument_list|,
sizeof|sizeof
name|recent_keys
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|bcopy
argument_list|(
name|recent_keys
operator|+
name|recent_keys_index
argument_list|,
name|XSTRING
argument_list|(
name|val
argument_list|)
operator|->
name|data
argument_list|,
sizeof|sizeof
name|recent_keys
operator|-
name|recent_keys_index
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|bcopy
argument_list|(
name|recent_keys
argument_list|,
name|XSTRING
argument_list|(
name|val
argument_list|)
operator|->
name|data
operator|+
sizeof|sizeof
name|recent_keys
operator|-
name|recent_keys_index
argument_list|,
name|recent_keys_index
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|val
return|;
end_return

begin_expr_stmt
unit|}  DEFUN
operator|(
literal|"this-command-keys"
operator|,
name|Fthis_command_keys
operator|,
name|Sthis_command_keys
operator|,
literal|0
operator|,
literal|0
operator|,
literal|0
operator|,
literal|"Return string of the keystrokes that invoked this command."
operator|)
operator|(
operator|)
block|{
return|return
name|make_string
argument_list|(
name|this_command_keys
argument_list|,
name|this_command_key_count
argument_list|)
return|;
block|}
end_expr_stmt

begin_macro
name|DEFUN
argument_list|(
literal|"recursion-depth"
argument_list|,
argument|Frecursion_depth
argument_list|,
argument|Srecursion_depth
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Return the current depth in recursive edits."
argument_list|)
end_macro

begin_expr_stmt
operator|(
operator|)
block|{
name|Lisp_Object
name|temp
block|;
name|XFASTINT
argument_list|(
name|temp
argument_list|)
operator|=
name|command_loop_level
operator|+
name|minibuf_level
block|;
return|return
name|temp
return|;
block|}
end_expr_stmt

begin_macro
name|DEFUN
argument_list|(
literal|"open-dribble-file"
argument_list|,
argument|Fopen_dribble_file
argument_list|,
argument|Sopen_dribble_file
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|"FOpen dribble file: "
argument_list|,
literal|"Start writing all keyboard characters to FILE."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|file
operator|)
name|Lisp_Object
name|file
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|file
operator|=
name|Fexpand_file_name
argument_list|(
name|file
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
name|dribble
operator|=
name|fopen
argument_list|(
name|XSTRING
argument_list|(
name|file
argument_list|)
operator|->
name|data
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
return|return
name|Qnil
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"discard-input"
argument_list|,
argument|Fdiscard_input
argument_list|,
argument|Sdiscard_input
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Discard the contents of the terminal input buffer.\n\ Also flush any kbd macro definition in progress."
argument_list|)
end_macro

begin_expr_stmt
operator|(
operator|)
block|{
name|defining_kbd_macro
operator|=
literal|0
block|;
name|update_mode_lines
operator|++
block|;
name|unread_command_char
operator|=
operator|-
literal|1
block|;
name|discard_tty_input
argument_list|()
block|;
name|kbd_count
operator|=
literal|0
block|;
name|input_pending
operator|=
literal|0
block|;
return|return
name|Qnil
return|;
block|}
end_expr_stmt

begin_escape
end_escape

begin_macro
name|DEFUN
argument_list|(
literal|"suspend-emacs"
argument_list|,
argument|Fsuspend_emacs
argument_list|,
argument|Ssuspend_emacs
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|""
argument_list|,
literal|"Stop Emacs and return to superior process.  You can resume.\n\ If optional arg STUFFSTRING is non-nil, its characters are stuffed\n\ to be read as terminal input by Emacs's superior shell.\n\ Before suspending, if `suspend-hook' is bound and value is non-nil\n\ call the value as a function of no args.  Don't suspend if it returns non-nil.\n\ Otherwise, suspend normally and after resumption call\n\ `suspend-resume-hook' if that is bound and non-nil."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|stuffstring
operator|)
name|Lisp_Object
name|stuffstring
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|Lisp_Object
name|tem
decl_stmt|;
name|int
name|count
init|=
name|specpdl_ptr
operator|-
name|specpdl
decl_stmt|;
name|int
name|old_height
decl_stmt|,
name|old_width
decl_stmt|;
name|int
name|width
decl_stmt|,
name|height
decl_stmt|;
name|struct
name|gcpro
name|gcpro1
decl_stmt|;
extern|extern init_sys_modes (
block|)
end_block

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_if
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|stuffstring
argument_list|)
condition|)
name|CHECK_STRING
argument_list|(
name|stuffstring
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_if

begin_expr_stmt
name|GCPRO1
argument_list|(
name|stuffstring
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Call value of suspend-hook      if it is bound and value is non-nil.  */
end_comment

begin_expr_stmt
name|tem
operator|=
name|intern
argument_list|(
literal|"suspend-hook"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|tem
operator|=
name|XSYMBOL
argument_list|(
name|tem
argument_list|)
operator|->
name|value
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
operator|!
name|EQ
argument_list|(
name|tem
argument_list|,
name|Qunbound
argument_list|)
operator|&&
operator|!
name|EQ
argument_list|(
name|tem
argument_list|,
name|Qnil
argument_list|)
condition|)
block|{
name|tem
operator|=
name|call0
argument_list|(
name|tem
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|EQ
argument_list|(
name|tem
argument_list|,
name|Qnil
argument_list|)
condition|)
return|return
name|Qnil
return|;
block|}
end_if

begin_expr_stmt
name|get_screen_size
argument_list|(
operator|&
name|old_width
argument_list|,
operator|&
name|old_height
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|reset_sys_modes
argument_list|()
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* sys_suspend can get an error if it tries to fork a subshell      and the system resources aren't available for that.  */
end_comment

begin_expr_stmt
name|record_unwind_protect
argument_list|(
name|init_sys_modes
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|stuff_buffered_input
argument_list|(
name|stuffstring
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|sys_suspend
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|unbind_to
argument_list|(
name|count
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Check if terminal/window size has changed.      Note that this is not useful when we are running directly      with a window system; but suspend should be disabled in that case.  */
end_comment

begin_expr_stmt
name|get_screen_size
argument_list|(
operator|&
name|width
argument_list|,
operator|&
name|height
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|width
operator|!=
name|old_width
operator|||
name|height
operator|!=
name|old_height
condition|)
name|change_screen_size
argument_list|(
name|height
argument_list|,
name|width
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_if

begin_comment
comment|/* Call value of suspend-resume-hook      if it is bound and value is non-nil.  */
end_comment

begin_expr_stmt
name|tem
operator|=
name|intern
argument_list|(
literal|"suspend-resume-hook"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|tem
operator|=
name|XSYMBOL
argument_list|(
name|tem
argument_list|)
operator|->
name|value
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
operator|!
name|EQ
argument_list|(
name|tem
argument_list|,
name|Qunbound
argument_list|)
operator|&&
operator|!
name|EQ
argument_list|(
name|tem
argument_list|,
name|Qnil
argument_list|)
condition|)
name|call0
argument_list|(
name|tem
argument_list|)
expr_stmt|;
end_if

begin_expr_stmt
name|UNGCPRO
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|Qnil
return|;
end_return

begin_comment
unit|}
comment|/* If STUFFSTRING is a string, stuff its contents as pending terminal input.    Then in any case stuff anthing Emacs has read ahead and not used.  */
end_comment

begin_expr_stmt
unit|stuff_buffered_input
operator|(
name|stuffstring
operator|)
name|Lisp_Object
name|stuffstring
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
comment|/* stuff_char works only in BSD, versions 4.2 and up.  */
ifdef|#
directive|ifdef
name|BSD
ifndef|#
directive|ifndef
name|BSD4_1
if|if
condition|(
name|XTYPE
argument_list|(
name|stuffstring
argument_list|)
operator|==
name|Lisp_String
condition|)
block|{
specifier|register
name|int
name|count
decl_stmt|;
name|p
operator|=
name|XSTRING
argument_list|(
name|stuffstring
argument_list|)
operator|->
name|data
expr_stmt|;
name|count
operator|=
name|XSTRING
argument_list|(
name|stuffstring
argument_list|)
operator|->
name|size
expr_stmt|;
while|while
condition|(
name|count
operator|--
operator|>
literal|0
condition|)
name|stuff_char
argument_list|(
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
name|stuff_char
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
comment|/* Anything we have read ahead, put back for the shell to read.  */
while|while
condition|(
name|kbd_count
condition|)
block|{
name|stuff_char
argument_list|(
operator|*
name|kbd_ptr
operator|++
argument_list|)
expr_stmt|;
name|kbd_count
operator|--
expr_stmt|;
block|}
name|input_pending
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* BSD and not BSD4_1 */
block|}
end_block

begin_escape
end_escape

begin_macro
name|set_waiting_for_input
argument_list|(
argument|word_to_clear
argument_list|)
end_macro

begin_decl_stmt
name|long
modifier|*
name|word_to_clear
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|input_available_clear_word
operator|=
name|word_to_clear
expr_stmt|;
comment|/* Tell interrupt_signal to throw back to read_command_char,  */
name|waiting_for_input
operator|=
literal|1
expr_stmt|;
comment|/* If interrupt_signal was called before and buffered a C-g,      make it run again now, to avoid timing error.  */
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|Vquit_flag
argument_list|)
condition|)
name|quit_throw_to_read_command_char
argument_list|()
expr_stmt|;
comment|/* Tell alarm signal to echo right away */
name|echo_now
operator|=
literal|1
expr_stmt|;
comment|/* If alarm has gone off already, echo now.  */
if|if
condition|(
name|echo_flag
condition|)
block|{
name|echo
argument_list|()
expr_stmt|;
name|echo_flag
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|clear_waiting_for_input
argument_list|()
end_macro

begin_block
block|{
comment|/* Tell interrupt_signal not to throw back to read_command_char,  */
name|waiting_for_input
operator|=
literal|0
expr_stmt|;
name|echo_now
operator|=
literal|0
expr_stmt|;
name|input_available_clear_word
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_comment
comment|/* This routine is called at interrupt level in response to C-G.  If interrupt_input, this is the handler for SIGINT.  Otherwise, it is called from kbd_buffer_store_char,  in handling SIGIO or SIGTINT.   If `waiting_for_input' is non zero, then unless `echoing' is nonzero,  immediately throw back to read_command_char.   Otherwise it sets the Lisp variable  quit-flag  not-nil.  This causes  eval  to throw, when it gets a chance.  If  quit-flag  is already non-nil, it stops the job right away.  */
end_comment

begin_macro
name|interrupt_signal
argument_list|()
end_macro

begin_block
block|{
name|char
name|c
decl_stmt|;
comment|/* Must preserve main program's value of errno.  */
name|int
name|old_errno
init|=
name|errno
decl_stmt|;
specifier|extern
name|Lisp_Object
name|Vwindow_system
decl_stmt|;
ifdef|#
directive|ifdef
name|USG
comment|/* USG systems forget handlers when they are used;      must reestablish each time */
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|interrupt_signal
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|interrupt_signal
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* USG */
name|cancel_echoing
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|Vquit_flag
argument_list|)
operator|&&
name|NULL
argument_list|(
name|Vwindow_system
argument_list|)
condition|)
block|{
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|reset_sys_modes
argument_list|()
expr_stmt|;
name|sigfree
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGTSTP
comment|/* Support possible in later USG versions */
comment|/*  * On systems which can suspend the current process and return to the original  * shell, this command causes the user to end up back at the shell.  * The "Auto-save" and "Abort" questions are not asked until  * the user elects to return to emacs, at which point he can save the current  * job and either dump core or continue.  */
name|sys_suspend
argument_list|()
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|VMS
if|if
condition|(
name|sys_suspend
argument_list|()
operator|==
operator|-
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"Not running as a subprocess;\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"you can continue or abort.\n"
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* not VMS */
comment|/* Perhaps should really fork an inferior shell? 	 But that would not provide any way to get back 	 to the original shell, ever.  */
name|printf
argument_list|(
literal|"No support for stopping a process on this operating system;\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"you can continue or abort.\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* not VMS */
endif|#
directive|endif
comment|/* not SIGTSTP */
name|printf
argument_list|(
literal|"Auto-save? (y or n) "
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|c
operator|=
name|getchar
argument_list|()
operator|)
operator|&
operator|~
literal|040
operator|)
operator|==
literal|'Y'
condition|)
name|Fdo_auto_save
argument_list|(
name|Qnil
argument_list|)
expr_stmt|;
while|while
condition|(
name|c
operator|!=
literal|'\n'
condition|)
name|c
operator|=
name|getchar
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|VMS
name|printf
argument_list|(
literal|"Abort (and enter debugger)? (y or n) "
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* not VMS */
name|printf
argument_list|(
literal|"Abort (and dump core)? (y or n) "
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* not VMS */
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|c
operator|=
name|getchar
argument_list|()
operator|)
operator|&
operator|~
literal|040
operator|)
operator|==
literal|'Y'
condition|)
name|abort
argument_list|()
expr_stmt|;
while|while
condition|(
name|c
operator|!=
literal|'\n'
condition|)
name|c
operator|=
name|getchar
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"Continuing...\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|init_sys_modes
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|/* If executing a function that wants to be interrupted out of 	     and the user has not deferred quitting by binding `inhibit-quit' 	     then quit right away.  */
if|if
condition|(
name|immediate_quit
operator|&&
name|NULL
argument_list|(
name|Vinhibit_quit
argument_list|)
condition|)
block|{
name|immediate_quit
operator|=
literal|0
expr_stmt|;
name|sigfree
argument_list|()
expr_stmt|;
name|Fsignal
argument_list|(
name|Qquit
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Else request quit when it's safe */
name|Vquit_flag
operator|=
name|Qt
expr_stmt|;
block|}
if|if
condition|(
name|waiting_for_input
operator|&&
operator|!
name|echoing
condition|)
name|quit_throw_to_read_command_char
argument_list|()
expr_stmt|;
name|errno
operator|=
name|old_errno
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Handle a C-g by making read_command_char return C-g.  */
end_comment

begin_macro
name|quit_throw_to_read_command_char
argument_list|()
end_macro

begin_block
block|{
name|quit_error_check
argument_list|()
expr_stmt|;
name|sigfree
argument_list|()
expr_stmt|;
comment|/* Prevent another signal from doing this before we finish.  */
name|waiting_for_input
operator|=
literal|0
expr_stmt|;
name|input_pending
operator|=
literal|0
expr_stmt|;
name|unread_command_char
operator|=
operator|-
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|POLL_FOR_INPUT
if|if
condition|(
name|poll_suppress_count
operator|!=
literal|1
condition|)
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|_longjmp
argument_list|(
name|getcjmp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_macro
name|DEFUN
argument_list|(
literal|"set-input-mode"
argument_list|,
argument|Fset_input_mode
argument_list|,
argument|Sset_input_mode
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|,
literal|"Set mode of reading keyboard input.\n\ First arg non-nil means use input interrupts; nil means use CBREAK mode.\n\ Second arg non-nil means use ^S/^Q flow control for output to terminal\n\  (no effect except in CBREAK mode).\n\ Optional third arg non-nil specifies character to use for quitting.\n\n\ Note that the arguments will change incompatibly in version 19."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|interrupt
operator|,
name|flow
operator|,
name|quit
operator|)
name|Lisp_Object
name|interrupt
operator|,
name|flow
operator|,
name|quit
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|reset_sys_modes
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGIO
comment|/* Note SIGIO has been undef'd if FIONREAD is missing.  */
ifdef|#
directive|ifdef
name|NO_SOCK_SIGIO
if|if
condition|(
name|read_socket_hook
condition|)
name|interrupt_input
operator|=
literal|0
expr_stmt|;
comment|/* No interrupts if reading from a socket.  */
else|else
endif|#
directive|endif
comment|/* NO_SOCK_SIGIO */
name|interrupt_input
operator|=
operator|!
name|NULL
argument_list|(
name|interrupt
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* not SIGIO */
name|interrupt_input
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* not SIGIO */
name|flow_control
operator|=
operator|!
name|NULL
argument_list|(
name|flow
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|quit
argument_list|)
condition|)
block|{
name|CHECK_NUMBER
argument_list|(
name|quit
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|quit_char
operator|=
name|XINT
argument_list|(
name|quit
argument_list|)
expr_stmt|;
comment|/* Don't let this value be out of range.  */
name|quit_char
operator|&=
operator|(
name|meta_key
condition|?
literal|0377
else|:
literal|0177
operator|)
expr_stmt|;
block|}
name|init_sys_modes
argument_list|()
expr_stmt|;
return|return
name|Qnil
return|;
block|}
end_block

begin_escape
end_escape

begin_macro
name|init_keyboard
argument_list|()
end_macro

begin_block
block|{
name|this_command_keys_size
operator|=
literal|40
expr_stmt|;
name|this_command_keys
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|40
argument_list|)
expr_stmt|;
name|command_loop_level
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Correct, before outermost invocation.  */
name|quit_char
operator|=
name|Ctl
argument_list|(
literal|'G'
argument_list|)
expr_stmt|;
name|immediate_quit
operator|=
literal|0
expr_stmt|;
name|unread_command_char
operator|=
operator|-
literal|1
expr_stmt|;
name|recent_keys_index
operator|=
literal|0
expr_stmt|;
name|total_keys
operator|=
literal|0
expr_stmt|;
name|kbd_count
operator|=
literal|0
expr_stmt|;
name|kbd_ptr
operator|=
name|kbd_buffer
expr_stmt|;
name|input_pending
operator|=
literal|0
expr_stmt|;
name|force_input
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|noninteractive
condition|)
block|{
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|interrupt_signal
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USG
comment|/* On USG systems, C-g is set up for both SIGINT and SIGQUIT 	 and we can't tell which one it will give us.  */
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|interrupt_signal
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* USG */
comment|/* Note SIGIO has been undef'd if FIONREAD is missing.  */
ifdef|#
directive|ifdef
name|SIGIO
name|signal
argument_list|(
name|SIGIO
argument_list|,
name|input_available_signal
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|SIGIO
block|}
comment|/* Use interrupt input by default, if it works and noninterrupt input    has deficiencies.  */
ifdef|#
directive|ifdef
name|INTERRUPT_INPUT
name|interrupt_input
operator|=
literal|1
expr_stmt|;
else|#
directive|else
name|interrupt_input
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|sigfree
argument_list|()
expr_stmt|;
name|dribble
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|keyboard_init_hook
condition|)
call|(
modifier|*
name|keyboard_init_hook
call|)
argument_list|()
expr_stmt|;
name|poll_suppress_count
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|POLL_FOR_INPUT
name|start_polling
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_macro
name|syms_of_keyboard
argument_list|()
end_macro

begin_block
block|{
name|Qself_insert_command
operator|=
name|intern
argument_list|(
literal|"self-insert-command"
argument_list|)
expr_stmt|;
name|staticpro
argument_list|(
operator|&
name|Qself_insert_command
argument_list|)
expr_stmt|;
name|Qforward_char
operator|=
name|intern
argument_list|(
literal|"forward-char"
argument_list|)
expr_stmt|;
name|staticpro
argument_list|(
operator|&
name|Qforward_char
argument_list|)
expr_stmt|;
name|Qbackward_char
operator|=
name|intern
argument_list|(
literal|"backward-char"
argument_list|)
expr_stmt|;
name|staticpro
argument_list|(
operator|&
name|Qbackward_char
argument_list|)
expr_stmt|;
name|Qtop_level
operator|=
name|intern
argument_list|(
literal|"top-level"
argument_list|)
expr_stmt|;
name|staticpro
argument_list|(
operator|&
name|Qtop_level
argument_list|)
expr_stmt|;
name|Qdisabled
operator|=
name|intern
argument_list|(
literal|"disabled"
argument_list|)
expr_stmt|;
name|staticpro
argument_list|(
operator|&
name|Qdisabled
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sread_key_sequence
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Srecursive_edit
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sinput_pending_p
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Scommand_execute
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Srecent_keys
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sthis_command_keys
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Ssuspend_emacs
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sabort_recursive_edit
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sexit_recursive_edit
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Srecursion_depth
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Stop_level
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sdiscard_input
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sopen_dribble_file
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sset_input_mode
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sexecute_extended_command
argument_list|)
expr_stmt|;
name|DEFVAR_LISP
argument_list|(
literal|"disabled-command-hook"
argument_list|,
operator|&
name|Vdisabled_command_hook
argument_list|,
literal|"Value is called instead of any command that is disabled\n\ \(has a non-nil  disabled  property)."
argument_list|)
expr_stmt|;
name|DEFVAR_BOOL
argument_list|(
literal|"meta-flag"
argument_list|,
operator|&
name|meta_key
argument_list|,
literal|"*Non-nil means treat 0200 bit in terminal input as Meta bit."
argument_list|)
expr_stmt|;
name|DEFVAR_INT
argument_list|(
literal|"last-command-char"
argument_list|,
operator|&
name|last_command_char
argument_list|,
literal|"Last terminal input character that was part of a command, as an integer."
argument_list|)
expr_stmt|;
name|DEFVAR_INT
argument_list|(
literal|"last-input-char"
argument_list|,
operator|&
name|last_input_char
argument_list|,
literal|"Last terminal input character, as an integer."
argument_list|)
expr_stmt|;
name|DEFVAR_INT
argument_list|(
literal|"unread-command-char"
argument_list|,
operator|&
name|unread_command_char
argument_list|,
literal|"Character to be read as next input from command input stream, or -1 if none."
argument_list|)
expr_stmt|;
name|DEFVAR_INT
argument_list|(
literal|"meta-prefix-char"
argument_list|,
operator|&
name|meta_prefix_char
argument_list|,
literal|"Meta-prefix character code.  Meta-foo as command input\n\ turns into this character followed by foo."
argument_list|)
expr_stmt|;
name|meta_prefix_char
operator|=
literal|033
expr_stmt|;
name|DEFVAR_LISP
argument_list|(
literal|"last-command"
argument_list|,
operator|&
name|last_command
argument_list|,
literal|"The last command executed.  Normally a symbol with a function definition,\n\ but can be whatever was found in the keymap, or whatever the variable\n\ `this-command' was set to by that command."
argument_list|)
expr_stmt|;
name|last_command
operator|=
name|Qnil
expr_stmt|;
name|DEFVAR_LISP
argument_list|(
literal|"this-command"
argument_list|,
operator|&
name|this_command
argument_list|,
literal|"The command now being executed.\n\ The command can set this variable; whatever is put here\n\ will be in  last-command  during the following command."
argument_list|)
expr_stmt|;
name|this_command
operator|=
name|Qnil
expr_stmt|;
name|DEFVAR_INT
argument_list|(
literal|"auto-save-interval"
argument_list|,
operator|&
name|auto_save_interval
argument_list|,
literal|"*Number of keyboard input characters between auto-saves.\n\ Zero means disable autosaving."
argument_list|)
expr_stmt|;
name|auto_save_interval
operator|=
literal|300
expr_stmt|;
name|DEFVAR_INT
argument_list|(
literal|"echo-keystrokes"
argument_list|,
operator|&
name|echo_keystrokes
argument_list|,
literal|"*Nonzero means echo unfinished commands after this many seconds of pause."
argument_list|)
expr_stmt|;
name|echo_keystrokes
operator|=
literal|1
expr_stmt|;
name|DEFVAR_INT
argument_list|(
literal|"polling-period"
argument_list|,
operator|&
name|polling_period
argument_list|,
literal|"*Interval between polling for input during Lisp execution.\n\ The reason for polling is to make C-g work to stop a running program.\n\ Polling is needed only when using X windows and SIGIO does not work.\n\ Polling is automatically disabled in all other cases."
argument_list|)
expr_stmt|;
name|polling_period
operator|=
literal|2
expr_stmt|;
name|DEFVAR_INT
argument_list|(
literal|"help-char"
argument_list|,
operator|&
name|help_char
argument_list|,
literal|"Character to recognize as meaning Help.\n\ When it is read, do (eval help-form), and display result if it's a string.\n\ If help-form's value is nil, this char can be read normally."
argument_list|)
expr_stmt|;
name|help_char
operator|=
name|Ctl
argument_list|(
literal|'H'
argument_list|)
expr_stmt|;
name|DEFVAR_LISP
argument_list|(
literal|"help-form"
argument_list|,
operator|&
name|Vhelp_form
argument_list|,
literal|"Form to execute when character help-char is read.\n\ If the form returns a string, that string is displayed.\n\ If help-form is nil, the help char is not recognized."
argument_list|)
expr_stmt|;
name|Vhelp_form
operator|=
name|Qnil
expr_stmt|;
name|DEFVAR_LISP
argument_list|(
literal|"top-level"
argument_list|,
operator|&
name|Vtop_level
argument_list|,
literal|"Form to evaluate when Emacs starts up.\n\ Useful to set before you dump a modified Emacs."
argument_list|)
expr_stmt|;
name|Vtop_level
operator|=
name|Qnil
expr_stmt|;
name|DEFVAR_LISP
argument_list|(
literal|"keyboard-translate-table"
argument_list|,
operator|&
name|Vkeyboard_translate_table
argument_list|,
literal|"String used as translate table for keyboard input, or nil.\n\ Each character is looked up in this string and the contents used instead.\n\ If string is of length N, character codes N and up are untranslated."
argument_list|)
expr_stmt|;
name|Vkeyboard_translate_table
operator|=
name|Qnil
expr_stmt|;
block|}
end_block

begin_macro
name|keys_of_keyboard
argument_list|()
end_macro

begin_block
block|{
name|ndefkey
argument_list|(
name|Vglobal_map
argument_list|,
name|Ctl
argument_list|(
literal|'Z'
argument_list|)
argument_list|,
literal|"suspend-emacs"
argument_list|)
expr_stmt|;
name|ndefkey
argument_list|(
name|Vctl_x_map
argument_list|,
name|Ctl
argument_list|(
literal|'Z'
argument_list|)
argument_list|,
literal|"suspend-emacs"
argument_list|)
expr_stmt|;
name|ndefkey
argument_list|(
name|Vesc_map
argument_list|,
name|Ctl
argument_list|(
literal|'C'
argument_list|)
argument_list|,
literal|"exit-recursive-edit"
argument_list|)
expr_stmt|;
name|ndefkey
argument_list|(
name|Vglobal_map
argument_list|,
name|Ctl
argument_list|(
literal|']'
argument_list|)
argument_list|,
literal|"abort-recursive-edit"
argument_list|)
expr_stmt|;
name|ndefkey
argument_list|(
name|Vesc_map
argument_list|,
literal|'x'
argument_list|,
literal|"execute-extended-command"
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

