begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* String search routines for GNU Emacs.    Copyright (C) 1985, 1986, 1987 Free Software Foundation, Inc.  This file is part of GNU Emacs.  GNU Emacs is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version.  GNU Emacs is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU Emacs; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"lisp.h"
end_include

begin_include
include|#
directive|include
file|"syntax.h"
end_include

begin_include
include|#
directive|include
file|"buffer.h"
end_include

begin_include
include|#
directive|include
file|"commands.h"
end_include

begin_include
include|#
directive|include
file|"regex.h"
end_include

begin_define
define|#
directive|define
name|max
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)> (b) ? (a) : (b))
end_define

begin_define
define|#
directive|define
name|min
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)< (b) ? (a) : (b))
end_define

begin_decl_stmt
name|unsigned
name|char
name|downcase_table
index|[
literal|01000
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* folds upper to lower case */
end_comment

begin_comment
comment|/* A WHEEL WILL FALL OFF IF, IN A trt, CHARACTER A */
end_comment

begin_comment
comment|/* TRANSLATES INTO CHARACTER B AND CHARACTER B DOES NOT */
end_comment

begin_comment
comment|/* ALSO TRANSLATE INTO CHARACTER B. */
end_comment

begin_comment
comment|/* If that constraint is met, compute_trt_inverse will follow a */
end_comment

begin_comment
comment|/* translation table with its inverse.  The inverse of a table */
end_comment

begin_comment
comment|/* follows the table at table[0400].  The form of this is that if */
end_comment

begin_comment
comment|/* table[a]=b then the chain starting at table[0400+b], linked by */
end_comment

begin_comment
comment|/* link(x)=table[0400+x] and ended by b must include a. */
end_comment

begin_comment
comment|/* At present compute_trt_inverse is blinded and the inverse for this */
end_comment

begin_comment
comment|/* particular table is created by a single-purpose loop. */
end_comment

begin_comment
comment|/* compute_trt_inverse has been tested on the following cases: */
end_comment

begin_comment
comment|/* trt[x]=x, trt[x]=(+ 3 (logand x, 0370)), trt[x]='a', and the */
end_comment

begin_comment
comment|/* downcase table. */
end_comment

begin_comment
comment|/* We compile regexps into this buffer and then use it for searching. */
end_comment

begin_decl_stmt
name|struct
name|re_pattern_buffer
name|searchbuf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|search_fastmap
index|[
literal|0400
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Last regexp we compiled */
end_comment

begin_decl_stmt
name|Lisp_Object
name|last_regexp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Every call to re_match, etc., must pass&search_regs as the regs argument  unless you can show it is unnecessary (i.e., if re_match is certainly going  to be called again before region-around-match can be called).  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|re_registers
name|search_regs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* error condition signalled when regexp compile_pattern fails */
end_comment

begin_decl_stmt
name|Lisp_Object
name|Qinvalid_regexp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Compile a regexp and signal a Lisp error if anything goes wrong.  */
end_comment

begin_macro
name|compile_pattern
argument_list|(
argument|pattern
argument_list|,
argument|bufp
argument_list|,
argument|translate
argument_list|)
end_macro

begin_decl_stmt
name|Lisp_Object
name|pattern
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|re_pattern_buffer
modifier|*
name|bufp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|translate
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|val
decl_stmt|;
name|Lisp_Object
name|dummy
decl_stmt|;
if|if
condition|(
name|EQ
argument_list|(
name|pattern
argument_list|,
name|last_regexp
argument_list|)
operator|&&
name|translate
operator|==
name|bufp
operator|->
name|translate
condition|)
return|return;
name|last_regexp
operator|=
name|Qnil
expr_stmt|;
name|bufp
operator|->
name|translate
operator|=
name|translate
expr_stmt|;
name|val
operator|=
name|re_compile_pattern
argument_list|(
name|XSTRING
argument_list|(
name|pattern
argument_list|)
operator|->
name|data
argument_list|,
name|XSTRING
argument_list|(
name|pattern
argument_list|)
operator|->
name|size
argument_list|,
name|bufp
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
condition|)
block|{
name|dummy
operator|=
name|build_string
argument_list|(
name|val
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
name|Fsignal
argument_list|(
name|Qinvalid_regexp
argument_list|,
name|Fcons
argument_list|(
name|dummy
argument_list|,
name|Qnil
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|last_regexp
operator|=
name|pattern
expr_stmt|;
return|return;
block|}
end_block

begin_comment
comment|/* Error condition used for failing searches */
end_comment

begin_decl_stmt
name|Lisp_Object
name|Qsearch_failed
decl_stmt|;
end_decl_stmt

begin_function
name|Lisp_Object
name|signal_failure
parameter_list|(
name|arg
parameter_list|)
name|Lisp_Object
name|arg
decl_stmt|;
block|{
name|Fsignal
argument_list|(
name|Qsearch_failed
argument_list|,
name|Fcons
argument_list|(
name|arg
argument_list|,
name|Qnil
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|Qnil
return|;
block|}
end_function

begin_escape
end_escape

begin_macro
name|DEFUN
argument_list|(
literal|"looking-at"
argument_list|,
argument|Flooking_at
argument_list|,
argument|Slooking_at
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"t if text after point matches regular expression PAT."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|string
operator|)
name|Lisp_Object
name|string
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|Lisp_Object
name|val
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
name|int
name|s1
decl_stmt|,
name|s2
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|CHECK_STRING
argument_list|(
name|string
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|compile_pattern
argument_list|(
name|string
argument_list|,
operator|&
name|searchbuf
argument_list|,
operator|!
name|NULL
argument_list|(
name|current_buffer
operator|->
name|case_fold_search
argument_list|)
condition|?
operator|(
name|char
operator|*
operator|)
name|downcase_table
else|:
literal|0
argument_list|)
expr_stmt|;
name|immediate_quit
operator|=
literal|1
expr_stmt|;
name|QUIT
expr_stmt|;
comment|/* Do a pending quit right away, to avoid paradoxical behavior */
comment|/* Get pointers and sizes of the two strings      that make up the visible portion of the buffer. */
name|p1
operator|=
name|BEGV_ADDR
expr_stmt|;
name|s1
operator|=
name|GPT
operator|-
name|BEGV
expr_stmt|;
name|p2
operator|=
name|GAP_END_ADDR
expr_stmt|;
name|s2
operator|=
name|ZV
operator|-
name|GPT
expr_stmt|;
if|if
condition|(
name|s1
operator|<
literal|0
condition|)
block|{
name|p2
operator|=
name|p1
expr_stmt|;
name|s2
operator|=
name|ZV
operator|-
name|BEGV
expr_stmt|;
name|s1
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|s2
operator|<
literal|0
condition|)
block|{
name|s1
operator|=
name|ZV
operator|-
name|BEGV
expr_stmt|;
name|s2
operator|=
literal|0
expr_stmt|;
block|}
name|val
operator|=
operator|(
literal|0
operator|<=
name|re_match_2
argument_list|(
operator|&
name|searchbuf
argument_list|,
name|p1
argument_list|,
name|s1
argument_list|,
name|p2
argument_list|,
name|s2
argument_list|,
name|point
operator|-
name|BEGV
argument_list|,
operator|&
name|search_regs
argument_list|,
name|ZV
operator|-
name|BEGV
argument_list|)
condition|?
name|Qt
else|:
name|Qnil
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RE_NREGS
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|search_regs
operator|.
name|start
index|[
name|i
index|]
operator|>=
literal|0
condition|)
block|{
name|search_regs
operator|.
name|start
index|[
name|i
index|]
operator|+=
name|BEGV
expr_stmt|;
name|search_regs
operator|.
name|end
index|[
name|i
index|]
operator|+=
name|BEGV
expr_stmt|;
block|}
name|immediate_quit
operator|=
literal|0
expr_stmt|;
return|return
name|val
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"string-match"
argument_list|,
argument|Fstring_match
argument_list|,
argument|Sstring_match
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|,
literal|"Return index of start of first match for REGEXP in STRING, or nil.\n\ If third arg START is non-nil, start search at that index in STRING.\n\ For index of first char beyond the match, do (match-end 0).\n\ match-end and match-beginning also give indices of substrings\n\ matched by parenthesis constructs in the pattern."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|regexp
operator|,
name|string
operator|,
name|start
operator|)
name|Lisp_Object
name|regexp
operator|,
name|string
operator|,
name|start
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|int
name|val
decl_stmt|;
name|int
name|s
decl_stmt|;
name|CHECK_STRING
argument_list|(
name|regexp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK_STRING
argument_list|(
name|string
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|start
argument_list|)
condition|)
name|s
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|int
name|len
init|=
name|XSTRING
argument_list|(
name|string
argument_list|)
operator|->
name|size
decl_stmt|;
name|CHECK_NUMBER
argument_list|(
name|start
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|s
operator|=
name|XINT
argument_list|(
name|start
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|<
literal|0
operator|&&
operator|-
name|s
operator|<=
name|len
condition|)
name|s
operator|=
name|len
operator|-
name|s
expr_stmt|;
elseif|else
if|if
condition|(
literal|0
operator|>
name|s
operator|||
name|s
operator|>
name|len
condition|)
name|args_out_of_range
argument_list|(
name|string
argument_list|,
name|start
argument_list|)
expr_stmt|;
block|}
name|compile_pattern
argument_list|(
name|regexp
argument_list|,
operator|&
name|searchbuf
argument_list|,
operator|!
name|NULL
argument_list|(
name|current_buffer
operator|->
name|case_fold_search
argument_list|)
condition|?
operator|(
name|char
operator|*
operator|)
name|downcase_table
else|:
literal|0
argument_list|)
expr_stmt|;
name|immediate_quit
operator|=
literal|1
expr_stmt|;
name|val
operator|=
name|re_search
argument_list|(
operator|&
name|searchbuf
argument_list|,
name|XSTRING
argument_list|(
name|string
argument_list|)
operator|->
name|data
argument_list|,
name|XSTRING
argument_list|(
name|string
argument_list|)
operator|->
name|size
argument_list|,
name|s
argument_list|,
name|XSTRING
argument_list|(
name|string
argument_list|)
operator|->
name|size
operator|-
name|s
argument_list|,
operator|&
name|search_regs
argument_list|)
expr_stmt|;
name|immediate_quit
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|val
operator|<
literal|0
condition|)
return|return
name|Qnil
return|;
return|return
name|make_number
argument_list|(
name|val
argument_list|)
return|;
block|}
end_block

begin_escape
end_escape

begin_macro
name|scan_buffer
argument_list|(
argument|target
argument_list|,
argument|pos
argument_list|,
argument|cnt
argument_list|,
argument|shortage
argument_list|)
end_macro

begin_decl_stmt
name|int
modifier|*
name|shortage
decl_stmt|,
name|pos
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|int
name|cnt
decl_stmt|,
name|target
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|lim
init|=
operator|(
operator|(
name|cnt
operator|>
literal|0
operator|)
condition|?
name|ZV
operator|-
literal|1
else|:
name|BEGV
operator|)
decl_stmt|;
name|int
name|direction
init|=
operator|(
operator|(
name|cnt
operator|>
literal|0
operator|)
condition|?
literal|1
else|:
operator|-
literal|1
operator|)
decl_stmt|;
specifier|register
name|int
name|lim0
decl_stmt|;
name|unsigned
name|char
modifier|*
name|base
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|cursor
decl_stmt|,
modifier|*
name|limit
decl_stmt|;
if|if
condition|(
name|shortage
operator|!=
literal|0
condition|)
operator|*
name|shortage
operator|=
literal|0
expr_stmt|;
name|immediate_quit
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|cnt
operator|>
literal|0
condition|)
while|while
condition|(
name|pos
operator|!=
name|lim
operator|+
literal|1
condition|)
block|{
name|lim0
operator|=
name|BufferSafeCeiling
argument_list|(
name|pos
argument_list|)
expr_stmt|;
name|lim0
operator|=
name|min
argument_list|(
name|lim
argument_list|,
name|lim0
argument_list|)
expr_stmt|;
name|limit
operator|=
operator|&
name|FETCH_CHAR
argument_list|(
name|lim0
argument_list|)
operator|+
literal|1
expr_stmt|;
name|base
operator|=
operator|(
name|cursor
operator|=
operator|&
name|FETCH_CHAR
argument_list|(
name|pos
argument_list|)
operator|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
while|while
condition|(
operator|*
name|cursor
operator|!=
name|target
operator|&&
operator|++
name|cursor
operator|!=
name|limit
condition|)
empty_stmt|;
if|if
condition|(
name|cursor
operator|!=
name|limit
condition|)
block|{
if|if
condition|(
operator|--
name|cnt
operator|==
literal|0
condition|)
block|{
name|immediate_quit
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|pos
operator|+
name|cursor
operator|-
name|base
operator|+
literal|1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|++
name|cursor
operator|==
name|limit
condition|)
break|break;
block|}
else|else
break|break;
block|}
name|pos
operator|+=
name|cursor
operator|-
name|base
expr_stmt|;
block|}
else|else
block|{
name|pos
operator|--
expr_stmt|;
comment|/* first character we scan */
while|while
condition|(
name|pos
operator|>
name|lim
operator|-
literal|1
condition|)
block|{
comment|/* we WILL scan under pos */
name|lim0
operator|=
name|BufferSafeFloor
argument_list|(
name|pos
argument_list|)
expr_stmt|;
name|lim0
operator|=
name|max
argument_list|(
name|lim
argument_list|,
name|lim0
argument_list|)
expr_stmt|;
name|limit
operator|=
operator|&
name|FETCH_CHAR
argument_list|(
name|lim0
argument_list|)
operator|-
literal|1
expr_stmt|;
name|base
operator|=
operator|(
name|cursor
operator|=
operator|&
name|FETCH_CHAR
argument_list|(
name|pos
argument_list|)
operator|)
expr_stmt|;
name|cursor
operator|++
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
while|while
condition|(
operator|--
name|cursor
operator|!=
name|limit
operator|&&
operator|*
name|cursor
operator|!=
name|target
condition|)
empty_stmt|;
if|if
condition|(
name|cursor
operator|!=
name|limit
condition|)
block|{
if|if
condition|(
operator|++
name|cnt
operator|==
literal|0
condition|)
block|{
name|immediate_quit
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|pos
operator|+
name|cursor
operator|-
name|base
operator|+
literal|1
operator|)
return|;
block|}
block|}
else|else
break|break;
block|}
name|pos
operator|+=
name|cursor
operator|-
name|base
expr_stmt|;
block|}
block|}
name|immediate_quit
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|shortage
operator|!=
literal|0
condition|)
operator|*
name|shortage
operator|=
name|cnt
operator|*
name|direction
expr_stmt|;
return|return
operator|(
name|pos
operator|+
operator|(
operator|(
name|direction
operator|==
literal|1
condition|?
literal|0
else|:
literal|1
operator|)
operator|)
operator|)
return|;
block|}
end_block

begin_function
name|int
name|find_next_newline
parameter_list|(
name|from
parameter_list|,
name|cnt
parameter_list|)
specifier|register
name|int
name|from
decl_stmt|,
name|cnt
decl_stmt|;
block|{
return|return
operator|(
name|scan_buffer
argument_list|(
literal|'\n'
argument_list|,
name|from
argument_list|,
name|cnt
argument_list|,
operator|(
name|int
operator|*
operator|)
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_macro
name|DEFUN
argument_list|(
literal|"skip-chars-forward"
argument_list|,
argument|Fskip_chars_forward
argument_list|,
argument|Sskip_chars_forward
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"Move point forward, stopping before a char not in CHARS, or at position LIM.\n\ CHARS is like the inside of a [...] in a regular expression\n\ except that ] is never special and \\ quotes ^, - or \\.\n\ Thus, with arg \"a-zA-Z\", this skips letters stopping before first nonletter.\n\ With arg \"^a-zA-Z\", skips nonletters stopping before first letter."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|string
operator|,
name|lim
operator|)
name|Lisp_Object
name|string
operator|,
name|lim
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|skip_chars
argument_list|(
literal|1
argument_list|,
name|string
argument_list|,
name|lim
argument_list|)
expr_stmt|;
return|return
name|Qnil
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"skip-chars-backward"
argument_list|,
argument|Fskip_chars_backward
argument_list|,
argument|Sskip_chars_backward
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"Move point backward, stopping after a char not in CHARS, or at position LIM.\n\ See skip-chars-forward for details."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|string
operator|,
name|lim
operator|)
name|Lisp_Object
name|string
operator|,
name|lim
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|skip_chars
argument_list|(
literal|0
argument_list|,
name|string
argument_list|,
name|lim
argument_list|)
expr_stmt|;
return|return
name|Qnil
return|;
block|}
end_block

begin_macro
name|skip_chars
argument_list|(
argument|forwardp
argument_list|,
argument|string
argument_list|,
argument|lim
argument_list|)
end_macro

begin_decl_stmt
name|int
name|forwardp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Lisp_Object
name|string
decl_stmt|,
name|lim
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|unsigned
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|pend
decl_stmt|;
specifier|register
name|unsigned
name|char
name|c
decl_stmt|;
name|unsigned
name|char
name|fastmap
index|[
literal|0400
index|]
decl_stmt|;
name|int
name|negate
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|CHECK_STRING
argument_list|(
name|string
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|lim
argument_list|)
condition|)
name|XFASTINT
argument_list|(
name|lim
argument_list|)
operator|=
name|forwardp
condition|?
name|ZV
else|:
name|BEGV
expr_stmt|;
else|else
name|CHECK_NUMBER_COERCE_MARKER
argument_list|(
name|lim
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* In any case, don't allow scan outside bounds of buffer.  */
if|if
condition|(
name|XFASTINT
argument_list|(
name|lim
argument_list|)
operator|>
name|ZV
condition|)
name|XFASTINT
argument_list|(
name|lim
argument_list|)
operator|=
name|ZV
expr_stmt|;
if|if
condition|(
name|XFASTINT
argument_list|(
name|lim
argument_list|)
operator|<
name|BEGV
condition|)
name|XFASTINT
argument_list|(
name|lim
argument_list|)
operator|=
name|BEGV
expr_stmt|;
name|p
operator|=
name|XSTRING
argument_list|(
name|string
argument_list|)
operator|->
name|data
expr_stmt|;
name|pend
operator|=
name|p
operator|+
name|XSTRING
argument_list|(
name|string
argument_list|)
operator|->
name|size
expr_stmt|;
name|bzero
argument_list|(
name|fastmap
argument_list|,
sizeof|sizeof
name|fastmap
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|pend
operator|&&
operator|*
name|p
operator|==
literal|'^'
condition|)
block|{
name|negate
operator|=
literal|1
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
comment|/* Find the characters specified and set their elements of fastmap.  */
while|while
condition|(
name|p
operator|!=
name|pend
condition|)
block|{
name|c
operator|=
operator|*
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
if|if
condition|(
name|p
operator|==
name|pend
condition|)
break|break;
name|c
operator|=
operator|*
name|p
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|!=
name|pend
operator|&&
operator|*
name|p
operator|==
literal|'-'
condition|)
block|{
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|pend
condition|)
break|break;
while|while
condition|(
name|c
operator|<=
operator|*
name|p
condition|)
block|{
name|fastmap
index|[
name|c
index|]
operator|=
literal|1
expr_stmt|;
name|c
operator|++
expr_stmt|;
block|}
name|p
operator|++
expr_stmt|;
block|}
else|else
name|fastmap
index|[
name|c
index|]
operator|=
literal|1
expr_stmt|;
block|}
comment|/* If ^ was the first character, complement the fastmap. */
if|if
condition|(
name|negate
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
name|fastmap
condition|;
name|i
operator|++
control|)
name|fastmap
index|[
name|i
index|]
operator|^=
literal|1
expr_stmt|;
name|immediate_quit
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|forwardp
condition|)
block|{
while|while
condition|(
name|point
operator|<
name|XINT
argument_list|(
name|lim
argument_list|)
operator|&&
name|fastmap
index|[
name|FETCH_CHAR
argument_list|(
name|point
argument_list|)
index|]
condition|)
name|SET_PT
argument_list|(
name|point
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|point
operator|>
name|XINT
argument_list|(
name|lim
argument_list|)
operator|&&
name|fastmap
index|[
name|FETCH_CHAR
argument_list|(
name|point
operator|-
literal|1
argument_list|)
index|]
condition|)
name|SET_PT
argument_list|(
name|point
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|immediate_quit
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Subroutines of Lisp buffer search functions. */
end_comment

begin_function
specifier|static
name|Lisp_Object
name|search_command
parameter_list|(
name|string
parameter_list|,
name|bound
parameter_list|,
name|noerror
parameter_list|,
name|count
parameter_list|,
name|direction
parameter_list|,
name|RE
parameter_list|)
name|Lisp_Object
name|string
decl_stmt|,
name|bound
decl_stmt|,
name|noerror
decl_stmt|,
name|count
decl_stmt|;
name|int
name|direction
decl_stmt|;
name|int
name|RE
decl_stmt|;
block|{
specifier|register
name|int
name|np
decl_stmt|;
name|int
name|lim
decl_stmt|;
name|int
name|n
init|=
name|direction
decl_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|count
argument_list|)
condition|)
block|{
name|CHECK_NUMBER
argument_list|(
name|count
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|n
operator|*=
name|XINT
argument_list|(
name|count
argument_list|)
expr_stmt|;
block|}
name|CHECK_STRING
argument_list|(
name|string
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|bound
argument_list|)
condition|)
name|lim
operator|=
name|n
operator|>
literal|0
condition|?
name|ZV
else|:
name|BEGV
expr_stmt|;
else|else
block|{
name|CHECK_NUMBER_COERCE_MARKER
argument_list|(
name|bound
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|lim
operator|=
name|XINT
argument_list|(
name|bound
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>
literal|0
condition|?
name|lim
operator|<
name|point
else|:
name|lim
operator|>
name|point
condition|)
name|error
argument_list|(
literal|"Invalid search bound (wrong side of point)"
argument_list|)
expr_stmt|;
if|if
condition|(
name|lim
operator|>
name|ZV
condition|)
name|lim
operator|=
name|ZV
expr_stmt|;
if|if
condition|(
name|lim
operator|<
name|BEGV
condition|)
name|lim
operator|=
name|BEGV
expr_stmt|;
block|}
name|np
operator|=
name|search_buffer
argument_list|(
name|string
argument_list|,
name|point
argument_list|,
name|lim
argument_list|,
name|n
argument_list|,
name|RE
argument_list|,
operator|!
name|NULL
argument_list|(
name|current_buffer
operator|->
name|case_fold_search
argument_list|)
condition|?
name|downcase_table
else|:
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|NULL
argument_list|(
name|noerror
argument_list|)
condition|)
return|return
name|signal_failure
argument_list|(
name|string
argument_list|)
return|;
if|if
condition|(
operator|!
name|EQ
argument_list|(
name|noerror
argument_list|,
name|Qt
argument_list|)
condition|)
block|{
if|if
condition|(
name|lim
operator|<
name|BEGV
operator|||
name|lim
operator|>
name|ZV
condition|)
name|abort
argument_list|()
expr_stmt|;
name|SET_PT
argument_list|(
name|lim
argument_list|)
expr_stmt|;
block|}
return|return
name|Qnil
return|;
block|}
if|if
condition|(
name|np
operator|<
name|BEGV
operator|||
name|np
operator|>
name|ZV
condition|)
name|abort
argument_list|()
expr_stmt|;
name|SET_PT
argument_list|(
name|np
argument_list|)
expr_stmt|;
return|return
name|Qt
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* search for the n'th occurrence of `string' in the current buffer,    starting at position `from' and stopping at position `lim',    treating `pat' as a literal string if `RE' is false or as    a regular expression if `RE' is true.     If `n' is positive, searching is forward and `lim' must be greater than `from'.    If `n' is negative, searching is backward and `lim' must be less than `from'.     Returns -x if only `n'-x occurrences found (x> 0),    or else the position at the beginning of the `n'th occurrence (if searching backward)    or the end (if searching forward).  */
end_comment

begin_comment
comment|/* INTERFACE CHANGE ALERT!!!!  search_buffer now returns -x if only */
end_comment

begin_comment
comment|/* n-x occurences are found. */
end_comment

begin_macro
name|search_buffer
argument_list|(
argument|string
argument_list|,
argument|pos
argument_list|,
argument|lim
argument_list|,
argument|n
argument_list|,
argument|RE
argument_list|,
argument|trt
argument_list|)
end_macro

begin_decl_stmt
name|Lisp_Object
name|string
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|pos
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|lim
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|RE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|unsigned
name|char
modifier|*
name|trt
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|len
init|=
name|XSTRING
argument_list|(
name|string
argument_list|)
operator|->
name|size
decl_stmt|;
name|unsigned
name|char
modifier|*
name|base_pat
init|=
name|XSTRING
argument_list|(
name|string
argument_list|)
operator|->
name|data
decl_stmt|;
specifier|register
name|int
modifier|*
name|BM_tab
decl_stmt|;
name|int
modifier|*
name|BM_tab_base
decl_stmt|;
specifier|register
name|int
name|direction
init|=
operator|(
operator|(
name|n
operator|>
literal|0
operator|)
condition|?
literal|1
else|:
operator|-
literal|1
operator|)
decl_stmt|;
specifier|register
name|int
name|dirlen
decl_stmt|;
name|int
name|infinity
decl_stmt|,
name|limit
decl_stmt|,
name|k
decl_stmt|,
name|stride_for_teases
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|pat
decl_stmt|,
modifier|*
name|cursor
decl_stmt|,
modifier|*
name|p_limit
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
name|int
name|s1
decl_stmt|,
name|s2
decl_stmt|;
if|if
condition|(
operator|!
name|len
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|RE
condition|)
name|compile_pattern
argument_list|(
name|string
argument_list|,
operator|&
name|searchbuf
argument_list|,
operator|(
name|char
operator|*
operator|)
name|trt
argument_list|)
expr_stmt|;
if|if
condition|(
name|RE
comment|/* Here we detect whether the */
comment|/* generality of an RE search is */
comment|/* really needed. */
operator|&&
operator|*
operator|(
name|searchbuf
operator|.
name|buffer
operator|)
operator|==
operator|(
name|char
operator|)
name|exactn
comment|/* first item is "exact match" */
operator|&&
name|searchbuf
operator|.
name|buffer
index|[
literal|1
index|]
operator|+
literal|2
operator|==
name|searchbuf
operator|.
name|used
condition|)
comment|/*first is ONLY item */
block|{
name|RE
operator|=
literal|0
expr_stmt|;
comment|/* can do straight (non RE) search */
name|pat
operator|=
operator|(
name|base_pat
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|searchbuf
operator|.
name|buffer
operator|+
literal|2
operator|)
expr_stmt|;
comment|/* trt already applied */
name|len
operator|=
name|searchbuf
operator|.
name|used
operator|-
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|RE
condition|)
block|{
name|pat
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|len
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|len
init|;
name|i
operator|--
condition|;
control|)
comment|/* Copy the pattern; apply trt */
operator|*
name|pat
operator|++
operator|=
operator|(
operator|(
operator|(
name|int
operator|)
name|trt
operator|)
condition|?
name|trt
index|[
operator|*
name|base_pat
operator|++
index|]
else|:
operator|*
name|base_pat
operator|++
operator|)
expr_stmt|;
name|pat
operator|-=
name|len
expr_stmt|;
name|base_pat
operator|=
name|pat
expr_stmt|;
block|}
if|if
condition|(
name|RE
condition|)
block|{
name|immediate_quit
operator|=
literal|1
expr_stmt|;
comment|/* Quit immediately if user types ^G, 				   because letting this function finish 				   can take too long. */
name|QUIT
expr_stmt|;
comment|/* Do a pending quit right away, 				   to avoid paradoxical behavior */
comment|/* Get pointers and sizes of the two strings 	 that make up the visible portion of the buffer. */
name|p1
operator|=
name|BEGV_ADDR
expr_stmt|;
name|s1
operator|=
name|GPT
operator|-
name|BEGV
expr_stmt|;
name|p2
operator|=
name|GAP_END_ADDR
expr_stmt|;
name|s2
operator|=
name|ZV
operator|-
name|GPT
expr_stmt|;
if|if
condition|(
name|s1
operator|<
literal|0
condition|)
block|{
name|p2
operator|=
name|p1
expr_stmt|;
name|s2
operator|=
name|ZV
operator|-
name|BEGV
expr_stmt|;
name|s1
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|s2
operator|<
literal|0
condition|)
block|{
name|s1
operator|=
name|ZV
operator|-
name|BEGV
expr_stmt|;
name|s2
operator|=
literal|0
expr_stmt|;
block|}
while|while
condition|(
name|n
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|re_search_2
argument_list|(
operator|&
name|searchbuf
argument_list|,
name|p1
argument_list|,
name|s1
argument_list|,
name|p2
argument_list|,
name|s2
argument_list|,
name|pos
operator|-
name|BEGV
argument_list|,
name|lim
operator|-
name|pos
argument_list|,
operator|&
name|search_regs
argument_list|,
comment|/* Don't allow match past current point */
name|pos
operator|-
name|BEGV
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|j
operator|=
name|BEGV
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RE_NREGS
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|search_regs
operator|.
name|start
index|[
name|i
index|]
operator|>=
literal|0
condition|)
block|{
name|search_regs
operator|.
name|start
index|[
name|i
index|]
operator|+=
name|j
expr_stmt|;
name|search_regs
operator|.
name|end
index|[
name|i
index|]
operator|+=
name|j
expr_stmt|;
block|}
comment|/* Set pos to the new position. */
name|pos
operator|=
name|search_regs
operator|.
name|start
index|[
literal|0
index|]
expr_stmt|;
block|}
else|else
block|{
name|immediate_quit
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|n
operator|)
return|;
block|}
name|n
operator|++
expr_stmt|;
block|}
while|while
condition|(
name|n
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|re_search_2
argument_list|(
operator|&
name|searchbuf
argument_list|,
name|p1
argument_list|,
name|s1
argument_list|,
name|p2
argument_list|,
name|s2
argument_list|,
name|pos
operator|-
name|BEGV
argument_list|,
name|lim
operator|-
name|pos
argument_list|,
operator|&
name|search_regs
argument_list|,
name|lim
operator|-
name|BEGV
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|j
operator|=
name|BEGV
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RE_NREGS
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|search_regs
operator|.
name|start
index|[
name|i
index|]
operator|>=
literal|0
condition|)
block|{
name|search_regs
operator|.
name|start
index|[
name|i
index|]
operator|+=
name|j
expr_stmt|;
name|search_regs
operator|.
name|end
index|[
name|i
index|]
operator|+=
name|j
expr_stmt|;
block|}
name|pos
operator|=
name|search_regs
operator|.
name|end
index|[
literal|0
index|]
expr_stmt|;
block|}
else|else
block|{
name|immediate_quit
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|-
name|n
operator|)
return|;
block|}
name|n
operator|--
expr_stmt|;
block|}
name|immediate_quit
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|pos
operator|)
return|;
block|}
else|else
comment|/* non-RE case */
block|{
ifdef|#
directive|ifdef
name|C_ALLOCA
name|int
name|BM_tab_space
index|[
literal|0400
index|]
decl_stmt|;
name|BM_tab
operator|=
operator|&
name|BM_tab_space
index|[
literal|0
index|]
expr_stmt|;
else|#
directive|else
name|BM_tab
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
literal|0400
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* The general approach is that we are going to maintain that we know */
comment|/* the first (closest to the present position, in whatever direction */
comment|/* we're searching) character that could possibly be the last */
comment|/* (furthest from present position) character of a valid match.  We */
comment|/* advance the state of our knowledge by looking at that character */
comment|/* and seeing whether it indeed matches the last character of the */
comment|/* pattern.  If it does, we take a closer look.  If it does not, we */
comment|/* move our pointer (to putative last characters) as far as is */
comment|/* logically possible.  This amount of movement, which I call a */
comment|/* stride, will be the length of the pattern if the actual character */
comment|/* appears nowhere in the pattern, otherwise it will be the distance */
comment|/* from the last occurrence of that character to the end of the */
comment|/* pattern. */
comment|/* As a coding trick, an enormous stride is coded into the table for */
comment|/* characters that match the last character.  This allows use of only */
comment|/* a single test, a test for having gone past the end of the */
comment|/* permissible match region, to test for both possible matches (when */
comment|/* the stride goes past the end immediately) and failure to */
comment|/* match (where you get nudged past the end one stride at a time). */
comment|/* Here we make a "mickey mouse" BM table.  The stride of the search */
comment|/* is determined only by the last character of the putative match. */
comment|/* If that character does not match, we will stride the proper */
comment|/* distance to propose a match that superimposes it on the last */
comment|/* instance of a character that matches it (per trt), or misses */
comment|/* it entirely if there is none. */
name|dirlen
operator|=
name|len
operator|*
name|direction
expr_stmt|;
name|infinity
operator|=
name|dirlen
operator|-
operator|(
name|lim
operator|+
name|pos
operator|+
name|len
operator|+
name|len
operator|)
operator|*
name|direction
expr_stmt|;
if|if
condition|(
name|direction
operator|<
literal|0
condition|)
name|pat
operator|=
operator|(
name|base_pat
operator|+=
name|len
operator|-
literal|1
operator|)
expr_stmt|;
name|BM_tab_base
operator|=
name|BM_tab
expr_stmt|;
name|BM_tab
operator|+=
literal|0400
expr_stmt|;
name|j
operator|=
name|dirlen
expr_stmt|;
comment|/* to get it in a register */
comment|/* A character that does not appear in the pattern induces a */
comment|/* stride equal to the pattern length. */
while|while
condition|(
name|BM_tab_base
operator|!=
name|BM_tab
condition|)
block|{
operator|*
operator|--
name|BM_tab
operator|=
name|j
expr_stmt|;
operator|*
operator|--
name|BM_tab
operator|=
name|j
expr_stmt|;
operator|*
operator|--
name|BM_tab
operator|=
name|j
expr_stmt|;
operator|*
operator|--
name|BM_tab
operator|=
name|j
expr_stmt|;
block|}
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|!=
name|infinity
condition|)
block|{
name|j
operator|=
name|pat
index|[
name|i
index|]
expr_stmt|;
name|i
operator|+=
name|direction
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|dirlen
condition|)
name|i
operator|=
name|infinity
expr_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|trt
condition|)
block|{
name|k
operator|=
operator|(
name|j
operator|=
name|trt
index|[
name|j
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|infinity
condition|)
name|stride_for_teases
operator|=
name|BM_tab
index|[
name|j
index|]
expr_stmt|;
name|BM_tab
index|[
name|j
index|]
operator|=
name|dirlen
operator|-
name|i
expr_stmt|;
comment|/* A translation table is followed by its inverse -- see */
comment|/* comment following downcase_table for details */
while|while
condition|(
operator|(
name|j
operator|=
name|trt
index|[
literal|0400
operator|+
name|j
index|]
operator|)
operator|!=
name|k
condition|)
name|BM_tab
index|[
name|j
index|]
operator|=
name|dirlen
operator|-
name|i
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|i
operator|==
name|infinity
condition|)
name|stride_for_teases
operator|=
name|BM_tab
index|[
name|j
index|]
expr_stmt|;
name|BM_tab
index|[
name|j
index|]
operator|=
name|dirlen
operator|-
name|i
expr_stmt|;
block|}
comment|/* stride_for_teases tells how much to stride if we get a */
comment|/* match on the far character but are subsequently */
comment|/* disappointed, by recording what the stride would have been */
comment|/* for that character if the last character had been */
comment|/* different. */
block|}
name|infinity
operator|=
name|dirlen
operator|-
name|infinity
expr_stmt|;
name|pos
operator|+=
name|dirlen
operator|-
operator|(
operator|(
name|direction
operator|>
literal|0
operator|)
condition|?
name|direction
else|:
literal|0
operator|)
expr_stmt|;
comment|/* loop invariant - pos points at where last char (first char if reverse) 	 of pattern would align in a possible match.  */
while|while
condition|(
name|n
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|lim
operator|-
name|pos
operator|-
operator|(
name|direction
operator|>
literal|0
operator|)
operator|)
operator|*
name|direction
operator|<
literal|0
condition|)
return|return
operator|(
name|n
operator|*
operator|(
literal|0
operator|-
name|direction
operator|)
operator|)
return|;
comment|/* First we do the part we can by pointers (maybe nothing) */
name|QUIT
expr_stmt|;
name|pat
operator|=
name|base_pat
expr_stmt|;
name|limit
operator|=
name|pos
operator|-
name|dirlen
operator|+
name|direction
expr_stmt|;
name|limit
operator|=
operator|(
operator|(
name|direction
operator|>
literal|0
operator|)
condition|?
name|BufferSafeCeiling
argument_list|(
name|limit
argument_list|)
else|:
name|BufferSafeFloor
argument_list|(
name|limit
argument_list|)
operator|)
expr_stmt|;
comment|/* LIMIT is now the last (not beyond-last!) value 	     POS can take on without hitting edge of buffer or the gap.  */
name|limit
operator|=
operator|(
operator|(
name|direction
operator|>
literal|0
operator|)
condition|?
name|min
argument_list|(
name|lim
operator|-
literal|1
argument_list|,
name|min
argument_list|(
name|limit
argument_list|,
name|pos
operator|+
literal|20000
argument_list|)
argument_list|)
else|:
name|max
argument_list|(
name|lim
argument_list|,
name|max
argument_list|(
name|limit
argument_list|,
name|pos
operator|-
literal|20000
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|limit
operator|-
name|pos
operator|)
operator|*
name|direction
operator|>
literal|20
condition|)
block|{
name|p_limit
operator|=
operator|&
name|FETCH_CHAR
argument_list|(
name|limit
argument_list|)
expr_stmt|;
name|p2
operator|=
operator|(
name|cursor
operator|=
operator|&
name|FETCH_CHAR
argument_list|(
name|pos
argument_list|)
operator|)
expr_stmt|;
comment|/* In this loop, pos + cursor - p2 is the surrogate for pos */
while|while
condition|(
literal|1
condition|)
comment|/* use one cursor setting as long as i can */
block|{
if|if
condition|(
name|direction
operator|>
literal|0
condition|)
comment|/* worth duplicating */
block|{
comment|/* Use signed comparison if appropriate 			 to make cursor+infinity sure to be> p_limit. 			 Assuming that the buffer lies in a range of addresses 			 that are all "positive" (as ints) or all "negative", 			 either kind of comparison will work as long 			 as we don't step by infinity.  So pick the kind 			 that works when we do step by infinity.  */
if|if
condition|(
call|(
name|int
call|)
argument_list|(
name|p_limit
operator|+
name|infinity
argument_list|)
operator|>
operator|(
name|int
operator|)
name|p_limit
condition|)
while|while
condition|(
operator|(
name|int
operator|)
name|cursor
operator|<=
operator|(
name|int
operator|)
name|p_limit
condition|)
name|cursor
operator|+=
name|BM_tab
index|[
operator|*
name|cursor
index|]
expr_stmt|;
else|else
while|while
condition|(
operator|(
name|unsigned
name|int
operator|)
name|cursor
operator|<=
operator|(
name|unsigned
name|int
operator|)
name|p_limit
condition|)
name|cursor
operator|+=
name|BM_tab
index|[
operator|*
name|cursor
index|]
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
call|(
name|int
call|)
argument_list|(
name|p_limit
operator|+
name|infinity
argument_list|)
operator|<
operator|(
name|int
operator|)
name|p_limit
condition|)
while|while
condition|(
operator|(
name|int
operator|)
name|cursor
operator|>=
operator|(
name|int
operator|)
name|p_limit
condition|)
name|cursor
operator|+=
name|BM_tab
index|[
operator|*
name|cursor
index|]
expr_stmt|;
else|else
while|while
condition|(
operator|(
name|unsigned
name|int
operator|)
name|cursor
operator|>=
operator|(
name|unsigned
name|int
operator|)
name|p_limit
condition|)
name|cursor
operator|+=
name|BM_tab
index|[
operator|*
name|cursor
index|]
expr_stmt|;
block|}
comment|/* If you are here, cursor is beyond the end of the searched region. */
comment|/* This can happen if you match on the far character of the pattern, */
comment|/* because the "stride" of that character is infinity, a number able */
comment|/* to throw you well beyond the end of the search.  It can also */
comment|/* happen if you fail to match within the permitted region and would */
comment|/* otherwise try a character beyond that region */
if|if
condition|(
operator|(
name|cursor
operator|-
name|p_limit
operator|)
operator|*
name|direction
operator|<=
name|len
condition|)
break|break;
comment|/* a small overrun is genuine */
name|cursor
operator|-=
name|infinity
expr_stmt|;
comment|/* large overrun = hit */
name|i
operator|=
name|dirlen
operator|-
name|direction
expr_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|trt
condition|)
block|{
while|while
condition|(
operator|(
name|i
operator|-=
name|direction
operator|)
operator|+
name|direction
operator|!=
literal|0
condition|)
if|if
condition|(
name|pat
index|[
name|i
index|]
operator|!=
name|trt
index|[
operator|*
operator|(
name|cursor
operator|-=
name|direction
operator|)
index|]
condition|)
break|break;
block|}
else|else
block|{
while|while
condition|(
operator|(
name|i
operator|-=
name|direction
operator|)
operator|+
name|direction
operator|!=
literal|0
condition|)
if|if
condition|(
name|pat
index|[
name|i
index|]
operator|!=
operator|*
operator|(
name|cursor
operator|-=
name|direction
operator|)
condition|)
break|break;
block|}
name|cursor
operator|+=
name|dirlen
operator|-
name|i
operator|-
name|direction
expr_stmt|;
comment|/* fix cursor */
if|if
condition|(
name|i
operator|+
name|direction
operator|==
literal|0
condition|)
block|{
name|cursor
operator|-=
name|direction
expr_stmt|;
name|search_regs
operator|.
name|start
index|[
literal|0
index|]
operator|=
name|pos
operator|+
name|cursor
operator|-
name|p2
operator|+
operator|(
operator|(
name|direction
operator|>
literal|0
operator|)
condition|?
literal|1
operator|-
name|len
else|:
literal|0
operator|)
expr_stmt|;
name|search_regs
operator|.
name|end
index|[
literal|0
index|]
operator|=
name|len
operator|+
name|search_regs
operator|.
name|start
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|-=
name|direction
operator|)
operator|!=
literal|0
condition|)
name|cursor
operator|+=
name|dirlen
expr_stmt|;
comment|/* to resume search */
else|else
return|return
operator|(
operator|(
name|direction
operator|>
literal|0
operator|)
condition|?
name|search_regs
operator|.
name|end
index|[
literal|0
index|]
else|:
name|search_regs
operator|.
name|start
index|[
literal|0
index|]
operator|)
return|;
block|}
else|else
name|cursor
operator|+=
name|stride_for_teases
expr_stmt|;
comment|/*<sigh> we lose -  */
block|}
name|pos
operator|+=
name|cursor
operator|-
name|p2
expr_stmt|;
block|}
else|else
comment|/* Now we'll pick up a clump that has to be done the hard */
comment|/* way because it covers a discontinuity */
block|{
name|limit
operator|=
operator|(
operator|(
name|direction
operator|>
literal|0
operator|)
condition|?
name|BufferSafeCeiling
argument_list|(
name|pos
operator|-
name|dirlen
operator|+
literal|1
argument_list|)
else|:
name|BufferSafeFloor
argument_list|(
name|pos
operator|-
name|dirlen
operator|-
literal|1
argument_list|)
operator|)
expr_stmt|;
name|limit
operator|=
operator|(
operator|(
name|direction
operator|>
literal|0
operator|)
condition|?
name|min
argument_list|(
name|limit
operator|+
name|len
argument_list|,
name|lim
operator|-
literal|1
argument_list|)
else|:
name|max
argument_list|(
name|limit
operator|-
name|len
argument_list|,
name|lim
argument_list|)
operator|)
expr_stmt|;
comment|/* LIMIT is now the last value POS can have 		 and still be valid for a possible match.  */
while|while
condition|(
literal|1
condition|)
block|{
comment|/* This loop can be coded for space rather than */
comment|/* speed because it will usually run only once. */
comment|/* (the reach is at most len + 21, and typically */
comment|/* does not exceed len) */
while|while
condition|(
operator|(
name|limit
operator|-
name|pos
operator|)
operator|*
name|direction
operator|>=
literal|0
condition|)
name|pos
operator|+=
name|BM_tab
index|[
name|FETCH_CHAR
argument_list|(
name|pos
argument_list|)
index|]
expr_stmt|;
comment|/* now run the same tests to distinguish going off the */
comment|/* end, a match or a phoney match. */
if|if
condition|(
operator|(
name|pos
operator|-
name|limit
operator|)
operator|*
name|direction
operator|<=
name|len
condition|)
break|break;
comment|/* ran off the end */
comment|/* Found what might be a match. 		     Set POS back to last (first if reverse) char pos.  */
name|pos
operator|-=
name|infinity
expr_stmt|;
name|i
operator|=
name|dirlen
operator|-
name|direction
expr_stmt|;
while|while
condition|(
operator|(
name|i
operator|-=
name|direction
operator|)
operator|+
name|direction
operator|!=
literal|0
condition|)
block|{
name|pos
operator|-=
name|direction
expr_stmt|;
if|if
condition|(
name|pat
index|[
name|i
index|]
operator|!=
operator|(
operator|(
operator|(
name|int
operator|)
name|trt
operator|)
condition|?
name|trt
index|[
name|FETCH_CHAR
argument_list|(
name|pos
argument_list|)
index|]
else|:
name|FETCH_CHAR
argument_list|(
name|pos
argument_list|)
operator|)
condition|)
break|break;
block|}
comment|/* Above loop has moved POS part or all the way 		     back to the first char pos (last char pos if reverse). 		     Set it once again at the last (first if reverse) char.  */
name|pos
operator|+=
name|dirlen
operator|-
name|i
operator|-
name|direction
expr_stmt|;
if|if
condition|(
name|i
operator|+
name|direction
operator|==
literal|0
condition|)
block|{
name|pos
operator|-=
name|direction
expr_stmt|;
name|search_regs
operator|.
name|start
index|[
literal|0
index|]
operator|=
name|pos
operator|+
operator|(
operator|(
name|direction
operator|>
literal|0
operator|)
condition|?
literal|1
operator|-
name|len
else|:
literal|0
operator|)
expr_stmt|;
name|search_regs
operator|.
name|end
index|[
literal|0
index|]
operator|=
name|len
operator|+
name|search_regs
operator|.
name|start
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|-=
name|direction
operator|)
operator|!=
literal|0
condition|)
name|pos
operator|+=
name|dirlen
expr_stmt|;
comment|/* to resume search */
else|else
return|return
operator|(
operator|(
name|direction
operator|>
literal|0
operator|)
condition|?
name|search_regs
operator|.
name|end
index|[
literal|0
index|]
else|:
name|search_regs
operator|.
name|start
index|[
literal|0
index|]
operator|)
return|;
block|}
else|else
name|pos
operator|+=
name|stride_for_teases
expr_stmt|;
block|}
block|}
comment|/* We have done one clump.  Can we continue? */
if|if
condition|(
operator|(
name|lim
operator|-
name|pos
operator|)
operator|*
name|direction
operator|<
literal|0
condition|)
return|return
operator|(
operator|(
literal|0
operator|-
name|n
operator|)
operator|*
name|direction
operator|)
return|;
block|}
return|return
name|pos
return|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Given a string of words separated by word delimiters,   compute a regexp that matches those exact words   separated by arbitrary punctuation.  */
end_comment

begin_function
specifier|static
name|Lisp_Object
name|wordify
parameter_list|(
name|string
parameter_list|)
name|Lisp_Object
name|string
decl_stmt|;
block|{
specifier|register
name|unsigned
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|o
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|len
decl_stmt|,
name|punct_count
init|=
literal|0
decl_stmt|,
name|word_count
init|=
literal|0
decl_stmt|;
name|Lisp_Object
name|val
decl_stmt|;
name|CHECK_STRING
argument_list|(
name|string
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|p
operator|=
name|XSTRING
argument_list|(
name|string
argument_list|)
operator|->
name|data
expr_stmt|;
name|len
operator|=
name|XSTRING
argument_list|(
name|string
argument_list|)
operator|->
name|size
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|SYNTAX
argument_list|(
name|p
index|[
name|i
index|]
argument_list|)
operator|!=
name|Sword
condition|)
block|{
name|punct_count
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
operator|&&
name|SYNTAX
argument_list|(
name|p
index|[
name|i
operator|-
literal|1
index|]
argument_list|)
operator|==
name|Sword
condition|)
name|word_count
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|SYNTAX
argument_list|(
name|p
index|[
name|len
operator|-
literal|1
index|]
argument_list|)
operator|==
name|Sword
condition|)
name|word_count
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|word_count
condition|)
return|return
name|build_string
argument_list|(
literal|""
argument_list|)
return|;
name|val
operator|=
name|make_string
argument_list|(
name|p
argument_list|,
name|len
operator|-
name|punct_count
operator|+
literal|5
operator|*
operator|(
name|word_count
operator|-
literal|1
operator|)
operator|+
literal|4
argument_list|)
expr_stmt|;
name|o
operator|=
name|XSTRING
argument_list|(
name|val
argument_list|)
operator|->
name|data
expr_stmt|;
operator|*
name|o
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|o
operator|++
operator|=
literal|'b'
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|SYNTAX
argument_list|(
name|p
index|[
name|i
index|]
argument_list|)
operator|==
name|Sword
condition|)
operator|*
name|o
operator|++
operator|=
name|p
index|[
name|i
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|>
literal|0
operator|&&
name|SYNTAX
argument_list|(
name|p
index|[
name|i
operator|-
literal|1
index|]
argument_list|)
operator|==
name|Sword
operator|&&
operator|--
name|word_count
condition|)
block|{
operator|*
name|o
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|o
operator|++
operator|=
literal|'W'
expr_stmt|;
operator|*
name|o
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|o
operator|++
operator|=
literal|'W'
expr_stmt|;
operator|*
name|o
operator|++
operator|=
literal|'*'
expr_stmt|;
block|}
operator|*
name|o
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|o
operator|++
operator|=
literal|'b'
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_escape
end_escape

begin_macro
name|DEFUN
argument_list|(
literal|"search-backward"
argument_list|,
argument|Fsearch_backward
argument_list|,
argument|Ssearch_backward
argument_list|,
literal|1
argument_list|,
literal|4
argument_list|,
literal|"sSearch backward: "
argument_list|,
literal|"Search backward from point for STRING.\n\ Set point to the beginning of the occurrence found, and return t.\n\ An optional second argument bounds the search; it is a buffer position.\n\ The match found must not extend before that position.\n\ Optional third argument, if t, means if fail just return nil (no error).\n\  If not nil and not t, position at limit of search and return nil.\n\ Optional fourth argument is repeat count--search for successive occurrences."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|string
operator|,
name|bound
operator|,
name|noerror
operator|,
name|count
operator|)
name|Lisp_Object
name|string
operator|,
name|bound
operator|,
name|noerror
operator|,
name|count
expr_stmt|;
end_expr_stmt

begin_block
block|{
return|return
name|search_command
argument_list|(
name|string
argument_list|,
name|bound
argument_list|,
name|noerror
argument_list|,
name|count
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"search-forward"
argument_list|,
argument|Fsearch_forward
argument_list|,
argument|Ssearch_forward
argument_list|,
literal|1
argument_list|,
literal|4
argument_list|,
literal|"sSearch: "
argument_list|,
literal|"Search forward from point for STRING.\n\ Set point to the end of the occurrence found, and return t.\n\ An optional second argument bounds the search; it is a buffer position.\n\ The match found must not extend after that position.\n\ Optional third argument, if t, means if fail just return nil (no error).\n\   If not nil and not t, move to limit of search and return nil.\n\ Optional fourth argument is repeat count--search for successive occurrences."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|string
operator|,
name|bound
operator|,
name|noerror
operator|,
name|count
operator|)
name|Lisp_Object
name|string
operator|,
name|bound
operator|,
name|noerror
operator|,
name|count
expr_stmt|;
end_expr_stmt

begin_block
block|{
return|return
name|search_command
argument_list|(
name|string
argument_list|,
name|bound
argument_list|,
name|noerror
argument_list|,
name|count
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"word-search-backward"
argument_list|,
argument|Fword_search_backward
argument_list|,
argument|Sword_search_backward
argument_list|,
literal|1
argument_list|,
literal|4
argument_list|,
literal|"sWord search backward: "
argument_list|,
literal|"Search backward from point for STRING, ignoring differences in punctuation.\n\ Set point to the beginning of the occurrence found, and return t.\n\ An optional second argument bounds the search; it is a buffer position.\n\ The match found must not extend before that position.\n\ Optional third argument, if t, means if fail just return nil (no error).\n\   If not nil and not t, move to limit of search and return nil.\n\ Optional fourth argument is repeat count--search for successive occurrences."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|string
operator|,
name|bound
operator|,
name|noerror
operator|,
name|count
operator|)
name|Lisp_Object
name|string
operator|,
name|bound
operator|,
name|noerror
operator|,
name|count
expr_stmt|;
end_expr_stmt

begin_block
block|{
return|return
name|search_command
argument_list|(
name|wordify
argument_list|(
name|string
argument_list|)
argument_list|,
name|bound
argument_list|,
name|noerror
argument_list|,
name|count
argument_list|,
operator|-
literal|1
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"word-search-forward"
argument_list|,
argument|Fword_search_forward
argument_list|,
argument|Sword_search_forward
argument_list|,
literal|1
argument_list|,
literal|4
argument_list|,
literal|"sWord search: "
argument_list|,
literal|"Search forward from point for STRING, ignoring differences in punctuation.\n\ Set point to the end of the occurrence found, and return t.\n\ An optional second argument bounds the search; it is a buffer position.\n\ The match found must not extend after that position.\n\ Optional third argument, if t, means if fail just return nil (no error).\n\   If not nil and not t, move to limit of search and return nil.\n\ Optional fourth argument is repeat count--search for successive occurrences."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|string
operator|,
name|bound
operator|,
name|noerror
operator|,
name|count
operator|)
name|Lisp_Object
name|string
operator|,
name|bound
operator|,
name|noerror
operator|,
name|count
expr_stmt|;
end_expr_stmt

begin_block
block|{
return|return
name|search_command
argument_list|(
name|wordify
argument_list|(
name|string
argument_list|)
argument_list|,
name|bound
argument_list|,
name|noerror
argument_list|,
name|count
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"re-search-backward"
argument_list|,
argument|Fre_search_backward
argument_list|,
argument|Sre_search_backward
argument_list|,
literal|1
argument_list|,
literal|4
argument_list|,
literal|"sRE search backward: "
argument_list|,
literal|"Search backward from point for match for regular expression REGEXP.\n\ Set point to the beginning of the match, and return t.\n\ The match found is the one starting last in the buffer\n\ and yet ending before the place the origin of the search.\n\ An optional second argument bounds the search; it is a buffer position.\n\ The match found must start at or after that position.\n\ Optional third argument, if t, means if fail just return nil (no error).\n\   If not nil and not t, move to limit of search and return nil.\n\ Optional fourth argument is repeat count--search for successive occurrences.\n\ See also the functions match-beginning and match-end and replace-match."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|string
operator|,
name|bound
operator|,
name|noerror
operator|,
name|count
operator|)
name|Lisp_Object
name|string
operator|,
name|bound
operator|,
name|noerror
operator|,
name|count
expr_stmt|;
end_expr_stmt

begin_block
block|{
return|return
name|search_command
argument_list|(
name|string
argument_list|,
name|bound
argument_list|,
name|noerror
argument_list|,
name|count
argument_list|,
operator|-
literal|1
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"re-search-forward"
argument_list|,
argument|Fre_search_forward
argument_list|,
argument|Sre_search_forward
argument_list|,
literal|1
argument_list|,
literal|4
argument_list|,
literal|"sRE search: "
argument_list|,
literal|"Search forward from point for regular expression REGEXP.\n\ Set point to the end of the occurrence found, and return t.\n\ An optional second argument bounds the search; it is a buffer position.\n\ The match found must not extend after that position.\n\ Optional third argument, if t, means if fail just return nil (no error).\n\   If not nil and not t, move to limit of search and return nil.\n\ Optional fourth argument is repeat count--search for successive occurrences.\n\ See also the functions match-beginning and match-end and replace-match."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|string
operator|,
name|bound
operator|,
name|noerror
operator|,
name|count
operator|)
name|Lisp_Object
name|string
operator|,
name|bound
operator|,
name|noerror
operator|,
name|count
expr_stmt|;
end_expr_stmt

begin_block
block|{
return|return
name|search_command
argument_list|(
name|string
argument_list|,
name|bound
argument_list|,
name|noerror
argument_list|,
name|count
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_block

begin_escape
end_escape

begin_macro
name|DEFUN
argument_list|(
literal|"replace-match"
argument_list|,
argument|Freplace_match
argument_list|,
argument|Sreplace_match
argument_list|,
literal|1
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|,
literal|"Replace text matched by last search with NEWTEXT.\n\ If second arg FIXEDCASE is non-nil, do not alter case of replacement text.\n\ Otherwise convert to all caps or cap initials, like replaced text.\n\ If third arg LITERAL is non-nil, insert NEWTEXT literally.\n\ Otherwise treat \\ as special:\n\   \\& in NEWTEXT means substitute original matched text,\n\   \\N means substitute match for \\(...\\) number N,\n\   \\\\ means insert one \\.\n\ Leaves point at end of replacement text."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|string
operator|,
name|fixedcase
operator|,
name|literal
operator|)
name|Lisp_Object
name|string
operator|,
name|fixedcase
operator|,
name|literal
expr_stmt|;
end_expr_stmt

begin_block
block|{
enum|enum
block|{
name|nochange
block|,
name|all_caps
block|,
name|cap_initial
block|}
name|case_action
enum|;
specifier|register
name|int
name|pos
decl_stmt|,
name|last
decl_stmt|;
name|int
name|some_multiletter_word
decl_stmt|;
name|int
name|some_letter
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|,
name|prevc
decl_stmt|;
name|int
name|inslen
decl_stmt|;
name|CHECK_STRING
argument_list|(
name|string
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|case_action
operator|=
name|nochange
expr_stmt|;
comment|/* We tried an initialization */
comment|/* but some C compilers blew it */
if|if
condition|(
name|search_regs
operator|.
name|start
index|[
literal|0
index|]
operator|<
name|BEGV
operator|||
name|search_regs
operator|.
name|start
index|[
literal|0
index|]
operator|>
name|search_regs
operator|.
name|end
index|[
literal|0
index|]
operator|||
name|search_regs
operator|.
name|end
index|[
literal|0
index|]
operator|>
name|ZV
condition|)
name|args_out_of_range
argument_list|(
name|make_number
argument_list|(
name|search_regs
operator|.
name|start
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|make_number
argument_list|(
name|search_regs
operator|.
name|end
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|fixedcase
argument_list|)
condition|)
block|{
comment|/* Decide how to casify by examining the matched text. */
name|last
operator|=
name|search_regs
operator|.
name|end
index|[
literal|0
index|]
expr_stmt|;
name|prevc
operator|=
literal|'\n'
expr_stmt|;
name|case_action
operator|=
name|all_caps
expr_stmt|;
comment|/* some_multiletter_word is set nonzero if any original word 	 is more than one letter long. */
name|some_multiletter_word
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|pos
operator|=
name|search_regs
operator|.
name|start
index|[
literal|0
index|]
init|;
name|pos
operator|<
name|last
condition|;
name|pos
operator|++
control|)
block|{
name|c
operator|=
name|FETCH_CHAR
argument_list|(
name|pos
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOWERCASEP
argument_list|(
name|c
argument_list|)
condition|)
block|{
comment|/* Cannot be all caps if any original char is lower case */
name|case_action
operator|=
name|cap_initial
expr_stmt|;
if|if
condition|(
name|SYNTAX
argument_list|(
name|prevc
argument_list|)
operator|!=
name|Sword
condition|)
block|{
comment|/* Cannot even be cap initials 		     if some original initial is lower case */
name|case_action
operator|=
name|nochange
expr_stmt|;
break|break;
block|}
else|else
name|some_multiletter_word
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|NOCASEP
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|some_letter
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|some_multiletter_word
operator|&&
name|SYNTAX
argument_list|(
name|prevc
argument_list|)
operator|==
name|Sword
condition|)
name|some_multiletter_word
operator|=
literal|1
expr_stmt|;
block|}
name|prevc
operator|=
name|c
expr_stmt|;
block|}
comment|/* Do not make new text all caps 	 if the original text contained only single letter words. */
if|if
condition|(
name|case_action
operator|==
name|all_caps
operator|&&
operator|!
name|some_multiletter_word
condition|)
name|case_action
operator|=
name|cap_initial
expr_stmt|;
if|if
condition|(
operator|!
name|some_letter
condition|)
name|case_action
operator|=
name|nochange
expr_stmt|;
block|}
name|SET_PT
argument_list|(
name|search_regs
operator|.
name|end
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|literal
argument_list|)
condition|)
name|Finsert
argument_list|(
literal|1
argument_list|,
operator|&
name|string
argument_list|)
expr_stmt|;
else|else
block|{
name|struct
name|gcpro
name|gcpro1
decl_stmt|;
name|GCPRO1
argument_list|(
name|string
argument_list|)
expr_stmt|;
for|for
control|(
name|pos
operator|=
literal|0
init|;
name|pos
operator|<
name|XSTRING
argument_list|(
name|string
argument_list|)
operator|->
name|size
condition|;
name|pos
operator|++
control|)
block|{
name|c
operator|=
name|XSTRING
argument_list|(
name|string
argument_list|)
operator|->
name|data
index|[
name|pos
index|]
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
name|c
operator|=
name|XSTRING
argument_list|(
name|string
argument_list|)
operator|->
name|data
index|[
operator|++
name|pos
index|]
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'&'
condition|)
name|Finsert_buffer_substring
argument_list|(
name|Fcurrent_buffer
argument_list|()
argument_list|,
name|make_number
argument_list|(
name|search_regs
operator|.
name|start
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|make_number
argument_list|(
name|search_regs
operator|.
name|end
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|>=
literal|'1'
operator|&&
name|c
operator|<=
name|RE_NREGS
operator|+
literal|'0'
condition|)
block|{
if|if
condition|(
name|search_regs
operator|.
name|start
index|[
name|c
operator|-
literal|'0'
index|]
operator|>=
literal|1
condition|)
name|Finsert_buffer_substring
argument_list|(
name|Fcurrent_buffer
argument_list|()
argument_list|,
name|make_number
argument_list|(
name|search_regs
operator|.
name|start
index|[
name|c
operator|-
literal|'0'
index|]
argument_list|)
argument_list|,
name|make_number
argument_list|(
name|search_regs
operator|.
name|end
index|[
name|c
operator|-
literal|'0'
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|insert_char
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
else|else
name|insert_char
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
name|UNGCPRO
expr_stmt|;
block|}
name|inslen
operator|=
name|point
operator|-
operator|(
name|search_regs
operator|.
name|end
index|[
literal|0
index|]
operator|)
expr_stmt|;
name|del_range
argument_list|(
name|search_regs
operator|.
name|start
index|[
literal|0
index|]
argument_list|,
name|search_regs
operator|.
name|end
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|case_action
operator|==
name|all_caps
condition|)
name|Fupcase_region
argument_list|(
name|make_number
argument_list|(
name|point
operator|-
name|inslen
argument_list|)
argument_list|,
name|make_number
argument_list|(
name|point
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|case_action
operator|==
name|cap_initial
condition|)
name|upcase_initials_region
argument_list|(
name|make_number
argument_list|(
name|point
operator|-
name|inslen
argument_list|)
argument_list|,
name|make_number
argument_list|(
name|point
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|Qnil
return|;
block|}
end_block

begin_escape
end_escape

begin_function
specifier|static
name|Lisp_Object
name|match_limit
parameter_list|(
name|num
parameter_list|,
name|beginningp
parameter_list|)
name|Lisp_Object
name|num
decl_stmt|;
name|int
name|beginningp
decl_stmt|;
block|{
specifier|register
name|int
name|n
decl_stmt|;
name|CHECK_NUMBER
argument_list|(
name|num
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|n
operator|=
name|XINT
argument_list|(
name|num
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
operator|||
name|n
operator|>=
name|RE_NREGS
condition|)
name|args_out_of_range
argument_list|(
name|num
argument_list|,
name|make_number
argument_list|(
name|RE_NREGS
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|search_regs
operator|.
name|start
index|[
name|n
index|]
operator|<
literal|0
condition|)
return|return
name|Qnil
return|;
return|return
operator|(
name|make_number
argument_list|(
operator|(
name|beginningp
operator|)
condition|?
name|search_regs
operator|.
name|start
index|[
name|n
index|]
else|:
name|search_regs
operator|.
name|end
index|[
name|n
index|]
argument_list|)
operator|)
return|;
block|}
end_function

begin_macro
name|DEFUN
argument_list|(
literal|"match-beginning"
argument_list|,
argument|Fmatch_beginning
argument_list|,
argument|Smatch_beginning
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Return the character number of start of text matched by last regexp searched for.\n\ ARG, a number, specifies which parenthesized expression in the last regexp.\n\  Value is nil if ARGth pair didn't match, or there were less than ARG pairs.\n\ Zero means the entire text matched by the whole regexp."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|num
operator|)
name|Lisp_Object
name|num
expr_stmt|;
end_expr_stmt

begin_block
block|{
return|return
name|match_limit
argument_list|(
name|num
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"match-end"
argument_list|,
argument|Fmatch_end
argument_list|,
argument|Smatch_end
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Return the character number of end of text matched by last regexp searched for.\n\ ARG, a number, specifies which parenthesized expression in the last regexp.\n\  Value is nil if ARGth pair didn't match, or there were less than ARG pairs.\n\ Zero means the entire text matched by the whole regexp."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|num
operator|)
name|Lisp_Object
name|num
expr_stmt|;
end_expr_stmt

begin_block
block|{
return|return
name|match_limit
argument_list|(
name|num
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"match-data"
argument_list|,
argument|Fmatch_data
argument_list|,
argument|Smatch_data
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Return list containing all info on what the last search matched.\n\ Element 2N is (match-beginning N); element 2N + 1 is (match-end N).\n\ All the elements are normally markers, or nil if the Nth pair didn't match.\n\ 0 is also possible, when matching was done with `string-match',\n\ if a match began at index 0 in the string."
argument_list|)
end_macro

begin_expr_stmt
operator|(
operator|)
block|{
name|Lisp_Object
name|data
index|[
literal|2
operator|*
name|RE_NREGS
index|]
block|;
name|int
name|i
block|,
name|len
block|;
name|len
operator|=
operator|-
literal|1
block|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RE_NREGS
condition|;
name|i
operator|++
control|)
block|{
name|int
name|start
init|=
name|search_regs
operator|.
name|start
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|start
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|start
operator|==
literal|0
condition|)
name|data
index|[
literal|2
operator|*
name|i
index|]
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|data
index|[
literal|2
operator|*
name|i
index|]
operator|=
name|Fmake_marker
argument_list|()
expr_stmt|;
name|Fset_marker
argument_list|(
name|data
index|[
literal|2
operator|*
name|i
index|]
argument_list|,
name|make_number
argument_list|(
name|start
argument_list|)
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_if
if|if
condition|(
name|search_regs
operator|.
name|end
index|[
name|i
index|]
operator|==
literal|0
condition|)
name|data
index|[
literal|2
operator|*
name|i
operator|+
literal|1
index|]
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|data
index|[
literal|2
operator|*
name|i
operator|+
literal|1
index|]
operator|=
name|Fmake_marker
argument_list|()
expr_stmt|;
name|Fset_marker
argument_list|(
name|data
index|[
literal|2
operator|*
name|i
operator|+
literal|1
index|]
argument_list|,
name|make_number
argument_list|(
name|search_regs
operator|.
name|end
index|[
name|i
index|]
argument_list|)
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
block|}
end_if

begin_expr_stmt
name|len
operator|=
name|i
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|}       else
name|data
index|[
literal|2
operator|*
name|i
index|]
operator|=
name|data
index|[
literal|2
operator|*
name|i
operator|+
literal|1
index|]
operator|=
name|Qnil
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|}   return
name|Flist
argument_list|(
literal|2
operator|*
name|len
operator|+
literal|2
argument_list|,
name|data
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|}   DEFUN
operator|(
literal|"store-match-data"
operator|,
name|Fstore_match_data
operator|,
name|Sstore_match_data
operator|,
literal|1
operator|,
literal|1
operator|,
literal|0
operator|,
literal|"Set internal data on last search match from elements of LIST.\n\ LIST should have been created by calling match-data previously."
operator|)
operator|(
name|list
operator|)
specifier|register
name|Lisp_Object
name|list
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|Lisp_Object
name|marker
decl_stmt|;
if|if
condition|(
operator|!
name|CONSP
argument_list|(
name|list
argument_list|)
operator|&&
operator|!
name|NULL
argument_list|(
name|list
argument_list|)
condition|)
name|list
operator|=
name|wrong_type_argument
argument_list|(
name|Qconsp
argument_list|,
name|list
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RE_NREGS
condition|;
name|i
operator|++
control|)
block|{
name|marker
operator|=
name|Fcar
argument_list|(
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|marker
argument_list|)
condition|)
block|{
name|search_regs
operator|.
name|start
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|list
operator|=
name|Fcdr
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|XTYPE
argument_list|(
name|marker
argument_list|)
operator|==
name|Lisp_Marker
operator|&&
name|XMARKER
argument_list|(
name|marker
argument_list|)
operator|->
name|buffer
operator|==
literal|0
condition|)
name|XFASTINT
argument_list|(
name|marker
argument_list|)
operator|=
literal|0
expr_stmt|;
name|CHECK_NUMBER_COERCE_MARKER
argument_list|(
name|marker
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|search_regs
operator|.
name|start
index|[
name|i
index|]
operator|=
name|XINT
argument_list|(
name|marker
argument_list|)
expr_stmt|;
name|list
operator|=
name|Fcdr
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|marker
operator|=
name|Fcar
argument_list|(
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
name|XTYPE
argument_list|(
name|marker
argument_list|)
operator|==
name|Lisp_Marker
operator|&&
name|XMARKER
argument_list|(
name|marker
argument_list|)
operator|->
name|buffer
operator|==
literal|0
condition|)
name|XFASTINT
argument_list|(
name|marker
argument_list|)
operator|=
literal|0
expr_stmt|;
name|CHECK_NUMBER_COERCE_MARKER
argument_list|(
name|marker
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|search_regs
operator|.
name|end
index|[
name|i
index|]
operator|=
name|XINT
argument_list|(
name|marker
argument_list|)
expr_stmt|;
block|}
name|list
operator|=
name|Fcdr
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
return|return
name|Qnil
return|;
block|}
end_block

begin_comment
comment|/* Quote a string to inactivate reg-expr chars */
end_comment

begin_macro
name|DEFUN
argument_list|(
literal|"regexp-quote"
argument_list|,
argument|Fregexp_quote
argument_list|,
argument|Sregexp_quote
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Return a regexp string which matches exactly STRING and nothing else."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|str
operator|)
name|Lisp_Object
name|str
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|unsigned
name|char
modifier|*
name|in
decl_stmt|,
modifier|*
name|out
decl_stmt|,
modifier|*
name|end
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|temp
decl_stmt|;
name|CHECK_STRING
argument_list|(
name|str
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|temp
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|XSTRING
argument_list|(
name|str
argument_list|)
operator|->
name|size
operator|*
literal|2
argument_list|)
expr_stmt|;
comment|/* Now copy the data into the new string, inserting escapes. */
name|in
operator|=
name|XSTRING
argument_list|(
name|str
argument_list|)
operator|->
name|data
expr_stmt|;
name|end
operator|=
name|in
operator|+
name|XSTRING
argument_list|(
name|str
argument_list|)
operator|->
name|size
expr_stmt|;
name|out
operator|=
name|temp
expr_stmt|;
for|for
control|(
init|;
name|in
operator|!=
name|end
condition|;
name|in
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|in
operator|==
literal|'['
operator|||
operator|*
name|in
operator|==
literal|']'
operator|||
operator|*
name|in
operator|==
literal|'*'
operator|||
operator|*
name|in
operator|==
literal|'.'
operator|||
operator|*
name|in
operator|==
literal|'\\'
operator|||
operator|*
name|in
operator|==
literal|'?'
operator|||
operator|*
name|in
operator|==
literal|'+'
operator|||
operator|*
name|in
operator|==
literal|'^'
operator|||
operator|*
name|in
operator|==
literal|'$'
condition|)
operator|*
name|out
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|out
operator|++
operator|=
operator|*
name|in
expr_stmt|;
block|}
return|return
name|make_string
argument_list|(
name|temp
argument_list|,
name|out
operator|-
name|temp
argument_list|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* This code should be unzapped when there comes to be multiple */
end_comment

begin_comment
comment|/* translation tables.  It has been certified on various cases. */
end_comment

begin_comment
comment|/* void compute_trt_inverse (trt)      register unsigned char *trt; {   register int i = 0400;   register unsigned char c, q;    while (i--)     trt[0400+i] = i;   i = 0400;   while (i--)     {       if ((q = trt[i]) != (unsigned char) i) 	{ 	  c = trt[q + 0400]; 	  trt[q + 0400] = i; 	  trt[0400 + i] = c; 	}     } } */
end_comment

begin_escape
end_escape

begin_macro
name|syms_of_search
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|0400
condition|;
name|i
operator|++
control|)
block|{
name|downcase_table
index|[
name|i
index|]
operator|=
operator|(
name|i
operator|>=
literal|'A'
operator|&&
name|i
operator|<=
literal|'Z'
operator|)
condition|?
name|i
operator|+
literal|040
else|:
name|i
expr_stmt|;
comment|/* We do this instead of using compute_trt_inverse to save space. */
comment|/* Does it? */
name|downcase_table
index|[
literal|0400
operator|+
name|i
index|]
operator|=
operator|(
operator|(
name|i
operator|>=
literal|'A'
operator|&&
name|i
operator|<=
literal|'Z'
operator|)
condition|?
name|i
operator|+
operator|(
literal|'a'
operator|-
literal|'A'
operator|)
else|:
operator|(
operator|(
name|i
operator|>=
literal|'a'
operator|&&
name|i
operator|<=
literal|'z'
operator|)
condition|?
name|i
operator|+
operator|(
literal|'A'
operator|-
literal|'a'
operator|)
else|:
name|i
operator|)
operator|)
expr_stmt|;
block|}
comment|/* Use this instead when there come to be multiple translation tables.    compute_trt_inverse (downcase_table);    */
name|searchbuf
operator|.
name|allocated
operator|=
literal|100
expr_stmt|;
name|searchbuf
operator|.
name|buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|searchbuf
operator|.
name|allocated
argument_list|)
expr_stmt|;
name|searchbuf
operator|.
name|fastmap
operator|=
name|search_fastmap
expr_stmt|;
name|Qsearch_failed
operator|=
name|intern
argument_list|(
literal|"search-failed"
argument_list|)
expr_stmt|;
name|staticpro
argument_list|(
operator|&
name|Qsearch_failed
argument_list|)
expr_stmt|;
name|Qinvalid_regexp
operator|=
name|intern
argument_list|(
literal|"invalid-regexp"
argument_list|)
expr_stmt|;
name|staticpro
argument_list|(
operator|&
name|Qinvalid_regexp
argument_list|)
expr_stmt|;
name|Fput
argument_list|(
name|Qsearch_failed
argument_list|,
name|Qerror_conditions
argument_list|,
name|Fcons
argument_list|(
name|Qsearch_failed
argument_list|,
name|Fcons
argument_list|(
name|Qerror
argument_list|,
name|Qnil
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|Fput
argument_list|(
name|Qsearch_failed
argument_list|,
name|Qerror_message
argument_list|,
name|build_string
argument_list|(
literal|"Search failed"
argument_list|)
argument_list|)
expr_stmt|;
name|Fput
argument_list|(
name|Qinvalid_regexp
argument_list|,
name|Qerror_conditions
argument_list|,
name|Fcons
argument_list|(
name|Qinvalid_regexp
argument_list|,
name|Fcons
argument_list|(
name|Qerror
argument_list|,
name|Qnil
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|Fput
argument_list|(
name|Qinvalid_regexp
argument_list|,
name|Qerror_message
argument_list|,
name|build_string
argument_list|(
literal|"Invalid regexp"
argument_list|)
argument_list|)
expr_stmt|;
name|last_regexp
operator|=
name|Qnil
expr_stmt|;
name|staticpro
argument_list|(
operator|&
name|last_regexp
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sstring_match
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Slooking_at
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sskip_chars_forward
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sskip_chars_backward
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Ssearch_forward
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Ssearch_backward
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sword_search_forward
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sword_search_backward
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sre_search_forward
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sre_search_backward
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sreplace_match
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Smatch_beginning
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Smatch_end
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Smatch_data
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sstore_match_data
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sregexp_quote
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

