begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Examine the result of  stat  and make a string describing file modes.    Copyright (C) 1985 Free Software Foundation, Inc.      This program is free software; you can redistribute it and/or modify     it under the terms of the GNU General Public License as published by     the Free Software Foundation; either version 1, or (at your option)     any later version.      This program is distributed in the hope that it will be useful,     but WITHOUT ANY WARRANTY; without even the implied warranty of     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the     GNU General Public License for more details.      You should have received a copy of the GNU General Public License     along with this program; if not, write to the Free Software     Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  In other words, you are welcome to use, share and improve this program. You are forbidden to forbid anyone else to use, share and improve what you give them.   Help stamp out software-hoarding!  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_comment
comment|/* filemodestring - set file attribute data   *** WARNING!  FILE STRUCTURE DEPENDENT ***     Filemodestring converts the data in the st_mode field of file status block `s' to a 10 character attribute string, which it stores in the block that `a' points to. This attribute string is modelled after the string produced by the Berkeley ls.  As usual under Unix, the elements of the string are numbered from 0.  Their meanings are:     0	File type.  'd' for directory, 'c' for character 	special, 'b' for block special, 'm' for multiplex, 	'l' for symbolic link, 's' for socket, 'p' for fifo, 	'-' for any other file type     1	'r' if the owner may read, '-' otherwise.     2	'w' if the owner may write, '-' otherwise.     3	'x' if the owner may execute, 's' if the file is 	set-user-id, '-' otherwise. 	'S' if the file is set-user-id, but the execute 	bit isn't set.  (sys v `feature' which helps to 	catch screw case.)     4	'r' if group members may read, '-' otherwise.     5	'w' if group members may write, '-' otherwise.     6	'x' if group members may execute, 's' if the file is 	set-group-id, '-' otherwise. 	'S' if it is set-group-id but not executable.     7	'r' if any user may read, '-' otherwise.     8	'w' if any user may write, '-' otherwise.     9	'x' if any user may execute, 't' if the file is "sticky" 	(will be retained in swap space after execution), '-' 	otherwise.   */
end_comment

begin_define
define|#
directive|define
name|VOID
value|void
end_define

begin_function_decl
specifier|static
name|char
name|ftypelet
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|VOID
name|rwx
argument_list|()
decl_stmt|,
name|setst
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function
name|VOID
name|filemodestring
parameter_list|(
name|s
parameter_list|,
name|a
parameter_list|)
name|struct
name|stat
modifier|*
name|s
decl_stmt|;
name|char
modifier|*
name|a
decl_stmt|;
block|{
name|a
index|[
literal|0
index|]
operator|=
name|ftypelet
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* Aren't there symbolic names for these byte-fields? */
name|rwx
argument_list|(
operator|(
name|s
operator|->
name|st_mode
operator|&
literal|0700
operator|)
operator|<<
literal|0
argument_list|,
operator|&
operator|(
name|a
index|[
literal|1
index|]
operator|)
argument_list|)
expr_stmt|;
name|rwx
argument_list|(
operator|(
name|s
operator|->
name|st_mode
operator|&
literal|0070
operator|)
operator|<<
literal|3
argument_list|,
operator|&
operator|(
name|a
index|[
literal|4
index|]
operator|)
argument_list|)
expr_stmt|;
name|rwx
argument_list|(
operator|(
name|s
operator|->
name|st_mode
operator|&
literal|0007
operator|)
operator|<<
literal|6
argument_list|,
operator|&
operator|(
name|a
index|[
literal|7
index|]
operator|)
argument_list|)
expr_stmt|;
name|setst
argument_list|(
name|s
operator|->
name|st_mode
argument_list|,
name|a
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ftypelet - file type letter  *** WARNING!  FILE STRUCTURE DEPENDENT ***     Ftypelet accepts a file status block and returns a character code describing the type of the file.  'd' is returned for directories, 'b' for block special files, 'c' for character special files, 'm' for multiplexor files, 'l' for symbolic link, 's' for socket, 'p' for fifo, '-' for any other file type  */
end_comment

begin_function
specifier|static
name|char
name|ftypelet
parameter_list|(
name|s
parameter_list|)
name|struct
name|stat
modifier|*
name|s
decl_stmt|;
block|{
switch|switch
condition|(
name|s
operator|->
name|st_mode
operator|&
name|S_IFMT
condition|)
block|{
default|default:
return|return
literal|'-'
return|;
case|case
name|S_IFDIR
case|:
return|return
literal|'d'
return|;
ifdef|#
directive|ifdef
name|S_IFLNK
case|case
name|S_IFLNK
case|:
return|return
literal|'l'
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|S_IFCHR
case|case
name|S_IFCHR
case|:
return|return
literal|'c'
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|S_IFBLK
case|case
name|S_IFBLK
case|:
return|return
literal|'b'
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|S_IFMPC
comment|/* These do not seem to exist */
case|case
name|S_IFMPC
case|:
case|case
name|S_IFMPB
case|:
return|return
literal|'m'
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|S_IFSOCK
case|case
name|S_IFSOCK
case|:
return|return
literal|'s'
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|S_IFIFO
if|#
directive|if
name|S_IFIFO
operator|!=
name|S_IFSOCK
case|case
name|S_IFIFO
case|:
return|return
literal|'p'
return|;
endif|#
directive|endif
endif|#
directive|endif
ifdef|#
directive|ifdef
name|S_IFNWK
comment|/* hp-ux hack */
case|case
name|S_IFNWK
case|:
return|return
literal|'n'
return|;
endif|#
directive|endif
block|}
block|}
end_function

begin_comment
comment|/* rwx - look at read, write, and execute bits and set character flags accordingly  *** WARNING!  FILE STRUCTURE DEPENDENT ***   */
end_comment

begin_function
specifier|static
name|VOID
name|rwx
parameter_list|(
name|bits
parameter_list|,
name|chars
parameter_list|)
name|unsigned
name|short
name|bits
decl_stmt|;
name|char
name|chars
index|[]
decl_stmt|;
block|{
name|chars
index|[
literal|0
index|]
operator|=
operator|(
name|bits
operator|&
name|S_IREAD
operator|)
condition|?
literal|'r'
else|:
literal|'-'
expr_stmt|;
name|chars
index|[
literal|1
index|]
operator|=
operator|(
name|bits
operator|&
name|S_IWRITE
operator|)
condition|?
literal|'w'
else|:
literal|'-'
expr_stmt|;
name|chars
index|[
literal|2
index|]
operator|=
operator|(
name|bits
operator|&
name|S_IEXEC
operator|)
condition|?
literal|'x'
else|:
literal|'-'
expr_stmt|;
block|}
end_function

begin_comment
comment|/* setst - set s& t flags in a file attributes string */
end_comment

begin_comment
comment|/* *** WARNING!  FILE STRUCTURE DEPENDENT *** */
end_comment

begin_function
specifier|static
name|VOID
name|setst
parameter_list|(
name|bits
parameter_list|,
name|chars
parameter_list|)
name|unsigned
name|short
name|bits
decl_stmt|;
name|char
name|chars
index|[]
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|S_ISUID
if|if
condition|(
name|bits
operator|&
name|S_ISUID
condition|)
block|{
if|if
condition|(
name|chars
index|[
literal|3
index|]
operator|!=
literal|'x'
condition|)
comment|/* Screw case: set-uid, but not executable. */
name|chars
index|[
literal|3
index|]
operator|=
literal|'S'
expr_stmt|;
else|else
name|chars
index|[
literal|3
index|]
operator|=
literal|'s'
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|S_ISGID
if|if
condition|(
name|bits
operator|&
name|S_ISGID
condition|)
block|{
if|if
condition|(
name|chars
index|[
literal|6
index|]
operator|!=
literal|'x'
condition|)
comment|/* Screw case: set-gid, but not executable. */
name|chars
index|[
literal|6
index|]
operator|=
literal|'S'
expr_stmt|;
else|else
name|chars
index|[
literal|6
index|]
operator|=
literal|'s'
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|S_ISVTX
if|if
condition|(
name|bits
operator|&
name|S_ISVTX
condition|)
name|chars
index|[
literal|9
index|]
operator|=
literal|'t'
expr_stmt|;
endif|#
directive|endif
block|}
end_function

end_unit

