begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Modified version of unexec for convex machines.    Copyright (C) 1985, 1986, 1988 Free Software Foundation, Inc.     Note that the GNU project considers support for the peculiarities    of the Convex operating system a peripheral activity which should    not be allowed to divert effort from development of the GNU system.    Changes in this code will be installed when Convex system    maintainers send them in, but aside from that we don't plan to    think about it, or about whether other Emacs maintenance might    break it.      This program is free software; you can redistribute it and/or modify     it under the terms of the GNU General Public License as published by     the Free Software Foundation; either version 1, or (at your option)     any later version.      This program is distributed in the hope that it will be useful,     but WITHOUT ANY WARRANTY; without even the implied warranty of     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the     GNU General Public License for more details.      You should have received a copy of the GNU General Public License     along with this program; if not, write to the Free Software     Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  In other words, you are welcome to use, share and improve this program. You are forbidden to forbid anyone else to use, share and improve what you give them.   Help stamp out software-hoarding!  */
end_comment

begin_comment
comment|/* modifyed for C-1 arch by jthomp@convex 871103 */
end_comment

begin_comment
comment|/* Corrected to support convex SOFF object file formats and thread specific  * regions.  streepy@convex 890302 */
end_comment

begin_comment
comment|/*  * unexec.c - Convert a running program into an a.out file.  *  * Author:	Spencer W. Thomas  * 		Computer Science Dept.  * 		University of Utah  * Date:	Tue Mar  2 1982  * Modified heavily since then.  *  * Synopsis:  *	unexec (new_name, a_name, data_start, bss_start, entry_address)  *	char *new_name, *a_name;  *	unsigned data_start, bss_start, entry_address;  *  * Takes a snapshot of the program and makes an a.out format file in the  * file named by the string argument new_name.  * If a_name is non-NULL, the symbol table will be taken from the given file.  * On some machines, an existing a_name file is required.  *  * The boundaries within the a.out file may be adjusted with the data_start  * and bss_start arguments.  Either or both may be given as 0 for defaults.  *  * Data_start gives the boundary between the text segment and the data  * segment of the program.  The text segment can contain shared, read-only  * program code and literal data, while the data segment is always unshared  * and unprotected.  Data_start gives the lowest unprotected address.  * The value you specify may be rounded down to a suitable boundary  * as required by the machine you are using.  *  * Specifying zero for data_start means the boundary between text and data  * should not be the same as when the program was loaded.  * If NO_REMAP is defined, the argument data_start is ignored and the  * segment boundaries are never changed.  *  * Bss_start indicates how much of the data segment is to be saved in the  * a.out file and restored when the program is executed.  It gives the lowest  * unsaved address, and is rounded up to a page boundary.  The default when 0  * is given assumes that the entire data segment is to be stored, including  * the previous data and bss as well as any additional storage allocated with  * break (2).  *  * The new file is set up to start at entry_address.  *  * If you make improvements I'd like to get them too.  * harpo!utah-cs!thomas, thomas@Utah-20  *  */
end_comment

begin_comment
comment|/* There are several compilation parameters affecting unexec:  * COFF  Define this if your system uses COFF for executables. Otherwise we assume you use Berkeley format.  * NO_REMAP  Define this if you do not want to try to save Emacs's pure data areas as part of the text segment.  Saving them as text is good because it allows users to share more.  However, on machines that locate the text area far from the data area, the boundary cannot feasibly be moved.  Such machines require NO_REMAP.  Also, remapping can cause trouble with the built-in startup routine /lib/crt0.o, which defines `environ' as an initialized variable. Dumping `environ' as pure does not work!  So, to use remapping, you must write a startup routine for your machine in Emacs's crt0.c. If NO_REMAP is defined, Emacs uses the system's crt0.o.  * SECTION_ALIGNMENT  Some machines that use COFF executables require that each section start on a certain boundary *in the COFF file*.  Such machines should define SECTION_ALIGNMENT to a mask of the low-order bits that must be zero on such a boundary.  This mask is used to control padding between segments in the COFF file.  If SECTION_ALIGNMENT is not defined, the segments are written consecutively with no attempt at alignment.  This is right for unmodified system V.  * SEGMENT_MASK  Some machines require that the beginnings and ends of segments *in core* be on certain boundaries.  For most machines, a page boundary is sufficient.  That is the default.  When a larger boundary is needed, define SEGMENT_MASK to a mask of the bits that must be zero on such a boundary.  * A_TEXT_OFFSET(HDR)  Some machines count the a.out header as part of the size of the text segment (a_text); they may actually load the header into core as the first data in the text segment.  Some have additional padding between the header and the real text of the program that is counted in a_text.  For these machines, define A_TEXT_OFFSET(HDR) to examine the header structure HDR and return the number of bytes to add to `a_text' before writing it (above and beyond the number of bytes of actual program text).  HDR's standard fields are already correct, except that this adjustment to the `a_text' field has not yet been made; thus, the amount of offset can depend on the data in the file.    * A_TEXT_SEEK(HDR)  If defined, this macro specifies the number of bytes to seek into the a.out file before starting to write the text segment.a  * EXEC_MAGIC  For machines using COFF, this macro, if defined, is a value stored into the magic number field of the output file.  * ADJUST_EXEC_HEADER  This macro can be used to generate statements to adjust or initialize nonstandard fields in the file header  * ADDR_CORRECT(ADDR)  Macro to correct an int which is the bit pattern of a pointer to a byte into an int which is the number of a byte.  This macro has a default definition which is usually right. This default definition is a no-op on most machines (where a pointer looks like an int) but not on all machines.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_define
define|#
directive|define
name|PERROR
parameter_list|(
name|file
parameter_list|)
value|report_error (file, new)
end_define

begin_include
include|#
directive|include
file|<a.out.h>
end_include

begin_comment
comment|/* Define getpagesize () if the system does not.    Note that this may depend on symbols defined in a.out.h  */
end_comment

begin_include
include|#
directive|include
file|"getpagesize.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_function_decl
specifier|extern
name|char
modifier|*
name|start_of_text
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Start of text */
end_comment

begin_function_decl
specifier|extern
name|char
modifier|*
name|start_of_data
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Start of initialized data */
end_comment

begin_include
include|#
directive|include
file|<machine/filehdr.h>
end_include

begin_include
include|#
directive|include
file|<machine/opthdr.h>
end_include

begin_include
include|#
directive|include
file|<machine/scnhdr.h>
end_include

begin_include
include|#
directive|include
file|<machine/pte.h>
end_include

begin_decl_stmt
specifier|static
name|long
name|block_copy_start
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Old executable start point */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|filehdr
name|f_hdr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* File header */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|opthdr
name|f_ohdr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Optional file header (a.out) */
end_comment

begin_decl_stmt
name|long
name|bias
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Bias to add for growth */
end_comment

begin_define
define|#
directive|define
name|SYMS_START
value|block_copy_start
end_define

begin_decl_stmt
specifier|static
name|long
name|text_scnptr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|data_scnptr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pagemask
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pagesz
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|report_error
argument_list|(
argument|file
argument_list|,
argument|fd
argument_list|)
name|char
operator|*
name|file
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|fd
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|fd
condition|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"Failure operating on %s"
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
end_block

begin_define
define|#
directive|define
name|ERROR0
parameter_list|(
name|msg
parameter_list|)
value|report_error_1 (new, msg, 0, 0); return -1
end_define

begin_define
define|#
directive|define
name|ERROR1
parameter_list|(
name|msg
parameter_list|,
name|x
parameter_list|)
value|report_error_1 (new, msg, x, 0); return -1
end_define

begin_define
define|#
directive|define
name|ERROR2
parameter_list|(
name|msg
parameter_list|,
name|x
parameter_list|,
name|y
parameter_list|)
value|report_error_1 (new, msg, x, y); return -1
end_define

begin_expr_stmt
specifier|static
name|report_error_1
argument_list|(
argument|fd
argument_list|,
argument|msg
argument_list|,
argument|a1
argument_list|,
argument|a2
argument_list|)
name|int
name|fd
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
modifier|*
name|msg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|a1
decl_stmt|,
name|a2
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|error
argument_list|(
name|msg
argument_list|,
name|a1
argument_list|,
name|a2
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* ****************************************************************  * unexec  *  * driving logic.  */
end_comment

begin_macro
name|unexec
argument_list|(
argument|new_name
argument_list|,
argument|a_name
argument_list|,
argument|data_start
argument_list|,
argument|bss_start
argument_list|,
argument|entry_address
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|new_name
decl_stmt|,
modifier|*
name|a_name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|data_start
decl_stmt|,
name|bss_start
decl_stmt|,
name|entry_address
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|new
decl_stmt|,
name|a_out
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|a_name
operator|&&
operator|(
name|a_out
operator|=
name|open
argument_list|(
name|a_name
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|PERROR
argument_list|(
name|a_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|new
operator|=
name|creat
argument_list|(
name|new_name
argument_list|,
literal|0666
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|PERROR
argument_list|(
name|new_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|make_hdr
argument_list|(
name|new
argument_list|,
name|a_out
argument_list|,
name|data_start
argument_list|,
name|bss_start
argument_list|,
name|entry_address
argument_list|,
name|a_name
argument_list|,
name|new_name
argument_list|)
operator|<
literal|0
operator|||
name|copy_text_and_data
argument_list|(
name|new
argument_list|)
operator|<
literal|0
operator|||
name|copy_sym
argument_list|(
name|new
argument_list|,
name|a_out
argument_list|,
name|a_name
argument_list|,
name|new_name
argument_list|)
operator|<
literal|0
condition|)
block|{
name|close
argument_list|(
name|new
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|close
argument_list|(
name|new
argument_list|)
expr_stmt|;
if|if
condition|(
name|a_out
operator|>=
literal|0
condition|)
name|close
argument_list|(
name|a_out
argument_list|)
expr_stmt|;
name|mark_x
argument_list|(
name|new_name
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* ****************************************************************  * make_hdr  *  * Make the header in the new a.out from the header in core.  * Modify the text and data sizes.  */
end_comment

begin_decl_stmt
name|struct
name|scnhdr
modifier|*
name|stbl
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Table of all scnhdr's */
end_comment

begin_decl_stmt
name|struct
name|scnhdr
modifier|*
name|f_thdr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Text section header */
end_comment

begin_decl_stmt
name|struct
name|scnhdr
modifier|*
name|f_dhdr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Data section header */
end_comment

begin_decl_stmt
name|struct
name|scnhdr
modifier|*
name|f_tdhdr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Thread Data section header */
end_comment

begin_decl_stmt
name|struct
name|scnhdr
modifier|*
name|f_bhdr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Bss section header */
end_comment

begin_decl_stmt
name|struct
name|scnhdr
modifier|*
name|f_tbhdr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Thread Bss section header */
end_comment

begin_function
specifier|static
name|int
name|make_hdr
parameter_list|(
name|new
parameter_list|,
name|a_out
parameter_list|,
name|data_start
parameter_list|,
name|bss_start
parameter_list|,
name|entry_address
parameter_list|,
name|a_name
parameter_list|,
name|new_name
parameter_list|)
name|int
name|new
decl_stmt|,
name|a_out
decl_stmt|;
name|unsigned
name|data_start
decl_stmt|,
name|bss_start
decl_stmt|,
name|entry_address
decl_stmt|;
name|char
modifier|*
name|a_name
decl_stmt|;
name|char
modifier|*
name|new_name
decl_stmt|;
block|{
specifier|register
name|int
name|scns
decl_stmt|;
name|unsigned
name|int
name|bss_end
decl_stmt|;
name|unsigned
name|int
name|eo_data
decl_stmt|;
comment|/* End of initialized data in new exec file */
name|int
name|scntype
decl_stmt|;
comment|/* Section type */
name|int
name|i
decl_stmt|;
comment|/* Var for sorting by vaddr */
name|struct
name|scnhdr
name|scntemp
decl_stmt|;
comment|/* For swapping entries in sort */
specifier|extern
name|char
modifier|*
name|start_of_data
parameter_list|()
function_decl|;
name|pagemask
operator|=
operator|(
name|pagesz
operator|=
name|getpagesize
argument_list|()
operator|)
operator|-
literal|1
expr_stmt|;
comment|/* Adjust text/data boundary. */
if|if
condition|(
operator|!
name|data_start
condition|)
name|data_start
operator|=
operator|(
name|unsigned
operator|)
name|start_of_data
argument_list|()
expr_stmt|;
name|data_start
operator|=
name|data_start
operator|&
operator|~
name|pagemask
expr_stmt|;
comment|/* (Down) to page boundary. */
name|bss_end
operator|=
operator|(
name|sbrk
argument_list|(
literal|0
argument_list|)
operator|+
name|pagemask
operator|)
operator|&
operator|~
name|pagemask
expr_stmt|;
comment|/* Adjust data/bss boundary. */
if|if
condition|(
name|bss_start
operator|!=
literal|0
condition|)
block|{
name|bss_start
operator|=
operator|(
name|bss_start
operator|+
name|pagemask
operator|)
operator|&
operator|~
name|pagemask
expr_stmt|;
comment|/* (Up) to page bdry. */
if|if
condition|(
name|bss_start
operator|>
name|bss_end
condition|)
block|{
name|ERROR1
argument_list|(
literal|"unexec: Specified bss_start (%x) is past end of program"
argument_list|,
name|bss_start
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|bss_start
operator|=
name|bss_end
expr_stmt|;
if|if
condition|(
name|data_start
operator|>
name|bss_start
condition|)
block|{
comment|/* Can't have negative data size. */
name|ERROR2
argument_list|(
literal|"unexec: data_start (%x) can't be greater than bss_start (%x)"
argument_list|,
name|data_start
argument_list|,
name|bss_start
argument_list|)
expr_stmt|;
block|}
comment|/* Salvage as much info from the existing file as possible */
if|if
condition|(
name|a_out
operator|<
literal|0
condition|)
block|{
name|ERROR0
argument_list|(
literal|"can't build a COFF file from scratch yet"
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
if|if
condition|(
name|read
argument_list|(
name|a_out
argument_list|,
operator|&
name|f_hdr
argument_list|,
sizeof|sizeof
argument_list|(
name|f_hdr
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|f_hdr
argument_list|)
condition|)
block|{
name|PERROR
argument_list|(
name|a_name
argument_list|)
expr_stmt|;
block|}
name|block_copy_start
operator|+=
sizeof|sizeof
argument_list|(
name|f_hdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|f_hdr
operator|.
name|h_opthdr
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|read
argument_list|(
name|a_out
argument_list|,
operator|&
name|f_ohdr
argument_list|,
sizeof|sizeof
argument_list|(
name|f_ohdr
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|f_ohdr
argument_list|)
condition|)
block|{
name|PERROR
argument_list|(
name|a_name
argument_list|)
expr_stmt|;
block|}
name|block_copy_start
operator|+=
sizeof|sizeof
argument_list|(
name|f_ohdr
argument_list|)
expr_stmt|;
block|}
comment|/* Allocate room for scn headers */
name|stbl
operator|=
operator|(
expr|struct
name|scnhdr
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|scnhdr
argument_list|)
operator|*
name|f_hdr
operator|.
name|h_nscns
argument_list|)
expr_stmt|;
if|if
condition|(
name|stbl
operator|==
name|NULL
condition|)
block|{
name|ERROR0
argument_list|(
literal|"unexec: malloc of stbl failed"
argument_list|)
expr_stmt|;
block|}
name|f_tdhdr
operator|=
name|f_tbhdr
operator|=
name|NULL
expr_stmt|;
comment|/* Loop through section headers, copying them in */
for|for
control|(
name|scns
operator|=
literal|0
init|;
name|scns
operator|<
name|f_hdr
operator|.
name|h_nscns
condition|;
name|scns
operator|++
control|)
block|{
if|if
condition|(
name|read
argument_list|(
name|a_out
argument_list|,
operator|&
name|stbl
index|[
name|scns
index|]
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|stbl
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
operator|*
name|stbl
argument_list|)
condition|)
block|{
name|PERROR
argument_list|(
name|a_name
argument_list|)
expr_stmt|;
block|}
name|scntype
operator|=
name|stbl
index|[
name|scns
index|]
operator|.
name|s_flags
operator|&
name|S_TYPMASK
expr_stmt|;
comment|/* What type of section */
if|if
condition|(
name|stbl
index|[
name|scns
index|]
operator|.
name|s_scnptr
operator|>
literal|0L
condition|)
block|{
if|if
condition|(
name|block_copy_start
operator|<
name|stbl
index|[
name|scns
index|]
operator|.
name|s_scnptr
operator|+
name|stbl
index|[
name|scns
index|]
operator|.
name|s_size
condition|)
name|block_copy_start
operator|=
name|stbl
index|[
name|scns
index|]
operator|.
name|s_scnptr
operator|+
name|stbl
index|[
name|scns
index|]
operator|.
name|s_size
expr_stmt|;
block|}
if|if
condition|(
name|scntype
operator|==
name|S_TEXT
condition|)
block|{
name|f_thdr
operator|=
operator|&
name|stbl
index|[
name|scns
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|scntype
operator|==
name|S_DATA
condition|)
block|{
name|f_dhdr
operator|=
operator|&
name|stbl
index|[
name|scns
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|S_TDATA
block|}
elseif|else
if|if
condition|(
name|scntype
operator|==
name|S_TDATA
condition|)
block|{
name|f_tdhdr
operator|=
operator|&
name|stbl
index|[
name|scns
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|scntype
operator|==
name|S_TBSS
condition|)
block|{
name|f_tbhdr
operator|=
operator|&
name|stbl
index|[
name|scns
index|]
expr_stmt|;
endif|#
directive|endif
comment|/* S_TDATA (thread stuff) */
block|}
elseif|else
if|if
condition|(
name|scntype
operator|==
name|S_BSS
condition|)
block|{
name|f_bhdr
operator|=
operator|&
name|stbl
index|[
name|scns
index|]
expr_stmt|;
block|}
block|}
comment|/* We will now convert TEXT and DATA into TEXT, BSS into DATA, and leave      * all thread stuff alone.      */
comment|/* Now we alter the contents of all the f_*hdr variables        to correspond to what we want to dump.  */
name|f_thdr
operator|->
name|s_vaddr
operator|=
operator|(
name|long
operator|)
name|start_of_text
argument_list|()
expr_stmt|;
name|f_thdr
operator|->
name|s_size
operator|=
name|data_start
operator|-
name|f_thdr
operator|->
name|s_vaddr
expr_stmt|;
name|f_thdr
operator|->
name|s_scnptr
operator|=
name|pagesz
expr_stmt|;
name|f_thdr
operator|->
name|s_relptr
operator|=
literal|0
expr_stmt|;
name|f_thdr
operator|->
name|s_nrel
operator|=
literal|0
expr_stmt|;
name|eo_data
operator|=
name|f_thdr
operator|->
name|s_scnptr
operator|+
name|f_thdr
operator|->
name|s_size
expr_stmt|;
if|if
condition|(
name|f_tdhdr
condition|)
block|{
comment|/* Process thread data */
name|f_tdhdr
operator|->
name|s_vaddr
operator|=
name|data_start
expr_stmt|;
name|f_tdhdr
operator|->
name|s_size
operator|+=
name|f_dhdr
operator|->
name|s_size
operator|-
operator|(
name|data_start
operator|-
name|f_dhdr
operator|->
name|s_vaddr
operator|)
expr_stmt|;
name|f_tdhdr
operator|->
name|s_scnptr
operator|=
name|eo_data
expr_stmt|;
name|f_tdhdr
operator|->
name|s_relptr
operator|=
literal|0
expr_stmt|;
name|f_tdhdr
operator|->
name|s_nrel
operator|=
literal|0
expr_stmt|;
name|eo_data
operator|+=
name|f_tdhdr
operator|->
name|s_size
expr_stmt|;
comment|/* And now for DATA */
name|f_dhdr
operator|->
name|s_vaddr
operator|=
name|f_bhdr
operator|->
name|s_vaddr
expr_stmt|;
comment|/* Take BSS start address */
name|f_dhdr
operator|->
name|s_size
operator|=
name|bss_end
operator|-
name|f_bhdr
operator|->
name|s_vaddr
expr_stmt|;
name|f_dhdr
operator|->
name|s_scnptr
operator|=
name|eo_data
expr_stmt|;
name|f_dhdr
operator|->
name|s_relptr
operator|=
literal|0
expr_stmt|;
name|f_dhdr
operator|->
name|s_nrel
operator|=
literal|0
expr_stmt|;
name|eo_data
operator|+=
name|f_dhdr
operator|->
name|s_size
expr_stmt|;
block|}
else|else
block|{
name|f_dhdr
operator|->
name|s_vaddr
operator|=
name|data_start
expr_stmt|;
name|f_dhdr
operator|->
name|s_size
operator|=
name|bss_start
operator|-
name|data_start
expr_stmt|;
name|f_dhdr
operator|->
name|s_scnptr
operator|=
name|eo_data
expr_stmt|;
name|f_dhdr
operator|->
name|s_relptr
operator|=
literal|0
expr_stmt|;
name|f_dhdr
operator|->
name|s_nrel
operator|=
literal|0
expr_stmt|;
name|eo_data
operator|+=
name|f_dhdr
operator|->
name|s_size
expr_stmt|;
block|}
name|f_bhdr
operator|->
name|s_vaddr
operator|=
name|bss_start
expr_stmt|;
name|f_bhdr
operator|->
name|s_size
operator|=
name|bss_end
operator|-
name|bss_start
operator|+
name|pagesz
comment|/* fudge */
expr_stmt|;
name|f_bhdr
operator|->
name|s_scnptr
operator|=
literal|0
expr_stmt|;
name|f_bhdr
operator|->
name|s_relptr
operator|=
literal|0
expr_stmt|;
name|f_bhdr
operator|->
name|s_nrel
operator|=
literal|0
expr_stmt|;
name|text_scnptr
operator|=
name|f_thdr
operator|->
name|s_scnptr
expr_stmt|;
name|data_scnptr
operator|=
name|f_dhdr
operator|->
name|s_scnptr
expr_stmt|;
name|bias
operator|=
name|eo_data
operator|-
name|block_copy_start
expr_stmt|;
if|if
condition|(
name|f_ohdr
operator|.
name|o_symptr
operator|>
literal|0L
condition|)
block|{
name|f_ohdr
operator|.
name|o_symptr
operator|+=
name|bias
expr_stmt|;
block|}
if|if
condition|(
name|f_hdr
operator|.
name|h_strptr
operator|>
literal|0
condition|)
block|{
name|f_hdr
operator|.
name|h_strptr
operator|+=
name|bias
expr_stmt|;
block|}
if|if
condition|(
name|write
argument_list|(
name|new
argument_list|,
operator|&
name|f_hdr
argument_list|,
sizeof|sizeof
argument_list|(
name|f_hdr
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|f_hdr
argument_list|)
condition|)
block|{
name|PERROR
argument_list|(
name|new_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|write
argument_list|(
name|new
argument_list|,
operator|&
name|f_ohdr
argument_list|,
sizeof|sizeof
argument_list|(
name|f_ohdr
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|f_ohdr
argument_list|)
condition|)
block|{
name|PERROR
argument_list|(
name|new_name
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|scns
operator|=
literal|0
init|;
name|scns
operator|<
name|f_hdr
operator|.
name|h_nscns
condition|;
name|scns
operator|++
control|)
block|{
comment|/* This is a cheesey little loop to write out the section headers 	 * in order of increasing virtual address. Dull but effective. 	 */
for|for
control|(
name|i
operator|=
name|scns
operator|+
literal|1
init|;
name|i
operator|<
name|f_hdr
operator|.
name|h_nscns
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|stbl
index|[
name|i
index|]
operator|.
name|s_vaddr
operator|<
name|stbl
index|[
name|scns
index|]
operator|.
name|s_vaddr
condition|)
block|{
comment|/* Swap */
name|scntemp
operator|=
name|stbl
index|[
name|i
index|]
expr_stmt|;
name|stbl
index|[
name|i
index|]
operator|=
name|stbl
index|[
name|scns
index|]
expr_stmt|;
name|stbl
index|[
name|scns
index|]
operator|=
name|scntemp
expr_stmt|;
block|}
block|}
block|}
for|for
control|(
name|scns
operator|=
literal|0
init|;
name|scns
operator|<
name|f_hdr
operator|.
name|h_nscns
condition|;
name|scns
operator|++
control|)
block|{
if|if
condition|(
name|write
argument_list|(
name|new
argument_list|,
operator|&
name|stbl
index|[
name|scns
index|]
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|stbl
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
operator|*
name|stbl
argument_list|)
condition|)
block|{
name|PERROR
argument_list|(
name|new_name
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* ****************************************************************  * copy_text_and_data  *  * Copy the text and data segments from memory to the new a.out  */
end_comment

begin_function
specifier|static
name|int
name|copy_text_and_data
parameter_list|(
name|new
parameter_list|)
name|int
name|new
decl_stmt|;
block|{
specifier|register
name|int
name|scns
decl_stmt|;
for|for
control|(
name|scns
operator|=
literal|0
init|;
name|scns
operator|<
name|f_hdr
operator|.
name|h_nscns
condition|;
name|scns
operator|++
control|)
name|write_segment
argument_list|(
name|new
argument_list|,
operator|&
name|stbl
index|[
name|scns
index|]
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_macro
name|write_segment
argument_list|(
argument|new
argument_list|,
argument|sptr
argument_list|)
end_macro

begin_decl_stmt
name|int
name|new
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|scnhdr
modifier|*
name|sptr
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|ptr
decl_stmt|,
modifier|*
name|end
decl_stmt|;
specifier|register
name|int
name|nwrite
decl_stmt|,
name|ret
decl_stmt|;
name|char
name|buf
index|[
literal|80
index|]
decl_stmt|;
specifier|extern
name|int
name|errno
decl_stmt|;
name|char
name|zeros
index|[
literal|128
index|]
decl_stmt|;
if|if
condition|(
name|sptr
operator|->
name|s_scnptr
operator|==
literal|0
condition|)
return|return;
comment|/* Nothing to do */
if|if
condition|(
name|lseek
argument_list|(
name|new
argument_list|,
operator|(
name|long
operator|)
name|sptr
operator|->
name|s_scnptr
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|PERROR
argument_list|(
literal|"unexecing"
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|zeros
argument_list|,
sizeof|sizeof
name|zeros
argument_list|)
expr_stmt|;
name|ptr
operator|=
operator|(
name|char
operator|*
operator|)
name|sptr
operator|->
name|s_vaddr
expr_stmt|;
name|end
operator|=
name|ptr
operator|+
name|sptr
operator|->
name|s_size
expr_stmt|;
while|while
condition|(
name|ptr
operator|<
name|end
condition|)
block|{
comment|/* distance to next multiple of 128.  */
name|nwrite
operator|=
operator|(
operator|(
operator|(
name|int
operator|)
name|ptr
operator|+
literal|128
operator|)
operator|&
operator|-
literal|128
operator|)
operator|-
operator|(
name|int
operator|)
name|ptr
expr_stmt|;
comment|/* But not beyond specified end.  */
if|if
condition|(
name|nwrite
operator|>
name|end
operator|-
name|ptr
condition|)
name|nwrite
operator|=
name|end
operator|-
name|ptr
expr_stmt|;
name|ret
operator|=
name|write
argument_list|(
name|new
argument_list|,
name|ptr
argument_list|,
name|nwrite
argument_list|)
expr_stmt|;
comment|/* If write gets a page fault, it means we reached 	   a gap between the old text segment and the old data segment. 	   This gap has probably been remapped into part of the text segment. 	   So write zeros for it.  */
if|if
condition|(
name|ret
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|==
name|EFAULT
condition|)
name|write
argument_list|(
name|new
argument_list|,
name|zeros
argument_list|,
name|nwrite
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|nwrite
operator|!=
name|ret
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"unexec write failure: addr 0x%x, fileno %d, size 0x%x, wrote 0x%x, errno %d"
argument_list|,
name|ptr
argument_list|,
name|new
argument_list|,
name|nwrite
argument_list|,
name|ret
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|PERROR
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
name|ptr
operator|+=
name|nwrite
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* ****************************************************************  * copy_sym  *  * Copy the relocation information and symbol table from the a.out to the new  */
end_comment

begin_function
specifier|static
name|int
name|copy_sym
parameter_list|(
name|new
parameter_list|,
name|a_out
parameter_list|,
name|a_name
parameter_list|,
name|new_name
parameter_list|)
name|int
name|new
decl_stmt|,
name|a_out
decl_stmt|;
name|char
modifier|*
name|a_name
decl_stmt|,
decl|*
name|new_name
decl_stmt|;
end_function

begin_block
block|{
name|char
name|page
index|[
literal|1024
index|]
decl_stmt|;
name|int
name|n
decl_stmt|;
if|if
condition|(
name|a_out
operator|<
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|SYMS_START
operator|==
literal|0L
condition|)
return|return
literal|0
return|;
name|lseek
argument_list|(
name|a_out
argument_list|,
name|SYMS_START
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Position a.out to symtab. */
name|lseek
argument_list|(
name|new
argument_list|,
operator|(
name|long
operator|)
name|f_ohdr
operator|.
name|o_symptr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|n
operator|=
name|read
argument_list|(
name|a_out
argument_list|,
name|page
argument_list|,
sizeof|sizeof
name|page
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|write
argument_list|(
name|new
argument_list|,
name|page
argument_list|,
name|n
argument_list|)
operator|!=
name|n
condition|)
block|{
name|PERROR
argument_list|(
name|new_name
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|PERROR
argument_list|(
name|a_name
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* ****************************************************************  * mark_x  *  * After succesfully building the new a.out, mark it executable  */
end_comment

begin_expr_stmt
specifier|static
name|mark_x
argument_list|(
argument|name
argument_list|)
name|char
operator|*
name|name
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|struct
name|stat
name|sbuf
decl_stmt|;
name|int
name|um
decl_stmt|;
name|int
name|new
init|=
literal|0
decl_stmt|;
comment|/* for PERROR */
name|um
operator|=
name|umask
argument_list|(
literal|777
argument_list|)
expr_stmt|;
name|umask
argument_list|(
name|um
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|name
argument_list|,
operator|&
name|sbuf
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|PERROR
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
name|sbuf
operator|.
name|st_mode
operator||=
literal|0111
operator|&
operator|~
name|um
expr_stmt|;
if|if
condition|(
name|chmod
argument_list|(
name|name
argument_list|,
name|sbuf
operator|.
name|st_mode
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|PERROR
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Find the first pty letter.  This is usually 'p', as in ptyp0, but    is sometimes configured down to 'm', 'n', or 'o' for some reason. */
end_comment

begin_macro
name|first_pty_letter
argument_list|()
end_macro

begin_block
block|{
name|struct
name|stat
name|buf
decl_stmt|;
name|char
name|pty_name
index|[
literal|16
index|]
decl_stmt|;
name|char
name|c
decl_stmt|;
for|for
control|(
name|c
operator|=
literal|'o'
init|;
name|c
operator|>=
literal|'a'
condition|;
name|c
operator|--
control|)
block|{
name|sprintf
argument_list|(
name|pty_name
argument_list|,
literal|"/dev/pty%c0"
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|pty_name
argument_list|,
operator|&
name|buf
argument_list|)
operator|<
literal|0
condition|)
return|return
name|c
operator|+
literal|1
return|;
block|}
return|return
literal|'a'
return|;
block|}
end_block

end_unit

