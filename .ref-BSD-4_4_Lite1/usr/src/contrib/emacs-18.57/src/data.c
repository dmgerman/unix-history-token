begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Primitive operations on Lisp data types for GNU Emacs Lisp interpreter.    Copyright (C) 1985, 1986 Free Software Foundation, Inc.  This file is part of GNU Emacs.  GNU Emacs is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version.  GNU Emacs is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU Emacs; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"lisp.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|standalone
end_ifndef

begin_include
include|#
directive|include
file|"buffer.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|Lisp_Object
name|Qnil
decl_stmt|,
name|Qt
decl_stmt|,
name|Qquote
decl_stmt|,
name|Qlambda
decl_stmt|,
name|Qsubr
decl_stmt|,
name|Qunbound
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Lisp_Object
name|Qerror_conditions
decl_stmt|,
name|Qerror_message
decl_stmt|,
name|Qtop_level
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Lisp_Object
name|Qerror
decl_stmt|,
name|Qquit
decl_stmt|,
name|Qwrong_type_argument
decl_stmt|,
name|Qargs_out_of_range
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Lisp_Object
name|Qvoid_variable
decl_stmt|,
name|Qvoid_function
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Lisp_Object
name|Qsetting_constant
decl_stmt|,
name|Qinvalid_read_syntax
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Lisp_Object
name|Qinvalid_function
decl_stmt|,
name|Qwrong_number_of_arguments
decl_stmt|,
name|Qno_catch
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Lisp_Object
name|Qend_of_file
decl_stmt|,
name|Qarith_error
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Lisp_Object
name|Qbeginning_of_buffer
decl_stmt|,
name|Qend_of_buffer
decl_stmt|,
name|Qbuffer_read_only
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Lisp_Object
name|Qintegerp
decl_stmt|,
name|Qnatnump
decl_stmt|,
name|Qsymbolp
decl_stmt|,
name|Qlistp
decl_stmt|,
name|Qconsp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Lisp_Object
name|Qstringp
decl_stmt|,
name|Qarrayp
decl_stmt|,
name|Qsequencep
decl_stmt|,
name|Qbufferp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Lisp_Object
name|Qchar_or_string_p
decl_stmt|,
name|Qmarkerp
decl_stmt|,
name|Qinteger_or_marker_p
decl_stmt|,
name|Qvectorp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Lisp_Object
name|Qboundp
decl_stmt|,
name|Qfboundp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Lisp_Object
name|Qcdr
decl_stmt|;
end_decl_stmt

begin_function
name|Lisp_Object
name|wrong_type_argument
parameter_list|(
name|predicate
parameter_list|,
name|value
parameter_list|)
specifier|register
name|Lisp_Object
name|predicate
decl_stmt|,
name|value
decl_stmt|;
block|{
specifier|register
name|Lisp_Object
name|tem
decl_stmt|;
do|do
block|{
if|if
condition|(
operator|!
name|EQ
argument_list|(
name|Vmocklisp_arguments
argument_list|,
name|Qt
argument_list|)
condition|)
block|{
if|if
condition|(
name|XTYPE
argument_list|(
name|value
argument_list|)
operator|==
name|Lisp_String
operator|&&
operator|(
name|EQ
argument_list|(
name|predicate
argument_list|,
name|Qintegerp
argument_list|)
operator|||
name|EQ
argument_list|(
name|predicate
argument_list|,
name|Qinteger_or_marker_p
argument_list|)
operator|)
condition|)
return|return
name|Fstring_to_int
argument_list|(
name|value
argument_list|,
name|Qt
argument_list|)
return|;
if|if
condition|(
name|XTYPE
argument_list|(
name|value
argument_list|)
operator|==
name|Lisp_Int
operator|&&
name|EQ
argument_list|(
name|predicate
argument_list|,
name|Qstringp
argument_list|)
condition|)
return|return
name|Fint_to_string
argument_list|(
name|value
argument_list|)
return|;
block|}
name|value
operator|=
name|Fsignal
argument_list|(
name|Qwrong_type_argument
argument_list|,
name|Fcons
argument_list|(
name|predicate
argument_list|,
name|Fcons
argument_list|(
name|value
argument_list|,
name|Qnil
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|tem
operator|=
name|call1
argument_list|(
name|predicate
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|NULL
argument_list|(
name|tem
argument_list|)
condition|)
do|;
return|return
name|value
return|;
block|}
end_function

begin_macro
name|pure_write_error
argument_list|()
end_macro

begin_block
block|{
name|error
argument_list|(
literal|"Attempt to modify read-only object"
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|void
name|args_out_of_range
parameter_list|(
name|a1
parameter_list|,
name|a2
parameter_list|)
name|Lisp_Object
name|a1
decl_stmt|,
name|a2
decl_stmt|;
block|{
while|while
condition|(
literal|1
condition|)
name|Fsignal
argument_list|(
name|Qargs_out_of_range
argument_list|,
name|Fcons
argument_list|(
name|a1
argument_list|,
name|Fcons
argument_list|(
name|a2
argument_list|,
name|Qnil
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|args_out_of_range_3
parameter_list|(
name|a1
parameter_list|,
name|a2
parameter_list|,
name|a3
parameter_list|)
name|Lisp_Object
name|a1
decl_stmt|,
name|a2
decl_stmt|,
name|a3
decl_stmt|;
block|{
while|while
condition|(
literal|1
condition|)
name|Fsignal
argument_list|(
name|Qargs_out_of_range
argument_list|,
name|Fcons
argument_list|(
name|a1
argument_list|,
name|Fcons
argument_list|(
name|a2
argument_list|,
name|Fcons
argument_list|(
name|a3
argument_list|,
name|Qnil
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|Lisp_Object
name|make_number
parameter_list|(
name|num
parameter_list|)
name|int
name|num
decl_stmt|;
block|{
specifier|register
name|Lisp_Object
name|val
decl_stmt|;
name|XSET
argument_list|(
name|val
argument_list|,
name|Lisp_Int
argument_list|,
name|num
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_comment
comment|/* On some machines, XINT needs a temporary location.    Here it is, in case it is needed.  */
end_comment

begin_decl_stmt
name|int
name|sign_extend_temp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* On a few machines, XINT can only be done by calling this.  */
end_comment

begin_function
name|int
name|sign_extend_lisp_int
parameter_list|(
name|num
parameter_list|)
name|int
name|num
decl_stmt|;
block|{
if|if
condition|(
name|num
operator|&
operator|(
literal|1
operator|<<
operator|(
name|VALBITS
operator|-
literal|1
operator|)
operator|)
condition|)
return|return
name|num
operator||
operator|(
operator|(
operator|-
literal|1
operator|)
operator|<<
name|VALBITS
operator|)
return|;
else|else
return|return
name|num
operator|&
operator|(
operator|(
literal|1
operator|<<
name|VALBITS
operator|)
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Data type predicates */
end_comment

begin_macro
name|DEFUN
argument_list|(
literal|"eq"
argument_list|,
argument|Feq
argument_list|,
argument|Seq
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"T if the two args are the same Lisp object."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|obj1
operator|,
name|obj2
operator|)
name|Lisp_Object
name|obj1
operator|,
name|obj2
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|EQ
argument_list|(
name|obj1
argument_list|,
name|obj2
argument_list|)
condition|)
return|return
name|Qt
return|;
return|return
name|Qnil
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"null"
argument_list|,
argument|Fnull
argument_list|,
argument|Snull
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"T if OBJECT is nil."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|obj
operator|)
name|Lisp_Object
name|obj
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|NULL
argument_list|(
name|obj
argument_list|)
condition|)
return|return
name|Qt
return|;
return|return
name|Qnil
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"consp"
argument_list|,
argument|Fconsp
argument_list|,
argument|Sconsp
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"T if OBJECT is a cons cell."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|obj
operator|)
name|Lisp_Object
name|obj
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|XTYPE
argument_list|(
name|obj
argument_list|)
operator|==
name|Lisp_Cons
condition|)
return|return
name|Qt
return|;
return|return
name|Qnil
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"atom"
argument_list|,
argument|Fatom
argument_list|,
argument|Satom
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"T if OBJECT is not a cons cell.  This includes nil."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|obj
operator|)
name|Lisp_Object
name|obj
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|XTYPE
argument_list|(
name|obj
argument_list|)
operator|==
name|Lisp_Cons
condition|)
return|return
name|Qnil
return|;
return|return
name|Qt
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"listp"
argument_list|,
argument|Flistp
argument_list|,
argument|Slistp
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"T if OBJECT is a list.  This includes nil."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|obj
operator|)
name|Lisp_Object
name|obj
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|XTYPE
argument_list|(
name|obj
argument_list|)
operator|==
name|Lisp_Cons
operator|||
name|NULL
argument_list|(
name|obj
argument_list|)
condition|)
return|return
name|Qt
return|;
return|return
name|Qnil
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"nlistp"
argument_list|,
argument|Fnlistp
argument_list|,
argument|Snlistp
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"T if OBJECT is not a list.  Lists include nil."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|obj
operator|)
name|Lisp_Object
name|obj
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|XTYPE
argument_list|(
name|obj
argument_list|)
operator|==
name|Lisp_Cons
operator|||
name|NULL
argument_list|(
name|obj
argument_list|)
condition|)
return|return
name|Qnil
return|;
return|return
name|Qt
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"integerp"
argument_list|,
argument|Fintegerp
argument_list|,
argument|Sintegerp
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"T if OBJECT is a number."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|obj
operator|)
name|Lisp_Object
name|obj
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|XTYPE
argument_list|(
name|obj
argument_list|)
operator|==
name|Lisp_Int
condition|)
return|return
name|Qt
return|;
return|return
name|Qnil
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"natnump"
argument_list|,
argument|Fnatnump
argument_list|,
argument|Snatnump
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"T if OBJECT is a nonnegative number."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|obj
operator|)
name|Lisp_Object
name|obj
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|XTYPE
argument_list|(
name|obj
argument_list|)
operator|==
name|Lisp_Int
operator|&&
name|XINT
argument_list|(
name|obj
argument_list|)
operator|>=
literal|0
condition|)
return|return
name|Qt
return|;
return|return
name|Qnil
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"symbolp"
argument_list|,
argument|Fsymbolp
argument_list|,
argument|Ssymbolp
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"T if OBJECT is a symbol."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|obj
operator|)
name|Lisp_Object
name|obj
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|XTYPE
argument_list|(
name|obj
argument_list|)
operator|==
name|Lisp_Symbol
condition|)
return|return
name|Qt
return|;
return|return
name|Qnil
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"vectorp"
argument_list|,
argument|Fvectorp
argument_list|,
argument|Svectorp
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"T if OBJECT is a vector."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|obj
operator|)
name|Lisp_Object
name|obj
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|XTYPE
argument_list|(
name|obj
argument_list|)
operator|==
name|Lisp_Vector
condition|)
return|return
name|Qt
return|;
return|return
name|Qnil
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"stringp"
argument_list|,
argument|Fstringp
argument_list|,
argument|Sstringp
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"T if OBJECT is a string."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|obj
operator|)
name|Lisp_Object
name|obj
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|XTYPE
argument_list|(
name|obj
argument_list|)
operator|==
name|Lisp_String
condition|)
return|return
name|Qt
return|;
return|return
name|Qnil
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"arrayp"
argument_list|,
argument|Farrayp
argument_list|,
argument|Sarrayp
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"T if OBJECT is an array (string or vector)."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|obj
operator|)
name|Lisp_Object
name|obj
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|XTYPE
argument_list|(
name|obj
argument_list|)
operator|==
name|Lisp_Vector
operator|||
name|XTYPE
argument_list|(
name|obj
argument_list|)
operator|==
name|Lisp_String
condition|)
return|return
name|Qt
return|;
return|return
name|Qnil
return|;
block|}
end_block

begin_expr_stmt
name|DEFUN
argument_list|(
literal|"sequencep"
argument_list|,
name|Fsequencep
argument_list|,
name|Ssequencep
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"T if OBJECT is a sequence (list or array)."
argument_list|)
argument_list|(
name|obj
argument_list|)
specifier|register
name|Lisp_Object
name|obj
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|CONSP
argument_list|(
name|obj
argument_list|)
operator|||
name|NULL
argument_list|(
name|obj
argument_list|)
operator|||
name|XTYPE
argument_list|(
name|obj
argument_list|)
operator|==
name|Lisp_Vector
operator|||
name|XTYPE
argument_list|(
name|obj
argument_list|)
operator|==
name|Lisp_String
condition|)
return|return
name|Qt
return|;
return|return
name|Qnil
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"bufferp"
argument_list|,
argument|Fbufferp
argument_list|,
argument|Sbufferp
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"T if OBJECT is an editor buffer."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|obj
operator|)
name|Lisp_Object
name|obj
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|XTYPE
argument_list|(
name|obj
argument_list|)
operator|==
name|Lisp_Buffer
condition|)
return|return
name|Qt
return|;
return|return
name|Qnil
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"markerp"
argument_list|,
argument|Fmarkerp
argument_list|,
argument|Smarkerp
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"T if OBJECT is a marker (editor pointer)."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|obj
operator|)
name|Lisp_Object
name|obj
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|XTYPE
argument_list|(
name|obj
argument_list|)
operator|==
name|Lisp_Marker
condition|)
return|return
name|Qt
return|;
return|return
name|Qnil
return|;
block|}
end_block

begin_expr_stmt
name|DEFUN
argument_list|(
literal|"integer-or-marker-p"
argument_list|,
name|Finteger_or_marker_p
argument_list|,
name|Sinteger_or_marker_p
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"T if OBJECT is an integer or a marker (editor pointer)."
argument_list|)
argument_list|(
name|obj
argument_list|)
specifier|register
name|Lisp_Object
name|obj
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|XTYPE
argument_list|(
name|obj
argument_list|)
operator|==
name|Lisp_Marker
operator|||
name|XTYPE
argument_list|(
name|obj
argument_list|)
operator|==
name|Lisp_Int
condition|)
return|return
name|Qt
return|;
return|return
name|Qnil
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"subrp"
argument_list|,
argument|Fsubrp
argument_list|,
argument|Ssubrp
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"T if OBJECT is a built-in function."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|obj
operator|)
name|Lisp_Object
name|obj
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|XTYPE
argument_list|(
name|obj
argument_list|)
operator|==
name|Lisp_Subr
condition|)
return|return
name|Qt
return|;
return|return
name|Qnil
return|;
block|}
end_block

begin_expr_stmt
name|DEFUN
argument_list|(
literal|"char-or-string-p"
argument_list|,
name|Fchar_or_string_p
argument_list|,
name|Schar_or_string_p
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"T if OBJECT is a character (a number) or a string."
argument_list|)
argument_list|(
name|obj
argument_list|)
specifier|register
name|Lisp_Object
name|obj
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|XTYPE
argument_list|(
name|obj
argument_list|)
operator|==
name|Lisp_Int
operator|||
name|XTYPE
argument_list|(
name|obj
argument_list|)
operator|==
name|Lisp_String
condition|)
return|return
name|Qt
return|;
return|return
name|Qnil
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Extract and set components of lists */
end_comment

begin_expr_stmt
name|DEFUN
argument_list|(
literal|"car"
argument_list|,
name|Fcar
argument_list|,
name|Scar
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Return the car of CONSCELL.  If arg is nil, return nil."
argument_list|)
argument_list|(
name|list
argument_list|)
specifier|register
name|Lisp_Object
name|list
expr_stmt|;
end_expr_stmt

begin_block
block|{
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|XTYPE
argument_list|(
name|list
argument_list|)
operator|==
name|Lisp_Cons
condition|)
return|return
name|XCONS
argument_list|(
name|list
argument_list|)
operator|->
name|car
return|;
elseif|else
if|if
condition|(
name|EQ
argument_list|(
name|list
argument_list|,
name|Qnil
argument_list|)
condition|)
return|return
name|Qnil
return|;
else|else
name|list
operator|=
name|wrong_type_argument
argument_list|(
name|Qlistp
argument_list|,
name|list
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"car-safe"
argument_list|,
argument|Fcar_safe
argument_list|,
argument|Scar_safe
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Return the car of OBJECT if it is a cons cell, or else  nil."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|object
operator|)
name|Lisp_Object
name|object
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|XTYPE
argument_list|(
name|object
argument_list|)
operator|==
name|Lisp_Cons
condition|)
return|return
name|XCONS
argument_list|(
name|object
argument_list|)
operator|->
name|car
return|;
else|else
return|return
name|Qnil
return|;
block|}
end_block

begin_expr_stmt
name|DEFUN
argument_list|(
literal|"cdr"
argument_list|,
name|Fcdr
argument_list|,
name|Scdr
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Return the cdr of CONSCELL.  If arg is nil, return nil."
argument_list|)
argument_list|(
name|list
argument_list|)
specifier|register
name|Lisp_Object
name|list
expr_stmt|;
end_expr_stmt

begin_block
block|{
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|XTYPE
argument_list|(
name|list
argument_list|)
operator|==
name|Lisp_Cons
condition|)
return|return
name|XCONS
argument_list|(
name|list
argument_list|)
operator|->
name|cdr
return|;
elseif|else
if|if
condition|(
name|EQ
argument_list|(
name|list
argument_list|,
name|Qnil
argument_list|)
condition|)
return|return
name|Qnil
return|;
else|else
name|list
operator|=
name|wrong_type_argument
argument_list|(
name|Qlistp
argument_list|,
name|list
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"cdr-safe"
argument_list|,
argument|Fcdr_safe
argument_list|,
argument|Scdr_safe
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Return the cdr of OBJECT if it is a cons cell, or else  nil."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|object
operator|)
name|Lisp_Object
name|object
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|XTYPE
argument_list|(
name|object
argument_list|)
operator|==
name|Lisp_Cons
condition|)
return|return
name|XCONS
argument_list|(
name|object
argument_list|)
operator|->
name|cdr
return|;
else|else
return|return
name|Qnil
return|;
block|}
end_block

begin_expr_stmt
name|DEFUN
argument_list|(
literal|"setcar"
argument_list|,
name|Fsetcar
argument_list|,
name|Ssetcar
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"Set the car of CONSCELL to be NEWCAR.  Returns NEWCAR."
argument_list|)
argument_list|(
name|cell
argument_list|,
name|newcar
argument_list|)
specifier|register
name|Lisp_Object
name|cell
operator|,
name|newcar
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|XTYPE
argument_list|(
name|cell
argument_list|)
operator|!=
name|Lisp_Cons
condition|)
name|cell
operator|=
name|wrong_type_argument
argument_list|(
name|Qconsp
argument_list|,
name|cell
argument_list|)
expr_stmt|;
name|CHECK_IMPURE
argument_list|(
name|cell
argument_list|)
expr_stmt|;
name|XCONS
argument_list|(
name|cell
argument_list|)
operator|->
name|car
operator|=
name|newcar
expr_stmt|;
return|return
name|newcar
return|;
block|}
end_block

begin_expr_stmt
name|DEFUN
argument_list|(
literal|"setcdr"
argument_list|,
name|Fsetcdr
argument_list|,
name|Ssetcdr
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"Set the cdr of CONSCELL to be NEWCDR.  Returns NEWCDR."
argument_list|)
argument_list|(
name|cell
argument_list|,
name|newcdr
argument_list|)
specifier|register
name|Lisp_Object
name|cell
operator|,
name|newcdr
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|XTYPE
argument_list|(
name|cell
argument_list|)
operator|!=
name|Lisp_Cons
condition|)
name|cell
operator|=
name|wrong_type_argument
argument_list|(
name|Qconsp
argument_list|,
name|cell
argument_list|)
expr_stmt|;
name|CHECK_IMPURE
argument_list|(
name|cell
argument_list|)
expr_stmt|;
name|XCONS
argument_list|(
name|cell
argument_list|)
operator|->
name|cdr
operator|=
name|newcdr
expr_stmt|;
return|return
name|newcdr
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Extract and set components of symbols */
end_comment

begin_expr_stmt
name|DEFUN
argument_list|(
literal|"boundp"
argument_list|,
name|Fboundp
argument_list|,
name|Sboundp
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"T if SYMBOL's value is not void."
argument_list|)
argument_list|(
name|sym
argument_list|)
specifier|register
name|Lisp_Object
name|sym
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|CHECK_SYMBOL
argument_list|(
name|sym
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|XTYPE
argument_list|(
name|XSYMBOL
argument_list|(
name|sym
argument_list|)
operator|->
name|value
argument_list|)
operator|==
name|Lisp_Void
operator|||
name|EQ
argument_list|(
name|XSYMBOL
argument_list|(
name|sym
argument_list|)
operator|->
name|value
argument_list|,
name|Qunbound
argument_list|)
operator|)
condition|?
name|Qnil
else|:
name|Qt
return|;
block|}
end_block

begin_expr_stmt
name|DEFUN
argument_list|(
literal|"fboundp"
argument_list|,
name|Ffboundp
argument_list|,
name|Sfboundp
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"T if SYMBOL's function definition is not void."
argument_list|)
argument_list|(
name|sym
argument_list|)
specifier|register
name|Lisp_Object
name|sym
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|CHECK_SYMBOL
argument_list|(
name|sym
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|XTYPE
argument_list|(
name|XSYMBOL
argument_list|(
name|sym
argument_list|)
operator|->
name|function
argument_list|)
operator|==
name|Lisp_Void
operator|||
name|EQ
argument_list|(
name|XSYMBOL
argument_list|(
name|sym
argument_list|)
operator|->
name|function
argument_list|,
name|Qunbound
argument_list|)
operator|)
condition|?
name|Qnil
else|:
name|Qt
return|;
block|}
end_block

begin_expr_stmt
name|DEFUN
argument_list|(
literal|"makunbound"
argument_list|,
name|Fmakunbound
argument_list|,
name|Smakunbound
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Make SYMBOL's value be void."
argument_list|)
argument_list|(
name|sym
argument_list|)
specifier|register
name|Lisp_Object
name|sym
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|CHECK_SYMBOL
argument_list|(
name|sym
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|XSYMBOL
argument_list|(
name|sym
argument_list|)
operator|->
name|value
operator|=
name|Qunbound
expr_stmt|;
return|return
name|sym
return|;
block|}
end_block

begin_expr_stmt
name|DEFUN
argument_list|(
literal|"fmakunbound"
argument_list|,
name|Ffmakunbound
argument_list|,
name|Sfmakunbound
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Make SYMBOL's function definition be void."
argument_list|)
argument_list|(
name|sym
argument_list|)
specifier|register
name|Lisp_Object
name|sym
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|CHECK_SYMBOL
argument_list|(
name|sym
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|XSYMBOL
argument_list|(
name|sym
argument_list|)
operator|->
name|function
operator|=
name|Qunbound
expr_stmt|;
return|return
name|sym
return|;
block|}
end_block

begin_expr_stmt
name|DEFUN
argument_list|(
literal|"symbol-function"
argument_list|,
name|Fsymbol_function
argument_list|,
name|Ssymbol_function
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Return SYMBOL's function definition."
argument_list|)
argument_list|(
name|sym
argument_list|)
specifier|register
name|Lisp_Object
name|sym
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|CHECK_SYMBOL
argument_list|(
name|sym
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|EQ
argument_list|(
name|XSYMBOL
argument_list|(
name|sym
argument_list|)
operator|->
name|function
argument_list|,
name|Qunbound
argument_list|)
condition|)
return|return
name|Fsignal
argument_list|(
name|Qvoid_function
argument_list|,
name|Fcons
argument_list|(
name|sym
argument_list|,
name|Qnil
argument_list|)
argument_list|)
return|;
return|return
name|XSYMBOL
argument_list|(
name|sym
argument_list|)
operator|->
name|function
return|;
block|}
end_block

begin_expr_stmt
name|DEFUN
argument_list|(
literal|"symbol-plist"
argument_list|,
name|Fsymbol_plist
argument_list|,
name|Ssymbol_plist
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Return SYMBOL's property list."
argument_list|)
argument_list|(
name|sym
argument_list|)
specifier|register
name|Lisp_Object
name|sym
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|CHECK_SYMBOL
argument_list|(
name|sym
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|XSYMBOL
argument_list|(
name|sym
argument_list|)
operator|->
name|plist
return|;
block|}
end_block

begin_expr_stmt
name|DEFUN
argument_list|(
literal|"symbol-name"
argument_list|,
name|Fsymbol_name
argument_list|,
name|Ssymbol_name
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Return SYMBOL's name, a string."
argument_list|)
argument_list|(
name|sym
argument_list|)
specifier|register
name|Lisp_Object
name|sym
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|Lisp_Object
name|name
decl_stmt|;
name|CHECK_SYMBOL
argument_list|(
name|sym
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|XSET
argument_list|(
name|name
argument_list|,
name|Lisp_String
argument_list|,
name|XSYMBOL
argument_list|(
name|sym
argument_list|)
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
name|name
return|;
block|}
end_block

begin_expr_stmt
name|DEFUN
argument_list|(
literal|"fset"
argument_list|,
name|Ffset
argument_list|,
name|Sfset
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"Set SYMBOL's function definition to NEWVAL, and return NEWVAL."
argument_list|)
argument_list|(
name|sym
argument_list|,
name|newdef
argument_list|)
specifier|register
name|Lisp_Object
name|sym
operator|,
name|newdef
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|CHECK_SYMBOL
argument_list|(
name|sym
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|Vautoload_queue
argument_list|)
operator|&&
operator|!
name|EQ
argument_list|(
name|XSYMBOL
argument_list|(
name|sym
argument_list|)
operator|->
name|function
argument_list|,
name|Qunbound
argument_list|)
condition|)
name|Vautoload_queue
operator|=
name|Fcons
argument_list|(
name|Fcons
argument_list|(
name|sym
argument_list|,
name|XSYMBOL
argument_list|(
name|sym
argument_list|)
operator|->
name|function
argument_list|)
argument_list|,
name|Vautoload_queue
argument_list|)
expr_stmt|;
name|XSYMBOL
argument_list|(
name|sym
argument_list|)
operator|->
name|function
operator|=
name|newdef
expr_stmt|;
return|return
name|newdef
return|;
block|}
end_block

begin_expr_stmt
name|DEFUN
argument_list|(
literal|"setplist"
argument_list|,
name|Fsetplist
argument_list|,
name|Ssetplist
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"Set SYMBOL's property list to NEWVAL, and return NEWVAL."
argument_list|)
argument_list|(
name|sym
argument_list|,
name|newplist
argument_list|)
specifier|register
name|Lisp_Object
name|sym
operator|,
name|newplist
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|CHECK_SYMBOL
argument_list|(
name|sym
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|XSYMBOL
argument_list|(
name|sym
argument_list|)
operator|->
name|plist
operator|=
name|newplist
expr_stmt|;
return|return
name|newplist
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Getting and setting values of symbols */
end_comment

begin_comment
comment|/* Given the raw contents of a symbol value cell,  return the Lisp value of the symbol. */
end_comment

begin_function
name|Lisp_Object
name|do_symval_forwarding
parameter_list|(
name|valcontents
parameter_list|)
specifier|register
name|Lisp_Object
name|valcontents
decl_stmt|;
block|{
specifier|register
name|Lisp_Object
name|val
decl_stmt|;
ifdef|#
directive|ifdef
name|SWITCH_ENUM_BUG
switch|switch
condition|(
operator|(
name|int
operator|)
name|XTYPE
argument_list|(
name|valcontents
argument_list|)
condition|)
else|#
directive|else
switch|switch
condition|(
name|XTYPE
argument_list|(
name|valcontents
argument_list|)
condition|)
endif|#
directive|endif
block|{
case|case
name|Lisp_Intfwd
case|:
name|XSET
argument_list|(
name|val
argument_list|,
name|Lisp_Int
argument_list|,
operator|*
name|XINTPTR
argument_list|(
name|valcontents
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|val
return|;
case|case
name|Lisp_Boolfwd
case|:
if|if
condition|(
operator|*
name|XINTPTR
argument_list|(
name|valcontents
argument_list|)
condition|)
return|return
name|Qt
return|;
return|return
name|Qnil
return|;
case|case
name|Lisp_Objfwd
case|:
return|return
operator|*
name|XOBJFWD
argument_list|(
name|valcontents
argument_list|)
return|;
case|case
name|Lisp_Buffer_Objfwd
case|:
return|return
operator|*
operator|(
name|Lisp_Object
operator|*
operator|)
operator|(
name|XUINT
argument_list|(
name|valcontents
argument_list|)
operator|+
operator|(
name|char
operator|*
operator|)
name|current_buffer
operator|)
return|;
block|}
return|return
name|valcontents
return|;
block|}
end_function

begin_function
name|void
name|store_symval_forwarding
parameter_list|(
name|sym
parameter_list|,
name|valcontents
parameter_list|,
name|newval
parameter_list|)
name|Lisp_Object
name|sym
decl_stmt|;
specifier|register
name|Lisp_Object
name|valcontents
decl_stmt|,
name|newval
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|SWITCH_ENUM_BUG
switch|switch
condition|(
operator|(
name|int
operator|)
name|XTYPE
argument_list|(
name|valcontents
argument_list|)
condition|)
else|#
directive|else
switch|switch
condition|(
name|XTYPE
argument_list|(
name|valcontents
argument_list|)
condition|)
endif|#
directive|endif
block|{
case|case
name|Lisp_Intfwd
case|:
name|CHECK_NUMBER
argument_list|(
name|newval
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|*
name|XINTPTR
argument_list|(
name|valcontents
argument_list|)
operator|=
name|XINT
argument_list|(
name|newval
argument_list|)
expr_stmt|;
break|break;
case|case
name|Lisp_Boolfwd
case|:
operator|*
name|XINTPTR
argument_list|(
name|valcontents
argument_list|)
operator|=
name|NULL
argument_list|(
name|newval
argument_list|)
condition|?
literal|0
else|:
literal|1
expr_stmt|;
break|break;
case|case
name|Lisp_Objfwd
case|:
operator|*
name|XOBJFWD
argument_list|(
name|valcontents
argument_list|)
operator|=
name|newval
expr_stmt|;
break|break;
case|case
name|Lisp_Buffer_Objfwd
case|:
operator|*
operator|(
name|Lisp_Object
operator|*
operator|)
operator|(
name|XUINT
argument_list|(
name|valcontents
argument_list|)
operator|+
operator|(
name|char
operator|*
operator|)
name|current_buffer
operator|)
operator|=
name|newval
expr_stmt|;
break|break;
default|default:
name|valcontents
operator|=
name|XSYMBOL
argument_list|(
name|sym
argument_list|)
operator|->
name|value
expr_stmt|;
if|if
condition|(
name|XTYPE
argument_list|(
name|valcontents
argument_list|)
operator|==
name|Lisp_Buffer_Local_Value
operator|||
name|XTYPE
argument_list|(
name|valcontents
argument_list|)
operator|==
name|Lisp_Some_Buffer_Local_Value
condition|)
name|XCONS
argument_list|(
name|XSYMBOL
argument_list|(
name|sym
argument_list|)
operator|->
name|value
argument_list|)
operator|->
name|car
operator|=
name|newval
expr_stmt|;
else|else
name|XSYMBOL
argument_list|(
name|sym
argument_list|)
operator|->
name|value
operator|=
name|newval
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Note that it must not be possible to quit within this function.    Great care is required for this.  */
end_comment

begin_macro
name|DEFUN
argument_list|(
literal|"symbol-value"
argument_list|,
argument|Fsymbol_value
argument_list|,
argument|Ssymbol_value
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Return SYMBOL's value."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|sym
operator|)
name|Lisp_Object
name|sym
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|Lisp_Object
name|valcontents
decl_stmt|,
name|tem1
decl_stmt|;
specifier|register
name|Lisp_Object
name|val
decl_stmt|;
name|CHECK_SYMBOL
argument_list|(
name|sym
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|valcontents
operator|=
name|XSYMBOL
argument_list|(
name|sym
argument_list|)
operator|->
name|value
expr_stmt|;
name|retry
label|:
ifdef|#
directive|ifdef
name|SWITCH_ENUM_BUG
switch|switch
condition|(
operator|(
name|int
operator|)
name|XTYPE
argument_list|(
name|valcontents
argument_list|)
condition|)
else|#
directive|else
switch|switch
condition|(
name|XTYPE
argument_list|(
name|valcontents
argument_list|)
condition|)
endif|#
directive|endif
block|{
case|case
name|Lisp_Buffer_Local_Value
case|:
case|case
name|Lisp_Some_Buffer_Local_Value
case|:
comment|/* valcontents is a list         (REALVALUE BUFFER CURRENT-ALIST-ELEMENT . DEFAULT-VALUE)).          CURRENT-ALIST-ELEMENT is a pointer to an element of BUFFER's 	local_var_alist, that being the element whose car is this variable.         Or it can be a pointer to the (CURRENT-ALIST-ELEMENT . DEFAULT-VALUE), if BUFFER 	does not have an element in its alist for this variable.  	If the current buffer is not BUFFER, we store the current REALVALUE value into 	CURRENT-ALIST-ELEMENT, then find the appropriate alist element for 	the buffer now current and set up CURRENT-ALIST-ELEMENT. 	Then we set REALVALUE out of that element, and store into BUFFER.  	Note that REALVALUE can be a forwarding pointer. */
name|tem1
operator|=
name|XCONS
argument_list|(
name|XCONS
argument_list|(
name|valcontents
argument_list|)
operator|->
name|cdr
argument_list|)
operator|->
name|car
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|tem1
argument_list|)
operator|||
name|current_buffer
operator|!=
name|XBUFFER
argument_list|(
name|tem1
argument_list|)
condition|)
block|{
name|tem1
operator|=
name|XCONS
argument_list|(
name|XCONS
argument_list|(
name|XCONS
argument_list|(
name|valcontents
argument_list|)
operator|->
name|cdr
argument_list|)
operator|->
name|cdr
argument_list|)
operator|->
name|car
expr_stmt|;
name|Fsetcdr
argument_list|(
name|tem1
argument_list|,
name|do_symval_forwarding
argument_list|(
name|XCONS
argument_list|(
name|valcontents
argument_list|)
operator|->
name|car
argument_list|)
argument_list|)
expr_stmt|;
name|tem1
operator|=
name|assq_no_quit
argument_list|(
name|sym
argument_list|,
name|current_buffer
operator|->
name|local_var_alist
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|tem1
argument_list|)
condition|)
name|tem1
operator|=
name|XCONS
argument_list|(
name|XCONS
argument_list|(
name|valcontents
argument_list|)
operator|->
name|cdr
argument_list|)
operator|->
name|cdr
expr_stmt|;
name|XCONS
argument_list|(
name|XCONS
argument_list|(
name|XCONS
argument_list|(
name|valcontents
argument_list|)
operator|->
name|cdr
argument_list|)
operator|->
name|cdr
argument_list|)
operator|->
name|car
operator|=
name|tem1
expr_stmt|;
name|XSET
argument_list|(
name|XCONS
argument_list|(
name|XCONS
argument_list|(
name|valcontents
argument_list|)
operator|->
name|cdr
argument_list|)
operator|->
name|car
argument_list|,
name|Lisp_Buffer
argument_list|,
name|current_buffer
argument_list|)
expr_stmt|;
name|store_symval_forwarding
argument_list|(
name|sym
argument_list|,
name|XCONS
argument_list|(
name|valcontents
argument_list|)
operator|->
name|car
argument_list|,
name|Fcdr
argument_list|(
name|tem1
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|valcontents
operator|=
name|XCONS
argument_list|(
name|valcontents
argument_list|)
operator|->
name|car
expr_stmt|;
goto|goto
name|retry
goto|;
case|case
name|Lisp_Intfwd
case|:
name|XSET
argument_list|(
name|val
argument_list|,
name|Lisp_Int
argument_list|,
operator|*
name|XINTPTR
argument_list|(
name|valcontents
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|val
return|;
case|case
name|Lisp_Boolfwd
case|:
if|if
condition|(
operator|*
name|XINTPTR
argument_list|(
name|valcontents
argument_list|)
condition|)
return|return
name|Qt
return|;
return|return
name|Qnil
return|;
case|case
name|Lisp_Objfwd
case|:
return|return
operator|*
name|XOBJFWD
argument_list|(
name|valcontents
argument_list|)
return|;
case|case
name|Lisp_Buffer_Objfwd
case|:
return|return
operator|*
operator|(
name|Lisp_Object
operator|*
operator|)
operator|(
name|XUINT
argument_list|(
name|valcontents
argument_list|)
operator|+
operator|(
name|char
operator|*
operator|)
name|current_buffer
operator|)
return|;
case|case
name|Lisp_Symbol
case|:
comment|/* For a symbol, check whether it is 'unbound. */
if|if
condition|(
operator|!
name|EQ
argument_list|(
name|valcontents
argument_list|,
name|Qunbound
argument_list|)
condition|)
break|break;
comment|/* drops through! */
case|case
name|Lisp_Void
case|:
return|return
name|Fsignal
argument_list|(
name|Qvoid_variable
argument_list|,
name|Fcons
argument_list|(
name|sym
argument_list|,
name|Qnil
argument_list|)
argument_list|)
return|;
block|}
return|return
name|valcontents
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"default-value"
argument_list|,
argument|Fdefault_value
argument_list|,
argument|Sdefault_value
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Return SYMBOL's default value.\n\ This is the value that is seen in buffers that do not have their own values\n\ for this variable."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|sym
operator|)
name|Lisp_Object
name|sym
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|Lisp_Object
name|valcontents
decl_stmt|;
name|CHECK_SYMBOL
argument_list|(
name|sym
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|valcontents
operator|=
name|XSYMBOL
argument_list|(
name|sym
argument_list|)
operator|->
name|value
expr_stmt|;
if|if
condition|(
name|XTYPE
argument_list|(
name|valcontents
argument_list|)
operator|==
name|Lisp_Buffer_Objfwd
condition|)
block|{
specifier|register
name|int
name|idx
init|=
name|XUINT
argument_list|(
name|valcontents
argument_list|)
decl_stmt|;
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
operator|(
name|idx
operator|+
operator|(
name|char
operator|*
operator|)
operator|&
name|buffer_local_flags
operator|)
operator|!=
literal|0
condition|)
return|return
operator|*
operator|(
name|Lisp_Object
operator|*
operator|)
operator|(
name|idx
operator|+
operator|(
name|char
operator|*
operator|)
operator|&
name|buffer_defaults
operator|)
return|;
block|}
if|if
condition|(
name|XTYPE
argument_list|(
name|valcontents
argument_list|)
operator|==
name|Lisp_Buffer_Local_Value
operator|||
name|XTYPE
argument_list|(
name|valcontents
argument_list|)
operator|==
name|Lisp_Some_Buffer_Local_Value
condition|)
return|return
name|XCONS
argument_list|(
name|XCONS
argument_list|(
name|XCONS
argument_list|(
name|valcontents
argument_list|)
operator|->
name|cdr
argument_list|)
operator|->
name|cdr
argument_list|)
operator|->
name|cdr
return|;
return|return
name|Fsymbol_value
argument_list|(
name|sym
argument_list|)
return|;
block|}
end_block

begin_expr_stmt
name|DEFUN
argument_list|(
literal|"set"
argument_list|,
name|Fset
argument_list|,
name|Sset
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"Set SYMBOL's value to NEWVAL, and return NEWVAL."
argument_list|)
argument_list|(
name|sym
argument_list|,
name|newval
argument_list|)
specifier|register
name|Lisp_Object
name|sym
operator|,
name|newval
expr_stmt|;
end_expr_stmt

begin_block
block|{
ifndef|#
directive|ifndef
name|RTPC_REGISTER_BUG
specifier|register
name|Lisp_Object
name|valcontents
decl_stmt|,
name|tem1
decl_stmt|,
name|current_alist_element
decl_stmt|;
else|#
directive|else
comment|/* RTPC_REGISTER_BUG */
specifier|register
name|Lisp_Object
name|tem1
decl_stmt|;
name|Lisp_Object
name|valcontents
decl_stmt|,
name|current_alist_element
decl_stmt|;
endif|#
directive|endif
comment|/* RTPC_REGISTER_BUG */
name|CHECK_SYMBOL
argument_list|(
name|sym
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|sym
argument_list|)
operator|||
name|EQ
argument_list|(
name|sym
argument_list|,
name|Qt
argument_list|)
condition|)
return|return
name|Fsignal
argument_list|(
name|Qsetting_constant
argument_list|,
name|Fcons
argument_list|(
name|sym
argument_list|,
name|Qnil
argument_list|)
argument_list|)
return|;
name|valcontents
operator|=
name|XSYMBOL
argument_list|(
name|sym
argument_list|)
operator|->
name|value
expr_stmt|;
if|if
condition|(
name|XTYPE
argument_list|(
name|valcontents
argument_list|)
operator|==
name|Lisp_Buffer_Objfwd
condition|)
block|{
specifier|register
name|int
name|idx
init|=
name|XUINT
argument_list|(
name|valcontents
argument_list|)
decl_stmt|;
specifier|register
name|int
name|mask
init|=
operator|*
operator|(
name|int
operator|*
operator|)
operator|(
name|idx
operator|+
operator|(
name|char
operator|*
operator|)
operator|&
name|buffer_local_flags
operator|)
decl_stmt|;
if|if
condition|(
name|mask
operator|>
literal|0
condition|)
name|current_buffer
operator|->
name|local_var_flags
operator||=
name|mask
expr_stmt|;
block|}
if|if
condition|(
name|XTYPE
argument_list|(
name|valcontents
argument_list|)
operator|==
name|Lisp_Buffer_Local_Value
operator|||
name|XTYPE
argument_list|(
name|valcontents
argument_list|)
operator|==
name|Lisp_Some_Buffer_Local_Value
condition|)
block|{
comment|/* valcontents is a list         (REALVALUE BUFFER CURRENT-ALIST-ELEMENT . DEFAULT-VALUE)).          CURRENT-ALIST-ELEMENT is a pointer to an element of BUFFER's 	local_var_alist, that being the element whose car is this variable.         Or it can be a pointer to the (CURRENT-ALIST-ELEMENT . DEFAULT-VALUE), if BUFFER 	does not have an element in its alist for this variable.  	If the current buffer is not BUFFER, we store the current REALVALUE value into 	CURRENT-ALIST-ELEMENT, then find the appropriate alist element for 	the buffer now current and set up CURRENT-ALIST-ELEMENT. 	Then we set REALVALUE out of that element, and store into BUFFER. 	Note that REALVALUE can be a forwarding pointer. */
name|current_alist_element
operator|=
name|XCONS
argument_list|(
name|XCONS
argument_list|(
name|XCONS
argument_list|(
name|valcontents
argument_list|)
operator|->
name|cdr
argument_list|)
operator|->
name|cdr
argument_list|)
operator|->
name|car
expr_stmt|;
if|if
condition|(
name|current_buffer
operator|!=
operator|(
operator|(
name|XTYPE
argument_list|(
name|valcontents
argument_list|)
operator|==
name|Lisp_Some_Buffer_Local_Value
operator|)
condition|?
name|XBUFFER
argument_list|(
name|XCONS
argument_list|(
name|XCONS
argument_list|(
name|valcontents
argument_list|)
operator|->
name|cdr
argument_list|)
operator|->
name|car
argument_list|)
else|:
name|XBUFFER
argument_list|(
name|XCONS
argument_list|(
name|current_alist_element
argument_list|)
operator|->
name|car
argument_list|)
operator|)
condition|)
block|{
name|Fsetcdr
argument_list|(
name|current_alist_element
argument_list|,
name|do_symval_forwarding
argument_list|(
name|XCONS
argument_list|(
name|valcontents
argument_list|)
operator|->
name|car
argument_list|)
argument_list|)
expr_stmt|;
name|tem1
operator|=
name|Fassq
argument_list|(
name|sym
argument_list|,
name|current_buffer
operator|->
name|local_var_alist
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|tem1
argument_list|)
condition|)
comment|/* This buffer sees the default value still. 	       If type is Lisp_Some_Buffer_Local_Value, set the default value. 	       If type is Lisp_Buffer_Local_Value, give this buffer a local value 		and set that.  */
if|if
condition|(
name|XTYPE
argument_list|(
name|valcontents
argument_list|)
operator|==
name|Lisp_Some_Buffer_Local_Value
condition|)
name|tem1
operator|=
name|XCONS
argument_list|(
name|XCONS
argument_list|(
name|valcontents
argument_list|)
operator|->
name|cdr
argument_list|)
operator|->
name|cdr
expr_stmt|;
else|else
block|{
name|tem1
operator|=
name|Fcons
argument_list|(
name|sym
argument_list|,
name|Fcdr
argument_list|(
name|current_alist_element
argument_list|)
argument_list|)
expr_stmt|;
name|current_buffer
operator|->
name|local_var_alist
operator|=
name|Fcons
argument_list|(
name|tem1
argument_list|,
name|current_buffer
operator|->
name|local_var_alist
argument_list|)
expr_stmt|;
block|}
name|XCONS
argument_list|(
name|XCONS
argument_list|(
name|XCONS
argument_list|(
name|valcontents
argument_list|)
operator|->
name|cdr
argument_list|)
operator|->
name|cdr
argument_list|)
operator|->
name|car
operator|=
name|tem1
expr_stmt|;
name|XSET
argument_list|(
name|XCONS
argument_list|(
name|XCONS
argument_list|(
name|valcontents
argument_list|)
operator|->
name|cdr
argument_list|)
operator|->
name|car
argument_list|,
name|Lisp_Buffer
argument_list|,
name|current_buffer
argument_list|)
expr_stmt|;
block|}
name|valcontents
operator|=
name|XCONS
argument_list|(
name|valcontents
argument_list|)
operator|->
name|car
expr_stmt|;
block|}
name|store_symval_forwarding
argument_list|(
name|sym
argument_list|,
name|valcontents
argument_list|,
name|newval
argument_list|)
expr_stmt|;
return|return
name|newval
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"set-default"
argument_list|,
argument|Fset_default
argument_list|,
argument|Sset_default
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"Set SYMBOL's default value to VAL.  SYMBOL and VAL are evaluated.\n\ The default value is seen in buffers that do not have their own values\n\ for this variable."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|sym
operator|,
name|value
operator|)
name|Lisp_Object
name|sym
operator|,
name|value
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|Lisp_Object
name|valcontents
decl_stmt|,
name|current_alist_element
decl_stmt|,
name|alist_element_buffer
decl_stmt|;
name|CHECK_SYMBOL
argument_list|(
name|sym
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|valcontents
operator|=
name|XSYMBOL
argument_list|(
name|sym
argument_list|)
operator|->
name|value
expr_stmt|;
comment|/* Handle variables like case-fold-search that have special slots      in the buffer.  Make them work apparently like Lisp_Buffer_Local_Value      variables.  */
if|if
condition|(
name|XTYPE
argument_list|(
name|valcontents
argument_list|)
operator|==
name|Lisp_Buffer_Objfwd
condition|)
block|{
specifier|register
name|int
name|idx
init|=
name|XUINT
argument_list|(
name|valcontents
argument_list|)
decl_stmt|;
ifndef|#
directive|ifndef
name|RTPC_REGISTER_BUG
specifier|register
name|struct
name|buffer
modifier|*
name|b
decl_stmt|;
else|#
directive|else
name|struct
name|buffer
modifier|*
name|b
decl_stmt|;
endif|#
directive|endif
specifier|register
name|int
name|mask
init|=
operator|*
operator|(
name|int
operator|*
operator|)
operator|(
name|idx
operator|+
operator|(
name|char
operator|*
operator|)
operator|&
name|buffer_local_flags
operator|)
decl_stmt|;
if|if
condition|(
name|mask
operator|>
literal|0
condition|)
block|{
operator|*
operator|(
name|Lisp_Object
operator|*
operator|)
operator|(
name|idx
operator|+
operator|(
name|char
operator|*
operator|)
operator|&
name|buffer_defaults
operator|)
operator|=
name|value
expr_stmt|;
for|for
control|(
name|b
operator|=
name|all_buffers
init|;
name|b
condition|;
name|b
operator|=
name|b
operator|->
name|next
control|)
if|if
condition|(
operator|!
operator|(
name|b
operator|->
name|local_var_flags
operator|&
name|mask
operator|)
condition|)
operator|*
operator|(
name|Lisp_Object
operator|*
operator|)
operator|(
name|idx
operator|+
operator|(
name|char
operator|*
operator|)
name|b
operator|)
operator|=
name|value
expr_stmt|;
block|}
return|return
name|value
return|;
block|}
if|if
condition|(
name|XTYPE
argument_list|(
name|valcontents
argument_list|)
operator|!=
name|Lisp_Buffer_Local_Value
operator|&&
name|XTYPE
argument_list|(
name|valcontents
argument_list|)
operator|!=
name|Lisp_Some_Buffer_Local_Value
condition|)
return|return
name|Fset
argument_list|(
name|sym
argument_list|,
name|value
argument_list|)
return|;
comment|/* Store new value into the DEFAULT-VALUE slot */
name|XCONS
argument_list|(
name|XCONS
argument_list|(
name|XCONS
argument_list|(
name|valcontents
argument_list|)
operator|->
name|cdr
argument_list|)
operator|->
name|cdr
argument_list|)
operator|->
name|cdr
operator|=
name|value
expr_stmt|;
comment|/* If that slot is current, we must set the REALVALUE slot too */
name|current_alist_element
operator|=
name|XCONS
argument_list|(
name|XCONS
argument_list|(
name|XCONS
argument_list|(
name|valcontents
argument_list|)
operator|->
name|cdr
argument_list|)
operator|->
name|cdr
argument_list|)
operator|->
name|car
expr_stmt|;
name|alist_element_buffer
operator|=
name|Fcar
argument_list|(
name|current_alist_element
argument_list|)
expr_stmt|;
if|if
condition|(
name|EQ
argument_list|(
name|alist_element_buffer
argument_list|,
name|current_alist_element
argument_list|)
condition|)
name|store_symval_forwarding
argument_list|(
name|sym
argument_list|,
name|XCONS
argument_list|(
name|valcontents
argument_list|)
operator|->
name|car
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
name|value
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"setq-default"
argument_list|,
argument|Fsetq_default
argument_list|,
argument|Ssetq_default
argument_list|,
literal|2
argument_list|,
argument|UNEVALLED
argument_list|,
literal|0
argument_list|,
literal|"Set SYMBOL's default value to VAL.  VAL is evaluated; SYMBOL is not.\n\ The default value is seen in buffers that do not have their own values\n\ for this variable."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|args
operator|)
name|Lisp_Object
name|args
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|Lisp_Object
name|val
decl_stmt|;
name|struct
name|gcpro
name|gcpro1
decl_stmt|;
name|GCPRO1
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|val
operator|=
name|Feval
argument_list|(
name|Fcar
argument_list|(
name|Fcdr
argument_list|(
name|args
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|UNGCPRO
expr_stmt|;
return|return
name|Fset_default
argument_list|(
name|Fcar
argument_list|(
name|args
argument_list|)
argument_list|,
name|val
argument_list|)
return|;
block|}
end_block

begin_expr_stmt
name|DEFUN
argument_list|(
literal|"make-variable-buffer-local"
argument_list|,
name|Fmake_variable_buffer_local
argument_list|,
name|Smake_variable_buffer_local
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|"vMake Variable Buffer Local: "
argument_list|,
literal|"Make VARIABLE have a separate value for each buffer.\n\ At any time, the value for the current buffer is in effect.\n\ There is also a default value which is seen in any buffer which has not yet\n\ set its own value.\n\ The function `default-value' gets the default value and `set-default' sets it.\n\ Using `set' or `setq' to set the variable causes it to have a separate value\n\ for the current buffer if it was previously using the default value."
argument_list|)
argument_list|(
name|sym
argument_list|)
specifier|register
name|Lisp_Object
name|sym
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|Lisp_Object
name|tem
decl_stmt|,
name|valcontents
decl_stmt|;
name|CHECK_SYMBOL
argument_list|(
name|sym
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|EQ
argument_list|(
name|sym
argument_list|,
name|Qnil
argument_list|)
operator|||
name|EQ
argument_list|(
name|sym
argument_list|,
name|Qt
argument_list|)
condition|)
name|error
argument_list|(
literal|"Symbol %s may not be buffer-local"
argument_list|,
name|XSYMBOL
argument_list|(
name|sym
argument_list|)
operator|->
name|name
operator|->
name|data
argument_list|)
expr_stmt|;
name|valcontents
operator|=
name|XSYMBOL
argument_list|(
name|sym
argument_list|)
operator|->
name|value
expr_stmt|;
if|if
condition|(
operator|(
name|XTYPE
argument_list|(
name|valcontents
argument_list|)
operator|==
name|Lisp_Buffer_Local_Value
operator|)
operator|||
operator|(
name|XTYPE
argument_list|(
name|valcontents
argument_list|)
operator|==
name|Lisp_Buffer_Objfwd
operator|)
condition|)
return|return
name|sym
return|;
if|if
condition|(
name|XTYPE
argument_list|(
name|valcontents
argument_list|)
operator|==
name|Lisp_Some_Buffer_Local_Value
condition|)
block|{
name|XSETTYPE
argument_list|(
name|XSYMBOL
argument_list|(
name|sym
argument_list|)
operator|->
name|value
argument_list|,
name|Lisp_Buffer_Local_Value
argument_list|)
expr_stmt|;
return|return
name|sym
return|;
block|}
if|if
condition|(
name|EQ
argument_list|(
name|valcontents
argument_list|,
name|Qunbound
argument_list|)
condition|)
name|XSYMBOL
argument_list|(
name|sym
argument_list|)
operator|->
name|value
operator|=
name|Qnil
expr_stmt|;
name|tem
operator|=
name|Fcons
argument_list|(
name|Qnil
argument_list|,
name|Fsymbol_value
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
name|XCONS
argument_list|(
name|tem
argument_list|)
operator|->
name|car
operator|=
name|tem
expr_stmt|;
name|XSYMBOL
argument_list|(
name|sym
argument_list|)
operator|->
name|value
operator|=
name|Fcons
argument_list|(
name|XSYMBOL
argument_list|(
name|sym
argument_list|)
operator|->
name|value
argument_list|,
name|Fcons
argument_list|(
name|Fcurrent_buffer
argument_list|()
argument_list|,
name|tem
argument_list|)
argument_list|)
expr_stmt|;
name|XSETTYPE
argument_list|(
name|XSYMBOL
argument_list|(
name|sym
argument_list|)
operator|->
name|value
argument_list|,
name|Lisp_Buffer_Local_Value
argument_list|)
expr_stmt|;
return|return
name|sym
return|;
block|}
end_block

begin_expr_stmt
name|DEFUN
argument_list|(
literal|"make-local-variable"
argument_list|,
name|Fmake_local_variable
argument_list|,
name|Smake_local_variable
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|"vMake Local Variable: "
argument_list|,
literal|"Make VARIABLE have a separate value in the current buffer.\n\ Other buffers will continue to share a common default value.\n\ See also `make-variable-buffer-local'."
argument_list|)
argument_list|(
name|sym
argument_list|)
specifier|register
name|Lisp_Object
name|sym
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|Lisp_Object
name|tem
decl_stmt|,
name|valcontents
decl_stmt|;
name|CHECK_SYMBOL
argument_list|(
name|sym
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|EQ
argument_list|(
name|sym
argument_list|,
name|Qnil
argument_list|)
operator|||
name|EQ
argument_list|(
name|sym
argument_list|,
name|Qt
argument_list|)
condition|)
name|error
argument_list|(
literal|"Symbol %s may not be buffer-local"
argument_list|,
name|XSYMBOL
argument_list|(
name|sym
argument_list|)
operator|->
name|name
operator|->
name|data
argument_list|)
expr_stmt|;
name|valcontents
operator|=
name|XSYMBOL
argument_list|(
name|sym
argument_list|)
operator|->
name|value
expr_stmt|;
if|if
condition|(
operator|(
name|XTYPE
argument_list|(
name|valcontents
argument_list|)
operator|==
name|Lisp_Buffer_Local_Value
operator|)
operator|||
operator|(
name|XTYPE
argument_list|(
name|valcontents
argument_list|)
operator|==
name|Lisp_Buffer_Objfwd
operator|)
condition|)
return|return
name|sym
return|;
comment|/* Make sure sym is set up to hold per-buffer values */
if|if
condition|(
name|XTYPE
argument_list|(
name|valcontents
argument_list|)
operator|!=
name|Lisp_Some_Buffer_Local_Value
condition|)
block|{
if|if
condition|(
name|EQ
argument_list|(
name|valcontents
argument_list|,
name|Qunbound
argument_list|)
condition|)
name|XSYMBOL
argument_list|(
name|sym
argument_list|)
operator|->
name|value
operator|=
name|Qnil
expr_stmt|;
name|tem
operator|=
name|Fcons
argument_list|(
name|Qnil
argument_list|,
name|Fsymbol_value
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
name|XCONS
argument_list|(
name|tem
argument_list|)
operator|->
name|car
operator|=
name|tem
expr_stmt|;
name|XSYMBOL
argument_list|(
name|sym
argument_list|)
operator|->
name|value
operator|=
name|Fcons
argument_list|(
name|XSYMBOL
argument_list|(
name|sym
argument_list|)
operator|->
name|value
argument_list|,
name|Fcons
argument_list|(
name|Qnil
argument_list|,
name|tem
argument_list|)
argument_list|)
expr_stmt|;
name|XSETTYPE
argument_list|(
name|XSYMBOL
argument_list|(
name|sym
argument_list|)
operator|->
name|value
argument_list|,
name|Lisp_Some_Buffer_Local_Value
argument_list|)
expr_stmt|;
block|}
comment|/* Make sure this buffer has its own value of sym */
name|tem
operator|=
name|Fassq
argument_list|(
name|sym
argument_list|,
name|current_buffer
operator|->
name|local_var_alist
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|tem
argument_list|)
condition|)
block|{
name|current_buffer
operator|->
name|local_var_alist
operator|=
name|Fcons
argument_list|(
name|Fcons
argument_list|(
name|sym
argument_list|,
name|XCONS
argument_list|(
name|XCONS
argument_list|(
name|XCONS
argument_list|(
name|XSYMBOL
argument_list|(
name|sym
argument_list|)
operator|->
name|value
argument_list|)
operator|->
name|cdr
argument_list|)
operator|->
name|cdr
argument_list|)
operator|->
name|cdr
argument_list|)
argument_list|,
name|current_buffer
operator|->
name|local_var_alist
argument_list|)
expr_stmt|;
comment|/* Make sure symbol does not think it is set up for this buffer; 	 force it to look once again for this buffer's value */
block|{
comment|/* This local variable avoids "expression to complex" on IBM RT.  */
name|Lisp_Object
name|xs
decl_stmt|;
name|xs
operator|=
name|XSYMBOL
argument_list|(
name|sym
argument_list|)
operator|->
name|value
expr_stmt|;
if|if
condition|(
name|current_buffer
operator|==
name|XBUFFER
argument_list|(
name|XCONS
argument_list|(
name|XCONS
argument_list|(
name|xs
argument_list|)
operator|->
name|cdr
argument_list|)
operator|->
name|car
argument_list|)
condition|)
name|XCONS
argument_list|(
name|XCONS
argument_list|(
name|XSYMBOL
argument_list|(
name|sym
argument_list|)
operator|->
name|value
argument_list|)
operator|->
name|cdr
argument_list|)
operator|->
name|car
operator|=
name|Qnil
expr_stmt|;
block|}
block|}
return|return
name|sym
return|;
block|}
end_block

begin_expr_stmt
name|DEFUN
argument_list|(
literal|"kill-local-variable"
argument_list|,
name|Fkill_local_variable
argument_list|,
name|Skill_local_variable
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|"vKill Local Variable: "
argument_list|,
literal|"Make VARIABLE no longer have a separate value in the current buffer.\n\ From now on the default value will apply in this buffer."
argument_list|)
argument_list|(
name|sym
argument_list|)
specifier|register
name|Lisp_Object
name|sym
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|Lisp_Object
name|tem
decl_stmt|,
name|valcontents
decl_stmt|;
name|CHECK_SYMBOL
argument_list|(
name|sym
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|valcontents
operator|=
name|XSYMBOL
argument_list|(
name|sym
argument_list|)
operator|->
name|value
expr_stmt|;
if|if
condition|(
name|XTYPE
argument_list|(
name|valcontents
argument_list|)
operator|==
name|Lisp_Buffer_Objfwd
condition|)
block|{
specifier|register
name|int
name|idx
init|=
name|XUINT
argument_list|(
name|valcontents
argument_list|)
decl_stmt|;
specifier|register
name|int
name|mask
init|=
operator|*
operator|(
name|int
operator|*
operator|)
operator|(
name|idx
operator|+
operator|(
name|char
operator|*
operator|)
operator|&
name|buffer_local_flags
operator|)
decl_stmt|;
if|if
condition|(
name|mask
operator|>
literal|0
condition|)
block|{
operator|*
operator|(
name|Lisp_Object
operator|*
operator|)
operator|(
name|idx
operator|+
operator|(
name|char
operator|*
operator|)
name|current_buffer
operator|)
operator|=
operator|*
operator|(
name|Lisp_Object
operator|*
operator|)
operator|(
name|idx
operator|+
operator|(
name|char
operator|*
operator|)
operator|&
name|buffer_defaults
operator|)
expr_stmt|;
name|current_buffer
operator|->
name|local_var_flags
operator|&=
operator|~
name|mask
expr_stmt|;
block|}
return|return
name|sym
return|;
block|}
if|if
condition|(
name|XTYPE
argument_list|(
name|valcontents
argument_list|)
operator|!=
name|Lisp_Buffer_Local_Value
operator|&&
name|XTYPE
argument_list|(
name|valcontents
argument_list|)
operator|!=
name|Lisp_Some_Buffer_Local_Value
condition|)
return|return
name|sym
return|;
comment|/* Get rid of this buffer's alist element, if any */
name|tem
operator|=
name|Fassq
argument_list|(
name|sym
argument_list|,
name|current_buffer
operator|->
name|local_var_alist
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|tem
argument_list|)
condition|)
name|current_buffer
operator|->
name|local_var_alist
operator|=
name|Fdelq
argument_list|(
name|tem
argument_list|,
name|current_buffer
operator|->
name|local_var_alist
argument_list|)
expr_stmt|;
comment|/* Make sure symbol does not think it is set up for this buffer;      force it to look once again for this buffer's value */
block|{
name|Lisp_Object
name|sv
decl_stmt|;
name|sv
operator|=
name|XSYMBOL
argument_list|(
name|sym
argument_list|)
operator|->
name|value
expr_stmt|;
if|if
condition|(
name|current_buffer
operator|==
name|XBUFFER
argument_list|(
name|XCONS
argument_list|(
name|XCONS
argument_list|(
name|sv
argument_list|)
operator|->
name|cdr
argument_list|)
operator|->
name|car
argument_list|)
condition|)
name|XCONS
argument_list|(
name|XCONS
argument_list|(
name|sv
argument_list|)
operator|->
name|cdr
argument_list|)
operator|->
name|car
operator|=
name|Qnil
expr_stmt|;
block|}
return|return
name|sym
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Extract and set vector and string elements */
end_comment

begin_expr_stmt
name|DEFUN
argument_list|(
literal|"aref"
argument_list|,
name|Faref
argument_list|,
name|Saref
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"Return the element of ARRAY at index INDEX.\n\ ARRAY may be a vector or a string.  INDEX starts at 0."
argument_list|)
argument_list|(
name|vector
argument_list|,
name|idx
argument_list|)
specifier|register
name|Lisp_Object
name|vector
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|Lisp_Object
name|idx
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|idxval
decl_stmt|;
name|CHECK_NUMBER
argument_list|(
name|idx
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|idxval
operator|=
name|XINT
argument_list|(
name|idx
argument_list|)
expr_stmt|;
if|if
condition|(
name|XTYPE
argument_list|(
name|vector
argument_list|)
operator|!=
name|Lisp_Vector
operator|&&
name|XTYPE
argument_list|(
name|vector
argument_list|)
operator|!=
name|Lisp_String
condition|)
name|vector
operator|=
name|wrong_type_argument
argument_list|(
name|Qarrayp
argument_list|,
name|vector
argument_list|)
expr_stmt|;
if|if
condition|(
name|idxval
operator|<
literal|0
operator|||
name|idxval
operator|>=
name|XVECTOR
argument_list|(
name|vector
argument_list|)
operator|->
name|size
condition|)
name|args_out_of_range
argument_list|(
name|vector
argument_list|,
name|idx
argument_list|)
expr_stmt|;
if|if
condition|(
name|XTYPE
argument_list|(
name|vector
argument_list|)
operator|==
name|Lisp_Vector
condition|)
return|return
name|XVECTOR
argument_list|(
name|vector
argument_list|)
operator|->
name|contents
index|[
name|idxval
index|]
return|;
else|else
block|{
name|Lisp_Object
name|val
decl_stmt|;
name|XFASTINT
argument_list|(
name|val
argument_list|)
operator|=
operator|(
name|unsigned
name|char
operator|)
name|XSTRING
argument_list|(
name|vector
argument_list|)
operator|->
name|data
index|[
name|idxval
index|]
expr_stmt|;
return|return
name|val
return|;
block|}
block|}
end_block

begin_expr_stmt
name|DEFUN
argument_list|(
literal|"aset"
argument_list|,
name|Faset
argument_list|,
name|Saset
argument_list|,
literal|3
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|,
literal|"Store into the element of ARRAY at index INDEX the value NEWVAL.\n\ ARRAY may be a vector or a string.  INDEX starts at 0."
argument_list|)
argument_list|(
name|vector
argument_list|,
name|idx
argument_list|,
name|newelt
argument_list|)
specifier|register
name|Lisp_Object
name|vector
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|Lisp_Object
name|idx
decl_stmt|,
name|newelt
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|idxval
decl_stmt|;
name|CHECK_NUMBER
argument_list|(
name|idx
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|idxval
operator|=
name|XINT
argument_list|(
name|idx
argument_list|)
expr_stmt|;
if|if
condition|(
name|XTYPE
argument_list|(
name|vector
argument_list|)
operator|!=
name|Lisp_Vector
operator|&&
name|XTYPE
argument_list|(
name|vector
argument_list|)
operator|!=
name|Lisp_String
condition|)
name|vector
operator|=
name|wrong_type_argument
argument_list|(
name|Qarrayp
argument_list|,
name|vector
argument_list|)
expr_stmt|;
if|if
condition|(
name|idxval
operator|<
literal|0
operator|||
name|idxval
operator|>=
name|XVECTOR
argument_list|(
name|vector
argument_list|)
operator|->
name|size
condition|)
name|args_out_of_range
argument_list|(
name|vector
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|CHECK_IMPURE
argument_list|(
name|vector
argument_list|)
expr_stmt|;
if|if
condition|(
name|XTYPE
argument_list|(
name|vector
argument_list|)
operator|==
name|Lisp_Vector
condition|)
name|XVECTOR
argument_list|(
name|vector
argument_list|)
operator|->
name|contents
index|[
name|idxval
index|]
operator|=
name|newelt
expr_stmt|;
else|else
name|XSTRING
argument_list|(
name|vector
argument_list|)
operator|->
name|data
index|[
name|idxval
index|]
operator|=
name|XINT
argument_list|(
name|newelt
argument_list|)
expr_stmt|;
return|return
name|newelt
return|;
block|}
end_block

begin_function
name|Lisp_Object
name|Farray_length
parameter_list|(
name|vector
parameter_list|)
specifier|register
name|Lisp_Object
name|vector
decl_stmt|;
block|{
specifier|register
name|Lisp_Object
name|size
decl_stmt|;
if|if
condition|(
name|XTYPE
argument_list|(
name|vector
argument_list|)
operator|!=
name|Lisp_Vector
operator|&&
name|XTYPE
argument_list|(
name|vector
argument_list|)
operator|!=
name|Lisp_String
condition|)
name|vector
operator|=
name|wrong_type_argument
argument_list|(
name|Qarrayp
argument_list|,
name|vector
argument_list|)
expr_stmt|;
name|XFASTINT
argument_list|(
name|size
argument_list|)
operator|=
name|XVECTOR
argument_list|(
name|vector
argument_list|)
operator|->
name|size
expr_stmt|;
return|return
name|size
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Arithmetic functions */
end_comment

begin_expr_stmt
name|DEFUN
argument_list|(
literal|"="
argument_list|,
name|Feqlsign
argument_list|,
name|Seqlsign
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"T if two args, both numbers, are equal."
argument_list|)
argument_list|(
name|num1
argument_list|,
name|num2
argument_list|)
specifier|register
name|Lisp_Object
name|num1
operator|,
name|num2
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|CHECK_NUMBER_COERCE_MARKER
argument_list|(
name|num1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK_NUMBER_COERCE_MARKER
argument_list|(
name|num2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|XINT
argument_list|(
name|num1
argument_list|)
operator|==
name|XINT
argument_list|(
name|num2
argument_list|)
condition|)
return|return
name|Qt
return|;
return|return
name|Qnil
return|;
block|}
end_block

begin_expr_stmt
name|DEFUN
argument_list|(
literal|"<"
argument_list|,
name|Flss
argument_list|,
name|Slss
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"T if first arg is less than second arg.  Both must be numbers."
argument_list|)
argument_list|(
name|num1
argument_list|,
name|num2
argument_list|)
specifier|register
name|Lisp_Object
name|num1
operator|,
name|num2
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|CHECK_NUMBER_COERCE_MARKER
argument_list|(
name|num1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK_NUMBER_COERCE_MARKER
argument_list|(
name|num2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|XINT
argument_list|(
name|num1
argument_list|)
operator|<
name|XINT
argument_list|(
name|num2
argument_list|)
condition|)
return|return
name|Qt
return|;
return|return
name|Qnil
return|;
block|}
end_block

begin_expr_stmt
name|DEFUN
argument_list|(
literal|">"
argument_list|,
name|Fgtr
argument_list|,
name|Sgtr
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"T if first arg is greater than second arg.  Both must be numbers."
argument_list|)
argument_list|(
name|num1
argument_list|,
name|num2
argument_list|)
specifier|register
name|Lisp_Object
name|num1
operator|,
name|num2
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|CHECK_NUMBER_COERCE_MARKER
argument_list|(
name|num1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK_NUMBER_COERCE_MARKER
argument_list|(
name|num2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|XINT
argument_list|(
name|num1
argument_list|)
operator|>
name|XINT
argument_list|(
name|num2
argument_list|)
condition|)
return|return
name|Qt
return|;
return|return
name|Qnil
return|;
block|}
end_block

begin_expr_stmt
name|DEFUN
argument_list|(
literal|"<="
argument_list|,
name|Fleq
argument_list|,
name|Sleq
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"T if first arg is less than or equal to second arg.  Both must be numbers."
argument_list|)
argument_list|(
name|num1
argument_list|,
name|num2
argument_list|)
specifier|register
name|Lisp_Object
name|num1
operator|,
name|num2
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|CHECK_NUMBER_COERCE_MARKER
argument_list|(
name|num1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK_NUMBER_COERCE_MARKER
argument_list|(
name|num2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|XINT
argument_list|(
name|num1
argument_list|)
operator|<=
name|XINT
argument_list|(
name|num2
argument_list|)
condition|)
return|return
name|Qt
return|;
return|return
name|Qnil
return|;
block|}
end_block

begin_expr_stmt
name|DEFUN
argument_list|(
literal|">="
argument_list|,
name|Fgeq
argument_list|,
name|Sgeq
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"T if first arg is greater than or equal to second arg.  Both must be numbers."
argument_list|)
argument_list|(
name|num1
argument_list|,
name|num2
argument_list|)
specifier|register
name|Lisp_Object
name|num1
operator|,
name|num2
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|CHECK_NUMBER_COERCE_MARKER
argument_list|(
name|num1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK_NUMBER_COERCE_MARKER
argument_list|(
name|num2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|XINT
argument_list|(
name|num1
argument_list|)
operator|>=
name|XINT
argument_list|(
name|num2
argument_list|)
condition|)
return|return
name|Qt
return|;
return|return
name|Qnil
return|;
block|}
end_block

begin_expr_stmt
name|DEFUN
argument_list|(
literal|"/="
argument_list|,
name|Fneq
argument_list|,
name|Sneq
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"T if first arg is not equal to second arg.  Both must be numbers."
argument_list|)
argument_list|(
name|num1
argument_list|,
name|num2
argument_list|)
specifier|register
name|Lisp_Object
name|num1
operator|,
name|num2
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|CHECK_NUMBER_COERCE_MARKER
argument_list|(
name|num1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK_NUMBER_COERCE_MARKER
argument_list|(
name|num2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|XINT
argument_list|(
name|num1
argument_list|)
operator|!=
name|XINT
argument_list|(
name|num2
argument_list|)
condition|)
return|return
name|Qt
return|;
return|return
name|Qnil
return|;
block|}
end_block

begin_expr_stmt
name|DEFUN
argument_list|(
literal|"zerop"
argument_list|,
name|Fzerop
argument_list|,
name|Szerop
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"T if NUMBER is zero."
argument_list|)
argument_list|(
name|num
argument_list|)
specifier|register
name|Lisp_Object
name|num
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|CHECK_NUMBER
argument_list|(
name|num
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|XINT
argument_list|(
name|num
argument_list|)
condition|)
return|return
name|Qt
return|;
return|return
name|Qnil
return|;
block|}
end_block

begin_escape
end_escape

begin_macro
name|DEFUN
argument_list|(
literal|"int-to-string"
argument_list|,
argument|Fint_to_string
argument_list|,
argument|Sint_to_string
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Convert INT to a string by printing it in decimal, with minus sign if negative."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|num
operator|)
name|Lisp_Object
name|num
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|char
name|buffer
index|[
literal|20
index|]
decl_stmt|;
name|CHECK_NUMBER
argument_list|(
name|num
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%d"
argument_list|,
name|XINT
argument_list|(
name|num
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|build_string
argument_list|(
name|buffer
argument_list|)
return|;
block|}
end_block

begin_expr_stmt
name|DEFUN
argument_list|(
literal|"string-to-int"
argument_list|,
name|Fstring_to_int
argument_list|,
name|Sstring_to_int
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Convert STRING to an integer by parsing it as a decimal number."
argument_list|)
argument_list|(
name|str
argument_list|,
name|flag
argument_list|)
specifier|register
name|Lisp_Object
name|str
operator|,
name|flag
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|CHECK_STRING
argument_list|(
name|str
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|make_number
argument_list|(
name|atoi
argument_list|(
name|XSTRING
argument_list|(
name|str
argument_list|)
operator|->
name|data
argument_list|)
argument_list|)
return|;
block|}
end_block

begin_enum
enum|enum
name|arithop
block|{
name|Aadd
block|,
name|Asub
block|,
name|Amult
block|,
name|Adiv
block|,
name|Alogand
block|,
name|Alogior
block|,
name|Alogxor
block|,
name|Amax
block|,
name|Amin
block|}
enum|;
end_enum

begin_function
name|Lisp_Object
name|arith_driver
parameter_list|(
name|code
parameter_list|,
name|nargs
parameter_list|,
name|args
parameter_list|)
name|enum
name|arithop
name|code
decl_stmt|;
name|int
name|nargs
decl_stmt|;
specifier|register
name|Lisp_Object
modifier|*
name|args
decl_stmt|;
block|{
specifier|register
name|Lisp_Object
name|val
decl_stmt|;
specifier|register
name|int
name|argnum
decl_stmt|;
specifier|register
name|int
name|accum
decl_stmt|;
specifier|register
name|int
name|next
decl_stmt|;
ifdef|#
directive|ifdef
name|SWITCH_ENUM_BUG
switch|switch
condition|(
operator|(
name|int
operator|)
name|code
condition|)
else|#
directive|else
switch|switch
condition|(
name|code
condition|)
endif|#
directive|endif
block|{
case|case
name|Alogior
case|:
case|case
name|Alogxor
case|:
case|case
name|Aadd
case|:
case|case
name|Asub
case|:
name|accum
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|Amult
case|:
name|accum
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|Alogand
case|:
name|accum
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
for|for
control|(
name|argnum
operator|=
literal|0
init|;
name|argnum
operator|<
name|nargs
condition|;
name|argnum
operator|++
control|)
block|{
name|val
operator|=
name|args
index|[
name|argnum
index|]
expr_stmt|;
comment|/* using args[argnum] as argument to CHECK_NUMBER_... */
name|CHECK_NUMBER_COERCE_MARKER
argument_list|(
name|val
argument_list|,
name|argnum
argument_list|)
expr_stmt|;
name|args
index|[
name|argnum
index|]
operator|=
name|val
expr_stmt|;
comment|/* runs into a compiler bug. */
name|next
operator|=
name|XINT
argument_list|(
name|args
index|[
name|argnum
index|]
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SWITCH_ENUM_BUG
switch|switch
condition|(
operator|(
name|int
operator|)
name|code
condition|)
else|#
directive|else
switch|switch
condition|(
name|code
condition|)
endif|#
directive|endif
block|{
case|case
name|Aadd
case|:
name|accum
operator|+=
name|next
expr_stmt|;
break|break;
case|case
name|Asub
case|:
if|if
condition|(
operator|!
name|argnum
operator|&&
name|nargs
operator|!=
literal|1
condition|)
name|next
operator|=
operator|-
name|next
expr_stmt|;
name|accum
operator|-=
name|next
expr_stmt|;
break|break;
case|case
name|Amult
case|:
name|accum
operator|*=
name|next
expr_stmt|;
break|break;
case|case
name|Adiv
case|:
if|if
condition|(
operator|!
name|argnum
condition|)
name|accum
operator|=
name|next
expr_stmt|;
else|else
name|accum
operator|/=
name|next
expr_stmt|;
break|break;
case|case
name|Alogand
case|:
name|accum
operator|&=
name|next
expr_stmt|;
break|break;
case|case
name|Alogior
case|:
name|accum
operator||=
name|next
expr_stmt|;
break|break;
case|case
name|Alogxor
case|:
name|accum
operator|^=
name|next
expr_stmt|;
break|break;
case|case
name|Amax
case|:
if|if
condition|(
operator|!
name|argnum
operator|||
name|next
operator|>
name|accum
condition|)
name|accum
operator|=
name|next
expr_stmt|;
break|break;
case|case
name|Amin
case|:
if|if
condition|(
operator|!
name|argnum
operator|||
name|next
operator|<
name|accum
condition|)
name|accum
operator|=
name|next
expr_stmt|;
break|break;
block|}
block|}
name|XSET
argument_list|(
name|val
argument_list|,
name|Lisp_Int
argument_list|,
name|accum
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_macro
name|DEFUN
argument_list|(
literal|"+"
argument_list|,
argument|Fplus
argument_list|,
argument|Splus
argument_list|,
literal|0
argument_list|,
argument|MANY
argument_list|,
literal|0
argument_list|,
literal|"Return sum of any number of numbers."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|nargs
operator|,
name|args
operator|)
name|int
name|nargs
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|Lisp_Object
modifier|*
name|args
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
name|arith_driver
argument_list|(
name|Aadd
argument_list|,
name|nargs
argument_list|,
name|args
argument_list|)
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"-"
argument_list|,
argument|Fminus
argument_list|,
argument|Sminus
argument_list|,
literal|0
argument_list|,
argument|MANY
argument_list|,
literal|0
argument_list|,
literal|"Negate number or subtract numbers.\n\ With one arg, negates it.  With more than one arg,\n\ subtracts all but the first from the first."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|nargs
operator|,
name|args
operator|)
name|int
name|nargs
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|Lisp_Object
modifier|*
name|args
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
name|arith_driver
argument_list|(
name|Asub
argument_list|,
name|nargs
argument_list|,
name|args
argument_list|)
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"*"
argument_list|,
argument|Ftimes
argument_list|,
argument|Stimes
argument_list|,
literal|0
argument_list|,
argument|MANY
argument_list|,
literal|0
argument_list|,
literal|"Returns product of any number of numbers."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|nargs
operator|,
name|args
operator|)
name|int
name|nargs
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|Lisp_Object
modifier|*
name|args
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
name|arith_driver
argument_list|(
name|Amult
argument_list|,
name|nargs
argument_list|,
name|args
argument_list|)
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"/"
argument_list|,
argument|Fquo
argument_list|,
argument|Squo
argument_list|,
literal|2
argument_list|,
argument|MANY
argument_list|,
literal|0
argument_list|,
literal|"Returns first argument divided by rest of arguments."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|nargs
operator|,
name|args
operator|)
name|int
name|nargs
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|Lisp_Object
modifier|*
name|args
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
name|arith_driver
argument_list|(
name|Adiv
argument_list|,
name|nargs
argument_list|,
name|args
argument_list|)
return|;
block|}
end_block

begin_expr_stmt
name|DEFUN
argument_list|(
literal|"%"
argument_list|,
name|Frem
argument_list|,
name|Srem
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"Returns remainder of first arg divided by second."
argument_list|)
argument_list|(
name|num1
argument_list|,
name|num2
argument_list|)
specifier|register
name|Lisp_Object
name|num1
operator|,
name|num2
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|Lisp_Object
name|val
decl_stmt|;
name|CHECK_NUMBER
argument_list|(
name|num1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK_NUMBER
argument_list|(
name|num2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|XSET
argument_list|(
name|val
argument_list|,
name|Lisp_Int
argument_list|,
name|XINT
argument_list|(
name|num1
argument_list|)
operator|%
name|XINT
argument_list|(
name|num2
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"max"
argument_list|,
argument|Fmax
argument_list|,
argument|Smax
argument_list|,
literal|1
argument_list|,
argument|MANY
argument_list|,
literal|0
argument_list|,
literal|"Return largest of all the arguments (which must be numbers.)"
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|nargs
operator|,
name|args
operator|)
name|int
name|nargs
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|Lisp_Object
modifier|*
name|args
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
name|arith_driver
argument_list|(
name|Amax
argument_list|,
name|nargs
argument_list|,
name|args
argument_list|)
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"min"
argument_list|,
argument|Fmin
argument_list|,
argument|Smin
argument_list|,
literal|1
argument_list|,
argument|MANY
argument_list|,
literal|0
argument_list|,
literal|"Return smallest of all the arguments (which must be numbers.)"
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|nargs
operator|,
name|args
operator|)
name|int
name|nargs
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|Lisp_Object
modifier|*
name|args
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
name|arith_driver
argument_list|(
name|Amin
argument_list|,
name|nargs
argument_list|,
name|args
argument_list|)
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"logand"
argument_list|,
argument|Flogand
argument_list|,
argument|Slogand
argument_list|,
literal|0
argument_list|,
argument|MANY
argument_list|,
literal|0
argument_list|,
literal|"Return bitwise and of all the arguments (numbers)."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|nargs
operator|,
name|args
operator|)
name|int
name|nargs
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|Lisp_Object
modifier|*
name|args
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
name|arith_driver
argument_list|(
name|Alogand
argument_list|,
name|nargs
argument_list|,
name|args
argument_list|)
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"logior"
argument_list|,
argument|Flogior
argument_list|,
argument|Slogior
argument_list|,
literal|0
argument_list|,
argument|MANY
argument_list|,
literal|0
argument_list|,
literal|"Return bitwise or of all the arguments (numbers)."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|nargs
operator|,
name|args
operator|)
name|int
name|nargs
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|Lisp_Object
modifier|*
name|args
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
name|arith_driver
argument_list|(
name|Alogior
argument_list|,
name|nargs
argument_list|,
name|args
argument_list|)
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"logxor"
argument_list|,
argument|Flogxor
argument_list|,
argument|Slogxor
argument_list|,
literal|0
argument_list|,
argument|MANY
argument_list|,
literal|0
argument_list|,
literal|"Return bitwise exclusive-or of all the arguments (numbers)."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|nargs
operator|,
name|args
operator|)
name|int
name|nargs
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|Lisp_Object
modifier|*
name|args
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
name|arith_driver
argument_list|(
name|Alogxor
argument_list|,
name|nargs
argument_list|,
name|args
argument_list|)
return|;
block|}
end_block

begin_expr_stmt
name|DEFUN
argument_list|(
literal|"ash"
argument_list|,
name|Fash
argument_list|,
name|Sash
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"Return VALUE with its bits shifted left by COUNT.\n\ If COUNT is negative, shifting is actually to the right.\n\ In this case, the sign bit is duplicated."
argument_list|)
argument_list|(
name|num1
argument_list|,
name|num2
argument_list|)
specifier|register
name|Lisp_Object
name|num1
operator|,
name|num2
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|Lisp_Object
name|val
decl_stmt|;
name|CHECK_NUMBER
argument_list|(
name|num1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK_NUMBER
argument_list|(
name|num2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|XINT
argument_list|(
name|num2
argument_list|)
operator|>
literal|0
condition|)
name|XSET
argument_list|(
name|val
argument_list|,
name|Lisp_Int
argument_list|,
name|XINT
argument_list|(
name|num1
argument_list|)
operator|<<
name|XFASTINT
argument_list|(
name|num2
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|XSET
argument_list|(
name|val
argument_list|,
name|Lisp_Int
argument_list|,
name|XINT
argument_list|(
name|num1
argument_list|)
operator|>>
operator|-
name|XINT
argument_list|(
name|num2
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_block

begin_expr_stmt
name|DEFUN
argument_list|(
literal|"lsh"
argument_list|,
name|Flsh
argument_list|,
name|Slsh
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"Return VALUE with its bits shifted left by COUNT.\n\ If COUNT is negative, shifting is actually to the right.\n\ In this case,  zeros are shifted in on the left."
argument_list|)
argument_list|(
name|num1
argument_list|,
name|num2
argument_list|)
specifier|register
name|Lisp_Object
name|num1
operator|,
name|num2
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|Lisp_Object
name|val
decl_stmt|;
name|CHECK_NUMBER
argument_list|(
name|num1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK_NUMBER
argument_list|(
name|num2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|XINT
argument_list|(
name|num2
argument_list|)
operator|>
literal|0
condition|)
name|XSET
argument_list|(
name|val
argument_list|,
name|Lisp_Int
argument_list|,
operator|(
name|unsigned
operator|)
name|XFASTINT
argument_list|(
name|num1
argument_list|)
operator|<<
name|XFASTINT
argument_list|(
name|num2
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|XSET
argument_list|(
name|val
argument_list|,
name|Lisp_Int
argument_list|,
operator|(
name|unsigned
operator|)
name|XFASTINT
argument_list|(
name|num1
argument_list|)
operator|>>
operator|-
name|XINT
argument_list|(
name|num2
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_block

begin_expr_stmt
name|DEFUN
argument_list|(
literal|"1+"
argument_list|,
name|Fadd1
argument_list|,
name|Sadd1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Return NUMBER plus one."
argument_list|)
argument_list|(
name|num
argument_list|)
specifier|register
name|Lisp_Object
name|num
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|CHECK_NUMBER_COERCE_MARKER
argument_list|(
name|num
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|XSETINT
argument_list|(
name|num
argument_list|,
name|XFASTINT
argument_list|(
name|num
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
name|num
return|;
block|}
end_block

begin_expr_stmt
name|DEFUN
argument_list|(
literal|"1-"
argument_list|,
name|Fsub1
argument_list|,
name|Ssub1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Return NUMBER minus one."
argument_list|)
argument_list|(
name|num
argument_list|)
specifier|register
name|Lisp_Object
name|num
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|CHECK_NUMBER_COERCE_MARKER
argument_list|(
name|num
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|XSETINT
argument_list|(
name|num
argument_list|,
name|XFASTINT
argument_list|(
name|num
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|num
return|;
block|}
end_block

begin_expr_stmt
name|DEFUN
argument_list|(
literal|"lognot"
argument_list|,
name|Flognot
argument_list|,
name|Slognot
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Return the bitwise complement of ARG."
argument_list|)
argument_list|(
name|num
argument_list|)
specifier|register
name|Lisp_Object
name|num
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|CHECK_NUMBER
argument_list|(
name|num
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|XSETINT
argument_list|(
name|num
argument_list|,
operator|~
name|XFASTINT
argument_list|(
name|num
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|num
return|;
block|}
end_block

begin_escape
end_escape

begin_function
name|void
name|syms_of_data
parameter_list|()
block|{
name|Qquote
operator|=
name|intern
argument_list|(
literal|"quote"
argument_list|)
expr_stmt|;
name|Qlambda
operator|=
name|intern
argument_list|(
literal|"lambda"
argument_list|)
expr_stmt|;
name|Qsubr
operator|=
name|intern
argument_list|(
literal|"subr"
argument_list|)
expr_stmt|;
name|Qerror_conditions
operator|=
name|intern
argument_list|(
literal|"error-conditions"
argument_list|)
expr_stmt|;
name|Qerror_message
operator|=
name|intern
argument_list|(
literal|"error-message"
argument_list|)
expr_stmt|;
name|Qtop_level
operator|=
name|intern
argument_list|(
literal|"top-level"
argument_list|)
expr_stmt|;
name|Qerror
operator|=
name|intern
argument_list|(
literal|"error"
argument_list|)
expr_stmt|;
name|Qquit
operator|=
name|intern
argument_list|(
literal|"quit"
argument_list|)
expr_stmt|;
name|Qwrong_type_argument
operator|=
name|intern
argument_list|(
literal|"wrong-type-argument"
argument_list|)
expr_stmt|;
name|Qargs_out_of_range
operator|=
name|intern
argument_list|(
literal|"args-out-of-range"
argument_list|)
expr_stmt|;
name|Qvoid_function
operator|=
name|intern
argument_list|(
literal|"void-function"
argument_list|)
expr_stmt|;
name|Qvoid_variable
operator|=
name|intern
argument_list|(
literal|"void-variable"
argument_list|)
expr_stmt|;
name|Qsetting_constant
operator|=
name|intern
argument_list|(
literal|"setting-constant"
argument_list|)
expr_stmt|;
name|Qinvalid_read_syntax
operator|=
name|intern
argument_list|(
literal|"invalid-read-syntax"
argument_list|)
expr_stmt|;
name|Qinvalid_function
operator|=
name|intern
argument_list|(
literal|"invalid-function"
argument_list|)
expr_stmt|;
name|Qwrong_number_of_arguments
operator|=
name|intern
argument_list|(
literal|"wrong-number-of-arguments"
argument_list|)
expr_stmt|;
name|Qno_catch
operator|=
name|intern
argument_list|(
literal|"no-catch"
argument_list|)
expr_stmt|;
name|Qend_of_file
operator|=
name|intern
argument_list|(
literal|"end-of-file"
argument_list|)
expr_stmt|;
name|Qarith_error
operator|=
name|intern
argument_list|(
literal|"arith-error"
argument_list|)
expr_stmt|;
name|Qbeginning_of_buffer
operator|=
name|intern
argument_list|(
literal|"beginning-of-buffer"
argument_list|)
expr_stmt|;
name|Qend_of_buffer
operator|=
name|intern
argument_list|(
literal|"end-of-buffer"
argument_list|)
expr_stmt|;
name|Qbuffer_read_only
operator|=
name|intern
argument_list|(
literal|"buffer-read-only"
argument_list|)
expr_stmt|;
name|Qlistp
operator|=
name|intern
argument_list|(
literal|"listp"
argument_list|)
expr_stmt|;
name|Qconsp
operator|=
name|intern
argument_list|(
literal|"consp"
argument_list|)
expr_stmt|;
name|Qsymbolp
operator|=
name|intern
argument_list|(
literal|"symbolp"
argument_list|)
expr_stmt|;
name|Qintegerp
operator|=
name|intern
argument_list|(
literal|"integerp"
argument_list|)
expr_stmt|;
name|Qnatnump
operator|=
name|intern
argument_list|(
literal|"natnump"
argument_list|)
expr_stmt|;
name|Qstringp
operator|=
name|intern
argument_list|(
literal|"stringp"
argument_list|)
expr_stmt|;
name|Qarrayp
operator|=
name|intern
argument_list|(
literal|"arrayp"
argument_list|)
expr_stmt|;
name|Qsequencep
operator|=
name|intern
argument_list|(
literal|"sequencep"
argument_list|)
expr_stmt|;
name|Qbufferp
operator|=
name|intern
argument_list|(
literal|"bufferp"
argument_list|)
expr_stmt|;
name|Qvectorp
operator|=
name|intern
argument_list|(
literal|"vectorp"
argument_list|)
expr_stmt|;
name|Qchar_or_string_p
operator|=
name|intern
argument_list|(
literal|"char-or-string-p"
argument_list|)
expr_stmt|;
name|Qmarkerp
operator|=
name|intern
argument_list|(
literal|"markerp"
argument_list|)
expr_stmt|;
name|Qinteger_or_marker_p
operator|=
name|intern
argument_list|(
literal|"integer-or-marker-p"
argument_list|)
expr_stmt|;
name|Qboundp
operator|=
name|intern
argument_list|(
literal|"boundp"
argument_list|)
expr_stmt|;
name|Qfboundp
operator|=
name|intern
argument_list|(
literal|"fboundp"
argument_list|)
expr_stmt|;
name|Qcdr
operator|=
name|intern
argument_list|(
literal|"cdr"
argument_list|)
expr_stmt|;
comment|/* ERROR is used as a signaler for random errors for which nothing else is right */
name|Fput
argument_list|(
name|Qerror
argument_list|,
name|Qerror_conditions
argument_list|,
name|Fcons
argument_list|(
name|Qerror
argument_list|,
name|Qnil
argument_list|)
argument_list|)
expr_stmt|;
name|Fput
argument_list|(
name|Qerror
argument_list|,
name|Qerror_message
argument_list|,
name|build_string
argument_list|(
literal|"error"
argument_list|)
argument_list|)
expr_stmt|;
name|Fput
argument_list|(
name|Qquit
argument_list|,
name|Qerror_conditions
argument_list|,
name|Fcons
argument_list|(
name|Qquit
argument_list|,
name|Qnil
argument_list|)
argument_list|)
expr_stmt|;
name|Fput
argument_list|(
name|Qquit
argument_list|,
name|Qerror_message
argument_list|,
name|build_string
argument_list|(
literal|"Quit"
argument_list|)
argument_list|)
expr_stmt|;
name|Fput
argument_list|(
name|Qwrong_type_argument
argument_list|,
name|Qerror_conditions
argument_list|,
name|Fcons
argument_list|(
name|Qwrong_type_argument
argument_list|,
name|Fcons
argument_list|(
name|Qerror
argument_list|,
name|Qnil
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|Fput
argument_list|(
name|Qwrong_type_argument
argument_list|,
name|Qerror_message
argument_list|,
name|build_string
argument_list|(
literal|"Wrong type argument"
argument_list|)
argument_list|)
expr_stmt|;
name|Fput
argument_list|(
name|Qargs_out_of_range
argument_list|,
name|Qerror_conditions
argument_list|,
name|Fcons
argument_list|(
name|Qargs_out_of_range
argument_list|,
name|Fcons
argument_list|(
name|Qerror
argument_list|,
name|Qnil
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|Fput
argument_list|(
name|Qargs_out_of_range
argument_list|,
name|Qerror_message
argument_list|,
name|build_string
argument_list|(
literal|"Args out of range"
argument_list|)
argument_list|)
expr_stmt|;
name|Fput
argument_list|(
name|Qvoid_function
argument_list|,
name|Qerror_conditions
argument_list|,
name|Fcons
argument_list|(
name|Qvoid_function
argument_list|,
name|Fcons
argument_list|(
name|Qerror
argument_list|,
name|Qnil
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|Fput
argument_list|(
name|Qvoid_function
argument_list|,
name|Qerror_message
argument_list|,
name|build_string
argument_list|(
literal|"Symbol's function definition is void"
argument_list|)
argument_list|)
expr_stmt|;
name|Fput
argument_list|(
name|Qvoid_variable
argument_list|,
name|Qerror_conditions
argument_list|,
name|Fcons
argument_list|(
name|Qvoid_variable
argument_list|,
name|Fcons
argument_list|(
name|Qerror
argument_list|,
name|Qnil
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|Fput
argument_list|(
name|Qvoid_variable
argument_list|,
name|Qerror_message
argument_list|,
name|build_string
argument_list|(
literal|"Symbol's value as variable is void"
argument_list|)
argument_list|)
expr_stmt|;
name|Fput
argument_list|(
name|Qsetting_constant
argument_list|,
name|Qerror_conditions
argument_list|,
name|Fcons
argument_list|(
name|Qsetting_constant
argument_list|,
name|Fcons
argument_list|(
name|Qerror
argument_list|,
name|Qnil
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|Fput
argument_list|(
name|Qsetting_constant
argument_list|,
name|Qerror_message
argument_list|,
name|build_string
argument_list|(
literal|"Attempt to set a constant symbol"
argument_list|)
argument_list|)
expr_stmt|;
name|Fput
argument_list|(
name|Qinvalid_read_syntax
argument_list|,
name|Qerror_conditions
argument_list|,
name|Fcons
argument_list|(
name|Qinvalid_read_syntax
argument_list|,
name|Fcons
argument_list|(
name|Qerror
argument_list|,
name|Qnil
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|Fput
argument_list|(
name|Qinvalid_read_syntax
argument_list|,
name|Qerror_message
argument_list|,
name|build_string
argument_list|(
literal|"Invalid read syntax"
argument_list|)
argument_list|)
expr_stmt|;
name|Fput
argument_list|(
name|Qinvalid_function
argument_list|,
name|Qerror_conditions
argument_list|,
name|Fcons
argument_list|(
name|Qinvalid_function
argument_list|,
name|Fcons
argument_list|(
name|Qerror
argument_list|,
name|Qnil
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|Fput
argument_list|(
name|Qinvalid_function
argument_list|,
name|Qerror_message
argument_list|,
name|build_string
argument_list|(
literal|"Invalid function"
argument_list|)
argument_list|)
expr_stmt|;
name|Fput
argument_list|(
name|Qwrong_number_of_arguments
argument_list|,
name|Qerror_conditions
argument_list|,
name|Fcons
argument_list|(
name|Qwrong_number_of_arguments
argument_list|,
name|Fcons
argument_list|(
name|Qerror
argument_list|,
name|Qnil
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|Fput
argument_list|(
name|Qwrong_number_of_arguments
argument_list|,
name|Qerror_message
argument_list|,
name|build_string
argument_list|(
literal|"Wrong number of arguments"
argument_list|)
argument_list|)
expr_stmt|;
name|Fput
argument_list|(
name|Qno_catch
argument_list|,
name|Qerror_conditions
argument_list|,
name|Fcons
argument_list|(
name|Qno_catch
argument_list|,
name|Fcons
argument_list|(
name|Qerror
argument_list|,
name|Qnil
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|Fput
argument_list|(
name|Qno_catch
argument_list|,
name|Qerror_message
argument_list|,
name|build_string
argument_list|(
literal|"No catch for tag"
argument_list|)
argument_list|)
expr_stmt|;
name|Fput
argument_list|(
name|Qend_of_file
argument_list|,
name|Qerror_conditions
argument_list|,
name|Fcons
argument_list|(
name|Qend_of_file
argument_list|,
name|Fcons
argument_list|(
name|Qerror
argument_list|,
name|Qnil
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|Fput
argument_list|(
name|Qend_of_file
argument_list|,
name|Qerror_message
argument_list|,
name|build_string
argument_list|(
literal|"End of file during parsing"
argument_list|)
argument_list|)
expr_stmt|;
name|Fput
argument_list|(
name|Qarith_error
argument_list|,
name|Qerror_conditions
argument_list|,
name|Fcons
argument_list|(
name|Qarith_error
argument_list|,
name|Fcons
argument_list|(
name|Qerror
argument_list|,
name|Qnil
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|Fput
argument_list|(
name|Qarith_error
argument_list|,
name|Qerror_message
argument_list|,
name|build_string
argument_list|(
literal|"Arithmetic error"
argument_list|)
argument_list|)
expr_stmt|;
name|Fput
argument_list|(
name|Qbeginning_of_buffer
argument_list|,
name|Qerror_conditions
argument_list|,
name|Fcons
argument_list|(
name|Qbeginning_of_buffer
argument_list|,
name|Fcons
argument_list|(
name|Qerror
argument_list|,
name|Qnil
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|Fput
argument_list|(
name|Qbeginning_of_buffer
argument_list|,
name|Qerror_message
argument_list|,
name|build_string
argument_list|(
literal|"Beginning of buffer"
argument_list|)
argument_list|)
expr_stmt|;
name|Fput
argument_list|(
name|Qend_of_buffer
argument_list|,
name|Qerror_conditions
argument_list|,
name|Fcons
argument_list|(
name|Qend_of_buffer
argument_list|,
name|Fcons
argument_list|(
name|Qerror
argument_list|,
name|Qnil
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|Fput
argument_list|(
name|Qend_of_buffer
argument_list|,
name|Qerror_message
argument_list|,
name|build_string
argument_list|(
literal|"End of buffer"
argument_list|)
argument_list|)
expr_stmt|;
name|Fput
argument_list|(
name|Qbuffer_read_only
argument_list|,
name|Qerror_conditions
argument_list|,
name|Fcons
argument_list|(
name|Qbuffer_read_only
argument_list|,
name|Fcons
argument_list|(
name|Qerror
argument_list|,
name|Qnil
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|Fput
argument_list|(
name|Qbuffer_read_only
argument_list|,
name|Qerror_message
argument_list|,
name|build_string
argument_list|(
literal|"Buffer is read-only"
argument_list|)
argument_list|)
expr_stmt|;
name|staticpro
argument_list|(
operator|&
name|Qnil
argument_list|)
expr_stmt|;
name|staticpro
argument_list|(
operator|&
name|Qt
argument_list|)
expr_stmt|;
name|staticpro
argument_list|(
operator|&
name|Qquote
argument_list|)
expr_stmt|;
name|staticpro
argument_list|(
operator|&
name|Qlambda
argument_list|)
expr_stmt|;
name|staticpro
argument_list|(
operator|&
name|Qsubr
argument_list|)
expr_stmt|;
name|staticpro
argument_list|(
operator|&
name|Qunbound
argument_list|)
expr_stmt|;
name|staticpro
argument_list|(
operator|&
name|Qerror_conditions
argument_list|)
expr_stmt|;
name|staticpro
argument_list|(
operator|&
name|Qerror_message
argument_list|)
expr_stmt|;
name|staticpro
argument_list|(
operator|&
name|Qtop_level
argument_list|)
expr_stmt|;
name|staticpro
argument_list|(
operator|&
name|Qerror
argument_list|)
expr_stmt|;
name|staticpro
argument_list|(
operator|&
name|Qquit
argument_list|)
expr_stmt|;
name|staticpro
argument_list|(
operator|&
name|Qwrong_type_argument
argument_list|)
expr_stmt|;
name|staticpro
argument_list|(
operator|&
name|Qargs_out_of_range
argument_list|)
expr_stmt|;
name|staticpro
argument_list|(
operator|&
name|Qvoid_function
argument_list|)
expr_stmt|;
name|staticpro
argument_list|(
operator|&
name|Qvoid_variable
argument_list|)
expr_stmt|;
name|staticpro
argument_list|(
operator|&
name|Qsetting_constant
argument_list|)
expr_stmt|;
name|staticpro
argument_list|(
operator|&
name|Qinvalid_read_syntax
argument_list|)
expr_stmt|;
name|staticpro
argument_list|(
operator|&
name|Qwrong_number_of_arguments
argument_list|)
expr_stmt|;
name|staticpro
argument_list|(
operator|&
name|Qinvalid_function
argument_list|)
expr_stmt|;
name|staticpro
argument_list|(
operator|&
name|Qno_catch
argument_list|)
expr_stmt|;
name|staticpro
argument_list|(
operator|&
name|Qend_of_file
argument_list|)
expr_stmt|;
name|staticpro
argument_list|(
operator|&
name|Qarith_error
argument_list|)
expr_stmt|;
name|staticpro
argument_list|(
operator|&
name|Qbeginning_of_buffer
argument_list|)
expr_stmt|;
name|staticpro
argument_list|(
operator|&
name|Qend_of_buffer
argument_list|)
expr_stmt|;
name|staticpro
argument_list|(
operator|&
name|Qbuffer_read_only
argument_list|)
expr_stmt|;
name|staticpro
argument_list|(
operator|&
name|Qlistp
argument_list|)
expr_stmt|;
name|staticpro
argument_list|(
operator|&
name|Qconsp
argument_list|)
expr_stmt|;
name|staticpro
argument_list|(
operator|&
name|Qsymbolp
argument_list|)
expr_stmt|;
name|staticpro
argument_list|(
operator|&
name|Qintegerp
argument_list|)
expr_stmt|;
name|staticpro
argument_list|(
operator|&
name|Qnatnump
argument_list|)
expr_stmt|;
name|staticpro
argument_list|(
operator|&
name|Qstringp
argument_list|)
expr_stmt|;
name|staticpro
argument_list|(
operator|&
name|Qarrayp
argument_list|)
expr_stmt|;
name|staticpro
argument_list|(
operator|&
name|Qsequencep
argument_list|)
expr_stmt|;
name|staticpro
argument_list|(
operator|&
name|Qbufferp
argument_list|)
expr_stmt|;
name|staticpro
argument_list|(
operator|&
name|Qvectorp
argument_list|)
expr_stmt|;
name|staticpro
argument_list|(
operator|&
name|Qchar_or_string_p
argument_list|)
expr_stmt|;
name|staticpro
argument_list|(
operator|&
name|Qmarkerp
argument_list|)
expr_stmt|;
name|staticpro
argument_list|(
operator|&
name|Qinteger_or_marker_p
argument_list|)
expr_stmt|;
name|staticpro
argument_list|(
operator|&
name|Qboundp
argument_list|)
expr_stmt|;
name|staticpro
argument_list|(
operator|&
name|Qfboundp
argument_list|)
expr_stmt|;
name|staticpro
argument_list|(
operator|&
name|Qcdr
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Seq
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Snull
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Slistp
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Snlistp
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sconsp
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Satom
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sintegerp
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Snatnump
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Ssymbolp
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sstringp
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Svectorp
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sarrayp
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Ssequencep
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sbufferp
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Smarkerp
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sinteger_or_marker_p
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Ssubrp
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Schar_or_string_p
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Scar
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Scdr
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Scar_safe
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Scdr_safe
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Ssetcar
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Ssetcdr
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Ssymbol_function
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Ssymbol_plist
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Ssymbol_name
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Smakunbound
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sfmakunbound
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sboundp
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sfboundp
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sfset
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Ssetplist
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Ssymbol_value
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sset
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sdefault_value
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sset_default
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Ssetq_default
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Smake_variable_buffer_local
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Smake_local_variable
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Skill_local_variable
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Saref
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Saset
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sint_to_string
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sstring_to_int
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Seqlsign
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Slss
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sgtr
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sleq
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sgeq
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sneq
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Szerop
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Splus
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sminus
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Stimes
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Squo
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Srem
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Smax
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Smin
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Slogand
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Slogior
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Slogxor
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Slsh
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sash
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sadd1
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Ssub1
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Slognot
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|arith_error
argument_list|(
argument|signo
argument_list|)
end_macro

begin_decl_stmt
name|int
name|signo
decl_stmt|;
end_decl_stmt

begin_block
block|{
ifdef|#
directive|ifdef
name|USG
comment|/* USG systems forget handlers when they are used;      must reestablish each time */
name|signal
argument_list|(
name|signo
argument_list|,
name|arith_error
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* USG */
ifdef|#
directive|ifdef
name|VMS
comment|/* VMS systems are like USG.  */
name|signal
argument_list|(
name|signo
argument_list|,
name|arith_error
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* VMS */
ifdef|#
directive|ifdef
name|BSD4_1
name|sigrelse
argument_list|(
name|SIGFPE
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* not BSD4_1 */
name|sigsetmask
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* not BSD4_1 */
name|Fsignal
argument_list|(
name|Qarith_error
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|init_data
argument_list|()
end_macro

begin_block
block|{
comment|/* Don't do this if just dumping out.      We don't want to call `signal' in this case      so that we don't have trouble with dumping      signal-delivering routines in an inconsistent state.  */
ifndef|#
directive|ifndef
name|CANNOT_DUMP
if|if
condition|(
operator|!
name|initialized
condition|)
return|return;
endif|#
directive|endif
comment|/* CANNOT_DUMP */
name|signal
argument_list|(
name|SIGFPE
argument_list|,
name|arith_error
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|uts
name|signal
argument_list|(
name|SIGEMT
argument_list|,
name|arith_error
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* uts */
block|}
end_block

end_unit

