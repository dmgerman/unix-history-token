begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Interfaces to system-dependent kernel and library entries.    Copyright (C) 1985, 1986, 1987, 1988, 1990 Free Software Foundation, Inc.  This file is part of GNU Emacs.  GNU Emacs is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version.  GNU Emacs is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU Emacs; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"lisp.h"
end_include

begin_undef
undef|#
directive|undef
name|NULL
end_undef

begin_define
define|#
directive|define
name|min
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|((x)> (y) ? (y) : (x))
end_define

begin_comment
comment|/* In this file, open, read and write refer to the system calls,    not our sugared interfaces  sys_open, sys_read and sys_write.    Contrariwise, for systems where we use the system calls directly,    define sys_read, etc. here as aliases for them.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|read
end_ifndef

begin_define
define|#
directive|define
name|sys_read
value|read
end_define

begin_define
define|#
directive|define
name|sys_write
value|write
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* `read' is not a macro */
end_comment

begin_undef
undef|#
directive|undef
name|read
end_undef

begin_undef
undef|#
directive|undef
name|write
end_undef

begin_ifndef
ifndef|#
directive|ifndef
name|close
end_ifndef

begin_define
define|#
directive|define
name|sys_close
value|close
end_define

begin_else
else|#
directive|else
end_else

begin_undef
undef|#
directive|undef
name|close
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|open
end_ifndef

begin_define
define|#
directive|define
name|sys_open
value|open
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* `open' is a macro */
end_comment

begin_undef
undef|#
directive|undef
name|open
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* `open' is a macro */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|VMS
end_ifndef

begin_ifndef
ifndef|#
directive|ifndef
name|BSD4_4
end_ifndef

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|sys_errlist
index|[]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|char
name|__progname
index|[]
init|=
literal|"emacs"
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|VMS
end_ifdef

begin_include
include|#
directive|include
file|<rms.h>
end_include

begin_include
include|#
directive|include
file|<ttdef.h>
end_include

begin_include
include|#
directive|include
file|<tt2def.h>
end_include

begin_include
include|#
directive|include
file|<iodef.h>
end_include

begin_include
include|#
directive|include
file|<ssdef.h>
end_include

begin_include
include|#
directive|include
file|<descrip.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<file.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|RAB$C_BID
end_ifndef

begin_include
include|#
directive|include
file|<rab.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|MAXIOSIZE
value|( 32 * PAGESIZE )
end_define

begin_comment
comment|/* Don't I/O more than 32 blocks at a time */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* VMS */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|BSD4_1
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|BSD
end_ifdef

begin_comment
comment|/* this is done this way to avoid defined(BSD) || defined (USG) 	      because the vms compiler doesn't grok `defined' */
end_comment

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|USG
end_ifdef

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not 4.1 bsd */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|BSD
end_ifdef

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|BSD4_1
end_ifdef

begin_include
include|#
directive|include
file|<wait.h>
end_include

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* not 4.1 */
end_comment

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not 4.1 */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* BSD */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|STRIDE
end_ifdef

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|mips
end_ifdef

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|AIX
end_ifdef

begin_comment
comment|/* Get files for keyboard remapping */
end_comment

begin_define
define|#
directive|define
name|HFNKEYS
value|2
end_define

begin_include
include|#
directive|include
file|<sys/hft.h>
end_include

begin_include
include|#
directive|include
file|<sys/devinfo.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Get rid of LLITOUT in 4.1, since it is said to stimulate kernel bugs.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|BSD4_1
end_ifdef

begin_undef
undef|#
directive|undef
name|LLITOUT
end_undef

begin_define
define|#
directive|define
name|LLITOUT
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* 4.1 */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_TERMIO
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|IBMR2AIX
end_ifdef

begin_include
include|#
directive|include
file|<termio.h>
end_include

begin_include
include|#
directive|include
file|<termios.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|TIOCGETP
end_ifdef

begin_undef
undef|#
directive|undef
name|TIOCGETP
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|TIOCGETP
value|TCGETS
end_define

begin_undef
undef|#
directive|undef
name|TIOCSETN
end_undef

begin_define
define|#
directive|define
name|TIOCSETN
value|TCSETSW
end_define

begin_undef
undef|#
directive|undef
name|TIOCSETP
end_undef

begin_define
define|#
directive|define
name|TIOCSETP
value|TCSETSF
end_define

begin_undef
undef|#
directive|undef
name|TCSETAW
end_undef

begin_define
define|#
directive|define
name|TCSETAW
value|TCSETS
end_define

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<termio.h>
end_include

begin_undef
undef|#
directive|undef
name|TIOCGETP
end_undef

begin_define
define|#
directive|define
name|TIOCGETP
value|TCGETA
end_define

begin_undef
undef|#
directive|undef
name|TIOCSETN
end_undef

begin_define
define|#
directive|define
name|TIOCSETN
value|TCSETAW
end_define

begin_undef
undef|#
directive|undef
name|TIOCSETP
end_undef

begin_define
define|#
directive|define
name|TIOCSETP
value|TCSETAF
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|IBMR2AIX
end_ifndef

begin_define
define|#
directive|define
name|TERMINAL
value|struct termio
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|TERMINAL
value|struct termios
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|OSPEED
parameter_list|(
name|str
parameter_list|)
value|(str.c_cflag& CBAUD)
end_define

begin_define
define|#
directive|define
name|SETOSPEED
parameter_list|(
name|str
parameter_list|,
name|new
parameter_list|)
value|(str.c_cflag = (str.c_cflag& ~CBAUD) | (new))
end_define

begin_define
define|#
directive|define
name|TABS_OK
parameter_list|(
name|str
parameter_list|)
value|((str.c_oflag& TABDLY) != TAB3)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_TERMIO */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|XENIX
end_ifdef

begin_undef
undef|#
directive|undef
name|TIOCGETC
end_undef

begin_comment
comment|/* Avoid confusing some conditionals that test this.  */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|BROKEN_TIOCGETC
end_ifdef

begin_undef
undef|#
directive|undef
name|TIOCGETC
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_TERMIO
end_ifndef

begin_ifndef
ifndef|#
directive|ifndef
name|VMS
end_ifndef

begin_include
include|#
directive|include
file|<sgtty.h>
end_include

begin_define
define|#
directive|define
name|TERMINAL
value|struct sgttyb
end_define

begin_define
define|#
directive|define
name|OSPEED
parameter_list|(
name|str
parameter_list|)
value|str.sg_ospeed
end_define

begin_define
define|#
directive|define
name|SETOSPEED
parameter_list|(
name|str
parameter_list|,
name|new
parameter_list|)
value|(str.sg_ospeed = (new))
end_define

begin_define
define|#
directive|define
name|TABS_OK
parameter_list|(
name|str
parameter_list|)
value|((str.sg_flags& XTABS) != XTABS)
end_define

begin_undef
undef|#
directive|undef
name|TCSETAW
end_undef

begin_define
define|#
directive|define
name|TCSETAW
value|TIOCSETN
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not VMS */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not HAVE_TERMIO */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|USG
end_ifdef

begin_include
include|#
directive|include
file|<sys/utsname.h>
end_include

begin_include
include|#
directive|include
file|<memory.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|TIOCGWINSZ
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|IRIS_4D
end_ifndef

begin_ifndef
ifndef|#
directive|ifndef
name|mips
end_ifndef

begin_ifndef
ifndef|#
directive|ifndef
name|aix386
end_ifndef

begin_ifndef
ifndef|#
directive|ifndef
name|NO_SIOCTL_H
end_ifndef

begin_comment
comment|/* Some USG systems with TIOCGWINSZ need this file; some don't have it.    We don't know how to distinguish them.    If this #include gets an error, just delete it.  */
end_comment

begin_include
include|#
directive|include
file|<sys/sioctl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|NEED_PTEM_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/stream.h>
end_include

begin_include
include|#
directive|include
file|<sys/ptem.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not aix386 */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not mips */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not IRIS_4D */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TIOCGWINSZ */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_TIMEVAL
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|HPUX
end_ifdef

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_TIMEVAL */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USG */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|VMS
end_ifdef

begin_include
include|#
directive|include
file|"window.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|NEED_BSDTTY
end_ifdef

begin_include
include|#
directive|include
file|<sys/bsdtty.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HPUX
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_PTYS
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/ptyio.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|AIX
end_ifdef

begin_include
include|#
directive|include
file|<sys/pty.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* AIX */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SYSV_PTYS
end_ifdef

begin_include
include|#
directive|include
file|<sys/tty.h>
end_include

begin_include
include|#
directive|include
file|<sys/pty.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|BROKEN_FIONREAD
end_ifdef

begin_undef
undef|#
directive|undef
name|FIONREAD
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|int
name|quit_char
decl_stmt|;
end_decl_stmt

begin_include
include|#
directive|include
file|"termhooks.h"
end_include

begin_include
include|#
directive|include
file|"termchar.h"
end_include

begin_include
include|#
directive|include
file|"termopts.h"
end_include

begin_include
include|#
directive|include
file|"dispextern.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|NONSYSTEM_DIR_LIBRARY
end_ifdef

begin_include
include|#
directive|include
file|"ndir.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NONSYSTEM_DIR_LIBRARY */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|sigmask
end_ifndef

begin_define
define|#
directive|define
name|sigmask
parameter_list|(
name|no
parameter_list|)
value|(1L<< ((no) - 1))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Define SIGCHLD as an alias for SIGCLD.  There are many conditionals    testing SIGCHLD.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|VMS
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|SIGCLD
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|SIGCHLD
end_ifndef

begin_define
define|#
directive|define
name|SIGCHLD
value|SIGCLD
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not SIGCHLD */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SIGCLD */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not VMS */
end_comment

begin_decl_stmt
specifier|static
name|int
name|baud_convert
index|[]
init|=
ifdef|#
directive|ifdef
name|BAUD_CONVERT
name|BAUD_CONVERT
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_block
block|{
literal|0
operator|,
literal|50
operator|,
literal|75
operator|,
literal|110
operator|,
literal|135
operator|,
literal|150
operator|,
literal|200
operator|,
literal|300
operator|,
literal|600
operator|,
literal|1200
operator|,
literal|1800
operator|,
literal|2400
operator|,
literal|4800
operator|,
literal|9600
operator|,
literal|19200
operator|,
literal|38400
block|}
end_block

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|short
name|ospeed
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|VMS
end_ifdef

begin_struct
specifier|static
struct|struct
name|iosb
block|{
name|short
name|status
decl_stmt|;
name|short
name|offset
decl_stmt|;
name|short
name|termlen
decl_stmt|;
name|short
name|term
decl_stmt|;
block|}
name|input_iosb
struct|;
end_struct

begin_function_decl
name|int
name|kbd_input_ast
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|waiting_for_ast
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|stop_input
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|input_ef
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|timer_ef
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|process_ef
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|input_eflist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|timer_eflist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|input_chan
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|$DESCRIPTOR
argument_list|(
name|input_dsc
argument_list|,
literal|"TT"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|terminator_mask
index|[
literal|2
index|]
init|=
block|{
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_struct
specifier|static
struct|struct
name|sensemode
block|{
name|short
name|status
decl_stmt|;
name|unsigned
name|char
name|xmit_baud
decl_stmt|;
name|unsigned
name|char
name|rcv_baud
decl_stmt|;
name|unsigned
name|char
name|crfill
decl_stmt|;
name|unsigned
name|char
name|lffill
decl_stmt|;
name|unsigned
name|char
name|parity
decl_stmt|;
name|unsigned
name|char
name|unused
decl_stmt|;
name|char
name|class
decl_stmt|;
name|char
name|type
decl_stmt|;
name|short
name|scr_wid
decl_stmt|;
name|unsigned
name|long
name|tt_char
range|:
literal|24
decl_stmt|,
name|scr_len
range|:
literal|8
decl_stmt|;
name|unsigned
name|long
name|tt2_char
decl_stmt|;
block|}
name|sensemode_iosb
struct|;
end_struct

begin_define
define|#
directive|define
name|TERMINAL
value|struct sensemode
end_define

begin_define
define|#
directive|define
name|OSPEED
parameter_list|(
name|str
parameter_list|)
value|(str.xmit_baud)
end_define

begin_define
define|#
directive|define
name|TABS_OK
parameter_list|(
name|str
parameter_list|)
value|((str.tt_char& TT$M_MECHTAB) != 0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* VMS */
end_comment

begin_macro
name|discard_tty_input
argument_list|()
end_macro

begin_block
block|{
name|TERMINAL
name|buf
decl_stmt|;
if|if
condition|(
name|noninteractive
condition|)
return|return;
ifdef|#
directive|ifdef
name|VMS
name|end_kbd_input
argument_list|()
expr_stmt|;
name|SYS$QIOW
argument_list|(
literal|0
argument_list|,
name|input_chan
argument_list|,
name|IO$_READVBLK
operator||
name|IO$M_PURGE
argument_list|,
name|input_iosb
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|buf
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|terminator_mask
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|queue_kbd_input
argument_list|()
expr_stmt|;
else|#
directive|else
comment|/* not VMS */
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCGETP
argument_list|,
operator|&
name|buf
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCSETP
argument_list|,
operator|&
name|buf
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* not VMS */
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|SIGTSTP
end_ifdef

begin_macro
name|stuff_char
argument_list|(
argument|c
argument_list|)
end_macro

begin_decl_stmt
name|char
name|c
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* Should perhaps error if in batch mode */
ifdef|#
directive|ifdef
name|TIOCSTI
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCSTI
argument_list|,
operator|&
name|c
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* no TIOCSTI */
name|error
argument_list|(
literal|"Cannot stuff terminal input characters in this version of Unix."
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* no TIOCSTI */
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SIGTSTP */
end_comment

begin_macro
name|init_baud_rate
argument_list|()
end_macro

begin_block
block|{
name|TERMINAL
name|sg
decl_stmt|;
if|if
condition|(
name|noninteractive
condition|)
name|ospeed
operator|=
literal|0
expr_stmt|;
else|else
block|{
ifdef|#
directive|ifdef
name|VMS
name|SYS$QIOW
argument_list|(
literal|0
argument_list|,
name|input_chan
argument_list|,
name|IO$_SENSEMODE
argument_list|,
operator|&
name|sg
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|sg
operator|.
name|class
argument_list|,
literal|12
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
name|SETOSPEED
argument_list|(
name|sg
argument_list|,
name|B9600
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCGETP
argument_list|,
operator|&
name|sg
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* not VMS */
name|ospeed
operator|=
name|OSPEED
argument_list|(
name|sg
argument_list|)
expr_stmt|;
block|}
name|baud_rate
operator|=
operator|(
name|ospeed
operator|<
sizeof|sizeof
name|baud_convert
operator|/
sizeof|sizeof
name|baud_convert
index|[
literal|0
index|]
condition|?
name|baud_convert
index|[
name|ospeed
index|]
else|:
literal|9600
operator|)
expr_stmt|;
if|if
condition|(
name|baud_rate
operator|==
literal|0
condition|)
name|baud_rate
operator|=
literal|1200
expr_stmt|;
block|}
end_block

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|set_exclusive_use
argument_list|(
argument|fd
argument_list|)
end_macro

begin_decl_stmt
name|int
name|fd
decl_stmt|;
end_decl_stmt

begin_block
block|{
ifdef|#
directive|ifdef
name|FIOCLEX
name|ioctl
argument_list|(
name|fd
argument_list|,
name|FIOCLEX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Ok to do nothing if this feature does not exist */
block|}
end_block

begin_ifndef
ifndef|#
directive|ifndef
name|subprocesses
end_ifndef

begin_macro
name|wait_without_blocking
argument_list|()
end_macro

begin_block
block|{
ifdef|#
directive|ifdef
name|BSD
name|wait3
argument_list|(
literal|0
argument_list|,
name|WNOHANG
operator||
name|WUNTRACED
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
name|croak
argument_list|(
literal|"wait_without_blocking"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not subprocesses */
end_comment

begin_decl_stmt
name|int
name|wait_debugging
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set nonzero to make following function work under dbx 		         (at least for bsd).  */
end_comment

begin_comment
comment|/* Wait for subprocess with process id `pid' to terminate and    make sure it will get eliminated (not remain forever as a zombie) */
end_comment

begin_macro
name|wait_for_termination
argument_list|(
argument|pid
argument_list|)
end_macro

begin_decl_stmt
name|int
name|pid
decl_stmt|;
end_decl_stmt

begin_block
block|{
while|while
condition|(
literal|1
condition|)
block|{
ifdef|#
directive|ifdef
name|subprocesses
if|#
directive|if
name|defined
argument_list|(
name|BSD
argument_list|)
operator|||
operator|(
name|defined
argument_list|(
name|HPUX
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|HPUX_5
argument_list|)
operator|)
comment|/* Note that kill returns -1 even if the process is just a zombie now. 	 But inevitably a SIGCHLD interrupt should be generated 	 and child_sig will do wait3 and make the process go away. */
comment|/* There is some indication that there is a bug involved with 	 termination of subprocesses, perhaps involving a kernel bug too, 	 but no idea what it is.  Just as a hunch we signal SIGCHLD to see 	 if that causes the problem to go away or get worse.  */
ifdef|#
directive|ifdef
name|BSD4_1
specifier|extern
name|int
name|synch_process_pid
decl_stmt|;
name|sighold
argument_list|(
name|SIGCHLD
argument_list|)
expr_stmt|;
if|if
condition|(
name|synch_process_pid
operator|==
literal|0
condition|)
block|{
name|sigrelse
argument_list|(
name|SIGCHLD
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|wait_debugging
condition|)
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
else|else
name|sigpause
argument_list|(
name|SIGCHLD
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* not BSD4_1 */
name|sigsetmask
argument_list|(
literal|1
operator|<<
operator|(
name|SIGCHLD
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|>
name|kill
argument_list|(
name|pid
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|sigsetmask
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|kill
argument_list|(
name|getpid
argument_list|()
argument_list|,
name|SIGCHLD
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|wait_debugging
condition|)
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
else|else
name|sigpause
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* not BSD4_1 */
else|#
directive|else
comment|/* not BSD, and not HPUX version>= 6 */
ifdef|#
directive|ifdef
name|UNIPLUS
if|if
condition|(
literal|0
operator|>
name|kill
argument_list|(
name|pid
argument_list|,
literal|0
argument_list|)
condition|)
break|break;
name|wait
argument_list|(
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* neither BSD nor UNIPLUS: random sysV */
if|if
condition|(
literal|0
operator|>
name|kill
argument_list|(
name|pid
argument_list|,
literal|0
argument_list|)
condition|)
break|break;
name|pause
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* not UNIPLUS */
endif|#
directive|endif
comment|/* not BSD, and not HPUX version>= 6 */
else|#
directive|else
comment|/* not subprocesses */
ifndef|#
directive|ifndef
name|BSD4_1
if|if
condition|(
literal|0
operator|>
name|kill
argument_list|(
name|pid
argument_list|,
literal|0
argument_list|)
condition|)
break|break;
name|wait
argument_list|(
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* BSD4_1 */
name|int
name|status
decl_stmt|;
name|status
operator|=
name|wait
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|pid
operator|||
name|status
operator|==
operator|-
literal|1
condition|)
break|break;
endif|#
directive|endif
comment|/* BSD4_1 */
endif|#
directive|endif
comment|/* not subprocesses */
block|}
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|subprocesses
end_ifdef

begin_comment
comment|/*  *	flush any pending output  *      (may flush input as well; it does not matter the way we use it)  */
end_comment

begin_macro
name|flush_pending_output
argument_list|(
argument|channel
argument_list|)
end_macro

begin_decl_stmt
name|int
name|channel
decl_stmt|;
end_decl_stmt

begin_block
block|{
ifdef|#
directive|ifdef
name|TCFLSH
name|ioctl
argument_list|(
name|channel
argument_list|,
name|TCFLSH
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|TIOCFLUSH
name|int
name|zero
init|=
literal|0
decl_stmt|;
comment|/* 3rd arg should be ignored      but some 4.2 kernels actually want the address of an int      and nonzero means something different.  */
name|ioctl
argument_list|(
name|channel
argument_list|,
name|TIOCFLUSH
argument_list|,
operator|&
name|zero
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
block|}
end_block

begin_comment
comment|/*  Set up the terminal at the other end of a pseudo-terminal that     we will be controlling an inferior through.     It should not echo or do line-editing, since that is done     in Emacs.  No padding needed for insertion into an Emacs buffer.  */
end_comment

begin_macro
name|child_setup_tty
argument_list|(
argument|out
argument_list|)
end_macro

begin_decl_stmt
name|int
name|out
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|TERMINAL
name|s
decl_stmt|;
name|ioctl
argument_list|(
name|out
argument_list|,
name|TIOCGETP
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_TERMIO
name|s
operator|.
name|c_oflag
operator||=
name|OPOST
expr_stmt|;
comment|/* Enable output postprocessing */
name|s
operator|.
name|c_oflag
operator|&=
operator|~
name|ONLCR
expr_stmt|;
comment|/* Disable map of NL to CR-NL on output */
name|s
operator|.
name|c_oflag
operator|&=
operator|~
operator|(
name|NLDLY
operator||
name|CRDLY
operator||
name|TABDLY
operator||
name|BSDLY
operator||
name|VTDLY
operator||
name|FFDLY
operator|)
expr_stmt|;
comment|/* No output delays */
name|s
operator|.
name|c_lflag
operator|&=
operator|~
name|ECHO
expr_stmt|;
comment|/* Disable echo */
name|s
operator|.
name|c_lflag
operator||=
name|ISIG
expr_stmt|;
comment|/* Enable signals */
name|s
operator|.
name|c_iflag
operator|&=
operator|~
name|IUCLC
expr_stmt|;
comment|/* Disable map of upper case to lower on input */
name|s
operator|.
name|c_oflag
operator|&=
operator|~
name|OLCUC
expr_stmt|;
comment|/* Disable map of lower case to upper on output */
comment|/* said to be unnecesary   s.c_cc[VMIN] = 1;		/* minimum number of characters to accept   s.c_cc[VTIME] = 0;		/* wait forever for at least 1 character */
name|s
operator|.
name|c_lflag
operator||=
name|ICANON
expr_stmt|;
comment|/* Enable erase/kill and eof processing */
name|s
operator|.
name|c_cc
index|[
name|VEOF
index|]
operator|=
literal|04
expr_stmt|;
comment|/* insure that EOF is Control-D */
name|s
operator|.
name|c_cc
index|[
name|VERASE
index|]
operator|=
literal|0377
expr_stmt|;
comment|/* disable erase processing */
name|s
operator|.
name|c_cc
index|[
name|VKILL
index|]
operator|=
literal|0377
expr_stmt|;
comment|/* disable kill processing */
ifdef|#
directive|ifdef
name|HPUX
name|s
operator|.
name|c_cflag
operator|=
operator|(
name|s
operator|.
name|c_cflag
operator|&
operator|~
name|CBAUD
operator|)
operator||
name|B9600
expr_stmt|;
comment|/* baud rate sanity */
endif|#
directive|endif
endif|HPUX
ifdef|#
directive|ifdef
name|AIX
comment|/* AIX enhanced edit loses NULs, so disable it */
ifndef|#
directive|ifndef
name|IBMR2AIX
name|s
operator|.
name|c_line
operator|=
literal|0
expr_stmt|;
name|s
operator|.
name|c_iflag
operator|&=
operator|~
name|ASCEDIT
expr_stmt|;
endif|#
directive|endif
comment|/* Also, PTY overloads NUL and BREAK.      don't ignore break, but don't signal either, so it looks like NUL.  */
name|s
operator|.
name|c_iflag
operator|&=
operator|~
name|IGNBRK
expr_stmt|;
name|s
operator|.
name|c_iflag
operator|&=
operator|~
name|BRKINT
expr_stmt|;
comment|/* QUIT and INTR work better as signals, so disable character forms */
name|s
operator|.
name|c_cc
index|[
name|VQUIT
index|]
operator|=
literal|0377
expr_stmt|;
name|s
operator|.
name|c_cc
index|[
name|VINTR
index|]
operator|=
literal|0377
expr_stmt|;
name|s
operator|.
name|c_cc
index|[
name|VEOL
index|]
operator|=
literal|0377
expr_stmt|;
name|s
operator|.
name|c_lflag
operator|&=
operator|~
name|ISIG
expr_stmt|;
name|s
operator|.
name|c_cflag
operator|=
operator|(
name|s
operator|.
name|c_cflag
operator|&
operator|~
name|CBAUD
operator|)
operator||
name|B9600
expr_stmt|;
comment|/* baud rate sanity */
endif|#
directive|endif
comment|/* AIX */
else|#
directive|else
comment|/* not HAVE_TERMIO */
name|s
operator|.
name|sg_flags
operator|&=
operator|~
operator|(
name|ECHO
operator||
name|CRMOD
operator||
name|ANYP
operator||
name|ALLDELAY
operator||
name|RAW
operator||
name|LCASE
operator||
name|CBREAK
operator||
name|TANDEM
operator|)
expr_stmt|;
endif|#
directive|endif
comment|/* not HAVE_TERMIO */
name|ioctl
argument_list|(
name|out
argument_list|,
name|TIOCSETN
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BSD4_1
if|if
condition|(
name|interrupt_input
condition|)
name|reset_sigio
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* BSD4_1 */
ifdef|#
directive|ifdef
name|RTU
block|{
name|int
name|zero
init|=
literal|0
decl_stmt|;
name|ioctl
argument_list|(
name|out
argument_list|,
name|FIOASYNC
argument_list|,
operator|&
name|zero
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* RTU */
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* subprocesses */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|setpgrp_of_tty
argument_list|(
argument|pid
argument_list|)
end_macro

begin_decl_stmt
name|int
name|pid
decl_stmt|;
end_decl_stmt

begin_block
block|{
ifdef|#
directive|ifdef
name|IBMR2AIX
name|tcsetpgrp
argument_list|(
literal|0
argument_list|,
name|pid
argument_list|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|TIOCSPGRP
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCSPGRP
argument_list|,
operator|&
name|pid
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* Just ignore this for now and hope for the best */
endif|#
directive|endif
endif|#
directive|endif
block|}
end_block

begin_comment
comment|/* Record a signal code and the handler for it.  */
end_comment

begin_struct
struct|struct
name|save_signal
block|{
name|int
name|code
decl_stmt|;
name|int
function_decl|(
modifier|*
name|handler
function_decl|)
parameter_list|()
function_decl|;
block|}
struct|;
end_struct

begin_comment
comment|/* Suspend the Emacs process; give terminal to its superior.  */
end_comment

begin_macro
name|sys_suspend
argument_list|()
end_macro

begin_block
block|{
ifdef|#
directive|ifdef
name|VMS
name|unsigned
name|long
name|parent_id
decl_stmt|;
name|parent_id
operator|=
name|getppid
argument_list|()
expr_stmt|;
if|if
condition|(
name|parent_id
operator|&&
name|parent_id
operator|!=
literal|0xffffffff
condition|)
block|{
name|int
name|oldsig
init|=
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
decl_stmt|;
name|int
name|status
init|=
name|LIB$ATTACH
argument_list|(
operator|&
name|parent_id
argument_list|)
operator|&
literal|1
decl_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|oldsig
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
return|return
operator|-
literal|1
return|;
else|#
directive|else
ifdef|#
directive|ifdef
name|SIGTSTP
ifdef|#
directive|ifdef
name|BSD
name|killpg
argument_list|(
name|getpgrp
argument_list|(
literal|0
argument_list|)
argument_list|,
name|SIGTSTP
argument_list|)
expr_stmt|;
else|#
directive|else
name|kill
argument_list|(
operator|-
name|getpgrp
argument_list|(
literal|0
argument_list|)
argument_list|,
name|SIGTSTP
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|#
directive|else
ifdef|#
directive|ifdef
name|USG_JOBCTRL
comment|/* If you don't know what this is don't mess with it */
name|ptrace
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* set for ptrace - caught by csh */
name|kill
argument_list|(
name|getpid
argument_list|()
argument_list|,
name|SIGQUIT
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* On a system where suspending is not implemented,    instead fork a subshell and let it talk directly to the terminal    while we wait.  */
name|int
name|pid
init|=
name|fork
argument_list|()
decl_stmt|;
name|struct
name|save_signal
name|saved_handlers
index|[
literal|5
index|]
decl_stmt|;
name|saved_handlers
index|[
literal|0
index|]
operator|.
name|code
operator|=
name|SIGINT
expr_stmt|;
name|saved_handlers
index|[
literal|1
index|]
operator|.
name|code
operator|=
name|SIGQUIT
expr_stmt|;
name|saved_handlers
index|[
literal|2
index|]
operator|.
name|code
operator|=
name|SIGTERM
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGIO
name|saved_handlers
index|[
literal|3
index|]
operator|.
name|code
operator|=
name|SIGIO
expr_stmt|;
name|saved_handlers
index|[
literal|4
index|]
operator|.
name|code
operator|=
literal|0
expr_stmt|;
else|#
directive|else
name|saved_handlers
index|[
literal|3
index|]
operator|.
name|code
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|pid
operator|==
operator|-
literal|1
condition|)
name|error
argument_list|(
literal|"Can't spawn subshell"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pid
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|sh
decl_stmt|;
name|sh
operator|=
operator|(
name|char
operator|*
operator|)
name|egetenv
argument_list|(
literal|"SHELL"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sh
operator|==
literal|0
condition|)
name|sh
operator|=
literal|"sh"
expr_stmt|;
comment|/* Use our buffer's default directory for the subshell.  */
block|{
name|Lisp_Object
name|dir
decl_stmt|;
name|unsigned
name|char
modifier|*
name|str
decl_stmt|;
name|int
name|len
decl_stmt|;
comment|/* mentioning current_buffer->buffer would mean including buffer.h, 	   which somehow wedges the hp compiler.  So instead... */
name|dir
operator|=
name|intern
argument_list|(
literal|"default-directory"
argument_list|)
expr_stmt|;
comment|/* Can't use NULL */
if|if
condition|(
name|XFASTINT
argument_list|(
name|Fboundp
argument_list|(
name|dir
argument_list|)
argument_list|)
operator|==
name|XFASTINT
argument_list|(
name|Qnil
argument_list|)
condition|)
goto|goto
name|xyzzy
goto|;
name|dir
operator|=
name|Fsymbol_value
argument_list|(
name|dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|XTYPE
argument_list|(
name|dir
argument_list|)
operator|!=
name|Lisp_String
condition|)
goto|goto
name|xyzzy
goto|;
name|str
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|XSTRING
argument_list|(
name|dir
argument_list|)
operator|->
name|size
operator|+
literal|2
argument_list|)
expr_stmt|;
name|len
operator|=
name|XSTRING
argument_list|(
name|dir
argument_list|)
operator|->
name|size
expr_stmt|;
name|bcopy
argument_list|(
name|XSTRING
argument_list|(
name|dir
argument_list|)
operator|->
name|data
argument_list|,
name|str
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|str
index|[
name|len
operator|-
literal|1
index|]
operator|!=
literal|'/'
condition|)
name|str
index|[
name|len
operator|++
index|]
operator|=
literal|'/'
expr_stmt|;
name|str
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
name|chdir
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
name|xyzzy
label|:
ifdef|#
directive|ifdef
name|subprocesses
name|close_process_descs
argument_list|()
expr_stmt|;
comment|/* Close Emacs's pipes/ptys */
endif|#
directive|endif
name|execlp
argument_list|(
name|sh
argument_list|,
name|sh
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|write
argument_list|(
literal|1
argument_list|,
literal|"Can't execute subshell"
argument_list|,
literal|22
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|save_signal_handlers
argument_list|(
operator|&
name|saved_handlers
argument_list|)
expr_stmt|;
name|wait_for_termination
argument_list|(
name|pid
argument_list|)
expr_stmt|;
name|restore_signal_handlers
argument_list|(
operator|&
name|saved_handlers
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* no USG_JOBCTRL */
endif|#
directive|endif
comment|/* no SIGTSTP */
endif|#
directive|endif
comment|/* not VMS */
block|}
end_block

begin_macro
name|save_signal_handlers
argument_list|(
argument|saved_handlers
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|save_signal
modifier|*
name|saved_handlers
decl_stmt|;
end_decl_stmt

begin_block
block|{
while|while
condition|(
name|saved_handlers
operator|->
name|code
condition|)
block|{
name|saved_handlers
operator|->
name|handler
operator|=
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
name|signal
argument_list|(
name|saved_handlers
operator|->
name|code
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|saved_handlers
operator|++
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|restore_signal_handlers
argument_list|(
argument|saved_handlers
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|save_signal
modifier|*
name|saved_handlers
decl_stmt|;
end_decl_stmt

begin_block
block|{
while|while
condition|(
name|saved_handlers
operator|->
name|code
condition|)
block|{
name|signal
argument_list|(
name|saved_handlers
operator|->
name|code
argument_list|,
name|saved_handlers
operator|->
name|handler
argument_list|)
expr_stmt|;
name|saved_handlers
operator|++
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|F_SETFL
end_ifdef

begin_decl_stmt
name|int
name|old_fcntl_flags
decl_stmt|;
end_decl_stmt

begin_macro
name|init_sigio
argument_list|()
end_macro

begin_block
block|{
ifdef|#
directive|ifdef
name|FASYNC
name|old_fcntl_flags
operator|=
name|fcntl
argument_list|(
literal|0
argument_list|,
name|F_GETFL
argument_list|,
literal|0
argument_list|)
operator|&
operator|~
name|FASYNC
expr_stmt|;
endif|#
directive|endif
name|request_sigio
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|reset_sigio
argument_list|()
end_macro

begin_block
block|{
name|unrequest_sigio
argument_list|()
expr_stmt|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|FASYNC
end_ifdef

begin_comment
comment|/* F_SETFL does not imply existance of FASYNC */
end_comment

begin_macro
name|request_sigio
argument_list|()
end_macro

begin_block
block|{
ifdef|#
directive|ifdef
name|SIGWINCH
name|int
name|omask
init|=
name|sigblock
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|sigsetmask
argument_list|(
name|omask
operator|&
operator|~
name|sigmask
argument_list|(
name|SIGWINCH
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fcntl
argument_list|(
literal|0
argument_list|,
name|F_SETFL
argument_list|,
name|old_fcntl_flags
operator||
name|FASYNC
argument_list|)
expr_stmt|;
name|interrupts_deferred
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_macro
name|unrequest_sigio
argument_list|()
end_macro

begin_block
block|{
ifdef|#
directive|ifdef
name|SIGWINCH
name|sigblock
argument_list|(
name|sigmask
argument_list|(
name|SIGWINCH
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fcntl
argument_list|(
literal|0
argument_list|,
name|F_SETFL
argument_list|,
name|old_fcntl_flags
argument_list|)
expr_stmt|;
name|interrupts_deferred
operator|=
literal|1
expr_stmt|;
block|}
end_block

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* no FASYNC */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|STRIDE
end_ifdef

begin_comment
comment|/* Stride doesn't have FASYNC - use FIOASYNC */
end_comment

begin_macro
name|request_sigio
argument_list|()
end_macro

begin_block
block|{
name|int
name|on
init|=
literal|1
decl_stmt|;
name|ioctl
argument_list|(
literal|0
argument_list|,
name|FIOASYNC
argument_list|,
operator|&
name|on
argument_list|)
expr_stmt|;
name|interrupts_deferred
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_macro
name|unrequest_sigio
argument_list|()
end_macro

begin_block
block|{
name|int
name|off
init|=
literal|0
decl_stmt|;
name|ioctl
argument_list|(
literal|0
argument_list|,
name|FIOASYNC
argument_list|,
operator|&
name|off
argument_list|)
expr_stmt|;
name|interrupts_deferred
operator|=
literal|1
expr_stmt|;
block|}
end_block

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* not FASYNC, not STRIDE */
end_comment

begin_macro
name|request_sigio
argument_list|()
end_macro

begin_block
block|{
name|croak
argument_list|(
literal|"request_sigio"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|unrequest_sigio
argument_list|()
end_macro

begin_block
block|{
name|croak
argument_list|(
literal|"unrequest_sigio"
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* STRIDE */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* FASYNC */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* F_SETFL */
end_comment

begin_escape
end_escape

begin_decl_stmt
name|TERMINAL
name|old_gtty
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The initial tty mode bits */
end_comment

begin_decl_stmt
name|int
name|term_initted
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1 if outer tty status has been recorded */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|F_SETOWN
end_ifdef

begin_decl_stmt
name|int
name|old_fcntl_owner
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* F_SETOWN */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|TIOCGLTC
end_ifdef

begin_decl_stmt
name|struct
name|ltchars
name|old_ltchars
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TIOCGLTC */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|TIOCGETC
end_ifdef

begin_decl_stmt
name|struct
name|tchars
name|old_tchars
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|old_lmode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|lmode
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current lmode value. */
end_comment

begin_comment
comment|/* Needed as global for 4.1 */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TIOCGETC */
end_comment

begin_comment
comment|/* This may also be defined in stdio,    but if so, this does no harm,    and using the same name avoids wasting the other one's space.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|USG
end_ifdef

begin_decl_stmt
name|unsigned
name|char
name|_sobuf
index|[
name|BUFSIZ
operator|+
literal|8
index|]
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|char
name|_sobuf
index|[
name|BUFSIZ
index|]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|TIOCGLTC
end_ifdef

begin_decl_stmt
specifier|static
name|struct
name|ltchars
name|new_ltchars
init|=
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|TIOCGETC
end_ifdef

begin_decl_stmt
specifier|static
name|struct
name|tchars
name|new_tchars
init|=
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|init_sys_modes
argument_list|()
end_macro

begin_block
block|{
name|TERMINAL
name|tty
decl_stmt|;
ifdef|#
directive|ifdef
name|TIOCGETC
name|struct
name|tchars
name|tchars
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|VMS
if|#
directive|if
literal|0
block|static int oob_chars[2] = {0, 1<< 7};
comment|/* catch C-g's */
block|extern int (*interrupt_signal) ();
endif|#
directive|endif
endif|#
directive|endif
if|if
condition|(
name|noninteractive
condition|)
return|return;
ifdef|#
directive|ifdef
name|VMS
if|if
condition|(
operator|!
name|input_ef
condition|)
name|LIB$GET_EF
argument_list|(
operator|&
name|input_ef
argument_list|)
expr_stmt|;
name|SYS$CLREF
argument_list|(
name|input_ef
argument_list|)
expr_stmt|;
name|waiting_for_ast
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|timer_ef
condition|)
name|LIB$GET_EF
argument_list|(
operator|&
name|timer_ef
argument_list|)
expr_stmt|;
name|SYS$CLREF
argument_list|(
name|timer_ef
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|process_ef
condition|)
block|{
name|LIB$GET_EF
argument_list|(
operator|&
name|process_ef
argument_list|)
expr_stmt|;
name|SYS$CLREF
argument_list|(
name|process_ef
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|input_ef
operator|/
literal|32
operator|!=
name|process_ef
operator|/
literal|32
condition|)
name|croak
argument_list|(
literal|"Input and process event flags in different clusters."
argument_list|)
expr_stmt|;
if|if
condition|(
name|input_ef
operator|/
literal|32
operator|!=
name|timer_ef
operator|/
literal|32
condition|)
name|croak
argument_list|(
literal|"Input and process event flags in different clusters."
argument_list|)
expr_stmt|;
name|input_eflist
operator|=
operator|(
operator|(
name|unsigned
operator|)
literal|1
operator|<<
operator|(
name|input_ef
operator|%
literal|32
operator|)
operator|)
operator||
operator|(
operator|(
name|unsigned
operator|)
literal|1
operator|<<
operator|(
name|process_ef
operator|%
literal|32
operator|)
operator|)
expr_stmt|;
name|timer_eflist
operator|=
operator|(
operator|(
name|unsigned
operator|)
literal|1
operator|<<
operator|(
name|input_ef
operator|%
literal|32
operator|)
operator|)
operator||
operator|(
operator|(
name|unsigned
operator|)
literal|1
operator|<<
operator|(
name|timer_ef
operator|%
literal|32
operator|)
operator|)
expr_stmt|;
name|SYS$QIOW
argument_list|(
literal|0
argument_list|,
name|input_chan
argument_list|,
name|IO$_SENSEMODE
argument_list|,
operator|&
name|old_gtty
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|old_gtty
operator|.
name|class
argument_list|,
literal|12
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|VMS4_4
name|sys_access_reinit
argument_list|()
expr_stmt|;
endif|#
directive|endif
else|#
directive|else
comment|/* not VMS */
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCGETP
argument_list|,
operator|&
name|old_gtty
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* not VMS */
if|if
condition|(
operator|!
name|read_socket_hook
condition|)
block|{
name|tty
operator|=
name|old_gtty
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_TERMIO
name|tty
operator|.
name|c_iflag
operator||=
operator|(
name|IGNBRK
operator|)
expr_stmt|;
comment|/* Ignore break condition */
name|tty
operator|.
name|c_iflag
operator|&=
operator|~
name|ICRNL
expr_stmt|;
comment|/* Disable map of CR to NL on input */
ifdef|#
directive|ifdef
name|ISTRIP
name|tty
operator|.
name|c_iflag
operator|&=
operator|~
name|ISTRIP
expr_stmt|;
comment|/* don't strip 8th bit on input */
endif|#
directive|endif
name|tty
operator|.
name|c_lflag
operator|&=
operator|~
name|ECHO
expr_stmt|;
comment|/* Disable echo */
name|tty
operator|.
name|c_lflag
operator|&=
operator|~
name|ICANON
expr_stmt|;
comment|/* Disable erase/kill processing */
name|tty
operator|.
name|c_lflag
operator||=
name|ISIG
expr_stmt|;
comment|/* Enable signals */
if|if
condition|(
name|flow_control
condition|)
block|{
name|tty
operator|.
name|c_iflag
operator||=
name|IXON
expr_stmt|;
comment|/* Enable start/stop output control */
ifdef|#
directive|ifdef
name|IXANY
name|tty
operator|.
name|c_iflag
operator|&=
operator|~
name|IXANY
expr_stmt|;
endif|#
directive|endif
comment|/* IXANY */
block|}
else|else
name|tty
operator|.
name|c_iflag
operator|&=
operator|~
name|IXON
expr_stmt|;
comment|/* Disable start/stop output control */
name|tty
operator|.
name|c_oflag
operator|&=
operator|~
name|ONLCR
expr_stmt|;
comment|/* Disable map of NL to CR-NL on output */
name|tty
operator|.
name|c_oflag
operator|&=
operator|~
name|TAB3
expr_stmt|;
comment|/* Disable tab expansion */
ifdef|#
directive|ifdef
name|CS8
name|tty
operator|.
name|c_cflag
operator||=
name|CS8
expr_stmt|;
comment|/* allow 8th bit on input */
name|tty
operator|.
name|c_cflag
operator|&=
operator|~
name|PARENB
expr_stmt|;
comment|/* Don't check parity */
endif|#
directive|endif
name|tty
operator|.
name|c_cc
index|[
name|VINTR
index|]
operator|=
name|quit_char
expr_stmt|;
comment|/* ^G gives SIGINT */
comment|/* Set up C-g (usually) for both SIGQUIT and SIGINT. 	 We don't know which we will get, but we handle both alike 	 so which one it really gives us does not matter.  */
name|tty
operator|.
name|c_cc
index|[
name|VQUIT
index|]
operator|=
name|quit_char
expr_stmt|;
name|tty
operator|.
name|c_cc
index|[
name|VMIN
index|]
operator|=
literal|1
expr_stmt|;
comment|/* Input should wait for at least 1 char */
name|tty
operator|.
name|c_cc
index|[
name|VTIME
index|]
operator|=
literal|0
expr_stmt|;
comment|/* no matter how long that takes.  */
ifdef|#
directive|ifdef
name|VSWTCH
name|tty
operator|.
name|c_cc
index|[
name|VSWTCH
index|]
operator|=
name|CDEL
expr_stmt|;
comment|/* Turn off shell layering use of C-z */
endif|#
directive|endif
comment|/* VSWTCH */
ifdef|#
directive|ifdef
name|mips
comment|/* The following code looks like the right thing in general, 		but it is said to cause a crash on USG V.4. 		Let's play safe by turning it on only for the MIPS.  */
ifdef|#
directive|ifdef
name|VSUSP
name|tty
operator|.
name|c_cc
index|[
name|VSUSP
index|]
operator|=
name|CDEL
expr_stmt|;
comment|/* Turn off mips handling of C-z.  */
endif|#
directive|endif
comment|/* VSUSP */
ifdef|#
directive|ifdef
name|V_DSUSP
name|tty
operator|.
name|c_cc
index|[
name|V_DSUSP
index|]
operator|=
name|CDEL
expr_stmt|;
comment|/* Turn off mips handling of C-y.  */
endif|#
directive|endif
comment|/* V_DSUSP */
endif|#
directive|endif
comment|/* mips */
ifdef|#
directive|ifdef
name|AIX
ifndef|#
directive|ifndef
name|IBMR2AIX
comment|/* AIX enhanced edit loses NULs, so disable it */
name|tty
operator|.
name|c_line
operator|=
literal|0
expr_stmt|;
name|tty
operator|.
name|c_iflag
operator|&=
operator|~
name|ASCEDIT
expr_stmt|;
else|#
directive|else
name|tty
operator|.
name|c_cc
index|[
name|VSTRT
index|]
operator|=
literal|255
expr_stmt|;
name|tty
operator|.
name|c_cc
index|[
name|VSTOP
index|]
operator|=
literal|255
expr_stmt|;
name|tty
operator|.
name|c_cc
index|[
name|VSUSP
index|]
operator|=
literal|255
expr_stmt|;
name|tty
operator|.
name|c_cc
index|[
name|VDSUSP
index|]
operator|=
literal|255
expr_stmt|;
endif|#
directive|endif
comment|/* IBMR2AIX */
comment|/* Also, PTY overloads NUL and BREAK. 	 don't ignore break, but don't signal either, so it looks like NUL. 	 This really serves a purpose only if running in an XTERM window 	 or via TELNET or the like, but does no harm elsewhere.  */
name|tty
operator|.
name|c_iflag
operator|&=
operator|~
name|IGNBRK
expr_stmt|;
name|tty
operator|.
name|c_iflag
operator|&=
operator|~
name|BRKINT
expr_stmt|;
endif|#
directive|endif
comment|/* AIX */
else|#
directive|else
comment|/* if not HAVE_TERMIO */
ifdef|#
directive|ifdef
name|VMS
name|tty
operator|.
name|tt_char
operator||=
name|TT$M_NOECHO
operator||
name|TT$M_EIGHTBIT
expr_stmt|;
if|if
condition|(
name|flow_control
condition|)
name|tty
operator|.
name|tt_char
operator||=
name|TT$M_TTSYNC
expr_stmt|;
else|else
name|tty
operator|.
name|tt_char
operator|&=
operator|~
name|TT$M_TTSYNC
expr_stmt|;
name|tty
operator|.
name|tt2_char
operator||=
name|TT2$M_PASTHRU
operator||
name|TT2$M_XON
expr_stmt|;
else|#
directive|else
comment|/* not VMS (BSD, that is) */
name|tty
operator|.
name|sg_flags
operator|&=
operator|~
operator|(
name|ECHO
operator||
name|CRMOD
operator||
name|XTABS
operator|)
expr_stmt|;
name|tty
operator|.
name|sg_flags
operator||=
name|ANYP
expr_stmt|;
name|tty
operator|.
name|sg_flags
operator||=
name|interrupt_input
condition|?
name|RAW
else|:
name|CBREAK
expr_stmt|;
endif|#
directive|endif
comment|/* not VMS (BSD, that is) */
endif|#
directive|endif
comment|/* not HAVE_TERMIO */
ifdef|#
directive|ifdef
name|VMS
name|SYS$QIOW
argument_list|(
literal|0
argument_list|,
name|input_chan
argument_list|,
name|IO$_SETMODE
argument_list|,
operator|&
name|input_iosb
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|tty
operator|.
name|class
argument_list|,
literal|12
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCSETN
argument_list|,
operator|&
name|tty
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* not VMS */
comment|/* This code added to insure that, if flow-control is not to be used, 	 we have an unlocked screen at the start. */
ifdef|#
directive|ifdef
name|TCXONC
if|if
condition|(
operator|!
name|flow_control
condition|)
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TCXONC
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TIOCSTART
if|if
condition|(
operator|!
name|flow_control
condition|)
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCSTART
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|AIX
name|hft_init
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|IBMR2AIX
block|{
comment|/* IBM's HFT device usually thinks a ^J should be LF/CR.  We need it        to be only LF.  This is the way that is done. */
name|struct
name|termio
name|tty
decl_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
literal|1
argument_list|,
name|HFTGETID
argument_list|,
operator|&
name|tty
argument_list|)
operator|!=
operator|-
literal|1
condition|)
name|write
argument_list|(
literal|1
argument_list|,
literal|"\033[20l"
argument_list|,
literal|5
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|#
directive|endif
ifdef|#
directive|ifdef
name|F_SETFL
ifdef|#
directive|ifdef
name|F_GETOWN
comment|/* F_SETFL does not imply existance of F_GETOWN */
if|if
condition|(
name|interrupt_input
condition|)
block|{
name|old_fcntl_owner
operator|=
name|fcntl
argument_list|(
literal|0
argument_list|,
name|F_GETOWN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fcntl
argument_list|(
literal|0
argument_list|,
name|F_SETOWN
argument_list|,
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
name|init_sigio
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* F_GETOWN */
endif|#
directive|endif
comment|/* F_SETFL */
comment|/* If going to use CBREAK mode, we must request C-g to interrupt 	   and turn off start and stop chars, etc. 	   If not going to use CBREAK mode, do this anyway 	   so as to turn off local flow control for user coming over 	   network on 4.2; in this case, only t_stopc and t_startc really matter.  */
ifdef|#
directive|ifdef
name|TIOCGLTC
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCGLTC
argument_list|,
operator|&
name|old_ltchars
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* TIOCGLTC */
ifndef|#
directive|ifndef
name|HAVE_TERMIO
ifdef|#
directive|ifdef
name|TIOCGETC
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCGETC
argument_list|,
operator|&
name|old_tchars
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCLGET
argument_list|,
operator|&
name|old_lmode
argument_list|)
expr_stmt|;
comment|/* Note: if not using CBREAK mode, it makes no difference how we set this */
name|tchars
operator|=
name|new_tchars
expr_stmt|;
name|tchars
operator|.
name|t_intrc
operator|=
name|quit_char
expr_stmt|;
if|if
condition|(
name|flow_control
condition|)
block|{
name|tchars
operator|.
name|t_startc
operator|=
literal|'\021'
expr_stmt|;
name|tchars
operator|.
name|t_stopc
operator|=
literal|'\023'
expr_stmt|;
block|}
comment|/* LPASS8 is new in 4.3, and makes cbreak mode provide all 8 bits.  */
ifndef|#
directive|ifndef
name|LPASS8
define|#
directive|define
name|LPASS8
value|0
endif|#
directive|endif
ifdef|#
directive|ifdef
name|BSD4_1
define|#
directive|define
name|LNOFLSH
value|0100000
endif|#
directive|endif
name|lmode
operator|=
name|LDECCTQ
operator||
name|LLITOUT
operator||
name|LPASS8
operator||
name|LNOFLSH
operator||
name|old_lmode
expr_stmt|;
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCSETC
argument_list|,
operator|&
name|tchars
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCLSET
argument_list|,
operator|&
name|lmode
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* TIOCGETC */
endif|#
directive|endif
comment|/* not HAVE_TERMIO */
ifdef|#
directive|ifdef
name|TIOCGLTC
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCSLTC
argument_list|,
operator|&
name|new_ltchars
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* TIOCGLTC */
ifdef|#
directive|ifdef
name|BSD4_1
if|if
condition|(
name|interrupt_input
condition|)
name|init_sigio
argument_list|()
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|VMS
comment|/*  Appears to do nothing when in PASTHRU mode.       SYS$QIOW (0, input_chan, IO$_SETMODE|IO$M_OUTBAND, 0, 0, 0, 		interrupt_signal, oob_chars, 0, 0, 0, 0); */
name|queue_kbd_input
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* VMS */
block|}
ifdef|#
directive|ifdef
name|VMS
comment|/* VMS sometimes has this symbol but lacks setvbuf.  */
undef|#
directive|undef
name|_IOFBF
endif|#
directive|endif
ifdef|#
directive|ifdef
name|_IOFBF
comment|/* This symbol is defined on recent USG systems.      Someone says without this call USG won't really buffer the file      even with a call to setbuf(). */
name|setvbuf
argument_list|(
name|stdout
argument_list|,
name|_sobuf
argument_list|,
name|_IOFBF
argument_list|,
sizeof|sizeof
name|_sobuf
argument_list|)
expr_stmt|;
else|#
directive|else
name|setbuf
argument_list|(
name|stdout
argument_list|,
name|_sobuf
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|set_terminal_modes
argument_list|()
expr_stmt|;
if|if
condition|(
name|term_initted
operator|&&
name|no_redraw_on_reenter
condition|)
block|{
if|if
condition|(
name|display_completed
condition|)
name|direct_output_forward_char
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|screen_garbaged
operator|=
literal|1
expr_stmt|;
name|term_initted
operator|=
literal|1
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Return nonzero if safe to use tabs in output.    At the time this is called, init_sys_modes has not been done yet.  */
end_comment

begin_macro
name|tabs_safe_p
argument_list|()
end_macro

begin_block
block|{
name|TERMINAL
name|tty
decl_stmt|;
if|if
condition|(
name|noninteractive
condition|)
return|return
literal|1
return|;
ifdef|#
directive|ifdef
name|VMS
name|SYS$QIOW
argument_list|(
literal|0
argument_list|,
name|input_chan
argument_list|,
name|IO$_SENSEMODE
argument_list|,
operator|&
name|tty
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|tty
operator|.
name|class
argument_list|,
literal|12
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCGETP
argument_list|,
operator|&
name|tty
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* not VMS */
return|return
operator|(
name|TABS_OK
argument_list|(
name|tty
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Get terminal size from system.    Store number of lines into *heightp and width into *widthp.    If zero or a negative number is stored, the value is not valid.  */
end_comment

begin_macro
name|get_screen_size
argument_list|(
argument|widthp
argument_list|,
argument|heightp
argument_list|)
end_macro

begin_decl_stmt
name|int
modifier|*
name|widthp
decl_stmt|,
modifier|*
name|heightp
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* Define the 4.3 names in terms of the Sun names    if the latter exist and the former do not.  */
ifdef|#
directive|ifdef
name|TIOCGSIZE
ifndef|#
directive|ifndef
name|TIOCGWINSZ
define|#
directive|define
name|TIOCGWINSZ
value|TIOCGSIZE
define|#
directive|define
name|winsize
value|ttysize
define|#
directive|define
name|ws_row
value|ts_lines
define|#
directive|define
name|ws_col
value|ts_cols
endif|#
directive|endif
endif|#
directive|endif
comment|/* Sun */
comment|/* Do it using the 4.3 names if possible.  */
ifdef|#
directive|ifdef
name|TIOCGWINSZ
name|struct
name|winsize
name|size
decl_stmt|;
operator|*
name|widthp
operator|=
literal|0
expr_stmt|;
operator|*
name|heightp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCGWINSZ
argument_list|,
operator|&
name|size
argument_list|)
operator|<
literal|0
condition|)
return|return;
operator|*
name|widthp
operator|=
name|size
operator|.
name|ws_col
expr_stmt|;
operator|*
name|heightp
operator|=
name|size
operator|.
name|ws_row
expr_stmt|;
else|#
directive|else
comment|/* not TIOCGWNSIZ */
ifdef|#
directive|ifdef
name|VMS
name|TERMINAL
name|tty
decl_stmt|;
name|SYS$QIOW
argument_list|(
literal|0
argument_list|,
name|input_chan
argument_list|,
name|IO$_SENSEMODE
argument_list|,
operator|&
name|tty
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|tty
operator|.
name|class
argument_list|,
literal|12
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|widthp
operator|=
name|tty
operator|.
name|scr_wid
expr_stmt|;
operator|*
name|heightp
operator|=
name|tty
operator|.
name|scr_len
expr_stmt|;
else|#
directive|else
comment|/* system doesn't know size */
operator|*
name|widthp
operator|=
literal|0
expr_stmt|;
operator|*
name|heightp
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* system does not know size */
endif|#
directive|endif
comment|/* not TIOCGWINSZ */
block|}
end_block

begin_escape
end_escape

begin_macro
name|reset_sys_modes
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|noninteractive
condition|)
block|{
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|term_initted
condition|)
return|return;
if|if
condition|(
name|read_socket_hook
condition|)
return|return;
name|move_cursor
argument_list|(
name|screen_height
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|clear_end_of_line
argument_list|(
name|screen_width
argument_list|)
expr_stmt|;
comment|/* clear_end_of_line may move the cursor */
name|move_cursor
argument_list|(
name|screen_height
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Output raw CR so kernel can track the cursor hpos.  */
name|cmputc
argument_list|(
literal|'\r'
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IBMR2AIX
block|{
comment|/* HFT devices normally use ^J as a LF/CR.  We forced it to         do the LF only.  Now, we need to reset it. */
name|struct
name|termio
name|tty
decl_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
literal|1
argument_list|,
name|HFTGETID
argument_list|,
operator|&
name|tty
argument_list|)
operator|!=
operator|-
literal|1
condition|)
name|write
argument_list|(
literal|1
argument_list|,
literal|"\033[20h"
argument_list|,
literal|5
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|reset_terminal_modes
argument_list|()
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BSD
ifndef|#
directive|ifndef
name|BSD4_1
comment|/* Avoid possible loss of output when changing terminal modes.  */
name|fsync
argument_list|(
name|fileno
argument_list|(
name|stdout
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TIOCGLTC
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCSLTC
argument_list|,
operator|&
name|old_ltchars
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* TIOCGLTC */
ifndef|#
directive|ifndef
name|HAVE_TERMIO
ifdef|#
directive|ifdef
name|TIOCGETC
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCSETC
argument_list|,
operator|&
name|old_tchars
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCLSET
argument_list|,
operator|&
name|old_lmode
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* TIOCGETC */
endif|#
directive|endif
comment|/* not HAVE_TERMIO */
ifdef|#
directive|ifdef
name|F_SETFL
ifdef|#
directive|ifdef
name|F_SETOWN
comment|/* F_SETFL does not imply existance of F_SETOWN */
if|if
condition|(
name|interrupt_input
condition|)
block|{
name|reset_sigio
argument_list|()
expr_stmt|;
name|fcntl
argument_list|(
literal|0
argument_list|,
name|F_SETOWN
argument_list|,
name|old_fcntl_owner
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* F_SETOWN */
endif|#
directive|endif
comment|/* F_SETFL */
ifdef|#
directive|ifdef
name|BSD4_1
if|if
condition|(
name|interrupt_input
condition|)
name|reset_sigio
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* BSD4_1 */
ifdef|#
directive|ifdef
name|VMS
name|end_kbd_input
argument_list|()
expr_stmt|;
name|SYS$QIOW
argument_list|(
literal|0
argument_list|,
name|input_chan
argument_list|,
name|IO$_SETMODE
argument_list|,
operator|&
name|input_iosb
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|old_gtty
operator|.
name|class
argument_list|,
literal|12
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* not VMS */
while|while
condition|(
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TCSETAW
argument_list|,
operator|&
name|old_gtty
argument_list|)
operator|<
literal|0
operator|&&
name|errno
operator|==
name|EINTR
condition|)
empty_stmt|;
endif|#
directive|endif
comment|/* not VMS */
ifdef|#
directive|ifdef
name|AIX
name|hft_reset
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_PTYS
end_ifdef

begin_comment
comment|/* Set up the proper status flags for use of a pty.  */
end_comment

begin_macro
name|setup_pty
argument_list|(
argument|fd
argument_list|)
end_macro

begin_decl_stmt
name|int
name|fd
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* I'm told that TOICREMOTE does not mean control chars      "can't be sent" but rather that they don't have      input-editing or signaling effects.      That should be good, because we have other ways      to do those things in Emacs.      However, telnet mode seems not to work on 4.2.      So TIOCREMOTE is turned off now. */
comment|/* Under hp-ux, if TIOCREMOTE is turned on, some calls      will hang.  In particular, the "timeout" feature (which      causes a read to return if there is no data available)      does this.  Also it is known that telnet mode will hang      in such a way that Emacs must be stopped (perhaps this      is the same problem).            If TIOCREMOTE is turned off, then there is a bug in      hp-ux which sometimes loses data.  Apparently the      code which blocks the master process when the internal      buffer fills up does not work.  Other than this,      though, everything else seems to work fine.            Since the latter lossage is more benign, we may as well      lose that way.  -- cph */
ifdef|#
directive|ifdef
name|FIONBIO
ifdef|#
directive|ifdef
name|SYSV_PTYS
block|{
name|int
name|on
init|=
literal|1
decl_stmt|;
name|ioctl
argument_list|(
name|fd
argument_list|,
name|FIONBIO
argument_list|,
operator|&
name|on
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|#
directive|endif
ifdef|#
directive|ifdef
name|IBMRTAIX
comment|/* On AIX, the parent gets SIGHUP when a pty attached child dies.  So, we */
comment|/* ignore SIGHUP once we've started a child on a pty.  Note that this may */
comment|/* cause EMACS not to die when it should, i.e., when its own controlling  */
comment|/* tty goes away.  I've complained to the AIX developers, and they may    */
comment|/* change this behavior, but I'm not going to hold my breath.             */
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_PTYS */
end_comment

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|VMS
end_ifdef

begin_comment
comment|/* Assigning an input channel is done at the start of Emacs execution.    This is called each time Emacs is resumed, also, but does nothing    because input_chain is no longer zero.  */
end_comment

begin_macro
name|init_vms_input
argument_list|()
end_macro

begin_block
block|{
name|int
name|status
decl_stmt|;
if|if
condition|(
name|input_chan
operator|==
literal|0
condition|)
block|{
name|status
operator|=
name|SYS$ASSIGN
argument_list|(
operator|&
name|input_dsc
argument_list|,
operator|&
name|input_chan
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|status
operator|&
literal|1
operator|)
condition|)
name|LIB$STOP
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Deassigning the input channel is done before exiting.  */
end_comment

begin_macro
name|stop_vms_input
argument_list|()
end_macro

begin_block
block|{
return|return
name|SYS$DASSGN
argument_list|(
name|input_chan
argument_list|)
return|;
block|}
end_block

begin_decl_stmt
name|short
name|input_buffer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Request reading one character into the keyboard buffer.    This is done as soon as the buffer becomes empty.  */
end_comment

begin_macro
name|queue_kbd_input
argument_list|()
end_macro

begin_block
block|{
name|int
name|status
decl_stmt|;
name|waiting_for_ast
operator|=
literal|0
expr_stmt|;
name|stop_input
operator|=
literal|0
expr_stmt|;
name|status
operator|=
name|SYS$QIO
argument_list|(
literal|0
argument_list|,
name|input_chan
argument_list|,
name|IO$_READVBLK
argument_list|,
operator|&
name|input_iosb
argument_list|,
name|kbd_input_ast
argument_list|,
literal|1
argument_list|,
operator|&
name|input_buffer
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|terminator_mask
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_decl_stmt
name|int
name|input_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Ast routine that is called when keyboard input comes in    in accord with the SYS$QIO above.  */
end_comment

begin_macro
name|kbd_input_ast
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|c
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|old_errno
init|=
name|errno
decl_stmt|;
if|if
condition|(
name|waiting_for_ast
condition|)
name|SYS$SETEF
argument_list|(
name|input_ef
argument_list|)
expr_stmt|;
name|waiting_for_ast
operator|=
literal|0
expr_stmt|;
name|input_count
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|ASTDEBUG
if|if
condition|(
name|input_count
operator|==
literal|25
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Ast # %d,"
argument_list|,
name|input_count
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" iosb = %x, %x, %x, %x"
argument_list|,
name|input_iosb
operator|.
name|offset
argument_list|,
name|input_iosb
operator|.
name|status
argument_list|,
name|input_iosb
operator|.
name|termlen
argument_list|,
name|input_iosb
operator|.
name|term
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|input_iosb
operator|.
name|offset
condition|)
block|{
name|c
operator|=
name|input_buffer
expr_stmt|;
ifdef|#
directive|ifdef
name|ASTDEBUG
name|printf
argument_list|(
literal|", char = 0%o"
argument_list|,
name|c
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|ASTDEBUG
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|stop_input
condition|)
name|queue_kbd_input
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|>=
literal|0
condition|)
name|kbd_buffer_store_char
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|errno
operator|=
name|old_errno
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Wait until there is something in kbd_buffer.  */
end_comment

begin_macro
name|wait_for_kbd_input
argument_list|()
end_macro

begin_block
block|{
specifier|extern
name|int
name|have_process_input
decl_stmt|,
name|process_exited
decl_stmt|;
comment|/* If already something, avoid doing system calls.  */
if|if
condition|(
name|detect_input_pending
argument_list|()
condition|)
block|{
return|return;
block|}
comment|/* Clear a flag, and tell ast routine above to set it.  */
name|SYS$CLREF
argument_list|(
name|input_ef
argument_list|)
expr_stmt|;
name|waiting_for_ast
operator|=
literal|1
expr_stmt|;
comment|/* Check for timing error: ast happened while we were doing that.  */
if|if
condition|(
operator|!
name|detect_input_pending
argument_list|()
condition|)
block|{
comment|/* No timing error: wait for flag to be set.  */
name|set_waiting_for_input
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|SYS$WFLOR
argument_list|(
name|input_ef
argument_list|,
name|input_eflist
argument_list|)
expr_stmt|;
name|clear_waiting_for_input
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|detect_input_pending
argument_list|()
condition|)
comment|/* Check for subprocess input availability */
block|{
name|int
name|dsp
init|=
name|have_process_input
operator|||
name|process_exited
decl_stmt|;
name|sys$clref
argument_list|(
name|process_ef
argument_list|)
expr_stmt|;
if|if
condition|(
name|have_process_input
condition|)
name|process_command_input
argument_list|()
expr_stmt|;
if|if
condition|(
name|process_exited
condition|)
name|process_exit
argument_list|()
expr_stmt|;
if|if
condition|(
name|dsp
condition|)
block|{
name|update_mode_lines
operator|++
expr_stmt|;
name|redisplay_preserve_echo_area
argument_list|()
expr_stmt|;
block|}
block|}
block|}
name|waiting_for_ast
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Get rid of any pending QIO, when we are about to suspend    or when we want to throw away pending input.    We wait for a positive sign that the AST routine has run    and therefore there is no I/O request queued when we return.    SYS$SETAST is used to avoid a timing error.  */
end_comment

begin_macro
name|end_kbd_input
argument_list|()
end_macro

begin_block
block|{
ifdef|#
directive|ifdef
name|ASTDEBUG
name|printf
argument_list|(
literal|"At end_kbd_input.\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|LIB$AST_IN_PROG
argument_list|()
condition|)
comment|/* Don't wait if suspending from kbd_buffer_store_char! */
block|{
name|SYS$CANCEL
argument_list|(
name|input_chan
argument_list|)
expr_stmt|;
return|return;
block|}
name|SYS$SETAST
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Clear a flag, and tell ast routine above to set it.  */
name|SYS$CLREF
argument_list|(
name|input_ef
argument_list|)
expr_stmt|;
name|waiting_for_ast
operator|=
literal|1
expr_stmt|;
name|stop_input
operator|=
literal|1
expr_stmt|;
name|SYS$CANCEL
argument_list|(
name|input_chan
argument_list|)
expr_stmt|;
name|SYS$SETAST
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|SYS$WAITFR
argument_list|(
name|input_ef
argument_list|)
expr_stmt|;
name|waiting_for_ast
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Wait for either input available or time interval expiry.  */
end_comment

begin_macro
name|input_wait_timeout
argument_list|(
argument|timeval
argument_list|)
end_macro

begin_decl_stmt
name|int
name|timeval
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Time to wait, in seconds */
end_comment

begin_block
block|{
name|int
name|time
index|[
literal|2
index|]
decl_stmt|;
name|LIB$EMUL
argument_list|(
operator|&
name|timeval
argument_list|,
operator|&
operator|-
literal|10000000
argument_list|,
operator|&
literal|0
argument_list|,
name|time
argument_list|)
expr_stmt|;
comment|/* Convert to VMS format */
comment|/* If already something, avoid doing system calls.  */
if|if
condition|(
name|detect_input_pending
argument_list|()
condition|)
block|{
return|return;
block|}
comment|/* Clear a flag, and tell ast routine above to set it.  */
name|SYS$CLREF
argument_list|(
name|input_ef
argument_list|)
expr_stmt|;
name|waiting_for_ast
operator|=
literal|1
expr_stmt|;
comment|/* Check for timing error: ast happened while we were doing that.  */
if|if
condition|(
operator|!
name|detect_input_pending
argument_list|()
condition|)
block|{
comment|/* No timing error: wait for flag to be set.  */
name|SYS$CANTIM
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|SYS$SETIMR
argument_list|(
name|timer_ef
argument_list|,
name|time
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
operator|&
literal|1
condition|)
comment|/* Set timer */
name|SYS$WFLOR
argument_list|(
name|timer_ef
argument_list|,
name|timer_eflist
argument_list|)
expr_stmt|;
comment|/* Wait for timer expiry or input */
block|}
name|waiting_for_ast
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_comment
comment|/* The standard `sleep' routine works some other way    and it stops working if you have ever quit out of it.    This one continues to work.  */
end_comment

begin_macro
name|sys_sleep
argument_list|(
argument|timeval
argument_list|)
end_macro

begin_decl_stmt
name|int
name|timeval
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|time
index|[
literal|2
index|]
decl_stmt|;
name|LIB$EMUL
argument_list|(
operator|&
name|timeval
argument_list|,
operator|&
operator|-
literal|10000000
argument_list|,
operator|&
literal|0
argument_list|,
name|time
argument_list|)
expr_stmt|;
comment|/* Convert to VMS format */
name|SYS$CANTIM
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|SYS$SETIMR
argument_list|(
name|timer_ef
argument_list|,
name|time
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
operator|&
literal|1
condition|)
comment|/* Set timer */
name|SYS$WAITFR
argument_list|(
name|timer_ef
argument_list|)
expr_stmt|;
comment|/* Wait for timer expiry only */
block|}
end_block

begin_macro
name|init_sigio
argument_list|()
end_macro

begin_block
block|{
name|request_sigio
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|reset_sigio
argument_list|()
end_macro

begin_block
block|{
name|unrequest_sigio
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|request_sigio
argument_list|()
end_macro

begin_block
block|{
name|croak
argument_list|(
literal|"request sigio"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|unrequest_sigio
argument_list|()
end_macro

begin_block
block|{
name|croak
argument_list|(
literal|"unrequest sigio"
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* VMS */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Note that VMS compiler won't accept defined (CANNOT_DUMP).  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|CANNOT_DUMP
end_ifndef

begin_define
define|#
directive|define
name|NEED_STARTS
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SYSTEM_MALLOC
end_ifndef

begin_ifndef
ifndef|#
directive|ifndef
name|NEED_STARTS
end_ifndef

begin_define
define|#
directive|define
name|NEED_STARTS
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|NEED_STARTS
end_ifdef

begin_comment
comment|/* Some systems that cannot dump also cannot implement these.  */
end_comment

begin_comment
comment|/*  *	Return the address of the start of the text segment prior to  *	doing an unexec().  After unexec() the return value is undefined.  *	See crt0.c for further explanation and _start().  *  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|CANNOT_UNEXEC
end_ifndef

begin_function
name|char
modifier|*
name|start_of_text
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|TEXT_START
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|TEXT_START
operator|)
return|;
else|#
directive|else
ifdef|#
directive|ifdef
name|GOULD
extern|extern csrt(
block|)
function|;
end_function

begin_return
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|csrt
operator|)
return|;
end_return

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* not GOULD */
end_comment

begin_function_decl
specifier|extern
name|int
name|_start
parameter_list|()
function_decl|;
end_function_decl

begin_return
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|_start
operator|)
return|;
end_return

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* GOULD */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TEXT_START */
end_comment

begin_endif
unit|}
endif|#
directive|endif
end_endif

begin_comment
comment|/* not CANNOT_UNEXEC */
end_comment

begin_comment
comment|/*  *	Return the address of the start of the data segment prior to  *	doing an unexec().  After unexec() the return value is undefined.  *	See crt0.c for further information and definition of data_start.  *  *	Apparently, on BSD systems this is etext at startup.  On  *	USG systems (swapping) this is highly mmu dependent and  *	is also dependent on whether or not the program is running  *	with shared text.  Generally there is a (possibly large)  *	gap between end of text and start of data with shared text.  *  *	On Uniplus+ systems with shared text, data starts at a  *	fixed address.  Each port (from a given oem) is generally  *	different, and the specific value of the start of data can  *	be obtained via the UniPlus+ specific "uvar(2)" system call,  *	however the method outlined in crt0.c seems to be more portable.  *  *	Probably what will have to happen when a USG unexec is available,  *	at least on UniPlus, is temacs will have to be made unshared so  *	that text and data are contiguous.  Then once loadup is complete,  *	unexec will produce a shared executable where the data can be  *	at the normal shared text boundry and the startofdata variable  *	will be patched by unexec to the correct value.  *  */
end_comment

begin_expr_stmt
unit|char
operator|*
name|start_of_data
argument_list|()
block|{
ifdef|#
directive|ifdef
name|DATA_START
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|DATA_START
operator|)
return|;
else|#
directive|else
specifier|extern
name|int
name|data_start
expr_stmt|;
end_expr_stmt

begin_return
return|return
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
name|data_start
operator|)
return|;
end_return

begin_endif
endif|#
directive|endif
end_endif

begin_endif
unit|}
endif|#
directive|endif
end_endif

begin_comment
comment|/* NEED_STARTS (not CANNOT_DUMP or not SYSTEM_MALLOC) */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|CANNOT_DUMP
end_ifndef

begin_comment
comment|/* Some systems that cannot dump also cannot implement these.  */
end_comment

begin_comment
comment|/*  *	Return the address of the end of the text segment prior to  *	doing an unexec().  After unexec() the return value is undefined.  */
end_comment

begin_expr_stmt
unit|char
operator|*
name|end_of_text
argument_list|()
block|{
ifdef|#
directive|ifdef
name|TEXT_END
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|TEXT_END
operator|)
return|;
else|#
directive|else
specifier|extern
name|int
name|etext
expr_stmt|;
end_expr_stmt

begin_return
return|return
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
name|etext
operator|)
return|;
end_return

begin_endif
endif|#
directive|endif
end_endif

begin_comment
unit|}
comment|/*  *	Return the address of the end of the data segment prior to  *	doing an unexec().  After unexec() the return value is undefined.  */
end_comment

begin_expr_stmt
unit|char
operator|*
name|end_of_data
argument_list|()
block|{
ifdef|#
directive|ifdef
name|DATA_END
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|DATA_END
operator|)
return|;
else|#
directive|else
specifier|extern
name|int
name|edata
expr_stmt|;
end_expr_stmt

begin_return
return|return
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
name|edata
operator|)
return|;
end_return

begin_endif
endif|#
directive|endif
end_endif

begin_endif
unit|}
endif|#
directive|endif
end_endif

begin_comment
comment|/* not CANNOT_DUMP */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Get_system_name returns as its value  a string for the Lisp function system-name to return. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|BSD4_1
end_ifdef

begin_include
include|#
directive|include
file|<whoami.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|USG
end_ifdef

begin_comment
comment|/* Can't have this within the function since `static' is #defined to nothing */
end_comment

begin_decl_stmt
unit|static
name|struct
name|utsname
name|get_system_name_name
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|char
modifier|*
name|get_system_name
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|USG
name|uname
argument_list|(
operator|&
name|get_system_name_name
argument_list|)
expr_stmt|;
return|return
operator|(
name|get_system_name_name
operator|.
name|nodename
operator|)
return|;
else|#
directive|else
comment|/* Not USG */
ifdef|#
directive|ifdef
name|BSD4_1
return|return
name|sysname
return|;
else|#
directive|else
comment|/* not USG, not 4.1 */
specifier|static
name|char
name|system_name_saved
index|[
literal|32
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|VMS
name|char
modifier|*
name|sp
decl_stmt|;
if|if
condition|(
operator|(
name|sp
operator|=
name|egetenv
argument_list|(
literal|"SYS$NODE"
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|sp
operator|=
literal|"vax-vms"
expr_stmt|;
else|else
block|{
name|char
modifier|*
name|end
decl_stmt|;
if|if
condition|(
operator|(
name|end
operator|=
name|index
argument_list|(
name|sp
argument_list|,
literal|':'
argument_list|)
operator|)
operator|!=
literal|0
condition|)
operator|*
name|end
operator|=
literal|'\0'
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|system_name_saved
argument_list|,
name|sp
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* not VMS */
name|gethostname
argument_list|(
name|system_name_saved
argument_list|,
sizeof|sizeof
argument_list|(
name|system_name_saved
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* not VMS */
return|return
name|system_name_saved
return|;
endif|#
directive|endif
comment|/* not USG, not 4.1 */
endif|#
directive|endif
comment|/* not USG */
block|}
end_function

begin_escape
end_escape

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_SELECT
end_ifndef

begin_comment
comment|/* Emulate as much as select as is possible under 4.1 and needed by Gnu Emacs  * Only checks read descriptors.  */
end_comment

begin_comment
comment|/* How long to wait between checking fds in select */
end_comment

begin_define
define|#
directive|define
name|SELECT_PAUSE
value|1
end_define

begin_decl_stmt
name|int
name|select_alarmed
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For longjmp'ing back to read_input_waiting.  */
end_comment

begin_decl_stmt
name|jmp_buf
name|read_alarm_throw
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if the alarm signal should throw back to read_input_waiting.    The read_socket_hook function sets this to 1 while it is waiting.  */
end_comment

begin_decl_stmt
name|int
name|read_alarm_should_throw
decl_stmt|;
end_decl_stmt

begin_macro
name|select_alarm
argument_list|()
end_macro

begin_block
block|{
name|select_alarmed
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|BSD4_1
name|sigrelse
argument_list|(
name|SIGALRM
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* not BSD4_1 */
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* not BSD4_1 */
if|if
condition|(
name|read_alarm_should_throw
condition|)
name|longjmp
argument_list|(
name|read_alarm_throw
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Only rfds are checked.  */
end_comment

begin_function
name|int
name|select
parameter_list|(
name|nfds
parameter_list|,
name|rfds
parameter_list|,
name|wfds
parameter_list|,
name|efds
parameter_list|,
name|timeout
parameter_list|)
name|int
name|nfds
decl_stmt|;
name|int
modifier|*
name|rfds
decl_stmt|,
decl|*
name|wfds
decl_stmt|,
modifier|*
name|efds
decl_stmt|,
modifier|*
name|timeout
decl_stmt|;
end_function

begin_block
block|{
name|int
name|ravail
init|=
literal|0
decl_stmt|,
name|orfds
init|=
literal|0
decl_stmt|,
name|old_alarm
decl_stmt|;
name|int
name|timeoutval
init|=
name|timeout
condition|?
operator|*
name|timeout
else|:
literal|100000
decl_stmt|;
name|int
modifier|*
name|local_timeout
init|=
operator|&
name|timeoutval
decl_stmt|;
specifier|extern
name|int
name|kbd_count
decl_stmt|;
specifier|extern
name|int
name|proc_buffered_char
index|[]
decl_stmt|;
ifndef|#
directive|ifndef
name|subprocesses
name|int
name|process_tick
init|=
literal|0
decl_stmt|,
name|update_tick
init|=
literal|0
decl_stmt|;
else|#
directive|else
specifier|extern
name|int
name|process_tick
decl_stmt|,
name|update_tick
decl_stmt|;
endif|#
directive|endif
name|int
function_decl|(
modifier|*
name|old_trap
function_decl|)
parameter_list|()
function_decl|;
name|char
name|buf
decl_stmt|;
if|if
condition|(
name|rfds
condition|)
block|{
name|orfds
operator|=
operator|*
name|rfds
expr_stmt|;
operator|*
name|rfds
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|wfds
condition|)
operator|*
name|wfds
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|efds
condition|)
operator|*
name|efds
operator|=
literal|0
expr_stmt|;
comment|/* If we are looking only for the terminal, with no timeout,      just read it and wait -- that's more efficient.  */
if|if
condition|(
name|orfds
operator|==
literal|1
operator|&&
operator|(
operator|!
name|timeout
operator|||
operator|*
name|timeout
operator|==
literal|100000
operator|)
operator|&&
name|process_tick
operator|==
name|update_tick
condition|)
block|{
if|if
condition|(
operator|!
name|kbd_count
condition|)
name|read_input_waiting
argument_list|()
expr_stmt|;
operator|*
name|rfds
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* Once a second, till the timer expires, check all the flagged read    * descriptors to see if any input is available.  If there is some then    * set the corresponding bit in the return copy of rfds.    */
while|while
condition|(
literal|1
condition|)
block|{
specifier|register
name|int
name|to_check
decl_stmt|,
name|bit
decl_stmt|,
name|fd
decl_stmt|;
if|if
condition|(
name|rfds
condition|)
block|{
for|for
control|(
name|to_check
operator|=
name|nfds
operator|,
name|bit
operator|=
literal|1
operator|,
name|fd
operator|=
literal|0
init|;
operator|--
name|to_check
operator|>=
literal|0
condition|;
name|bit
operator|<<=
literal|1
operator|,
name|fd
operator|++
control|)
block|{
if|if
condition|(
name|orfds
operator|&
name|bit
condition|)
block|{
name|int
name|avail
init|=
literal|0
decl_stmt|,
name|status
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|bit
operator|==
literal|1
condition|)
name|avail
operator|=
name|detect_input_pending
argument_list|()
expr_stmt|;
comment|/* Special keyboard handler */
else|else
block|{
ifdef|#
directive|ifdef
name|FIONREAD
name|status
operator|=
name|ioctl
argument_list|(
name|fd
argument_list|,
name|FIONREAD
argument_list|,
operator|&
name|avail
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* no FIONREAD */
comment|/* Hoping it will return -1 if nothing available 			 or 0 if all 0 chars requested are read.  */
if|if
condition|(
name|proc_buffered_char
index|[
name|fd
index|]
operator|>=
literal|0
condition|)
name|avail
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|avail
operator|=
name|read
argument_list|(
name|fd
argument_list|,
operator|&
name|buf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|avail
operator|>
literal|0
condition|)
name|proc_buffered_char
index|[
name|fd
index|]
operator|=
name|buf
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* no FIONREAD */
block|}
if|if
condition|(
name|status
operator|>=
literal|0
operator|&&
name|avail
operator|>
literal|0
condition|)
block|{
operator|(
operator|*
name|rfds
operator|)
operator||=
name|bit
expr_stmt|;
name|ravail
operator|++
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
operator|*
name|local_timeout
operator|==
literal|0
operator|||
name|ravail
operator|!=
literal|0
operator|||
name|process_tick
operator|!=
name|update_tick
condition|)
break|break;
name|old_alarm
operator|=
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|old_trap
operator|=
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|select_alarm
argument_list|)
expr_stmt|;
name|select_alarmed
operator|=
literal|0
expr_stmt|;
name|alarm
argument_list|(
name|SELECT_PAUSE
argument_list|)
expr_stmt|;
comment|/* Wait for a SIGALRM (or maybe a SIGTINT) */
while|while
condition|(
name|select_alarmed
operator|==
literal|0
operator|&&
operator|*
name|local_timeout
operator|!=
literal|0
operator|&&
name|process_tick
operator|==
name|update_tick
condition|)
block|{
comment|/* If we are interested in terminal input, 	     wait by reading the terminal. 	     That makes instant wakeup for terminal input at least.  */
if|if
condition|(
name|orfds
operator|&
literal|1
condition|)
block|{
name|read_input_waiting
argument_list|()
expr_stmt|;
if|if
condition|(
name|kbd_count
condition|)
name|select_alarmed
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|pause
argument_list|()
expr_stmt|;
block|}
operator|(
operator|*
name|local_timeout
operator|)
operator|-=
name|SELECT_PAUSE
expr_stmt|;
comment|/* Reset the old alarm if there was one */
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|old_trap
argument_list|)
expr_stmt|;
if|if
condition|(
name|old_alarm
operator|!=
literal|0
condition|)
block|{
comment|/* Reset or forge an interrupt for the original handler. */
name|old_alarm
operator|-=
name|SELECT_PAUSE
expr_stmt|;
if|if
condition|(
name|old_alarm
operator|<=
literal|0
condition|)
name|kill
argument_list|(
name|getpid
argument_list|()
argument_list|,
name|SIGALRM
argument_list|)
expr_stmt|;
comment|/* Fake an alarm with the orig' handler */
else|else
name|alarm
argument_list|(
name|old_alarm
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|local_timeout
operator|==
literal|0
condition|)
comment|/* Stop on timer being cleared */
break|break;
block|}
return|return
name|ravail
return|;
block|}
end_block

begin_comment
comment|/* Read keyboard input into the standard buffer,    waiting for at least one character.  */
end_comment

begin_comment
comment|/* Make all keyboard buffers much bigger when using X windows.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_X_WINDOWS
end_ifdef

begin_define
define|#
directive|define
name|BUFFER_SIZE_FACTOR
value|16
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|BUFFER_SIZE_FACTOR
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|read_input_waiting
argument_list|()
end_macro

begin_block
block|{
specifier|extern
name|int
name|kbd_count
decl_stmt|;
specifier|extern
name|unsigned
name|char
name|kbd_buffer
index|[]
decl_stmt|;
specifier|extern
name|unsigned
name|char
modifier|*
name|kbd_ptr
decl_stmt|;
name|int
name|val
decl_stmt|;
if|if
condition|(
name|read_socket_hook
condition|)
block|{
name|read_alarm_should_throw
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|setjmp
argument_list|(
name|read_alarm_throw
argument_list|)
condition|)
name|val
operator|=
call|(
modifier|*
name|read_socket_hook
call|)
argument_list|(
literal|0
argument_list|,
name|kbd_buffer
argument_list|,
literal|256
operator|*
name|BUFFER_SIZE_FACTOR
argument_list|)
expr_stmt|;
else|else
name|val
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
name|val
operator|=
name|read
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
name|kbd_buffer
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|>
literal|0
condition|)
block|{
name|kbd_ptr
operator|=
name|kbd_buffer
expr_stmt|;
name|kbd_count
operator|=
name|val
expr_stmt|;
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not HAVE_SELECT */
end_comment

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|BSD4_1
end_ifdef

begin_comment
comment|/* VARARGS */
end_comment

begin_macro
name|setpriority
argument_list|()
end_macro

begin_block
block|{
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/*  * Partially emulate 4.2 open call.  * open is defined as this in 4.1.  *  * - added by Michael Bloom @ Citicorp/TTI  *  */
end_comment

begin_function
name|int
name|sys_open
parameter_list|(
name|path
parameter_list|,
name|oflag
parameter_list|,
name|mode
parameter_list|)
name|char
modifier|*
name|path
decl_stmt|;
name|int
name|oflag
decl_stmt|,
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|oflag
operator|&
name|O_CREAT
condition|)
return|return
name|creat
argument_list|(
name|path
argument_list|,
name|mode
argument_list|)
return|;
else|else
return|return
name|open
argument_list|(
name|path
argument_list|,
name|oflag
argument_list|)
return|;
block|}
end_function

begin_macro
name|init_sigio
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|noninteractive
condition|)
return|return;
name|lmode
operator|=
name|LINTRUP
operator||
name|lmode
expr_stmt|;
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCLSET
argument_list|,
operator|&
name|lmode
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|reset_sigio
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|noninteractive
condition|)
return|return;
name|lmode
operator|=
operator|~
name|LINTRUP
operator|&
name|lmode
expr_stmt|;
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCLSET
argument_list|,
operator|&
name|lmode
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|request_sigio
argument_list|()
end_macro

begin_block
block|{
name|sigrelse
argument_list|(
name|SIGTINT
argument_list|)
expr_stmt|;
name|interrupts_deferred
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_macro
name|unrequest_sigio
argument_list|()
end_macro

begin_block
block|{
name|sighold
argument_list|(
name|SIGTINT
argument_list|)
expr_stmt|;
name|interrupts_deferred
operator|=
literal|1
expr_stmt|;
block|}
end_block

begin_comment
comment|/* still inside #ifdef BSD4_1 */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|subprocesses
end_ifdef

begin_decl_stmt
name|int
name|sigheld
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Mask of held signals */
end_comment

begin_macro
name|sigholdx
argument_list|(
argument|signum
argument_list|)
end_macro

begin_decl_stmt
name|int
name|signum
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|sigheld
operator||=
name|sigbit
argument_list|(
name|signum
argument_list|)
expr_stmt|;
name|sighold
argument_list|(
name|signum
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|sigisheld
argument_list|(
argument|signum
argument_list|)
end_macro

begin_decl_stmt
name|int
name|signum
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|sigheld
operator||=
name|sigbit
argument_list|(
name|signum
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|sigunhold
argument_list|(
argument|signum
argument_list|)
end_macro

begin_decl_stmt
name|int
name|signum
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|sigheld
operator|&=
operator|~
name|sigbit
argument_list|(
name|signum
argument_list|)
expr_stmt|;
name|sigrelse
argument_list|(
name|signum
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|sigfree
argument_list|()
end_macro

begin_comment
comment|/* Free all held signals */
end_comment

begin_block
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NSIG
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|sigheld
operator|&
name|sigbit
argument_list|(
name|i
argument_list|)
condition|)
name|sigrelse
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|sigheld
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_macro
name|sigbit
argument_list|(
argument|i
argument_list|)
end_macro

begin_block
block|{
return|return
literal|1
operator|<<
operator|(
name|i
operator|-
literal|1
operator|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* subprocesses */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* BSD4_1 */
end_comment

begin_escape
end_escape

begin_ifndef
ifndef|#
directive|ifndef
name|BSTRING
end_ifndef

begin_function
name|void
name|bzero
parameter_list|(
name|b
parameter_list|,
name|length
parameter_list|)
specifier|register
name|char
modifier|*
name|b
decl_stmt|;
specifier|register
name|int
name|length
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|VMS
name|short
name|zero
init|=
literal|0
decl_stmt|;
name|long
name|max_str
init|=
literal|65535
decl_stmt|;
while|while
condition|(
name|length
operator|>
name|max_str
condition|)
block|{
operator|(
name|void
operator|)
name|LIB$MOVC5
argument_list|(
operator|&
name|zero
argument_list|,
operator|&
name|zero
argument_list|,
operator|&
name|zero
argument_list|,
operator|&
name|max_str
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|length
operator|-=
name|max_str
expr_stmt|;
name|b
operator|+=
name|max_str
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|LIB$MOVC5
argument_list|(
operator|&
name|zero
argument_list|,
operator|&
name|zero
argument_list|,
operator|&
name|zero
argument_list|,
operator|&
name|length
argument_list|,
name|b
argument_list|)
expr_stmt|;
else|#
directive|else
while|while
condition|(
name|length
operator|--
operator|>
literal|0
condition|)
operator|*
name|b
operator|++
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* not VMS */
block|}
end_function

begin_comment
comment|/* Saying `void' requires a declaration, above, where bcopy is used    and that declaration causes pain for systems where bcopy is a macro.  */
end_comment

begin_expr_stmt
name|bcopy
argument_list|(
name|b1
argument_list|,
name|b2
argument_list|,
name|length
argument_list|)
specifier|register
name|char
operator|*
name|b1
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|char
modifier|*
name|b2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|int
name|length
decl_stmt|;
end_decl_stmt

begin_block
block|{
ifdef|#
directive|ifdef
name|VMS
name|long
name|max_str
init|=
literal|65535
decl_stmt|;
while|while
condition|(
name|length
operator|>
name|max_str
condition|)
block|{
operator|(
name|void
operator|)
name|LIB$MOVC3
argument_list|(
operator|&
name|max_str
argument_list|,
name|b1
argument_list|,
name|b2
argument_list|)
expr_stmt|;
name|length
operator|-=
name|max_str
expr_stmt|;
name|b1
operator|+=
name|max_str
expr_stmt|;
name|b2
operator|+=
name|max_str
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|LIB$MOVC3
argument_list|(
operator|&
name|length
argument_list|,
name|b1
argument_list|,
name|b2
argument_list|)
expr_stmt|;
else|#
directive|else
while|while
condition|(
name|length
operator|--
operator|>
literal|0
condition|)
operator|*
name|b2
operator|++
operator|=
operator|*
name|b1
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* not VMS */
block|}
end_block

begin_function
name|int
name|bcmp
parameter_list|(
name|b1
parameter_list|,
name|b2
parameter_list|,
name|length
parameter_list|)
comment|/* This could be a macro! */
specifier|register
name|char
modifier|*
name|b1
decl_stmt|;
specifier|register
name|char
modifier|*
name|b2
decl_stmt|;
specifier|register
name|int
name|length
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|VMS
name|struct
name|dsc$descriptor_s
name|src1
init|=
block|{
name|length
block|,
name|DSC$K_DTYPE_T
block|,
name|DSC$K_CLASS_S
block|,
name|b1
block|}
decl_stmt|;
name|struct
name|dsc$descriptor_s
name|src2
init|=
block|{
name|length
block|,
name|DSC$K_DTYPE_T
block|,
name|DSC$K_CLASS_S
block|,
name|b2
block|}
decl_stmt|;
return|return
name|STR$COMPARE
argument_list|(
operator|&
name|src1
argument_list|,
operator|&
name|src2
argument_list|)
return|;
else|#
directive|else
while|while
condition|(
name|length
operator|--
operator|>
literal|0
condition|)
if|if
condition|(
operator|*
name|b1
operator|++
operator|!=
operator|*
name|b2
operator|++
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
endif|#
directive|endif
comment|/* not VMS */
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not BSTRING */
end_comment

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|BSD4_1
end_ifdef

begin_function
name|long
name|random
parameter_list|()
block|{
return|return
operator|(
name|rand
argument_list|()
operator|)
return|;
block|}
end_function

begin_macro
name|srandom
argument_list|(
argument|arg
argument_list|)
end_macro

begin_decl_stmt
name|int
name|arg
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|srand
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
endif|BSD4_1
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HPUX
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|X11
end_ifdef

begin_define
define|#
directive|define
name|HAVE_RANDOM
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|USG
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_RANDOM
end_ifndef

begin_comment
comment|/*  *	The BSD random(3) returns numbers in the range of  *	0 to 2e31 - 1.  The USG rand(3C) returns numbers in the  *	range of 0 to 2e15 - 1.  This is probably not significant  *	in this usage.  */
end_comment

begin_function
name|long
name|random
parameter_list|()
block|{
comment|/* Arrange to return a range centered on zero.  */
return|return
name|rand
argument_list|()
operator|-
operator|(
literal|1
operator|<<
literal|14
operator|)
return|;
block|}
end_function

begin_macro
name|srandom
argument_list|(
argument|arg
argument_list|)
end_macro

begin_decl_stmt
name|int
name|arg
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|srand
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_RANDOM */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USG */
end_comment

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|VMS
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|getenv
end_ifdef

begin_comment
comment|/* If any place else asks for the TERM variable,    allow it to be overridden with the EMACS_TERM variable    before attempting to translate the logical name TERM.  As a last    resort, ask for VAX C's special idea of the TERM variable.  */
end_comment

begin_undef
undef|#
directive|undef
name|getenv
end_undef

begin_function
name|char
modifier|*
name|sys_getenv
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|val
decl_stmt|;
specifier|static
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
specifier|static
name|struct
name|dsc$descriptor_s
name|equiv
init|=
block|{
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
block|,
name|DSC$K_DTYPE_T
block|,
name|DSC$K_CLASS_S
block|,
name|buf
block|}
decl_stmt|;
specifier|static
name|struct
name|dsc$descriptor_s
name|d_name
init|=
block|{
literal|0
block|,
name|DSC$K_DTYPE_T
block|,
name|DSC$K_CLASS_S
block|,
literal|0
block|}
decl_stmt|;
name|short
name|eqlen
decl_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"TERM"
argument_list|)
condition|)
block|{
name|val
operator|=
operator|(
name|char
operator|*
operator|)
name|getenv
argument_list|(
literal|"EMACS_TERM"
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
condition|)
return|return
name|val
return|;
block|}
name|d_name
operator|.
name|dsc$w_length
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|d_name
operator|.
name|dsc$a_pointer
operator|=
name|name
expr_stmt|;
if|if
condition|(
name|lib$sys_trnlog
argument_list|(
operator|&
name|d_name
argument_list|,
operator|&
name|eqlen
argument_list|,
operator|&
name|equiv
argument_list|)
operator|==
literal|1
condition|)
block|{
name|char
modifier|*
name|str
init|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|eqlen
operator|+
literal|1
argument_list|)
decl_stmt|;
name|bcopy
argument_list|(
name|buf
argument_list|,
name|str
argument_list|,
name|eqlen
argument_list|)
expr_stmt|;
name|str
index|[
name|eqlen
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* This is a storage leak, but a pain to fix.  With luck, 	 no one will ever notice.  */
return|return
name|str
return|;
block|}
return|return
operator|(
name|char
operator|*
operator|)
name|getenv
argument_list|(
name|name
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* getenv */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|abort
end_ifdef

begin_comment
comment|/* Since VMS doesn't believe in core dumps, the only way to debug this beast is    to force a call on the debugger from within the image. */
end_comment

begin_undef
undef|#
directive|undef
name|abort
end_undef

begin_macro
name|sys_abort
argument_list|()
end_macro

begin_block
block|{
name|reset_sys_modes
argument_list|()
expr_stmt|;
name|LIB$SIGNAL
argument_list|(
name|SS$_DEBUG
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* abort */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* VMS */
end_comment

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|VMS
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|LINK_CRTL_SHARE
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|SHAREABLE_LIB_BUG
end_ifdef

begin_comment
comment|/* Variables declared noshare and initialized in shareable libraries    cannot be shared.  The VMS linker incorrectly forces you to use a private    version which is uninitialized... If not for this "feature", we    could use the C library definition of sys_nerr and sys_errlist. */
end_comment

begin_decl_stmt
name|int
name|sys_nerr
init|=
literal|35
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|sys_errlist
index|[]
init|=
block|{
literal|"error 0"
block|,
literal|"not owner"
block|,
literal|"no such file or directory"
block|,
literal|"no such process"
block|,
literal|"interrupted system call"
block|,
literal|"i/o error"
block|,
literal|"no such device or address"
block|,
literal|"argument list too long"
block|,
literal|"exec format error"
block|,
literal|"bad file number"
block|,
literal|"no child process"
block|,
literal|"no more processes"
block|,
literal|"not enough memory"
block|,
literal|"permission denied"
block|,
literal|"bad address"
block|,
literal|"block device required"
block|,
literal|"mount devices busy"
block|,
literal|"file exists"
block|,
literal|"cross-device link"
block|,
literal|"no such device"
block|,
literal|"not a directory"
block|,
literal|"is a directory"
block|,
literal|"invalid argument"
block|,
literal|"file table overflow"
block|,
literal|"too many open files"
block|,
literal|"not a typewriter"
block|,
literal|"text file busy"
block|,
literal|"file too big"
block|,
literal|"no space left on device"
block|,
literal|"illegal seek"
block|,
literal|"read-only file system"
block|,
literal|"too many links"
block|,
literal|"broken pipe"
block|,
literal|"math argument"
block|,
literal|"result too large"
block|,
literal|"I/O stream empty"
block|,
literal|"vax/vms specific error code nontranslatable error"
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SHAREABLE_LIB_BUG */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* LINK_CRTL_SHARE */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* VMS */
end_comment

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|INTERRUPTABLE_OPEN
end_ifdef

begin_function
name|int
comment|/* VARARGS 2 */
name|sys_open
parameter_list|(
name|path
parameter_list|,
name|oflag
parameter_list|,
name|mode
parameter_list|)
name|char
modifier|*
name|path
decl_stmt|;
name|int
name|oflag
decl_stmt|,
name|mode
decl_stmt|;
block|{
specifier|register
name|int
name|rtnval
decl_stmt|;
while|while
condition|(
operator|(
name|rtnval
operator|=
name|open
argument_list|(
name|path
argument_list|,
name|oflag
argument_list|,
name|mode
argument_list|)
operator|)
operator|==
operator|-
literal|1
operator|&&
operator|(
name|errno
operator|==
name|EINTR
operator|)
condition|)
empty_stmt|;
return|return
operator|(
name|rtnval
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* INTERRUPTABLE_OPEN */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|INTERRUPTABLE_CLOSE
end_ifdef

begin_macro
name|sys_close
argument_list|(
argument|fd
argument_list|)
end_macro

begin_decl_stmt
name|int
name|fd
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|rtnval
decl_stmt|;
while|while
condition|(
operator|(
name|rtnval
operator|=
name|close
argument_list|(
name|fd
argument_list|)
operator|)
operator|==
operator|-
literal|1
operator|&&
operator|(
name|errno
operator|==
name|EINTR
operator|)
condition|)
empty_stmt|;
return|return
name|rtnval
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* INTERRUPTABLE_CLOSE */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|INTERRUPTABLE_IO
end_ifdef

begin_function
name|int
name|sys_read
parameter_list|(
name|fildes
parameter_list|,
name|buf
parameter_list|,
name|nbyte
parameter_list|)
name|int
name|fildes
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|unsigned
name|int
name|nbyte
decl_stmt|;
block|{
specifier|register
name|int
name|rtnval
decl_stmt|;
while|while
condition|(
operator|(
name|rtnval
operator|=
name|read
argument_list|(
name|fildes
argument_list|,
name|buf
argument_list|,
name|nbyte
argument_list|)
operator|)
operator|==
operator|-
literal|1
operator|&&
operator|(
name|errno
operator|==
name|EINTR
operator|)
condition|)
empty_stmt|;
return|return
operator|(
name|rtnval
operator|)
return|;
block|}
end_function

begin_function
name|int
name|sys_write
parameter_list|(
name|fildes
parameter_list|,
name|buf
parameter_list|,
name|nbyte
parameter_list|)
name|int
name|fildes
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|unsigned
name|int
name|nbyte
decl_stmt|;
block|{
specifier|register
name|int
name|rtnval
decl_stmt|;
while|while
condition|(
operator|(
name|rtnval
operator|=
name|write
argument_list|(
name|fildes
argument_list|,
name|buf
argument_list|,
name|nbyte
argument_list|)
operator|)
operator|==
operator|-
literal|1
operator|&&
operator|(
name|errno
operator|==
name|EINTR
operator|)
condition|)
empty_stmt|;
return|return
operator|(
name|rtnval
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* INTERRUPTABLE_IO */
end_comment

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|USG
end_ifdef

begin_comment
comment|/*  *	All of the following are for USG.  *  *	On USG systems the system calls are interruptable by signals  *	that the user program has elected to catch.  Thus the system call  *	must be retried in these cases.  To handle this without massive  *	changes in the source code, we remap the standard system call names  *	to names for our own functions in sysdep.c that do the system call  *	with retries.  Actually, for portability reasons, it is good  *	programming practice, as this example shows, to limit all actual  *	system calls to a single occurance in the source.  Sure, this  *	adds an extra level of function call overhead but it is almost  *	always negligible.   Fred Fish, Unisoft Systems Inc.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|sys_siglist
index|[
name|NSIG
operator|+
literal|1
index|]
init|=
block|{
ifdef|#
directive|ifdef
name|AIX
comment|/* AIX has changed the signals a bit */
literal|"bogus signal"
block|,
comment|/* 0 */
literal|"hangup"
block|,
comment|/* 1  SIGHUP */
literal|"interrupt"
block|,
comment|/* 2  SIGINT */
literal|"quit"
block|,
comment|/* 3  SIGQUIT */
literal|"illegal instruction"
block|,
comment|/* 4  SIGILL */
literal|"trace trap"
block|,
comment|/* 5  SIGTRAP */
literal|"IOT instruction"
block|,
comment|/* 6  SIGIOT */
literal|"crash likely"
block|,
comment|/* 7  SIGDANGER */
literal|"floating point exception"
block|,
comment|/* 8  SIGFPE */
literal|"kill"
block|,
comment|/* 9  SIGKILL */
literal|"bus error"
block|,
comment|/* 10 SIGBUS */
literal|"segmentation violation"
block|,
comment|/* 11 SIGSEGV */
literal|"bad argument to system call"
block|,
comment|/* 12 SIGSYS */
literal|"write on a pipe with no one to read it"
block|,
comment|/* 13 SIGPIPE */
literal|"alarm clock"
block|,
comment|/* 14 SIGALRM */
literal|"software termination signum"
block|,
comment|/* 15 SIGTERM */
literal|"user defined signal 1"
block|,
comment|/* 16 SIGUSR1 */
literal|"user defined signal 2"
block|,
comment|/* 17 SIGUSR2 */
literal|"death of a child"
block|,
comment|/* 18 SIGCLD */
literal|"power-fail restart"
block|,
comment|/* 19 SIGPWR */
literal|"bogus signal"
block|,
comment|/* 20 */
literal|"bogus signal"
block|,
comment|/* 21 */
literal|"bogus signal"
block|,
comment|/* 22 */
literal|"bogus signal"
block|,
comment|/* 23 */
literal|"bogus signal"
block|,
comment|/* 24 */
literal|"LAN I/O interrupt"
block|,
comment|/* 25 SIGAIO */
literal|"PTY I/O interrupt"
block|,
comment|/* 26 SIGPTY */
literal|"I/O intervention required"
block|,
comment|/* 27 SIGIOINT */
literal|"HFT grant"
block|,
comment|/* 28 SIGGRANT */
literal|"HFT retract"
block|,
comment|/* 29 SIGRETRACT */
literal|"HFT sound done"
block|,
comment|/* 30 SIGSOUND */
literal|"HFT input ready"
block|,
comment|/* 31 SIGMSG */
else|#
directive|else
comment|/* not AIX */
literal|"bogus signal"
block|,
comment|/* 0 */
literal|"hangup"
block|,
comment|/* 1  SIGHUP */
literal|"interrupt"
block|,
comment|/* 2  SIGINT */
literal|"quit"
block|,
comment|/* 3  SIGQUIT */
literal|"illegal instruction"
block|,
comment|/* 4  SIGILL */
literal|"trace trap"
block|,
comment|/* 5  SIGTRAP */
literal|"IOT instruction"
block|,
comment|/* 6  SIGIOT */
literal|"EMT instruction"
block|,
comment|/* 7  SIGEMT */
literal|"floating point exception"
block|,
comment|/* 8  SIGFPE */
literal|"kill"
block|,
comment|/* 9  SIGKILL */
literal|"bus error"
block|,
comment|/* 10 SIGBUS */
literal|"segmentation violation"
block|,
comment|/* 11 SIGSEGV */
literal|"bad argument to system call"
block|,
comment|/* 12 SIGSYS */
literal|"write on a pipe with no one to read it"
block|,
comment|/* 13 SIGPIPE */
literal|"alarm clock"
block|,
comment|/* 14 SIGALRM */
literal|"software termination signum"
block|,
comment|/* 15 SIGTERM */
literal|"user defined signal 1"
block|,
comment|/* 16 SIGUSR1 */
literal|"user defined signal 2"
block|,
comment|/* 17 SIGUSR2 */
literal|"death of a child"
block|,
comment|/* 18 SIGCLD */
literal|"power-fail restart"
block|,
comment|/* 19 SIGPWR */
endif|#
directive|endif
comment|/* not AIX */
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *	Warning, this function may not duplicate 4.2 action properly  *	under error conditions.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|MAXPATHLEN
end_ifndef

begin_comment
comment|/* In 4.1, param.h fails to define this.  */
end_comment

begin_define
define|#
directive|define
name|MAXPATHLEN
value|1024
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_GETWD
end_ifndef

begin_function
name|char
modifier|*
name|getwd
parameter_list|(
name|pathname
parameter_list|)
name|char
modifier|*
name|pathname
decl_stmt|;
block|{
name|char
modifier|*
name|npath
decl_stmt|,
modifier|*
name|spath
decl_stmt|;
specifier|extern
name|char
modifier|*
name|getcwd
parameter_list|()
function_decl|;
name|spath
operator|=
name|npath
operator|=
name|getcwd
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|MAXPATHLEN
argument_list|)
expr_stmt|;
comment|/* On Altos 3068, getcwd can return @hostname/dir, so discard      up to first slash.  Should be harmless on other systems.  */
while|while
condition|(
operator|*
name|npath
operator|&&
operator|*
name|npath
operator|!=
literal|'/'
condition|)
name|npath
operator|++
expr_stmt|;
name|strcpy
argument_list|(
name|pathname
argument_list|,
name|npath
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|spath
argument_list|)
expr_stmt|;
comment|/* getcwd uses malloc */
return|return
name|pathname
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
endif|HAVE_GETWD
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_RENAME
end_ifndef

begin_comment
comment|/*  *	Emulate rename using unlink/link.  Note that this is  *	only partially correct.  Also, doesn't enforce restriction  *	that files be of same type (regular->regular, dir->dir, etc).  */
end_comment

begin_macro
name|rename
argument_list|(
argument|from
argument_list|,
argument|to
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|from
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|to
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|access
argument_list|(
name|from
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
block|{
name|unlink
argument_list|(
name|to
argument_list|)
expr_stmt|;
if|if
condition|(
name|link
argument_list|(
name|from
argument_list|,
name|to
argument_list|)
operator|==
literal|0
condition|)
if|if
condition|(
name|unlink
argument_list|(
name|from
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not HAVE_RENAME */
end_comment

begin_comment
comment|/* VARARGS */
end_comment

begin_macro
name|setpriority
argument_list|()
end_macro

begin_block
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_VFORK
end_ifndef

begin_comment
comment|/*  *	Substitute fork(2) for vfork(2) on USG flavors.  */
end_comment

begin_macro
name|vfork
argument_list|()
end_macro

begin_block
block|{
return|return
operator|(
name|fork
argument_list|()
operator|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not HAVE_VFORK */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|MISSING_UTIMES
end_ifdef

begin_comment
comment|/* HPUX (among others) sets HAVE_TIMEVAL but does not implement utimes.  */
end_comment

begin_macro
name|utimes
argument_list|()
end_macro

begin_block
block|{ }
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|IRIS_UTIME
end_ifdef

begin_comment
comment|/* The IRIS (3.5) has timevals, but uses sys V utime, and doesn't have the    utimbuf structure defined anywhere but in the man page. */
end_comment

begin_struct
struct|struct
name|utimbuf
block|{
name|long
name|actime
decl_stmt|;
name|long
name|modtime
decl_stmt|;
block|}
struct|;
end_struct

begin_macro
name|utimes
argument_list|(
argument|name
argument_list|,
argument|tvp
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|timeval
name|tvp
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|utimbuf
name|utb
decl_stmt|;
name|utb
operator|.
name|actime
operator|=
name|tvp
index|[
literal|0
index|]
operator|.
name|tv_sec
expr_stmt|;
name|utb
operator|.
name|modtime
operator|=
name|tvp
index|[
literal|1
index|]
operator|.
name|tv_sec
expr_stmt|;
name|utime
argument_list|(
name|name
argument_list|,
operator|&
name|utb
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* IRIS_UTIME */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_ifdef
ifdef|#
directive|ifdef
name|HPUX
end_ifdef

begin_comment
comment|/* HPUX curses library references perror, but as far as we know    it won't be called.  Anyway this definition will do for now.  */
end_comment

begin_endif
unit|perror () { }
endif|#
directive|endif
end_endif

begin_comment
comment|/* HPUX */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* 0 */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_DUP2
end_ifndef

begin_comment
comment|/*  *	Emulate BSD dup2(2).  First close newd if it already exists.  *	Then, attempt to dup oldd.  If not successful, call dup2 recursively  *	until we are, then close the unsuccessful ones.  */
end_comment

begin_macro
name|dup2
argument_list|(
argument|oldd
argument_list|,
argument|newd
argument_list|)
end_macro

begin_decl_stmt
name|int
name|oldd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|newd
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|fd
decl_stmt|;
name|sys_close
argument_list|(
name|newd
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|F_DUPFD
name|fd
operator|=
name|fcntl
argument_list|(
name|oldd
argument_list|,
name|F_DUPFD
argument_list|,
name|newd
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|!=
name|newd
condition|)
name|error
argument_list|(
literal|"cant dup2(%i,%i) : %s"
argument_list|,
name|oldd
argument_list|,
name|newd
argument_list|,
name|sys_errlist
index|[
name|errno
index|]
argument_list|)
expr_stmt|;
else|#
directive|else
while|while
condition|(
operator|(
name|fd
operator|=
name|dup
argument_list|(
name|oldd
argument_list|)
operator|)
operator|!=
name|newd
condition|)
block|{
name|dup2
argument_list|(
name|oldd
argument_list|,
name|newd
argument_list|)
expr_stmt|;
name|sys_close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not HAVE_DUP2 */
end_comment

begin_comment
comment|/*  *	Gettimeofday.  Simulate as much as possible.  Only accurate  *	to nearest second.  Emacs doesn't use tzp so ignore it for now.  *	Only needed when subprocesses are defined.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|subprocesses
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_GETTIMEOFDAY
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_TIMEVAL
end_ifdef

begin_comment
comment|/* ARGSUSED */
end_comment

begin_macro
name|gettimeofday
argument_list|(
argument|tp
argument_list|,
argument|tzp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|timeval
modifier|*
name|tp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|timezone
modifier|*
name|tzp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|extern
name|long
name|time
parameter_list|()
function_decl|;
name|tp
operator|->
name|tv_sec
operator|=
name|time
argument_list|(
operator|(
name|long
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|tp
operator|->
name|tv_usec
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* subprocess&& !HAVE_GETTIMEOFDAY&& HAVE_TIMEVAL */
end_comment

begin_comment
comment|/*  *	This function will go away as soon as all the stubs fixed. (fnf)  */
end_comment

begin_macro
name|croak
argument_list|(
argument|badfunc
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|badfunc
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|printf
argument_list|(
literal|"%s not yet implemented\r\n"
argument_list|,
name|badfunc
argument_list|)
expr_stmt|;
name|reset_sys_modes
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USG */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Directory routines for systems that don't have them. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SYSV_SYSTEM_DIR
end_ifdef

begin_include
include|#
directive|include
file|<dirent.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_CLOSEDIR
end_ifndef

begin_function
name|int
name|closedir
parameter_list|(
name|dirp
parameter_list|)
specifier|register
name|DIR
modifier|*
name|dirp
decl_stmt|;
comment|/* stream from opendir() */
block|{
name|sys_close
argument_list|(
name|dirp
operator|->
name|dd_fd
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dirp
operator|->
name|dd_buf
argument_list|)
expr_stmt|;
comment|/* directory block defined in<dirent.h> */
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dirp
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not HAVE_CLOSEDIR */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SYSV_SYSTEM_DIR */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|NONSYSTEM_DIR_LIBRARY
end_ifdef

begin_function
name|DIR
modifier|*
name|opendir
parameter_list|(
name|filename
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
comment|/* name of directory */
block|{
specifier|register
name|DIR
modifier|*
name|dirp
decl_stmt|;
comment|/* -> malloc'ed storage */
specifier|register
name|int
name|fd
decl_stmt|;
comment|/* file descriptor for read */
name|struct
name|stat
name|sbuf
decl_stmt|;
comment|/* result of fstat() */
name|fd
operator|=
name|sys_open
argument_list|(
name|filename
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|fstat
argument_list|(
name|fd
argument_list|,
operator|&
name|sbuf
argument_list|)
operator|<
literal|0
operator|||
operator|(
name|sbuf
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|!=
name|S_IFDIR
operator|||
operator|(
name|dirp
operator|=
operator|(
name|DIR
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|DIR
argument_list|)
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|sys_close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
comment|/* bad luck today */
block|}
name|dirp
operator|->
name|dd_fd
operator|=
name|fd
expr_stmt|;
name|dirp
operator|->
name|dd_loc
operator|=
name|dirp
operator|->
name|dd_size
operator|=
literal|0
expr_stmt|;
comment|/* refill needed */
return|return
name|dirp
return|;
block|}
end_function

begin_function
name|void
name|closedir
parameter_list|(
name|dirp
parameter_list|)
specifier|register
name|DIR
modifier|*
name|dirp
decl_stmt|;
comment|/* stream from opendir() */
block|{
name|sys_close
argument_list|(
name|dirp
operator|->
name|dd_fd
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dirp
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|VMS
end_ifndef

begin_define
define|#
directive|define
name|DIRSIZ
value|14
end_define

begin_struct
struct|struct
name|olddir
block|{
name|ino_t
name|od_ino
decl_stmt|;
comment|/* inode */
name|char
name|od_name
index|[
name|DIRSIZ
index|]
decl_stmt|;
comment|/* filename */
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not VMS */
end_comment

begin_decl_stmt
name|struct
name|direct
name|dir_static
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* simulated directory contents */
end_comment

begin_comment
comment|/* ARGUSED */
end_comment

begin_function
name|struct
name|direct
modifier|*
name|readdir
parameter_list|(
name|dirp
parameter_list|)
specifier|register
name|DIR
modifier|*
name|dirp
decl_stmt|;
comment|/* stream from opendir() */
block|{
ifndef|#
directive|ifndef
name|VMS
specifier|register
name|struct
name|olddir
modifier|*
name|dp
decl_stmt|;
comment|/* -> directory data */
else|#
directive|else
comment|/* VMS */
specifier|register
name|struct
name|dir$_name
modifier|*
name|dp
decl_stmt|;
comment|/* -> directory data */
specifier|register
name|struct
name|dir$_version
modifier|*
name|dv
decl_stmt|;
comment|/* -> version data */
endif|#
directive|endif
comment|/* VMS */
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|dirp
operator|->
name|dd_loc
operator|>=
name|dirp
operator|->
name|dd_size
condition|)
name|dirp
operator|->
name|dd_loc
operator|=
name|dirp
operator|->
name|dd_size
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dirp
operator|->
name|dd_size
operator|==
literal|0
comment|/* refill buffer */
operator|&&
operator|(
name|dirp
operator|->
name|dd_size
operator|=
name|sys_read
argument_list|(
name|dirp
operator|->
name|dd_fd
argument_list|,
name|dirp
operator|->
name|dd_buf
argument_list|,
name|DIRBLKSIZ
argument_list|)
operator|)
operator|<=
literal|0
condition|)
return|return
literal|0
return|;
ifndef|#
directive|ifndef
name|VMS
name|dp
operator|=
operator|(
expr|struct
name|olddir
operator|*
operator|)
operator|&
name|dirp
operator|->
name|dd_buf
index|[
name|dirp
operator|->
name|dd_loc
index|]
expr_stmt|;
name|dirp
operator|->
name|dd_loc
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|olddir
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|od_ino
operator|!=
literal|0
condition|)
comment|/* not deleted entry */
block|{
name|dir_static
operator|.
name|d_ino
operator|=
name|dp
operator|->
name|od_ino
expr_stmt|;
name|strncpy
argument_list|(
name|dir_static
operator|.
name|d_name
argument_list|,
name|dp
operator|->
name|od_name
argument_list|,
name|DIRSIZ
argument_list|)
expr_stmt|;
name|dir_static
operator|.
name|d_name
index|[
name|DIRSIZ
index|]
operator|=
literal|'\0'
expr_stmt|;
name|dir_static
operator|.
name|d_namlen
operator|=
name|strlen
argument_list|(
name|dir_static
operator|.
name|d_name
argument_list|)
expr_stmt|;
name|dir_static
operator|.
name|d_reclen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|direct
argument_list|)
operator|-
name|MAXNAMLEN
operator|+
literal|3
operator|+
name|dir_static
operator|.
name|d_namlen
operator|-
name|dir_static
operator|.
name|d_namlen
operator|%
literal|4
expr_stmt|;
return|return
operator|&
name|dir_static
return|;
comment|/* -> simulated structure */
block|}
else|#
directive|else
comment|/* VMS */
name|dp
operator|=
operator|(
expr|struct
name|dir$_name
operator|*
operator|)
name|dirp
operator|->
name|dd_buf
expr_stmt|;
if|if
condition|(
name|dirp
operator|->
name|dd_loc
operator|==
literal|0
condition|)
name|dirp
operator|->
name|dd_loc
operator|=
operator|(
name|dp
operator|->
name|dir$b_namecount
operator|&
literal|1
operator|)
condition|?
name|dp
operator|->
name|dir$b_namecount
operator|+
literal|1
else|:
name|dp
operator|->
name|dir$b_namecount
expr_stmt|;
name|dv
operator|=
operator|(
expr|struct
name|dir$_version
operator|*
operator|)
operator|&
name|dp
operator|->
name|dir$t_name
index|[
name|dirp
operator|->
name|dd_loc
index|]
expr_stmt|;
name|dir_static
operator|.
name|d_ino
operator|=
name|dv
operator|->
name|dir$w_fid_num
expr_stmt|;
name|dir_static
operator|.
name|d_namlen
operator|=
name|dp
operator|->
name|dir$b_namecount
expr_stmt|;
name|dir_static
operator|.
name|d_reclen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|direct
argument_list|)
operator|-
name|MAXNAMLEN
operator|+
literal|3
operator|+
name|dir_static
operator|.
name|d_namlen
operator|-
name|dir_static
operator|.
name|d_namlen
operator|%
literal|4
expr_stmt|;
name|strncpy
argument_list|(
name|dir_static
operator|.
name|d_name
argument_list|,
name|dp
operator|->
name|dir$t_name
argument_list|,
name|dp
operator|->
name|dir$b_namecount
argument_list|)
expr_stmt|;
name|dir_static
operator|.
name|d_name
index|[
name|dir_static
operator|.
name|d_namlen
index|]
operator|=
literal|'\0'
expr_stmt|;
name|dirp
operator|->
name|dd_loc
operator|=
name|dirp
operator|->
name|dd_size
expr_stmt|;
comment|/* only one record at a time */
return|return
operator|&
name|dir_static
return|;
endif|#
directive|endif
comment|/* VMS */
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|VMS
end_ifdef

begin_comment
comment|/* readdirver is just like readdir except it returns all versions of a file    as separate entries.  */
end_comment

begin_comment
comment|/* ARGUSED */
end_comment

begin_function
name|struct
name|direct
modifier|*
name|readdirver
parameter_list|(
name|dirp
parameter_list|)
specifier|register
name|DIR
modifier|*
name|dirp
decl_stmt|;
comment|/* stream from opendir() */
block|{
specifier|register
name|struct
name|dir$_name
modifier|*
name|dp
decl_stmt|;
comment|/* -> directory data */
specifier|register
name|struct
name|dir$_version
modifier|*
name|dv
decl_stmt|;
comment|/* -> version data */
if|if
condition|(
name|dirp
operator|->
name|dd_loc
operator|>=
name|dirp
operator|->
name|dd_size
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|dir$_name
argument_list|)
condition|)
name|dirp
operator|->
name|dd_loc
operator|=
name|dirp
operator|->
name|dd_size
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dirp
operator|->
name|dd_size
operator|==
literal|0
comment|/* refill buffer */
operator|&&
operator|(
name|dirp
operator|->
name|dd_size
operator|=
name|sys_read
argument_list|(
name|dirp
operator|->
name|dd_fd
argument_list|,
name|dirp
operator|->
name|dd_buf
argument_list|,
name|DIRBLKSIZ
argument_list|)
operator|)
operator|<=
literal|0
condition|)
return|return
literal|0
return|;
name|dp
operator|=
operator|(
expr|struct
name|dir$_name
operator|*
operator|)
name|dirp
operator|->
name|dd_buf
expr_stmt|;
if|if
condition|(
name|dirp
operator|->
name|dd_loc
operator|==
literal|0
condition|)
name|dirp
operator|->
name|dd_loc
operator|=
operator|(
name|dp
operator|->
name|dir$b_namecount
operator|&
literal|1
operator|)
condition|?
name|dp
operator|->
name|dir$b_namecount
operator|+
literal|1
else|:
name|dp
operator|->
name|dir$b_namecount
expr_stmt|;
name|dv
operator|=
operator|(
expr|struct
name|dir$_version
operator|*
operator|)
operator|&
name|dp
operator|->
name|dir$t_name
index|[
name|dirp
operator|->
name|dd_loc
index|]
expr_stmt|;
name|strncpy
argument_list|(
name|dir_static
operator|.
name|d_name
argument_list|,
name|dp
operator|->
name|dir$t_name
argument_list|,
name|dp
operator|->
name|dir$b_namecount
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
operator|&
name|dir_static
operator|.
name|d_name
index|[
name|dp
operator|->
name|dir$b_namecount
index|]
argument_list|,
literal|";%d"
argument_list|,
name|dv
operator|->
name|dir$w_version
argument_list|)
expr_stmt|;
name|dir_static
operator|.
name|d_namlen
operator|=
name|strlen
argument_list|(
name|dir_static
operator|.
name|d_name
argument_list|)
expr_stmt|;
name|dir_static
operator|.
name|d_ino
operator|=
name|dv
operator|->
name|dir$w_fid_num
expr_stmt|;
name|dir_static
operator|.
name|d_reclen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|direct
argument_list|)
operator|-
name|MAXNAMLEN
operator|+
literal|3
operator|+
name|dir_static
operator|.
name|d_namlen
operator|-
name|dir_static
operator|.
name|d_namlen
operator|%
literal|4
expr_stmt|;
name|dirp
operator|->
name|dd_loc
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
operator|(
operator|++
name|dv
operator|)
operator|-
name|dp
operator|->
name|dir$t_name
operator|)
expr_stmt|;
return|return
operator|&
name|dir_static
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* VMS */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NONSYSTEM_DIR_LIBRARY */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Functions for VMS */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|VMS
end_ifdef

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|<acldef.h>
end_include

begin_include
include|#
directive|include
file|<chpdef.h>
end_include

begin_include
include|#
directive|include
file|<jpidef.h>
end_include

begin_comment
comment|/* Return as a string the VMS error string pertaining to STATUS.    Reuses the same static buffer each time it is called.  */
end_comment

begin_function
name|char
modifier|*
name|vmserrstr
parameter_list|(
name|status
parameter_list|)
name|int
name|status
decl_stmt|;
comment|/* VMS status code */
block|{
name|int
name|bufadr
index|[
literal|2
index|]
decl_stmt|;
name|short
name|len
decl_stmt|;
specifier|static
name|char
name|buf
index|[
literal|257
index|]
decl_stmt|;
name|bufadr
index|[
literal|0
index|]
operator|=
sizeof|sizeof
name|buf
operator|-
literal|1
expr_stmt|;
name|bufadr
index|[
literal|1
index|]
operator|=
name|buf
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|SYS$GETMSG
argument_list|(
name|status
argument_list|,
operator|&
name|len
argument_list|,
name|bufadr
argument_list|,
literal|0x1
argument_list|,
literal|0
argument_list|)
operator|&
literal|1
operator|)
condition|)
return|return
literal|"untranslatable VMS error status"
return|;
name|buf
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|access
end_ifdef

begin_undef
undef|#
directive|undef
name|access
end_undef

begin_comment
comment|/* The following is necessary because 'access' emulation by VMS C (2.0) does  * not work correctly.  (It also doesn't work well in version 2.3.)  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|VMS4_4
end_ifdef

begin_define
define|#
directive|define
name|DESCRIPTOR
parameter_list|(
name|name
parameter_list|,
name|string
parameter_list|)
value|struct dsc$descriptor_s name = \ 	{ strlen(string), DSC$K_DTYPE_T, DSC$K_CLASS_S, string }
end_define

begin_typedef
typedef|typedef
union|union
block|{
struct|struct
block|{
name|unsigned
name|short
name|s_buflen
decl_stmt|;
name|unsigned
name|short
name|s_code
decl_stmt|;
name|char
modifier|*
name|s_bufadr
decl_stmt|;
name|unsigned
name|short
modifier|*
name|s_retlenadr
decl_stmt|;
block|}
name|s
struct|;
name|int
name|end
decl_stmt|;
block|}
name|item
typedef|;
end_typedef

begin_define
define|#
directive|define
name|buflen
value|s.s_buflen
end_define

begin_define
define|#
directive|define
name|code
value|s.s_code
end_define

begin_define
define|#
directive|define
name|bufadr
value|s.s_bufadr
end_define

begin_define
define|#
directive|define
name|retlenadr
value|s.s_retlenadr
end_define

begin_define
define|#
directive|define
name|R_OK
value|4
end_define

begin_comment
comment|/* test for read permission */
end_comment

begin_define
define|#
directive|define
name|W_OK
value|2
end_define

begin_comment
comment|/* test for write permission */
end_comment

begin_define
define|#
directive|define
name|X_OK
value|1
end_define

begin_comment
comment|/* test for execute (search) permission */
end_comment

begin_define
define|#
directive|define
name|F_OK
value|0
end_define

begin_comment
comment|/* test for presence of file */
end_comment

begin_function
name|int
name|sys_access
parameter_list|(
name|path
parameter_list|,
name|mode
parameter_list|)
name|char
modifier|*
name|path
decl_stmt|;
name|int
name|mode
decl_stmt|;
block|{
specifier|static
name|char
modifier|*
name|user
init|=
name|NULL
decl_stmt|;
name|char
name|dir_fn
index|[
literal|512
index|]
decl_stmt|;
comment|/* translate possible directory spec into .DIR file name, so brain-dead    * access() can treat the directory like a file.  */
if|if
condition|(
name|directory_file_name
argument_list|(
name|path
argument_list|,
name|dir_fn
argument_list|)
condition|)
name|path
operator|=
name|dir_fn
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|F_OK
condition|)
return|return
name|access
argument_list|(
name|path
argument_list|,
name|mode
argument_list|)
return|;
if|if
condition|(
name|user
operator|==
name|NULL
operator|&&
operator|(
name|user
operator|=
name|getenv
argument_list|(
literal|"USER"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
block|{
name|int
name|stat
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|int
name|acces
decl_stmt|;
name|int
name|dummy
decl_stmt|;
name|item
name|itemlst
index|[
literal|3
index|]
decl_stmt|;
name|DESCRIPTOR
argument_list|(
name|path_desc
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|DESCRIPTOR
argument_list|(
name|user_desc
argument_list|,
name|user
argument_list|)
expr_stmt|;
name|flags
operator|=
literal|0
expr_stmt|;
name|acces
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|mode
operator|&
name|X_OK
operator|)
operator|&&
operator|(
operator|(
name|stat
operator|=
name|access
argument_list|(
name|path
argument_list|,
name|mode
argument_list|)
operator|)
operator|<
literal|0
operator|||
name|mode
operator|==
name|X_OK
operator|)
condition|)
return|return
name|stat
return|;
if|if
condition|(
name|mode
operator|&
name|R_OK
condition|)
name|acces
operator||=
name|CHP$M_READ
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|W_OK
condition|)
name|acces
operator||=
name|CHP$M_WRITE
expr_stmt|;
name|itemlst
index|[
literal|0
index|]
operator|.
name|buflen
operator|=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|itemlst
index|[
literal|0
index|]
operator|.
name|code
operator|=
name|CHP$_FLAGS
expr_stmt|;
name|itemlst
index|[
literal|0
index|]
operator|.
name|bufadr
operator|=
operator|&
name|flags
expr_stmt|;
name|itemlst
index|[
literal|0
index|]
operator|.
name|retlenadr
operator|=
operator|&
name|dummy
expr_stmt|;
name|itemlst
index|[
literal|1
index|]
operator|.
name|buflen
operator|=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|itemlst
index|[
literal|1
index|]
operator|.
name|code
operator|=
name|CHP$_ACCESS
expr_stmt|;
name|itemlst
index|[
literal|1
index|]
operator|.
name|bufadr
operator|=
operator|&
name|acces
expr_stmt|;
name|itemlst
index|[
literal|1
index|]
operator|.
name|retlenadr
operator|=
operator|&
name|dummy
expr_stmt|;
name|itemlst
index|[
literal|2
index|]
operator|.
name|end
operator|=
name|CHP$_END
expr_stmt|;
name|stat
operator|=
name|SYS$CHECK_ACCESS
argument_list|(
operator|&
name|ACL$C_FILE
argument_list|,
operator|&
name|path_desc
argument_list|,
operator|&
name|user_desc
argument_list|,
name|itemlst
argument_list|)
expr_stmt|;
return|return
name|stat
operator|==
name|SS$_NORMAL
condition|?
literal|0
else|:
operator|-
literal|1
return|;
block|}
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* not VMS4_4 */
end_comment

begin_include
include|#
directive|include
file|<prvdef.h>
end_include

begin_define
define|#
directive|define
name|ACE$M_WRITE
value|2
end_define

begin_define
define|#
directive|define
name|ACE$C_KEYID
value|1
end_define

begin_decl_stmt
specifier|static
name|unsigned
name|short
name|memid
decl_stmt|,
name|grpid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|uic
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Called from init_sys_modes, so it happens not very often    but at least each time Emacs is loaded.  */
end_comment

begin_macro
name|sys_access_reinit
argument_list|()
end_macro

begin_block
block|{
name|uic
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_function
name|int
name|sys_access
parameter_list|(
name|filename
parameter_list|,
name|type
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
name|int
name|type
decl_stmt|;
block|{
name|struct
name|FAB
name|fab
decl_stmt|;
name|struct
name|XABPRO
name|xab
decl_stmt|;
name|int
name|status
decl_stmt|,
name|prvmask
index|[
literal|2
index|]
decl_stmt|,
name|size
decl_stmt|,
name|i
decl_stmt|,
name|typecode
decl_stmt|,
name|acl_controlled
decl_stmt|;
name|unsigned
name|int
modifier|*
name|aclptr
decl_stmt|,
modifier|*
name|aclend
decl_stmt|,
name|aclbuf
index|[
literal|60
index|]
decl_stmt|;
comment|/* Get UIC and GRP values for protection checking.  */
if|if
condition|(
name|uic
operator|==
literal|0
condition|)
block|{
name|status
operator|=
name|LIB$GETJPI
argument_list|(
operator|&
name|JPI$_UIC
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|uic
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|status
operator|&
literal|1
operator|)
condition|)
return|return
operator|-
literal|1
return|;
name|memid
operator|=
name|uic
operator|&
literal|0xFFFF
expr_stmt|;
name|grpid
operator|=
name|uic
operator|>>
literal|16
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|!=
literal|2
condition|)
comment|/* not checking write access */
return|return
name|access
argument_list|(
name|filename
argument_list|,
name|type
argument_list|)
return|;
comment|/* Check write protection. */
define|#
directive|define
name|CHECKPRIV
parameter_list|(
name|bit
parameter_list|)
value|(prvmask[bit / 32]& (1<< (bit % 32)))
define|#
directive|define
name|WRITEABLE
parameter_list|(
name|field
parameter_list|)
value|(! ((xab.xab$w_pro>> field)& XAB$M_NOWRITE))
comment|/* Find privilege bits */
name|status
operator|=
name|sys$setprv
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|prvmask
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|status
operator|&
literal|1
operator|)
condition|)
name|error
argument_list|(
literal|"Unable to find privileges: %s"
argument_list|,
name|vmserrstr
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|CHECKPRIV
argument_list|(
name|PRV$V_BYPASS
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* BYPASS enabled */
name|fab
operator|=
name|cc$rms_fab
expr_stmt|;
name|fab
operator|.
name|fab$b_fac
operator|=
name|FAB$M_GET
expr_stmt|;
name|fab
operator|.
name|fab$l_fna
operator|=
name|filename
expr_stmt|;
name|fab
operator|.
name|fab$b_fns
operator|=
name|strlen
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|fab
operator|.
name|fab$l_xab
operator|=
operator|&
name|xab
expr_stmt|;
name|xab
operator|=
name|cc$rms_xabpro
expr_stmt|;
name|xab
operator|.
name|xab$l_aclbuf
operator|=
name|aclbuf
expr_stmt|;
name|xab
operator|.
name|xab$w_aclsiz
operator|=
sizeof|sizeof
argument_list|(
name|aclbuf
argument_list|)
expr_stmt|;
name|status
operator|=
name|sys$open
argument_list|(
operator|&
name|fab
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|status
operator|&
literal|1
operator|)
condition|)
return|return
operator|-
literal|1
return|;
name|sys$close
argument_list|(
operator|&
name|fab
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Check system access */
if|if
condition|(
name|CHECKPRIV
argument_list|(
name|PRV$V_SYSPRV
argument_list|)
operator|&&
name|WRITEABLE
argument_list|(
name|XAB$V_SYS
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Check ACL entries, if any */
name|acl_controlled
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|xab
operator|.
name|xab$w_acllen
operator|>
literal|0
condition|)
block|{
name|aclptr
operator|=
name|aclbuf
expr_stmt|;
name|aclend
operator|=
operator|&
name|aclbuf
index|[
name|xab
operator|.
name|xab$w_acllen
operator|/
literal|4
index|]
expr_stmt|;
while|while
condition|(
operator|*
name|aclptr
operator|&&
name|aclptr
operator|<
name|aclend
condition|)
block|{
name|size
operator|=
operator|(
operator|*
name|aclptr
operator|&
literal|0xff
operator|)
operator|/
literal|4
expr_stmt|;
name|typecode
operator|=
operator|(
operator|*
name|aclptr
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
name|typecode
operator|==
name|ACE$C_KEYID
condition|)
for|for
control|(
name|i
operator|=
name|size
operator|-
literal|1
init|;
name|i
operator|>
literal|1
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|aclptr
index|[
name|i
index|]
operator|==
name|uic
condition|)
block|{
name|acl_controlled
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|aclptr
index|[
literal|1
index|]
operator|&
name|ACE$M_WRITE
condition|)
return|return
literal|0
return|;
comment|/* Write access through ACL */
block|}
name|aclptr
operator|=
operator|&
name|aclptr
index|[
name|size
index|]
expr_stmt|;
block|}
if|if
condition|(
name|acl_controlled
condition|)
comment|/* ACL specified, prohibits write access */
return|return
operator|-
literal|1
return|;
block|}
comment|/* No ACL entries specified, check normal protection */
if|if
condition|(
name|WRITEABLE
argument_list|(
name|XAB$V_WLD
argument_list|)
condition|)
comment|/* World writeable */
return|return
literal|0
return|;
if|if
condition|(
name|WRITEABLE
argument_list|(
name|XAB$V_GRP
argument_list|)
operator|&&
call|(
name|unsigned
name|short
call|)
argument_list|(
name|xab
operator|.
name|xab$l_uic
operator|>>
literal|16
argument_list|)
operator|==
name|grpid
condition|)
return|return
literal|0
return|;
comment|/* Group writeable */
if|if
condition|(
name|WRITEABLE
argument_list|(
name|XAB$V_OWN
argument_list|)
operator|&&
operator|(
name|xab
operator|.
name|xab$l_uic
operator|&
literal|0xFFFF
operator|)
operator|==
name|memid
condition|)
return|return
literal|0
return|;
comment|/* Owner writeable */
return|return
operator|-
literal|1
return|;
comment|/* Not writeable */
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not VMS4_4 */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* access */
end_comment

begin_decl_stmt
specifier|static
name|char
name|vtbuf
index|[
name|NAM$C_MAXRSS
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* translate a vms file spec to a unix path */
end_comment

begin_function
name|char
modifier|*
name|sys_translate_vms
parameter_list|(
name|vfile
parameter_list|)
name|char
modifier|*
name|vfile
decl_stmt|;
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|targ
decl_stmt|;
if|if
condition|(
operator|!
name|vfile
condition|)
return|return
literal|0
return|;
name|targ
operator|=
name|vtbuf
expr_stmt|;
comment|/* leading device or logical name is a root directory */
if|if
condition|(
name|p
operator|=
name|strchr
argument_list|(
name|vfile
argument_list|,
literal|':'
argument_list|)
condition|)
block|{
operator|*
name|targ
operator|++
operator|=
literal|'/'
expr_stmt|;
while|while
condition|(
name|vfile
operator|<
name|p
condition|)
operator|*
name|targ
operator|++
operator|=
operator|*
name|vfile
operator|++
expr_stmt|;
name|vfile
operator|++
expr_stmt|;
operator|*
name|targ
operator|++
operator|=
literal|'/'
expr_stmt|;
block|}
name|p
operator|=
name|vfile
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'['
operator|||
operator|*
name|p
operator|==
literal|'<'
condition|)
block|{
while|while
condition|(
operator|*
operator|++
name|vfile
operator|!=
operator|*
name|p
operator|+
literal|2
condition|)
switch|switch
condition|(
operator|*
name|vfile
condition|)
block|{
case|case
literal|'.'
case|:
if|if
condition|(
name|vfile
index|[
operator|-
literal|1
index|]
operator|==
operator|*
name|p
condition|)
operator|*
name|targ
operator|++
operator|=
literal|'.'
expr_stmt|;
operator|*
name|targ
operator|++
operator|=
literal|'/'
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
operator|*
name|targ
operator|++
operator|=
literal|'.'
expr_stmt|;
operator|*
name|targ
operator|++
operator|=
literal|'.'
expr_stmt|;
break|break;
default|default:
operator|*
name|targ
operator|++
operator|=
operator|*
name|vfile
expr_stmt|;
break|break;
block|}
name|vfile
operator|++
expr_stmt|;
operator|*
name|targ
operator|++
operator|=
literal|'/'
expr_stmt|;
block|}
while|while
condition|(
operator|*
name|vfile
condition|)
operator|*
name|targ
operator|++
operator|=
operator|*
name|vfile
operator|++
expr_stmt|;
return|return
name|vtbuf
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|char
name|utbuf
index|[
name|NAM$C_MAXRSS
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* translate a unix path to a VMS file spec */
end_comment

begin_function
name|char
modifier|*
name|sys_translate_unix
parameter_list|(
name|ufile
parameter_list|)
name|char
modifier|*
name|ufile
decl_stmt|;
block|{
name|int
name|slash_seen
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|targ
decl_stmt|;
if|if
condition|(
operator|!
name|ufile
condition|)
return|return
literal|0
return|;
name|targ
operator|=
name|utbuf
expr_stmt|;
if|if
condition|(
operator|*
name|ufile
operator|==
literal|'/'
condition|)
block|{
name|ufile
operator|++
expr_stmt|;
block|}
while|while
condition|(
operator|*
name|ufile
condition|)
block|{
switch|switch
condition|(
operator|*
name|ufile
condition|)
block|{
case|case
literal|'/'
case|:
if|if
condition|(
name|slash_seen
condition|)
if|if
condition|(
name|index
argument_list|(
operator|&
name|ufile
index|[
literal|1
index|]
argument_list|,
literal|'/'
argument_list|)
condition|)
operator|*
name|targ
operator|++
operator|=
literal|'.'
expr_stmt|;
else|else
operator|*
name|targ
operator|++
operator|=
literal|']'
expr_stmt|;
else|else
block|{
operator|*
name|targ
operator|++
operator|=
literal|':'
expr_stmt|;
if|if
condition|(
name|index
argument_list|(
operator|&
name|ufile
index|[
literal|1
index|]
argument_list|,
literal|'/'
argument_list|)
condition|)
operator|*
name|targ
operator|++
operator|=
literal|'['
expr_stmt|;
name|slash_seen
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
literal|'.'
case|:
if|if
condition|(
name|strncmp
argument_list|(
name|ufile
argument_list|,
literal|"./"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|slash_seen
condition|)
block|{
operator|*
name|targ
operator|++
operator|=
literal|'['
expr_stmt|;
name|slash_seen
operator|=
literal|1
expr_stmt|;
block|}
name|ufile
operator|++
expr_stmt|;
comment|/* skip the dot */
if|if
condition|(
name|index
argument_list|(
operator|&
name|ufile
index|[
literal|1
index|]
argument_list|,
literal|'/'
argument_list|)
condition|)
operator|*
name|targ
operator|++
operator|=
literal|'.'
expr_stmt|;
else|else
operator|*
name|targ
operator|++
operator|=
literal|']'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|ufile
argument_list|,
literal|"../"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|slash_seen
condition|)
block|{
operator|*
name|targ
operator|++
operator|=
literal|'['
expr_stmt|;
name|slash_seen
operator|=
literal|1
expr_stmt|;
block|}
operator|*
name|targ
operator|++
operator|=
literal|'-'
expr_stmt|;
name|ufile
operator|+=
literal|2
expr_stmt|;
comment|/* skip the dots */
if|if
condition|(
name|index
argument_list|(
operator|&
name|ufile
index|[
literal|1
index|]
argument_list|,
literal|'/'
argument_list|)
condition|)
operator|*
name|targ
operator|++
operator|=
literal|'.'
expr_stmt|;
else|else
operator|*
name|targ
operator|++
operator|=
literal|']'
expr_stmt|;
block|}
else|else
operator|*
name|targ
operator|++
operator|=
operator|*
name|ufile
expr_stmt|;
break|break;
default|default:
operator|*
name|targ
operator|++
operator|=
operator|*
name|ufile
expr_stmt|;
break|break;
block|}
name|ufile
operator|++
expr_stmt|;
block|}
operator|*
name|targ
operator|=
literal|'\0'
expr_stmt|;
return|return
name|utbuf
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|getwd
parameter_list|(
name|pathname
parameter_list|)
name|char
modifier|*
name|pathname
decl_stmt|;
block|{
name|char
modifier|*
name|ptr
decl_stmt|;
name|strcpy
argument_list|(
name|pathname
argument_list|,
name|egetenv
argument_list|(
literal|"PATH"
argument_list|)
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|pathname
expr_stmt|;
while|while
condition|(
operator|*
name|ptr
condition|)
block|{
if|if
condition|(
literal|'a'
operator|<=
operator|*
name|ptr
operator|&&
operator|*
name|ptr
operator|<=
literal|'z'
condition|)
operator|*
name|ptr
operator|-=
literal|040
expr_stmt|;
name|ptr
operator|++
expr_stmt|;
block|}
return|return
name|pathname
return|;
block|}
end_function

begin_macro
name|getppid
argument_list|()
end_macro

begin_block
block|{
name|long
name|item_code
init|=
name|JPI$_OWNER
decl_stmt|;
name|unsigned
name|long
name|parent_id
decl_stmt|;
name|int
name|status
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|status
operator|=
name|LIB$GETJPI
argument_list|(
operator|&
name|item_code
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|parent_id
argument_list|)
operator|)
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
block|{
name|errno
operator|=
name|EVMSERR
expr_stmt|;
name|vaxc$errno
operator|=
name|status
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
name|parent_id
return|;
block|}
end_block

begin_undef
undef|#
directive|undef
name|getuid
end_undef

begin_function
name|unsigned
name|sys_getuid
parameter_list|()
block|{
return|return
operator|(
name|getgid
argument_list|()
operator|<<
literal|16
operator|)
operator||
name|getuid
argument_list|()
return|;
block|}
end_function

begin_function
name|int
name|sys_read
parameter_list|(
name|fildes
parameter_list|,
name|buf
parameter_list|,
name|nbyte
parameter_list|)
name|int
name|fildes
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|unsigned
name|int
name|nbyte
decl_stmt|;
block|{
return|return
name|read
argument_list|(
name|fildes
argument_list|,
name|buf
argument_list|,
operator|(
name|nbyte
operator|<
name|MAXIOSIZE
condition|?
name|nbyte
else|:
name|MAXIOSIZE
operator|)
argument_list|)
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|int sys_write (fildes, buf, nbyte)      int fildes;      char *buf;      unsigned int nbyte; {   register int nwrote, rtnval = 0;    while (nbyte> MAXIOSIZE&& (nwrote = write (fildes, buf, MAXIOSIZE))> 0) {     nbyte -= nwrote;     buf += nwrote;     rtnval += nwrote;   }   if (nwrote< 0)     return rtnval ? rtnval : -1;   if ((nwrote = write (fildes, buf, nbyte))< 0)     return rtnval ? rtnval : -1;   return (rtnval + nwrote); }
endif|#
directive|endif
end_endif

begin_comment
comment|/* 0 */
end_comment

begin_comment
comment|/*  *	VAX/VMS VAX C RTL really loses. It insists that records  *      end with a newline (carriage return) character, and if they  *	don't it adds one (nice of it isn't it!)  *  *	Thus we do this stupidity below.  */
end_comment

begin_function
name|int
name|sys_write
parameter_list|(
name|fildes
parameter_list|,
name|buf
parameter_list|,
name|nbytes
parameter_list|)
name|int
name|fildes
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|unsigned
name|int
name|nbytes
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|char
modifier|*
name|e
decl_stmt|;
name|int
name|retval
decl_stmt|,
name|sum
decl_stmt|;
name|p
operator|=
name|buf
expr_stmt|;
name|sum
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|nbytes
operator|>
literal|0
condition|)
block|{
name|e
operator|=
name|p
operator|+
name|min
argument_list|(
name|MAXIOSIZE
argument_list|,
name|nbytes
argument_list|)
operator|-
literal|1
expr_stmt|;
while|while
condition|(
operator|*
name|e
operator|!=
literal|'\n'
operator|&&
name|e
operator|>
name|p
condition|)
name|e
operator|--
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|e
condition|)
comment|/* Ok.. so here we add a newline... sigh. */
name|e
operator|=
name|p
operator|+
name|min
argument_list|(
name|MAXIOSIZE
argument_list|,
name|nbytes
argument_list|)
operator|-
literal|1
expr_stmt|;
name|retval
operator|=
name|write
argument_list|(
name|fildes
argument_list|,
name|p
argument_list|,
name|e
operator|-
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
name|e
operator|-
name|p
operator|+
literal|1
condition|)
return|return
operator|-
literal|1
return|;
name|p
operator|=
name|e
operator|+
literal|1
expr_stmt|;
name|sum
operator|=
name|sum
operator|+
name|retval
expr_stmt|;
name|nbytes
operator|-=
name|retval
expr_stmt|;
block|}
return|return
name|sum
return|;
block|}
end_function

begin_comment
comment|/* Create file NEW copying its attributes from file OLD.  If    OLD is 0 or does not exist, create based on the value of    vms_stmlf_recfm. */
end_comment

begin_function
name|int
name|creat_copy_attrs
parameter_list|(
name|old
parameter_list|,
name|new
parameter_list|)
name|char
modifier|*
name|old
decl_stmt|,
decl|*
name|new
decl_stmt|;
end_function

begin_block
block|{
name|struct
name|FAB
name|fab
init|=
name|cc$rms_fab
decl_stmt|;
name|struct
name|XABPRO
name|xabpro
decl_stmt|;
name|char
name|aclbuf
index|[
literal|256
index|]
decl_stmt|;
comment|/* Choice of size is arbitrary.  See below. */
specifier|extern
name|int
name|vms_stmlf_recfm
decl_stmt|;
if|if
condition|(
name|old
condition|)
block|{
name|fab
operator|.
name|fab$b_fac
operator|=
name|FAB$M_GET
expr_stmt|;
name|fab
operator|.
name|fab$l_fna
operator|=
name|old
expr_stmt|;
name|fab
operator|.
name|fab$b_fns
operator|=
name|strlen
argument_list|(
name|old
argument_list|)
expr_stmt|;
name|fab
operator|.
name|fab$l_xab
operator|=
operator|&
name|xabpro
expr_stmt|;
name|xabpro
operator|=
name|cc$rms_xabpro
expr_stmt|;
name|xabpro
operator|.
name|xab$l_aclbuf
operator|=
name|aclbuf
expr_stmt|;
name|xabpro
operator|.
name|xab$w_aclsiz
operator|=
sizeof|sizeof
name|aclbuf
expr_stmt|;
comment|/* Call $OPEN to fill in the fab& xabpro fields. */
if|if
condition|(
name|sys$open
argument_list|(
operator|&
name|fab
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|&
literal|1
condition|)
block|{
name|sys$close
argument_list|(
operator|&
name|fab
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fab
operator|.
name|fab$l_alq
operator|=
literal|0
expr_stmt|;
comment|/* zero the allocation quantity */
if|if
condition|(
name|xabpro
operator|.
name|xab$w_acllen
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|xabpro
operator|.
name|xab$w_acllen
operator|>
sizeof|sizeof
name|aclbuf
condition|)
comment|/* If the acl buffer was too short, redo open with longer one. 		   Wouldn't need to do this if there were some system imposed 		   limit on the size of an ACL, but I can't find any such. */
block|{
name|xabpro
operator|.
name|xab$l_aclbuf
operator|=
name|alloca
argument_list|(
name|xabpro
operator|.
name|xab$w_acllen
argument_list|)
expr_stmt|;
name|xabpro
operator|.
name|xab$w_aclsiz
operator|=
name|xabpro
operator|.
name|xab$w_acllen
expr_stmt|;
if|if
condition|(
name|sys$open
argument_list|(
operator|&
name|fab
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|&
literal|1
condition|)
name|sys$close
argument_list|(
operator|&
name|fab
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|old
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
name|xabpro
operator|.
name|xab$l_aclbuf
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|old
operator|=
literal|0
expr_stmt|;
block|}
name|fab
operator|.
name|fab$l_fna
operator|=
name|new
expr_stmt|;
name|fab
operator|.
name|fab$b_fns
operator|=
name|strlen
argument_list|(
name|new
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|old
condition|)
block|{
name|fab
operator|.
name|fab$l_xab
operator|=
literal|0
expr_stmt|;
name|fab
operator|.
name|fab$b_rfm
operator|=
name|vms_stmlf_recfm
condition|?
name|FAB$C_STMLF
else|:
name|FAB$C_VAR
expr_stmt|;
name|fab
operator|.
name|fab$b_rat
operator|=
name|FAB$M_CR
expr_stmt|;
block|}
comment|/* Create the new file with either default attrs or attrs copied      from old file. */
if|if
condition|(
operator|!
operator|(
name|SYS$CREATE
argument_list|(
operator|&
name|fab
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|&
literal|1
operator|)
condition|)
return|return
operator|-
literal|1
return|;
name|sys$close
argument_list|(
operator|&
name|fab
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* As this is a "replacement" for creat, return a file descriptor      opened for writing. */
return|return
name|open
argument_list|(
name|new
argument_list|,
name|O_WRONLY
argument_list|)
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|creat
end_ifdef

begin_undef
undef|#
directive|undef
name|creat
end_undef

begin_include
include|#
directive|include
file|<varargs.h>
end_include

begin_macro
name|sys_creat
argument_list|(
argument|va_alist
argument_list|)
end_macro

begin_macro
name|va_dcl
end_macro

begin_block
block|{
name|va_list
name|list_incrementor
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|mode
decl_stmt|;
name|int
name|rfd
decl_stmt|;
comment|/* related file descriptor */
name|int
name|fd
decl_stmt|;
comment|/* Our new file descriptor */
name|int
name|count
decl_stmt|;
name|struct
name|stat
name|st_buf
decl_stmt|;
name|char
name|rfm
index|[
literal|12
index|]
decl_stmt|;
name|char
name|rat
index|[
literal|15
index|]
decl_stmt|;
name|char
name|mrs
index|[
literal|13
index|]
decl_stmt|;
name|char
name|fsz
index|[
literal|13
index|]
decl_stmt|;
specifier|extern
name|int
name|vms_stmlf_recfm
decl_stmt|;
name|va_count
argument_list|(
name|count
argument_list|)
expr_stmt|;
name|va_start
argument_list|(
name|list_incrementor
argument_list|)
expr_stmt|;
name|name
operator|=
name|va_arg
argument_list|(
name|list_incrementor
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
name|mode
operator|=
name|va_arg
argument_list|(
name|list_incrementor
argument_list|,
name|int
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|>
literal|2
condition|)
name|rfd
operator|=
name|va_arg
argument_list|(
name|list_incrementor
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|list_incrementor
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|>
literal|2
condition|)
block|{
comment|/* Use information from the related file descriptor to set record 	 format of the newly created file. */
name|fstat
argument_list|(
name|rfd
argument_list|,
operator|&
name|st_buf
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|st_buf
operator|.
name|st_fab_rfm
condition|)
block|{
case|case
name|FAB$C_FIX
case|:
name|strcpy
argument_list|(
name|rfm
argument_list|,
literal|"rfm = fix"
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|mrs
argument_list|,
literal|"mrs = %d"
argument_list|,
name|st_buf
operator|.
name|st_fab_mrs
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|rat
argument_list|,
literal|"rat = "
argument_list|)
expr_stmt|;
if|if
condition|(
name|st_buf
operator|.
name|st_fab_rat
operator|&
name|FAB$M_CR
condition|)
name|strcat
argument_list|(
name|rat
argument_list|,
literal|"cr"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|st_buf
operator|.
name|st_fab_rat
operator|&
name|FAB$M_FTN
condition|)
name|strcat
argument_list|(
name|rat
argument_list|,
literal|"ftn"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|st_buf
operator|.
name|st_fab_rat
operator|&
name|FAB$M_PRN
condition|)
name|strcat
argument_list|(
name|rat
argument_list|,
literal|"prn"
argument_list|)
expr_stmt|;
if|if
condition|(
name|st_buf
operator|.
name|st_fab_rat
operator|&
name|FAB$M_BLK
condition|)
if|if
condition|(
name|st_buf
operator|.
name|st_fab_rat
operator|&
operator|(
name|FAB$M_CR
operator||
name|FAB$M_FTN
operator||
name|FAB$M_PRN
operator|)
condition|)
name|strcat
argument_list|(
name|rat
argument_list|,
literal|", blk"
argument_list|)
expr_stmt|;
else|else
name|strcat
argument_list|(
name|rat
argument_list|,
literal|"blk"
argument_list|)
expr_stmt|;
return|return
name|creat
argument_list|(
name|name
argument_list|,
literal|0
argument_list|,
name|rfm
argument_list|,
name|rat
argument_list|,
name|mrs
argument_list|)
return|;
case|case
name|FAB$C_VFC
case|:
name|strcpy
argument_list|(
name|rfm
argument_list|,
literal|"rfm = vfc"
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|fsz
argument_list|,
literal|"fsz = %d"
argument_list|,
name|st_buf
operator|.
name|st_fab_fsz
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|rat
argument_list|,
literal|"rat = "
argument_list|)
expr_stmt|;
if|if
condition|(
name|st_buf
operator|.
name|st_fab_rat
operator|&
name|FAB$M_CR
condition|)
name|strcat
argument_list|(
name|rat
argument_list|,
literal|"cr"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|st_buf
operator|.
name|st_fab_rat
operator|&
name|FAB$M_FTN
condition|)
name|strcat
argument_list|(
name|rat
argument_list|,
literal|"ftn"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|st_buf
operator|.
name|st_fab_rat
operator|&
name|FAB$M_PRN
condition|)
name|strcat
argument_list|(
name|rat
argument_list|,
literal|"prn"
argument_list|)
expr_stmt|;
if|if
condition|(
name|st_buf
operator|.
name|st_fab_rat
operator|&
name|FAB$M_BLK
condition|)
if|if
condition|(
name|st_buf
operator|.
name|st_fab_rat
operator|&
operator|(
name|FAB$M_CR
operator||
name|FAB$M_FTN
operator||
name|FAB$M_PRN
operator|)
condition|)
name|strcat
argument_list|(
name|rat
argument_list|,
literal|", blk"
argument_list|)
expr_stmt|;
else|else
name|strcat
argument_list|(
name|rat
argument_list|,
literal|"blk"
argument_list|)
expr_stmt|;
return|return
name|creat
argument_list|(
name|name
argument_list|,
literal|0
argument_list|,
name|rfm
argument_list|,
name|rat
argument_list|,
name|fsz
argument_list|)
return|;
case|case
name|FAB$C_STM
case|:
name|strcpy
argument_list|(
name|rfm
argument_list|,
literal|"rfm = stm"
argument_list|)
expr_stmt|;
break|break;
case|case
name|FAB$C_STMCR
case|:
name|strcpy
argument_list|(
name|rfm
argument_list|,
literal|"rfm = stmcr"
argument_list|)
expr_stmt|;
break|break;
case|case
name|FAB$C_STMLF
case|:
name|strcpy
argument_list|(
name|rfm
argument_list|,
literal|"rfm = stmlf"
argument_list|)
expr_stmt|;
break|break;
case|case
name|FAB$C_UDF
case|:
name|strcpy
argument_list|(
name|rfm
argument_list|,
literal|"rfm = udf"
argument_list|)
expr_stmt|;
break|break;
case|case
name|FAB$C_VAR
case|:
name|strcpy
argument_list|(
name|rfm
argument_list|,
literal|"rfm = var"
argument_list|)
expr_stmt|;
break|break;
block|}
name|strcpy
argument_list|(
name|rat
argument_list|,
literal|"rat = "
argument_list|)
expr_stmt|;
if|if
condition|(
name|st_buf
operator|.
name|st_fab_rat
operator|&
name|FAB$M_CR
condition|)
name|strcat
argument_list|(
name|rat
argument_list|,
literal|"cr"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|st_buf
operator|.
name|st_fab_rat
operator|&
name|FAB$M_FTN
condition|)
name|strcat
argument_list|(
name|rat
argument_list|,
literal|"ftn"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|st_buf
operator|.
name|st_fab_rat
operator|&
name|FAB$M_PRN
condition|)
name|strcat
argument_list|(
name|rat
argument_list|,
literal|"prn"
argument_list|)
expr_stmt|;
if|if
condition|(
name|st_buf
operator|.
name|st_fab_rat
operator|&
name|FAB$M_BLK
condition|)
if|if
condition|(
name|st_buf
operator|.
name|st_fab_rat
operator|&
operator|(
name|FAB$M_CR
operator||
name|FAB$M_FTN
operator||
name|FAB$M_PRN
operator|)
condition|)
name|strcat
argument_list|(
name|rat
argument_list|,
literal|", blk"
argument_list|)
expr_stmt|;
else|else
name|strcat
argument_list|(
name|rat
argument_list|,
literal|"blk"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|strcpy
argument_list|(
name|rfm
argument_list|,
name|vms_stmlf_recfm
condition|?
literal|"rfm = stmlf"
else|:
literal|"rfm=var"
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|rat
argument_list|,
literal|"rat=cr"
argument_list|)
expr_stmt|;
block|}
comment|/* Until the VAX C RTL fixes the many bugs with modes, always use      mode 0 to get the user's default protection. */
name|fd
operator|=
name|creat
argument_list|(
name|name
argument_list|,
literal|0
argument_list|,
name|rfm
argument_list|,
name|rat
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
operator|&&
name|errno
operator|==
name|EEXIST
condition|)
block|{
if|if
condition|(
name|unlink
argument_list|(
name|name
argument_list|)
operator|<
literal|0
condition|)
name|report_file_error
argument_list|(
literal|"delete"
argument_list|,
name|build_string
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|fd
operator|=
name|creat
argument_list|(
name|name
argument_list|,
literal|0
argument_list|,
name|rfm
argument_list|,
name|rat
argument_list|)
expr_stmt|;
block|}
return|return
name|fd
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* creat */
end_comment

begin_comment
comment|/* fwrite to stdout is S L O W.  Speed it up by using fputc...*/
end_comment

begin_expr_stmt
name|sys_fwrite
argument_list|(
name|ptr
argument_list|,
name|size
argument_list|,
name|num
argument_list|,
name|fp
argument_list|)
specifier|register
name|char
operator|*
name|ptr
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|FILE
modifier|*
name|fp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|tot
init|=
name|num
operator|*
name|size
decl_stmt|;
while|while
condition|(
name|tot
operator|--
condition|)
name|fputc
argument_list|(
operator|*
name|ptr
operator|++
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * The VMS C library routine creat() actually creates a new version of an  * existing file rather than truncating the old version.  There are times  * when this is not the desired behavior, for instance, when writing an  * auto save file (you only want one version), or when you don't have  * write permission in the directory containing the file (but the file  * itself is writable).  Hence this routine, which is equivalent to   * "close (creat (fn, 0));" on Unix if fn already exists.  */
end_comment

begin_function
name|int
name|vms_truncate
parameter_list|(
name|fn
parameter_list|)
name|char
modifier|*
name|fn
decl_stmt|;
block|{
name|struct
name|FAB
name|xfab
init|=
name|cc$rms_fab
decl_stmt|;
name|struct
name|RAB
name|xrab
init|=
name|cc$rms_rab
decl_stmt|;
name|int
name|status
decl_stmt|;
name|xfab
operator|.
name|fab$l_fop
operator|=
name|FAB$M_TEF
expr_stmt|;
comment|/* free allocated but unused blocks on close */
name|xfab
operator|.
name|fab$b_fac
operator|=
name|FAB$M_TRN
operator||
name|FAB$M_GET
expr_stmt|;
comment|/* allow truncate and get access */
name|xfab
operator|.
name|fab$b_shr
operator|=
name|FAB$M_NIL
expr_stmt|;
comment|/* allow no sharing - file must be locked */
name|xfab
operator|.
name|fab$l_fna
operator|=
name|fn
expr_stmt|;
name|xfab
operator|.
name|fab$b_fns
operator|=
name|strlen
argument_list|(
name|fn
argument_list|)
expr_stmt|;
name|xfab
operator|.
name|fab$l_dna
operator|=
literal|";0"
expr_stmt|;
comment|/* default to latest version of the file */
name|xfab
operator|.
name|fab$b_dns
operator|=
literal|2
expr_stmt|;
name|xrab
operator|.
name|rab$l_fab
operator|=
operator|&
name|xfab
expr_stmt|;
comment|/* This gibberish opens the file, positions to the first record, and      deletes all records from there until the end of file. */
if|if
condition|(
operator|(
name|sys$open
argument_list|(
operator|&
name|xfab
argument_list|)
operator|&
literal|01
operator|)
operator|==
literal|01
condition|)
block|{
if|if
condition|(
operator|(
name|sys$connect
argument_list|(
operator|&
name|xrab
argument_list|)
operator|&
literal|01
operator|)
operator|==
literal|01
operator|&&
operator|(
name|sys$find
argument_list|(
operator|&
name|xrab
argument_list|)
operator|&
literal|01
operator|)
operator|==
literal|01
operator|&&
operator|(
name|sys$truncate
argument_list|(
operator|&
name|xrab
argument_list|)
operator|&
literal|01
operator|)
operator|==
literal|01
condition|)
name|status
operator|=
literal|0
expr_stmt|;
else|else
name|status
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
name|status
operator|=
operator|-
literal|1
expr_stmt|;
name|sys$close
argument_list|(
operator|&
name|xfab
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/* Define this symbol to actually read SYSUAF.DAT.  This requires either    SYSPRV or a readable SYSUAF.DAT. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|READ_SYSUAF
end_ifdef

begin_comment
comment|/*  * getuaf.c  *  * Routine to read the VMS User Authorization File and return  * a specific user's record.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|UAF
name|retuaf
decl_stmt|;
end_decl_stmt

begin_function
name|struct
name|UAF
modifier|*
name|get_uaf_name
parameter_list|(
name|uname
parameter_list|)
name|char
modifier|*
name|uname
decl_stmt|;
block|{
specifier|register
name|status
expr_stmt|;
name|struct
name|FAB
name|uaf_fab
decl_stmt|;
name|struct
name|RAB
name|uaf_rab
decl_stmt|;
name|uaf_fab
operator|=
name|cc$rms_fab
expr_stmt|;
name|uaf_rab
operator|=
name|cc$rms_rab
expr_stmt|;
comment|/* initialize fab fields */
name|uaf_fab
operator|.
name|fab$l_fna
operator|=
literal|"SYS$SYSTEM:SYSUAF.DAT"
expr_stmt|;
name|uaf_fab
operator|.
name|fab$b_fns
operator|=
literal|21
expr_stmt|;
name|uaf_fab
operator|.
name|fab$b_fac
operator|=
name|FAB$M_GET
expr_stmt|;
name|uaf_fab
operator|.
name|fab$b_org
operator|=
name|FAB$C_IDX
expr_stmt|;
name|uaf_fab
operator|.
name|fab$b_shr
operator|=
name|FAB$M_GET
operator||
name|FAB$M_PUT
operator||
name|FAB$M_UPD
operator||
name|FAB$M_DEL
expr_stmt|;
comment|/* initialize rab fields */
name|uaf_rab
operator|.
name|rab$l_fab
operator|=
operator|&
name|uaf_fab
expr_stmt|;
comment|/* open the User Authorization File */
name|status
operator|=
name|sys$open
argument_list|(
operator|&
name|uaf_fab
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|status
operator|&
literal|1
operator|)
condition|)
block|{
name|errno
operator|=
name|EVMSERR
expr_stmt|;
name|vaxc$errno
operator|=
name|status
expr_stmt|;
return|return
literal|0
return|;
block|}
name|status
operator|=
name|sys$connect
argument_list|(
operator|&
name|uaf_rab
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|status
operator|&
literal|1
operator|)
condition|)
block|{
name|errno
operator|=
name|EVMSERR
expr_stmt|;
name|vaxc$errno
operator|=
name|status
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* read the requested record - index is in uname */
name|uaf_rab
operator|.
name|rab$l_kbf
operator|=
name|uname
expr_stmt|;
name|uaf_rab
operator|.
name|rab$b_ksz
operator|=
name|strlen
argument_list|(
name|uname
argument_list|)
expr_stmt|;
name|uaf_rab
operator|.
name|rab$b_rac
operator|=
name|RAB$C_KEY
expr_stmt|;
name|uaf_rab
operator|.
name|rab$l_ubf
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|retuaf
expr_stmt|;
name|uaf_rab
operator|.
name|rab$w_usz
operator|=
sizeof|sizeof
name|retuaf
expr_stmt|;
name|status
operator|=
name|sys$get
argument_list|(
operator|&
name|uaf_rab
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|status
operator|&
literal|1
operator|)
condition|)
block|{
name|errno
operator|=
name|EVMSERR
expr_stmt|;
name|vaxc$errno
operator|=
name|status
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* close the User Authorization File */
name|status
operator|=
name|sys$disconnect
argument_list|(
operator|&
name|uaf_rab
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|status
operator|&
literal|1
operator|)
condition|)
block|{
name|errno
operator|=
name|EVMSERR
expr_stmt|;
name|vaxc$errno
operator|=
name|status
expr_stmt|;
return|return
literal|0
return|;
block|}
name|status
operator|=
name|sys$close
argument_list|(
operator|&
name|uaf_fab
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|status
operator|&
literal|1
operator|)
condition|)
block|{
name|errno
operator|=
name|EVMSERR
expr_stmt|;
name|vaxc$errno
operator|=
name|status
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
operator|&
name|retuaf
return|;
block|}
end_function

begin_function
name|struct
name|UAF
modifier|*
name|get_uaf_uic
parameter_list|(
name|uic
parameter_list|)
name|unsigned
name|long
name|uic
decl_stmt|;
block|{
specifier|register
name|status
expr_stmt|;
name|struct
name|FAB
name|uaf_fab
decl_stmt|;
name|struct
name|RAB
name|uaf_rab
decl_stmt|;
name|uaf_fab
operator|=
name|cc$rms_fab
expr_stmt|;
name|uaf_rab
operator|=
name|cc$rms_rab
expr_stmt|;
comment|/* initialize fab fields */
name|uaf_fab
operator|.
name|fab$l_fna
operator|=
literal|"SYS$SYSTEM:SYSUAF.DAT"
expr_stmt|;
name|uaf_fab
operator|.
name|fab$b_fns
operator|=
literal|21
expr_stmt|;
name|uaf_fab
operator|.
name|fab$b_fac
operator|=
name|FAB$M_GET
expr_stmt|;
name|uaf_fab
operator|.
name|fab$b_org
operator|=
name|FAB$C_IDX
expr_stmt|;
name|uaf_fab
operator|.
name|fab$b_shr
operator|=
name|FAB$M_GET
operator||
name|FAB$M_PUT
operator||
name|FAB$M_UPD
operator||
name|FAB$M_DEL
expr_stmt|;
comment|/* initialize rab fields */
name|uaf_rab
operator|.
name|rab$l_fab
operator|=
operator|&
name|uaf_fab
expr_stmt|;
comment|/* open the User Authorization File */
name|status
operator|=
name|sys$open
argument_list|(
operator|&
name|uaf_fab
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|status
operator|&
literal|1
operator|)
condition|)
block|{
name|errno
operator|=
name|EVMSERR
expr_stmt|;
name|vaxc$errno
operator|=
name|status
expr_stmt|;
return|return
literal|0
return|;
block|}
name|status
operator|=
name|sys$connect
argument_list|(
operator|&
name|uaf_rab
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|status
operator|&
literal|1
operator|)
condition|)
block|{
name|errno
operator|=
name|EVMSERR
expr_stmt|;
name|vaxc$errno
operator|=
name|status
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* read the requested record - index is in uic */
name|uaf_rab
operator|.
name|rab$b_krf
operator|=
literal|1
expr_stmt|;
comment|/* 1st alternate key */
name|uaf_rab
operator|.
name|rab$l_kbf
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|uic
expr_stmt|;
name|uaf_rab
operator|.
name|rab$b_ksz
operator|=
sizeof|sizeof
name|uic
expr_stmt|;
name|uaf_rab
operator|.
name|rab$b_rac
operator|=
name|RAB$C_KEY
expr_stmt|;
name|uaf_rab
operator|.
name|rab$l_ubf
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|retuaf
expr_stmt|;
name|uaf_rab
operator|.
name|rab$w_usz
operator|=
sizeof|sizeof
name|retuaf
expr_stmt|;
name|status
operator|=
name|sys$get
argument_list|(
operator|&
name|uaf_rab
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|status
operator|&
literal|1
operator|)
condition|)
block|{
name|errno
operator|=
name|EVMSERR
expr_stmt|;
name|vaxc$errno
operator|=
name|status
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* close the User Authorization File */
name|status
operator|=
name|sys$disconnect
argument_list|(
operator|&
name|uaf_rab
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|status
operator|&
literal|1
operator|)
condition|)
block|{
name|errno
operator|=
name|EVMSERR
expr_stmt|;
name|vaxc$errno
operator|=
name|status
expr_stmt|;
return|return
literal|0
return|;
block|}
name|status
operator|=
name|sys$close
argument_list|(
operator|&
name|uaf_fab
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|status
operator|&
literal|1
operator|)
condition|)
block|{
name|errno
operator|=
name|EVMSERR
expr_stmt|;
name|vaxc$errno
operator|=
name|status
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
operator|&
name|retuaf
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|passwd
name|retpw
decl_stmt|;
end_decl_stmt

begin_function
name|struct
name|passwd
modifier|*
name|cnv_uaf_pw
parameter_list|(
name|up
parameter_list|)
name|struct
name|UAF
modifier|*
name|up
decl_stmt|;
block|{
name|char
modifier|*
name|ptr
decl_stmt|;
comment|/* copy these out first because if the username is 32 chars, the next      section will overwrite the first byte of the UIC */
name|retpw
operator|.
name|pw_uid
operator|=
name|up
operator|->
name|uaf$w_mem
expr_stmt|;
name|retpw
operator|.
name|pw_gid
operator|=
name|up
operator|->
name|uaf$w_grp
expr_stmt|;
comment|/* I suppose this is not the best sytle, to possibly overwrite one      byte beyond the end of the field, but what the heck... */
name|ptr
operator|=
operator|&
name|up
operator|->
name|uaf$t_username
index|[
name|UAF$S_USERNAME
index|]
expr_stmt|;
while|while
condition|(
name|ptr
index|[
operator|-
literal|1
index|]
operator|==
literal|' '
condition|)
name|ptr
operator|--
expr_stmt|;
operator|*
name|ptr
operator|=
literal|'\0'
expr_stmt|;
name|strcpy
argument_list|(
name|retpw
operator|.
name|pw_name
argument_list|,
name|up
operator|->
name|uaf$t_username
argument_list|)
expr_stmt|;
comment|/* the rest of these are counted ascii strings */
name|strncpy
argument_list|(
name|retpw
operator|.
name|pw_gecos
argument_list|,
operator|&
name|up
operator|->
name|uaf$t_owner
index|[
literal|1
index|]
argument_list|,
name|up
operator|->
name|uaf$t_owner
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|retpw
operator|.
name|pw_gecos
index|[
name|up
operator|->
name|uaf$t_owner
index|[
literal|0
index|]
index|]
operator|=
literal|'\0'
expr_stmt|;
name|strncpy
argument_list|(
name|retpw
operator|.
name|pw_dir
argument_list|,
operator|&
name|up
operator|->
name|uaf$t_defdev
index|[
literal|1
index|]
argument_list|,
name|up
operator|->
name|uaf$t_defdev
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|retpw
operator|.
name|pw_dir
index|[
name|up
operator|->
name|uaf$t_defdev
index|[
literal|0
index|]
index|]
operator|=
literal|'\0'
expr_stmt|;
name|strncat
argument_list|(
name|retpw
operator|.
name|pw_dir
argument_list|,
operator|&
name|up
operator|->
name|uaf$t_defdir
index|[
literal|1
index|]
argument_list|,
name|up
operator|->
name|uaf$t_defdir
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|retpw
operator|.
name|pw_dir
index|[
name|up
operator|->
name|uaf$t_defdev
index|[
literal|0
index|]
operator|+
name|up
operator|->
name|uaf$t_defdir
index|[
literal|0
index|]
index|]
operator|=
literal|'\0'
expr_stmt|;
name|strncpy
argument_list|(
name|retpw
operator|.
name|pw_shell
argument_list|,
operator|&
name|up
operator|->
name|uaf$t_defcli
index|[
literal|1
index|]
argument_list|,
name|up
operator|->
name|uaf$t_defcli
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|retpw
operator|.
name|pw_shell
index|[
name|up
operator|->
name|uaf$t_defcli
index|[
literal|0
index|]
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|&
name|retpw
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* not READ_SYSUAF */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|passwd
name|retpw
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not READ_SYSUAF */
end_comment

begin_function
name|struct
name|passwd
modifier|*
name|getpwnam
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|READ_SYSUAF
name|struct
name|UAF
modifier|*
name|up
decl_stmt|;
else|#
directive|else
name|char
modifier|*
name|user
decl_stmt|;
name|char
modifier|*
name|dir
decl_stmt|;
name|char
modifier|*
name|full
decl_stmt|;
endif|#
directive|endif
comment|/* READ_SYSUAF */
name|char
modifier|*
name|ptr
init|=
name|name
decl_stmt|;
while|while
condition|(
operator|*
name|ptr
condition|)
block|{
if|if
condition|(
literal|'a'
operator|<=
operator|*
name|ptr
operator|&&
operator|*
name|ptr
operator|<=
literal|'z'
condition|)
operator|*
name|ptr
operator|-=
literal|040
expr_stmt|;
name|ptr
operator|++
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|READ_SYSUAF
if|if
condition|(
operator|!
operator|(
name|up
operator|=
name|get_uaf_name
argument_list|(
name|name
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
return|return
name|cnv_uaf_pw
argument_list|(
name|up
argument_list|)
return|;
else|#
directive|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|getenv
argument_list|(
literal|"USER"
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|retpw
operator|.
name|pw_uid
operator|=
name|getuid
argument_list|()
expr_stmt|;
name|retpw
operator|.
name|pw_gid
operator|=
name|getgid
argument_list|()
expr_stmt|;
name|strcpy
argument_list|(
name|retpw
operator|.
name|pw_name
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|full
operator|=
name|egetenv
argument_list|(
literal|"FULLNAME"
argument_list|)
condition|)
name|strcpy
argument_list|(
name|retpw
operator|.
name|pw_gecos
argument_list|,
name|full
argument_list|)
expr_stmt|;
else|else
operator|*
name|retpw
operator|.
name|pw_gecos
operator|=
literal|'\0'
expr_stmt|;
name|strcpy
argument_list|(
name|retpw
operator|.
name|pw_dir
argument_list|,
name|egetenv
argument_list|(
literal|"HOME"
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|retpw
operator|.
name|pw_shell
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|&
name|retpw
return|;
block|}
else|else
return|return
literal|0
return|;
endif|#
directive|endif
comment|/* not READ_SYSUAF */
block|}
end_function

begin_function
name|struct
name|passwd
modifier|*
name|getpwuid
parameter_list|(
name|uid
parameter_list|)
name|unsigned
name|long
name|uid
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|READ_SYSUAF
name|struct
name|UAF
modifier|*
name|up
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|up
operator|=
name|get_uaf_uic
argument_list|(
name|uid
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
return|return
name|cnv_uaf_pw
argument_list|(
name|up
argument_list|)
return|;
else|#
directive|else
if|if
condition|(
name|uid
operator|==
name|sys_getuid
argument_list|()
condition|)
return|return
name|getpwnam
argument_list|(
name|egetenv
argument_list|(
literal|"USER"
argument_list|)
argument_list|)
return|;
else|else
return|return
literal|0
return|;
endif|#
directive|endif
comment|/* not READ_SYSUAF */
block|}
end_function

begin_comment
comment|/* return total address space available to the current process.  This is    the sum of the current p0 size, p1 size and free page table entries    available. */
end_comment

begin_macro
name|vlimit
argument_list|()
end_macro

begin_block
block|{
name|int
name|item_code
decl_stmt|;
name|unsigned
name|long
name|free_pages
decl_stmt|;
name|unsigned
name|long
name|frep0va
decl_stmt|;
name|unsigned
name|long
name|frep1va
decl_stmt|;
specifier|register
name|status
expr_stmt|;
name|item_code
operator|=
name|JPI$_FREPTECNT
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|status
operator|=
name|LIB$GETJPI
argument_list|(
operator|&
name|item_code
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|free_pages
argument_list|)
operator|)
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
block|{
name|errno
operator|=
name|EVMSERR
expr_stmt|;
name|vaxc$errno
operator|=
name|status
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|free_pages
operator|*=
literal|512
expr_stmt|;
name|item_code
operator|=
name|JPI$_FREP0VA
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|status
operator|=
name|LIB$GETJPI
argument_list|(
operator|&
name|item_code
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|frep0va
argument_list|)
operator|)
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
block|{
name|errno
operator|=
name|EVMSERR
expr_stmt|;
name|vaxc$errno
operator|=
name|status
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|item_code
operator|=
name|JPI$_FREP1VA
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|status
operator|=
name|LIB$GETJPI
argument_list|(
operator|&
name|item_code
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|frep1va
argument_list|)
operator|)
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
block|{
name|errno
operator|=
name|EVMSERR
expr_stmt|;
name|vaxc$errno
operator|=
name|status
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
name|free_pages
operator|+
name|frep0va
operator|+
operator|(
literal|0x7fffffff
operator|-
name|frep1va
operator|)
return|;
block|}
end_block

begin_macro
name|define_logical_name
argument_list|(
argument|varname
argument_list|,
argument|string
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|varname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|string
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|dsc$descriptor_s
name|strdsc
init|=
block|{
name|strlen
argument_list|(
name|string
argument_list|)
block|,
name|DSC$K_DTYPE_T
block|,
name|DSC$K_CLASS_S
block|,
name|string
block|}
decl_stmt|;
name|struct
name|dsc$descriptor_s
name|envdsc
init|=
block|{
name|strlen
argument_list|(
name|varname
argument_list|)
block|,
name|DSC$K_DTYPE_T
block|,
name|DSC$K_CLASS_S
block|,
name|varname
block|}
decl_stmt|;
name|struct
name|dsc$descriptor_s
name|lnmdsc
init|=
block|{
literal|7
block|,
name|DSC$K_DTYPE_T
block|,
name|DSC$K_CLASS_S
block|,
literal|"LNM$JOB"
block|}
decl_stmt|;
return|return
name|LIB$SET_LOGICAL
argument_list|(
operator|&
name|envdsc
argument_list|,
operator|&
name|strdsc
argument_list|,
operator|&
name|lnmdsc
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_block

begin_macro
name|delete_logical_name
argument_list|(
argument|varname
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|varname
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|dsc$descriptor_s
name|envdsc
init|=
block|{
name|strlen
argument_list|(
name|varname
argument_list|)
block|,
name|DSC$K_DTYPE_T
block|,
name|DSC$K_CLASS_S
block|,
name|varname
block|}
decl_stmt|;
name|struct
name|dsc$descriptor_s
name|lnmdsc
init|=
block|{
literal|7
block|,
name|DSC$K_DTYPE_T
block|,
name|DSC$K_CLASS_S
block|,
literal|"LNM$JOB"
block|}
decl_stmt|;
return|return
name|LIB$DELETE_LOGICAL
argument_list|(
operator|&
name|envdsc
argument_list|,
operator|&
name|lnmdsc
argument_list|)
return|;
block|}
end_block

begin_macro
name|ulimit
argument_list|()
end_macro

begin_block
block|{}
end_block

begin_macro
name|setpriority
argument_list|()
end_macro

begin_block
block|{}
end_block

begin_macro
name|setpgrp
argument_list|()
end_macro

begin_block
block|{}
end_block

begin_macro
name|execvp
argument_list|()
end_macro

begin_block
block|{
name|error
argument_list|(
literal|"execvp system call not implemented"
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|int
name|rename
parameter_list|(
name|from
parameter_list|,
name|to
parameter_list|)
name|char
modifier|*
name|from
decl_stmt|,
decl|*
name|to
decl_stmt|;
end_function

begin_block
block|{
name|int
name|status
decl_stmt|;
name|struct
name|FAB
name|from_fab
init|=
name|cc$rms_fab
decl_stmt|,
name|to_fab
init|=
name|cc$rms_fab
decl_stmt|;
name|struct
name|NAM
name|from_nam
init|=
name|cc$rms_nam
decl_stmt|,
name|to_nam
init|=
name|cc$rms_nam
decl_stmt|;
name|char
name|from_esn
index|[
name|NAM$C_MAXRSS
index|]
decl_stmt|;
name|char
name|to_esn
index|[
name|NAM$C_MAXRSS
index|]
decl_stmt|;
name|from_fab
operator|.
name|fab$l_fna
operator|=
name|from
expr_stmt|;
name|from_fab
operator|.
name|fab$b_fns
operator|=
name|strlen
argument_list|(
name|from
argument_list|)
expr_stmt|;
name|from_fab
operator|.
name|fab$l_nam
operator|=
operator|&
name|from_nam
expr_stmt|;
name|from_fab
operator|.
name|fab$l_fop
operator|=
name|FAB$M_NAM
expr_stmt|;
name|from_nam
operator|.
name|nam$l_esa
operator|=
name|from_esn
expr_stmt|;
name|from_nam
operator|.
name|nam$b_ess
operator|=
sizeof|sizeof
name|from_esn
expr_stmt|;
name|to_fab
operator|.
name|fab$l_fna
operator|=
name|to
expr_stmt|;
name|to_fab
operator|.
name|fab$b_fns
operator|=
name|strlen
argument_list|(
name|to
argument_list|)
expr_stmt|;
name|to_fab
operator|.
name|fab$l_nam
operator|=
operator|&
name|to_nam
expr_stmt|;
name|to_fab
operator|.
name|fab$l_fop
operator|=
name|FAB$M_NAM
expr_stmt|;
name|to_nam
operator|.
name|nam$l_esa
operator|=
name|to_esn
expr_stmt|;
name|to_nam
operator|.
name|nam$b_ess
operator|=
sizeof|sizeof
name|to_esn
expr_stmt|;
name|status
operator|=
name|SYS$RENAME
argument_list|(
operator|&
name|from_fab
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|to_fab
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
literal|1
condition|)
return|return
literal|0
return|;
else|else
block|{
if|if
condition|(
name|status
operator|==
name|RMS$_DEV
condition|)
name|errno
operator|=
name|EXDEV
expr_stmt|;
else|else
name|errno
operator|=
name|EVMSERR
expr_stmt|;
name|vaxc$errno
operator|=
name|status
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
end_block

begin_macro
name|link
argument_list|(
argument|file
argument_list|,
argument|new
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|file
decl_stmt|,
modifier|*
name|new
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|status
expr_stmt|;
name|struct
name|FAB
name|fab
decl_stmt|;
name|struct
name|NAM
name|nam
decl_stmt|;
name|unsigned
name|short
name|fid
index|[
literal|3
index|]
decl_stmt|;
name|char
name|esa
index|[
name|NAM$C_MAXRSS
index|]
decl_stmt|;
name|fab
operator|=
name|cc$rms_fab
expr_stmt|;
name|fab
operator|.
name|fab$l_fop
operator|=
name|FAB$M_OFP
expr_stmt|;
name|fab
operator|.
name|fab$l_fna
operator|=
name|file
expr_stmt|;
name|fab
operator|.
name|fab$b_fns
operator|=
name|strlen
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|fab
operator|.
name|fab$l_nam
operator|=
operator|&
name|nam
expr_stmt|;
name|nam
operator|=
name|cc$rms_nam
expr_stmt|;
name|nam
operator|.
name|nam$l_esa
operator|=
name|esa
expr_stmt|;
name|nam
operator|.
name|nam$b_ess
operator|=
name|NAM$C_MAXRSS
expr_stmt|;
name|status
operator|=
name|SYS$PARSE
argument_list|(
operator|&
name|fab
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
block|{
name|errno
operator|=
name|EVMSERR
expr_stmt|;
name|vaxc$errno
operator|=
name|status
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|status
operator|=
name|SYS$SEARCH
argument_list|(
operator|&
name|fab
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
block|{
name|errno
operator|=
name|EVMSERR
expr_stmt|;
name|vaxc$errno
operator|=
name|status
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|fid
index|[
literal|0
index|]
operator|=
name|nam
operator|.
name|nam$w_fid
index|[
literal|0
index|]
expr_stmt|;
name|fid
index|[
literal|1
index|]
operator|=
name|nam
operator|.
name|nam$w_fid
index|[
literal|1
index|]
expr_stmt|;
name|fid
index|[
literal|2
index|]
operator|=
name|nam
operator|.
name|nam$w_fid
index|[
literal|2
index|]
expr_stmt|;
name|fab
operator|.
name|fab$l_fna
operator|=
name|new
expr_stmt|;
name|fab
operator|.
name|fab$b_fns
operator|=
name|strlen
argument_list|(
name|new
argument_list|)
expr_stmt|;
name|status
operator|=
name|SYS$PARSE
argument_list|(
operator|&
name|fab
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
block|{
name|errno
operator|=
name|EVMSERR
expr_stmt|;
name|vaxc$errno
operator|=
name|status
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|nam
operator|.
name|nam$w_fid
index|[
literal|0
index|]
operator|=
name|fid
index|[
literal|0
index|]
expr_stmt|;
name|nam
operator|.
name|nam$w_fid
index|[
literal|1
index|]
operator|=
name|fid
index|[
literal|1
index|]
expr_stmt|;
name|nam
operator|.
name|nam$w_fid
index|[
literal|2
index|]
operator|=
name|fid
index|[
literal|2
index|]
expr_stmt|;
name|nam
operator|.
name|nam$l_esa
operator|=
name|nam
operator|.
name|nam$l_name
expr_stmt|;
name|nam
operator|.
name|nam$b_esl
operator|=
name|nam
operator|.
name|nam$b_name
operator|+
name|nam
operator|.
name|nam$b_type
operator|+
name|nam
operator|.
name|nam$b_ver
expr_stmt|;
name|status
operator|=
name|SYS$ENTER
argument_list|(
operator|&
name|fab
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
block|{
name|errno
operator|=
name|EVMSERR
expr_stmt|;
name|vaxc$errno
operator|=
name|status
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_block

begin_macro
name|croak
argument_list|(
argument|badfunc
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|badfunc
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|printf
argument_list|(
literal|"%s not yet implemented\r\n"
argument_list|,
name|badfunc
argument_list|)
expr_stmt|;
name|reset_sys_modes
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|long
name|random
parameter_list|()
block|{
comment|/* Arrange to return a range centered on zero.  */
return|return
name|rand
argument_list|()
operator|-
operator|(
literal|1
operator|<<
literal|30
operator|)
return|;
block|}
end_function

begin_macro
name|srandom
argument_list|(
argument|seed
argument_list|)
end_macro

begin_block
block|{
name|srand
argument_list|(
name|seed
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* VMS */
end_comment

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|AIX
end_ifdef

begin_comment
comment|/* Called from init_sys_modes.  */
end_comment

begin_macro
name|hft_init
argument_list|()
end_macro

begin_block
block|{
comment|/* If we're not on an HFT we shouldn't do any of this.  We determine      if we are on an HFT by trying to get an HFT error code.  If this      call fails, we're not on an HFT. */
ifdef|#
directive|ifdef
name|IBMR2AIX
if|if
condition|(
name|ioctl
argument_list|(
literal|0
argument_list|,
name|HFQERROR
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
return|return;
else|#
directive|else
comment|/* not IBMR2AIX */
if|if
condition|(
name|ioctl
argument_list|(
literal|0
argument_list|,
name|HFQEIO
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
return|return;
endif|#
directive|endif
comment|/* not IBMR2AIX */
comment|/* On AIX the default hft keyboard mapping uses backspace rather than delete      as the rubout key's ASCII code.  Here this is changed.  The bug is that      there's no way to determine the old mapping, so in reset_sys_modes      we need to assume that the normal map had been present.  Of course, this      code also doesn't help if on a terminal emulator which doesn't understand      HFT VTD's. */
block|{
name|struct
name|hfbuf
name|buf
decl_stmt|;
name|struct
name|hfkeymap
name|keymap
decl_stmt|;
name|buf
operator|.
name|hf_bufp
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|keymap
expr_stmt|;
name|buf
operator|.
name|hf_buflen
operator|=
sizeof|sizeof
argument_list|(
name|keymap
argument_list|)
expr_stmt|;
name|keymap
operator|.
name|hf_nkeys
operator|=
literal|2
expr_stmt|;
name|keymap
operator|.
name|hfkey
index|[
literal|0
index|]
operator|.
name|hf_kpos
operator|=
literal|15
expr_stmt|;
name|keymap
operator|.
name|hfkey
index|[
literal|0
index|]
operator|.
name|hf_kstate
operator|=
name|HFMAPCHAR
operator||
name|HFSHFNONE
expr_stmt|;
ifdef|#
directive|ifdef
name|IBMR2AIX
name|keymap
operator|.
name|hfkey
index|[
literal|0
index|]
operator|.
name|hf_keyidh
operator|=
literal|'<'
expr_stmt|;
else|#
directive|else
comment|/* not IBMR2AIX */
name|keymap
operator|.
name|hfkey
index|[
literal|0
index|]
operator|.
name|hf_page
operator|=
literal|'<'
expr_stmt|;
endif|#
directive|endif
comment|/* not IBMR2AIX */
name|keymap
operator|.
name|hfkey
index|[
literal|0
index|]
operator|.
name|hf_char
operator|=
literal|127
expr_stmt|;
name|keymap
operator|.
name|hfkey
index|[
literal|1
index|]
operator|.
name|hf_kpos
operator|=
literal|15
expr_stmt|;
name|keymap
operator|.
name|hfkey
index|[
literal|1
index|]
operator|.
name|hf_kstate
operator|=
name|HFMAPCHAR
operator||
name|HFSHFSHFT
expr_stmt|;
ifdef|#
directive|ifdef
name|IBMR2AIX
name|keymap
operator|.
name|hfkey
index|[
literal|1
index|]
operator|.
name|hf_keyidh
operator|=
literal|'<'
expr_stmt|;
else|#
directive|else
comment|/* not IBMR2AIX */
name|keymap
operator|.
name|hfkey
index|[
literal|1
index|]
operator|.
name|hf_page
operator|=
literal|'<'
expr_stmt|;
endif|#
directive|endif
comment|/* not IBMR2AIX */
name|keymap
operator|.
name|hfkey
index|[
literal|1
index|]
operator|.
name|hf_char
operator|=
literal|127
expr_stmt|;
name|hftctl
argument_list|(
literal|0
argument_list|,
name|HFSKBD
argument_list|,
operator|&
name|buf
argument_list|)
expr_stmt|;
block|}
comment|/* The HFT system on AIX doesn't optimize for scrolling, so it's really ugly      at times. */
name|line_ins_del_ok
operator|=
name|char_ins_del_ok
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Reset the rubout key to backspace. */
end_comment

begin_macro
name|hft_reset
argument_list|()
end_macro

begin_block
block|{
name|struct
name|hfbuf
name|buf
decl_stmt|;
name|struct
name|hfkeymap
name|keymap
decl_stmt|;
ifdef|#
directive|ifdef
name|IBMR2AIX
if|if
condition|(
name|ioctl
argument_list|(
literal|0
argument_list|,
name|HFQERROR
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
return|return;
else|#
directive|else
comment|/* not IBMR2AIX */
if|if
condition|(
name|ioctl
argument_list|(
literal|0
argument_list|,
name|HFQEIO
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
return|return;
endif|#
directive|endif
comment|/* not IBMR2AIX */
name|buf
operator|.
name|hf_bufp
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|keymap
expr_stmt|;
name|buf
operator|.
name|hf_buflen
operator|=
sizeof|sizeof
argument_list|(
name|keymap
argument_list|)
expr_stmt|;
name|keymap
operator|.
name|hf_nkeys
operator|=
literal|2
expr_stmt|;
name|keymap
operator|.
name|hfkey
index|[
literal|0
index|]
operator|.
name|hf_kpos
operator|=
literal|15
expr_stmt|;
name|keymap
operator|.
name|hfkey
index|[
literal|0
index|]
operator|.
name|hf_kstate
operator|=
name|HFMAPCHAR
operator||
name|HFSHFNONE
expr_stmt|;
ifdef|#
directive|ifdef
name|IBMR2AIX
name|keymap
operator|.
name|hfkey
index|[
literal|0
index|]
operator|.
name|hf_keyidh
operator|=
literal|'<'
expr_stmt|;
else|#
directive|else
comment|/* not IBMR2AIX */
name|keymap
operator|.
name|hfkey
index|[
literal|0
index|]
operator|.
name|hf_page
operator|=
literal|'<'
expr_stmt|;
endif|#
directive|endif
comment|/* not IBMR2AIX */
name|keymap
operator|.
name|hfkey
index|[
literal|0
index|]
operator|.
name|hf_char
operator|=
literal|8
expr_stmt|;
name|keymap
operator|.
name|hfkey
index|[
literal|1
index|]
operator|.
name|hf_kpos
operator|=
literal|15
expr_stmt|;
name|keymap
operator|.
name|hfkey
index|[
literal|1
index|]
operator|.
name|hf_kstate
operator|=
name|HFMAPCHAR
operator||
name|HFSHFSHFT
expr_stmt|;
ifdef|#
directive|ifdef
name|IBMR2AIX
name|keymap
operator|.
name|hfkey
index|[
literal|1
index|]
operator|.
name|hf_keyidh
operator|=
literal|'<'
expr_stmt|;
else|#
directive|else
comment|/* not IBMR2AIX */
name|keymap
operator|.
name|hfkey
index|[
literal|1
index|]
operator|.
name|hf_page
operator|=
literal|'<'
expr_stmt|;
endif|#
directive|endif
comment|/* not IBMR2AIX */
name|keymap
operator|.
name|hfkey
index|[
literal|1
index|]
operator|.
name|hf_char
operator|=
literal|8
expr_stmt|;
name|hftctl
argument_list|(
literal|0
argument_list|,
name|HFSKBD
argument_list|,
operator|&
name|buf
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* AIX */
end_comment

end_unit

