begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Newly written part of redisplay code.    Copyright (C) 1985, 1986, 1987, 1988, 1990 Free Software Foundation, Inc.  This file is part of GNU Emacs.  GNU Emacs is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version.  GNU Emacs is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU Emacs; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_TIMEVAL
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|HPUX
end_ifdef

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_TERMIO
end_ifdef

begin_include
include|#
directive|include
file|<termio.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|TCOUTQ
end_ifdef

begin_undef
undef|#
directive|undef
name|TIOCOUTQ
end_undef

begin_define
define|#
directive|define
name|TIOCOUTQ
value|TCOUTQ
end_define

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TCOUTQ defined */
end_comment

begin_else
else|#
directive|else
end_else

begin_ifndef
ifndef|#
directive|ifndef
name|VMS
end_ifndef

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not VMS */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not HAVE_TERMIO */
end_comment

begin_comment
comment|/* Allow m- file to inhibit use of FIONREAD.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|BROKEN_FIONREAD
end_ifdef

begin_undef
undef|#
directive|undef
name|FIONREAD
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* We are unable to use interrupts if FIONREAD is not available,    so flush SIGIO so we won't try. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|FIONREAD
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|SIGIO
end_ifdef

begin_undef
undef|#
directive|undef
name|SIGIO
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_undef
undef|#
directive|undef
name|NULL
end_undef

begin_include
include|#
directive|include
file|"termchar.h"
end_include

begin_include
include|#
directive|include
file|"termopts.h"
end_include

begin_include
include|#
directive|include
file|"cm.h"
end_include

begin_include
include|#
directive|include
file|"dispextern.h"
end_include

begin_include
include|#
directive|include
file|"lisp.h"
end_include

begin_include
include|#
directive|include
file|"buffer.h"
end_include

begin_include
include|#
directive|include
file|"window.h"
end_include

begin_include
include|#
directive|include
file|"commands.h"
end_include

begin_define
define|#
directive|define
name|max
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)> (b) ? (a) : (b))
end_define

begin_define
define|#
directive|define
name|min
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)< (b) ? (a) : (b))
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|PENDING_OUTPUT_COUNT
end_ifndef

begin_comment
comment|/* Get number of chars of output now in the buffer of a stdio stream.    This ought to be built in in stdio, but it isn't.    Some s- files override this because their stdio internals differ.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__GNU_LIBRARY__
end_ifdef

begin_define
define|#
directive|define
name|PENDING_OUTPUT_COUNT
parameter_list|(
name|FILE
parameter_list|)
value|((FILE)->__bp - (FILE)->__buf)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|PENDING_OUTPUT_COUNT
parameter_list|(
name|FILE
parameter_list|)
value|((FILE)->_ptr - (FILE)->_base)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* No PENDING_OUTPUT_COUNT */
end_comment

begin_comment
comment|/* Nonzero means do not assume anything about current    contents of actual terminal screen */
end_comment

begin_decl_stmt
name|int
name|screen_garbaged
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Desired terminal cursor position (to show position of point),    origin zero */
end_comment

begin_decl_stmt
name|int
name|cursor_hpos
decl_stmt|,
name|cursor_vpos
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means last display completed and cursor is really at    cursor_hpos, cursor_vpos.  Zero means it was preempted. */
end_comment

begin_decl_stmt
name|int
name|display_completed
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Lisp variable visible-bell; enables use of screen-flash    instead of audible bell.  */
end_comment

begin_decl_stmt
name|int
name|visible_bell
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Invert the color of the whole screen, at a low level.  */
end_comment

begin_decl_stmt
name|int
name|inverse_video
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Line speed of the terminal.  */
end_comment

begin_decl_stmt
name|int
name|baud_rate
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* nil or a symbol naming the window system    under which emacs is running    ('x is the only current possibility).  */
end_comment

begin_decl_stmt
name|Lisp_Object
name|Vwindow_system
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Version number of window system, or nil if no window system.  */
end_comment

begin_decl_stmt
name|Lisp_Object
name|Vwindow_system_version
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means reading single-character input with prompt    so put cursor on minibuffer after the prompt.  */
end_comment

begin_decl_stmt
name|int
name|cursor_in_echo_area
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Description of actual screen contents.  */
end_comment

begin_decl_stmt
name|struct
name|matrix
modifier|*
name|current_screen
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Description of desired screen contents.  */
end_comment

begin_decl_stmt
name|struct
name|matrix
modifier|*
name|new_screen
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Buffer sometimes used to hold partial screen contents.  */
end_comment

begin_decl_stmt
name|struct
name|matrix
modifier|*
name|temp_screen
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Stdio stream being used for copy of all terminal output.  */
end_comment

begin_decl_stmt
name|FILE
modifier|*
name|termscript
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Structure for info on cursor positioning */
end_comment

begin_decl_stmt
name|struct
name|cm
name|Wcm
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|in_display
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1 if in redisplay: can't handle SIGWINCH now.  */
end_comment

begin_decl_stmt
name|int
name|delayed_size_change
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1 means SIGWINCH happened when not safe.  */
end_comment

begin_decl_stmt
name|int
name|delayed_screen_height
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Remembered new screen height.  */
end_comment

begin_decl_stmt
name|int
name|delayed_screen_width
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Remembered new screen width.  */
end_comment

begin_comment
comment|/* This buffer records the history of display preemption.  */
end_comment

begin_struct
struct|struct
name|preempt
block|{
comment|/* Number of keyboard characters read so far at preempt.  */
name|int
name|keyboard_char_count
decl_stmt|;
comment|/* Vertical position at which preemption occurred.  */
name|int
name|vpos
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|N_PREEMPTIONS
value|50
end_define

begin_comment
comment|/* Circular buffer recording recent display preemptions.  */
end_comment

begin_decl_stmt
name|struct
name|preempt
name|preemptions
index|[
name|N_PREEMPTIONS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Index of next element in preemptions.  */
end_comment

begin_decl_stmt
name|int
name|preemption_index
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set these variables in the debugger to force a display preemption.  */
end_comment

begin_decl_stmt
name|int
name|debug_preemption_vpos
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|debug_preemption_char_count
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|num_input_chars
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Free and reallocate current_screen and new_screen.  */
end_comment

begin_function_decl
name|struct
name|matrix
modifier|*
name|make_screen_structure
parameter_list|()
function_decl|;
end_function_decl

begin_macro
name|remake_screen_structures
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|current_screen
condition|)
name|free_screen_structure
argument_list|(
name|current_screen
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_screen
condition|)
name|free_screen_structure
argument_list|(
name|new_screen
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp_screen
condition|)
name|free_screen_structure
argument_list|(
name|temp_screen
argument_list|)
expr_stmt|;
name|current_screen
operator|=
name|make_screen_structure
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|new_screen
operator|=
name|make_screen_structure
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|temp_screen
operator|=
name|make_screen_structure
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|message_buf
condition|)
name|message_buf
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|message_buf
argument_list|,
name|screen_width
operator|+
literal|1
argument_list|)
expr_stmt|;
else|else
name|message_buf
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|screen_width
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|struct
name|matrix
modifier|*
name|make_screen_structure
parameter_list|(
name|empty
parameter_list|)
name|int
name|empty
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|struct
name|matrix
modifier|*
name|new
init|=
operator|(
expr|struct
name|matrix
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|matrix
argument_list|)
argument_list|)
decl_stmt|;
name|new
operator|->
name|height
operator|=
name|screen_height
expr_stmt|;
name|new
operator|->
name|width
operator|=
name|screen_width
expr_stmt|;
name|new
operator|->
name|highlight
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|screen_height
argument_list|)
expr_stmt|;
name|new
operator|->
name|enable
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|screen_height
argument_list|)
expr_stmt|;
name|new
operator|->
name|contents
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|screen_height
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|->
name|used
operator|=
operator|(
name|int
operator|*
operator|)
name|xmalloc
argument_list|(
name|screen_height
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|empty
condition|)
block|{
comment|/* Make the buffer used by decode_mode_spec.  */
name|new
operator|->
name|total_contents
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|screen_width
operator|+
literal|2
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|new
operator|->
name|contents
argument_list|,
name|screen_height
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Add 2 to leave extra bytes at beginning and end of each line.  */
name|new
operator|->
name|total_contents
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|screen_height
operator|*
operator|(
name|screen_width
operator|+
literal|2
operator|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|new
operator|->
name|total_contents
argument_list|,
name|screen_height
operator|*
operator|(
name|screen_width
operator|+
literal|2
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|screen_height
condition|;
name|i
operator|++
control|)
name|new
operator|->
name|contents
index|[
name|i
index|]
operator|=
name|new
operator|->
name|total_contents
operator|+
name|i
operator|*
operator|(
name|screen_width
operator|+
literal|2
operator|)
operator|+
literal|1
expr_stmt|;
block|}
name|bzero
argument_list|(
name|new
operator|->
name|enable
argument_list|,
name|screen_height
argument_list|)
expr_stmt|;
return|return
name|new
return|;
block|}
end_function

begin_macro
name|free_screen_structure
argument_list|(
argument|matrix
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|matrix
modifier|*
name|matrix
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|matrix
operator|->
name|total_contents
condition|)
name|free
argument_list|(
name|matrix
operator|->
name|total_contents
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|matrix
operator|->
name|contents
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|matrix
operator|->
name|highlight
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|matrix
operator|->
name|enable
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|matrix
operator|->
name|used
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|matrix
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Return the hash code of contents of line VPOS of screen-matrix M.  */
end_comment

begin_function
name|int
name|line_hash_code
parameter_list|(
name|m
parameter_list|,
name|vpos
parameter_list|)
name|struct
name|matrix
modifier|*
name|m
decl_stmt|;
name|int
name|vpos
decl_stmt|;
block|{
specifier|register
name|unsigned
name|char
modifier|*
name|body
decl_stmt|;
specifier|register
name|int
name|h
init|=
literal|0
decl_stmt|;
comment|/* Give all lighlighted lines the same hash code      so as to encourage scrolling to leave them in place.  */
if|if
condition|(
name|m
operator|->
name|highlight
index|[
name|vpos
index|]
condition|)
return|return
operator|-
literal|1
return|;
name|body
operator|=
name|m
operator|->
name|contents
index|[
name|vpos
index|]
expr_stmt|;
if|if
condition|(
name|must_write_spaces
condition|)
block|{
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|c
init|=
operator|*
name|body
operator|++
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
break|break;
name|h
operator|=
operator|(
operator|(
operator|(
name|h
operator|<<
literal|4
operator|)
operator|+
operator|(
name|h
operator|>>
literal|24
operator|)
operator|)
operator|&
literal|0x0fffffff
operator|)
operator|+
name|c
operator|-
literal|' '
expr_stmt|;
block|}
block|}
else|else
block|{
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|c
init|=
operator|*
name|body
operator|++
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
break|break;
name|h
operator|=
operator|(
operator|(
operator|(
name|h
operator|<<
literal|4
operator|)
operator|+
operator|(
name|h
operator|>>
literal|24
operator|)
operator|)
operator|&
literal|0x0fffffff
operator|)
operator|+
name|c
expr_stmt|;
block|}
block|}
if|if
condition|(
name|h
condition|)
return|return
name|h
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return number of characters in line in M at vpos VPOS,    except don't count leading and trailing spaces    unless the terminal requires those to be explicitly output.  */
end_comment

begin_function
name|int
name|line_draw_cost
parameter_list|(
name|m
parameter_list|,
name|vpos
parameter_list|)
name|struct
name|matrix
modifier|*
name|m
decl_stmt|;
name|int
name|vpos
decl_stmt|;
block|{
specifier|register
name|unsigned
name|char
modifier|*
name|body
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|must_write_spaces
condition|)
return|return
name|m
operator|->
name|used
index|[
name|vpos
index|]
return|;
name|body
operator|=
name|m
operator|->
name|contents
index|[
name|vpos
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
name|m
operator|->
name|used
index|[
name|vpos
index|]
init|;
name|i
operator|>
literal|0
operator|&&
name|body
index|[
name|i
operator|-
literal|2
index|]
operator|==
literal|' '
condition|;
name|i
operator|--
control|)
empty_stmt|;
name|i
operator|-=
name|count_blanks
argument_list|(
name|body
argument_list|)
expr_stmt|;
return|return
name|max
argument_list|(
name|i
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The functions on this page are the interface from xdisp.c to redisplay.   The only other interface into redisplay is through setting  cursor_hpos and cursor_vpos (in xdisp.c) and setting screen_garbaged. */
end_comment

begin_comment
comment|/* cancel_line eliminates any request to display a line at position `vpos' */
end_comment

begin_macro
name|cancel_line
argument_list|(
argument|vpos
argument_list|)
end_macro

begin_decl_stmt
name|int
name|vpos
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|new_screen
operator|->
name|enable
index|[
name|vpos
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_macro
name|clear_screen_records
argument_list|()
end_macro

begin_block
block|{
name|int
name|i
decl_stmt|;
name|bzero
argument_list|(
name|current_screen
operator|->
name|enable
argument_list|,
name|screen_height
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Get ready to display on line `vpos'    and set it up for outputting starting at `hpos' within it.    Return the text string where that line is stored.  */
end_comment

begin_function
name|unsigned
name|char
modifier|*
name|get_display_line
parameter_list|(
name|vpos
parameter_list|,
name|hpos
parameter_list|)
name|int
name|vpos
decl_stmt|;
specifier|register
name|int
name|hpos
decl_stmt|;
block|{
if|if
condition|(
name|new_screen
operator|->
name|enable
index|[
name|vpos
index|]
operator|&&
name|new_screen
operator|->
name|used
index|[
name|vpos
index|]
operator|>
name|hpos
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|new_screen
operator|->
name|enable
index|[
name|vpos
index|]
condition|)
block|{
name|new_screen
operator|->
name|used
index|[
name|vpos
index|]
operator|=
literal|0
expr_stmt|;
name|new_screen
operator|->
name|highlight
index|[
name|vpos
index|]
operator|=
literal|0
expr_stmt|;
name|new_screen
operator|->
name|enable
index|[
name|vpos
index|]
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|hpos
operator|>
name|new_screen
operator|->
name|used
index|[
name|vpos
index|]
condition|)
block|{
name|unsigned
name|char
modifier|*
name|p
init|=
name|new_screen
operator|->
name|contents
index|[
name|vpos
index|]
operator|+
name|new_screen
operator|->
name|used
index|[
name|vpos
index|]
decl_stmt|;
name|unsigned
name|char
modifier|*
name|end
init|=
name|new_screen
operator|->
name|contents
index|[
name|vpos
index|]
operator|+
name|hpos
decl_stmt|;
name|new_screen
operator|->
name|used
index|[
name|vpos
index|]
operator|=
name|hpos
expr_stmt|;
while|while
condition|(
name|p
operator|!=
name|end
condition|)
operator|*
name|p
operator|++
operator|=
literal|' '
expr_stmt|;
block|}
return|return
name|new_screen
operator|->
name|contents
index|[
name|vpos
index|]
return|;
block|}
end_function

begin_comment
comment|/* Scroll lines from vpos `from' up to but not including vpos `end'  down by `amount' lines (`amount' may be negative).  Returns nonzero if done, zero if terminal cannot scroll them. */
end_comment

begin_function
name|int
name|scroll_screen_lines
parameter_list|(
name|from
parameter_list|,
name|end
parameter_list|,
name|amount
parameter_list|)
name|int
name|from
decl_stmt|,
name|end
decl_stmt|,
name|amount
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|line_ins_del_ok
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|amount
operator|==
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|amount
operator|>
literal|0
condition|)
block|{
name|set_terminal_window
argument_list|(
name|end
operator|+
name|amount
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|scroll_region_ok
condition|)
name|ins_del_lines
argument_list|(
name|end
argument_list|,
operator|-
name|amount
argument_list|)
expr_stmt|;
name|ins_del_lines
argument_list|(
name|from
argument_list|,
name|amount
argument_list|)
expr_stmt|;
name|set_terminal_window
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|rotate_vector
argument_list|(
name|current_screen
operator|->
name|contents
operator|+
name|from
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
operator|(
name|end
operator|+
name|amount
operator|-
name|from
operator|)
argument_list|,
name|amount
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|safe_bcopy
argument_list|(
name|current_screen
operator|->
name|used
operator|+
name|from
argument_list|,
name|current_screen
operator|->
name|used
operator|+
name|from
operator|+
name|amount
argument_list|,
operator|(
name|end
operator|-
name|from
operator|)
operator|*
sizeof|sizeof
name|current_screen
operator|->
name|used
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|safe_bcopy
argument_list|(
name|current_screen
operator|->
name|highlight
operator|+
name|from
argument_list|,
name|current_screen
operator|->
name|highlight
operator|+
name|from
operator|+
name|amount
argument_list|,
operator|(
name|end
operator|-
name|from
operator|)
operator|*
sizeof|sizeof
name|current_screen
operator|->
name|highlight
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|safe_bcopy
argument_list|(
name|current_screen
operator|->
name|enable
operator|+
name|from
argument_list|,
name|current_screen
operator|->
name|enable
operator|+
name|from
operator|+
name|amount
argument_list|,
operator|(
name|end
operator|-
name|from
operator|)
operator|*
sizeof|sizeof
name|current_screen
operator|->
name|enable
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* Mark the lines made empty by scrolling as enabled, empty and 	 normal video.  */
name|bzero
argument_list|(
name|current_screen
operator|->
name|used
operator|+
name|from
argument_list|,
name|amount
operator|*
sizeof|sizeof
name|current_screen
operator|->
name|used
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|current_screen
operator|->
name|highlight
operator|+
name|from
argument_list|,
name|amount
operator|*
sizeof|sizeof
name|current_screen
operator|->
name|highlight
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|from
init|;
name|i
operator|<
name|from
operator|+
name|amount
condition|;
name|i
operator|++
control|)
block|{
name|current_screen
operator|->
name|contents
index|[
name|i
index|]
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|current_screen
operator|->
name|enable
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|amount
operator|<
literal|0
condition|)
block|{
name|set_terminal_window
argument_list|(
name|end
argument_list|)
expr_stmt|;
name|ins_del_lines
argument_list|(
name|from
operator|+
name|amount
argument_list|,
name|amount
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|scroll_region_ok
condition|)
name|ins_del_lines
argument_list|(
name|end
operator|+
name|amount
argument_list|,
operator|-
name|amount
argument_list|)
expr_stmt|;
name|set_terminal_window
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|rotate_vector
argument_list|(
name|current_screen
operator|->
name|contents
operator|+
name|from
operator|+
name|amount
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
operator|(
name|end
operator|-
name|from
operator|-
name|amount
operator|)
argument_list|,
operator|(
name|end
operator|-
name|from
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|safe_bcopy
argument_list|(
name|current_screen
operator|->
name|used
operator|+
name|from
argument_list|,
name|current_screen
operator|->
name|used
operator|+
name|from
operator|+
name|amount
argument_list|,
operator|(
name|end
operator|-
name|from
operator|)
operator|*
sizeof|sizeof
name|current_screen
operator|->
name|used
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|safe_bcopy
argument_list|(
name|current_screen
operator|->
name|highlight
operator|+
name|from
argument_list|,
name|current_screen
operator|->
name|highlight
operator|+
name|from
operator|+
name|amount
argument_list|,
operator|(
name|end
operator|-
name|from
operator|)
operator|*
sizeof|sizeof
name|current_screen
operator|->
name|highlight
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|safe_bcopy
argument_list|(
name|current_screen
operator|->
name|enable
operator|+
name|from
argument_list|,
name|current_screen
operator|->
name|enable
operator|+
name|from
operator|+
name|amount
argument_list|,
operator|(
name|end
operator|-
name|from
operator|)
operator|*
sizeof|sizeof
name|current_screen
operator|->
name|enable
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* Mark the lines made empty by scrolling as enabled, empty and 	 normal video.  */
name|bzero
argument_list|(
name|current_screen
operator|->
name|used
operator|+
name|end
operator|+
name|amount
argument_list|,
operator|-
name|amount
operator|*
sizeof|sizeof
name|current_screen
operator|->
name|used
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|current_screen
operator|->
name|highlight
operator|+
name|end
operator|+
name|amount
argument_list|,
operator|-
name|amount
operator|*
sizeof|sizeof
name|current_screen
operator|->
name|highlight
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|end
operator|+
name|amount
init|;
name|i
operator|<
name|end
condition|;
name|i
operator|++
control|)
block|{
name|current_screen
operator|->
name|contents
index|[
name|i
index|]
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|current_screen
operator|->
name|enable
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Rotate a vector of SIZE bytes, by DISTANCE bytes.    DISTANCE may be negative.  */
end_comment

begin_macro
name|rotate_vector
argument_list|(
argument|vector
argument_list|,
argument|size
argument_list|,
argument|distance
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|vector
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|distance
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|temp
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
name|distance
operator|<
literal|0
condition|)
name|distance
operator|+=
name|size
expr_stmt|;
name|bcopy
argument_list|(
name|vector
argument_list|,
name|temp
operator|+
name|distance
argument_list|,
name|size
operator|-
name|distance
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|vector
operator|+
name|size
operator|-
name|distance
argument_list|,
name|temp
argument_list|,
name|distance
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|temp
argument_list|,
name|vector
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Like bcopy except never gets confused by overlap.  */
end_comment

begin_macro
name|safe_bcopy
argument_list|(
argument|from
argument_list|,
argument|to
argument_list|,
argument|size
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|from
decl_stmt|,
modifier|*
name|to
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|size
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|endf
decl_stmt|;
specifier|register
name|char
modifier|*
name|endt
decl_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|from
operator|>
name|to
condition|)
block|{
comment|/* If destination is lower in memory, we can go from the beginning.  */
name|endf
operator|=
name|from
operator|+
name|size
expr_stmt|;
while|while
condition|(
name|from
operator|!=
name|endf
condition|)
operator|*
name|to
operator|++
operator|=
operator|*
name|from
operator|++
expr_stmt|;
return|return;
block|}
comment|/* If destination is higher in memory, we can go backwards from the end.  */
name|endf
operator|=
name|from
operator|+
name|size
expr_stmt|;
name|endt
operator|=
name|to
operator|+
name|size
expr_stmt|;
do|do
operator|*
operator|--
name|endt
operator|=
operator|*
operator|--
name|endf
expr_stmt|;
do|while
condition|(
name|endf
operator|!=
name|from
condition|)
do|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* After updating a window w that isn't the full screen wide,  copy all the columns that w does not occupy  from current_screen to new_screen,  so that update_screen will not change those columns.  */
end_comment

begin_macro
name|preserve_other_columns
argument_list|(
argument|w
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|window
modifier|*
name|w
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|vpos
decl_stmt|;
name|int
name|start
init|=
name|XFASTINT
argument_list|(
name|w
operator|->
name|left
argument_list|)
decl_stmt|;
name|int
name|end
init|=
name|XFASTINT
argument_list|(
name|w
operator|->
name|left
argument_list|)
operator|+
name|XFASTINT
argument_list|(
name|w
operator|->
name|width
argument_list|)
decl_stmt|;
name|int
name|bot
init|=
name|XFASTINT
argument_list|(
name|w
operator|->
name|top
argument_list|)
operator|+
name|XFASTINT
argument_list|(
name|w
operator|->
name|height
argument_list|)
decl_stmt|;
for|for
control|(
name|vpos
operator|=
name|XFASTINT
argument_list|(
name|w
operator|->
name|top
argument_list|)
init|;
name|vpos
operator|<
name|bot
condition|;
name|vpos
operator|++
control|)
block|{
if|if
condition|(
name|current_screen
operator|->
name|enable
index|[
name|vpos
index|]
operator|&&
name|new_screen
operator|->
name|enable
index|[
name|vpos
index|]
condition|)
block|{
if|if
condition|(
name|start
operator|>
literal|0
condition|)
block|{
name|int
name|len
decl_stmt|;
name|bcopy
argument_list|(
name|current_screen
operator|->
name|contents
index|[
name|vpos
index|]
argument_list|,
name|new_screen
operator|->
name|contents
index|[
name|vpos
index|]
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|len
operator|=
name|min
argument_list|(
name|start
argument_list|,
name|current_screen
operator|->
name|used
index|[
name|vpos
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_screen
operator|->
name|used
index|[
name|vpos
index|]
operator|<
name|len
condition|)
name|new_screen
operator|->
name|used
index|[
name|vpos
index|]
operator|=
name|len
expr_stmt|;
block|}
if|if
condition|(
name|current_screen
operator|->
name|used
index|[
name|vpos
index|]
operator|>
name|end
operator|&&
name|new_screen
operator|->
name|used
index|[
name|vpos
index|]
operator|<
name|current_screen
operator|->
name|used
index|[
name|vpos
index|]
condition|)
block|{
while|while
condition|(
name|new_screen
operator|->
name|used
index|[
name|vpos
index|]
operator|<
name|end
condition|)
name|new_screen
operator|->
name|contents
index|[
name|vpos
index|]
index|[
name|new_screen
operator|->
name|used
index|[
name|vpos
index|]
operator|++
index|]
operator|=
literal|' '
expr_stmt|;
name|bcopy
argument_list|(
name|current_screen
operator|->
name|contents
index|[
name|vpos
index|]
operator|+
name|end
argument_list|,
name|new_screen
operator|->
name|contents
index|[
name|vpos
index|]
operator|+
name|end
argument_list|,
name|current_screen
operator|->
name|used
index|[
name|vpos
index|]
operator|-
name|end
argument_list|)
expr_stmt|;
name|new_screen
operator|->
name|used
index|[
name|vpos
index|]
operator|=
name|current_screen
operator|->
name|used
index|[
name|vpos
index|]
expr_stmt|;
block|}
block|}
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* On discovering that the redisplay for a window was no good,  cancel the columns of that window,  so that when the window is displayed over again  get_display_line will not complain. */
end_comment

begin_macro
name|cancel_my_columns
argument_list|(
argument|w
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|window
modifier|*
name|w
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|vpos
decl_stmt|;
specifier|register
name|int
name|start
init|=
name|XFASTINT
argument_list|(
name|w
operator|->
name|left
argument_list|)
decl_stmt|;
specifier|register
name|int
name|bot
init|=
name|XFASTINT
argument_list|(
name|w
operator|->
name|top
argument_list|)
operator|+
name|XFASTINT
argument_list|(
name|w
operator|->
name|height
argument_list|)
decl_stmt|;
for|for
control|(
name|vpos
operator|=
name|XFASTINT
argument_list|(
name|w
operator|->
name|top
argument_list|)
init|;
name|vpos
operator|<
name|bot
condition|;
name|vpos
operator|++
control|)
if|if
condition|(
name|new_screen
operator|->
name|enable
index|[
name|vpos
index|]
operator|&&
name|new_screen
operator|->
name|used
index|[
name|vpos
index|]
operator|>=
name|start
condition|)
name|new_screen
operator|->
name|used
index|[
name|vpos
index|]
operator|=
name|start
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* These functions try to perform directly and immediately on the screen    the necessary output for one change in the buffer.    They may return 0 meaning nothing was done if anything is difficult,    or 1 meaning the output was performed properly.    They assume that the screen was up to date before the buffer    change being displayed.  THey make various other assumptions too;    see command_loop_1 where these are called.  */
end_comment

begin_function
name|int
name|direct_output_for_insert
parameter_list|(
name|c
parameter_list|)
name|int
name|c
decl_stmt|;
block|{
ifndef|#
directive|ifndef
name|COMPILER_REGISTER_BUG
specifier|register
endif|#
directive|endif
endif|COMPILER_REGISTER_BUG
name|struct
name|window
modifier|*
name|w
init|=
name|XWINDOW
argument_list|(
name|selected_window
argument_list|)
decl_stmt|;
ifndef|#
directive|ifndef
name|COMPILER_REGISTER_BUG
specifier|register
endif|#
directive|endif
endif|COMPILER_REGISTER_BUG
name|int
name|hpos
init|=
name|cursor_hpos
decl_stmt|;
ifndef|#
directive|ifndef
name|COMPILER_REGISTER_BUG
specifier|register
endif|#
directive|endif
endif|COMPILER_REGISTER_BUG
name|int
name|vpos
init|=
name|cursor_vpos
decl_stmt|;
comment|/* Give up if about to continue line */
if|if
condition|(
name|hpos
operator|-
name|XFASTINT
argument_list|(
name|w
operator|->
name|left
argument_list|)
operator|+
literal|1
operator|+
literal|1
operator|>=
name|XFASTINT
argument_list|(
name|w
operator|->
name|width
argument_list|)
comment|/* Avoid losing if cursor is in invisible text off left margin */
operator|||
name|XINT
argument_list|(
name|w
operator|->
name|hscroll
argument_list|)
operator|&&
name|hpos
operator|==
name|XFASTINT
argument_list|(
name|w
operator|->
name|left
argument_list|)
comment|/* Give up if cursor outside window (in minibuf, probably) */
operator|||
name|cursor_vpos
operator|<
name|XFASTINT
argument_list|(
name|w
operator|->
name|top
argument_list|)
operator|||
name|cursor_vpos
operator|>=
name|XFASTINT
argument_list|(
name|w
operator|->
name|top
argument_list|)
operator|+
name|XFASTINT
argument_list|(
name|w
operator|->
name|height
argument_list|)
comment|/* Give up if cursor not really at cursor_hpos, cursor_vpos */
operator|||
operator|!
name|display_completed
comment|/* Give up if w is minibuffer and a message is being displayed there */
operator|||
name|EQ
argument_list|(
name|selected_window
argument_list|,
name|minibuf_window
argument_list|)
operator|&&
name|echo_area_contents
condition|)
return|return
literal|0
return|;
name|current_screen
operator|->
name|contents
index|[
name|vpos
index|]
index|[
name|hpos
index|]
operator|=
name|c
expr_stmt|;
name|unchanged_modified
operator|=
name|MODIFF
expr_stmt|;
name|beg_unchanged
operator|=
name|GPT
operator|-
name|BEG
expr_stmt|;
name|XFASTINT
argument_list|(
name|w
operator|->
name|last_point
argument_list|)
operator|=
name|point
expr_stmt|;
name|XFASTINT
argument_list|(
name|w
operator|->
name|last_point_x
argument_list|)
operator|=
name|cursor_hpos
expr_stmt|;
name|XFASTINT
argument_list|(
name|w
operator|->
name|last_modified
argument_list|)
operator|=
name|MODIFF
expr_stmt|;
name|reassert_line_highlight
argument_list|(
literal|0
argument_list|,
name|cursor_vpos
argument_list|)
expr_stmt|;
name|output_chars
argument_list|(
operator|&
name|current_screen
operator|->
name|contents
index|[
name|vpos
index|]
index|[
name|hpos
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
operator|++
name|cursor_hpos
expr_stmt|;
if|if
condition|(
name|hpos
operator|==
name|current_screen
operator|->
name|used
index|[
name|vpos
index|]
condition|)
block|{
name|current_screen
operator|->
name|used
index|[
name|vpos
index|]
operator|=
name|hpos
operator|+
literal|1
expr_stmt|;
name|current_screen
operator|->
name|contents
index|[
name|vpos
index|]
index|[
name|hpos
operator|+
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|direct_output_forward_char
parameter_list|(
name|n
parameter_list|)
name|int
name|n
decl_stmt|;
block|{
specifier|register
name|struct
name|window
modifier|*
name|w
init|=
name|XWINDOW
argument_list|(
name|selected_window
argument_list|)
decl_stmt|;
comment|/* Avoid losing if cursor is in invisible text off left margin */
if|if
condition|(
name|XINT
argument_list|(
name|w
operator|->
name|hscroll
argument_list|)
operator|&&
name|cursor_hpos
operator|==
name|XFASTINT
argument_list|(
name|w
operator|->
name|left
argument_list|)
condition|)
return|return
literal|0
return|;
name|cursor_hpos
operator|+=
name|n
expr_stmt|;
name|XFASTINT
argument_list|(
name|w
operator|->
name|last_point_x
argument_list|)
operator|=
name|cursor_hpos
expr_stmt|;
name|XFASTINT
argument_list|(
name|w
operator|->
name|last_point
argument_list|)
operator|=
name|point
expr_stmt|;
name|move_cursor
argument_list|(
name|cursor_vpos
argument_list|,
name|cursor_hpos
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Update the actual terminal screen based on the data in new_screen.    Value is nonzero if redisplay stopped due to pending input.    FORCE nonzero means do not stop for pending input.  */
end_comment

begin_macro
name|update_screen
argument_list|(
argument|force
argument_list|,
argument|inhibit_hairy_id
argument_list|)
end_macro

begin_decl_stmt
name|int
name|force
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|inhibit_hairy_id
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|display_line
modifier|*
modifier|*
name|p
decl_stmt|;
specifier|register
name|struct
name|display_line
modifier|*
name|l
decl_stmt|,
modifier|*
name|lnew
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|pause
decl_stmt|;
name|int
name|preempt_count
init|=
name|baud_rate
operator|/
literal|2400
operator|+
literal|1
decl_stmt|;
extern|extern input_pending;
if|if
condition|(
name|screen_height
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Some bug zeros some core */
name|detect_input_pending
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|force
operator|&&
operator|(
operator|(
name|num_input_chars
operator|==
name|debug_preemption_char_count
operator|&&
name|debug_preemption_vpos
operator|==
name|screen_height
operator|-
literal|1
operator|)
operator|||
name|input_pending
operator|)
condition|)
block|{
name|pause
operator|=
name|screen_height
expr_stmt|;
goto|goto
name|do_pause
goto|;
block|}
name|update_begin
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|line_ins_del_ok
condition|)
name|inhibit_hairy_id
operator|=
literal|1
expr_stmt|;
comment|/* Don't compute for i/d line if just want cursor motion. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|screen_height
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|new_screen
operator|->
name|enable
condition|)
break|break;
comment|/* Try doing i/d line, if not yet inhibited.  */
if|if
condition|(
operator|!
name|inhibit_hairy_id
operator|&&
name|i
operator|<
name|screen_height
condition|)
name|force
operator||=
name|scrolling
argument_list|()
expr_stmt|;
comment|/* Update the individual lines as needed.  Do bottom line first.  */
if|if
condition|(
name|new_screen
operator|->
name|enable
index|[
name|screen_height
operator|-
literal|1
index|]
condition|)
name|update_line
argument_list|(
name|screen_height
operator|-
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|screen_height
operator|-
literal|1
operator|&&
operator|(
name|force
operator|||
operator|!
name|input_pending
operator|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|force
operator|&&
name|num_input_chars
operator|==
name|debug_preemption_char_count
operator|&&
name|debug_preemption_vpos
operator|==
name|i
condition|)
break|break;
if|if
condition|(
name|new_screen
operator|->
name|enable
index|[
name|i
index|]
condition|)
block|{
comment|/* Flush out every so many lines. 	     Also flush out if likely to have more than 1k buffered 	     otherwise.   I'm told that telnet connections get really 	     screwed by more than 1k output at once.  */
name|int
name|outq
init|=
name|PENDING_OUTPUT_COUNT
argument_list|(
name|stdout
argument_list|)
decl_stmt|;
if|if
condition|(
name|outq
operator|>
literal|900
operator|||
operator|(
name|outq
operator|>
literal|20
operator|&&
operator|(
operator|(
name|i
operator|-
literal|1
operator|)
operator|%
name|preempt_count
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|preempt_count
operator|==
literal|1
condition|)
block|{
ifdef|#
directive|ifdef
name|TIOCOUTQ
if|if
condition|(
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCOUTQ
argument_list|,
operator|&
name|outq
argument_list|)
operator|<
literal|0
condition|)
comment|/* Probably not a tty.  Ignore the error and reset 		     * the outq count. */
name|outq
operator|=
name|PENDING_OUTPUT_COUNT
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|outq
operator|*=
literal|10
expr_stmt|;
name|sleep
argument_list|(
name|outq
operator|/
name|baud_rate
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|i
operator|-
literal|1
operator|)
operator|%
name|preempt_count
operator|==
literal|0
condition|)
name|detect_input_pending
argument_list|()
expr_stmt|;
comment|/* Now update this line.  */
name|update_line
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
name|pause
operator|=
operator|(
name|i
operator|<
name|screen_height
operator|-
literal|1
operator|)
condition|?
name|i
operator|+
literal|1
else|:
literal|0
expr_stmt|;
comment|/* Now just clean up termcap drivers and set cursor, etc.  */
if|if
condition|(
operator|!
name|pause
condition|)
block|{
if|if
condition|(
name|cursor_in_echo_area
operator|<
literal|0
condition|)
name|move_cursor
argument_list|(
name|screen_height
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|cursor_in_echo_area
operator|>
literal|0
operator|&&
operator|!
name|current_screen
operator|->
name|enable
index|[
name|screen_height
operator|-
literal|1
index|]
condition|)
name|move_cursor
argument_list|(
name|screen_height
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|cursor_in_echo_area
condition|)
name|move_cursor
argument_list|(
name|screen_height
operator|-
literal|1
argument_list|,
name|min
argument_list|(
name|screen_width
operator|-
literal|1
argument_list|,
name|current_screen
operator|->
name|used
index|[
name|screen_height
operator|-
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|move_cursor
argument_list|(
name|cursor_vpos
argument_list|,
name|max
argument_list|(
name|min
argument_list|(
name|cursor_hpos
argument_list|,
name|screen_width
operator|-
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|update_end
argument_list|()
expr_stmt|;
if|if
condition|(
name|termscript
condition|)
name|fflush
argument_list|(
name|termscript
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
comment|/* Here if output is preempted because input is detected.  */
name|do_pause
label|:
if|if
condition|(
name|screen_height
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Some bug zeros some core */
name|display_completed
operator|=
operator|!
name|pause
expr_stmt|;
if|if
condition|(
name|pause
condition|)
block|{
name|preemptions
index|[
name|preemption_index
index|]
operator|.
name|vpos
operator|=
name|pause
operator|-
literal|1
expr_stmt|;
name|preemptions
index|[
name|preemption_index
index|]
operator|.
name|keyboard_char_count
operator|=
name|num_input_chars
expr_stmt|;
name|preemption_index
operator|++
expr_stmt|;
if|if
condition|(
name|preemption_index
operator|==
name|N_PREEMPTIONS
condition|)
name|preemption_index
operator|=
literal|0
expr_stmt|;
block|}
name|bzero
argument_list|(
name|new_screen
operator|->
name|enable
argument_list|,
name|screen_height
argument_list|)
expr_stmt|;
return|return
name|pause
return|;
block|}
end_block

begin_comment
comment|/* Called when about to quit, to check for doing so    at an improper time.  */
end_comment

begin_function
name|void
name|quit_error_check
parameter_list|()
block|{
if|if
condition|(
name|new_screen
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|new_screen
operator|->
name|enable
index|[
literal|0
index|]
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|new_screen
operator|->
name|enable
index|[
name|screen_height
operator|-
literal|1
index|]
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Decide what insert/delete line to do, and do it */
end_comment

begin_macro
name|scrolling
argument_list|()
end_macro

begin_block
block|{
name|int
name|unchanged_at_top
decl_stmt|,
name|unchanged_at_bottom
decl_stmt|;
name|int
name|window_size
decl_stmt|;
name|int
name|changed_lines
decl_stmt|;
name|int
modifier|*
name|old_hash
init|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|screen_height
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
decl_stmt|;
name|int
modifier|*
name|new_hash
init|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|screen_height
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
decl_stmt|;
name|int
modifier|*
name|draw_cost
init|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|screen_height
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|free_at_end_vpos
init|=
name|screen_height
decl_stmt|;
comment|/* Compute hash codes of all the lines.      Also calculate number of changed lines,      number of unchanged lines at the beginning,      and number of unchanged lines at the end.  */
name|changed_lines
operator|=
literal|0
expr_stmt|;
name|unchanged_at_top
operator|=
literal|0
expr_stmt|;
name|unchanged_at_bottom
operator|=
name|screen_height
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|screen_height
condition|;
name|i
operator|++
control|)
block|{
comment|/* Give up on this scrolling if some old lines are not enabled.  */
if|if
condition|(
operator|!
name|current_screen
operator|->
name|enable
index|[
name|i
index|]
condition|)
return|return
literal|0
return|;
name|old_hash
index|[
name|i
index|]
operator|=
name|line_hash_code
argument_list|(
name|current_screen
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|new_screen
operator|->
name|enable
index|[
name|i
index|]
condition|)
name|new_hash
index|[
name|i
index|]
operator|=
name|old_hash
index|[
name|i
index|]
expr_stmt|;
else|else
name|new_hash
index|[
name|i
index|]
operator|=
name|line_hash_code
argument_list|(
name|new_screen
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|old_hash
index|[
name|i
index|]
operator|!=
name|new_hash
index|[
name|i
index|]
condition|)
block|{
name|changed_lines
operator|++
expr_stmt|;
name|unchanged_at_bottom
operator|=
name|screen_height
operator|-
name|i
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|==
name|unchanged_at_top
condition|)
name|unchanged_at_top
operator|++
expr_stmt|;
comment|/* If line is not changing, its redraw cost is infinite, 	 since we can't redraw it.  */
if|if
condition|(
operator|!
name|new_screen
operator|->
name|enable
index|[
name|i
index|]
condition|)
name|draw_cost
index|[
name|i
index|]
operator|=
name|INFINITY
expr_stmt|;
else|else
name|draw_cost
index|[
name|i
index|]
operator|=
name|line_draw_cost
argument_list|(
name|new_screen
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
comment|/* If changed lines are few, don't allow preemption, don't scroll.  */
if|if
condition|(
name|changed_lines
operator|<
name|baud_rate
operator|/
literal|2400
operator|||
name|unchanged_at_bottom
operator|==
name|screen_height
condition|)
return|return
literal|1
return|;
name|window_size
operator|=
name|screen_height
operator|-
name|unchanged_at_top
operator|-
name|unchanged_at_bottom
expr_stmt|;
if|if
condition|(
name|scroll_region_ok
condition|)
name|free_at_end_vpos
operator|-=
name|unchanged_at_bottom
expr_stmt|;
elseif|else
if|if
condition|(
name|memory_below_screen
condition|)
name|free_at_end_vpos
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* If large window, fast terminal and few lines in common between      current_screen and new_screen, don't bother with i/d calc.  */
if|if
condition|(
name|window_size
operator|>=
literal|18
operator|&&
name|baud_rate
operator|>
literal|2400
operator|&&
operator|(
name|window_size
operator|>=
literal|10
operator|*
name|scrolling_max_lines_saved
argument_list|(
name|unchanged_at_top
argument_list|,
name|screen_height
operator|-
name|unchanged_at_bottom
argument_list|,
name|old_hash
argument_list|,
name|new_hash
argument_list|,
name|draw_cost
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
name|scrolling_1
argument_list|(
name|window_size
argument_list|,
name|unchanged_at_top
argument_list|,
name|unchanged_at_bottom
argument_list|,
name|draw_cost
operator|+
name|unchanged_at_top
operator|-
literal|1
argument_list|,
name|old_hash
operator|+
name|unchanged_at_top
operator|-
literal|1
argument_list|,
name|new_hash
operator|+
name|unchanged_at_top
operator|-
literal|1
argument_list|,
name|free_at_end_vpos
operator|-
name|unchanged_at_top
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_escape
end_escape

begin_macro
name|update_line
argument_list|(
argument|vpos
argument_list|)
end_macro

begin_decl_stmt
name|int
name|vpos
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|unsigned
name|char
modifier|*
name|obody
decl_stmt|,
modifier|*
name|nbody
decl_stmt|,
modifier|*
name|op1
decl_stmt|,
modifier|*
name|op2
decl_stmt|,
modifier|*
name|np1
decl_stmt|;
name|int
name|tem
decl_stmt|;
name|int
name|osp
decl_stmt|,
name|nsp
decl_stmt|,
name|begmatch
decl_stmt|,
name|endmatch
decl_stmt|,
name|olen
decl_stmt|,
name|nlen
decl_stmt|;
name|int
name|save
decl_stmt|;
name|unsigned
name|char
modifier|*
name|temp
decl_stmt|;
comment|/* Check for highlighting change.  */
if|if
condition|(
name|new_screen
operator|->
name|highlight
index|[
name|vpos
index|]
operator|!=
operator|(
name|current_screen
operator|->
name|enable
index|[
name|vpos
index|]
operator|&&
name|current_screen
operator|->
name|highlight
index|[
name|vpos
index|]
operator|)
condition|)
block|{
name|change_line_highlight
argument_list|(
name|new_screen
operator|->
name|highlight
index|[
name|vpos
index|]
argument_list|,
name|vpos
argument_list|,
operator|(
name|current_screen
operator|->
name|enable
index|[
name|vpos
index|]
condition|?
name|current_screen
operator|->
name|used
index|[
name|vpos
index|]
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
name|current_screen
operator|->
name|enable
index|[
name|vpos
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|reassert_line_highlight
argument_list|(
name|new_screen
operator|->
name|highlight
index|[
name|vpos
index|]
argument_list|,
name|vpos
argument_list|)
expr_stmt|;
comment|/* ??? */
if|if
condition|(
operator|!
name|current_screen
operator|->
name|enable
index|[
name|vpos
index|]
condition|)
block|{
name|olen
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|obody
operator|=
name|current_screen
operator|->
name|contents
index|[
name|vpos
index|]
expr_stmt|;
name|olen
operator|=
name|current_screen
operator|->
name|used
index|[
name|vpos
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|current_screen
operator|->
name|highlight
index|[
name|vpos
index|]
condition|)
block|{
comment|/* Note obody[-1] is always 0.  */
if|if
condition|(
operator|!
name|must_write_spaces
condition|)
while|while
condition|(
name|obody
index|[
name|olen
operator|-
literal|1
index|]
operator|==
literal|' '
condition|)
name|olen
operator|--
expr_stmt|;
block|}
else|else
block|{
comment|/* For an inverse-video line, remember we gave it 	     spaces all the way to the screen edge 	     so that the reverse video extends all the way across.  */
while|while
condition|(
name|olen
operator|<
name|screen_width
operator|-
literal|1
condition|)
name|obody
index|[
name|olen
operator|++
index|]
operator|=
literal|' '
expr_stmt|;
block|}
block|}
comment|/* One way or another, this will enable the line being updated.  */
name|current_screen
operator|->
name|enable
index|[
name|vpos
index|]
operator|=
literal|1
expr_stmt|;
name|current_screen
operator|->
name|used
index|[
name|vpos
index|]
operator|=
name|new_screen
operator|->
name|used
index|[
name|vpos
index|]
expr_stmt|;
name|current_screen
operator|->
name|highlight
index|[
name|vpos
index|]
operator|=
name|new_screen
operator|->
name|highlight
index|[
name|vpos
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|new_screen
operator|->
name|enable
index|[
name|vpos
index|]
condition|)
block|{
name|nlen
operator|=
literal|0
expr_stmt|;
goto|goto
name|just_erase
goto|;
block|}
name|nbody
operator|=
name|new_screen
operator|->
name|contents
index|[
name|vpos
index|]
expr_stmt|;
name|nlen
operator|=
name|new_screen
operator|->
name|used
index|[
name|vpos
index|]
expr_stmt|;
comment|/* Pretend trailing spaces are not there at all,      unless for one reason or another we must write all spaces.  */
comment|/* We know that the previous character byte contains 0.  */
if|if
condition|(
operator|!
name|new_screen
operator|->
name|highlight
index|[
name|vpos
index|]
condition|)
block|{
if|if
condition|(
operator|!
name|must_write_spaces
condition|)
while|while
condition|(
name|nbody
index|[
name|nlen
operator|-
literal|1
index|]
operator|==
literal|' '
condition|)
name|nlen
operator|--
expr_stmt|;
block|}
else|else
block|{
comment|/* For an inverse-video line, give it extra trailing spaces 	 all the way to the screen edge 	 so that the reverse video extends all the way across.  */
while|while
condition|(
name|nlen
operator|<
name|screen_width
operator|-
literal|1
condition|)
name|nbody
index|[
name|nlen
operator|++
index|]
operator|=
literal|' '
expr_stmt|;
block|}
comment|/* If there's no i/d char, quickly do the best we can without it.  */
if|if
condition|(
operator|!
name|char_ins_del_ok
condition|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nlen
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>=
name|olen
operator|||
name|nbody
index|[
name|i
index|]
operator|!=
name|obody
index|[
name|i
index|]
condition|)
block|{
comment|/* We found a non-matching char.  */
name|move_cursor
argument_list|(
name|vpos
argument_list|,
name|i
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
operator|(
name|i
operator|+
name|j
operator|<
name|nlen
operator|&&
operator|(
name|i
operator|+
name|j
operator|>=
name|olen
operator|||
name|nbody
index|[
name|i
operator|+
name|j
index|]
operator|!=
name|obody
index|[
name|i
operator|+
name|j
index|]
operator|)
operator|)
condition|;
name|j
operator|++
control|)
empty_stmt|;
comment|/* Output this run of non-matching chars.  */
name|output_chars
argument_list|(
name|nbody
operator|+
name|i
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|i
operator|+=
name|j
operator|-
literal|1
expr_stmt|;
comment|/* Now find the next non-match.  */
block|}
block|}
comment|/* Clear the rest of the line, or the non-clear part of it.  */
if|if
condition|(
name|olen
operator|>
name|nlen
condition|)
block|{
name|move_cursor
argument_list|(
name|vpos
argument_list|,
name|nlen
argument_list|)
expr_stmt|;
name|clear_end_of_line
argument_list|(
name|olen
argument_list|)
expr_stmt|;
block|}
comment|/* Exchange contents between current_screen and new_screen.  */
name|temp
operator|=
name|new_screen
operator|->
name|contents
index|[
name|vpos
index|]
expr_stmt|;
name|new_screen
operator|->
name|contents
index|[
name|vpos
index|]
operator|=
name|current_screen
operator|->
name|contents
index|[
name|vpos
index|]
expr_stmt|;
name|current_screen
operator|->
name|contents
index|[
name|vpos
index|]
operator|=
name|temp
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|olen
condition|)
block|{
name|nsp
operator|=
operator|(
name|must_write_spaces
operator|||
name|new_screen
operator|->
name|highlight
index|[
name|vpos
index|]
operator|)
condition|?
literal|0
else|:
name|count_blanks
argument_list|(
name|nbody
argument_list|)
expr_stmt|;
if|if
condition|(
name|nlen
operator|>
name|nsp
condition|)
block|{
name|move_cursor
argument_list|(
name|vpos
argument_list|,
name|nsp
argument_list|)
expr_stmt|;
name|output_chars
argument_list|(
name|nbody
operator|+
name|nsp
argument_list|,
name|nlen
operator|-
name|nsp
argument_list|)
expr_stmt|;
block|}
comment|/* Exchange contents between current_screen and new_screen.  */
name|temp
operator|=
name|new_screen
operator|->
name|contents
index|[
name|vpos
index|]
expr_stmt|;
name|new_screen
operator|->
name|contents
index|[
name|vpos
index|]
operator|=
name|current_screen
operator|->
name|contents
index|[
name|vpos
index|]
expr_stmt|;
name|current_screen
operator|->
name|contents
index|[
name|vpos
index|]
operator|=
name|temp
expr_stmt|;
return|return;
block|}
name|obody
index|[
name|olen
index|]
operator|=
literal|1
expr_stmt|;
name|save
operator|=
name|nbody
index|[
name|nlen
index|]
expr_stmt|;
name|nbody
index|[
name|nlen
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Compute number of leading blanks in old and new contents.  */
name|osp
operator|=
name|count_blanks
argument_list|(
name|obody
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|new_screen
operator|->
name|highlight
index|[
name|vpos
index|]
condition|)
name|nsp
operator|=
name|count_blanks
argument_list|(
name|nbody
argument_list|)
expr_stmt|;
else|else
name|nsp
operator|=
literal|0
expr_stmt|;
comment|/* Compute number of matching chars starting with first nonblank.  */
name|begmatch
operator|=
name|count_match
argument_list|(
name|obody
operator|+
name|osp
argument_list|,
name|nbody
operator|+
name|nsp
argument_list|)
expr_stmt|;
comment|/* Spaces in new match implicit space past the end of old.  */
comment|/* A bug causing this to be a no-op was fixed in 18.29.  */
if|if
condition|(
operator|!
name|must_write_spaces
operator|&&
name|osp
operator|+
name|begmatch
operator|==
name|olen
condition|)
block|{
name|np1
operator|=
name|nbody
operator|+
name|nsp
expr_stmt|;
while|while
condition|(
name|np1
index|[
name|begmatch
index|]
operator|==
literal|' '
condition|)
name|begmatch
operator|++
expr_stmt|;
block|}
comment|/* Avoid doing insert/delete char      just cause number of leading spaces differs      when the following text does not match. */
if|if
condition|(
name|begmatch
operator|==
literal|0
operator|&&
name|osp
operator|!=
name|nsp
condition|)
name|osp
operator|=
name|nsp
operator|=
name|min
argument_list|(
name|osp
argument_list|,
name|nsp
argument_list|)
expr_stmt|;
comment|/* Find matching characters at end of line */
name|op1
operator|=
name|obody
operator|+
name|olen
expr_stmt|;
name|np1
operator|=
name|nbody
operator|+
name|nlen
expr_stmt|;
name|op2
operator|=
name|op1
operator|+
name|begmatch
operator|-
name|min
argument_list|(
name|olen
operator|-
name|osp
argument_list|,
name|nlen
operator|-
name|nsp
argument_list|)
expr_stmt|;
while|while
condition|(
name|op1
operator|>
name|op2
operator|&&
name|op1
index|[
operator|-
literal|1
index|]
operator|==
name|np1
index|[
operator|-
literal|1
index|]
condition|)
block|{
name|op1
operator|--
expr_stmt|;
name|np1
operator|--
expr_stmt|;
block|}
name|endmatch
operator|=
name|obody
operator|+
name|olen
operator|-
name|op1
expr_stmt|;
comment|/* Put correct value back in nbody[nlen].      This is important because direct_output_for_insert      can write into the line at a later point.  */
name|nbody
index|[
name|nlen
index|]
operator|=
name|save
expr_stmt|;
comment|/* tem gets the distance to insert or delete.      endmatch is how many characters we save by doing so.      Is it worth it?  */
name|tem
operator|=
operator|(
name|nlen
operator|-
name|nsp
operator|)
operator|-
operator|(
name|olen
operator|-
name|osp
operator|)
expr_stmt|;
if|if
condition|(
name|endmatch
operator|&&
name|tem
operator|&&
name|endmatch
operator|<=
name|DCICcost
index|[
name|tem
index|]
condition|)
name|endmatch
operator|=
literal|0
expr_stmt|;
comment|/* nsp - osp is the distance to insert or delete.      begmatch + endmatch is how much we save by doing so.      Is it worth it?  */
if|if
condition|(
name|begmatch
operator|+
name|endmatch
operator|>
literal|0
operator|&&
name|nsp
operator|!=
name|osp
operator|&&
name|begmatch
operator|+
name|endmatch
operator|<=
name|DCICcost
index|[
name|nsp
operator|-
name|osp
index|]
condition|)
block|{
name|begmatch
operator|=
literal|0
expr_stmt|;
name|endmatch
operator|=
literal|0
expr_stmt|;
name|osp
operator|=
name|nsp
operator|=
name|min
argument_list|(
name|osp
argument_list|,
name|nsp
argument_list|)
expr_stmt|;
block|}
comment|/* Now go through the line, inserting, writing and deleting as appropriate.  */
if|if
condition|(
name|osp
operator|>
name|nsp
condition|)
block|{
name|move_cursor
argument_list|(
name|vpos
argument_list|,
name|nsp
argument_list|)
expr_stmt|;
name|delete_chars
argument_list|(
name|osp
operator|-
name|nsp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nsp
operator|>
name|osp
condition|)
block|{
comment|/* If going to delete chars later in line 	 and insert earlier in the line, 	 must delete first to avoid losing data in the insert */
if|if
condition|(
name|endmatch
operator|&&
name|nlen
operator|<
name|olen
operator|+
name|nsp
operator|-
name|osp
condition|)
block|{
name|move_cursor
argument_list|(
name|vpos
argument_list|,
name|nlen
operator|-
name|endmatch
operator|+
name|osp
operator|-
name|nsp
argument_list|)
expr_stmt|;
name|delete_chars
argument_list|(
name|olen
operator|+
name|nsp
operator|-
name|osp
operator|-
name|nlen
argument_list|)
expr_stmt|;
name|olen
operator|=
name|nlen
operator|-
operator|(
name|nsp
operator|-
name|osp
operator|)
expr_stmt|;
block|}
name|move_cursor
argument_list|(
name|vpos
argument_list|,
name|osp
argument_list|)
expr_stmt|;
name|insert_chars
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|nsp
operator|-
name|osp
argument_list|)
expr_stmt|;
block|}
name|olen
operator|+=
name|nsp
operator|-
name|osp
expr_stmt|;
name|tem
operator|=
name|nsp
operator|+
name|begmatch
operator|+
name|endmatch
expr_stmt|;
if|if
condition|(
name|nlen
operator|!=
name|tem
operator|||
name|olen
operator|!=
name|tem
condition|)
block|{
name|move_cursor
argument_list|(
name|vpos
argument_list|,
name|nsp
operator|+
name|begmatch
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|endmatch
operator|||
name|nlen
operator|==
name|olen
condition|)
block|{
comment|/* If new text being written reaches right margin, 	     there is no need to do clear-to-eol at the end. 	     (and it would not be safe, since cursor is not 	     going to be "at the margin" after the text is done) */
if|if
condition|(
name|nlen
operator|==
name|screen_width
condition|)
name|olen
operator|=
literal|0
expr_stmt|;
name|output_chars
argument_list|(
name|nbody
operator|+
name|nsp
operator|+
name|begmatch
argument_list|,
name|nlen
operator|-
name|tem
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|obsolete
comment|/* the following code loses disastrously if tem == nlen.    Rather than trying to fix that case, I am trying the simpler    solution found above.  */
comment|/* If the text reaches to the right margin, 	     it will lose one way or another (depending on AutoWrap) 	     to clear to end of line after outputting all the text. 	     So pause with one character to go and clear the line then.  */
if|if
condition|(
name|nlen
operator|==
name|screen_width
operator|&&
name|fast_clear_end_of_line
operator|&&
name|olen
operator|>
name|nlen
condition|)
block|{
comment|/* endmatch must be zero, and tem must equal nsp + begmatch */
name|output_chars
argument_list|(
name|nbody
operator|+
name|tem
argument_list|,
name|nlen
operator|-
name|tem
operator|-
literal|1
argument_list|)
expr_stmt|;
name|clear_end_of_line
argument_list|(
name|olen
argument_list|)
expr_stmt|;
name|olen
operator|=
literal|0
expr_stmt|;
comment|/* Don't let it be cleared again later */
name|output_chars
argument_list|(
name|nbody
operator|+
name|nlen
operator|-
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|output_chars
argument_list|(
name|nbody
operator|+
name|nsp
operator|+
name|begmatch
argument_list|,
name|nlen
operator|-
name|tem
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|nlen
operator|>
name|olen
condition|)
block|{
name|output_chars
argument_list|(
name|nbody
operator|+
name|nsp
operator|+
name|begmatch
argument_list|,
name|olen
operator|-
name|tem
argument_list|)
expr_stmt|;
name|insert_chars
argument_list|(
name|nbody
operator|+
name|nsp
operator|+
name|begmatch
operator|+
name|olen
operator|-
name|tem
argument_list|,
name|nlen
operator|-
name|olen
argument_list|)
expr_stmt|;
name|olen
operator|=
name|nlen
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|olen
operator|>
name|nlen
condition|)
block|{
name|output_chars
argument_list|(
name|nbody
operator|+
name|nsp
operator|+
name|begmatch
argument_list|,
name|nlen
operator|-
name|tem
argument_list|)
expr_stmt|;
name|delete_chars
argument_list|(
name|olen
operator|-
name|nlen
argument_list|)
expr_stmt|;
name|olen
operator|=
name|nlen
expr_stmt|;
block|}
block|}
name|just_erase
label|:
comment|/* If any unerased characters remain after the new line, erase them.  */
if|if
condition|(
name|olen
operator|>
name|nlen
condition|)
block|{
name|move_cursor
argument_list|(
name|vpos
argument_list|,
name|nlen
argument_list|)
expr_stmt|;
name|clear_end_of_line
argument_list|(
name|olen
argument_list|)
expr_stmt|;
block|}
comment|/* Exchange contents between current_screen and new_screen.  */
name|temp
operator|=
name|new_screen
operator|->
name|contents
index|[
name|vpos
index|]
expr_stmt|;
name|new_screen
operator|->
name|contents
index|[
name|vpos
index|]
operator|=
name|current_screen
operator|->
name|contents
index|[
name|vpos
index|]
expr_stmt|;
name|current_screen
operator|->
name|contents
index|[
name|vpos
index|]
operator|=
name|temp
expr_stmt|;
block|}
end_block

begin_macro
name|count_blanks
argument_list|(
argument|str
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|str
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
init|=
name|str
decl_stmt|;
while|while
condition|(
operator|*
name|str
operator|++
operator|==
literal|' '
condition|)
empty_stmt|;
return|return
name|str
operator|-
name|p
operator|-
literal|1
return|;
block|}
end_block

begin_macro
name|count_match
argument_list|(
argument|str1
argument_list|,
argument|str2
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|str1
decl_stmt|,
modifier|*
name|str2
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p1
init|=
name|str1
decl_stmt|;
specifier|register
name|char
modifier|*
name|p2
init|=
name|str2
decl_stmt|;
while|while
condition|(
operator|*
name|p1
operator|++
operator|==
operator|*
name|p2
operator|++
condition|)
empty_stmt|;
return|return
name|p1
operator|-
name|str1
operator|-
literal|1
return|;
block|}
end_block

begin_escape
end_escape

begin_macro
name|DEFUN
argument_list|(
literal|"open-termscript"
argument_list|,
argument|Fopen_termscript
argument_list|,
argument|Sopen_termscript
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|"FOpen termscript file: "
argument_list|,
literal|"Start writing all terminal output to FILE as well as the terminal.\n\ FILE = nil means just close any termscript file currently open."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|file
operator|)
name|Lisp_Object
name|file
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|termscript
operator|!=
literal|0
condition|)
name|fclose
argument_list|(
name|termscript
argument_list|)
expr_stmt|;
name|termscript
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|file
argument_list|)
condition|)
block|{
name|file
operator|=
name|Fexpand_file_name
argument_list|(
name|file
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
name|termscript
operator|=
name|fopen
argument_list|(
name|XSTRING
argument_list|(
name|file
argument_list|)
operator|->
name|data
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|termscript
operator|==
literal|0
condition|)
name|report_file_error
argument_list|(
literal|"Opening termscript"
argument_list|,
name|Fcons
argument_list|(
name|file
argument_list|,
name|Qnil
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|Qnil
return|;
block|}
end_block

begin_escape
end_escape

begin_macro
name|DEFUN
argument_list|(
literal|"set-screen-height"
argument_list|,
argument|Fset_screen_height
argument_list|,
argument|Sset_screen_height
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"Tell redisplay that the screen has LINES lines.\n\ Optional second arg non-nil means that redisplay should use LINES lines\n\ but that the idea of the actual height of the screen should not be changed."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|n
operator|,
name|pretend
operator|)
name|Lisp_Object
name|n
operator|,
name|pretend
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|CHECK_NUMBER
argument_list|(
name|n
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|change_screen_size
argument_list|(
name|XINT
argument_list|(
name|n
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|!
name|NULL
argument_list|(
name|pretend
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|Qnil
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"set-screen-width"
argument_list|,
argument|Fset_screen_width
argument_list|,
argument|Sset_screen_width
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"Tell redisplay that the screen has COLS columns.\n\ Optional second arg non-nil means that redisplay should use COLS columns\n\ but that the idea of the actual width of the screen should not be changed."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|n
operator|,
name|pretend
operator|)
name|Lisp_Object
name|n
operator|,
name|pretend
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|CHECK_NUMBER
argument_list|(
name|n
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|change_screen_size
argument_list|(
literal|0
argument_list|,
name|XINT
argument_list|(
name|n
argument_list|)
argument_list|,
operator|!
name|NULL
argument_list|(
name|pretend
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|Qnil
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"screen-height"
argument_list|,
argument|Fscreen_height
argument_list|,
argument|Sscreen_height
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Return number of lines on screen available for display."
argument_list|)
end_macro

begin_expr_stmt
operator|(
operator|)
block|{
return|return
name|make_number
argument_list|(
name|screen_height
argument_list|)
return|;
block|}
end_expr_stmt

begin_macro
name|DEFUN
argument_list|(
literal|"screen-width"
argument_list|,
argument|Fscreen_width
argument_list|,
argument|Sscreen_width
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Return number of columns on screen available for display."
argument_list|)
end_macro

begin_expr_stmt
operator|(
operator|)
block|{
return|return
name|make_number
argument_list|(
name|screen_width
argument_list|)
return|;
block|}
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|SIGWINCH
end_ifdef

begin_macro
name|window_change_signal
argument_list|()
end_macro

begin_block
block|{
name|int
name|width
decl_stmt|,
name|height
decl_stmt|;
specifier|extern
name|int
name|errno
decl_stmt|;
name|int
name|old_errno
init|=
name|errno
decl_stmt|;
name|get_screen_size
argument_list|(
operator|&
name|width
argument_list|,
operator|&
name|height
argument_list|)
expr_stmt|;
comment|/* Record the new size, but don't reallocate the data structures now.      Let that be done later outside of the signal handler.  */
name|in_display
operator|++
expr_stmt|;
name|change_screen_size
argument_list|(
name|height
argument_list|,
name|width
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|in_display
operator|--
expr_stmt|;
name|signal
argument_list|(
name|SIGWINCH
argument_list|,
name|window_change_signal
argument_list|)
expr_stmt|;
name|errno
operator|=
name|old_errno
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SIGWINCH */
end_comment

begin_comment
comment|/* Do any change in screen size that was requested by a signal.  */
end_comment

begin_macro
name|do_pending_window_change
argument_list|()
end_macro

begin_block
block|{
comment|/* If change_screen_size should have run before, run it now.  */
while|while
condition|(
name|delayed_size_change
condition|)
block|{
name|int
name|newwidth
init|=
name|delayed_screen_width
decl_stmt|;
name|int
name|newheight
init|=
name|delayed_screen_height
decl_stmt|;
name|delayed_size_change
operator|=
literal|0
expr_stmt|;
name|change_screen_size_1
argument_list|(
name|newheight
argument_list|,
name|newwidth
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Change the screen height and/or width.  Values may be given as zero to    indicate no change is to take place.    PRETEND is normally 0; 1 means change used-size only    but don't change the size used for calculations;    -1 means don't redisplay.  */
end_comment

begin_expr_stmt
name|change_screen_size
argument_list|(
name|newlength
argument_list|,
name|newwidth
argument_list|,
name|pretend
argument_list|)
specifier|register
name|int
name|newlength
operator|,
name|newwidth
operator|,
name|pretend
expr_stmt|;
end_expr_stmt

begin_block
block|{
comment|/* If we can't deal with the change now, queue it for later.  */
if|if
condition|(
name|in_display
condition|)
block|{
name|delayed_screen_width
operator|=
name|newwidth
expr_stmt|;
name|delayed_screen_height
operator|=
name|newlength
expr_stmt|;
name|delayed_size_change
operator|=
literal|1
expr_stmt|;
return|return;
block|}
name|delayed_size_change
operator|=
literal|0
expr_stmt|;
name|change_screen_size_1
argument_list|(
name|newlength
argument_list|,
name|newwidth
argument_list|,
name|pretend
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|change_screen_size_1
argument_list|(
name|newlength
argument_list|,
name|newwidth
argument_list|,
name|pretend
argument_list|)
specifier|register
name|int
name|newlength
operator|,
name|newwidth
operator|,
name|pretend
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
operator|(
name|newlength
operator|==
literal|0
operator|||
name|newlength
operator|==
name|screen_height
operator|)
operator|&&
operator|(
name|newwidth
operator|==
literal|0
operator|||
name|newwidth
operator|==
name|screen_width
operator|)
condition|)
return|return;
if|if
condition|(
name|newlength
operator|&&
name|newlength
operator|!=
name|screen_height
condition|)
block|{
name|set_window_height
argument_list|(
name|XWINDOW
argument_list|(
name|minibuf_window
argument_list|)
operator|->
name|prev
argument_list|,
name|newlength
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|XFASTINT
argument_list|(
name|XWINDOW
argument_list|(
name|minibuf_window
argument_list|)
operator|->
name|top
argument_list|)
operator|=
name|newlength
operator|-
literal|1
expr_stmt|;
name|set_window_height
argument_list|(
name|minibuf_window
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|screen_height
operator|=
name|newlength
expr_stmt|;
if|if
condition|(
name|pretend
operator|<=
literal|0
condition|)
name|ScreenRows
operator|=
name|newlength
expr_stmt|;
name|set_terminal_window
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|newwidth
operator|&&
name|newwidth
operator|!=
name|screen_width
condition|)
block|{
name|set_window_width
argument_list|(
name|XWINDOW
argument_list|(
name|minibuf_window
argument_list|)
operator|->
name|prev
argument_list|,
name|newwidth
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_window_width
argument_list|(
name|minibuf_window
argument_list|,
name|newwidth
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|screen_width
operator|=
name|newwidth
expr_stmt|;
if|if
condition|(
name|pretend
operator|<=
literal|0
condition|)
name|ScreenCols
operator|=
name|newwidth
expr_stmt|;
block|}
name|remake_screen_structures
argument_list|()
expr_stmt|;
name|screen_garbaged
operator|=
literal|1
expr_stmt|;
name|calculate_costs
argument_list|()
expr_stmt|;
if|if
condition|(
name|pretend
operator|>=
literal|0
condition|)
name|redisplay_preserve_echo_area
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"baud-rate"
argument_list|,
argument|Fbaud_rate
argument_list|,
argument|Sbaud_rate
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Return the output baud rate of the terminal."
argument_list|)
end_macro

begin_expr_stmt
operator|(
operator|)
block|{
name|Lisp_Object
name|temp
block|;
name|XSET
argument_list|(
name|temp
argument_list|,
name|Lisp_Int
argument_list|,
name|baud_rate
argument_list|)
block|;
return|return
name|temp
return|;
block|}
end_expr_stmt

begin_escape
end_escape

begin_macro
name|DEFUN
argument_list|(
literal|"send-string-to-terminal"
argument_list|,
argument|Fsend_string_to_terminal
argument_list|,
argument|Ssend_string_to_terminal
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Send STRING to the terminal without alteration.\n\ Control characters in STRING will have terminal-dependent effects."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|str
operator|)
name|Lisp_Object
name|str
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|CHECK_STRING
argument_list|(
name|str
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fwrite
argument_list|(
name|XSTRING
argument_list|(
name|str
argument_list|)
operator|->
name|data
argument_list|,
literal|1
argument_list|,
name|XSTRING
argument_list|(
name|str
argument_list|)
operator|->
name|size
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|termscript
condition|)
block|{
name|fwrite
argument_list|(
name|XSTRING
argument_list|(
name|str
argument_list|)
operator|->
name|data
argument_list|,
literal|1
argument_list|,
name|XSTRING
argument_list|(
name|str
argument_list|)
operator|->
name|size
argument_list|,
name|termscript
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|termscript
argument_list|)
expr_stmt|;
block|}
return|return
name|Qnil
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"ding"
argument_list|,
argument|Fding
argument_list|,
argument|Sding
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Beep, or flash the screen.\n\ Terminates any keyboard macro currently executing unless an argument\n\ is given."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|arg
operator|)
name|Lisp_Object
name|arg
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|arg
argument_list|)
condition|)
block|{
name|bell
argument_list|()
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
else|else
name|bell
argument_list|()
expr_stmt|;
return|return
name|Qnil
return|;
block|}
end_block

begin_macro
name|bell
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|noninteractive
condition|)
name|putchar
argument_list|(
literal|07
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|FROM_KBD
condition|)
comment|/* Stop executing a keyboard macro. */
name|error
argument_list|(
literal|"Keyboard macro terminated by a command ringing the bell"
argument_list|)
expr_stmt|;
else|else
name|ring_bell
argument_list|()
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"sleep-for"
argument_list|,
argument|Fsleep_for
argument_list|,
argument|Ssleep_for
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Pause, without updating display, for ARG seconds."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|n
operator|)
name|Lisp_Object
name|n
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|t
decl_stmt|;
ifndef|#
directive|ifndef
name|subprocesses
ifdef|#
directive|ifdef
name|HAVE_TIMEVAL
name|struct
name|timeval
name|timeout
decl_stmt|,
name|end_time
decl_stmt|,
name|garbage1
decl_stmt|;
endif|#
directive|endif
comment|/* HAVE_TIMEVAL */
endif|#
directive|endif
comment|/* no subprocesses */
name|CHECK_NUMBER
argument_list|(
name|n
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t
operator|=
name|XINT
argument_list|(
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|<=
literal|0
condition|)
return|return
name|Qnil
return|;
ifdef|#
directive|ifdef
name|subprocesses
name|wait_reading_process_input
argument_list|(
name|t
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* No subprocesses */
name|immediate_quit
operator|=
literal|1
expr_stmt|;
name|QUIT
expr_stmt|;
ifdef|#
directive|ifdef
name|VMS
name|sys_sleep
argument_list|(
name|t
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* not VMS */
comment|/* The reason this is done this way      (rather than defined (H_S)&& defined (H_T))    is because the VMS preprocessor doesn't grok `defined' */
ifdef|#
directive|ifdef
name|HAVE_SELECT
ifdef|#
directive|ifdef
name|HAVE_TIMEVAL
name|gettimeofday
argument_list|(
operator|&
name|end_time
argument_list|,
operator|&
name|garbage1
argument_list|)
expr_stmt|;
name|end_time
operator|.
name|tv_sec
operator|+=
name|t
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|gettimeofday
argument_list|(
operator|&
name|timeout
argument_list|,
operator|&
name|garbage1
argument_list|)
expr_stmt|;
name|timeout
operator|.
name|tv_sec
operator|=
name|end_time
operator|.
name|tv_sec
operator|-
name|timeout
operator|.
name|tv_sec
expr_stmt|;
name|timeout
operator|.
name|tv_usec
operator|=
name|end_time
operator|.
name|tv_usec
operator|-
name|timeout
operator|.
name|tv_usec
expr_stmt|;
if|if
condition|(
name|timeout
operator|.
name|tv_usec
operator|<
literal|0
condition|)
name|timeout
operator|.
name|tv_usec
operator|+=
literal|1000000
operator|,
name|timeout
operator|.
name|tv_sec
operator|--
expr_stmt|;
if|if
condition|(
name|timeout
operator|.
name|tv_sec
operator|<
literal|0
condition|)
break|break;
if|if
condition|(
operator|!
name|select
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|timeout
argument_list|)
condition|)
break|break;
block|}
else|#
directive|else
comment|/* not HAVE_TIMEVAL */
comment|/* Is it safe to quit out of `sleep'?  I'm afraid to trust it.  */
name|sleep
argument_list|(
name|t
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_TIMEVAL */
else|#
directive|else
comment|/* not HAVE_SELECT */
name|sleep
argument_list|(
name|t
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_SELECT */
endif|#
directive|endif
comment|/* not VMS */
name|immediate_quit
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* no subprocesses */
return|return
name|Qnil
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"sit-for"
argument_list|,
argument|Fsit_for
argument_list|,
argument|Ssit_for
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"Perform redisplay, then wait for ARG seconds or until input is available.\n\ Optional second arg non-nil means don't redisplay.\n\ Redisplay is preempted as always if input arrives, and does not happen\n\ if input is available before it starts.\n\ Value is t if waited the full time with no input arriving."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|n
operator|,
name|nodisp
operator|)
name|Lisp_Object
name|n
operator|,
name|nodisp
expr_stmt|;
end_expr_stmt

begin_block
block|{
ifndef|#
directive|ifndef
name|subprocesses
ifdef|#
directive|ifdef
name|HAVE_TIMEVAL
name|struct
name|timeval
name|timeout
decl_stmt|;
else|#
directive|else
name|int
name|timeout_sec
decl_stmt|;
endif|#
directive|endif
name|int
name|waitchannels
decl_stmt|;
endif|#
directive|endif
comment|/* no subprocesses */
name|CHECK_NUMBER
argument_list|(
name|n
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|detect_input_pending
argument_list|()
condition|)
return|return
name|Qnil
return|;
if|if
condition|(
name|EQ
argument_list|(
name|nodisp
argument_list|,
name|Qnil
argument_list|)
condition|)
name|redisplay_preserve_echo_area
argument_list|()
expr_stmt|;
if|if
condition|(
name|XINT
argument_list|(
name|n
argument_list|)
operator|>
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|subprocesses
ifdef|#
directive|ifdef
name|SIGIO
name|gobble_input
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* SIGIO */
name|wait_reading_process_input
argument_list|(
name|XINT
argument_list|(
name|n
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* no subprocesses */
name|immediate_quit
operator|=
literal|1
expr_stmt|;
name|QUIT
expr_stmt|;
name|waitchannels
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|VMS
name|input_wait_timeout
argument_list|(
name|XINT
argument_list|(
name|n
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* not VMS */
ifndef|#
directive|ifndef
name|HAVE_TIMEVAL
name|timeout_sec
operator|=
name|XINT
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|select
argument_list|(
literal|1
argument_list|,
operator|&
name|waitchannels
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|timeout_sec
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* HAVE_TIMEVAL */
name|timeout
operator|.
name|tv_sec
operator|=
name|XINT
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|timeout
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|select
argument_list|(
literal|1
argument_list|,
operator|&
name|waitchannels
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|timeout
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_TIMEVAL */
endif|#
directive|endif
comment|/* not VMS */
name|immediate_quit
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* no subprocesses */
block|}
return|return
name|detect_input_pending
argument_list|()
condition|?
name|Qnil
else|:
name|Qt
return|;
block|}
end_block

begin_escape
end_escape

begin_decl_stmt
name|char
modifier|*
name|terminal_type
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Initialization done when Emacs fork is started, before doing stty. */
end_comment

begin_comment
comment|/* Determine terminal type and set terminal_driver */
end_comment

begin_comment
comment|/* Then invoke its decoding routine to set up variables   in the terminal package */
end_comment

begin_macro
name|init_display
argument_list|()
end_macro

begin_block
block|{
ifdef|#
directive|ifdef
name|HAVE_X_WINDOWS
specifier|extern
name|Lisp_Object
name|Vxterm
decl_stmt|;
name|Vxterm
operator|=
name|Qnil
expr_stmt|;
endif|#
directive|endif
name|Vwindow_system
operator|=
name|Qnil
expr_stmt|;
name|meta_key
operator|=
literal|0
expr_stmt|;
name|inverse_video
operator|=
literal|0
expr_stmt|;
name|cursor_in_echo_area
operator|=
literal|0
expr_stmt|;
name|terminal_type
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|inhibit_window_system
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_X_WINDOWS
specifier|extern
name|char
modifier|*
name|alternate_display
decl_stmt|;
name|char
modifier|*
name|disp
init|=
operator|(
name|char
operator|*
operator|)
name|egetenv
argument_list|(
literal|"DISPLAY"
argument_list|)
decl_stmt|;
comment|/* Note KSH likes to provide an empty string as an envvar value.  */
if|if
condition|(
name|alternate_display
operator|||
operator|(
name|disp
operator|&&
operator|*
name|disp
operator|)
condition|)
block|{
name|x_term_init
argument_list|()
expr_stmt|;
name|Vxterm
operator|=
name|Qt
expr_stmt|;
name|Vwindow_system
operator|=
name|intern
argument_list|(
literal|"x"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|X11
name|Vwindow_system_version
operator|=
name|make_number
argument_list|(
literal|11
argument_list|)
expr_stmt|;
else|#
directive|else
name|Vwindow_system_version
operator|=
name|make_number
argument_list|(
literal|10
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|term_init_done
goto|;
block|}
endif|#
directive|endif
comment|/* HAVE_X_WINDOWS */
empty_stmt|;
block|}
comment|/* Record we aren't using a window system.  */
name|inhibit_window_system
operator|=
literal|1
expr_stmt|;
comment|/* Look at the TERM variable */
name|terminal_type
operator|=
operator|(
name|char
operator|*
operator|)
name|getenv
argument_list|(
literal|"TERM"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|terminal_type
condition|)
block|{
ifdef|#
directive|ifdef
name|VMS
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Please specify your terminal type.\n\ For types defined in VMS, use  set term /device=TYPE.\n\ For types not defined in VMS, use  define emacs_term \"TYPE\".\n\ \(The quotation marks are necessary since terminal types are lower case.)\n"
argument_list|)
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Please set the environment variable TERM; see tset(1).\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|term_init
argument_list|(
name|terminal_type
argument_list|)
expr_stmt|;
name|term_init_done
label|:
name|remake_screen_structures
argument_list|()
expr_stmt|;
name|calculate_costs
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGWINCH
ifndef|#
directive|ifndef
name|CANNOT_DUMP
if|if
condition|(
name|initialized
condition|)
endif|#
directive|endif
comment|/* CANNOT_DUMP */
if|if
condition|(
name|inhibit_window_system
condition|)
name|signal
argument_list|(
name|SIGWINCH
argument_list|,
name|window_change_signal
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SIGWINCH */
block|}
end_block

begin_escape
end_escape

begin_macro
name|syms_of_display
argument_list|()
end_macro

begin_block
block|{
name|defsubr
argument_list|(
operator|&
name|Sopen_termscript
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sding
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Ssit_for
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sscreen_height
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sscreen_width
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sset_screen_height
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sset_screen_width
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Ssleep_for
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sbaud_rate
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Ssend_string_to_terminal
argument_list|)
expr_stmt|;
name|DEFVAR_BOOL
argument_list|(
literal|"inverse-video"
argument_list|,
operator|&
name|inverse_video
argument_list|,
literal|"*Non-nil means use inverse-video."
argument_list|)
expr_stmt|;
name|DEFVAR_BOOL
argument_list|(
literal|"visible-bell"
argument_list|,
operator|&
name|visible_bell
argument_list|,
literal|"*Non-nil means try to flash the screen to represent a bell."
argument_list|)
expr_stmt|;
name|DEFVAR_BOOL
argument_list|(
literal|"no-redraw-on-reenter"
argument_list|,
operator|&
name|no_redraw_on_reenter
argument_list|,
literal|"*Non-nil means no need to redraw entire screen after suspending.\n\ It is up to you to set this variable to inform Emacs."
argument_list|)
expr_stmt|;
name|DEFVAR_LISP
argument_list|(
literal|"window-system"
argument_list|,
operator|&
name|Vwindow_system
argument_list|,
literal|"A symbol naming the window-system under which Emacs is running,\n\ \(such as `x'), or nil if emacs is running on an ordinary terminal."
argument_list|)
expr_stmt|;
name|DEFVAR_LISP
argument_list|(
literal|"window-system-version"
argument_list|,
operator|&
name|Vwindow_system_version
argument_list|,
literal|"Version number of the window system Emacs is running under."
argument_list|)
expr_stmt|;
name|DEFVAR_BOOL
argument_list|(
literal|"cursor-in-echo-area"
argument_list|,
operator|&
name|cursor_in_echo_area
argument_list|,
literal|"Non-nil means put cursor in minibuffer after any message displayed there."
argument_list|)
expr_stmt|;
comment|/* Initialize `window-system', unless init_display already decided it.  */
ifdef|#
directive|ifdef
name|CANNOT_DUMP
if|if
condition|(
name|noninteractive
condition|)
endif|#
directive|endif
block|{
name|Vwindow_system_version
operator|=
name|Qnil
expr_stmt|;
name|Vwindow_system
operator|=
name|Qnil
expr_stmt|;
block|}
block|}
end_block

end_unit

