begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Lisp functions for making directory listings.    Copyright (C) 1985, 1986 Free Software Foundation, Inc.  This file is part of GNU Emacs.  GNU Emacs is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version.  GNU Emacs is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU Emacs; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|SYSV_SYSTEM_DIR
end_ifdef

begin_include
include|#
directive|include
file|<dirent.h>
end_include

begin_define
define|#
directive|define
name|DIRENTRY
value|struct dirent
end_define

begin_define
define|#
directive|define
name|NAMLEN
parameter_list|(
name|p
parameter_list|)
value|strlen (p->d_name)
end_define

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|NONSYSTEM_DIR_LIBRARY
end_ifdef

begin_include
include|#
directive|include
file|"ndir.h"
end_include

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* not NONSYSTEM_DIR_LIBRARY */
end_comment

begin_include
include|#
directive|include
file|<sys/dir.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not NONSYSTEM_DIR_LIBRARY */
end_comment

begin_define
define|#
directive|define
name|DIRENTRY
value|struct direct
end_define

begin_define
define|#
directive|define
name|NAMLEN
parameter_list|(
name|p
parameter_list|)
value|p->d_namlen
end_define

begin_function_decl
specifier|extern
name|DIR
modifier|*
name|opendir
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|struct
name|direct
modifier|*
name|readdir
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_undef
undef|#
directive|undef
name|NULL
end_undef

begin_include
include|#
directive|include
file|"lisp.h"
end_include

begin_include
include|#
directive|include
file|"buffer.h"
end_include

begin_include
include|#
directive|include
file|"commands.h"
end_include

begin_include
include|#
directive|include
file|"regex.h"
end_include

begin_define
define|#
directive|define
name|min
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)< (b) ? (a) : (b))
end_define

begin_comment
comment|/* if system does not have symbolic links, it does not have lstat.    In that case, use ordinary stat instead.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|S_IFLNK
end_ifndef

begin_define
define|#
directive|define
name|lstat
value|stat
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|Lisp_Object
name|Vcompletion_ignored_extensions
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Lisp_Object
name|Qcompletion_ignore_case
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_macro
name|DEFUN
argument_list|(
literal|"directory-files"
argument_list|,
argument|Fdirectory_files
argument_list|,
argument|Sdirectory_files
argument_list|,
literal|1
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|,
literal|"Return a list of names of files in DIRECTORY.\n\ If FULL is non-NIL, absolute pathnames of the files are returned.\n\ If MATCH is non-NIL, only pathnames containing that regexp are returned."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|dirname
operator|,
name|full
operator|,
name|match
operator|)
name|Lisp_Object
name|dirname
operator|,
name|full
operator|,
name|match
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|DIR
modifier|*
name|d
decl_stmt|;
name|char
name|slashfilename
index|[
name|MAXNAMLEN
operator|+
literal|2
index|]
decl_stmt|;
name|char
modifier|*
name|filename
init|=
name|slashfilename
decl_stmt|;
name|int
name|length
decl_stmt|;
name|Lisp_Object
name|list
decl_stmt|,
name|name
decl_stmt|;
comment|/* In search.c */
specifier|extern
name|struct
name|re_pattern_buffer
name|searchbuf
decl_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|match
argument_list|)
condition|)
block|{
name|CHECK_STRING
argument_list|(
name|match
argument_list|,
literal|3
argument_list|)
expr_stmt|;
comment|/* Compile it now so we don't get an error after opendir */
ifdef|#
directive|ifdef
name|VMS
name|compile_pattern
argument_list|(
name|match
argument_list|,
operator|&
name|searchbuf
argument_list|,
operator|(
name|char
operator|*
operator|)
name|downcase_table
argument_list|)
expr_stmt|;
else|#
directive|else
name|compile_pattern
argument_list|(
name|match
argument_list|,
operator|&
name|searchbuf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|dirname
operator|=
name|Fexpand_file_name
argument_list|(
name|dirname
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|d
operator|=
name|opendir
argument_list|(
name|XSTRING
argument_list|(
name|Fdirectory_file_name
argument_list|(
name|dirname
argument_list|)
argument_list|)
operator|->
name|data
argument_list|)
operator|)
condition|)
name|report_file_error
argument_list|(
literal|"Opening directory"
argument_list|,
name|Fcons
argument_list|(
name|dirname
argument_list|,
name|Qnil
argument_list|)
argument_list|)
expr_stmt|;
name|list
operator|=
name|Qnil
expr_stmt|;
name|length
operator|=
name|XSTRING
argument_list|(
name|dirname
argument_list|)
operator|->
name|size
expr_stmt|;
ifndef|#
directive|ifndef
name|VMS
if|if
condition|(
name|length
operator|==
literal|0
operator|||
name|XSTRING
argument_list|(
name|dirname
argument_list|)
operator|->
name|data
index|[
name|length
operator|-
literal|1
index|]
operator|!=
literal|'/'
condition|)
operator|*
name|filename
operator|++
operator|=
literal|'/'
expr_stmt|;
endif|#
directive|endif
comment|/* VMS */
comment|/* Loop reading blocks */
while|while
condition|(
literal|1
condition|)
block|{
name|DIRENTRY
modifier|*
name|dp
init|=
name|readdir
argument_list|(
name|d
argument_list|)
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
operator|!
name|dp
condition|)
break|break;
name|len
operator|=
name|NAMLEN
argument_list|(
name|dp
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|d_ino
condition|)
block|{
name|strncpy
argument_list|(
name|filename
argument_list|,
name|dp
operator|->
name|d_name
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|filename
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|NULL
argument_list|(
name|match
argument_list|)
operator|||
operator|(
literal|0
operator|<=
name|re_search
argument_list|(
operator|&
name|searchbuf
argument_list|,
name|filename
argument_list|,
name|len
argument_list|,
literal|0
argument_list|,
name|len
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|full
argument_list|)
condition|)
name|name
operator|=
name|concat2
argument_list|(
name|dirname
argument_list|,
name|build_string
argument_list|(
name|slashfilename
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|name
operator|=
name|build_string
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|list
operator|=
name|Fcons
argument_list|(
name|name
argument_list|,
name|list
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|closedir
argument_list|(
name|d
argument_list|)
expr_stmt|;
return|return
name|Fsort
argument_list|(
name|Fnreverse
argument_list|(
name|list
argument_list|)
argument_list|,
name|Qstring_lessp
argument_list|)
return|;
block|}
end_block

begin_escape
end_escape

begin_function_decl
name|Lisp_Object
name|file_name_completion
parameter_list|()
function_decl|;
end_function_decl

begin_macro
name|DEFUN
argument_list|(
literal|"file-name-completion"
argument_list|,
argument|Ffile_name_completion
argument_list|,
argument|Sfile_name_completion
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"Complete file name FILE in directory DIR.\n\ Returns the longest string common to all filenames in DIR\n\ that start with FILE.\n\ If there is only one and FILE matches it exactly, returns t.\n\ Returns nil if DIR contains no name starting with FILE."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|file
operator|,
name|dirname
operator|)
name|Lisp_Object
name|file
operator|,
name|dirname
expr_stmt|;
end_expr_stmt

begin_block
block|{
comment|/* Don't waste time trying to complete a null string.      Besides, this case happens when user is being asked for      a directory name and has supplied one ending in a /.      We would not want to add anything in that case      even if there are some unique characters in that directory.  */
if|if
condition|(
name|XTYPE
argument_list|(
name|file
argument_list|)
operator|==
name|Lisp_String
operator|&&
name|XSTRING
argument_list|(
name|file
argument_list|)
operator|->
name|size
operator|==
literal|0
condition|)
return|return
name|file
return|;
return|return
name|file_name_completion
argument_list|(
name|file
argument_list|,
name|dirname
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_block

begin_macro
name|DEFUN
argument_list|(
literal|"file-name-all-completions"
argument_list|,
argument|Ffile_name_all_completions
argument_list|,
argument|Sfile_name_all_completions
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"Return a list of all completions of file name FILE in directory DIR."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|file
operator|,
name|dirname
operator|)
name|Lisp_Object
name|file
operator|,
name|dirname
expr_stmt|;
end_expr_stmt

begin_block
block|{
return|return
name|file_name_completion
argument_list|(
name|file
argument_list|,
name|dirname
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|VMS
end_ifdef

begin_macro
name|DEFUN
argument_list|(
literal|"file-name-all-versions"
argument_list|,
argument|Ffile_name_all_versions
argument_list|,
argument|Sfile_name_all_versions
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"Return a list of all versions of file name FILE in directory DIR."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|file
operator|,
name|dirname
operator|)
name|Lisp_Object
name|file
operator|,
name|dirname
expr_stmt|;
end_expr_stmt

begin_block
block|{
return|return
name|file_name_completion
argument_list|(
name|file
argument_list|,
name|dirname
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* VMS */
end_comment

begin_function
name|Lisp_Object
name|file_name_completion
parameter_list|(
name|file
parameter_list|,
name|dirname
parameter_list|,
name|all_flag
parameter_list|,
name|ver_flag
parameter_list|)
name|Lisp_Object
name|file
decl_stmt|,
name|dirname
decl_stmt|;
name|int
name|all_flag
decl_stmt|,
name|ver_flag
decl_stmt|;
block|{
name|DIR
modifier|*
name|d
decl_stmt|;
name|DIRENTRY
modifier|*
name|dp
decl_stmt|;
name|int
name|bestmatchsize
decl_stmt|,
name|skip
decl_stmt|;
specifier|register
name|int
name|compare
decl_stmt|,
name|matchsize
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
name|int
name|matchcount
init|=
literal|0
decl_stmt|;
name|Lisp_Object
name|bestmatch
decl_stmt|,
name|tem
decl_stmt|,
name|elt
decl_stmt|,
name|name
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
name|int
name|directoryp
decl_stmt|;
name|int
name|passcount
decl_stmt|;
name|int
name|count
init|=
name|specpdl_ptr
operator|-
name|specpdl
decl_stmt|;
ifdef|#
directive|ifdef
name|VMS
specifier|extern
name|DIRENTRY
modifier|*
name|readdirver
parameter_list|()
function_decl|;
name|DIRENTRY
argument_list|*
operator|(
call|(
modifier|*
name|readfunc
call|)
argument_list|()
operator|)
argument_list|;
comment|/* Filename completion on VMS ignores case, since VMS filesys does.  */
name|specbind
argument_list|(
name|Qcompletion_ignore_case
argument_list|,
name|Qt
argument_list|)
argument_list|;
name|readfunc
operator|=
name|readdir
argument_list|;   if
operator|(
name|ver_flag
operator|)
name|readfunc
operator|=
name|readdirver
argument_list|;
name|file
operator|=
name|Fupcase
argument_list|(
name|file
argument_list|)
argument_list|;
endif|#
directive|endif
comment|/* VMS */
name|CHECK_STRING
argument_list|(
name|file
argument_list|,
literal|0
argument_list|)
argument_list|;
name|dirname
operator|=
name|Fexpand_file_name
argument_list|(
name|dirname
argument_list|,
name|Qnil
argument_list|)
argument_list|;
name|bestmatch
operator|=
name|Qnil
argument_list|;
comment|/* passcount = 0, ignore files that end in an ignored extension.      If nothing found then try again with passcount = 1, don't ignore them.      If looking for all completions, start with passcount = 1,      so always take even the ignored ones.  */
argument_list|for
operator|(
name|passcount
operator|=
operator|!
operator|!
name|all_flag
expr|;
name|NULL
argument_list|(
name|bestmatch
argument_list|)
operator|&&
name|passcount
operator|<
literal|2
expr|;
name|passcount
operator|++
operator|)
block|{
if|if
condition|(
operator|!
operator|(
name|d
operator|=
name|opendir
argument_list|(
name|XSTRING
argument_list|(
name|Fdirectory_file_name
argument_list|(
name|dirname
argument_list|)
argument_list|)
operator|->
name|data
argument_list|)
operator|)
condition|)
name|report_file_error
argument_list|(
literal|"Opening directory"
argument_list|,
name|Fcons
argument_list|(
name|dirname
argument_list|,
name|Qnil
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Loop reading blocks */
comment|/* (att3b compiler bug requires do a null comparison this way) */
while|while
condition|(
literal|1
condition|)
block|{
name|DIRENTRY
modifier|*
name|dp
decl_stmt|;
name|int
name|len
decl_stmt|;
ifdef|#
directive|ifdef
name|VMS
name|dp
operator|=
call|(
modifier|*
name|readfunc
call|)
argument_list|(
name|d
argument_list|)
expr_stmt|;
else|#
directive|else
name|dp
operator|=
name|readdir
argument_list|(
name|d
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|dp
condition|)
break|break;
name|len
operator|=
name|NAMLEN
argument_list|(
name|dp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NULL
argument_list|(
name|Vquit_flag
argument_list|)
operator|&&
name|NULL
argument_list|(
name|Vinhibit_quit
argument_list|)
condition|)
goto|goto
name|quit
goto|;
if|if
condition|(
operator|!
name|dp
operator|->
name|d_ino
operator|||
name|len
operator|<
name|XSTRING
argument_list|(
name|file
argument_list|)
operator|->
name|size
operator|||
literal|0
operator|<=
name|scmp
argument_list|(
name|dp
operator|->
name|d_name
argument_list|,
name|XSTRING
argument_list|(
name|file
argument_list|)
operator|->
name|data
argument_list|,
name|XSTRING
argument_list|(
name|file
argument_list|)
operator|->
name|size
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|file_name_completion_stat
argument_list|(
name|dirname
argument_list|,
name|dp
argument_list|,
operator|&
name|st
argument_list|)
operator|<
literal|0
condition|)
continue|continue;
name|directoryp
operator|=
operator|(
operator|(
name|st
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|==
name|S_IFDIR
operator|)
expr_stmt|;
name|tem
operator|=
name|Qnil
expr_stmt|;
if|if
condition|(
operator|!
name|directoryp
condition|)
block|{
comment|/* Compare extensions-to-be-ignored against end of this file name */
comment|/* if name is not an exact match against specified string */
if|if
condition|(
operator|!
name|passcount
operator|&&
name|len
operator|>
name|XSTRING
argument_list|(
name|file
argument_list|)
operator|->
name|size
condition|)
comment|/* and exit this for loop if a match is found */
for|for
control|(
name|tem
operator|=
name|Vcompletion_ignored_extensions
init|;
name|CONSP
argument_list|(
name|tem
argument_list|)
condition|;
name|tem
operator|=
name|XCONS
argument_list|(
name|tem
argument_list|)
operator|->
name|cdr
control|)
block|{
name|elt
operator|=
name|XCONS
argument_list|(
name|tem
argument_list|)
operator|->
name|car
expr_stmt|;
if|if
condition|(
name|XTYPE
argument_list|(
name|elt
argument_list|)
operator|!=
name|Lisp_String
condition|)
continue|continue;
name|skip
operator|=
name|len
operator|-
name|XSTRING
argument_list|(
name|elt
argument_list|)
operator|->
name|size
expr_stmt|;
if|if
condition|(
name|skip
operator|<
literal|0
condition|)
continue|continue;
if|if
condition|(
literal|0
operator|<=
name|scmp
argument_list|(
name|dp
operator|->
name|d_name
operator|+
name|skip
argument_list|,
name|XSTRING
argument_list|(
name|elt
argument_list|)
operator|->
name|data
argument_list|,
name|XSTRING
argument_list|(
name|elt
argument_list|)
operator|->
name|size
argument_list|)
condition|)
continue|continue;
break|break;
block|}
block|}
comment|/* Unless an ignored-extensions match was found,              process this name as a completion */
if|if
condition|(
name|passcount
operator|||
operator|!
name|CONSP
argument_list|(
name|tem
argument_list|)
condition|)
block|{
comment|/* Update computation of how much all possible completions match */
name|matchcount
operator|++
expr_stmt|;
if|if
condition|(
name|all_flag
operator|||
name|NULL
argument_list|(
name|bestmatch
argument_list|)
condition|)
block|{
comment|/* This is a possible completion */
if|if
condition|(
name|directoryp
condition|)
block|{
comment|/* This completion is a directory; make it end with '/' */
name|name
operator|=
name|Ffile_name_as_directory
argument_list|(
name|make_string
argument_list|(
name|dp
operator|->
name|d_name
argument_list|,
name|len
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|name
operator|=
name|make_string
argument_list|(
name|dp
operator|->
name|d_name
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|all_flag
condition|)
block|{
name|bestmatch
operator|=
name|Fcons
argument_list|(
name|name
argument_list|,
name|bestmatch
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bestmatch
operator|=
name|name
expr_stmt|;
name|bestmatchsize
operator|=
name|XSTRING
argument_list|(
name|name
argument_list|)
operator|->
name|size
expr_stmt|;
block|}
block|}
else|else
block|{
name|compare
operator|=
name|min
argument_list|(
name|bestmatchsize
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|p1
operator|=
name|XSTRING
argument_list|(
name|bestmatch
argument_list|)
operator|->
name|data
expr_stmt|;
name|p2
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|dp
operator|->
name|d_name
expr_stmt|;
name|matchsize
operator|=
name|scmp
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|,
name|compare
argument_list|)
expr_stmt|;
if|if
condition|(
name|matchsize
operator|<
literal|0
condition|)
name|matchsize
operator|=
name|compare
expr_stmt|;
comment|/* If this dirname all matches, 		     see if implicit following slash does too.  */
if|if
condition|(
name|directoryp
operator|&&
name|compare
operator|==
name|matchsize
operator|&&
name|bestmatchsize
operator|>
name|matchsize
operator|&&
name|p1
index|[
name|matchsize
index|]
operator|==
literal|'/'
condition|)
name|matchsize
operator|++
expr_stmt|;
name|bestmatchsize
operator|=
name|min
argument_list|(
name|matchsize
argument_list|,
name|bestmatchsize
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|closedir
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|unbind_to
argument_list|(
name|count
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|all_flag
operator|||
name|NULL
argument_list|(
name|bestmatch
argument_list|)
condition|)
return|return
name|bestmatch
return|;
end_if

begin_if
if|if
condition|(
name|matchcount
operator|==
literal|1
operator|&&
name|bestmatchsize
operator|==
name|XSTRING
argument_list|(
name|file
argument_list|)
operator|->
name|size
condition|)
return|return
name|Qt
return|;
end_if

begin_return
return|return
name|Fsubstring
argument_list|(
name|bestmatch
argument_list|,
name|make_number
argument_list|(
literal|0
argument_list|)
argument_list|,
name|make_number
argument_list|(
name|bestmatchsize
argument_list|)
argument_list|)
return|;
end_return

begin_label
name|quit
label|:
end_label

begin_if
if|if
condition|(
name|d
condition|)
name|closedir
argument_list|(
name|d
argument_list|)
expr_stmt|;
end_if

begin_expr_stmt
name|Vquit_flag
operator|=
name|Qnil
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|Fsignal
argument_list|(
name|Qquit
argument_list|,
name|Qnil
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  file_name_completion_stat
operator|(
name|dirname
operator|,
name|dp
operator|,
name|st_addr
operator|)
name|Lisp_Object
name|dirname
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|DIRENTRY
modifier|*
name|dp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|stat
modifier|*
name|st_addr
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|len
init|=
name|NAMLEN
argument_list|(
name|dp
argument_list|)
decl_stmt|;
name|int
name|pos
init|=
name|XSTRING
argument_list|(
name|dirname
argument_list|)
operator|->
name|size
decl_stmt|;
name|char
modifier|*
name|fullname
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|len
operator|+
name|pos
operator|+
literal|2
argument_list|)
decl_stmt|;
name|bcopy
argument_list|(
name|XSTRING
argument_list|(
name|dirname
argument_list|)
operator|->
name|data
argument_list|,
name|fullname
argument_list|,
name|pos
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|VMS
if|if
condition|(
name|fullname
index|[
name|pos
operator|-
literal|1
index|]
operator|!=
literal|'/'
condition|)
name|fullname
index|[
name|pos
operator|++
index|]
operator|=
literal|'/'
expr_stmt|;
endif|#
directive|endif
name|bcopy
argument_list|(
name|dp
operator|->
name|d_name
argument_list|,
name|fullname
operator|+
name|pos
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|fullname
index|[
name|pos
operator|+
name|len
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|stat
argument_list|(
name|fullname
argument_list|,
name|st_addr
argument_list|)
return|;
block|}
end_block

begin_escape
end_escape

begin_function
name|Lisp_Object
name|make_time
parameter_list|(
name|time
parameter_list|)
name|int
name|time
decl_stmt|;
block|{
return|return
name|Fcons
argument_list|(
name|make_number
argument_list|(
name|time
operator|>>
literal|16
argument_list|)
argument_list|,
name|Fcons
argument_list|(
name|make_number
argument_list|(
name|time
operator|&
literal|0177777
argument_list|)
argument_list|,
name|Qnil
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_macro
name|DEFUN
argument_list|(
literal|"file-attributes"
argument_list|,
argument|Ffile_attributes
argument_list|,
argument|Sfile_attributes
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Return a list of attributes of file FILENAME.\n\ Value is nil if specified file cannot be opened.\n\ Otherwise, list elements are:\n\  0. t for directory, string (name linked to) for symbolic link, or nil.\n\  1. Number of links to file.\n\  2. File uid.\n\  3. File gid.\n\  4. Last access time, as a list of two integers.\n\   First integer has high-order 16 bits of time, second has low 16 bits.\n\  5. Last modification time, likewise.\n\  6. Last status change time, likewise.\n\  7. Size in bytes.\n\  8. File modes, as a string of ten letters or dashes as in ls -l.\n\  9. t iff file's gid would change if file were deleted and recreated.\n\ 10. inode number.\n\ \n\ If file does not exists, returns nil."
argument_list|)
end_macro

begin_expr_stmt
operator|(
name|filename
operator|)
name|Lisp_Object
name|filename
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|Lisp_Object
name|values
index|[
literal|11
index|]
decl_stmt|;
name|Lisp_Object
name|dirname
decl_stmt|;
name|struct
name|stat
name|s
decl_stmt|;
name|struct
name|stat
name|sdir
decl_stmt|;
name|char
name|modes
index|[
literal|10
index|]
decl_stmt|;
name|filename
operator|=
name|Fexpand_file_name
argument_list|(
name|filename
argument_list|,
name|Qnil
argument_list|)
expr_stmt|;
if|if
condition|(
name|lstat
argument_list|(
name|XSTRING
argument_list|(
name|filename
argument_list|)
operator|->
name|data
argument_list|,
operator|&
name|s
argument_list|)
operator|<
literal|0
condition|)
return|return
name|Qnil
return|;
switch|switch
condition|(
name|s
operator|.
name|st_mode
operator|&
name|S_IFMT
condition|)
block|{
default|default:
name|values
index|[
literal|0
index|]
operator|=
name|Qnil
expr_stmt|;
break|break;
case|case
name|S_IFDIR
case|:
name|values
index|[
literal|0
index|]
operator|=
name|Qt
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|S_IFLNK
case|case
name|S_IFLNK
case|:
name|values
index|[
literal|0
index|]
operator|=
name|Ffile_symlink_p
argument_list|(
name|filename
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
block|}
name|values
index|[
literal|1
index|]
operator|=
name|make_number
argument_list|(
name|s
operator|.
name|st_nlink
argument_list|)
expr_stmt|;
name|values
index|[
literal|2
index|]
operator|=
name|make_number
argument_list|(
name|s
operator|.
name|st_uid
argument_list|)
expr_stmt|;
name|values
index|[
literal|3
index|]
operator|=
name|make_number
argument_list|(
name|s
operator|.
name|st_gid
argument_list|)
expr_stmt|;
name|values
index|[
literal|4
index|]
operator|=
name|make_time
argument_list|(
name|s
operator|.
name|st_atime
argument_list|)
expr_stmt|;
name|values
index|[
literal|5
index|]
operator|=
name|make_time
argument_list|(
name|s
operator|.
name|st_mtime
argument_list|)
expr_stmt|;
name|values
index|[
literal|6
index|]
operator|=
name|make_time
argument_list|(
name|s
operator|.
name|st_ctime
argument_list|)
expr_stmt|;
comment|/* perhaps we should set this to most-positive-fixnum if it is too large? */
name|values
index|[
literal|7
index|]
operator|=
name|make_number
argument_list|(
operator|(
name|int
operator|)
name|s
operator|.
name|st_size
argument_list|)
expr_stmt|;
name|filemodestring
argument_list|(
operator|&
name|s
argument_list|,
name|modes
argument_list|)
expr_stmt|;
name|values
index|[
literal|8
index|]
operator|=
name|make_string
argument_list|(
name|modes
argument_list|,
literal|10
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BSD4_3
comment|/* Gross kludge to avoid lack of "#if defined(...)" in VMS */
define|#
directive|define
name|BSD4_2
comment|/* A new meaning to the term `backwards compatability' */
endif|#
directive|endif
ifdef|#
directive|ifdef
name|BSD4_2
comment|/* file gid will be dir gid */
name|dirname
operator|=
name|Ffile_name_directory
argument_list|(
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|dirname
operator|!=
name|Qnil
operator|&&
name|stat
argument_list|(
name|XSTRING
argument_list|(
name|dirname
argument_list|)
operator|->
name|data
argument_list|,
operator|&
name|sdir
argument_list|)
operator|==
literal|0
condition|)
name|values
index|[
literal|9
index|]
operator|=
operator|(
name|sdir
operator|.
name|st_gid
operator|!=
name|s
operator|.
name|st_gid
operator|)
condition|?
name|Qt
else|:
name|Qnil
expr_stmt|;
else|else
comment|/* if we can't tell, assume worst */
name|values
index|[
literal|9
index|]
operator|=
name|Qt
expr_stmt|;
else|#
directive|else
comment|/* file gid will be egid */
name|values
index|[
literal|9
index|]
operator|=
operator|(
name|s
operator|.
name|st_gid
operator|!=
name|getegid
argument_list|()
operator|)
condition|?
name|Qt
else|:
name|Qnil
expr_stmt|;
endif|#
directive|endif
comment|/* BSD4_2 (or BSD4_3) */
ifdef|#
directive|ifdef
name|BSD4_3
undef|#
directive|undef
name|BSD4_2
comment|/* ok, you can look again without throwing up */
endif|#
directive|endif
name|values
index|[
literal|10
index|]
operator|=
name|make_number
argument_list|(
name|s
operator|.
name|st_ino
argument_list|)
expr_stmt|;
return|return
name|Flist
argument_list|(
literal|11
argument_list|,
name|values
argument_list|)
return|;
block|}
end_block

begin_escape
end_escape

begin_macro
name|syms_of_dired
argument_list|()
end_macro

begin_block
block|{
name|defsubr
argument_list|(
operator|&
name|Sdirectory_files
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sfile_name_completion
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|VMS
name|defsubr
argument_list|(
operator|&
name|Sfile_name_all_versions
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* VMS */
name|defsubr
argument_list|(
operator|&
name|Sfile_name_all_completions
argument_list|)
expr_stmt|;
name|defsubr
argument_list|(
operator|&
name|Sfile_attributes
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|VMS
name|Qcompletion_ignore_case
operator|=
name|intern
argument_list|(
literal|"completion-ignore-case"
argument_list|)
expr_stmt|;
name|staticpro
argument_list|(
operator|&
name|Qcompletion_ignore_case
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* VMS */
name|DEFVAR_LISP
argument_list|(
literal|"completion-ignored-extensions"
argument_list|,
operator|&
name|Vcompletion_ignored_extensions
argument_list|,
literal|"*Completion ignores filenames ending in any string in this list."
argument_list|)
expr_stmt|;
name|Vcompletion_ignored_extensions
operator|=
name|Qnil
expr_stmt|;
block|}
end_block

end_unit

