begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Output like sprintf to a buffer of specified size.    Also takes args differently: pass one pointer to an array of strings    in addition to the format string which is separate.    Copyright (C) 1985 Free Software Foundation, Inc.  This file is part of GNU Emacs.  GNU Emacs is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version.  GNU Emacs is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU Emacs; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_macro
name|doprnt
argument_list|(
argument|buffer
argument_list|,
argument|bufsize
argument_list|,
argument|format
argument_list|,
argument|nargs
argument_list|,
argument|args
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|buffer
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|int
name|bufsize
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|format
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nargs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|args
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|cnt
init|=
literal|0
decl_stmt|;
comment|/* Number of arg to gobble next */
specifier|register
name|char
modifier|*
name|fmt
init|=
name|format
decl_stmt|;
comment|/* Pointer into format string */
specifier|register
name|char
modifier|*
name|bufptr
init|=
name|buffer
decl_stmt|;
comment|/* Pointer into output buffer.. */
name|char
name|tembuf
index|[
literal|80
index|]
decl_stmt|;
specifier|register
name|int
name|tem
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
name|char
name|fmtcpy
index|[
literal|20
index|]
decl_stmt|;
name|int
name|minlen
decl_stmt|;
name|bufsize
operator|--
expr_stmt|;
while|while
condition|(
operator|*
name|fmt
operator|&&
name|bufsize
operator|>
literal|0
condition|)
comment|/* Loop until end of format string or buffer full */
block|{
if|if
condition|(
operator|*
name|fmt
operator|==
literal|'%'
condition|)
comment|/* Check for a '%' character */
block|{
name|fmt
operator|++
expr_stmt|;
comment|/* Copy this one %-spec into fmtcopy.  */
name|string
operator|=
name|fmtcpy
expr_stmt|;
operator|*
name|string
operator|++
operator|=
literal|'%'
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
operator|*
name|string
operator|++
operator|=
operator|*
name|fmt
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|fmt
operator|>=
literal|'0'
operator|&&
operator|*
name|fmt
operator|<=
literal|'9'
operator|)
operator|&&
operator|*
name|fmt
operator|!=
literal|'-'
operator|&&
operator|*
name|fmt
operator|!=
literal|' '
condition|)
break|break;
name|fmt
operator|++
expr_stmt|;
block|}
operator|*
name|string
operator|=
literal|0
expr_stmt|;
name|minlen
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
operator|*
name|fmt
operator|++
condition|)
block|{
default|default:
name|error
argument_list|(
literal|"Invalid format operation %%%c"
argument_list|,
name|fmt
index|[
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
case|case
literal|'b'
case|:
case|case
literal|'d'
case|:
case|case
literal|'o'
case|:
case|case
literal|'x'
case|:
if|if
condition|(
name|cnt
operator|==
name|nargs
condition|)
name|error
argument_list|(
literal|"Format string wants too many arguments"
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|tembuf
argument_list|,
name|fmtcpy
argument_list|,
name|args
index|[
name|cnt
operator|++
index|]
argument_list|)
expr_stmt|;
comment|/* Now copy tembuf into final output, truncating as nec.  */
name|string
operator|=
name|tembuf
expr_stmt|;
goto|goto
name|doit
goto|;
case|case
literal|'s'
case|:
if|if
condition|(
name|cnt
operator|==
name|nargs
condition|)
name|error
argument_list|(
literal|"Format string wants too many arguments"
argument_list|)
expr_stmt|;
name|string
operator|=
name|args
index|[
name|cnt
operator|++
index|]
expr_stmt|;
if|if
condition|(
name|fmtcpy
index|[
literal|1
index|]
operator|!=
literal|'s'
condition|)
name|minlen
operator|=
name|atoi
argument_list|(
operator|&
name|fmtcpy
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* Copy string into final output, truncating if no room.  */
name|doit
label|:
name|tem
operator|=
name|strlen
argument_list|(
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|minlen
operator|>
literal|0
condition|)
block|{
while|while
condition|(
name|minlen
operator|>
name|tem
operator|&&
name|bufsize
operator|>
literal|0
condition|)
block|{
operator|*
name|bufptr
operator|++
operator|=
literal|' '
expr_stmt|;
name|bufsize
operator|--
expr_stmt|;
name|minlen
operator|--
expr_stmt|;
block|}
name|minlen
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|tem
operator|>
name|bufsize
condition|)
name|tem
operator|=
name|bufsize
expr_stmt|;
name|strncpy
argument_list|(
name|bufptr
argument_list|,
name|string
argument_list|,
name|tem
argument_list|)
expr_stmt|;
name|bufptr
operator|+=
name|tem
expr_stmt|;
name|bufsize
operator|-=
name|tem
expr_stmt|;
if|if
condition|(
name|minlen
operator|<
literal|0
condition|)
block|{
while|while
condition|(
name|minlen
operator|<
operator|-
name|tem
operator|&&
name|bufsize
operator|>
literal|0
condition|)
block|{
operator|*
name|bufptr
operator|++
operator|=
literal|' '
expr_stmt|;
name|bufsize
operator|--
expr_stmt|;
name|minlen
operator|++
expr_stmt|;
block|}
name|minlen
operator|=
literal|0
expr_stmt|;
block|}
continue|continue;
case|case
literal|'c'
case|:
if|if
condition|(
name|cnt
operator|==
name|nargs
condition|)
name|error
argument_list|(
literal|"Format string wants too many arguments"
argument_list|)
expr_stmt|;
operator|*
name|bufptr
operator|++
operator|=
operator|(
name|int
operator|)
name|args
index|[
name|cnt
operator|++
index|]
expr_stmt|;
name|bufsize
operator|--
expr_stmt|;
continue|continue;
case|case
literal|'%'
case|:
name|fmt
operator|--
expr_stmt|;
comment|/* Drop thru and this % will be treated as normal */
block|}
block|}
operator|*
name|bufptr
operator|++
operator|=
operator|*
name|fmt
operator|++
expr_stmt|;
comment|/* Just some characters; Copy 'em */
name|bufsize
operator|--
expr_stmt|;
block|}
empty_stmt|;
operator|*
name|bufptr
operator|=
literal|0
expr_stmt|;
comment|/* Make sure our string end with a '\0' */
return|return
name|bufptr
operator|-
name|buffer
return|;
block|}
end_block

end_unit

