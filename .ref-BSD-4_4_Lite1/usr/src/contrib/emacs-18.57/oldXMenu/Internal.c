begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|<X11/copyright.h>
end_include

begin_comment
comment|/* $Header: Internal.c,v 1.12 87/12/20 12:05:22 rws Exp $ */
end_comment

begin_comment
comment|/* Copyright    Massachusetts Institute of Technology    1985	*/
end_comment

begin_comment
comment|/*  * XMenu:	MIT Project Athena, X Window system menu package  *  * 	XMenuInternal.c - XMenu internal (not user visable) routines.  *  *	Author:		Tony Della Fera, DEC  *			November, 1985  *  */
end_comment

begin_include
include|#
directive|include
file|"XMenuInt.h"
end_include

begin_comment
comment|/*  * Toggle color macro.  */
end_comment

begin_define
define|#
directive|define
name|toggle_color
parameter_list|(
name|x
parameter_list|)
define|\
value|((x) == menu->bkgnd_color ? menu->s_frg_color : menu->bkgnd_color)
end_define

begin_comment
comment|/*  * Internal Window creation queue sizes.  */
end_comment

begin_define
define|#
directive|define
name|S_QUE_SIZE
value|300
end_define

begin_define
define|#
directive|define
name|P_QUE_SIZE
value|20
end_define

begin_define
define|#
directive|define
name|BUFFER_SIZE
value|(S_QUE_SIZE>= P_QUE_SIZE ? S_QUE_SIZE : P_QUE_SIZE)
end_define

begin_comment
comment|/*  * XMWinQue - Internal window creation queue datatype.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|_xmwinquedef
block|{
name|int
name|sq_size
decl_stmt|;
name|XMSelect
modifier|*
name|sq
index|[
name|S_QUE_SIZE
index|]
decl_stmt|;
name|XMSelect
modifier|*
modifier|*
name|sq_ptr
decl_stmt|;
name|int
name|pq_size
decl_stmt|;
name|XMPane
modifier|*
name|pq
index|[
name|P_QUE_SIZE
index|]
decl_stmt|;
name|XMPane
modifier|*
modifier|*
name|pq_ptr
decl_stmt|;
block|}
name|XMWinQue
typedef|;
end_typedef

begin_comment
comment|/*  * _XMWinQue - Internal static window creation queue.  */
end_comment

begin_decl_stmt
specifier|static
name|Bool
name|_XMWinQueIsInit
init|=
name|False
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|XMWinQue
name|_XMWinQue
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * _XMErrorCode - Global XMenu error code.  */
end_comment

begin_decl_stmt
name|int
name|_XMErrorCode
init|=
name|XME_NO_ERROR
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * _XMErrorList - Global XMenu error code discription strings.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|_XMErrorList
index|[
name|XME_CODE_COUNT
index|]
init|=
block|{
literal|"No error"
block|,
comment|/* XME_NO_ERROR */
literal|"Menu not initialized"
block|,
comment|/* XME_NOT_INIT */
literal|"Argument out of bounds"
block|,
comment|/* XME_ARG_BOUNDS */
literal|"Pane not found"
block|,
comment|/* XME_P_NOT_FOUND */
literal|"Selection not found"
block|,
comment|/* XME_S_NOT_FOUND */
literal|"Invalid menu style parameter"
block|,
comment|/* XME_STYLE_PARAM */
literal|"Unable to grab mouse"
block|,
comment|/* XME_GRAB_MOUSE */
literal|"Unable to interpret locator"
block|,
comment|/* XME_INTERP_LOC */
literal|"Unable to calloc memory"
block|,
comment|/* XME_CALLOC */
literal|"Unable to create XAssocTable"
block|,
comment|/* XME_CREATE_ASSOC */
literal|"Unable to store bitmap"
block|,
comment|/* XME_STORE_BITMAP */
literal|"Unable to make tile pixmaps"
block|,
comment|/* XME_MAKE_TILES */
literal|"Unable to make pixmap"
block|,
comment|/* XME_MAKE_PIXMAP */
literal|"Unable to create cursor"
block|,
comment|/* XME_CREATE_CURSOR */
literal|"Unable to open font"
block|,
comment|/* XME_OPEN_FONT */
literal|"Unable to create windows"
block|,
comment|/* XME_CREATE_WINDOW */
literal|"Unable to create transparencies"
block|,
comment|/* XME_CREATE_TRANSP */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * _XMEventHandler - Internal event handler variable.  */
end_comment

begin_function_decl
name|int
function_decl|(
modifier|*
name|_XMEventHandler
function_decl|)
parameter_list|()
init|=
name|NULL
function_decl|;
end_function_decl

begin_comment
comment|/*  * _XMWinQueInit - Internal routine to initialize the window  *		   queue.  */
end_comment

begin_macro
name|_XMWinQueInit
argument_list|()
end_macro

begin_block
block|{
comment|/*      * If the queue is not initialized initialize it.      */
if|if
condition|(
operator|!
name|_XMWinQueIsInit
condition|)
block|{
comment|/* 	 * Blank the queue structure. 	 */
name|bzero
argument_list|(
operator|&
name|_XMWinQue
argument_list|,
sizeof|sizeof
argument_list|(
name|XMWinQue
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize the next free location pointers. 	 */
name|_XMWinQue
operator|.
name|sq_ptr
operator|=
name|_XMWinQue
operator|.
name|sq
expr_stmt|;
name|_XMWinQue
operator|.
name|pq_ptr
operator|=
name|_XMWinQue
operator|.
name|pq
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * _XMWinQueAddPane - Internal routine to add a pane to the pane  *		      window queue.  */
end_comment

begin_function
name|int
name|_XMWinQueAddPane
parameter_list|(
name|display
parameter_list|,
name|menu
parameter_list|,
name|p_ptr
parameter_list|)
specifier|register
name|Display
modifier|*
name|display
decl_stmt|;
specifier|register
name|XMenu
modifier|*
name|menu
decl_stmt|;
comment|/* Menu being manipulated. */
specifier|register
name|XMPane
modifier|*
name|p_ptr
decl_stmt|;
comment|/* XMPane being queued. */
block|{
comment|/*      * If the queue is currently full then flush it.      */
if|if
condition|(
name|_XMWinQue
operator|.
name|pq_size
operator|==
name|P_QUE_SIZE
condition|)
block|{
if|if
condition|(
name|_XMWinQueFlush
argument_list|(
name|display
argument_list|,
name|menu
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|==
name|_FAILURE
condition|)
return|return
operator|(
name|_FAILURE
operator|)
return|;
block|}
comment|/*      * Insert the new XMPane pointer and increment the queue pointer      * and the queue size.      */
operator|*
name|_XMWinQue
operator|.
name|pq_ptr
operator|=
name|p_ptr
expr_stmt|;
name|_XMWinQue
operator|.
name|pq_ptr
operator|++
expr_stmt|;
name|_XMWinQue
operator|.
name|pq_size
operator|++
expr_stmt|;
comment|/*      * All went well, return successfully.      */
name|_XMErrorCode
operator|=
name|XME_NO_ERROR
expr_stmt|;
return|return
operator|(
name|_SUCCESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * _XMWinQueAddSelection - Internal routine to add a selection to  *			   the selection window queue.  */
end_comment

begin_function
name|int
name|_XMWinQueAddSelection
parameter_list|(
name|display
parameter_list|,
name|menu
parameter_list|,
name|s_ptr
parameter_list|)
specifier|register
name|Display
modifier|*
name|display
decl_stmt|;
specifier|register
name|XMenu
modifier|*
name|menu
decl_stmt|;
comment|/* Menu being manipulated. */
specifier|register
name|XMSelect
modifier|*
name|s_ptr
decl_stmt|;
comment|/* XMSelection being queued. */
block|{
comment|/*      * If this entry will overflow the queue then flush it.      */
if|if
condition|(
name|_XMWinQue
operator|.
name|sq_size
operator|==
name|S_QUE_SIZE
condition|)
block|{
if|if
condition|(
name|_XMWinQueFlush
argument_list|(
name|display
argument_list|,
name|menu
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|==
name|_FAILURE
condition|)
return|return
operator|(
name|_FAILURE
operator|)
return|;
block|}
comment|/*      * Insert the new XMSelect pointer and increment the queue pointer      * and the queue size.      */
operator|*
name|_XMWinQue
operator|.
name|sq_ptr
operator|=
name|s_ptr
expr_stmt|;
name|_XMWinQue
operator|.
name|sq_ptr
operator|++
expr_stmt|;
name|_XMWinQue
operator|.
name|sq_size
operator|++
expr_stmt|;
comment|/*      * All went well, return successfully.      */
name|_XMErrorCode
operator|=
name|XME_NO_ERROR
expr_stmt|;
return|return
operator|(
name|_SUCCESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * _XMWinQueFlush - Internal routine to flush the pane and  *		    selection window queues.  */
end_comment

begin_function
name|int
name|_XMWinQueFlush
parameter_list|(
name|display
parameter_list|,
name|menu
parameter_list|,
name|pane
parameter_list|,
name|select
parameter_list|)
specifier|register
name|Display
modifier|*
name|display
decl_stmt|;
specifier|register
name|XMenu
modifier|*
name|menu
decl_stmt|;
comment|/* Menu being manipulated. */
specifier|register
name|XMPane
modifier|*
name|pane
decl_stmt|;
comment|/* Current pane. */
block|{
specifier|register
name|int
name|pq_index
decl_stmt|;
comment|/* Pane queue index. */
specifier|register
name|int
name|sq_index
decl_stmt|;
comment|/* Selection queue index. */
specifier|register
name|XMPane
modifier|*
name|p_ptr
decl_stmt|;
comment|/* XMPane pointer. */
specifier|register
name|XMSelect
modifier|*
name|s_ptr
decl_stmt|;
comment|/* XMSelect pointer. */
name|unsigned
name|long
name|valuemask
decl_stmt|;
comment|/* Which attributes to set. */
name|XSetWindowAttributes
modifier|*
name|attributes
decl_stmt|;
comment|/* Attributes to be set. */
comment|/*      * If the pane window queue is not empty...      */
if|if
condition|(
name|_XMWinQue
operator|.
name|pq_size
operator|>
literal|0
condition|)
block|{
comment|/* 	 * set up attributes for pane window to be created. 	 */
name|valuemask
operator|=
operator|(
name|CWBackPixmap
operator||
name|CWBorderPixel
operator||
name|CWOverrideRedirect
operator|)
expr_stmt|;
name|attributes
operator|=
operator|(
name|XSetWindowAttributes
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|XSetWindowAttributes
argument_list|)
argument_list|)
expr_stmt|;
name|attributes
operator|->
name|border_pixel
operator|=
name|menu
operator|->
name|p_bdr_color
expr_stmt|;
name|attributes
operator|->
name|background_pixmap
operator|=
name|menu
operator|->
name|inact_pixmap
expr_stmt|;
name|attributes
operator|->
name|override_redirect
operator|=
name|True
expr_stmt|;
comment|/* 	 * Create all the pending panes in order, so that the 	 * current pane will be on top, with the others 	 * stacked appropriately under it. 	 */
for|for
control|(
name|pq_index
operator|=
name|_XMWinQue
operator|.
name|pq_size
operator|-
literal|1
init|;
name|pq_index
operator|>=
literal|0
condition|;
name|pq_index
operator|--
control|)
block|{
name|p_ptr
operator|=
name|_XMWinQue
operator|.
name|pq
index|[
name|pq_index
index|]
expr_stmt|;
comment|/* Retrieve next pane. */
if|if
condition|(
name|p_ptr
operator|==
name|pane
condition|)
break|break;
name|p_ptr
operator|->
name|window
operator|=
name|XCreateWindow
argument_list|(
name|display
argument_list|,
name|menu
operator|->
name|parent
argument_list|,
name|p_ptr
operator|->
name|window_x
argument_list|,
name|p_ptr
operator|->
name|window_y
argument_list|,
name|p_ptr
operator|->
name|window_w
argument_list|,
name|p_ptr
operator|->
name|window_h
argument_list|,
name|menu
operator|->
name|p_bdr_width
argument_list|,
name|CopyFromParent
argument_list|,
name|InputOutput
argument_list|,
name|CopyFromParent
argument_list|,
name|valuemask
argument_list|,
name|attributes
argument_list|)
expr_stmt|;
name|XMakeAssoc
argument_list|(
name|display
argument_list|,
name|menu
operator|->
name|assoc_tab
argument_list|,
name|p_ptr
operator|->
name|window
argument_list|,
name|p_ptr
argument_list|)
expr_stmt|;
name|XSelectInput
argument_list|(
name|display
argument_list|,
name|p_ptr
operator|->
name|window
argument_list|,
name|menu
operator|->
name|p_events
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|pq_index
operator|=
literal|0
init|;
name|pq_index
operator|<
name|_XMWinQue
operator|.
name|pq_size
condition|;
name|pq_index
operator|++
control|)
block|{
name|p_ptr
operator|=
name|_XMWinQue
operator|.
name|pq
index|[
name|pq_index
index|]
expr_stmt|;
comment|/* Retrieve next pane. */
name|p_ptr
operator|->
name|window
operator|=
name|XCreateWindow
argument_list|(
name|display
argument_list|,
name|menu
operator|->
name|parent
argument_list|,
name|p_ptr
operator|->
name|window_x
argument_list|,
name|p_ptr
operator|->
name|window_y
argument_list|,
name|p_ptr
operator|->
name|window_w
argument_list|,
name|p_ptr
operator|->
name|window_h
argument_list|,
name|menu
operator|->
name|p_bdr_width
argument_list|,
name|CopyFromParent
argument_list|,
name|InputOutput
argument_list|,
name|CopyFromParent
argument_list|,
name|valuemask
argument_list|,
name|attributes
argument_list|)
expr_stmt|;
name|XMakeAssoc
argument_list|(
name|display
argument_list|,
name|menu
operator|->
name|assoc_tab
argument_list|,
name|p_ptr
operator|->
name|window
argument_list|,
name|p_ptr
argument_list|)
expr_stmt|;
name|XSelectInput
argument_list|(
name|display
argument_list|,
name|p_ptr
operator|->
name|window
argument_list|,
name|menu
operator|->
name|p_events
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_ptr
operator|==
name|pane
condition|)
break|break;
block|}
comment|/* 	 * Reset the pane queue pointer and size. 	 */
name|_XMWinQue
operator|.
name|pq_size
operator|=
literal|0
expr_stmt|;
name|_XMWinQue
operator|.
name|pq_ptr
operator|=
name|_XMWinQue
operator|.
name|pq
expr_stmt|;
block|}
comment|/*      * If the selection window queue is not empty...      */
if|if
condition|(
name|_XMWinQue
operator|.
name|sq_size
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|sq_index
operator|=
literal|0
init|;
name|sq_index
operator|<
name|_XMWinQue
operator|.
name|sq_size
condition|;
name|sq_index
operator|++
control|)
block|{
comment|/* 	     * Retrieve the XMSelect pointer. 	     */
name|s_ptr
operator|=
name|_XMWinQue
operator|.
name|sq
index|[
name|sq_index
index|]
expr_stmt|;
name|s_ptr
operator|->
name|window
operator|=
name|XCreateWindow
argument_list|(
name|display
argument_list|,
name|s_ptr
operator|->
name|parent_p
operator|->
name|window
argument_list|,
name|s_ptr
operator|->
name|window_x
argument_list|,
name|s_ptr
operator|->
name|window_y
argument_list|,
name|s_ptr
operator|->
name|window_w
argument_list|,
name|s_ptr
operator|->
name|window_h
argument_list|,
literal|0
argument_list|,
comment|/* border width*/
name|CopyFromParent
argument_list|,
name|InputOnly
argument_list|,
name|CopyFromParent
argument_list|,
literal|0
argument_list|,
name|attributes
argument_list|)
expr_stmt|;
comment|/* 	     * Insert the new window id and its 	     * associated XMSelect structure into the  	     * assoction table. 	     */
name|XMakeAssoc
argument_list|(
name|display
argument_list|,
name|menu
operator|->
name|assoc_tab
argument_list|,
name|s_ptr
operator|->
name|window
argument_list|,
name|s_ptr
argument_list|)
expr_stmt|;
name|XSelectInput
argument_list|(
name|display
argument_list|,
name|s_ptr
operator|->
name|window
argument_list|,
name|menu
operator|->
name|s_events
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Reset the selection queue pointer and size. 	 */
name|_XMWinQue
operator|.
name|sq_size
operator|=
literal|0
expr_stmt|;
name|_XMWinQue
operator|.
name|sq_ptr
operator|=
name|_XMWinQue
operator|.
name|sq
expr_stmt|;
block|}
comment|/*      * Flush X's internal queues.      */
name|XFlush
argument_list|(
name|display
argument_list|)
expr_stmt|;
comment|/*      * All went well, return successfully.      */
name|_XMErrorCode
operator|=
name|XME_NO_ERROR
expr_stmt|;
return|return
operator|(
name|_SUCCESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * _XMGetPanePtr - 	Given a menu pointer and a pane index number, return  *			a pane pointer that points to the indexed pane.  */
end_comment

begin_function
name|XMPane
modifier|*
name|_XMGetPanePtr
parameter_list|(
name|menu
parameter_list|,
name|p_num
parameter_list|)
specifier|register
name|XMenu
modifier|*
name|menu
decl_stmt|;
comment|/* Menu to find the pane in. */
specifier|register
name|int
name|p_num
decl_stmt|;
comment|/* Index number of pane to find. */
block|{
specifier|register
name|XMPane
modifier|*
name|p_ptr
decl_stmt|;
comment|/* Pane pointer to be returned. */
specifier|register
name|int
name|i
decl_stmt|;
comment|/* Loop counter. */
comment|/*      * Is the pane number out of range?      */
if|if
condition|(
operator|(
name|p_num
operator|<
literal|0
operator|)
operator|||
operator|(
name|p_num
operator|>
operator|(
name|menu
operator|->
name|p_count
operator|-
literal|1
operator|)
operator|)
condition|)
block|{
name|_XMErrorCode
operator|=
name|XME_P_NOT_FOUND
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/*      * Find the right pane.      */
name|p_ptr
operator|=
name|menu
operator|->
name|p_list
operator|->
name|next
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p_num
condition|;
name|i
operator|++
control|)
name|p_ptr
operator|=
name|p_ptr
operator|->
name|next
expr_stmt|;
comment|/*      * Return successfully.      */
name|_XMErrorCode
operator|=
name|XME_NO_ERROR
expr_stmt|;
return|return
operator|(
name|p_ptr
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * _XMGetSelectionPtr -	Given pane pointer and a selection index number,  *			return a selection pointer that points to the  *			indexed selection.  */
end_comment

begin_function
name|XMSelect
modifier|*
name|_XMGetSelectionPtr
parameter_list|(
name|p_ptr
parameter_list|,
name|s_num
parameter_list|)
specifier|register
name|XMPane
modifier|*
name|p_ptr
decl_stmt|;
comment|/* Pane to find the selection in. */
specifier|register
name|int
name|s_num
decl_stmt|;
comment|/* Index number of the selection to find. */
block|{
specifier|register
name|XMSelect
modifier|*
name|s_ptr
decl_stmt|;
comment|/* Selection pointer to be returned. */
specifier|register
name|int
name|i
decl_stmt|;
comment|/* Loop counter. *./          /*      * Is the selection number out of range?      */
if|if
condition|(
operator|(
name|s_num
operator|<
literal|0
operator|)
operator|||
operator|(
name|s_num
operator|>
operator|(
name|p_ptr
operator|->
name|s_count
operator|-
literal|1
operator|)
operator|)
condition|)
block|{
name|_XMErrorCode
operator|=
name|XME_S_NOT_FOUND
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/*      * Find the right selection.      */
name|s_ptr
operator|=
name|p_ptr
operator|->
name|s_list
operator|->
name|next
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|s_num
condition|;
name|i
operator|++
control|)
name|s_ptr
operator|=
name|s_ptr
operator|->
name|next
expr_stmt|;
comment|/*      * Return successfully.      */
name|_XMErrorCode
operator|=
name|XME_NO_ERROR
expr_stmt|;
return|return
operator|(
name|s_ptr
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * _XMRecomputeGlobals - Internal subroutine to recompute menu wide  *			 global values.  */
end_comment

begin_expr_stmt
name|_XMRecomputeGlobals
argument_list|(
name|display
argument_list|,
name|menu
argument_list|)
specifier|register
name|Display
operator|*
name|display
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*X11 display variable. */
end_comment

begin_decl_stmt
specifier|register
name|XMenu
modifier|*
name|menu
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Menu object to compute from. */
end_comment

begin_block
block|{
specifier|register
name|XMPane
modifier|*
name|p_ptr
decl_stmt|;
comment|/* Pane pointer. */
specifier|register
name|XMSelect
modifier|*
name|s_ptr
decl_stmt|;
comment|/* Selection pointer. */
specifier|register
name|int
name|max_p_label
init|=
literal|0
decl_stmt|;
comment|/* Maximum pane label width. */
specifier|register
name|int
name|max_s_label
init|=
literal|0
decl_stmt|;
comment|/* Maximum selection label width. */
specifier|register
name|int
name|s_count
init|=
literal|0
decl_stmt|;
comment|/* Maximum selection count. */
name|int
name|p_s_pad
decl_stmt|;
comment|/* Pane<-> selection padding. */
name|int
name|p_s_diff
decl_stmt|;
comment|/* Pane<-> selection seperation. */
name|int
name|p_height
decl_stmt|;
comment|/* Pane window height. */
name|int
name|p_width
decl_stmt|;
comment|/* Pane window width. */
name|int
name|s_width
decl_stmt|;
comment|/* Selection window width. */
name|int
name|screen
decl_stmt|;
comment|/* DefaultScreen holder. */
comment|/*      * For each pane...      */
for|for
control|(
name|p_ptr
operator|=
name|menu
operator|->
name|p_list
operator|->
name|next
init|;
name|p_ptr
operator|!=
name|menu
operator|->
name|p_list
condition|;
name|p_ptr
operator|=
name|p_ptr
operator|->
name|next
control|)
block|{
comment|/* 	 * Recompute maximum pane label width. 	 */
name|max_p_label
operator|=
name|max
argument_list|(
name|max_p_label
argument_list|,
name|p_ptr
operator|->
name|label_width
argument_list|)
expr_stmt|;
comment|/* 	 * Recompute maximum selection count.  	 */
name|s_count
operator|=
name|max
argument_list|(
name|s_count
argument_list|,
name|p_ptr
operator|->
name|s_count
argument_list|)
expr_stmt|;
comment|/* 	 * For each selection in the current pane... 	 */
for|for
control|(
name|s_ptr
operator|=
name|p_ptr
operator|->
name|s_list
operator|->
name|next
init|;
name|s_ptr
operator|!=
name|p_ptr
operator|->
name|s_list
condition|;
name|s_ptr
operator|=
name|s_ptr
operator|->
name|next
control|)
block|{
comment|/* 	     * Recompute maximum selection label width. 	     */
name|max_s_label
operator|=
name|max
argument_list|(
name|max_s_label
argument_list|,
name|s_ptr
operator|->
name|label_width
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*      * Recompute pane height.      */
name|p_height
operator|=
operator|(
name|menu
operator|->
name|flag_height
operator|<<
literal|1
operator|)
operator|+
operator|(
name|menu
operator|->
name|s_y_off
operator|*
name|s_count
operator|)
expr_stmt|;
comment|/*      * Recompute horizontal padding between the pane window and the      * selection windows.      */
name|p_s_pad
operator|=
name|menu
operator|->
name|p_x_off
operator|<<
literal|1
expr_stmt|;
comment|/*      * Recompute pane and selection window widths.      * This is done by first computing the window sizes from the maximum      * label widths.  If the spacing between the selection window and the      * containing pane window is less than the pane selection padding value      * (twice the pane X offset) then change the size of the pane to be      * the size of the selection window plus the padding.  If, however the      * spacing between the selection window and the containing pane window      * is more than the pane selection padding value increase the size of      * the selection to its maximum possible value (the pane width minus      * the pane selection padding value).      */
name|p_width
operator|=
name|max_p_label
operator|+
name|p_s_pad
expr_stmt|;
name|s_width
operator|=
name|max_s_label
operator|+
operator|(
name|menu
operator|->
name|s_fnt_pad
operator|<<
literal|1
operator|)
operator|+
operator|(
name|menu
operator|->
name|s_bdr_width
operator|<<
literal|1
operator|)
expr_stmt|;
name|p_s_diff
operator|=
name|p_width
operator|-
name|s_width
expr_stmt|;
if|if
condition|(
name|p_s_diff
operator|<
name|p_s_pad
condition|)
block|{
name|p_width
operator|=
name|s_width
operator|+
name|p_s_pad
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p_s_diff
operator|>
name|p_s_pad
condition|)
block|{
name|s_width
operator|=
name|p_width
operator|-
name|p_s_pad
expr_stmt|;
block|}
comment|/*      * Reset menu wide global values.      */
name|menu
operator|->
name|s_count
operator|=
name|s_count
expr_stmt|;
name|menu
operator|->
name|p_height
operator|=
name|p_height
expr_stmt|;
name|menu
operator|->
name|p_width
operator|=
name|p_width
expr_stmt|;
name|menu
operator|->
name|s_width
operator|=
name|s_width
expr_stmt|;
comment|/*       * Ensure that the origin of the menu is placed so that      * None of the panes ore selections are off the screen.      */
name|screen
operator|=
name|DefaultScreen
argument_list|(
name|display
argument_list|)
expr_stmt|;
if|if
condition|(
name|menu
operator|->
name|x_pos
operator|+
name|menu
operator|->
name|width
operator|>
name|DisplayWidth
argument_list|(
name|display
argument_list|,
name|screen
argument_list|)
condition|)
name|menu
operator|->
name|x_pos
operator|=
name|DisplayWidth
argument_list|(
name|display
argument_list|,
name|screen
argument_list|)
operator|-
name|menu
operator|->
name|width
expr_stmt|;
elseif|else
if|if
condition|(
name|menu
operator|->
name|x_pos
operator|<
literal|0
condition|)
name|menu
operator|->
name|x_pos
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|menu
operator|->
name|y_pos
operator|+
name|menu
operator|->
name|height
operator|>
name|DisplayHeight
argument_list|(
name|display
argument_list|,
name|screen
argument_list|)
condition|)
name|menu
operator|->
name|y_pos
operator|=
name|DisplayHeight
argument_list|(
name|display
argument_list|,
name|screen
argument_list|)
operator|-
name|menu
operator|->
name|height
expr_stmt|;
elseif|else
if|if
condition|(
name|menu
operator|->
name|y_pos
operator|<
literal|0
condition|)
name|menu
operator|->
name|y_pos
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * _XMRecomputePane - Internal subroutine to recompute pane  *		      window dependencies.  */
end_comment

begin_function
name|int
name|_XMRecomputePane
parameter_list|(
name|display
parameter_list|,
name|menu
parameter_list|,
name|p_ptr
parameter_list|,
name|p_num
parameter_list|)
specifier|register
name|Display
modifier|*
name|display
decl_stmt|;
comment|/* Standard X display variable. */
specifier|register
name|XMenu
modifier|*
name|menu
decl_stmt|;
comment|/* Menu object being recomputed. */
specifier|register
name|XMPane
modifier|*
name|p_ptr
decl_stmt|;
comment|/* Pane pointer. */
specifier|register
name|int
name|p_num
decl_stmt|;
comment|/* Pane sequence number. */
block|{
specifier|register
name|int
name|window_x
decl_stmt|;
comment|/* Recomputed window X coordinate. */
specifier|register
name|int
name|window_y
decl_stmt|;
comment|/* Recomputed window Y coordinate. */
name|unsigned
name|long
name|change_mask
decl_stmt|;
comment|/* Value mask to reconfigure window. */
name|XWindowChanges
modifier|*
name|changes
decl_stmt|;
comment|/* Values to use in configure window. */
specifier|register
name|Bool
name|config_p
init|=
name|False
decl_stmt|;
comment|/* Reconfigure pane window? */
comment|/*      * Update the pane serial number.      */
name|p_ptr
operator|->
name|serial
operator|=
name|p_num
expr_stmt|;
comment|/*      * Recompute window X and Y coordinates.      */
switch|switch
condition|(
name|menu
operator|->
name|menu_style
condition|)
block|{
case|case
name|LEFT
case|:
name|window_x
operator|=
name|menu
operator|->
name|p_x_off
operator|*
operator|(
operator|(
name|menu
operator|->
name|p_count
operator|-
literal|1
operator|)
operator|-
name|p_num
operator|)
expr_stmt|;
name|window_y
operator|=
name|menu
operator|->
name|p_y_off
operator|*
operator|(
operator|(
name|menu
operator|->
name|p_count
operator|-
literal|1
operator|)
operator|-
name|p_num
operator|)
expr_stmt|;
break|break;
case|case
name|RIGHT
case|:
name|window_x
operator|=
name|menu
operator|->
name|p_x_off
operator|*
name|p_num
expr_stmt|;
name|window_y
operator|=
name|menu
operator|->
name|p_y_off
operator|*
operator|(
operator|(
name|menu
operator|->
name|p_count
operator|-
literal|1
operator|)
operator|-
name|p_num
operator|)
expr_stmt|;
break|break;
case|case
name|CENTER
case|:
name|window_x
operator|=
literal|0
expr_stmt|;
name|window_y
operator|=
name|menu
operator|->
name|p_y_off
operator|*
operator|(
operator|(
name|menu
operator|->
name|p_count
operator|-
literal|1
operator|)
operator|-
name|p_num
operator|)
expr_stmt|;
break|break;
default|default:
comment|/* Error! Invalid style parameter. */
name|_XMErrorCode
operator|=
name|XME_STYLE_PARAM
expr_stmt|;
return|return
operator|(
name|_FAILURE
operator|)
return|;
block|}
name|window_x
operator|+=
name|menu
operator|->
name|x_pos
expr_stmt|;
name|window_y
operator|+=
name|menu
operator|->
name|y_pos
expr_stmt|;
comment|/*      * If the newly compute pane coordinates differ from the       * current coordinates, reset the current coordinates and      * reconfigure the pane.      */
if|if
condition|(
operator|(
name|window_x
operator|!=
name|p_ptr
operator|->
name|window_x
operator|)
operator|||
operator|(
name|window_y
operator|!=
name|p_ptr
operator|->
name|window_y
operator|)
condition|)
block|{
comment|/* 	 * Reset the coordinates and schedule 	 * the pane for reconfiguration. 	 */
name|p_ptr
operator|->
name|window_x
operator|=
name|window_x
expr_stmt|;
name|p_ptr
operator|->
name|window_y
operator|=
name|window_y
expr_stmt|;
name|config_p
operator|=
name|True
expr_stmt|;
block|}
comment|/*      * If the local pane width and height differs from the      * menu pane width and height, reset the local values.      */
if|if
condition|(
operator|(
name|p_ptr
operator|->
name|window_w
operator|!=
name|menu
operator|->
name|p_width
operator|)
operator|||
operator|(
name|p_ptr
operator|->
name|window_h
operator|!=
name|menu
operator|->
name|p_height
operator|)
condition|)
block|{
comment|/* 	 * Reset window width and height and schedule 	 * the pane for reconfiguration. 	 */
name|p_ptr
operator|->
name|window_w
operator|=
name|menu
operator|->
name|p_width
expr_stmt|;
name|p_ptr
operator|->
name|window_h
operator|=
name|menu
operator|->
name|p_height
expr_stmt|;
name|config_p
operator|=
name|True
expr_stmt|;
block|}
comment|/*      * If we need to reconfigure the pane window do it now.      */
if|if
condition|(
name|config_p
operator|==
name|True
condition|)
block|{
comment|/* 	 * If the pane window has already been created then 	 * reconfigure the existing window, otherwise queue 	 * it for creation with the new configuration. 	 */
if|if
condition|(
name|p_ptr
operator|->
name|window
condition|)
block|{
name|change_mask
operator|=
operator|(
name|CWX
operator||
name|CWY
operator||
name|CWWidth
operator||
name|CWHeight
operator|)
expr_stmt|;
name|changes
operator|=
operator|(
name|XWindowChanges
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|XWindowChanges
argument_list|)
argument_list|)
expr_stmt|;
name|changes
operator|->
name|x
operator|=
name|p_ptr
operator|->
name|window_x
expr_stmt|;
name|changes
operator|->
name|y
operator|=
name|p_ptr
operator|->
name|window_y
expr_stmt|;
name|changes
operator|->
name|width
operator|=
name|p_ptr
operator|->
name|window_w
expr_stmt|;
name|changes
operator|->
name|height
operator|=
name|p_ptr
operator|->
name|window_h
expr_stmt|;
name|XConfigureWindow
argument_list|(
name|display
argument_list|,
name|p_ptr
operator|->
name|window
argument_list|,
name|change_mask
argument_list|,
name|changes
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|changes
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|_XMWinQueAddPane
argument_list|(
name|display
argument_list|,
name|menu
argument_list|,
name|p_ptr
argument_list|)
operator|==
name|_FAILURE
condition|)
block|{
return|return
operator|(
name|_FAILURE
operator|)
return|;
block|}
block|}
block|}
comment|/*      * Recompute label X position.      */
switch|switch
condition|(
name|menu
operator|->
name|p_style
condition|)
block|{
case|case
name|LEFT
case|:
name|p_ptr
operator|->
name|label_x
operator|=
name|menu
operator|->
name|p_x_off
operator|+
name|menu
operator|->
name|p_fnt_pad
expr_stmt|;
break|break;
case|case
name|RIGHT
case|:
name|p_ptr
operator|->
name|label_x
operator|=
name|menu
operator|->
name|p_width
operator|-
operator|(
name|p_ptr
operator|->
name|label_width
operator|+
name|menu
operator|->
name|p_x_off
operator|+
name|menu
operator|->
name|p_fnt_pad
operator|)
expr_stmt|;
break|break;
case|case
name|CENTER
case|:
name|p_ptr
operator|->
name|label_x
operator|=
operator|(
name|menu
operator|->
name|p_width
operator|-
name|p_ptr
operator|->
name|label_width
operator|)
operator|>>
literal|1
expr_stmt|;
break|break;
default|default:
comment|/* Error! Invalid style parameter. */
name|_XMErrorCode
operator|=
name|XME_STYLE_PARAM
expr_stmt|;
return|return
operator|(
name|_FAILURE
operator|)
return|;
block|}
comment|/*      * Recompute label Y positions.      */
name|p_ptr
operator|->
name|label_uy
operator|=
name|menu
operator|->
name|p_fnt_pad
operator|+
name|menu
operator|->
name|p_fnt_info
operator|->
name|max_bounds
operator|.
name|ascent
expr_stmt|;
name|p_ptr
operator|->
name|label_ly
operator|=
operator|(
name|menu
operator|->
name|p_height
operator|-
name|menu
operator|->
name|p_fnt_pad
operator|-
name|menu
operator|->
name|p_fnt_info
operator|->
name|max_bounds
operator|.
name|descent
operator|)
expr_stmt|;
comment|/*      * All went well, return successfully.      */
name|_XMErrorCode
operator|=
name|XME_NO_ERROR
expr_stmt|;
return|return
operator|(
name|_SUCCESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * _XMRecomputeSelection - Internal subroutine to recompute  *			   selection window dependencies.  */
end_comment

begin_function
name|int
name|_XMRecomputeSelection
parameter_list|(
name|display
parameter_list|,
name|menu
parameter_list|,
name|s_ptr
parameter_list|,
name|s_num
parameter_list|)
specifier|register
name|Display
modifier|*
name|display
decl_stmt|;
specifier|register
name|XMenu
modifier|*
name|menu
decl_stmt|;
comment|/* Menu object being recomputed. */
specifier|register
name|XMSelect
modifier|*
name|s_ptr
decl_stmt|;
comment|/* Selection pointer. */
specifier|register
name|int
name|s_num
decl_stmt|;
comment|/* Selection sequence number. */
block|{
specifier|register
name|Bool
name|config_s
init|=
name|False
decl_stmt|;
comment|/* Reconfigure selection window? */
name|XWindowChanges
modifier|*
name|changes
decl_stmt|;
comment|/* Values to change in configure. */
name|unsigned
name|long
name|change_mask
decl_stmt|;
comment|/* Value mask for XConfigureWindow. */
comment|/*      * If the selection serial numbers are out of order, begin      * resequencing selections.  Recompute selection window coordinates      * and serial number.      *      * When selections are created they are given a serial number of      * -1, this causes this routine to give a new selection      * its initial coordinates and serial number.      */
if|if
condition|(
name|s_ptr
operator|->
name|serial
operator|!=
name|s_num
condition|)
block|{
comment|/* 	 * Fix the sequence number. 	 */
name|s_ptr
operator|->
name|serial
operator|=
name|s_num
expr_stmt|;
comment|/* 	 * Recompute window X and Y coordinates. 	 */
name|s_ptr
operator|->
name|window_x
operator|=
name|menu
operator|->
name|s_x_off
expr_stmt|;
name|s_ptr
operator|->
name|window_y
operator|=
name|menu
operator|->
name|flag_height
operator|+
operator|(
name|menu
operator|->
name|s_y_off
operator|*
name|s_num
operator|)
expr_stmt|;
comment|/* 	 * We must reconfigure the window. 	 */
name|config_s
operator|=
name|True
expr_stmt|;
block|}
comment|/*      * If the local selection width and height differs from the      * menu selection width and height, reset the local values.      */
if|if
condition|(
operator|(
name|s_ptr
operator|->
name|window_w
operator|!=
name|menu
operator|->
name|s_width
operator|)
operator|||
operator|(
name|s_ptr
operator|->
name|window_h
operator|!=
name|menu
operator|->
name|s_height
operator|)
condition|)
block|{
comment|/* 	 * We must reconfigure the window. 	 */
name|config_s
operator|=
name|True
expr_stmt|;
comment|/* 	 * Reset window width and height. 	 */
name|s_ptr
operator|->
name|window_w
operator|=
name|menu
operator|->
name|s_width
expr_stmt|;
name|s_ptr
operator|->
name|window_h
operator|=
name|menu
operator|->
name|s_height
expr_stmt|;
block|}
comment|/*      * If we need to reconfigure the selection window do it now.      */
if|if
condition|(
name|config_s
operator|==
name|True
condition|)
block|{
comment|/* 	 * If the selection window has already been created then 	 * reconfigure the existing window, otherwise queue it 	 * for creation with the new configuration. 	 */
if|if
condition|(
name|s_ptr
operator|->
name|window
condition|)
block|{
name|changes
operator|=
operator|(
name|XWindowChanges
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|XWindowChanges
argument_list|)
argument_list|)
expr_stmt|;
name|change_mask
operator|=
operator|(
name|CWX
operator||
name|CWY
operator||
name|CWWidth
operator||
name|CWHeight
operator|)
expr_stmt|;
name|changes
operator|=
operator|(
name|XWindowChanges
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|XWindowChanges
argument_list|)
argument_list|)
expr_stmt|;
name|changes
operator|->
name|x
operator|=
name|s_ptr
operator|->
name|window_x
expr_stmt|;
name|changes
operator|->
name|y
operator|=
name|s_ptr
operator|->
name|window_y
expr_stmt|;
name|changes
operator|->
name|width
operator|=
name|s_ptr
operator|->
name|window_w
expr_stmt|;
name|changes
operator|->
name|height
operator|=
name|s_ptr
operator|->
name|window_h
expr_stmt|;
name|XConfigureWindow
argument_list|(
name|display
argument_list|,
name|s_ptr
operator|->
name|window
argument_list|,
name|change_mask
argument_list|,
name|changes
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|changes
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|_XMWinQueAddSelection
argument_list|(
name|display
argument_list|,
name|menu
argument_list|,
name|s_ptr
argument_list|)
operator|==
name|_FAILURE
condition|)
block|{
return|return
operator|(
name|_FAILURE
operator|)
return|;
block|}
block|}
block|}
comment|/*      * Recompute label X position.      */
switch|switch
condition|(
name|menu
operator|->
name|s_style
condition|)
block|{
case|case
name|LEFT
case|:
name|s_ptr
operator|->
name|label_x
operator|=
name|menu
operator|->
name|s_bdr_width
operator|+
name|menu
operator|->
name|s_fnt_pad
operator|+
name|s_ptr
operator|->
name|window_x
expr_stmt|;
break|break;
case|case
name|RIGHT
case|:
name|s_ptr
operator|->
name|label_x
operator|=
name|s_ptr
operator|->
name|window_x
operator|+
name|menu
operator|->
name|s_width
operator|-
operator|(
name|s_ptr
operator|->
name|label_width
operator|+
name|menu
operator|->
name|s_bdr_width
operator|+
name|menu
operator|->
name|s_fnt_pad
operator|)
expr_stmt|;
break|break;
case|case
name|CENTER
case|:
name|s_ptr
operator|->
name|label_x
operator|=
name|s_ptr
operator|->
name|window_x
operator|+
operator|(
operator|(
name|menu
operator|->
name|s_width
operator|-
name|s_ptr
operator|->
name|label_width
operator|)
operator|>>
literal|1
operator|)
expr_stmt|;
break|break;
default|default:
comment|/* Error! Invaild style parameter. */
name|_XMErrorCode
operator|=
name|XME_STYLE_PARAM
expr_stmt|;
return|return
operator|(
name|_FAILURE
operator|)
return|;
block|}
comment|/*      * Recompute label Y position.      */
name|s_ptr
operator|->
name|label_y
operator|=
name|s_ptr
operator|->
name|window_y
operator|+
name|menu
operator|->
name|s_fnt_info
operator|->
name|max_bounds
operator|.
name|ascent
operator|+
name|menu
operator|->
name|s_fnt_pad
operator|+
name|menu
operator|->
name|s_bdr_width
expr_stmt|;
comment|/*      * All went well, return successfully.      */
name|_XMErrorCode
operator|=
name|XME_NO_ERROR
expr_stmt|;
return|return
operator|(
name|_SUCCESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * _XMTransToOrigin - Internal subroutine to translate the point at  *		      the center of the current pane and selection to the   *		      the menu origin.  *  *	WARNING! ******	Be certain that all menu depencies have been  *			recomputed before calling this routine or  *			unpredictable results will follow.  */
end_comment

begin_macro
name|_XMTransToOrigin
argument_list|(
argument|display
argument_list|,
argument|menu
argument_list|,
argument|p_ptr
argument_list|,
argument|s_ptr
argument_list|,
argument|x_pos
argument_list|,
argument|y_pos
argument_list|,
argument|orig_x
argument_list|,
argument|orig_y
argument_list|)
end_macro

begin_decl_stmt
name|Display
modifier|*
name|display
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Not used. Included for consistency. */
end_comment

begin_decl_stmt
specifier|register
name|XMenu
modifier|*
name|menu
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Menu being computed against. */
end_comment

begin_decl_stmt
specifier|register
name|XMPane
modifier|*
name|p_ptr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current pane pointer. */
end_comment

begin_decl_stmt
specifier|register
name|XMSelect
modifier|*
name|s_ptr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current selection pointer. */
end_comment

begin_decl_stmt
name|int
name|x_pos
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* X coordinate of point to translate. */
end_comment

begin_decl_stmt
name|int
name|y_pos
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Y coordinate of point to translate. */
end_comment

begin_decl_stmt
name|int
modifier|*
name|orig_x
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return value X coord. of the menu origin. */
end_comment

begin_decl_stmt
name|int
modifier|*
name|orig_y
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return value Y coord. of the menu origin. */
end_comment

begin_block
block|{
specifier|register
name|int
name|l_orig_x
decl_stmt|;
comment|/* Local X coordinate of the menu origin. */
specifier|register
name|int
name|l_orig_y
decl_stmt|;
comment|/* Local Y coordinate of the menu origin. */
comment|/*      * Translate the menu origin such that the cursor hot point will be in the      * center of the desired current selection and pane.      * If the current selection pointer is NULL then assume that the hot point      * will be in the center of the current pane flag.      */
if|if
condition|(
name|s_ptr
operator|==
name|NULL
condition|)
block|{
comment|/* 	 * Translate from the center of the pane flag to the upper left 	 * of the current pane window. 	 */
name|l_orig_x
operator|=
name|x_pos
operator|-
operator|(
name|menu
operator|->
name|p_width
operator|>>
literal|1
operator|)
operator|-
name|menu
operator|->
name|p_bdr_width
expr_stmt|;
name|l_orig_y
operator|=
name|y_pos
operator|-
operator|(
name|menu
operator|->
name|flag_height
operator|>>
literal|1
operator|)
operator|-
name|menu
operator|->
name|p_bdr_width
expr_stmt|;
block|}
else|else
block|{
comment|/* 	 * First translate from the center of the current selection 	 * to the upper left of the current selection window. 	 */
name|l_orig_x
operator|=
name|x_pos
operator|-
operator|(
name|menu
operator|->
name|s_width
operator|>>
literal|1
operator|)
expr_stmt|;
name|l_orig_y
operator|=
name|y_pos
operator|-
operator|(
name|menu
operator|->
name|s_height
operator|>>
literal|1
operator|)
expr_stmt|;
comment|/* 	 * Then translate to the upper left of the current pane window. 	 */
name|l_orig_x
operator|-=
operator|(
name|s_ptr
operator|->
name|window_x
operator|+
name|menu
operator|->
name|p_bdr_width
operator|)
expr_stmt|;
name|l_orig_y
operator|-=
operator|(
name|s_ptr
operator|->
name|window_y
operator|+
name|menu
operator|->
name|p_bdr_width
operator|)
expr_stmt|;
block|}
comment|/*      * Finally translate to the upper left of the menu.      */
name|l_orig_x
operator|-=
operator|(
name|p_ptr
operator|->
name|window_x
operator|-
name|menu
operator|->
name|x_pos
operator|)
expr_stmt|;
name|l_orig_y
operator|-=
operator|(
name|p_ptr
operator|->
name|window_y
operator|-
name|menu
operator|->
name|y_pos
operator|)
expr_stmt|;
comment|/*      * Set the return values.      */
operator|*
name|orig_x
operator|=
name|l_orig_x
expr_stmt|;
operator|*
name|orig_y
operator|=
name|l_orig_y
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * _XMRefreshPane - Internal subroutine to completely refresh  *		    the contents of a pane.  */
end_comment

begin_expr_stmt
name|_XMRefreshPane
argument_list|(
name|display
argument_list|,
name|menu
argument_list|,
name|pane
argument_list|)
specifier|register
name|Display
operator|*
name|display
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|XMenu
modifier|*
name|menu
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|XMPane
modifier|*
name|pane
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|XMSelect
modifier|*
name|s_list
init|=
name|pane
operator|->
name|s_list
decl_stmt|;
specifier|register
name|XMSelect
modifier|*
name|s_ptr
decl_stmt|;
comment|/*      * First clear the pane.       */
name|XClearWindow
argument_list|(
name|display
argument_list|,
name|pane
operator|->
name|window
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pane
operator|->
name|activated
condition|)
block|{
name|XFillRectangle
argument_list|(
name|display
argument_list|,
name|pane
operator|->
name|window
argument_list|,
name|menu
operator|->
name|inverse_select_GC
argument_list|,
name|pane
operator|->
name|label_x
operator|-
name|menu
operator|->
name|p_fnt_pad
argument_list|,
name|pane
operator|->
name|label_uy
operator|-
name|menu
operator|->
name|p_fnt_info
operator|->
name|max_bounds
operator|.
name|ascent
operator|-
name|menu
operator|->
name|p_fnt_pad
argument_list|,
name|pane
operator|->
name|label_width
operator|+
operator|(
name|menu
operator|->
name|p_fnt_pad
operator|<<
literal|1
operator|)
argument_list|,
name|menu
operator|->
name|flag_height
argument_list|)
expr_stmt|;
name|XFillRectangle
argument_list|(
name|display
argument_list|,
name|pane
operator|->
name|window
argument_list|,
name|menu
operator|->
name|inverse_select_GC
argument_list|,
name|pane
operator|->
name|label_x
operator|-
name|menu
operator|->
name|p_fnt_pad
argument_list|,
name|pane
operator|->
name|label_ly
operator|-
name|menu
operator|->
name|p_fnt_info
operator|->
name|max_bounds
operator|.
name|ascent
operator|-
name|menu
operator|->
name|p_fnt_pad
argument_list|,
name|pane
operator|->
name|label_width
operator|+
operator|(
name|menu
operator|->
name|p_fnt_pad
operator|<<
literal|1
operator|)
argument_list|,
name|menu
operator|->
name|flag_height
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|pane
operator|->
name|active
condition|)
block|{
name|XDrawString
argument_list|(
name|display
argument_list|,
name|pane
operator|->
name|window
argument_list|,
name|menu
operator|->
name|inact_GC
argument_list|,
name|pane
operator|->
name|label_x
argument_list|,
name|pane
operator|->
name|label_uy
argument_list|,
name|pane
operator|->
name|label
argument_list|,
name|pane
operator|->
name|label_length
argument_list|)
expr_stmt|;
name|XDrawString
argument_list|(
name|display
argument_list|,
name|pane
operator|->
name|window
argument_list|,
name|menu
operator|->
name|inact_GC
argument_list|,
name|pane
operator|->
name|label_x
argument_list|,
name|pane
operator|->
name|label_ly
argument_list|,
name|pane
operator|->
name|label
argument_list|,
name|pane
operator|->
name|label_length
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|XDrawString
argument_list|(
name|display
argument_list|,
name|pane
operator|->
name|window
argument_list|,
name|menu
operator|->
name|pane_GC
argument_list|,
name|pane
operator|->
name|label_x
argument_list|,
name|pane
operator|->
name|label_uy
argument_list|,
name|pane
operator|->
name|label
argument_list|,
name|pane
operator|->
name|label_length
argument_list|)
expr_stmt|;
name|XDrawString
argument_list|(
name|display
argument_list|,
name|pane
operator|->
name|window
argument_list|,
name|menu
operator|->
name|pane_GC
argument_list|,
name|pane
operator|->
name|label_x
argument_list|,
name|pane
operator|->
name|label_ly
argument_list|,
name|pane
operator|->
name|label
argument_list|,
name|pane
operator|->
name|label_length
argument_list|)
expr_stmt|;
comment|/* 	 * Finally refresh each selection if the pane is activated. 	 */
if|if
condition|(
name|pane
operator|->
name|activated
condition|)
block|{
for|for
control|(
name|s_ptr
operator|=
name|s_list
operator|->
name|next
init|;
name|s_ptr
operator|!=
name|s_list
condition|;
name|s_ptr
operator|=
name|s_ptr
operator|->
name|next
control|)
name|_XMRefreshSelection
argument_list|(
name|display
argument_list|,
name|menu
argument_list|,
name|s_ptr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/*  * _XMRefreshSelection - Internal subroutine that refreshes   *			 a single selection window.  */
end_comment

begin_expr_stmt
name|_XMRefreshSelection
argument_list|(
name|display
argument_list|,
name|menu
argument_list|,
name|select
argument_list|)
specifier|register
name|Display
operator|*
name|display
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|XMenu
modifier|*
name|menu
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|XMSelect
modifier|*
name|select
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|width
init|=
name|select
operator|->
name|window_w
decl_stmt|;
specifier|register
name|int
name|height
init|=
name|select
operator|->
name|window_h
decl_stmt|;
specifier|register
name|int
name|bdr_width
init|=
name|menu
operator|->
name|s_bdr_width
decl_stmt|;
if|if
condition|(
name|select
operator|->
name|activated
condition|)
block|{
if|if
condition|(
name|menu
operator|->
name|menu_mode
operator|==
name|INVERT
condition|)
block|{
name|XFillRectangle
argument_list|(
name|display
argument_list|,
name|select
operator|->
name|parent_p
operator|->
name|window
argument_list|,
name|menu
operator|->
name|normal_select_GC
argument_list|,
name|select
operator|->
name|window_x
argument_list|,
name|select
operator|->
name|window_y
argument_list|,
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
name|XDrawString
argument_list|(
name|display
argument_list|,
name|select
operator|->
name|parent_p
operator|->
name|window
argument_list|,
name|menu
operator|->
name|inverse_select_GC
argument_list|,
name|select
operator|->
name|label_x
argument_list|,
name|select
operator|->
name|label_y
argument_list|,
name|select
operator|->
name|label
argument_list|,
name|select
operator|->
name|label_length
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 	     * Using BOX mode.              * Since most drawing routines with arbitrary width lines 	     * are slow compared to raster-ops lets use a raster-op to 	     * draw the boxes.              */
name|XDrawRectangle
argument_list|(
name|display
argument_list|,
name|select
operator|->
name|parent_p
operator|->
name|window
argument_list|,
name|menu
operator|->
name|normal_select_GC
argument_list|,
name|select
operator|->
name|window_x
operator|+
operator|(
name|bdr_width
operator|>>
literal|1
operator|)
argument_list|,
name|select
operator|->
name|window_y
operator|+
operator|(
name|bdr_width
operator|>>
literal|1
operator|)
argument_list|,
name|width
operator|-
name|bdr_width
argument_list|,
name|height
operator|-
name|bdr_width
argument_list|)
expr_stmt|;
name|XDrawString
argument_list|(
name|display
argument_list|,
name|select
operator|->
name|parent_p
operator|->
name|window
argument_list|,
name|menu
operator|->
name|normal_select_GC
argument_list|,
name|select
operator|->
name|label_x
argument_list|,
name|select
operator|->
name|label_y
argument_list|,
name|select
operator|->
name|label
argument_list|,
name|select
operator|->
name|label_length
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|XClearArea
argument_list|(
name|display
argument_list|,
name|select
operator|->
name|parent_p
operator|->
name|window
argument_list|,
name|select
operator|->
name|window_x
argument_list|,
name|select
operator|->
name|window_y
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|False
argument_list|)
expr_stmt|;
if|if
condition|(
name|select
operator|->
name|active
condition|)
block|{
name|XDrawString
argument_list|(
name|display
argument_list|,
name|select
operator|->
name|parent_p
operator|->
name|window
argument_list|,
name|menu
operator|->
name|normal_select_GC
argument_list|,
name|select
operator|->
name|label_x
argument_list|,
name|select
operator|->
name|label_y
argument_list|,
name|select
operator|->
name|label
argument_list|,
name|select
operator|->
name|label_length
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|XDrawString
argument_list|(
name|display
argument_list|,
name|select
operator|->
name|parent_p
operator|->
name|window
argument_list|,
name|menu
operator|->
name|inact_GC
argument_list|,
name|select
operator|->
name|label_x
argument_list|,
name|select
operator|->
name|label_y
argument_list|,
name|select
operator|->
name|label
argument_list|,
name|select
operator|->
name|label_length
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

end_unit

