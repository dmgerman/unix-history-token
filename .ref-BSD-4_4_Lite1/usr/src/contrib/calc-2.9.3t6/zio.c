begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1994 David I. Bell  * Permission is granted to use, distribute, or modify this source,  * provided that this copyright notice remains intact.  *  * Scanf and printf routines for arbitrary precision integers.  */
end_comment

begin_include
include|#
directive|include
file|"stdarg.h"
end_include

begin_include
include|#
directive|include
file|"zmath.h"
end_include

begin_define
define|#
directive|define
name|OUTBUFSIZE
value|200
end_define

begin_comment
comment|/* realloc size for output buffers */
end_comment

begin_define
define|#
directive|define
name|PUTCHAR
parameter_list|(
name|ch
parameter_list|)
value|math_chr(ch)
end_define

begin_define
define|#
directive|define
name|PUTSTR
parameter_list|(
name|str
parameter_list|)
value|math_str(str)
end_define

begin_define
define|#
directive|define
name|PRINTF1
parameter_list|(
name|fmt
parameter_list|,
name|a1
parameter_list|)
value|math_fmt(fmt, a1)
end_define

begin_define
define|#
directive|define
name|PRINTF2
parameter_list|(
name|fmt
parameter_list|,
name|a1
parameter_list|,
name|a2
parameter_list|)
value|math_fmt(fmt, a1, a2)
end_define

begin_decl_stmt
name|long
name|_outdigits_
init|=
literal|20
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* default digits for output */
end_comment

begin_decl_stmt
name|int
name|_outmode_
init|=
name|MODE_INITIAL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* default output mode */
end_comment

begin_comment
comment|/*  * Output state that has been saved when diversions are done.  */
end_comment

begin_typedef
typedef|typedef
name|struct
name|iostate
name|IOSTATE
typedef|;
end_typedef

begin_struct
struct|struct
name|iostate
block|{
name|IOSTATE
modifier|*
name|oldiostates
decl_stmt|;
comment|/* previous saved state */
name|long
name|outdigits
decl_stmt|;
comment|/* digits for output */
name|int
name|outmode
decl_stmt|;
comment|/* output mode */
name|FILE
modifier|*
name|outfp
decl_stmt|;
comment|/* file unit for output (if any) */
name|char
modifier|*
name|outbuf
decl_stmt|;
comment|/* output string buffer (if any) */
name|long
name|outbufsize
decl_stmt|;
comment|/* current size of string buffer */
name|long
name|outbufused
decl_stmt|;
comment|/* space used in string buffer */
name|BOOL
name|outputisstring
decl_stmt|;
comment|/* TRUE if output is to string buffer */
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|IOSTATE
modifier|*
name|oldiostates
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* list of saved output states */
end_comment

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|outfp
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* file unit for output */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|outbuf
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current diverted buffer */
end_comment

begin_decl_stmt
specifier|static
name|BOOL
name|outputisstring
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|outbufsize
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|outbufused
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * zio_init - perform needed initilization work  *  * On some systems, one cannot initialize a pointer to a FILE *.  * This routine, called once at startup is a work-a-round for  * systems with such bogons.  */
end_comment

begin_function
name|void
name|zio_init
parameter_list|()
block|{
specifier|static
name|int
name|done
init|=
literal|0
decl_stmt|;
comment|/* 1 => routine already called */
if|if
condition|(
operator|!
name|done
condition|)
block|{
name|outfp
operator|=
name|stdout
expr_stmt|;
name|done
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Routine to output a character either to a FILE  * handle or into a string.  */
end_comment

begin_function
name|void
name|math_chr
parameter_list|(
name|ch
parameter_list|)
name|int
name|ch
decl_stmt|;
block|{
name|char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
operator|!
name|outputisstring
condition|)
block|{
name|fputc
argument_list|(
name|ch
argument_list|,
name|outfp
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|outbufused
operator|>=
name|outbufsize
condition|)
block|{
name|cp
operator|=
operator|(
name|char
operator|*
operator|)
name|realloc
argument_list|(
name|outbuf
argument_list|,
name|outbufsize
operator|+
name|OUTBUFSIZE
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
name|math_error
argument_list|(
literal|"Cannot realloc output string"
argument_list|)
expr_stmt|;
name|outbuf
operator|=
name|cp
expr_stmt|;
name|outbufsize
operator|+=
name|OUTBUFSIZE
expr_stmt|;
block|}
name|outbuf
index|[
name|outbufused
operator|++
index|]
operator|=
operator|(
name|char
operator|)
name|ch
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Routine to output a null-terminated string either  * to a FILE handle or into a string.  */
end_comment

begin_function
name|void
name|math_str
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
operator|!
name|outputisstring
condition|)
block|{
name|fputs
argument_list|(
name|str
argument_list|,
name|outfp
argument_list|)
expr_stmt|;
return|return;
block|}
name|len
operator|=
name|strlen
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|outbufused
operator|+
name|len
operator|)
operator|>
name|outbufsize
condition|)
block|{
name|cp
operator|=
operator|(
name|char
operator|*
operator|)
name|realloc
argument_list|(
name|outbuf
argument_list|,
name|outbufsize
operator|+
name|len
operator|+
name|OUTBUFSIZE
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
name|math_error
argument_list|(
literal|"Cannot realloc output string"
argument_list|)
expr_stmt|;
name|outbuf
operator|=
name|cp
expr_stmt|;
name|outbufsize
operator|+=
operator|(
name|len
operator|+
name|OUTBUFSIZE
operator|)
expr_stmt|;
block|}
name|memcpy
argument_list|(
operator|&
name|outbuf
index|[
name|outbufused
index|]
argument_list|,
name|str
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|outbufused
operator|+=
name|len
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Output a null-terminated string either to a FILE handle or into a string,  * padded with spaces as needed so as to fit within the specified width.  * If width is positive, the spaces are added at the front of the string.  * If width is negative, the spaces are added at the end of the string.  * The complete string is always output, even if this overflows the width.  * No characters within the string are handled specially.  */
end_comment

begin_function
name|void
name|math_fill
parameter_list|(
name|str
parameter_list|,
name|width
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
name|long
name|width
decl_stmt|;
block|{
if|if
condition|(
name|width
operator|>
literal|0
condition|)
block|{
name|width
operator|-=
name|strlen
argument_list|(
name|str
argument_list|)
expr_stmt|;
while|while
condition|(
name|width
operator|--
operator|>
literal|0
condition|)
name|PUTCHAR
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|PUTSTR
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|width
operator|+=
name|strlen
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|PUTSTR
argument_list|(
name|str
argument_list|)
expr_stmt|;
while|while
condition|(
name|width
operator|++
operator|<
literal|0
condition|)
name|PUTCHAR
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Routine to output a printf-style formatted string either  * to a FILE handle or into a string.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|VARARGS
end_ifdef

begin_define
define|#
directive|define
name|VA_ALIST
value|fmt, va_alist
end_define

begin_define
define|#
directive|define
name|VA_DCL
value|char *fmt; va_dcl
end_define

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__STDC__
argument_list|)
operator|&&
name|__STDC__
operator|==
literal|1
end_if

begin_define
define|#
directive|define
name|VA_ALIST
value|char *fmt, ...
end_define

begin_define
define|#
directive|define
name|VA_DCL
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|VA_ALIST
value|fmt
end_define

begin_define
define|#
directive|define
name|VA_DCL
value|char *fmt;
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*VARARGS*/
end_comment

begin_function
name|void
name|math_fmt
parameter_list|(
name|VA_ALIST
parameter_list|)
function|VA_DCL
block|{
name|va_list
name|ap
decl_stmt|;
name|char
name|buf
index|[
literal|200
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|VARARGS
name|va_start
argument_list|(
name|ap
argument_list|)
expr_stmt|;
else|#
directive|else
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|vsprintf
argument_list|(
name|buf
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|math_str
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Flush the current output stream.  */
end_comment

begin_function
name|void
name|math_flush
parameter_list|()
block|{
if|if
condition|(
operator|!
name|outputisstring
condition|)
name|fflush
argument_list|(
name|outfp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Divert further output so that it is saved into a string that will be  * returned later when the diversion is completed.  The current state of  * output is remembered for later restoration.  Diversions can be nested.  * Output diversion is only intended for saving output to "stdout".  */
end_comment

begin_function
name|void
name|math_divertio
parameter_list|()
block|{
specifier|register
name|IOSTATE
modifier|*
name|sp
decl_stmt|;
name|sp
operator|=
operator|(
name|IOSTATE
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|IOSTATE
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|==
name|NULL
condition|)
name|math_error
argument_list|(
literal|"No memory for diverting output"
argument_list|)
expr_stmt|;
name|sp
operator|->
name|oldiostates
operator|=
name|oldiostates
expr_stmt|;
name|sp
operator|->
name|outdigits
operator|=
name|_outdigits_
expr_stmt|;
name|sp
operator|->
name|outmode
operator|=
name|_outmode_
expr_stmt|;
name|sp
operator|->
name|outfp
operator|=
name|outfp
expr_stmt|;
name|sp
operator|->
name|outbuf
operator|=
name|outbuf
expr_stmt|;
name|sp
operator|->
name|outbufsize
operator|=
name|outbufsize
expr_stmt|;
name|sp
operator|->
name|outbufused
operator|=
name|outbufused
expr_stmt|;
name|sp
operator|->
name|outputisstring
operator|=
name|outputisstring
expr_stmt|;
name|outbufused
operator|=
literal|0
expr_stmt|;
name|outbufsize
operator|=
literal|0
expr_stmt|;
name|outbuf
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|OUTBUFSIZE
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|outbuf
operator|==
name|NULL
condition|)
name|math_error
argument_list|(
literal|"Cannot allocate divert string"
argument_list|)
expr_stmt|;
name|outbufsize
operator|=
name|OUTBUFSIZE
expr_stmt|;
name|outputisstring
operator|=
name|TRUE
expr_stmt|;
name|oldiostates
operator|=
name|sp
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Undivert output and return the saved output as a string.  This also  * restores the output state to what it was before the diversion began.  * The string needs freeing by the caller when it is no longer needed.  */
end_comment

begin_function
name|char
modifier|*
name|math_getdivertedio
parameter_list|()
block|{
specifier|register
name|IOSTATE
modifier|*
name|sp
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|sp
operator|=
name|oldiostates
expr_stmt|;
if|if
condition|(
name|sp
operator|==
name|NULL
condition|)
name|math_error
argument_list|(
literal|"No diverted state to restore"
argument_list|)
expr_stmt|;
name|cp
operator|=
name|outbuf
expr_stmt|;
name|cp
index|[
name|outbufused
index|]
operator|=
literal|'\0'
expr_stmt|;
name|oldiostates
operator|=
name|sp
operator|->
name|oldiostates
expr_stmt|;
name|_outdigits_
operator|=
name|sp
operator|->
name|outdigits
expr_stmt|;
name|_outmode_
operator|=
name|sp
operator|->
name|outmode
expr_stmt|;
name|outfp
operator|=
name|sp
operator|->
name|outfp
expr_stmt|;
name|outbuf
operator|=
name|sp
operator|->
name|outbuf
expr_stmt|;
name|outbufsize
operator|=
name|sp
operator|->
name|outbufsize
expr_stmt|;
name|outbufused
operator|=
name|sp
operator|->
name|outbufused
expr_stmt|;
name|outbuf
operator|=
name|sp
operator|->
name|outbuf
expr_stmt|;
name|outputisstring
operator|=
name|sp
operator|->
name|outputisstring
expr_stmt|;
return|return
name|cp
return|;
block|}
end_function

begin_comment
comment|/*  * Clear all diversions and set output back to the original destination.  * This is called when resetting the global state of the program.  */
end_comment

begin_function
name|void
name|math_cleardiversions
parameter_list|()
block|{
while|while
condition|(
name|oldiostates
condition|)
name|free
argument_list|(
name|math_getdivertedio
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set the output routines to output to the specified FILE stream.  * This interacts with output diversion in the following manner.  *	STDOUT	diversion	action  *	----	---------	------  *	yes	yes		set output to diversion string again.  *	yes	no		set output to stdout.  *	no	yes		set output to specified file.  *	no	no		set output to specified file.  */
end_comment

begin_function
name|void
name|math_setfp
parameter_list|(
name|newfp
parameter_list|)
name|FILE
modifier|*
name|newfp
decl_stmt|;
block|{
name|outfp
operator|=
name|newfp
expr_stmt|;
name|outputisstring
operator|=
operator|(
name|oldiostates
operator|&&
operator|(
name|newfp
operator|==
name|stdout
operator|)
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set the output mode for numeric output.  * This also returns the previous mode.  */
end_comment

begin_function
name|int
name|math_setmode
parameter_list|(
name|newmode
parameter_list|)
name|int
name|newmode
decl_stmt|;
block|{
name|int
name|oldmode
decl_stmt|;
if|if
condition|(
operator|(
name|newmode
operator|<=
name|MODE_DEFAULT
operator|)
operator|||
operator|(
name|newmode
operator|>
name|MODE_MAX
operator|)
condition|)
name|math_error
argument_list|(
literal|"Setting illegal output mode"
argument_list|)
expr_stmt|;
name|oldmode
operator|=
name|_outmode_
expr_stmt|;
name|_outmode_
operator|=
name|newmode
expr_stmt|;
return|return
name|oldmode
return|;
block|}
end_function

begin_comment
comment|/*  * Set the number of digits for float or exponential output.  * This also returns the previous number of digits.  */
end_comment

begin_function
name|long
name|math_setdigits
parameter_list|(
name|newdigits
parameter_list|)
name|long
name|newdigits
decl_stmt|;
block|{
name|long
name|olddigits
decl_stmt|;
if|if
condition|(
name|newdigits
operator|<
literal|0
condition|)
name|math_error
argument_list|(
literal|"Setting illegal number of digits"
argument_list|)
expr_stmt|;
name|olddigits
operator|=
name|_outdigits_
expr_stmt|;
name|_outdigits_
operator|=
name|newdigits
expr_stmt|;
return|return
name|olddigits
return|;
block|}
end_function

begin_comment
comment|/*  * Print an integer value as a hex number.  * Width is the number of columns to print the number in, including the  * sign if required.  If zero, no extra output is done.  If positive,  * leading spaces are typed if necessary. If negative, trailing spaces are  * typed if necessary.  The special characters 0x appear to indicate the  * number is hex.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|void
name|zprintx
parameter_list|(
name|z
parameter_list|,
name|width
parameter_list|)
name|ZVALUE
name|z
decl_stmt|;
name|long
name|width
decl_stmt|;
block|{
specifier|register
name|HALF
modifier|*
name|hp
decl_stmt|;
comment|/* current word to print */
name|int
name|len
decl_stmt|;
comment|/* number of halfwords to type */
name|char
modifier|*
name|str
decl_stmt|;
if|if
condition|(
name|width
condition|)
block|{
name|math_divertio
argument_list|()
expr_stmt|;
name|zprintx
argument_list|(
name|z
argument_list|,
literal|0L
argument_list|)
expr_stmt|;
name|str
operator|=
name|math_getdivertedio
argument_list|()
expr_stmt|;
name|math_fill
argument_list|(
name|str
argument_list|,
name|width
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
name|len
operator|=
name|z
operator|.
name|len
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|zisneg
argument_list|(
name|z
argument_list|)
condition|)
name|PUTCHAR
argument_list|(
literal|'-'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|len
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|*
name|z
operator|.
name|v
operator|<=
operator|(
name|FULL
operator|)
literal|9
operator|)
condition|)
block|{
name|len
operator|=
literal|'0'
operator|+
operator|*
name|z
operator|.
name|v
expr_stmt|;
name|PUTCHAR
argument_list|(
name|len
argument_list|)
expr_stmt|;
return|return;
block|}
name|hp
operator|=
name|z
operator|.
name|v
operator|+
name|len
expr_stmt|;
name|PRINTF1
argument_list|(
literal|"0x%x"
argument_list|,
operator|(
name|FULL
operator|)
operator|*
name|hp
operator|--
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|len
operator|>=
literal|0
condition|)
name|PRINTF1
argument_list|(
literal|"%04x"
argument_list|,
operator|(
name|FULL
operator|)
operator|*
name|hp
operator|--
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Print an integer value as a binary number.  * The special characters 0b appear to indicate the number is binary.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|void
name|zprintb
parameter_list|(
name|z
parameter_list|,
name|width
parameter_list|)
name|ZVALUE
name|z
decl_stmt|;
name|long
name|width
decl_stmt|;
block|{
specifier|register
name|HALF
modifier|*
name|hp
decl_stmt|;
comment|/* current word to print */
name|int
name|len
decl_stmt|;
comment|/* number of halfwords to type */
name|HALF
name|val
decl_stmt|;
comment|/* current value */
name|HALF
name|mask
decl_stmt|;
comment|/* current mask */
name|int
name|didprint
decl_stmt|;
comment|/* nonzero if printed some digits */
name|int
name|ch
decl_stmt|;
comment|/* current char */
name|char
modifier|*
name|str
decl_stmt|;
if|if
condition|(
name|width
condition|)
block|{
name|math_divertio
argument_list|()
expr_stmt|;
name|zprintb
argument_list|(
name|z
argument_list|,
literal|0L
argument_list|)
expr_stmt|;
name|str
operator|=
name|math_getdivertedio
argument_list|()
expr_stmt|;
name|math_fill
argument_list|(
name|str
argument_list|,
name|width
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
name|len
operator|=
name|z
operator|.
name|len
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|zisneg
argument_list|(
name|z
argument_list|)
condition|)
name|PUTCHAR
argument_list|(
literal|'-'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|len
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|*
name|z
operator|.
name|v
operator|<=
operator|(
name|FULL
operator|)
literal|1
operator|)
condition|)
block|{
name|len
operator|=
literal|'0'
operator|+
operator|*
name|z
operator|.
name|v
expr_stmt|;
name|PUTCHAR
argument_list|(
name|len
argument_list|)
expr_stmt|;
return|return;
block|}
name|hp
operator|=
name|z
operator|.
name|v
operator|+
name|len
expr_stmt|;
name|didprint
operator|=
literal|0
expr_stmt|;
name|PUTSTR
argument_list|(
literal|"0b"
argument_list|)
expr_stmt|;
while|while
condition|(
name|len
operator|--
operator|>=
literal|0
condition|)
block|{
name|val
operator|=
operator|*
name|hp
operator|--
expr_stmt|;
name|mask
operator|=
operator|(
literal|1
operator|<<
operator|(
name|BASEB
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
while|while
condition|(
name|mask
condition|)
block|{
name|ch
operator|=
literal|'0'
operator|+
operator|(
operator|(
name|mask
operator|&
name|val
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|didprint
operator|||
operator|(
name|ch
operator|!=
literal|'0'
operator|)
condition|)
block|{
name|PUTCHAR
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|didprint
operator|=
literal|1
expr_stmt|;
block|}
name|mask
operator|>>=
literal|1
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Print an integer value as an octal number.  * The number begins with a leading 0 to indicate that it is octal.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|void
name|zprinto
parameter_list|(
name|z
parameter_list|,
name|width
parameter_list|)
name|ZVALUE
name|z
decl_stmt|;
name|long
name|width
decl_stmt|;
block|{
specifier|register
name|HALF
modifier|*
name|hp
decl_stmt|;
comment|/* current word to print */
name|int
name|len
decl_stmt|;
comment|/* number of halfwords to type */
name|int
name|num1
init|=
literal|'0'
decl_stmt|,
name|num2
init|=
literal|'0'
decl_stmt|;
comment|/* numbers to type */
name|int
name|rem
decl_stmt|;
comment|/* remainder number of halfwords */
name|char
modifier|*
name|str
decl_stmt|;
if|if
condition|(
name|width
condition|)
block|{
name|math_divertio
argument_list|()
expr_stmt|;
name|zprinto
argument_list|(
name|z
argument_list|,
literal|0L
argument_list|)
expr_stmt|;
name|str
operator|=
name|math_getdivertedio
argument_list|()
expr_stmt|;
name|math_fill
argument_list|(
name|str
argument_list|,
name|width
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|zisneg
argument_list|(
name|z
argument_list|)
condition|)
name|PUTCHAR
argument_list|(
literal|'-'
argument_list|)
expr_stmt|;
name|len
operator|=
name|z
operator|.
name|len
expr_stmt|;
if|if
condition|(
operator|(
name|len
operator|==
literal|1
operator|)
operator|&&
operator|(
operator|*
name|z
operator|.
name|v
operator|<=
operator|(
name|FULL
operator|)
literal|7
operator|)
condition|)
block|{
name|num1
operator|=
literal|'0'
operator|+
operator|*
name|z
operator|.
name|v
expr_stmt|;
name|PUTCHAR
argument_list|(
name|num1
argument_list|)
expr_stmt|;
return|return;
block|}
name|hp
operator|=
name|z
operator|.
name|v
operator|+
name|len
operator|-
literal|1
expr_stmt|;
name|rem
operator|=
name|len
operator|%
literal|3
expr_stmt|;
switch|switch
condition|(
name|rem
condition|)
block|{
comment|/* handle odd amounts first */
case|case
literal|0
case|:
name|num1
operator|=
operator|(
operator|(
operator|(
name|FULL
operator|)
name|hp
index|[
literal|0
index|]
operator|)
operator|<<
literal|8
operator|)
operator|+
operator|(
operator|(
operator|(
name|FULL
operator|)
name|hp
index|[
operator|-
literal|1
index|]
operator|)
operator|>>
literal|8
operator|)
expr_stmt|;
name|num2
operator|=
operator|(
operator|(
call|(
name|FULL
call|)
argument_list|(
name|hp
index|[
operator|-
literal|1
index|]
operator|&
literal|0xff
argument_list|)
operator|)
operator|<<
literal|16
operator|)
operator|+
operator|(
operator|(
name|FULL
operator|)
name|hp
index|[
operator|-
literal|2
index|]
operator|)
expr_stmt|;
name|rem
operator|=
literal|3
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|num1
operator|=
literal|0
expr_stmt|;
name|num2
operator|=
operator|(
name|FULL
operator|)
name|hp
index|[
literal|0
index|]
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|num1
operator|=
operator|(
operator|(
operator|(
name|FULL
operator|)
name|hp
index|[
literal|0
index|]
operator|)
operator|>>
literal|8
operator|)
expr_stmt|;
name|num2
operator|=
operator|(
operator|(
call|(
name|FULL
call|)
argument_list|(
name|hp
index|[
literal|0
index|]
operator|&
literal|0xff
argument_list|)
operator|)
operator|<<
literal|16
operator|)
operator|+
operator|(
operator|(
name|FULL
operator|)
name|hp
index|[
operator|-
literal|1
index|]
operator|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|num1
condition|)
name|PRINTF2
argument_list|(
literal|"0%o%08o"
argument_list|,
name|num1
argument_list|,
name|num2
argument_list|)
expr_stmt|;
else|else
name|PRINTF1
argument_list|(
literal|"0%o"
argument_list|,
name|num2
argument_list|)
expr_stmt|;
name|len
operator|-=
name|rem
expr_stmt|;
name|hp
operator|-=
name|rem
expr_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
comment|/* finish in groups of 3 halfwords */
name|num1
operator|=
operator|(
operator|(
operator|(
name|FULL
operator|)
name|hp
index|[
literal|0
index|]
operator|)
operator|<<
literal|8
operator|)
operator|+
operator|(
operator|(
operator|(
name|FULL
operator|)
name|hp
index|[
operator|-
literal|1
index|]
operator|)
operator|>>
literal|8
operator|)
expr_stmt|;
name|num2
operator|=
operator|(
operator|(
call|(
name|FULL
call|)
argument_list|(
name|hp
index|[
operator|-
literal|1
index|]
operator|&
literal|0xff
argument_list|)
operator|)
operator|<<
literal|16
operator|)
operator|+
operator|(
operator|(
name|FULL
operator|)
name|hp
index|[
operator|-
literal|2
index|]
operator|)
expr_stmt|;
name|PRINTF2
argument_list|(
literal|"%08o%08o"
argument_list|,
name|num1
argument_list|,
name|num2
argument_list|)
expr_stmt|;
name|hp
operator|-=
literal|3
expr_stmt|;
name|len
operator|-=
literal|3
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Print a decimal integer to the terminal.  * This works by dividing the number by 10^2^N for some N, and  * then doing this recursively on the quotient and remainder.  * Decimals supplies number of decimal places to print, with a decimal  * point at the right location, with zero meaning no decimal point.  * Width is the number of columns to print the number in, including the  * decimal point and sign if required.  If zero, no extra output is done.  * If positive, leading spaces are typed if necessary. If negative, trailing  * spaces are typed if necessary.  As examples of the effects of these values,  * (345,0,0) = "345", (345,2,0) = "3.45", (345,5,8) = "  .00345".  */
end_comment

begin_function
name|void
name|zprintval
parameter_list|(
name|z
parameter_list|,
name|decimals
parameter_list|,
name|width
parameter_list|)
name|ZVALUE
name|z
decl_stmt|;
comment|/* number to be printed */
name|long
name|decimals
decl_stmt|;
comment|/* number of decimal places */
name|long
name|width
decl_stmt|;
comment|/* number of columns to print in */
block|{
name|int
name|depth
decl_stmt|;
comment|/* maximum depth */
name|int
name|n
decl_stmt|;
comment|/* current index into array */
name|int
name|i
decl_stmt|;
comment|/* number to print */
name|long
name|leadspaces
decl_stmt|;
comment|/* number of leading spaces to print */
name|long
name|putpoint
decl_stmt|;
comment|/* digits until print decimal point */
name|long
name|digits
decl_stmt|;
comment|/* number of digits of raw number */
name|BOOL
name|output
decl_stmt|;
comment|/* TRUE if have output something */
name|BOOL
name|neg
decl_stmt|;
comment|/* TRUE if negative */
name|ZVALUE
name|quo
decl_stmt|,
name|rem
decl_stmt|;
comment|/* quotient and remainder */
name|ZVALUE
name|leftnums
index|[
literal|32
index|]
decl_stmt|;
comment|/* left parts of the number */
name|ZVALUE
name|rightnums
index|[
literal|32
index|]
decl_stmt|;
comment|/* right parts of the number */
if|if
condition|(
name|decimals
operator|<
literal|0
condition|)
name|decimals
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|width
operator|<
literal|0
condition|)
name|width
operator|=
literal|0
expr_stmt|;
name|neg
operator|=
operator|(
name|z
operator|.
name|sign
operator|!=
literal|0
operator|)
expr_stmt|;
name|leadspaces
operator|=
name|width
operator|-
name|neg
operator|-
operator|(
name|decimals
operator|>
literal|0
operator|)
expr_stmt|;
name|z
operator|.
name|sign
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Find the 2^N power of ten which is greater than or equal 	 * to the number, calculating it the first time if necessary. 	 */
name|_tenpowers_
index|[
literal|0
index|]
operator|=
name|_ten_
expr_stmt|;
name|depth
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|_tenpowers_
index|[
name|depth
index|]
operator|.
name|len
operator|<
name|z
operator|.
name|len
operator|)
operator|||
operator|(
name|zrel
argument_list|(
name|_tenpowers_
index|[
name|depth
index|]
argument_list|,
name|z
argument_list|)
operator|<=
literal|0
operator|)
condition|)
block|{
name|depth
operator|++
expr_stmt|;
if|if
condition|(
name|_tenpowers_
index|[
name|depth
index|]
operator|.
name|len
operator|==
literal|0
condition|)
name|zsquare
argument_list|(
name|_tenpowers_
index|[
name|depth
operator|-
literal|1
index|]
argument_list|,
operator|&
name|_tenpowers_
index|[
name|depth
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Divide by smaller 2^N powers of ten until the parts are small 	 * enough to output.  This algorithm walks through a binary tree 	 * where each node is a piece of the number to print, and such that 	 * we visit left nodes first.  We do the needed recursion in line. 	 */
name|digits
operator|=
literal|1
expr_stmt|;
name|output
operator|=
name|FALSE
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
name|putpoint
operator|=
literal|0
expr_stmt|;
name|rightnums
index|[
literal|0
index|]
operator|.
name|len
operator|=
literal|0
expr_stmt|;
name|leftnums
index|[
literal|0
index|]
operator|=
name|z
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
while|while
condition|(
name|n
operator|<
name|depth
condition|)
block|{
name|i
operator|=
name|depth
operator|-
name|n
operator|-
literal|1
expr_stmt|;
name|zdiv
argument_list|(
name|leftnums
index|[
name|n
index|]
argument_list|,
name|_tenpowers_
index|[
name|i
index|]
argument_list|,
operator|&
name|quo
argument_list|,
operator|&
name|rem
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ziszero
argument_list|(
name|quo
argument_list|)
condition|)
name|digits
operator|+=
operator|(
literal|1L
operator|<<
name|i
operator|)
expr_stmt|;
name|n
operator|++
expr_stmt|;
name|leftnums
index|[
name|n
index|]
operator|=
name|quo
expr_stmt|;
name|rightnums
index|[
name|n
index|]
operator|=
name|rem
expr_stmt|;
block|}
name|i
operator|=
name|leftnums
index|[
name|n
index|]
operator|.
name|v
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|output
operator|||
name|i
operator|||
operator|(
name|n
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|output
condition|)
block|{
name|output
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|decimals
operator|>
name|digits
condition|)
name|leadspaces
operator|-=
name|decimals
expr_stmt|;
else|else
name|leadspaces
operator|-=
name|digits
expr_stmt|;
while|while
condition|(
operator|--
name|leadspaces
operator|>=
literal|0
condition|)
name|PUTCHAR
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
name|neg
condition|)
name|PUTCHAR
argument_list|(
literal|'-'
argument_list|)
expr_stmt|;
if|if
condition|(
name|decimals
condition|)
block|{
name|putpoint
operator|=
operator|(
name|digits
operator|-
name|decimals
operator|)
expr_stmt|;
if|if
condition|(
name|putpoint
operator|<=
literal|0
condition|)
block|{
name|PUTCHAR
argument_list|(
literal|'.'
argument_list|)
expr_stmt|;
while|while
condition|(
operator|++
name|putpoint
operator|<=
literal|0
condition|)
name|PUTCHAR
argument_list|(
literal|'0'
argument_list|)
expr_stmt|;
name|putpoint
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
name|i
operator|+=
literal|'0'
expr_stmt|;
name|PUTCHAR
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|putpoint
operator|==
literal|0
condition|)
name|PUTCHAR
argument_list|(
literal|'.'
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|rightnums
index|[
name|n
index|]
operator|.
name|len
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|n
operator|<=
literal|0
condition|)
return|return;
if|if
condition|(
name|leftnums
index|[
name|n
index|]
operator|.
name|len
condition|)
name|zfree
argument_list|(
name|leftnums
index|[
name|n
index|]
argument_list|)
expr_stmt|;
name|n
operator|--
expr_stmt|;
block|}
name|zfree
argument_list|(
name|leftnums
index|[
name|n
index|]
argument_list|)
expr_stmt|;
name|leftnums
index|[
name|n
index|]
operator|=
name|rightnums
index|[
name|n
index|]
expr_stmt|;
name|rightnums
index|[
name|n
index|]
operator|.
name|len
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Read an integer value in decimal, hex, octal, or binary.  * Hex numbers are indicated by a leading "0x", binary with a leading "0b",  * and octal by a leading "0".  Periods are skipped over, but any other  * extraneous character stops the scan.  */
end_comment

begin_function
name|void
name|atoz
parameter_list|(
name|s
parameter_list|,
name|res
parameter_list|)
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
name|ZVALUE
modifier|*
name|res
decl_stmt|;
block|{
name|ZVALUE
name|z
decl_stmt|,
name|ztmp
decl_stmt|,
name|digit
decl_stmt|;
name|HALF
name|digval
decl_stmt|;
name|BOOL
name|minus
decl_stmt|;
name|long
name|shift
decl_stmt|;
name|minus
operator|=
name|FALSE
expr_stmt|;
name|shift
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'+'
condition|)
name|s
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|'-'
condition|)
block|{
name|minus
operator|=
name|TRUE
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|s
operator|==
literal|'0'
condition|)
block|{
comment|/* possibly hex, octal, or binary */
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|s
operator|>=
literal|'0'
operator|)
operator|&&
operator|(
operator|*
name|s
operator|<=
literal|'7'
operator|)
condition|)
block|{
name|shift
operator|=
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|s
operator|==
literal|'x'
operator|)
operator|||
operator|(
operator|*
name|s
operator|==
literal|'X'
operator|)
condition|)
block|{
name|shift
operator|=
literal|4
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|s
operator|==
literal|'b'
operator|)
operator|||
operator|(
operator|*
name|s
operator|==
literal|'B'
operator|)
condition|)
block|{
name|shift
operator|=
literal|1
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
block|}
name|digit
operator|.
name|v
operator|=
operator|&
name|digval
expr_stmt|;
name|digit
operator|.
name|len
operator|=
literal|1
expr_stmt|;
name|digit
operator|.
name|sign
operator|=
literal|0
expr_stmt|;
name|z
operator|=
name|_zero_
expr_stmt|;
while|while
condition|(
operator|*
name|s
condition|)
block|{
name|digval
operator|=
operator|*
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|digval
operator|>=
literal|'0'
operator|)
operator|&&
operator|(
name|digval
operator|<=
literal|'9'
operator|)
condition|)
name|digval
operator|-=
literal|'0'
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|digval
operator|>=
literal|'a'
operator|)
operator|&&
operator|(
name|digval
operator|<=
literal|'f'
operator|)
operator|&&
name|shift
condition|)
name|digval
operator|-=
operator|(
literal|'a'
operator|-
literal|10
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|digval
operator|>=
literal|'A'
operator|)
operator|&&
operator|(
name|digval
operator|<=
literal|'F'
operator|)
operator|&&
name|shift
condition|)
name|digval
operator|-=
operator|(
literal|'A'
operator|-
literal|10
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|digval
operator|==
literal|'.'
condition|)
continue|continue;
else|else
break|break;
if|if
condition|(
name|shift
condition|)
name|zshift
argument_list|(
name|z
argument_list|,
name|shift
argument_list|,
operator|&
name|ztmp
argument_list|)
expr_stmt|;
else|else
name|zmuli
argument_list|(
name|z
argument_list|,
literal|10L
argument_list|,
operator|&
name|ztmp
argument_list|)
expr_stmt|;
name|zfree
argument_list|(
name|z
argument_list|)
expr_stmt|;
name|zadd
argument_list|(
name|ztmp
argument_list|,
name|digit
argument_list|,
operator|&
name|z
argument_list|)
expr_stmt|;
name|zfree
argument_list|(
name|ztmp
argument_list|)
expr_stmt|;
block|}
name|ztrim
argument_list|(
operator|&
name|z
argument_list|)
expr_stmt|;
if|if
condition|(
name|minus
operator|&&
operator|!
name|ziszero
argument_list|(
name|z
argument_list|)
condition|)
name|z
operator|.
name|sign
operator|=
literal|1
expr_stmt|;
operator|*
name|res
operator|=
name|z
expr_stmt|;
block|}
end_function

begin_comment
comment|/* END CODE */
end_comment

end_unit

