begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1994 David I. Bell  * Permission is granted to use, distribute, or modify this source,  * provided that this copyright notice remains intact.  *  * String list routines.  */
end_comment

begin_include
include|#
directive|include
file|"calc.h"
end_include

begin_include
include|#
directive|include
file|"string.h"
end_include

begin_define
define|#
directive|define
name|STR_TABLECHUNK
value|100
end_define

begin_comment
comment|/* how often to reallocate string table */
end_comment

begin_define
define|#
directive|define
name|STR_CHUNK
value|2000
end_define

begin_comment
comment|/* size of string storage allocation */
end_comment

begin_define
define|#
directive|define
name|STR_UNIQUE
value|100
end_define

begin_comment
comment|/* size of string to allocate separately */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|chartable
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* single character string table */
end_comment

begin_struct
specifier|static
struct|struct
block|{
name|long
name|l_count
decl_stmt|;
comment|/* count of strings in table */
name|long
name|l_maxcount
decl_stmt|;
comment|/* maximum strings storable in table */
name|long
name|l_avail
decl_stmt|;
comment|/* characters available in current string */
name|char
modifier|*
name|l_alloc
decl_stmt|;
comment|/* next available string storage */
name|char
modifier|*
modifier|*
name|l_table
decl_stmt|;
comment|/* current string table */
block|}
name|literals
struct|;
end_struct

begin_comment
comment|/*  * Initialize or reinitialize a string header for use.  */
end_comment

begin_function
name|void
name|initstr
parameter_list|(
name|hp
parameter_list|)
specifier|register
name|STRINGHEAD
modifier|*
name|hp
decl_stmt|;
comment|/* structure to be inited */
block|{
if|if
condition|(
name|hp
operator|->
name|h_list
operator|==
name|NULL
condition|)
block|{
name|hp
operator|->
name|h_list
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
literal|2000
argument_list|)
expr_stmt|;
name|hp
operator|->
name|h_avail
operator|=
literal|2000
expr_stmt|;
name|hp
operator|->
name|h_used
operator|=
literal|0
expr_stmt|;
block|}
name|hp
operator|->
name|h_avail
operator|+=
name|hp
operator|->
name|h_used
expr_stmt|;
name|hp
operator|->
name|h_used
operator|=
literal|0
expr_stmt|;
name|hp
operator|->
name|h_count
operator|=
literal|0
expr_stmt|;
name|hp
operator|->
name|h_list
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|hp
operator|->
name|h_list
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Copy a string to the end of a list of strings, and return the address  * of the copied string.  Returns NULL if the string could not be copied.  * No checks are made to see if the string is already in the list.  * The string cannot be null or have imbedded nulls.  */
end_comment

begin_function
name|char
modifier|*
name|addstr
parameter_list|(
name|hp
parameter_list|,
name|str
parameter_list|)
specifier|register
name|STRINGHEAD
modifier|*
name|hp
decl_stmt|;
comment|/* header of string storage */
name|char
modifier|*
name|str
decl_stmt|;
comment|/* string to be added */
block|{
name|char
modifier|*
name|retstr
decl_stmt|;
comment|/* returned string pointer */
name|char
modifier|*
name|list
decl_stmt|;
comment|/* string list */
name|long
name|newsize
decl_stmt|;
comment|/* new size of string list */
name|long
name|len
decl_stmt|;
comment|/* length of current string */
if|if
condition|(
operator|(
name|str
operator|==
name|NULL
operator|)
operator|||
operator|(
operator|*
name|str
operator|==
literal|'\0'
operator|)
condition|)
return|return
name|NULL
return|;
name|len
operator|=
name|strlen
argument_list|(
name|str
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|h_avail
operator|<=
name|len
condition|)
block|{
name|newsize
operator|=
name|len
operator|+
literal|2000
operator|+
name|hp
operator|->
name|h_used
operator|+
name|hp
operator|->
name|h_avail
expr_stmt|;
name|list
operator|=
operator|(
name|char
operator|*
operator|)
name|realloc
argument_list|(
name|hp
operator|->
name|h_list
argument_list|,
name|newsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|list
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|hp
operator|->
name|h_list
operator|=
name|list
expr_stmt|;
name|hp
operator|->
name|h_avail
operator|=
name|newsize
operator|-
name|hp
operator|->
name|h_used
expr_stmt|;
block|}
name|retstr
operator|=
name|hp
operator|->
name|h_list
operator|+
name|hp
operator|->
name|h_used
expr_stmt|;
name|hp
operator|->
name|h_used
operator|+=
name|len
expr_stmt|;
name|hp
operator|->
name|h_avail
operator|-=
name|len
expr_stmt|;
name|hp
operator|->
name|h_count
operator|++
expr_stmt|;
name|strcpy
argument_list|(
name|retstr
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|retstr
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|retstr
return|;
block|}
end_function

begin_comment
comment|/*  * Return a null-terminated string which consists of a single character.  * The table is initialized on the first call.  */
end_comment

begin_function
name|char
modifier|*
name|charstr
parameter_list|(
name|ch
parameter_list|)
name|int
name|ch
decl_stmt|;
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|chartable
operator|==
name|NULL
condition|)
block|{
name|cp
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
literal|512
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
name|math_error
argument_list|(
literal|"Cannot allocate character table"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|cp
operator|++
operator|=
operator|(
name|char
operator|)
name|i
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
literal|'\0'
expr_stmt|;
block|}
name|chartable
operator|=
name|cp
operator|-
literal|512
expr_stmt|;
block|}
return|return
operator|&
name|chartable
index|[
operator|(
name|ch
operator|&
literal|0xff
operator|)
operator|*
literal|2
index|]
return|;
block|}
end_function

begin_comment
comment|/*  * Find a string with the specified name and return its number in the  * string list.  The first string is numbered zero.  Minus one is returned  * if the string is not found.  */
end_comment

begin_function
name|long
name|findstr
parameter_list|(
name|hp
parameter_list|,
name|str
parameter_list|)
name|STRINGHEAD
modifier|*
name|hp
decl_stmt|;
comment|/* header of string storage */
specifier|register
name|char
modifier|*
name|str
decl_stmt|;
comment|/* string to be added */
block|{
specifier|register
name|char
modifier|*
name|test
decl_stmt|;
comment|/* string being tested */
name|long
name|len
decl_stmt|;
comment|/* length of string being found */
name|long
name|testlen
decl_stmt|;
comment|/* length of test string */
name|long
name|index
decl_stmt|;
comment|/* index of string */
if|if
condition|(
operator|(
name|hp
operator|->
name|h_count
operator|<=
literal|0
operator|)
operator|||
operator|(
name|str
operator|==
name|NULL
operator|)
condition|)
return|return
operator|-
literal|1
return|;
name|len
operator|=
name|strlen
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|test
operator|=
name|hp
operator|->
name|h_list
expr_stmt|;
name|index
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|test
condition|)
block|{
name|testlen
operator|=
name|strlen
argument_list|(
name|test
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|testlen
operator|==
name|len
operator|)
operator|&&
operator|(
operator|*
name|test
operator|==
operator|*
name|str
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|test
argument_list|,
name|str
argument_list|)
operator|==
literal|0
operator|)
condition|)
return|return
name|index
return|;
name|test
operator|+=
operator|(
name|testlen
operator|+
literal|1
operator|)
expr_stmt|;
name|index
operator|++
expr_stmt|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Return the name of a string with the given index.  * If the index is illegal, a pointer to an empty string is returned.  */
end_comment

begin_function
name|char
modifier|*
name|namestr
parameter_list|(
name|hp
parameter_list|,
name|n
parameter_list|)
name|STRINGHEAD
modifier|*
name|hp
decl_stmt|;
comment|/* header of string storage */
name|long
name|n
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|str
decl_stmt|;
comment|/* current string */
if|if
condition|(
operator|(
name|unsigned
name|long
operator|)
name|n
operator|>=
name|hp
operator|->
name|h_count
condition|)
return|return
literal|""
return|;
name|str
operator|=
name|hp
operator|->
name|h_list
expr_stmt|;
while|while
condition|(
operator|*
name|str
condition|)
block|{
if|if
condition|(
operator|--
name|n
operator|<
literal|0
condition|)
return|return
name|str
return|;
name|str
operator|+=
operator|(
name|strlen
argument_list|(
name|str
argument_list|)
operator|+
literal|1
operator|)
expr_stmt|;
block|}
return|return
literal|""
return|;
block|}
end_function

begin_comment
comment|/*  * Useful routine to return the index of one string within another one  * which has the format:  "str1\0str2\0str3\0...strn\0\0".  Index starts  * at one for the first string.  Returns zero if the string being checked  * is not contained in the formatted string.  */
end_comment

begin_function
name|long
name|stringindex
parameter_list|(
name|format
parameter_list|,
name|test
parameter_list|)
specifier|register
name|char
modifier|*
name|format
decl_stmt|;
comment|/* string formatted into substrings */
name|char
modifier|*
name|test
decl_stmt|;
comment|/* string to be found in formatted string */
block|{
name|long
name|index
decl_stmt|;
comment|/* found index */
name|long
name|len
decl_stmt|;
comment|/* length of current piece of string */
name|long
name|testlen
decl_stmt|;
comment|/* length of test string */
name|testlen
operator|=
name|strlen
argument_list|(
name|test
argument_list|)
expr_stmt|;
name|index
operator|=
literal|1
expr_stmt|;
while|while
condition|(
operator|*
name|format
condition|)
block|{
name|len
operator|=
name|strlen
argument_list|(
name|format
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|len
operator|==
name|testlen
operator|)
operator|&&
operator|(
operator|*
name|format
operator|==
operator|*
name|test
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|format
argument_list|,
name|test
argument_list|)
operator|==
literal|0
operator|)
condition|)
return|return
name|index
return|;
name|format
operator|+=
operator|(
name|len
operator|+
literal|1
operator|)
expr_stmt|;
name|index
operator|++
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Add a possibly new literal string to the literal string pool.  * Returns the new string address which is guaranteed to be always valid.  * Duplicate strings will repeatedly return the same address.  */
end_comment

begin_function
name|char
modifier|*
name|addliteral
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
modifier|*
name|table
decl_stmt|;
comment|/* table of strings */
name|char
modifier|*
name|newstr
decl_stmt|;
comment|/* newly allocated string */
name|long
name|count
decl_stmt|;
comment|/* number of strings */
name|long
name|len
decl_stmt|;
comment|/* length of string to allocate */
name|len
operator|=
name|strlen
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<=
literal|1
condition|)
return|return
name|charstr
argument_list|(
operator|*
name|str
argument_list|)
return|;
comment|/* 	 * See if the string is already in the table. 	 */
name|table
operator|=
name|literals
operator|.
name|l_table
expr_stmt|;
name|count
operator|=
name|literals
operator|.
name|l_count
expr_stmt|;
while|while
condition|(
name|count
operator|--
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|str
index|[
literal|0
index|]
operator|==
name|table
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|)
operator|&&
operator|(
name|str
index|[
literal|1
index|]
operator|==
name|table
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|str
argument_list|,
name|table
index|[
literal|0
index|]
argument_list|)
operator|==
literal|0
operator|)
condition|)
return|return
name|table
index|[
literal|0
index|]
return|;
name|table
operator|++
expr_stmt|;
block|}
comment|/* 	 * Make the table of string pointers larger if necessary. 	 */
if|if
condition|(
name|literals
operator|.
name|l_count
operator|>=
name|literals
operator|.
name|l_maxcount
condition|)
block|{
name|count
operator|=
name|literals
operator|.
name|l_maxcount
operator|+
name|STR_TABLECHUNK
expr_stmt|;
if|if
condition|(
name|literals
operator|.
name|l_maxcount
condition|)
name|table
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|realloc
argument_list|(
name|literals
operator|.
name|l_table
argument_list|,
name|count
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|table
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|malloc
argument_list|(
name|count
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|table
operator|==
name|NULL
condition|)
name|math_error
argument_list|(
literal|"Cannot allocate string literal table"
argument_list|)
expr_stmt|;
name|literals
operator|.
name|l_table
operator|=
name|table
expr_stmt|;
name|literals
operator|.
name|l_maxcount
operator|=
name|count
expr_stmt|;
block|}
name|table
operator|=
name|literals
operator|.
name|l_table
expr_stmt|;
comment|/* 	 * If the new string is very long, allocate it manually. 	 */
name|len
operator|=
operator|(
name|len
operator|+
literal|2
operator|)
operator|&
operator|~
literal|1
expr_stmt|;
comment|/* add room for null and round up to word */
if|if
condition|(
name|len
operator|>=
name|STR_UNIQUE
condition|)
block|{
name|newstr
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|newstr
operator|==
name|NULL
condition|)
name|math_error
argument_list|(
literal|"Cannot allocate large literal string"
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|newstr
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|table
index|[
name|literals
operator|.
name|l_count
operator|++
index|]
operator|=
name|newstr
expr_stmt|;
return|return
name|newstr
return|;
block|}
comment|/* 	 * If the remaining space in the allocate string is too small, 	 * then allocate a new one. 	 */
if|if
condition|(
name|literals
operator|.
name|l_avail
operator|<
name|len
condition|)
block|{
name|newstr
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|STR_CHUNK
argument_list|)
expr_stmt|;
if|if
condition|(
name|newstr
operator|==
name|NULL
condition|)
name|math_error
argument_list|(
literal|"Cannot allocate new literal string"
argument_list|)
expr_stmt|;
name|literals
operator|.
name|l_alloc
operator|=
name|newstr
expr_stmt|;
name|literals
operator|.
name|l_avail
operator|=
name|STR_CHUNK
expr_stmt|;
block|}
comment|/* 	 * Allocate the new string from the allocate string. 	 */
name|newstr
operator|=
name|literals
operator|.
name|l_alloc
expr_stmt|;
name|literals
operator|.
name|l_avail
operator|-=
name|len
expr_stmt|;
name|literals
operator|.
name|l_alloc
operator|+=
name|len
expr_stmt|;
name|table
index|[
name|literals
operator|.
name|l_count
operator|++
index|]
operator|=
name|newstr
expr_stmt|;
name|strcpy
argument_list|(
name|newstr
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return
name|newstr
return|;
block|}
end_function

begin_comment
comment|/*  * Calculate a trivial hash value for a string.  */
end_comment

begin_function
name|HASH
name|hashstr
parameter_list|(
name|cp
parameter_list|)
name|char
modifier|*
name|cp
decl_stmt|;
block|{
name|int
name|len
decl_stmt|;
name|HASH
name|hash
decl_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|hash
operator|=
name|len
operator|*
literal|300007
expr_stmt|;
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
comment|/* ignore Saber-C warning about Over/underflow */
name|hash
operator|=
name|hash
operator|*
literal|300017
operator|+
operator|*
name|cp
operator|++
operator|+
literal|300043
expr_stmt|;
return|return
name|hash
return|;
block|}
end_function

begin_comment
comment|/* END CODE */
end_comment

end_unit

