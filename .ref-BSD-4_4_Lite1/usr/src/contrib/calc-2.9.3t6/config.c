begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1994 David I. Bell  * Permission is granted to use, distribute, or modify this source,  * provided that this copyright notice remains intact.  *  * Configuration routines.  */
end_comment

begin_include
include|#
directive|include
file|"calc.h"
end_include

begin_comment
comment|/*  * Configuration parameter name and type.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|char
modifier|*
name|name
decl_stmt|;
comment|/* name of configuration string */
name|int
name|type
decl_stmt|;
comment|/* type for configuration */
block|}
name|CONFIG
typedef|;
end_typedef

begin_comment
comment|/*  * Table of configuration types that can be set or read.  */
end_comment

begin_decl_stmt
specifier|static
name|CONFIG
name|configs
index|[]
init|=
block|{
literal|"trace"
block|,
name|CONFIG_TRACE
block|,
literal|"display"
block|,
name|CONFIG_DISPLAY
block|,
literal|"epsilon"
block|,
name|CONFIG_EPSILON
block|,
literal|"mode"
block|,
name|CONFIG_MODE
block|,
literal|"maxprint"
block|,
name|CONFIG_MAXPRINT
block|,
literal|"mul2"
block|,
name|CONFIG_MUL2
block|,
literal|"sq2"
block|,
name|CONFIG_SQ2
block|,
literal|"pow2"
block|,
name|CONFIG_POW2
block|,
literal|"redc2"
block|,
name|CONFIG_REDC2
block|,
literal|"tilde"
block|,
name|CONFIG_TILDE
block|,
literal|"tab"
block|,
name|CONFIG_TAB
block|,
name|NULL
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Possible output modes.  */
end_comment

begin_decl_stmt
specifier|static
name|CONFIG
name|modes
index|[]
init|=
block|{
literal|"frac"
block|,
name|MODE_FRAC
block|,
literal|"decimal"
block|,
name|MODE_FRAC
block|,
literal|"dec"
block|,
name|MODE_FRAC
block|,
literal|"int"
block|,
name|MODE_INT
block|,
literal|"real"
block|,
name|MODE_REAL
block|,
literal|"exp"
block|,
name|MODE_EXP
block|,
literal|"hexadecimal"
block|,
name|MODE_HEX
block|,
literal|"hex"
block|,
name|MODE_HEX
block|,
literal|"octal"
block|,
name|MODE_OCTAL
block|,
literal|"oct"
block|,
name|MODE_OCTAL
block|,
literal|"binary"
block|,
name|MODE_BINARY
block|,
literal|"bin"
block|,
name|MODE_BINARY
block|,
name|NULL
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Possible binary config state values  */
end_comment

begin_decl_stmt
specifier|static
name|CONFIG
name|truth
index|[]
init|=
block|{
literal|"y"
block|,
name|TRUE
block|,
literal|"n"
block|,
name|FALSE
block|,
literal|"yes"
block|,
name|TRUE
block|,
literal|"no"
block|,
name|FALSE
block|,
literal|"set"
block|,
name|TRUE
block|,
literal|"unset"
block|,
name|FALSE
block|,
literal|"on"
block|,
name|TRUE
block|,
literal|"off"
block|,
name|FALSE
block|,
literal|"true"
block|,
name|TRUE
block|,
literal|"false"
block|,
name|FALSE
block|,
literal|"t"
block|,
name|TRUE
block|,
literal|"f"
block|,
name|FALSE
block|,
literal|"1"
block|,
name|TRUE
block|,
literal|"0"
block|,
name|FALSE
block|,
name|NULL
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Given a string value which represents a configuration name, return  * the configuration type for that string.  Returns negative type if  * the string is unknown.  */
end_comment

begin_function
name|int
name|configtype
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
comment|/* configuration name */
block|{
name|CONFIG
modifier|*
name|cp
decl_stmt|;
comment|/* current config pointer */
for|for
control|(
name|cp
operator|=
name|configs
init|;
name|cp
operator|->
name|name
condition|;
name|cp
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|cp
operator|->
name|name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
name|cp
operator|->
name|type
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Given the name of a mode, convert it to the internal format.  * Returns -1 if the string is unknown.  */
end_comment

begin_function
specifier|static
name|int
name|modetype
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
comment|/* mode name */
block|{
name|CONFIG
modifier|*
name|cp
decl_stmt|;
comment|/* current config pointer */
for|for
control|(
name|cp
operator|=
name|modes
init|;
name|cp
operator|->
name|name
condition|;
name|cp
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|cp
operator|->
name|name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
name|cp
operator|->
name|type
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Given the name of a truth value, convert it to a BOOL or -1.  * Returns -1 if the string is unknown.  */
end_comment

begin_function
specifier|static
name|int
name|truthtype
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
comment|/* mode name */
block|{
name|CONFIG
modifier|*
name|cp
decl_stmt|;
comment|/* current config pointer */
for|for
control|(
name|cp
operator|=
name|truth
init|;
name|cp
operator|->
name|name
condition|;
name|cp
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|cp
operator|->
name|name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
name|cp
operator|->
name|type
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Given the mode type, convert it to a string representing that mode.  * Where there are multiple strings representing the same mode, the first  * one in the table is used.  Returns NULL if the node type is unknown.  * The returned string cannot be modified.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|modename
parameter_list|(
name|type
parameter_list|)
name|int
name|type
decl_stmt|;
block|{
name|CONFIG
modifier|*
name|cp
decl_stmt|;
comment|/* current config pointer */
for|for
control|(
name|cp
operator|=
name|modes
init|;
name|cp
operator|->
name|name
condition|;
name|cp
operator|++
control|)
block|{
if|if
condition|(
name|type
operator|==
name|cp
operator|->
name|type
condition|)
return|return
name|cp
operator|->
name|name
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * Set the specified configuration type to the specified value.  * An error is generated if the type number or value is illegal.  */
end_comment

begin_function
name|void
name|setconfig
parameter_list|(
name|type
parameter_list|,
name|vp
parameter_list|)
name|int
name|type
decl_stmt|;
name|VALUE
modifier|*
name|vp
decl_stmt|;
block|{
name|NUMBER
modifier|*
name|q
decl_stmt|;
name|long
name|temp
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|CONFIG_TRACE
case|:
if|if
condition|(
name|vp
operator|->
name|v_type
operator|!=
name|V_NUM
condition|)
name|math_error
argument_list|(
literal|"Non-numeric for trace"
argument_list|)
expr_stmt|;
name|q
operator|=
name|vp
operator|->
name|v_num
expr_stmt|;
name|temp
operator|=
name|qtoi
argument_list|(
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
name|qisfrac
argument_list|(
name|q
argument_list|)
operator|||
operator|!
name|zistiny
argument_list|(
name|q
operator|->
name|num
argument_list|)
operator|||
operator|(
operator|(
name|unsigned
name|long
operator|)
name|temp
operator|>
name|TRACE_MAX
operator|)
condition|)
name|math_error
argument_list|(
literal|"Bad trace value"
argument_list|)
expr_stmt|;
name|traceflags
operator|=
operator|(
name|FLAG
operator|)
name|temp
expr_stmt|;
break|break;
case|case
name|CONFIG_DISPLAY
case|:
if|if
condition|(
name|vp
operator|->
name|v_type
operator|!=
name|V_NUM
condition|)
name|math_error
argument_list|(
literal|"Non-numeric for display"
argument_list|)
expr_stmt|;
name|q
operator|=
name|vp
operator|->
name|v_num
expr_stmt|;
name|temp
operator|=
name|qtoi
argument_list|(
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
name|qisfrac
argument_list|(
name|q
argument_list|)
operator|||
name|qisneg
argument_list|(
name|q
argument_list|)
operator|||
operator|!
name|zistiny
argument_list|(
name|q
operator|->
name|num
argument_list|)
condition|)
name|temp
operator|=
operator|-
literal|1
expr_stmt|;
name|math_setdigits
argument_list|(
name|temp
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONFIG_MODE
case|:
if|if
condition|(
name|vp
operator|->
name|v_type
operator|!=
name|V_STR
condition|)
name|math_error
argument_list|(
literal|"Non-string for mode"
argument_list|)
expr_stmt|;
name|temp
operator|=
name|modetype
argument_list|(
name|vp
operator|->
name|v_str
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|<
literal|0
condition|)
name|math_error
argument_list|(
literal|"Unknown mode \"%s\""
argument_list|,
name|vp
operator|->
name|v_str
argument_list|)
expr_stmt|;
name|math_setmode
argument_list|(
operator|(
name|int
operator|)
name|temp
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONFIG_EPSILON
case|:
if|if
condition|(
name|vp
operator|->
name|v_type
operator|!=
name|V_NUM
condition|)
name|math_error
argument_list|(
literal|"Non-numeric for epsilon"
argument_list|)
expr_stmt|;
name|setepsilon
argument_list|(
name|vp
operator|->
name|v_num
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONFIG_MAXPRINT
case|:
if|if
condition|(
name|vp
operator|->
name|v_type
operator|!=
name|V_NUM
condition|)
name|math_error
argument_list|(
literal|"Non-numeric for maxprint"
argument_list|)
expr_stmt|;
name|q
operator|=
name|vp
operator|->
name|v_num
expr_stmt|;
name|temp
operator|=
name|qtoi
argument_list|(
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
name|qisfrac
argument_list|(
name|q
argument_list|)
operator|||
name|qisneg
argument_list|(
name|q
argument_list|)
operator|||
operator|!
name|zistiny
argument_list|(
name|q
operator|->
name|num
argument_list|)
condition|)
name|temp
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|temp
operator|<
literal|0
condition|)
name|math_error
argument_list|(
literal|"Maxprint value is out of range"
argument_list|)
expr_stmt|;
name|maxprint
operator|=
name|temp
expr_stmt|;
break|break;
case|case
name|CONFIG_MUL2
case|:
if|if
condition|(
name|vp
operator|->
name|v_type
operator|!=
name|V_NUM
condition|)
name|math_error
argument_list|(
literal|"Non-numeric for mul2"
argument_list|)
expr_stmt|;
name|q
operator|=
name|vp
operator|->
name|v_num
expr_stmt|;
name|temp
operator|=
name|qtoi
argument_list|(
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
name|qisfrac
argument_list|(
name|q
argument_list|)
operator|||
name|qisneg
argument_list|(
name|q
argument_list|)
condition|)
name|temp
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|temp
operator|==
literal|0
condition|)
name|temp
operator|=
name|MUL_ALG2
expr_stmt|;
if|if
condition|(
name|temp
operator|<
literal|2
condition|)
name|math_error
argument_list|(
literal|"Illegal mul2 value"
argument_list|)
expr_stmt|;
name|_mul2_
operator|=
name|temp
expr_stmt|;
break|break;
case|case
name|CONFIG_SQ2
case|:
if|if
condition|(
name|vp
operator|->
name|v_type
operator|!=
name|V_NUM
condition|)
name|math_error
argument_list|(
literal|"Non-numeric for sq2"
argument_list|)
expr_stmt|;
name|q
operator|=
name|vp
operator|->
name|v_num
expr_stmt|;
name|temp
operator|=
name|qtoi
argument_list|(
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
name|qisfrac
argument_list|(
name|q
argument_list|)
operator|||
name|qisneg
argument_list|(
name|q
argument_list|)
condition|)
name|temp
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|temp
operator|==
literal|0
condition|)
name|temp
operator|=
name|SQ_ALG2
expr_stmt|;
if|if
condition|(
name|temp
operator|<
literal|2
condition|)
name|math_error
argument_list|(
literal|"Illegal sq2 value"
argument_list|)
expr_stmt|;
name|_sq2_
operator|=
name|temp
expr_stmt|;
break|break;
case|case
name|CONFIG_POW2
case|:
if|if
condition|(
name|vp
operator|->
name|v_type
operator|!=
name|V_NUM
condition|)
name|math_error
argument_list|(
literal|"Non-numeric for pow2"
argument_list|)
expr_stmt|;
name|q
operator|=
name|vp
operator|->
name|v_num
expr_stmt|;
name|temp
operator|=
name|qtoi
argument_list|(
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
name|qisfrac
argument_list|(
name|q
argument_list|)
operator|||
name|qisneg
argument_list|(
name|q
argument_list|)
condition|)
name|temp
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|temp
operator|==
literal|0
condition|)
name|temp
operator|=
name|POW_ALG2
expr_stmt|;
if|if
condition|(
name|temp
operator|<
literal|1
condition|)
name|math_error
argument_list|(
literal|"Illegal pow2 value"
argument_list|)
expr_stmt|;
name|_pow2_
operator|=
name|temp
expr_stmt|;
break|break;
case|case
name|CONFIG_REDC2
case|:
if|if
condition|(
name|vp
operator|->
name|v_type
operator|!=
name|V_NUM
condition|)
name|math_error
argument_list|(
literal|"Non-numeric for redc2"
argument_list|)
expr_stmt|;
name|q
operator|=
name|vp
operator|->
name|v_num
expr_stmt|;
name|temp
operator|=
name|qtoi
argument_list|(
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
name|qisfrac
argument_list|(
name|q
argument_list|)
operator|||
name|qisneg
argument_list|(
name|q
argument_list|)
condition|)
name|temp
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|temp
operator|==
literal|0
condition|)
name|temp
operator|=
name|REDC_ALG2
expr_stmt|;
if|if
condition|(
name|temp
operator|<
literal|1
condition|)
name|math_error
argument_list|(
literal|"Illegal redc2 value"
argument_list|)
expr_stmt|;
name|_redc2_
operator|=
name|temp
expr_stmt|;
break|break;
case|case
name|CONFIG_TILDE
case|:
if|if
condition|(
name|vp
operator|->
name|v_type
operator|==
name|V_NUM
condition|)
block|{
name|q
operator|=
name|vp
operator|->
name|v_num
expr_stmt|;
name|tilde_ok
operator|=
operator|!
name|qiszero
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vp
operator|->
name|v_type
operator|==
name|V_STR
condition|)
block|{
name|temp
operator|=
name|truthtype
argument_list|(
name|vp
operator|->
name|v_str
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|<
literal|0
condition|)
block|{
name|math_error
argument_list|(
literal|"Illegal truth value"
argument_list|)
expr_stmt|;
block|}
name|tilde_ok
operator|=
name|temp
expr_stmt|;
block|}
break|break;
case|case
name|CONFIG_TAB
case|:
if|if
condition|(
name|vp
operator|->
name|v_type
operator|==
name|V_NUM
condition|)
block|{
name|q
operator|=
name|vp
operator|->
name|v_num
expr_stmt|;
name|tab_ok
operator|=
operator|!
name|qiszero
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vp
operator|->
name|v_type
operator|==
name|V_STR
condition|)
block|{
name|temp
operator|=
name|truthtype
argument_list|(
name|vp
operator|->
name|v_str
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|<
literal|0
condition|)
block|{
name|math_error
argument_list|(
literal|"Illegal truth value"
argument_list|)
expr_stmt|;
block|}
name|tab_ok
operator|=
name|temp
expr_stmt|;
block|}
break|break;
default|default:
name|math_error
argument_list|(
literal|"Setting illegal config parameter"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Get the current value of the specified configuration type.  * An error is generated if the type number is illegal.  */
end_comment

begin_function
name|void
name|getconfig
parameter_list|(
name|type
parameter_list|,
name|vp
parameter_list|)
name|int
name|type
decl_stmt|;
name|VALUE
modifier|*
name|vp
decl_stmt|;
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|CONFIG_TRACE
case|:
name|vp
operator|->
name|v_type
operator|=
name|V_NUM
expr_stmt|;
name|vp
operator|->
name|v_num
operator|=
name|itoq
argument_list|(
operator|(
name|long
operator|)
name|traceflags
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONFIG_DISPLAY
case|:
name|vp
operator|->
name|v_type
operator|=
name|V_NUM
expr_stmt|;
name|vp
operator|->
name|v_num
operator|=
name|itoq
argument_list|(
name|_outdigits_
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONFIG_MODE
case|:
name|vp
operator|->
name|v_type
operator|=
name|V_STR
expr_stmt|;
name|vp
operator|->
name|v_subtype
operator|=
name|V_STRLITERAL
expr_stmt|;
name|vp
operator|->
name|v_str
operator|=
name|modename
argument_list|(
name|_outmode_
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONFIG_EPSILON
case|:
name|vp
operator|->
name|v_type
operator|=
name|V_NUM
expr_stmt|;
name|vp
operator|->
name|v_num
operator|=
name|qlink
argument_list|(
name|_epsilon_
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONFIG_MAXPRINT
case|:
name|vp
operator|->
name|v_type
operator|=
name|V_NUM
expr_stmt|;
name|vp
operator|->
name|v_num
operator|=
name|itoq
argument_list|(
name|maxprint
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONFIG_MUL2
case|:
name|vp
operator|->
name|v_type
operator|=
name|V_NUM
expr_stmt|;
name|vp
operator|->
name|v_num
operator|=
name|itoq
argument_list|(
name|_mul2_
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONFIG_SQ2
case|:
name|vp
operator|->
name|v_type
operator|=
name|V_NUM
expr_stmt|;
name|vp
operator|->
name|v_num
operator|=
name|itoq
argument_list|(
name|_sq2_
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONFIG_POW2
case|:
name|vp
operator|->
name|v_type
operator|=
name|V_NUM
expr_stmt|;
name|vp
operator|->
name|v_num
operator|=
name|itoq
argument_list|(
name|_pow2_
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONFIG_REDC2
case|:
name|vp
operator|->
name|v_type
operator|=
name|V_NUM
expr_stmt|;
name|vp
operator|->
name|v_num
operator|=
name|itoq
argument_list|(
name|_redc2_
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONFIG_TILDE
case|:
name|vp
operator|->
name|v_type
operator|=
name|V_NUM
expr_stmt|;
name|vp
operator|->
name|v_num
operator|=
name|itoq
argument_list|(
name|tilde_ok
argument_list|)
expr_stmt|;
case|case
name|CONFIG_TAB
case|:
name|vp
operator|->
name|v_type
operator|=
name|V_NUM
expr_stmt|;
name|vp
operator|->
name|v_num
operator|=
name|itoq
argument_list|(
name|tab_ok
argument_list|)
expr_stmt|;
break|break;
default|default:
name|math_error
argument_list|(
literal|"Getting illegal config parameter"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* END CODE */
end_comment

end_unit

