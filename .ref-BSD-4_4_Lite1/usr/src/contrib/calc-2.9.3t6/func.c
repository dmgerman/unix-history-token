begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1994 David I. Bell  * Permission is granted to use, distribute, or modify this source,  * provided that this copyright notice remains intact.  *  * Built-in functions implemented here  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/times.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|"calc.h"
end_include

begin_include
include|#
directive|include
file|"opcodes.h"
end_include

begin_include
include|#
directive|include
file|"token.h"
end_include

begin_include
include|#
directive|include
file|"func.h"
end_include

begin_include
include|#
directive|include
file|"string.h"
end_include

begin_include
include|#
directive|include
file|"symbol.h"
end_include

begin_comment
comment|/* if HZ& CLK_TCK are not defined, pick typical values, hope for the best */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HZ
argument_list|)
end_if

begin_define
define|#
directive|define
name|HZ
value|60
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|CLK_TCK
argument_list|)
end_if

begin_undef
undef|#
directive|undef
name|CLK_TCK
end_undef

begin_define
define|#
directive|define
name|CLK_TCK
value|HZ
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Totally numeric functions.  */
end_comment

begin_function_decl
specifier|static
name|NUMBER
modifier|*
name|f_cfsim
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* simplify number using continued fractions */
end_comment

begin_function_decl
specifier|static
name|NUMBER
modifier|*
name|f_ilog
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* return log of one number to another */
end_comment

begin_function_decl
specifier|static
name|NUMBER
modifier|*
name|f_faccnt
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* count of divisions */
end_comment

begin_function_decl
specifier|static
name|NUMBER
modifier|*
name|f_min
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* minimum of several arguments */
end_comment

begin_function_decl
specifier|static
name|NUMBER
modifier|*
name|f_max
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* maximum of several arguments */
end_comment

begin_function_decl
specifier|static
name|NUMBER
modifier|*
name|f_hmean
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* harmonic mean */
end_comment

begin_function_decl
specifier|static
name|NUMBER
modifier|*
name|f_trunc
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* truncate number to specified decimal places */
end_comment

begin_function_decl
specifier|static
name|NUMBER
modifier|*
name|f_btrunc
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* truncate number to specified binary places */
end_comment

begin_function_decl
specifier|static
name|NUMBER
modifier|*
name|f_gcd
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* greatest common divisor */
end_comment

begin_function_decl
specifier|static
name|NUMBER
modifier|*
name|f_lcm
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* least common multiple */
end_comment

begin_function_decl
specifier|static
name|NUMBER
modifier|*
name|f_xor
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* xor of several arguments */
end_comment

begin_function_decl
specifier|static
name|NUMBER
modifier|*
name|f_ceil
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* ceiling of a fraction */
end_comment

begin_function_decl
specifier|static
name|NUMBER
modifier|*
name|f_floor
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* floor of a fraction */
end_comment

begin_function_decl
specifier|static
name|NUMBER
modifier|*
name|f_meq
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* numbers are same modular value */
end_comment

begin_function_decl
specifier|static
name|NUMBER
modifier|*
name|f_isrel
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* two numbers are relatively prime */
end_comment

begin_function_decl
specifier|static
name|NUMBER
modifier|*
name|f_ismult
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* whether one number divides another */
end_comment

begin_function_decl
specifier|static
name|NUMBER
modifier|*
name|f_mne
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* whether a and b are not equal modulo c */
end_comment

begin_function_decl
specifier|static
name|NUMBER
modifier|*
name|f_isset
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* tests if a bit of a num (base 2) is set */
end_comment

begin_function_decl
specifier|static
name|NUMBER
modifier|*
name|f_highbit
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* high bit number in base 2 representation */
end_comment

begin_function_decl
specifier|static
name|NUMBER
modifier|*
name|f_lowbit
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* low bit number in base 2 representation */
end_comment

begin_function_decl
specifier|static
name|NUMBER
modifier|*
name|f_near
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* whether two numbers are near each other */
end_comment

begin_function_decl
specifier|static
name|NUMBER
modifier|*
name|f_legtoleg
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* positive form of leg to leg */
end_comment

begin_function_decl
specifier|static
name|NUMBER
modifier|*
name|f_ilog10
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* integer log of number base 10 */
end_comment

begin_function_decl
specifier|static
name|NUMBER
modifier|*
name|f_ilog2
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* integer log of number base 2 */
end_comment

begin_function_decl
specifier|static
name|NUMBER
modifier|*
name|f_digits
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* number of digits of number */
end_comment

begin_function_decl
specifier|static
name|NUMBER
modifier|*
name|f_digit
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* digit at specified decimal place of number */
end_comment

begin_function_decl
specifier|static
name|NUMBER
modifier|*
name|f_places
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* number of decimal places of number */
end_comment

begin_function_decl
specifier|static
name|NUMBER
modifier|*
name|f_primetest
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* primality test */
end_comment

begin_function_decl
specifier|static
name|NUMBER
modifier|*
name|f_issquare
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* whether number is a square */
end_comment

begin_function_decl
specifier|static
name|NUMBER
modifier|*
name|f_runtime
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* user runtime in seconds */
end_comment

begin_function_decl
specifier|static
name|NUMBER
modifier|*
name|f_base
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* set default output base */
end_comment

begin_comment
comment|/*  * General functions.  */
end_comment

begin_function_decl
specifier|static
name|VALUE
name|f_hash
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* produce hash from values */
end_comment

begin_function_decl
specifier|static
name|VALUE
name|f_bround
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* round number to specified binary places */
end_comment

begin_function_decl
specifier|static
name|VALUE
name|f_round
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* round number to specified decimal places */
end_comment

begin_function_decl
specifier|static
name|VALUE
name|f_det
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* determinant of matrix */
end_comment

begin_function_decl
specifier|static
name|VALUE
name|f_mattrans
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* return transpose of matrix */
end_comment

begin_function_decl
specifier|static
name|VALUE
name|f_matdim
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* dimension of matrix */
end_comment

begin_function_decl
specifier|static
name|VALUE
name|f_matmax
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* maximum index of matrix dimension */
end_comment

begin_function_decl
specifier|static
name|VALUE
name|f_matmin
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* minimum index of matrix dimension */
end_comment

begin_function_decl
specifier|static
name|VALUE
name|f_matfill
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* fill matrix with values */
end_comment

begin_function_decl
specifier|static
name|VALUE
name|f_listpush
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* push element onto front of list */
end_comment

begin_function_decl
specifier|static
name|VALUE
name|f_listpop
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* pop element from front of list */
end_comment

begin_function_decl
specifier|static
name|VALUE
name|f_listappend
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* append element to end of list */
end_comment

begin_function_decl
specifier|static
name|VALUE
name|f_listremove
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* remove element from end of list */
end_comment

begin_function_decl
specifier|static
name|VALUE
name|f_listinsert
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* insert element into list */
end_comment

begin_function_decl
specifier|static
name|VALUE
name|f_listdelete
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* delete element from list */
end_comment

begin_function_decl
specifier|static
name|VALUE
name|f_strlen
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* length of string */
end_comment

begin_function_decl
specifier|static
name|VALUE
name|f_char
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* character value of integer */
end_comment

begin_function_decl
specifier|static
name|VALUE
name|f_substr
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* extract substring */
end_comment

begin_function_decl
specifier|static
name|VALUE
name|f_strcat
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* concatenate strings */
end_comment

begin_function_decl
specifier|static
name|VALUE
name|f_ord
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* get ordinal value for character */
end_comment

begin_function_decl
specifier|static
name|VALUE
name|f_avg
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* average of several arguments */
end_comment

begin_function_decl
specifier|static
name|VALUE
name|f_ssq
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* sum of squares */
end_comment

begin_function_decl
specifier|static
name|VALUE
name|f_poly
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* result of evaluating polynomial */
end_comment

begin_function_decl
specifier|static
name|VALUE
name|f_sqrt
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* square root of a number */
end_comment

begin_function_decl
specifier|static
name|VALUE
name|f_root
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* number taken to root of another */
end_comment

begin_function_decl
specifier|static
name|VALUE
name|f_exp
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* complex exponential */
end_comment

begin_function_decl
specifier|static
name|VALUE
name|f_ln
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* complex natural logarithm */
end_comment

begin_function_decl
specifier|static
name|VALUE
name|f_power
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* one value to another power */
end_comment

begin_function_decl
specifier|static
name|VALUE
name|f_cos
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* complex cosine */
end_comment

begin_function_decl
specifier|static
name|VALUE
name|f_sin
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* complex sine */
end_comment

begin_function_decl
specifier|static
name|VALUE
name|f_polar
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* polar representation of complex number */
end_comment

begin_function_decl
specifier|static
name|VALUE
name|f_arg
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* argument of complex number */
end_comment

begin_function_decl
specifier|static
name|VALUE
name|f_list
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* create a list */
end_comment

begin_function_decl
specifier|static
name|VALUE
name|f_size
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* number of elements in object */
end_comment

begin_function_decl
specifier|static
name|VALUE
name|f_search
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* search matrix or list for match */
end_comment

begin_function_decl
specifier|static
name|VALUE
name|f_rsearch
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* search matrix or list backwards for match */
end_comment

begin_function_decl
specifier|static
name|VALUE
name|f_cp
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* cross product of vectors */
end_comment

begin_function_decl
specifier|static
name|VALUE
name|f_dp
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* dot product of vectors */
end_comment

begin_function_decl
specifier|static
name|VALUE
name|f_prompt
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* prompt for input line */
end_comment

begin_function_decl
specifier|static
name|VALUE
name|f_eval
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* evaluate string into value */
end_comment

begin_function_decl
specifier|static
name|VALUE
name|f_str
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* convert value to string */
end_comment

begin_function_decl
specifier|static
name|VALUE
name|f_fopen
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* open file for reading or writing */
end_comment

begin_function_decl
specifier|static
name|VALUE
name|f_fprintf
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* print data to file */
end_comment

begin_function_decl
specifier|static
name|VALUE
name|f_strprintf
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* return printed data as a string */
end_comment

begin_function_decl
specifier|static
name|VALUE
name|f_fgetline
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* read next line from file */
end_comment

begin_function_decl
specifier|static
name|VALUE
name|f_fgetc
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* read next char from file */
end_comment

begin_function_decl
specifier|static
name|VALUE
name|f_fflush
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* flush output to file */
end_comment

begin_function_decl
specifier|static
name|VALUE
name|f_printf
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* print data to stdout */
end_comment

begin_function_decl
specifier|static
name|VALUE
name|f_fclose
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* close file */
end_comment

begin_function_decl
specifier|static
name|VALUE
name|f_ferror
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* whether error occurred */
end_comment

begin_function_decl
specifier|static
name|VALUE
name|f_feof
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* whether end of file reached */
end_comment

begin_function_decl
specifier|static
name|VALUE
name|f_files
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* return file handle or number of files */
end_comment

begin_function_decl
specifier|static
name|VALUE
name|f_assoc
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* return a new association value */
end_comment

begin_define
define|#
directive|define
name|IN
value|100
end_define

begin_comment
comment|/* maximum number of arguments */
end_comment

begin_define
define|#
directive|define
name|FE
value|0x01
end_define

begin_comment
comment|/* flag to indicate default epsilon argument */
end_comment

begin_define
define|#
directive|define
name|FA
value|0x02
end_define

begin_comment
comment|/* preserve addresses of variables */
end_comment

begin_comment
comment|/*  * List of primitive built-in functions  */
end_comment

begin_struct
specifier|static
struct|struct
name|builtin
block|{
name|char
modifier|*
name|b_name
decl_stmt|;
comment|/* name of built-in function */
name|short
name|b_minargs
decl_stmt|;
comment|/* minimum number of arguments */
name|short
name|b_maxargs
decl_stmt|;
comment|/* maximum number of arguments */
name|short
name|b_flags
decl_stmt|;
comment|/* special handling flags */
name|short
name|b_opcode
decl_stmt|;
comment|/* opcode which makes the call quick */
name|NUMBER
modifier|*
function_decl|(
modifier|*
name|b_numfunc
function_decl|)
parameter_list|()
function_decl|;
comment|/* routine to calculate numeric function */
name|VALUE
function_decl|(
modifier|*
name|b_valfunc
function_decl|)
parameter_list|()
function_decl|;
comment|/* routine to calculate general values */
name|char
modifier|*
name|b_desc
decl_stmt|;
comment|/* description of function */
block|}
name|builtins
index|[]
init|=
block|{
literal|"abs"
block|,
literal|1
block|,
literal|2
block|,
literal|0
block|,
name|OP_ABS
block|,
literal|0
block|,
literal|0
block|,
literal|"absolute value within accuracy b"
block|,
literal|"acos"
block|,
literal|1
block|,
literal|2
block|,
name|FE
block|,
name|OP_NOP
block|,
name|qacos
block|,
literal|0
block|,
literal|"arccosine of a within accuracy b"
block|,
literal|"acosh"
block|,
literal|1
block|,
literal|2
block|,
name|FE
block|,
name|OP_NOP
block|,
name|qacosh
block|,
literal|0
block|,
literal|"hyperbolic arccosine of a within accuracy b"
block|,
literal|"append"
block|,
literal|2
block|,
literal|2
block|,
name|FA
block|,
name|OP_NOP
block|,
literal|0
block|,
name|f_listappend
block|,
literal|"append value to end of list"
block|,
literal|"appr"
block|,
literal|1
block|,
literal|2
block|,
name|FE
block|,
name|OP_NOP
block|,
name|qbappr
block|,
literal|0
block|,
literal|"approximate a with simpler fraction to within b"
block|,
literal|"arg"
block|,
literal|1
block|,
literal|2
block|,
literal|0
block|,
name|OP_NOP
block|,
literal|0
block|,
name|f_arg
block|,
literal|"argument (the angle) of complex number"
block|,
literal|"asin"
block|,
literal|1
block|,
literal|2
block|,
name|FE
block|,
name|OP_NOP
block|,
name|qasin
block|,
literal|0
block|,
literal|"arcsine of a within accuracy b"
block|,
literal|"asinh"
block|,
literal|1
block|,
literal|2
block|,
name|FE
block|,
name|OP_NOP
block|,
name|qasinh
block|,
literal|0
block|,
literal|"hyperbolic arcsine of a within accuracy b"
block|,
literal|"assoc"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|OP_NOP
block|,
literal|0
block|,
name|f_assoc
block|,
literal|"create new association array"
block|,
literal|"atan"
block|,
literal|1
block|,
literal|2
block|,
name|FE
block|,
name|OP_NOP
block|,
name|qatan
block|,
literal|0
block|,
literal|"arctangent of a within accuracy b"
block|,
literal|"atan2"
block|,
literal|2
block|,
literal|3
block|,
name|FE
block|,
name|OP_NOP
block|,
name|qatan2
block|,
literal|0
block|,
literal|"angle to point (b,a) within accuracy c"
block|,
literal|"atanh"
block|,
literal|1
block|,
literal|2
block|,
name|FE
block|,
name|OP_NOP
block|,
name|qatanh
block|,
literal|0
block|,
literal|"hyperbolic arctangent of a within accuracy b"
block|,
literal|"avg"
block|,
literal|1
block|,
name|IN
block|,
literal|0
block|,
name|OP_NOP
block|,
literal|0
block|,
name|f_avg
block|,
literal|"arithmetic mean of values"
block|,
literal|"base"
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
name|OP_NOP
block|,
name|f_base
block|,
literal|0
block|,
literal|"set default output base"
block|,
literal|"bround"
block|,
literal|1
block|,
literal|2
block|,
literal|0
block|,
name|OP_NOP
block|,
literal|0
block|,
name|f_bround
block|,
literal|"round value a to b number of binary places"
block|,
literal|"btrunc"
block|,
literal|1
block|,
literal|2
block|,
literal|0
block|,
name|OP_NOP
block|,
name|f_btrunc
block|,
literal|0
block|,
literal|"truncate a to b number of binary places"
block|,
literal|"ceil"
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
name|OP_NOP
block|,
name|f_ceil
block|,
literal|0
block|,
literal|"smallest integer greater than or equal to number"
block|,
literal|"cfappr"
block|,
literal|1
block|,
literal|2
block|,
name|FE
block|,
name|OP_NOP
block|,
name|qcfappr
block|,
literal|0
block|,
literal|"approximate a within accuracy b using\n\t\t    continued fractions"
block|,
literal|"cfsim"
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
name|OP_NOP
block|,
name|f_cfsim
block|,
literal|0
block|,
literal|"simplify number using continued fractions"
block|,
literal|"char"
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
name|OP_NOP
block|,
literal|0
block|,
name|f_char
block|,
literal|"character corresponding to integer value"
block|,
literal|"cmp"
block|,
literal|2
block|,
literal|2
block|,
literal|0
block|,
name|OP_CMP
block|,
literal|0
block|,
literal|0
block|,
literal|"compare values returning -1, 0, or 1"
block|,
literal|"comb"
block|,
literal|2
block|,
literal|2
block|,
literal|0
block|,
name|OP_NOP
block|,
name|qcomb
block|,
literal|0
block|,
literal|"combinatorial number a!/b!(a-b)!"
block|,
literal|"config"
block|,
literal|1
block|,
literal|2
block|,
literal|0
block|,
name|OP_SETCONFIG
block|,
literal|0
block|,
literal|0
block|,
literal|"set or read configuration value"
block|,
literal|"conj"
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
name|OP_CONJUGATE
block|,
literal|0
block|,
literal|0
block|,
literal|"complex conjugate of value"
block|,
literal|"cos"
block|,
literal|1
block|,
literal|2
block|,
literal|0
block|,
name|OP_NOP
block|,
literal|0
block|,
name|f_cos
block|,
literal|"cosine of value a within accuracy b"
block|,
literal|"cosh"
block|,
literal|1
block|,
literal|2
block|,
name|FE
block|,
name|OP_NOP
block|,
name|qcosh
block|,
literal|0
block|,
literal|"hyperbolic cosine of a within accuracy b"
block|,
literal|"cp"
block|,
literal|2
block|,
literal|2
block|,
literal|0
block|,
name|OP_NOP
block|,
literal|0
block|,
name|f_cp
block|,
literal|"Cross product of two vectors"
block|,
literal|"delete"
block|,
literal|2
block|,
literal|2
block|,
name|FA
block|,
name|OP_NOP
block|,
literal|0
block|,
name|f_listdelete
block|,
literal|"delete element from list a at position b"
block|,
literal|"den"
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
name|OP_DENOMINATOR
block|,
name|qden
block|,
literal|0
block|,
literal|"denominator of fraction"
block|,
literal|"det"
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
name|OP_NOP
block|,
literal|0
block|,
name|f_det
block|,
literal|"determinant of matrix"
block|,
literal|"digit"
block|,
literal|2
block|,
literal|2
block|,
literal|0
block|,
name|OP_NOP
block|,
name|f_digit
block|,
literal|0
block|,
literal|"digit at specified decimal place of number"
block|,
literal|"digits"
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
name|OP_NOP
block|,
name|f_digits
block|,
literal|0
block|,
literal|"number of digits in number"
block|,
literal|"dp"
block|,
literal|2
block|,
literal|2
block|,
literal|0
block|,
name|OP_NOP
block|,
literal|0
block|,
name|f_dp
block|,
literal|"Dot product of two vectors"
block|,
literal|"epsilon"
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
name|OP_SETEPSILON
block|,
literal|0
block|,
literal|0
block|,
literal|"set or read allowed error for real calculations"
block|,
literal|"eval"
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
name|OP_NOP
block|,
literal|0
block|,
name|f_eval
block|,
literal|"Evaluate expression from string to value"
block|,
literal|"exp"
block|,
literal|1
block|,
literal|2
block|,
literal|0
block|,
name|OP_NOP
block|,
literal|0
block|,
name|f_exp
block|,
literal|"exponential of value a within accuracy b"
block|,
literal|"fcnt"
block|,
literal|2
block|,
literal|2
block|,
literal|0
block|,
name|OP_NOP
block|,
name|f_faccnt
block|,
literal|0
block|,
literal|"count of times one number divides another"
block|,
literal|"fib"
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
name|OP_NOP
block|,
name|qfib
block|,
literal|0
block|,
literal|"Fibonacci number F(n)"
block|,
literal|"frem"
block|,
literal|2
block|,
literal|2
block|,
literal|0
block|,
name|OP_NOP
block|,
name|qfacrem
block|,
literal|0
block|,
literal|"number with all occurrences of factor removed"
block|,
literal|"fact"
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
name|OP_NOP
block|,
name|qfact
block|,
literal|0
block|,
literal|"factorial"
block|,
literal|"fclose"
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
name|OP_NOP
block|,
literal|0
block|,
name|f_fclose
block|,
literal|"close file"
block|,
literal|"feof"
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
name|OP_NOP
block|,
literal|0
block|,
name|f_feof
block|,
literal|"whether EOF reached for file"
block|,
literal|"ferror"
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
name|OP_NOP
block|,
literal|0
block|,
name|f_ferror
block|,
literal|"whether error occurred for file"
block|,
literal|"fflush"
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
name|OP_NOP
block|,
literal|0
block|,
name|f_fflush
block|,
literal|"flush output to file"
block|,
literal|"fgetc"
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
name|OP_NOP
block|,
literal|0
block|,
name|f_fgetc
block|,
literal|"read next char from file"
block|,
literal|"fgetline"
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
name|OP_NOP
block|,
literal|0
block|,
name|f_fgetline
block|,
literal|"read next line from file"
block|,
literal|"files"
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
name|OP_NOP
block|,
literal|0
block|,
name|f_files
block|,
literal|"return opened file or max number of opened files"
block|,
literal|"floor"
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
name|OP_NOP
block|,
name|f_floor
block|,
literal|0
block|,
literal|"greatest integer less than or equal to number"
block|,
literal|"fopen"
block|,
literal|2
block|,
literal|2
block|,
literal|0
block|,
name|OP_NOP
block|,
literal|0
block|,
name|f_fopen
block|,
literal|"open file name a in mode b"
block|,
literal|"fprintf"
block|,
literal|2
block|,
name|IN
block|,
literal|0
block|,
name|OP_NOP
block|,
literal|0
block|,
name|f_fprintf
block|,
literal|"print formatted output to opened file"
block|,
literal|"frac"
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
name|OP_FRAC
block|,
name|qfrac
block|,
literal|0
block|,
literal|"fractional part of value"
block|,
literal|"gcd"
block|,
literal|1
block|,
name|IN
block|,
literal|0
block|,
name|OP_NOP
block|,
name|f_gcd
block|,
literal|0
block|,
literal|"greatest common divisor"
block|,
literal|"gcdrem"
block|,
literal|2
block|,
literal|2
block|,
literal|0
block|,
name|OP_NOP
block|,
name|qgcdrem
block|,
literal|0
block|,
literal|"a divided repeatedly by gcd with b"
block|,
literal|"hash"
block|,
literal|1
block|,
name|IN
block|,
literal|0
block|,
name|OP_NOP
block|,
literal|0
block|,
name|f_hash
block|,
literal|"return non-negative hash value for one or\n\t\t    more values"
block|,
literal|"highbit"
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
name|OP_NOP
block|,
name|f_highbit
block|,
literal|0
block|,
literal|"high bit number in base 2 representation"
block|,
literal|"hmean"
block|,
literal|1
block|,
name|IN
block|,
literal|0
block|,
name|OP_NOP
block|,
name|f_hmean
block|,
literal|0
block|,
literal|"harmonic mean of values"
block|,
literal|"hypot"
block|,
literal|2
block|,
literal|3
block|,
name|FE
block|,
name|OP_NOP
block|,
name|qhypot
block|,
literal|0
block|,
literal|"hypotenuse of right triangle within accuracy c"
block|,
literal|"ilog"
block|,
literal|2
block|,
literal|2
block|,
literal|0
block|,
name|OP_NOP
block|,
name|f_ilog
block|,
literal|0
block|,
literal|"integral log of one number with another"
block|,
literal|"ilog10"
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
name|OP_NOP
block|,
name|f_ilog10
block|,
literal|0
block|,
literal|"integral log of a number base 10"
block|,
literal|"ilog2"
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
name|OP_NOP
block|,
name|f_ilog2
block|,
literal|0
block|,
literal|"integral log of a number base 2"
block|,
literal|"im"
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
name|OP_IM
block|,
literal|0
block|,
literal|0
block|,
literal|"imaginary part of complex number"
block|,
literal|"insert"
block|,
literal|3
block|,
literal|3
block|,
name|FA
block|,
name|OP_NOP
block|,
literal|0
block|,
name|f_listinsert
block|,
literal|"insert value c into list a at position b"
block|,
literal|"int"
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
name|OP_INT
block|,
name|qint
block|,
literal|0
block|,
literal|"integer part of value"
block|,
literal|"inverse"
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
name|OP_INVERT
block|,
literal|0
block|,
literal|0
block|,
literal|"multiplicative inverse of value"
block|,
literal|"iroot"
block|,
literal|2
block|,
literal|2
block|,
literal|0
block|,
name|OP_NOP
block|,
name|qiroot
block|,
literal|0
block|,
literal|"integer b'th root of a"
block|,
literal|"isassoc"
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
name|OP_ISASSOC
block|,
literal|0
block|,
literal|0
block|,
literal|"whether a value is an association"
block|,
literal|"iseven"
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
name|OP_ISEVEN
block|,
literal|0
block|,
literal|0
block|,
literal|"whether a value is an even integer"
block|,
literal|"isfile"
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
name|OP_ISFILE
block|,
literal|0
block|,
literal|0
block|,
literal|"whether a value is a file"
block|,
literal|"isint"
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
name|OP_ISINT
block|,
literal|0
block|,
literal|0
block|,
literal|"whether a value is an integer"
block|,
literal|"islist"
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
name|OP_ISLIST
block|,
literal|0
block|,
literal|0
block|,
literal|"whether a value is a list"
block|,
literal|"ismat"
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
name|OP_ISMAT
block|,
literal|0
block|,
literal|0
block|,
literal|"whether a value is a matrix"
block|,
literal|"ismult"
block|,
literal|2
block|,
literal|2
block|,
literal|0
block|,
name|OP_NOP
block|,
name|f_ismult
block|,
literal|0
block|,
literal|"whether a is a multiple of b"
block|,
literal|"isnull"
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
name|OP_ISNULL
block|,
literal|0
block|,
literal|0
block|,
literal|"whether a value is the null value"
block|,
literal|"isnum"
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
name|OP_ISNUM
block|,
literal|0
block|,
literal|0
block|,
literal|"whether a value is a number"
block|,
literal|"isobj"
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
name|OP_ISOBJ
block|,
literal|0
block|,
literal|0
block|,
literal|"whether a value is an object"
block|,
literal|"isodd"
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
name|OP_ISODD
block|,
literal|0
block|,
literal|0
block|,
literal|"whether a value is an odd integer"
block|,
literal|"isqrt"
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
name|OP_NOP
block|,
name|qisqrt
block|,
literal|0
block|,
literal|"integer part of square root"
block|,
literal|"isreal"
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
name|OP_ISREAL
block|,
literal|0
block|,
literal|0
block|,
literal|"whether a value is a real number"
block|,
literal|"isset"
block|,
literal|2
block|,
literal|2
block|,
literal|0
block|,
name|OP_NOP
block|,
name|f_isset
block|,
literal|0
block|,
literal|"whether bit b of abs(a) (in base 2) is set"
block|,
literal|"isstr"
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
name|OP_ISSTR
block|,
literal|0
block|,
literal|0
block|,
literal|"whether a value is a string"
block|,
literal|"isrel"
block|,
literal|2
block|,
literal|2
block|,
literal|0
block|,
name|OP_NOP
block|,
name|f_isrel
block|,
literal|0
block|,
literal|"whether two numbers are relatively prime"
block|,
literal|"issimple"
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
name|OP_ISSIMPLE
block|,
literal|0
block|,
literal|0
block|,
literal|"whether value is a simple type"
block|,
literal|"issq"
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
name|OP_NOP
block|,
name|f_issquare
block|,
literal|0
block|,
literal|"whether or not number is a square"
block|,
literal|"istype"
block|,
literal|2
block|,
literal|2
block|,
literal|0
block|,
name|OP_ISTYPE
block|,
literal|0
block|,
literal|0
block|,
literal|"whether the type of a is same as the type of b"
block|,
literal|"jacobi"
block|,
literal|2
block|,
literal|2
block|,
literal|0
block|,
name|OP_NOP
block|,
name|qjacobi
block|,
literal|0
block|,
literal|"-1 => a is not quadratic residue mod b\n\t\t  1 => b is composite, or a is quad residue of b"
block|,
literal|"lcm"
block|,
literal|1
block|,
name|IN
block|,
literal|0
block|,
name|OP_NOP
block|,
name|f_lcm
block|,
literal|0
block|,
literal|"least common multiple"
block|,
literal|"lcmfact"
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
name|OP_NOP
block|,
name|qlcmfact
block|,
literal|0
block|,
literal|"lcm of all integers up till number"
block|,
literal|"lfactor"
block|,
literal|2
block|,
literal|2
block|,
literal|0
block|,
name|OP_NOP
block|,
name|qlowfactor
block|,
literal|0
block|,
literal|"lowest prime factor of a in first b primes"
block|,
literal|"list"
block|,
literal|0
block|,
name|IN
block|,
literal|0
block|,
name|OP_NOP
block|,
literal|0
block|,
name|f_list
block|,
literal|"create list of specified values"
block|,
literal|"ln"
block|,
literal|1
block|,
literal|2
block|,
literal|0
block|,
name|OP_NOP
block|,
literal|0
block|,
name|f_ln
block|,
literal|"natural logarithm of value a within accuracy b"
block|,
literal|"lowbit"
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
name|OP_NOP
block|,
name|f_lowbit
block|,
literal|0
block|,
literal|"low bit number in base 2 representation"
block|,
literal|"ltol"
block|,
literal|1
block|,
literal|2
block|,
name|FE
block|,
name|OP_NOP
block|,
name|f_legtoleg
block|,
literal|0
block|,
literal|"leg-to-leg of unit right triangle (sqrt(1 - a^2))"
block|,
literal|"matdim"
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
name|OP_NOP
block|,
literal|0
block|,
name|f_matdim
block|,
literal|"number of dimensions of matrix"
block|,
literal|"matfill"
block|,
literal|2
block|,
literal|3
block|,
name|FA
block|,
name|OP_NOP
block|,
literal|0
block|,
name|f_matfill
block|,
literal|"fill matrix with value b (value c on diagonal)"
block|,
literal|"matmax"
block|,
literal|2
block|,
literal|2
block|,
literal|0
block|,
name|OP_NOP
block|,
literal|0
block|,
name|f_matmax
block|,
literal|"maximum index of matrix a dim b"
block|,
literal|"matmin"
block|,
literal|2
block|,
literal|2
block|,
literal|0
block|,
name|OP_NOP
block|,
literal|0
block|,
name|f_matmin
block|,
literal|"minimum index of matrix a dim b"
block|,
literal|"mattrans"
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
name|OP_NOP
block|,
literal|0
block|,
name|f_mattrans
block|,
literal|"transpose of matrix"
block|,
literal|"max"
block|,
literal|1
block|,
name|IN
block|,
literal|0
block|,
name|OP_NOP
block|,
name|f_max
block|,
literal|0
block|,
literal|"maximum value"
block|,
literal|"meq"
block|,
literal|3
block|,
literal|3
block|,
literal|0
block|,
name|OP_NOP
block|,
name|f_meq
block|,
literal|0
block|,
literal|"whether a and b are equal modulo c"
block|,
literal|"min"
block|,
literal|1
block|,
name|IN
block|,
literal|0
block|,
name|OP_NOP
block|,
name|f_min
block|,
literal|0
block|,
literal|"minimum value"
block|,
literal|"minv"
block|,
literal|2
block|,
literal|2
block|,
literal|0
block|,
name|OP_NOP
block|,
name|qminv
block|,
literal|0
block|,
literal|"inverse of a modulo b"
block|,
literal|"mmin"
block|,
literal|2
block|,
literal|2
block|,
literal|0
block|,
name|OP_NOP
block|,
name|qminmod
block|,
literal|0
block|,
literal|"a mod b value with smallest abs value"
block|,
literal|"mne"
block|,
literal|3
block|,
literal|3
block|,
literal|0
block|,
name|OP_NOP
block|,
name|f_mne
block|,
literal|0
block|,
literal|"whether a and b are not equal modulo c"
block|,
literal|"near"
block|,
literal|2
block|,
literal|3
block|,
literal|0
block|,
name|OP_NOP
block|,
name|f_near
block|,
literal|0
block|,
literal|"sign of (abs(a-b) - c)"
block|,
literal|"norm"
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
name|OP_NORM
block|,
literal|0
block|,
literal|0
block|,
literal|"norm of a value (square of absolute value)"
block|,
literal|"null"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|OP_UNDEF
block|,
literal|0
block|,
literal|0
block|,
literal|"null value"
block|,
literal|"num"
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
name|OP_NUMERATOR
block|,
name|qnum
block|,
literal|0
block|,
literal|"numerator of fraction"
block|,
literal|"ord"
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
name|OP_NOP
block|,
literal|0
block|,
name|f_ord
block|,
literal|"integer corresponding to character value"
block|,
literal|"param"
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
name|OP_ARGVALUE
block|,
literal|0
block|,
literal|0
block|,
literal|"value of parameter n (or parameter count if n\n\t\t    is zero)"
block|,
literal|"perm"
block|,
literal|2
block|,
literal|2
block|,
literal|0
block|,
name|OP_NOP
block|,
name|qperm
block|,
literal|0
block|,
literal|"permutation number a!/(a-b)!"
block|,
literal|"pfact"
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
name|OP_NOP
block|,
name|qpfact
block|,
literal|0
block|,
literal|"product of primes up till number"
block|,
literal|"pi"
block|,
literal|0
block|,
literal|1
block|,
name|FE
block|,
name|OP_NOP
block|,
name|qpi
block|,
literal|0
block|,
literal|"value of pi accurate to within epsilon"
block|,
literal|"places"
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
name|OP_NOP
block|,
name|f_places
block|,
literal|0
block|,
literal|"places after decimal point (-1 if infinite)"
block|,
literal|"pmod"
block|,
literal|3
block|,
literal|3
block|,
literal|0
block|,
name|OP_NOP
block|,
name|qpowermod
block|,
literal|0
block|,
literal|"mod of a power (a ^ b (mod c))"
block|,
literal|"polar"
block|,
literal|2
block|,
literal|3
block|,
literal|0
block|,
name|OP_NOP
block|,
literal|0
block|,
name|f_polar
block|,
literal|"complex value of polar coordinate (a * exp(b*1i))"
block|,
literal|"poly"
block|,
literal|2
block|,
name|IN
block|,
literal|0
block|,
name|OP_NOP
block|,
literal|0
block|,
name|f_poly
block|,
literal|"(a1,a2,...,an,x) = a1*x^n+a2*x^(n-1)+...+an"
block|,
literal|"pop"
block|,
literal|1
block|,
literal|1
block|,
name|FA
block|,
name|OP_NOP
block|,
literal|0
block|,
name|f_listpop
block|,
literal|"pop value from front of list"
block|,
literal|"power"
block|,
literal|2
block|,
literal|3
block|,
literal|0
block|,
name|OP_NOP
block|,
literal|0
block|,
name|f_power
block|,
literal|"value a raised to the power b within accuracy c"
block|,
literal|"ptest"
block|,
literal|2
block|,
literal|2
block|,
literal|0
block|,
name|OP_NOP
block|,
name|f_primetest
block|,
literal|0
block|,
literal|"probabilistic primality test"
block|,
literal|"printf"
block|,
literal|1
block|,
name|IN
block|,
literal|0
block|,
name|OP_NOP
block|,
literal|0
block|,
name|f_printf
block|,
literal|"print formatted output to stdout"
block|,
literal|"prompt"
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
name|OP_NOP
block|,
literal|0
block|,
name|f_prompt
block|,
literal|"prompt for input line using value a"
block|,
literal|"push"
block|,
literal|2
block|,
literal|2
block|,
name|FA
block|,
name|OP_NOP
block|,
literal|0
block|,
name|f_listpush
block|,
literal|"push value onto front of list"
block|,
literal|"quomod"
block|,
literal|4
block|,
literal|4
block|,
literal|0
block|,
name|OP_QUOMOD
block|,
literal|0
block|,
literal|0
block|,
literal|"set c and d to quotient and remainder of a\n\t\t    divided by b"
block|,
literal|"rcin"
block|,
literal|2
block|,
literal|2
block|,
literal|0
block|,
name|OP_NOP
block|,
name|qredcin
block|,
literal|0
block|,
literal|"convert normal number a to REDC number mod b"
block|,
literal|"rcmul"
block|,
literal|3
block|,
literal|3
block|,
literal|0
block|,
name|OP_NOP
block|,
name|qredcmul
block|,
literal|0
block|,
literal|"multiply REDC numbers a and b mod c"
block|,
literal|"rcout"
block|,
literal|2
block|,
literal|2
block|,
literal|0
block|,
name|OP_NOP
block|,
name|qredcout
block|,
literal|0
block|,
literal|"convert REDC number a mod b to normal number"
block|,
literal|"rcpow"
block|,
literal|3
block|,
literal|3
block|,
literal|0
block|,
name|OP_NOP
block|,
name|qredcpower
block|,
literal|0
block|,
literal|"raise REDC number a to power b mod c"
block|,
literal|"rcsq"
block|,
literal|2
block|,
literal|2
block|,
literal|0
block|,
name|OP_NOP
block|,
name|qredcsquare
block|,
literal|0
block|,
literal|"square REDC number a mod b"
block|,
literal|"re"
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
name|OP_RE
block|,
literal|0
block|,
literal|0
block|,
literal|"real part of complex number"
block|,
literal|"remove"
block|,
literal|1
block|,
literal|1
block|,
name|FA
block|,
name|OP_NOP
block|,
literal|0
block|,
name|f_listremove
block|,
literal|"remove value from end of list"
block|,
literal|"root"
block|,
literal|2
block|,
literal|3
block|,
literal|0
block|,
name|OP_NOP
block|,
literal|0
block|,
name|f_root
block|,
literal|"value a taken to the b'th root within accuracy c"
block|,
literal|"round"
block|,
literal|1
block|,
literal|2
block|,
literal|0
block|,
name|OP_NOP
block|,
literal|0
block|,
name|f_round
block|,
literal|"round value a to b number of decimal places"
block|,
literal|"rsearch"
block|,
literal|2
block|,
literal|3
block|,
literal|0
block|,
name|OP_NOP
block|,
literal|0
block|,
name|f_rsearch
block|,
literal|"reverse search matrix or list for value b\n\t\t    starting at index c"
block|,
literal|"runtime"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|OP_NOP
block|,
name|f_runtime
block|,
literal|0
block|,
literal|"user mode cpu time in seconds"
block|,
literal|"scale"
block|,
literal|2
block|,
literal|2
block|,
literal|0
block|,
name|OP_SCALE
block|,
literal|0
block|,
literal|0
block|,
literal|"scale value up or down by a power of two"
block|,
literal|"search"
block|,
literal|2
block|,
literal|3
block|,
literal|0
block|,
name|OP_NOP
block|,
literal|0
block|,
name|f_search
block|,
literal|"search matrix or list for value b starting\n\t\t    at index c"
block|,
literal|"sgn"
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
name|OP_SGN
block|,
name|qsign
block|,
literal|0
block|,
literal|"sign of value (-1, 0, 1)"
block|,
literal|"sin"
block|,
literal|1
block|,
literal|2
block|,
literal|0
block|,
name|OP_NOP
block|,
literal|0
block|,
name|f_sin
block|,
literal|"sine of value a within accuracy b"
block|,
literal|"sinh"
block|,
literal|1
block|,
literal|2
block|,
name|FE
block|,
name|OP_NOP
block|,
name|qsinh
block|,
literal|0
block|,
literal|"hyperbolic sine of a within accuracy b"
block|,
literal|"size"
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
name|OP_NOP
block|,
literal|0
block|,
name|f_size
block|,
literal|"total number of elements in value"
block|,
literal|"sqrt"
block|,
literal|1
block|,
literal|2
block|,
literal|0
block|,
name|OP_NOP
block|,
literal|0
block|,
name|f_sqrt
block|,
literal|"square root of value a within accuracy b"
block|,
literal|"ssq"
block|,
literal|1
block|,
name|IN
block|,
literal|0
block|,
name|OP_NOP
block|,
literal|0
block|,
name|f_ssq
block|,
literal|"sum of squares of values"
block|,
literal|"str"
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
name|OP_NOP
block|,
literal|0
block|,
name|f_str
block|,
literal|"simple value converted to string"
block|,
literal|"strcat"
block|,
literal|1
block|,
name|IN
block|,
literal|0
block|,
name|OP_NOP
block|,
literal|0
block|,
name|f_strcat
block|,
literal|"concatenate strings together"
block|,
literal|"strlen"
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
name|OP_NOP
block|,
literal|0
block|,
name|f_strlen
block|,
literal|"length of string"
block|,
literal|"strprintf"
block|,
literal|1
block|,
name|IN
block|,
literal|0
block|,
name|OP_NOP
block|,
literal|0
block|,
name|f_strprintf
block|,
literal|"return formatted output as a string"
block|,
literal|"substr"
block|,
literal|3
block|,
literal|3
block|,
literal|0
block|,
name|OP_NOP
block|,
literal|0
block|,
name|f_substr
block|,
literal|"substring of a from position b for c chars"
block|,
literal|"swap"
block|,
literal|2
block|,
literal|2
block|,
literal|0
block|,
name|OP_SWAP
block|,
literal|0
block|,
literal|0
block|,
literal|"swap values of variables a and b (can be dangerous)"
block|,
literal|"tan"
block|,
literal|1
block|,
literal|2
block|,
name|FE
block|,
name|OP_NOP
block|,
name|qtan
block|,
literal|0
block|,
literal|"tangent of a within accuracy b"
block|,
literal|"tanh"
block|,
literal|1
block|,
literal|2
block|,
name|FE
block|,
name|OP_NOP
block|,
name|qtanh
block|,
literal|0
block|,
literal|"hyperbolic tangent of a within accuracy b"
block|,
literal|"trunc"
block|,
literal|1
block|,
literal|2
block|,
literal|0
block|,
name|OP_NOP
block|,
name|f_trunc
block|,
literal|0
block|,
literal|"truncate a to b number of decimal places"
block|,
literal|"xor"
block|,
literal|1
block|,
name|IN
block|,
literal|0
block|,
name|OP_NOP
block|,
name|f_xor
block|,
literal|0
block|,
literal|"logical xor"
block|,
name|NULL
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|OP_NOP
block|,
literal|0
block|,
literal|0
block|,
name|NULL
comment|/* end of table */
block|}
struct|;
end_struct

begin_comment
comment|/*  * Call a built-in function.  * Arguments to the function are on the stack, but are not removed here.  * Functions are either purely numeric, or else can take any value type.  */
end_comment

begin_function
name|VALUE
name|builtinfunc
parameter_list|(
name|index
parameter_list|,
name|argcount
parameter_list|,
name|stck
parameter_list|)
name|int
name|argcount
decl_stmt|;
name|long
name|index
decl_stmt|;
name|VALUE
modifier|*
name|stck
decl_stmt|;
comment|/* arguments on the stack */
block|{
name|VALUE
modifier|*
name|sp
decl_stmt|;
comment|/* pointer to stack entries */
name|VALUE
modifier|*
modifier|*
name|vpp
decl_stmt|;
comment|/* pointer to current value address */
name|struct
name|builtin
modifier|*
name|bp
decl_stmt|;
comment|/* builtin function to be called */
name|long
name|i
decl_stmt|;
comment|/* index */
name|NUMBER
modifier|*
name|numargs
index|[
name|IN
index|]
decl_stmt|;
comment|/* numeric arguments for function */
name|VALUE
modifier|*
name|valargs
index|[
name|IN
index|]
decl_stmt|;
comment|/* addresses of actual arguments */
name|VALUE
name|result
decl_stmt|;
comment|/* general result of function */
if|if
condition|(
operator|(
name|unsigned
name|long
operator|)
name|index
operator|>=
operator|(
sizeof|sizeof
argument_list|(
name|builtins
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|builtins
index|[
literal|0
index|]
argument_list|)
operator|)
operator|-
literal|1
condition|)
name|math_error
argument_list|(
literal|"Bad built-in function index"
argument_list|)
expr_stmt|;
name|bp
operator|=
operator|&
name|builtins
index|[
name|index
index|]
expr_stmt|;
if|if
condition|(
name|argcount
operator|<
name|bp
operator|->
name|b_minargs
condition|)
name|math_error
argument_list|(
literal|"Too few arguments for builtin function \"%s\""
argument_list|,
name|bp
operator|->
name|b_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|argcount
operator|>
name|bp
operator|->
name|b_maxargs
operator|)
operator|||
operator|(
name|argcount
operator|>
name|IN
operator|)
condition|)
name|math_error
argument_list|(
literal|"Too many arguments for builtin function \"%s\""
argument_list|,
name|bp
operator|->
name|b_name
argument_list|)
expr_stmt|;
comment|/* 	 * If an address was passed, then point at the real variable, 	 * otherwise point at the stack value itself (unless the function 	 * is very special). 	 */
name|sp
operator|=
name|stck
operator|-
name|argcount
operator|+
literal|1
expr_stmt|;
name|vpp
operator|=
name|valargs
expr_stmt|;
for|for
control|(
name|i
operator|=
name|argcount
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
operator|(
name|sp
operator|->
name|v_type
operator|!=
name|V_ADDR
operator|)
operator|||
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|FA
operator|)
condition|)
operator|*
name|vpp
operator|=
name|sp
expr_stmt|;
else|else
operator|*
name|vpp
operator|=
name|sp
operator|->
name|v_addr
expr_stmt|;
name|sp
operator|++
expr_stmt|;
name|vpp
operator|++
expr_stmt|;
block|}
comment|/* 	 * Handle general values if the function accepts them. 	 */
if|if
condition|(
name|bp
operator|->
name|b_valfunc
condition|)
block|{
name|vpp
operator|=
name|valargs
expr_stmt|;
if|if
condition|(
operator|(
name|bp
operator|->
name|b_minargs
operator|==
literal|1
operator|)
operator|&&
operator|(
name|bp
operator|->
name|b_maxargs
operator|==
literal|1
operator|)
condition|)
name|result
operator|=
call|(
modifier|*
name|bp
operator|->
name|b_valfunc
call|)
argument_list|(
name|vpp
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|bp
operator|->
name|b_minargs
operator|==
literal|2
operator|)
operator|&&
operator|(
name|bp
operator|->
name|b_maxargs
operator|==
literal|2
operator|)
condition|)
name|result
operator|=
call|(
modifier|*
name|bp
operator|->
name|b_valfunc
call|)
argument_list|(
name|vpp
index|[
literal|0
index|]
argument_list|,
name|vpp
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|bp
operator|->
name|b_minargs
operator|==
literal|3
operator|)
operator|&&
operator|(
name|bp
operator|->
name|b_maxargs
operator|==
literal|3
operator|)
condition|)
name|result
operator|=
call|(
modifier|*
name|bp
operator|->
name|b_valfunc
call|)
argument_list|(
name|vpp
index|[
literal|0
index|]
argument_list|,
name|vpp
index|[
literal|1
index|]
argument_list|,
name|vpp
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
else|else
name|result
operator|=
call|(
modifier|*
name|bp
operator|->
name|b_valfunc
call|)
argument_list|(
name|argcount
argument_list|,
name|vpp
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
comment|/* 	 * Function must be purely numeric, so handle that. 	 */
name|vpp
operator|=
name|valargs
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argcount
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|vpp
operator|)
operator|->
name|v_type
operator|!=
name|V_NUM
condition|)
name|math_error
argument_list|(
literal|"Non-real argument for builtin function %s"
argument_list|,
name|bp
operator|->
name|b_name
argument_list|)
expr_stmt|;
name|numargs
index|[
name|i
index|]
operator|=
operator|(
operator|*
name|vpp
operator|)
operator|->
name|v_num
expr_stmt|;
name|vpp
operator|++
expr_stmt|;
block|}
name|result
operator|.
name|v_type
operator|=
name|V_NUM
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|FE
operator|)
operator|&&
operator|(
name|bp
operator|->
name|b_minargs
operator|!=
name|bp
operator|->
name|b_maxargs
operator|)
condition|)
block|{
name|result
operator|.
name|v_num
operator|=
call|(
modifier|*
name|bp
operator|->
name|b_numfunc
call|)
argument_list|(
name|argcount
argument_list|,
name|numargs
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|FE
operator|)
operator|&&
operator|(
name|argcount
operator|<
name|bp
operator|->
name|b_maxargs
operator|)
condition|)
name|numargs
index|[
name|argcount
operator|++
index|]
operator|=
name|_epsilon_
expr_stmt|;
switch|switch
condition|(
name|argcount
condition|)
block|{
case|case
literal|0
case|:
name|result
operator|.
name|v_num
operator|=
call|(
modifier|*
name|bp
operator|->
name|b_numfunc
call|)
argument_list|()
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|result
operator|.
name|v_num
operator|=
call|(
modifier|*
name|bp
operator|->
name|b_numfunc
call|)
argument_list|(
name|numargs
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|result
operator|.
name|v_num
operator|=
call|(
modifier|*
name|bp
operator|->
name|b_numfunc
call|)
argument_list|(
name|numargs
index|[
literal|0
index|]
argument_list|,
name|numargs
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|result
operator|.
name|v_num
operator|=
call|(
modifier|*
name|bp
operator|->
name|b_numfunc
call|)
argument_list|(
name|numargs
index|[
literal|0
index|]
argument_list|,
name|numargs
index|[
literal|1
index|]
argument_list|,
name|numargs
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
break|break;
default|default:
name|math_error
argument_list|(
literal|"Bad builtin function call"
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|VALUE
name|f_eval
parameter_list|(
name|vp
parameter_list|)
name|VALUE
modifier|*
name|vp
decl_stmt|;
block|{
name|FUNC
modifier|*
name|oldfunc
decl_stmt|;
name|FUNC
modifier|*
name|newfunc
decl_stmt|;
name|VALUE
name|result
decl_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|!=
name|V_STR
condition|)
name|math_error
argument_list|(
literal|"Evaluating non-string argument"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|openstring
argument_list|(
name|vp
operator|->
name|v_str
argument_list|)
expr_stmt|;
name|oldfunc
operator|=
name|curfunc
expr_stmt|;
name|enterfilescope
argument_list|()
expr_stmt|;
if|if
condition|(
name|evaluate
argument_list|(
name|TRUE
argument_list|)
condition|)
block|{
name|exitfilescope
argument_list|()
expr_stmt|;
name|freevalue
argument_list|(
name|stack
operator|--
argument_list|)
expr_stmt|;
name|newfunc
operator|=
name|curfunc
expr_stmt|;
name|curfunc
operator|=
name|oldfunc
expr_stmt|;
name|result
operator|=
name|newfunc
operator|->
name|f_savedvalue
expr_stmt|;
name|newfunc
operator|->
name|f_savedvalue
operator|.
name|v_type
operator|=
name|V_NULL
expr_stmt|;
if|if
condition|(
name|newfunc
operator|!=
name|oldfunc
condition|)
name|free
argument_list|(
name|newfunc
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
name|exitfilescope
argument_list|()
expr_stmt|;
name|newfunc
operator|=
name|curfunc
expr_stmt|;
name|curfunc
operator|=
name|oldfunc
expr_stmt|;
name|freevalue
argument_list|(
operator|&
name|newfunc
operator|->
name|f_savedvalue
argument_list|)
expr_stmt|;
name|newfunc
operator|->
name|f_savedvalue
operator|.
name|v_type
operator|=
name|V_NULL
expr_stmt|;
if|if
condition|(
name|newfunc
operator|!=
name|oldfunc
condition|)
name|free
argument_list|(
name|newfunc
argument_list|)
expr_stmt|;
name|math_error
argument_list|(
literal|"Evaluation error"
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|VALUE
name|f_prompt
parameter_list|(
name|vp
parameter_list|)
name|VALUE
modifier|*
name|vp
decl_stmt|;
block|{
name|VALUE
name|result
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|char
modifier|*
name|newcp
decl_stmt|;
if|if
condition|(
name|inputisterminal
argument_list|()
condition|)
block|{
name|printvalue
argument_list|(
name|vp
argument_list|,
name|PRINT_SHORT
argument_list|)
expr_stmt|;
name|math_flush
argument_list|()
expr_stmt|;
block|}
name|cp
operator|=
name|nextline
argument_list|()
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
name|math_error
argument_list|(
literal|"End of file while prompting"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\0'
condition|)
block|{
name|result
operator|.
name|v_type
operator|=
name|V_STR
expr_stmt|;
name|result
operator|.
name|v_subtype
operator|=
name|V_STRLITERAL
expr_stmt|;
name|result
operator|.
name|v_str
operator|=
literal|""
expr_stmt|;
return|return
name|result
return|;
block|}
name|newcp
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|strlen
argument_list|(
name|cp
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|newcp
operator|==
name|NULL
condition|)
name|math_error
argument_list|(
literal|"Cannot allocate string"
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|newcp
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|result
operator|.
name|v_str
operator|=
name|newcp
expr_stmt|;
name|result
operator|.
name|v_type
operator|=
name|V_STR
expr_stmt|;
name|result
operator|.
name|v_subtype
operator|=
name|V_STRALLOC
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|VALUE
name|f_str
parameter_list|(
name|vp
parameter_list|)
name|VALUE
modifier|*
name|vp
decl_stmt|;
block|{
name|VALUE
name|result
decl_stmt|;
specifier|static
name|char
modifier|*
name|cp
decl_stmt|;
switch|switch
condition|(
name|vp
operator|->
name|v_type
condition|)
block|{
case|case
name|V_STR
case|:
name|copyvalue
argument_list|(
name|vp
argument_list|,
operator|&
name|result
argument_list|)
expr_stmt|;
return|return
name|result
return|;
case|case
name|V_NULL
case|:
name|result
operator|.
name|v_str
operator|=
literal|""
expr_stmt|;
name|result
operator|.
name|v_type
operator|=
name|V_STR
expr_stmt|;
name|result
operator|.
name|v_subtype
operator|=
name|V_STRLITERAL
expr_stmt|;
return|return
name|result
return|;
case|case
name|V_NUM
case|:
name|math_divertio
argument_list|()
expr_stmt|;
name|qprintnum
argument_list|(
name|vp
operator|->
name|v_num
argument_list|,
name|MODE_DEFAULT
argument_list|)
expr_stmt|;
name|cp
operator|=
name|math_getdivertedio
argument_list|()
expr_stmt|;
break|break;
case|case
name|V_COM
case|:
name|math_divertio
argument_list|()
expr_stmt|;
name|comprint
argument_list|(
name|vp
operator|->
name|v_com
argument_list|)
expr_stmt|;
name|cp
operator|=
name|math_getdivertedio
argument_list|()
expr_stmt|;
break|break;
default|default:
name|math_error
argument_list|(
literal|"Non-simple type for string conversion"
argument_list|)
expr_stmt|;
block|}
name|result
operator|.
name|v_str
operator|=
name|cp
expr_stmt|;
name|result
operator|.
name|v_type
operator|=
name|V_STR
expr_stmt|;
name|result
operator|.
name|v_subtype
operator|=
name|V_STRALLOC
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|VALUE
name|f_poly
parameter_list|(
name|count
parameter_list|,
name|vals
parameter_list|)
name|int
name|count
decl_stmt|;
name|VALUE
modifier|*
modifier|*
name|vals
decl_stmt|;
block|{
name|VALUE
modifier|*
name|x
decl_stmt|;
name|VALUE
name|result
decl_stmt|,
name|tmp
decl_stmt|;
name|x
operator|=
name|vals
index|[
operator|--
name|count
index|]
expr_stmt|;
name|copyvalue
argument_list|(
operator|*
name|vals
operator|++
argument_list|,
operator|&
name|result
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|count
operator|>
literal|0
condition|)
block|{
name|mulvalue
argument_list|(
operator|&
name|result
argument_list|,
name|x
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
name|freevalue
argument_list|(
operator|&
name|result
argument_list|)
expr_stmt|;
name|addvalue
argument_list|(
operator|*
name|vals
operator|++
argument_list|,
operator|&
name|tmp
argument_list|,
operator|&
name|result
argument_list|)
expr_stmt|;
name|freevalue
argument_list|(
operator|&
name|tmp
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|NUMBER
modifier|*
name|f_mne
parameter_list|(
name|val1
parameter_list|,
name|val2
parameter_list|,
name|val3
parameter_list|)
name|NUMBER
modifier|*
name|val1
decl_stmt|,
decl|*
name|val2
decl_stmt|,
modifier|*
name|val3
decl_stmt|;
end_function

begin_block
block|{
return|return
name|itoq
argument_list|(
operator|(
name|long
operator|)
name|qcmpmod
argument_list|(
name|val1
argument_list|,
name|val2
argument_list|,
name|val3
argument_list|)
argument_list|)
return|;
block|}
end_block

begin_function
specifier|static
name|NUMBER
modifier|*
name|f_isrel
parameter_list|(
name|val1
parameter_list|,
name|val2
parameter_list|)
name|NUMBER
modifier|*
name|val1
decl_stmt|,
decl|*
name|val2
decl_stmt|;
end_function

begin_block
block|{
if|if
condition|(
name|qisfrac
argument_list|(
name|val1
argument_list|)
operator|||
name|qisfrac
argument_list|(
name|val2
argument_list|)
condition|)
name|math_error
argument_list|(
literal|"Non-integer for isrel"
argument_list|)
expr_stmt|;
return|return
name|itoq
argument_list|(
operator|(
name|long
operator|)
name|zrelprime
argument_list|(
name|val1
operator|->
name|num
argument_list|,
name|val2
operator|->
name|num
argument_list|)
argument_list|)
return|;
block|}
end_block

begin_function
specifier|static
name|NUMBER
modifier|*
name|f_issquare
parameter_list|(
name|vp
parameter_list|)
name|NUMBER
modifier|*
name|vp
decl_stmt|;
block|{
return|return
name|itoq
argument_list|(
operator|(
name|long
operator|)
name|qissquare
argument_list|(
name|vp
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|NUMBER
modifier|*
name|f_primetest
parameter_list|(
name|val1
parameter_list|,
name|val2
parameter_list|)
name|NUMBER
modifier|*
name|val1
decl_stmt|,
decl|*
name|val2
decl_stmt|;
end_function

begin_block
block|{
return|return
name|itoq
argument_list|(
operator|(
name|long
operator|)
name|qprimetest
argument_list|(
name|val1
argument_list|,
name|val2
argument_list|)
argument_list|)
return|;
block|}
end_block

begin_function
specifier|static
name|NUMBER
modifier|*
name|f_isset
parameter_list|(
name|val1
parameter_list|,
name|val2
parameter_list|)
name|NUMBER
modifier|*
name|val1
decl_stmt|,
decl|*
name|val2
decl_stmt|;
end_function

begin_block
block|{
if|if
condition|(
name|qisfrac
argument_list|(
name|val2
argument_list|)
condition|)
name|math_error
argument_list|(
literal|"Non-integral bit position"
argument_list|)
expr_stmt|;
if|if
condition|(
name|qiszero
argument_list|(
name|val1
argument_list|)
operator|||
operator|(
name|qisint
argument_list|(
name|val1
argument_list|)
operator|&&
name|qisneg
argument_list|(
name|val2
argument_list|)
operator|)
condition|)
return|return
name|qlink
argument_list|(
operator|&
name|_qzero_
argument_list|)
return|;
if|if
condition|(
name|zisbig
argument_list|(
name|val2
operator|->
name|num
argument_list|)
condition|)
block|{
if|if
condition|(
name|qisneg
argument_list|(
name|val2
argument_list|)
condition|)
name|math_error
argument_list|(
literal|"Very large bit position"
argument_list|)
expr_stmt|;
return|return
name|qlink
argument_list|(
operator|&
name|_qzero_
argument_list|)
return|;
block|}
return|return
name|itoq
argument_list|(
operator|(
name|long
operator|)
name|qisset
argument_list|(
name|val1
argument_list|,
name|qtoi
argument_list|(
name|val2
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
end_block

begin_function
specifier|static
name|NUMBER
modifier|*
name|f_digit
parameter_list|(
name|val1
parameter_list|,
name|val2
parameter_list|)
name|NUMBER
modifier|*
name|val1
decl_stmt|,
decl|*
name|val2
decl_stmt|;
end_function

begin_block
block|{
if|if
condition|(
name|qisfrac
argument_list|(
name|val2
argument_list|)
condition|)
name|math_error
argument_list|(
literal|"Non-integral digit position"
argument_list|)
expr_stmt|;
if|if
condition|(
name|qiszero
argument_list|(
name|val1
argument_list|)
operator|||
operator|(
name|qisint
argument_list|(
name|val1
argument_list|)
operator|&&
name|qisneg
argument_list|(
name|val2
argument_list|)
operator|)
condition|)
return|return
name|qlink
argument_list|(
operator|&
name|_qzero_
argument_list|)
return|;
if|if
condition|(
name|zisbig
argument_list|(
name|val2
operator|->
name|num
argument_list|)
condition|)
block|{
if|if
condition|(
name|qisneg
argument_list|(
name|val2
argument_list|)
condition|)
name|math_error
argument_list|(
literal|"Very large digit position"
argument_list|)
expr_stmt|;
return|return
name|qlink
argument_list|(
operator|&
name|_qzero_
argument_list|)
return|;
block|}
return|return
name|itoq
argument_list|(
operator|(
name|long
operator|)
name|qdigit
argument_list|(
name|val1
argument_list|,
name|qtoi
argument_list|(
name|val2
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
end_block

begin_function
specifier|static
name|NUMBER
modifier|*
name|f_digits
parameter_list|(
name|val
parameter_list|)
name|NUMBER
modifier|*
name|val
decl_stmt|;
block|{
return|return
name|itoq
argument_list|(
operator|(
name|long
operator|)
name|qdigits
argument_list|(
name|val
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|NUMBER
modifier|*
name|f_places
parameter_list|(
name|val
parameter_list|)
name|NUMBER
modifier|*
name|val
decl_stmt|;
block|{
return|return
name|itoq
argument_list|(
operator|(
name|long
operator|)
name|qplaces
argument_list|(
name|val
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|NUMBER
modifier|*
name|f_xor
parameter_list|(
name|count
parameter_list|,
name|vals
parameter_list|)
name|int
name|count
decl_stmt|;
name|NUMBER
modifier|*
modifier|*
name|vals
decl_stmt|;
block|{
name|NUMBER
modifier|*
name|val
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
name|val
operator|=
name|qlink
argument_list|(
operator|*
name|vals
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|count
operator|>
literal|0
condition|)
block|{
name|tmp
operator|=
name|qxor
argument_list|(
name|val
argument_list|,
operator|*
operator|++
name|vals
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|val
operator|=
name|tmp
expr_stmt|;
block|}
return|return
name|val
return|;
block|}
end_function

begin_function
specifier|static
name|NUMBER
modifier|*
name|f_min
parameter_list|(
name|count
parameter_list|,
name|vals
parameter_list|)
name|int
name|count
decl_stmt|;
name|NUMBER
modifier|*
modifier|*
name|vals
decl_stmt|;
block|{
name|NUMBER
modifier|*
name|val
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
name|val
operator|=
name|qlink
argument_list|(
operator|*
name|vals
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|count
operator|>
literal|0
condition|)
block|{
name|tmp
operator|=
name|qmin
argument_list|(
name|val
argument_list|,
operator|*
operator|++
name|vals
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|val
operator|=
name|tmp
expr_stmt|;
block|}
return|return
name|val
return|;
block|}
end_function

begin_function
specifier|static
name|NUMBER
modifier|*
name|f_max
parameter_list|(
name|count
parameter_list|,
name|vals
parameter_list|)
name|int
name|count
decl_stmt|;
name|NUMBER
modifier|*
modifier|*
name|vals
decl_stmt|;
block|{
name|NUMBER
modifier|*
name|val
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
name|val
operator|=
name|qlink
argument_list|(
operator|*
name|vals
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|count
operator|>
literal|0
condition|)
block|{
name|tmp
operator|=
name|qmax
argument_list|(
name|val
argument_list|,
operator|*
operator|++
name|vals
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|val
operator|=
name|tmp
expr_stmt|;
block|}
return|return
name|val
return|;
block|}
end_function

begin_function
specifier|static
name|NUMBER
modifier|*
name|f_gcd
parameter_list|(
name|count
parameter_list|,
name|vals
parameter_list|)
name|int
name|count
decl_stmt|;
name|NUMBER
modifier|*
modifier|*
name|vals
decl_stmt|;
block|{
name|NUMBER
modifier|*
name|val
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
name|val
operator|=
name|qabs
argument_list|(
operator|*
name|vals
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|count
operator|>
literal|0
condition|)
block|{
name|tmp
operator|=
name|qgcd
argument_list|(
name|val
argument_list|,
operator|*
operator|++
name|vals
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|val
operator|=
name|tmp
expr_stmt|;
block|}
return|return
name|val
return|;
block|}
end_function

begin_function
specifier|static
name|NUMBER
modifier|*
name|f_lcm
parameter_list|(
name|count
parameter_list|,
name|vals
parameter_list|)
name|int
name|count
decl_stmt|;
name|NUMBER
modifier|*
modifier|*
name|vals
decl_stmt|;
block|{
name|NUMBER
modifier|*
name|val
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
name|val
operator|=
name|qabs
argument_list|(
operator|*
name|vals
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|count
operator|>
literal|0
condition|)
block|{
name|tmp
operator|=
name|qlcm
argument_list|(
name|val
argument_list|,
operator|*
operator|++
name|vals
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|val
operator|=
name|tmp
expr_stmt|;
if|if
condition|(
name|qiszero
argument_list|(
name|val
argument_list|)
condition|)
break|break;
block|}
return|return
name|val
return|;
block|}
end_function

begin_function
specifier|static
name|VALUE
name|f_hash
parameter_list|(
name|count
parameter_list|,
name|vals
parameter_list|)
name|int
name|count
decl_stmt|;
name|VALUE
modifier|*
modifier|*
name|vals
decl_stmt|;
block|{
name|HASH
name|hash
decl_stmt|;
name|long
name|lhash
decl_stmt|;
name|VALUE
name|result
decl_stmt|;
name|hash
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|count
operator|--
operator|>
literal|0
condition|)
name|hash
operator|=
name|hash
operator|*
literal|947369
operator|+
name|hashvalue
argument_list|(
operator|*
name|vals
operator|++
argument_list|)
expr_stmt|;
name|lhash
operator|=
operator|(
name|long
operator|)
name|hash
expr_stmt|;
if|if
condition|(
name|lhash
operator|<
literal|0
condition|)
name|lhash
operator|=
operator|-
name|lhash
expr_stmt|;
if|if
condition|(
name|lhash
operator|<
literal|0
condition|)
name|lhash
operator|=
literal|0
expr_stmt|;
name|result
operator|.
name|v_num
operator|=
name|itoq
argument_list|(
name|lhash
argument_list|)
expr_stmt|;
name|result
operator|.
name|v_type
operator|=
name|V_NUM
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|VALUE
name|f_avg
parameter_list|(
name|count
parameter_list|,
name|vals
parameter_list|)
name|int
name|count
decl_stmt|;
name|VALUE
modifier|*
modifier|*
name|vals
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|VALUE
name|result
decl_stmt|;
name|VALUE
name|tmp
decl_stmt|;
name|VALUE
name|div
decl_stmt|;
name|result
operator|.
name|v_num
operator|=
name|qlink
argument_list|(
operator|&
name|_qzero_
argument_list|)
expr_stmt|;
name|result
operator|.
name|v_type
operator|=
name|V_NUM
expr_stmt|;
for|for
control|(
name|i
operator|=
name|count
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|addvalue
argument_list|(
operator|&
name|result
argument_list|,
operator|*
name|vals
operator|++
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
name|freevalue
argument_list|(
operator|&
name|result
argument_list|)
expr_stmt|;
name|result
operator|=
name|tmp
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|<=
literal|1
condition|)
return|return
name|result
return|;
name|div
operator|.
name|v_num
operator|=
name|itoq
argument_list|(
operator|(
name|long
operator|)
name|count
argument_list|)
expr_stmt|;
name|div
operator|.
name|v_type
operator|=
name|V_NUM
expr_stmt|;
name|divvalue
argument_list|(
operator|&
name|result
argument_list|,
operator|&
name|div
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|div
operator|.
name|v_num
argument_list|)
expr_stmt|;
return|return
name|tmp
return|;
block|}
end_function

begin_function
specifier|static
name|NUMBER
modifier|*
name|f_hmean
parameter_list|(
name|count
parameter_list|,
name|vals
parameter_list|)
name|int
name|count
decl_stmt|;
name|NUMBER
modifier|*
modifier|*
name|vals
decl_stmt|;
block|{
name|NUMBER
modifier|*
name|val
decl_stmt|,
modifier|*
name|tmp
decl_stmt|,
modifier|*
name|tmp2
decl_stmt|,
modifier|*
name|num
decl_stmt|;
name|num
operator|=
name|itoq
argument_list|(
name|count
argument_list|)
expr_stmt|;
name|val
operator|=
name|qinv
argument_list|(
operator|*
name|vals
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|count
operator|>
literal|0
condition|)
block|{
name|tmp2
operator|=
name|qinv
argument_list|(
operator|*
operator|++
name|vals
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|qadd
argument_list|(
name|val
argument_list|,
name|tmp2
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|tmp2
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|val
operator|=
name|tmp
expr_stmt|;
block|}
name|tmp
operator|=
name|qdiv
argument_list|(
name|num
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|num
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|val
argument_list|)
expr_stmt|;
return|return
name|tmp
return|;
block|}
end_function

begin_function
specifier|static
name|VALUE
name|f_ssq
parameter_list|(
name|count
parameter_list|,
name|vals
parameter_list|)
name|int
name|count
decl_stmt|;
name|VALUE
modifier|*
modifier|*
name|vals
decl_stmt|;
block|{
name|VALUE
name|result
decl_stmt|,
name|tmp1
decl_stmt|,
name|tmp2
decl_stmt|;
name|squarevalue
argument_list|(
operator|*
name|vals
operator|++
argument_list|,
operator|&
name|result
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|count
operator|>
literal|0
condition|)
block|{
name|squarevalue
argument_list|(
operator|*
name|vals
operator|++
argument_list|,
operator|&
name|tmp1
argument_list|)
expr_stmt|;
name|addvalue
argument_list|(
operator|&
name|tmp1
argument_list|,
operator|&
name|result
argument_list|,
operator|&
name|tmp2
argument_list|)
expr_stmt|;
name|freevalue
argument_list|(
operator|&
name|tmp1
argument_list|)
expr_stmt|;
name|freevalue
argument_list|(
operator|&
name|result
argument_list|)
expr_stmt|;
name|result
operator|=
name|tmp2
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|NUMBER
modifier|*
name|f_ismult
parameter_list|(
name|val1
parameter_list|,
name|val2
parameter_list|)
name|NUMBER
modifier|*
name|val1
decl_stmt|,
decl|*
name|val2
decl_stmt|;
end_function

begin_block
block|{
return|return
name|itoq
argument_list|(
operator|(
name|long
operator|)
name|qdivides
argument_list|(
name|val1
argument_list|,
name|val2
argument_list|)
argument_list|)
return|;
block|}
end_block

begin_function
specifier|static
name|NUMBER
modifier|*
name|f_meq
parameter_list|(
name|val1
parameter_list|,
name|val2
parameter_list|,
name|val3
parameter_list|)
name|NUMBER
modifier|*
name|val1
decl_stmt|,
decl|*
name|val2
decl_stmt|,
modifier|*
name|val3
decl_stmt|;
end_function

begin_block
block|{
name|NUMBER
modifier|*
name|tmp
decl_stmt|,
modifier|*
name|res
decl_stmt|;
name|tmp
operator|=
name|qsub
argument_list|(
name|val1
argument_list|,
name|val2
argument_list|)
expr_stmt|;
name|res
operator|=
name|itoq
argument_list|(
operator|(
name|long
operator|)
name|qdivides
argument_list|(
name|tmp
argument_list|,
name|val3
argument_list|)
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_block

begin_function
specifier|static
name|VALUE
name|f_exp
parameter_list|(
name|count
parameter_list|,
name|vals
parameter_list|)
name|int
name|count
decl_stmt|;
name|VALUE
modifier|*
modifier|*
name|vals
decl_stmt|;
block|{
name|VALUE
name|result
decl_stmt|;
name|NUMBER
modifier|*
name|err
decl_stmt|;
name|err
operator|=
name|_epsilon_
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|2
condition|)
block|{
if|if
condition|(
name|vals
index|[
literal|1
index|]
operator|->
name|v_type
operator|!=
name|V_NUM
condition|)
name|math_error
argument_list|(
literal|"Non-real epsilon value for exp"
argument_list|)
expr_stmt|;
name|err
operator|=
name|vals
index|[
literal|1
index|]
operator|->
name|v_num
expr_stmt|;
block|}
switch|switch
condition|(
name|vals
index|[
literal|0
index|]
operator|->
name|v_type
condition|)
block|{
case|case
name|V_NUM
case|:
name|result
operator|.
name|v_num
operator|=
name|qexp
argument_list|(
name|vals
index|[
literal|0
index|]
operator|->
name|v_num
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|result
operator|.
name|v_type
operator|=
name|V_NUM
expr_stmt|;
break|break;
case|case
name|V_COM
case|:
name|result
operator|.
name|v_com
operator|=
name|cexp
argument_list|(
name|vals
index|[
literal|0
index|]
operator|->
name|v_com
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|result
operator|.
name|v_type
operator|=
name|V_COM
expr_stmt|;
break|break;
default|default:
name|math_error
argument_list|(
literal|"Bad argument type for exp"
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|VALUE
name|f_ln
parameter_list|(
name|count
parameter_list|,
name|vals
parameter_list|)
name|int
name|count
decl_stmt|;
name|VALUE
modifier|*
modifier|*
name|vals
decl_stmt|;
block|{
name|VALUE
name|result
decl_stmt|;
name|COMPLEX
name|ctmp
decl_stmt|;
name|NUMBER
modifier|*
name|err
decl_stmt|;
name|err
operator|=
name|_epsilon_
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|2
condition|)
block|{
if|if
condition|(
name|vals
index|[
literal|1
index|]
operator|->
name|v_type
operator|!=
name|V_NUM
condition|)
name|math_error
argument_list|(
literal|"Non-real epsilon value for ln"
argument_list|)
expr_stmt|;
name|err
operator|=
name|vals
index|[
literal|1
index|]
operator|->
name|v_num
expr_stmt|;
block|}
switch|switch
condition|(
name|vals
index|[
literal|0
index|]
operator|->
name|v_type
condition|)
block|{
case|case
name|V_NUM
case|:
if|if
condition|(
operator|!
name|qisneg
argument_list|(
name|vals
index|[
literal|0
index|]
operator|->
name|v_num
argument_list|)
operator|&&
operator|!
name|qiszero
argument_list|(
name|vals
index|[
literal|0
index|]
operator|->
name|v_num
argument_list|)
condition|)
block|{
name|result
operator|.
name|v_num
operator|=
name|qln
argument_list|(
name|vals
index|[
literal|0
index|]
operator|->
name|v_num
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|result
operator|.
name|v_type
operator|=
name|V_NUM
expr_stmt|;
break|break;
block|}
name|ctmp
operator|.
name|real
operator|=
name|vals
index|[
literal|0
index|]
operator|->
name|v_num
expr_stmt|;
name|ctmp
operator|.
name|imag
operator|=
operator|&
name|_qzero_
expr_stmt|;
name|ctmp
operator|.
name|links
operator|=
literal|1
expr_stmt|;
name|result
operator|.
name|v_com
operator|=
name|cln
argument_list|(
operator|&
name|ctmp
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|result
operator|.
name|v_type
operator|=
name|V_COM
expr_stmt|;
break|break;
case|case
name|V_COM
case|:
name|result
operator|.
name|v_com
operator|=
name|cln
argument_list|(
name|vals
index|[
literal|0
index|]
operator|->
name|v_com
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|result
operator|.
name|v_type
operator|=
name|V_COM
expr_stmt|;
break|break;
default|default:
name|math_error
argument_list|(
literal|"Bad argument type for ln"
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|VALUE
name|f_cos
parameter_list|(
name|count
parameter_list|,
name|vals
parameter_list|)
name|int
name|count
decl_stmt|;
name|VALUE
modifier|*
modifier|*
name|vals
decl_stmt|;
block|{
name|VALUE
name|result
decl_stmt|;
name|COMPLEX
modifier|*
name|c
decl_stmt|;
name|NUMBER
modifier|*
name|err
decl_stmt|;
name|err
operator|=
name|_epsilon_
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|2
condition|)
block|{
if|if
condition|(
name|vals
index|[
literal|1
index|]
operator|->
name|v_type
operator|!=
name|V_NUM
condition|)
name|math_error
argument_list|(
literal|"Non-real epsilon value for cos"
argument_list|)
expr_stmt|;
name|err
operator|=
name|vals
index|[
literal|1
index|]
operator|->
name|v_num
expr_stmt|;
block|}
switch|switch
condition|(
name|vals
index|[
literal|0
index|]
operator|->
name|v_type
condition|)
block|{
case|case
name|V_NUM
case|:
name|result
operator|.
name|v_num
operator|=
name|qcos
argument_list|(
name|vals
index|[
literal|0
index|]
operator|->
name|v_num
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|result
operator|.
name|v_type
operator|=
name|V_NUM
expr_stmt|;
break|break;
case|case
name|V_COM
case|:
name|c
operator|=
name|ccos
argument_list|(
name|vals
index|[
literal|0
index|]
operator|->
name|v_com
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|result
operator|.
name|v_com
operator|=
name|c
expr_stmt|;
name|result
operator|.
name|v_type
operator|=
name|V_COM
expr_stmt|;
if|if
condition|(
name|cisreal
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|result
operator|.
name|v_num
operator|=
name|qlink
argument_list|(
name|c
operator|->
name|real
argument_list|)
expr_stmt|;
name|result
operator|.
name|v_type
operator|=
name|V_NUM
expr_stmt|;
name|comfree
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|math_error
argument_list|(
literal|"Bad argument type for cos"
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|VALUE
name|f_sin
parameter_list|(
name|count
parameter_list|,
name|vals
parameter_list|)
name|int
name|count
decl_stmt|;
name|VALUE
modifier|*
modifier|*
name|vals
decl_stmt|;
block|{
name|VALUE
name|result
decl_stmt|;
name|COMPLEX
modifier|*
name|c
decl_stmt|;
name|NUMBER
modifier|*
name|err
decl_stmt|;
name|err
operator|=
name|_epsilon_
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|2
condition|)
block|{
if|if
condition|(
name|vals
index|[
literal|1
index|]
operator|->
name|v_type
operator|!=
name|V_NUM
condition|)
name|math_error
argument_list|(
literal|"Non-real epsilon value for sin"
argument_list|)
expr_stmt|;
name|err
operator|=
name|vals
index|[
literal|1
index|]
operator|->
name|v_num
expr_stmt|;
block|}
switch|switch
condition|(
name|vals
index|[
literal|0
index|]
operator|->
name|v_type
condition|)
block|{
case|case
name|V_NUM
case|:
name|result
operator|.
name|v_num
operator|=
name|qsin
argument_list|(
name|vals
index|[
literal|0
index|]
operator|->
name|v_num
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|result
operator|.
name|v_type
operator|=
name|V_NUM
expr_stmt|;
break|break;
case|case
name|V_COM
case|:
name|c
operator|=
name|csin
argument_list|(
name|vals
index|[
literal|0
index|]
operator|->
name|v_com
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|result
operator|.
name|v_com
operator|=
name|c
expr_stmt|;
name|result
operator|.
name|v_type
operator|=
name|V_COM
expr_stmt|;
if|if
condition|(
name|cisreal
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|result
operator|.
name|v_num
operator|=
name|qlink
argument_list|(
name|c
operator|->
name|real
argument_list|)
expr_stmt|;
name|result
operator|.
name|v_type
operator|=
name|V_NUM
expr_stmt|;
name|comfree
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|math_error
argument_list|(
literal|"Bad argument type for sin"
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|VALUE
name|f_arg
parameter_list|(
name|count
parameter_list|,
name|vals
parameter_list|)
name|int
name|count
decl_stmt|;
name|VALUE
modifier|*
modifier|*
name|vals
decl_stmt|;
block|{
name|VALUE
name|result
decl_stmt|;
name|COMPLEX
modifier|*
name|c
decl_stmt|;
name|NUMBER
modifier|*
name|err
decl_stmt|;
name|err
operator|=
name|_epsilon_
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|2
condition|)
block|{
if|if
condition|(
name|vals
index|[
literal|1
index|]
operator|->
name|v_type
operator|!=
name|V_NUM
condition|)
name|math_error
argument_list|(
literal|"Non-real epsilon value for arg"
argument_list|)
expr_stmt|;
name|err
operator|=
name|vals
index|[
literal|1
index|]
operator|->
name|v_num
expr_stmt|;
block|}
name|result
operator|.
name|v_type
operator|=
name|V_NUM
expr_stmt|;
switch|switch
condition|(
name|vals
index|[
literal|0
index|]
operator|->
name|v_type
condition|)
block|{
case|case
name|V_NUM
case|:
if|if
condition|(
name|qisneg
argument_list|(
name|vals
index|[
literal|0
index|]
operator|->
name|v_num
argument_list|)
condition|)
name|result
operator|.
name|v_num
operator|=
name|qpi
argument_list|(
name|err
argument_list|)
expr_stmt|;
else|else
name|result
operator|.
name|v_num
operator|=
name|qlink
argument_list|(
operator|&
name|_qzero_
argument_list|)
expr_stmt|;
break|break;
case|case
name|V_COM
case|:
name|c
operator|=
name|vals
index|[
literal|0
index|]
operator|->
name|v_com
expr_stmt|;
if|if
condition|(
name|ciszero
argument_list|(
name|c
argument_list|)
condition|)
name|result
operator|.
name|v_num
operator|=
name|qlink
argument_list|(
operator|&
name|_qzero_
argument_list|)
expr_stmt|;
else|else
name|result
operator|.
name|v_num
operator|=
name|qatan2
argument_list|(
name|c
operator|->
name|imag
argument_list|,
name|c
operator|->
name|real
argument_list|,
name|err
argument_list|)
expr_stmt|;
break|break;
default|default:
name|math_error
argument_list|(
literal|"Bad argument type for arg"
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|NUMBER
modifier|*
name|f_legtoleg
parameter_list|(
name|val1
parameter_list|,
name|val2
parameter_list|)
name|NUMBER
modifier|*
name|val1
decl_stmt|,
decl|*
name|val2
decl_stmt|;
end_function

begin_block
block|{
return|return
name|qlegtoleg
argument_list|(
name|val1
argument_list|,
name|val2
argument_list|,
name|FALSE
argument_list|)
return|;
block|}
end_block

begin_function
specifier|static
name|NUMBER
modifier|*
name|f_trunc
parameter_list|(
name|count
parameter_list|,
name|vals
parameter_list|)
name|int
name|count
decl_stmt|;
name|NUMBER
modifier|*
modifier|*
name|vals
decl_stmt|;
block|{
name|NUMBER
modifier|*
name|val
decl_stmt|;
name|val
operator|=
operator|&
name|_qzero_
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|2
condition|)
name|val
operator|=
name|vals
index|[
literal|1
index|]
expr_stmt|;
return|return
name|qtrunc
argument_list|(
operator|*
name|vals
argument_list|,
name|val
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|VALUE
name|f_bround
parameter_list|(
name|count
parameter_list|,
name|vals
parameter_list|)
name|int
name|count
decl_stmt|;
name|VALUE
modifier|*
modifier|*
name|vals
decl_stmt|;
block|{
name|VALUE
modifier|*
name|vp
decl_stmt|,
name|tmp
decl_stmt|,
name|res
decl_stmt|;
if|if
condition|(
name|count
operator|>
literal|1
condition|)
name|vp
operator|=
name|vals
index|[
literal|1
index|]
expr_stmt|;
else|else
block|{
name|tmp
operator|.
name|v_type
operator|=
name|V_INT
expr_stmt|;
name|tmp
operator|.
name|v_num
operator|=
literal|0
expr_stmt|;
name|vp
operator|=
operator|&
name|tmp
expr_stmt|;
block|}
name|broundvalue
argument_list|(
name|vals
index|[
literal|0
index|]
argument_list|,
name|vp
argument_list|,
operator|&
name|res
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_function
specifier|static
name|VALUE
name|f_round
parameter_list|(
name|count
parameter_list|,
name|vals
parameter_list|)
name|int
name|count
decl_stmt|;
name|VALUE
modifier|*
modifier|*
name|vals
decl_stmt|;
block|{
name|VALUE
modifier|*
name|vp
decl_stmt|,
name|tmp
decl_stmt|,
name|res
decl_stmt|;
if|if
condition|(
name|count
operator|>
literal|1
condition|)
name|vp
operator|=
name|vals
index|[
literal|1
index|]
expr_stmt|;
else|else
block|{
name|tmp
operator|.
name|v_type
operator|=
name|V_INT
expr_stmt|;
name|tmp
operator|.
name|v_num
operator|=
literal|0
expr_stmt|;
name|vp
operator|=
operator|&
name|tmp
expr_stmt|;
block|}
name|roundvalue
argument_list|(
name|vals
index|[
literal|0
index|]
argument_list|,
name|vp
argument_list|,
operator|&
name|res
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_function
specifier|static
name|NUMBER
modifier|*
name|f_btrunc
parameter_list|(
name|count
parameter_list|,
name|vals
parameter_list|)
name|int
name|count
decl_stmt|;
name|NUMBER
modifier|*
modifier|*
name|vals
decl_stmt|;
block|{
name|NUMBER
modifier|*
name|val
decl_stmt|;
name|val
operator|=
operator|&
name|_qzero_
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|2
condition|)
name|val
operator|=
name|vals
index|[
literal|1
index|]
expr_stmt|;
return|return
name|qbtrunc
argument_list|(
operator|*
name|vals
argument_list|,
name|val
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|NUMBER
modifier|*
name|f_near
parameter_list|(
name|count
parameter_list|,
name|vals
parameter_list|)
name|int
name|count
decl_stmt|;
name|NUMBER
modifier|*
modifier|*
name|vals
decl_stmt|;
block|{
name|NUMBER
modifier|*
name|val
decl_stmt|;
name|val
operator|=
name|_epsilon_
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|3
condition|)
name|val
operator|=
name|vals
index|[
literal|2
index|]
expr_stmt|;
return|return
name|itoq
argument_list|(
operator|(
name|long
operator|)
name|qnear
argument_list|(
name|vals
index|[
literal|0
index|]
argument_list|,
name|vals
index|[
literal|1
index|]
argument_list|,
name|val
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|NUMBER
modifier|*
name|f_cfsim
parameter_list|(
name|val
parameter_list|)
name|NUMBER
modifier|*
name|val
decl_stmt|;
block|{
return|return
name|qcfappr
argument_list|(
name|val
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|NUMBER
modifier|*
name|f_ceil
parameter_list|(
name|val
parameter_list|)
name|NUMBER
modifier|*
name|val
decl_stmt|;
block|{
name|NUMBER
modifier|*
name|val2
decl_stmt|;
if|if
condition|(
name|qisint
argument_list|(
name|val
argument_list|)
condition|)
return|return
name|qlink
argument_list|(
name|val
argument_list|)
return|;
name|val2
operator|=
name|qint
argument_list|(
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|qisneg
argument_list|(
name|val
argument_list|)
condition|)
return|return
name|val2
return|;
name|val
operator|=
name|qinc
argument_list|(
name|val2
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|val2
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_function
specifier|static
name|NUMBER
modifier|*
name|f_floor
parameter_list|(
name|val
parameter_list|)
name|NUMBER
modifier|*
name|val
decl_stmt|;
block|{
name|NUMBER
modifier|*
name|val2
decl_stmt|;
if|if
condition|(
name|qisint
argument_list|(
name|val
argument_list|)
condition|)
return|return
name|qlink
argument_list|(
name|val
argument_list|)
return|;
name|val2
operator|=
name|qint
argument_list|(
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|qisneg
argument_list|(
name|val
argument_list|)
condition|)
return|return
name|val2
return|;
name|val
operator|=
name|qdec
argument_list|(
name|val2
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|val2
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_function
specifier|static
name|NUMBER
modifier|*
name|f_highbit
parameter_list|(
name|val
parameter_list|)
name|NUMBER
modifier|*
name|val
decl_stmt|;
block|{
if|if
condition|(
name|qiszero
argument_list|(
name|val
argument_list|)
condition|)
name|math_error
argument_list|(
literal|"Highbit of zero"
argument_list|)
expr_stmt|;
if|if
condition|(
name|qisfrac
argument_list|(
name|val
argument_list|)
condition|)
name|math_error
argument_list|(
literal|"Highbit of non-integer"
argument_list|)
expr_stmt|;
return|return
name|itoq
argument_list|(
name|zhighbit
argument_list|(
name|val
operator|->
name|num
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|NUMBER
modifier|*
name|f_lowbit
parameter_list|(
name|val
parameter_list|)
name|NUMBER
modifier|*
name|val
decl_stmt|;
block|{
if|if
condition|(
name|qiszero
argument_list|(
name|val
argument_list|)
condition|)
name|math_error
argument_list|(
literal|"Lowbit of zero"
argument_list|)
expr_stmt|;
if|if
condition|(
name|qisfrac
argument_list|(
name|val
argument_list|)
condition|)
name|math_error
argument_list|(
literal|"Lowbit of non-integer"
argument_list|)
expr_stmt|;
return|return
name|itoq
argument_list|(
name|zlowbit
argument_list|(
name|val
operator|->
name|num
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|VALUE
name|f_sqrt
parameter_list|(
name|count
parameter_list|,
name|vals
parameter_list|)
name|int
name|count
decl_stmt|;
name|VALUE
modifier|*
modifier|*
name|vals
decl_stmt|;
block|{
name|VALUE
modifier|*
name|vp
decl_stmt|,
name|err
decl_stmt|,
name|result
decl_stmt|;
if|if
condition|(
name|count
operator|>
literal|1
condition|)
name|vp
operator|=
name|vals
index|[
literal|1
index|]
expr_stmt|;
else|else
block|{
name|err
operator|.
name|v_num
operator|=
name|_epsilon_
expr_stmt|;
name|err
operator|.
name|v_type
operator|=
name|V_NUM
expr_stmt|;
name|vp
operator|=
operator|&
name|err
expr_stmt|;
block|}
name|sqrtvalue
argument_list|(
name|vals
index|[
literal|0
index|]
argument_list|,
name|vp
argument_list|,
operator|&
name|result
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|VALUE
name|f_root
parameter_list|(
name|count
parameter_list|,
name|vals
parameter_list|)
name|int
name|count
decl_stmt|;
name|VALUE
modifier|*
modifier|*
name|vals
decl_stmt|;
block|{
name|VALUE
modifier|*
name|vp
decl_stmt|,
name|err
decl_stmt|,
name|result
decl_stmt|;
if|if
condition|(
name|count
operator|>
literal|2
condition|)
name|vp
operator|=
name|vals
index|[
literal|3
index|]
expr_stmt|;
else|else
block|{
name|err
operator|.
name|v_num
operator|=
name|_epsilon_
expr_stmt|;
name|err
operator|.
name|v_type
operator|=
name|V_NUM
expr_stmt|;
name|vp
operator|=
operator|&
name|err
expr_stmt|;
block|}
name|rootvalue
argument_list|(
name|vals
index|[
literal|0
index|]
argument_list|,
name|vals
index|[
literal|1
index|]
argument_list|,
name|vp
argument_list|,
operator|&
name|result
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|VALUE
name|f_power
parameter_list|(
name|count
parameter_list|,
name|vals
parameter_list|)
name|int
name|count
decl_stmt|;
name|VALUE
modifier|*
modifier|*
name|vals
decl_stmt|;
block|{
name|VALUE
modifier|*
name|vp
decl_stmt|,
name|err
decl_stmt|,
name|result
decl_stmt|;
if|if
condition|(
name|count
operator|>
literal|2
condition|)
name|vp
operator|=
name|vals
index|[
literal|2
index|]
expr_stmt|;
else|else
block|{
name|err
operator|.
name|v_num
operator|=
name|_epsilon_
expr_stmt|;
name|err
operator|.
name|v_type
operator|=
name|V_NUM
expr_stmt|;
name|vp
operator|=
operator|&
name|err
expr_stmt|;
block|}
name|powervalue
argument_list|(
name|vals
index|[
literal|0
index|]
argument_list|,
name|vals
index|[
literal|1
index|]
argument_list|,
name|vp
argument_list|,
operator|&
name|result
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|VALUE
name|f_polar
parameter_list|(
name|count
parameter_list|,
name|vals
parameter_list|)
name|int
name|count
decl_stmt|;
name|VALUE
modifier|*
modifier|*
name|vals
decl_stmt|;
block|{
name|VALUE
modifier|*
name|vp
decl_stmt|,
name|err
decl_stmt|,
name|result
decl_stmt|;
name|COMPLEX
modifier|*
name|c
decl_stmt|;
if|if
condition|(
name|count
operator|>
literal|2
condition|)
name|vp
operator|=
name|vals
index|[
literal|2
index|]
expr_stmt|;
else|else
block|{
name|err
operator|.
name|v_num
operator|=
name|_epsilon_
expr_stmt|;
name|err
operator|.
name|v_type
operator|=
name|V_NUM
expr_stmt|;
name|vp
operator|=
operator|&
name|err
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|vals
index|[
literal|0
index|]
operator|->
name|v_type
operator|!=
name|V_NUM
operator|)
operator|||
operator|(
name|vals
index|[
literal|1
index|]
operator|->
name|v_type
operator|!=
name|V_NUM
operator|)
condition|)
name|math_error
argument_list|(
literal|"Non-real argument for polar"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|vp
operator|->
name|v_type
operator|!=
name|V_NUM
operator|)
operator|||
name|qisneg
argument_list|(
name|vp
operator|->
name|v_num
argument_list|)
operator|||
name|qiszero
argument_list|(
name|vp
operator|->
name|v_num
argument_list|)
condition|)
name|math_error
argument_list|(
literal|"Bad epsilon value for polar"
argument_list|)
expr_stmt|;
name|c
operator|=
name|cpolar
argument_list|(
name|vals
index|[
literal|0
index|]
operator|->
name|v_num
argument_list|,
name|vals
index|[
literal|1
index|]
operator|->
name|v_num
argument_list|,
name|vp
operator|->
name|v_num
argument_list|)
expr_stmt|;
name|result
operator|.
name|v_com
operator|=
name|c
expr_stmt|;
name|result
operator|.
name|v_type
operator|=
name|V_COM
expr_stmt|;
if|if
condition|(
name|cisreal
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|result
operator|.
name|v_num
operator|=
name|qlink
argument_list|(
name|c
operator|->
name|real
argument_list|)
expr_stmt|;
name|result
operator|.
name|v_type
operator|=
name|V_NUM
expr_stmt|;
name|comfree
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|NUMBER
modifier|*
name|f_ilog
parameter_list|(
name|val1
parameter_list|,
name|val2
parameter_list|)
name|NUMBER
modifier|*
name|val1
decl_stmt|,
decl|*
name|val2
decl_stmt|;
end_function

begin_block
block|{
return|return
name|itoq
argument_list|(
name|qilog
argument_list|(
name|val1
argument_list|,
name|val2
argument_list|)
argument_list|)
return|;
block|}
end_block

begin_function
specifier|static
name|NUMBER
modifier|*
name|f_ilog2
parameter_list|(
name|val
parameter_list|)
name|NUMBER
modifier|*
name|val
decl_stmt|;
block|{
return|return
name|itoq
argument_list|(
name|qilog2
argument_list|(
name|val
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|NUMBER
modifier|*
name|f_ilog10
parameter_list|(
name|val
parameter_list|)
name|NUMBER
modifier|*
name|val
decl_stmt|;
block|{
return|return
name|itoq
argument_list|(
name|qilog10
argument_list|(
name|val
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|NUMBER
modifier|*
name|f_faccnt
parameter_list|(
name|val1
parameter_list|,
name|val2
parameter_list|)
name|NUMBER
modifier|*
name|val1
decl_stmt|,
decl|*
name|val2
decl_stmt|;
end_function

begin_block
block|{
return|return
name|itoq
argument_list|(
name|qdivcount
argument_list|(
name|val1
argument_list|,
name|val2
argument_list|)
argument_list|)
return|;
block|}
end_block

begin_function
specifier|static
name|VALUE
name|f_matfill
parameter_list|(
name|count
parameter_list|,
name|vals
parameter_list|)
name|int
name|count
decl_stmt|;
name|VALUE
modifier|*
modifier|*
name|vals
decl_stmt|;
block|{
name|VALUE
modifier|*
name|v1
decl_stmt|,
modifier|*
name|v2
decl_stmt|,
modifier|*
name|v3
decl_stmt|;
name|VALUE
name|result
decl_stmt|;
name|v1
operator|=
name|vals
index|[
literal|0
index|]
expr_stmt|;
name|v2
operator|=
name|vals
index|[
literal|1
index|]
expr_stmt|;
name|v3
operator|=
operator|(
name|count
operator|==
literal|3
operator|)
condition|?
name|vals
index|[
literal|2
index|]
else|:
name|NULL
expr_stmt|;
if|if
condition|(
name|v1
operator|->
name|v_type
operator|!=
name|V_ADDR
condition|)
name|math_error
argument_list|(
literal|"Non-variable argument for matfill"
argument_list|)
expr_stmt|;
name|v1
operator|=
name|v1
operator|->
name|v_addr
expr_stmt|;
if|if
condition|(
name|v1
operator|->
name|v_type
operator|!=
name|V_MAT
condition|)
name|math_error
argument_list|(
literal|"Non-matrix for matfill"
argument_list|)
expr_stmt|;
if|if
condition|(
name|v2
operator|->
name|v_type
operator|==
name|V_ADDR
condition|)
name|v2
operator|=
name|v2
operator|->
name|v_addr
expr_stmt|;
if|if
condition|(
name|v3
operator|&&
operator|(
name|v3
operator|->
name|v_type
operator|==
name|V_ADDR
operator|)
condition|)
name|v3
operator|=
name|v3
operator|->
name|v_addr
expr_stmt|;
name|matfill
argument_list|(
name|v1
operator|->
name|v_mat
argument_list|,
name|v2
argument_list|,
name|v3
argument_list|)
expr_stmt|;
name|result
operator|.
name|v_type
operator|=
name|V_NULL
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|VALUE
name|f_mattrans
parameter_list|(
name|vp
parameter_list|)
name|VALUE
modifier|*
name|vp
decl_stmt|;
block|{
name|VALUE
name|result
decl_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|!=
name|V_MAT
condition|)
name|math_error
argument_list|(
literal|"Non-matrix argument for mattrans"
argument_list|)
expr_stmt|;
name|result
operator|.
name|v_type
operator|=
name|V_MAT
expr_stmt|;
name|result
operator|.
name|v_mat
operator|=
name|mattrans
argument_list|(
name|vp
operator|->
name|v_mat
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|VALUE
name|f_det
parameter_list|(
name|vp
parameter_list|)
name|VALUE
modifier|*
name|vp
decl_stmt|;
block|{
if|if
condition|(
name|vp
operator|->
name|v_type
operator|!=
name|V_MAT
condition|)
name|math_error
argument_list|(
literal|"Non-matrix argument for det"
argument_list|)
expr_stmt|;
return|return
name|matdet
argument_list|(
name|vp
operator|->
name|v_mat
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|VALUE
name|f_matdim
parameter_list|(
name|vp
parameter_list|)
name|VALUE
modifier|*
name|vp
decl_stmt|;
block|{
name|VALUE
name|result
decl_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|!=
name|V_MAT
condition|)
name|math_error
argument_list|(
literal|"Non-matrix argument for matdim"
argument_list|)
expr_stmt|;
name|result
operator|.
name|v_type
operator|=
name|V_NUM
expr_stmt|;
name|result
operator|.
name|v_num
operator|=
name|itoq
argument_list|(
operator|(
name|long
operator|)
name|vp
operator|->
name|v_mat
operator|->
name|m_dim
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|VALUE
name|f_matmin
parameter_list|(
name|v1
parameter_list|,
name|v2
parameter_list|)
name|VALUE
modifier|*
name|v1
decl_stmt|,
decl|*
name|v2
decl_stmt|;
end_function

begin_block
block|{
name|VALUE
name|result
decl_stmt|;
name|NUMBER
modifier|*
name|q
decl_stmt|;
name|long
name|i
decl_stmt|;
if|if
condition|(
operator|(
name|v1
operator|->
name|v_type
operator|!=
name|V_MAT
operator|)
operator|||
operator|(
name|v2
operator|->
name|v_type
operator|!=
name|V_NUM
operator|)
condition|)
name|math_error
argument_list|(
literal|"Bad argument type for matmin"
argument_list|)
expr_stmt|;
name|q
operator|=
name|v2
operator|->
name|v_num
expr_stmt|;
name|i
operator|=
name|qtoi
argument_list|(
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
name|qisfrac
argument_list|(
name|q
argument_list|)
operator|||
name|qisneg
argument_list|(
name|q
argument_list|)
operator|||
operator|(
name|i
operator|<=
literal|0
operator|)
operator|||
operator|(
name|i
operator|>
name|v1
operator|->
name|v_mat
operator|->
name|m_dim
operator|)
condition|)
name|math_error
argument_list|(
literal|"Bad dimension value for matmin"
argument_list|)
expr_stmt|;
name|result
operator|.
name|v_type
operator|=
name|V_NUM
expr_stmt|;
name|result
operator|.
name|v_num
operator|=
name|itoq
argument_list|(
name|v1
operator|->
name|v_mat
operator|->
name|m_min
index|[
name|i
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_block

begin_function
specifier|static
name|VALUE
name|f_matmax
parameter_list|(
name|v1
parameter_list|,
name|v2
parameter_list|)
name|VALUE
modifier|*
name|v1
decl_stmt|,
decl|*
name|v2
decl_stmt|;
end_function

begin_block
block|{
name|VALUE
name|result
decl_stmt|;
name|NUMBER
modifier|*
name|q
decl_stmt|;
name|long
name|i
decl_stmt|;
if|if
condition|(
operator|(
name|v1
operator|->
name|v_type
operator|!=
name|V_MAT
operator|)
operator|||
operator|(
name|v2
operator|->
name|v_type
operator|!=
name|V_NUM
operator|)
condition|)
name|math_error
argument_list|(
literal|"Bad argument type for matmax"
argument_list|)
expr_stmt|;
name|q
operator|=
name|v2
operator|->
name|v_num
expr_stmt|;
name|i
operator|=
name|qtoi
argument_list|(
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
name|qisfrac
argument_list|(
name|q
argument_list|)
operator|||
name|qisneg
argument_list|(
name|q
argument_list|)
operator|||
operator|(
name|i
operator|<=
literal|0
operator|)
operator|||
operator|(
name|i
operator|>
name|v1
operator|->
name|v_mat
operator|->
name|m_dim
operator|)
condition|)
name|math_error
argument_list|(
literal|"Bad dimension value for matmax"
argument_list|)
expr_stmt|;
name|result
operator|.
name|v_type
operator|=
name|V_NUM
expr_stmt|;
name|result
operator|.
name|v_num
operator|=
name|itoq
argument_list|(
name|v1
operator|->
name|v_mat
operator|->
name|m_max
index|[
name|i
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_block

begin_function
specifier|static
name|VALUE
name|f_cp
parameter_list|(
name|v1
parameter_list|,
name|v2
parameter_list|)
name|VALUE
modifier|*
name|v1
decl_stmt|,
decl|*
name|v2
decl_stmt|;
end_function

begin_block
block|{
name|VALUE
name|result
decl_stmt|;
if|if
condition|(
operator|(
name|v1
operator|->
name|v_type
operator|!=
name|V_MAT
operator|)
operator|||
operator|(
name|v2
operator|->
name|v_type
operator|!=
name|V_MAT
operator|)
condition|)
name|math_error
argument_list|(
literal|"Non-matrix argument for cross product"
argument_list|)
expr_stmt|;
name|result
operator|.
name|v_type
operator|=
name|V_MAT
expr_stmt|;
name|result
operator|.
name|v_mat
operator|=
name|matcross
argument_list|(
name|v1
operator|->
name|v_mat
argument_list|,
name|v2
operator|->
name|v_mat
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_block

begin_function
specifier|static
name|VALUE
name|f_dp
parameter_list|(
name|v1
parameter_list|,
name|v2
parameter_list|)
name|VALUE
modifier|*
name|v1
decl_stmt|,
decl|*
name|v2
decl_stmt|;
end_function

begin_block
block|{
if|if
condition|(
operator|(
name|v1
operator|->
name|v_type
operator|!=
name|V_MAT
operator|)
operator|||
operator|(
name|v2
operator|->
name|v_type
operator|!=
name|V_MAT
operator|)
condition|)
name|math_error
argument_list|(
literal|"Non-matrix argument for dot product"
argument_list|)
expr_stmt|;
return|return
name|matdot
argument_list|(
name|v1
operator|->
name|v_mat
argument_list|,
name|v2
operator|->
name|v_mat
argument_list|)
return|;
block|}
end_block

begin_function
specifier|static
name|VALUE
name|f_strlen
parameter_list|(
name|vp
parameter_list|)
name|VALUE
modifier|*
name|vp
decl_stmt|;
block|{
name|VALUE
name|result
decl_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|!=
name|V_STR
condition|)
name|math_error
argument_list|(
literal|"Non-string argument for strlen"
argument_list|)
expr_stmt|;
name|result
operator|.
name|v_type
operator|=
name|V_NUM
expr_stmt|;
name|result
operator|.
name|v_num
operator|=
name|itoq
argument_list|(
operator|(
name|long
operator|)
name|strlen
argument_list|(
name|vp
operator|->
name|v_str
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|VALUE
name|f_strcat
parameter_list|(
name|count
parameter_list|,
name|vals
parameter_list|)
name|int
name|count
decl_stmt|;
name|VALUE
modifier|*
modifier|*
name|vals
decl_stmt|;
block|{
specifier|register
name|VALUE
modifier|*
modifier|*
name|vp
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|long
name|len
decl_stmt|;
name|long
name|lengths
index|[
name|IN
index|]
decl_stmt|;
name|VALUE
name|result
decl_stmt|;
name|len
operator|=
literal|1
expr_stmt|;
name|vp
operator|=
name|vals
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|vp
operator|)
operator|->
name|v_type
operator|!=
name|V_STR
condition|)
name|math_error
argument_list|(
literal|"Non-string argument for strcat"
argument_list|)
expr_stmt|;
name|lengths
index|[
name|i
index|]
operator|=
name|strlen
argument_list|(
operator|(
operator|*
name|vp
operator|)
operator|->
name|v_str
argument_list|)
expr_stmt|;
name|len
operator|+=
name|lengths
index|[
name|i
index|]
expr_stmt|;
name|vp
operator|++
expr_stmt|;
block|}
name|cp
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
name|math_error
argument_list|(
literal|"No memory for strcat"
argument_list|)
expr_stmt|;
name|result
operator|.
name|v_str
operator|=
name|cp
expr_stmt|;
name|result
operator|.
name|v_type
operator|=
name|V_STR
expr_stmt|;
name|result
operator|.
name|v_subtype
operator|=
name|V_STRALLOC
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|vp
operator|=
name|vals
init|;
name|count
operator|--
operator|>
literal|0
condition|;
name|vp
operator|++
control|)
block|{
name|strcpy
argument_list|(
name|cp
argument_list|,
operator|(
operator|*
name|vp
operator|)
operator|->
name|v_str
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|lengths
index|[
name|i
operator|++
index|]
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|VALUE
name|f_substr
parameter_list|(
name|v1
parameter_list|,
name|v2
parameter_list|,
name|v3
parameter_list|)
name|VALUE
modifier|*
name|v1
decl_stmt|,
decl|*
name|v2
decl_stmt|,
modifier|*
name|v3
decl_stmt|;
end_function

begin_block
block|{
name|NUMBER
modifier|*
name|q1
decl_stmt|,
modifier|*
name|q2
decl_stmt|;
name|long
name|i1
decl_stmt|,
name|i2
decl_stmt|,
name|len
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|VALUE
name|result
decl_stmt|;
if|if
condition|(
name|v1
operator|->
name|v_type
operator|!=
name|V_STR
condition|)
name|math_error
argument_list|(
literal|"Non-string argument for substr"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|v2
operator|->
name|v_type
operator|!=
name|V_NUM
operator|)
operator|||
operator|(
name|v3
operator|->
name|v_type
operator|!=
name|V_NUM
operator|)
condition|)
name|math_error
argument_list|(
literal|"Non-numeric positions for substr"
argument_list|)
expr_stmt|;
name|q1
operator|=
name|v2
operator|->
name|v_num
expr_stmt|;
name|q2
operator|=
name|v3
operator|->
name|v_num
expr_stmt|;
if|if
condition|(
name|qisfrac
argument_list|(
name|q1
argument_list|)
operator|||
name|qisneg
argument_list|(
name|q1
argument_list|)
operator|||
name|qisfrac
argument_list|(
name|q2
argument_list|)
operator|||
name|qisneg
argument_list|(
name|q2
argument_list|)
condition|)
name|math_error
argument_list|(
literal|"Illegal positions for substr"
argument_list|)
expr_stmt|;
name|i1
operator|=
name|qtoi
argument_list|(
name|q1
argument_list|)
expr_stmt|;
name|i2
operator|=
name|qtoi
argument_list|(
name|q2
argument_list|)
expr_stmt|;
name|cp
operator|=
name|v1
operator|->
name|v_str
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|result
operator|.
name|v_type
operator|=
name|V_STR
expr_stmt|;
if|if
condition|(
name|i1
operator|>
literal|0
condition|)
name|i1
operator|--
expr_stmt|;
if|if
condition|(
name|i1
operator|>=
name|len
condition|)
block|{
comment|/* indexing off of end */
name|result
operator|.
name|v_subtype
operator|=
name|V_STRLITERAL
expr_stmt|;
name|result
operator|.
name|v_str
operator|=
literal|""
expr_stmt|;
return|return
name|result
return|;
block|}
name|cp
operator|+=
name|i1
expr_stmt|;
name|len
operator|-=
name|i1
expr_stmt|;
if|if
condition|(
operator|(
name|i2
operator|>=
name|len
operator|)
operator|&&
operator|(
name|v1
operator|->
name|v_subtype
operator|==
name|V_STRLITERAL
operator|)
condition|)
block|{
name|result
operator|.
name|v_subtype
operator|=
name|V_STRLITERAL
expr_stmt|;
name|result
operator|.
name|v_str
operator|=
name|cp
expr_stmt|;
return|return
name|result
return|;
block|}
if|if
condition|(
name|len
operator|>
name|i2
condition|)
name|len
operator|=
name|i2
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|1
condition|)
block|{
name|result
operator|.
name|v_subtype
operator|=
name|V_STRLITERAL
expr_stmt|;
name|result
operator|.
name|v_str
operator|=
name|charstr
argument_list|(
operator|*
name|cp
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
name|result
operator|.
name|v_subtype
operator|=
name|V_STRALLOC
expr_stmt|;
name|result
operator|.
name|v_str
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|.
name|v_str
operator|==
name|NULL
condition|)
name|math_error
argument_list|(
literal|"No memory for substr"
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|result
operator|.
name|v_str
argument_list|,
name|cp
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|result
operator|.
name|v_str
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|result
return|;
block|}
end_block

begin_function
specifier|static
name|VALUE
name|f_char
parameter_list|(
name|vp
parameter_list|)
name|VALUE
modifier|*
name|vp
decl_stmt|;
block|{
name|long
name|num
decl_stmt|;
name|NUMBER
modifier|*
name|q
decl_stmt|;
name|VALUE
name|result
decl_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|!=
name|V_NUM
condition|)
name|math_error
argument_list|(
literal|"Non-numeric argument for char"
argument_list|)
expr_stmt|;
name|q
operator|=
name|vp
operator|->
name|v_num
expr_stmt|;
name|num
operator|=
name|qtoi
argument_list|(
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
name|qisneg
argument_list|(
name|q
argument_list|)
operator|||
name|qisfrac
argument_list|(
name|q
argument_list|)
operator|||
name|zisbig
argument_list|(
name|q
operator|->
name|num
argument_list|)
operator|||
operator|(
name|num
operator|>
literal|255
operator|)
condition|)
name|math_error
argument_list|(
literal|"Illegal number for char"
argument_list|)
expr_stmt|;
name|result
operator|.
name|v_type
operator|=
name|V_STR
expr_stmt|;
name|result
operator|.
name|v_subtype
operator|=
name|V_STRLITERAL
expr_stmt|;
name|result
operator|.
name|v_str
operator|=
name|charstr
argument_list|(
operator|(
name|int
operator|)
name|num
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|VALUE
name|f_ord
parameter_list|(
name|vp
parameter_list|)
name|VALUE
modifier|*
name|vp
decl_stmt|;
block|{
name|char
modifier|*
name|str
decl_stmt|;
name|VALUE
name|result
decl_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|!=
name|V_STR
condition|)
name|math_error
argument_list|(
literal|"Non-string argument for ord"
argument_list|)
expr_stmt|;
name|str
operator|=
name|vp
operator|->
name|v_str
expr_stmt|;
if|if
condition|(
name|str
index|[
literal|0
index|]
operator|&&
name|str
index|[
literal|1
index|]
condition|)
name|math_error
argument_list|(
literal|"Multi-character string given for ord"
argument_list|)
expr_stmt|;
name|result
operator|.
name|v_type
operator|=
name|V_NUM
expr_stmt|;
name|result
operator|.
name|v_num
operator|=
name|itoq
argument_list|(
call|(
name|long
call|)
argument_list|(
operator|*
name|str
operator|&
literal|0xff
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|VALUE
name|f_size
parameter_list|(
name|vp
parameter_list|)
name|VALUE
modifier|*
name|vp
decl_stmt|;
block|{
name|long
name|count
decl_stmt|;
name|VALUE
name|result
decl_stmt|;
switch|switch
condition|(
name|vp
operator|->
name|v_type
condition|)
block|{
case|case
name|V_NULL
case|:
name|count
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|V_MAT
case|:
name|count
operator|=
name|vp
operator|->
name|v_mat
operator|->
name|m_size
expr_stmt|;
break|break;
case|case
name|V_LIST
case|:
name|count
operator|=
name|vp
operator|->
name|v_list
operator|->
name|l_count
expr_stmt|;
break|break;
case|case
name|V_ASSOC
case|:
name|count
operator|=
name|vp
operator|->
name|v_assoc
operator|->
name|a_count
expr_stmt|;
break|break;
case|case
name|V_OBJ
case|:
name|count
operator|=
name|vp
operator|->
name|v_obj
operator|->
name|o_actions
operator|->
name|count
expr_stmt|;
break|break;
default|default:
name|count
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|result
operator|.
name|v_type
operator|=
name|V_NUM
expr_stmt|;
name|result
operator|.
name|v_num
operator|=
name|itoq
argument_list|(
name|count
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|VALUE
name|f_search
parameter_list|(
name|count
parameter_list|,
name|vals
parameter_list|)
name|int
name|count
decl_stmt|;
name|VALUE
modifier|*
modifier|*
name|vals
decl_stmt|;
block|{
name|VALUE
modifier|*
name|v1
decl_stmt|,
modifier|*
name|v2
decl_stmt|;
name|NUMBER
modifier|*
name|q
decl_stmt|;
name|long
name|start
decl_stmt|;
name|long
name|index
init|=
operator|-
literal|1
decl_stmt|;
name|VALUE
name|result
decl_stmt|;
name|v1
operator|=
operator|*
name|vals
operator|++
expr_stmt|;
name|v2
operator|=
operator|*
name|vals
operator|++
expr_stmt|;
name|start
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|3
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|vals
operator|)
operator|->
name|v_type
operator|!=
name|V_NUM
condition|)
name|math_error
argument_list|(
literal|"Non-numeric start index for search"
argument_list|)
expr_stmt|;
name|q
operator|=
operator|(
operator|*
name|vals
operator|)
operator|->
name|v_num
expr_stmt|;
if|if
condition|(
name|qisfrac
argument_list|(
name|q
argument_list|)
operator|||
name|qisneg
argument_list|(
name|q
argument_list|)
condition|)
name|math_error
argument_list|(
literal|"Bad start index for search"
argument_list|)
expr_stmt|;
name|start
operator|=
name|qtoi
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|v1
operator|->
name|v_type
condition|)
block|{
case|case
name|V_MAT
case|:
name|index
operator|=
name|matsearch
argument_list|(
name|v1
operator|->
name|v_mat
argument_list|,
name|v2
argument_list|,
name|start
argument_list|)
expr_stmt|;
break|break;
case|case
name|V_LIST
case|:
name|index
operator|=
name|listsearch
argument_list|(
name|v1
operator|->
name|v_list
argument_list|,
name|v2
argument_list|,
name|start
argument_list|)
expr_stmt|;
break|break;
case|case
name|V_ASSOC
case|:
name|index
operator|=
name|assocsearch
argument_list|(
name|v1
operator|->
name|v_assoc
argument_list|,
name|v2
argument_list|,
name|start
argument_list|)
expr_stmt|;
break|break;
default|default:
name|math_error
argument_list|(
literal|"Bad argument type for search"
argument_list|)
expr_stmt|;
block|}
name|result
operator|.
name|v_type
operator|=
name|V_NULL
expr_stmt|;
if|if
condition|(
name|index
operator|>=
literal|0
condition|)
block|{
name|result
operator|.
name|v_type
operator|=
name|V_NUM
expr_stmt|;
name|result
operator|.
name|v_num
operator|=
name|itoq
argument_list|(
name|index
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|VALUE
name|f_rsearch
parameter_list|(
name|count
parameter_list|,
name|vals
parameter_list|)
name|int
name|count
decl_stmt|;
name|VALUE
modifier|*
modifier|*
name|vals
decl_stmt|;
block|{
name|VALUE
modifier|*
name|v1
decl_stmt|,
modifier|*
name|v2
decl_stmt|;
name|NUMBER
modifier|*
name|q
decl_stmt|;
name|long
name|start
decl_stmt|;
name|long
name|index
init|=
operator|-
literal|1
decl_stmt|;
name|VALUE
name|result
decl_stmt|;
name|v1
operator|=
operator|*
name|vals
operator|++
expr_stmt|;
name|v2
operator|=
operator|*
name|vals
operator|++
expr_stmt|;
name|start
operator|=
name|MAXFULL
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|3
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|vals
operator|)
operator|->
name|v_type
operator|!=
name|V_NUM
condition|)
name|math_error
argument_list|(
literal|"Non-numeric start index for rsearch"
argument_list|)
expr_stmt|;
name|q
operator|=
operator|(
operator|*
name|vals
operator|)
operator|->
name|v_num
expr_stmt|;
if|if
condition|(
name|qisfrac
argument_list|(
name|q
argument_list|)
operator|||
name|qisneg
argument_list|(
name|q
argument_list|)
condition|)
name|math_error
argument_list|(
literal|"Bad start index for rsearch"
argument_list|)
expr_stmt|;
name|start
operator|=
name|qtoi
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|v1
operator|->
name|v_type
condition|)
block|{
case|case
name|V_MAT
case|:
name|index
operator|=
name|matrsearch
argument_list|(
name|v1
operator|->
name|v_mat
argument_list|,
name|v2
argument_list|,
name|start
argument_list|)
expr_stmt|;
break|break;
case|case
name|V_LIST
case|:
name|index
operator|=
name|listrsearch
argument_list|(
name|v1
operator|->
name|v_list
argument_list|,
name|v2
argument_list|,
name|start
argument_list|)
expr_stmt|;
break|break;
case|case
name|V_ASSOC
case|:
name|index
operator|=
name|assocrsearch
argument_list|(
name|v1
operator|->
name|v_assoc
argument_list|,
name|v2
argument_list|,
name|start
argument_list|)
expr_stmt|;
break|break;
default|default:
name|math_error
argument_list|(
literal|"Bad argument type for rsearch"
argument_list|)
expr_stmt|;
block|}
name|result
operator|.
name|v_type
operator|=
name|V_NULL
expr_stmt|;
if|if
condition|(
name|index
operator|>=
literal|0
condition|)
block|{
name|result
operator|.
name|v_type
operator|=
name|V_NUM
expr_stmt|;
name|result
operator|.
name|v_num
operator|=
name|itoq
argument_list|(
name|index
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|VALUE
name|f_list
parameter_list|(
name|count
parameter_list|,
name|vals
parameter_list|)
name|int
name|count
decl_stmt|;
name|VALUE
modifier|*
modifier|*
name|vals
decl_stmt|;
block|{
name|VALUE
name|result
decl_stmt|;
name|result
operator|.
name|v_type
operator|=
name|V_LIST
expr_stmt|;
name|result
operator|.
name|v_list
operator|=
name|listalloc
argument_list|()
expr_stmt|;
while|while
condition|(
name|count
operator|--
operator|>
literal|0
condition|)
name|insertlistlast
argument_list|(
name|result
operator|.
name|v_list
argument_list|,
operator|*
name|vals
operator|++
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|VALUE
name|f_assoc
parameter_list|(
name|count
parameter_list|,
name|vals
parameter_list|)
name|int
name|count
decl_stmt|;
name|VALUE
modifier|*
modifier|*
name|vals
decl_stmt|;
block|{
name|VALUE
name|result
decl_stmt|;
name|result
operator|.
name|v_type
operator|=
name|V_ASSOC
expr_stmt|;
name|result
operator|.
name|v_assoc
operator|=
name|assocalloc
argument_list|(
literal|0L
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|VALUE
name|f_listinsert
parameter_list|(
name|v1
parameter_list|,
name|v2
parameter_list|,
name|v3
parameter_list|)
name|VALUE
modifier|*
name|v1
decl_stmt|,
decl|*
name|v2
decl_stmt|,
modifier|*
name|v3
decl_stmt|;
end_function

begin_block
block|{
name|VALUE
name|result
decl_stmt|;
if|if
condition|(
operator|(
name|v1
operator|->
name|v_type
operator|!=
name|V_ADDR
operator|)
operator|||
operator|(
name|v1
operator|->
name|v_addr
operator|->
name|v_type
operator|!=
name|V_LIST
operator|)
condition|)
name|math_error
argument_list|(
literal|"Inserting into non-list variable"
argument_list|)
expr_stmt|;
if|if
condition|(
name|v2
operator|->
name|v_type
operator|==
name|V_ADDR
condition|)
name|v2
operator|=
name|v2
operator|->
name|v_addr
expr_stmt|;
if|if
condition|(
operator|(
name|v2
operator|->
name|v_type
operator|!=
name|V_NUM
operator|)
operator|||
name|qisfrac
argument_list|(
name|v2
operator|->
name|v_num
argument_list|)
condition|)
name|math_error
argument_list|(
literal|"Non-integral index for list insert"
argument_list|)
expr_stmt|;
if|if
condition|(
name|v3
operator|->
name|v_type
operator|==
name|V_ADDR
condition|)
name|v3
operator|=
name|v3
operator|->
name|v_addr
expr_stmt|;
name|insertlistmiddle
argument_list|(
name|v1
operator|->
name|v_addr
operator|->
name|v_list
argument_list|,
name|qtoi
argument_list|(
name|v2
operator|->
name|v_num
argument_list|)
argument_list|,
name|v3
argument_list|)
expr_stmt|;
name|result
operator|.
name|v_type
operator|=
name|V_NULL
expr_stmt|;
return|return
name|result
return|;
block|}
end_block

begin_function
specifier|static
name|VALUE
name|f_listpush
parameter_list|(
name|v1
parameter_list|,
name|v2
parameter_list|)
name|VALUE
modifier|*
name|v1
decl_stmt|,
decl|*
name|v2
decl_stmt|;
end_function

begin_block
block|{
name|VALUE
name|result
decl_stmt|;
if|if
condition|(
operator|(
name|v1
operator|->
name|v_type
operator|!=
name|V_ADDR
operator|)
operator|||
operator|(
name|v1
operator|->
name|v_addr
operator|->
name|v_type
operator|!=
name|V_LIST
operator|)
condition|)
name|math_error
argument_list|(
literal|"Pushing onto non-list variable"
argument_list|)
expr_stmt|;
if|if
condition|(
name|v2
operator|->
name|v_type
operator|==
name|V_ADDR
condition|)
name|v2
operator|=
name|v2
operator|->
name|v_addr
expr_stmt|;
name|insertlistfirst
argument_list|(
name|v1
operator|->
name|v_addr
operator|->
name|v_list
argument_list|,
name|v2
argument_list|)
expr_stmt|;
name|result
operator|.
name|v_type
operator|=
name|V_NULL
expr_stmt|;
return|return
name|result
return|;
block|}
end_block

begin_function
specifier|static
name|VALUE
name|f_listappend
parameter_list|(
name|v1
parameter_list|,
name|v2
parameter_list|)
name|VALUE
modifier|*
name|v1
decl_stmt|,
decl|*
name|v2
decl_stmt|;
end_function

begin_block
block|{
name|VALUE
name|result
decl_stmt|;
if|if
condition|(
operator|(
name|v1
operator|->
name|v_type
operator|!=
name|V_ADDR
operator|)
operator|||
operator|(
name|v1
operator|->
name|v_addr
operator|->
name|v_type
operator|!=
name|V_LIST
operator|)
condition|)
name|math_error
argument_list|(
literal|"Appending to non-list variable"
argument_list|)
expr_stmt|;
if|if
condition|(
name|v2
operator|->
name|v_type
operator|==
name|V_ADDR
condition|)
name|v2
operator|=
name|v2
operator|->
name|v_addr
expr_stmt|;
name|insertlistlast
argument_list|(
name|v1
operator|->
name|v_addr
operator|->
name|v_list
argument_list|,
name|v2
argument_list|)
expr_stmt|;
name|result
operator|.
name|v_type
operator|=
name|V_NULL
expr_stmt|;
return|return
name|result
return|;
block|}
end_block

begin_function
specifier|static
name|VALUE
name|f_listdelete
parameter_list|(
name|v1
parameter_list|,
name|v2
parameter_list|)
name|VALUE
modifier|*
name|v1
decl_stmt|,
decl|*
name|v2
decl_stmt|;
end_function

begin_block
block|{
name|VALUE
name|result
decl_stmt|;
if|if
condition|(
operator|(
name|v1
operator|->
name|v_type
operator|!=
name|V_ADDR
operator|)
operator|||
operator|(
name|v1
operator|->
name|v_addr
operator|->
name|v_type
operator|!=
name|V_LIST
operator|)
condition|)
name|math_error
argument_list|(
literal|"Deleting from non-list variable"
argument_list|)
expr_stmt|;
if|if
condition|(
name|v2
operator|->
name|v_type
operator|==
name|V_ADDR
condition|)
name|v2
operator|=
name|v2
operator|->
name|v_addr
expr_stmt|;
if|if
condition|(
operator|(
name|v2
operator|->
name|v_type
operator|!=
name|V_NUM
operator|)
operator|||
name|qisfrac
argument_list|(
name|v2
operator|->
name|v_num
argument_list|)
condition|)
name|math_error
argument_list|(
literal|"Non-integral index for list delete"
argument_list|)
expr_stmt|;
name|removelistmiddle
argument_list|(
name|v1
operator|->
name|v_addr
operator|->
name|v_list
argument_list|,
name|qtoi
argument_list|(
name|v2
operator|->
name|v_num
argument_list|)
argument_list|,
operator|&
name|result
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_block

begin_function
specifier|static
name|VALUE
name|f_listpop
parameter_list|(
name|vp
parameter_list|)
name|VALUE
modifier|*
name|vp
decl_stmt|;
block|{
name|VALUE
name|result
decl_stmt|;
if|if
condition|(
operator|(
name|vp
operator|->
name|v_type
operator|!=
name|V_ADDR
operator|)
operator|||
operator|(
name|vp
operator|->
name|v_addr
operator|->
name|v_type
operator|!=
name|V_LIST
operator|)
condition|)
name|math_error
argument_list|(
literal|"Popping from non-list variable"
argument_list|)
expr_stmt|;
name|removelistfirst
argument_list|(
name|vp
operator|->
name|v_addr
operator|->
name|v_list
argument_list|,
operator|&
name|result
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|VALUE
name|f_listremove
parameter_list|(
name|vp
parameter_list|)
name|VALUE
modifier|*
name|vp
decl_stmt|;
block|{
name|VALUE
name|result
decl_stmt|;
if|if
condition|(
operator|(
name|vp
operator|->
name|v_type
operator|!=
name|V_ADDR
operator|)
operator|||
operator|(
name|vp
operator|->
name|v_addr
operator|->
name|v_type
operator|!=
name|V_LIST
operator|)
condition|)
name|math_error
argument_list|(
literal|"Removing from non-list variable"
argument_list|)
expr_stmt|;
name|removelistlast
argument_list|(
name|vp
operator|->
name|v_addr
operator|->
name|v_list
argument_list|,
operator|&
name|result
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/*  * Return the current runtime of calc in seconds.  * This is the user mode time only.  */
end_comment

begin_function
specifier|static
name|NUMBER
modifier|*
name|f_runtime
parameter_list|()
block|{
name|struct
name|tms
name|buf
decl_stmt|;
name|times
argument_list|(
operator|&
name|buf
argument_list|)
expr_stmt|;
return|return
name|iitoq
argument_list|(
operator|(
name|long
operator|)
name|buf
operator|.
name|tms_utime
argument_list|,
operator|(
name|long
operator|)
name|CLK_TCK
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|VALUE
name|f_fopen
parameter_list|(
name|v1
parameter_list|,
name|v2
parameter_list|)
name|VALUE
modifier|*
name|v1
decl_stmt|,
decl|*
name|v2
decl_stmt|;
end_function

begin_block
block|{
name|VALUE
name|result
decl_stmt|;
name|FILEID
name|id
decl_stmt|;
if|if
condition|(
name|v1
operator|->
name|v_type
operator|!=
name|V_STR
condition|)
name|math_error
argument_list|(
literal|"Non-string filename for fopen"
argument_list|)
expr_stmt|;
if|if
condition|(
name|v2
operator|->
name|v_type
operator|!=
name|V_STR
condition|)
name|math_error
argument_list|(
literal|"Non-string mode for fopen"
argument_list|)
expr_stmt|;
name|id
operator|=
name|openid
argument_list|(
name|v1
operator|->
name|v_str
argument_list|,
name|v2
operator|->
name|v_str
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
operator|==
name|FILEID_NONE
condition|)
block|{
name|result
operator|.
name|v_type
operator|=
name|V_NUM
expr_stmt|;
name|result
operator|.
name|v_num
operator|=
name|itoq
argument_list|(
operator|(
name|long
operator|)
name|errno
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|result
operator|.
name|v_type
operator|=
name|V_FILE
expr_stmt|;
name|result
operator|.
name|v_file
operator|=
name|id
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_block

begin_function
specifier|static
name|VALUE
name|f_fclose
parameter_list|(
name|vp
parameter_list|)
name|VALUE
modifier|*
name|vp
decl_stmt|;
block|{
name|VALUE
name|result
decl_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|!=
name|V_FILE
condition|)
name|math_error
argument_list|(
literal|"Non-file for fclose"
argument_list|)
expr_stmt|;
if|if
condition|(
name|closeid
argument_list|(
name|vp
operator|->
name|v_file
argument_list|)
condition|)
block|{
name|result
operator|.
name|v_type
operator|=
name|V_NUM
expr_stmt|;
name|result
operator|.
name|v_num
operator|=
name|itoq
argument_list|(
operator|(
name|long
operator|)
name|errno
argument_list|)
expr_stmt|;
block|}
else|else
name|result
operator|.
name|v_type
operator|=
name|V_NULL
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|VALUE
name|f_ferror
parameter_list|(
name|vp
parameter_list|)
name|VALUE
modifier|*
name|vp
decl_stmt|;
block|{
name|VALUE
name|result
decl_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|!=
name|V_FILE
condition|)
name|math_error
argument_list|(
literal|"Non-file for ferror"
argument_list|)
expr_stmt|;
name|result
operator|.
name|v_type
operator|=
name|V_NUM
expr_stmt|;
name|result
operator|.
name|v_num
operator|=
name|itoq
argument_list|(
operator|(
name|long
operator|)
name|errorid
argument_list|(
name|vp
operator|->
name|v_file
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|VALUE
name|f_feof
parameter_list|(
name|vp
parameter_list|)
name|VALUE
modifier|*
name|vp
decl_stmt|;
block|{
name|VALUE
name|result
decl_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|!=
name|V_FILE
condition|)
name|math_error
argument_list|(
literal|"Non-file for feof"
argument_list|)
expr_stmt|;
name|result
operator|.
name|v_type
operator|=
name|V_NUM
expr_stmt|;
name|result
operator|.
name|v_num
operator|=
name|itoq
argument_list|(
operator|(
name|long
operator|)
name|eofid
argument_list|(
name|vp
operator|->
name|v_file
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|VALUE
name|f_fflush
parameter_list|(
name|vp
parameter_list|)
name|VALUE
modifier|*
name|vp
decl_stmt|;
block|{
name|VALUE
name|result
decl_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|!=
name|V_FILE
condition|)
name|math_error
argument_list|(
literal|"Non-file for fflush"
argument_list|)
expr_stmt|;
name|flushid
argument_list|(
name|vp
operator|->
name|v_file
argument_list|)
expr_stmt|;
name|result
operator|.
name|v_type
operator|=
name|V_NULL
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|VALUE
name|f_fprintf
parameter_list|(
name|count
parameter_list|,
name|vals
parameter_list|)
name|int
name|count
decl_stmt|;
name|VALUE
modifier|*
modifier|*
name|vals
decl_stmt|;
block|{
name|VALUE
name|result
decl_stmt|;
if|if
condition|(
name|vals
index|[
literal|0
index|]
operator|->
name|v_type
operator|!=
name|V_FILE
condition|)
name|math_error
argument_list|(
literal|"Non-file for fprintf"
argument_list|)
expr_stmt|;
if|if
condition|(
name|vals
index|[
literal|1
index|]
operator|->
name|v_type
operator|!=
name|V_STR
condition|)
name|math_error
argument_list|(
literal|"Non-string format for fprintf"
argument_list|)
expr_stmt|;
name|idprintf
argument_list|(
name|vals
index|[
literal|0
index|]
operator|->
name|v_file
argument_list|,
name|vals
index|[
literal|1
index|]
operator|->
name|v_str
argument_list|,
name|count
operator|-
literal|2
argument_list|,
name|vals
operator|+
literal|2
argument_list|)
expr_stmt|;
name|result
operator|.
name|v_type
operator|=
name|V_NULL
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|VALUE
name|f_printf
parameter_list|(
name|count
parameter_list|,
name|vals
parameter_list|)
name|int
name|count
decl_stmt|;
name|VALUE
modifier|*
modifier|*
name|vals
decl_stmt|;
block|{
name|VALUE
name|result
decl_stmt|;
if|if
condition|(
name|vals
index|[
literal|0
index|]
operator|->
name|v_type
operator|!=
name|V_STR
condition|)
name|math_error
argument_list|(
literal|"Non-string format for printf"
argument_list|)
expr_stmt|;
name|idprintf
argument_list|(
name|FILEID_STDOUT
argument_list|,
name|vals
index|[
literal|0
index|]
operator|->
name|v_str
argument_list|,
name|count
operator|-
literal|1
argument_list|,
name|vals
operator|+
literal|1
argument_list|)
expr_stmt|;
name|result
operator|.
name|v_type
operator|=
name|V_NULL
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|VALUE
name|f_strprintf
parameter_list|(
name|count
parameter_list|,
name|vals
parameter_list|)
name|int
name|count
decl_stmt|;
name|VALUE
modifier|*
modifier|*
name|vals
decl_stmt|;
block|{
name|VALUE
name|result
decl_stmt|;
if|if
condition|(
name|vals
index|[
literal|0
index|]
operator|->
name|v_type
operator|!=
name|V_STR
condition|)
name|math_error
argument_list|(
literal|"Non-string format for strprintf"
argument_list|)
expr_stmt|;
name|math_divertio
argument_list|()
expr_stmt|;
name|idprintf
argument_list|(
name|FILEID_STDOUT
argument_list|,
name|vals
index|[
literal|0
index|]
operator|->
name|v_str
argument_list|,
name|count
operator|-
literal|1
argument_list|,
name|vals
operator|+
literal|1
argument_list|)
expr_stmt|;
name|result
operator|.
name|v_str
operator|=
name|math_getdivertedio
argument_list|()
expr_stmt|;
name|result
operator|.
name|v_type
operator|=
name|V_STR
expr_stmt|;
name|result
operator|.
name|v_subtype
operator|=
name|V_STRALLOC
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|VALUE
name|f_fgetc
parameter_list|(
name|vp
parameter_list|)
name|VALUE
modifier|*
name|vp
decl_stmt|;
block|{
name|VALUE
name|result
decl_stmt|;
name|int
name|ch
decl_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|!=
name|V_FILE
condition|)
name|math_error
argument_list|(
literal|"Non-file for fgetc"
argument_list|)
expr_stmt|;
name|ch
operator|=
name|getcharid
argument_list|(
name|vp
operator|->
name|v_file
argument_list|)
expr_stmt|;
name|result
operator|.
name|v_type
operator|=
name|V_NULL
expr_stmt|;
if|if
condition|(
name|ch
operator|!=
name|EOF
condition|)
block|{
name|result
operator|.
name|v_type
operator|=
name|V_STR
expr_stmt|;
name|result
operator|.
name|v_subtype
operator|=
name|V_STRLITERAL
expr_stmt|;
name|result
operator|.
name|v_str
operator|=
name|charstr
argument_list|(
name|ch
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|VALUE
name|f_fgetline
parameter_list|(
name|vp
parameter_list|)
name|VALUE
modifier|*
name|vp
decl_stmt|;
block|{
name|VALUE
name|result
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|!=
name|V_FILE
condition|)
name|math_error
argument_list|(
literal|"Non-file for fgetline"
argument_list|)
expr_stmt|;
name|readid
argument_list|(
name|vp
operator|->
name|v_file
argument_list|,
operator|&
name|str
argument_list|)
expr_stmt|;
name|result
operator|.
name|v_type
operator|=
name|V_NULL
expr_stmt|;
if|if
condition|(
name|str
condition|)
block|{
name|result
operator|.
name|v_type
operator|=
name|V_STR
expr_stmt|;
name|result
operator|.
name|v_subtype
operator|=
name|V_STRALLOC
expr_stmt|;
name|result
operator|.
name|v_str
operator|=
name|str
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|VALUE
name|f_files
parameter_list|(
name|count
parameter_list|,
name|vals
parameter_list|)
name|int
name|count
decl_stmt|;
name|VALUE
modifier|*
modifier|*
name|vals
decl_stmt|;
block|{
name|VALUE
name|result
decl_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
block|{
name|result
operator|.
name|v_type
operator|=
name|V_NUM
expr_stmt|;
name|result
operator|.
name|v_num
operator|=
name|itoq
argument_list|(
operator|(
name|long
operator|)
name|MAXFILES
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
if|if
condition|(
operator|(
name|vals
index|[
literal|0
index|]
operator|->
name|v_type
operator|!=
name|V_NUM
operator|)
operator|||
name|qisfrac
argument_list|(
name|vals
index|[
literal|0
index|]
operator|->
name|v_num
argument_list|)
condition|)
name|math_error
argument_list|(
literal|"Non-integer for files"
argument_list|)
expr_stmt|;
name|result
operator|.
name|v_type
operator|=
name|V_NULL
expr_stmt|;
name|result
operator|.
name|v_file
operator|=
name|indexid
argument_list|(
name|qtoi
argument_list|(
name|vals
index|[
literal|0
index|]
operator|->
name|v_num
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|.
name|v_file
operator|!=
name|FILEID_NONE
condition|)
name|result
operator|.
name|v_type
operator|=
name|V_FILE
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/*  * return a numerical 'value' of the mode/base  */
end_comment

begin_function
specifier|static
name|NUMBER
modifier|*
name|base_value
parameter_list|(
name|mode
parameter_list|)
name|long
name|mode
decl_stmt|;
comment|/* a MODE_XYZ value */
block|{
name|NUMBER
modifier|*
name|result
decl_stmt|;
comment|/* return the old base */
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|MODE_DEFAULT
case|:
if|if
condition|(
name|_outmode_
operator|==
name|MODE_DEFAULT
condition|)
block|{
name|result
operator|=
name|itoq
argument_list|(
literal|10
argument_list|)
expr_stmt|;
comment|/* firewall */
block|}
else|else
block|{
name|result
operator|=
name|base_value
argument_list|(
name|_outmode_
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|MODE_FRAC
case|:
name|result
operator|=
name|qalloc
argument_list|()
expr_stmt|;
name|itoz
argument_list|(
literal|3
argument_list|,
operator|&
name|result
operator|->
name|den
argument_list|)
expr_stmt|;
break|break;
case|case
name|MODE_INT
case|:
name|result
operator|=
name|itoq
argument_list|(
operator|-
literal|10
argument_list|)
expr_stmt|;
break|break;
case|case
name|MODE_REAL
case|:
name|result
operator|=
name|itoq
argument_list|(
literal|10
argument_list|)
expr_stmt|;
break|break;
case|case
name|MODE_EXP
case|:
name|result
operator|=
name|qalloc
argument_list|()
expr_stmt|;
name|ztenpow
argument_list|(
literal|20
argument_list|,
operator|&
name|result
operator|->
name|num
argument_list|)
expr_stmt|;
break|break;
case|case
name|MODE_HEX
case|:
name|result
operator|=
name|itoq
argument_list|(
literal|16
argument_list|)
expr_stmt|;
break|break;
case|case
name|MODE_OCTAL
case|:
name|result
operator|=
name|itoq
argument_list|(
literal|8
argument_list|)
expr_stmt|;
break|break;
case|case
name|MODE_BINARY
case|:
name|result
operator|=
name|itoq
argument_list|(
literal|2
argument_list|)
expr_stmt|;
break|break;
default|default:
name|result
operator|=
name|itoq
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/*  * set the default output base/mode  */
end_comment

begin_function
specifier|static
name|NUMBER
modifier|*
name|f_base
parameter_list|(
name|count
parameter_list|,
name|vals
parameter_list|)
name|int
name|count
decl_stmt|;
name|NUMBER
modifier|*
modifier|*
name|vals
decl_stmt|;
block|{
name|long
name|base
decl_stmt|;
comment|/* output base/mode */
name|long
name|oldbase
init|=
literal|0
decl_stmt|;
comment|/* output base/mode */
comment|/* deal with just a query */
if|if
condition|(
name|count
operator|!=
literal|1
condition|)
block|{
return|return
name|base_value
argument_list|(
name|_outmode_
argument_list|)
return|;
block|}
comment|/* deal with the specal modes first */
if|if
condition|(
name|qisfrac
argument_list|(
name|vals
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
return|return
name|base_value
argument_list|(
name|math_setmode
argument_list|(
name|MODE_FRAC
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|vals
index|[
literal|0
index|]
operator|->
name|num
operator|.
name|len
operator|>
literal|64
operator|/
name|BASEB
condition|)
block|{
return|return
name|base_value
argument_list|(
name|math_setmode
argument_list|(
name|MODE_EXP
argument_list|)
argument_list|)
return|;
block|}
comment|/* set the base, if possible */
name|base
operator|=
name|qtoi
argument_list|(
name|vals
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|base
condition|)
block|{
case|case
operator|-
literal|10
case|:
name|oldbase
operator|=
name|math_setmode
argument_list|(
name|MODE_INT
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|oldbase
operator|=
name|math_setmode
argument_list|(
name|MODE_BINARY
argument_list|)
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|oldbase
operator|=
name|math_setmode
argument_list|(
name|MODE_OCTAL
argument_list|)
expr_stmt|;
break|break;
case|case
literal|10
case|:
name|oldbase
operator|=
name|math_setmode
argument_list|(
name|MODE_REAL
argument_list|)
expr_stmt|;
break|break;
case|case
literal|16
case|:
name|oldbase
operator|=
name|math_setmode
argument_list|(
name|MODE_HEX
argument_list|)
expr_stmt|;
break|break;
default|default:
name|math_error
argument_list|(
literal|"Unsupported base"
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* return the old base */
return|return
name|base_value
argument_list|(
name|oldbase
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Show the list of primitive built-in functions  */
end_comment

begin_function
name|void
name|showbuiltins
parameter_list|()
block|{
specifier|register
name|struct
name|builtin
modifier|*
name|bp
decl_stmt|;
comment|/* current function */
name|printf
argument_list|(
literal|"\nName\tArgs\tDescription\n\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|bp
operator|=
name|builtins
init|;
name|bp
operator|->
name|b_name
condition|;
name|bp
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"%-9s "
argument_list|,
name|bp
operator|->
name|b_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_maxargs
operator|==
name|IN
condition|)
name|printf
argument_list|(
literal|"%d+    "
argument_list|,
name|bp
operator|->
name|b_minargs
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|bp
operator|->
name|b_minargs
operator|==
name|bp
operator|->
name|b_maxargs
condition|)
name|printf
argument_list|(
literal|"%-6d"
argument_list|,
name|bp
operator|->
name|b_minargs
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%d-%-4d"
argument_list|,
name|bp
operator|->
name|b_minargs
argument_list|,
name|bp
operator|->
name|b_maxargs
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %s\n"
argument_list|,
name|bp
operator|->
name|b_desc
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Return the index of a built-in function given its name.  * Returns minus one if the name is not known.  */
end_comment

begin_function
name|int
name|getbuiltinfunc
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|struct
name|builtin
modifier|*
name|bp
decl_stmt|;
for|for
control|(
name|bp
operator|=
name|builtins
init|;
name|bp
operator|->
name|b_name
condition|;
name|bp
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|name
operator|==
operator|*
name|bp
operator|->
name|b_name
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|bp
operator|->
name|b_name
argument_list|)
operator|==
literal|0
operator|)
condition|)
return|return
operator|(
name|bp
operator|-
name|builtins
operator|)
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Given the index of a built-in function, return its name.  */
end_comment

begin_function
name|char
modifier|*
name|builtinname
parameter_list|(
name|index
parameter_list|)
name|long
name|index
decl_stmt|;
block|{
if|if
condition|(
operator|(
name|unsigned
name|long
operator|)
name|index
operator|>=
operator|(
sizeof|sizeof
argument_list|(
name|builtins
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|builtins
index|[
literal|0
index|]
argument_list|)
operator|)
operator|-
literal|1
condition|)
return|return
literal|""
return|;
return|return
name|builtins
index|[
name|index
index|]
operator|.
name|b_name
return|;
block|}
end_function

begin_comment
comment|/*  * Given the index of a built-in function, and the number of arguments seen,  * determine if the number of arguments are legal.  This routine is called  * during parsing time.  */
end_comment

begin_function
name|void
name|builtincheck
parameter_list|(
name|index
parameter_list|,
name|count
parameter_list|)
name|int
name|count
decl_stmt|;
name|long
name|index
decl_stmt|;
block|{
specifier|register
name|struct
name|builtin
modifier|*
name|bp
decl_stmt|;
if|if
condition|(
operator|(
name|unsigned
name|long
operator|)
name|index
operator|>=
operator|(
sizeof|sizeof
argument_list|(
name|builtins
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|builtins
index|[
literal|0
index|]
argument_list|)
operator|)
operator|-
literal|1
condition|)
name|math_error
argument_list|(
literal|"Unknown built in index"
argument_list|)
expr_stmt|;
name|bp
operator|=
operator|&
name|builtins
index|[
name|index
index|]
expr_stmt|;
if|if
condition|(
name|count
operator|<
name|bp
operator|->
name|b_minargs
condition|)
name|scanerror
argument_list|(
name|T_NULL
argument_list|,
literal|"Too few arguments for builtin function \"%s\""
argument_list|,
name|bp
operator|->
name|b_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|>
name|bp
operator|->
name|b_maxargs
condition|)
name|scanerror
argument_list|(
name|T_NULL
argument_list|,
literal|"Too many arguments for builtin function \"%s\""
argument_list|,
name|bp
operator|->
name|b_name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Return the opcode for a built-in function that can be used to avoid  * the function call at all.  */
end_comment

begin_function
name|int
name|builtinopcode
parameter_list|(
name|index
parameter_list|)
name|long
name|index
decl_stmt|;
block|{
if|if
condition|(
operator|(
name|unsigned
name|long
operator|)
name|index
operator|>=
operator|(
sizeof|sizeof
argument_list|(
name|builtins
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|builtins
index|[
literal|0
index|]
argument_list|)
operator|)
operator|-
literal|1
condition|)
return|return
name|OP_NOP
return|;
return|return
name|builtins
index|[
name|index
index|]
operator|.
name|b_opcode
return|;
block|}
end_function

begin_comment
comment|/* END CODE */
end_comment

end_unit

