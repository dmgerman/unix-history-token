begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1994 David I. Bell  * Permission is granted to use, distribute, or modify this source,  * provided that this copyright notice remains intact.  *  * Opcode execution module  */
end_comment

begin_include
include|#
directive|include
file|"stdarg.h"
end_include

begin_include
include|#
directive|include
file|"calc.h"
end_include

begin_include
include|#
directive|include
file|"opcodes.h"
end_include

begin_include
include|#
directive|include
file|"func.h"
end_include

begin_include
include|#
directive|include
file|"symbol.h"
end_include

begin_include
include|#
directive|include
file|"hist.h"
end_include

begin_define
define|#
directive|define
name|QUICKLOCALS
value|20
end_define

begin_comment
comment|/* local vars to handle quickly */
end_comment

begin_decl_stmt
name|VALUE
modifier|*
name|stack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current location of top of stack */
end_comment

begin_decl_stmt
specifier|static
name|VALUE
name|stackarray
index|[
name|MAXSTACK
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* storage for stack */
end_comment

begin_decl_stmt
specifier|static
name|VALUE
name|oldvalue
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* previous calculation value */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|funcname
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* function being executed */
end_comment

begin_decl_stmt
specifier|static
name|long
name|funcline
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* function line being executed */
end_comment

begin_decl_stmt
name|FLAG
name|traceflags
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current trace flags */
end_comment

begin_decl_stmt
name|int
name|tab_ok
init|=
name|TRUE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* FALSE => don't print lading tabs */
end_comment

begin_comment
comment|/*  * Routine definitions  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|o_nop
argument_list|()
decl_stmt|,
name|o_localaddr
argument_list|()
decl_stmt|,
name|o_globaladdr
argument_list|()
decl_stmt|,
name|o_paramaddr
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|o_globalvalue
argument_list|()
decl_stmt|,
name|o_paramvalue
argument_list|()
decl_stmt|,
name|o_number
argument_list|()
decl_stmt|,
name|o_indexaddr
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|o_assign
argument_list|()
decl_stmt|,
name|o_add
argument_list|()
decl_stmt|,
name|o_sub
argument_list|()
decl_stmt|,
name|o_mul
argument_list|()
decl_stmt|,
name|o_div
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|o_mod
argument_list|()
decl_stmt|,
name|o_save
argument_list|()
decl_stmt|,
name|o_negate
argument_list|()
decl_stmt|,
name|o_invert
argument_list|()
decl_stmt|,
name|o_int
argument_list|()
decl_stmt|,
name|o_frac
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|o_numerator
argument_list|()
decl_stmt|,
name|o_denominator
argument_list|()
decl_stmt|,
name|o_duplicate
argument_list|()
decl_stmt|,
name|o_pop
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|o_jumpeq
argument_list|()
decl_stmt|,
name|o_jumpne
argument_list|()
decl_stmt|,
name|o_jump
argument_list|()
decl_stmt|,
name|o_usercall
argument_list|()
decl_stmt|,
name|o_getvalue
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|o_eq
argument_list|()
decl_stmt|,
name|o_ne
argument_list|()
decl_stmt|,
name|o_le
argument_list|()
decl_stmt|,
name|o_ge
argument_list|()
decl_stmt|,
name|o_lt
argument_list|()
decl_stmt|,
name|o_gt
argument_list|()
decl_stmt|,
name|o_preinc
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|o_postinc
argument_list|()
decl_stmt|,
name|o_postdec
argument_list|()
decl_stmt|,
name|o_debug
argument_list|()
decl_stmt|,
name|o_print
argument_list|()
decl_stmt|,
name|o_assignpop
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|o_zero
argument_list|()
decl_stmt|,
name|o_one
argument_list|()
decl_stmt|,
name|o_printeol
argument_list|()
decl_stmt|,
name|o_printspace
argument_list|()
decl_stmt|,
name|o_printstring
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|o_oldvalue
argument_list|()
decl_stmt|,
name|o_quo
argument_list|()
decl_stmt|,
name|o_power
argument_list|()
decl_stmt|,
name|o_quit
argument_list|()
decl_stmt|,
name|o_call
argument_list|()
decl_stmt|,
name|o_swap
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|o_dupvalue
argument_list|()
decl_stmt|,
name|o_getepsilon
argument_list|()
decl_stmt|,
name|o_and
argument_list|()
decl_stmt|,
name|o_or
argument_list|()
decl_stmt|,
name|o_not
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|o_abs
argument_list|()
decl_stmt|,
name|o_sgn
argument_list|()
decl_stmt|,
name|o_isint
argument_list|()
decl_stmt|,
name|o_condorjump
argument_list|()
decl_stmt|,
name|o_condandjump
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|o_square
argument_list|()
decl_stmt|,
name|o_string
argument_list|()
decl_stmt|,
name|o_isnum
argument_list|()
decl_stmt|,
name|o_undef
argument_list|()
decl_stmt|,
name|o_isnull
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|o_matcreate
argument_list|()
decl_stmt|,
name|o_ismat
argument_list|()
decl_stmt|,
name|o_isstr
argument_list|()
decl_stmt|,
name|o_getconfig
argument_list|()
decl_stmt|,
name|o_predec
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|o_leftshift
argument_list|()
decl_stmt|,
name|o_rightshift
argument_list|()
decl_stmt|,
name|o_casejump
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|o_isodd
argument_list|()
decl_stmt|,
name|o_iseven
argument_list|()
decl_stmt|,
name|o_fiaddr
argument_list|()
decl_stmt|,
name|o_fivalue
argument_list|()
decl_stmt|,
name|o_argvalue
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|o_isreal
argument_list|()
decl_stmt|,
name|o_imaginary
argument_list|()
decl_stmt|,
name|o_re
argument_list|()
decl_stmt|,
name|o_im
argument_list|()
decl_stmt|,
name|o_conjugate
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|o_objcreate
argument_list|()
decl_stmt|,
name|o_isobj
argument_list|()
decl_stmt|,
name|o_norm
argument_list|()
decl_stmt|,
name|o_elemaddr
argument_list|()
decl_stmt|,
name|o_elemvalue
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|o_istype
argument_list|()
decl_stmt|,
name|o_scale
argument_list|()
decl_stmt|,
name|o_localvalue
argument_list|()
decl_stmt|,
name|o_return
argument_list|()
decl_stmt|,
name|o_islist
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|o_issimple
argument_list|()
decl_stmt|,
name|o_cmp
argument_list|()
decl_stmt|,
name|o_quomod
argument_list|()
decl_stmt|,
name|o_setconfig
argument_list|()
decl_stmt|,
name|o_setepsilon
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|o_printresult
argument_list|()
decl_stmt|,
name|o_isfile
argument_list|()
decl_stmt|,
name|o_isassoc
argument_list|()
decl_stmt|,
name|o_eleminit
argument_list|()
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Types of opcodes (depends on arguments saved after the opcode).  */
end_comment

begin_define
define|#
directive|define
name|OPNUL
value|1
end_define

begin_comment
comment|/* opcode has no arguments */
end_comment

begin_define
define|#
directive|define
name|OPONE
value|2
end_define

begin_comment
comment|/* opcode has one integer argument */
end_comment

begin_define
define|#
directive|define
name|OPTWO
value|3
end_define

begin_comment
comment|/* opcode has two integer arguments */
end_comment

begin_define
define|#
directive|define
name|OPJMP
value|4
end_define

begin_comment
comment|/* opcode is a jump (with one pointer argument) */
end_comment

begin_define
define|#
directive|define
name|OPRET
value|5
end_define

begin_comment
comment|/* opcode is a return (with no argument) */
end_comment

begin_define
define|#
directive|define
name|OPGLB
value|6
end_define

begin_comment
comment|/* opcode has global symbol pointer argument */
end_comment

begin_define
define|#
directive|define
name|OPPAR
value|7
end_define

begin_comment
comment|/* opcode has parameter index argument */
end_comment

begin_define
define|#
directive|define
name|OPLOC
value|8
end_define

begin_comment
comment|/* opcode needs local variable pointer (with one arg) */
end_comment

begin_define
define|#
directive|define
name|OPSTR
value|9
end_define

begin_comment
comment|/* opcode has a string constant arg */
end_comment

begin_define
define|#
directive|define
name|OPARG
value|10
end_define

begin_comment
comment|/* opcode is given number of arguments */
end_comment

begin_define
define|#
directive|define
name|OPSTI
value|11
end_define

begin_comment
comment|/* opcode is static initialization */
end_comment

begin_comment
comment|/*  * Information about each opcode.  */
end_comment

begin_struct
specifier|static
struct|struct
name|opcode
block|{
name|void
function_decl|(
modifier|*
name|o_func
function_decl|)
parameter_list|()
function_decl|;
comment|/* routine to call for opcode */
name|int
name|o_type
decl_stmt|;
comment|/* type of opcode */
name|char
modifier|*
name|o_name
decl_stmt|;
comment|/* name of opcode */
block|}
name|opcodes
index|[
name|MAX_OPCODE
operator|+
literal|1
index|]
init|=
block|{
name|o_nop
block|,
name|OPNUL
block|,
literal|"NOP"
block|,
comment|/* no operation */
name|o_localaddr
block|,
name|OPLOC
block|,
literal|"LOCALADDR"
block|,
comment|/* address of local variable */
name|o_globaladdr
block|,
name|OPGLB
block|,
literal|"GLOBALADDR"
block|,
comment|/* address of global variable */
name|o_paramaddr
block|,
name|OPPAR
block|,
literal|"PARAMADDR"
block|,
comment|/* address of paramater variable */
name|o_localvalue
block|,
name|OPLOC
block|,
literal|"LOCALVALUE"
block|,
comment|/* value of local variable */
name|o_globalvalue
block|,
name|OPGLB
block|,
literal|"GLOBALVALUE"
block|,
comment|/* value of global variable */
name|o_paramvalue
block|,
name|OPPAR
block|,
literal|"PARAMVALUE"
block|,
comment|/* value of paramater variable */
name|o_number
block|,
name|OPONE
block|,
literal|"NUMBER"
block|,
comment|/* constant real numeric value */
name|o_indexaddr
block|,
name|OPTWO
block|,
literal|"INDEXADDR"
block|,
comment|/* array index address */
name|o_printresult
block|,
name|OPNUL
block|,
literal|"PRINTRESULT"
block|,
comment|/* print result of top-level expression */
name|o_assign
block|,
name|OPNUL
block|,
literal|"ASSIGN"
block|,
comment|/* assign value to variable */
name|o_add
block|,
name|OPNUL
block|,
literal|"ADD"
block|,
comment|/* add top two values */
name|o_sub
block|,
name|OPNUL
block|,
literal|"SUB"
block|,
comment|/* subtract top two values */
name|o_mul
block|,
name|OPNUL
block|,
literal|"MUL"
block|,
comment|/* multiply top two values */
name|o_div
block|,
name|OPNUL
block|,
literal|"DIV"
block|,
comment|/* divide top two values */
name|o_mod
block|,
name|OPNUL
block|,
literal|"MOD"
block|,
comment|/* take mod of top two values */
name|o_save
block|,
name|OPNUL
block|,
literal|"SAVE"
block|,
comment|/* save value for later use */
name|o_negate
block|,
name|OPNUL
block|,
literal|"NEGATE"
block|,
comment|/* negate top value */
name|o_invert
block|,
name|OPNUL
block|,
literal|"INVERT"
block|,
comment|/* invert top value */
name|o_int
block|,
name|OPNUL
block|,
literal|"INT"
block|,
comment|/* take integer part */
name|o_frac
block|,
name|OPNUL
block|,
literal|"FRAC"
block|,
comment|/* take fraction part */
name|o_numerator
block|,
name|OPNUL
block|,
literal|"NUMERATOR"
block|,
comment|/* take numerator */
name|o_denominator
block|,
name|OPNUL
block|,
literal|"DENOMINATOR"
block|,
comment|/* take denominator */
name|o_duplicate
block|,
name|OPNUL
block|,
literal|"DUPLICATE"
block|,
comment|/* duplicate top value */
name|o_pop
block|,
name|OPNUL
block|,
literal|"POP"
block|,
comment|/* pop top value */
name|o_return
block|,
name|OPRET
block|,
literal|"RETURN"
block|,
comment|/* return value of function */
name|o_jumpeq
block|,
name|OPJMP
block|,
literal|"JUMPEQ"
block|,
comment|/* jump if value zero */
name|o_jumpne
block|,
name|OPJMP
block|,
literal|"JUMPNE"
block|,
comment|/* jump if value nonzero */
name|o_jump
block|,
name|OPJMP
block|,
literal|"JUMP"
block|,
comment|/* jump unconditionally */
name|o_usercall
block|,
name|OPTWO
block|,
literal|"USERCALL"
block|,
comment|/* call a user function */
name|o_getvalue
block|,
name|OPNUL
block|,
literal|"GETVALUE"
block|,
comment|/* convert address to value */
name|o_eq
block|,
name|OPNUL
block|,
literal|"EQ"
block|,
comment|/* test elements for equality */
name|o_ne
block|,
name|OPNUL
block|,
literal|"NE"
block|,
comment|/* test elements for inequality */
name|o_le
block|,
name|OPNUL
block|,
literal|"LE"
block|,
comment|/* test elements for<= */
name|o_ge
block|,
name|OPNUL
block|,
literal|"GE"
block|,
comment|/* test elements for>= */
name|o_lt
block|,
name|OPNUL
block|,
literal|"LT"
block|,
comment|/* test elements for< */
name|o_gt
block|,
name|OPNUL
block|,
literal|"GT"
block|,
comment|/* test elements for> */
name|o_preinc
block|,
name|OPNUL
block|,
literal|"PREINC"
block|,
comment|/* add one to variable (++x) */
name|o_predec
block|,
name|OPNUL
block|,
literal|"PREDEC"
block|,
comment|/* subtract one from variable (--x) */
name|o_postinc
block|,
name|OPNUL
block|,
literal|"POSTINC"
block|,
comment|/* add one to variable (x++) */
name|o_postdec
block|,
name|OPNUL
block|,
literal|"POSTDEC"
block|,
comment|/* subtract one from variable (x--) */
name|o_debug
block|,
name|OPONE
block|,
literal|"DEBUG"
block|,
comment|/* debugging point */
name|o_print
block|,
name|OPONE
block|,
literal|"PRINT"
block|,
comment|/* print value */
name|o_assignpop
block|,
name|OPNUL
block|,
literal|"ASSIGNPOP"
block|,
comment|/* assign to variable and pop it */
name|o_zero
block|,
name|OPNUL
block|,
literal|"ZERO"
block|,
comment|/* put zero on the stack */
name|o_one
block|,
name|OPNUL
block|,
literal|"ONE"
block|,
comment|/* put one on the stack */
name|o_printeol
block|,
name|OPNUL
block|,
literal|"PRINTEOL"
block|,
comment|/* print end of line */
name|o_printspace
block|,
name|OPNUL
block|,
literal|"PRINTSPACE"
block|,
comment|/* print a space */
name|o_printstring
block|,
name|OPSTR
block|,
literal|"PRINTSTR"
block|,
comment|/* print constant string */
name|o_dupvalue
block|,
name|OPNUL
block|,
literal|"DUPVALUE"
block|,
comment|/* duplicate value of top value */
name|o_oldvalue
block|,
name|OPNUL
block|,
literal|"OLDVALUE"
block|,
comment|/* old value from previous calc */
name|o_quo
block|,
name|OPNUL
block|,
literal|"QUO"
block|,
comment|/* integer quotient of top values */
name|o_power
block|,
name|OPNUL
block|,
literal|"POWER"
block|,
comment|/* value raised to a power */
name|o_quit
block|,
name|OPSTR
block|,
literal|"QUIT"
block|,
comment|/* quit program */
name|o_call
block|,
name|OPTWO
block|,
literal|"CALL"
block|,
comment|/* call built-in routine */
name|o_getepsilon
block|,
name|OPNUL
block|,
literal|"GETEPSILON"
block|,
comment|/* get allowed error for calculations */
name|o_and
block|,
name|OPNUL
block|,
literal|"AND"
block|,
comment|/* arithmetic and or top two values */
name|o_or
block|,
name|OPNUL
block|,
literal|"OR"
block|,
comment|/* arithmetic or of top two values */
name|o_not
block|,
name|OPNUL
block|,
literal|"NOT"
block|,
comment|/* logical not or top value */
name|o_abs
block|,
name|OPNUL
block|,
literal|"ABS"
block|,
comment|/* absolute value of top value */
name|o_sgn
block|,
name|OPNUL
block|,
literal|"SGN"
block|,
comment|/* sign of number */
name|o_isint
block|,
name|OPNUL
block|,
literal|"ISINT"
block|,
comment|/* whether number is an integer */
name|o_condorjump
block|,
name|OPJMP
block|,
literal|"CONDORJUMP"
block|,
comment|/* conditional or jump */
name|o_condandjump
block|,
name|OPJMP
block|,
literal|"CONDANDJUMP"
block|,
comment|/* conditional and jump */
name|o_square
block|,
name|OPNUL
block|,
literal|"SQUARE"
block|,
comment|/* square top value */
name|o_string
block|,
name|OPSTR
block|,
literal|"STRING"
block|,
comment|/* string constant value */
name|o_isnum
block|,
name|OPNUL
block|,
literal|"ISNUM"
block|,
comment|/* whether value is a number */
name|o_undef
block|,
name|OPNUL
block|,
literal|"UNDEF"
block|,
comment|/* load undefined value on stack */
name|o_isnull
block|,
name|OPNUL
block|,
literal|"ISNULL"
block|,
comment|/* whether value is the null value */
name|o_argvalue
block|,
name|OPARG
block|,
literal|"ARGVALUE"
block|,
comment|/* load value of arg (parameter) n */
name|o_matcreate
block|,
name|OPONE
block|,
literal|"MATCREATE"
block|,
comment|/* create matrix */
name|o_ismat
block|,
name|OPNUL
block|,
literal|"ISMAT"
block|,
comment|/* whether value is a matrix */
name|o_isstr
block|,
name|OPNUL
block|,
literal|"ISSTR"
block|,
comment|/* whether value is a string */
name|o_getconfig
block|,
name|OPNUL
block|,
literal|"GETCONFIG"
block|,
comment|/* get value of configuration parameter */
name|o_leftshift
block|,
name|OPNUL
block|,
literal|"LEFTSHIFT"
block|,
comment|/* left shift of integer */
name|o_rightshift
block|,
name|OPNUL
block|,
literal|"RIGHTSHIFT"
block|,
comment|/* right shift of integer */
name|o_casejump
block|,
name|OPJMP
block|,
literal|"CASEJUMP"
block|,
comment|/* test case and jump if not matched */
name|o_isodd
block|,
name|OPNUL
block|,
literal|"ISODD"
block|,
comment|/* whether value is odd integer */
name|o_iseven
block|,
name|OPNUL
block|,
literal|"ISEVEN"
block|,
comment|/* whether value is even integer */
name|o_fiaddr
block|,
name|OPNUL
block|,
literal|"FIADDR"
block|,
comment|/* 'fast index' matrix address */
name|o_fivalue
block|,
name|OPNUL
block|,
literal|"FIVALUE"
block|,
comment|/* 'fast index' matrix value */
name|o_isreal
block|,
name|OPNUL
block|,
literal|"ISREAL"
block|,
comment|/* whether value is real number */
name|o_imaginary
block|,
name|OPONE
block|,
literal|"IMAGINARY"
block|,
comment|/* constant imaginary numeric value */
name|o_re
block|,
name|OPNUL
block|,
literal|"RE"
block|,
comment|/* real part of complex number */
name|o_im
block|,
name|OPNUL
block|,
literal|"IM"
block|,
comment|/* imaginary part of complex number */
name|o_conjugate
block|,
name|OPNUL
block|,
literal|"CONJUGATE"
block|,
comment|/* complex conjugate */
name|o_objcreate
block|,
name|OPONE
block|,
literal|"OBJCREATE"
block|,
comment|/* create object */
name|o_isobj
block|,
name|OPNUL
block|,
literal|"ISOBJ"
block|,
comment|/* whether value is an object */
name|o_norm
block|,
name|OPNUL
block|,
literal|"NORM"
block|,
comment|/* norm of value (square of abs) */
name|o_elemaddr
block|,
name|OPONE
block|,
literal|"ELEMADDR"
block|,
comment|/* address of element of object */
name|o_elemvalue
block|,
name|OPONE
block|,
literal|"ELEMVALUE"
block|,
comment|/* value of element of object */
name|o_istype
block|,
name|OPNUL
block|,
literal|"ISTYPE"
block|,
comment|/* whether types are the same */
name|o_scale
block|,
name|OPNUL
block|,
literal|"SCALE"
block|,
comment|/* scale value by a power of two */
name|o_islist
block|,
name|OPNUL
block|,
literal|"ISLIST"
block|,
comment|/* whether value is a list */
name|o_swap
block|,
name|OPNUL
block|,
literal|"SWAP"
block|,
comment|/* swap values of two variables */
name|o_issimple
block|,
name|OPNUL
block|,
literal|"ISSIMPLE"
block|,
comment|/* whether value is simple type */
name|o_cmp
block|,
name|OPNUL
block|,
literal|"CMP"
block|,
comment|/* compare values returning -1, 0, 1 */
name|o_quomod
block|,
name|OPNUL
block|,
literal|"QUOMOD"
block|,
comment|/* calculate quotient and remainder */
name|o_setconfig
block|,
name|OPNUL
block|,
literal|"SETCONFIG"
block|,
comment|/* set configuration parameter */
name|o_setepsilon
block|,
name|OPNUL
block|,
literal|"SETEPSILON"
block|,
comment|/* set allowed error for calculations */
name|o_isfile
block|,
name|OPNUL
block|,
literal|"ISFILE"
block|,
comment|/* whether value is a file */
name|o_isassoc
block|,
name|OPNUL
block|,
literal|"ISASSOC"
block|,
comment|/* whether value is an association */
name|o_nop
block|,
name|OPSTI
block|,
literal|"INITSTATIC"
block|,
comment|/* once only code for static init */
name|o_eleminit
block|,
name|OPONE
block|,
literal|"ELEMINIT"
comment|/* assign element of matrix or object */
block|}
struct|;
end_struct

begin_comment
comment|/*  * Initialize the stack.  */
end_comment

begin_function
name|void
name|initstack
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
comment|/* on first init, setup the stack array */
if|if
condition|(
name|stack
operator|==
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|stackarray
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|stackarray
index|[
literal|0
index|]
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|stackarray
index|[
name|i
index|]
operator|.
name|v_type
operator|=
name|V_NULL
expr_stmt|;
name|stackarray
index|[
name|i
index|]
operator|.
name|v_subtype
operator|=
name|V_NOSUBTYPE
expr_stmt|;
block|}
name|stack
operator|=
name|stackarray
expr_stmt|;
comment|/* on subsequent inits, free the old stack */
block|}
else|else
block|{
while|while
condition|(
name|stack
operator|>
name|stackarray
condition|)
block|{
name|freevalue
argument_list|(
name|stack
operator|--
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Compute the result of a function by interpreting opcodes.  * Arguments have just been pushed onto the evaluation stack.  */
end_comment

begin_function
name|void
name|calculate
parameter_list|(
name|fp
parameter_list|,
name|argcount
parameter_list|)
specifier|register
name|FUNC
modifier|*
name|fp
decl_stmt|;
comment|/* function to calculate */
name|int
name|argcount
decl_stmt|;
comment|/* number of arguments called with */
block|{
specifier|register
name|unsigned
name|long
name|pc
decl_stmt|;
comment|/* current pc inside function */
specifier|register
name|struct
name|opcode
modifier|*
name|op
decl_stmt|;
comment|/* current opcode pointer */
specifier|register
name|VALUE
modifier|*
name|locals
decl_stmt|;
comment|/* pointer to local variables */
name|long
name|oldline
decl_stmt|;
comment|/* old value of line counter */
name|unsigned
name|int
name|opnum
decl_stmt|;
comment|/* current opcode number */
name|int
name|origargcount
decl_stmt|;
comment|/* original number of arguments */
name|int
name|i
decl_stmt|;
comment|/* loop counter */
name|BOOL
name|dojump
decl_stmt|;
comment|/* TRUE if jump is to occur */
name|char
modifier|*
name|oldname
decl_stmt|;
comment|/* old function name being executed */
name|VALUE
modifier|*
name|beginstack
decl_stmt|;
comment|/* beginning of stack frame */
name|VALUE
modifier|*
name|args
decl_stmt|;
comment|/* pointer to function arguments */
name|VALUE
name|retval
decl_stmt|;
comment|/* function return value */
name|VALUE
name|localtable
index|[
name|QUICKLOCALS
index|]
decl_stmt|;
comment|/* some local variables */
name|oldname
operator|=
name|funcname
expr_stmt|;
name|oldline
operator|=
name|funcline
expr_stmt|;
name|funcname
operator|=
name|fp
operator|->
name|f_name
expr_stmt|;
name|funcline
operator|=
literal|0
expr_stmt|;
name|origargcount
operator|=
name|argcount
expr_stmt|;
while|while
condition|(
name|argcount
operator|<
name|fp
operator|->
name|f_paramcount
condition|)
block|{
name|stack
operator|++
expr_stmt|;
name|stack
operator|->
name|v_type
operator|=
name|V_NULL
expr_stmt|;
name|argcount
operator|++
expr_stmt|;
block|}
name|locals
operator|=
name|localtable
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|f_localcount
operator|>
name|QUICKLOCALS
condition|)
block|{
name|locals
operator|=
operator|(
name|VALUE
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|VALUE
argument_list|)
operator|*
name|fp
operator|->
name|f_localcount
argument_list|)
expr_stmt|;
if|if
condition|(
name|locals
operator|==
name|NULL
condition|)
name|math_error
argument_list|(
literal|"No memory for local variables"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fp
operator|->
name|f_localcount
condition|;
name|i
operator|++
control|)
block|{
name|locals
index|[
name|i
index|]
operator|.
name|v_num
operator|=
name|qlink
argument_list|(
operator|&
name|_qzero_
argument_list|)
expr_stmt|;
name|locals
index|[
name|i
index|]
operator|.
name|v_type
operator|=
name|V_NUM
expr_stmt|;
name|locals
index|[
name|i
index|]
operator|.
name|v_subtype
operator|=
name|V_NOSUBTYPE
expr_stmt|;
block|}
name|pc
operator|=
literal|0
expr_stmt|;
name|beginstack
operator|=
name|stack
expr_stmt|;
name|args
operator|=
name|beginstack
operator|-
operator|(
name|argcount
operator|-
literal|1
operator|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|abortlevel
operator|>=
name|ABORT_OPCODE
condition|)
name|math_error
argument_list|(
literal|"Calculation aborted in opcode"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pc
operator|>=
name|fp
operator|->
name|f_opcodecount
condition|)
name|math_error
argument_list|(
literal|"Function pc out of range"
argument_list|)
expr_stmt|;
if|if
condition|(
name|stack
operator|>
operator|&
name|stackarray
index|[
name|MAXSTACK
operator|-
literal|3
index|]
condition|)
name|math_error
argument_list|(
literal|"Evaluation stack depth exceeded"
argument_list|)
expr_stmt|;
name|opnum
operator|=
name|fp
operator|->
name|f_opcodes
index|[
name|pc
index|]
expr_stmt|;
if|if
condition|(
name|opnum
operator|>
name|MAX_OPCODE
condition|)
name|math_error
argument_list|(
literal|"Function opcode out of range"
argument_list|)
expr_stmt|;
name|op
operator|=
operator|&
name|opcodes
index|[
name|opnum
index|]
expr_stmt|;
if|if
condition|(
name|traceflags
operator|&
name|TRACE_OPCODES
condition|)
block|{
name|printf
argument_list|(
literal|"%8s, pc %4ld:  "
argument_list|,
name|fp
operator|->
name|f_name
argument_list|,
name|pc
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dumpop
argument_list|(
operator|&
name|fp
operator|->
name|f_opcodes
index|[
name|pc
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Now call the opcode routine appropriately. 		 */
name|pc
operator|++
expr_stmt|;
switch|switch
condition|(
name|op
operator|->
name|o_type
condition|)
block|{
case|case
name|OPNUL
case|:
comment|/* no extra arguments */
call|(
modifier|*
name|op
operator|->
name|o_func
call|)
argument_list|(
name|fp
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPONE
case|:
comment|/* one extra integer argument */
call|(
modifier|*
name|op
operator|->
name|o_func
call|)
argument_list|(
name|fp
argument_list|,
name|fp
operator|->
name|f_opcodes
index|[
name|pc
operator|++
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPTWO
case|:
comment|/* two extra integer arguments */
call|(
modifier|*
name|op
operator|->
name|o_func
call|)
argument_list|(
name|fp
argument_list|,
name|fp
operator|->
name|f_opcodes
index|[
name|pc
index|]
argument_list|,
name|fp
operator|->
name|f_opcodes
index|[
name|pc
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
name|pc
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|OPJMP
case|:
comment|/* jump opcodes (one extra pointer arg) */
name|dojump
operator|=
name|FALSE
expr_stmt|;
call|(
modifier|*
name|op
operator|->
name|o_func
call|)
argument_list|(
name|fp
argument_list|,
operator|&
name|dojump
argument_list|)
expr_stmt|;
if|if
condition|(
name|dojump
condition|)
name|pc
operator|=
name|fp
operator|->
name|f_opcodes
index|[
name|pc
index|]
expr_stmt|;
else|else
name|pc
operator|++
expr_stmt|;
break|break;
case|case
name|OPGLB
case|:
comment|/* global symbol reference (pointer arg) */
case|case
name|OPSTR
case|:
comment|/* string constant address */
call|(
modifier|*
name|op
operator|->
name|o_func
call|)
argument_list|(
name|fp
argument_list|,
operator|*
operator|(
operator|(
name|char
operator|*
operator|*
operator|)
operator|&
name|fp
operator|->
name|f_opcodes
index|[
name|pc
index|]
operator|)
argument_list|)
expr_stmt|;
name|pc
operator|+=
name|PTR_SIZE
expr_stmt|;
break|break;
case|case
name|OPLOC
case|:
comment|/* local variable reference */
call|(
modifier|*
name|op
operator|->
name|o_func
call|)
argument_list|(
name|fp
argument_list|,
name|locals
argument_list|,
name|fp
operator|->
name|f_opcodes
index|[
name|pc
operator|++
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPPAR
case|:
comment|/* parameter variable reference */
call|(
modifier|*
name|op
operator|->
name|o_func
call|)
argument_list|(
name|fp
argument_list|,
name|argcount
argument_list|,
name|args
argument_list|,
name|fp
operator|->
name|f_opcodes
index|[
name|pc
operator|++
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPARG
case|:
comment|/* parameter variable reference */
call|(
modifier|*
name|op
operator|->
name|o_func
call|)
argument_list|(
name|fp
argument_list|,
name|origargcount
argument_list|,
name|args
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPRET
case|:
comment|/* return from function */
if|if
condition|(
name|stack
operator|->
name|v_type
operator|==
name|V_ADDR
condition|)
name|copyvalue
argument_list|(
name|stack
operator|->
name|v_addr
argument_list|,
name|stack
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fp
operator|->
name|f_localcount
condition|;
name|i
operator|++
control|)
name|freevalue
argument_list|(
operator|&
name|locals
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|locals
operator|!=
name|localtable
condition|)
name|free
argument_list|(
name|locals
argument_list|)
expr_stmt|;
if|if
condition|(
name|stack
operator|!=
operator|&
name|beginstack
index|[
literal|1
index|]
condition|)
name|math_error
argument_list|(
literal|"Misaligned stack"
argument_list|)
expr_stmt|;
if|if
condition|(
name|argcount
operator|<=
literal|0
condition|)
block|{
name|funcname
operator|=
name|oldname
expr_stmt|;
name|funcline
operator|=
name|oldline
expr_stmt|;
return|return;
block|}
name|retval
operator|=
operator|*
name|stack
operator|--
expr_stmt|;
while|while
condition|(
operator|--
name|argcount
operator|>=
literal|0
condition|)
name|freevalue
argument_list|(
name|stack
operator|--
argument_list|)
expr_stmt|;
operator|*
operator|++
name|stack
operator|=
name|retval
expr_stmt|;
name|funcname
operator|=
name|oldname
expr_stmt|;
name|funcline
operator|=
name|oldline
expr_stmt|;
return|return;
case|case
name|OPSTI
case|:
comment|/* static initialization code */
name|fp
operator|->
name|f_opcodes
index|[
name|pc
operator|++
operator|-
literal|1
index|]
operator|=
name|OP_JUMP
expr_stmt|;
break|break;
default|default:
name|math_error
argument_list|(
literal|"Unknown opcode type"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Dump an opcode at a particular address.  * Returns the size of the opcode so that it can easily be skipped over.  */
end_comment

begin_function
name|int
name|dumpop
parameter_list|(
name|pc
parameter_list|)
name|long
modifier|*
name|pc
decl_stmt|;
comment|/* location of the opcode */
block|{
name|unsigned
name|long
name|op
decl_stmt|;
comment|/* opcode number */
name|op
operator|=
operator|*
name|pc
operator|++
expr_stmt|;
if|if
condition|(
name|op
operator|<=
name|MAX_OPCODE
condition|)
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|opcodes
index|[
name|op
index|]
operator|.
name|o_name
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"OP%ld"
argument_list|,
name|op
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|OP_LOCALADDR
case|:
case|case
name|OP_LOCALVALUE
case|:
name|printf
argument_list|(
literal|" %s\n"
argument_list|,
name|localname
argument_list|(
operator|*
name|pc
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|2
return|;
case|case
name|OP_GLOBALADDR
case|:
case|case
name|OP_GLOBALVALUE
case|:
name|printf
argument_list|(
literal|" %s\n"
argument_list|,
name|globalname
argument_list|(
operator|*
operator|(
operator|(
name|GLOBAL
operator|*
operator|*
operator|)
name|pc
operator|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|+
name|PTR_SIZE
operator|)
return|;
case|case
name|OP_PARAMADDR
case|:
case|case
name|OP_PARAMVALUE
case|:
name|printf
argument_list|(
literal|" %s\n"
argument_list|,
name|paramname
argument_list|(
operator|*
name|pc
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|2
return|;
case|case
name|OP_PRINTSTRING
case|:
case|case
name|OP_STRING
case|:
name|printf
argument_list|(
literal|" \"%s\"\n"
argument_list|,
operator|*
operator|(
operator|(
name|char
operator|*
operator|*
operator|)
name|pc
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|+
name|PTR_SIZE
operator|)
return|;
case|case
name|OP_QUIT
case|:
if|if
condition|(
operator|*
operator|(
name|char
operator|*
operator|*
operator|)
name|pc
condition|)
name|printf
argument_list|(
literal|" \"%s\"\n"
argument_list|,
operator|*
operator|(
operator|(
name|char
operator|*
operator|*
operator|)
name|pc
operator|)
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|+
name|PTR_SIZE
operator|)
return|;
case|case
name|OP_INDEXADDR
case|:
name|printf
argument_list|(
literal|" %ld %ld\n"
argument_list|,
name|pc
index|[
literal|0
index|]
argument_list|,
name|pc
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
literal|3
return|;
case|case
name|OP_PRINT
case|:
case|case
name|OP_JUMPEQ
case|:
case|case
name|OP_JUMPNE
case|:
case|case
name|OP_JUMP
case|:
case|case
name|OP_CONDORJUMP
case|:
case|case
name|OP_CONDANDJUMP
case|:
case|case
name|OP_CASEJUMP
case|:
case|case
name|OP_INITSTATIC
case|:
case|case
name|OP_MATCREATE
case|:
case|case
name|OP_OBJCREATE
case|:
name|printf
argument_list|(
literal|" %ld\n"
argument_list|,
operator|*
name|pc
argument_list|)
expr_stmt|;
return|return
literal|2
return|;
case|case
name|OP_NUMBER
case|:
case|case
name|OP_IMAGINARY
case|:
name|qprintf
argument_list|(
literal|" %r\n"
argument_list|,
name|constvalue
argument_list|(
operator|*
name|pc
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|2
return|;
case|case
name|OP_DEBUG
case|:
name|printf
argument_list|(
literal|" line %ld\n"
argument_list|,
operator|*
name|pc
argument_list|)
expr_stmt|;
return|return
literal|2
return|;
case|case
name|OP_CALL
case|:
name|printf
argument_list|(
literal|" %s with %ld args\n"
argument_list|,
name|builtinname
argument_list|(
name|pc
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|pc
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
literal|3
return|;
case|case
name|OP_USERCALL
case|:
name|printf
argument_list|(
literal|" %s with %ld args\n"
argument_list|,
name|namefunc
argument_list|(
name|pc
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|pc
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
literal|3
return|;
default|default:
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * The various opcodes  */
end_comment

begin_function
specifier|static
name|void
name|o_nop
parameter_list|()
block|{ }
end_function

begin_function
specifier|static
name|void
name|o_localaddr
parameter_list|(
name|fp
parameter_list|,
name|locals
parameter_list|,
name|index
parameter_list|)
name|FUNC
modifier|*
name|fp
decl_stmt|;
name|VALUE
modifier|*
name|locals
decl_stmt|;
name|long
name|index
decl_stmt|;
block|{
if|if
condition|(
operator|(
name|unsigned
name|long
operator|)
name|index
operator|>=
name|fp
operator|->
name|f_localcount
condition|)
name|math_error
argument_list|(
literal|"Bad local variable index"
argument_list|)
expr_stmt|;
name|locals
operator|+=
name|index
expr_stmt|;
name|stack
operator|++
expr_stmt|;
name|stack
operator|->
name|v_addr
operator|=
name|locals
expr_stmt|;
name|stack
operator|->
name|v_type
operator|=
name|V_ADDR
expr_stmt|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|o_globaladdr
parameter_list|(
name|fp
parameter_list|,
name|sp
parameter_list|)
name|FUNC
modifier|*
name|fp
decl_stmt|;
name|GLOBAL
modifier|*
name|sp
decl_stmt|;
block|{
if|if
condition|(
name|sp
operator|==
name|NULL
condition|)
name|math_error
argument_list|(
literal|"Global variable \"%s\" not initialized"
argument_list|,
name|sp
operator|->
name|g_name
argument_list|)
expr_stmt|;
name|stack
operator|++
expr_stmt|;
name|stack
operator|->
name|v_addr
operator|=
operator|&
name|sp
operator|->
name|g_value
expr_stmt|;
name|stack
operator|->
name|v_type
operator|=
name|V_ADDR
expr_stmt|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|o_paramaddr
parameter_list|(
name|fp
parameter_list|,
name|argcount
parameter_list|,
name|args
parameter_list|,
name|index
parameter_list|)
name|FUNC
modifier|*
name|fp
decl_stmt|;
name|int
name|argcount
decl_stmt|;
name|VALUE
modifier|*
name|args
decl_stmt|;
name|long
name|index
decl_stmt|;
block|{
if|if
condition|(
operator|(
name|unsigned
name|long
operator|)
name|index
operator|>=
name|argcount
condition|)
name|math_error
argument_list|(
literal|"Bad parameter index"
argument_list|)
expr_stmt|;
name|args
operator|+=
name|index
expr_stmt|;
name|stack
operator|++
expr_stmt|;
if|if
condition|(
name|args
operator|->
name|v_type
operator|==
name|V_ADDR
condition|)
name|stack
operator|->
name|v_addr
operator|=
name|args
operator|->
name|v_addr
expr_stmt|;
else|else
name|stack
operator|->
name|v_addr
operator|=
name|args
expr_stmt|;
name|stack
operator|->
name|v_type
operator|=
name|V_ADDR
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|o_localvalue
parameter_list|(
name|fp
parameter_list|,
name|locals
parameter_list|,
name|index
parameter_list|)
name|FUNC
modifier|*
name|fp
decl_stmt|;
name|VALUE
modifier|*
name|locals
decl_stmt|;
name|long
name|index
decl_stmt|;
block|{
if|if
condition|(
operator|(
name|unsigned
name|long
operator|)
name|index
operator|>=
name|fp
operator|->
name|f_localcount
condition|)
name|math_error
argument_list|(
literal|"Bad local variable index"
argument_list|)
expr_stmt|;
name|locals
operator|+=
name|index
expr_stmt|;
name|copyvalue
argument_list|(
name|locals
argument_list|,
operator|++
name|stack
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|o_globalvalue
parameter_list|(
name|fp
parameter_list|,
name|sp
parameter_list|)
name|FUNC
modifier|*
name|fp
decl_stmt|;
name|GLOBAL
modifier|*
name|sp
decl_stmt|;
comment|/* global symbol */
block|{
if|if
condition|(
name|sp
operator|==
name|NULL
condition|)
name|math_error
argument_list|(
literal|"Global variable not defined"
argument_list|)
expr_stmt|;
name|copyvalue
argument_list|(
operator|&
name|sp
operator|->
name|g_value
argument_list|,
operator|++
name|stack
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|o_paramvalue
parameter_list|(
name|fp
parameter_list|,
name|argcount
parameter_list|,
name|args
parameter_list|,
name|index
parameter_list|)
name|FUNC
modifier|*
name|fp
decl_stmt|;
name|int
name|argcount
decl_stmt|;
name|VALUE
modifier|*
name|args
decl_stmt|;
name|long
name|index
decl_stmt|;
block|{
if|if
condition|(
operator|(
name|unsigned
name|long
operator|)
name|index
operator|>=
name|argcount
condition|)
name|math_error
argument_list|(
literal|"Bad paramaeter index"
argument_list|)
expr_stmt|;
name|args
operator|+=
name|index
expr_stmt|;
if|if
condition|(
name|args
operator|->
name|v_type
operator|==
name|V_ADDR
condition|)
name|args
operator|=
name|args
operator|->
name|v_addr
expr_stmt|;
name|copyvalue
argument_list|(
name|args
argument_list|,
operator|++
name|stack
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|o_argvalue
parameter_list|(
name|fp
parameter_list|,
name|argcount
parameter_list|,
name|args
parameter_list|)
name|FUNC
modifier|*
name|fp
decl_stmt|;
name|int
name|argcount
decl_stmt|;
name|VALUE
modifier|*
name|args
decl_stmt|;
block|{
name|VALUE
modifier|*
name|vp
decl_stmt|;
name|long
name|index
decl_stmt|;
name|vp
operator|=
name|stack
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|==
name|V_ADDR
condition|)
name|vp
operator|=
name|vp
operator|->
name|v_addr
expr_stmt|;
if|if
condition|(
operator|(
name|vp
operator|->
name|v_type
operator|!=
name|V_NUM
operator|)
operator|||
name|qisneg
argument_list|(
name|vp
operator|->
name|v_num
argument_list|)
operator|||
name|qisfrac
argument_list|(
name|vp
operator|->
name|v_num
argument_list|)
condition|)
name|math_error
argument_list|(
literal|"Illegal argument for arg function"
argument_list|)
expr_stmt|;
if|if
condition|(
name|qiszero
argument_list|(
name|vp
operator|->
name|v_num
argument_list|)
condition|)
block|{
if|if
condition|(
name|stack
operator|->
name|v_type
operator|==
name|V_NUM
condition|)
name|qfree
argument_list|(
name|stack
operator|->
name|v_num
argument_list|)
expr_stmt|;
name|stack
operator|->
name|v_num
operator|=
name|itoq
argument_list|(
operator|(
name|long
operator|)
name|argcount
argument_list|)
expr_stmt|;
name|stack
operator|->
name|v_type
operator|=
name|V_NUM
expr_stmt|;
return|return;
block|}
name|index
operator|=
name|qtoi
argument_list|(
name|vp
operator|->
name|v_num
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|stack
operator|->
name|v_type
operator|==
name|V_NUM
condition|)
name|qfree
argument_list|(
name|stack
operator|->
name|v_num
argument_list|)
expr_stmt|;
name|stack
operator|--
expr_stmt|;
operator|(
name|void
operator|)
name|o_paramvalue
argument_list|(
name|fp
argument_list|,
name|argcount
argument_list|,
name|args
argument_list|,
name|index
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|o_number
parameter_list|(
name|fp
parameter_list|,
name|arg
parameter_list|)
name|FUNC
modifier|*
name|fp
decl_stmt|;
name|long
name|arg
decl_stmt|;
block|{
name|NUMBER
modifier|*
name|q
decl_stmt|;
name|q
operator|=
name|constvalue
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|==
name|NULL
condition|)
name|math_error
argument_list|(
literal|"Numeric constant value not found"
argument_list|)
expr_stmt|;
name|stack
operator|++
expr_stmt|;
name|stack
operator|->
name|v_num
operator|=
name|qlink
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|stack
operator|->
name|v_type
operator|=
name|V_NUM
expr_stmt|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|o_imaginary
parameter_list|(
name|fp
parameter_list|,
name|arg
parameter_list|)
name|FUNC
modifier|*
name|fp
decl_stmt|;
name|long
name|arg
decl_stmt|;
block|{
name|NUMBER
modifier|*
name|q
decl_stmt|;
name|COMPLEX
modifier|*
name|c
decl_stmt|;
name|q
operator|=
name|constvalue
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|==
name|NULL
condition|)
name|math_error
argument_list|(
literal|"Numeric constant value not found"
argument_list|)
expr_stmt|;
name|stack
operator|++
expr_stmt|;
if|if
condition|(
name|qiszero
argument_list|(
name|q
argument_list|)
condition|)
block|{
name|stack
operator|->
name|v_num
operator|=
name|qlink
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|stack
operator|->
name|v_type
operator|=
name|V_NUM
expr_stmt|;
return|return;
block|}
name|c
operator|=
name|comalloc
argument_list|()
expr_stmt|;
name|c
operator|->
name|real
operator|=
name|qlink
argument_list|(
operator|&
name|_qzero_
argument_list|)
expr_stmt|;
name|c
operator|->
name|imag
operator|=
name|qlink
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|stack
operator|->
name|v_com
operator|=
name|c
expr_stmt|;
name|stack
operator|->
name|v_type
operator|=
name|V_COM
expr_stmt|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|o_string
parameter_list|(
name|fp
parameter_list|,
name|cp
parameter_list|)
name|FUNC
modifier|*
name|fp
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
block|{
name|stack
operator|++
expr_stmt|;
name|stack
operator|->
name|v_str
operator|=
name|cp
expr_stmt|;
name|stack
operator|->
name|v_type
operator|=
name|V_STR
expr_stmt|;
name|stack
operator|->
name|v_subtype
operator|=
name|V_STRLITERAL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|o_undef
parameter_list|()
block|{
name|stack
operator|++
expr_stmt|;
name|stack
operator|->
name|v_type
operator|=
name|V_NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|o_matcreate
parameter_list|(
name|fp
parameter_list|,
name|dim
parameter_list|)
name|FUNC
modifier|*
name|fp
decl_stmt|;
name|long
name|dim
decl_stmt|;
block|{
specifier|register
name|MATRIX
modifier|*
name|mp
decl_stmt|;
comment|/* matrix being defined */
name|NUMBER
modifier|*
name|num1
decl_stmt|;
comment|/* first number from stack */
name|NUMBER
modifier|*
name|num2
decl_stmt|;
comment|/* second number from stack */
name|VALUE
modifier|*
name|vp
decl_stmt|;
comment|/* value being defined */
name|VALUE
modifier|*
name|v1
decl_stmt|,
modifier|*
name|v2
decl_stmt|;
name|long
name|min
index|[
name|MAXDIM
index|]
decl_stmt|;
comment|/* minimum range */
name|long
name|max
index|[
name|MAXDIM
index|]
decl_stmt|;
comment|/* maximum range */
name|long
name|i
decl_stmt|;
comment|/* index */
name|long
name|tmp
decl_stmt|;
comment|/* temporary */
name|long
name|size
decl_stmt|;
comment|/* size of matrix */
if|if
condition|(
operator|(
name|dim
operator|<=
literal|0
operator|)
operator|||
operator|(
name|dim
operator|>
name|MAXDIM
operator|)
condition|)
name|math_error
argument_list|(
literal|"Bad dimension %ld for matrix"
argument_list|,
name|dim
argument_list|)
expr_stmt|;
if|if
condition|(
name|stack
index|[
operator|-
literal|2
operator|*
name|dim
index|]
operator|.
name|v_type
operator|!=
name|V_ADDR
condition|)
name|math_error
argument_list|(
literal|"Attempting to init matrix for non-address"
argument_list|)
expr_stmt|;
name|size
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
name|dim
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|v1
operator|=
operator|&
name|stack
index|[
operator|-
literal|1
index|]
expr_stmt|;
name|v2
operator|=
operator|&
name|stack
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|v1
operator|->
name|v_type
operator|==
name|V_ADDR
condition|)
name|v1
operator|=
name|v1
operator|->
name|v_addr
expr_stmt|;
if|if
condition|(
name|v2
operator|->
name|v_type
operator|==
name|V_ADDR
condition|)
name|v2
operator|=
name|v2
operator|->
name|v_addr
expr_stmt|;
if|if
condition|(
operator|(
name|v1
operator|->
name|v_type
operator|!=
name|V_NUM
operator|)
operator|||
operator|(
name|v2
operator|->
name|v_type
operator|!=
name|V_NUM
operator|)
condition|)
name|math_error
argument_list|(
literal|"Non-numeric bounds for matrix"
argument_list|)
expr_stmt|;
name|num1
operator|=
name|v1
operator|->
name|v_num
expr_stmt|;
name|num2
operator|=
name|v2
operator|->
name|v_num
expr_stmt|;
if|if
condition|(
name|qisfrac
argument_list|(
name|num1
argument_list|)
operator|||
name|qisfrac
argument_list|(
name|num2
argument_list|)
condition|)
name|math_error
argument_list|(
literal|"Non-integral bounds for matrix"
argument_list|)
expr_stmt|;
if|if
condition|(
name|zisbig
argument_list|(
name|num1
operator|->
name|num
argument_list|)
operator|||
name|zisbig
argument_list|(
name|num2
operator|->
name|num
argument_list|)
condition|)
name|math_error
argument_list|(
literal|"Very large bounds for matrix"
argument_list|)
expr_stmt|;
name|min
index|[
name|i
index|]
operator|=
name|qtoi
argument_list|(
name|num1
argument_list|)
expr_stmt|;
name|max
index|[
name|i
index|]
operator|=
name|qtoi
argument_list|(
name|num2
argument_list|)
expr_stmt|;
if|if
condition|(
name|min
index|[
name|i
index|]
operator|>
name|max
index|[
name|i
index|]
condition|)
block|{
name|tmp
operator|=
name|min
index|[
name|i
index|]
expr_stmt|;
name|min
index|[
name|i
index|]
operator|=
name|max
index|[
name|i
index|]
expr_stmt|;
name|max
index|[
name|i
index|]
operator|=
name|tmp
expr_stmt|;
block|}
name|size
operator|*=
operator|(
name|max
index|[
name|i
index|]
operator|-
name|min
index|[
name|i
index|]
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|size
operator|>
literal|10000000
condition|)
name|math_error
argument_list|(
literal|"Very large size for matrix"
argument_list|)
expr_stmt|;
name|freevalue
argument_list|(
name|stack
operator|--
argument_list|)
expr_stmt|;
name|freevalue
argument_list|(
name|stack
operator|--
argument_list|)
expr_stmt|;
block|}
name|mp
operator|=
name|matalloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|mp
operator|->
name|m_dim
operator|=
name|dim
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dim
condition|;
name|i
operator|++
control|)
block|{
name|mp
operator|->
name|m_min
index|[
name|i
index|]
operator|=
name|min
index|[
name|i
index|]
expr_stmt|;
name|mp
operator|->
name|m_max
index|[
name|i
index|]
operator|=
name|max
index|[
name|i
index|]
expr_stmt|;
block|}
name|vp
operator|=
name|mp
operator|->
name|m_table
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
name|vp
operator|->
name|v_type
operator|=
name|V_NUM
expr_stmt|;
name|vp
operator|->
name|v_num
operator|=
name|qlink
argument_list|(
operator|&
name|_qzero_
argument_list|)
expr_stmt|;
name|vp
operator|++
expr_stmt|;
block|}
name|vp
operator|=
name|stack
index|[
literal|0
index|]
operator|.
name|v_addr
expr_stmt|;
name|vp
operator|->
name|v_type
operator|=
name|V_MAT
expr_stmt|;
name|vp
operator|->
name|v_mat
operator|=
name|mp
expr_stmt|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|o_eleminit
parameter_list|(
name|fp
parameter_list|,
name|index
parameter_list|)
name|FUNC
modifier|*
name|fp
decl_stmt|;
name|long
name|index
decl_stmt|;
block|{
name|VALUE
modifier|*
name|vp
decl_stmt|;
specifier|static
name|VALUE
modifier|*
name|oldvp
decl_stmt|;
name|MATRIX
modifier|*
name|mp
decl_stmt|;
name|OBJECT
modifier|*
name|op
decl_stmt|;
name|vp
operator|=
operator|&
name|stack
index|[
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|==
name|V_ADDR
condition|)
name|vp
operator|=
name|vp
operator|->
name|v_addr
expr_stmt|;
switch|switch
condition|(
name|vp
operator|->
name|v_type
condition|)
block|{
case|case
name|V_MAT
case|:
name|mp
operator|=
name|vp
operator|->
name|v_mat
expr_stmt|;
if|if
condition|(
operator|(
name|index
operator|<
literal|0
operator|)
operator|||
operator|(
name|index
operator|>=
name|mp
operator|->
name|m_size
operator|)
condition|)
name|math_error
argument_list|(
literal|"Too many initializer values"
argument_list|)
expr_stmt|;
name|oldvp
operator|=
operator|&
name|mp
operator|->
name|m_table
index|[
name|index
index|]
expr_stmt|;
break|break;
case|case
name|V_OBJ
case|:
name|op
operator|=
name|vp
operator|->
name|v_obj
expr_stmt|;
if|if
condition|(
operator|(
name|index
operator|<
literal|0
operator|)
operator|||
operator|(
name|index
operator|>=
name|op
operator|->
name|o_actions
operator|->
name|count
operator|)
condition|)
name|math_error
argument_list|(
literal|"Too many initializer values"
argument_list|)
expr_stmt|;
name|oldvp
operator|=
operator|&
name|op
operator|->
name|o_table
index|[
name|index
index|]
expr_stmt|;
break|break;
default|default:
name|math_error
argument_list|(
literal|"Attempt to initialize non matrix or object"
argument_list|)
expr_stmt|;
block|}
name|vp
operator|=
name|stack
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|==
name|V_ADDR
condition|)
name|vp
operator|=
name|vp
operator|->
name|v_addr
expr_stmt|;
name|freevalue
argument_list|(
name|oldvp
argument_list|)
expr_stmt|;
name|copyvalue
argument_list|(
name|vp
argument_list|,
name|oldvp
argument_list|)
expr_stmt|;
name|stack
operator|--
expr_stmt|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|o_indexaddr
parameter_list|(
name|fp
parameter_list|,
name|dim
parameter_list|,
name|writeflag
parameter_list|)
name|FUNC
modifier|*
name|fp
decl_stmt|;
name|long
name|dim
decl_stmt|;
comment|/* dimension of matrix */
name|long
name|writeflag
decl_stmt|;
comment|/* nonzero if element will be written */
block|{
name|int
name|i
decl_stmt|;
name|BOOL
name|flag
decl_stmt|;
name|VALUE
modifier|*
name|val
decl_stmt|;
name|VALUE
modifier|*
name|vp
decl_stmt|;
name|VALUE
name|indices
index|[
name|MAXDIM
index|]
decl_stmt|;
comment|/* index values */
name|flag
operator|=
operator|(
name|writeflag
operator|!=
literal|0
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|dim
operator|<=
literal|0
operator|)
operator|||
operator|(
name|dim
operator|>
name|MAXDIM
operator|)
condition|)
name|math_error
argument_list|(
literal|"Too many dimensions for indexing"
argument_list|)
expr_stmt|;
name|val
operator|=
operator|&
name|stack
index|[
operator|-
name|dim
index|]
expr_stmt|;
if|if
condition|(
name|val
operator|->
name|v_type
operator|!=
name|V_ADDR
condition|)
name|math_error
argument_list|(
literal|"Non-pointer for index operation"
argument_list|)
expr_stmt|;
name|val
operator|=
name|val
operator|->
name|v_addr
expr_stmt|;
name|vp
operator|=
operator|&
name|stack
index|[
operator|-
name|dim
operator|+
literal|1
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dim
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|vp
operator|->
name|v_type
operator|==
name|V_ADDR
condition|)
name|indices
index|[
name|i
index|]
operator|=
name|vp
operator|->
name|v_addr
index|[
literal|0
index|]
expr_stmt|;
else|else
name|indices
index|[
name|i
index|]
operator|=
name|vp
index|[
literal|0
index|]
expr_stmt|;
name|vp
operator|++
expr_stmt|;
block|}
switch|switch
condition|(
name|val
operator|->
name|v_type
condition|)
block|{
case|case
name|V_MAT
case|:
name|vp
operator|=
name|matindex
argument_list|(
name|val
operator|->
name|v_mat
argument_list|,
name|flag
argument_list|,
name|dim
argument_list|,
name|indices
argument_list|)
expr_stmt|;
break|break;
case|case
name|V_ASSOC
case|:
name|vp
operator|=
name|associndex
argument_list|(
name|val
operator|->
name|v_assoc
argument_list|,
name|flag
argument_list|,
name|dim
argument_list|,
name|indices
argument_list|)
expr_stmt|;
break|break;
default|default:
name|math_error
argument_list|(
literal|"Illegal value for indexing"
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|dim
operator|--
operator|>
literal|0
condition|)
name|freevalue
argument_list|(
name|stack
operator|--
argument_list|)
expr_stmt|;
name|stack
operator|->
name|v_type
operator|=
name|V_ADDR
expr_stmt|;
name|stack
operator|->
name|v_addr
operator|=
name|vp
expr_stmt|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|o_elemaddr
parameter_list|(
name|fp
parameter_list|,
name|index
parameter_list|)
name|FUNC
modifier|*
name|fp
decl_stmt|;
name|long
name|index
decl_stmt|;
block|{
if|if
condition|(
name|stack
operator|->
name|v_type
operator|!=
name|V_ADDR
condition|)
name|math_error
argument_list|(
literal|"Non-pointer for element reference"
argument_list|)
expr_stmt|;
if|if
condition|(
name|stack
operator|->
name|v_addr
operator|->
name|v_type
operator|!=
name|V_OBJ
condition|)
name|math_error
argument_list|(
literal|"Referencing element of non-object"
argument_list|)
expr_stmt|;
name|index
operator|=
name|objoffset
argument_list|(
name|stack
operator|->
name|v_addr
operator|->
name|v_obj
argument_list|,
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|<
literal|0
condition|)
name|math_error
argument_list|(
literal|"Element does not exist for object"
argument_list|)
expr_stmt|;
name|stack
operator|->
name|v_addr
operator|=
operator|&
name|stack
operator|->
name|v_addr
operator|->
name|v_obj
operator|->
name|o_table
index|[
name|index
index|]
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|o_elemvalue
parameter_list|(
name|fp
parameter_list|,
name|index
parameter_list|)
name|FUNC
modifier|*
name|fp
decl_stmt|;
name|long
name|index
decl_stmt|;
block|{
if|if
condition|(
name|stack
operator|->
name|v_type
operator|!=
name|V_OBJ
condition|)
block|{
operator|(
name|void
operator|)
name|o_elemaddr
argument_list|(
name|fp
argument_list|,
name|index
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|o_getvalue
argument_list|()
expr_stmt|;
return|return;
block|}
name|index
operator|=
name|objoffset
argument_list|(
name|stack
operator|->
name|v_obj
argument_list|,
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|<
literal|0
condition|)
name|math_error
argument_list|(
literal|"Element does not exist for object"
argument_list|)
expr_stmt|;
name|copyvalue
argument_list|(
operator|&
name|stack
operator|->
name|v_obj
operator|->
name|o_table
index|[
name|index
index|]
argument_list|,
name|stack
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|o_objcreate
parameter_list|(
name|fp
parameter_list|,
name|arg
parameter_list|)
name|FUNC
modifier|*
name|fp
decl_stmt|;
name|long
name|arg
decl_stmt|;
block|{
name|OBJECT
modifier|*
name|op
decl_stmt|;
comment|/* object being created */
name|VALUE
modifier|*
name|vp
decl_stmt|;
comment|/* value being defined */
if|if
condition|(
name|stack
operator|->
name|v_type
operator|!=
name|V_ADDR
condition|)
name|math_error
argument_list|(
literal|"Attempting to init object for non-address"
argument_list|)
expr_stmt|;
name|op
operator|=
name|objalloc
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|vp
operator|=
name|stack
operator|->
name|v_addr
expr_stmt|;
name|vp
operator|->
name|v_type
operator|=
name|V_OBJ
expr_stmt|;
name|vp
operator|->
name|v_obj
operator|=
name|op
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|o_assign
parameter_list|()
block|{
name|VALUE
modifier|*
name|var
decl_stmt|;
comment|/* variable value */
name|VALUE
modifier|*
name|vp
decl_stmt|;
name|var
operator|=
operator|&
name|stack
index|[
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|var
operator|->
name|v_type
operator|!=
name|V_ADDR
condition|)
name|math_error
argument_list|(
literal|"Assignment into non-variable"
argument_list|)
expr_stmt|;
name|var
operator|=
name|var
operator|->
name|v_addr
expr_stmt|;
name|stack
index|[
operator|-
literal|1
index|]
operator|=
name|stack
index|[
literal|0
index|]
expr_stmt|;
name|stack
operator|--
expr_stmt|;
name|vp
operator|=
name|stack
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|==
name|V_ADDR
condition|)
block|{
name|vp
operator|=
name|vp
operator|->
name|v_addr
expr_stmt|;
if|if
condition|(
name|vp
operator|==
name|var
condition|)
return|return;
block|}
name|freevalue
argument_list|(
name|var
argument_list|)
expr_stmt|;
name|copyvalue
argument_list|(
name|vp
argument_list|,
name|var
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|o_assignpop
parameter_list|()
block|{
name|VALUE
modifier|*
name|var
decl_stmt|;
comment|/* variable value */
name|VALUE
modifier|*
name|vp
decl_stmt|;
name|var
operator|=
operator|&
name|stack
index|[
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|var
operator|->
name|v_type
operator|!=
name|V_ADDR
condition|)
name|math_error
argument_list|(
literal|"Assignment into non-variable"
argument_list|)
expr_stmt|;
name|var
operator|=
name|var
operator|->
name|v_addr
expr_stmt|;
name|vp
operator|=
operator|&
name|stack
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|vp
operator|->
name|v_type
operator|==
name|V_ADDR
operator|)
operator|&&
operator|(
name|vp
operator|->
name|v_addr
operator|==
name|var
operator|)
condition|)
block|{
name|stack
operator|-=
literal|2
expr_stmt|;
return|return;
block|}
name|freevalue
argument_list|(
name|var
argument_list|)
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|==
name|V_ADDR
condition|)
name|copyvalue
argument_list|(
name|vp
operator|->
name|v_addr
argument_list|,
name|var
argument_list|)
expr_stmt|;
else|else
operator|*
name|var
operator|=
operator|*
name|vp
expr_stmt|;
name|stack
operator|-=
literal|2
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|o_swap
parameter_list|()
block|{
name|VALUE
modifier|*
name|v1
decl_stmt|,
modifier|*
name|v2
decl_stmt|;
comment|/* variables to be swapped */
name|VALUE
name|tmp
decl_stmt|;
name|v1
operator|=
operator|&
name|stack
index|[
operator|-
literal|1
index|]
expr_stmt|;
name|v2
operator|=
operator|&
name|stack
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|v1
operator|->
name|v_type
operator|!=
name|V_ADDR
operator|)
operator|||
operator|(
name|v2
operator|->
name|v_type
operator|!=
name|V_ADDR
operator|)
condition|)
name|math_error
argument_list|(
literal|"Swapping non-variables"
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|v1
operator|->
name|v_addr
index|[
literal|0
index|]
expr_stmt|;
name|v1
operator|->
name|v_addr
index|[
literal|0
index|]
operator|=
name|v2
operator|->
name|v_addr
index|[
literal|0
index|]
expr_stmt|;
name|v2
operator|->
name|v_addr
index|[
literal|0
index|]
operator|=
name|tmp
expr_stmt|;
name|stack
operator|--
expr_stmt|;
name|stack
operator|->
name|v_type
operator|=
name|V_NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|o_add
parameter_list|()
block|{
name|VALUE
modifier|*
name|v1
decl_stmt|,
modifier|*
name|v2
decl_stmt|;
name|NUMBER
modifier|*
name|q
decl_stmt|;
name|VALUE
name|tmp
decl_stmt|;
name|v1
operator|=
operator|&
name|stack
index|[
operator|-
literal|1
index|]
expr_stmt|;
name|v2
operator|=
operator|&
name|stack
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|v1
operator|->
name|v_type
operator|==
name|V_ADDR
condition|)
name|v1
operator|=
name|v1
operator|->
name|v_addr
expr_stmt|;
if|if
condition|(
name|v2
operator|->
name|v_type
operator|==
name|V_ADDR
condition|)
name|v2
operator|=
name|v2
operator|->
name|v_addr
expr_stmt|;
if|if
condition|(
operator|(
name|v1
operator|->
name|v_type
operator|!=
name|V_NUM
operator|)
operator|||
operator|(
name|v2
operator|->
name|v_type
operator|!=
name|V_NUM
operator|)
condition|)
block|{
name|addvalue
argument_list|(
name|v1
argument_list|,
name|v2
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
name|freevalue
argument_list|(
name|stack
operator|--
argument_list|)
expr_stmt|;
name|freevalue
argument_list|(
name|stack
argument_list|)
expr_stmt|;
operator|*
name|stack
operator|=
name|tmp
expr_stmt|;
return|return;
block|}
name|q
operator|=
name|qadd
argument_list|(
name|v1
operator|->
name|v_num
argument_list|,
name|v2
operator|->
name|v_num
argument_list|)
expr_stmt|;
if|if
condition|(
name|stack
operator|->
name|v_type
operator|==
name|V_NUM
condition|)
name|qfree
argument_list|(
name|stack
operator|->
name|v_num
argument_list|)
expr_stmt|;
name|stack
operator|--
expr_stmt|;
if|if
condition|(
name|stack
operator|->
name|v_type
operator|==
name|V_NUM
condition|)
name|qfree
argument_list|(
name|stack
operator|->
name|v_num
argument_list|)
expr_stmt|;
name|stack
operator|->
name|v_num
operator|=
name|q
expr_stmt|;
name|stack
operator|->
name|v_type
operator|=
name|V_NUM
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|o_sub
parameter_list|()
block|{
name|VALUE
modifier|*
name|v1
decl_stmt|,
modifier|*
name|v2
decl_stmt|;
name|NUMBER
modifier|*
name|q
decl_stmt|;
name|VALUE
name|tmp
decl_stmt|;
name|v1
operator|=
operator|&
name|stack
index|[
operator|-
literal|1
index|]
expr_stmt|;
name|v2
operator|=
operator|&
name|stack
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|v1
operator|->
name|v_type
operator|==
name|V_ADDR
condition|)
name|v1
operator|=
name|v1
operator|->
name|v_addr
expr_stmt|;
if|if
condition|(
name|v2
operator|->
name|v_type
operator|==
name|V_ADDR
condition|)
name|v2
operator|=
name|v2
operator|->
name|v_addr
expr_stmt|;
if|if
condition|(
operator|(
name|v1
operator|->
name|v_type
operator|!=
name|V_NUM
operator|)
operator|||
operator|(
name|v2
operator|->
name|v_type
operator|!=
name|V_NUM
operator|)
condition|)
block|{
name|subvalue
argument_list|(
name|v1
argument_list|,
name|v2
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
name|freevalue
argument_list|(
name|stack
operator|--
argument_list|)
expr_stmt|;
name|freevalue
argument_list|(
name|stack
argument_list|)
expr_stmt|;
operator|*
name|stack
operator|=
name|tmp
expr_stmt|;
return|return;
block|}
name|q
operator|=
name|qsub
argument_list|(
name|v1
operator|->
name|v_num
argument_list|,
name|v2
operator|->
name|v_num
argument_list|)
expr_stmt|;
if|if
condition|(
name|stack
operator|->
name|v_type
operator|==
name|V_NUM
condition|)
name|qfree
argument_list|(
name|stack
operator|->
name|v_num
argument_list|)
expr_stmt|;
name|stack
operator|--
expr_stmt|;
if|if
condition|(
name|stack
operator|->
name|v_type
operator|==
name|V_NUM
condition|)
name|qfree
argument_list|(
name|stack
operator|->
name|v_num
argument_list|)
expr_stmt|;
name|stack
operator|->
name|v_num
operator|=
name|q
expr_stmt|;
name|stack
operator|->
name|v_type
operator|=
name|V_NUM
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|o_mul
parameter_list|()
block|{
name|VALUE
modifier|*
name|v1
decl_stmt|,
modifier|*
name|v2
decl_stmt|;
name|NUMBER
modifier|*
name|q
decl_stmt|;
name|VALUE
name|tmp
decl_stmt|;
name|v1
operator|=
operator|&
name|stack
index|[
operator|-
literal|1
index|]
expr_stmt|;
name|v2
operator|=
operator|&
name|stack
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|v1
operator|->
name|v_type
operator|==
name|V_ADDR
condition|)
name|v1
operator|=
name|v1
operator|->
name|v_addr
expr_stmt|;
if|if
condition|(
name|v2
operator|->
name|v_type
operator|==
name|V_ADDR
condition|)
name|v2
operator|=
name|v2
operator|->
name|v_addr
expr_stmt|;
if|if
condition|(
operator|(
name|v1
operator|->
name|v_type
operator|!=
name|V_NUM
operator|)
operator|||
operator|(
name|v2
operator|->
name|v_type
operator|!=
name|V_NUM
operator|)
condition|)
block|{
name|mulvalue
argument_list|(
name|v1
argument_list|,
name|v2
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
name|freevalue
argument_list|(
name|stack
operator|--
argument_list|)
expr_stmt|;
name|freevalue
argument_list|(
name|stack
argument_list|)
expr_stmt|;
operator|*
name|stack
operator|=
name|tmp
expr_stmt|;
return|return;
block|}
name|q
operator|=
name|qmul
argument_list|(
name|v1
operator|->
name|v_num
argument_list|,
name|v2
operator|->
name|v_num
argument_list|)
expr_stmt|;
if|if
condition|(
name|stack
operator|->
name|v_type
operator|==
name|V_NUM
condition|)
name|qfree
argument_list|(
name|stack
operator|->
name|v_num
argument_list|)
expr_stmt|;
name|stack
operator|--
expr_stmt|;
if|if
condition|(
name|stack
operator|->
name|v_type
operator|==
name|V_NUM
condition|)
name|qfree
argument_list|(
name|stack
operator|->
name|v_num
argument_list|)
expr_stmt|;
name|stack
operator|->
name|v_num
operator|=
name|q
expr_stmt|;
name|stack
operator|->
name|v_type
operator|=
name|V_NUM
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|o_power
parameter_list|()
block|{
name|VALUE
modifier|*
name|v1
decl_stmt|,
modifier|*
name|v2
decl_stmt|;
name|VALUE
name|tmp
decl_stmt|;
name|v1
operator|=
operator|&
name|stack
index|[
operator|-
literal|1
index|]
expr_stmt|;
name|v2
operator|=
operator|&
name|stack
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|v1
operator|->
name|v_type
operator|==
name|V_ADDR
condition|)
name|v1
operator|=
name|v1
operator|->
name|v_addr
expr_stmt|;
if|if
condition|(
name|v2
operator|->
name|v_type
operator|==
name|V_ADDR
condition|)
name|v2
operator|=
name|v2
operator|->
name|v_addr
expr_stmt|;
name|powivalue
argument_list|(
name|v1
argument_list|,
name|v2
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
name|freevalue
argument_list|(
name|stack
operator|--
argument_list|)
expr_stmt|;
name|freevalue
argument_list|(
name|stack
argument_list|)
expr_stmt|;
operator|*
name|stack
operator|=
name|tmp
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|o_div
parameter_list|()
block|{
name|VALUE
modifier|*
name|v1
decl_stmt|,
modifier|*
name|v2
decl_stmt|;
name|NUMBER
modifier|*
name|q
decl_stmt|;
name|VALUE
name|tmp
decl_stmt|;
name|v1
operator|=
operator|&
name|stack
index|[
operator|-
literal|1
index|]
expr_stmt|;
name|v2
operator|=
operator|&
name|stack
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|v1
operator|->
name|v_type
operator|==
name|V_ADDR
condition|)
name|v1
operator|=
name|v1
operator|->
name|v_addr
expr_stmt|;
if|if
condition|(
name|v2
operator|->
name|v_type
operator|==
name|V_ADDR
condition|)
name|v2
operator|=
name|v2
operator|->
name|v_addr
expr_stmt|;
if|if
condition|(
operator|(
name|v1
operator|->
name|v_type
operator|!=
name|V_NUM
operator|)
operator|||
operator|(
name|v2
operator|->
name|v_type
operator|!=
name|V_NUM
operator|)
condition|)
block|{
name|divvalue
argument_list|(
name|v1
argument_list|,
name|v2
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
name|freevalue
argument_list|(
name|stack
operator|--
argument_list|)
expr_stmt|;
name|freevalue
argument_list|(
name|stack
argument_list|)
expr_stmt|;
operator|*
name|stack
operator|=
name|tmp
expr_stmt|;
return|return;
block|}
name|q
operator|=
name|qdiv
argument_list|(
name|v1
operator|->
name|v_num
argument_list|,
name|v2
operator|->
name|v_num
argument_list|)
expr_stmt|;
if|if
condition|(
name|stack
operator|->
name|v_type
operator|==
name|V_NUM
condition|)
name|qfree
argument_list|(
name|stack
operator|->
name|v_num
argument_list|)
expr_stmt|;
name|stack
operator|--
expr_stmt|;
if|if
condition|(
name|stack
operator|->
name|v_type
operator|==
name|V_NUM
condition|)
name|qfree
argument_list|(
name|stack
operator|->
name|v_num
argument_list|)
expr_stmt|;
name|stack
operator|->
name|v_num
operator|=
name|q
expr_stmt|;
name|stack
operator|->
name|v_type
operator|=
name|V_NUM
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|o_quo
parameter_list|()
block|{
name|VALUE
modifier|*
name|v1
decl_stmt|,
modifier|*
name|v2
decl_stmt|;
name|NUMBER
modifier|*
name|q
decl_stmt|;
name|VALUE
name|tmp
decl_stmt|;
name|v1
operator|=
operator|&
name|stack
index|[
operator|-
literal|1
index|]
expr_stmt|;
name|v2
operator|=
operator|&
name|stack
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|v1
operator|->
name|v_type
operator|==
name|V_ADDR
condition|)
name|v1
operator|=
name|v1
operator|->
name|v_addr
expr_stmt|;
if|if
condition|(
name|v2
operator|->
name|v_type
operator|==
name|V_ADDR
condition|)
name|v2
operator|=
name|v2
operator|->
name|v_addr
expr_stmt|;
if|if
condition|(
operator|(
name|v1
operator|->
name|v_type
operator|!=
name|V_NUM
operator|)
operator|||
operator|(
name|v2
operator|->
name|v_type
operator|!=
name|V_NUM
operator|)
condition|)
block|{
name|quovalue
argument_list|(
name|v1
argument_list|,
name|v2
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
name|freevalue
argument_list|(
name|stack
operator|--
argument_list|)
expr_stmt|;
name|freevalue
argument_list|(
name|stack
argument_list|)
expr_stmt|;
operator|*
name|stack
operator|=
name|tmp
expr_stmt|;
return|return;
block|}
name|q
operator|=
name|qquo
argument_list|(
name|v1
operator|->
name|v_num
argument_list|,
name|v2
operator|->
name|v_num
argument_list|)
expr_stmt|;
if|if
condition|(
name|stack
operator|->
name|v_type
operator|==
name|V_NUM
condition|)
name|qfree
argument_list|(
name|stack
operator|->
name|v_num
argument_list|)
expr_stmt|;
name|stack
operator|--
expr_stmt|;
if|if
condition|(
name|stack
operator|->
name|v_type
operator|==
name|V_NUM
condition|)
name|qfree
argument_list|(
name|stack
operator|->
name|v_num
argument_list|)
expr_stmt|;
name|stack
operator|->
name|v_num
operator|=
name|q
expr_stmt|;
name|stack
operator|->
name|v_type
operator|=
name|V_NUM
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|o_mod
parameter_list|()
block|{
name|VALUE
modifier|*
name|v1
decl_stmt|,
modifier|*
name|v2
decl_stmt|;
name|NUMBER
modifier|*
name|q
decl_stmt|;
name|VALUE
name|tmp
decl_stmt|;
name|v1
operator|=
operator|&
name|stack
index|[
operator|-
literal|1
index|]
expr_stmt|;
name|v2
operator|=
operator|&
name|stack
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|v1
operator|->
name|v_type
operator|==
name|V_ADDR
condition|)
name|v1
operator|=
name|v1
operator|->
name|v_addr
expr_stmt|;
if|if
condition|(
name|v2
operator|->
name|v_type
operator|==
name|V_ADDR
condition|)
name|v2
operator|=
name|v2
operator|->
name|v_addr
expr_stmt|;
if|if
condition|(
operator|(
name|v1
operator|->
name|v_type
operator|!=
name|V_NUM
operator|)
operator|||
operator|(
name|v2
operator|->
name|v_type
operator|!=
name|V_NUM
operator|)
condition|)
block|{
name|modvalue
argument_list|(
name|v1
argument_list|,
name|v2
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
name|freevalue
argument_list|(
name|stack
operator|--
argument_list|)
expr_stmt|;
name|freevalue
argument_list|(
name|stack
argument_list|)
expr_stmt|;
operator|*
name|stack
operator|=
name|tmp
expr_stmt|;
return|return;
block|}
name|q
operator|=
name|qmod
argument_list|(
name|v1
operator|->
name|v_num
argument_list|,
name|v2
operator|->
name|v_num
argument_list|)
expr_stmt|;
if|if
condition|(
name|stack
operator|->
name|v_type
operator|==
name|V_NUM
condition|)
name|qfree
argument_list|(
name|stack
operator|->
name|v_num
argument_list|)
expr_stmt|;
name|stack
operator|--
expr_stmt|;
if|if
condition|(
name|stack
operator|->
name|v_type
operator|==
name|V_NUM
condition|)
name|qfree
argument_list|(
name|stack
operator|->
name|v_num
argument_list|)
expr_stmt|;
name|stack
operator|->
name|v_num
operator|=
name|q
expr_stmt|;
name|stack
operator|->
name|v_type
operator|=
name|V_NUM
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|o_quomod
parameter_list|()
block|{
name|VALUE
modifier|*
name|v1
decl_stmt|,
modifier|*
name|v2
decl_stmt|,
modifier|*
name|v3
decl_stmt|,
modifier|*
name|v4
decl_stmt|;
name|VALUE
name|valquo
decl_stmt|,
name|valmod
decl_stmt|;
name|BOOL
name|res
decl_stmt|;
name|v1
operator|=
operator|&
name|stack
index|[
operator|-
literal|3
index|]
expr_stmt|;
name|v2
operator|=
operator|&
name|stack
index|[
operator|-
literal|2
index|]
expr_stmt|;
name|v3
operator|=
operator|&
name|stack
index|[
operator|-
literal|1
index|]
expr_stmt|;
name|v4
operator|=
operator|&
name|stack
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|v1
operator|->
name|v_type
operator|==
name|V_ADDR
condition|)
name|v1
operator|=
name|v1
operator|->
name|v_addr
expr_stmt|;
if|if
condition|(
name|v2
operator|->
name|v_type
operator|==
name|V_ADDR
condition|)
name|v2
operator|=
name|v2
operator|->
name|v_addr
expr_stmt|;
if|if
condition|(
operator|(
name|v3
operator|->
name|v_type
operator|!=
name|V_ADDR
operator|)
operator|||
operator|(
name|v4
operator|->
name|v_type
operator|!=
name|V_ADDR
operator|)
condition|)
name|math_error
argument_list|(
literal|"Non-variable for quomod"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|v1
operator|->
name|v_type
operator|!=
name|V_NUM
operator|)
operator|||
operator|(
name|v2
operator|->
name|v_type
operator|!=
name|V_NUM
operator|)
condition|)
name|math_error
argument_list|(
literal|"Non-reals for quomod"
argument_list|)
expr_stmt|;
name|v3
operator|=
name|v3
operator|->
name|v_addr
expr_stmt|;
name|v4
operator|=
name|v4
operator|->
name|v_addr
expr_stmt|;
name|valquo
operator|.
name|v_type
operator|=
name|V_NUM
expr_stmt|;
name|valmod
operator|.
name|v_type
operator|=
name|V_NUM
expr_stmt|;
name|res
operator|=
name|qquomod
argument_list|(
name|v1
operator|->
name|v_num
argument_list|,
name|v2
operator|->
name|v_num
argument_list|,
operator|&
name|valquo
operator|.
name|v_num
argument_list|,
operator|&
name|valmod
operator|.
name|v_num
argument_list|)
expr_stmt|;
name|freevalue
argument_list|(
name|stack
operator|--
argument_list|)
expr_stmt|;
name|freevalue
argument_list|(
name|stack
operator|--
argument_list|)
expr_stmt|;
name|stack
operator|--
expr_stmt|;
name|stack
operator|->
name|v_num
operator|=
operator|(
name|res
condition|?
name|qlink
argument_list|(
operator|&
name|_qone_
argument_list|)
else|:
name|qlink
argument_list|(
operator|&
name|_qzero_
argument_list|)
operator|)
expr_stmt|;
name|stack
operator|->
name|v_type
operator|=
name|V_NUM
expr_stmt|;
name|freevalue
argument_list|(
name|v3
argument_list|)
expr_stmt|;
name|freevalue
argument_list|(
name|v4
argument_list|)
expr_stmt|;
operator|*
name|v3
operator|=
name|valquo
expr_stmt|;
operator|*
name|v4
operator|=
name|valmod
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|o_and
parameter_list|()
block|{
name|VALUE
modifier|*
name|v1
decl_stmt|,
modifier|*
name|v2
decl_stmt|;
name|NUMBER
modifier|*
name|q
decl_stmt|;
name|v1
operator|=
operator|&
name|stack
index|[
operator|-
literal|1
index|]
expr_stmt|;
name|v2
operator|=
operator|&
name|stack
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|v1
operator|->
name|v_type
operator|==
name|V_ADDR
condition|)
name|v1
operator|=
name|v1
operator|->
name|v_addr
expr_stmt|;
if|if
condition|(
name|v2
operator|->
name|v_type
operator|==
name|V_ADDR
condition|)
name|v2
operator|=
name|v2
operator|->
name|v_addr
expr_stmt|;
if|if
condition|(
operator|(
name|v1
operator|->
name|v_type
operator|!=
name|V_NUM
operator|)
operator|||
operator|(
name|v2
operator|->
name|v_type
operator|!=
name|V_NUM
operator|)
condition|)
name|math_error
argument_list|(
literal|"Non-numerics for and"
argument_list|)
expr_stmt|;
name|q
operator|=
name|qand
argument_list|(
name|v1
operator|->
name|v_num
argument_list|,
name|v2
operator|->
name|v_num
argument_list|)
expr_stmt|;
if|if
condition|(
name|stack
operator|->
name|v_type
operator|==
name|V_NUM
condition|)
name|qfree
argument_list|(
name|stack
operator|->
name|v_num
argument_list|)
expr_stmt|;
name|stack
operator|--
expr_stmt|;
if|if
condition|(
name|stack
operator|->
name|v_type
operator|==
name|V_NUM
condition|)
name|qfree
argument_list|(
name|stack
operator|->
name|v_num
argument_list|)
expr_stmt|;
name|stack
operator|->
name|v_num
operator|=
name|q
expr_stmt|;
name|stack
operator|->
name|v_type
operator|=
name|V_NUM
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|o_or
parameter_list|()
block|{
name|VALUE
modifier|*
name|v1
decl_stmt|,
modifier|*
name|v2
decl_stmt|;
name|NUMBER
modifier|*
name|q
decl_stmt|;
name|v1
operator|=
operator|&
name|stack
index|[
operator|-
literal|1
index|]
expr_stmt|;
name|v2
operator|=
operator|&
name|stack
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|v1
operator|->
name|v_type
operator|==
name|V_ADDR
condition|)
name|v1
operator|=
name|v1
operator|->
name|v_addr
expr_stmt|;
if|if
condition|(
name|v2
operator|->
name|v_type
operator|==
name|V_ADDR
condition|)
name|v2
operator|=
name|v2
operator|->
name|v_addr
expr_stmt|;
if|if
condition|(
operator|(
name|v1
operator|->
name|v_type
operator|!=
name|V_NUM
operator|)
operator|||
operator|(
name|v2
operator|->
name|v_type
operator|!=
name|V_NUM
operator|)
condition|)
name|math_error
argument_list|(
literal|"Non-numerics for or"
argument_list|)
expr_stmt|;
name|q
operator|=
name|qor
argument_list|(
name|v1
operator|->
name|v_num
argument_list|,
name|v2
operator|->
name|v_num
argument_list|)
expr_stmt|;
if|if
condition|(
name|stack
operator|->
name|v_type
operator|==
name|V_NUM
condition|)
name|qfree
argument_list|(
name|stack
operator|->
name|v_num
argument_list|)
expr_stmt|;
name|stack
operator|--
expr_stmt|;
if|if
condition|(
name|stack
operator|->
name|v_type
operator|==
name|V_NUM
condition|)
name|qfree
argument_list|(
name|stack
operator|->
name|v_num
argument_list|)
expr_stmt|;
name|stack
operator|->
name|v_num
operator|=
name|q
expr_stmt|;
name|stack
operator|->
name|v_type
operator|=
name|V_NUM
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|o_not
parameter_list|()
block|{
name|VALUE
modifier|*
name|vp
decl_stmt|;
name|int
name|r
decl_stmt|;
name|vp
operator|=
name|stack
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|==
name|V_ADDR
condition|)
name|vp
operator|=
name|vp
operator|->
name|v_addr
expr_stmt|;
name|r
operator|=
name|testvalue
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|freevalue
argument_list|(
name|stack
argument_list|)
expr_stmt|;
name|stack
operator|->
name|v_num
operator|=
operator|(
name|r
condition|?
name|qlink
argument_list|(
operator|&
name|_qzero_
argument_list|)
else|:
name|qlink
argument_list|(
operator|&
name|_qone_
argument_list|)
operator|)
expr_stmt|;
name|stack
operator|->
name|v_type
operator|=
name|V_NUM
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|o_negate
parameter_list|()
block|{
name|VALUE
modifier|*
name|vp
decl_stmt|;
name|NUMBER
modifier|*
name|q
decl_stmt|;
name|VALUE
name|tmp
decl_stmt|;
name|vp
operator|=
name|stack
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|==
name|V_ADDR
condition|)
name|vp
operator|=
name|vp
operator|->
name|v_addr
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|==
name|V_NUM
condition|)
block|{
name|q
operator|=
name|qneg
argument_list|(
name|vp
operator|->
name|v_num
argument_list|)
expr_stmt|;
if|if
condition|(
name|stack
operator|->
name|v_type
operator|==
name|V_NUM
condition|)
name|qfree
argument_list|(
name|stack
operator|->
name|v_num
argument_list|)
expr_stmt|;
name|stack
operator|->
name|v_num
operator|=
name|q
expr_stmt|;
name|stack
operator|->
name|v_type
operator|=
name|V_NUM
expr_stmt|;
return|return;
block|}
name|negvalue
argument_list|(
name|vp
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
name|freevalue
argument_list|(
name|stack
argument_list|)
expr_stmt|;
operator|*
name|stack
operator|=
name|tmp
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|o_invert
parameter_list|()
block|{
name|VALUE
modifier|*
name|vp
decl_stmt|;
name|NUMBER
modifier|*
name|q
decl_stmt|;
name|VALUE
name|tmp
decl_stmt|;
name|vp
operator|=
name|stack
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|==
name|V_ADDR
condition|)
name|vp
operator|=
name|vp
operator|->
name|v_addr
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|==
name|V_NUM
condition|)
block|{
name|q
operator|=
name|qinv
argument_list|(
name|vp
operator|->
name|v_num
argument_list|)
expr_stmt|;
if|if
condition|(
name|stack
operator|->
name|v_type
operator|==
name|V_NUM
condition|)
name|qfree
argument_list|(
name|stack
operator|->
name|v_num
argument_list|)
expr_stmt|;
name|stack
operator|->
name|v_num
operator|=
name|q
expr_stmt|;
name|stack
operator|->
name|v_type
operator|=
name|V_NUM
expr_stmt|;
return|return;
block|}
name|invertvalue
argument_list|(
name|vp
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
name|freevalue
argument_list|(
name|stack
argument_list|)
expr_stmt|;
operator|*
name|stack
operator|=
name|tmp
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|o_scale
parameter_list|()
block|{
name|VALUE
modifier|*
name|v1
decl_stmt|,
modifier|*
name|v2
decl_stmt|;
name|NUMBER
modifier|*
name|q
decl_stmt|;
name|VALUE
name|tmp
decl_stmt|;
name|v1
operator|=
operator|&
name|stack
index|[
literal|0
index|]
expr_stmt|;
name|v2
operator|=
operator|&
name|stack
index|[
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|v1
operator|->
name|v_type
operator|==
name|V_ADDR
condition|)
name|v1
operator|=
name|v1
operator|->
name|v_addr
expr_stmt|;
if|if
condition|(
name|v2
operator|->
name|v_type
operator|==
name|V_ADDR
condition|)
name|v2
operator|=
name|v2
operator|->
name|v_addr
expr_stmt|;
if|if
condition|(
operator|(
name|v1
operator|->
name|v_type
operator|!=
name|V_NUM
operator|)
operator|||
operator|(
name|v2
operator|->
name|v_type
operator|!=
name|V_NUM
operator|)
condition|)
block|{
name|scalevalue
argument_list|(
name|v2
argument_list|,
name|v1
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
name|freevalue
argument_list|(
name|stack
operator|--
argument_list|)
expr_stmt|;
name|freevalue
argument_list|(
name|stack
argument_list|)
expr_stmt|;
operator|*
name|stack
operator|=
name|tmp
expr_stmt|;
return|return;
block|}
name|q
operator|=
name|v1
operator|->
name|v_num
expr_stmt|;
if|if
condition|(
name|qisfrac
argument_list|(
name|q
argument_list|)
condition|)
name|math_error
argument_list|(
literal|"Non-integral scaling factor"
argument_list|)
expr_stmt|;
if|if
condition|(
name|zisbig
argument_list|(
name|q
operator|->
name|num
argument_list|)
condition|)
name|math_error
argument_list|(
literal|"Very large scaling factor"
argument_list|)
expr_stmt|;
name|q
operator|=
name|qscale
argument_list|(
name|v2
operator|->
name|v_num
argument_list|,
name|qtoi
argument_list|(
name|q
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|stack
operator|->
name|v_type
operator|==
name|V_NUM
condition|)
name|qfree
argument_list|(
name|stack
operator|->
name|v_num
argument_list|)
expr_stmt|;
name|stack
operator|--
expr_stmt|;
if|if
condition|(
name|stack
operator|->
name|v_type
operator|==
name|V_NUM
condition|)
name|qfree
argument_list|(
name|stack
operator|->
name|v_num
argument_list|)
expr_stmt|;
name|stack
operator|->
name|v_num
operator|=
name|q
expr_stmt|;
name|stack
operator|->
name|v_type
operator|=
name|V_NUM
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|o_int
parameter_list|()
block|{
name|VALUE
modifier|*
name|vp
decl_stmt|;
name|NUMBER
modifier|*
name|q
decl_stmt|;
name|VALUE
name|tmp
decl_stmt|;
name|vp
operator|=
name|stack
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|==
name|V_ADDR
condition|)
name|vp
operator|=
name|vp
operator|->
name|v_addr
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|==
name|V_NUM
condition|)
block|{
if|if
condition|(
name|qisint
argument_list|(
name|vp
operator|->
name|v_num
argument_list|)
operator|&&
operator|(
name|stack
operator|->
name|v_type
operator|==
name|V_NUM
operator|)
condition|)
return|return;
name|q
operator|=
name|qint
argument_list|(
name|vp
operator|->
name|v_num
argument_list|)
expr_stmt|;
if|if
condition|(
name|stack
operator|->
name|v_type
operator|==
name|V_NUM
condition|)
name|qfree
argument_list|(
name|stack
operator|->
name|v_num
argument_list|)
expr_stmt|;
name|stack
operator|->
name|v_num
operator|=
name|q
expr_stmt|;
name|stack
operator|->
name|v_type
operator|=
name|V_NUM
expr_stmt|;
return|return;
block|}
name|intvalue
argument_list|(
name|vp
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
name|freevalue
argument_list|(
name|stack
argument_list|)
expr_stmt|;
operator|*
name|stack
operator|=
name|tmp
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|o_frac
parameter_list|()
block|{
name|VALUE
modifier|*
name|vp
decl_stmt|;
name|NUMBER
modifier|*
name|q
decl_stmt|;
name|VALUE
name|tmp
decl_stmt|;
name|vp
operator|=
name|stack
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|==
name|V_ADDR
condition|)
name|vp
operator|=
name|vp
operator|->
name|v_addr
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|==
name|V_NUM
condition|)
block|{
name|q
operator|=
name|qfrac
argument_list|(
name|vp
operator|->
name|v_num
argument_list|)
expr_stmt|;
if|if
condition|(
name|stack
operator|->
name|v_type
operator|==
name|V_NUM
condition|)
name|qfree
argument_list|(
name|stack
operator|->
name|v_num
argument_list|)
expr_stmt|;
name|stack
operator|->
name|v_num
operator|=
name|q
expr_stmt|;
name|stack
operator|->
name|v_type
operator|=
name|V_NUM
expr_stmt|;
return|return;
block|}
name|fracvalue
argument_list|(
name|vp
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
name|freevalue
argument_list|(
name|stack
argument_list|)
expr_stmt|;
operator|*
name|stack
operator|=
name|tmp
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|o_abs
parameter_list|()
block|{
name|VALUE
modifier|*
name|v1
decl_stmt|,
modifier|*
name|v2
decl_stmt|;
name|NUMBER
modifier|*
name|q
decl_stmt|;
name|VALUE
name|tmp
decl_stmt|;
name|v1
operator|=
operator|&
name|stack
index|[
operator|-
literal|1
index|]
expr_stmt|;
name|v2
operator|=
operator|&
name|stack
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|v1
operator|->
name|v_type
operator|==
name|V_ADDR
condition|)
name|v1
operator|=
name|v1
operator|->
name|v_addr
expr_stmt|;
if|if
condition|(
name|v2
operator|->
name|v_type
operator|==
name|V_ADDR
condition|)
name|v2
operator|=
name|v2
operator|->
name|v_addr
expr_stmt|;
if|if
condition|(
operator|(
name|v1
operator|->
name|v_type
operator|!=
name|V_NUM
operator|)
operator|||
operator|(
name|v2
operator|->
name|v_type
operator|!=
name|V_NUM
operator|)
operator|||
operator|!
name|qispos
argument_list|(
name|v2
operator|->
name|v_num
argument_list|)
condition|)
block|{
name|absvalue
argument_list|(
name|v1
argument_list|,
name|v2
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
name|freevalue
argument_list|(
name|stack
operator|--
argument_list|)
expr_stmt|;
name|freevalue
argument_list|(
name|stack
argument_list|)
expr_stmt|;
operator|*
name|stack
operator|=
name|tmp
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|stack
operator|->
name|v_type
operator|==
name|V_NUM
condition|)
name|qfree
argument_list|(
name|stack
operator|->
name|v_num
argument_list|)
expr_stmt|;
name|stack
operator|--
expr_stmt|;
if|if
condition|(
operator|(
name|stack
operator|->
name|v_type
operator|==
name|V_NUM
operator|)
operator|&&
operator|!
name|qisneg
argument_list|(
name|v1
operator|->
name|v_num
argument_list|)
condition|)
return|return;
name|q
operator|=
name|qabs
argument_list|(
name|v1
operator|->
name|v_num
argument_list|)
expr_stmt|;
if|if
condition|(
name|stack
operator|->
name|v_type
operator|==
name|V_NUM
condition|)
name|qfree
argument_list|(
name|stack
operator|->
name|v_num
argument_list|)
expr_stmt|;
name|stack
operator|->
name|v_num
operator|=
name|q
expr_stmt|;
name|stack
operator|->
name|v_type
operator|=
name|V_NUM
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|o_norm
parameter_list|()
block|{
name|VALUE
modifier|*
name|vp
decl_stmt|;
name|NUMBER
modifier|*
name|q
decl_stmt|;
name|VALUE
name|tmp
decl_stmt|;
name|vp
operator|=
name|stack
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|==
name|V_ADDR
condition|)
name|vp
operator|=
name|vp
operator|->
name|v_addr
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|==
name|V_NUM
condition|)
block|{
name|q
operator|=
name|qsquare
argument_list|(
name|vp
operator|->
name|v_num
argument_list|)
expr_stmt|;
if|if
condition|(
name|stack
operator|->
name|v_type
operator|==
name|V_NUM
condition|)
name|qfree
argument_list|(
name|stack
operator|->
name|v_num
argument_list|)
expr_stmt|;
name|stack
operator|->
name|v_num
operator|=
name|q
expr_stmt|;
name|stack
operator|->
name|v_type
operator|=
name|V_NUM
expr_stmt|;
return|return;
block|}
name|normvalue
argument_list|(
name|vp
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
name|freevalue
argument_list|(
name|stack
argument_list|)
expr_stmt|;
operator|*
name|stack
operator|=
name|tmp
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|o_square
parameter_list|()
block|{
name|VALUE
modifier|*
name|vp
decl_stmt|;
name|NUMBER
modifier|*
name|q
decl_stmt|;
name|VALUE
name|tmp
decl_stmt|;
name|vp
operator|=
name|stack
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|==
name|V_ADDR
condition|)
name|vp
operator|=
name|vp
operator|->
name|v_addr
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|==
name|V_NUM
condition|)
block|{
name|q
operator|=
name|qsquare
argument_list|(
name|vp
operator|->
name|v_num
argument_list|)
expr_stmt|;
if|if
condition|(
name|stack
operator|->
name|v_type
operator|==
name|V_NUM
condition|)
name|qfree
argument_list|(
name|stack
operator|->
name|v_num
argument_list|)
expr_stmt|;
name|stack
operator|->
name|v_num
operator|=
name|q
expr_stmt|;
name|stack
operator|->
name|v_type
operator|=
name|V_NUM
expr_stmt|;
return|return;
block|}
name|squarevalue
argument_list|(
name|vp
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
name|freevalue
argument_list|(
name|stack
argument_list|)
expr_stmt|;
operator|*
name|stack
operator|=
name|tmp
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|o_istype
parameter_list|()
block|{
name|VALUE
modifier|*
name|v1
decl_stmt|,
modifier|*
name|v2
decl_stmt|;
name|int
name|r
decl_stmt|;
name|v1
operator|=
operator|&
name|stack
index|[
operator|-
literal|1
index|]
expr_stmt|;
name|v2
operator|=
operator|&
name|stack
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|v1
operator|->
name|v_type
operator|==
name|V_ADDR
condition|)
name|v1
operator|=
name|v1
operator|->
name|v_addr
expr_stmt|;
if|if
condition|(
name|v2
operator|->
name|v_type
operator|==
name|V_ADDR
condition|)
name|v2
operator|=
name|v2
operator|->
name|v_addr
expr_stmt|;
if|if
condition|(
operator|(
name|v1
operator|->
name|v_type
operator|!=
name|V_OBJ
operator|)
operator|||
operator|(
name|v2
operator|->
name|v_type
operator|!=
name|V_OBJ
operator|)
condition|)
name|r
operator|=
operator|(
name|v1
operator|->
name|v_type
operator|==
name|v2
operator|->
name|v_type
operator|)
expr_stmt|;
else|else
name|r
operator|=
operator|(
name|v1
operator|->
name|v_obj
operator|->
name|o_actions
operator|==
name|v2
operator|->
name|v_obj
operator|->
name|o_actions
operator|)
expr_stmt|;
name|freevalue
argument_list|(
name|stack
operator|--
argument_list|)
expr_stmt|;
name|freevalue
argument_list|(
name|stack
argument_list|)
expr_stmt|;
name|stack
operator|->
name|v_num
operator|=
name|itoq
argument_list|(
operator|(
name|long
operator|)
name|r
argument_list|)
expr_stmt|;
name|stack
operator|->
name|v_type
operator|=
name|V_NUM
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|o_isint
parameter_list|()
block|{
name|VALUE
modifier|*
name|vp
decl_stmt|;
name|NUMBER
modifier|*
name|q
decl_stmt|;
name|vp
operator|=
name|stack
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|==
name|V_ADDR
condition|)
name|vp
operator|=
name|stack
operator|->
name|v_addr
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|!=
name|V_NUM
condition|)
block|{
name|freevalue
argument_list|(
name|stack
argument_list|)
expr_stmt|;
name|stack
operator|->
name|v_num
operator|=
name|qlink
argument_list|(
operator|&
name|_qzero_
argument_list|)
expr_stmt|;
name|stack
operator|->
name|v_type
operator|=
name|V_NUM
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|qisint
argument_list|(
name|vp
operator|->
name|v_num
argument_list|)
condition|)
name|q
operator|=
name|qlink
argument_list|(
operator|&
name|_qone_
argument_list|)
expr_stmt|;
else|else
name|q
operator|=
name|qlink
argument_list|(
operator|&
name|_qzero_
argument_list|)
expr_stmt|;
if|if
condition|(
name|stack
operator|->
name|v_type
operator|==
name|V_NUM
condition|)
name|qfree
argument_list|(
name|stack
operator|->
name|v_num
argument_list|)
expr_stmt|;
name|stack
operator|->
name|v_num
operator|=
name|q
expr_stmt|;
name|stack
operator|->
name|v_type
operator|=
name|V_NUM
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|o_isnum
parameter_list|()
block|{
name|VALUE
modifier|*
name|vp
decl_stmt|;
name|vp
operator|=
name|stack
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|==
name|V_ADDR
condition|)
name|vp
operator|=
name|vp
operator|->
name|v_addr
expr_stmt|;
switch|switch
condition|(
name|vp
operator|->
name|v_type
condition|)
block|{
case|case
name|V_NUM
case|:
if|if
condition|(
name|stack
operator|->
name|v_type
operator|==
name|V_NUM
condition|)
name|qfree
argument_list|(
name|stack
operator|->
name|v_num
argument_list|)
expr_stmt|;
break|break;
case|case
name|V_COM
case|:
if|if
condition|(
name|stack
operator|->
name|v_type
operator|==
name|V_COM
condition|)
name|comfree
argument_list|(
name|stack
operator|->
name|v_com
argument_list|)
expr_stmt|;
break|break;
default|default:
name|freevalue
argument_list|(
name|stack
argument_list|)
expr_stmt|;
name|stack
operator|->
name|v_num
operator|=
name|qlink
argument_list|(
operator|&
name|_qzero_
argument_list|)
expr_stmt|;
name|stack
operator|->
name|v_type
operator|=
name|V_NUM
expr_stmt|;
return|return;
block|}
name|stack
operator|->
name|v_num
operator|=
name|qlink
argument_list|(
operator|&
name|_qone_
argument_list|)
expr_stmt|;
name|stack
operator|->
name|v_type
operator|=
name|V_NUM
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|o_ismat
parameter_list|()
block|{
name|VALUE
modifier|*
name|vp
decl_stmt|;
name|vp
operator|=
name|stack
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|==
name|V_ADDR
condition|)
name|vp
operator|=
name|vp
operator|->
name|v_addr
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|!=
name|V_MAT
condition|)
block|{
name|freevalue
argument_list|(
name|stack
argument_list|)
expr_stmt|;
name|stack
operator|->
name|v_num
operator|=
name|qlink
argument_list|(
operator|&
name|_qzero_
argument_list|)
expr_stmt|;
name|stack
operator|->
name|v_type
operator|=
name|V_NUM
expr_stmt|;
return|return;
block|}
name|freevalue
argument_list|(
name|stack
argument_list|)
expr_stmt|;
name|stack
operator|->
name|v_type
operator|=
name|V_NUM
expr_stmt|;
name|stack
operator|->
name|v_num
operator|=
name|qlink
argument_list|(
operator|&
name|_qone_
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|o_islist
parameter_list|()
block|{
name|VALUE
modifier|*
name|vp
decl_stmt|;
name|int
name|r
decl_stmt|;
name|vp
operator|=
name|stack
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|==
name|V_ADDR
condition|)
name|vp
operator|=
name|vp
operator|->
name|v_addr
expr_stmt|;
name|r
operator|=
operator|(
name|vp
operator|->
name|v_type
operator|==
name|V_LIST
operator|)
expr_stmt|;
name|freevalue
argument_list|(
name|stack
argument_list|)
expr_stmt|;
name|stack
operator|->
name|v_num
operator|=
operator|(
name|r
condition|?
name|qlink
argument_list|(
operator|&
name|_qone_
argument_list|)
else|:
name|qlink
argument_list|(
operator|&
name|_qzero_
argument_list|)
operator|)
expr_stmt|;
name|stack
operator|->
name|v_type
operator|=
name|V_NUM
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|o_isobj
parameter_list|()
block|{
name|VALUE
modifier|*
name|vp
decl_stmt|;
name|int
name|r
decl_stmt|;
name|vp
operator|=
name|stack
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|==
name|V_ADDR
condition|)
name|vp
operator|=
name|vp
operator|->
name|v_addr
expr_stmt|;
name|r
operator|=
operator|(
name|vp
operator|->
name|v_type
operator|==
name|V_OBJ
operator|)
expr_stmt|;
name|freevalue
argument_list|(
name|stack
argument_list|)
expr_stmt|;
name|stack
operator|->
name|v_num
operator|=
operator|(
name|r
condition|?
name|qlink
argument_list|(
operator|&
name|_qone_
argument_list|)
else|:
name|qlink
argument_list|(
operator|&
name|_qzero_
argument_list|)
operator|)
expr_stmt|;
name|stack
operator|->
name|v_type
operator|=
name|V_NUM
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|o_isstr
parameter_list|()
block|{
name|VALUE
modifier|*
name|vp
decl_stmt|;
name|int
name|r
decl_stmt|;
name|vp
operator|=
name|stack
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|==
name|V_ADDR
condition|)
name|vp
operator|=
name|vp
operator|->
name|v_addr
expr_stmt|;
name|r
operator|=
operator|(
name|vp
operator|->
name|v_type
operator|==
name|V_STR
operator|)
expr_stmt|;
name|freevalue
argument_list|(
name|stack
argument_list|)
expr_stmt|;
name|stack
operator|->
name|v_num
operator|=
operator|(
name|r
condition|?
name|qlink
argument_list|(
operator|&
name|_qone_
argument_list|)
else|:
name|qlink
argument_list|(
operator|&
name|_qzero_
argument_list|)
operator|)
expr_stmt|;
name|stack
operator|->
name|v_type
operator|=
name|V_NUM
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|o_isfile
parameter_list|()
block|{
name|VALUE
modifier|*
name|vp
decl_stmt|;
name|int
name|r
decl_stmt|;
name|vp
operator|=
name|stack
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|==
name|V_ADDR
condition|)
name|vp
operator|=
name|vp
operator|->
name|v_addr
expr_stmt|;
name|r
operator|=
operator|(
name|vp
operator|->
name|v_type
operator|==
name|V_FILE
operator|)
expr_stmt|;
name|freevalue
argument_list|(
name|stack
argument_list|)
expr_stmt|;
name|stack
operator|->
name|v_num
operator|=
operator|(
name|r
condition|?
name|qlink
argument_list|(
operator|&
name|_qone_
argument_list|)
else|:
name|qlink
argument_list|(
operator|&
name|_qzero_
argument_list|)
operator|)
expr_stmt|;
name|stack
operator|->
name|v_type
operator|=
name|V_NUM
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|o_isassoc
parameter_list|()
block|{
name|VALUE
modifier|*
name|vp
decl_stmt|;
name|int
name|r
decl_stmt|;
name|vp
operator|=
name|stack
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|==
name|V_ADDR
condition|)
name|vp
operator|=
name|vp
operator|->
name|v_addr
expr_stmt|;
name|r
operator|=
operator|(
name|vp
operator|->
name|v_type
operator|==
name|V_ASSOC
operator|)
expr_stmt|;
name|freevalue
argument_list|(
name|stack
argument_list|)
expr_stmt|;
name|stack
operator|->
name|v_num
operator|=
operator|(
name|r
condition|?
name|qlink
argument_list|(
operator|&
name|_qone_
argument_list|)
else|:
name|qlink
argument_list|(
operator|&
name|_qzero_
argument_list|)
operator|)
expr_stmt|;
name|stack
operator|->
name|v_type
operator|=
name|V_NUM
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|o_issimple
parameter_list|()
block|{
name|VALUE
modifier|*
name|vp
decl_stmt|;
name|int
name|r
decl_stmt|;
name|vp
operator|=
name|stack
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|==
name|V_ADDR
condition|)
name|vp
operator|=
name|vp
operator|->
name|v_addr
expr_stmt|;
name|r
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|vp
operator|->
name|v_type
condition|)
block|{
case|case
name|V_NULL
case|:
case|case
name|V_NUM
case|:
case|case
name|V_COM
case|:
case|case
name|V_STR
case|:
name|r
operator|=
literal|1
expr_stmt|;
block|}
name|freevalue
argument_list|(
name|stack
argument_list|)
expr_stmt|;
name|stack
operator|->
name|v_num
operator|=
operator|(
name|r
condition|?
name|qlink
argument_list|(
operator|&
name|_qone_
argument_list|)
else|:
name|qlink
argument_list|(
operator|&
name|_qzero_
argument_list|)
operator|)
expr_stmt|;
name|stack
operator|->
name|v_type
operator|=
name|V_NUM
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|o_isodd
parameter_list|()
block|{
name|VALUE
modifier|*
name|vp
decl_stmt|;
name|vp
operator|=
name|stack
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|==
name|V_ADDR
condition|)
name|vp
operator|=
name|vp
operator|->
name|v_addr
expr_stmt|;
if|if
condition|(
operator|(
name|vp
operator|->
name|v_type
operator|==
name|V_NUM
operator|)
operator|&&
name|qisodd
argument_list|(
name|vp
operator|->
name|v_num
argument_list|)
condition|)
block|{
if|if
condition|(
name|stack
operator|->
name|v_type
operator|==
name|V_NUM
condition|)
name|qfree
argument_list|(
name|stack
operator|->
name|v_num
argument_list|)
expr_stmt|;
name|stack
operator|->
name|v_num
operator|=
name|qlink
argument_list|(
operator|&
name|_qone_
argument_list|)
expr_stmt|;
name|stack
operator|->
name|v_type
operator|=
name|V_NUM
expr_stmt|;
return|return;
block|}
name|freevalue
argument_list|(
name|stack
argument_list|)
expr_stmt|;
name|stack
operator|->
name|v_num
operator|=
name|qlink
argument_list|(
operator|&
name|_qzero_
argument_list|)
expr_stmt|;
name|stack
operator|->
name|v_type
operator|=
name|V_NUM
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|o_iseven
parameter_list|()
block|{
name|VALUE
modifier|*
name|vp
decl_stmt|;
name|vp
operator|=
name|stack
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|==
name|V_ADDR
condition|)
name|vp
operator|=
name|vp
operator|->
name|v_addr
expr_stmt|;
if|if
condition|(
operator|(
name|vp
operator|->
name|v_type
operator|==
name|V_NUM
operator|)
operator|&&
name|qiseven
argument_list|(
name|vp
operator|->
name|v_num
argument_list|)
condition|)
block|{
if|if
condition|(
name|stack
operator|->
name|v_type
operator|==
name|V_NUM
condition|)
name|qfree
argument_list|(
name|stack
operator|->
name|v_num
argument_list|)
expr_stmt|;
name|stack
operator|->
name|v_num
operator|=
name|qlink
argument_list|(
operator|&
name|_qone_
argument_list|)
expr_stmt|;
name|stack
operator|->
name|v_type
operator|=
name|V_NUM
expr_stmt|;
return|return;
block|}
name|freevalue
argument_list|(
name|stack
argument_list|)
expr_stmt|;
name|stack
operator|->
name|v_num
operator|=
name|qlink
argument_list|(
operator|&
name|_qzero_
argument_list|)
expr_stmt|;
name|stack
operator|->
name|v_type
operator|=
name|V_NUM
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|o_isreal
parameter_list|()
block|{
name|VALUE
modifier|*
name|vp
decl_stmt|;
name|vp
operator|=
name|stack
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|==
name|V_ADDR
condition|)
name|vp
operator|=
name|vp
operator|->
name|v_addr
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|==
name|V_NUM
condition|)
block|{
if|if
condition|(
name|stack
operator|->
name|v_type
operator|==
name|V_NUM
condition|)
name|qfree
argument_list|(
name|stack
operator|->
name|v_num
argument_list|)
expr_stmt|;
name|stack
operator|->
name|v_num
operator|=
name|qlink
argument_list|(
operator|&
name|_qone_
argument_list|)
expr_stmt|;
name|stack
operator|->
name|v_type
operator|=
name|V_NUM
expr_stmt|;
return|return;
block|}
name|freevalue
argument_list|(
name|stack
argument_list|)
expr_stmt|;
name|stack
operator|->
name|v_num
operator|=
name|qlink
argument_list|(
operator|&
name|_qzero_
argument_list|)
expr_stmt|;
name|stack
operator|->
name|v_type
operator|=
name|V_NUM
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|o_isnull
parameter_list|()
block|{
name|VALUE
modifier|*
name|vp
decl_stmt|;
name|vp
operator|=
name|stack
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|==
name|V_ADDR
condition|)
name|vp
operator|=
name|vp
operator|->
name|v_addr
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|!=
name|V_NULL
condition|)
block|{
name|freevalue
argument_list|(
name|stack
argument_list|)
expr_stmt|;
name|stack
operator|->
name|v_num
operator|=
name|qlink
argument_list|(
operator|&
name|_qzero_
argument_list|)
expr_stmt|;
name|stack
operator|->
name|v_type
operator|=
name|V_NUM
expr_stmt|;
return|return;
block|}
name|freevalue
argument_list|(
name|stack
argument_list|)
expr_stmt|;
name|stack
operator|->
name|v_num
operator|=
name|qlink
argument_list|(
operator|&
name|_qone_
argument_list|)
expr_stmt|;
name|stack
operator|->
name|v_type
operator|=
name|V_NUM
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|o_re
parameter_list|()
block|{
name|VALUE
modifier|*
name|vp
decl_stmt|;
name|NUMBER
modifier|*
name|q
decl_stmt|;
name|vp
operator|=
name|stack
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|==
name|V_ADDR
condition|)
name|vp
operator|=
name|vp
operator|->
name|v_addr
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|==
name|V_NUM
condition|)
block|{
if|if
condition|(
name|stack
operator|->
name|v_type
operator|==
name|V_ADDR
condition|)
block|{
name|stack
operator|->
name|v_num
operator|=
name|qlink
argument_list|(
name|vp
operator|->
name|v_num
argument_list|)
expr_stmt|;
name|stack
operator|->
name|v_type
operator|=
name|V_NUM
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
name|vp
operator|->
name|v_type
operator|!=
name|V_COM
condition|)
name|math_error
argument_list|(
literal|"Taking real part of non-number"
argument_list|)
expr_stmt|;
name|q
operator|=
name|qlink
argument_list|(
name|vp
operator|->
name|v_com
operator|->
name|real
argument_list|)
expr_stmt|;
if|if
condition|(
name|stack
operator|->
name|v_type
operator|==
name|V_COM
condition|)
name|comfree
argument_list|(
name|stack
operator|->
name|v_com
argument_list|)
expr_stmt|;
name|stack
operator|->
name|v_num
operator|=
name|q
expr_stmt|;
name|stack
operator|->
name|v_type
operator|=
name|V_NUM
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|o_im
parameter_list|()
block|{
name|VALUE
modifier|*
name|vp
decl_stmt|;
name|NUMBER
modifier|*
name|q
decl_stmt|;
name|vp
operator|=
name|stack
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|==
name|V_ADDR
condition|)
name|vp
operator|=
name|vp
operator|->
name|v_addr
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|==
name|V_NUM
condition|)
block|{
if|if
condition|(
name|stack
operator|->
name|v_type
operator|==
name|V_NUM
condition|)
name|qfree
argument_list|(
name|stack
operator|->
name|v_num
argument_list|)
expr_stmt|;
name|stack
operator|->
name|v_num
operator|=
name|qlink
argument_list|(
operator|&
name|_qzero_
argument_list|)
expr_stmt|;
name|stack
operator|->
name|v_type
operator|=
name|V_NUM
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|vp
operator|->
name|v_type
operator|!=
name|V_COM
condition|)
name|math_error
argument_list|(
literal|"Taking imaginary part of non-number"
argument_list|)
expr_stmt|;
name|q
operator|=
name|qlink
argument_list|(
name|vp
operator|->
name|v_com
operator|->
name|imag
argument_list|)
expr_stmt|;
if|if
condition|(
name|stack
operator|->
name|v_type
operator|==
name|V_COM
condition|)
name|comfree
argument_list|(
name|stack
operator|->
name|v_com
argument_list|)
expr_stmt|;
name|stack
operator|->
name|v_num
operator|=
name|q
expr_stmt|;
name|stack
operator|->
name|v_type
operator|=
name|V_NUM
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|o_conjugate
parameter_list|()
block|{
name|VALUE
modifier|*
name|vp
decl_stmt|;
name|VALUE
name|tmp
decl_stmt|;
name|vp
operator|=
name|stack
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|==
name|V_ADDR
condition|)
name|vp
operator|=
name|vp
operator|->
name|v_addr
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|==
name|V_NUM
condition|)
block|{
if|if
condition|(
name|stack
operator|->
name|v_type
operator|==
name|V_ADDR
condition|)
block|{
name|stack
operator|->
name|v_num
operator|=
name|qlink
argument_list|(
name|vp
operator|->
name|v_num
argument_list|)
expr_stmt|;
name|stack
operator|->
name|v_type
operator|=
name|V_NUM
expr_stmt|;
block|}
return|return;
block|}
name|conjvalue
argument_list|(
name|vp
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
name|freevalue
argument_list|(
name|stack
argument_list|)
expr_stmt|;
operator|*
name|stack
operator|=
name|tmp
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|o_fiaddr
parameter_list|()
block|{
specifier|register
name|MATRIX
modifier|*
name|m
decl_stmt|;
comment|/* current matrix element */
name|NUMBER
modifier|*
name|q
decl_stmt|;
comment|/* index value */
name|LIST
modifier|*
name|lp
decl_stmt|;
comment|/* list header */
name|ASSOC
modifier|*
name|ap
decl_stmt|;
comment|/* association header */
name|VALUE
modifier|*
name|vp
decl_stmt|;
comment|/* stack value */
name|long
name|index
decl_stmt|;
comment|/* index value as an integer */
name|vp
operator|=
name|stack
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|==
name|V_ADDR
condition|)
name|vp
operator|=
name|vp
operator|->
name|v_addr
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|!=
name|V_NUM
condition|)
name|math_error
argument_list|(
literal|"Fast indexing by non-number"
argument_list|)
expr_stmt|;
name|q
operator|=
name|vp
operator|->
name|v_num
expr_stmt|;
if|if
condition|(
name|qisfrac
argument_list|(
name|q
argument_list|)
condition|)
name|math_error
argument_list|(
literal|"Fast indexing by non-integer"
argument_list|)
expr_stmt|;
name|index
operator|=
name|qtoi
argument_list|(
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
name|zisbig
argument_list|(
name|q
operator|->
name|num
argument_list|)
operator|||
operator|(
name|index
operator|<
literal|0
operator|)
condition|)
name|math_error
argument_list|(
literal|"Index out of range for fast indexing"
argument_list|)
expr_stmt|;
if|if
condition|(
name|stack
operator|->
name|v_type
operator|==
name|V_NUM
condition|)
name|qfree
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|stack
operator|--
expr_stmt|;
name|vp
operator|=
name|stack
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|!=
name|V_ADDR
condition|)
name|math_error
argument_list|(
literal|"Bad value for fast indexing"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|vp
operator|->
name|v_addr
operator|->
name|v_type
condition|)
block|{
case|case
name|V_OBJ
case|:
if|if
condition|(
name|index
operator|>=
name|vp
operator|->
name|v_addr
operator|->
name|v_obj
operator|->
name|o_actions
operator|->
name|count
condition|)
name|math_error
argument_list|(
literal|"Index out of bounds for object"
argument_list|)
expr_stmt|;
name|vp
operator|->
name|v_addr
operator|=
name|vp
operator|->
name|v_addr
operator|->
name|v_obj
operator|->
name|o_table
operator|+
name|index
expr_stmt|;
break|break;
case|case
name|V_MAT
case|:
name|m
operator|=
name|vp
operator|->
name|v_addr
operator|->
name|v_mat
expr_stmt|;
if|if
condition|(
name|index
operator|>=
name|m
operator|->
name|m_size
condition|)
name|math_error
argument_list|(
literal|"Index out of bounds for matrix"
argument_list|)
expr_stmt|;
name|vp
operator|->
name|v_addr
operator|=
name|m
operator|->
name|m_table
operator|+
name|index
expr_stmt|;
break|break;
case|case
name|V_LIST
case|:
name|lp
operator|=
name|vp
operator|->
name|v_addr
operator|->
name|v_list
expr_stmt|;
name|vp
operator|->
name|v_addr
operator|=
name|listfindex
argument_list|(
name|lp
argument_list|,
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_addr
operator|==
name|NULL
condition|)
name|math_error
argument_list|(
literal|"Index out of bounds for list"
argument_list|)
expr_stmt|;
break|break;
case|case
name|V_ASSOC
case|:
name|ap
operator|=
name|vp
operator|->
name|v_addr
operator|->
name|v_assoc
expr_stmt|;
name|vp
operator|->
name|v_addr
operator|=
name|assocfindex
argument_list|(
name|ap
argument_list|,
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_addr
operator|==
name|NULL
condition|)
name|math_error
argument_list|(
literal|"Index out of bounds for association"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|math_error
argument_list|(
literal|"Bad variable type for fast indexing"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|o_fivalue
parameter_list|()
block|{
operator|(
name|void
operator|)
name|o_fiaddr
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|o_getvalue
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|o_sgn
parameter_list|()
block|{
name|VALUE
modifier|*
name|vp
decl_stmt|;
name|NUMBER
modifier|*
name|q
decl_stmt|;
name|VALUE
name|val
decl_stmt|;
name|vp
operator|=
name|stack
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|==
name|V_ADDR
condition|)
name|vp
operator|=
name|vp
operator|->
name|v_addr
expr_stmt|;
switch|switch
condition|(
name|vp
operator|->
name|v_type
condition|)
block|{
case|case
name|V_NUM
case|:
name|q
operator|=
name|qsign
argument_list|(
name|vp
operator|->
name|v_num
argument_list|)
expr_stmt|;
if|if
condition|(
name|stack
operator|->
name|v_type
operator|==
name|V_NUM
condition|)
name|qfree
argument_list|(
name|vp
operator|->
name|v_num
argument_list|)
expr_stmt|;
name|stack
operator|->
name|v_num
operator|=
name|q
expr_stmt|;
name|stack
operator|->
name|v_type
operator|=
name|V_NUM
expr_stmt|;
break|break;
case|case
name|V_OBJ
case|:
name|val
operator|=
name|objcall
argument_list|(
name|OBJ_SGN
argument_list|,
name|vp
argument_list|,
name|NULL_VALUE
argument_list|,
name|NULL_VALUE
argument_list|)
expr_stmt|;
name|q
operator|=
name|itoq
argument_list|(
name|val
operator|.
name|v_int
argument_list|)
expr_stmt|;
name|freevalue
argument_list|(
name|stack
argument_list|)
expr_stmt|;
name|stack
operator|->
name|v_num
operator|=
name|q
expr_stmt|;
name|stack
operator|->
name|v_type
operator|=
name|V_NUM
expr_stmt|;
break|break;
default|default:
name|math_error
argument_list|(
literal|"Bad value for sgn"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|o_numerator
parameter_list|()
block|{
name|VALUE
modifier|*
name|vp
decl_stmt|;
name|NUMBER
modifier|*
name|q
decl_stmt|;
name|vp
operator|=
name|stack
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|==
name|V_ADDR
condition|)
name|vp
operator|=
name|vp
operator|->
name|v_addr
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|!=
name|V_NUM
condition|)
name|math_error
argument_list|(
literal|"Numerator of non-number"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|stack
operator|->
name|v_type
operator|==
name|V_NUM
operator|)
operator|&&
name|qisint
argument_list|(
name|vp
operator|->
name|v_num
argument_list|)
condition|)
return|return;
name|q
operator|=
name|qnum
argument_list|(
name|vp
operator|->
name|v_num
argument_list|)
expr_stmt|;
if|if
condition|(
name|stack
operator|->
name|v_type
operator|==
name|V_NUM
condition|)
name|qfree
argument_list|(
name|stack
operator|->
name|v_num
argument_list|)
expr_stmt|;
name|stack
operator|->
name|v_num
operator|=
name|q
expr_stmt|;
name|stack
operator|->
name|v_type
operator|=
name|V_NUM
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|o_denominator
parameter_list|()
block|{
name|VALUE
modifier|*
name|vp
decl_stmt|;
name|NUMBER
modifier|*
name|q
decl_stmt|;
name|vp
operator|=
name|stack
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|==
name|V_ADDR
condition|)
name|vp
operator|=
name|vp
operator|->
name|v_addr
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|!=
name|V_NUM
condition|)
name|math_error
argument_list|(
literal|"Denominator of non-number"
argument_list|)
expr_stmt|;
name|q
operator|=
name|qden
argument_list|(
name|vp
operator|->
name|v_num
argument_list|)
expr_stmt|;
if|if
condition|(
name|stack
operator|->
name|v_type
operator|==
name|V_NUM
condition|)
name|qfree
argument_list|(
name|stack
operator|->
name|v_num
argument_list|)
expr_stmt|;
name|stack
operator|->
name|v_num
operator|=
name|q
expr_stmt|;
name|stack
operator|->
name|v_type
operator|=
name|V_NUM
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|o_duplicate
parameter_list|()
block|{
name|copyvalue
argument_list|(
name|stack
argument_list|,
name|stack
operator|+
literal|1
argument_list|)
expr_stmt|;
name|stack
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|o_dupvalue
parameter_list|()
block|{
if|if
condition|(
name|stack
operator|->
name|v_type
operator|==
name|V_ADDR
condition|)
name|copyvalue
argument_list|(
name|stack
operator|->
name|v_addr
argument_list|,
name|stack
operator|+
literal|1
argument_list|)
expr_stmt|;
else|else
name|copyvalue
argument_list|(
name|stack
argument_list|,
name|stack
operator|+
literal|1
argument_list|)
expr_stmt|;
name|stack
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|o_pop
parameter_list|()
block|{
name|freevalue
argument_list|(
name|stack
operator|--
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|o_return
parameter_list|()
block|{ }
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|o_jumpeq
parameter_list|(
name|fp
parameter_list|,
name|dojump
parameter_list|)
name|FUNC
modifier|*
name|fp
decl_stmt|;
name|BOOL
modifier|*
name|dojump
decl_stmt|;
block|{
name|VALUE
modifier|*
name|vp
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* result of comparison */
name|vp
operator|=
name|stack
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|==
name|V_ADDR
condition|)
name|vp
operator|=
name|vp
operator|->
name|v_addr
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|==
name|V_NUM
condition|)
block|{
name|i
operator|=
operator|!
name|qiszero
argument_list|(
name|vp
operator|->
name|v_num
argument_list|)
expr_stmt|;
if|if
condition|(
name|stack
operator|->
name|v_type
operator|==
name|V_NUM
condition|)
name|qfree
argument_list|(
name|stack
operator|->
name|v_num
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|i
operator|=
name|testvalue
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|freevalue
argument_list|(
name|stack
argument_list|)
expr_stmt|;
block|}
name|stack
operator|--
expr_stmt|;
if|if
condition|(
operator|!
name|i
condition|)
operator|*
name|dojump
operator|=
name|TRUE
expr_stmt|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|o_jumpne
parameter_list|(
name|fp
parameter_list|,
name|dojump
parameter_list|)
name|FUNC
modifier|*
name|fp
decl_stmt|;
name|BOOL
modifier|*
name|dojump
decl_stmt|;
block|{
name|VALUE
modifier|*
name|vp
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* result of comparison */
name|vp
operator|=
name|stack
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|==
name|V_ADDR
condition|)
name|vp
operator|=
name|vp
operator|->
name|v_addr
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|==
name|V_NUM
condition|)
block|{
name|i
operator|=
operator|!
name|qiszero
argument_list|(
name|vp
operator|->
name|v_num
argument_list|)
expr_stmt|;
if|if
condition|(
name|stack
operator|->
name|v_type
operator|==
name|V_NUM
condition|)
name|qfree
argument_list|(
name|stack
operator|->
name|v_num
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|i
operator|=
name|testvalue
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|freevalue
argument_list|(
name|stack
argument_list|)
expr_stmt|;
block|}
name|stack
operator|--
expr_stmt|;
if|if
condition|(
name|i
condition|)
operator|*
name|dojump
operator|=
name|TRUE
expr_stmt|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|o_condorjump
parameter_list|(
name|fp
parameter_list|,
name|dojump
parameter_list|)
name|FUNC
modifier|*
name|fp
decl_stmt|;
name|BOOL
modifier|*
name|dojump
decl_stmt|;
block|{
name|VALUE
modifier|*
name|vp
decl_stmt|;
name|vp
operator|=
name|stack
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|==
name|V_ADDR
condition|)
name|vp
operator|=
name|vp
operator|->
name|v_addr
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|==
name|V_NUM
condition|)
block|{
if|if
condition|(
operator|!
name|qiszero
argument_list|(
name|vp
operator|->
name|v_num
argument_list|)
condition|)
block|{
operator|*
name|dojump
operator|=
name|TRUE
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|stack
operator|->
name|v_type
operator|==
name|V_NUM
condition|)
name|qfree
argument_list|(
name|stack
operator|->
name|v_num
argument_list|)
expr_stmt|;
name|stack
operator|--
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|testvalue
argument_list|(
name|vp
argument_list|)
condition|)
operator|*
name|dojump
operator|=
name|TRUE
expr_stmt|;
else|else
name|freevalue
argument_list|(
name|stack
operator|--
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|o_condandjump
parameter_list|(
name|fp
parameter_list|,
name|dojump
parameter_list|)
name|FUNC
modifier|*
name|fp
decl_stmt|;
name|BOOL
modifier|*
name|dojump
decl_stmt|;
block|{
name|VALUE
modifier|*
name|vp
decl_stmt|;
name|vp
operator|=
name|stack
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|==
name|V_ADDR
condition|)
name|vp
operator|=
name|vp
operator|->
name|v_addr
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|==
name|V_NUM
condition|)
block|{
if|if
condition|(
name|qiszero
argument_list|(
name|vp
operator|->
name|v_num
argument_list|)
condition|)
block|{
operator|*
name|dojump
operator|=
name|TRUE
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|stack
operator|->
name|v_type
operator|==
name|V_NUM
condition|)
name|qfree
argument_list|(
name|stack
operator|->
name|v_num
argument_list|)
expr_stmt|;
name|stack
operator|--
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|testvalue
argument_list|(
name|vp
argument_list|)
condition|)
operator|*
name|dojump
operator|=
name|TRUE
expr_stmt|;
else|else
name|freevalue
argument_list|(
name|stack
operator|--
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Compare the top two values on the stack for equality and jump if they are  * different, popping off the top element, leaving the first one on the stack.  * If they are equal, pop both values and do not jump.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|o_casejump
parameter_list|(
name|fp
parameter_list|,
name|dojump
parameter_list|)
name|FUNC
modifier|*
name|fp
decl_stmt|;
name|BOOL
modifier|*
name|dojump
decl_stmt|;
block|{
name|VALUE
modifier|*
name|v1
decl_stmt|,
modifier|*
name|v2
decl_stmt|;
name|int
name|r
decl_stmt|;
name|v1
operator|=
operator|&
name|stack
index|[
operator|-
literal|1
index|]
expr_stmt|;
name|v2
operator|=
operator|&
name|stack
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|v1
operator|->
name|v_type
operator|==
name|V_ADDR
condition|)
name|v1
operator|=
name|v1
operator|->
name|v_addr
expr_stmt|;
if|if
condition|(
name|v2
operator|->
name|v_type
operator|==
name|V_ADDR
condition|)
name|v2
operator|=
name|v2
operator|->
name|v_addr
expr_stmt|;
name|r
operator|=
name|comparevalue
argument_list|(
name|v1
argument_list|,
name|v2
argument_list|)
expr_stmt|;
name|freevalue
argument_list|(
name|stack
operator|--
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
operator|*
name|dojump
operator|=
name|TRUE
expr_stmt|;
else|else
name|freevalue
argument_list|(
name|stack
operator|--
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|o_jump
parameter_list|(
name|fp
parameter_list|,
name|dojump
parameter_list|)
name|FUNC
modifier|*
name|fp
decl_stmt|;
name|BOOL
modifier|*
name|dojump
decl_stmt|;
block|{
operator|*
name|dojump
operator|=
name|TRUE
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|o_usercall
parameter_list|(
name|fp
parameter_list|,
name|index
parameter_list|,
name|argcount
parameter_list|)
name|FUNC
modifier|*
name|fp
decl_stmt|;
name|long
name|index
decl_stmt|,
name|argcount
decl_stmt|;
block|{
name|fp
operator|=
name|findfunc
argument_list|(
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
name|math_error
argument_list|(
literal|"Function \"%s\" is undefined"
argument_list|,
name|namefunc
argument_list|(
name|index
argument_list|)
argument_list|)
expr_stmt|;
name|calculate
argument_list|(
name|fp
argument_list|,
operator|(
name|int
operator|)
name|argcount
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|o_call
parameter_list|(
name|fp
parameter_list|,
name|index
parameter_list|,
name|argcount
parameter_list|)
name|FUNC
modifier|*
name|fp
decl_stmt|;
name|long
name|index
decl_stmt|,
name|argcount
decl_stmt|;
block|{
name|VALUE
name|result
decl_stmt|;
name|result
operator|=
name|builtinfunc
argument_list|(
name|index
argument_list|,
operator|(
name|int
operator|)
name|argcount
argument_list|,
name|stack
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|argcount
operator|>=
literal|0
condition|)
name|freevalue
argument_list|(
name|stack
operator|--
argument_list|)
expr_stmt|;
name|stack
operator|++
expr_stmt|;
operator|*
name|stack
operator|=
name|result
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|o_getvalue
parameter_list|()
block|{
if|if
condition|(
name|stack
operator|->
name|v_type
operator|==
name|V_ADDR
condition|)
name|copyvalue
argument_list|(
name|stack
operator|->
name|v_addr
argument_list|,
name|stack
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|o_cmp
parameter_list|()
block|{
name|VALUE
modifier|*
name|v1
decl_stmt|,
modifier|*
name|v2
decl_stmt|;
name|int
name|r
decl_stmt|;
name|v1
operator|=
operator|&
name|stack
index|[
operator|-
literal|1
index|]
expr_stmt|;
name|v2
operator|=
operator|&
name|stack
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|v1
operator|->
name|v_type
operator|==
name|V_ADDR
condition|)
name|v1
operator|=
name|v1
operator|->
name|v_addr
expr_stmt|;
if|if
condition|(
name|v2
operator|->
name|v_type
operator|==
name|V_ADDR
condition|)
name|v2
operator|=
name|v2
operator|->
name|v_addr
expr_stmt|;
name|r
operator|=
name|relvalue
argument_list|(
name|v1
argument_list|,
name|v2
argument_list|)
expr_stmt|;
name|freevalue
argument_list|(
name|stack
operator|--
argument_list|)
expr_stmt|;
name|freevalue
argument_list|(
name|stack
argument_list|)
expr_stmt|;
name|stack
operator|->
name|v_num
operator|=
name|itoq
argument_list|(
operator|(
name|long
operator|)
name|r
argument_list|)
expr_stmt|;
name|stack
operator|->
name|v_type
operator|=
name|V_NUM
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|o_eq
parameter_list|()
block|{
name|VALUE
modifier|*
name|v1
decl_stmt|,
modifier|*
name|v2
decl_stmt|;
name|int
name|r
decl_stmt|;
name|v1
operator|=
operator|&
name|stack
index|[
operator|-
literal|1
index|]
expr_stmt|;
name|v2
operator|=
operator|&
name|stack
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|v1
operator|->
name|v_type
operator|==
name|V_ADDR
condition|)
name|v1
operator|=
name|v1
operator|->
name|v_addr
expr_stmt|;
if|if
condition|(
name|v2
operator|->
name|v_type
operator|==
name|V_ADDR
condition|)
name|v2
operator|=
name|v2
operator|->
name|v_addr
expr_stmt|;
name|r
operator|=
name|comparevalue
argument_list|(
name|v1
argument_list|,
name|v2
argument_list|)
expr_stmt|;
name|freevalue
argument_list|(
name|stack
operator|--
argument_list|)
expr_stmt|;
name|freevalue
argument_list|(
name|stack
argument_list|)
expr_stmt|;
name|stack
operator|->
name|v_num
operator|=
name|itoq
argument_list|(
call|(
name|long
call|)
argument_list|(
name|r
operator|==
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|stack
operator|->
name|v_type
operator|=
name|V_NUM
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|o_ne
parameter_list|()
block|{
name|VALUE
modifier|*
name|v1
decl_stmt|,
modifier|*
name|v2
decl_stmt|;
name|int
name|r
decl_stmt|;
name|v1
operator|=
operator|&
name|stack
index|[
operator|-
literal|1
index|]
expr_stmt|;
name|v2
operator|=
operator|&
name|stack
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|v1
operator|->
name|v_type
operator|==
name|V_ADDR
condition|)
name|v1
operator|=
name|v1
operator|->
name|v_addr
expr_stmt|;
if|if
condition|(
name|v2
operator|->
name|v_type
operator|==
name|V_ADDR
condition|)
name|v2
operator|=
name|v2
operator|->
name|v_addr
expr_stmt|;
name|r
operator|=
name|comparevalue
argument_list|(
name|v1
argument_list|,
name|v2
argument_list|)
expr_stmt|;
name|freevalue
argument_list|(
name|stack
operator|--
argument_list|)
expr_stmt|;
name|freevalue
argument_list|(
name|stack
argument_list|)
expr_stmt|;
name|stack
operator|->
name|v_num
operator|=
name|itoq
argument_list|(
call|(
name|long
call|)
argument_list|(
name|r
operator|!=
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|stack
operator|->
name|v_type
operator|=
name|V_NUM
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|o_le
parameter_list|()
block|{
name|VALUE
modifier|*
name|v1
decl_stmt|,
modifier|*
name|v2
decl_stmt|;
name|int
name|r
decl_stmt|;
name|v1
operator|=
operator|&
name|stack
index|[
operator|-
literal|1
index|]
expr_stmt|;
name|v2
operator|=
operator|&
name|stack
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|v1
operator|->
name|v_type
operator|==
name|V_ADDR
condition|)
name|v1
operator|=
name|v1
operator|->
name|v_addr
expr_stmt|;
if|if
condition|(
name|v2
operator|->
name|v_type
operator|==
name|V_ADDR
condition|)
name|v2
operator|=
name|v2
operator|->
name|v_addr
expr_stmt|;
name|r
operator|=
name|relvalue
argument_list|(
name|v1
argument_list|,
name|v2
argument_list|)
expr_stmt|;
name|freevalue
argument_list|(
name|stack
operator|--
argument_list|)
expr_stmt|;
name|freevalue
argument_list|(
name|stack
argument_list|)
expr_stmt|;
name|stack
operator|->
name|v_num
operator|=
name|itoq
argument_list|(
call|(
name|long
call|)
argument_list|(
name|r
operator|<=
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|stack
operator|->
name|v_type
operator|=
name|V_NUM
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|o_ge
parameter_list|()
block|{
name|VALUE
modifier|*
name|v1
decl_stmt|,
modifier|*
name|v2
decl_stmt|;
name|int
name|r
decl_stmt|;
name|v1
operator|=
operator|&
name|stack
index|[
operator|-
literal|1
index|]
expr_stmt|;
name|v2
operator|=
operator|&
name|stack
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|v1
operator|->
name|v_type
operator|==
name|V_ADDR
condition|)
name|v1
operator|=
name|v1
operator|->
name|v_addr
expr_stmt|;
if|if
condition|(
name|v2
operator|->
name|v_type
operator|==
name|V_ADDR
condition|)
name|v2
operator|=
name|v2
operator|->
name|v_addr
expr_stmt|;
name|r
operator|=
name|relvalue
argument_list|(
name|v1
argument_list|,
name|v2
argument_list|)
expr_stmt|;
name|freevalue
argument_list|(
name|stack
operator|--
argument_list|)
expr_stmt|;
name|freevalue
argument_list|(
name|stack
argument_list|)
expr_stmt|;
name|stack
operator|->
name|v_num
operator|=
name|itoq
argument_list|(
call|(
name|long
call|)
argument_list|(
name|r
operator|>=
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|stack
operator|->
name|v_type
operator|=
name|V_NUM
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|o_lt
parameter_list|()
block|{
name|VALUE
modifier|*
name|v1
decl_stmt|,
modifier|*
name|v2
decl_stmt|;
name|int
name|r
decl_stmt|;
name|v1
operator|=
operator|&
name|stack
index|[
operator|-
literal|1
index|]
expr_stmt|;
name|v2
operator|=
operator|&
name|stack
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|v1
operator|->
name|v_type
operator|==
name|V_ADDR
condition|)
name|v1
operator|=
name|v1
operator|->
name|v_addr
expr_stmt|;
if|if
condition|(
name|v2
operator|->
name|v_type
operator|==
name|V_ADDR
condition|)
name|v2
operator|=
name|v2
operator|->
name|v_addr
expr_stmt|;
name|r
operator|=
name|relvalue
argument_list|(
name|v1
argument_list|,
name|v2
argument_list|)
expr_stmt|;
name|freevalue
argument_list|(
name|stack
operator|--
argument_list|)
expr_stmt|;
name|freevalue
argument_list|(
name|stack
argument_list|)
expr_stmt|;
name|stack
operator|->
name|v_num
operator|=
name|itoq
argument_list|(
call|(
name|long
call|)
argument_list|(
name|r
operator|<
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|stack
operator|->
name|v_type
operator|=
name|V_NUM
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|o_gt
parameter_list|()
block|{
name|VALUE
modifier|*
name|v1
decl_stmt|,
modifier|*
name|v2
decl_stmt|;
name|int
name|r
decl_stmt|;
name|v1
operator|=
operator|&
name|stack
index|[
operator|-
literal|1
index|]
expr_stmt|;
name|v2
operator|=
operator|&
name|stack
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|v1
operator|->
name|v_type
operator|==
name|V_ADDR
condition|)
name|v1
operator|=
name|v1
operator|->
name|v_addr
expr_stmt|;
if|if
condition|(
name|v2
operator|->
name|v_type
operator|==
name|V_ADDR
condition|)
name|v2
operator|=
name|v2
operator|->
name|v_addr
expr_stmt|;
name|r
operator|=
name|relvalue
argument_list|(
name|v1
argument_list|,
name|v2
argument_list|)
expr_stmt|;
name|freevalue
argument_list|(
name|stack
operator|--
argument_list|)
expr_stmt|;
name|freevalue
argument_list|(
name|stack
argument_list|)
expr_stmt|;
name|stack
operator|->
name|v_num
operator|=
name|itoq
argument_list|(
call|(
name|long
call|)
argument_list|(
name|r
operator|>
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|stack
operator|->
name|v_type
operator|=
name|V_NUM
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|o_preinc
parameter_list|()
block|{
name|NUMBER
modifier|*
name|q
decl_stmt|,
modifier|*
modifier|*
name|np
decl_stmt|;
name|VALUE
modifier|*
name|vp
decl_stmt|,
name|tmp
decl_stmt|;
if|if
condition|(
name|stack
operator|->
name|v_type
operator|!=
name|V_ADDR
condition|)
name|math_error
argument_list|(
literal|"Preincrementing non-variable"
argument_list|)
expr_stmt|;
if|if
condition|(
name|stack
operator|->
name|v_addr
operator|->
name|v_type
operator|==
name|V_NUM
condition|)
block|{
name|np
operator|=
operator|&
name|stack
operator|->
name|v_addr
operator|->
name|v_num
expr_stmt|;
name|q
operator|=
name|qinc
argument_list|(
operator|*
name|np
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
operator|*
name|np
argument_list|)
expr_stmt|;
operator|*
name|np
operator|=
name|q
expr_stmt|;
name|stack
operator|->
name|v_type
operator|=
name|V_NUM
expr_stmt|;
name|stack
operator|->
name|v_num
operator|=
name|qlink
argument_list|(
name|q
argument_list|)
expr_stmt|;
return|return;
block|}
name|vp
operator|=
name|stack
operator|->
name|v_addr
expr_stmt|;
name|incvalue
argument_list|(
name|vp
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
name|freevalue
argument_list|(
name|vp
argument_list|)
expr_stmt|;
operator|*
name|vp
operator|=
name|tmp
expr_stmt|;
name|copyvalue
argument_list|(
operator|&
name|tmp
argument_list|,
name|stack
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|o_predec
parameter_list|()
block|{
name|NUMBER
modifier|*
name|q
decl_stmt|,
modifier|*
modifier|*
name|np
decl_stmt|;
name|VALUE
modifier|*
name|vp
decl_stmt|,
name|tmp
decl_stmt|;
if|if
condition|(
name|stack
operator|->
name|v_type
operator|!=
name|V_ADDR
condition|)
name|math_error
argument_list|(
literal|"Predecrementing non-variable"
argument_list|)
expr_stmt|;
if|if
condition|(
name|stack
operator|->
name|v_addr
operator|->
name|v_type
operator|==
name|V_NUM
condition|)
block|{
name|np
operator|=
operator|&
name|stack
operator|->
name|v_addr
operator|->
name|v_num
expr_stmt|;
name|q
operator|=
name|qdec
argument_list|(
operator|*
name|np
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
operator|*
name|np
argument_list|)
expr_stmt|;
operator|*
name|np
operator|=
name|q
expr_stmt|;
name|stack
operator|->
name|v_type
operator|=
name|V_NUM
expr_stmt|;
name|stack
operator|->
name|v_num
operator|=
name|qlink
argument_list|(
name|q
argument_list|)
expr_stmt|;
return|return;
block|}
name|vp
operator|=
name|stack
operator|->
name|v_addr
expr_stmt|;
name|decvalue
argument_list|(
name|vp
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
name|freevalue
argument_list|(
name|vp
argument_list|)
expr_stmt|;
operator|*
name|vp
operator|=
name|tmp
expr_stmt|;
name|copyvalue
argument_list|(
operator|&
name|tmp
argument_list|,
name|stack
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|o_postinc
parameter_list|()
block|{
name|NUMBER
modifier|*
name|q
decl_stmt|,
modifier|*
modifier|*
name|np
decl_stmt|;
name|VALUE
modifier|*
name|vp
decl_stmt|,
name|tmp
decl_stmt|;
if|if
condition|(
name|stack
operator|->
name|v_type
operator|!=
name|V_ADDR
condition|)
name|math_error
argument_list|(
literal|"Postincrementing non-variable"
argument_list|)
expr_stmt|;
if|if
condition|(
name|stack
operator|->
name|v_addr
operator|->
name|v_type
operator|==
name|V_NUM
condition|)
block|{
name|np
operator|=
operator|&
name|stack
operator|->
name|v_addr
operator|->
name|v_num
expr_stmt|;
name|q
operator|=
operator|*
name|np
expr_stmt|;
operator|*
name|np
operator|=
name|qinc
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|stack
operator|->
name|v_type
operator|=
name|V_NUM
expr_stmt|;
name|stack
operator|->
name|v_num
operator|=
name|q
expr_stmt|;
return|return;
block|}
name|vp
operator|=
name|stack
operator|->
name|v_addr
expr_stmt|;
name|tmp
operator|=
operator|*
name|vp
expr_stmt|;
name|incvalue
argument_list|(
operator|&
name|tmp
argument_list|,
name|vp
argument_list|)
expr_stmt|;
operator|*
name|stack
operator|=
name|tmp
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|o_postdec
parameter_list|()
block|{
name|NUMBER
modifier|*
name|q
decl_stmt|,
modifier|*
modifier|*
name|np
decl_stmt|;
name|VALUE
modifier|*
name|vp
decl_stmt|,
name|tmp
decl_stmt|;
if|if
condition|(
name|stack
operator|->
name|v_type
operator|!=
name|V_ADDR
condition|)
name|math_error
argument_list|(
literal|"Postdecrementing non-variable"
argument_list|)
expr_stmt|;
if|if
condition|(
name|stack
operator|->
name|v_addr
operator|->
name|v_type
operator|==
name|V_NUM
condition|)
block|{
name|np
operator|=
operator|&
name|stack
operator|->
name|v_addr
operator|->
name|v_num
expr_stmt|;
name|q
operator|=
operator|*
name|np
expr_stmt|;
operator|*
name|np
operator|=
name|qdec
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|stack
operator|->
name|v_type
operator|=
name|V_NUM
expr_stmt|;
name|stack
operator|->
name|v_num
operator|=
name|q
expr_stmt|;
return|return;
block|}
name|vp
operator|=
name|stack
operator|->
name|v_addr
expr_stmt|;
name|tmp
operator|=
operator|*
name|vp
expr_stmt|;
name|decvalue
argument_list|(
operator|&
name|tmp
argument_list|,
name|vp
argument_list|)
expr_stmt|;
operator|*
name|stack
operator|=
name|tmp
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|o_leftshift
parameter_list|()
block|{
name|VALUE
modifier|*
name|v1
decl_stmt|,
modifier|*
name|v2
decl_stmt|;
name|VALUE
name|tmp
decl_stmt|;
name|v1
operator|=
operator|&
name|stack
index|[
operator|-
literal|1
index|]
expr_stmt|;
name|v2
operator|=
operator|&
name|stack
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|v1
operator|->
name|v_type
operator|==
name|V_ADDR
condition|)
name|v1
operator|=
name|v1
operator|->
name|v_addr
expr_stmt|;
if|if
condition|(
name|v2
operator|->
name|v_type
operator|==
name|V_ADDR
condition|)
name|v2
operator|=
name|v2
operator|->
name|v_addr
expr_stmt|;
name|shiftvalue
argument_list|(
name|v1
argument_list|,
name|v2
argument_list|,
name|FALSE
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
name|freevalue
argument_list|(
name|stack
operator|--
argument_list|)
expr_stmt|;
name|freevalue
argument_list|(
name|stack
argument_list|)
expr_stmt|;
operator|*
name|stack
operator|=
name|tmp
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|o_rightshift
parameter_list|()
block|{
name|VALUE
modifier|*
name|v1
decl_stmt|,
modifier|*
name|v2
decl_stmt|;
name|VALUE
name|tmp
decl_stmt|;
name|v1
operator|=
operator|&
name|stack
index|[
operator|-
literal|1
index|]
expr_stmt|;
name|v2
operator|=
operator|&
name|stack
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|v1
operator|->
name|v_type
operator|==
name|V_ADDR
condition|)
name|v1
operator|=
name|v1
operator|->
name|v_addr
expr_stmt|;
if|if
condition|(
name|v2
operator|->
name|v_type
operator|==
name|V_ADDR
condition|)
name|v2
operator|=
name|v2
operator|->
name|v_addr
expr_stmt|;
name|shiftvalue
argument_list|(
name|v1
argument_list|,
name|v2
argument_list|,
name|TRUE
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
name|freevalue
argument_list|(
name|stack
operator|--
argument_list|)
expr_stmt|;
name|freevalue
argument_list|(
name|stack
argument_list|)
expr_stmt|;
operator|*
name|stack
operator|=
name|tmp
expr_stmt|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|o_debug
parameter_list|(
name|fp
parameter_list|,
name|line
parameter_list|)
name|FUNC
modifier|*
name|fp
decl_stmt|;
name|long
name|line
decl_stmt|;
block|{
name|funcline
operator|=
name|line
expr_stmt|;
if|if
condition|(
name|abortlevel
operator|>=
name|ABORT_STATEMENT
condition|)
name|math_error
argument_list|(
literal|"Calculation aborted at statement boundary"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|o_printresult
parameter_list|()
block|{
name|VALUE
modifier|*
name|vp
decl_stmt|;
name|vp
operator|=
name|stack
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|==
name|V_ADDR
condition|)
name|vp
operator|=
name|vp
operator|->
name|v_addr
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|!=
name|V_NULL
condition|)
block|{
if|if
condition|(
name|tab_ok
condition|)
name|math_chr
argument_list|(
literal|'\t'
argument_list|)
expr_stmt|;
name|printvalue
argument_list|(
name|vp
argument_list|,
name|PRINT_UNAMBIG
argument_list|)
expr_stmt|;
name|math_chr
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|math_flush
argument_list|()
expr_stmt|;
block|}
name|freevalue
argument_list|(
name|stack
operator|--
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|o_print
parameter_list|(
name|fp
parameter_list|,
name|flags
parameter_list|)
name|FUNC
modifier|*
name|fp
decl_stmt|;
name|long
name|flags
decl_stmt|;
block|{
name|VALUE
modifier|*
name|vp
decl_stmt|;
name|vp
operator|=
name|stack
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|==
name|V_ADDR
condition|)
name|vp
operator|=
name|vp
operator|->
name|v_addr
expr_stmt|;
name|printvalue
argument_list|(
name|vp
argument_list|,
operator|(
name|int
operator|)
name|flags
argument_list|)
expr_stmt|;
name|freevalue
argument_list|(
name|stack
operator|--
argument_list|)
expr_stmt|;
if|if
condition|(
name|traceflags
operator|&
name|TRACE_OPCODES
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|math_flush
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|o_printeol
parameter_list|()
block|{
name|math_chr
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|math_flush
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|o_printspace
parameter_list|()
block|{
name|math_chr
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
name|traceflags
operator|&
name|TRACE_OPCODES
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|o_printstring
parameter_list|(
name|fp
parameter_list|,
name|cp
parameter_list|)
name|FUNC
modifier|*
name|fp
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
block|{
name|math_str
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|traceflags
operator|&
name|TRACE_OPCODES
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|math_flush
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|o_zero
parameter_list|()
block|{
name|stack
operator|++
expr_stmt|;
name|stack
operator|->
name|v_type
operator|=
name|V_NUM
expr_stmt|;
name|stack
operator|->
name|v_num
operator|=
name|qlink
argument_list|(
operator|&
name|_qzero_
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|o_one
parameter_list|()
block|{
name|stack
operator|++
expr_stmt|;
name|stack
operator|->
name|v_type
operator|=
name|V_NUM
expr_stmt|;
name|stack
operator|->
name|v_num
operator|=
name|qlink
argument_list|(
operator|&
name|_qone_
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|o_save
parameter_list|(
name|fp
parameter_list|)
name|FUNC
modifier|*
name|fp
decl_stmt|;
block|{
name|VALUE
modifier|*
name|vp
decl_stmt|;
name|vp
operator|=
name|stack
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|==
name|V_ADDR
condition|)
name|vp
operator|=
name|vp
operator|->
name|v_addr
expr_stmt|;
name|freevalue
argument_list|(
operator|&
name|fp
operator|->
name|f_savedvalue
argument_list|)
expr_stmt|;
name|copyvalue
argument_list|(
name|vp
argument_list|,
operator|&
name|fp
operator|->
name|f_savedvalue
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|o_oldvalue
parameter_list|()
block|{
name|copyvalue
argument_list|(
operator|&
name|oldvalue
argument_list|,
operator|++
name|stack
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|o_quit
parameter_list|(
name|fp
parameter_list|,
name|cp
parameter_list|)
name|FUNC
modifier|*
name|fp
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
block|{
if|if
condition|(
operator|(
name|fp
operator|->
name|f_name
index|[
literal|0
index|]
operator|==
literal|'*'
operator|)
operator|&&
operator|(
name|fp
operator|->
name|f_name
index|[
literal|1
index|]
operator|==
literal|'\0'
operator|)
condition|)
block|{
if|if
condition|(
name|cp
condition|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|hist_term
argument_list|()
expr_stmt|;
while|while
condition|(
name|stack
operator|>
name|stackarray
condition|)
block|{
name|freevalue
argument_list|(
name|stack
operator|--
argument_list|)
expr_stmt|;
block|}
name|freevalue
argument_list|(
name|stackarray
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cp
condition|)
name|math_error
argument_list|(
literal|"%s"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|math_error
argument_list|(
literal|"quit statement executed"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|o_getepsilon
parameter_list|()
block|{
name|stack
operator|++
expr_stmt|;
name|stack
operator|->
name|v_type
operator|=
name|V_NUM
expr_stmt|;
name|stack
operator|->
name|v_num
operator|=
name|qlink
argument_list|(
name|_epsilon_
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|o_setepsilon
parameter_list|()
block|{
name|VALUE
modifier|*
name|vp
decl_stmt|;
name|NUMBER
modifier|*
name|newep
decl_stmt|;
name|vp
operator|=
operator|&
name|stack
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|==
name|V_ADDR
condition|)
name|vp
operator|=
name|vp
operator|->
name|v_addr
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|!=
name|V_NUM
condition|)
name|math_error
argument_list|(
literal|"Non-numeric for epsilon"
argument_list|)
expr_stmt|;
name|newep
operator|=
name|vp
operator|->
name|v_num
expr_stmt|;
name|stack
operator|->
name|v_num
operator|=
name|qlink
argument_list|(
name|_epsilon_
argument_list|)
expr_stmt|;
name|setepsilon
argument_list|(
name|newep
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|newep
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|o_setconfig
parameter_list|()
block|{
name|int
name|type
decl_stmt|;
name|VALUE
modifier|*
name|v1
decl_stmt|,
modifier|*
name|v2
decl_stmt|;
name|VALUE
name|tmp
decl_stmt|;
name|v1
operator|=
operator|&
name|stack
index|[
operator|-
literal|1
index|]
expr_stmt|;
name|v2
operator|=
operator|&
name|stack
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|v1
operator|->
name|v_type
operator|==
name|V_ADDR
condition|)
name|v1
operator|=
name|v1
operator|->
name|v_addr
expr_stmt|;
if|if
condition|(
name|v2
operator|->
name|v_type
operator|==
name|V_ADDR
condition|)
name|v2
operator|=
name|v2
operator|->
name|v_addr
expr_stmt|;
if|if
condition|(
name|v1
operator|->
name|v_type
operator|!=
name|V_STR
condition|)
name|math_error
argument_list|(
literal|"Non-string for config"
argument_list|)
expr_stmt|;
name|type
operator|=
name|configtype
argument_list|(
name|v1
operator|->
name|v_str
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|<
literal|0
condition|)
name|math_error
argument_list|(
literal|"Unknown config name \"%s\""
argument_list|,
name|v1
operator|->
name|v_str
argument_list|)
expr_stmt|;
name|getconfig
argument_list|(
name|type
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
name|setconfig
argument_list|(
name|type
argument_list|,
name|v2
argument_list|)
expr_stmt|;
name|freevalue
argument_list|(
name|stack
operator|--
argument_list|)
expr_stmt|;
name|freevalue
argument_list|(
name|stack
argument_list|)
expr_stmt|;
operator|*
name|stack
operator|=
name|tmp
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|o_getconfig
parameter_list|()
block|{
name|int
name|type
decl_stmt|;
name|VALUE
modifier|*
name|vp
decl_stmt|;
name|vp
operator|=
operator|&
name|stack
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|==
name|V_ADDR
condition|)
name|vp
operator|=
name|vp
operator|->
name|v_addr
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|!=
name|V_STR
condition|)
name|math_error
argument_list|(
literal|"Non-string for config"
argument_list|)
expr_stmt|;
name|type
operator|=
name|configtype
argument_list|(
name|vp
operator|->
name|v_str
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|<
literal|0
condition|)
name|math_error
argument_list|(
literal|"Unknown config name \"%s\""
argument_list|,
name|vp
operator|->
name|v_str
argument_list|)
expr_stmt|;
name|freevalue
argument_list|(
name|stack
argument_list|)
expr_stmt|;
name|getconfig
argument_list|(
name|type
argument_list|,
name|stack
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set the 'old' value to the last value saved during the calculation.  */
end_comment

begin_function
name|void
name|updateoldvalue
parameter_list|(
name|fp
parameter_list|)
name|FUNC
modifier|*
name|fp
decl_stmt|;
block|{
if|if
condition|(
name|fp
operator|->
name|f_savedvalue
operator|.
name|v_type
operator|==
name|V_NULL
condition|)
return|return;
name|freevalue
argument_list|(
operator|&
name|oldvalue
argument_list|)
expr_stmt|;
name|oldvalue
operator|=
name|fp
operator|->
name|f_savedvalue
expr_stmt|;
name|fp
operator|->
name|f_savedvalue
operator|.
name|v_type
operator|=
name|V_NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Routine called on any runtime error, to complain about it (with possible  * arguments), and then longjump back to the top level command scanner.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|VARARGS
end_ifdef

begin_define
define|#
directive|define
name|VA_ALIST
value|fmt, va_alist
end_define

begin_define
define|#
directive|define
name|VA_DCL
value|char *fmt; va_dcl
end_define

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__STDC__
argument_list|)
operator|&&
name|__STDC__
operator|==
literal|1
end_if

begin_define
define|#
directive|define
name|VA_ALIST
value|char *fmt, ...
end_define

begin_define
define|#
directive|define
name|VA_DCL
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|VA_ALIST
value|fmt
end_define

begin_define
define|#
directive|define
name|VA_DCL
value|char *fmt;
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*VARARGS*/
end_comment

begin_function
name|void
name|math_error
parameter_list|(
name|VA_ALIST
parameter_list|)
function|VA_DCL
block|{
name|va_list
name|ap
decl_stmt|;
name|char
name|buf
index|[
name|MAXERROR
operator|+
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|funcname
operator|&&
operator|(
operator|*
name|funcname
operator|!=
literal|'*'
operator|)
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\"%s\": "
argument_list|,
name|funcname
argument_list|)
expr_stmt|;
if|if
condition|(
name|funcline
operator|&&
operator|(
operator|(
name|funcname
operator|&&
operator|(
operator|*
name|funcname
operator|!=
literal|'*'
operator|)
operator|)
operator|||
operator|!
name|inputisterminal
argument_list|()
operator|)
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"line %ld: "
argument_list|,
name|funcline
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|VARARGS
name|va_start
argument_list|(
name|ap
argument_list|)
expr_stmt|;
else|#
directive|else
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|vsprintf
argument_list|(
name|buf
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|funcname
operator|=
name|NULL
expr_stmt|;
name|longjmp
argument_list|(
name|jmpbuf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* END CODE */
end_comment

end_unit

