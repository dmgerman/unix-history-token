begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1994 David I. Bell  * Permission is granted to use, distribute, or modify this source,  * provided that this copyright notice remains intact.  *  * Extended precision rational arithmetic matrix functions.  * Matrices can contain arbitrary types of elements.  */
end_comment

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_decl_stmt
specifier|static
name|void
name|matswaprow
name|MATH_PROTO
argument_list|(
operator|(
name|MATRIX
operator|*
name|m
operator|,
name|long
name|r1
operator|,
name|long
name|r2
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|matsubrow
name|MATH_PROTO
argument_list|(
operator|(
name|MATRIX
operator|*
name|m
operator|,
name|long
name|oprow
operator|,
name|long
name|baserow
operator|,
name|VALUE
operator|*
name|mulval
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|matmulrow
name|MATH_PROTO
argument_list|(
operator|(
name|MATRIX
operator|*
name|m
operator|,
name|long
name|row
operator|,
name|VALUE
operator|*
name|mulval
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|MATRIX
modifier|*
name|matident
name|MATH_PROTO
argument_list|(
operator|(
name|MATRIX
operator|*
name|m
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Add two compatible matrices.  */
end_comment

begin_function
name|MATRIX
modifier|*
name|matadd
parameter_list|(
name|m1
parameter_list|,
name|m2
parameter_list|)
name|MATRIX
modifier|*
name|m1
decl_stmt|,
decl|*
name|m2
decl_stmt|;
end_function

begin_block
block|{
name|int
name|dim
decl_stmt|;
name|long
name|min1
decl_stmt|,
name|min2
decl_stmt|,
name|max1
decl_stmt|,
name|max2
decl_stmt|,
name|index
decl_stmt|;
name|VALUE
modifier|*
name|v1
decl_stmt|,
modifier|*
name|v2
decl_stmt|,
modifier|*
name|vres
decl_stmt|;
name|MATRIX
modifier|*
name|res
decl_stmt|;
name|MATRIX
name|tmp
decl_stmt|;
if|if
condition|(
name|m1
operator|->
name|m_dim
operator|!=
name|m2
operator|->
name|m_dim
condition|)
name|math_error
argument_list|(
literal|"Incompatible matrix dimensions for add"
argument_list|)
expr_stmt|;
name|tmp
operator|.
name|m_dim
operator|=
name|m1
operator|->
name|m_dim
expr_stmt|;
name|tmp
operator|.
name|m_size
operator|=
name|m1
operator|->
name|m_size
expr_stmt|;
for|for
control|(
name|dim
operator|=
literal|0
init|;
name|dim
operator|<
name|m1
operator|->
name|m_dim
condition|;
name|dim
operator|++
control|)
block|{
name|min1
operator|=
name|m1
operator|->
name|m_min
index|[
name|dim
index|]
expr_stmt|;
name|max1
operator|=
name|m1
operator|->
name|m_max
index|[
name|dim
index|]
expr_stmt|;
name|min2
operator|=
name|m2
operator|->
name|m_min
index|[
name|dim
index|]
expr_stmt|;
name|max2
operator|=
name|m2
operator|->
name|m_max
index|[
name|dim
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|min1
operator|&&
name|min2
operator|&&
operator|(
name|min1
operator|!=
name|min2
operator|)
operator|)
operator|||
operator|(
operator|(
name|max1
operator|-
name|min1
operator|)
operator|!=
operator|(
name|max2
operator|-
name|min2
operator|)
operator|)
condition|)
name|math_error
argument_list|(
literal|"Incompatible matrix bounds for add"
argument_list|)
expr_stmt|;
name|tmp
operator|.
name|m_min
index|[
name|dim
index|]
operator|=
operator|(
name|min1
condition|?
name|min1
else|:
name|min2
operator|)
expr_stmt|;
name|tmp
operator|.
name|m_max
index|[
name|dim
index|]
operator|=
name|tmp
operator|.
name|m_min
index|[
name|dim
index|]
operator|+
operator|(
name|max1
operator|-
name|min1
operator|)
expr_stmt|;
block|}
name|res
operator|=
name|matalloc
argument_list|(
name|m1
operator|->
name|m_size
argument_list|)
expr_stmt|;
operator|*
name|res
operator|=
name|tmp
expr_stmt|;
name|v1
operator|=
name|m1
operator|->
name|m_table
expr_stmt|;
name|v2
operator|=
name|m2
operator|->
name|m_table
expr_stmt|;
name|vres
operator|=
name|res
operator|->
name|m_table
expr_stmt|;
for|for
control|(
name|index
operator|=
name|m1
operator|->
name|m_size
init|;
name|index
operator|>
literal|0
condition|;
name|index
operator|--
control|)
name|addvalue
argument_list|(
name|v1
operator|++
argument_list|,
name|v2
operator|++
argument_list|,
name|vres
operator|++
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_block

begin_comment
comment|/*  * Subtract two compatible matrices.  */
end_comment

begin_function
name|MATRIX
modifier|*
name|matsub
parameter_list|(
name|m1
parameter_list|,
name|m2
parameter_list|)
name|MATRIX
modifier|*
name|m1
decl_stmt|,
decl|*
name|m2
decl_stmt|;
end_function

begin_block
block|{
name|int
name|dim
decl_stmt|;
name|long
name|min1
decl_stmt|,
name|min2
decl_stmt|,
name|max1
decl_stmt|,
name|max2
decl_stmt|,
name|index
decl_stmt|;
name|VALUE
modifier|*
name|v1
decl_stmt|,
modifier|*
name|v2
decl_stmt|,
modifier|*
name|vres
decl_stmt|;
name|MATRIX
modifier|*
name|res
decl_stmt|;
name|MATRIX
name|tmp
decl_stmt|;
if|if
condition|(
name|m1
operator|->
name|m_dim
operator|!=
name|m2
operator|->
name|m_dim
condition|)
name|math_error
argument_list|(
literal|"Incompatible matrix dimensions for sub"
argument_list|)
expr_stmt|;
name|tmp
operator|.
name|m_dim
operator|=
name|m1
operator|->
name|m_dim
expr_stmt|;
name|tmp
operator|.
name|m_size
operator|=
name|m1
operator|->
name|m_size
expr_stmt|;
for|for
control|(
name|dim
operator|=
literal|0
init|;
name|dim
operator|<
name|m1
operator|->
name|m_dim
condition|;
name|dim
operator|++
control|)
block|{
name|min1
operator|=
name|m1
operator|->
name|m_min
index|[
name|dim
index|]
expr_stmt|;
name|max1
operator|=
name|m1
operator|->
name|m_max
index|[
name|dim
index|]
expr_stmt|;
name|min2
operator|=
name|m2
operator|->
name|m_min
index|[
name|dim
index|]
expr_stmt|;
name|max2
operator|=
name|m2
operator|->
name|m_max
index|[
name|dim
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|min1
operator|&&
name|min2
operator|&&
operator|(
name|min1
operator|!=
name|min2
operator|)
operator|)
operator|||
operator|(
operator|(
name|max1
operator|-
name|min1
operator|)
operator|!=
operator|(
name|max2
operator|-
name|min2
operator|)
operator|)
condition|)
name|math_error
argument_list|(
literal|"Incompatible matrix bounds for sub"
argument_list|)
expr_stmt|;
name|tmp
operator|.
name|m_min
index|[
name|dim
index|]
operator|=
operator|(
name|min1
condition|?
name|min1
else|:
name|min2
operator|)
expr_stmt|;
name|tmp
operator|.
name|m_max
index|[
name|dim
index|]
operator|=
name|tmp
operator|.
name|m_min
index|[
name|dim
index|]
operator|+
operator|(
name|max1
operator|-
name|min1
operator|)
expr_stmt|;
block|}
name|res
operator|=
name|matalloc
argument_list|(
name|m1
operator|->
name|m_size
argument_list|)
expr_stmt|;
operator|*
name|res
operator|=
name|tmp
expr_stmt|;
name|v1
operator|=
name|m1
operator|->
name|m_table
expr_stmt|;
name|v2
operator|=
name|m2
operator|->
name|m_table
expr_stmt|;
name|vres
operator|=
name|res
operator|->
name|m_table
expr_stmt|;
for|for
control|(
name|index
operator|=
name|m1
operator|->
name|m_size
init|;
name|index
operator|>
literal|0
condition|;
name|index
operator|--
control|)
name|subvalue
argument_list|(
name|v1
operator|++
argument_list|,
name|v2
operator|++
argument_list|,
name|vres
operator|++
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_block

begin_comment
comment|/*  * Produce the negative of a matrix.  */
end_comment

begin_function
name|MATRIX
modifier|*
name|matneg
parameter_list|(
name|m
parameter_list|)
name|MATRIX
modifier|*
name|m
decl_stmt|;
block|{
specifier|register
name|VALUE
modifier|*
name|val
decl_stmt|,
modifier|*
name|vres
decl_stmt|;
name|long
name|index
decl_stmt|;
name|MATRIX
modifier|*
name|res
decl_stmt|;
name|res
operator|=
name|matalloc
argument_list|(
name|m
operator|->
name|m_size
argument_list|)
expr_stmt|;
operator|*
name|res
operator|=
operator|*
name|m
expr_stmt|;
name|val
operator|=
name|m
operator|->
name|m_table
expr_stmt|;
name|vres
operator|=
name|res
operator|->
name|m_table
expr_stmt|;
for|for
control|(
name|index
operator|=
name|m
operator|->
name|m_size
init|;
name|index
operator|>
literal|0
condition|;
name|index
operator|--
control|)
name|negvalue
argument_list|(
name|val
operator|++
argument_list|,
name|vres
operator|++
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/*  * Multiply two compatible matrices.  */
end_comment

begin_function
name|MATRIX
modifier|*
name|matmul
parameter_list|(
name|m1
parameter_list|,
name|m2
parameter_list|)
name|MATRIX
modifier|*
name|m1
decl_stmt|,
decl|*
name|m2
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|MATRIX
modifier|*
name|res
decl_stmt|;
name|long
name|i1
decl_stmt|,
name|i2
decl_stmt|,
name|max1
decl_stmt|,
name|max2
decl_stmt|,
name|index
decl_stmt|,
name|maxindex
decl_stmt|;
name|VALUE
modifier|*
name|v1
decl_stmt|,
modifier|*
name|v2
decl_stmt|;
name|VALUE
name|sum
decl_stmt|,
name|tmp1
decl_stmt|,
name|tmp2
decl_stmt|;
if|if
condition|(
operator|(
name|m1
operator|->
name|m_dim
operator|!=
literal|2
operator|)
operator|||
operator|(
name|m2
operator|->
name|m_dim
operator|!=
literal|2
operator|)
condition|)
name|math_error
argument_list|(
literal|"Matrix dimension must be two for mul"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m1
operator|->
name|m_max
index|[
literal|1
index|]
operator|-
name|m1
operator|->
name|m_min
index|[
literal|1
index|]
operator|)
operator|!=
operator|(
name|m2
operator|->
name|m_max
index|[
literal|0
index|]
operator|-
name|m2
operator|->
name|m_min
index|[
literal|0
index|]
operator|)
condition|)
name|math_error
argument_list|(
literal|"Incompatible bounds for matrix mul"
argument_list|)
expr_stmt|;
name|max1
operator|=
operator|(
name|m1
operator|->
name|m_max
index|[
literal|0
index|]
operator|-
name|m1
operator|->
name|m_min
index|[
literal|0
index|]
operator|+
literal|1
operator|)
expr_stmt|;
name|max2
operator|=
operator|(
name|m2
operator|->
name|m_max
index|[
literal|1
index|]
operator|-
name|m2
operator|->
name|m_min
index|[
literal|1
index|]
operator|+
literal|1
operator|)
expr_stmt|;
name|maxindex
operator|=
operator|(
name|m1
operator|->
name|m_max
index|[
literal|1
index|]
operator|-
name|m1
operator|->
name|m_min
index|[
literal|1
index|]
operator|+
literal|1
operator|)
expr_stmt|;
name|res
operator|=
name|matalloc
argument_list|(
name|max1
operator|*
name|max2
argument_list|)
expr_stmt|;
name|res
operator|->
name|m_dim
operator|=
literal|2
expr_stmt|;
name|res
operator|->
name|m_min
index|[
literal|0
index|]
operator|=
name|m1
operator|->
name|m_min
index|[
literal|0
index|]
expr_stmt|;
name|res
operator|->
name|m_max
index|[
literal|0
index|]
operator|=
name|m1
operator|->
name|m_max
index|[
literal|0
index|]
expr_stmt|;
name|res
operator|->
name|m_min
index|[
literal|1
index|]
operator|=
name|m2
operator|->
name|m_min
index|[
literal|1
index|]
expr_stmt|;
name|res
operator|->
name|m_max
index|[
literal|1
index|]
operator|=
name|m2
operator|->
name|m_max
index|[
literal|1
index|]
expr_stmt|;
for|for
control|(
name|i1
operator|=
literal|0
init|;
name|i1
operator|<
name|max1
condition|;
name|i1
operator|++
control|)
block|{
for|for
control|(
name|i2
operator|=
literal|0
init|;
name|i2
operator|<
name|max2
condition|;
name|i2
operator|++
control|)
block|{
name|sum
operator|.
name|v_num
operator|=
name|qlink
argument_list|(
operator|&
name|_qzero_
argument_list|)
expr_stmt|;
name|sum
operator|.
name|v_type
operator|=
name|V_NUM
expr_stmt|;
name|v1
operator|=
operator|&
name|m1
operator|->
name|m_table
index|[
name|i1
operator|*
name|maxindex
index|]
expr_stmt|;
name|v2
operator|=
operator|&
name|m2
operator|->
name|m_table
index|[
name|i2
index|]
expr_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|maxindex
condition|;
name|index
operator|++
control|)
block|{
name|mulvalue
argument_list|(
name|v1
argument_list|,
name|v2
argument_list|,
operator|&
name|tmp1
argument_list|)
expr_stmt|;
name|addvalue
argument_list|(
operator|&
name|sum
argument_list|,
operator|&
name|tmp1
argument_list|,
operator|&
name|tmp2
argument_list|)
expr_stmt|;
name|freevalue
argument_list|(
operator|&
name|tmp1
argument_list|)
expr_stmt|;
name|freevalue
argument_list|(
operator|&
name|sum
argument_list|)
expr_stmt|;
name|sum
operator|=
name|tmp2
expr_stmt|;
name|v1
operator|++
expr_stmt|;
name|v2
operator|+=
name|max2
expr_stmt|;
block|}
name|index
operator|=
operator|(
name|i1
operator|*
name|max2
operator|)
operator|+
name|i2
expr_stmt|;
name|res
operator|->
name|m_table
index|[
name|index
index|]
operator|=
name|sum
expr_stmt|;
block|}
block|}
return|return
name|res
return|;
block|}
end_block

begin_comment
comment|/*  * Square a matrix.  */
end_comment

begin_function
name|MATRIX
modifier|*
name|matsquare
parameter_list|(
name|m
parameter_list|)
name|MATRIX
modifier|*
name|m
decl_stmt|;
block|{
specifier|register
name|MATRIX
modifier|*
name|res
decl_stmt|;
name|long
name|i1
decl_stmt|,
name|i2
decl_stmt|,
name|max
decl_stmt|,
name|index
decl_stmt|;
name|VALUE
modifier|*
name|v1
decl_stmt|,
modifier|*
name|v2
decl_stmt|;
name|VALUE
name|sum
decl_stmt|,
name|tmp1
decl_stmt|,
name|tmp2
decl_stmt|;
if|if
condition|(
name|m
operator|->
name|m_dim
operator|!=
literal|2
condition|)
name|math_error
argument_list|(
literal|"Matrix dimension must be two for square"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|m_max
index|[
literal|0
index|]
operator|-
name|m
operator|->
name|m_min
index|[
literal|0
index|]
operator|)
operator|!=
operator|(
name|m
operator|->
name|m_max
index|[
literal|1
index|]
operator|-
name|m
operator|->
name|m_min
index|[
literal|1
index|]
operator|)
condition|)
name|math_error
argument_list|(
literal|"Squaring non-square matrix"
argument_list|)
expr_stmt|;
name|max
operator|=
operator|(
name|m
operator|->
name|m_max
index|[
literal|0
index|]
operator|-
name|m
operator|->
name|m_min
index|[
literal|0
index|]
operator|+
literal|1
operator|)
expr_stmt|;
name|res
operator|=
name|matalloc
argument_list|(
name|max
operator|*
name|max
argument_list|)
expr_stmt|;
name|res
operator|->
name|m_dim
operator|=
literal|2
expr_stmt|;
name|res
operator|->
name|m_min
index|[
literal|0
index|]
operator|=
name|m
operator|->
name|m_min
index|[
literal|0
index|]
expr_stmt|;
name|res
operator|->
name|m_max
index|[
literal|0
index|]
operator|=
name|m
operator|->
name|m_max
index|[
literal|0
index|]
expr_stmt|;
name|res
operator|->
name|m_min
index|[
literal|1
index|]
operator|=
name|m
operator|->
name|m_min
index|[
literal|1
index|]
expr_stmt|;
name|res
operator|->
name|m_max
index|[
literal|1
index|]
operator|=
name|m
operator|->
name|m_max
index|[
literal|1
index|]
expr_stmt|;
for|for
control|(
name|i1
operator|=
literal|0
init|;
name|i1
operator|<
name|max
condition|;
name|i1
operator|++
control|)
block|{
for|for
control|(
name|i2
operator|=
literal|0
init|;
name|i2
operator|<
name|max
condition|;
name|i2
operator|++
control|)
block|{
name|sum
operator|.
name|v_num
operator|=
name|qlink
argument_list|(
operator|&
name|_qzero_
argument_list|)
expr_stmt|;
name|sum
operator|.
name|v_type
operator|=
name|V_NUM
expr_stmt|;
name|v1
operator|=
operator|&
name|m
operator|->
name|m_table
index|[
name|i1
operator|*
name|max
index|]
expr_stmt|;
name|v2
operator|=
operator|&
name|m
operator|->
name|m_table
index|[
name|i2
index|]
expr_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|max
condition|;
name|index
operator|++
control|)
block|{
name|mulvalue
argument_list|(
name|v1
argument_list|,
name|v2
argument_list|,
operator|&
name|tmp1
argument_list|)
expr_stmt|;
name|addvalue
argument_list|(
operator|&
name|sum
argument_list|,
operator|&
name|tmp1
argument_list|,
operator|&
name|tmp2
argument_list|)
expr_stmt|;
name|freevalue
argument_list|(
operator|&
name|tmp1
argument_list|)
expr_stmt|;
name|freevalue
argument_list|(
operator|&
name|sum
argument_list|)
expr_stmt|;
name|sum
operator|=
name|tmp2
expr_stmt|;
name|v1
operator|++
expr_stmt|;
name|v2
operator|+=
name|max
expr_stmt|;
block|}
name|index
operator|=
operator|(
name|i1
operator|*
name|max
operator|)
operator|+
name|i2
expr_stmt|;
name|res
operator|->
name|m_table
index|[
name|index
index|]
operator|=
name|sum
expr_stmt|;
block|}
block|}
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/*  * Compute the result of raising a square matrix to an integer power.  * Negative powers mean the positive power of the inverse.  * Note: This calculation could someday be improved for large powers  * by using the characteristic polynomial of the matrix.  */
end_comment

begin_function
name|MATRIX
modifier|*
name|matpowi
parameter_list|(
name|m
parameter_list|,
name|q
parameter_list|)
name|MATRIX
modifier|*
name|m
decl_stmt|;
comment|/* matrix to be raised */
name|NUMBER
modifier|*
name|q
decl_stmt|;
comment|/* power to raise it to */
block|{
name|MATRIX
modifier|*
name|res
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
name|long
name|power
decl_stmt|;
comment|/* power to raise to */
name|unsigned
name|long
name|bit
decl_stmt|;
comment|/* current bit value */
if|if
condition|(
name|m
operator|->
name|m_dim
operator|!=
literal|2
condition|)
name|math_error
argument_list|(
literal|"Matrix dimension must be two for power"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|m_max
index|[
literal|0
index|]
operator|-
name|m
operator|->
name|m_min
index|[
literal|0
index|]
operator|)
operator|!=
operator|(
name|m
operator|->
name|m_max
index|[
literal|1
index|]
operator|-
name|m
operator|->
name|m_min
index|[
literal|1
index|]
operator|)
condition|)
name|math_error
argument_list|(
literal|"Raising non-square matrix to a power"
argument_list|)
expr_stmt|;
if|if
condition|(
name|qisfrac
argument_list|(
name|q
argument_list|)
condition|)
name|math_error
argument_list|(
literal|"Raising matrix to non-integral power"
argument_list|)
expr_stmt|;
if|if
condition|(
name|zisbig
argument_list|(
name|q
operator|->
name|num
argument_list|)
condition|)
name|math_error
argument_list|(
literal|"Raising matrix to very large power"
argument_list|)
expr_stmt|;
name|power
operator|=
operator|(
name|zistiny
argument_list|(
name|q
operator|->
name|num
argument_list|)
condition|?
name|z1tol
argument_list|(
name|q
operator|->
name|num
argument_list|)
else|:
name|z2tol
argument_list|(
name|q
operator|->
name|num
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|qisneg
argument_list|(
name|q
argument_list|)
condition|)
name|power
operator|=
operator|-
name|power
expr_stmt|;
comment|/* 	 * Handle some low powers specially 	 */
if|if
condition|(
operator|(
name|power
operator|<=
literal|4
operator|)
operator|&&
operator|(
name|power
operator|>=
operator|-
literal|2
operator|)
condition|)
block|{
switch|switch
condition|(
operator|(
name|int
operator|)
name|power
condition|)
block|{
case|case
literal|0
case|:
return|return
name|matident
argument_list|(
name|m
argument_list|)
return|;
case|case
literal|1
case|:
return|return
name|matcopy
argument_list|(
name|m
argument_list|)
return|;
case|case
operator|-
literal|1
case|:
return|return
name|matinv
argument_list|(
name|m
argument_list|)
return|;
case|case
literal|2
case|:
return|return
name|matsquare
argument_list|(
name|m
argument_list|)
return|;
case|case
operator|-
literal|2
case|:
name|tmp
operator|=
name|matinv
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|res
operator|=
name|matsquare
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|matfree
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
return|return
name|res
return|;
case|case
literal|3
case|:
name|tmp
operator|=
name|matsquare
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|res
operator|=
name|matmul
argument_list|(
name|m
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|matfree
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
return|return
name|res
return|;
case|case
literal|4
case|:
name|tmp
operator|=
name|matsquare
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|res
operator|=
name|matsquare
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|matfree
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
block|}
if|if
condition|(
name|power
operator|<
literal|0
condition|)
block|{
name|m
operator|=
name|matinv
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|power
operator|=
operator|-
name|power
expr_stmt|;
block|}
comment|/* 	 * Compute the power by squaring and multiplying. 	 * This uses the left to right method of power raising. 	 */
name|bit
operator|=
name|TOPFULL
expr_stmt|;
while|while
condition|(
operator|(
name|bit
operator|&
name|power
operator|)
operator|==
literal|0
condition|)
name|bit
operator|>>=
literal|1L
expr_stmt|;
name|bit
operator|>>=
literal|1L
expr_stmt|;
name|res
operator|=
name|matsquare
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|bit
operator|&
name|power
condition|)
block|{
name|tmp
operator|=
name|matmul
argument_list|(
name|res
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|matfree
argument_list|(
name|res
argument_list|)
expr_stmt|;
name|res
operator|=
name|tmp
expr_stmt|;
block|}
name|bit
operator|>>=
literal|1L
expr_stmt|;
while|while
condition|(
name|bit
condition|)
block|{
name|tmp
operator|=
name|matsquare
argument_list|(
name|res
argument_list|)
expr_stmt|;
name|matfree
argument_list|(
name|res
argument_list|)
expr_stmt|;
name|res
operator|=
name|tmp
expr_stmt|;
if|if
condition|(
name|bit
operator|&
name|power
condition|)
block|{
name|tmp
operator|=
name|matmul
argument_list|(
name|res
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|matfree
argument_list|(
name|res
argument_list|)
expr_stmt|;
name|res
operator|=
name|tmp
expr_stmt|;
block|}
name|bit
operator|>>=
literal|1L
expr_stmt|;
block|}
if|if
condition|(
name|qisneg
argument_list|(
name|q
argument_list|)
condition|)
name|matfree
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/*  * Calculate the cross product of two one dimensional matrices each  * with three components.  *	m3 = matcross(m1, m2);  */
end_comment

begin_function
name|MATRIX
modifier|*
name|matcross
parameter_list|(
name|m1
parameter_list|,
name|m2
parameter_list|)
name|MATRIX
modifier|*
name|m1
decl_stmt|,
decl|*
name|m2
decl_stmt|;
end_function

begin_block
block|{
name|MATRIX
modifier|*
name|res
decl_stmt|;
name|VALUE
modifier|*
name|v1
decl_stmt|,
modifier|*
name|v2
decl_stmt|,
modifier|*
name|vr
decl_stmt|;
name|VALUE
name|tmp1
decl_stmt|,
name|tmp2
decl_stmt|;
if|if
condition|(
operator|(
name|m1
operator|->
name|m_dim
operator|!=
literal|1
operator|)
operator|||
operator|(
name|m2
operator|->
name|m_dim
operator|!=
literal|1
operator|)
condition|)
name|math_error
argument_list|(
literal|"Matrix not 1d for cross product"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m1
operator|->
name|m_size
operator|!=
literal|3
operator|)
operator|||
operator|(
name|m2
operator|->
name|m_size
operator|!=
literal|3
operator|)
condition|)
name|math_error
argument_list|(
literal|"Matrix not size 3 for cross product"
argument_list|)
expr_stmt|;
name|res
operator|=
name|matalloc
argument_list|(
literal|3L
argument_list|)
expr_stmt|;
name|res
operator|->
name|m_dim
operator|=
literal|1
expr_stmt|;
name|res
operator|->
name|m_min
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|res
operator|->
name|m_max
index|[
literal|0
index|]
operator|=
literal|2
expr_stmt|;
name|v1
operator|=
name|m1
operator|->
name|m_table
expr_stmt|;
name|v2
operator|=
name|m2
operator|->
name|m_table
expr_stmt|;
name|vr
operator|=
name|res
operator|->
name|m_table
expr_stmt|;
name|mulvalue
argument_list|(
name|v1
operator|+
literal|1
argument_list|,
name|v2
operator|+
literal|2
argument_list|,
operator|&
name|tmp1
argument_list|)
expr_stmt|;
name|mulvalue
argument_list|(
name|v1
operator|+
literal|2
argument_list|,
name|v2
operator|+
literal|1
argument_list|,
operator|&
name|tmp2
argument_list|)
expr_stmt|;
name|subvalue
argument_list|(
operator|&
name|tmp1
argument_list|,
operator|&
name|tmp2
argument_list|,
name|vr
operator|+
literal|0
argument_list|)
expr_stmt|;
name|freevalue
argument_list|(
operator|&
name|tmp1
argument_list|)
expr_stmt|;
name|freevalue
argument_list|(
operator|&
name|tmp2
argument_list|)
expr_stmt|;
name|mulvalue
argument_list|(
name|v1
operator|+
literal|2
argument_list|,
name|v2
operator|+
literal|0
argument_list|,
operator|&
name|tmp1
argument_list|)
expr_stmt|;
name|mulvalue
argument_list|(
name|v1
operator|+
literal|0
argument_list|,
name|v2
operator|+
literal|2
argument_list|,
operator|&
name|tmp2
argument_list|)
expr_stmt|;
name|subvalue
argument_list|(
operator|&
name|tmp1
argument_list|,
operator|&
name|tmp2
argument_list|,
name|vr
operator|+
literal|1
argument_list|)
expr_stmt|;
name|freevalue
argument_list|(
operator|&
name|tmp1
argument_list|)
expr_stmt|;
name|freevalue
argument_list|(
operator|&
name|tmp2
argument_list|)
expr_stmt|;
name|mulvalue
argument_list|(
name|v1
operator|+
literal|0
argument_list|,
name|v2
operator|+
literal|1
argument_list|,
operator|&
name|tmp1
argument_list|)
expr_stmt|;
name|mulvalue
argument_list|(
name|v1
operator|+
literal|1
argument_list|,
name|v2
operator|+
literal|0
argument_list|,
operator|&
name|tmp2
argument_list|)
expr_stmt|;
name|subvalue
argument_list|(
operator|&
name|tmp1
argument_list|,
operator|&
name|tmp2
argument_list|,
name|vr
operator|+
literal|2
argument_list|)
expr_stmt|;
name|freevalue
argument_list|(
operator|&
name|tmp1
argument_list|)
expr_stmt|;
name|freevalue
argument_list|(
operator|&
name|tmp2
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_block

begin_comment
comment|/*  * Return the dot product of two matrices.  *	result = matdot(m1, m2);  */
end_comment

begin_function
name|VALUE
name|matdot
parameter_list|(
name|m1
parameter_list|,
name|m2
parameter_list|)
name|MATRIX
modifier|*
name|m1
decl_stmt|,
decl|*
name|m2
decl_stmt|;
end_function

begin_block
block|{
name|VALUE
modifier|*
name|v1
decl_stmt|,
modifier|*
name|v2
decl_stmt|;
name|VALUE
name|result
decl_stmt|,
name|tmp1
decl_stmt|,
name|tmp2
decl_stmt|;
name|long
name|len
decl_stmt|;
if|if
condition|(
operator|(
name|m1
operator|->
name|m_dim
operator|!=
literal|1
operator|)
operator|||
operator|(
name|m2
operator|->
name|m_dim
operator|!=
literal|1
operator|)
condition|)
name|math_error
argument_list|(
literal|"Matrix not 1d for dot product"
argument_list|)
expr_stmt|;
if|if
condition|(
name|m1
operator|->
name|m_size
operator|!=
name|m2
operator|->
name|m_size
condition|)
name|math_error
argument_list|(
literal|"Incompatible matrix sizes for dot product"
argument_list|)
expr_stmt|;
name|v1
operator|=
name|m1
operator|->
name|m_table
expr_stmt|;
name|v2
operator|=
name|m2
operator|->
name|m_table
expr_stmt|;
name|mulvalue
argument_list|(
name|v1
argument_list|,
name|v2
argument_list|,
operator|&
name|result
argument_list|)
expr_stmt|;
name|len
operator|=
name|m1
operator|->
name|m_size
expr_stmt|;
while|while
condition|(
operator|--
name|len
operator|>
literal|0
condition|)
block|{
name|mulvalue
argument_list|(
operator|++
name|v1
argument_list|,
operator|++
name|v2
argument_list|,
operator|&
name|tmp1
argument_list|)
expr_stmt|;
name|addvalue
argument_list|(
operator|&
name|result
argument_list|,
operator|&
name|tmp1
argument_list|,
operator|&
name|tmp2
argument_list|)
expr_stmt|;
name|freevalue
argument_list|(
operator|&
name|tmp1
argument_list|)
expr_stmt|;
name|freevalue
argument_list|(
operator|&
name|result
argument_list|)
expr_stmt|;
name|result
operator|=
name|tmp2
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_block

begin_comment
comment|/*  * Scale the elements of a matrix by a specified power of two.  */
end_comment

begin_function
name|MATRIX
modifier|*
name|matscale
parameter_list|(
name|m
parameter_list|,
name|n
parameter_list|)
name|MATRIX
modifier|*
name|m
decl_stmt|;
comment|/* matrix to be scaled */
name|long
name|n
decl_stmt|;
block|{
specifier|register
name|VALUE
modifier|*
name|val
decl_stmt|,
modifier|*
name|vres
decl_stmt|;
name|VALUE
name|num
decl_stmt|;
name|long
name|index
decl_stmt|;
name|MATRIX
modifier|*
name|res
decl_stmt|;
comment|/* resulting matrix */
if|if
condition|(
name|n
operator|==
literal|0
condition|)
return|return
name|matcopy
argument_list|(
name|m
argument_list|)
return|;
name|num
operator|.
name|v_type
operator|=
name|V_NUM
expr_stmt|;
name|num
operator|.
name|v_num
operator|=
name|itoq
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|res
operator|=
name|matalloc
argument_list|(
name|m
operator|->
name|m_size
argument_list|)
expr_stmt|;
operator|*
name|res
operator|=
operator|*
name|m
expr_stmt|;
name|val
operator|=
name|m
operator|->
name|m_table
expr_stmt|;
name|vres
operator|=
name|res
operator|->
name|m_table
expr_stmt|;
for|for
control|(
name|index
operator|=
name|m
operator|->
name|m_size
init|;
name|index
operator|>
literal|0
condition|;
name|index
operator|--
control|)
name|scalevalue
argument_list|(
name|val
operator|++
argument_list|,
operator|&
name|num
argument_list|,
name|vres
operator|++
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|num
operator|.
name|v_num
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/*  * Shift the elements of a matrix by the specified number of bits.  * Positive shift means leftwards, negative shift rightwards.  */
end_comment

begin_function
name|MATRIX
modifier|*
name|matshift
parameter_list|(
name|m
parameter_list|,
name|n
parameter_list|)
name|MATRIX
modifier|*
name|m
decl_stmt|;
comment|/* matrix to be scaled */
name|long
name|n
decl_stmt|;
block|{
specifier|register
name|VALUE
modifier|*
name|val
decl_stmt|,
modifier|*
name|vres
decl_stmt|;
name|VALUE
name|num
decl_stmt|;
name|long
name|index
decl_stmt|;
name|MATRIX
modifier|*
name|res
decl_stmt|;
comment|/* resulting matrix */
if|if
condition|(
name|n
operator|==
literal|0
condition|)
return|return
name|matcopy
argument_list|(
name|m
argument_list|)
return|;
name|num
operator|.
name|v_type
operator|=
name|V_NUM
expr_stmt|;
name|num
operator|.
name|v_num
operator|=
name|itoq
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|res
operator|=
name|matalloc
argument_list|(
name|m
operator|->
name|m_size
argument_list|)
expr_stmt|;
operator|*
name|res
operator|=
operator|*
name|m
expr_stmt|;
name|val
operator|=
name|m
operator|->
name|m_table
expr_stmt|;
name|vres
operator|=
name|res
operator|->
name|m_table
expr_stmt|;
for|for
control|(
name|index
operator|=
name|m
operator|->
name|m_size
init|;
name|index
operator|>
literal|0
condition|;
name|index
operator|--
control|)
name|shiftvalue
argument_list|(
name|val
operator|++
argument_list|,
operator|&
name|num
argument_list|,
name|FALSE
argument_list|,
name|vres
operator|++
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|num
operator|.
name|v_num
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/*  * Multiply the elements of a matrix by a specified value.  */
end_comment

begin_function
name|MATRIX
modifier|*
name|matmulval
parameter_list|(
name|m
parameter_list|,
name|vp
parameter_list|)
name|MATRIX
modifier|*
name|m
decl_stmt|;
comment|/* matrix to be multiplied */
name|VALUE
modifier|*
name|vp
decl_stmt|;
comment|/* value to multiply by */
block|{
specifier|register
name|VALUE
modifier|*
name|val
decl_stmt|,
modifier|*
name|vres
decl_stmt|;
name|long
name|index
decl_stmt|;
name|MATRIX
modifier|*
name|res
decl_stmt|;
name|res
operator|=
name|matalloc
argument_list|(
name|m
operator|->
name|m_size
argument_list|)
expr_stmt|;
operator|*
name|res
operator|=
operator|*
name|m
expr_stmt|;
name|val
operator|=
name|m
operator|->
name|m_table
expr_stmt|;
name|vres
operator|=
name|res
operator|->
name|m_table
expr_stmt|;
for|for
control|(
name|index
operator|=
name|m
operator|->
name|m_size
init|;
name|index
operator|>
literal|0
condition|;
name|index
operator|--
control|)
name|mulvalue
argument_list|(
name|val
operator|++
argument_list|,
name|vp
argument_list|,
name|vres
operator|++
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/*  * Divide the elements of a matrix by a specified value, keeping  * only the integer quotient.  */
end_comment

begin_function
name|MATRIX
modifier|*
name|matquoval
parameter_list|(
name|m
parameter_list|,
name|vp
parameter_list|)
name|MATRIX
modifier|*
name|m
decl_stmt|;
comment|/* matrix to be divided */
name|VALUE
modifier|*
name|vp
decl_stmt|;
comment|/* value to divide by */
block|{
specifier|register
name|VALUE
modifier|*
name|val
decl_stmt|,
modifier|*
name|vres
decl_stmt|;
name|long
name|index
decl_stmt|;
name|MATRIX
modifier|*
name|res
decl_stmt|;
if|if
condition|(
operator|(
name|vp
operator|->
name|v_type
operator|==
name|V_NUM
operator|)
operator|&&
name|qiszero
argument_list|(
name|vp
operator|->
name|v_num
argument_list|)
condition|)
name|math_error
argument_list|(
literal|"Division by zero"
argument_list|)
expr_stmt|;
name|res
operator|=
name|matalloc
argument_list|(
name|m
operator|->
name|m_size
argument_list|)
expr_stmt|;
operator|*
name|res
operator|=
operator|*
name|m
expr_stmt|;
name|val
operator|=
name|m
operator|->
name|m_table
expr_stmt|;
name|vres
operator|=
name|res
operator|->
name|m_table
expr_stmt|;
for|for
control|(
name|index
operator|=
name|m
operator|->
name|m_size
init|;
name|index
operator|>
literal|0
condition|;
name|index
operator|--
control|)
name|quovalue
argument_list|(
name|val
operator|++
argument_list|,
name|vp
argument_list|,
name|vres
operator|++
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/*  * Divide the elements of a matrix by a specified value, keeping  * only the remainder of the division.  */
end_comment

begin_function
name|MATRIX
modifier|*
name|matmodval
parameter_list|(
name|m
parameter_list|,
name|vp
parameter_list|)
name|MATRIX
modifier|*
name|m
decl_stmt|;
comment|/* matrix to be divided */
name|VALUE
modifier|*
name|vp
decl_stmt|;
comment|/* value to divide by */
block|{
specifier|register
name|VALUE
modifier|*
name|val
decl_stmt|,
modifier|*
name|vres
decl_stmt|;
name|long
name|index
decl_stmt|;
name|MATRIX
modifier|*
name|res
decl_stmt|;
if|if
condition|(
operator|(
name|vp
operator|->
name|v_type
operator|==
name|V_NUM
operator|)
operator|&&
name|qiszero
argument_list|(
name|vp
operator|->
name|v_num
argument_list|)
condition|)
name|math_error
argument_list|(
literal|"Division by zero"
argument_list|)
expr_stmt|;
name|res
operator|=
name|matalloc
argument_list|(
name|m
operator|->
name|m_size
argument_list|)
expr_stmt|;
operator|*
name|res
operator|=
operator|*
name|m
expr_stmt|;
name|val
operator|=
name|m
operator|->
name|m_table
expr_stmt|;
name|vres
operator|=
name|res
operator|->
name|m_table
expr_stmt|;
for|for
control|(
name|index
operator|=
name|m
operator|->
name|m_size
init|;
name|index
operator|>
literal|0
condition|;
name|index
operator|--
control|)
name|modvalue
argument_list|(
name|val
operator|++
argument_list|,
name|vp
argument_list|,
name|vres
operator|++
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_function
name|MATRIX
modifier|*
name|mattrans
parameter_list|(
name|m
parameter_list|)
name|MATRIX
modifier|*
name|m
decl_stmt|;
comment|/* matrix to be transposed */
block|{
specifier|register
name|VALUE
modifier|*
name|v1
decl_stmt|,
modifier|*
name|v2
decl_stmt|;
comment|/* current values */
name|long
name|rows
decl_stmt|,
name|cols
decl_stmt|;
comment|/* rows and columns in new matrix */
name|long
name|row
decl_stmt|,
name|col
decl_stmt|;
comment|/* current row and column */
name|MATRIX
modifier|*
name|res
decl_stmt|;
if|if
condition|(
name|m
operator|->
name|m_dim
operator|!=
literal|2
condition|)
name|math_error
argument_list|(
literal|"Matrix dimension must be two for transpose"
argument_list|)
expr_stmt|;
name|res
operator|=
name|matalloc
argument_list|(
name|m
operator|->
name|m_size
argument_list|)
expr_stmt|;
name|res
operator|->
name|m_dim
operator|=
literal|2
expr_stmt|;
name|res
operator|->
name|m_min
index|[
literal|0
index|]
operator|=
name|m
operator|->
name|m_min
index|[
literal|1
index|]
expr_stmt|;
name|res
operator|->
name|m_max
index|[
literal|0
index|]
operator|=
name|m
operator|->
name|m_max
index|[
literal|1
index|]
expr_stmt|;
name|res
operator|->
name|m_min
index|[
literal|1
index|]
operator|=
name|m
operator|->
name|m_min
index|[
literal|0
index|]
expr_stmt|;
name|res
operator|->
name|m_max
index|[
literal|1
index|]
operator|=
name|m
operator|->
name|m_max
index|[
literal|0
index|]
expr_stmt|;
name|rows
operator|=
operator|(
name|m
operator|->
name|m_max
index|[
literal|1
index|]
operator|-
name|m
operator|->
name|m_min
index|[
literal|1
index|]
operator|+
literal|1
operator|)
expr_stmt|;
name|cols
operator|=
operator|(
name|m
operator|->
name|m_max
index|[
literal|0
index|]
operator|-
name|m
operator|->
name|m_min
index|[
literal|0
index|]
operator|+
literal|1
operator|)
expr_stmt|;
name|v1
operator|=
name|res
operator|->
name|m_table
expr_stmt|;
for|for
control|(
name|row
operator|=
literal|0
init|;
name|row
operator|<
name|rows
condition|;
name|row
operator|++
control|)
block|{
name|v2
operator|=
operator|&
name|m
operator|->
name|m_table
index|[
name|row
index|]
expr_stmt|;
for|for
control|(
name|col
operator|=
literal|0
init|;
name|col
operator|<
name|cols
condition|;
name|col
operator|++
control|)
block|{
name|copyvalue
argument_list|(
name|v2
argument_list|,
name|v1
argument_list|)
expr_stmt|;
name|v1
operator|++
expr_stmt|;
name|v2
operator|+=
name|rows
expr_stmt|;
block|}
block|}
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/*  * Produce a matrix with values all of which are conjugated.  */
end_comment

begin_function
name|MATRIX
modifier|*
name|matconj
parameter_list|(
name|m
parameter_list|)
name|MATRIX
modifier|*
name|m
decl_stmt|;
block|{
specifier|register
name|VALUE
modifier|*
name|val
decl_stmt|,
modifier|*
name|vres
decl_stmt|;
name|long
name|index
decl_stmt|;
name|MATRIX
modifier|*
name|res
decl_stmt|;
name|res
operator|=
name|matalloc
argument_list|(
name|m
operator|->
name|m_size
argument_list|)
expr_stmt|;
operator|*
name|res
operator|=
operator|*
name|m
expr_stmt|;
name|val
operator|=
name|m
operator|->
name|m_table
expr_stmt|;
name|vres
operator|=
name|res
operator|->
name|m_table
expr_stmt|;
for|for
control|(
name|index
operator|=
name|m
operator|->
name|m_size
init|;
name|index
operator|>
literal|0
condition|;
name|index
operator|--
control|)
name|conjvalue
argument_list|(
name|val
operator|++
argument_list|,
name|vres
operator|++
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/*  * Produce a matrix with values all of which have been rounded to the  * specified number of decimal places.  */
end_comment

begin_function
name|MATRIX
modifier|*
name|matround
parameter_list|(
name|m
parameter_list|,
name|places
parameter_list|)
name|MATRIX
modifier|*
name|m
decl_stmt|;
name|long
name|places
decl_stmt|;
block|{
specifier|register
name|VALUE
modifier|*
name|val
decl_stmt|,
modifier|*
name|vres
decl_stmt|;
name|VALUE
name|tmp
decl_stmt|;
name|long
name|index
decl_stmt|;
name|MATRIX
modifier|*
name|res
decl_stmt|;
if|if
condition|(
name|places
operator|<
literal|0
condition|)
name|math_error
argument_list|(
literal|"Negative number of places for matround"
argument_list|)
expr_stmt|;
name|res
operator|=
name|matalloc
argument_list|(
name|m
operator|->
name|m_size
argument_list|)
expr_stmt|;
operator|*
name|res
operator|=
operator|*
name|m
expr_stmt|;
name|tmp
operator|.
name|v_type
operator|=
name|V_INT
expr_stmt|;
name|tmp
operator|.
name|v_int
operator|=
name|places
expr_stmt|;
name|val
operator|=
name|m
operator|->
name|m_table
expr_stmt|;
name|vres
operator|=
name|res
operator|->
name|m_table
expr_stmt|;
for|for
control|(
name|index
operator|=
name|m
operator|->
name|m_size
init|;
name|index
operator|>
literal|0
condition|;
name|index
operator|--
control|)
name|roundvalue
argument_list|(
name|val
operator|++
argument_list|,
operator|&
name|tmp
argument_list|,
name|vres
operator|++
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/*  * Produce a matrix with values all of which have been rounded to the  * specified number of binary places.  */
end_comment

begin_function
name|MATRIX
modifier|*
name|matbround
parameter_list|(
name|m
parameter_list|,
name|places
parameter_list|)
name|MATRIX
modifier|*
name|m
decl_stmt|;
name|long
name|places
decl_stmt|;
block|{
specifier|register
name|VALUE
modifier|*
name|val
decl_stmt|,
modifier|*
name|vres
decl_stmt|;
name|VALUE
name|tmp
decl_stmt|;
name|long
name|index
decl_stmt|;
name|MATRIX
modifier|*
name|res
decl_stmt|;
if|if
condition|(
name|places
operator|<
literal|0
condition|)
name|math_error
argument_list|(
literal|"Negative number of places for matbround"
argument_list|)
expr_stmt|;
name|res
operator|=
name|matalloc
argument_list|(
name|m
operator|->
name|m_size
argument_list|)
expr_stmt|;
operator|*
name|res
operator|=
operator|*
name|m
expr_stmt|;
name|tmp
operator|.
name|v_type
operator|=
name|V_INT
expr_stmt|;
name|tmp
operator|.
name|v_int
operator|=
name|places
expr_stmt|;
name|val
operator|=
name|m
operator|->
name|m_table
expr_stmt|;
name|vres
operator|=
name|res
operator|->
name|m_table
expr_stmt|;
for|for
control|(
name|index
operator|=
name|m
operator|->
name|m_size
init|;
name|index
operator|>
literal|0
condition|;
name|index
operator|--
control|)
name|broundvalue
argument_list|(
name|val
operator|++
argument_list|,
operator|&
name|tmp
argument_list|,
name|vres
operator|++
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/*  * Produce a matrix with values all of which have been truncated to integers.  */
end_comment

begin_function
name|MATRIX
modifier|*
name|matint
parameter_list|(
name|m
parameter_list|)
name|MATRIX
modifier|*
name|m
decl_stmt|;
block|{
specifier|register
name|VALUE
modifier|*
name|val
decl_stmt|,
modifier|*
name|vres
decl_stmt|;
name|long
name|index
decl_stmt|;
name|MATRIX
modifier|*
name|res
decl_stmt|;
name|res
operator|=
name|matalloc
argument_list|(
name|m
operator|->
name|m_size
argument_list|)
expr_stmt|;
operator|*
name|res
operator|=
operator|*
name|m
expr_stmt|;
name|val
operator|=
name|m
operator|->
name|m_table
expr_stmt|;
name|vres
operator|=
name|res
operator|->
name|m_table
expr_stmt|;
for|for
control|(
name|index
operator|=
name|m
operator|->
name|m_size
init|;
name|index
operator|>
literal|0
condition|;
name|index
operator|--
control|)
name|intvalue
argument_list|(
name|val
operator|++
argument_list|,
name|vres
operator|++
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/*  * Produce a matrix with values all of which have only the fraction part left.  */
end_comment

begin_function
name|MATRIX
modifier|*
name|matfrac
parameter_list|(
name|m
parameter_list|)
name|MATRIX
modifier|*
name|m
decl_stmt|;
block|{
specifier|register
name|VALUE
modifier|*
name|val
decl_stmt|,
modifier|*
name|vres
decl_stmt|;
name|long
name|index
decl_stmt|;
name|MATRIX
modifier|*
name|res
decl_stmt|;
name|res
operator|=
name|matalloc
argument_list|(
name|m
operator|->
name|m_size
argument_list|)
expr_stmt|;
operator|*
name|res
operator|=
operator|*
name|m
expr_stmt|;
name|val
operator|=
name|m
operator|->
name|m_table
expr_stmt|;
name|vres
operator|=
name|res
operator|->
name|m_table
expr_stmt|;
for|for
control|(
name|index
operator|=
name|m
operator|->
name|m_size
init|;
name|index
operator|>
literal|0
condition|;
name|index
operator|--
control|)
name|fracvalue
argument_list|(
name|val
operator|++
argument_list|,
name|vres
operator|++
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/*  * Index a matrix normally by the specified set of index values.  * Returns the address of the matrix element if it is valid, or generates  * an error if the index values are out of range.  The create flag is TRUE  * if the element is to be written, but this is ignored here.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|VALUE
modifier|*
name|matindex
parameter_list|(
name|mp
parameter_list|,
name|create
parameter_list|,
name|dim
parameter_list|,
name|indices
parameter_list|)
name|MATRIX
modifier|*
name|mp
decl_stmt|;
name|BOOL
name|create
decl_stmt|;
name|long
name|dim
decl_stmt|;
comment|/* dimension of the indexing */
name|VALUE
modifier|*
name|indices
decl_stmt|;
comment|/* table of values being indexed by */
block|{
name|NUMBER
modifier|*
name|q
decl_stmt|;
comment|/* index value */
name|long
name|index
decl_stmt|;
comment|/* index value as an integer */
name|long
name|offset
decl_stmt|;
comment|/* current offset into array */
name|int
name|i
decl_stmt|;
comment|/* loop counter */
if|if
condition|(
operator|(
name|dim
operator|<=
literal|0
operator|)
operator|||
operator|(
name|dim
operator|>
name|MAXDIM
operator|)
condition|)
name|math_error
argument_list|(
literal|"Bad dimension %ld for matrix"
argument_list|,
name|dim
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|m_dim
operator|!=
name|dim
condition|)
name|math_error
argument_list|(
literal|"Indexing a %ldd matrix as a %ldd matrix"
argument_list|,
name|mp
operator|->
name|m_dim
argument_list|,
name|dim
argument_list|)
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dim
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|indices
operator|->
name|v_type
operator|!=
name|V_NUM
condition|)
name|math_error
argument_list|(
literal|"Non-numeric index for matrix"
argument_list|)
expr_stmt|;
name|q
operator|=
name|indices
operator|->
name|v_num
expr_stmt|;
if|if
condition|(
name|qisfrac
argument_list|(
name|q
argument_list|)
condition|)
name|math_error
argument_list|(
literal|"Non-integral index for matrix"
argument_list|)
expr_stmt|;
name|index
operator|=
name|qtoi
argument_list|(
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
name|zisbig
argument_list|(
name|q
operator|->
name|num
argument_list|)
operator|||
operator|(
name|index
operator|<
name|mp
operator|->
name|m_min
index|[
name|i
index|]
operator|)
operator|||
operator|(
name|index
operator|>
name|mp
operator|->
name|m_max
index|[
name|i
index|]
operator|)
condition|)
name|math_error
argument_list|(
literal|"Index out of bounds for matrix"
argument_list|)
expr_stmt|;
name|offset
operator|*=
operator|(
name|mp
operator|->
name|m_max
index|[
name|i
index|]
operator|-
name|mp
operator|->
name|m_min
index|[
name|i
index|]
operator|+
literal|1
operator|)
expr_stmt|;
name|offset
operator|+=
operator|(
name|index
operator|-
name|mp
operator|->
name|m_min
index|[
name|i
index|]
operator|)
expr_stmt|;
name|indices
operator|++
expr_stmt|;
block|}
return|return
name|mp
operator|->
name|m_table
operator|+
name|offset
return|;
block|}
end_function

begin_comment
comment|/*  * Search a matrix for the specified value, starting with the specified index.  * Returns the index of the found value, or -1 if the value was not found.  */
end_comment

begin_function
name|long
name|matsearch
parameter_list|(
name|m
parameter_list|,
name|vp
parameter_list|,
name|index
parameter_list|)
name|MATRIX
modifier|*
name|m
decl_stmt|;
name|VALUE
modifier|*
name|vp
decl_stmt|;
name|long
name|index
decl_stmt|;
block|{
specifier|register
name|VALUE
modifier|*
name|val
decl_stmt|;
if|if
condition|(
name|index
operator|<
literal|0
condition|)
name|index
operator|=
literal|0
expr_stmt|;
name|val
operator|=
operator|&
name|m
operator|->
name|m_table
index|[
name|index
index|]
expr_stmt|;
while|while
condition|(
name|index
operator|<
name|m
operator|->
name|m_size
condition|)
block|{
if|if
condition|(
operator|!
name|comparevalue
argument_list|(
name|vp
argument_list|,
name|val
argument_list|)
condition|)
return|return
name|index
return|;
name|index
operator|++
expr_stmt|;
name|val
operator|++
expr_stmt|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Search a matrix backwards for the specified value, starting with the  * specified index.  Returns the index of the found value, or -1 if the  * value was not found.  */
end_comment

begin_function
name|long
name|matrsearch
parameter_list|(
name|m
parameter_list|,
name|vp
parameter_list|,
name|index
parameter_list|)
name|MATRIX
modifier|*
name|m
decl_stmt|;
name|VALUE
modifier|*
name|vp
decl_stmt|;
name|long
name|index
decl_stmt|;
block|{
specifier|register
name|VALUE
modifier|*
name|val
decl_stmt|;
if|if
condition|(
name|index
operator|>=
name|m
operator|->
name|m_size
condition|)
name|index
operator|=
name|m
operator|->
name|m_size
operator|-
literal|1
expr_stmt|;
name|val
operator|=
operator|&
name|m
operator|->
name|m_table
index|[
name|index
index|]
expr_stmt|;
while|while
condition|(
name|index
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|comparevalue
argument_list|(
name|vp
argument_list|,
name|val
argument_list|)
condition|)
return|return
name|index
return|;
name|index
operator|--
expr_stmt|;
name|val
operator|--
expr_stmt|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Fill all of the elements of a matrix with one of two specified values.  * All entries are filled with the first specified value, except that if  * the matrix is square and the second value pointer is non-NULL, then  * all diagonal entries are filled with the second value.  This routine  * affects the supplied matrix directly, and doesn't return a copy.  */
end_comment

begin_function
name|void
name|matfill
parameter_list|(
name|m
parameter_list|,
name|v1
parameter_list|,
name|v2
parameter_list|)
name|MATRIX
modifier|*
name|m
decl_stmt|;
comment|/* matrix to be filled */
name|VALUE
modifier|*
name|v1
decl_stmt|;
comment|/* value to fill most of matrix with */
name|VALUE
modifier|*
name|v2
decl_stmt|;
comment|/* value for diagonal entries (or NULL) */
block|{
specifier|register
name|VALUE
modifier|*
name|val
decl_stmt|;
name|long
name|row
decl_stmt|,
name|col
decl_stmt|;
name|long
name|rows
decl_stmt|;
name|long
name|index
decl_stmt|;
if|if
condition|(
name|v2
operator|&&
operator|(
operator|(
name|m
operator|->
name|m_dim
operator|!=
literal|2
operator|)
operator|||
operator|(
operator|(
name|m
operator|->
name|m_max
index|[
literal|0
index|]
operator|-
name|m
operator|->
name|m_min
index|[
literal|0
index|]
operator|)
operator|!=
operator|(
name|m
operator|->
name|m_max
index|[
literal|1
index|]
operator|-
name|m
operator|->
name|m_min
index|[
literal|1
index|]
operator|)
operator|)
operator|)
condition|)
name|math_error
argument_list|(
literal|"Filling diagonals of non-square matrix"
argument_list|)
expr_stmt|;
name|val
operator|=
name|m
operator|->
name|m_table
expr_stmt|;
for|for
control|(
name|index
operator|=
name|m
operator|->
name|m_size
init|;
name|index
operator|>
literal|0
condition|;
name|index
operator|--
control|)
name|freevalue
argument_list|(
name|val
operator|++
argument_list|)
expr_stmt|;
name|val
operator|=
name|m
operator|->
name|m_table
expr_stmt|;
if|if
condition|(
name|v2
operator|==
name|NULL
condition|)
block|{
for|for
control|(
name|index
operator|=
name|m
operator|->
name|m_size
init|;
name|index
operator|>
literal|0
condition|;
name|index
operator|--
control|)
name|copyvalue
argument_list|(
name|v1
argument_list|,
name|val
operator|++
argument_list|)
expr_stmt|;
return|return;
block|}
name|rows
operator|=
name|m
operator|->
name|m_max
index|[
literal|0
index|]
operator|-
name|m
operator|->
name|m_min
index|[
literal|0
index|]
operator|+
literal|1
expr_stmt|;
for|for
control|(
name|row
operator|=
literal|0
init|;
name|row
operator|<
name|rows
condition|;
name|row
operator|++
control|)
block|{
for|for
control|(
name|col
operator|=
literal|0
init|;
name|col
operator|<
name|rows
condition|;
name|col
operator|++
control|)
block|{
name|copyvalue
argument_list|(
operator|(
operator|(
name|row
operator|!=
name|col
operator|)
condition|?
name|v1
else|:
name|v2
operator|)
argument_list|,
name|val
operator|++
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Set a copy of a square matrix to the identity matrix.  */
end_comment

begin_function
specifier|static
name|MATRIX
modifier|*
name|matident
parameter_list|(
name|m
parameter_list|)
name|MATRIX
modifier|*
name|m
decl_stmt|;
block|{
specifier|register
name|VALUE
modifier|*
name|val
decl_stmt|;
comment|/* current value */
name|long
name|row
decl_stmt|,
name|col
decl_stmt|;
comment|/* current row and column */
name|long
name|rows
decl_stmt|;
comment|/* number of rows */
name|MATRIX
modifier|*
name|res
decl_stmt|;
comment|/* resulting matrix */
if|if
condition|(
name|m
operator|->
name|m_dim
operator|!=
literal|2
condition|)
name|math_error
argument_list|(
literal|"Matrix dimension must be two for setting to identity"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|m_max
index|[
literal|0
index|]
operator|-
name|m
operator|->
name|m_min
index|[
literal|0
index|]
operator|)
operator|!=
operator|(
name|m
operator|->
name|m_max
index|[
literal|1
index|]
operator|-
name|m
operator|->
name|m_min
index|[
literal|1
index|]
operator|)
condition|)
name|math_error
argument_list|(
literal|"Matrix must be square for setting to identity"
argument_list|)
expr_stmt|;
name|res
operator|=
name|matalloc
argument_list|(
name|m
operator|->
name|m_size
argument_list|)
expr_stmt|;
operator|*
name|res
operator|=
operator|*
name|m
expr_stmt|;
name|val
operator|=
name|res
operator|->
name|m_table
expr_stmt|;
name|rows
operator|=
operator|(
name|res
operator|->
name|m_max
index|[
literal|0
index|]
operator|-
name|res
operator|->
name|m_min
index|[
literal|0
index|]
operator|+
literal|1
operator|)
expr_stmt|;
for|for
control|(
name|row
operator|=
literal|0
init|;
name|row
operator|<
name|rows
condition|;
name|row
operator|++
control|)
block|{
for|for
control|(
name|col
operator|=
literal|0
init|;
name|col
operator|<
name|rows
condition|;
name|col
operator|++
control|)
block|{
name|val
operator|->
name|v_type
operator|=
name|V_NUM
expr_stmt|;
name|val
operator|->
name|v_num
operator|=
operator|(
operator|(
name|row
operator|==
name|col
operator|)
condition|?
name|qlink
argument_list|(
operator|&
name|_qone_
argument_list|)
else|:
name|qlink
argument_list|(
operator|&
name|_qzero_
argument_list|)
operator|)
expr_stmt|;
name|val
operator|++
expr_stmt|;
block|}
block|}
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/*  * Calculate the inverse of a matrix if it exists.  * This is done by using transformations on the supplied matrix to convert  * it to the identity matrix, and simultaneously applying the same set of  * transformations to the identity matrix.  */
end_comment

begin_function
name|MATRIX
modifier|*
name|matinv
parameter_list|(
name|m
parameter_list|)
name|MATRIX
modifier|*
name|m
decl_stmt|;
block|{
name|MATRIX
modifier|*
name|res
decl_stmt|;
comment|/* matrix to become the inverse */
name|long
name|rows
decl_stmt|;
comment|/* number of rows */
name|long
name|cur
decl_stmt|;
comment|/* current row being worked on */
name|long
name|row
decl_stmt|,
name|col
decl_stmt|;
comment|/* temp row and column values */
name|VALUE
modifier|*
name|val
decl_stmt|;
comment|/* current value in matrix*/
name|VALUE
name|mulval
decl_stmt|;
comment|/* value to multiply rows by */
name|VALUE
name|tmpval
decl_stmt|;
comment|/* temporary value */
if|if
condition|(
name|m
operator|->
name|m_dim
operator|!=
literal|2
condition|)
name|math_error
argument_list|(
literal|"Matrix dimension must be two for inverse"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|m_max
index|[
literal|0
index|]
operator|-
name|m
operator|->
name|m_min
index|[
literal|0
index|]
operator|)
operator|!=
operator|(
name|m
operator|->
name|m_max
index|[
literal|1
index|]
operator|-
name|m
operator|->
name|m_min
index|[
literal|1
index|]
operator|)
condition|)
name|math_error
argument_list|(
literal|"Inverting non-square matrix"
argument_list|)
expr_stmt|;
comment|/* 	 * Begin by creating the identity matrix with the same attributes. 	 */
name|res
operator|=
name|matalloc
argument_list|(
name|m
operator|->
name|m_size
argument_list|)
expr_stmt|;
operator|*
name|res
operator|=
operator|*
name|m
expr_stmt|;
name|rows
operator|=
operator|(
name|m
operator|->
name|m_max
index|[
literal|0
index|]
operator|-
name|m
operator|->
name|m_min
index|[
literal|0
index|]
operator|+
literal|1
operator|)
expr_stmt|;
name|val
operator|=
name|res
operator|->
name|m_table
expr_stmt|;
for|for
control|(
name|row
operator|=
literal|0
init|;
name|row
operator|<
name|rows
condition|;
name|row
operator|++
control|)
block|{
for|for
control|(
name|col
operator|=
literal|0
init|;
name|col
operator|<
name|rows
condition|;
name|col
operator|++
control|)
block|{
if|if
condition|(
name|row
operator|==
name|col
condition|)
name|val
operator|->
name|v_num
operator|=
name|qlink
argument_list|(
operator|&
name|_qone_
argument_list|)
expr_stmt|;
else|else
name|val
operator|->
name|v_num
operator|=
name|qlink
argument_list|(
operator|&
name|_qzero_
argument_list|)
expr_stmt|;
name|val
operator|->
name|v_type
operator|=
name|V_NUM
expr_stmt|;
name|val
operator|++
expr_stmt|;
block|}
block|}
comment|/* 	 * Now loop over each row, and eliminate all entries in the 	 * corresponding column by using row operations.  Do the same 	 * operations on the resulting matrix.  Copy the original matrix 	 * so that we don't destroy it. 	 */
name|m
operator|=
name|matcopy
argument_list|(
name|m
argument_list|)
expr_stmt|;
for|for
control|(
name|cur
operator|=
literal|0
init|;
name|cur
operator|<
name|rows
condition|;
name|cur
operator|++
control|)
block|{
comment|/* 		 * Find the first nonzero value in the rest of the column 		 * downwards from [cur,cur].  If there is no such value, then 		 * the matrix is not invertible.  If the first nonzero entry 		 * is not the current row, then swap the two rows to make the 		 * current one nonzero. 		 */
name|row
operator|=
name|cur
expr_stmt|;
name|val
operator|=
operator|&
name|m
operator|->
name|m_table
index|[
operator|(
name|row
operator|*
name|rows
operator|)
operator|+
name|row
index|]
expr_stmt|;
while|while
condition|(
name|testvalue
argument_list|(
name|val
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|++
name|row
operator|>=
name|rows
condition|)
block|{
name|matfree
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|matfree
argument_list|(
name|res
argument_list|)
expr_stmt|;
name|math_error
argument_list|(
literal|"Matrix is not invertible"
argument_list|)
expr_stmt|;
block|}
name|val
operator|+=
name|rows
expr_stmt|;
block|}
name|invertvalue
argument_list|(
name|val
argument_list|,
operator|&
name|mulval
argument_list|)
expr_stmt|;
if|if
condition|(
name|row
operator|!=
name|cur
condition|)
block|{
name|matswaprow
argument_list|(
name|m
argument_list|,
name|row
argument_list|,
name|cur
argument_list|)
expr_stmt|;
name|matswaprow
argument_list|(
name|res
argument_list|,
name|row
argument_list|,
name|cur
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Now for every other nonzero entry in the current column, subtract 		 * the appropriate multiple of the current row to force that entry 		 * to become zero. 		 */
name|val
operator|=
operator|&
name|m
operator|->
name|m_table
index|[
name|cur
index|]
expr_stmt|;
comment|/* ignore Saber-C warning about bad pointer val */
for|for
control|(
name|row
operator|=
literal|0
init|;
name|row
operator|<
name|rows
condition|;
name|row
operator|++
operator|,
name|val
operator|+=
name|rows
control|)
block|{
if|if
condition|(
operator|(
name|row
operator|==
name|cur
operator|)
operator|||
operator|(
name|testvalue
argument_list|(
name|val
argument_list|)
operator|==
literal|0
operator|)
condition|)
continue|continue;
name|mulvalue
argument_list|(
name|val
argument_list|,
operator|&
name|mulval
argument_list|,
operator|&
name|tmpval
argument_list|)
expr_stmt|;
name|matsubrow
argument_list|(
name|m
argument_list|,
name|row
argument_list|,
name|cur
argument_list|,
operator|&
name|tmpval
argument_list|)
expr_stmt|;
name|matsubrow
argument_list|(
name|res
argument_list|,
name|row
argument_list|,
name|cur
argument_list|,
operator|&
name|tmpval
argument_list|)
expr_stmt|;
name|freevalue
argument_list|(
operator|&
name|tmpval
argument_list|)
expr_stmt|;
block|}
name|freevalue
argument_list|(
operator|&
name|mulval
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Now the original matrix has nonzero entries only on its main diagonal. 	 * Scale the rows of the result matrix by the inverse of those entries. 	 */
name|val
operator|=
name|m
operator|->
name|m_table
expr_stmt|;
for|for
control|(
name|row
operator|=
literal|0
init|;
name|row
operator|<
name|rows
condition|;
name|row
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|val
operator|->
name|v_type
operator|!=
name|V_NUM
operator|)
operator|||
operator|!
name|qisone
argument_list|(
name|val
operator|->
name|v_num
argument_list|)
condition|)
block|{
name|invertvalue
argument_list|(
name|val
argument_list|,
operator|&
name|mulval
argument_list|)
expr_stmt|;
name|matmulrow
argument_list|(
name|res
argument_list|,
name|row
argument_list|,
operator|&
name|mulval
argument_list|)
expr_stmt|;
name|freevalue
argument_list|(
operator|&
name|mulval
argument_list|)
expr_stmt|;
block|}
comment|/* ignore Saber-C warning about bad pointer val */
name|val
operator|+=
operator|(
name|rows
operator|+
literal|1
operator|)
expr_stmt|;
block|}
name|matfree
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/*  * Calculate the determinant of a square matrix.  * This is done using row operations to create an upper-diagonal matrix.  */
end_comment

begin_function
name|VALUE
name|matdet
parameter_list|(
name|m
parameter_list|)
name|MATRIX
modifier|*
name|m
decl_stmt|;
block|{
name|long
name|rows
decl_stmt|;
comment|/* number of rows */
name|long
name|cur
decl_stmt|;
comment|/* current row being worked on */
name|long
name|row
decl_stmt|;
comment|/* temp row values */
name|int
name|neg
decl_stmt|;
comment|/* whether to negate determinant */
name|VALUE
modifier|*
name|val
decl_stmt|;
comment|/* current value */
name|VALUE
name|mulval
decl_stmt|,
name|tmpval
decl_stmt|;
comment|/* other values */
if|if
condition|(
name|m
operator|->
name|m_dim
operator|!=
literal|2
condition|)
name|math_error
argument_list|(
literal|"Matrix dimension must be two for determinant"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|m_max
index|[
literal|0
index|]
operator|-
name|m
operator|->
name|m_min
index|[
literal|0
index|]
operator|)
operator|!=
operator|(
name|m
operator|->
name|m_max
index|[
literal|1
index|]
operator|-
name|m
operator|->
name|m_min
index|[
literal|1
index|]
operator|)
condition|)
name|math_error
argument_list|(
literal|"Non-square matrix for determinant"
argument_list|)
expr_stmt|;
comment|/* 	 * Loop over each row, and eliminate all lower entries in the 	 * corresponding column by using row operations.  Copy the original 	 * matrix so that we don't destroy it. 	 */
name|neg
operator|=
literal|0
expr_stmt|;
name|m
operator|=
name|matcopy
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|rows
operator|=
operator|(
name|m
operator|->
name|m_max
index|[
literal|0
index|]
operator|-
name|m
operator|->
name|m_min
index|[
literal|0
index|]
operator|+
literal|1
operator|)
expr_stmt|;
for|for
control|(
name|cur
operator|=
literal|0
init|;
name|cur
operator|<
name|rows
condition|;
name|cur
operator|++
control|)
block|{
comment|/* 		 * Find the first nonzero value in the rest of the column 		 * downwards from [cur,cur].  If there is no such value, then 		 * the determinant is zero.  If the first nonzero entry is not 		 * the current row, then swap the two rows to make the current 		 * one nonzero, and remember that the determinant changes sign. 		 */
name|row
operator|=
name|cur
expr_stmt|;
name|val
operator|=
operator|&
name|m
operator|->
name|m_table
index|[
operator|(
name|row
operator|*
name|rows
operator|)
operator|+
name|row
index|]
expr_stmt|;
while|while
condition|(
name|testvalue
argument_list|(
name|val
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|++
name|row
operator|>=
name|rows
condition|)
block|{
name|matfree
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|mulval
operator|.
name|v_type
operator|=
name|V_NUM
expr_stmt|;
name|mulval
operator|.
name|v_num
operator|=
name|qlink
argument_list|(
operator|&
name|_qzero_
argument_list|)
expr_stmt|;
return|return
name|mulval
return|;
block|}
name|val
operator|+=
name|rows
expr_stmt|;
block|}
name|invertvalue
argument_list|(
name|val
argument_list|,
operator|&
name|mulval
argument_list|)
expr_stmt|;
if|if
condition|(
name|row
operator|!=
name|cur
condition|)
block|{
name|matswaprow
argument_list|(
name|m
argument_list|,
name|row
argument_list|,
name|cur
argument_list|)
expr_stmt|;
name|neg
operator|=
operator|!
name|neg
expr_stmt|;
block|}
comment|/* 		 * Now for every other nonzero entry lower down in the current column, 		 * subtract the appropriate multiple of the current row to force that 		 * entry to become zero. 		 */
name|row
operator|=
name|cur
operator|+
literal|1
expr_stmt|;
comment|/* ignore Saber-C warning about bad pointer into val */
name|val
operator|=
operator|&
name|m
operator|->
name|m_table
index|[
operator|(
name|row
operator|*
name|rows
operator|)
operator|+
name|cur
index|]
expr_stmt|;
comment|/* ignore Saber-C warning about bad pointer into val */
for|for
control|(
init|;
name|row
operator|<
name|rows
condition|;
name|row
operator|++
operator|,
name|val
operator|+=
name|rows
control|)
block|{
if|if
condition|(
name|testvalue
argument_list|(
name|val
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
name|mulvalue
argument_list|(
name|val
argument_list|,
operator|&
name|mulval
argument_list|,
operator|&
name|tmpval
argument_list|)
expr_stmt|;
name|matsubrow
argument_list|(
name|m
argument_list|,
name|row
argument_list|,
name|cur
argument_list|,
operator|&
name|tmpval
argument_list|)
expr_stmt|;
name|freevalue
argument_list|(
operator|&
name|tmpval
argument_list|)
expr_stmt|;
block|}
name|freevalue
argument_list|(
operator|&
name|mulval
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Now the matrix is upper-diagonal, and the determinant is the 	 * product of the main diagonal entries, and is possibly negated. 	 */
name|val
operator|=
name|m
operator|->
name|m_table
expr_stmt|;
name|mulval
operator|.
name|v_type
operator|=
name|V_NUM
expr_stmt|;
name|mulval
operator|.
name|v_num
operator|=
name|qlink
argument_list|(
operator|&
name|_qone_
argument_list|)
expr_stmt|;
for|for
control|(
name|row
operator|=
literal|0
init|;
name|row
operator|<
name|rows
condition|;
name|row
operator|++
control|)
block|{
name|mulvalue
argument_list|(
operator|&
name|mulval
argument_list|,
name|val
argument_list|,
operator|&
name|tmpval
argument_list|)
expr_stmt|;
name|freevalue
argument_list|(
operator|&
name|mulval
argument_list|)
expr_stmt|;
name|mulval
operator|=
name|tmpval
expr_stmt|;
comment|/* ignore Saber-C warning about bad pointer into val */
name|val
operator|+=
operator|(
name|rows
operator|+
literal|1
operator|)
expr_stmt|;
block|}
name|matfree
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|neg
condition|)
block|{
name|negvalue
argument_list|(
operator|&
name|mulval
argument_list|,
operator|&
name|tmpval
argument_list|)
expr_stmt|;
name|freevalue
argument_list|(
operator|&
name|mulval
argument_list|)
expr_stmt|;
return|return
name|tmpval
return|;
block|}
return|return
name|mulval
return|;
block|}
end_function

begin_comment
comment|/*  * Local utility routine to swap two rows of a square matrix.  * No checks are made to verify the legality of the arguments.  */
end_comment

begin_function
specifier|static
name|void
name|matswaprow
parameter_list|(
name|m
parameter_list|,
name|r1
parameter_list|,
name|r2
parameter_list|)
name|MATRIX
modifier|*
name|m
decl_stmt|;
name|long
name|r1
decl_stmt|,
name|r2
decl_stmt|;
block|{
specifier|register
name|VALUE
modifier|*
name|v1
decl_stmt|,
modifier|*
name|v2
decl_stmt|;
specifier|register
name|long
name|rows
decl_stmt|;
name|VALUE
name|tmp
decl_stmt|;
if|if
condition|(
name|r1
operator|==
name|r2
condition|)
return|return;
name|rows
operator|=
operator|(
name|m
operator|->
name|m_max
index|[
literal|0
index|]
operator|-
name|m
operator|->
name|m_min
index|[
literal|0
index|]
operator|+
literal|1
operator|)
expr_stmt|;
name|v1
operator|=
operator|&
name|m
operator|->
name|m_table
index|[
name|r1
operator|*
name|rows
index|]
expr_stmt|;
name|v2
operator|=
operator|&
name|m
operator|->
name|m_table
index|[
name|r2
operator|*
name|rows
index|]
expr_stmt|;
while|while
condition|(
name|rows
operator|--
operator|>
literal|0
condition|)
block|{
name|tmp
operator|=
operator|*
name|v1
expr_stmt|;
operator|*
name|v1
operator|=
operator|*
name|v2
expr_stmt|;
operator|*
name|v2
operator|=
name|tmp
expr_stmt|;
name|v1
operator|++
expr_stmt|;
name|v2
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Local utility routine to subtract a multiple of one row to another one.  * The row to be changed is oprow, the row to be subtracted is baserow.  * No checks are made to verify the legality of the arguments.  */
end_comment

begin_function
specifier|static
name|void
name|matsubrow
parameter_list|(
name|m
parameter_list|,
name|oprow
parameter_list|,
name|baserow
parameter_list|,
name|mulval
parameter_list|)
name|MATRIX
modifier|*
name|m
decl_stmt|;
name|long
name|oprow
decl_stmt|,
name|baserow
decl_stmt|;
name|VALUE
modifier|*
name|mulval
decl_stmt|;
block|{
specifier|register
name|VALUE
modifier|*
name|vop
decl_stmt|,
modifier|*
name|vbase
decl_stmt|;
specifier|register
name|long
name|entries
decl_stmt|;
name|VALUE
name|tmp1
decl_stmt|,
name|tmp2
decl_stmt|;
name|entries
operator|=
operator|(
name|m
operator|->
name|m_max
index|[
literal|0
index|]
operator|-
name|m
operator|->
name|m_min
index|[
literal|0
index|]
operator|+
literal|1
operator|)
expr_stmt|;
name|vop
operator|=
operator|&
name|m
operator|->
name|m_table
index|[
name|oprow
operator|*
name|entries
index|]
expr_stmt|;
name|vbase
operator|=
operator|&
name|m
operator|->
name|m_table
index|[
name|baserow
operator|*
name|entries
index|]
expr_stmt|;
while|while
condition|(
name|entries
operator|--
operator|>
literal|0
condition|)
block|{
name|mulvalue
argument_list|(
name|vbase
argument_list|,
name|mulval
argument_list|,
operator|&
name|tmp1
argument_list|)
expr_stmt|;
name|subvalue
argument_list|(
name|vop
argument_list|,
operator|&
name|tmp1
argument_list|,
operator|&
name|tmp2
argument_list|)
expr_stmt|;
name|freevalue
argument_list|(
operator|&
name|tmp1
argument_list|)
expr_stmt|;
name|freevalue
argument_list|(
name|vop
argument_list|)
expr_stmt|;
operator|*
name|vop
operator|=
name|tmp2
expr_stmt|;
name|vop
operator|++
expr_stmt|;
name|vbase
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Local utility routine to multiply a row by a specified number.  * No checks are made to verify the legality of the arguments.  */
end_comment

begin_function
specifier|static
name|void
name|matmulrow
parameter_list|(
name|m
parameter_list|,
name|row
parameter_list|,
name|mulval
parameter_list|)
name|MATRIX
modifier|*
name|m
decl_stmt|;
name|long
name|row
decl_stmt|;
name|VALUE
modifier|*
name|mulval
decl_stmt|;
block|{
specifier|register
name|VALUE
modifier|*
name|val
decl_stmt|;
specifier|register
name|long
name|rows
decl_stmt|;
name|VALUE
name|tmp
decl_stmt|;
name|rows
operator|=
operator|(
name|m
operator|->
name|m_max
index|[
literal|0
index|]
operator|-
name|m
operator|->
name|m_min
index|[
literal|0
index|]
operator|+
literal|1
operator|)
expr_stmt|;
name|val
operator|=
operator|&
name|m
operator|->
name|m_table
index|[
name|row
operator|*
name|rows
index|]
expr_stmt|;
while|while
condition|(
name|rows
operator|--
operator|>
literal|0
condition|)
block|{
name|mulvalue
argument_list|(
name|val
argument_list|,
name|mulval
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
name|freevalue
argument_list|(
name|val
argument_list|)
expr_stmt|;
operator|*
name|val
operator|=
name|tmp
expr_stmt|;
name|val
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Make a full copy of a matrix.  */
end_comment

begin_function
name|MATRIX
modifier|*
name|matcopy
parameter_list|(
name|m
parameter_list|)
name|MATRIX
modifier|*
name|m
decl_stmt|;
block|{
name|MATRIX
modifier|*
name|res
decl_stmt|;
specifier|register
name|VALUE
modifier|*
name|v1
decl_stmt|,
modifier|*
name|v2
decl_stmt|;
specifier|register
name|long
name|i
decl_stmt|;
name|res
operator|=
name|matalloc
argument_list|(
name|m
operator|->
name|m_size
argument_list|)
expr_stmt|;
operator|*
name|res
operator|=
operator|*
name|m
expr_stmt|;
name|v1
operator|=
name|m
operator|->
name|m_table
expr_stmt|;
name|v2
operator|=
name|res
operator|->
name|m_table
expr_stmt|;
name|i
operator|=
name|m
operator|->
name|m_size
expr_stmt|;
while|while
condition|(
name|i
operator|--
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|v1
operator|->
name|v_type
operator|==
name|V_NUM
condition|)
block|{
name|v2
operator|->
name|v_type
operator|=
name|V_NUM
expr_stmt|;
name|v2
operator|->
name|v_num
operator|=
name|qlink
argument_list|(
name|v1
operator|->
name|v_num
argument_list|)
expr_stmt|;
block|}
else|else
name|copyvalue
argument_list|(
name|v1
argument_list|,
name|v2
argument_list|)
expr_stmt|;
name|v1
operator|++
expr_stmt|;
name|v2
operator|++
expr_stmt|;
block|}
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/*  * Allocate a matrix with the specified number of elements.  */
end_comment

begin_function
name|MATRIX
modifier|*
name|matalloc
parameter_list|(
name|size
parameter_list|)
name|long
name|size
decl_stmt|;
block|{
name|MATRIX
modifier|*
name|m
decl_stmt|;
name|m
operator|=
operator|(
name|MATRIX
operator|*
operator|)
name|malloc
argument_list|(
name|matsize
argument_list|(
name|size
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
name|math_error
argument_list|(
literal|"Cannot get memory to allocate matrix of size %d"
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_size
operator|=
name|size
expr_stmt|;
return|return
name|m
return|;
block|}
end_function

begin_comment
comment|/*  * Free a matrix, along with all of its element values.  */
end_comment

begin_function
name|void
name|matfree
parameter_list|(
name|m
parameter_list|)
name|MATRIX
modifier|*
name|m
decl_stmt|;
block|{
specifier|register
name|VALUE
modifier|*
name|vp
decl_stmt|;
specifier|register
name|long
name|i
decl_stmt|;
name|vp
operator|=
name|m
operator|->
name|m_table
expr_stmt|;
name|i
operator|=
name|m
operator|->
name|m_size
expr_stmt|;
while|while
condition|(
name|i
operator|--
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|vp
operator|->
name|v_type
operator|==
name|V_NUM
condition|)
block|{
name|vp
operator|->
name|v_type
operator|=
name|V_NULL
expr_stmt|;
name|qfree
argument_list|(
name|vp
operator|->
name|v_num
argument_list|)
expr_stmt|;
block|}
else|else
name|freevalue
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|vp
operator|++
expr_stmt|;
block|}
name|free
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Test whether a matrix has any nonzero values.  * Returns TRUE if so.  */
end_comment

begin_function
name|BOOL
name|mattest
parameter_list|(
name|m
parameter_list|)
name|MATRIX
modifier|*
name|m
decl_stmt|;
block|{
specifier|register
name|VALUE
modifier|*
name|vp
decl_stmt|;
specifier|register
name|long
name|i
decl_stmt|;
name|vp
operator|=
name|m
operator|->
name|m_table
expr_stmt|;
name|i
operator|=
name|m
operator|->
name|m_size
expr_stmt|;
while|while
condition|(
name|i
operator|--
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|vp
operator|->
name|v_type
operator|!=
name|V_NUM
operator|)
operator|||
operator|(
operator|!
name|qiszero
argument_list|(
name|vp
operator|->
name|v_num
argument_list|)
operator|)
condition|)
return|return
name|TRUE
return|;
name|vp
operator|++
expr_stmt|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/*  * Test whether or not two matrices are equal.  * Equality is determined by the shape and values of the matrices,  * but not by their index bounds.  Returns TRUE if they differ.  */
end_comment

begin_function
name|BOOL
name|matcmp
parameter_list|(
name|m1
parameter_list|,
name|m2
parameter_list|)
name|MATRIX
modifier|*
name|m1
decl_stmt|,
decl|*
name|m2
decl_stmt|;
end_function

begin_block
block|{
name|VALUE
modifier|*
name|v1
decl_stmt|,
modifier|*
name|v2
decl_stmt|;
name|long
name|i
decl_stmt|;
if|if
condition|(
name|m1
operator|==
name|m2
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|(
name|m1
operator|->
name|m_dim
operator|!=
name|m2
operator|->
name|m_dim
operator|)
operator|||
operator|(
name|m1
operator|->
name|m_size
operator|!=
name|m2
operator|->
name|m_size
operator|)
condition|)
return|return
name|TRUE
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|m1
operator|->
name|m_dim
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|m1
operator|->
name|m_max
index|[
name|i
index|]
operator|-
name|m1
operator|->
name|m_min
index|[
name|i
index|]
operator|)
operator|!=
operator|(
name|m2
operator|->
name|m_max
index|[
name|i
index|]
operator|-
name|m2
operator|->
name|m_min
index|[
name|i
index|]
operator|)
condition|)
return|return
name|TRUE
return|;
block|}
name|v1
operator|=
name|m1
operator|->
name|m_table
expr_stmt|;
name|v2
operator|=
name|m2
operator|->
name|m_table
expr_stmt|;
name|i
operator|=
name|m1
operator|->
name|m_size
expr_stmt|;
while|while
condition|(
name|i
operator|--
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|comparevalue
argument_list|(
name|v1
operator|++
argument_list|,
name|v2
operator|++
argument_list|)
condition|)
return|return
name|TRUE
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_block

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/*  * Test whether or not a matrix is the identity matrix.  * Returns TRUE if so.  */
end_comment

begin_comment
unit|BOOL matisident(m) 	MATRIX *m; { 	register VALUE *val;
comment|/* current value */
end_comment

begin_comment
unit|long row, col;
comment|/* row and column numbers */
end_comment

begin_endif
unit|if ((m->m_dim != 2) || 		((m->m_max[0] - m->m_min[0]) != (m->m_max[1] - m->m_min[1]))) 			return FALSE; 	val = m->m_table; 	for (row = 0; row< m->m_size; row++) { 		for (col = 0; col< m->m_size; col++) { 			if (val->v_type != V_NUM) 				return FALSE; 			if (row == col) { 				if (!qisone(val->v_num)) 					return FALSE; 			} else { 				if (!qiszero(val->v_num)) 					return FALSE; 			} 			val++; 		} 	} 	return TRUE; }
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Return a trivial hash value for a matrix.  */
end_comment

begin_function
name|HASH
name|mathash
parameter_list|(
name|m
parameter_list|)
name|MATRIX
modifier|*
name|m
decl_stmt|;
block|{
name|HASH
name|hash
decl_stmt|;
name|long
name|fullsize
decl_stmt|;
name|long
name|skip
decl_stmt|;
name|int
name|i
decl_stmt|;
name|VALUE
modifier|*
name|vp
decl_stmt|;
name|hash
operator|=
name|m
operator|->
name|m_dim
operator|*
literal|500009
expr_stmt|;
name|fullsize
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
name|m
operator|->
name|m_dim
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|hash
operator|=
name|hash
operator|*
literal|500029
operator|+
name|m
operator|->
name|m_max
index|[
name|i
index|]
expr_stmt|;
name|fullsize
operator|*=
operator|(
name|m
operator|->
name|m_max
index|[
name|i
index|]
operator|-
name|m
operator|->
name|m_min
index|[
name|i
index|]
operator|+
literal|1
operator|)
expr_stmt|;
block|}
name|hash
operator|=
name|hash
operator|*
literal|500041
operator|+
name|fullsize
expr_stmt|;
name|vp
operator|=
name|m
operator|->
name|m_table
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
operator|(
name|i
operator|<
name|fullsize
operator|)
operator|&&
operator|(
name|i
operator|<
literal|16
operator|)
operator|)
condition|;
name|i
operator|++
control|)
name|hash
operator|=
name|hash
operator|*
literal|500057
operator|+
name|hashvalue
argument_list|(
name|vp
operator|++
argument_list|)
expr_stmt|;
name|i
operator|=
literal|16
expr_stmt|;
name|vp
operator|=
operator|&
name|m
operator|->
name|m_table
index|[
literal|16
index|]
expr_stmt|;
name|skip
operator|=
operator|(
name|fullsize
operator|/
literal|11
operator|)
operator|+
literal|1
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|fullsize
condition|)
block|{
name|hash
operator|=
name|hash
operator|*
literal|500069
operator|+
name|hashvalue
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|i
operator|+=
name|skip
expr_stmt|;
name|vp
operator|+=
name|skip
expr_stmt|;
block|}
return|return
name|hash
return|;
block|}
end_function

begin_comment
comment|/*  * Print a matrix and possibly few of its elements.  * The argument supplied specifies how many elements to allow printing.  * If any elements are printed, they are printed in short form.  */
end_comment

begin_function
name|void
name|matprint
parameter_list|(
name|m
parameter_list|,
name|max_print
parameter_list|)
name|MATRIX
modifier|*
name|m
decl_stmt|;
name|long
name|max_print
decl_stmt|;
block|{
name|VALUE
modifier|*
name|vp
decl_stmt|;
name|long
name|fullsize
decl_stmt|,
name|count
decl_stmt|,
name|index
decl_stmt|,
name|num
decl_stmt|;
name|int
name|dim
decl_stmt|,
name|i
decl_stmt|;
name|char
modifier|*
name|msg
decl_stmt|;
name|long
name|sizes
index|[
name|MAXDIM
index|]
decl_stmt|;
name|dim
operator|=
name|m
operator|->
name|m_dim
expr_stmt|;
name|fullsize
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
name|dim
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|sizes
index|[
name|i
index|]
operator|=
name|fullsize
expr_stmt|;
name|fullsize
operator|*=
operator|(
name|m
operator|->
name|m_max
index|[
name|i
index|]
operator|-
name|m
operator|->
name|m_min
index|[
name|i
index|]
operator|+
literal|1
operator|)
expr_stmt|;
block|}
name|msg
operator|=
operator|(
operator|(
name|max_print
operator|>
literal|0
operator|)
condition|?
literal|"\nmat ["
else|:
literal|"mat ["
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dim
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|m
operator|->
name|m_min
index|[
name|i
index|]
condition|)
name|math_fmt
argument_list|(
literal|"%s%ld:%ld"
argument_list|,
name|msg
argument_list|,
name|m
operator|->
name|m_min
index|[
name|i
index|]
argument_list|,
name|m
operator|->
name|m_max
index|[
name|i
index|]
argument_list|)
expr_stmt|;
else|else
name|math_fmt
argument_list|(
literal|"%s%ld"
argument_list|,
name|msg
argument_list|,
name|m
operator|->
name|m_max
index|[
name|i
index|]
operator|+
literal|1
argument_list|)
expr_stmt|;
name|msg
operator|=
literal|","
expr_stmt|;
block|}
if|if
condition|(
name|max_print
operator|>
name|fullsize
condition|)
name|max_print
operator|=
name|fullsize
expr_stmt|;
name|vp
operator|=
name|m
operator|->
name|m_table
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|fullsize
condition|;
name|index
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|vp
operator|->
name|v_type
operator|!=
name|V_NUM
operator|)
operator|||
operator|!
name|qiszero
argument_list|(
name|vp
operator|->
name|v_num
argument_list|)
condition|)
name|count
operator|++
expr_stmt|;
name|vp
operator|++
expr_stmt|;
block|}
name|math_fmt
argument_list|(
literal|"] (%ld element%s, %ld nonzero)"
argument_list|,
name|fullsize
argument_list|,
operator|(
name|fullsize
operator|==
literal|1
operator|)
condition|?
literal|""
else|:
literal|"s"
argument_list|,
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|max_print
operator|<=
literal|0
condition|)
return|return;
comment|/* 	 * Now print the first few elements of the matrix in short 	 * and unambigous format. 	 */
name|math_str
argument_list|(
literal|":\n"
argument_list|)
expr_stmt|;
name|vp
operator|=
name|m
operator|->
name|m_table
expr_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|max_print
condition|;
name|index
operator|++
control|)
block|{
name|msg
operator|=
literal|"  ["
expr_stmt|;
name|num
operator|=
name|index
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dim
condition|;
name|i
operator|++
control|)
block|{
name|math_fmt
argument_list|(
literal|"%s%ld"
argument_list|,
name|msg
argument_list|,
name|m
operator|->
name|m_min
index|[
name|i
index|]
operator|+
operator|(
name|num
operator|/
name|sizes
index|[
name|i
index|]
operator|)
argument_list|)
expr_stmt|;
name|num
operator|%=
name|sizes
index|[
name|i
index|]
expr_stmt|;
name|msg
operator|=
literal|","
expr_stmt|;
block|}
name|math_str
argument_list|(
literal|"] = "
argument_list|)
expr_stmt|;
name|printvalue
argument_list|(
name|vp
operator|++
argument_list|,
name|PRINT_SHORT
operator||
name|PRINT_UNAMBIG
argument_list|)
expr_stmt|;
name|math_str
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|max_print
operator|<
name|fullsize
condition|)
name|math_str
argument_list|(
literal|"  ...\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* END CODE */
end_comment

end_unit

