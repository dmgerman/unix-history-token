begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1994 David I. Bell  * Permission is granted to use, distribute, or modify this source,  * provided that this copyright notice remains intact.  *  * Add opcodes to a function being compiled.  */
end_comment

begin_include
include|#
directive|include
file|"calc.h"
end_include

begin_include
include|#
directive|include
file|"opcodes.h"
end_include

begin_include
include|#
directive|include
file|"string.h"
end_include

begin_include
include|#
directive|include
file|"func.h"
end_include

begin_include
include|#
directive|include
file|"token.h"
end_include

begin_include
include|#
directive|include
file|"label.h"
end_include

begin_include
include|#
directive|include
file|"symbol.h"
end_include

begin_define
define|#
directive|define
name|FUNCALLOCSIZE
value|20
end_define

begin_comment
comment|/* reallocate size for functions */
end_comment

begin_define
define|#
directive|define
name|OPCODEALLOCSIZE
value|100
end_define

begin_comment
comment|/* reallocate size for opcodes in functions */
end_comment

begin_decl_stmt
specifier|static
name|long
name|maxopcodes
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of opcodes available */
end_comment

begin_decl_stmt
specifier|static
name|long
name|newindex
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* index of new function */
end_comment

begin_decl_stmt
specifier|static
name|long
name|oldop
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* previous opcode */
end_comment

begin_decl_stmt
specifier|static
name|long
name|debugline
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* line number of latest debug opcode */
end_comment

begin_decl_stmt
specifier|static
name|long
name|funccount
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of functions */
end_comment

begin_decl_stmt
specifier|static
name|long
name|funcavail
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* available number of functions */
end_comment

begin_decl_stmt
specifier|static
name|FUNC
modifier|*
name|functemplate
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* function definition template */
end_comment

begin_decl_stmt
specifier|static
name|FUNC
modifier|*
modifier|*
name|functions
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* table of functions */
end_comment

begin_decl_stmt
specifier|static
name|STRINGHEAD
name|funcnames
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* function names */
end_comment

begin_decl_stmt
specifier|static
name|int
name|codeflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Initialize the table of user defined functions.  */
end_comment

begin_function
name|void
name|initfunctions
parameter_list|()
block|{
name|initstr
argument_list|(
operator|&
name|funcnames
argument_list|)
expr_stmt|;
name|maxopcodes
operator|=
name|OPCODEALLOCSIZE
expr_stmt|;
name|functemplate
operator|=
operator|(
name|FUNC
operator|*
operator|)
name|malloc
argument_list|(
name|funcsize
argument_list|(
name|maxopcodes
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|functemplate
operator|==
name|NULL
condition|)
name|math_error
argument_list|(
literal|"Cannot allocate function template"
argument_list|)
expr_stmt|;
name|functions
operator|=
operator|(
name|FUNC
operator|*
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|FUNC
operator|*
argument_list|)
operator|*
name|FUNCALLOCSIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|functions
operator|==
name|NULL
condition|)
name|math_error
argument_list|(
literal|"Cannot allocate function table"
argument_list|)
expr_stmt|;
name|funccount
operator|=
literal|0
expr_stmt|;
name|funcavail
operator|=
name|FUNCALLOCSIZE
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Show the list of user defined functions.  */
end_comment

begin_function
name|void
name|showfunctions
parameter_list|()
block|{
name|FUNC
modifier|*
modifier|*
name|fpp
decl_stmt|;
comment|/* pointer into function table */
name|FUNC
modifier|*
name|fp
decl_stmt|;
comment|/* current function */
if|if
condition|(
name|funccount
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"No user functions defined.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|printf
argument_list|(
literal|"Name Arguments\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"---- ---------\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|fpp
operator|=
operator|&
name|functions
index|[
name|funccount
operator|-
literal|1
index|]
init|;
name|fpp
operator|>=
name|functions
condition|;
name|fpp
operator|--
control|)
block|{
name|fp
operator|=
operator|*
name|fpp
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
continue|continue;
name|printf
argument_list|(
literal|"%-12s %-2d\n"
argument_list|,
name|fp
operator|->
name|f_name
argument_list|,
name|fp
operator|->
name|f_paramcount
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Initialize a function for definition.  * Newflag is TRUE if we should allocate a new function structure,  * instead of the usual overwriting of the template function structure.  * The new structure is returned in the global curfunc variable.  */
end_comment

begin_function
name|void
name|beginfunc
parameter_list|(
name|name
parameter_list|,
name|newflag
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
comment|/* name of function */
name|BOOL
name|newflag
decl_stmt|;
comment|/* TRUE if need new structure */
block|{
specifier|register
name|FUNC
modifier|*
name|fp
decl_stmt|;
comment|/* current function */
name|newindex
operator|=
name|adduserfunc
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|maxopcodes
operator|=
name|OPCODEALLOCSIZE
expr_stmt|;
name|fp
operator|=
name|functemplate
expr_stmt|;
if|if
condition|(
name|newflag
condition|)
block|{
name|fp
operator|=
operator|(
name|FUNC
operator|*
operator|)
name|malloc
argument_list|(
name|funcsize
argument_list|(
name|maxopcodes
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
name|math_error
argument_list|(
literal|"Cannot allocate temporary function"
argument_list|)
expr_stmt|;
block|}
name|fp
operator|->
name|f_next
operator|=
name|NULL
expr_stmt|;
name|fp
operator|->
name|f_localcount
operator|=
literal|0
expr_stmt|;
name|fp
operator|->
name|f_opcodecount
operator|=
literal|0
expr_stmt|;
name|fp
operator|->
name|f_savedvalue
operator|.
name|v_type
operator|=
name|V_NULL
expr_stmt|;
name|fp
operator|->
name|f_name
operator|=
name|namestr
argument_list|(
operator|&
name|funcnames
argument_list|,
name|newindex
argument_list|)
expr_stmt|;
name|curfunc
operator|=
name|fp
expr_stmt|;
name|initlocals
argument_list|()
expr_stmt|;
name|initlabels
argument_list|()
expr_stmt|;
name|oldop
operator|=
name|OP_NOP
expr_stmt|;
name|debugline
operator|=
literal|0
expr_stmt|;
name|errorcount
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Commit the just defined function for use.  * This replaces any existing definition for the function.  * This should only be called for normal user-defined functions.  */
end_comment

begin_function
name|void
name|endfunc
parameter_list|()
block|{
specifier|register
name|FUNC
modifier|*
name|fp
decl_stmt|;
comment|/* function just finished */
name|long
name|size
decl_stmt|;
comment|/* size of just created function */
name|checklabels
argument_list|()
expr_stmt|;
if|if
condition|(
name|errorcount
condition|)
block|{
name|printf
argument_list|(
literal|"\"%s\": %ld error%s\n"
argument_list|,
name|curfunc
operator|->
name|f_name
argument_list|,
name|errorcount
argument_list|,
operator|(
operator|(
name|errorcount
operator|==
literal|1
operator|)
condition|?
literal|""
else|:
literal|"s"
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|size
operator|=
name|funcsize
argument_list|(
name|curfunc
operator|->
name|f_opcodecount
argument_list|)
expr_stmt|;
name|fp
operator|=
operator|(
name|FUNC
operator|*
operator|)
name|malloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
name|math_error
argument_list|(
literal|"Cannot commit function"
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|fp
argument_list|,
operator|(
name|char
operator|*
operator|)
name|curfunc
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|curfunc
operator|!=
name|functemplate
condition|)
name|free
argument_list|(
name|curfunc
argument_list|)
expr_stmt|;
if|if
condition|(
name|codeflag
condition|)
block|{
for|for
control|(
name|size
operator|=
literal|0
init|;
name|size
operator|<
name|fp
operator|->
name|f_opcodecount
condition|;
control|)
block|{
name|printf
argument_list|(
literal|"%ld: "
argument_list|,
operator|(
name|long
operator|)
name|size
argument_list|)
expr_stmt|;
name|size
operator|+=
name|dumpop
argument_list|(
operator|&
name|fp
operator|->
name|f_opcodes
index|[
name|size
index|]
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|functions
index|[
name|newindex
index|]
condition|)
name|free
argument_list|(
name|functions
index|[
name|newindex
index|]
argument_list|)
expr_stmt|;
name|functions
index|[
name|newindex
index|]
operator|=
name|fp
expr_stmt|;
name|objuncache
argument_list|()
expr_stmt|;
if|if
condition|(
name|inputisterminal
argument_list|()
condition|)
name|printf
argument_list|(
literal|"\"%s\" defined\n"
argument_list|,
name|fp
operator|->
name|f_name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Find the user function with the specified name, and return its index.  * If the function does not exist, its name is added to the function table  * and an error will be generated when it is called if it is still undefined.  */
end_comment

begin_function
name|long
name|adduserfunc
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
comment|/* name of function */
block|{
name|long
name|index
decl_stmt|;
comment|/* index of function */
name|index
operator|=
name|findstr
argument_list|(
operator|&
name|funcnames
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|>=
literal|0
condition|)
return|return
name|index
return|;
if|if
condition|(
name|funccount
operator|>=
name|funcavail
condition|)
block|{
name|functions
operator|=
operator|(
name|FUNC
operator|*
operator|*
operator|)
name|realloc
argument_list|(
name|functions
argument_list|,
sizeof|sizeof
argument_list|(
name|FUNC
operator|*
argument_list|)
operator|*
operator|(
name|funcavail
operator|+
name|FUNCALLOCSIZE
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|functions
operator|==
name|NULL
condition|)
name|math_error
argument_list|(
literal|"Failed to reallocate function table"
argument_list|)
expr_stmt|;
name|funcavail
operator|+=
name|FUNCALLOCSIZE
expr_stmt|;
block|}
if|if
condition|(
name|addstr
argument_list|(
operator|&
name|funcnames
argument_list|,
name|name
argument_list|)
operator|==
name|NULL
condition|)
name|math_error
argument_list|(
literal|"Cannot save function name"
argument_list|)
expr_stmt|;
name|index
operator|=
name|funccount
operator|++
expr_stmt|;
name|functions
index|[
name|index
index|]
operator|=
name|NULL
expr_stmt|;
return|return
name|index
return|;
block|}
end_function

begin_comment
comment|/*  * Clear any optimization that may be done for the next opcode.  * This is used when defining a label.  */
end_comment

begin_function
name|void
name|clearopt
parameter_list|()
block|{
name|oldop
operator|=
name|OP_NOP
expr_stmt|;
name|debugline
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Find a function structure given its index.  */
end_comment

begin_function
name|FUNC
modifier|*
name|findfunc
parameter_list|(
name|index
parameter_list|)
name|long
name|index
decl_stmt|;
block|{
if|if
condition|(
operator|(
name|unsigned
name|long
operator|)
name|index
operator|>=
name|funccount
condition|)
name|math_error
argument_list|(
literal|"Undefined function"
argument_list|)
expr_stmt|;
return|return
name|functions
index|[
name|index
index|]
return|;
block|}
end_function

begin_comment
comment|/*  * Return the name of a function given its index.  */
end_comment

begin_function
name|char
modifier|*
name|namefunc
parameter_list|(
name|index
parameter_list|)
name|long
name|index
decl_stmt|;
block|{
return|return
name|namestr
argument_list|(
operator|&
name|funcnames
argument_list|,
name|index
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Let a matrix indexing operation know that it will be treated as a write  * reference instead of just as a read reference.  */
end_comment

begin_function
name|void
name|writeindexop
parameter_list|()
block|{
if|if
condition|(
name|oldop
operator|==
name|OP_INDEXADDR
condition|)
name|curfunc
operator|->
name|f_opcodes
index|[
name|curfunc
operator|->
name|f_opcodecount
operator|-
literal|1
index|]
operator|=
name|TRUE
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Add an opcode to the current function being compiled.  * Note: This can change the curfunc global variable when the  * function needs expanding.  */
end_comment

begin_function
name|void
name|addop
parameter_list|(
name|op
parameter_list|)
name|long
name|op
decl_stmt|;
block|{
specifier|register
name|FUNC
modifier|*
name|fp
decl_stmt|;
comment|/* current function */
name|NUMBER
modifier|*
name|q
decl_stmt|;
name|fp
operator|=
name|curfunc
expr_stmt|;
if|if
condition|(
operator|(
name|fp
operator|->
name|f_opcodecount
operator|+
literal|5
operator|)
operator|>=
name|maxopcodes
condition|)
block|{
name|maxopcodes
operator|+=
name|OPCODEALLOCSIZE
expr_stmt|;
name|fp
operator|=
operator|(
name|FUNC
operator|*
operator|)
name|malloc
argument_list|(
name|funcsize
argument_list|(
name|maxopcodes
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
name|math_error
argument_list|(
literal|"cannot malloc function"
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|fp
argument_list|,
operator|(
name|char
operator|*
operator|)
name|curfunc
argument_list|,
name|funcsize
argument_list|(
name|curfunc
operator|->
name|f_opcodecount
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|curfunc
operator|!=
name|functemplate
condition|)
name|free
argument_list|(
name|curfunc
argument_list|)
expr_stmt|;
name|curfunc
operator|=
name|fp
expr_stmt|;
block|}
comment|/* 	 * Check the current opcode against the previous opcode and try to 	 * slightly optimize the code depending on the various combinations. 	 */
if|if
condition|(
name|op
operator|==
name|OP_GETVALUE
condition|)
block|{
switch|switch
condition|(
name|oldop
condition|)
block|{
case|case
name|OP_NUMBER
case|:
case|case
name|OP_ZERO
case|:
case|case
name|OP_ONE
case|:
case|case
name|OP_IMAGINARY
case|:
case|case
name|OP_GETEPSILON
case|:
case|case
name|OP_SETEPSILON
case|:
case|case
name|OP_STRING
case|:
case|case
name|OP_UNDEF
case|:
case|case
name|OP_GETCONFIG
case|:
case|case
name|OP_SETCONFIG
case|:
return|return;
case|case
name|OP_DUPLICATE
case|:
name|fp
operator|->
name|f_opcodes
index|[
name|fp
operator|->
name|f_opcodecount
operator|-
literal|1
index|]
operator|=
name|OP_DUPVALUE
expr_stmt|;
name|oldop
operator|=
name|OP_DUPVALUE
expr_stmt|;
return|return;
case|case
name|OP_FIADDR
case|:
name|fp
operator|->
name|f_opcodes
index|[
name|fp
operator|->
name|f_opcodecount
operator|-
literal|1
index|]
operator|=
name|OP_FIVALUE
expr_stmt|;
name|oldop
operator|=
name|OP_FIVALUE
expr_stmt|;
return|return;
case|case
name|OP_GLOBALADDR
case|:
name|fp
operator|->
name|f_opcodes
index|[
name|fp
operator|->
name|f_opcodecount
operator|-
literal|2
index|]
operator|=
name|OP_GLOBALVALUE
expr_stmt|;
name|oldop
operator|=
name|OP_GLOBALVALUE
expr_stmt|;
return|return;
case|case
name|OP_LOCALADDR
case|:
name|fp
operator|->
name|f_opcodes
index|[
name|fp
operator|->
name|f_opcodecount
operator|-
literal|2
index|]
operator|=
name|OP_LOCALVALUE
expr_stmt|;
name|oldop
operator|=
name|OP_LOCALVALUE
expr_stmt|;
return|return;
case|case
name|OP_PARAMADDR
case|:
name|fp
operator|->
name|f_opcodes
index|[
name|fp
operator|->
name|f_opcodecount
operator|-
literal|2
index|]
operator|=
name|OP_PARAMVALUE
expr_stmt|;
name|oldop
operator|=
name|OP_PARAMVALUE
expr_stmt|;
return|return;
case|case
name|OP_ELEMADDR
case|:
name|fp
operator|->
name|f_opcodes
index|[
name|fp
operator|->
name|f_opcodecount
operator|-
literal|2
index|]
operator|=
name|OP_ELEMVALUE
expr_stmt|;
name|oldop
operator|=
name|OP_ELEMVALUE
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
operator|(
name|op
operator|==
name|OP_NEGATE
operator|)
operator|&&
operator|(
name|oldop
operator|==
name|OP_NUMBER
operator|)
condition|)
block|{
name|q
operator|=
name|constvalue
argument_list|(
name|fp
operator|->
name|f_opcodes
index|[
name|fp
operator|->
name|f_opcodecount
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
name|fp
operator|->
name|f_opcodes
index|[
name|fp
operator|->
name|f_opcodecount
operator|-
literal|1
index|]
operator|=
name|addqconstant
argument_list|(
name|qneg
argument_list|(
name|q
argument_list|)
argument_list|)
expr_stmt|;
name|oldop
operator|=
name|OP_NUMBER
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|op
operator|==
name|OP_POWER
operator|)
operator|&&
operator|(
name|oldop
operator|==
name|OP_NUMBER
operator|)
condition|)
block|{
if|if
condition|(
name|qcmpi
argument_list|(
name|constvalue
argument_list|(
name|fp
operator|->
name|f_opcodes
index|[
name|fp
operator|->
name|f_opcodecount
operator|-
literal|1
index|]
argument_list|)
argument_list|,
literal|2L
argument_list|)
operator|==
literal|0
condition|)
block|{
name|fp
operator|->
name|f_opcodecount
operator|--
expr_stmt|;
name|fp
operator|->
name|f_opcodes
index|[
name|fp
operator|->
name|f_opcodecount
operator|-
literal|1
index|]
operator|=
name|OP_SQUARE
expr_stmt|;
name|oldop
operator|=
name|OP_SQUARE
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|qcmpi
argument_list|(
name|constvalue
argument_list|(
name|fp
operator|->
name|f_opcodes
index|[
name|fp
operator|->
name|f_opcodecount
operator|-
literal|1
index|]
argument_list|)
argument_list|,
literal|4L
argument_list|)
operator|==
literal|0
condition|)
block|{
name|fp
operator|->
name|f_opcodes
index|[
name|fp
operator|->
name|f_opcodecount
operator|-
literal|2
index|]
operator|=
name|OP_SQUARE
expr_stmt|;
name|fp
operator|->
name|f_opcodes
index|[
name|fp
operator|->
name|f_opcodecount
operator|-
literal|1
index|]
operator|=
name|OP_SQUARE
expr_stmt|;
name|oldop
operator|=
name|OP_SQUARE
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
operator|(
name|op
operator|==
name|OP_POP
operator|)
operator|&&
operator|(
name|oldop
operator|==
name|OP_ASSIGN
operator|)
condition|)
block|{
comment|/* optimize */
name|fp
operator|->
name|f_opcodes
index|[
name|fp
operator|->
name|f_opcodecount
operator|-
literal|1
index|]
operator|=
name|OP_ASSIGNPOP
expr_stmt|;
name|oldop
operator|=
name|OP_ASSIGNPOP
expr_stmt|;
return|return;
block|}
comment|/* 	 * No optimization possible, so store the opcode. 	 */
name|fp
operator|->
name|f_opcodes
index|[
name|fp
operator|->
name|f_opcodecount
index|]
operator|=
name|op
expr_stmt|;
name|fp
operator|->
name|f_opcodecount
operator|++
expr_stmt|;
name|oldop
operator|=
name|op
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Add an opcode and and one integer argument to the current function  * being compiled.  */
end_comment

begin_function
name|void
name|addopone
parameter_list|(
name|op
parameter_list|,
name|arg
parameter_list|)
name|long
name|op
decl_stmt|;
name|long
name|arg
decl_stmt|;
block|{
name|NUMBER
modifier|*
name|q
decl_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|OP_NUMBER
case|:
name|q
operator|=
name|constvalue
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
name|qiszero
argument_list|(
name|q
argument_list|)
condition|)
block|{
name|addop
argument_list|(
name|OP_ZERO
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|qisone
argument_list|(
name|q
argument_list|)
condition|)
block|{
name|addop
argument_list|(
name|OP_ONE
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
case|case
name|OP_DEBUG
case|:
if|if
condition|(
operator|(
name|traceflags
operator|&
name|TRACE_NODEBUG
operator|)
operator|||
operator|(
name|arg
operator|==
name|debugline
operator|)
condition|)
return|return;
name|debugline
operator|=
name|arg
expr_stmt|;
if|if
condition|(
name|oldop
operator|==
name|OP_DEBUG
condition|)
block|{
name|curfunc
operator|->
name|f_opcodes
index|[
name|curfunc
operator|->
name|f_opcodecount
operator|-
literal|1
index|]
operator|=
name|arg
expr_stmt|;
return|return;
block|}
break|break;
block|}
name|addop
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|curfunc
operator|->
name|f_opcodes
index|[
name|curfunc
operator|->
name|f_opcodecount
index|]
operator|=
name|arg
expr_stmt|;
name|curfunc
operator|->
name|f_opcodecount
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Add an opcode and and two integer arguments to the current function  * being compiled.  */
end_comment

begin_function
name|void
name|addoptwo
parameter_list|(
name|op
parameter_list|,
name|arg1
parameter_list|,
name|arg2
parameter_list|)
name|long
name|op
decl_stmt|;
name|long
name|arg1
decl_stmt|;
name|long
name|arg2
decl_stmt|;
block|{
name|addop
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|curfunc
operator|->
name|f_opcodes
index|[
name|curfunc
operator|->
name|f_opcodecount
operator|++
index|]
operator|=
name|arg1
expr_stmt|;
name|curfunc
operator|->
name|f_opcodes
index|[
name|curfunc
operator|->
name|f_opcodecount
operator|++
index|]
operator|=
name|arg2
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Add an opcode and a character pointer to the function being compiled.  */
end_comment

begin_function
name|void
name|addopptr
parameter_list|(
name|op
parameter_list|,
name|ptr
parameter_list|)
name|long
name|op
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
block|{
name|char
modifier|*
modifier|*
name|ptraddr
decl_stmt|;
name|addop
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|ptraddr
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
operator|&
name|curfunc
operator|->
name|f_opcodes
index|[
name|curfunc
operator|->
name|f_opcodecount
index|]
expr_stmt|;
operator|*
name|ptraddr
operator|=
name|ptr
expr_stmt|;
name|curfunc
operator|->
name|f_opcodecount
operator|+=
name|PTR_SIZE
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Add an opcode and an index and an argument count for a function call.  */
end_comment

begin_function
name|void
name|addopfunction
parameter_list|(
name|op
parameter_list|,
name|index
parameter_list|,
name|count
parameter_list|)
name|int
name|count
decl_stmt|;
name|long
name|op
decl_stmt|;
name|long
name|index
decl_stmt|;
block|{
name|long
name|newop
decl_stmt|;
if|if
condition|(
operator|(
name|op
operator|==
name|OP_CALL
operator|)
operator|&&
operator|(
operator|(
name|newop
operator|=
name|builtinopcode
argument_list|(
name|index
argument_list|)
operator|)
operator|!=
name|OP_NOP
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|newop
operator|==
name|OP_SETCONFIG
operator|)
operator|&&
operator|(
name|count
operator|==
literal|1
operator|)
condition|)
name|newop
operator|=
name|OP_GETCONFIG
expr_stmt|;
if|if
condition|(
operator|(
name|newop
operator|==
name|OP_SETEPSILON
operator|)
operator|&&
operator|(
name|count
operator|==
literal|0
operator|)
condition|)
name|newop
operator|=
name|OP_GETEPSILON
expr_stmt|;
if|if
condition|(
operator|(
name|newop
operator|==
name|OP_ABS
operator|)
operator|&&
operator|(
name|count
operator|==
literal|1
operator|)
condition|)
name|addop
argument_list|(
name|OP_GETEPSILON
argument_list|)
expr_stmt|;
name|addop
argument_list|(
name|newop
argument_list|)
expr_stmt|;
return|return;
block|}
name|addop
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|curfunc
operator|->
name|f_opcodes
index|[
name|curfunc
operator|->
name|f_opcodecount
operator|++
index|]
operator|=
name|index
expr_stmt|;
name|curfunc
operator|->
name|f_opcodes
index|[
name|curfunc
operator|->
name|f_opcodecount
operator|++
index|]
operator|=
name|count
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Add a jump-type opcode and a label to the function being compiled.  */
end_comment

begin_function
name|void
name|addoplabel
parameter_list|(
name|op
parameter_list|,
name|label
parameter_list|)
name|long
name|op
decl_stmt|;
name|LABEL
modifier|*
name|label
decl_stmt|;
comment|/* label to be added */
block|{
name|addop
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|uselabel
argument_list|(
name|label
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* END CODE */
end_comment

end_unit

