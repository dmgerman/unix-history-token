begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1993 David I. Bell  * Permission is granted to use, distribute, or modify this source,  * provided that this copyright notice remains intact.  *  * Extended precision complex arithmetic non-primitive routines  */
end_comment

begin_include
include|#
directive|include
file|"cmath.h"
end_include

begin_comment
comment|/*  * Round a complex number to the specified number of decimal places.  * This simply means to round each of the components of the number.  * Zero decimal places means round to the nearest complex integer.  */
end_comment

begin_function
name|COMPLEX
modifier|*
name|cround
parameter_list|(
name|c
parameter_list|,
name|places
parameter_list|)
name|COMPLEX
modifier|*
name|c
decl_stmt|;
name|long
name|places
decl_stmt|;
block|{
name|COMPLEX
modifier|*
name|res
decl_stmt|;
comment|/* result */
name|res
operator|=
name|comalloc
argument_list|()
expr_stmt|;
name|res
operator|->
name|real
operator|=
name|qround
argument_list|(
name|c
operator|->
name|real
argument_list|,
name|places
argument_list|)
expr_stmt|;
name|res
operator|->
name|imag
operator|=
name|qround
argument_list|(
name|c
operator|->
name|imag
argument_list|,
name|places
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/*  * Round a complex number to the specified number of binary decimal places.  * This simply means to round each of the components of the number.  * Zero binary places means round to the nearest complex integer.  */
end_comment

begin_function
name|COMPLEX
modifier|*
name|cbround
parameter_list|(
name|c
parameter_list|,
name|places
parameter_list|)
name|COMPLEX
modifier|*
name|c
decl_stmt|;
name|long
name|places
decl_stmt|;
block|{
name|COMPLEX
modifier|*
name|res
decl_stmt|;
comment|/* result */
name|res
operator|=
name|comalloc
argument_list|()
expr_stmt|;
name|res
operator|->
name|real
operator|=
name|qbround
argument_list|(
name|c
operator|->
name|real
argument_list|,
name|places
argument_list|)
expr_stmt|;
name|res
operator|->
name|imag
operator|=
name|qbround
argument_list|(
name|c
operator|->
name|imag
argument_list|,
name|places
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/*  * Compute the result of raising a complex number to an integer power.  */
end_comment

begin_function
name|COMPLEX
modifier|*
name|cpowi
parameter_list|(
name|c
parameter_list|,
name|q
parameter_list|)
name|COMPLEX
modifier|*
name|c
decl_stmt|;
comment|/* complex number to be raised */
name|NUMBER
modifier|*
name|q
decl_stmt|;
comment|/* power to raise it to */
block|{
name|COMPLEX
modifier|*
name|tmp
decl_stmt|,
modifier|*
name|res
decl_stmt|;
comment|/* temporary values */
name|long
name|power
decl_stmt|;
comment|/* power to raise to */
name|unsigned
name|long
name|bit
decl_stmt|;
comment|/* current bit value */
name|int
name|sign
decl_stmt|;
if|if
condition|(
name|qisfrac
argument_list|(
name|q
argument_list|)
condition|)
name|math_error
argument_list|(
literal|"Raising number to non-integral power"
argument_list|)
expr_stmt|;
if|if
condition|(
name|zisbig
argument_list|(
name|q
operator|->
name|num
argument_list|)
condition|)
name|math_error
argument_list|(
literal|"Raising number to very large power"
argument_list|)
expr_stmt|;
name|power
operator|=
operator|(
name|zistiny
argument_list|(
name|q
operator|->
name|num
argument_list|)
condition|?
name|z1tol
argument_list|(
name|q
operator|->
name|num
argument_list|)
else|:
name|z2tol
argument_list|(
name|q
operator|->
name|num
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|ciszero
argument_list|(
name|c
argument_list|)
operator|&&
operator|(
name|power
operator|==
literal|0
operator|)
condition|)
name|math_error
argument_list|(
literal|"Raising zero to zeroth power"
argument_list|)
expr_stmt|;
name|sign
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|qisneg
argument_list|(
name|q
argument_list|)
condition|)
name|sign
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* 	 * Handle some low powers specially 	 */
if|if
condition|(
name|power
operator|<=
literal|4
condition|)
block|{
switch|switch
condition|(
call|(
name|int
call|)
argument_list|(
name|power
operator|*
name|sign
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
return|return
name|clink
argument_list|(
operator|&
name|_cone_
argument_list|)
return|;
case|case
literal|1
case|:
return|return
name|clink
argument_list|(
name|c
argument_list|)
return|;
case|case
operator|-
literal|1
case|:
return|return
name|cinv
argument_list|(
name|c
argument_list|)
return|;
case|case
literal|2
case|:
return|return
name|csquare
argument_list|(
name|c
argument_list|)
return|;
case|case
operator|-
literal|2
case|:
name|tmp
operator|=
name|csquare
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|res
operator|=
name|cinv
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|comfree
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
return|return
name|res
return|;
case|case
literal|3
case|:
name|tmp
operator|=
name|csquare
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|res
operator|=
name|cmul
argument_list|(
name|c
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|comfree
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
return|return
name|res
return|;
case|case
literal|4
case|:
name|tmp
operator|=
name|csquare
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|res
operator|=
name|csquare
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|comfree
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
block|}
comment|/* 	 * Compute the power by squaring and multiplying. 	 * This uses the left to right method of power raising. 	 */
name|bit
operator|=
name|TOPFULL
expr_stmt|;
while|while
condition|(
operator|(
name|bit
operator|&
name|power
operator|)
operator|==
literal|0
condition|)
name|bit
operator|>>=
literal|1L
expr_stmt|;
name|bit
operator|>>=
literal|1L
expr_stmt|;
name|res
operator|=
name|csquare
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|bit
operator|&
name|power
condition|)
block|{
name|tmp
operator|=
name|cmul
argument_list|(
name|res
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|comfree
argument_list|(
name|res
argument_list|)
expr_stmt|;
name|res
operator|=
name|tmp
expr_stmt|;
block|}
name|bit
operator|>>=
literal|1L
expr_stmt|;
while|while
condition|(
name|bit
condition|)
block|{
name|tmp
operator|=
name|csquare
argument_list|(
name|res
argument_list|)
expr_stmt|;
name|comfree
argument_list|(
name|res
argument_list|)
expr_stmt|;
name|res
operator|=
name|tmp
expr_stmt|;
if|if
condition|(
name|bit
operator|&
name|power
condition|)
block|{
name|tmp
operator|=
name|cmul
argument_list|(
name|res
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|comfree
argument_list|(
name|res
argument_list|)
expr_stmt|;
name|res
operator|=
name|tmp
expr_stmt|;
block|}
name|bit
operator|>>=
literal|1L
expr_stmt|;
block|}
if|if
condition|(
name|sign
operator|<
literal|0
condition|)
block|{
name|tmp
operator|=
name|cinv
argument_list|(
name|res
argument_list|)
expr_stmt|;
name|comfree
argument_list|(
name|res
argument_list|)
expr_stmt|;
name|res
operator|=
name|tmp
expr_stmt|;
block|}
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/*  * Calculate the square root of a complex number, with each component  * within the specified error.  If the number is a square, then the error  * is zero.  For sqrt(a + bi), this calculates:  *	R = sqrt(a^2 + b^2)  *	U = sqrt((R + abs(a))/2)  *	V = b/(2 * U)  *	then sqrt(a + bi) = U + Vi if a>= 0,  *	or abs(V) + sgn(b) * U  if a< 0  */
end_comment

begin_function
name|COMPLEX
modifier|*
name|csqrt
parameter_list|(
name|c
parameter_list|,
name|epsilon
parameter_list|)
name|COMPLEX
modifier|*
name|c
decl_stmt|;
name|NUMBER
modifier|*
name|epsilon
decl_stmt|;
block|{
name|COMPLEX
modifier|*
name|r
decl_stmt|;
name|NUMBER
modifier|*
name|A
decl_stmt|,
modifier|*
name|B
decl_stmt|,
modifier|*
name|R
decl_stmt|,
modifier|*
name|U
decl_stmt|,
modifier|*
name|V
decl_stmt|,
modifier|*
name|tmp1
decl_stmt|,
modifier|*
name|tmp2
decl_stmt|,
modifier|*
name|epsilon2
decl_stmt|;
name|long
name|m
decl_stmt|,
name|n
decl_stmt|;
if|if
condition|(
name|ciszero
argument_list|(
name|c
argument_list|)
operator|||
name|cisone
argument_list|(
name|c
argument_list|)
condition|)
return|return
name|clink
argument_list|(
name|c
argument_list|)
return|;
if|if
condition|(
name|cisreal
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|r
operator|=
name|comalloc
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|qisneg
argument_list|(
name|c
operator|->
name|real
argument_list|)
condition|)
block|{
name|r
operator|->
name|real
operator|=
name|qsqrt
argument_list|(
name|c
operator|->
name|real
argument_list|,
name|epsilon
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
name|tmp1
operator|=
name|qneg
argument_list|(
name|c
operator|->
name|real
argument_list|)
expr_stmt|;
name|r
operator|->
name|imag
operator|=
name|qsqrt
argument_list|(
name|tmp1
argument_list|,
name|epsilon
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|tmp1
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
name|A
operator|=
name|qlink
argument_list|(
name|c
operator|->
name|real
argument_list|)
expr_stmt|;
name|B
operator|=
name|qlink
argument_list|(
name|c
operator|->
name|imag
argument_list|)
expr_stmt|;
name|n
operator|=
name|zhighbit
argument_list|(
name|B
operator|->
name|num
argument_list|)
operator|-
name|zhighbit
argument_list|(
name|B
operator|->
name|den
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|qiszero
argument_list|(
name|A
argument_list|)
condition|)
block|{
name|m
operator|=
name|zhighbit
argument_list|(
name|A
operator|->
name|num
argument_list|)
operator|-
name|zhighbit
argument_list|(
name|A
operator|->
name|den
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|>
name|n
condition|)
name|n
operator|=
name|m
expr_stmt|;
block|}
name|epsilon2
operator|=
name|qscale
argument_list|(
name|epsilon
argument_list|,
name|n
operator|/
literal|2
argument_list|)
expr_stmt|;
name|R
operator|=
name|qhypot
argument_list|(
name|A
argument_list|,
name|B
argument_list|,
name|epsilon2
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|epsilon2
argument_list|)
expr_stmt|;
if|if
condition|(
name|qisneg
argument_list|(
name|A
argument_list|)
condition|)
name|tmp1
operator|=
name|qsub
argument_list|(
name|R
argument_list|,
name|A
argument_list|)
expr_stmt|;
else|else
name|tmp1
operator|=
name|qadd
argument_list|(
name|R
argument_list|,
name|A
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|A
argument_list|)
expr_stmt|;
name|tmp2
operator|=
name|qscale
argument_list|(
name|tmp1
argument_list|,
operator|-
literal|1L
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|tmp1
argument_list|)
expr_stmt|;
name|U
operator|=
name|qsqrt
argument_list|(
name|tmp2
argument_list|,
name|epsilon
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|tmp2
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|R
argument_list|)
expr_stmt|;
if|if
condition|(
name|qiszero
argument_list|(
name|U
argument_list|)
condition|)
block|{
name|qfree
argument_list|(
name|B
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|U
argument_list|)
expr_stmt|;
return|return
name|clink
argument_list|(
operator|&
name|_czero_
argument_list|)
return|;
block|}
name|tmp1
operator|=
name|qdiv
argument_list|(
name|B
argument_list|,
name|U
argument_list|)
expr_stmt|;
name|V
operator|=
name|qscale
argument_list|(
name|tmp1
argument_list|,
operator|-
literal|1L
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|tmp1
argument_list|)
expr_stmt|;
name|r
operator|=
name|comalloc
argument_list|()
expr_stmt|;
if|if
condition|(
name|qisneg
argument_list|(
name|c
operator|->
name|real
argument_list|)
condition|)
block|{
if|if
condition|(
name|qisneg
argument_list|(
name|B
argument_list|)
condition|)
block|{
name|tmp1
operator|=
name|qneg
argument_list|(
name|U
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|U
argument_list|)
expr_stmt|;
name|U
operator|=
name|tmp1
expr_stmt|;
name|tmp2
operator|=
name|qabs
argument_list|(
name|V
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|V
argument_list|)
expr_stmt|;
name|V
operator|=
name|tmp2
expr_stmt|;
block|}
name|r
operator|->
name|real
operator|=
name|V
expr_stmt|;
name|r
operator|->
name|imag
operator|=
name|U
expr_stmt|;
block|}
else|else
block|{
name|r
operator|->
name|real
operator|=
name|U
expr_stmt|;
name|r
operator|->
name|imag
operator|=
name|V
expr_stmt|;
block|}
name|qfree
argument_list|(
name|B
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/*  * Take the Nth root of a complex number, where N is a positive integer.  * Each component of the result is within the specified error.  */
end_comment

begin_function
name|COMPLEX
modifier|*
name|croot
parameter_list|(
name|c
parameter_list|,
name|q
parameter_list|,
name|epsilon
parameter_list|)
name|COMPLEX
modifier|*
name|c
decl_stmt|;
name|NUMBER
modifier|*
name|q
decl_stmt|,
decl|*
name|epsilon
decl_stmt|;
end_function

begin_block
block|{
name|COMPLEX
modifier|*
name|r
decl_stmt|;
name|NUMBER
modifier|*
name|a2pb2
decl_stmt|,
modifier|*
name|root
decl_stmt|,
modifier|*
name|tmp1
decl_stmt|,
modifier|*
name|tmp2
decl_stmt|,
modifier|*
name|epsilon2
decl_stmt|;
if|if
condition|(
name|qisneg
argument_list|(
name|q
argument_list|)
operator|||
name|qiszero
argument_list|(
name|q
argument_list|)
operator|||
name|qisfrac
argument_list|(
name|q
argument_list|)
condition|)
name|math_error
argument_list|(
literal|"Taking bad root of complex number"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cisone
argument_list|(
name|c
argument_list|)
operator|||
name|qisone
argument_list|(
name|q
argument_list|)
condition|)
return|return
name|clink
argument_list|(
name|c
argument_list|)
return|;
if|if
condition|(
name|qistwo
argument_list|(
name|q
argument_list|)
condition|)
return|return
name|csqrt
argument_list|(
name|c
argument_list|,
name|epsilon
argument_list|)
return|;
name|r
operator|=
name|comalloc
argument_list|()
expr_stmt|;
if|if
condition|(
name|cisreal
argument_list|(
name|c
argument_list|)
operator|&&
operator|!
name|qisneg
argument_list|(
name|c
operator|->
name|real
argument_list|)
condition|)
block|{
name|r
operator|->
name|real
operator|=
name|qroot
argument_list|(
name|c
operator|->
name|real
argument_list|,
name|q
argument_list|,
name|epsilon
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
comment|/* 	 * Calculate the root using the formula: 	 *	croot(a + bi, n) = 	 *		cpolar(qroot(a^2 + b^2, 2 * n), qatan2(b, a) / n). 	 */
name|epsilon2
operator|=
name|qscale
argument_list|(
name|epsilon
argument_list|,
operator|-
literal|8L
argument_list|)
expr_stmt|;
name|tmp1
operator|=
name|qsquare
argument_list|(
name|c
operator|->
name|real
argument_list|)
expr_stmt|;
name|tmp2
operator|=
name|qsquare
argument_list|(
name|c
operator|->
name|imag
argument_list|)
expr_stmt|;
name|a2pb2
operator|=
name|qadd
argument_list|(
name|tmp1
argument_list|,
name|tmp2
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|tmp1
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|tmp2
argument_list|)
expr_stmt|;
name|tmp1
operator|=
name|qscale
argument_list|(
name|q
argument_list|,
literal|1L
argument_list|)
expr_stmt|;
name|root
operator|=
name|qroot
argument_list|(
name|a2pb2
argument_list|,
name|tmp1
argument_list|,
name|epsilon2
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|a2pb2
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|tmp1
argument_list|)
expr_stmt|;
name|tmp1
operator|=
name|qatan2
argument_list|(
name|c
operator|->
name|imag
argument_list|,
name|c
operator|->
name|real
argument_list|,
name|epsilon2
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|epsilon2
argument_list|)
expr_stmt|;
name|tmp2
operator|=
name|qdiv
argument_list|(
name|tmp1
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|tmp1
argument_list|)
expr_stmt|;
name|r
operator|=
name|cpolar
argument_list|(
name|root
argument_list|,
name|tmp2
argument_list|,
name|epsilon
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|root
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|tmp2
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_block

begin_comment
comment|/*  * Calculate the complex exponential function to the desired accuracy.  * We use the formula:  *	exp(a + bi) = exp(a) * (cos(b) + i * sin(b)).  */
end_comment

begin_function
name|COMPLEX
modifier|*
name|cexp
parameter_list|(
name|c
parameter_list|,
name|epsilon
parameter_list|)
name|COMPLEX
modifier|*
name|c
decl_stmt|;
name|NUMBER
modifier|*
name|epsilon
decl_stmt|;
block|{
name|COMPLEX
modifier|*
name|r
decl_stmt|;
name|NUMBER
modifier|*
name|tmp1
decl_stmt|,
modifier|*
name|tmp2
decl_stmt|,
modifier|*
name|epsilon2
decl_stmt|;
if|if
condition|(
name|ciszero
argument_list|(
name|c
argument_list|)
condition|)
return|return
name|clink
argument_list|(
operator|&
name|_cone_
argument_list|)
return|;
name|r
operator|=
name|comalloc
argument_list|()
expr_stmt|;
if|if
condition|(
name|cisreal
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|r
operator|->
name|real
operator|=
name|qexp
argument_list|(
name|c
operator|->
name|real
argument_list|,
name|epsilon
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
name|epsilon2
operator|=
name|qscale
argument_list|(
name|epsilon
argument_list|,
operator|-
literal|2L
argument_list|)
expr_stmt|;
name|r
operator|->
name|real
operator|=
name|qcos
argument_list|(
name|c
operator|->
name|imag
argument_list|,
name|epsilon2
argument_list|)
expr_stmt|;
name|r
operator|->
name|imag
operator|=
name|qlegtoleg
argument_list|(
name|r
operator|->
name|real
argument_list|,
name|epsilon2
argument_list|,
name|_sinisneg_
argument_list|)
expr_stmt|;
if|if
condition|(
name|qiszero
argument_list|(
name|c
operator|->
name|real
argument_list|)
condition|)
block|{
name|qfree
argument_list|(
name|epsilon2
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
name|tmp1
operator|=
name|qexp
argument_list|(
name|c
operator|->
name|real
argument_list|,
name|epsilon2
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|epsilon2
argument_list|)
expr_stmt|;
name|tmp2
operator|=
name|qmul
argument_list|(
name|r
operator|->
name|real
argument_list|,
name|tmp1
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|r
operator|->
name|real
argument_list|)
expr_stmt|;
name|r
operator|->
name|real
operator|=
name|tmp2
expr_stmt|;
name|tmp2
operator|=
name|qmul
argument_list|(
name|r
operator|->
name|imag
argument_list|,
name|tmp1
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|r
operator|->
name|imag
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|tmp1
argument_list|)
expr_stmt|;
name|r
operator|->
name|imag
operator|=
name|tmp2
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/*  * Calculate the natural logarithm of a complex number within the specified  * error.  We use the formula:  *	ln(a + bi) = ln(a^2 + b^2) / 2 + i * atan2(b, a).  */
end_comment

begin_function
name|COMPLEX
modifier|*
name|cln
parameter_list|(
name|c
parameter_list|,
name|epsilon
parameter_list|)
name|COMPLEX
modifier|*
name|c
decl_stmt|;
name|NUMBER
modifier|*
name|epsilon
decl_stmt|;
block|{
name|COMPLEX
modifier|*
name|r
decl_stmt|;
name|NUMBER
modifier|*
name|a2b2
decl_stmt|,
modifier|*
name|tmp1
decl_stmt|,
modifier|*
name|tmp2
decl_stmt|;
if|if
condition|(
name|ciszero
argument_list|(
name|c
argument_list|)
condition|)
name|math_error
argument_list|(
literal|"Logarithm of zero"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cisone
argument_list|(
name|c
argument_list|)
condition|)
return|return
name|clink
argument_list|(
operator|&
name|_czero_
argument_list|)
return|;
name|r
operator|=
name|comalloc
argument_list|()
expr_stmt|;
if|if
condition|(
name|cisreal
argument_list|(
name|c
argument_list|)
operator|&&
operator|!
name|qisneg
argument_list|(
name|c
operator|->
name|real
argument_list|)
condition|)
block|{
name|r
operator|->
name|real
operator|=
name|qln
argument_list|(
name|c
operator|->
name|real
argument_list|,
name|epsilon
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
name|tmp1
operator|=
name|qsquare
argument_list|(
name|c
operator|->
name|real
argument_list|)
expr_stmt|;
name|tmp2
operator|=
name|qsquare
argument_list|(
name|c
operator|->
name|imag
argument_list|)
expr_stmt|;
name|a2b2
operator|=
name|qadd
argument_list|(
name|tmp1
argument_list|,
name|tmp2
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|tmp1
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|tmp2
argument_list|)
expr_stmt|;
name|tmp1
operator|=
name|qln
argument_list|(
name|a2b2
argument_list|,
name|epsilon
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|a2b2
argument_list|)
expr_stmt|;
name|r
operator|->
name|real
operator|=
name|qscale
argument_list|(
name|tmp1
argument_list|,
operator|-
literal|1L
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|tmp1
argument_list|)
expr_stmt|;
name|r
operator|->
name|imag
operator|=
name|qatan2
argument_list|(
name|c
operator|->
name|imag
argument_list|,
name|c
operator|->
name|real
argument_list|,
name|epsilon
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/*  * Calculate the complex cosine within the specified accuracy.  * This uses the formula:  *	cos(a + bi) = cos(a) * cosh(b) - sin(a) * sinh(b) * i.  */
end_comment

begin_function
name|COMPLEX
modifier|*
name|ccos
parameter_list|(
name|c
parameter_list|,
name|epsilon
parameter_list|)
name|COMPLEX
modifier|*
name|c
decl_stmt|;
name|NUMBER
modifier|*
name|epsilon
decl_stmt|;
block|{
name|COMPLEX
modifier|*
name|r
decl_stmt|;
name|NUMBER
modifier|*
name|cosval
decl_stmt|,
modifier|*
name|coshval
decl_stmt|,
modifier|*
name|tmp1
decl_stmt|,
modifier|*
name|tmp2
decl_stmt|,
modifier|*
name|tmp3
decl_stmt|,
modifier|*
name|epsilon2
decl_stmt|;
name|int
name|negimag
decl_stmt|;
if|if
condition|(
name|ciszero
argument_list|(
name|c
argument_list|)
condition|)
return|return
name|clink
argument_list|(
operator|&
name|_cone_
argument_list|)
return|;
name|r
operator|=
name|comalloc
argument_list|()
expr_stmt|;
if|if
condition|(
name|cisreal
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|r
operator|->
name|real
operator|=
name|qcos
argument_list|(
name|c
operator|->
name|real
argument_list|,
name|epsilon
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
if|if
condition|(
name|qiszero
argument_list|(
name|c
operator|->
name|real
argument_list|)
condition|)
block|{
name|r
operator|->
name|real
operator|=
name|qcosh
argument_list|(
name|c
operator|->
name|imag
argument_list|,
name|epsilon
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
name|epsilon2
operator|=
name|qscale
argument_list|(
name|epsilon
argument_list|,
operator|-
literal|2L
argument_list|)
expr_stmt|;
name|coshval
operator|=
name|qcosh
argument_list|(
name|c
operator|->
name|imag
argument_list|,
name|epsilon2
argument_list|)
expr_stmt|;
name|cosval
operator|=
name|qcos
argument_list|(
name|c
operator|->
name|real
argument_list|,
name|epsilon2
argument_list|)
expr_stmt|;
name|negimag
operator|=
operator|!
name|_sinisneg_
expr_stmt|;
if|if
condition|(
name|qisneg
argument_list|(
name|c
operator|->
name|imag
argument_list|)
condition|)
name|negimag
operator|=
operator|!
name|negimag
expr_stmt|;
name|r
operator|->
name|real
operator|=
name|qmul
argument_list|(
name|cosval
argument_list|,
name|coshval
argument_list|)
expr_stmt|;
comment|/* 	 * Calculate the imaginary part using the formula: 	 *	sin(a) * sinh(b) = sqrt((1 - a^2) * (b^2 - 1)). 	 */
name|tmp1
operator|=
name|qsquare
argument_list|(
name|cosval
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|cosval
argument_list|)
expr_stmt|;
name|tmp2
operator|=
name|qdec
argument_list|(
name|tmp1
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|tmp1
argument_list|)
expr_stmt|;
name|tmp1
operator|=
name|qneg
argument_list|(
name|tmp2
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|tmp2
argument_list|)
expr_stmt|;
name|tmp2
operator|=
name|qsquare
argument_list|(
name|coshval
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|coshval
argument_list|)
expr_stmt|;
name|tmp3
operator|=
name|qdec
argument_list|(
name|tmp2
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|tmp2
argument_list|)
expr_stmt|;
name|tmp2
operator|=
name|qmul
argument_list|(
name|tmp1
argument_list|,
name|tmp3
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|tmp1
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|tmp3
argument_list|)
expr_stmt|;
name|r
operator|->
name|imag
operator|=
name|qsqrt
argument_list|(
name|tmp2
argument_list|,
name|epsilon2
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|tmp2
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|epsilon2
argument_list|)
expr_stmt|;
if|if
condition|(
name|negimag
condition|)
block|{
name|tmp1
operator|=
name|qneg
argument_list|(
name|r
operator|->
name|imag
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|r
operator|->
name|imag
argument_list|)
expr_stmt|;
name|r
operator|->
name|imag
operator|=
name|tmp1
expr_stmt|;
block|}
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/*  * Calculate the complex sine within the specified accuracy.  * This uses the formula:  *	sin(a + bi) = sin(a) * cosh(b) + cos(a) * sinh(b) * i.  */
end_comment

begin_function
name|COMPLEX
modifier|*
name|csin
parameter_list|(
name|c
parameter_list|,
name|epsilon
parameter_list|)
name|COMPLEX
modifier|*
name|c
decl_stmt|;
name|NUMBER
modifier|*
name|epsilon
decl_stmt|;
block|{
name|COMPLEX
modifier|*
name|r
decl_stmt|;
name|NUMBER
modifier|*
name|cosval
decl_stmt|,
modifier|*
name|coshval
decl_stmt|,
modifier|*
name|tmp1
decl_stmt|,
modifier|*
name|tmp2
decl_stmt|,
modifier|*
name|epsilon2
decl_stmt|;
if|if
condition|(
name|ciszero
argument_list|(
name|c
argument_list|)
condition|)
return|return
name|clink
argument_list|(
operator|&
name|_czero_
argument_list|)
return|;
name|r
operator|=
name|comalloc
argument_list|()
expr_stmt|;
if|if
condition|(
name|cisreal
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|r
operator|->
name|real
operator|=
name|qsin
argument_list|(
name|c
operator|->
name|real
argument_list|,
name|epsilon
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
if|if
condition|(
name|qiszero
argument_list|(
name|c
operator|->
name|real
argument_list|)
condition|)
block|{
name|r
operator|->
name|imag
operator|=
name|qsinh
argument_list|(
name|c
operator|->
name|imag
argument_list|,
name|epsilon
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
name|epsilon2
operator|=
name|qscale
argument_list|(
name|epsilon
argument_list|,
operator|-
literal|2L
argument_list|)
expr_stmt|;
name|coshval
operator|=
name|qcosh
argument_list|(
name|c
operator|->
name|imag
argument_list|,
name|epsilon2
argument_list|)
expr_stmt|;
name|cosval
operator|=
name|qcos
argument_list|(
name|c
operator|->
name|real
argument_list|,
name|epsilon2
argument_list|)
expr_stmt|;
name|tmp1
operator|=
name|qlegtoleg
argument_list|(
name|cosval
argument_list|,
name|epsilon2
argument_list|,
name|_sinisneg_
argument_list|)
expr_stmt|;
name|r
operator|->
name|real
operator|=
name|qmul
argument_list|(
name|tmp1
argument_list|,
name|coshval
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|tmp1
argument_list|)
expr_stmt|;
name|tmp1
operator|=
name|qsquare
argument_list|(
name|coshval
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|coshval
argument_list|)
expr_stmt|;
name|tmp2
operator|=
name|qdec
argument_list|(
name|tmp1
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|tmp1
argument_list|)
expr_stmt|;
name|tmp1
operator|=
name|qsqrt
argument_list|(
name|tmp2
argument_list|,
name|epsilon2
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|tmp2
argument_list|)
expr_stmt|;
name|r
operator|->
name|imag
operator|=
name|qmul
argument_list|(
name|tmp1
argument_list|,
name|cosval
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|tmp1
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|cosval
argument_list|)
expr_stmt|;
if|if
condition|(
name|qisneg
argument_list|(
name|c
operator|->
name|imag
argument_list|)
condition|)
block|{
name|tmp1
operator|=
name|qneg
argument_list|(
name|r
operator|->
name|imag
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|r
operator|->
name|imag
argument_list|)
expr_stmt|;
name|r
operator|->
name|imag
operator|=
name|tmp1
expr_stmt|;
block|}
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/*  * Convert a number from polar coordinates to normal complex number form  * within the specified accuracy.  This produces the value:  *	q1 * cos(q2) + q1 * sin(q2) * i.  */
end_comment

begin_function
name|COMPLEX
modifier|*
name|cpolar
parameter_list|(
name|q1
parameter_list|,
name|q2
parameter_list|,
name|epsilon
parameter_list|)
name|NUMBER
modifier|*
name|q1
decl_stmt|,
decl|*
name|q2
decl_stmt|,
modifier|*
name|epsilon
decl_stmt|;
end_function

begin_block
block|{
name|COMPLEX
modifier|*
name|r
decl_stmt|;
name|NUMBER
modifier|*
name|tmp
decl_stmt|,
modifier|*
name|epsilon2
decl_stmt|;
name|long
name|scale
decl_stmt|;
name|r
operator|=
name|comalloc
argument_list|()
expr_stmt|;
if|if
condition|(
name|qiszero
argument_list|(
name|q1
argument_list|)
operator|||
name|qiszero
argument_list|(
name|q2
argument_list|)
condition|)
block|{
name|r
operator|->
name|real
operator|=
name|qlink
argument_list|(
name|q1
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
name|epsilon2
operator|=
name|epsilon
expr_stmt|;
if|if
condition|(
operator|!
name|qisunit
argument_list|(
name|q1
argument_list|)
condition|)
block|{
name|scale
operator|=
name|zhighbit
argument_list|(
name|q1
operator|->
name|num
argument_list|)
operator|-
name|zhighbit
argument_list|(
name|q1
operator|->
name|den
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|scale
operator|>
literal|0
condition|)
name|epsilon2
operator|=
name|qscale
argument_list|(
name|epsilon
argument_list|,
operator|-
name|scale
argument_list|)
expr_stmt|;
block|}
name|r
operator|->
name|real
operator|=
name|qcos
argument_list|(
name|q2
argument_list|,
name|epsilon2
argument_list|)
expr_stmt|;
name|r
operator|->
name|imag
operator|=
name|qlegtoleg
argument_list|(
name|r
operator|->
name|real
argument_list|,
name|epsilon2
argument_list|,
name|_sinisneg_
argument_list|)
expr_stmt|;
if|if
condition|(
name|epsilon2
operator|!=
name|epsilon
condition|)
name|qfree
argument_list|(
name|epsilon2
argument_list|)
expr_stmt|;
if|if
condition|(
name|qisone
argument_list|(
name|q1
argument_list|)
condition|)
return|return
name|r
return|;
name|tmp
operator|=
name|qmul
argument_list|(
name|r
operator|->
name|real
argument_list|,
name|q1
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|r
operator|->
name|real
argument_list|)
expr_stmt|;
name|r
operator|->
name|real
operator|=
name|tmp
expr_stmt|;
name|tmp
operator|=
name|qmul
argument_list|(
name|r
operator|->
name|imag
argument_list|,
name|q1
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|r
operator|->
name|imag
argument_list|)
expr_stmt|;
name|r
operator|->
name|imag
operator|=
name|tmp
expr_stmt|;
return|return
name|r
return|;
block|}
end_block

begin_comment
comment|/*  * Raise one complex number to the power of another one to within the  * specified error.  */
end_comment

begin_function
name|COMPLEX
modifier|*
name|cpower
parameter_list|(
name|c1
parameter_list|,
name|c2
parameter_list|,
name|epsilon
parameter_list|)
name|COMPLEX
modifier|*
name|c1
decl_stmt|,
decl|*
name|c2
decl_stmt|;
end_function

begin_decl_stmt
name|NUMBER
modifier|*
name|epsilon
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|COMPLEX
modifier|*
name|tmp1
decl_stmt|,
modifier|*
name|tmp2
decl_stmt|;
name|NUMBER
modifier|*
name|epsilon2
decl_stmt|;
if|if
condition|(
name|cisreal
argument_list|(
name|c2
argument_list|)
operator|&&
name|qisint
argument_list|(
name|c2
operator|->
name|real
argument_list|)
condition|)
return|return
name|cpowi
argument_list|(
name|c1
argument_list|,
name|c2
operator|->
name|real
argument_list|)
return|;
if|if
condition|(
name|cisone
argument_list|(
name|c1
argument_list|)
operator|||
name|ciszero
argument_list|(
name|c1
argument_list|)
condition|)
return|return
name|clink
argument_list|(
name|c1
argument_list|)
return|;
name|epsilon2
operator|=
name|qscale
argument_list|(
name|epsilon
argument_list|,
operator|-
literal|4L
argument_list|)
expr_stmt|;
name|tmp1
operator|=
name|cln
argument_list|(
name|c1
argument_list|,
name|epsilon2
argument_list|)
expr_stmt|;
name|tmp2
operator|=
name|cmul
argument_list|(
name|tmp1
argument_list|,
name|c2
argument_list|)
expr_stmt|;
name|comfree
argument_list|(
name|tmp1
argument_list|)
expr_stmt|;
name|tmp1
operator|=
name|cexp
argument_list|(
name|tmp2
argument_list|,
name|epsilon
argument_list|)
expr_stmt|;
name|comfree
argument_list|(
name|tmp2
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|epsilon2
argument_list|)
expr_stmt|;
return|return
name|tmp1
return|;
block|}
end_block

begin_comment
comment|/*  * Return a trivial hash value for a complex number.  */
end_comment

begin_function
name|HASH
name|chash
parameter_list|(
name|c
parameter_list|)
name|COMPLEX
modifier|*
name|c
decl_stmt|;
block|{
name|HASH
name|hash
decl_stmt|;
name|hash
operator|=
name|qhash
argument_list|(
name|c
operator|->
name|real
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cisreal
argument_list|(
name|c
argument_list|)
condition|)
name|hash
operator|+=
name|qhash
argument_list|(
name|c
operator|->
name|imag
argument_list|)
operator|*
literal|2000029
expr_stmt|;
return|return
name|hash
return|;
block|}
end_function

begin_comment
comment|/*  * Print a complex number in the current output mode.  */
end_comment

begin_function
name|void
name|comprint
parameter_list|(
name|c
parameter_list|)
name|COMPLEX
modifier|*
name|c
decl_stmt|;
block|{
name|NUMBER
name|qtmp
decl_stmt|;
if|if
condition|(
name|_outmode_
operator|==
name|MODE_FRAC
condition|)
block|{
name|cprintfr
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|qiszero
argument_list|(
name|c
operator|->
name|real
argument_list|)
operator|||
name|qiszero
argument_list|(
name|c
operator|->
name|imag
argument_list|)
condition|)
name|qprintnum
argument_list|(
name|c
operator|->
name|real
argument_list|,
name|MODE_DEFAULT
argument_list|)
expr_stmt|;
name|qtmp
operator|=
name|c
operator|->
name|imag
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|qiszero
argument_list|(
operator|&
name|qtmp
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|!
name|qiszero
argument_list|(
name|c
operator|->
name|real
argument_list|)
operator|&&
operator|!
name|qisneg
argument_list|(
operator|&
name|qtmp
argument_list|)
condition|)
name|math_chr
argument_list|(
literal|'+'
argument_list|)
expr_stmt|;
if|if
condition|(
name|qisneg
argument_list|(
operator|&
name|qtmp
argument_list|)
condition|)
block|{
name|math_chr
argument_list|(
literal|'-'
argument_list|)
expr_stmt|;
name|qtmp
operator|.
name|num
operator|.
name|sign
operator|=
literal|0
expr_stmt|;
block|}
name|qprintnum
argument_list|(
operator|&
name|qtmp
argument_list|,
name|MODE_DEFAULT
argument_list|)
expr_stmt|;
name|math_chr
argument_list|(
literal|'i'
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Print a complex number in rational representation.  * Example:  2/3-4i/5  */
end_comment

begin_function
name|void
name|cprintfr
parameter_list|(
name|c
parameter_list|)
name|COMPLEX
modifier|*
name|c
decl_stmt|;
block|{
name|NUMBER
modifier|*
name|r
decl_stmt|;
name|NUMBER
modifier|*
name|i
decl_stmt|;
name|r
operator|=
name|c
operator|->
name|real
expr_stmt|;
name|i
operator|=
name|c
operator|->
name|imag
expr_stmt|;
if|if
condition|(
operator|!
name|qiszero
argument_list|(
name|r
argument_list|)
operator|||
name|qiszero
argument_list|(
name|i
argument_list|)
condition|)
name|qprintfr
argument_list|(
name|r
argument_list|,
literal|0L
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|qiszero
argument_list|(
name|i
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|!
name|qiszero
argument_list|(
name|r
argument_list|)
operator|&&
operator|!
name|qisneg
argument_list|(
name|i
argument_list|)
condition|)
name|math_chr
argument_list|(
literal|'+'
argument_list|)
expr_stmt|;
name|zprintval
argument_list|(
name|i
operator|->
name|num
argument_list|,
literal|0L
argument_list|,
literal|0L
argument_list|)
expr_stmt|;
name|math_chr
argument_list|(
literal|'i'
argument_list|)
expr_stmt|;
if|if
condition|(
name|qisfrac
argument_list|(
name|i
argument_list|)
condition|)
block|{
name|math_chr
argument_list|(
literal|'/'
argument_list|)
expr_stmt|;
name|zprintval
argument_list|(
name|i
operator|->
name|den
argument_list|,
literal|0L
argument_list|,
literal|0L
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* END CODE */
end_comment

end_unit

