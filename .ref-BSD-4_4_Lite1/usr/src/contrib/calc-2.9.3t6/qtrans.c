begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1994 David I. Bell  * Permission is granted to use, distribute, or modify this source,  * provided that this copyright notice remains intact.  *  * Transcendental functions for real numbers.  * These are sin, cos, exp, ln, power, cosh, sinh.  */
end_comment

begin_include
include|#
directive|include
file|"qmath.h"
end_include

begin_decl_stmt
name|BOOL
name|_sinisneg_
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* whether sin(x)< 0 (set by cos(x)) */
end_comment

begin_comment
comment|/*  * Calculate the cosine of a number with an accuracy within epsilon.  * This also saves the sign of the corresponding sin function.  */
end_comment

begin_function
name|NUMBER
modifier|*
name|qcos
parameter_list|(
name|q
parameter_list|,
name|epsilon
parameter_list|)
name|NUMBER
modifier|*
name|q
decl_stmt|,
decl|*
name|epsilon
decl_stmt|;
end_function

begin_block
block|{
name|NUMBER
modifier|*
name|term
decl_stmt|,
modifier|*
name|sum
decl_stmt|,
modifier|*
name|qsq
decl_stmt|,
modifier|*
name|epsilon2
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
name|FULL
name|n
decl_stmt|,
name|i
decl_stmt|;
name|long
name|scale
decl_stmt|,
name|bits
decl_stmt|,
name|bits2
decl_stmt|;
name|_sinisneg_
operator|=
name|qisneg
argument_list|(
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
name|qisneg
argument_list|(
name|epsilon
argument_list|)
operator|||
name|qiszero
argument_list|(
name|epsilon
argument_list|)
condition|)
name|math_error
argument_list|(
literal|"Illegal epsilon value for cosine"
argument_list|)
expr_stmt|;
if|if
condition|(
name|qiszero
argument_list|(
name|q
argument_list|)
condition|)
return|return
name|qlink
argument_list|(
operator|&
name|_qone_
argument_list|)
return|;
name|bits
operator|=
name|qprecision
argument_list|(
name|epsilon
argument_list|)
operator|+
literal|1
expr_stmt|;
name|epsilon
operator|=
name|qscale
argument_list|(
name|epsilon
argument_list|,
operator|-
literal|4L
argument_list|)
expr_stmt|;
comment|/* 	 * If the argument is larger than one, then divide it by a power of two 	 * so that it is one or less.  This will make the series converge quickly. 	 * We will extrapolate the result for the original argument afterwards. 	 */
name|scale
operator|=
name|zhighbit
argument_list|(
name|q
operator|->
name|num
argument_list|)
operator|-
name|zhighbit
argument_list|(
name|q
operator|->
name|den
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|scale
operator|<
literal|0
condition|)
name|scale
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|scale
operator|>
literal|0
condition|)
block|{
name|q
operator|=
name|qscale
argument_list|(
name|q
argument_list|,
operator|-
name|scale
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|qscale
argument_list|(
name|epsilon
argument_list|,
operator|-
name|scale
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|epsilon
argument_list|)
expr_stmt|;
name|epsilon
operator|=
name|tmp
expr_stmt|;
block|}
name|epsilon2
operator|=
name|qscale
argument_list|(
name|epsilon
argument_list|,
operator|-
literal|4L
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|epsilon
argument_list|)
expr_stmt|;
name|bits2
operator|=
name|qprecision
argument_list|(
name|epsilon2
argument_list|)
operator|+
literal|10
expr_stmt|;
comment|/* 	 * Now use the Taylor series expansion to calculate the cosine. 	 * Keep using approximations so that the fractions don't get too large. 	 */
name|qsq
operator|=
name|qsquare
argument_list|(
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
name|scale
operator|>
literal|0
condition|)
name|qfree
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|term
operator|=
name|qlink
argument_list|(
operator|&
name|_qone_
argument_list|)
expr_stmt|;
name|sum
operator|=
name|qlink
argument_list|(
operator|&
name|_qone_
argument_list|)
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|qrel
argument_list|(
name|term
argument_list|,
name|epsilon2
argument_list|)
operator|>
literal|0
condition|)
block|{
name|i
operator|=
operator|++
name|n
expr_stmt|;
name|i
operator|*=
operator|++
name|n
expr_stmt|;
name|tmp
operator|=
name|qmul
argument_list|(
name|term
argument_list|,
name|qsq
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|term
argument_list|)
expr_stmt|;
name|term
operator|=
name|qdivi
argument_list|(
name|tmp
argument_list|,
operator|(
name|long
operator|)
name|i
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|qbround
argument_list|(
name|term
argument_list|,
name|bits2
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|term
argument_list|)
expr_stmt|;
name|term
operator|=
name|tmp
expr_stmt|;
if|if
condition|(
name|n
operator|&
literal|2
condition|)
name|tmp
operator|=
name|qsub
argument_list|(
name|sum
argument_list|,
name|term
argument_list|)
expr_stmt|;
else|else
name|tmp
operator|=
name|qadd
argument_list|(
name|sum
argument_list|,
name|term
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|sum
argument_list|)
expr_stmt|;
name|sum
operator|=
name|qbround
argument_list|(
name|tmp
argument_list|,
name|bits2
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
name|qfree
argument_list|(
name|term
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|qsq
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|epsilon2
argument_list|)
expr_stmt|;
comment|/* 	 * Now scale back up to the original value of x by using the formula: 	 *	cos(2 * x) = 2 * (cos(x) ^ 2) - 1. 	 */
while|while
condition|(
operator|--
name|scale
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|qisneg
argument_list|(
name|sum
argument_list|)
condition|)
name|_sinisneg_
operator|=
operator|!
name|_sinisneg_
expr_stmt|;
name|tmp
operator|=
name|qsquare
argument_list|(
name|sum
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|sum
argument_list|)
expr_stmt|;
name|sum
operator|=
name|qscale
argument_list|(
name|tmp
argument_list|,
literal|1L
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|qdec
argument_list|(
name|sum
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|sum
argument_list|)
expr_stmt|;
name|sum
operator|=
name|qbround
argument_list|(
name|tmp
argument_list|,
name|bits2
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
name|tmp
operator|=
name|qbround
argument_list|(
name|sum
argument_list|,
name|bits
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|sum
argument_list|)
expr_stmt|;
return|return
name|tmp
return|;
block|}
end_block

begin_comment
comment|/*  * Calculate the sine of a number with an accuracy within epsilon.  * This is calculated using the formula:  *	sin(x)^2 + cos(x)^2 = 1.  * The only tricky bit is resolving the sign of the result.  * Future: Use sin(3*x) = 3*sin(x) - 4*sin(x)^3.  */
end_comment

begin_function
name|NUMBER
modifier|*
name|qsin
parameter_list|(
name|q
parameter_list|,
name|epsilon
parameter_list|)
name|NUMBER
modifier|*
name|q
decl_stmt|,
decl|*
name|epsilon
decl_stmt|;
end_function

begin_block
block|{
name|NUMBER
modifier|*
name|tmp1
decl_stmt|,
modifier|*
name|tmp2
decl_stmt|,
modifier|*
name|epsilon2
decl_stmt|;
if|if
condition|(
name|qisneg
argument_list|(
name|epsilon
argument_list|)
operator|||
name|qiszero
argument_list|(
name|epsilon
argument_list|)
condition|)
name|math_error
argument_list|(
literal|"Illegal epsilon value for sine"
argument_list|)
expr_stmt|;
if|if
condition|(
name|qiszero
argument_list|(
name|q
argument_list|)
condition|)
return|return
name|qlink
argument_list|(
name|q
argument_list|)
return|;
name|epsilon2
operator|=
name|qsquare
argument_list|(
name|epsilon
argument_list|)
expr_stmt|;
name|tmp1
operator|=
name|qcos
argument_list|(
name|q
argument_list|,
name|epsilon2
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|epsilon2
argument_list|)
expr_stmt|;
name|tmp2
operator|=
name|qlegtoleg
argument_list|(
name|tmp1
argument_list|,
name|epsilon
argument_list|,
name|_sinisneg_
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|tmp1
argument_list|)
expr_stmt|;
return|return
name|tmp2
return|;
block|}
end_block

begin_comment
comment|/*  * Calculate the tangent function.  */
end_comment

begin_function
name|NUMBER
modifier|*
name|qtan
parameter_list|(
name|q
parameter_list|,
name|epsilon
parameter_list|)
name|NUMBER
modifier|*
name|q
decl_stmt|,
decl|*
name|epsilon
decl_stmt|;
end_function

begin_block
block|{
name|NUMBER
modifier|*
name|cosval
decl_stmt|,
modifier|*
name|sinval
decl_stmt|,
modifier|*
name|epsilon2
decl_stmt|,
modifier|*
name|tmp
decl_stmt|,
modifier|*
name|res
decl_stmt|;
if|if
condition|(
name|qisneg
argument_list|(
name|epsilon
argument_list|)
operator|||
name|qiszero
argument_list|(
name|epsilon
argument_list|)
condition|)
name|math_error
argument_list|(
literal|"Illegal epsilon value for tangent"
argument_list|)
expr_stmt|;
if|if
condition|(
name|qiszero
argument_list|(
name|q
argument_list|)
condition|)
return|return
name|qlink
argument_list|(
name|q
argument_list|)
return|;
name|epsilon2
operator|=
name|qsquare
argument_list|(
name|epsilon
argument_list|)
expr_stmt|;
name|cosval
operator|=
name|qcos
argument_list|(
name|q
argument_list|,
name|epsilon2
argument_list|)
expr_stmt|;
name|sinval
operator|=
name|qlegtoleg
argument_list|(
name|cosval
argument_list|,
name|epsilon2
argument_list|,
name|_sinisneg_
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|epsilon2
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|qdiv
argument_list|(
name|sinval
argument_list|,
name|cosval
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|cosval
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|sinval
argument_list|)
expr_stmt|;
name|res
operator|=
name|qbround
argument_list|(
name|tmp
argument_list|,
name|qprecision
argument_list|(
name|epsilon
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_block

begin_comment
comment|/*  * Calculate the arcsine function.  * The result is in the range -pi/2 to pi/2.  */
end_comment

begin_function
name|NUMBER
modifier|*
name|qasin
parameter_list|(
name|q
parameter_list|,
name|epsilon
parameter_list|)
name|NUMBER
modifier|*
name|q
decl_stmt|,
decl|*
name|epsilon
decl_stmt|;
end_function

begin_block
block|{
name|NUMBER
modifier|*
name|sum
decl_stmt|,
modifier|*
name|term
decl_stmt|,
modifier|*
name|epsilon2
decl_stmt|,
modifier|*
name|qsq
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
name|FULL
name|n
decl_stmt|,
name|i
decl_stmt|;
name|long
name|bits
decl_stmt|,
name|bits2
decl_stmt|;
name|int
name|neg
decl_stmt|;
name|NUMBER
name|mulnum
decl_stmt|;
name|HALF
name|numval
index|[
literal|2
index|]
decl_stmt|;
name|HALF
name|denval
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
name|qisneg
argument_list|(
name|epsilon
argument_list|)
operator|||
name|qiszero
argument_list|(
name|epsilon
argument_list|)
condition|)
name|math_error
argument_list|(
literal|"Illegal epsilon value for arcsine"
argument_list|)
expr_stmt|;
if|if
condition|(
name|qiszero
argument_list|(
name|q
argument_list|)
condition|)
return|return
name|qlink
argument_list|(
operator|&
name|_qzero_
argument_list|)
return|;
if|if
condition|(
operator|(
name|qrel
argument_list|(
name|q
argument_list|,
operator|&
name|_qone_
argument_list|)
operator|>
literal|0
operator|)
operator|||
operator|(
name|qrel
argument_list|(
name|q
argument_list|,
operator|&
name|_qnegone_
argument_list|)
operator|<
literal|0
operator|)
condition|)
name|math_error
argument_list|(
literal|"Argument too large for asin"
argument_list|)
expr_stmt|;
name|neg
operator|=
name|qisneg
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|q
operator|=
name|qabs
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|epsilon
operator|=
name|qscale
argument_list|(
name|epsilon
argument_list|,
operator|-
literal|4L
argument_list|)
expr_stmt|;
name|epsilon2
operator|=
name|qscale
argument_list|(
name|epsilon
argument_list|,
operator|-
literal|4L
argument_list|)
expr_stmt|;
name|mulnum
operator|.
name|num
operator|.
name|sign
operator|=
literal|0
expr_stmt|;
name|mulnum
operator|.
name|num
operator|.
name|len
operator|=
literal|1
expr_stmt|;
name|mulnum
operator|.
name|num
operator|.
name|v
operator|=
name|numval
expr_stmt|;
name|mulnum
operator|.
name|den
operator|.
name|sign
operator|=
literal|0
expr_stmt|;
name|mulnum
operator|.
name|den
operator|.
name|len
operator|=
literal|1
expr_stmt|;
name|mulnum
operator|.
name|den
operator|.
name|v
operator|=
name|denval
expr_stmt|;
comment|/* 	 * If the argument is too near one (we use .5) then reduce the 	 * argument to a more accurate range using the formula: 	 *	asin(x) = 2 * asin(sqrt((1 - sqrt(1 - x^2)) / 2)). 	 */
if|if
condition|(
name|qrel
argument_list|(
name|q
argument_list|,
operator|&
name|_qonehalf_
argument_list|)
operator|>
literal|0
condition|)
block|{
name|sum
operator|=
name|qlegtoleg
argument_list|(
name|q
argument_list|,
name|epsilon2
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|qsub
argument_list|(
operator|&
name|_qone_
argument_list|,
name|sum
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|sum
argument_list|)
expr_stmt|;
name|sum
operator|=
name|qscale
argument_list|(
name|tmp
argument_list|,
operator|-
literal|1L
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|qsqrt
argument_list|(
name|sum
argument_list|,
name|epsilon2
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|sum
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|epsilon2
argument_list|)
expr_stmt|;
name|sum
operator|=
name|qasin
argument_list|(
name|tmp
argument_list|,
name|epsilon
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|epsilon
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|qscale
argument_list|(
name|sum
argument_list|,
literal|1L
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|sum
argument_list|)
expr_stmt|;
if|if
condition|(
name|neg
condition|)
block|{
name|sum
operator|=
name|qneg
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|sum
expr_stmt|;
block|}
return|return
name|tmp
return|;
block|}
comment|/* 	 * Argument is between zero and .5, so use the series. 	 */
name|epsilon
operator|=
name|qscale
argument_list|(
name|epsilon
argument_list|,
operator|-
literal|4L
argument_list|)
expr_stmt|;
name|epsilon2
operator|=
name|qscale
argument_list|(
name|epsilon
argument_list|,
operator|-
literal|4L
argument_list|)
expr_stmt|;
name|bits
operator|=
name|qprecision
argument_list|(
name|epsilon
argument_list|)
operator|+
literal|1
expr_stmt|;
name|bits2
operator|=
name|bits
operator|+
literal|10
expr_stmt|;
name|sum
operator|=
name|qlink
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|term
operator|=
name|qlink
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|qsq
operator|=
name|qsquare
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|n
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|qrel
argument_list|(
name|term
argument_list|,
name|epsilon2
argument_list|)
operator|>
literal|0
condition|)
block|{
name|i
operator|=
name|n
operator|*
name|n
expr_stmt|;
name|numval
index|[
literal|0
index|]
operator|=
name|i
operator|&
name|BASE1
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|BASE
condition|)
block|{
name|numval
index|[
literal|1
index|]
operator|=
name|i
operator|/
name|BASE
expr_stmt|;
name|mulnum
operator|.
name|den
operator|.
name|len
operator|=
literal|2
expr_stmt|;
block|}
name|i
operator|=
operator|(
name|n
operator|+
literal|1
operator|)
operator|*
operator|(
name|n
operator|+
literal|2
operator|)
expr_stmt|;
name|denval
index|[
literal|0
index|]
operator|=
name|i
operator|&
name|BASE1
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|BASE
condition|)
block|{
name|denval
index|[
literal|1
index|]
operator|=
name|i
operator|/
name|BASE
expr_stmt|;
name|mulnum
operator|.
name|den
operator|.
name|len
operator|=
literal|2
expr_stmt|;
block|}
name|tmp
operator|=
name|qmul
argument_list|(
name|term
argument_list|,
name|qsq
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|term
argument_list|)
expr_stmt|;
name|term
operator|=
name|qmul
argument_list|(
name|tmp
argument_list|,
operator|&
name|mulnum
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|qbround
argument_list|(
name|term
argument_list|,
name|bits2
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|term
argument_list|)
expr_stmt|;
name|term
operator|=
name|tmp
expr_stmt|;
name|tmp
operator|=
name|qadd
argument_list|(
name|sum
argument_list|,
name|term
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|sum
argument_list|)
expr_stmt|;
name|sum
operator|=
name|qbround
argument_list|(
name|tmp
argument_list|,
name|bits2
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|n
operator|+=
literal|2
expr_stmt|;
block|}
name|qfree
argument_list|(
name|epsilon
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|epsilon2
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|term
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|qsq
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|qbround
argument_list|(
name|sum
argument_list|,
name|bits
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|sum
argument_list|)
expr_stmt|;
if|if
condition|(
name|neg
condition|)
block|{
name|term
operator|=
name|qneg
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|term
expr_stmt|;
block|}
return|return
name|tmp
return|;
block|}
end_block

begin_comment
comment|/*  * Calculate the acos function.  * The result is in the range 0 to pi.  */
end_comment

begin_function
name|NUMBER
modifier|*
name|qacos
parameter_list|(
name|q
parameter_list|,
name|epsilon
parameter_list|)
name|NUMBER
modifier|*
name|q
decl_stmt|,
decl|*
name|epsilon
decl_stmt|;
end_function

begin_block
block|{
name|NUMBER
modifier|*
name|tmp1
decl_stmt|,
modifier|*
name|tmp2
decl_stmt|,
modifier|*
name|tmp3
decl_stmt|,
modifier|*
name|epsilon2
decl_stmt|;
if|if
condition|(
name|qisneg
argument_list|(
name|epsilon
argument_list|)
operator|||
name|qiszero
argument_list|(
name|epsilon
argument_list|)
condition|)
name|math_error
argument_list|(
literal|"Illegal epsilon value for arccosine"
argument_list|)
expr_stmt|;
if|if
condition|(
name|qisone
argument_list|(
name|q
argument_list|)
condition|)
return|return
name|qlink
argument_list|(
operator|&
name|_qzero_
argument_list|)
return|;
if|if
condition|(
operator|(
name|qrel
argument_list|(
name|q
argument_list|,
operator|&
name|_qone_
argument_list|)
operator|>
literal|0
operator|)
operator|||
operator|(
name|qrel
argument_list|(
name|q
argument_list|,
operator|&
name|_qnegone_
argument_list|)
operator|<
literal|0
operator|)
condition|)
name|math_error
argument_list|(
literal|"Argument too large for acos"
argument_list|)
expr_stmt|;
comment|/* 	 * Calculate the result using the formula: 	 *	acos(x) = asin(sqrt(1 - x^2)). 	 * The formula is only good for positive x, so we must fix up the 	 * result for negative values. 	 */
name|epsilon2
operator|=
name|qscale
argument_list|(
name|epsilon
argument_list|,
operator|-
literal|8L
argument_list|)
expr_stmt|;
name|tmp1
operator|=
name|qlegtoleg
argument_list|(
name|q
argument_list|,
name|epsilon2
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|epsilon2
argument_list|)
expr_stmt|;
name|tmp2
operator|=
name|qasin
argument_list|(
name|tmp1
argument_list|,
name|epsilon
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|tmp1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|qisneg
argument_list|(
name|q
argument_list|)
condition|)
return|return
name|tmp2
return|;
comment|/* 	 * For negative values, we need to subtract the asin from pi. 	 */
name|tmp1
operator|=
name|qpi
argument_list|(
name|epsilon
argument_list|)
expr_stmt|;
name|tmp3
operator|=
name|qsub
argument_list|(
name|tmp1
argument_list|,
name|tmp2
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|tmp1
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|tmp2
argument_list|)
expr_stmt|;
name|tmp1
operator|=
name|qbround
argument_list|(
name|tmp3
argument_list|,
name|qprecision
argument_list|(
name|epsilon
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|tmp3
argument_list|)
expr_stmt|;
return|return
name|tmp1
return|;
block|}
end_block

begin_comment
comment|/*  * Calculate the arctangent function with a accuracy less than epsilon.  * This uses the formula:  *	atan(x) = asin(sqrt(x^2 / (x^2 + 1))).  */
end_comment

begin_function
name|NUMBER
modifier|*
name|qatan
parameter_list|(
name|q
parameter_list|,
name|epsilon
parameter_list|)
name|NUMBER
modifier|*
name|q
decl_stmt|,
decl|*
name|epsilon
decl_stmt|;
end_function

begin_block
block|{
name|NUMBER
modifier|*
name|tmp1
decl_stmt|,
modifier|*
name|tmp2
decl_stmt|,
modifier|*
name|tmp3
decl_stmt|,
modifier|*
name|epsilon2
decl_stmt|;
if|if
condition|(
name|qisneg
argument_list|(
name|epsilon
argument_list|)
operator|||
name|qiszero
argument_list|(
name|epsilon
argument_list|)
condition|)
name|math_error
argument_list|(
literal|"Illegal epsilon value for arctangent"
argument_list|)
expr_stmt|;
if|if
condition|(
name|qiszero
argument_list|(
name|q
argument_list|)
condition|)
return|return
name|qlink
argument_list|(
operator|&
name|_qzero_
argument_list|)
return|;
name|tmp1
operator|=
name|qsquare
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|tmp2
operator|=
name|qinc
argument_list|(
name|tmp1
argument_list|)
expr_stmt|;
name|tmp3
operator|=
name|qdiv
argument_list|(
name|tmp1
argument_list|,
name|tmp2
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|tmp1
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|tmp2
argument_list|)
expr_stmt|;
name|epsilon2
operator|=
name|qscale
argument_list|(
name|epsilon
argument_list|,
operator|-
literal|8L
argument_list|)
expr_stmt|;
name|tmp1
operator|=
name|qsqrt
argument_list|(
name|tmp3
argument_list|,
name|epsilon2
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|epsilon2
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|tmp3
argument_list|)
expr_stmt|;
name|tmp2
operator|=
name|qasin
argument_list|(
name|tmp1
argument_list|,
name|epsilon
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|tmp1
argument_list|)
expr_stmt|;
if|if
condition|(
name|qisneg
argument_list|(
name|q
argument_list|)
condition|)
block|{
name|tmp1
operator|=
name|qneg
argument_list|(
name|tmp2
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|tmp2
argument_list|)
expr_stmt|;
name|tmp2
operator|=
name|tmp1
expr_stmt|;
block|}
return|return
name|tmp2
return|;
block|}
end_block

begin_comment
comment|/*  * Calculate the angle which is determined by the point (x,y).  * This is the same as arctan for non-negative x, but gives the correct  * value for negative x.  By convention, y is the first argument.  * For example, qatan2(1, -1) = 3/4 * pi.  */
end_comment

begin_function
name|NUMBER
modifier|*
name|qatan2
parameter_list|(
name|qy
parameter_list|,
name|qx
parameter_list|,
name|epsilon
parameter_list|)
name|NUMBER
modifier|*
name|qy
decl_stmt|,
decl|*
name|qx
decl_stmt|,
modifier|*
name|epsilon
decl_stmt|;
end_function

begin_block
block|{
name|NUMBER
modifier|*
name|tmp1
decl_stmt|,
modifier|*
name|tmp2
decl_stmt|,
modifier|*
name|epsilon2
decl_stmt|;
if|if
condition|(
name|qisneg
argument_list|(
name|epsilon
argument_list|)
operator|||
name|qiszero
argument_list|(
name|epsilon
argument_list|)
condition|)
name|math_error
argument_list|(
literal|"Illegal epsilon value for atan2"
argument_list|)
expr_stmt|;
if|if
condition|(
name|qiszero
argument_list|(
name|qy
argument_list|)
operator|&&
name|qiszero
argument_list|(
name|qx
argument_list|)
condition|)
block|{
comment|/* conform to 4.3BSD ANSI/IEEE 754-1985 math lib */
return|return
name|qlink
argument_list|(
operator|&
name|_qzero_
argument_list|)
return|;
block|}
comment|/* 	 * If the point is on the negative real axis, then the answer is pi. 	 */
if|if
condition|(
name|qiszero
argument_list|(
name|qy
argument_list|)
operator|&&
name|qisneg
argument_list|(
name|qx
argument_list|)
condition|)
return|return
name|qpi
argument_list|(
name|epsilon
argument_list|)
return|;
comment|/* 	 * If the point is in the right half plane, then use the normal atan. 	 */
if|if
condition|(
operator|!
name|qisneg
argument_list|(
name|qx
argument_list|)
operator|&&
operator|!
name|qiszero
argument_list|(
name|qx
argument_list|)
condition|)
block|{
if|if
condition|(
name|qiszero
argument_list|(
name|qy
argument_list|)
condition|)
return|return
name|qlink
argument_list|(
operator|&
name|_qzero_
argument_list|)
return|;
name|tmp1
operator|=
name|qdiv
argument_list|(
name|qy
argument_list|,
name|qx
argument_list|)
expr_stmt|;
name|tmp2
operator|=
name|qatan
argument_list|(
name|tmp1
argument_list|,
name|epsilon
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|tmp1
argument_list|)
expr_stmt|;
return|return
name|tmp2
return|;
block|}
comment|/* 	 * The point is in the left half plane.  Calculate the angle by finding 	 * the atan of half the angle using the formula: 	 *	atan2(y,x) = 2 * atan((sqrt(x^2 + y^2) - x) / y). 	 */
name|epsilon2
operator|=
name|qscale
argument_list|(
name|epsilon
argument_list|,
operator|-
literal|4L
argument_list|)
expr_stmt|;
name|tmp1
operator|=
name|qhypot
argument_list|(
name|qx
argument_list|,
name|qy
argument_list|,
name|epsilon2
argument_list|)
expr_stmt|;
name|tmp2
operator|=
name|qsub
argument_list|(
name|tmp1
argument_list|,
name|qx
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|tmp1
argument_list|)
expr_stmt|;
name|tmp1
operator|=
name|qdiv
argument_list|(
name|tmp2
argument_list|,
name|qy
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|tmp2
argument_list|)
expr_stmt|;
name|tmp2
operator|=
name|qatan
argument_list|(
name|tmp1
argument_list|,
name|epsilon2
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|tmp1
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|epsilon2
argument_list|)
expr_stmt|;
name|tmp1
operator|=
name|qscale
argument_list|(
name|tmp2
argument_list|,
literal|1L
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|tmp2
argument_list|)
expr_stmt|;
return|return
name|tmp1
return|;
block|}
end_block

begin_comment
comment|/*  * Calculate the value of pi to within the required epsilon.  * This uses the following formula which only needs integer calculations  * except for the final operation:  *	pi = 1 / SUMOF(comb(2 * N, N) ^ 3 * (42 * N + 5) / 2 ^ (12 * N + 4)),  * where the summation runs from N=0.  This formula gives about 6 bits of  * accuracy per term.  Since the denominator for each term is a power of two,  * we can simply use shifts to sum the terms.  The combinatorial numbers  * in the formula are calculated recursively using the formula:  *	comb(2*(N+1), N+1) = 2 * comb(2 * N, N) * (2 * N + 1) / N.  */
end_comment

begin_function
name|NUMBER
modifier|*
name|qpi
parameter_list|(
name|epsilon
parameter_list|)
name|NUMBER
modifier|*
name|epsilon
decl_stmt|;
block|{
name|ZVALUE
name|comb
decl_stmt|;
comment|/* current combinatorial value */
name|ZVALUE
name|sum
decl_stmt|;
comment|/* current sum */
name|ZVALUE
name|tmp1
decl_stmt|,
name|tmp2
decl_stmt|;
name|NUMBER
modifier|*
name|r
decl_stmt|,
modifier|*
name|t1
decl_stmt|,
name|qtmp
decl_stmt|;
name|long
name|shift
decl_stmt|;
comment|/* current shift of result */
name|long
name|N
decl_stmt|;
comment|/* current term number */
name|long
name|bits
decl_stmt|;
comment|/* needed number of bits of precision */
name|long
name|t
decl_stmt|;
if|if
condition|(
name|qiszero
argument_list|(
name|epsilon
argument_list|)
operator|||
name|qisneg
argument_list|(
name|epsilon
argument_list|)
condition|)
name|math_error
argument_list|(
literal|"Bad epsilon value for pi"
argument_list|)
expr_stmt|;
name|bits
operator|=
name|qprecision
argument_list|(
name|epsilon
argument_list|)
operator|+
literal|4
expr_stmt|;
name|comb
operator|=
name|_one_
expr_stmt|;
name|itoz
argument_list|(
literal|5L
argument_list|,
operator|&
name|sum
argument_list|)
expr_stmt|;
name|N
operator|=
literal|0
expr_stmt|;
name|shift
operator|=
literal|4
expr_stmt|;
do|do
block|{
name|t
operator|=
literal|1
operator|+
operator|(
operator|++
name|N
operator|&
literal|0x1
operator|)
expr_stmt|;
operator|(
name|void
operator|)
name|zdivi
argument_list|(
name|comb
argument_list|,
name|N
operator|/
operator|(
literal|3
operator|-
name|t
operator|)
argument_list|,
operator|&
name|tmp1
argument_list|)
expr_stmt|;
name|zfree
argument_list|(
name|comb
argument_list|)
expr_stmt|;
name|zmuli
argument_list|(
name|tmp1
argument_list|,
name|t
operator|*
operator|(
literal|2
operator|*
name|N
operator|-
literal|1
operator|)
argument_list|,
operator|&
name|comb
argument_list|)
expr_stmt|;
name|zfree
argument_list|(
name|tmp1
argument_list|)
expr_stmt|;
name|zsquare
argument_list|(
name|comb
argument_list|,
operator|&
name|tmp1
argument_list|)
expr_stmt|;
name|zmul
argument_list|(
name|comb
argument_list|,
name|tmp1
argument_list|,
operator|&
name|tmp2
argument_list|)
expr_stmt|;
name|zfree
argument_list|(
name|tmp1
argument_list|)
expr_stmt|;
name|zmuli
argument_list|(
name|tmp2
argument_list|,
literal|42
operator|*
name|N
operator|+
literal|5
argument_list|,
operator|&
name|tmp1
argument_list|)
expr_stmt|;
name|zfree
argument_list|(
name|tmp2
argument_list|)
expr_stmt|;
name|zshift
argument_list|(
name|sum
argument_list|,
literal|12L
argument_list|,
operator|&
name|tmp2
argument_list|)
expr_stmt|;
name|zfree
argument_list|(
name|sum
argument_list|)
expr_stmt|;
name|zadd
argument_list|(
name|tmp1
argument_list|,
name|tmp2
argument_list|,
operator|&
name|sum
argument_list|)
expr_stmt|;
name|t
operator|=
name|zhighbit
argument_list|(
name|tmp1
argument_list|)
expr_stmt|;
name|zfree
argument_list|(
name|tmp1
argument_list|)
expr_stmt|;
name|zfree
argument_list|(
name|tmp2
argument_list|)
expr_stmt|;
name|shift
operator|+=
literal|12
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|shift
operator|-
name|t
operator|)
operator|<
name|bits
condition|)
do|;
name|qtmp
operator|.
name|num
operator|=
name|_one_
expr_stmt|;
name|qtmp
operator|.
name|den
operator|=
name|sum
expr_stmt|;
name|t1
operator|=
name|qscale
argument_list|(
operator|&
name|qtmp
argument_list|,
name|shift
argument_list|)
expr_stmt|;
name|zfree
argument_list|(
name|sum
argument_list|)
expr_stmt|;
name|r
operator|=
name|qbround
argument_list|(
name|t1
argument_list|,
name|bits
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|t1
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/*  * Calculate the exponential function with a relative accuracy less than  * epsilon.  */
end_comment

begin_function
name|NUMBER
modifier|*
name|qexp
parameter_list|(
name|q
parameter_list|,
name|epsilon
parameter_list|)
name|NUMBER
modifier|*
name|q
decl_stmt|,
decl|*
name|epsilon
decl_stmt|;
end_function

begin_block
block|{
name|long
name|scale
decl_stmt|;
name|FULL
name|n
decl_stmt|;
name|long
name|bits
decl_stmt|,
name|bits2
decl_stmt|;
name|NUMBER
modifier|*
name|sum
decl_stmt|,
modifier|*
name|term
decl_stmt|,
modifier|*
name|qs
decl_stmt|,
modifier|*
name|epsilon2
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
if|if
condition|(
name|qisneg
argument_list|(
name|epsilon
argument_list|)
operator|||
name|qiszero
argument_list|(
name|epsilon
argument_list|)
condition|)
name|math_error
argument_list|(
literal|"Illegal epsilon value for exp"
argument_list|)
expr_stmt|;
if|if
condition|(
name|qiszero
argument_list|(
name|q
argument_list|)
condition|)
return|return
name|qlink
argument_list|(
operator|&
name|_qone_
argument_list|)
return|;
name|epsilon
operator|=
name|qscale
argument_list|(
name|epsilon
argument_list|,
operator|-
literal|4L
argument_list|)
expr_stmt|;
comment|/* 	 * If the argument is larger than one, then divide it by a power of two 	 * so that it is one or less.  This will make the series converge quickly. 	 * We will extrapolate the result for the original argument afterwards. 	 * Also make the argument non-negative. 	 */
name|qs
operator|=
name|qabs
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|scale
operator|=
name|zhighbit
argument_list|(
name|q
operator|->
name|num
argument_list|)
operator|-
name|zhighbit
argument_list|(
name|q
operator|->
name|den
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|scale
operator|<
literal|0
condition|)
name|scale
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|scale
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|scale
operator|>
literal|100000
condition|)
name|math_error
argument_list|(
literal|"Very large argument for exp"
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|qscale
argument_list|(
name|qs
argument_list|,
operator|-
name|scale
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|qs
argument_list|)
expr_stmt|;
name|qs
operator|=
name|tmp
expr_stmt|;
name|tmp
operator|=
name|qscale
argument_list|(
name|epsilon
argument_list|,
operator|-
name|scale
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|epsilon
argument_list|)
expr_stmt|;
name|epsilon
operator|=
name|tmp
expr_stmt|;
block|}
name|epsilon2
operator|=
name|qscale
argument_list|(
name|epsilon
argument_list|,
operator|-
literal|4L
argument_list|)
expr_stmt|;
name|bits
operator|=
name|qprecision
argument_list|(
name|epsilon
argument_list|)
operator|+
literal|1
expr_stmt|;
name|bits2
operator|=
name|bits
operator|+
literal|10
expr_stmt|;
name|qfree
argument_list|(
name|epsilon
argument_list|)
expr_stmt|;
comment|/* 	 * Now use the Taylor series expansion to calculate the exponential. 	 * Keep using approximations so that the fractions don't get too large. 	 */
name|sum
operator|=
name|qlink
argument_list|(
operator|&
name|_qone_
argument_list|)
expr_stmt|;
name|term
operator|=
name|qlink
argument_list|(
operator|&
name|_qone_
argument_list|)
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|qrel
argument_list|(
name|term
argument_list|,
name|epsilon2
argument_list|)
operator|>
literal|0
condition|)
block|{
name|n
operator|++
expr_stmt|;
name|tmp
operator|=
name|qmul
argument_list|(
name|term
argument_list|,
name|qs
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|term
argument_list|)
expr_stmt|;
name|term
operator|=
name|qdivi
argument_list|(
name|tmp
argument_list|,
operator|(
name|long
operator|)
name|n
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|qbround
argument_list|(
name|term
argument_list|,
name|bits2
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|term
argument_list|)
expr_stmt|;
name|term
operator|=
name|tmp
expr_stmt|;
name|tmp
operator|=
name|qadd
argument_list|(
name|sum
argument_list|,
name|term
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|sum
argument_list|)
expr_stmt|;
name|sum
operator|=
name|qbround
argument_list|(
name|tmp
argument_list|,
name|bits2
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
name|qfree
argument_list|(
name|term
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|qs
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|epsilon2
argument_list|)
expr_stmt|;
comment|/* 	 * Now repeatedly square the answer to get the final result. 	 * Then invert it if the original argument was negative. 	 */
while|while
condition|(
operator|--
name|scale
operator|>=
literal|0
condition|)
block|{
name|tmp
operator|=
name|qsquare
argument_list|(
name|sum
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|sum
argument_list|)
expr_stmt|;
name|sum
operator|=
name|qbround
argument_list|(
name|tmp
argument_list|,
name|bits2
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
name|tmp
operator|=
name|qbround
argument_list|(
name|sum
argument_list|,
name|bits
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|sum
argument_list|)
expr_stmt|;
if|if
condition|(
name|qisneg
argument_list|(
name|q
argument_list|)
condition|)
block|{
name|sum
operator|=
name|qinv
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|sum
expr_stmt|;
block|}
return|return
name|tmp
return|;
block|}
end_block

begin_comment
comment|/*  * Calculate the natural logarithm of a number accurate to the specified  * epsilon.  */
end_comment

begin_function
name|NUMBER
modifier|*
name|qln
parameter_list|(
name|q
parameter_list|,
name|epsilon
parameter_list|)
name|NUMBER
modifier|*
name|q
decl_stmt|,
decl|*
name|epsilon
decl_stmt|;
end_function

begin_block
block|{
name|NUMBER
modifier|*
name|term
decl_stmt|,
modifier|*
name|term2
decl_stmt|,
modifier|*
name|sum
decl_stmt|,
modifier|*
name|epsilon2
decl_stmt|,
modifier|*
name|tmp1
decl_stmt|,
modifier|*
name|tmp2
decl_stmt|,
modifier|*
name|maxr
decl_stmt|;
name|long
name|shift
decl_stmt|,
name|bits
decl_stmt|,
name|bits2
decl_stmt|;
name|int
name|j
decl_stmt|,
name|k
decl_stmt|;
name|FULL
name|n
decl_stmt|;
name|BOOL
name|neg
decl_stmt|;
if|if
condition|(
name|qisneg
argument_list|(
name|q
argument_list|)
operator|||
name|qiszero
argument_list|(
name|q
argument_list|)
condition|)
name|math_error
argument_list|(
literal|"log of non-positive number"
argument_list|)
expr_stmt|;
if|if
condition|(
name|qisneg
argument_list|(
name|epsilon
argument_list|)
operator|||
name|qiszero
argument_list|(
name|epsilon
argument_list|)
condition|)
name|math_error
argument_list|(
literal|"Illegal epsilon for ln"
argument_list|)
expr_stmt|;
if|if
condition|(
name|qisone
argument_list|(
name|q
argument_list|)
condition|)
return|return
name|qlink
argument_list|(
operator|&
name|_qzero_
argument_list|)
return|;
comment|/* 	 * If the number is less than one, invert it and remember that 	 * the result is to be negative. 	 */
name|neg
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|zrel
argument_list|(
name|q
operator|->
name|num
argument_list|,
name|q
operator|->
name|den
argument_list|)
operator|<
literal|0
condition|)
block|{
name|neg
operator|=
name|TRUE
expr_stmt|;
name|q
operator|=
name|qinv
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
else|else
name|q
operator|=
name|qlink
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|j
operator|=
literal|16
expr_stmt|;
name|k
operator|=
name|zhighbit
argument_list|(
name|q
operator|->
name|num
argument_list|)
operator|-
name|zhighbit
argument_list|(
name|q
operator|->
name|den
argument_list|)
operator|+
literal|1
expr_stmt|;
while|while
condition|(
name|k
operator|>>=
literal|1
condition|)
name|j
operator|++
expr_stmt|;
name|epsilon2
operator|=
name|qscale
argument_list|(
name|epsilon
argument_list|,
operator|-
name|j
argument_list|)
expr_stmt|;
name|bits
operator|=
name|qprecision
argument_list|(
name|epsilon
argument_list|)
operator|+
literal|1
expr_stmt|;
name|bits2
operator|=
name|qprecision
argument_list|(
name|epsilon2
argument_list|)
operator|+
literal|5
expr_stmt|;
comment|/* 	 * By repeated square-roots scale number down to a value close 	 * to 1 so that Taylor series to be used will converge rapidly. 	 * The effect of scaling will be reversed by a later shift. 	 */
name|maxr
operator|=
name|iitoq
argument_list|(
name|BASE
operator|+
literal|1
argument_list|,
name|BASE
argument_list|)
expr_stmt|;
name|shift
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|qrel
argument_list|(
name|q
argument_list|,
name|maxr
argument_list|)
operator|>
literal|0
condition|)
block|{
name|tmp1
operator|=
name|qsqrt
argument_list|(
name|q
argument_list|,
name|epsilon2
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|q
operator|=
name|tmp1
expr_stmt|;
name|shift
operator|++
expr_stmt|;
block|}
name|qfree
argument_list|(
name|maxr
argument_list|)
expr_stmt|;
comment|/* 	 * Calculate a value which will always converge using the formula: 	 *	ln((1+x)/(1-x)) = ln(1+x) - ln(1-x). 	 */
name|tmp1
operator|=
name|qdec
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|tmp2
operator|=
name|qinc
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|term
operator|=
name|qdiv
argument_list|(
name|tmp1
argument_list|,
name|tmp2
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|tmp1
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|tmp2
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|q
argument_list|)
expr_stmt|;
comment|/* 	 * Now use the Taylor series expansion to calculate the result. 	 */
name|n
operator|=
literal|1
expr_stmt|;
name|term2
operator|=
name|qsquare
argument_list|(
name|term
argument_list|)
expr_stmt|;
name|sum
operator|=
name|qlink
argument_list|(
name|term
argument_list|)
expr_stmt|;
while|while
condition|(
name|qrel
argument_list|(
name|term
argument_list|,
name|epsilon2
argument_list|)
operator|>
literal|0
condition|)
block|{
name|n
operator|+=
literal|2
expr_stmt|;
name|tmp1
operator|=
name|qmul
argument_list|(
name|term
argument_list|,
name|term2
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|term
argument_list|)
expr_stmt|;
name|term
operator|=
name|qbround
argument_list|(
name|tmp1
argument_list|,
name|bits2
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|tmp1
argument_list|)
expr_stmt|;
name|tmp1
operator|=
name|qdivi
argument_list|(
name|term
argument_list|,
operator|(
name|long
operator|)
name|n
argument_list|)
expr_stmt|;
name|tmp2
operator|=
name|qadd
argument_list|(
name|sum
argument_list|,
name|tmp1
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|tmp1
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|sum
argument_list|)
expr_stmt|;
name|sum
operator|=
name|qbround
argument_list|(
name|tmp2
argument_list|,
name|bits2
argument_list|)
expr_stmt|;
block|}
name|qfree
argument_list|(
name|epsilon2
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|term
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|term2
argument_list|)
expr_stmt|;
comment|/* 	 * Calculate the final result by multiplying by the proper power 	 * of two to undo the square roots done at the top, and possibly 	 * negating the result. 	 */
name|tmp1
operator|=
name|qscale
argument_list|(
name|sum
argument_list|,
name|shift
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|sum
argument_list|)
expr_stmt|;
name|sum
operator|=
name|qbround
argument_list|(
name|tmp1
argument_list|,
name|bits
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|tmp1
argument_list|)
expr_stmt|;
if|if
condition|(
name|neg
condition|)
block|{
name|tmp1
operator|=
name|qneg
argument_list|(
name|sum
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|sum
argument_list|)
expr_stmt|;
name|sum
operator|=
name|tmp1
expr_stmt|;
block|}
return|return
name|sum
return|;
block|}
end_block

begin_comment
comment|/*  * Calculate the result of raising one number to the power of another.  * The result is calculated to within the specified relative error.  */
end_comment

begin_function
name|NUMBER
modifier|*
name|qpower
parameter_list|(
name|q1
parameter_list|,
name|q2
parameter_list|,
name|epsilon
parameter_list|)
name|NUMBER
modifier|*
name|q1
decl_stmt|,
decl|*
name|q2
decl_stmt|,
modifier|*
name|epsilon
decl_stmt|;
end_function

begin_block
block|{
name|NUMBER
modifier|*
name|tmp1
decl_stmt|,
modifier|*
name|tmp2
decl_stmt|,
modifier|*
name|epsilon2
decl_stmt|;
if|if
condition|(
name|qisint
argument_list|(
name|q2
argument_list|)
condition|)
return|return
name|qpowi
argument_list|(
name|q1
argument_list|,
name|q2
argument_list|)
return|;
name|epsilon2
operator|=
name|qscale
argument_list|(
name|epsilon
argument_list|,
operator|-
literal|4L
argument_list|)
expr_stmt|;
name|tmp1
operator|=
name|qln
argument_list|(
name|q1
argument_list|,
name|epsilon2
argument_list|)
expr_stmt|;
name|tmp2
operator|=
name|qmul
argument_list|(
name|tmp1
argument_list|,
name|q2
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|tmp1
argument_list|)
expr_stmt|;
name|tmp1
operator|=
name|qexp
argument_list|(
name|tmp2
argument_list|,
name|epsilon
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|tmp2
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|epsilon2
argument_list|)
expr_stmt|;
return|return
name|tmp1
return|;
block|}
end_block

begin_comment
comment|/*  * Calculate the Kth root of a number to within the specified accuracy.  */
end_comment

begin_function
name|NUMBER
modifier|*
name|qroot
parameter_list|(
name|q1
parameter_list|,
name|q2
parameter_list|,
name|epsilon
parameter_list|)
name|NUMBER
modifier|*
name|q1
decl_stmt|,
decl|*
name|q2
decl_stmt|,
modifier|*
name|epsilon
decl_stmt|;
end_function

begin_block
block|{
name|NUMBER
modifier|*
name|tmp1
decl_stmt|,
modifier|*
name|tmp2
decl_stmt|,
modifier|*
name|epsilon2
decl_stmt|;
name|int
name|neg
decl_stmt|;
if|if
condition|(
name|qisneg
argument_list|(
name|q2
argument_list|)
operator|||
name|qiszero
argument_list|(
name|q2
argument_list|)
operator|||
name|qisfrac
argument_list|(
name|q2
argument_list|)
condition|)
name|math_error
argument_list|(
literal|"Taking bad root of number"
argument_list|)
expr_stmt|;
if|if
condition|(
name|qiszero
argument_list|(
name|q1
argument_list|)
operator|||
name|qisone
argument_list|(
name|q1
argument_list|)
operator|||
name|qisone
argument_list|(
name|q2
argument_list|)
condition|)
return|return
name|qlink
argument_list|(
name|q1
argument_list|)
return|;
if|if
condition|(
name|qistwo
argument_list|(
name|q2
argument_list|)
condition|)
return|return
name|qsqrt
argument_list|(
name|q1
argument_list|,
name|epsilon
argument_list|)
return|;
name|neg
operator|=
name|qisneg
argument_list|(
name|q1
argument_list|)
expr_stmt|;
if|if
condition|(
name|neg
condition|)
block|{
if|if
condition|(
name|ziseven
argument_list|(
name|q2
operator|->
name|num
argument_list|)
condition|)
name|math_error
argument_list|(
literal|"Taking even root of negative number"
argument_list|)
expr_stmt|;
name|q1
operator|=
name|qabs
argument_list|(
name|q1
argument_list|)
expr_stmt|;
block|}
name|epsilon2
operator|=
name|qscale
argument_list|(
name|epsilon
argument_list|,
operator|-
literal|4L
argument_list|)
expr_stmt|;
name|tmp1
operator|=
name|qln
argument_list|(
name|q1
argument_list|,
name|epsilon2
argument_list|)
expr_stmt|;
name|tmp2
operator|=
name|qdiv
argument_list|(
name|tmp1
argument_list|,
name|q2
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|tmp1
argument_list|)
expr_stmt|;
name|tmp1
operator|=
name|qexp
argument_list|(
name|tmp2
argument_list|,
name|epsilon
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|tmp2
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|epsilon2
argument_list|)
expr_stmt|;
if|if
condition|(
name|neg
condition|)
block|{
name|tmp2
operator|=
name|qneg
argument_list|(
name|tmp1
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|tmp1
argument_list|)
expr_stmt|;
name|tmp1
operator|=
name|tmp2
expr_stmt|;
block|}
return|return
name|tmp1
return|;
block|}
end_block

begin_comment
comment|/*  * Calculate the hyperbolic cosine function with a relative accuracy less  * than epsilon.  This is defined by:  *	cosh(x) = (exp(x) + exp(-x)) / 2.  */
end_comment

begin_function
name|NUMBER
modifier|*
name|qcosh
parameter_list|(
name|q
parameter_list|,
name|epsilon
parameter_list|)
name|NUMBER
modifier|*
name|q
decl_stmt|,
decl|*
name|epsilon
decl_stmt|;
end_function

begin_block
block|{
name|long
name|scale
decl_stmt|;
name|FULL
name|n
decl_stmt|;
name|FULL
name|m
decl_stmt|;
name|long
name|bits
decl_stmt|,
name|bits2
decl_stmt|;
name|NUMBER
modifier|*
name|sum
decl_stmt|,
modifier|*
name|term
decl_stmt|,
modifier|*
name|qs
decl_stmt|,
modifier|*
name|epsilon2
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
if|if
condition|(
name|qisneg
argument_list|(
name|epsilon
argument_list|)
operator|||
name|qiszero
argument_list|(
name|epsilon
argument_list|)
condition|)
name|math_error
argument_list|(
literal|"Illegal epsilon value for exp"
argument_list|)
expr_stmt|;
if|if
condition|(
name|qiszero
argument_list|(
name|q
argument_list|)
condition|)
return|return
name|qlink
argument_list|(
operator|&
name|_qone_
argument_list|)
return|;
name|epsilon
operator|=
name|qscale
argument_list|(
name|epsilon
argument_list|,
operator|-
literal|4L
argument_list|)
expr_stmt|;
comment|/* 	 * If the argument is larger than one, then divide it by a power of two 	 * so that it is one or less.  This will make the series converge quickly. 	 * We will extrapolate the result for the original argument afterwards. 	 */
name|qs
operator|=
name|qabs
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|scale
operator|=
name|zhighbit
argument_list|(
name|q
operator|->
name|num
argument_list|)
operator|-
name|zhighbit
argument_list|(
name|q
operator|->
name|den
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|scale
operator|<
literal|0
condition|)
name|scale
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|scale
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|scale
operator|>
literal|100000
condition|)
name|math_error
argument_list|(
literal|"Very large argument for exp"
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|qscale
argument_list|(
name|qs
argument_list|,
operator|-
name|scale
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|qs
argument_list|)
expr_stmt|;
name|qs
operator|=
name|tmp
expr_stmt|;
name|tmp
operator|=
name|qscale
argument_list|(
name|epsilon
argument_list|,
operator|-
name|scale
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|epsilon
argument_list|)
expr_stmt|;
name|epsilon
operator|=
name|tmp
expr_stmt|;
block|}
name|epsilon2
operator|=
name|qscale
argument_list|(
name|epsilon
argument_list|,
operator|-
literal|4L
argument_list|)
expr_stmt|;
name|bits
operator|=
name|qprecision
argument_list|(
name|epsilon
argument_list|)
operator|+
literal|1
expr_stmt|;
name|bits2
operator|=
name|bits
operator|+
literal|10
expr_stmt|;
name|qfree
argument_list|(
name|epsilon
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|qsquare
argument_list|(
name|qs
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|qs
argument_list|)
expr_stmt|;
name|qs
operator|=
name|tmp
expr_stmt|;
comment|/* 	 * Now use the Taylor series expansion to calculate the exponential. 	 * Keep using approximations so that the fractions don't get too large. 	 */
name|sum
operator|=
name|qlink
argument_list|(
operator|&
name|_qone_
argument_list|)
expr_stmt|;
name|term
operator|=
name|qlink
argument_list|(
operator|&
name|_qone_
argument_list|)
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|qrel
argument_list|(
name|term
argument_list|,
name|epsilon2
argument_list|)
operator|>
literal|0
condition|)
block|{
name|m
operator|=
operator|++
name|n
expr_stmt|;
name|m
operator|*=
operator|++
name|n
expr_stmt|;
name|tmp
operator|=
name|qmul
argument_list|(
name|term
argument_list|,
name|qs
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|term
argument_list|)
expr_stmt|;
name|term
operator|=
name|qdivi
argument_list|(
name|tmp
argument_list|,
operator|(
name|long
operator|)
name|m
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|qbround
argument_list|(
name|term
argument_list|,
name|bits2
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|term
argument_list|)
expr_stmt|;
name|term
operator|=
name|tmp
expr_stmt|;
name|tmp
operator|=
name|qadd
argument_list|(
name|sum
argument_list|,
name|term
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|sum
argument_list|)
expr_stmt|;
name|sum
operator|=
name|qbround
argument_list|(
name|tmp
argument_list|,
name|bits2
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
name|qfree
argument_list|(
name|term
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|qs
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|epsilon2
argument_list|)
expr_stmt|;
comment|/* 	 * Now bring the number back up into range to get the final result. 	 * This uses the formula: 	 *	cosh(2 * x) = 2 * cosh(x)^2 - 1. 	 */
while|while
condition|(
operator|--
name|scale
operator|>=
literal|0
condition|)
block|{
name|tmp
operator|=
name|qsquare
argument_list|(
name|sum
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|sum
argument_list|)
expr_stmt|;
name|sum
operator|=
name|qscale
argument_list|(
name|tmp
argument_list|,
literal|1L
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|qdec
argument_list|(
name|sum
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|sum
argument_list|)
expr_stmt|;
name|sum
operator|=
name|qbround
argument_list|(
name|tmp
argument_list|,
name|bits2
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
name|tmp
operator|=
name|qbround
argument_list|(
name|sum
argument_list|,
name|bits
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|sum
argument_list|)
expr_stmt|;
return|return
name|tmp
return|;
block|}
end_block

begin_comment
comment|/*  * Calculate the hyperbolic sine with an accurary less than epsilon.  * This is calculated using the formula:  *	cosh(x)^2 - sinh(x)^2 = 1.  */
end_comment

begin_function
name|NUMBER
modifier|*
name|qsinh
parameter_list|(
name|q
parameter_list|,
name|epsilon
parameter_list|)
name|NUMBER
modifier|*
name|q
decl_stmt|,
decl|*
name|epsilon
decl_stmt|;
end_function

begin_block
block|{
name|NUMBER
modifier|*
name|tmp1
decl_stmt|,
modifier|*
name|tmp2
decl_stmt|;
if|if
condition|(
name|qisneg
argument_list|(
name|epsilon
argument_list|)
operator|||
name|qiszero
argument_list|(
name|epsilon
argument_list|)
condition|)
name|math_error
argument_list|(
literal|"Illegal epsilon value for sinh"
argument_list|)
expr_stmt|;
if|if
condition|(
name|qiszero
argument_list|(
name|q
argument_list|)
condition|)
return|return
name|qlink
argument_list|(
name|q
argument_list|)
return|;
name|epsilon
operator|=
name|qscale
argument_list|(
name|epsilon
argument_list|,
operator|-
literal|4L
argument_list|)
expr_stmt|;
name|tmp1
operator|=
name|qcosh
argument_list|(
name|q
argument_list|,
name|epsilon
argument_list|)
expr_stmt|;
name|tmp2
operator|=
name|qsquare
argument_list|(
name|tmp1
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|tmp1
argument_list|)
expr_stmt|;
name|tmp1
operator|=
name|qdec
argument_list|(
name|tmp2
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|tmp2
argument_list|)
expr_stmt|;
name|tmp2
operator|=
name|qsqrt
argument_list|(
name|tmp1
argument_list|,
name|epsilon
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|tmp1
argument_list|)
expr_stmt|;
if|if
condition|(
name|qisneg
argument_list|(
name|q
argument_list|)
condition|)
block|{
name|tmp1
operator|=
name|qneg
argument_list|(
name|tmp2
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|tmp2
argument_list|)
expr_stmt|;
name|tmp2
operator|=
name|tmp1
expr_stmt|;
block|}
name|qfree
argument_list|(
name|epsilon
argument_list|)
expr_stmt|;
return|return
name|tmp2
return|;
block|}
end_block

begin_comment
comment|/*  * Calculate the hyperbolic tangent with an accurary less than epsilon.  * This is calculated using the formula:  *	tanh(x) = sinh(x) / cosh(x).  */
end_comment

begin_function
name|NUMBER
modifier|*
name|qtanh
parameter_list|(
name|q
parameter_list|,
name|epsilon
parameter_list|)
name|NUMBER
modifier|*
name|q
decl_stmt|,
decl|*
name|epsilon
decl_stmt|;
end_function

begin_block
block|{
name|NUMBER
modifier|*
name|tmp1
decl_stmt|,
modifier|*
name|tmp2
decl_stmt|,
modifier|*
name|coshval
decl_stmt|;
if|if
condition|(
name|qisneg
argument_list|(
name|epsilon
argument_list|)
operator|||
name|qiszero
argument_list|(
name|epsilon
argument_list|)
condition|)
name|math_error
argument_list|(
literal|"Illegal epsilon value for tanh"
argument_list|)
expr_stmt|;
if|if
condition|(
name|qiszero
argument_list|(
name|q
argument_list|)
condition|)
return|return
name|qlink
argument_list|(
name|q
argument_list|)
return|;
name|epsilon
operator|=
name|qscale
argument_list|(
name|epsilon
argument_list|,
operator|-
literal|4L
argument_list|)
expr_stmt|;
name|coshval
operator|=
name|qcosh
argument_list|(
name|q
argument_list|,
name|epsilon
argument_list|)
expr_stmt|;
name|tmp2
operator|=
name|qsquare
argument_list|(
name|coshval
argument_list|)
expr_stmt|;
name|tmp1
operator|=
name|qdec
argument_list|(
name|tmp2
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|tmp2
argument_list|)
expr_stmt|;
name|tmp2
operator|=
name|qsqrt
argument_list|(
name|tmp1
argument_list|,
name|epsilon
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|tmp1
argument_list|)
expr_stmt|;
if|if
condition|(
name|qisneg
argument_list|(
name|q
argument_list|)
condition|)
block|{
name|tmp1
operator|=
name|qneg
argument_list|(
name|tmp2
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|tmp2
argument_list|)
expr_stmt|;
name|tmp2
operator|=
name|tmp1
expr_stmt|;
block|}
name|qfree
argument_list|(
name|epsilon
argument_list|)
expr_stmt|;
name|tmp1
operator|=
name|qdiv
argument_list|(
name|tmp2
argument_list|,
name|coshval
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|tmp2
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|coshval
argument_list|)
expr_stmt|;
return|return
name|tmp1
return|;
block|}
end_block

begin_comment
comment|/*  * Compute the hyperbolic arccosine within the specified accuracy.  * This is calculated using the formula:  *	acosh(x) = ln(x + sqrt(x^2 - 1)).  */
end_comment

begin_function
name|NUMBER
modifier|*
name|qacosh
parameter_list|(
name|q
parameter_list|,
name|epsilon
parameter_list|)
name|NUMBER
modifier|*
name|q
decl_stmt|,
decl|*
name|epsilon
decl_stmt|;
end_function

begin_block
block|{
name|NUMBER
modifier|*
name|tmp1
decl_stmt|,
modifier|*
name|tmp2
decl_stmt|,
modifier|*
name|epsilon2
decl_stmt|;
if|if
condition|(
name|qisneg
argument_list|(
name|epsilon
argument_list|)
operator|||
name|qiszero
argument_list|(
name|epsilon
argument_list|)
condition|)
name|math_error
argument_list|(
literal|"Illegal epsilon value for acosh"
argument_list|)
expr_stmt|;
if|if
condition|(
name|qisone
argument_list|(
name|q
argument_list|)
condition|)
return|return
name|qlink
argument_list|(
operator|&
name|_qzero_
argument_list|)
return|;
if|if
condition|(
name|qreli
argument_list|(
name|q
argument_list|,
literal|1L
argument_list|)
operator|<
literal|0
condition|)
name|math_error
argument_list|(
literal|"Argument less than one for acosh"
argument_list|)
expr_stmt|;
name|epsilon2
operator|=
name|qscale
argument_list|(
name|epsilon
argument_list|,
operator|-
literal|8L
argument_list|)
expr_stmt|;
name|tmp1
operator|=
name|qsquare
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|tmp2
operator|=
name|qdec
argument_list|(
name|tmp1
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|tmp1
argument_list|)
expr_stmt|;
name|tmp1
operator|=
name|qsqrt
argument_list|(
name|tmp2
argument_list|,
name|epsilon2
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|tmp2
argument_list|)
expr_stmt|;
name|tmp2
operator|=
name|qadd
argument_list|(
name|tmp1
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|tmp1
argument_list|)
expr_stmt|;
name|tmp1
operator|=
name|qln
argument_list|(
name|tmp2
argument_list|,
name|epsilon
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|tmp2
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|epsilon2
argument_list|)
expr_stmt|;
return|return
name|tmp1
return|;
block|}
end_block

begin_comment
comment|/*  * Compute the hyperbolic arcsine within the specified accuracy.  * This is calculated using the formula:  *	asinh(x) = ln(x + sqrt(x^2 + 1)).  */
end_comment

begin_function
name|NUMBER
modifier|*
name|qasinh
parameter_list|(
name|q
parameter_list|,
name|epsilon
parameter_list|)
name|NUMBER
modifier|*
name|q
decl_stmt|,
decl|*
name|epsilon
decl_stmt|;
end_function

begin_block
block|{
name|NUMBER
modifier|*
name|tmp1
decl_stmt|,
modifier|*
name|tmp2
decl_stmt|,
modifier|*
name|epsilon2
decl_stmt|;
if|if
condition|(
name|qisneg
argument_list|(
name|epsilon
argument_list|)
operator|||
name|qiszero
argument_list|(
name|epsilon
argument_list|)
condition|)
name|math_error
argument_list|(
literal|"Illegal epsilon value for asinh"
argument_list|)
expr_stmt|;
if|if
condition|(
name|qiszero
argument_list|(
name|q
argument_list|)
condition|)
return|return
name|qlink
argument_list|(
operator|&
name|_qzero_
argument_list|)
return|;
name|epsilon2
operator|=
name|qscale
argument_list|(
name|epsilon
argument_list|,
operator|-
literal|8L
argument_list|)
expr_stmt|;
name|tmp1
operator|=
name|qsquare
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|tmp2
operator|=
name|qinc
argument_list|(
name|tmp1
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|tmp1
argument_list|)
expr_stmt|;
name|tmp1
operator|=
name|qsqrt
argument_list|(
name|tmp2
argument_list|,
name|epsilon2
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|tmp2
argument_list|)
expr_stmt|;
name|tmp2
operator|=
name|qadd
argument_list|(
name|tmp1
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|tmp1
argument_list|)
expr_stmt|;
name|tmp1
operator|=
name|qln
argument_list|(
name|tmp2
argument_list|,
name|epsilon
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|tmp2
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|epsilon2
argument_list|)
expr_stmt|;
return|return
name|tmp1
return|;
block|}
end_block

begin_comment
comment|/*  * Compute the hyperbolic arctangent within the specified accuracy.  * This is calculated using the formula:  *	atanh(x) = ln((1 + u) / (1 - u)) / 2.  */
end_comment

begin_function
name|NUMBER
modifier|*
name|qatanh
parameter_list|(
name|q
parameter_list|,
name|epsilon
parameter_list|)
name|NUMBER
modifier|*
name|q
decl_stmt|,
decl|*
name|epsilon
decl_stmt|;
end_function

begin_block
block|{
name|NUMBER
modifier|*
name|tmp1
decl_stmt|,
modifier|*
name|tmp2
decl_stmt|,
modifier|*
name|tmp3
decl_stmt|;
if|if
condition|(
name|qisneg
argument_list|(
name|epsilon
argument_list|)
operator|||
name|qiszero
argument_list|(
name|epsilon
argument_list|)
condition|)
name|math_error
argument_list|(
literal|"Illegal epsilon value for atanh"
argument_list|)
expr_stmt|;
if|if
condition|(
name|qiszero
argument_list|(
name|q
argument_list|)
condition|)
return|return
name|qlink
argument_list|(
operator|&
name|_qzero_
argument_list|)
return|;
if|if
condition|(
operator|(
name|qreli
argument_list|(
name|q
argument_list|,
literal|1L
argument_list|)
operator|>
literal|0
operator|)
operator|||
operator|(
name|qreli
argument_list|(
name|q
argument_list|,
operator|-
literal|1L
argument_list|)
operator|<
literal|0
operator|)
condition|)
name|math_error
argument_list|(
literal|"Argument not between -1 and 1 for atanh"
argument_list|)
expr_stmt|;
name|tmp1
operator|=
name|qinc
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|tmp2
operator|=
name|qsub
argument_list|(
operator|&
name|_qone_
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|tmp3
operator|=
name|qdiv
argument_list|(
name|tmp1
argument_list|,
name|tmp2
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|tmp1
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|tmp2
argument_list|)
expr_stmt|;
name|tmp1
operator|=
name|qln
argument_list|(
name|tmp3
argument_list|,
name|epsilon
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|tmp3
argument_list|)
expr_stmt|;
name|tmp2
operator|=
name|qscale
argument_list|(
name|tmp1
argument_list|,
operator|-
literal|1L
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|tmp1
argument_list|)
expr_stmt|;
return|return
name|tmp2
return|;
block|}
end_block

begin_comment
comment|/* END CODE */
end_comment

end_unit

