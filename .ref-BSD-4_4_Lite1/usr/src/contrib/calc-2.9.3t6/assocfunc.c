begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1994 David I. Bell  * Permission is granted to use, distribute, or modify this source,  * provided that this copyright notice remains intact.  *  * Association table routines.  * An association table is a type of value which can be "indexed" by  * one or more arbitrary values.  Each element in the table is thus an  * association between a particular set of index values and a result value.  * The elements in an association table are stored in a hash table for  * quick access.  */
end_comment

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_define
define|#
directive|define
name|MINHASHSIZE
value|31
end_define

begin_comment
comment|/* minimum size of hash tables */
end_comment

begin_define
define|#
directive|define
name|GROWHASHSIZE
value|50
end_define

begin_comment
comment|/* approximate growth for hash tables */
end_comment

begin_define
define|#
directive|define
name|CHAINLENGTH
value|10
end_define

begin_comment
comment|/* desired number of elements on a hash chain */
end_comment

begin_define
define|#
directive|define
name|ELEMSIZE
parameter_list|(
name|n
parameter_list|)
value|(sizeof(ASSOCELEM) + (sizeof(VALUE) * ((n) - 1)))
end_define

begin_decl_stmt
specifier|static
name|ASSOCELEM
modifier|*
name|elemindex
name|MATH_PROTO
argument_list|(
operator|(
name|ASSOC
operator|*
name|ap
operator|,
name|long
name|index
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|BOOL
name|compareindices
name|MATH_PROTO
argument_list|(
operator|(
name|VALUE
operator|*
name|v1
operator|,
name|VALUE
operator|*
name|v2
operator|,
name|long
name|dim
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|resize
name|MATH_PROTO
argument_list|(
operator|(
name|ASSOC
operator|*
name|ap
operator|,
name|long
name|newsize
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|assoc_elemfree
name|MATH_PROTO
argument_list|(
operator|(
name|ASSOCELEM
operator|*
name|ep
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|nextprime
name|MATH_PROTO
argument_list|(
operator|(
name|long
name|n
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Return the address of the value specified by normal indexing of  * an association.  The create flag is TRUE if a value is going to be  * assigned into the specified indexing location.  If create is FALSE and  * the index value doesn't exist, a pointer to a NULL value is returned.  */
end_comment

begin_function
name|VALUE
modifier|*
name|associndex
parameter_list|(
name|ap
parameter_list|,
name|create
parameter_list|,
name|dim
parameter_list|,
name|indices
parameter_list|)
name|ASSOC
modifier|*
name|ap
decl_stmt|;
comment|/* association to index into */
name|BOOL
name|create
decl_stmt|;
comment|/* whether to create the index value */
name|long
name|dim
decl_stmt|;
comment|/* dimension of the indexing */
name|VALUE
modifier|*
name|indices
decl_stmt|;
comment|/* table of values being indexed by */
block|{
name|ASSOCELEM
modifier|*
modifier|*
name|listhead
decl_stmt|;
name|ASSOCELEM
modifier|*
name|ep
decl_stmt|;
specifier|static
name|VALUE
name|val
decl_stmt|;
name|HASH
name|hash
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|dim
operator|<=
literal|0
condition|)
name|math_error
argument_list|(
literal|"No dimensions for indexing association"
argument_list|)
expr_stmt|;
comment|/* 	 * Calculate the hash value to use for this set of indices 	 * so that we can first select the correct hash chain, and 	 * also so we can quickly compare each element for a match. 	 */
name|hash
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dim
condition|;
name|i
operator|++
control|)
comment|/* ignore Saber-C warning about Over/underflow */
name|hash
operator|=
name|hash
operator|*
literal|67319821
operator|+
name|hashvalue
argument_list|(
operator|&
name|indices
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* 	 * Search the correct hash chain for the specified set of indices. 	 * If found, return the address of the found element's value. 	 */
name|listhead
operator|=
operator|&
name|ap
operator|->
name|a_table
index|[
name|hash
operator|%
name|ap
operator|->
name|a_size
index|]
expr_stmt|;
for|for
control|(
name|ep
operator|=
operator|*
name|listhead
init|;
name|ep
condition|;
name|ep
operator|=
name|ep
operator|->
name|e_next
control|)
block|{
if|if
condition|(
operator|(
name|ep
operator|->
name|e_hash
operator|!=
name|hash
operator|)
operator|||
operator|(
name|ep
operator|->
name|e_dim
operator|!=
name|dim
operator|)
condition|)
continue|continue;
if|if
condition|(
name|compareindices
argument_list|(
name|ep
operator|->
name|e_indices
argument_list|,
name|indices
argument_list|,
name|dim
argument_list|)
condition|)
return|return
operator|&
name|ep
operator|->
name|e_value
return|;
block|}
comment|/* 	 * The set of indices was not found. 	 * Either return a pointer to a NULL value for a read reference, 	 * or allocate a new element in the list for a write reference. 	 */
if|if
condition|(
operator|!
name|create
condition|)
block|{
name|val
operator|.
name|v_type
operator|=
name|V_NULL
expr_stmt|;
return|return
operator|&
name|val
return|;
block|}
name|ep
operator|=
operator|(
name|ASSOCELEM
operator|*
operator|)
name|malloc
argument_list|(
name|ELEMSIZE
argument_list|(
name|dim
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|==
name|NULL
condition|)
name|math_error
argument_list|(
literal|"Cannot allocate association element"
argument_list|)
expr_stmt|;
name|ep
operator|->
name|e_dim
operator|=
name|dim
expr_stmt|;
name|ep
operator|->
name|e_hash
operator|=
name|hash
expr_stmt|;
name|ep
operator|->
name|e_value
operator|.
name|v_type
operator|=
name|V_NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dim
condition|;
name|i
operator|++
control|)
name|copyvalue
argument_list|(
operator|&
name|indices
index|[
name|i
index|]
argument_list|,
operator|&
name|ep
operator|->
name|e_indices
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ep
operator|->
name|e_next
operator|=
operator|*
name|listhead
expr_stmt|;
operator|*
name|listhead
operator|=
name|ep
expr_stmt|;
name|ap
operator|->
name|a_count
operator|++
expr_stmt|;
name|resize
argument_list|(
name|ap
argument_list|,
name|ap
operator|->
name|a_count
operator|/
name|CHAINLENGTH
argument_list|)
expr_stmt|;
return|return
operator|&
name|ep
operator|->
name|e_value
return|;
block|}
end_function

begin_comment
comment|/*  * Search an association for the specified value starting at the  * specified index.  Returns the element number (zero based) of the  * found value, or -1 if the value was not found.  */
end_comment

begin_function
name|long
name|assocsearch
parameter_list|(
name|ap
parameter_list|,
name|vp
parameter_list|,
name|index
parameter_list|)
name|ASSOC
modifier|*
name|ap
decl_stmt|;
name|VALUE
modifier|*
name|vp
decl_stmt|;
name|long
name|index
decl_stmt|;
block|{
name|ASSOCELEM
modifier|*
name|ep
decl_stmt|;
if|if
condition|(
name|index
operator|<
literal|0
condition|)
name|index
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|TRUE
condition|)
block|{
name|ep
operator|=
name|elemindex
argument_list|(
name|ap
argument_list|,
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|!
name|comparevalue
argument_list|(
operator|&
name|ep
operator|->
name|e_value
argument_list|,
name|vp
argument_list|)
condition|)
return|return
name|index
return|;
name|index
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Search an association backwards for the specified value starting at the  * specified index.  Returns the element number (zero based) of the  * found value, or -1 if the value was not found.  */
end_comment

begin_function
name|long
name|assocrsearch
parameter_list|(
name|ap
parameter_list|,
name|vp
parameter_list|,
name|index
parameter_list|)
name|ASSOC
modifier|*
name|ap
decl_stmt|;
name|VALUE
modifier|*
name|vp
decl_stmt|;
name|long
name|index
decl_stmt|;
block|{
name|ASSOCELEM
modifier|*
name|ep
decl_stmt|;
if|if
condition|(
name|index
operator|>=
name|ap
operator|->
name|a_count
condition|)
name|index
operator|=
name|ap
operator|->
name|a_count
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|TRUE
condition|)
block|{
name|ep
operator|=
name|elemindex
argument_list|(
name|ap
argument_list|,
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|!
name|comparevalue
argument_list|(
operator|&
name|ep
operator|->
name|e_value
argument_list|,
name|vp
argument_list|)
condition|)
return|return
name|index
return|;
name|index
operator|--
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Return the address of an element of an association indexed by the  * double-bracket operation.  */
end_comment

begin_function
specifier|static
name|ASSOCELEM
modifier|*
name|elemindex
parameter_list|(
name|ap
parameter_list|,
name|index
parameter_list|)
name|ASSOC
modifier|*
name|ap
decl_stmt|;
comment|/* association to index into */
name|long
name|index
decl_stmt|;
comment|/* index of desired element */
block|{
name|ASSOCELEM
modifier|*
name|ep
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|(
name|index
operator|<
literal|0
operator|)
operator|||
operator|(
name|index
operator|>
name|ap
operator|->
name|a_count
operator|)
condition|)
return|return
name|NULL
return|;
comment|/* 	 * This loop should be made more efficient by remembering 	 * previously requested locations within the association. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ap
operator|->
name|a_size
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|ep
operator|=
name|ap
operator|->
name|a_table
index|[
name|i
index|]
init|;
name|ep
condition|;
name|ep
operator|=
name|ep
operator|->
name|e_next
control|)
block|{
if|if
condition|(
name|index
operator|--
operator|==
literal|0
condition|)
return|return
name|ep
return|;
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * Return the address of the value specified by double-bracket indexing  * of an association.  Returns NULL if there is no such element.  */
end_comment

begin_function
name|VALUE
modifier|*
name|assocfindex
parameter_list|(
name|ap
parameter_list|,
name|index
parameter_list|)
name|ASSOC
modifier|*
name|ap
decl_stmt|;
comment|/* association to index into */
name|long
name|index
decl_stmt|;
comment|/* index of desired element */
block|{
name|ASSOCELEM
modifier|*
name|ep
decl_stmt|;
name|ep
operator|=
name|elemindex
argument_list|(
name|ap
argument_list|,
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
return|return
operator|&
name|ep
operator|->
name|e_value
return|;
block|}
end_function

begin_comment
comment|/*  * Compare two associations to see if they are identical.  * Returns TRUE if they are different.  */
end_comment

begin_function
name|BOOL
name|assoccmp
parameter_list|(
name|ap1
parameter_list|,
name|ap2
parameter_list|)
name|ASSOC
modifier|*
name|ap1
decl_stmt|,
decl|*
name|ap2
decl_stmt|;
end_function

begin_block
block|{
name|ASSOCELEM
modifier|*
modifier|*
name|table1
decl_stmt|;
name|ASSOCELEM
modifier|*
name|ep1
decl_stmt|;
name|ASSOCELEM
modifier|*
name|ep2
decl_stmt|;
name|long
name|size1
decl_stmt|;
name|long
name|size2
decl_stmt|;
name|HASH
name|hash
decl_stmt|;
name|long
name|dim
decl_stmt|;
if|if
condition|(
name|ap1
operator|==
name|ap2
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|ap1
operator|->
name|a_count
operator|!=
name|ap2
operator|->
name|a_count
condition|)
return|return
name|TRUE
return|;
name|table1
operator|=
name|ap1
operator|->
name|a_table
expr_stmt|;
name|size1
operator|=
name|ap1
operator|->
name|a_size
expr_stmt|;
name|size2
operator|=
name|ap2
operator|->
name|a_size
expr_stmt|;
while|while
condition|(
name|size1
operator|--
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|ep1
operator|=
operator|*
name|table1
operator|++
init|;
name|ep1
condition|;
name|ep1
operator|=
name|ep1
operator|->
name|e_next
control|)
block|{
name|hash
operator|=
name|ep1
operator|->
name|e_hash
expr_stmt|;
name|dim
operator|=
name|ep1
operator|->
name|e_dim
expr_stmt|;
for|for
control|(
name|ep2
operator|=
name|ap2
operator|->
name|a_table
index|[
name|hash
operator|%
name|size2
index|]
init|;
condition|;
name|ep2
operator|=
name|ep2
operator|->
name|e_next
control|)
block|{
if|if
condition|(
name|ep2
operator|==
name|NULL
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|ep2
operator|->
name|e_hash
operator|!=
name|hash
condition|)
continue|continue;
if|if
condition|(
name|ep2
operator|->
name|e_dim
operator|!=
name|dim
condition|)
continue|continue;
if|if
condition|(
name|compareindices
argument_list|(
name|ep1
operator|->
name|e_indices
argument_list|,
name|ep2
operator|->
name|e_indices
argument_list|,
name|dim
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|comparevalue
argument_list|(
operator|&
name|ep1
operator|->
name|e_value
argument_list|,
operator|&
name|ep2
operator|->
name|e_value
argument_list|)
condition|)
return|return
name|TRUE
return|;
block|}
block|}
return|return
name|FALSE
return|;
block|}
end_block

begin_comment
comment|/*  * Copy an association value.  */
end_comment

begin_function
name|ASSOC
modifier|*
name|assoccopy
parameter_list|(
name|oldap
parameter_list|)
name|ASSOC
modifier|*
name|oldap
decl_stmt|;
block|{
name|ASSOC
modifier|*
name|ap
decl_stmt|;
name|ASSOCELEM
modifier|*
name|oldep
decl_stmt|;
name|ASSOCELEM
modifier|*
name|ep
decl_stmt|;
name|ASSOCELEM
modifier|*
modifier|*
name|listhead
decl_stmt|;
name|int
name|oldhi
decl_stmt|;
name|int
name|i
decl_stmt|;
name|ap
operator|=
name|assocalloc
argument_list|(
name|oldap
operator|->
name|a_count
operator|/
name|CHAINLENGTH
argument_list|)
expr_stmt|;
name|ap
operator|->
name|a_count
operator|=
name|oldap
operator|->
name|a_count
expr_stmt|;
for|for
control|(
name|oldhi
operator|=
literal|0
init|;
name|oldhi
operator|<
name|oldap
operator|->
name|a_size
condition|;
name|oldhi
operator|++
control|)
block|{
for|for
control|(
name|oldep
operator|=
name|oldap
operator|->
name|a_table
index|[
name|oldhi
index|]
init|;
name|oldep
condition|;
name|oldep
operator|=
name|oldep
operator|->
name|e_next
control|)
block|{
name|ep
operator|=
operator|(
name|ASSOCELEM
operator|*
operator|)
name|malloc
argument_list|(
name|ELEMSIZE
argument_list|(
name|oldep
operator|->
name|e_dim
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|==
name|NULL
condition|)
name|math_error
argument_list|(
literal|"Cannot allocate association element"
argument_list|)
expr_stmt|;
name|ep
operator|->
name|e_dim
operator|=
name|oldep
operator|->
name|e_dim
expr_stmt|;
name|ep
operator|->
name|e_hash
operator|=
name|oldep
operator|->
name|e_hash
expr_stmt|;
name|ep
operator|->
name|e_value
operator|.
name|v_type
operator|=
name|V_NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ep
operator|->
name|e_dim
condition|;
name|i
operator|++
control|)
name|copyvalue
argument_list|(
operator|&
name|oldep
operator|->
name|e_indices
index|[
name|i
index|]
argument_list|,
operator|&
name|ep
operator|->
name|e_indices
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|copyvalue
argument_list|(
operator|&
name|oldep
operator|->
name|e_value
argument_list|,
operator|&
name|ep
operator|->
name|e_value
argument_list|)
expr_stmt|;
name|listhead
operator|=
operator|&
name|ap
operator|->
name|a_table
index|[
name|ep
operator|->
name|e_hash
operator|%
name|ap
operator|->
name|a_size
index|]
expr_stmt|;
name|ep
operator|->
name|e_next
operator|=
operator|*
name|listhead
expr_stmt|;
operator|*
name|listhead
operator|=
name|ep
expr_stmt|;
block|}
block|}
return|return
name|ap
return|;
block|}
end_function

begin_comment
comment|/*  * Resize the hash table for an association to be the specified size.  * This is only actually done if the growth from the previous size is  * enough to make this worthwhile.  */
end_comment

begin_function
specifier|static
name|void
name|resize
parameter_list|(
name|ap
parameter_list|,
name|newsize
parameter_list|)
name|ASSOC
modifier|*
name|ap
decl_stmt|;
name|long
name|newsize
decl_stmt|;
block|{
name|ASSOCELEM
modifier|*
modifier|*
name|oldtable
decl_stmt|;
name|ASSOCELEM
modifier|*
modifier|*
name|newtable
decl_stmt|;
name|ASSOCELEM
modifier|*
modifier|*
name|oldlist
decl_stmt|;
name|ASSOCELEM
modifier|*
modifier|*
name|newlist
decl_stmt|;
name|ASSOCELEM
modifier|*
name|ep
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|newsize
operator|<
name|ap
operator|->
name|a_size
operator|+
name|GROWHASHSIZE
condition|)
return|return;
name|newsize
operator|=
name|nextprime
argument_list|(
name|newsize
argument_list|)
expr_stmt|;
name|newtable
operator|=
operator|(
name|ASSOCELEM
operator|*
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|ASSOCELEM
operator|*
argument_list|)
operator|*
name|newsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|newtable
operator|==
name|NULL
condition|)
name|math_error
argument_list|(
literal|"No memory to grow association"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|newsize
condition|;
name|i
operator|++
control|)
name|newtable
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|oldtable
operator|=
name|ap
operator|->
name|a_table
expr_stmt|;
name|oldlist
operator|=
name|oldtable
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ap
operator|->
name|a_size
condition|;
name|i
operator|++
control|)
block|{
while|while
condition|(
operator|*
name|oldlist
condition|)
block|{
name|ep
operator|=
operator|*
name|oldlist
expr_stmt|;
operator|*
name|oldlist
operator|=
name|ep
operator|->
name|e_next
expr_stmt|;
name|newlist
operator|=
operator|&
name|newtable
index|[
name|ep
operator|->
name|e_hash
operator|%
name|newsize
index|]
expr_stmt|;
name|ep
operator|->
name|e_next
operator|=
operator|*
name|newlist
expr_stmt|;
operator|*
name|newlist
operator|=
name|ep
expr_stmt|;
block|}
name|oldlist
operator|++
expr_stmt|;
block|}
name|ap
operator|->
name|a_table
operator|=
name|newtable
expr_stmt|;
name|ap
operator|->
name|a_size
operator|=
name|newsize
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|oldtable
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Free an association element, along with any contained values.  */
end_comment

begin_function
specifier|static
name|void
name|assoc_elemfree
parameter_list|(
name|ep
parameter_list|)
name|ASSOCELEM
modifier|*
name|ep
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ep
operator|->
name|e_dim
condition|;
name|i
operator|++
control|)
name|freevalue
argument_list|(
operator|&
name|ep
operator|->
name|e_indices
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|freevalue
argument_list|(
operator|&
name|ep
operator|->
name|e_value
argument_list|)
expr_stmt|;
name|ep
operator|->
name|e_dim
operator|=
literal|0
expr_stmt|;
name|ep
operator|->
name|e_next
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ep
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Allocate a new association value with an initial hash table.  * The hash table size is set at specified (but at least a minimum size).  */
end_comment

begin_function
name|ASSOC
modifier|*
name|assocalloc
parameter_list|(
name|initsize
parameter_list|)
name|long
name|initsize
decl_stmt|;
block|{
specifier|register
name|ASSOC
modifier|*
name|ap
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|initsize
operator|<
name|MINHASHSIZE
condition|)
name|initsize
operator|=
name|MINHASHSIZE
expr_stmt|;
name|ap
operator|=
operator|(
name|ASSOC
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|ASSOC
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ap
operator|==
name|NULL
condition|)
name|math_error
argument_list|(
literal|"No memory for association"
argument_list|)
expr_stmt|;
name|ap
operator|->
name|a_count
operator|=
literal|0
expr_stmt|;
name|ap
operator|->
name|a_size
operator|=
name|initsize
expr_stmt|;
name|ap
operator|->
name|a_table
operator|=
operator|(
name|ASSOCELEM
operator|*
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|ASSOCELEM
operator|*
argument_list|)
operator|*
name|initsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|ap
operator|->
name|a_table
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ap
argument_list|)
expr_stmt|;
name|math_error
argument_list|(
literal|"No memory for association"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|initsize
condition|;
name|i
operator|++
control|)
name|ap
operator|->
name|a_table
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
return|return
name|ap
return|;
block|}
end_function

begin_comment
comment|/*  * Free an association value, along with all of its elements.  */
end_comment

begin_function
name|void
name|assocfree
parameter_list|(
name|ap
parameter_list|)
specifier|register
name|ASSOC
modifier|*
name|ap
decl_stmt|;
block|{
name|ASSOCELEM
modifier|*
modifier|*
name|listhead
decl_stmt|;
name|ASSOCELEM
modifier|*
name|ep
decl_stmt|;
name|ASSOCELEM
modifier|*
name|nextep
decl_stmt|;
name|int
name|i
decl_stmt|;
name|listhead
operator|=
name|ap
operator|->
name|a_table
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ap
operator|->
name|a_size
condition|;
name|i
operator|++
control|)
block|{
name|nextep
operator|=
operator|*
name|listhead
expr_stmt|;
operator|*
name|listhead
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|nextep
condition|)
block|{
name|ep
operator|=
name|nextep
expr_stmt|;
name|nextep
operator|=
name|ep
operator|->
name|e_next
expr_stmt|;
name|assoc_elemfree
argument_list|(
name|ep
argument_list|)
expr_stmt|;
block|}
name|listhead
operator|++
expr_stmt|;
block|}
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ap
operator|->
name|a_table
argument_list|)
expr_stmt|;
name|ap
operator|->
name|a_table
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Print out an association along with the specified number of  * its elements.  The elements are printed out in shortened form.  */
end_comment

begin_function
name|void
name|assocprint
parameter_list|(
name|ap
parameter_list|,
name|max_print
parameter_list|)
name|ASSOC
modifier|*
name|ap
decl_stmt|;
name|long
name|max_print
decl_stmt|;
block|{
name|ASSOCELEM
modifier|*
name|ep
decl_stmt|;
name|long
name|index
decl_stmt|;
name|long
name|i
decl_stmt|;
name|int
name|savemode
decl_stmt|;
if|if
condition|(
name|max_print
operator|<=
literal|0
condition|)
block|{
name|math_fmt
argument_list|(
literal|"assoc (%ld element%s)"
argument_list|,
name|ap
operator|->
name|a_count
argument_list|,
operator|(
operator|(
name|ap
operator|->
name|a_count
operator|==
literal|1
operator|)
condition|?
literal|""
else|:
literal|"s"
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|math_fmt
argument_list|(
literal|"\n  assoc (%ld element%s):\n"
argument_list|,
name|ap
operator|->
name|a_count
argument_list|,
operator|(
operator|(
name|ap
operator|->
name|a_count
operator|==
literal|1
operator|)
condition|?
literal|""
else|:
literal|"s"
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
operator|(
operator|(
name|index
operator|<
name|max_print
operator|)
operator|&&
operator|(
name|index
operator|<
name|ap
operator|->
name|a_count
operator|)
operator|)
condition|;
name|index
operator|++
control|)
block|{
name|ep
operator|=
name|elemindex
argument_list|(
name|ap
argument_list|,
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|==
name|NULL
condition|)
continue|continue;
name|math_str
argument_list|(
literal|"  ["
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ep
operator|->
name|e_dim
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
condition|)
name|math_chr
argument_list|(
literal|','
argument_list|)
expr_stmt|;
name|savemode
operator|=
name|math_setmode
argument_list|(
name|MODE_FRAC
argument_list|)
expr_stmt|;
name|printvalue
argument_list|(
operator|&
name|ep
operator|->
name|e_indices
index|[
name|i
index|]
argument_list|,
operator|(
name|PRINT_SHORT
operator||
name|PRINT_UNAMBIG
operator|)
argument_list|)
expr_stmt|;
name|math_setmode
argument_list|(
name|savemode
argument_list|)
expr_stmt|;
block|}
name|math_str
argument_list|(
literal|"] = "
argument_list|)
expr_stmt|;
name|printvalue
argument_list|(
operator|&
name|ep
operator|->
name|e_value
argument_list|,
name|PRINT_SHORT
operator||
name|PRINT_UNAMBIG
argument_list|)
expr_stmt|;
name|math_chr
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|max_print
operator|<
name|ap
operator|->
name|a_count
condition|)
name|math_str
argument_list|(
literal|"  ...\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Return a trivial hash value for an association.  */
end_comment

begin_function
name|HASH
name|assochash
parameter_list|(
name|ap
parameter_list|)
name|ASSOC
modifier|*
name|ap
decl_stmt|;
block|{
return|return
name|ap
operator|->
name|a_count
operator|*
literal|700001
return|;
block|}
end_function

begin_comment
comment|/*  * Compare two lists of index values to see if they are identical.  * Returns TRUE if they are the same.  */
end_comment

begin_function
specifier|static
name|BOOL
name|compareindices
parameter_list|(
name|v1
parameter_list|,
name|v2
parameter_list|,
name|dim
parameter_list|)
name|VALUE
modifier|*
name|v1
decl_stmt|;
name|VALUE
modifier|*
name|v2
decl_stmt|;
name|long
name|dim
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dim
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|v1
index|[
name|i
index|]
operator|.
name|v_type
operator|!=
name|v2
index|[
name|i
index|]
operator|.
name|v_type
condition|)
return|return
name|FALSE
return|;
while|while
condition|(
name|dim
operator|--
operator|>
literal|0
condition|)
if|if
condition|(
name|comparevalue
argument_list|(
name|v1
operator|++
argument_list|,
name|v2
operator|++
argument_list|)
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/*  * Return the next prime number up from the specified value.  * This is used to pick a good hash table size.  */
end_comment

begin_function
specifier|static
name|long
name|nextprime
parameter_list|(
name|n
parameter_list|)
name|long
name|n
decl_stmt|;
block|{
name|long
name|i
decl_stmt|;
if|if
condition|(
operator|(
name|n
operator|&
literal|0x01
operator|)
operator|==
literal|0
condition|)
name|n
operator|++
expr_stmt|;
while|while
condition|(
name|TRUE
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|3
init|;
name|n
operator|%
name|i
condition|;
name|i
operator|+=
literal|2
control|)
block|{
if|if
condition|(
name|i
operator|*
name|i
operator|>
name|n
condition|)
return|return
name|n
return|;
block|}
name|n
operator|+=
literal|2
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* END CODE */
end_comment

end_unit

