begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1994 David I. Bell  * Permission is granted to use, distribute, or modify this source,  * provided that this copyright notice remains intact.  *  * Nested input source file reader.  * For terminal input, this also provides a simple command stack.  */
end_comment

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|"calc.h"
end_include

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"hist.h"
end_include

begin_define
define|#
directive|define
name|TTYSIZE
value|100
end_define

begin_comment
comment|/* reallocation size for terminal buffers */
end_comment

begin_define
define|#
directive|define
name|DEPTH
value|10
end_define

begin_comment
comment|/* maximum depth of input */
end_comment

begin_define
define|#
directive|define
name|IS_READ
value|1
end_define

begin_comment
comment|/* reading normally */
end_comment

begin_define
define|#
directive|define
name|IS_REREAD
value|2
end_define

begin_comment
comment|/* reread current character */
end_comment

begin_define
define|#
directive|define
name|chartoint
parameter_list|(
name|ch
parameter_list|)
value|((ch)& 0xff)
end_define

begin_comment
comment|/* make sure char is not negative */
end_comment

begin_define
define|#
directive|define
name|READSET_ALLOC
value|8
end_define

begin_comment
comment|/* readset to allocate chunk size */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|int
name|i_state
decl_stmt|;
comment|/* state (read, reread) */
name|int
name|i_char
decl_stmt|;
comment|/* currently read char */
name|long
name|i_line
decl_stmt|;
comment|/* line number */
name|char
modifier|*
name|i_str
decl_stmt|;
comment|/* current string for input (if not NULL) */
name|char
modifier|*
name|i_origstr
decl_stmt|;
comment|/* original string so it can be freed */
name|char
modifier|*
name|i_ttystr
decl_stmt|;
comment|/* current character of tty line (or NULL) */
name|FILE
modifier|*
name|i_fp
decl_stmt|;
comment|/* current file for input (if not NULL) */
name|char
modifier|*
name|i_name
decl_stmt|;
comment|/* file name if known */
block|}
name|INPUT
typedef|;
end_typedef

begin_comment
comment|/* files that calc has read or included */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|int
name|active
decl_stmt|;
comment|/* != 0 => active entry, 0 => unused entry */
name|char
modifier|*
name|name
decl_stmt|;
comment|/* name used to read file */
name|char
modifier|*
name|path
decl_stmt|;
comment|/* real path used to open file */
name|struct
name|stat
name|inode
decl_stmt|;
comment|/* inode information for file */
block|}
name|READSET
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|READSET
modifier|*
name|readset
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* array of files read */
end_comment

begin_decl_stmt
specifier|static
name|int
name|maxreadset
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* length of readset */
end_comment

begin_decl_stmt
specifier|static
name|int
name|linesize
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current max size of input line */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|linebuf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current input line buffer */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|prompt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current prompt for terminal */
end_comment

begin_decl_stmt
specifier|static
name|BOOL
name|noprompt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* TRUE if should not print prompt */
end_comment

begin_decl_stmt
specifier|static
name|int
name|depth
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current input depth */
end_comment

begin_decl_stmt
specifier|static
name|INPUT
modifier|*
name|cip
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current input source */
end_comment

begin_decl_stmt
specifier|static
name|INPUT
name|inputs
index|[
name|DEPTH
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* input sources */
end_comment

begin_decl_stmt
specifier|static
name|int
name|openfile
name|MATH_PROTO
argument_list|(
operator|(
name|char
operator|*
name|name
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ttychar
name|MATH_PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|closeinput
name|MATH_PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|isinoderead
name|MATH_PROTO
argument_list|(
operator|(
expr|struct
name|stat
operator|*
name|sbuf
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|findfreeread
name|MATH_PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|addreadset
name|MATH_PROTO
argument_list|(
operator|(
name|char
operator|*
name|name
operator|,
name|char
operator|*
name|path
operator|,
expr|struct
name|stat
operator|*
name|sbuf
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Open an input file by possibly searching through a path list  * and also possibly applying the specified extension.  For example:  * opensearchfile("barf", ".:/tmp", ".c") searches in order for the  * files "./barf", "./barf.c", "/tmp/barf", and "/tmp/barf.c".  *  * Returns -1 if we could not open a file or error.    * Returns 1 if file was opened and added to/updated in the readset.     * Returns 0 if file was already in the readset and reopen was 0.  */
end_comment

begin_function
name|int
name|opensearchfile
parameter_list|(
name|name
parameter_list|,
name|pathlist
parameter_list|,
name|extension
parameter_list|,
name|rd_once
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
comment|/* file name to be read */
name|char
modifier|*
name|pathlist
decl_stmt|;
comment|/* list of colon separated paths (or NULL) */
name|char
modifier|*
name|extension
decl_stmt|;
comment|/* extra extension to try (or NULL) */
name|int
name|rd_once
decl_stmt|;
comment|/* TRUE => do not reread a file */
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|char
name|path
index|[
name|PATHSIZE
operator|+
literal|1
index|]
decl_stmt|;
comment|/* name being searched for */
name|struct
name|stat
name|statbuf
decl_stmt|;
comment|/* stat of the path */
comment|/* 	 * Don't try the extension if the filename already contains it. 	 */
if|if
condition|(
name|extension
condition|)
block|{
name|i
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
operator|-
name|strlen
argument_list|(
name|extension
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
operator|&
name|name
index|[
name|i
index|]
argument_list|,
name|extension
argument_list|)
operator|==
literal|0
operator|)
condition|)
name|extension
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 	 * If the name is absolute, or if there is no path list, then 	 * make one which just searches for the name straight.  Then 	 * search through the path list for the file, without and with 	 * the specified extension. 	 */
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
name|PATHCHAR
operator|||
name|name
index|[
literal|0
index|]
operator|==
name|HOMECHAR
operator|||
operator|(
name|name
index|[
literal|0
index|]
operator|==
name|DOTCHAR
operator|&&
name|name
index|[
literal|1
index|]
operator|==
name|PATHCHAR
operator|)
operator|||
name|pathlist
operator|==
name|NULL
condition|)
block|{
name|pathlist
operator|=
literal|""
expr_stmt|;
block|}
name|pathlist
operator|--
expr_stmt|;
do|do
block|{
name|pathlist
operator|++
expr_stmt|;
name|cp
operator|=
name|path
expr_stmt|;
while|while
condition|(
operator|*
name|pathlist
operator|&&
operator|(
operator|*
name|pathlist
operator|!=
name|LISTCHAR
operator|)
condition|)
operator|*
name|cp
operator|++
operator|=
operator|*
name|pathlist
operator|++
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|path
condition|)
operator|*
name|cp
operator|++
operator|=
name|PATHCHAR
expr_stmt|;
name|strcpy
argument_list|(
name|cp
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|i
operator|=
name|openfile
argument_list|(
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|<
literal|0
operator|)
operator|&&
name|extension
condition|)
block|{
name|strcat
argument_list|(
name|path
argument_list|,
name|extension
argument_list|)
expr_stmt|;
name|i
operator|=
name|openfile
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|(
name|i
operator|<
literal|0
operator|)
operator|&&
operator|*
name|pathlist
condition|)
do|;
comment|/* examine what our search produced */
if|if
condition|(
name|i
operator|<
literal|0
operator|||
name|cip
operator|->
name|i_fp
operator|==
name|NULL
condition|)
block|{
comment|/* cannot find a file to open */
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|fstat
argument_list|(
name|fileno
argument_list|(
name|cip
operator|->
name|i_fp
argument_list|)
argument_list|,
operator|&
name|statbuf
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* unable to fstat the open file */
return|return
operator|-
literal|1
return|;
block|}
comment|/* note if we will reopen a file and if that is allowed */
if|if
condition|(
name|rd_once
operator|==
name|TRUE
operator|&&
name|isinoderead
argument_list|(
operator|&
name|statbuf
argument_list|)
operator|>=
literal|0
condition|)
block|{
comment|/* file is in readset and reopen is false */
name|closeinput
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* add this name to the readset */
if|if
condition|(
name|addreadset
argument_list|(
name|name
argument_list|,
name|path
argument_list|,
operator|&
name|statbuf
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* cannot add to readset */
name|closeinput
argument_list|()
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* file was added to/updated in readset */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Given a filename with a leading ~, expand it into a home directory for   * that user.  This function will malloc the space for the expanded path.  *  * If the path is just ~, or begins with ~/, expand it to the home  * directory of the current user.  If the environment variable $HOME  * is known, it will be used, otherwise the password file will be  * consulted.  *  * If the path is just ~username, or ~username/, expand it to the home  * directory of that user by looking it up in the password file.  *  * If the password file must be consulted and the username is not found  * a NULL pointer is returned.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|homeexpand
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
comment|/* a filename with a leading ~ */
block|{
name|struct
name|passwd
modifier|*
name|ent
decl_stmt|;
comment|/* password entry */
name|char
modifier|*
name|home2
decl_stmt|;
comment|/* fullpath of the home directory */
name|char
modifier|*
name|fullpath
decl_stmt|;
comment|/* the malloced expanded path */
name|char
modifier|*
name|after
decl_stmt|;
comment|/* after the ~user or ~ */
name|char
name|username
index|[
name|PATHSIZE
operator|+
literal|1
index|]
decl_stmt|;
comment|/* extratced username */
comment|/* firewall */
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|!=
name|HOMECHAR
condition|)
return|return
name|NULL
return|;
comment|/* 	 * obtain the home directory component 	 */
switch|switch
condition|(
name|name
index|[
literal|1
index|]
condition|)
block|{
case|case
name|PATHCHAR
case|:
comment|/* ~/... */
case|case
literal|'\0'
case|:
comment|/* ~ */
name|home2
operator|=
name|home
expr_stmt|;
name|after
operator|=
name|name
operator|+
literal|1
expr_stmt|;
break|break;
default|default:
comment|/* ~username or ~username/... */
comment|/* extract the username after the ~ */
name|after
operator|=
operator|(
name|char
operator|*
operator|)
name|strchr
argument_list|(
name|name
operator|+
literal|2
argument_list|,
name|PATHCHAR
argument_list|)
expr_stmt|;
if|if
condition|(
name|after
operator|==
name|NULL
condition|)
block|{
comment|/* path is just ~username */
name|ent
operator|=
operator|(
expr|struct
name|passwd
operator|*
operator|)
name|getpwnam
argument_list|(
name|name
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ent
operator|==
name|NULL
condition|)
block|{
comment|/* unknown user */
return|return
name|NULL
return|;
block|}
comment|/* just malloc the home directory and return it */
name|fullpath
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|strlen
argument_list|(
name|ent
operator|->
name|pw_dir
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|fullpath
argument_list|,
name|ent
operator|->
name|pw_dir
argument_list|)
expr_stmt|;
return|return
name|fullpath
return|;
block|}
if|if
condition|(
name|after
operator|-
name|name
operator|>
name|PATHSIZE
operator|+
literal|1
condition|)
block|{
comment|/* username is too big */
return|return
name|NULL
return|;
block|}
name|strncpy
argument_list|(
name|username
argument_list|,
name|name
operator|+
literal|1
argument_list|,
name|after
operator|-
name|name
operator|-
literal|1
argument_list|)
expr_stmt|;
name|username
index|[
name|after
operator|-
name|name
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* get that user's home directory */
name|ent
operator|=
operator|(
expr|struct
name|passwd
operator|*
operator|)
name|getpwnam
argument_list|(
name|username
argument_list|)
expr_stmt|;
if|if
condition|(
name|ent
operator|==
name|NULL
condition|)
block|{
comment|/* unknown user */
return|return
name|NULL
return|;
block|}
name|home2
operator|=
name|ent
operator|->
name|pw_dir
expr_stmt|;
break|break;
block|}
comment|/* 	 * build the fullpath given the home directory 	 */
name|fullpath
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|strlen
argument_list|(
name|home2
argument_list|)
operator|+
name|strlen
argument_list|(
name|after
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|fullpath
argument_list|,
literal|"%s%s"
argument_list|,
name|home2
argument_list|,
name|after
argument_list|)
expr_stmt|;
return|return
name|fullpath
return|;
block|}
end_function

begin_comment
comment|/*  * f_open - ~-expand a filename and fopen() it  */
end_comment

begin_function
name|FILE
modifier|*
name|f_open
parameter_list|(
name|name
parameter_list|,
name|mode
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
comment|/* the filename to open */
name|char
modifier|*
name|mode
decl_stmt|;
comment|/* the fopen mode to use */
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
comment|/* open file descriptor */
name|char
modifier|*
name|fullname
decl_stmt|;
comment|/* file name with HOMECHAR expansion */
comment|/* 	 * expand ~ if needed 	 */
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
name|HOMECHAR
condition|)
block|{
name|fullname
operator|=
name|homeexpand
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|fullname
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|fp
operator|=
name|fopen
argument_list|(
name|fullname
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|fullname
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fp
operator|=
name|fopen
argument_list|(
name|name
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
return|return
name|fp
return|;
block|}
end_function

begin_comment
comment|/*  * Setup for reading from a input file.  * Returns -1 if file could not be opened.  */
end_comment

begin_function
specifier|static
name|int
name|openfile
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
comment|/* file name to be read */
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
comment|/* open file descriptor */
if|if
condition|(
name|depth
operator|>=
name|DEPTH
condition|)
return|return
operator|-
literal|1
return|;
name|fp
operator|=
name|f_open
argument_list|(
name|name
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|cip
operator|++
expr_stmt|;
name|cip
operator|->
name|i_state
operator|=
name|IS_READ
expr_stmt|;
name|cip
operator|->
name|i_char
operator|=
literal|'\0'
expr_stmt|;
name|cip
operator|->
name|i_str
operator|=
name|NULL
expr_stmt|;
name|cip
operator|->
name|i_origstr
operator|=
name|NULL
expr_stmt|;
name|cip
operator|->
name|i_ttystr
operator|=
name|NULL
expr_stmt|;
name|cip
operator|->
name|i_fp
operator|=
name|fp
expr_stmt|;
name|cip
operator|->
name|i_line
operator|=
literal|1
expr_stmt|;
name|cip
operator|->
name|i_name
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|cip
operator|->
name|i_name
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|depth
operator|++
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Open a string for scanning. String is ended by a null character.  * String is copied into local memory so it can be trashed afterwards.  * Returns -1 if cannot open string.  */
end_comment

begin_function
name|int
name|openstring
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
comment|/* string to be opened */
block|{
name|char
modifier|*
name|cp
decl_stmt|;
comment|/* copied string */
if|if
condition|(
operator|(
name|depth
operator|>=
name|DEPTH
operator|)
operator|||
operator|(
name|str
operator|==
name|NULL
operator|)
condition|)
return|return
operator|-
literal|1
return|;
name|cp
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|strlen
argument_list|(
name|str
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|strcpy
argument_list|(
name|cp
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|cip
operator|++
expr_stmt|;
name|cip
operator|->
name|i_state
operator|=
name|IS_READ
expr_stmt|;
name|cip
operator|->
name|i_char
operator|=
literal|'\0'
expr_stmt|;
name|cip
operator|->
name|i_str
operator|=
name|cp
expr_stmt|;
name|cip
operator|->
name|i_origstr
operator|=
name|cp
expr_stmt|;
name|cip
operator|->
name|i_fp
operator|=
name|NULL
expr_stmt|;
name|cip
operator|->
name|i_name
operator|=
name|NULL
expr_stmt|;
name|cip
operator|->
name|i_ttystr
operator|=
name|NULL
expr_stmt|;
name|cip
operator|->
name|i_line
operator|=
literal|1
expr_stmt|;
name|depth
operator|++
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Set to read input from the terminal.  * Returns -1 if there is no more depth for input.  */
end_comment

begin_function
name|int
name|openterminal
parameter_list|()
block|{
if|if
condition|(
name|depth
operator|>=
name|DEPTH
condition|)
return|return
operator|-
literal|1
return|;
name|cip
operator|++
expr_stmt|;
name|cip
operator|->
name|i_state
operator|=
name|IS_READ
expr_stmt|;
name|cip
operator|->
name|i_char
operator|=
literal|'\0'
expr_stmt|;
name|cip
operator|->
name|i_str
operator|=
name|NULL
expr_stmt|;
name|cip
operator|->
name|i_origstr
operator|=
name|NULL
expr_stmt|;
name|cip
operator|->
name|i_ttystr
operator|=
name|NULL
expr_stmt|;
name|cip
operator|->
name|i_fp
operator|=
name|NULL
expr_stmt|;
name|cip
operator|->
name|i_name
operator|=
name|NULL
expr_stmt|;
name|cip
operator|->
name|i_line
operator|=
literal|1
expr_stmt|;
name|depth
operator|++
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Close the current input source.  */
end_comment

begin_function
specifier|static
name|void
name|closeinput
parameter_list|()
block|{
if|if
condition|(
name|depth
operator|<=
literal|0
condition|)
return|return;
if|if
condition|(
name|cip
operator|->
name|i_origstr
condition|)
name|free
argument_list|(
name|cip
operator|->
name|i_origstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|cip
operator|->
name|i_fp
condition|)
name|fclose
argument_list|(
name|cip
operator|->
name|i_fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cip
operator|->
name|i_name
condition|)
name|free
argument_list|(
name|cip
operator|->
name|i_name
argument_list|)
expr_stmt|;
name|cip
operator|--
expr_stmt|;
name|depth
operator|--
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Reset the input sources back to the initial state.  */
end_comment

begin_function
name|void
name|resetinput
parameter_list|()
block|{
while|while
condition|(
name|depth
operator|>
literal|0
condition|)
name|closeinput
argument_list|()
expr_stmt|;
name|cip
operator|=
name|inputs
expr_stmt|;
name|noprompt
operator|=
name|FALSE
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set the prompt for terminal input.  */
end_comment

begin_function
name|void
name|setprompt
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|prompt
operator|=
name|str
expr_stmt|;
name|noprompt
operator|=
name|FALSE
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Read the next character from the current input source.  * End of file closes current input source, and returns EOF character.  */
end_comment

begin_function
name|int
name|nextchar
parameter_list|()
block|{
name|int
name|ch
decl_stmt|;
comment|/* current input character */
if|if
condition|(
name|depth
operator|==
literal|0
condition|)
comment|/* input finished */
return|return
name|EOF
return|;
if|if
condition|(
name|cip
operator|->
name|i_state
operator|==
name|IS_REREAD
condition|)
block|{
comment|/* rereading current char */
name|ch
operator|=
name|cip
operator|->
name|i_char
expr_stmt|;
name|cip
operator|->
name|i_state
operator|=
name|IS_READ
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'\n'
condition|)
name|cip
operator|->
name|i_line
operator|++
expr_stmt|;
return|return
name|ch
return|;
block|}
if|if
condition|(
name|cip
operator|->
name|i_str
condition|)
block|{
comment|/* from string */
name|ch
operator|=
name|chartoint
argument_list|(
operator|*
name|cip
operator|->
name|i_str
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'\0'
condition|)
name|ch
operator|=
name|EOF
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cip
operator|->
name|i_fp
condition|)
block|{
comment|/* from file */
name|ch
operator|=
name|fgetc
argument_list|(
name|cip
operator|->
name|i_fp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* from terminal */
name|ch
operator|=
name|ttychar
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|ch
operator|==
name|EOF
condition|)
block|{
comment|/* fix up end of file */
name|closeinput
argument_list|()
expr_stmt|;
name|ch
operator|=
name|EOF
expr_stmt|;
block|}
if|if
condition|(
name|depth
operator|>
literal|0
condition|)
name|cip
operator|->
name|i_char
operator|=
name|ch
expr_stmt|;
comment|/* save for rereads */
if|if
condition|(
name|ch
operator|==
literal|'\n'
condition|)
name|cip
operator|->
name|i_line
operator|++
expr_stmt|;
return|return
name|ch
return|;
block|}
end_function

begin_comment
comment|/*  * Read in the next line of input from the current input source.  * The line is terminated with a null character, and does not contain  * the final newline character.  The returned string is only valid  * until the next such call, and so must be copied if necessary.  * Returns NULL on end of file.  */
end_comment

begin_function
name|char
modifier|*
name|nextline
parameter_list|()
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|ch
decl_stmt|;
name|int
name|len
decl_stmt|;
name|cp
operator|=
name|linebuf
expr_stmt|;
if|if
condition|(
name|linesize
operator|==
literal|0
condition|)
block|{
name|cp
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|TTYSIZE
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
name|math_error
argument_list|(
literal|"Cannot allocate line buffer"
argument_list|)
expr_stmt|;
name|linebuf
operator|=
name|cp
expr_stmt|;
name|linesize
operator|=
name|TTYSIZE
expr_stmt|;
block|}
name|len
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|noprompt
operator|=
name|TRUE
expr_stmt|;
name|ch
operator|=
name|nextchar
argument_list|()
expr_stmt|;
name|noprompt
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|ch
operator|==
name|EOF
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|ch
operator|==
literal|'\0'
condition|)
continue|continue;
if|if
condition|(
name|ch
operator|==
literal|'\n'
condition|)
break|break;
if|if
condition|(
name|len
operator|>=
name|linesize
condition|)
block|{
name|cp
operator|=
operator|(
name|char
operator|*
operator|)
name|realloc
argument_list|(
name|cp
argument_list|,
name|linesize
operator|+
name|TTYSIZE
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
name|math_error
argument_list|(
literal|"Cannot realloc line buffer"
argument_list|)
expr_stmt|;
name|linebuf
operator|=
name|cp
expr_stmt|;
name|linesize
operator|+=
name|TTYSIZE
expr_stmt|;
block|}
name|cp
index|[
name|len
operator|++
index|]
operator|=
operator|(
name|char
operator|)
name|ch
expr_stmt|;
block|}
name|cp
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|linebuf
return|;
block|}
end_function

begin_comment
comment|/*  * Read the next character from the terminal.  * The routines in the history module are called so that the user  * can use a command history and emacs-like editing of the line.  */
end_comment

begin_function
specifier|static
name|int
name|ttychar
parameter_list|()
block|{
name|int
name|ch
decl_stmt|;
comment|/* current char */
name|int
name|len
decl_stmt|;
comment|/* length of current command */
specifier|static
name|char
name|charbuf
index|[
literal|1000
index|]
decl_stmt|;
comment|/* 	 * If we have more to read from the saved command line, then do that. 	 * When we see a newline character, then clear the pointer so we will 	 * read a new line on the next call. 	 */
if|if
condition|(
name|cip
operator|->
name|i_ttystr
condition|)
block|{
name|ch
operator|=
name|chartoint
argument_list|(
operator|*
name|cip
operator|->
name|i_ttystr
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'\n'
condition|)
name|cip
operator|->
name|i_ttystr
operator|=
name|NULL
expr_stmt|;
return|return
name|ch
return|;
block|}
comment|/* 	 * We need another complete line. 	 */
name|abortlevel
operator|=
literal|0
expr_stmt|;
name|inputwait
operator|=
name|TRUE
expr_stmt|;
name|len
operator|=
name|hist_getline
argument_list|(
name|noprompt
condition|?
literal|""
else|:
name|prompt
argument_list|,
name|charbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|charbuf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
name|inputwait
operator|=
name|FALSE
expr_stmt|;
return|return
name|EOF
return|;
block|}
name|inputwait
operator|=
name|FALSE
expr_stmt|;
comment|/* 	 * Handle shell escape if present 	 */
if|if
condition|(
name|charbuf
index|[
literal|0
index|]
operator|==
literal|'!'
condition|)
block|{
comment|/* do a shell command */
name|char
modifier|*
name|cmd
decl_stmt|;
name|cmd
operator|=
name|charbuf
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|cmd
operator|==
literal|'\0'
operator|||
operator|*
name|cmd
operator|==
literal|'\n'
condition|)
name|cmd
operator|=
name|shell
expr_stmt|;
name|system
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
return|return
literal|'\n'
return|;
block|}
name|hist_saveline
argument_list|(
name|charbuf
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* 	 * Return the first character of the line, and set up to 	 * return the rest of it with later calls. 	 */
name|ch
operator|=
name|chartoint
argument_list|(
name|charbuf
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|!=
literal|'\n'
condition|)
name|cip
operator|->
name|i_ttystr
operator|=
name|charbuf
operator|+
literal|1
expr_stmt|;
return|return
name|ch
return|;
block|}
end_function

begin_comment
comment|/*  * Return whether or not the input source is the terminal.  */
end_comment

begin_function
name|BOOL
name|inputisterminal
parameter_list|()
block|{
return|return
operator|(
operator|(
name|depth
operator|<=
literal|0
operator|)
operator|||
operator|(
operator|(
name|cip
operator|->
name|i_str
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|cip
operator|->
name|i_fp
operator|==
name|NULL
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return the name of the current input file.  * Returns NULL for terminal or strings.  */
end_comment

begin_function
name|char
modifier|*
name|inputname
parameter_list|()
block|{
if|if
condition|(
name|depth
operator|<=
literal|0
condition|)
return|return
name|NULL
return|;
return|return
name|cip
operator|->
name|i_name
return|;
block|}
end_function

begin_comment
comment|/*  * Return the current line number.  */
end_comment

begin_function
name|long
name|linenumber
parameter_list|()
block|{
if|if
condition|(
name|depth
operator|>
literal|0
condition|)
return|return
name|cip
operator|->
name|i_line
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Restore the next character to be read again on the next nextchar call.  */
end_comment

begin_function
name|void
name|reread
parameter_list|()
block|{
if|if
condition|(
operator|(
name|depth
operator|<=
literal|0
operator|)
operator|||
operator|(
name|cip
operator|->
name|i_state
operator|==
name|IS_REREAD
operator|)
condition|)
return|return;
name|cip
operator|->
name|i_state
operator|=
name|IS_REREAD
expr_stmt|;
if|if
condition|(
name|cip
operator|->
name|i_char
operator|==
literal|'\n'
condition|)
name|cip
operator|->
name|i_line
operator|--
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Process all startup files found in the $CALCRC path.  */
end_comment

begin_function
name|void
name|runrcfiles
parameter_list|()
block|{
name|char
name|path
index|[
name|PATHSIZE
operator|+
literal|1
index|]
decl_stmt|;
comment|/* name being searched for */
name|char
modifier|*
name|cp
decl_stmt|;
name|char
modifier|*
name|newcp
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* execute each file in the list */
for|for
control|(
name|cp
operator|=
name|calcrc
operator|,
name|newcp
operator|=
operator|(
name|char
operator|*
operator|)
name|strchr
argument_list|(
name|calcrc
argument_list|,
name|LISTCHAR
argument_list|)
init|;
name|cp
operator|!=
name|NULL
operator|&&
operator|*
name|cp
condition|;
name|cp
operator|=
name|newcp
operator|,
name|newcp
operator|=
operator|(
name|newcp
operator|)
condition|?
operator|(
name|char
operator|*
operator|)
name|strchr
argument_list|(
name|newcp
operator|+
literal|1
argument_list|,
name|LISTCHAR
argument_list|)
else|:
name|NULL
control|)
block|{
comment|/* load file name into the path */
if|if
condition|(
name|newcp
operator|==
name|NULL
condition|)
block|{
name|strcpy
argument_list|(
name|path
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|strncpy
argument_list|(
name|path
argument_list|,
name|cp
argument_list|,
name|newcp
operator|-
name|cp
argument_list|)
expr_stmt|;
name|path
index|[
name|newcp
operator|-
name|cp
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
comment|/* find the start of the path */
name|p
operator|=
operator|(
name|path
index|[
literal|0
index|]
operator|==
literal|':'
operator|)
condition|?
name|path
operator|+
literal|1
else|:
name|path
expr_stmt|;
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
continue|continue;
block|}
comment|/* process the current file in the list */
name|i
operator|=
name|openfile
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
continue|continue;
name|getcommands
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * isinoderead - determine if we have read a given dev/inode  *  * This function returns the index of the readset element that matches  * a given device/inode, -1 otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|isinoderead
parameter_list|(
name|sbuf
parameter_list|)
name|struct
name|stat
modifier|*
name|sbuf
decl_stmt|;
comment|/* stat of the inode in question */
block|{
name|int
name|i
decl_stmt|;
comment|/* deal with the empty case */
if|if
condition|(
name|readset
operator|==
name|NULL
operator|||
name|maxreadset
operator|<=
literal|0
condition|)
block|{
comment|/* readset is empty */
return|return
operator|-
literal|1
return|;
block|}
comment|/* scan the entire readset */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|maxreadset
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|readset
index|[
name|i
index|]
operator|.
name|active
operator|&&
name|sbuf
operator|->
name|st_dev
operator|==
name|readset
index|[
name|i
index|]
operator|.
name|inode
operator|.
name|st_dev
operator|&&
name|sbuf
operator|->
name|st_ino
operator|==
name|readset
index|[
name|i
index|]
operator|.
name|inode
operator|.
name|st_ino
condition|)
block|{
comment|/* found a match */
return|return
name|i
return|;
block|}
block|}
comment|/* no match found */
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * findfreeread - find the next free readset element  *  * This function will return the index of the next free readset element.  * If needed, this function will allocate new readset elements.  *  * This function returns the index of the next free element, or -1.  */
end_comment

begin_function
specifier|static
name|int
name|findfreeread
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
comment|/* deal with an empty readset case */
if|if
condition|(
name|readset
operator|==
name|NULL
operator|||
name|maxreadset
operator|<=
literal|0
condition|)
block|{
comment|/* malloc a new readset */
name|readset
operator|=
operator|(
name|READSET
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|READSET_ALLOC
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|READSET
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|readset
operator|==
name|NULL
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
name|maxreadset
operator|=
name|READSET_ALLOC
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|READSET_ALLOC
condition|;
operator|++
name|i
control|)
block|{
name|readset
index|[
name|i
index|]
operator|.
name|active
operator|=
literal|0
expr_stmt|;
block|}
comment|/* return first entry */
return|return
literal|0
return|;
block|}
comment|/* try to find a free readset entry */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|maxreadset
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|readset
index|[
name|i
index|]
operator|.
name|active
operator|==
literal|0
condition|)
block|{
comment|/* found a free readset entry */
return|return
name|i
return|;
block|}
block|}
comment|/* all readset entries are in use, allocate more */
name|readset
operator|=
operator|(
name|READSET
operator|*
operator|)
name|realloc
argument_list|(
name|readset
argument_list|,
operator|(
name|maxreadset
operator|+
name|READSET_ALLOC
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|READSET
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|readset
operator|==
name|NULL
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|READSET_ALLOC
condition|;
operator|++
name|i
control|)
block|{
name|readset
index|[
name|i
operator|+
name|maxreadset
index|]
operator|.
name|active
operator|=
literal|0
expr_stmt|;
block|}
name|maxreadset
operator|+=
name|READSET_ALLOC
expr_stmt|;
comment|/* return the furst newly allocated free entry */
return|return
name|maxreadset
operator|-
name|READSET_ALLOC
return|;
block|}
end_function

begin_comment
comment|/*  * addreadset - add a entry to the readset array if it is not already there  *  * This function attempts to add a file into the readset.  If the readset  * has an entry with a matching dev/inode, then that entry is updated with  * the new name and path.  If no such readset entry is found, a new entry  * is added.  *  * This function returns the index of the readset entry, or -1 if error.  */
end_comment

begin_function
specifier|static
name|int
name|addreadset
parameter_list|(
name|name
parameter_list|,
name|path
parameter_list|,
name|sbuf
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
comment|/* name given to read or include */
name|char
modifier|*
name|path
decl_stmt|;
comment|/* full pathname of file */
name|struct
name|stat
modifier|*
name|sbuf
decl_stmt|;
comment|/* stat of the path */
block|{
name|int
name|ret
decl_stmt|;
comment|/* index to return */
comment|/* find the inode */
name|ret
operator|=
name|isinoderead
argument_list|(
name|sbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
comment|/* not in readset, find a free node */
name|ret
operator|=
name|findfreeread
argument_list|()
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
comment|/* cannot find/form a free readset entry */
return|return
operator|-
literal|1
return|;
block|}
block|}
else|else
block|{
comment|/* found an readset entry, free old readset data */
if|if
condition|(
name|readset
index|[
name|ret
index|]
operator|.
name|name
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|readset
index|[
name|ret
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|readset
index|[
name|ret
index|]
operator|.
name|path
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|readset
index|[
name|ret
index|]
operator|.
name|path
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* load our information into the readset entry */
name|readset
index|[
name|ret
index|]
operator|.
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|readset
index|[
name|ret
index|]
operator|.
name|name
operator|==
name|NULL
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
name|strcpy
argument_list|(
name|readset
index|[
name|ret
index|]
operator|.
name|name
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|readset
index|[
name|ret
index|]
operator|.
name|path
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|strlen
argument_list|(
name|path
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|readset
index|[
name|ret
index|]
operator|.
name|path
operator|==
name|NULL
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
name|strcpy
argument_list|(
name|readset
index|[
name|ret
index|]
operator|.
name|path
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|readset
index|[
name|ret
index|]
operator|.
name|inode
operator|=
operator|*
name|sbuf
expr_stmt|;
name|readset
index|[
name|ret
index|]
operator|.
name|active
operator|=
literal|1
expr_stmt|;
comment|/* return index of the newly added entry */
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* END CODE */
end_comment

end_unit

