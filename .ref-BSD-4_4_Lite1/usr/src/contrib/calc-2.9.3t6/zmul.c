begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1994 David I. Bell  * Permission is granted to use, distribute, or modify this source,  * provided that this copyright notice remains intact.  *  * Faster than usual multiplying and squaring routines.  * The algorithm used is the reasonably simple one from Knuth, volume 2,  * section 4.3.3.  These recursive routines are of speed O(N^1.585)  * instead of O(N^2).  The usual multiplication and (almost usual) squaring  * algorithms are used for small numbers.  On a 386 with its compiler, the  * two algorithms are equal in speed at about 100 decimal digits.  */
end_comment

begin_include
include|#
directive|include
file|"zmath.h"
end_include

begin_decl_stmt
name|LEN
name|_mul2_
init|=
name|MUL_ALG2
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* size of number to use multiply algorithm 2 */
end_comment

begin_decl_stmt
name|LEN
name|_sq2_
init|=
name|SQ_ALG2
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* size of number to use square algorithm 2 */
end_comment

begin_decl_stmt
specifier|static
name|HALF
modifier|*
name|tempbuf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* temporary buffer for multiply and square */
end_comment

begin_decl_stmt
specifier|static
name|LEN
name|domul
name|MATH_PROTO
argument_list|(
operator|(
name|HALF
operator|*
name|v1
operator|,
name|LEN
name|size1
operator|,
name|HALF
operator|*
name|v2
operator|,
name|LEN
name|size2
operator|,
name|HALF
operator|*
name|ans
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|LEN
name|dosquare
name|MATH_PROTO
argument_list|(
operator|(
name|HALF
operator|*
name|vp
operator|,
name|LEN
name|size
operator|,
name|HALF
operator|*
name|ans
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Multiply two numbers using the following formula recursively:  *	(A*S+B)*(C*S+D) = (S^2+S)*A*C + S*(A-B)*(D-C) + (S+1)*B*D  * where S is a power of 2^16, and so multiplies by it are shifts, and  * A,B,C,D are the left and right halfs of the numbers to be multiplied.  */
end_comment

begin_function
name|void
name|zmul
parameter_list|(
name|z1
parameter_list|,
name|z2
parameter_list|,
name|res
parameter_list|)
name|ZVALUE
name|z1
decl_stmt|,
name|z2
decl_stmt|;
comment|/* numbers to multiply */
name|ZVALUE
modifier|*
name|res
decl_stmt|;
comment|/* result of multiplication */
block|{
name|LEN
name|len
decl_stmt|;
comment|/* size of array */
if|if
condition|(
name|ziszero
argument_list|(
name|z1
argument_list|)
operator|||
name|ziszero
argument_list|(
name|z2
argument_list|)
condition|)
block|{
operator|*
name|res
operator|=
name|_zero_
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|zisunit
argument_list|(
name|z1
argument_list|)
condition|)
block|{
name|zcopy
argument_list|(
name|z2
argument_list|,
name|res
argument_list|)
expr_stmt|;
name|res
operator|->
name|sign
operator|=
operator|(
name|z1
operator|.
name|sign
operator|!=
name|z2
operator|.
name|sign
operator|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|zisunit
argument_list|(
name|z2
argument_list|)
condition|)
block|{
name|zcopy
argument_list|(
name|z1
argument_list|,
name|res
argument_list|)
expr_stmt|;
name|res
operator|->
name|sign
operator|=
operator|(
name|z1
operator|.
name|sign
operator|!=
name|z2
operator|.
name|sign
operator|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Allocate a temporary buffer for the recursion levels to use. 	 * An array needs to be allocated large enough for all of the 	 * temporary results to fit in.  This size is about twice the size 	 * of the largest original number, since each recursion level uses 	 * the size of its given number, and whose size is 1/2 the size of 	 * the previous level.  The sum of the infinite series is 2. 	 * Add some extra words because of rounding when dividing by 2 	 * and also because of the extra word that each multiply needs. 	 */
name|len
operator|=
name|z1
operator|.
name|len
expr_stmt|;
if|if
condition|(
name|len
operator|<
name|z2
operator|.
name|len
condition|)
name|len
operator|=
name|z2
operator|.
name|len
expr_stmt|;
name|len
operator|=
literal|2
operator|*
name|len
operator|+
literal|64
expr_stmt|;
name|tempbuf
operator|=
name|zalloctemp
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|res
operator|->
name|sign
operator|=
operator|(
name|z1
operator|.
name|sign
operator|!=
name|z2
operator|.
name|sign
operator|)
expr_stmt|;
name|res
operator|->
name|v
operator|=
name|alloc
argument_list|(
name|z1
operator|.
name|len
operator|+
name|z2
operator|.
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|res
operator|->
name|len
operator|=
name|domul
argument_list|(
name|z1
operator|.
name|v
argument_list|,
name|z1
operator|.
name|len
argument_list|,
name|z2
operator|.
name|v
argument_list|,
name|z2
operator|.
name|len
argument_list|,
name|res
operator|->
name|v
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Recursive routine to multiply two numbers by splitting them up into  * two numbers of half the size, and using the results of multiplying the  * subpieces.  The result is placed in the indicated array, which must be  * large enough for the result plus one extra word (size1 + size2 + 1).  * Returns the actual size of the result with leading zeroes stripped.  * This also uses a temporary array which must be twice as large as  * one more than the size of the number at the top level recursive call.  */
end_comment

begin_function
specifier|static
name|LEN
name|domul
parameter_list|(
name|v1
parameter_list|,
name|size1
parameter_list|,
name|v2
parameter_list|,
name|size2
parameter_list|,
name|ans
parameter_list|)
name|HALF
modifier|*
name|v1
decl_stmt|;
comment|/* first number */
name|LEN
name|size1
decl_stmt|;
comment|/* size of first number */
name|HALF
modifier|*
name|v2
decl_stmt|;
comment|/* second number */
name|LEN
name|size2
decl_stmt|;
comment|/* size of second number */
name|HALF
modifier|*
name|ans
decl_stmt|;
comment|/* location for result */
block|{
name|LEN
name|shift
decl_stmt|;
comment|/* amount numbers are shifted by */
name|LEN
name|sizeA
decl_stmt|;
comment|/* size of left half of first number */
name|LEN
name|sizeB
decl_stmt|;
comment|/* size of right half of first number */
name|LEN
name|sizeC
decl_stmt|;
comment|/* size of left half of second number */
name|LEN
name|sizeD
decl_stmt|;
comment|/* size of right half of second number */
name|LEN
name|sizeAB
decl_stmt|;
comment|/* size of subtraction of A and B */
name|LEN
name|sizeDC
decl_stmt|;
comment|/* size of subtraction of D and C */
name|LEN
name|sizeABDC
decl_stmt|;
comment|/* size of product of above two results */
name|LEN
name|subsize
decl_stmt|;
comment|/* size of difference of halfs */
name|LEN
name|copysize
decl_stmt|;
comment|/* size of number left to copy */
name|LEN
name|sizetotal
decl_stmt|;
comment|/* total size of product */
name|LEN
name|len
decl_stmt|;
comment|/* temporary length */
name|HALF
modifier|*
name|baseA
decl_stmt|;
comment|/* base of left half of first number */
name|HALF
modifier|*
name|baseB
decl_stmt|;
comment|/* base of right half of first number */
name|HALF
modifier|*
name|baseC
decl_stmt|;
comment|/* base of left half of second number */
name|HALF
modifier|*
name|baseD
decl_stmt|;
comment|/* base of right half of second number */
name|HALF
modifier|*
name|baseAB
decl_stmt|;
comment|/* base of result of subtraction of A and B */
name|HALF
modifier|*
name|baseDC
decl_stmt|;
comment|/* base of result of subtraction of D and C */
name|HALF
modifier|*
name|baseABDC
decl_stmt|;
comment|/* base of product of above two results */
name|HALF
modifier|*
name|baseAC
decl_stmt|;
comment|/* base of product of A and C */
name|HALF
modifier|*
name|baseBD
decl_stmt|;
comment|/* base of product of B and D */
name|FULL
name|carry
decl_stmt|;
comment|/* carry digit for small multiplications */
name|FULL
name|carryACBD
decl_stmt|;
comment|/* carry from addition of A*C and B*D */
name|FULL
name|digit
decl_stmt|;
comment|/* single digit multiplying by */
name|HALF
modifier|*
name|temp
decl_stmt|;
comment|/* base for temporary calculations */
name|BOOL
name|neg
decl_stmt|;
comment|/* whether imtermediate term is negative */
specifier|register
name|HALF
modifier|*
name|hd
decl_stmt|,
modifier|*
name|h1
init|=
name|NULL
decl_stmt|,
modifier|*
name|h2
init|=
name|NULL
decl_stmt|;
comment|/* for inner loops */
name|SIUNION
name|sival
decl_stmt|;
comment|/* for addition of digits */
comment|/* 	 * Trim the numbers of leading zeroes and initialize the 	 * estimated size of the result. 	 */
name|hd
operator|=
operator|&
name|v1
index|[
name|size1
operator|-
literal|1
index|]
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|hd
operator|==
literal|0
operator|)
operator|&&
operator|(
name|size1
operator|>
literal|1
operator|)
condition|)
block|{
name|hd
operator|--
expr_stmt|;
name|size1
operator|--
expr_stmt|;
block|}
name|hd
operator|=
operator|&
name|v2
index|[
name|size2
operator|-
literal|1
index|]
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|hd
operator|==
literal|0
operator|)
operator|&&
operator|(
name|size2
operator|>
literal|1
operator|)
condition|)
block|{
name|hd
operator|--
expr_stmt|;
name|size2
operator|--
expr_stmt|;
block|}
name|sizetotal
operator|=
name|size1
operator|+
name|size2
expr_stmt|;
comment|/* 	 * First check for zero answer. 	 */
if|if
condition|(
operator|(
operator|(
name|size1
operator|==
literal|1
operator|)
operator|&&
operator|(
operator|*
name|v1
operator|==
literal|0
operator|)
operator|)
operator|||
operator|(
operator|(
name|size2
operator|==
literal|1
operator|)
operator|&&
operator|(
operator|*
name|v2
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
operator|*
name|ans
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* 	 * Exchange the two numbers if necessary to make the number of 	 * digits of the first number be greater than or equal to the 	 * second number. 	 */
if|if
condition|(
name|size1
operator|<
name|size2
condition|)
block|{
name|len
operator|=
name|size1
expr_stmt|;
name|size1
operator|=
name|size2
expr_stmt|;
name|size2
operator|=
name|len
expr_stmt|;
name|hd
operator|=
name|v1
expr_stmt|;
name|v1
operator|=
name|v2
expr_stmt|;
name|v2
operator|=
name|hd
expr_stmt|;
block|}
comment|/* 	 * If the smaller number has only a few digits, then calculate 	 * the result in the normal manner in order to avoid the overhead 	 * of the recursion for small numbers.  The number of digits where 	 * the algorithm changes is settable from 2 to maxint. 	 */
if|if
condition|(
name|size2
operator|<
name|_mul2_
condition|)
block|{
comment|/* 		 * First clear the top part of the result, and then multiply 		 * by the lowest digit to get the first partial sum.  Later 		 * products will then add into this result. 		 */
name|hd
operator|=
operator|&
name|ans
index|[
name|size1
index|]
expr_stmt|;
name|len
operator|=
name|size2
expr_stmt|;
while|while
condition|(
name|len
operator|--
condition|)
operator|*
name|hd
operator|++
operator|=
literal|0
expr_stmt|;
name|digit
operator|=
operator|*
name|v2
operator|++
expr_stmt|;
name|h1
operator|=
name|v1
expr_stmt|;
name|hd
operator|=
name|ans
expr_stmt|;
name|carry
operator|=
literal|0
expr_stmt|;
name|len
operator|=
name|size1
expr_stmt|;
while|while
condition|(
name|len
operator|>=
literal|4
condition|)
block|{
comment|/* expand the loop some */
name|len
operator|-=
literal|4
expr_stmt|;
name|sival
operator|.
name|ivalue
operator|=
operator|(
operator|(
name|FULL
operator|)
operator|*
name|h1
operator|++
operator|)
operator|*
name|digit
operator|+
name|carry
expr_stmt|;
operator|*
name|hd
operator|++
operator|=
name|sival
operator|.
name|silow
expr_stmt|;
name|carry
operator|=
name|sival
operator|.
name|sihigh
expr_stmt|;
name|sival
operator|.
name|ivalue
operator|=
operator|(
operator|(
name|FULL
operator|)
operator|*
name|h1
operator|++
operator|)
operator|*
name|digit
operator|+
name|carry
expr_stmt|;
operator|*
name|hd
operator|++
operator|=
name|sival
operator|.
name|silow
expr_stmt|;
name|carry
operator|=
name|sival
operator|.
name|sihigh
expr_stmt|;
name|sival
operator|.
name|ivalue
operator|=
operator|(
operator|(
name|FULL
operator|)
operator|*
name|h1
operator|++
operator|)
operator|*
name|digit
operator|+
name|carry
expr_stmt|;
operator|*
name|hd
operator|++
operator|=
name|sival
operator|.
name|silow
expr_stmt|;
name|carry
operator|=
name|sival
operator|.
name|sihigh
expr_stmt|;
name|sival
operator|.
name|ivalue
operator|=
operator|(
operator|(
name|FULL
operator|)
operator|*
name|h1
operator|++
operator|)
operator|*
name|digit
operator|+
name|carry
expr_stmt|;
operator|*
name|hd
operator|++
operator|=
name|sival
operator|.
name|silow
expr_stmt|;
name|carry
operator|=
name|sival
operator|.
name|sihigh
expr_stmt|;
block|}
while|while
condition|(
name|len
operator|--
condition|)
block|{
name|sival
operator|.
name|ivalue
operator|=
operator|(
operator|(
name|FULL
operator|)
operator|*
name|h1
operator|++
operator|)
operator|*
name|digit
operator|+
name|carry
expr_stmt|;
operator|*
name|hd
operator|++
operator|=
name|sival
operator|.
name|silow
expr_stmt|;
name|carry
operator|=
name|sival
operator|.
name|sihigh
expr_stmt|;
block|}
operator|*
name|hd
operator|=
operator|(
name|HALF
operator|)
name|carry
expr_stmt|;
comment|/* 		 * Now multiply by the remaining digits of the second number, 		 * adding each product into the final result. 		 */
name|h2
operator|=
name|ans
expr_stmt|;
while|while
condition|(
operator|--
name|size2
operator|>
literal|0
condition|)
block|{
name|digit
operator|=
operator|*
name|v2
operator|++
expr_stmt|;
name|h1
operator|=
name|v1
expr_stmt|;
name|hd
operator|=
operator|++
name|h2
expr_stmt|;
if|if
condition|(
name|digit
operator|==
literal|0
condition|)
continue|continue;
name|carry
operator|=
literal|0
expr_stmt|;
name|len
operator|=
name|size1
expr_stmt|;
while|while
condition|(
name|len
operator|>=
literal|4
condition|)
block|{
comment|/* expand the loop some */
name|len
operator|-=
literal|4
expr_stmt|;
name|sival
operator|.
name|ivalue
operator|=
operator|(
operator|(
name|FULL
operator|)
operator|*
name|h1
operator|++
operator|)
operator|*
name|digit
operator|+
operator|(
operator|(
name|FULL
operator|)
operator|*
name|hd
operator|)
operator|+
name|carry
expr_stmt|;
operator|*
name|hd
operator|++
operator|=
name|sival
operator|.
name|silow
expr_stmt|;
name|carry
operator|=
name|sival
operator|.
name|sihigh
expr_stmt|;
name|sival
operator|.
name|ivalue
operator|=
operator|(
operator|(
name|FULL
operator|)
operator|*
name|h1
operator|++
operator|)
operator|*
name|digit
operator|+
operator|(
operator|(
name|FULL
operator|)
operator|*
name|hd
operator|)
operator|+
name|carry
expr_stmt|;
operator|*
name|hd
operator|++
operator|=
name|sival
operator|.
name|silow
expr_stmt|;
name|carry
operator|=
name|sival
operator|.
name|sihigh
expr_stmt|;
name|sival
operator|.
name|ivalue
operator|=
operator|(
operator|(
name|FULL
operator|)
operator|*
name|h1
operator|++
operator|)
operator|*
name|digit
operator|+
operator|(
operator|(
name|FULL
operator|)
operator|*
name|hd
operator|)
operator|+
name|carry
expr_stmt|;
operator|*
name|hd
operator|++
operator|=
name|sival
operator|.
name|silow
expr_stmt|;
name|carry
operator|=
name|sival
operator|.
name|sihigh
expr_stmt|;
name|sival
operator|.
name|ivalue
operator|=
operator|(
operator|(
name|FULL
operator|)
operator|*
name|h1
operator|++
operator|)
operator|*
name|digit
operator|+
operator|(
operator|(
name|FULL
operator|)
operator|*
name|hd
operator|)
operator|+
name|carry
expr_stmt|;
operator|*
name|hd
operator|++
operator|=
name|sival
operator|.
name|silow
expr_stmt|;
name|carry
operator|=
name|sival
operator|.
name|sihigh
expr_stmt|;
block|}
while|while
condition|(
name|len
operator|--
condition|)
block|{
name|sival
operator|.
name|ivalue
operator|=
operator|(
operator|(
name|FULL
operator|)
operator|*
name|h1
operator|++
operator|)
operator|*
name|digit
operator|+
operator|(
operator|(
name|FULL
operator|)
operator|*
name|hd
operator|)
operator|+
name|carry
expr_stmt|;
operator|*
name|hd
operator|++
operator|=
name|sival
operator|.
name|silow
expr_stmt|;
name|carry
operator|=
name|sival
operator|.
name|sihigh
expr_stmt|;
block|}
while|while
condition|(
name|carry
condition|)
block|{
name|sival
operator|.
name|ivalue
operator|=
operator|(
operator|(
name|FULL
operator|)
operator|*
name|hd
operator|)
operator|+
name|carry
expr_stmt|;
operator|*
name|hd
operator|++
operator|=
name|sival
operator|.
name|silow
expr_stmt|;
name|carry
operator|=
name|sival
operator|.
name|sihigh
expr_stmt|;
block|}
block|}
comment|/* 		 * Now return the true size of the number. 		 */
name|len
operator|=
name|sizetotal
expr_stmt|;
name|hd
operator|=
operator|&
name|ans
index|[
name|len
operator|-
literal|1
index|]
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|hd
operator|==
literal|0
operator|)
operator|&&
operator|(
name|len
operator|>
literal|1
operator|)
condition|)
block|{
name|hd
operator|--
expr_stmt|;
name|len
operator|--
expr_stmt|;
block|}
return|return
name|len
return|;
block|}
comment|/* 	 * Need to multiply by a large number. 	 * Allocate temporary space for calculations, and calculate the 	 * value for the shift.  The shift value is 1/2 the size of the 	 * larger (first) number (rounded up).  The amount of temporary 	 * space needed is twice the size of the shift, plus one more word 	 * for the multiply to use. 	 */
name|shift
operator|=
operator|(
name|size1
operator|+
literal|1
operator|)
operator|/
literal|2
expr_stmt|;
name|temp
operator|=
name|tempbuf
expr_stmt|;
name|tempbuf
operator|+=
operator|(
literal|2
operator|*
name|shift
operator|)
operator|+
literal|1
expr_stmt|;
comment|/* 	 * Determine the sizes and locations of all the numbers. 	 * The value of sizeC can be negative, and this is checked later. 	 * The value of sizeD is limited by the full size of the number. 	 */
name|baseA
operator|=
name|v1
operator|+
name|shift
expr_stmt|;
name|baseB
operator|=
name|v1
expr_stmt|;
comment|/*  	 * XXX - Saber-C Version 3.1 says: 	 * 	 *    W#26, Storing a bad pointer into auto variable dmul`baseC. 	 * 	 * This warning is issued during the regression test #026 	 * (read cryrand). 	 * 	 * Saver-C claims that v2+shift is past the end of allocated 	 * memory for v2.  When this warning is first issued, shift 	 * has the value 51. 	 * 	 * The call stack is: 	 * 	 *   domul(0x165ca0, 101, 0x160998, 40, 0x16d0a8) at "zmul.c":315  	 *   zmul(0x2ddf88, 0x2ddf8c, 0x2ddc98) at "zmul.c":73  	 *   qsqrt(0x38defc, 0x38ea94) at "qfunc.c":248  	 *   qln(0x38defc, 0x38de70) at "qtrans.c":589  	 *   qpower(0x38eacc, 0x38a398, 0x38a018) at "qtrans.c":657  	 *   powervalue(0x1740f8,0x174118,0x195234,0x19523c) at "value.c":1009  	 *   f_power(2, 0x533278) at "func.c":1188  	 *   builtinfunc(117, 2, 0x174118) at "func.c":354  	 *   o_call(0x5328d8, 117, 2) at "opcodes.c":2094  	 *   calculate(0x5328d8, 1) at "opcodes.c":288  	 *   o_usercall(0x5328d8, 54, 1) at "opcodes.c":2082  	 *   calculate(0x48ffa8, 4) at "opcodes.c":288  	 *   o_usercall(0x48ffa8, 53, 1) at "opcodes.c":2082  	 *   calculate(0x1652a0, 1) at "opcodes.c":288  	 *   o_usercall(0x1652a0, 57, 1) at "opcodes.c":2082  	 *   calculate(0x16cca8, 0) at "opcodes.c":288  	 *   evaluate(0) at "codegen.c":167  	 *   getcommands(0) at "codegen.c":106  	 *   getcommands(0) at "codegen.c":76  	 *   getcommands(1) at "codegen.c":76  	 *   main(-1, 0x181f8c) at "calc.c":155  	 * 	 * Purify does not complain about this code.  Who is right? 	 */
name|baseC
operator|=
name|v2
operator|+
name|shift
expr_stmt|;
name|baseD
operator|=
name|v2
expr_stmt|;
name|baseAB
operator|=
name|ans
expr_stmt|;
name|baseDC
operator|=
name|ans
operator|+
name|shift
expr_stmt|;
name|baseAC
operator|=
name|ans
operator|+
name|shift
operator|*
literal|2
expr_stmt|;
name|baseBD
operator|=
name|ans
expr_stmt|;
name|sizeA
operator|=
name|size1
operator|-
name|shift
expr_stmt|;
name|sizeC
operator|=
name|size2
operator|-
name|shift
expr_stmt|;
name|sizeB
operator|=
name|shift
expr_stmt|;
name|hd
operator|=
operator|&
name|baseB
index|[
name|shift
operator|-
literal|1
index|]
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|hd
operator|==
literal|0
operator|)
operator|&&
operator|(
name|sizeB
operator|>
literal|1
operator|)
condition|)
block|{
name|hd
operator|--
expr_stmt|;
name|sizeB
operator|--
expr_stmt|;
block|}
name|sizeD
operator|=
name|shift
expr_stmt|;
if|if
condition|(
name|sizeD
operator|>
name|size2
condition|)
name|sizeD
operator|=
name|size2
expr_stmt|;
name|hd
operator|=
operator|&
name|baseD
index|[
name|sizeD
operator|-
literal|1
index|]
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|hd
operator|==
literal|0
operator|)
operator|&&
operator|(
name|sizeD
operator|>
literal|1
operator|)
condition|)
block|{
name|hd
operator|--
expr_stmt|;
name|sizeD
operator|--
expr_stmt|;
block|}
comment|/* 	 * If the smaller number has a high half of zero, then calculate 	 * the result by breaking up the first number into two numbers 	 * and combining the results using the obvious formula: 	 *	(A*S+B) * D = (A*D)*S + B*D 	 */
if|if
condition|(
name|sizeC
operator|<=
literal|0
condition|)
block|{
name|len
operator|=
name|domul
argument_list|(
name|baseB
argument_list|,
name|sizeB
argument_list|,
name|baseD
argument_list|,
name|sizeD
argument_list|,
name|ans
argument_list|)
expr_stmt|;
name|hd
operator|=
operator|&
name|ans
index|[
name|len
index|]
expr_stmt|;
name|len
operator|=
name|sizetotal
operator|-
name|len
expr_stmt|;
while|while
condition|(
name|len
operator|--
condition|)
operator|*
name|hd
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* 		 * Add the second number into the first number, shifted 		 * over at the correct position. 		 */
name|len
operator|=
name|domul
argument_list|(
name|baseA
argument_list|,
name|sizeA
argument_list|,
name|baseD
argument_list|,
name|sizeD
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|h1
operator|=
name|temp
expr_stmt|;
name|hd
operator|=
name|ans
operator|+
name|shift
expr_stmt|;
name|carry
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|len
operator|--
condition|)
block|{
name|sival
operator|.
name|ivalue
operator|=
operator|(
operator|(
name|FULL
operator|)
operator|*
name|h1
operator|++
operator|)
operator|+
operator|(
operator|(
name|FULL
operator|)
operator|*
name|hd
operator|)
operator|+
name|carry
expr_stmt|;
operator|*
name|hd
operator|++
operator|=
name|sival
operator|.
name|silow
expr_stmt|;
name|carry
operator|=
name|sival
operator|.
name|sihigh
expr_stmt|;
block|}
while|while
condition|(
name|carry
condition|)
block|{
name|sival
operator|.
name|ivalue
operator|=
operator|(
operator|(
name|FULL
operator|)
operator|*
name|hd
operator|)
operator|+
name|carry
expr_stmt|;
operator|*
name|hd
operator|++
operator|=
name|sival
operator|.
name|silow
expr_stmt|;
name|carry
operator|=
name|sival
operator|.
name|sihigh
expr_stmt|;
block|}
comment|/* 		 * Determine the final size of the number and return it. 		 */
name|len
operator|=
name|sizetotal
expr_stmt|;
name|hd
operator|=
operator|&
name|ans
index|[
name|len
operator|-
literal|1
index|]
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|hd
operator|==
literal|0
operator|)
operator|&&
operator|(
name|len
operator|>
literal|1
operator|)
condition|)
block|{
name|hd
operator|--
expr_stmt|;
name|len
operator|--
expr_stmt|;
block|}
name|tempbuf
operator|=
name|temp
expr_stmt|;
return|return
name|len
return|;
block|}
comment|/* 	 * Now we know that the high halfs of the numbers are nonzero, 	 * so we can use the complete formula. 	 *	(A*S+B)*(C*S+D) = (S^2+S)*A*C + S*(A-B)*(D-C) + (S+1)*B*D. 	 * The steps are done in the following order: 	 *	A-B 	 *	D-C 	 *	(A-B)*(D-C) 	 *	S^2*A*C + B*D 	 *	(S^2+S)*A*C + (S+1)*B*D				(*) 	 *	(S^2+S)*A*C + S*(A-B)*(D-C) + (S+1)*B*D 	 * 	 * Note: step (*) above can produce a result which is larger than 	 * the final product will be, and this is where the extra word 	 * needed in the product comes from.  After the final subtraction is 	 * done, the result fits in the expected size.  Using the extra word 	 * is easier than suppressing the carries and borrows everywhere. 	 * 	 * Begin by forming the product (A-B)*(D-C) into a temporary 	 * location that we save until the final step.  Do each subtraction 	 * at positions 0 and S.  Be very careful about the relative sizes 	 * of the numbers since this result can be negative.  For the first 	 * step calculate the absolute difference of A and B into a temporary 	 * location at position 0 of the result.  Negate the sign if A is 	 * smaller than B. 	 */
name|neg
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|sizeA
operator|==
name|sizeB
condition|)
block|{
name|len
operator|=
name|sizeA
expr_stmt|;
name|h1
operator|=
operator|&
name|baseA
index|[
name|len
operator|-
literal|1
index|]
expr_stmt|;
name|h2
operator|=
operator|&
name|baseB
index|[
name|len
operator|-
literal|1
index|]
expr_stmt|;
while|while
condition|(
operator|(
name|len
operator|>
literal|1
operator|)
operator|&&
operator|(
operator|*
name|h1
operator|==
operator|*
name|h2
operator|)
condition|)
block|{
name|len
operator|--
expr_stmt|;
name|h1
operator|--
expr_stmt|;
name|h2
operator|--
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|sizeA
operator|>
name|sizeB
operator|)
operator|||
operator|(
operator|(
name|sizeA
operator|==
name|sizeB
operator|)
operator|&&
name|h1
operator|&&
name|h2
operator|&&
operator|(
operator|*
name|h1
operator|>
operator|*
name|h2
operator|)
operator|)
condition|)
block|{
name|h1
operator|=
name|baseA
expr_stmt|;
name|h2
operator|=
name|baseB
expr_stmt|;
name|sizeAB
operator|=
name|sizeA
expr_stmt|;
name|subsize
operator|=
name|sizeB
expr_stmt|;
block|}
else|else
block|{
name|neg
operator|=
operator|!
name|neg
expr_stmt|;
name|h1
operator|=
name|baseB
expr_stmt|;
name|h2
operator|=
name|baseA
expr_stmt|;
name|sizeAB
operator|=
name|sizeB
expr_stmt|;
name|subsize
operator|=
name|sizeA
expr_stmt|;
block|}
name|copysize
operator|=
name|sizeAB
operator|-
name|subsize
expr_stmt|;
name|hd
operator|=
name|baseAB
expr_stmt|;
name|carry
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|subsize
operator|--
condition|)
block|{
name|sival
operator|.
name|ivalue
operator|=
name|BASE1
operator|-
operator|(
operator|(
name|FULL
operator|)
operator|*
name|h1
operator|++
operator|)
operator|+
operator|(
operator|(
name|FULL
operator|)
operator|*
name|h2
operator|++
operator|)
operator|+
name|carry
expr_stmt|;
operator|*
name|hd
operator|++
operator|=
name|BASE1
operator|-
name|sival
operator|.
name|silow
expr_stmt|;
name|carry
operator|=
name|sival
operator|.
name|sihigh
expr_stmt|;
block|}
while|while
condition|(
name|copysize
operator|--
condition|)
block|{
name|sival
operator|.
name|ivalue
operator|=
operator|(
name|BASE1
operator|-
operator|(
operator|(
name|FULL
operator|)
operator|*
name|h1
operator|++
operator|)
operator|)
operator|+
name|carry
expr_stmt|;
operator|*
name|hd
operator|++
operator|=
name|BASE1
operator|-
name|sival
operator|.
name|silow
expr_stmt|;
name|carry
operator|=
name|sival
operator|.
name|sihigh
expr_stmt|;
block|}
name|hd
operator|=
operator|&
name|baseAB
index|[
name|sizeAB
operator|-
literal|1
index|]
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|hd
operator|==
literal|0
operator|)
operator|&&
operator|(
name|sizeAB
operator|>
literal|1
operator|)
condition|)
block|{
name|hd
operator|--
expr_stmt|;
name|sizeAB
operator|--
expr_stmt|;
block|}
comment|/* 	 * This completes the calculation of abs(A-B).  For the next step 	 * calculate the absolute difference of D and C into a temporary 	 * location at position S of the result.  Negate the sign if C is 	 * larger than D. 	 */
if|if
condition|(
name|sizeC
operator|==
name|sizeD
condition|)
block|{
name|len
operator|=
name|sizeC
expr_stmt|;
name|h1
operator|=
operator|&
name|baseC
index|[
name|len
operator|-
literal|1
index|]
expr_stmt|;
name|h2
operator|=
operator|&
name|baseD
index|[
name|len
operator|-
literal|1
index|]
expr_stmt|;
while|while
condition|(
operator|(
name|len
operator|>
literal|1
operator|)
operator|&&
operator|(
operator|*
name|h1
operator|==
operator|*
name|h2
operator|)
condition|)
block|{
name|len
operator|--
expr_stmt|;
name|h1
operator|--
expr_stmt|;
name|h2
operator|--
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|sizeC
operator|>
name|sizeD
operator|)
operator|||
operator|(
operator|(
name|sizeC
operator|==
name|sizeD
operator|)
operator|&&
operator|(
operator|*
name|h1
operator|>
operator|*
name|h2
operator|)
operator|)
condition|)
block|{
name|neg
operator|=
operator|!
name|neg
expr_stmt|;
name|h1
operator|=
name|baseC
expr_stmt|;
name|h2
operator|=
name|baseD
expr_stmt|;
name|sizeDC
operator|=
name|sizeC
expr_stmt|;
name|subsize
operator|=
name|sizeD
expr_stmt|;
block|}
else|else
block|{
name|h1
operator|=
name|baseD
expr_stmt|;
name|h2
operator|=
name|baseC
expr_stmt|;
name|sizeDC
operator|=
name|sizeD
expr_stmt|;
name|subsize
operator|=
name|sizeC
expr_stmt|;
block|}
name|copysize
operator|=
name|sizeDC
operator|-
name|subsize
expr_stmt|;
name|hd
operator|=
name|baseDC
expr_stmt|;
name|carry
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|subsize
operator|--
condition|)
block|{
name|sival
operator|.
name|ivalue
operator|=
name|BASE1
operator|-
operator|(
operator|(
name|FULL
operator|)
operator|*
name|h1
operator|++
operator|)
operator|+
operator|(
operator|(
name|FULL
operator|)
operator|*
name|h2
operator|++
operator|)
operator|+
name|carry
expr_stmt|;
operator|*
name|hd
operator|++
operator|=
name|BASE1
operator|-
name|sival
operator|.
name|silow
expr_stmt|;
name|carry
operator|=
name|sival
operator|.
name|sihigh
expr_stmt|;
block|}
while|while
condition|(
name|copysize
operator|--
condition|)
block|{
name|sival
operator|.
name|ivalue
operator|=
operator|(
name|BASE1
operator|-
operator|(
operator|(
name|FULL
operator|)
operator|*
name|h1
operator|++
operator|)
operator|)
operator|+
name|carry
expr_stmt|;
operator|*
name|hd
operator|++
operator|=
name|BASE1
operator|-
name|sival
operator|.
name|silow
expr_stmt|;
name|carry
operator|=
name|sival
operator|.
name|sihigh
expr_stmt|;
block|}
name|hd
operator|=
operator|&
name|baseDC
index|[
name|sizeDC
operator|-
literal|1
index|]
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|hd
operator|==
literal|0
operator|)
operator|&&
operator|(
name|sizeDC
operator|>
literal|1
operator|)
condition|)
block|{
name|hd
operator|--
expr_stmt|;
name|sizeDC
operator|--
expr_stmt|;
block|}
comment|/* 	 * This completes the calculation of abs(D-C).  Now multiply 	 * together abs(A-B) and abs(D-C) into a temporary location, 	 * which is preserved until the final steps. 	 */
name|baseABDC
operator|=
name|temp
expr_stmt|;
name|sizeABDC
operator|=
name|domul
argument_list|(
name|baseAB
argument_list|,
name|sizeAB
argument_list|,
name|baseDC
argument_list|,
name|sizeDC
argument_list|,
name|baseABDC
argument_list|)
expr_stmt|;
comment|/* 	 * Now calculate B*D and A*C into one of their two final locations. 	 * Make sure the high order digits of the products are zeroed since 	 * this initializes the final result.  Be careful about this zeroing 	 * since the size of the high order words might be smaller than 	 * the shift size.  Do B*D first since the multiplies use one more 	 * word than the size of the product.  Also zero the final extra 	 * word in the result for possible carries to use. 	 */
name|len
operator|=
name|domul
argument_list|(
name|baseB
argument_list|,
name|sizeB
argument_list|,
name|baseD
argument_list|,
name|sizeD
argument_list|,
name|baseBD
argument_list|)
expr_stmt|;
name|hd
operator|=
operator|&
name|baseBD
index|[
name|len
index|]
expr_stmt|;
name|len
operator|=
name|shift
operator|*
literal|2
operator|-
name|len
expr_stmt|;
while|while
condition|(
name|len
operator|--
condition|)
operator|*
name|hd
operator|++
operator|=
literal|0
expr_stmt|;
name|len
operator|=
name|domul
argument_list|(
name|baseA
argument_list|,
name|sizeA
argument_list|,
name|baseC
argument_list|,
name|sizeC
argument_list|,
name|baseAC
argument_list|)
expr_stmt|;
name|hd
operator|=
operator|&
name|baseAC
index|[
name|len
index|]
expr_stmt|;
name|len
operator|=
name|sizetotal
operator|-
name|shift
operator|*
literal|2
operator|-
name|len
operator|+
literal|1
expr_stmt|;
while|while
condition|(
name|len
operator|--
condition|)
operator|*
name|hd
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Now add in A*C and B*D into themselves at the other shifted 	 * position that they need.  This addition is tricky in order to 	 * make sure that the two additions cannot interfere with each other. 	 * Therefore we first add in the top half of B*D and the lower half 	 * of A*C.  The sources and destinations of these two additions 	 * overlap, and so the same answer results from the two additions, 	 * thus only two pointers suffice for both additions.  Keep the 	 * final carry from these additions for later use since we cannot 	 * afford to change the top half of A*C yet. 	 */
name|h1
operator|=
name|baseBD
operator|+
name|shift
expr_stmt|;
name|h2
operator|=
name|baseAC
expr_stmt|;
name|carryACBD
operator|=
literal|0
expr_stmt|;
name|len
operator|=
name|shift
expr_stmt|;
while|while
condition|(
name|len
operator|--
condition|)
block|{
name|sival
operator|.
name|ivalue
operator|=
operator|(
operator|(
name|FULL
operator|)
operator|*
name|h1
operator|)
operator|+
operator|(
operator|(
name|FULL
operator|)
operator|*
name|h2
operator|)
operator|+
name|carryACBD
expr_stmt|;
operator|*
name|h1
operator|++
operator|=
name|sival
operator|.
name|silow
expr_stmt|;
operator|*
name|h2
operator|++
operator|=
name|sival
operator|.
name|silow
expr_stmt|;
name|carryACBD
operator|=
name|sival
operator|.
name|sihigh
expr_stmt|;
block|}
comment|/* 	 * Now add in the bottom half of B*D and the top half of A*C. 	 * These additions are straightforward, except that A*C should 	 * be done first because of possible carries from B*D, and the 	 * top half of A*C might not exist.  Add in one of the carries 	 * from the previous addition while we are at it. 	 */
name|h1
operator|=
name|baseAC
operator|+
name|shift
expr_stmt|;
name|hd
operator|=
name|baseAC
expr_stmt|;
name|carry
operator|=
name|carryACBD
expr_stmt|;
name|len
operator|=
name|sizetotal
operator|-
literal|3
operator|*
name|shift
expr_stmt|;
while|while
condition|(
name|len
operator|--
condition|)
block|{
name|sival
operator|.
name|ivalue
operator|=
operator|(
operator|(
name|FULL
operator|)
operator|*
name|h1
operator|++
operator|)
operator|+
operator|(
operator|(
name|FULL
operator|)
operator|*
name|hd
operator|)
operator|+
name|carry
expr_stmt|;
operator|*
name|hd
operator|++
operator|=
name|sival
operator|.
name|silow
expr_stmt|;
name|carry
operator|=
name|sival
operator|.
name|sihigh
expr_stmt|;
block|}
while|while
condition|(
name|carry
condition|)
block|{
name|sival
operator|.
name|ivalue
operator|=
operator|(
operator|(
name|FULL
operator|)
operator|*
name|hd
operator|)
operator|+
name|carry
expr_stmt|;
operator|*
name|hd
operator|++
operator|=
name|sival
operator|.
name|silow
expr_stmt|;
name|carry
operator|=
name|sival
operator|.
name|sihigh
expr_stmt|;
block|}
name|h1
operator|=
name|baseBD
expr_stmt|;
name|hd
operator|=
name|baseBD
operator|+
name|shift
expr_stmt|;
name|carry
operator|=
literal|0
expr_stmt|;
name|len
operator|=
name|shift
expr_stmt|;
while|while
condition|(
name|len
operator|--
condition|)
block|{
name|sival
operator|.
name|ivalue
operator|=
operator|(
operator|(
name|FULL
operator|)
operator|*
name|h1
operator|++
operator|)
operator|+
operator|(
operator|(
name|FULL
operator|)
operator|*
name|hd
operator|)
operator|+
name|carry
expr_stmt|;
operator|*
name|hd
operator|++
operator|=
name|sival
operator|.
name|silow
expr_stmt|;
name|carry
operator|=
name|sival
operator|.
name|sihigh
expr_stmt|;
block|}
while|while
condition|(
name|carry
condition|)
block|{
name|sival
operator|.
name|ivalue
operator|=
operator|(
operator|(
name|FULL
operator|)
operator|*
name|hd
operator|)
operator|+
name|carry
expr_stmt|;
operator|*
name|hd
operator|++
operator|=
name|sival
operator|.
name|silow
expr_stmt|;
name|carry
operator|=
name|sival
operator|.
name|sihigh
expr_stmt|;
block|}
comment|/* 	 * Now finally add in the other delayed carry from the 	 * above addition. 	 */
name|hd
operator|=
name|baseAC
operator|+
name|shift
expr_stmt|;
while|while
condition|(
name|carryACBD
condition|)
block|{
name|sival
operator|.
name|ivalue
operator|=
operator|(
operator|(
name|FULL
operator|)
operator|*
name|hd
operator|)
operator|+
name|carryACBD
expr_stmt|;
operator|*
name|hd
operator|++
operator|=
name|sival
operator|.
name|silow
expr_stmt|;
name|carryACBD
operator|=
name|sival
operator|.
name|sihigh
expr_stmt|;
block|}
comment|/* 	 * Now finally add or subtract (A-B)*(D-C) into the final result at 	 * the correct position (S), according to whether it is positive or 	 * negative.  When subtracting, the answer cannot go negative. 	 */
name|h1
operator|=
name|baseABDC
expr_stmt|;
name|hd
operator|=
name|ans
operator|+
name|shift
expr_stmt|;
name|carry
operator|=
literal|0
expr_stmt|;
name|len
operator|=
name|sizeABDC
expr_stmt|;
if|if
condition|(
name|neg
condition|)
block|{
while|while
condition|(
name|len
operator|--
condition|)
block|{
name|sival
operator|.
name|ivalue
operator|=
name|BASE1
operator|-
operator|(
operator|(
name|FULL
operator|)
operator|*
name|hd
operator|)
operator|+
operator|(
operator|(
name|FULL
operator|)
operator|*
name|h1
operator|++
operator|)
operator|+
name|carry
expr_stmt|;
operator|*
name|hd
operator|++
operator|=
name|BASE1
operator|-
name|sival
operator|.
name|silow
expr_stmt|;
name|carry
operator|=
name|sival
operator|.
name|sihigh
expr_stmt|;
block|}
while|while
condition|(
name|carry
condition|)
block|{
name|sival
operator|.
name|ivalue
operator|=
name|BASE1
operator|-
operator|(
operator|(
name|FULL
operator|)
operator|*
name|hd
operator|)
operator|+
name|carry
expr_stmt|;
operator|*
name|hd
operator|++
operator|=
name|BASE1
operator|-
name|sival
operator|.
name|silow
expr_stmt|;
name|carry
operator|=
name|sival
operator|.
name|sihigh
expr_stmt|;
block|}
block|}
else|else
block|{
while|while
condition|(
name|len
operator|--
condition|)
block|{
name|sival
operator|.
name|ivalue
operator|=
operator|(
operator|(
name|FULL
operator|)
operator|*
name|h1
operator|++
operator|)
operator|+
operator|(
operator|(
name|FULL
operator|)
operator|*
name|hd
operator|)
operator|+
name|carry
expr_stmt|;
operator|*
name|hd
operator|++
operator|=
name|sival
operator|.
name|silow
expr_stmt|;
name|carry
operator|=
name|sival
operator|.
name|sihigh
expr_stmt|;
block|}
while|while
condition|(
name|carry
condition|)
block|{
name|sival
operator|.
name|ivalue
operator|=
operator|(
operator|(
name|FULL
operator|)
operator|*
name|hd
operator|)
operator|+
name|carry
expr_stmt|;
operator|*
name|hd
operator|++
operator|=
name|sival
operator|.
name|silow
expr_stmt|;
name|carry
operator|=
name|sival
operator|.
name|sihigh
expr_stmt|;
block|}
block|}
comment|/* 	 * Finally determine the size of the final result and return that. 	 */
name|len
operator|=
name|sizetotal
expr_stmt|;
name|hd
operator|=
operator|&
name|ans
index|[
name|len
operator|-
literal|1
index|]
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|hd
operator|==
literal|0
operator|)
operator|&&
operator|(
name|len
operator|>
literal|1
operator|)
condition|)
block|{
name|hd
operator|--
expr_stmt|;
name|len
operator|--
expr_stmt|;
block|}
name|tempbuf
operator|=
name|temp
expr_stmt|;
return|return
name|len
return|;
block|}
end_function

begin_comment
comment|/*  * Square a number by using the following formula recursively:  *	(A*S+B)^2 = (S^2+S)*A^2 + (S+1)*B^2 - S*(A-B)^2  * where S is a power of 2^16, and so multiplies by it are shifts,  * and A and B are the left and right halfs of the number to square.  */
end_comment

begin_function
name|void
name|zsquare
parameter_list|(
name|z
parameter_list|,
name|res
parameter_list|)
name|ZVALUE
name|z
decl_stmt|,
decl|*
name|res
decl_stmt|;
end_function

begin_block
block|{
name|LEN
name|len
decl_stmt|;
if|if
condition|(
name|ziszero
argument_list|(
name|z
argument_list|)
condition|)
block|{
operator|*
name|res
operator|=
name|_zero_
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|zisunit
argument_list|(
name|z
argument_list|)
condition|)
block|{
operator|*
name|res
operator|=
name|_one_
expr_stmt|;
return|return;
block|}
comment|/* 	 * Allocate a temporary array if necessary for the recursion to use. 	 * The array needs to be allocated large enough for all of the 	 * temporary results to fit in.  This size is about 3 times the 	 * size of the original number, since each recursion level uses 3/2 	 * of the size of its given number, and whose size is 1/2 the size 	 * of the previous level.  The sum of the infinite series is 3. 	 * Allocate some extra words for rounding up the sizes. 	 */
name|len
operator|=
literal|3
operator|*
name|z
operator|.
name|len
operator|+
literal|32
expr_stmt|;
name|tempbuf
operator|=
name|zalloctemp
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|res
operator|->
name|sign
operator|=
literal|0
expr_stmt|;
name|res
operator|->
name|v
operator|=
name|alloc
argument_list|(
operator|(
name|z
operator|.
name|len
operator|+
literal|1
operator|)
operator|*
literal|2
argument_list|)
expr_stmt|;
name|res
operator|->
name|len
operator|=
name|dosquare
argument_list|(
name|z
operator|.
name|v
argument_list|,
name|z
operator|.
name|len
argument_list|,
name|res
operator|->
name|v
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Recursive routine to square a number by splitting it up into two numbers  * of half the size, and using the results of squaring the subpieces.  * The result is placed in the indicated array, which must be large  * enough for the result (size * 2).  Returns the size of the result.  * This uses a temporary array which must be 3 times as large as the  * size of the number at the top level recursive call.  */
end_comment

begin_function
specifier|static
name|LEN
name|dosquare
parameter_list|(
name|vp
parameter_list|,
name|size
parameter_list|,
name|ans
parameter_list|)
name|HALF
modifier|*
name|vp
decl_stmt|;
comment|/* value to be squared */
name|LEN
name|size
decl_stmt|;
comment|/* length of value to square */
name|HALF
modifier|*
name|ans
decl_stmt|;
comment|/* location for result */
block|{
name|LEN
name|shift
decl_stmt|;
comment|/* amount numbers are shifted by */
name|LEN
name|sizeA
decl_stmt|;
comment|/* size of left half of number to square */
name|LEN
name|sizeB
decl_stmt|;
comment|/* size of right half of number to square */
name|LEN
name|sizeAA
decl_stmt|;
comment|/* size of square of left half */
name|LEN
name|sizeBB
decl_stmt|;
comment|/* size of square of right half */
name|LEN
name|sizeAABB
decl_stmt|;
comment|/* size of sum of squares of A and B */
name|LEN
name|sizeAB
decl_stmt|;
comment|/* size of difference of A and B */
name|LEN
name|sizeABAB
decl_stmt|;
comment|/* size of square of difference of A and B */
name|LEN
name|subsize
decl_stmt|;
comment|/* size of difference of halfs */
name|LEN
name|copysize
decl_stmt|;
comment|/* size of number left to copy */
name|LEN
name|sumsize
decl_stmt|;
comment|/* size of sum */
name|LEN
name|sizetotal
decl_stmt|;
comment|/* total size of square */
name|LEN
name|len
decl_stmt|;
comment|/* temporary length */
name|LEN
name|len1
decl_stmt|;
comment|/* another temporary length */
name|FULL
name|carry
decl_stmt|;
comment|/* carry digit for small multiplications */
name|FULL
name|digit
decl_stmt|;
comment|/* single digit multiplying by */
name|HALF
modifier|*
name|temp
decl_stmt|;
comment|/* base for temporary calculations */
name|HALF
modifier|*
name|baseA
decl_stmt|;
comment|/* base of left half of number */
name|HALF
modifier|*
name|baseB
decl_stmt|;
comment|/* base of right half of number */
name|HALF
modifier|*
name|baseAA
decl_stmt|;
comment|/* base of square of left half of number */
name|HALF
modifier|*
name|baseBB
decl_stmt|;
comment|/* base of square of right half of number */
name|HALF
modifier|*
name|baseAABB
decl_stmt|;
comment|/* base of sum of squares of A and B */
name|HALF
modifier|*
name|baseAB
decl_stmt|;
comment|/* base of difference of A and B */
name|HALF
modifier|*
name|baseABAB
decl_stmt|;
comment|/* base of square of difference of A and B */
specifier|register
name|HALF
modifier|*
name|hd
decl_stmt|,
modifier|*
name|h1
decl_stmt|,
modifier|*
name|h2
decl_stmt|,
modifier|*
name|h3
decl_stmt|;
comment|/* for inner loops */
name|SIUNION
name|sival
decl_stmt|;
comment|/* for addition of digits */
comment|/* 	 * First trim the number of leading zeroes. 	 */
name|hd
operator|=
operator|&
name|vp
index|[
name|size
operator|-
literal|1
index|]
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|hd
operator|==
literal|0
operator|)
operator|&&
operator|(
name|size
operator|>
literal|1
operator|)
condition|)
block|{
name|size
operator|--
expr_stmt|;
name|hd
operator|--
expr_stmt|;
block|}
name|sizetotal
operator|=
name|size
operator|+
name|size
expr_stmt|;
comment|/* 	 * If the number has only a small number of digits, then use the 	 * (almost) normal multiplication method.  Multiply each halfword 	 * only by those halfwards further on in the number.  Missed terms 	 * will then be the same pairs of products repeated, and the squares 	 * of each halfword.  The first case is handled by doubling the 	 * result.  The second case is handled explicitly.  The number of 	 * digits where the algorithm changes is settable from 2 to maxint. 	 */
if|if
condition|(
name|size
operator|<
name|_sq2_
condition|)
block|{
name|hd
operator|=
name|ans
expr_stmt|;
name|len
operator|=
name|sizetotal
expr_stmt|;
while|while
condition|(
name|len
operator|--
condition|)
operator|*
name|hd
operator|++
operator|=
literal|0
expr_stmt|;
name|h2
operator|=
name|vp
expr_stmt|;
name|hd
operator|=
name|ans
operator|+
literal|1
expr_stmt|;
for|for
control|(
name|len
operator|=
name|size
init|;
name|len
operator|--
condition|;
name|hd
operator|+=
literal|2
control|)
block|{
name|digit
operator|=
operator|(
name|FULL
operator|)
operator|*
name|h2
operator|++
expr_stmt|;
if|if
condition|(
name|digit
operator|==
literal|0
condition|)
continue|continue;
name|h3
operator|=
name|h2
expr_stmt|;
name|h1
operator|=
name|hd
expr_stmt|;
name|carry
operator|=
literal|0
expr_stmt|;
name|len1
operator|=
name|len
expr_stmt|;
while|while
condition|(
name|len1
operator|>=
literal|4
condition|)
block|{
comment|/* expand the loop some */
name|len1
operator|-=
literal|4
expr_stmt|;
name|sival
operator|.
name|ivalue
operator|=
operator|(
name|digit
operator|*
operator|(
operator|(
name|FULL
operator|)
operator|*
name|h3
operator|++
operator|)
operator|)
operator|+
operator|(
operator|(
name|FULL
operator|)
operator|*
name|h1
operator|)
operator|+
name|carry
expr_stmt|;
operator|*
name|h1
operator|++
operator|=
name|sival
operator|.
name|silow
expr_stmt|;
name|sival
operator|.
name|ivalue
operator|=
operator|(
name|digit
operator|*
operator|(
operator|(
name|FULL
operator|)
operator|*
name|h3
operator|++
operator|)
operator|)
operator|+
operator|(
operator|(
name|FULL
operator|)
operator|*
name|h1
operator|)
operator|+
operator|(
operator|(
name|FULL
operator|)
name|sival
operator|.
name|sihigh
operator|)
expr_stmt|;
operator|*
name|h1
operator|++
operator|=
name|sival
operator|.
name|silow
expr_stmt|;
name|sival
operator|.
name|ivalue
operator|=
operator|(
name|digit
operator|*
operator|(
operator|(
name|FULL
operator|)
operator|*
name|h3
operator|++
operator|)
operator|)
operator|+
operator|(
operator|(
name|FULL
operator|)
operator|*
name|h1
operator|)
operator|+
operator|(
operator|(
name|FULL
operator|)
name|sival
operator|.
name|sihigh
operator|)
expr_stmt|;
operator|*
name|h1
operator|++
operator|=
name|sival
operator|.
name|silow
expr_stmt|;
name|sival
operator|.
name|ivalue
operator|=
operator|(
name|digit
operator|*
operator|(
operator|(
name|FULL
operator|)
operator|*
name|h3
operator|++
operator|)
operator|)
operator|+
operator|(
operator|(
name|FULL
operator|)
operator|*
name|h1
operator|)
operator|+
operator|(
operator|(
name|FULL
operator|)
name|sival
operator|.
name|sihigh
operator|)
expr_stmt|;
operator|*
name|h1
operator|++
operator|=
name|sival
operator|.
name|silow
expr_stmt|;
name|carry
operator|=
name|sival
operator|.
name|sihigh
expr_stmt|;
block|}
while|while
condition|(
name|len1
operator|--
condition|)
block|{
name|sival
operator|.
name|ivalue
operator|=
operator|(
name|digit
operator|*
operator|(
operator|(
name|FULL
operator|)
operator|*
name|h3
operator|++
operator|)
operator|)
operator|+
operator|(
operator|(
name|FULL
operator|)
operator|*
name|h1
operator|)
operator|+
name|carry
expr_stmt|;
operator|*
name|h1
operator|++
operator|=
name|sival
operator|.
name|silow
expr_stmt|;
name|carry
operator|=
name|sival
operator|.
name|sihigh
expr_stmt|;
block|}
while|while
condition|(
name|carry
condition|)
block|{
name|sival
operator|.
name|ivalue
operator|=
operator|(
operator|(
name|FULL
operator|)
operator|*
name|h1
operator|)
operator|+
name|carry
expr_stmt|;
operator|*
name|h1
operator|++
operator|=
name|sival
operator|.
name|silow
expr_stmt|;
name|carry
operator|=
name|sival
operator|.
name|sihigh
expr_stmt|;
block|}
block|}
comment|/* 		 * Now double the result. 		 * There is no final carry to worry about because we 		 * handle all digits of the result which must fit. 		 */
name|carry
operator|=
literal|0
expr_stmt|;
name|hd
operator|=
name|ans
expr_stmt|;
name|len
operator|=
name|sizetotal
expr_stmt|;
while|while
condition|(
name|len
operator|--
condition|)
block|{
name|digit
operator|=
operator|(
operator|(
name|FULL
operator|)
operator|*
name|hd
operator|)
expr_stmt|;
name|sival
operator|.
name|ivalue
operator|=
name|digit
operator|+
name|digit
operator|+
name|carry
expr_stmt|;
operator|*
name|hd
operator|++
operator|=
name|sival
operator|.
name|silow
expr_stmt|;
name|carry
operator|=
name|sival
operator|.
name|sihigh
expr_stmt|;
block|}
comment|/* 		 * Now add in the squares of each halfword. 		 */
name|carry
operator|=
literal|0
expr_stmt|;
name|hd
operator|=
name|ans
expr_stmt|;
name|h3
operator|=
name|vp
expr_stmt|;
name|len
operator|=
name|size
expr_stmt|;
while|while
condition|(
name|len
operator|--
condition|)
block|{
name|digit
operator|=
operator|(
operator|(
name|FULL
operator|)
operator|*
name|h3
operator|++
operator|)
expr_stmt|;
name|sival
operator|.
name|ivalue
operator|=
name|digit
operator|*
name|digit
operator|+
operator|(
operator|(
name|FULL
operator|)
operator|*
name|hd
operator|)
operator|+
name|carry
expr_stmt|;
operator|*
name|hd
operator|++
operator|=
name|sival
operator|.
name|silow
expr_stmt|;
name|carry
operator|=
name|sival
operator|.
name|sihigh
expr_stmt|;
name|sival
operator|.
name|ivalue
operator|=
operator|(
operator|(
name|FULL
operator|)
operator|*
name|hd
operator|)
operator|+
name|carry
expr_stmt|;
operator|*
name|hd
operator|++
operator|=
name|sival
operator|.
name|silow
expr_stmt|;
name|carry
operator|=
name|sival
operator|.
name|sihigh
expr_stmt|;
block|}
while|while
condition|(
name|carry
condition|)
block|{
name|sival
operator|.
name|ivalue
operator|=
operator|(
operator|(
name|FULL
operator|)
operator|*
name|hd
operator|)
operator|+
name|carry
expr_stmt|;
operator|*
name|hd
operator|++
operator|=
name|sival
operator|.
name|silow
expr_stmt|;
name|carry
operator|=
name|sival
operator|.
name|sihigh
expr_stmt|;
block|}
comment|/* 		 * Finally return the size of the result. 		 */
name|len
operator|=
name|sizetotal
expr_stmt|;
name|hd
operator|=
operator|&
name|ans
index|[
name|len
operator|-
literal|1
index|]
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|hd
operator|==
literal|0
operator|)
operator|&&
operator|(
name|len
operator|>
literal|1
operator|)
condition|)
block|{
name|len
operator|--
expr_stmt|;
name|hd
operator|--
expr_stmt|;
block|}
return|return
name|len
return|;
block|}
comment|/* 	 * The number to be squared is large. 	 * Allocate temporary space and determine the sizes and 	 * positions of the values to be calculated. 	 */
name|temp
operator|=
name|tempbuf
expr_stmt|;
name|tempbuf
operator|+=
operator|(
literal|3
operator|*
operator|(
name|size
operator|+
literal|1
operator|)
operator|/
literal|2
operator|)
expr_stmt|;
name|sizeA
operator|=
name|size
operator|/
literal|2
expr_stmt|;
name|sizeB
operator|=
name|size
operator|-
name|sizeA
expr_stmt|;
name|shift
operator|=
name|sizeB
expr_stmt|;
name|baseA
operator|=
name|vp
operator|+
name|sizeB
expr_stmt|;
name|baseB
operator|=
name|vp
expr_stmt|;
name|baseAA
operator|=
operator|&
name|ans
index|[
name|shift
operator|*
literal|2
index|]
expr_stmt|;
name|baseBB
operator|=
name|ans
expr_stmt|;
name|baseAABB
operator|=
name|temp
expr_stmt|;
name|baseAB
operator|=
name|temp
expr_stmt|;
name|baseABAB
operator|=
operator|&
name|temp
index|[
name|shift
index|]
expr_stmt|;
comment|/* 	 * Trim the second number of leading zeroes. 	 */
name|hd
operator|=
operator|&
name|baseB
index|[
name|sizeB
operator|-
literal|1
index|]
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|hd
operator|==
literal|0
operator|)
operator|&&
operator|(
name|sizeB
operator|>
literal|1
operator|)
condition|)
block|{
name|sizeB
operator|--
expr_stmt|;
name|hd
operator|--
expr_stmt|;
block|}
comment|/* 	 * Now to proceed to calculate the result using the formula. 	 *	(A*S+B)^2 = (S^2+S)*A^2 + (S+1)*B^2 - S*(A-B)^2. 	 * The steps are done in the following order: 	 *	S^2*A^2 + B^2 	 *	A^2 + B^2 	 *	(S^2+S)*A^2 + (S+1)*B^2 	 *	(A-B)^2 	 *	(S^2+S)*A^2 + (S+1)*B^2 - S*(A-B)^2. 	 * 	 * Begin by forming the squares of two the halfs concatenated 	 * together in the final result location.  Make sure that the 	 * highest words of the results are zero. 	 */
name|sizeBB
operator|=
name|dosquare
argument_list|(
name|baseB
argument_list|,
name|sizeB
argument_list|,
name|baseBB
argument_list|)
expr_stmt|;
name|hd
operator|=
operator|&
name|baseBB
index|[
name|sizeBB
index|]
expr_stmt|;
name|len
operator|=
name|shift
operator|*
literal|2
operator|-
name|sizeBB
expr_stmt|;
while|while
condition|(
name|len
operator|--
condition|)
operator|*
name|hd
operator|++
operator|=
literal|0
expr_stmt|;
name|sizeAA
operator|=
name|dosquare
argument_list|(
name|baseA
argument_list|,
name|sizeA
argument_list|,
name|baseAA
argument_list|)
expr_stmt|;
name|hd
operator|=
operator|&
name|baseAA
index|[
name|sizeAA
index|]
expr_stmt|;
name|len
operator|=
name|sizetotal
operator|-
name|shift
operator|*
literal|2
operator|-
name|sizeAA
expr_stmt|;
while|while
condition|(
name|len
operator|--
condition|)
operator|*
name|hd
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Sum the two squares into a temporary location. 	 */
if|if
condition|(
name|sizeAA
operator|>=
name|sizeBB
condition|)
block|{
name|h1
operator|=
name|baseAA
expr_stmt|;
name|h2
operator|=
name|baseBB
expr_stmt|;
name|sizeAABB
operator|=
name|sizeAA
expr_stmt|;
name|sumsize
operator|=
name|sizeBB
expr_stmt|;
block|}
else|else
block|{
name|h1
operator|=
name|baseBB
expr_stmt|;
name|h2
operator|=
name|baseAA
expr_stmt|;
name|sizeAABB
operator|=
name|sizeBB
expr_stmt|;
name|sumsize
operator|=
name|sizeAA
expr_stmt|;
block|}
name|copysize
operator|=
name|sizeAABB
operator|-
name|sumsize
expr_stmt|;
name|hd
operator|=
name|baseAABB
expr_stmt|;
name|carry
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|sumsize
operator|--
condition|)
block|{
name|sival
operator|.
name|ivalue
operator|=
operator|(
operator|(
name|FULL
operator|)
operator|*
name|h1
operator|++
operator|)
operator|+
operator|(
operator|(
name|FULL
operator|)
operator|*
name|h2
operator|++
operator|)
operator|+
name|carry
expr_stmt|;
operator|*
name|hd
operator|++
operator|=
name|sival
operator|.
name|silow
expr_stmt|;
name|carry
operator|=
name|sival
operator|.
name|sihigh
expr_stmt|;
block|}
while|while
condition|(
name|copysize
operator|--
condition|)
block|{
name|sival
operator|.
name|ivalue
operator|=
operator|(
operator|(
name|FULL
operator|)
operator|*
name|h1
operator|++
operator|)
operator|+
name|carry
expr_stmt|;
operator|*
name|hd
operator|++
operator|=
name|sival
operator|.
name|silow
expr_stmt|;
name|carry
operator|=
name|sival
operator|.
name|sihigh
expr_stmt|;
block|}
if|if
condition|(
name|carry
condition|)
block|{
operator|*
name|hd
operator|=
operator|(
name|HALF
operator|)
name|carry
expr_stmt|;
name|sizeAABB
operator|++
expr_stmt|;
block|}
comment|/* 	 * Add the sum back into the previously calculated squares 	 * shifted over to the proper location. 	 */
name|h1
operator|=
name|baseAABB
expr_stmt|;
name|hd
operator|=
name|ans
operator|+
name|shift
expr_stmt|;
name|carry
operator|=
literal|0
expr_stmt|;
name|len
operator|=
name|sizeAABB
expr_stmt|;
while|while
condition|(
name|len
operator|--
condition|)
block|{
name|sival
operator|.
name|ivalue
operator|=
operator|(
operator|(
name|FULL
operator|)
operator|*
name|hd
operator|)
operator|+
operator|(
operator|(
name|FULL
operator|)
operator|*
name|h1
operator|++
operator|)
operator|+
name|carry
expr_stmt|;
operator|*
name|hd
operator|++
operator|=
name|sival
operator|.
name|silow
expr_stmt|;
name|carry
operator|=
name|sival
operator|.
name|sihigh
expr_stmt|;
block|}
while|while
condition|(
name|carry
condition|)
block|{
comment|/* 		 * XXX - Saber-C Version 3.1 says: 		 * 		 *    W#113, Using allocated data what has not been set. 		 * 		 * This warning is issued during the regression test #622 		 * (algcheck 1). 		 * 		 * Saber-C claims that *hd has been allocated but not set. 		 * When this warning was first issued, hd == 0x19547c 		 * which is 12 bytes off from ans.  The value of carry 		 * was 1, the value of shift was 2, len was -1 and sizeAABB 		 * was 4, sizeBB as 4, sizeAA was 2.  The value stored 		 * in *hd was 0xbfbf. 		 * 		 * The call stack is: 		 * 		 *   dosquare(0x183e88, 3, 0x195470) at "zmul.c":981  		 *   zsquare(0x1952b0, 0x4c1348) at "zmul.c":687  		 *   zpowermod(0x5d1d58,0x5d1d5c,0x5d1d60,0x390218) at "zmod.c":679  		 *   qpowermod(0x38a088, 0x3901a8, 0x38a964) at "qfunc.c":76  		 *   builtinfunc(113, 3, 0x1740f0) at "func.c":386  		 *   o_call(0x3b5de0, 113, 3) at "opcodes.c":2094  		 *   calculate(0x3b5de0, 3) at "opcodes.c":288  		 *   o_usercall(0x3b5de0, 13, 3) at "opcodes.c":2082  		 *   calculate(0x47dfa8, 0) at "opcodes.c":288  		 *   o_usercall(0x47dfa8, 14, 0) at "opcodes.c":2082  		 *   calculate(0x16cca8, 0) at "opcodes.c":288  		 *   evaluate(0) at "codegen.c":167  		 *   getcommands(0) at "codegen.c":106  		 *   getcommands(1) at "codegen.c":76  		 *   main(-1, 0x181f8c) at "calc.c":155  		 * 		 * Purify does not report this.  Who is right? 		 */
name|sival
operator|.
name|ivalue
operator|=
operator|(
operator|(
name|FULL
operator|)
operator|*
name|hd
operator|)
operator|+
name|carry
expr_stmt|;
operator|*
name|hd
operator|++
operator|=
name|sival
operator|.
name|silow
expr_stmt|;
name|carry
operator|=
name|sival
operator|.
name|sihigh
expr_stmt|;
block|}
comment|/* 	 * Calculate the absolute value of the difference of the two halfs 	 * into a temporary location. 	 */
if|if
condition|(
name|sizeA
operator|==
name|sizeB
condition|)
block|{
name|len
operator|=
name|sizeA
expr_stmt|;
name|h1
operator|=
operator|&
name|baseA
index|[
name|len
operator|-
literal|1
index|]
expr_stmt|;
name|h2
operator|=
operator|&
name|baseB
index|[
name|len
operator|-
literal|1
index|]
expr_stmt|;
while|while
condition|(
operator|(
name|len
operator|>
literal|1
operator|)
operator|&&
operator|(
operator|*
name|h1
operator|==
operator|*
name|h2
operator|)
condition|)
block|{
name|len
operator|--
expr_stmt|;
name|h1
operator|--
expr_stmt|;
name|h2
operator|--
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|sizeA
operator|>
name|sizeB
operator|)
operator|||
operator|(
operator|(
name|sizeA
operator|==
name|sizeB
operator|)
operator|&&
operator|(
operator|*
name|h1
operator|>
operator|*
name|h2
operator|)
operator|)
condition|)
block|{
name|h1
operator|=
name|baseA
expr_stmt|;
name|h2
operator|=
name|baseB
expr_stmt|;
name|sizeAB
operator|=
name|sizeA
expr_stmt|;
name|subsize
operator|=
name|sizeB
expr_stmt|;
block|}
else|else
block|{
name|h1
operator|=
name|baseB
expr_stmt|;
name|h2
operator|=
name|baseA
expr_stmt|;
name|sizeAB
operator|=
name|sizeB
expr_stmt|;
name|subsize
operator|=
name|sizeA
expr_stmt|;
block|}
name|copysize
operator|=
name|sizeAB
operator|-
name|subsize
expr_stmt|;
name|hd
operator|=
name|baseAB
expr_stmt|;
name|carry
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|subsize
operator|--
condition|)
block|{
name|sival
operator|.
name|ivalue
operator|=
name|BASE1
operator|-
operator|(
operator|(
name|FULL
operator|)
operator|*
name|h1
operator|++
operator|)
operator|+
operator|(
operator|(
name|FULL
operator|)
operator|*
name|h2
operator|++
operator|)
operator|+
name|carry
expr_stmt|;
operator|*
name|hd
operator|++
operator|=
name|BASE1
operator|-
name|sival
operator|.
name|silow
expr_stmt|;
name|carry
operator|=
name|sival
operator|.
name|sihigh
expr_stmt|;
block|}
while|while
condition|(
name|copysize
operator|--
condition|)
block|{
name|sival
operator|.
name|ivalue
operator|=
operator|(
name|BASE1
operator|-
operator|(
operator|(
name|FULL
operator|)
operator|*
name|h1
operator|++
operator|)
operator|)
operator|+
name|carry
expr_stmt|;
operator|*
name|hd
operator|++
operator|=
name|BASE1
operator|-
name|sival
operator|.
name|silow
expr_stmt|;
name|carry
operator|=
name|sival
operator|.
name|sihigh
expr_stmt|;
block|}
name|hd
operator|=
operator|&
name|baseAB
index|[
name|sizeAB
operator|-
literal|1
index|]
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|hd
operator|==
literal|0
operator|)
operator|&&
operator|(
name|sizeAB
operator|>
literal|1
operator|)
condition|)
block|{
name|sizeAB
operator|--
expr_stmt|;
name|hd
operator|--
expr_stmt|;
block|}
comment|/* 	 * Now square the number into another temporary location, 	 * and subtract that from the final result. 	 */
name|sizeABAB
operator|=
name|dosquare
argument_list|(
name|baseAB
argument_list|,
name|sizeAB
argument_list|,
name|baseABAB
argument_list|)
expr_stmt|;
name|h1
operator|=
name|baseABAB
expr_stmt|;
name|hd
operator|=
name|ans
operator|+
name|shift
expr_stmt|;
name|carry
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|sizeABAB
operator|--
condition|)
block|{
name|sival
operator|.
name|ivalue
operator|=
name|BASE1
operator|-
operator|(
operator|(
name|FULL
operator|)
operator|*
name|hd
operator|)
operator|+
operator|(
operator|(
name|FULL
operator|)
operator|*
name|h1
operator|++
operator|)
operator|+
name|carry
expr_stmt|;
operator|*
name|hd
operator|++
operator|=
name|BASE1
operator|-
name|sival
operator|.
name|silow
expr_stmt|;
name|carry
operator|=
name|sival
operator|.
name|sihigh
expr_stmt|;
block|}
while|while
condition|(
name|carry
condition|)
block|{
name|sival
operator|.
name|ivalue
operator|=
name|BASE1
operator|-
operator|(
operator|(
name|FULL
operator|)
operator|*
name|hd
operator|)
operator|+
name|carry
expr_stmt|;
operator|*
name|hd
operator|++
operator|=
name|BASE1
operator|-
name|sival
operator|.
name|silow
expr_stmt|;
name|carry
operator|=
name|sival
operator|.
name|sihigh
expr_stmt|;
block|}
comment|/* 	 * Return the size of the result. 	 */
name|len
operator|=
name|sizetotal
expr_stmt|;
name|hd
operator|=
operator|&
name|ans
index|[
name|len
operator|-
literal|1
index|]
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|hd
operator|==
literal|0
operator|)
operator|&&
operator|(
name|len
operator|>
literal|1
operator|)
condition|)
block|{
name|len
operator|--
expr_stmt|;
name|hd
operator|--
expr_stmt|;
block|}
name|tempbuf
operator|=
name|temp
expr_stmt|;
return|return
name|len
return|;
block|}
end_function

begin_comment
comment|/*  * Return a pointer to a buffer to be used for holding a temporary number.  * The buffer will be at least as large as the specified number of HALFs,  * and remains valid until the next call to this routine.  The buffer cannot  * be freed by the caller.  There is only one temporary buffer, and so as to  * avoid possible conflicts this is only used by the lowest level routines  * such as divide, multiply, and square.  */
end_comment

begin_function
name|HALF
modifier|*
name|zalloctemp
parameter_list|(
name|len
parameter_list|)
name|LEN
name|len
decl_stmt|;
comment|/* required number of HALFs in buffer */
block|{
name|HALF
modifier|*
name|hp
decl_stmt|;
specifier|static
name|LEN
name|buflen
decl_stmt|;
comment|/* current length of temp buffer */
specifier|static
name|HALF
modifier|*
name|bufptr
decl_stmt|;
comment|/* pointer to current temp buffer */
if|if
condition|(
name|len
operator|<=
name|buflen
condition|)
return|return
name|bufptr
return|;
comment|/* 	 * We need to grow the temporary buffer. 	 * First free any existing buffer, and then allocate the new one. 	 * While we are at it, make the new buffer bigger than necessary 	 * in order to reduce the number of reallocations. 	 */
name|len
operator|+=
literal|100
expr_stmt|;
if|if
condition|(
name|buflen
condition|)
block|{
name|buflen
operator|=
literal|0
expr_stmt|;
name|free
argument_list|(
name|bufptr
argument_list|)
expr_stmt|;
block|}
name|hp
operator|=
operator|(
name|HALF
operator|*
operator|)
name|malloc
argument_list|(
name|len
operator|*
sizeof|sizeof
argument_list|(
name|HALF
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|==
name|NULL
condition|)
name|math_error
argument_list|(
literal|"No memory for temp buffer"
argument_list|)
expr_stmt|;
name|bufptr
operator|=
name|hp
expr_stmt|;
name|buflen
operator|=
name|len
expr_stmt|;
return|return
name|hp
return|;
block|}
end_function

begin_comment
comment|/* END CODE */
end_comment

end_unit

