begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1994 David I. Bell  * Permission is granted to use, distribute, or modify this source,  * provided that this copyright notice remains intact.  *  * Global and local symbol routines.  */
end_comment

begin_include
include|#
directive|include
file|"calc.h"
end_include

begin_include
include|#
directive|include
file|"token.h"
end_include

begin_include
include|#
directive|include
file|"symbol.h"
end_include

begin_include
include|#
directive|include
file|"string.h"
end_include

begin_include
include|#
directive|include
file|"opcodes.h"
end_include

begin_include
include|#
directive|include
file|"func.h"
end_include

begin_define
define|#
directive|define
name|HASHSIZE
value|37
end_define

begin_comment
comment|/* size of hash table */
end_comment

begin_decl_stmt
specifier|static
name|int
name|filescope
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* file scope level for static variables */
end_comment

begin_decl_stmt
specifier|static
name|int
name|funcscope
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* function scope level for static variables */
end_comment

begin_decl_stmt
specifier|static
name|STRINGHEAD
name|localnames
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* list of local variable names */
end_comment

begin_decl_stmt
specifier|static
name|STRINGHEAD
name|globalnames
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* list of global variable names */
end_comment

begin_decl_stmt
specifier|static
name|STRINGHEAD
name|paramnames
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* list of parameter variable names */
end_comment

begin_decl_stmt
specifier|static
name|GLOBAL
modifier|*
name|globalhash
index|[
name|HASHSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* hash table for globals */
end_comment

begin_decl_stmt
specifier|static
name|void
name|fitprint
name|MATH_PROTO
argument_list|(
operator|(
name|NUMBER
operator|*
name|num
operator|,
name|long
name|digits
operator|,
name|long
name|width
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|unscope
name|MATH_PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Hash a symbol name so we can find it in the hash table.  * Args are the symbol name and the symbol name size.  */
end_comment

begin_define
define|#
directive|define
name|HASHSYM
parameter_list|(
name|n
parameter_list|,
name|s
parameter_list|)
value|((unsigned)((n)[0]*123 + (n)[s-1]*135 + (s)*157) % HASHSIZE)
end_define

begin_comment
comment|/*  * Initialize the global symbol table.  */
end_comment

begin_function
name|void
name|initglobals
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
comment|/* index counter */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HASHSIZE
condition|;
name|i
operator|++
control|)
name|globalhash
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|initstr
argument_list|(
operator|&
name|globalnames
argument_list|)
expr_stmt|;
name|filescope
operator|=
name|SCOPE_STATIC
expr_stmt|;
name|funcscope
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Define a possibly new global variable which may or may not be static.  * If it did not already exist, it is created with a value of zero.  * The address of the global symbol structure is returned.  */
end_comment

begin_function
name|GLOBAL
modifier|*
name|addglobal
parameter_list|(
name|name
parameter_list|,
name|isstatic
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
comment|/* name of global variable */
name|BOOL
name|isstatic
decl_stmt|;
comment|/* TRUE if symbol is static */
block|{
name|GLOBAL
modifier|*
name|sp
decl_stmt|;
comment|/* current symbol pointer */
name|GLOBAL
modifier|*
modifier|*
name|hp
decl_stmt|;
comment|/* hash table head address */
name|long
name|len
decl_stmt|;
comment|/* length of string */
name|int
name|newfilescope
decl_stmt|;
comment|/* file scope being looked for */
name|int
name|newfuncscope
decl_stmt|;
comment|/* function scope being looked for */
name|newfilescope
operator|=
name|SCOPE_GLOBAL
expr_stmt|;
name|newfuncscope
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|isstatic
condition|)
block|{
name|newfilescope
operator|=
name|filescope
expr_stmt|;
name|newfuncscope
operator|=
name|funcscope
expr_stmt|;
block|}
name|len
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
return|return
name|NULL
return|;
name|hp
operator|=
operator|&
name|globalhash
index|[
name|HASHSYM
argument_list|(
name|name
argument_list|,
name|len
argument_list|)
index|]
expr_stmt|;
for|for
control|(
name|sp
operator|=
operator|*
name|hp
init|;
name|sp
condition|;
name|sp
operator|=
name|sp
operator|->
name|g_next
control|)
block|{
if|if
condition|(
operator|(
name|sp
operator|->
name|g_len
operator|==
name|len
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|sp
operator|->
name|g_name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|sp
operator|->
name|g_filescope
operator|==
name|newfilescope
operator|)
operator|&&
operator|(
name|sp
operator|->
name|g_funcscope
operator|==
name|newfuncscope
operator|)
condition|)
return|return
name|sp
return|;
block|}
name|sp
operator|=
operator|(
name|GLOBAL
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|GLOBAL
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|==
name|NULL
condition|)
return|return
name|sp
return|;
name|sp
operator|->
name|g_name
operator|=
name|addstr
argument_list|(
operator|&
name|globalnames
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|sp
operator|->
name|g_len
operator|=
name|len
expr_stmt|;
name|sp
operator|->
name|g_filescope
operator|=
name|newfilescope
expr_stmt|;
name|sp
operator|->
name|g_funcscope
operator|=
name|newfuncscope
expr_stmt|;
name|sp
operator|->
name|g_value
operator|.
name|v_num
operator|=
name|qlink
argument_list|(
operator|&
name|_qzero_
argument_list|)
expr_stmt|;
name|sp
operator|->
name|g_value
operator|.
name|v_type
operator|=
name|V_NUM
expr_stmt|;
name|sp
operator|->
name|g_next
operator|=
operator|*
name|hp
expr_stmt|;
operator|*
name|hp
operator|=
name|sp
expr_stmt|;
return|return
name|sp
return|;
block|}
end_function

begin_comment
comment|/*  * Look up the name of a global variable and return its address.  * Since the same variable may appear in different scopes, we search  * for the one with the highest function scope value within the current  * file scope level (or which is global).  Returns NULL if the symbol  * was not found.  */
end_comment

begin_function
name|GLOBAL
modifier|*
name|findglobal
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
comment|/* name of global variable */
block|{
name|GLOBAL
modifier|*
name|sp
decl_stmt|;
comment|/* current symbol pointer */
name|GLOBAL
modifier|*
name|bestsp
decl_stmt|;
comment|/* found symbol with highest scope */
name|long
name|len
decl_stmt|;
comment|/* length of string */
name|bestsp
operator|=
name|NULL
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|sp
operator|=
name|globalhash
index|[
name|HASHSYM
argument_list|(
name|name
argument_list|,
name|len
argument_list|)
index|]
init|;
name|sp
condition|;
name|sp
operator|=
name|sp
operator|->
name|g_next
control|)
block|{
if|if
condition|(
operator|(
name|sp
operator|->
name|g_len
operator|!=
name|len
operator|)
operator|||
name|strcmp
argument_list|(
name|sp
operator|->
name|g_name
argument_list|,
name|name
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|sp
operator|->
name|g_filescope
operator|==
name|SCOPE_GLOBAL
condition|)
block|{
if|if
condition|(
name|bestsp
operator|==
name|NULL
condition|)
name|bestsp
operator|=
name|sp
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|sp
operator|->
name|g_filescope
operator|!=
name|filescope
condition|)
continue|continue;
if|if
condition|(
operator|(
name|bestsp
operator|==
name|NULL
operator|)
operator|||
operator|(
name|sp
operator|->
name|g_funcscope
operator|>
name|bestsp
operator|->
name|g_funcscope
operator|)
condition|)
name|bestsp
operator|=
name|sp
expr_stmt|;
block|}
return|return
name|bestsp
return|;
block|}
end_function

begin_comment
comment|/*  * Return the name of a global variable given its address.  */
end_comment

begin_function
name|char
modifier|*
name|globalname
parameter_list|(
name|sp
parameter_list|)
name|GLOBAL
modifier|*
name|sp
decl_stmt|;
comment|/* address of global pointer */
block|{
if|if
condition|(
name|sp
condition|)
return|return
name|sp
operator|->
name|g_name
return|;
return|return
literal|""
return|;
block|}
end_function

begin_comment
comment|/*  * Show the value of all global variables, typing only the head and  * tail of very large numbers.  Only truly global symbols are shown.  */
end_comment

begin_function
name|void
name|showglobals
parameter_list|()
block|{
name|GLOBAL
modifier|*
modifier|*
name|hp
decl_stmt|;
comment|/* hash table head address */
specifier|register
name|GLOBAL
modifier|*
name|sp
decl_stmt|;
comment|/* current global symbol pointer */
name|long
name|count
decl_stmt|;
comment|/* number of global variables shown */
name|NUMBER
modifier|*
name|num
decl_stmt|,
modifier|*
name|den
decl_stmt|;
name|long
name|digits
decl_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|hp
operator|=
operator|&
name|globalhash
index|[
name|HASHSIZE
operator|-
literal|1
index|]
init|;
name|hp
operator|>=
name|globalhash
condition|;
name|hp
operator|--
control|)
block|{
for|for
control|(
name|sp
operator|=
operator|*
name|hp
init|;
name|sp
condition|;
name|sp
operator|=
name|sp
operator|->
name|g_next
control|)
block|{
if|if
condition|(
name|sp
operator|->
name|g_value
operator|.
name|v_type
operator|!=
name|V_NUM
condition|)
continue|continue;
if|if
condition|(
name|sp
operator|->
name|g_filescope
operator|!=
name|SCOPE_GLOBAL
condition|)
continue|continue;
if|if
condition|(
name|count
operator|++
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"\nName    Digits  Value\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"----    ------  -----\n"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"%-8s "
argument_list|,
name|sp
operator|->
name|g_name
argument_list|)
expr_stmt|;
name|num
operator|=
name|qnum
argument_list|(
name|sp
operator|->
name|g_value
operator|.
name|v_num
argument_list|)
expr_stmt|;
name|digits
operator|=
name|qdigits
argument_list|(
name|num
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%-7ld "
argument_list|,
name|digits
argument_list|)
expr_stmt|;
name|fitprint
argument_list|(
name|num
argument_list|,
name|digits
argument_list|,
literal|60L
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|num
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|qisint
argument_list|(
name|sp
operator|->
name|g_value
operator|.
name|v_num
argument_list|)
condition|)
block|{
name|den
operator|=
name|qden
argument_list|(
name|sp
operator|->
name|g_value
operator|.
name|v_num
argument_list|)
expr_stmt|;
name|digits
operator|=
name|qdigits
argument_list|(
name|den
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n	%-6ld /"
argument_list|,
name|digits
argument_list|)
expr_stmt|;
name|fitprint
argument_list|(
name|den
argument_list|,
name|digits
argument_list|,
literal|60L
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|den
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
name|printf
argument_list|(
name|count
condition|?
literal|"\n"
else|:
literal|"No global variables defined.\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Print an integer which is guaranteed to fit in the specified number  * of columns, using imbedded '...' characters if it is too large.  */
end_comment

begin_function
specifier|static
name|void
name|fitprint
parameter_list|(
name|num
parameter_list|,
name|digits
parameter_list|,
name|width
parameter_list|)
name|NUMBER
modifier|*
name|num
decl_stmt|;
comment|/* number to print */
name|long
name|digits
decl_stmt|,
name|width
decl_stmt|;
block|{
name|long
name|show
decl_stmt|,
name|used
decl_stmt|;
name|NUMBER
modifier|*
name|p
decl_stmt|,
modifier|*
name|t
decl_stmt|,
modifier|*
name|div
decl_stmt|,
modifier|*
name|val
decl_stmt|;
if|if
condition|(
name|digits
operator|<=
name|width
condition|)
block|{
name|qprintf
argument_list|(
literal|"%r"
argument_list|,
name|num
argument_list|)
expr_stmt|;
return|return;
block|}
name|show
operator|=
operator|(
name|width
operator|/
literal|2
operator|)
operator|-
literal|2
expr_stmt|;
name|t
operator|=
name|itoq
argument_list|(
literal|10L
argument_list|)
expr_stmt|;
name|p
operator|=
name|itoq
argument_list|(
call|(
name|long
call|)
argument_list|(
name|digits
operator|-
name|show
argument_list|)
argument_list|)
expr_stmt|;
name|div
operator|=
name|qpowi
argument_list|(
name|t
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|val
operator|=
name|qquo
argument_list|(
name|num
argument_list|,
name|div
argument_list|)
expr_stmt|;
name|qprintf
argument_list|(
literal|"%r..."
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|div
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|p
operator|=
name|itoq
argument_list|(
name|show
argument_list|)
expr_stmt|;
name|div
operator|=
name|qpowi
argument_list|(
name|t
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|val
operator|=
name|qmod
argument_list|(
name|num
argument_list|,
name|div
argument_list|)
expr_stmt|;
name|used
operator|=
name|qdigits
argument_list|(
name|val
argument_list|)
expr_stmt|;
while|while
condition|(
name|used
operator|++
operator|<
name|show
condition|)
name|printf
argument_list|(
literal|"0"
argument_list|)
expr_stmt|;
name|qprintf
argument_list|(
literal|"%r"
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|div
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Write all normal global variables to an output file.  * Note: Currently only simple types are saved.  * Returns nonzero on error.  */
end_comment

begin_function
name|int
name|writeglobals
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
name|GLOBAL
modifier|*
modifier|*
name|hp
decl_stmt|;
comment|/* hash table head address */
specifier|register
name|GLOBAL
modifier|*
name|sp
decl_stmt|;
comment|/* current global symbol pointer */
name|int
name|savemode
decl_stmt|;
comment|/* saved output mode */
name|fp
operator|=
name|f_open
argument_list|(
name|name
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
return|return
literal|1
return|;
name|math_setfp
argument_list|(
name|fp
argument_list|)
expr_stmt|;
for|for
control|(
name|hp
operator|=
operator|&
name|globalhash
index|[
name|HASHSIZE
operator|-
literal|1
index|]
init|;
name|hp
operator|>=
name|globalhash
condition|;
name|hp
operator|--
control|)
block|{
for|for
control|(
name|sp
operator|=
operator|*
name|hp
init|;
name|sp
condition|;
name|sp
operator|=
name|sp
operator|->
name|g_next
control|)
block|{
switch|switch
condition|(
name|sp
operator|->
name|g_value
operator|.
name|v_type
condition|)
block|{
case|case
name|V_NUM
case|:
case|case
name|V_COM
case|:
case|case
name|V_STR
case|:
break|break;
default|default:
continue|continue;
block|}
name|math_fmt
argument_list|(
literal|"%s = "
argument_list|,
name|sp
operator|->
name|g_name
argument_list|)
expr_stmt|;
name|savemode
operator|=
name|math_setmode
argument_list|(
name|MODE_HEX
argument_list|)
expr_stmt|;
name|printvalue
argument_list|(
operator|&
name|sp
operator|->
name|g_value
argument_list|,
name|PRINT_UNAMBIG
argument_list|)
expr_stmt|;
name|math_setmode
argument_list|(
name|savemode
argument_list|)
expr_stmt|;
name|math_str
argument_list|(
literal|";\n"
argument_list|)
expr_stmt|;
block|}
block|}
name|math_setfp
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|fp
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Reset the file and function scope levels back to the original values.  * This is called on errors to forget any static variables which were being  * defined.  */
end_comment

begin_function
name|void
name|resetscopes
parameter_list|()
block|{
name|filescope
operator|=
name|SCOPE_STATIC
expr_stmt|;
name|funcscope
operator|=
literal|0
expr_stmt|;
name|unscope
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Enter a new file scope level so that newly defined static variables  * will have the appropriate scope, and so that previously defined static  * variables will temporarily be unaccessible.  This should only be called  * when the function scope level is zero.  */
end_comment

begin_function
name|void
name|enterfilescope
parameter_list|()
block|{
name|filescope
operator|++
expr_stmt|;
name|funcscope
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Exit from a file scope level.  This deletes from the global symbol table  * all of the static variables that were defined within this file scope level.  * The function scope level is also reset to zero.  */
end_comment

begin_function
name|void
name|exitfilescope
parameter_list|()
block|{
if|if
condition|(
name|filescope
operator|>
name|SCOPE_STATIC
condition|)
name|filescope
operator|--
expr_stmt|;
name|funcscope
operator|=
literal|0
expr_stmt|;
name|unscope
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Enter a new function scope level within the current file scope level.  * This allows newly defined static variables to override previously defined  * static variables in the same file scope level.  */
end_comment

begin_function
name|void
name|enterfuncscope
parameter_list|()
block|{
name|funcscope
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Exit from a function scope level.  This deletes static symbols which were  * defined within the current function scope level, and makes previously  * defined symbols with the same name within the same file scope level  * accessible again.  */
end_comment

begin_function
name|void
name|exitfuncscope
parameter_list|()
block|{
if|if
condition|(
name|funcscope
operator|>
literal|0
condition|)
name|funcscope
operator|--
expr_stmt|;
name|unscope
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Remove all the symbols from the global symbol table which have file or  * function scopes larger than the current scope levels.  Their memory  * remains allocated since their values still actually exist.  */
end_comment

begin_function
specifier|static
name|void
name|unscope
parameter_list|()
block|{
name|GLOBAL
modifier|*
modifier|*
name|hp
decl_stmt|;
comment|/* hash table head address */
specifier|register
name|GLOBAL
modifier|*
name|sp
decl_stmt|;
comment|/* current global symbol pointer */
name|GLOBAL
modifier|*
name|prevsp
decl_stmt|;
comment|/* previous kept symbol pointer */
for|for
control|(
name|hp
operator|=
operator|&
name|globalhash
index|[
name|HASHSIZE
operator|-
literal|1
index|]
init|;
name|hp
operator|>=
name|globalhash
condition|;
name|hp
operator|--
control|)
block|{
name|prevsp
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|sp
operator|=
operator|*
name|hp
init|;
name|sp
condition|;
name|sp
operator|=
name|sp
operator|->
name|g_next
control|)
block|{
if|if
condition|(
operator|(
name|sp
operator|->
name|g_filescope
operator|==
name|SCOPE_GLOBAL
operator|)
operator|||
operator|(
name|sp
operator|->
name|g_filescope
operator|<
name|filescope
operator|)
operator|||
operator|(
operator|(
name|sp
operator|->
name|g_filescope
operator|==
name|filescope
operator|)
operator|&&
operator|(
name|sp
operator|->
name|g_funcscope
operator|<=
name|funcscope
operator|)
operator|)
condition|)
block|{
name|prevsp
operator|=
name|sp
expr_stmt|;
continue|continue;
block|}
comment|/* 			 * This symbol needs removing. 			 */
if|if
condition|(
name|prevsp
condition|)
name|prevsp
operator|->
name|g_next
operator|=
name|sp
operator|->
name|g_next
expr_stmt|;
else|else
operator|*
name|hp
operator|=
name|sp
operator|->
name|g_next
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Initialize the local and parameter symbol table information.  */
end_comment

begin_function
name|void
name|initlocals
parameter_list|()
block|{
name|initstr
argument_list|(
operator|&
name|localnames
argument_list|)
expr_stmt|;
name|initstr
argument_list|(
operator|&
name|paramnames
argument_list|)
expr_stmt|;
name|curfunc
operator|->
name|f_localcount
operator|=
literal|0
expr_stmt|;
name|curfunc
operator|->
name|f_paramcount
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Add a possibly new local variable definition.  * Returns the index of the variable into the local symbol table.  * Minus one indicates the symbol could not be added.  */
end_comment

begin_function
name|long
name|addlocal
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
comment|/* name of local variable */
block|{
name|long
name|index
decl_stmt|;
comment|/* current symbol index */
name|index
operator|=
name|findstr
argument_list|(
operator|&
name|localnames
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|>=
literal|0
condition|)
return|return
name|index
return|;
name|index
operator|=
name|localnames
operator|.
name|h_count
expr_stmt|;
operator|(
name|void
operator|)
name|addstr
argument_list|(
operator|&
name|localnames
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|curfunc
operator|->
name|f_localcount
operator|++
expr_stmt|;
return|return
name|index
return|;
block|}
end_function

begin_comment
comment|/*  * Find a local variable name and return its index.  * Returns minus one if the variable name is not defined.  */
end_comment

begin_function
name|long
name|findlocal
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
comment|/* name of local variable */
block|{
return|return
name|findstr
argument_list|(
operator|&
name|localnames
argument_list|,
name|name
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return the name of a local variable.  */
end_comment

begin_function
name|char
modifier|*
name|localname
parameter_list|(
name|n
parameter_list|)
name|long
name|n
decl_stmt|;
block|{
return|return
name|namestr
argument_list|(
operator|&
name|localnames
argument_list|,
name|n
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Add a possibly new parameter variable definition.  * Returns the index of the variable into the parameter symbol table.  * Minus one indicates the symbol could not be added.  */
end_comment

begin_function
name|long
name|addparam
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
comment|/* name of parameter variable */
block|{
name|long
name|index
decl_stmt|;
comment|/* current symbol index */
name|index
operator|=
name|findstr
argument_list|(
operator|&
name|paramnames
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|>=
literal|0
condition|)
return|return
name|index
return|;
name|index
operator|=
name|paramnames
operator|.
name|h_count
expr_stmt|;
operator|(
name|void
operator|)
name|addstr
argument_list|(
operator|&
name|paramnames
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|curfunc
operator|->
name|f_paramcount
operator|++
expr_stmt|;
return|return
name|index
return|;
block|}
end_function

begin_comment
comment|/*  * Find a parameter variable name and return its index.  * Returns minus one if the variable name is not defined.  */
end_comment

begin_function
name|long
name|findparam
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
comment|/* name of parameter variable */
block|{
return|return
name|findstr
argument_list|(
operator|&
name|paramnames
argument_list|,
name|name
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return the name of a parameter variable.  */
end_comment

begin_function
name|char
modifier|*
name|paramname
parameter_list|(
name|n
parameter_list|)
name|long
name|n
decl_stmt|;
block|{
return|return
name|namestr
argument_list|(
operator|&
name|paramnames
argument_list|,
name|n
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return the type of a variable name.  * This is either local, parameter, global, static, or undefined.  */
end_comment

begin_function
name|int
name|symboltype
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
comment|/* variable name to find */
block|{
name|GLOBAL
modifier|*
name|sp
decl_stmt|;
if|if
condition|(
name|findlocal
argument_list|(
name|name
argument_list|)
operator|>=
literal|0
condition|)
return|return
name|SYM_LOCAL
return|;
if|if
condition|(
name|findparam
argument_list|(
name|name
argument_list|)
operator|>=
literal|0
condition|)
return|return
name|SYM_PARAM
return|;
name|sp
operator|=
name|findglobal
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
condition|)
block|{
if|if
condition|(
name|sp
operator|->
name|g_filescope
operator|==
name|SCOPE_GLOBAL
condition|)
return|return
name|SYM_GLOBAL
return|;
return|return
name|SYM_STATIC
return|;
block|}
return|return
name|SYM_UNDEFINED
return|;
block|}
end_function

begin_comment
comment|/* END CODE */
end_comment

end_unit

