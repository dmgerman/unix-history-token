begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1994 David I. Bell  * Permission is granted to use, distribute, or modify this source,  * provided that this copyright notice remains intact.  *  * Extended precision rational arithmetic primitive routines  */
end_comment

begin_include
include|#
directive|include
file|"qmath.h"
end_include

begin_decl_stmt
name|NUMBER
name|_qzero_
init|=
block|{
block|{
name|_zeroval_
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
name|_oneval_
block|,
literal|1
block|,
literal|0
block|}
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|NUMBER
name|_qone_
init|=
block|{
block|{
name|_oneval_
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
name|_oneval_
block|,
literal|1
block|,
literal|0
block|}
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|NUMBER
name|_qtwo_
init|=
block|{
block|{
name|_twoval_
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
name|_oneval_
block|,
literal|1
block|,
literal|0
block|}
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|NUMBER
name|_qten_
init|=
block|{
block|{
name|_tenval_
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
name|_oneval_
block|,
literal|1
block|,
literal|0
block|}
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|NUMBER
name|_qnegone_
init|=
block|{
block|{
name|_oneval_
block|,
literal|1
block|,
literal|1
block|}
block|,
block|{
name|_oneval_
block|,
literal|1
block|,
literal|0
block|}
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|NUMBER
name|_qonehalf_
init|=
block|{
block|{
name|_oneval_
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
name|_twoval_
block|,
literal|1
block|,
literal|0
block|}
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Create another copy of a number.  *	q2 = qcopy(q1);  */
end_comment

begin_function
name|NUMBER
modifier|*
name|qcopy
parameter_list|(
name|q
parameter_list|)
specifier|register
name|NUMBER
modifier|*
name|q
decl_stmt|;
block|{
specifier|register
name|NUMBER
modifier|*
name|r
decl_stmt|;
name|r
operator|=
name|qalloc
argument_list|()
expr_stmt|;
name|r
operator|->
name|num
operator|.
name|sign
operator|=
name|q
operator|->
name|num
operator|.
name|sign
expr_stmt|;
if|if
condition|(
operator|!
name|zisunit
argument_list|(
name|q
operator|->
name|num
argument_list|)
condition|)
block|{
name|r
operator|->
name|num
operator|.
name|len
operator|=
name|q
operator|->
name|num
operator|.
name|len
expr_stmt|;
name|r
operator|->
name|num
operator|.
name|v
operator|=
name|alloc
argument_list|(
name|r
operator|->
name|num
operator|.
name|len
argument_list|)
expr_stmt|;
name|zcopyval
argument_list|(
name|q
operator|->
name|num
argument_list|,
name|r
operator|->
name|num
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|zisunit
argument_list|(
name|q
operator|->
name|den
argument_list|)
condition|)
block|{
name|r
operator|->
name|den
operator|.
name|len
operator|=
name|q
operator|->
name|den
operator|.
name|len
expr_stmt|;
name|r
operator|->
name|den
operator|.
name|v
operator|=
name|alloc
argument_list|(
name|r
operator|->
name|den
operator|.
name|len
argument_list|)
expr_stmt|;
name|zcopyval
argument_list|(
name|q
operator|->
name|den
argument_list|,
name|r
operator|->
name|den
argument_list|)
expr_stmt|;
block|}
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/*  * Convert a number to a normal integer.  *	i = qtoi(q);  */
end_comment

begin_function
name|long
name|qtoi
parameter_list|(
name|q
parameter_list|)
specifier|register
name|NUMBER
modifier|*
name|q
decl_stmt|;
block|{
name|long
name|i
decl_stmt|;
name|ZVALUE
name|res
decl_stmt|;
if|if
condition|(
name|qisint
argument_list|(
name|q
argument_list|)
condition|)
return|return
name|ztoi
argument_list|(
name|q
operator|->
name|num
argument_list|)
return|;
name|zquo
argument_list|(
name|q
operator|->
name|num
argument_list|,
name|q
operator|->
name|den
argument_list|,
operator|&
name|res
argument_list|)
expr_stmt|;
name|i
operator|=
name|ztoi
argument_list|(
name|res
argument_list|)
expr_stmt|;
name|zfree
argument_list|(
name|res
argument_list|)
expr_stmt|;
return|return
name|i
return|;
block|}
end_function

begin_comment
comment|/*  * Convert a normal integer into a number.  *	q = itoq(i);  */
end_comment

begin_function
name|NUMBER
modifier|*
name|itoq
parameter_list|(
name|i
parameter_list|)
name|long
name|i
decl_stmt|;
block|{
specifier|register
name|NUMBER
modifier|*
name|q
decl_stmt|;
if|if
condition|(
operator|(
name|i
operator|>=
operator|-
literal|1
operator|)
operator|&&
operator|(
name|i
operator|<=
literal|10
operator|)
condition|)
block|{
switch|switch
condition|(
operator|(
name|int
operator|)
name|i
condition|)
block|{
case|case
literal|0
case|:
name|q
operator|=
operator|&
name|_qzero_
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|q
operator|=
operator|&
name|_qone_
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|q
operator|=
operator|&
name|_qtwo_
expr_stmt|;
break|break;
case|case
literal|10
case|:
name|q
operator|=
operator|&
name|_qten_
expr_stmt|;
break|break;
case|case
operator|-
literal|1
case|:
name|q
operator|=
operator|&
name|_qnegone_
expr_stmt|;
break|break;
default|default:
name|q
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|q
condition|)
return|return
name|qlink
argument_list|(
name|q
argument_list|)
return|;
block|}
name|q
operator|=
name|qalloc
argument_list|()
expr_stmt|;
name|itoz
argument_list|(
name|i
argument_list|,
operator|&
name|q
operator|->
name|num
argument_list|)
expr_stmt|;
return|return
name|q
return|;
block|}
end_function

begin_comment
comment|/*  * Create a number from the given integral numerator and denominator.  *	q = iitoq(inum, iden);  */
end_comment

begin_function
name|NUMBER
modifier|*
name|iitoq
parameter_list|(
name|inum
parameter_list|,
name|iden
parameter_list|)
name|long
name|inum
decl_stmt|,
name|iden
decl_stmt|;
block|{
specifier|register
name|NUMBER
modifier|*
name|q
decl_stmt|;
name|long
name|d
decl_stmt|;
name|BOOL
name|sign
decl_stmt|;
if|if
condition|(
name|iden
operator|==
literal|0
condition|)
name|math_error
argument_list|(
literal|"Division by zero"
argument_list|)
expr_stmt|;
if|if
condition|(
name|inum
operator|==
literal|0
condition|)
return|return
name|qlink
argument_list|(
operator|&
name|_qzero_
argument_list|)
return|;
name|sign
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|inum
operator|<
literal|0
condition|)
block|{
name|sign
operator|=
literal|1
expr_stmt|;
name|inum
operator|=
operator|-
name|inum
expr_stmt|;
block|}
if|if
condition|(
name|iden
operator|<
literal|0
condition|)
block|{
name|sign
operator|=
literal|1
operator|-
name|sign
expr_stmt|;
name|iden
operator|=
operator|-
name|iden
expr_stmt|;
block|}
name|d
operator|=
name|iigcd
argument_list|(
name|inum
argument_list|,
name|iden
argument_list|)
expr_stmt|;
name|inum
operator|/=
name|d
expr_stmt|;
name|iden
operator|/=
name|d
expr_stmt|;
if|if
condition|(
name|iden
operator|==
literal|1
condition|)
return|return
name|itoq
argument_list|(
name|sign
condition|?
operator|-
name|inum
else|:
name|inum
argument_list|)
return|;
name|q
operator|=
name|qalloc
argument_list|()
expr_stmt|;
if|if
condition|(
name|inum
operator|!=
literal|1
condition|)
name|itoz
argument_list|(
name|inum
argument_list|,
operator|&
name|q
operator|->
name|num
argument_list|)
expr_stmt|;
name|itoz
argument_list|(
name|iden
argument_list|,
operator|&
name|q
operator|->
name|den
argument_list|)
expr_stmt|;
name|q
operator|->
name|num
operator|.
name|sign
operator|=
name|sign
expr_stmt|;
return|return
name|q
return|;
block|}
end_function

begin_comment
comment|/*  * Add two numbers to each other.  *	q3 = qadd(q1, q2);  */
end_comment

begin_function
name|NUMBER
modifier|*
name|qadd
parameter_list|(
name|q1
parameter_list|,
name|q2
parameter_list|)
specifier|register
name|NUMBER
modifier|*
name|q1
decl_stmt|,
decl|*
name|q2
decl_stmt|;
end_function

begin_block
block|{
name|NUMBER
modifier|*
name|r
decl_stmt|;
name|ZVALUE
name|t1
decl_stmt|,
name|t2
decl_stmt|,
name|temp
decl_stmt|,
name|d1
decl_stmt|,
name|d2
decl_stmt|,
name|vpd1
decl_stmt|,
name|upd1
decl_stmt|;
if|if
condition|(
name|qiszero
argument_list|(
name|q1
argument_list|)
condition|)
return|return
name|qlink
argument_list|(
name|q2
argument_list|)
return|;
if|if
condition|(
name|qiszero
argument_list|(
name|q2
argument_list|)
condition|)
return|return
name|qlink
argument_list|(
name|q1
argument_list|)
return|;
name|r
operator|=
name|qalloc
argument_list|()
expr_stmt|;
comment|/* 	 * If either number is an integer, then the result is easy. 	 */
if|if
condition|(
name|qisint
argument_list|(
name|q1
argument_list|)
operator|&&
name|qisint
argument_list|(
name|q2
argument_list|)
condition|)
block|{
name|zadd
argument_list|(
name|q1
operator|->
name|num
argument_list|,
name|q2
operator|->
name|num
argument_list|,
operator|&
name|r
operator|->
name|num
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
if|if
condition|(
name|qisint
argument_list|(
name|q2
argument_list|)
condition|)
block|{
name|zmul
argument_list|(
name|q1
operator|->
name|den
argument_list|,
name|q2
operator|->
name|num
argument_list|,
operator|&
name|temp
argument_list|)
expr_stmt|;
name|zadd
argument_list|(
name|q1
operator|->
name|num
argument_list|,
name|temp
argument_list|,
operator|&
name|r
operator|->
name|num
argument_list|)
expr_stmt|;
name|zfree
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|zcopy
argument_list|(
name|q1
operator|->
name|den
argument_list|,
operator|&
name|r
operator|->
name|den
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
if|if
condition|(
name|qisint
argument_list|(
name|q1
argument_list|)
condition|)
block|{
name|zmul
argument_list|(
name|q2
operator|->
name|den
argument_list|,
name|q1
operator|->
name|num
argument_list|,
operator|&
name|temp
argument_list|)
expr_stmt|;
name|zadd
argument_list|(
name|q2
operator|->
name|num
argument_list|,
name|temp
argument_list|,
operator|&
name|r
operator|->
name|num
argument_list|)
expr_stmt|;
name|zfree
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|zcopy
argument_list|(
name|q2
operator|->
name|den
argument_list|,
operator|&
name|r
operator|->
name|den
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
comment|/* 	 * Both arguments are true fractions, so we need more work. 	 * If the denominators are relatively prime, then the answer is the 	 * straightforward cross product result with no need for reduction. 	 */
name|zgcd
argument_list|(
name|q1
operator|->
name|den
argument_list|,
name|q2
operator|->
name|den
argument_list|,
operator|&
name|d1
argument_list|)
expr_stmt|;
if|if
condition|(
name|zisunit
argument_list|(
name|d1
argument_list|)
condition|)
block|{
name|zfree
argument_list|(
name|d1
argument_list|)
expr_stmt|;
name|zmul
argument_list|(
name|q1
operator|->
name|num
argument_list|,
name|q2
operator|->
name|den
argument_list|,
operator|&
name|t1
argument_list|)
expr_stmt|;
name|zmul
argument_list|(
name|q1
operator|->
name|den
argument_list|,
name|q2
operator|->
name|num
argument_list|,
operator|&
name|t2
argument_list|)
expr_stmt|;
name|zadd
argument_list|(
name|t1
argument_list|,
name|t2
argument_list|,
operator|&
name|r
operator|->
name|num
argument_list|)
expr_stmt|;
name|zfree
argument_list|(
name|t1
argument_list|)
expr_stmt|;
name|zfree
argument_list|(
name|t2
argument_list|)
expr_stmt|;
name|zmul
argument_list|(
name|q1
operator|->
name|den
argument_list|,
name|q2
operator|->
name|den
argument_list|,
operator|&
name|r
operator|->
name|den
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
comment|/* 	 * The calculation is now more complicated. 	 * See Knuth Vol 2 for details. 	 */
name|zquo
argument_list|(
name|q2
operator|->
name|den
argument_list|,
name|d1
argument_list|,
operator|&
name|vpd1
argument_list|)
expr_stmt|;
name|zquo
argument_list|(
name|q1
operator|->
name|den
argument_list|,
name|d1
argument_list|,
operator|&
name|upd1
argument_list|)
expr_stmt|;
name|zmul
argument_list|(
name|q1
operator|->
name|num
argument_list|,
name|vpd1
argument_list|,
operator|&
name|t1
argument_list|)
expr_stmt|;
name|zmul
argument_list|(
name|q2
operator|->
name|num
argument_list|,
name|upd1
argument_list|,
operator|&
name|t2
argument_list|)
expr_stmt|;
name|zadd
argument_list|(
name|t1
argument_list|,
name|t2
argument_list|,
operator|&
name|temp
argument_list|)
expr_stmt|;
name|zfree
argument_list|(
name|t1
argument_list|)
expr_stmt|;
name|zfree
argument_list|(
name|t2
argument_list|)
expr_stmt|;
name|zfree
argument_list|(
name|vpd1
argument_list|)
expr_stmt|;
name|zgcd
argument_list|(
name|temp
argument_list|,
name|d1
argument_list|,
operator|&
name|d2
argument_list|)
expr_stmt|;
name|zfree
argument_list|(
name|d1
argument_list|)
expr_stmt|;
if|if
condition|(
name|zisunit
argument_list|(
name|d2
argument_list|)
condition|)
block|{
name|zfree
argument_list|(
name|d2
argument_list|)
expr_stmt|;
name|r
operator|->
name|num
operator|=
name|temp
expr_stmt|;
name|zmul
argument_list|(
name|upd1
argument_list|,
name|q2
operator|->
name|den
argument_list|,
operator|&
name|r
operator|->
name|den
argument_list|)
expr_stmt|;
name|zfree
argument_list|(
name|upd1
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
name|zquo
argument_list|(
name|temp
argument_list|,
name|d2
argument_list|,
operator|&
name|r
operator|->
name|num
argument_list|)
expr_stmt|;
name|zfree
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|zquo
argument_list|(
name|q2
operator|->
name|den
argument_list|,
name|d2
argument_list|,
operator|&
name|temp
argument_list|)
expr_stmt|;
name|zfree
argument_list|(
name|d2
argument_list|)
expr_stmt|;
name|zmul
argument_list|(
name|temp
argument_list|,
name|upd1
argument_list|,
operator|&
name|r
operator|->
name|den
argument_list|)
expr_stmt|;
name|zfree
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|zfree
argument_list|(
name|upd1
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_block

begin_comment
comment|/*  * Subtract one number from another.  *	q3 = qsub(q1, q2);  */
end_comment

begin_function
name|NUMBER
modifier|*
name|qsub
parameter_list|(
name|q1
parameter_list|,
name|q2
parameter_list|)
specifier|register
name|NUMBER
modifier|*
name|q1
decl_stmt|,
decl|*
name|q2
decl_stmt|;
end_function

begin_block
block|{
name|NUMBER
modifier|*
name|r
decl_stmt|;
if|if
condition|(
name|q1
operator|==
name|q2
condition|)
return|return
name|qlink
argument_list|(
operator|&
name|_qzero_
argument_list|)
return|;
if|if
condition|(
name|qiszero
argument_list|(
name|q2
argument_list|)
condition|)
return|return
name|qlink
argument_list|(
name|q1
argument_list|)
return|;
if|if
condition|(
name|qisint
argument_list|(
name|q1
argument_list|)
operator|&&
name|qisint
argument_list|(
name|q2
argument_list|)
condition|)
block|{
name|r
operator|=
name|qalloc
argument_list|()
expr_stmt|;
name|zsub
argument_list|(
name|q1
operator|->
name|num
argument_list|,
name|q2
operator|->
name|num
argument_list|,
operator|&
name|r
operator|->
name|num
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
name|q2
operator|=
name|qneg
argument_list|(
name|q2
argument_list|)
expr_stmt|;
if|if
condition|(
name|qiszero
argument_list|(
name|q1
argument_list|)
condition|)
return|return
name|q2
return|;
name|r
operator|=
name|qadd
argument_list|(
name|q1
argument_list|,
name|q2
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|q2
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_block

begin_comment
comment|/*  * Increment a number by one.  */
end_comment

begin_function
name|NUMBER
modifier|*
name|qinc
parameter_list|(
name|q
parameter_list|)
name|NUMBER
modifier|*
name|q
decl_stmt|;
block|{
name|NUMBER
modifier|*
name|r
decl_stmt|;
name|r
operator|=
name|qalloc
argument_list|()
expr_stmt|;
if|if
condition|(
name|qisint
argument_list|(
name|q
argument_list|)
condition|)
block|{
name|zadd
argument_list|(
name|q
operator|->
name|num
argument_list|,
name|_one_
argument_list|,
operator|&
name|r
operator|->
name|num
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
name|zadd
argument_list|(
name|q
operator|->
name|num
argument_list|,
name|q
operator|->
name|den
argument_list|,
operator|&
name|r
operator|->
name|num
argument_list|)
expr_stmt|;
name|zcopy
argument_list|(
name|q
operator|->
name|den
argument_list|,
operator|&
name|r
operator|->
name|den
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/*  * Decrement a number by one.  */
end_comment

begin_function
name|NUMBER
modifier|*
name|qdec
parameter_list|(
name|q
parameter_list|)
name|NUMBER
modifier|*
name|q
decl_stmt|;
block|{
name|NUMBER
modifier|*
name|r
decl_stmt|;
name|r
operator|=
name|qalloc
argument_list|()
expr_stmt|;
if|if
condition|(
name|qisint
argument_list|(
name|q
argument_list|)
condition|)
block|{
name|zsub
argument_list|(
name|q
operator|->
name|num
argument_list|,
name|_one_
argument_list|,
operator|&
name|r
operator|->
name|num
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
name|zsub
argument_list|(
name|q
operator|->
name|num
argument_list|,
name|q
operator|->
name|den
argument_list|,
operator|&
name|r
operator|->
name|num
argument_list|)
expr_stmt|;
name|zcopy
argument_list|(
name|q
operator|->
name|den
argument_list|,
operator|&
name|r
operator|->
name|den
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/*  * Add a normal small integer value to an arbitrary number.  */
end_comment

begin_function
name|NUMBER
modifier|*
name|qaddi
parameter_list|(
name|q1
parameter_list|,
name|n
parameter_list|)
name|NUMBER
modifier|*
name|q1
decl_stmt|;
name|long
name|n
decl_stmt|;
block|{
name|NUMBER
name|addnum
decl_stmt|;
comment|/* temporary number */
name|HALF
name|addval
index|[
literal|2
index|]
decl_stmt|;
comment|/* value of small number */
name|BOOL
name|neg
decl_stmt|;
comment|/* TRUE if number is neg */
if|if
condition|(
name|n
operator|==
literal|0
condition|)
return|return
name|qlink
argument_list|(
name|q1
argument_list|)
return|;
if|if
condition|(
name|n
operator|==
literal|1
condition|)
return|return
name|qinc
argument_list|(
name|q1
argument_list|)
return|;
if|if
condition|(
name|n
operator|==
operator|-
literal|1
condition|)
return|return
name|qdec
argument_list|(
name|q1
argument_list|)
return|;
if|if
condition|(
name|qiszero
argument_list|(
name|q1
argument_list|)
condition|)
return|return
name|itoq
argument_list|(
name|n
argument_list|)
return|;
name|addnum
operator|.
name|num
operator|.
name|sign
operator|=
literal|0
expr_stmt|;
name|addnum
operator|.
name|num
operator|.
name|len
operator|=
literal|1
expr_stmt|;
name|addnum
operator|.
name|num
operator|.
name|v
operator|=
name|addval
expr_stmt|;
name|addnum
operator|.
name|den
operator|=
name|_one_
expr_stmt|;
name|neg
operator|=
operator|(
name|n
operator|<
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|neg
condition|)
name|n
operator|=
operator|-
name|n
expr_stmt|;
name|addval
index|[
literal|0
index|]
operator|=
operator|(
name|HALF
operator|)
name|n
expr_stmt|;
name|n
operator|=
operator|(
operator|(
operator|(
name|FULL
operator|)
name|n
operator|)
operator|>>
name|BASEB
operator|)
expr_stmt|;
if|if
condition|(
name|n
condition|)
block|{
name|addval
index|[
literal|1
index|]
operator|=
operator|(
name|HALF
operator|)
name|n
expr_stmt|;
name|addnum
operator|.
name|num
operator|.
name|len
operator|=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|neg
condition|)
return|return
name|qsub
argument_list|(
name|q1
argument_list|,
operator|&
name|addnum
argument_list|)
return|;
else|else
return|return
name|qadd
argument_list|(
name|q1
argument_list|,
operator|&
name|addnum
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Multiply two numbers.  *	q3 = qmul(q1, q2);  */
end_comment

begin_function
name|NUMBER
modifier|*
name|qmul
parameter_list|(
name|q1
parameter_list|,
name|q2
parameter_list|)
specifier|register
name|NUMBER
modifier|*
name|q1
decl_stmt|,
decl|*
name|q2
decl_stmt|;
end_function

begin_block
block|{
name|NUMBER
modifier|*
name|r
decl_stmt|;
comment|/* returned value */
name|ZVALUE
name|n1
decl_stmt|,
name|n2
decl_stmt|,
name|d1
decl_stmt|,
name|d2
decl_stmt|;
comment|/* numerators and denominators */
name|ZVALUE
name|tmp
decl_stmt|;
if|if
condition|(
name|qiszero
argument_list|(
name|q1
argument_list|)
operator|||
name|qiszero
argument_list|(
name|q2
argument_list|)
condition|)
return|return
name|qlink
argument_list|(
operator|&
name|_qzero_
argument_list|)
return|;
if|if
condition|(
name|qisone
argument_list|(
name|q1
argument_list|)
condition|)
return|return
name|qlink
argument_list|(
name|q2
argument_list|)
return|;
if|if
condition|(
name|qisone
argument_list|(
name|q2
argument_list|)
condition|)
return|return
name|qlink
argument_list|(
name|q1
argument_list|)
return|;
if|if
condition|(
name|qisint
argument_list|(
name|q1
argument_list|)
operator|&&
name|qisint
argument_list|(
name|q2
argument_list|)
condition|)
block|{
comment|/* easy results if integers */
name|r
operator|=
name|qalloc
argument_list|()
expr_stmt|;
name|zmul
argument_list|(
name|q1
operator|->
name|num
argument_list|,
name|q2
operator|->
name|num
argument_list|,
operator|&
name|r
operator|->
name|num
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
name|n1
operator|=
name|q1
operator|->
name|num
expr_stmt|;
name|n2
operator|=
name|q2
operator|->
name|num
expr_stmt|;
name|d1
operator|=
name|q1
operator|->
name|den
expr_stmt|;
name|d2
operator|=
name|q2
operator|->
name|den
expr_stmt|;
if|if
condition|(
name|ziszero
argument_list|(
name|d1
argument_list|)
operator|||
name|ziszero
argument_list|(
name|d2
argument_list|)
condition|)
name|math_error
argument_list|(
literal|"Division by zero"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ziszero
argument_list|(
name|n1
argument_list|)
operator|||
name|ziszero
argument_list|(
name|n2
argument_list|)
condition|)
return|return
name|qlink
argument_list|(
operator|&
name|_qzero_
argument_list|)
return|;
if|if
condition|(
operator|!
name|zisunit
argument_list|(
name|n1
argument_list|)
operator|&&
operator|!
name|zisunit
argument_list|(
name|d2
argument_list|)
condition|)
block|{
comment|/* possibly reduce */
name|zgcd
argument_list|(
name|n1
argument_list|,
name|d2
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|zisunit
argument_list|(
name|tmp
argument_list|)
condition|)
block|{
name|zquo
argument_list|(
name|q1
operator|->
name|num
argument_list|,
name|tmp
argument_list|,
operator|&
name|n1
argument_list|)
expr_stmt|;
name|zquo
argument_list|(
name|q2
operator|->
name|den
argument_list|,
name|tmp
argument_list|,
operator|&
name|d2
argument_list|)
expr_stmt|;
block|}
name|zfree
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|zisunit
argument_list|(
name|n2
argument_list|)
operator|&&
operator|!
name|zisunit
argument_list|(
name|d1
argument_list|)
condition|)
block|{
comment|/* again possibly reduce */
name|zgcd
argument_list|(
name|n2
argument_list|,
name|d1
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|zisunit
argument_list|(
name|tmp
argument_list|)
condition|)
block|{
name|zquo
argument_list|(
name|q2
operator|->
name|num
argument_list|,
name|tmp
argument_list|,
operator|&
name|n2
argument_list|)
expr_stmt|;
name|zquo
argument_list|(
name|q1
operator|->
name|den
argument_list|,
name|tmp
argument_list|,
operator|&
name|d1
argument_list|)
expr_stmt|;
block|}
name|zfree
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
name|r
operator|=
name|qalloc
argument_list|()
expr_stmt|;
name|zmul
argument_list|(
name|n1
argument_list|,
name|n2
argument_list|,
operator|&
name|r
operator|->
name|num
argument_list|)
expr_stmt|;
name|zmul
argument_list|(
name|d1
argument_list|,
name|d2
argument_list|,
operator|&
name|r
operator|->
name|den
argument_list|)
expr_stmt|;
if|if
condition|(
name|q1
operator|->
name|num
operator|.
name|v
operator|!=
name|n1
operator|.
name|v
condition|)
name|zfree
argument_list|(
name|n1
argument_list|)
expr_stmt|;
if|if
condition|(
name|q1
operator|->
name|den
operator|.
name|v
operator|!=
name|d1
operator|.
name|v
condition|)
name|zfree
argument_list|(
name|d1
argument_list|)
expr_stmt|;
if|if
condition|(
name|q2
operator|->
name|num
operator|.
name|v
operator|!=
name|n2
operator|.
name|v
condition|)
name|zfree
argument_list|(
name|n2
argument_list|)
expr_stmt|;
if|if
condition|(
name|q2
operator|->
name|den
operator|.
name|v
operator|!=
name|d2
operator|.
name|v
condition|)
name|zfree
argument_list|(
name|d2
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_block

begin_comment
comment|/*  * Multiply a number by a small integer.  *	q2 = qmuli(q1, n);  */
end_comment

begin_function
name|NUMBER
modifier|*
name|qmuli
parameter_list|(
name|q
parameter_list|,
name|n
parameter_list|)
name|NUMBER
modifier|*
name|q
decl_stmt|;
name|long
name|n
decl_stmt|;
block|{
name|NUMBER
modifier|*
name|r
decl_stmt|;
name|long
name|d
decl_stmt|;
comment|/* gcd of multiplier and denominator */
name|int
name|sign
decl_stmt|;
if|if
condition|(
operator|(
name|n
operator|==
literal|0
operator|)
operator|||
name|qiszero
argument_list|(
name|q
argument_list|)
condition|)
return|return
name|qlink
argument_list|(
operator|&
name|_qzero_
argument_list|)
return|;
if|if
condition|(
name|n
operator|==
literal|1
condition|)
return|return
name|qlink
argument_list|(
name|q
argument_list|)
return|;
name|r
operator|=
name|qalloc
argument_list|()
expr_stmt|;
if|if
condition|(
name|qisint
argument_list|(
name|q
argument_list|)
condition|)
block|{
name|zmuli
argument_list|(
name|q
operator|->
name|num
argument_list|,
name|n
argument_list|,
operator|&
name|r
operator|->
name|num
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
name|sign
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|n
operator|=
operator|-
name|n
expr_stmt|;
name|sign
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|d
operator|=
name|zmodi
argument_list|(
name|q
operator|->
name|den
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|d
operator|=
name|iigcd
argument_list|(
name|d
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|zmuli
argument_list|(
name|q
operator|->
name|num
argument_list|,
operator|(
name|n
operator|*
name|sign
operator|)
operator|/
name|d
argument_list|,
operator|&
name|r
operator|->
name|num
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zdivi
argument_list|(
name|q
operator|->
name|den
argument_list|,
name|d
argument_list|,
operator|&
name|r
operator|->
name|den
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/*  * Divide two numbers (as fractions).  *	q3 = qdiv(q1, q2);  */
end_comment

begin_function
name|NUMBER
modifier|*
name|qdiv
parameter_list|(
name|q1
parameter_list|,
name|q2
parameter_list|)
specifier|register
name|NUMBER
modifier|*
name|q1
decl_stmt|,
decl|*
name|q2
decl_stmt|;
end_function

begin_block
block|{
name|NUMBER
name|temp
decl_stmt|;
if|if
condition|(
name|qiszero
argument_list|(
name|q2
argument_list|)
condition|)
name|math_error
argument_list|(
literal|"Division by zero"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|q1
operator|==
name|q2
operator|)
operator|||
operator|!
name|qcmp
argument_list|(
name|q1
argument_list|,
name|q2
argument_list|)
condition|)
return|return
name|qlink
argument_list|(
operator|&
name|_qone_
argument_list|)
return|;
if|if
condition|(
name|qisone
argument_list|(
name|q1
argument_list|)
condition|)
return|return
name|qinv
argument_list|(
name|q2
argument_list|)
return|;
name|temp
operator|.
name|num
operator|=
name|q2
operator|->
name|den
expr_stmt|;
name|temp
operator|.
name|den
operator|=
name|q2
operator|->
name|num
expr_stmt|;
name|temp
operator|.
name|num
operator|.
name|sign
operator|=
name|temp
operator|.
name|den
operator|.
name|sign
expr_stmt|;
name|temp
operator|.
name|den
operator|.
name|sign
operator|=
literal|0
expr_stmt|;
name|temp
operator|.
name|links
operator|=
literal|1
expr_stmt|;
return|return
name|qmul
argument_list|(
name|q1
argument_list|,
operator|&
name|temp
argument_list|)
return|;
block|}
end_block

begin_comment
comment|/*  * Divide a number by a small integer.  *	q2 = qdivi(q1, n);  */
end_comment

begin_function
name|NUMBER
modifier|*
name|qdivi
parameter_list|(
name|q
parameter_list|,
name|n
parameter_list|)
name|NUMBER
modifier|*
name|q
decl_stmt|;
name|long
name|n
decl_stmt|;
block|{
name|NUMBER
modifier|*
name|r
decl_stmt|;
name|long
name|d
decl_stmt|;
comment|/* gcd of divisor and numerator */
name|int
name|sign
decl_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
name|math_error
argument_list|(
literal|"Division by zero"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|==
literal|1
operator|)
operator|||
name|qiszero
argument_list|(
name|q
argument_list|)
condition|)
return|return
name|qlink
argument_list|(
name|q
argument_list|)
return|;
name|sign
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|n
operator|=
operator|-
name|n
expr_stmt|;
name|sign
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|r
operator|=
name|qalloc
argument_list|()
expr_stmt|;
name|d
operator|=
name|zmodi
argument_list|(
name|q
operator|->
name|num
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|d
operator|=
name|iigcd
argument_list|(
name|d
argument_list|,
name|n
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zdivi
argument_list|(
name|q
operator|->
name|num
argument_list|,
name|d
operator|*
name|sign
argument_list|,
operator|&
name|r
operator|->
name|num
argument_list|)
expr_stmt|;
name|zmuli
argument_list|(
name|q
operator|->
name|den
argument_list|,
name|n
operator|/
name|d
argument_list|,
operator|&
name|r
operator|->
name|den
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/*  * Return the quotient when one number is divided by another.  * This works for fractional values also, and in all cases:  *	qquo(q1, q2) = int(q1 / q2).  */
end_comment

begin_function
name|NUMBER
modifier|*
name|qquo
parameter_list|(
name|q1
parameter_list|,
name|q2
parameter_list|)
specifier|register
name|NUMBER
modifier|*
name|q1
decl_stmt|,
decl|*
name|q2
decl_stmt|;
end_function

begin_block
block|{
name|ZVALUE
name|num
decl_stmt|,
name|den
decl_stmt|,
name|res
decl_stmt|;
name|NUMBER
modifier|*
name|q
decl_stmt|;
if|if
condition|(
name|zisunit
argument_list|(
name|q1
operator|->
name|num
argument_list|)
condition|)
name|num
operator|=
name|q2
operator|->
name|den
expr_stmt|;
elseif|else
if|if
condition|(
name|zisunit
argument_list|(
name|q2
operator|->
name|den
argument_list|)
condition|)
name|num
operator|=
name|q1
operator|->
name|num
expr_stmt|;
else|else
name|zmul
argument_list|(
name|q1
operator|->
name|num
argument_list|,
name|q2
operator|->
name|den
argument_list|,
operator|&
name|num
argument_list|)
expr_stmt|;
if|if
condition|(
name|zisunit
argument_list|(
name|q1
operator|->
name|den
argument_list|)
condition|)
name|den
operator|=
name|q2
operator|->
name|num
expr_stmt|;
elseif|else
if|if
condition|(
name|zisunit
argument_list|(
name|q2
operator|->
name|num
argument_list|)
condition|)
name|den
operator|=
name|q1
operator|->
name|den
expr_stmt|;
else|else
name|zmul
argument_list|(
name|q1
operator|->
name|den
argument_list|,
name|q2
operator|->
name|num
argument_list|,
operator|&
name|den
argument_list|)
expr_stmt|;
name|zquo
argument_list|(
name|num
argument_list|,
name|den
argument_list|,
operator|&
name|res
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|num
operator|.
name|v
operator|!=
name|q2
operator|->
name|den
operator|.
name|v
operator|)
operator|&&
operator|(
name|num
operator|.
name|v
operator|!=
name|q1
operator|->
name|num
operator|.
name|v
operator|)
condition|)
name|zfree
argument_list|(
name|num
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|den
operator|.
name|v
operator|!=
name|q2
operator|->
name|num
operator|.
name|v
operator|)
operator|&&
operator|(
name|den
operator|.
name|v
operator|!=
name|q1
operator|->
name|den
operator|.
name|v
operator|)
condition|)
name|zfree
argument_list|(
name|den
argument_list|)
expr_stmt|;
if|if
condition|(
name|ziszero
argument_list|(
name|res
argument_list|)
condition|)
block|{
name|zfree
argument_list|(
name|res
argument_list|)
expr_stmt|;
return|return
name|qlink
argument_list|(
operator|&
name|_qzero_
argument_list|)
return|;
block|}
name|res
operator|.
name|sign
operator|=
operator|(
name|q1
operator|->
name|num
operator|.
name|sign
operator|!=
name|q2
operator|->
name|num
operator|.
name|sign
operator|)
expr_stmt|;
if|if
condition|(
name|zisunit
argument_list|(
name|res
argument_list|)
condition|)
block|{
name|q
operator|=
operator|(
name|res
operator|.
name|sign
condition|?
operator|&
name|_qnegone_
else|:
operator|&
name|_qone_
operator|)
expr_stmt|;
name|zfree
argument_list|(
name|res
argument_list|)
expr_stmt|;
return|return
name|qlink
argument_list|(
name|q
argument_list|)
return|;
block|}
name|q
operator|=
name|qalloc
argument_list|()
expr_stmt|;
name|q
operator|->
name|num
operator|=
name|res
expr_stmt|;
return|return
name|q
return|;
block|}
end_block

begin_comment
comment|/*  * Return the absolute value of a number.  *	q2 = qabs(q1);  */
end_comment

begin_function
name|NUMBER
modifier|*
name|qabs
parameter_list|(
name|q
parameter_list|)
specifier|register
name|NUMBER
modifier|*
name|q
decl_stmt|;
block|{
specifier|register
name|NUMBER
modifier|*
name|r
decl_stmt|;
if|if
condition|(
name|q
operator|->
name|num
operator|.
name|sign
operator|==
literal|0
condition|)
return|return
name|qlink
argument_list|(
name|q
argument_list|)
return|;
name|r
operator|=
name|qalloc
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|zisunit
argument_list|(
name|q
operator|->
name|num
argument_list|)
condition|)
name|zcopy
argument_list|(
name|q
operator|->
name|num
argument_list|,
operator|&
name|r
operator|->
name|num
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|zisunit
argument_list|(
name|q
operator|->
name|den
argument_list|)
condition|)
name|zcopy
argument_list|(
name|q
operator|->
name|den
argument_list|,
operator|&
name|r
operator|->
name|den
argument_list|)
expr_stmt|;
name|r
operator|->
name|num
operator|.
name|sign
operator|=
literal|0
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/*  * Negate a number.  *	q2 = qneg(q1);  */
end_comment

begin_function
name|NUMBER
modifier|*
name|qneg
parameter_list|(
name|q
parameter_list|)
specifier|register
name|NUMBER
modifier|*
name|q
decl_stmt|;
block|{
specifier|register
name|NUMBER
modifier|*
name|r
decl_stmt|;
if|if
condition|(
name|qiszero
argument_list|(
name|q
argument_list|)
condition|)
return|return
name|qlink
argument_list|(
operator|&
name|_qzero_
argument_list|)
return|;
name|r
operator|=
name|qalloc
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|zisunit
argument_list|(
name|q
operator|->
name|num
argument_list|)
condition|)
name|zcopy
argument_list|(
name|q
operator|->
name|num
argument_list|,
operator|&
name|r
operator|->
name|num
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|zisunit
argument_list|(
name|q
operator|->
name|den
argument_list|)
condition|)
name|zcopy
argument_list|(
name|q
operator|->
name|den
argument_list|,
operator|&
name|r
operator|->
name|den
argument_list|)
expr_stmt|;
name|r
operator|->
name|num
operator|.
name|sign
operator|=
operator|!
name|q
operator|->
name|num
operator|.
name|sign
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/*  * Return the sign of a number (-1, 0 or 1)  */
end_comment

begin_function
name|NUMBER
modifier|*
name|qsign
parameter_list|(
name|q
parameter_list|)
name|NUMBER
modifier|*
name|q
decl_stmt|;
block|{
if|if
condition|(
name|qiszero
argument_list|(
name|q
argument_list|)
condition|)
return|return
name|qlink
argument_list|(
operator|&
name|_qzero_
argument_list|)
return|;
if|if
condition|(
name|qisneg
argument_list|(
name|q
argument_list|)
condition|)
return|return
name|qlink
argument_list|(
operator|&
name|_qnegone_
argument_list|)
return|;
return|return
name|qlink
argument_list|(
operator|&
name|_qone_
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Invert a number.  *	q2 = qinv(q1);  */
end_comment

begin_function
name|NUMBER
modifier|*
name|qinv
parameter_list|(
name|q
parameter_list|)
specifier|register
name|NUMBER
modifier|*
name|q
decl_stmt|;
block|{
specifier|register
name|NUMBER
modifier|*
name|r
decl_stmt|;
if|if
condition|(
name|qisunit
argument_list|(
name|q
argument_list|)
condition|)
block|{
name|r
operator|=
operator|(
name|qisneg
argument_list|(
name|q
argument_list|)
condition|?
operator|&
name|_qnegone_
else|:
operator|&
name|_qone_
operator|)
expr_stmt|;
return|return
name|qlink
argument_list|(
name|r
argument_list|)
return|;
block|}
if|if
condition|(
name|qiszero
argument_list|(
name|q
argument_list|)
condition|)
name|math_error
argument_list|(
literal|"Division by zero"
argument_list|)
expr_stmt|;
name|r
operator|=
name|qalloc
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|zisunit
argument_list|(
name|q
operator|->
name|num
argument_list|)
condition|)
name|zcopy
argument_list|(
name|q
operator|->
name|num
argument_list|,
operator|&
name|r
operator|->
name|den
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|zisunit
argument_list|(
name|q
operator|->
name|den
argument_list|)
condition|)
name|zcopy
argument_list|(
name|q
operator|->
name|den
argument_list|,
operator|&
name|r
operator|->
name|num
argument_list|)
expr_stmt|;
name|r
operator|->
name|num
operator|.
name|sign
operator|=
name|q
operator|->
name|num
operator|.
name|sign
expr_stmt|;
name|r
operator|->
name|den
operator|.
name|sign
operator|=
literal|0
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/*  * Return just the numerator of a number.  *	q2 = qnum(q1);  */
end_comment

begin_function
name|NUMBER
modifier|*
name|qnum
parameter_list|(
name|q
parameter_list|)
specifier|register
name|NUMBER
modifier|*
name|q
decl_stmt|;
block|{
specifier|register
name|NUMBER
modifier|*
name|r
decl_stmt|;
if|if
condition|(
name|qisint
argument_list|(
name|q
argument_list|)
condition|)
return|return
name|qlink
argument_list|(
name|q
argument_list|)
return|;
if|if
condition|(
name|zisunit
argument_list|(
name|q
operator|->
name|num
argument_list|)
condition|)
block|{
name|r
operator|=
operator|(
name|qisneg
argument_list|(
name|q
argument_list|)
condition|?
operator|&
name|_qnegone_
else|:
operator|&
name|_qone_
operator|)
expr_stmt|;
return|return
name|qlink
argument_list|(
name|r
argument_list|)
return|;
block|}
name|r
operator|=
name|qalloc
argument_list|()
expr_stmt|;
name|zcopy
argument_list|(
name|q
operator|->
name|num
argument_list|,
operator|&
name|r
operator|->
name|num
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/*  * Return just the denominator of a number.  *	q2 = qden(q1);  */
end_comment

begin_function
name|NUMBER
modifier|*
name|qden
parameter_list|(
name|q
parameter_list|)
specifier|register
name|NUMBER
modifier|*
name|q
decl_stmt|;
block|{
specifier|register
name|NUMBER
modifier|*
name|r
decl_stmt|;
if|if
condition|(
name|qisint
argument_list|(
name|q
argument_list|)
condition|)
return|return
name|qlink
argument_list|(
operator|&
name|_qone_
argument_list|)
return|;
name|r
operator|=
name|qalloc
argument_list|()
expr_stmt|;
name|zcopy
argument_list|(
name|q
operator|->
name|den
argument_list|,
operator|&
name|r
operator|->
name|num
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/*  * Return the fractional part of a number.  *	q2 = qfrac(q1);  */
end_comment

begin_function
name|NUMBER
modifier|*
name|qfrac
parameter_list|(
name|q
parameter_list|)
specifier|register
name|NUMBER
modifier|*
name|q
decl_stmt|;
block|{
specifier|register
name|NUMBER
modifier|*
name|r
decl_stmt|;
name|ZVALUE
name|z
decl_stmt|;
if|if
condition|(
name|qisint
argument_list|(
name|q
argument_list|)
condition|)
return|return
name|qlink
argument_list|(
operator|&
name|_qzero_
argument_list|)
return|;
if|if
condition|(
operator|(
name|q
operator|->
name|num
operator|.
name|len
operator|<
name|q
operator|->
name|den
operator|.
name|len
operator|)
operator|||
operator|(
operator|(
name|q
operator|->
name|num
operator|.
name|len
operator|==
name|q
operator|->
name|den
operator|.
name|len
operator|)
operator|&&
operator|(
name|q
operator|->
name|num
operator|.
name|v
index|[
name|q
operator|->
name|num
operator|.
name|len
operator|-
literal|1
index|]
operator|<
name|q
operator|->
name|den
operator|.
name|v
index|[
name|q
operator|->
name|num
operator|.
name|len
operator|-
literal|1
index|]
operator|)
operator|)
condition|)
return|return
name|qlink
argument_list|(
name|q
argument_list|)
return|;
name|r
operator|=
name|qalloc
argument_list|()
expr_stmt|;
if|if
condition|(
name|qisneg
argument_list|(
name|q
argument_list|)
condition|)
block|{
name|zmod
argument_list|(
name|q
operator|->
name|num
argument_list|,
name|q
operator|->
name|den
argument_list|,
operator|&
name|z
argument_list|)
expr_stmt|;
name|zsub
argument_list|(
name|q
operator|->
name|den
argument_list|,
name|z
argument_list|,
operator|&
name|r
operator|->
name|num
argument_list|)
expr_stmt|;
name|zfree
argument_list|(
name|z
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|zmod
argument_list|(
name|q
operator|->
name|num
argument_list|,
name|q
operator|->
name|den
argument_list|,
operator|&
name|r
operator|->
name|num
argument_list|)
expr_stmt|;
block|}
name|zcopy
argument_list|(
name|q
operator|->
name|den
argument_list|,
operator|&
name|r
operator|->
name|den
argument_list|)
expr_stmt|;
name|r
operator|->
name|num
operator|.
name|sign
operator|=
name|q
operator|->
name|num
operator|.
name|sign
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/*  * Return the integral part of a number.  *	q2 = qint(q1);  */
end_comment

begin_function
name|NUMBER
modifier|*
name|qint
parameter_list|(
name|q
parameter_list|)
specifier|register
name|NUMBER
modifier|*
name|q
decl_stmt|;
block|{
specifier|register
name|NUMBER
modifier|*
name|r
decl_stmt|;
if|if
condition|(
name|qisint
argument_list|(
name|q
argument_list|)
condition|)
return|return
name|qlink
argument_list|(
name|q
argument_list|)
return|;
if|if
condition|(
operator|(
name|q
operator|->
name|num
operator|.
name|len
operator|<
name|q
operator|->
name|den
operator|.
name|len
operator|)
operator|||
operator|(
operator|(
name|q
operator|->
name|num
operator|.
name|len
operator|==
name|q
operator|->
name|den
operator|.
name|len
operator|)
operator|&&
operator|(
name|q
operator|->
name|num
operator|.
name|v
index|[
name|q
operator|->
name|num
operator|.
name|len
operator|-
literal|1
index|]
operator|<
name|q
operator|->
name|den
operator|.
name|v
index|[
name|q
operator|->
name|num
operator|.
name|len
operator|-
literal|1
index|]
operator|)
operator|)
condition|)
return|return
name|qlink
argument_list|(
operator|&
name|_qzero_
argument_list|)
return|;
name|r
operator|=
name|qalloc
argument_list|()
expr_stmt|;
name|zquo
argument_list|(
name|q
operator|->
name|num
argument_list|,
name|q
operator|->
name|den
argument_list|,
operator|&
name|r
operator|->
name|num
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/*  * Compute the square of a number.  */
end_comment

begin_function
name|NUMBER
modifier|*
name|qsquare
parameter_list|(
name|q
parameter_list|)
specifier|register
name|NUMBER
modifier|*
name|q
decl_stmt|;
block|{
name|ZVALUE
name|num
decl_stmt|,
name|den
decl_stmt|;
if|if
condition|(
name|qiszero
argument_list|(
name|q
argument_list|)
condition|)
return|return
name|qlink
argument_list|(
operator|&
name|_qzero_
argument_list|)
return|;
if|if
condition|(
name|qisunit
argument_list|(
name|q
argument_list|)
condition|)
return|return
name|qlink
argument_list|(
operator|&
name|_qone_
argument_list|)
return|;
name|num
operator|=
name|q
operator|->
name|num
expr_stmt|;
name|den
operator|=
name|q
operator|->
name|den
expr_stmt|;
name|q
operator|=
name|qalloc
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|zisunit
argument_list|(
name|num
argument_list|)
condition|)
name|zsquare
argument_list|(
name|num
argument_list|,
operator|&
name|q
operator|->
name|num
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|zisunit
argument_list|(
name|den
argument_list|)
condition|)
name|zsquare
argument_list|(
name|den
argument_list|,
operator|&
name|q
operator|->
name|den
argument_list|)
expr_stmt|;
return|return
name|q
return|;
block|}
end_function

begin_comment
comment|/*  * Shift an integer by a given number of bits. This multiplies the number  * by the appropriate power of two.  Positive numbers shift left, negative  * ones shift right.  Low bits are truncated when shifting right.  */
end_comment

begin_function
name|NUMBER
modifier|*
name|qshift
parameter_list|(
name|q
parameter_list|,
name|n
parameter_list|)
name|NUMBER
modifier|*
name|q
decl_stmt|;
name|long
name|n
decl_stmt|;
block|{
specifier|register
name|NUMBER
modifier|*
name|r
decl_stmt|;
if|if
condition|(
name|qisfrac
argument_list|(
name|q
argument_list|)
condition|)
name|math_error
argument_list|(
literal|"Shift of non-integer"
argument_list|)
expr_stmt|;
if|if
condition|(
name|qiszero
argument_list|(
name|q
argument_list|)
operator|||
operator|(
name|n
operator|==
literal|0
operator|)
condition|)
return|return
name|qlink
argument_list|(
name|q
argument_list|)
return|;
if|if
condition|(
name|n
operator|<=
operator|-
operator|(
name|q
operator|->
name|num
operator|.
name|len
operator|*
name|BASEB
operator|)
condition|)
return|return
name|qlink
argument_list|(
operator|&
name|_qzero_
argument_list|)
return|;
name|r
operator|=
name|qalloc
argument_list|()
expr_stmt|;
name|zshift
argument_list|(
name|q
operator|->
name|num
argument_list|,
name|n
argument_list|,
operator|&
name|r
operator|->
name|num
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/*  * Scale a number by a power of two, as in:  *	ans = q * 2^n.  * This is similar to shifting, except that fractions work.  */
end_comment

begin_function
name|NUMBER
modifier|*
name|qscale
parameter_list|(
name|q
parameter_list|,
name|pow
parameter_list|)
name|NUMBER
modifier|*
name|q
decl_stmt|;
name|long
name|pow
decl_stmt|;
block|{
name|long
name|numshift
decl_stmt|,
name|denshift
decl_stmt|,
name|tmp
decl_stmt|;
name|NUMBER
modifier|*
name|r
decl_stmt|;
if|if
condition|(
name|qiszero
argument_list|(
name|q
argument_list|)
operator|||
operator|(
name|pow
operator|==
literal|0
operator|)
condition|)
return|return
name|qlink
argument_list|(
name|q
argument_list|)
return|;
if|if
condition|(
operator|(
name|pow
operator|>
literal|1000000L
operator|)
operator|||
operator|(
name|pow
operator|<
operator|-
literal|1000000L
operator|)
condition|)
name|math_error
argument_list|(
literal|"Very large scale value"
argument_list|)
expr_stmt|;
name|numshift
operator|=
name|zisodd
argument_list|(
name|q
operator|->
name|num
argument_list|)
condition|?
literal|0
else|:
name|zlowbit
argument_list|(
name|q
operator|->
name|num
argument_list|)
expr_stmt|;
name|denshift
operator|=
name|zisodd
argument_list|(
name|q
operator|->
name|den
argument_list|)
condition|?
literal|0
else|:
name|zlowbit
argument_list|(
name|q
operator|->
name|den
argument_list|)
expr_stmt|;
if|if
condition|(
name|pow
operator|>
literal|0
condition|)
block|{
name|tmp
operator|=
name|pow
expr_stmt|;
if|if
condition|(
name|tmp
operator|>
name|denshift
condition|)
name|tmp
operator|=
name|denshift
expr_stmt|;
name|denshift
operator|=
operator|-
name|tmp
expr_stmt|;
name|numshift
operator|=
operator|(
name|pow
operator|-
name|tmp
operator|)
expr_stmt|;
block|}
else|else
block|{
name|pow
operator|=
operator|-
name|pow
expr_stmt|;
name|tmp
operator|=
name|pow
expr_stmt|;
if|if
condition|(
name|tmp
operator|>
name|numshift
condition|)
name|tmp
operator|=
name|numshift
expr_stmt|;
name|numshift
operator|=
operator|-
name|tmp
expr_stmt|;
name|denshift
operator|=
operator|(
name|pow
operator|-
name|tmp
operator|)
expr_stmt|;
block|}
name|r
operator|=
name|qalloc
argument_list|()
expr_stmt|;
if|if
condition|(
name|numshift
condition|)
name|zshift
argument_list|(
name|q
operator|->
name|num
argument_list|,
name|numshift
argument_list|,
operator|&
name|r
operator|->
name|num
argument_list|)
expr_stmt|;
else|else
name|zcopy
argument_list|(
name|q
operator|->
name|num
argument_list|,
operator|&
name|r
operator|->
name|num
argument_list|)
expr_stmt|;
if|if
condition|(
name|denshift
condition|)
name|zshift
argument_list|(
name|q
operator|->
name|den
argument_list|,
name|denshift
argument_list|,
operator|&
name|r
operator|->
name|den
argument_list|)
expr_stmt|;
else|else
name|zcopy
argument_list|(
name|q
operator|->
name|den
argument_list|,
operator|&
name|r
operator|->
name|den
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/*  * Return the minimum of two numbers.  */
end_comment

begin_function
name|NUMBER
modifier|*
name|qmin
parameter_list|(
name|q1
parameter_list|,
name|q2
parameter_list|)
name|NUMBER
modifier|*
name|q1
decl_stmt|,
decl|*
name|q2
decl_stmt|;
end_function

begin_block
block|{
if|if
condition|(
name|q1
operator|==
name|q2
condition|)
return|return
name|qlink
argument_list|(
name|q1
argument_list|)
return|;
if|if
condition|(
name|qrel
argument_list|(
name|q1
argument_list|,
name|q2
argument_list|)
operator|>
literal|0
condition|)
name|q1
operator|=
name|q2
expr_stmt|;
return|return
name|qlink
argument_list|(
name|q1
argument_list|)
return|;
block|}
end_block

begin_comment
comment|/*  * Return the maximum of two numbers.  */
end_comment

begin_function
name|NUMBER
modifier|*
name|qmax
parameter_list|(
name|q1
parameter_list|,
name|q2
parameter_list|)
name|NUMBER
modifier|*
name|q1
decl_stmt|,
decl|*
name|q2
decl_stmt|;
end_function

begin_block
block|{
if|if
condition|(
name|q1
operator|==
name|q2
condition|)
return|return
name|qlink
argument_list|(
name|q1
argument_list|)
return|;
if|if
condition|(
name|qrel
argument_list|(
name|q1
argument_list|,
name|q2
argument_list|)
operator|<
literal|0
condition|)
name|q1
operator|=
name|q2
expr_stmt|;
return|return
name|qlink
argument_list|(
name|q1
argument_list|)
return|;
block|}
end_block

begin_comment
comment|/*  * Perform the logical OR of two integers.  */
end_comment

begin_function
name|NUMBER
modifier|*
name|qor
parameter_list|(
name|q1
parameter_list|,
name|q2
parameter_list|)
name|NUMBER
modifier|*
name|q1
decl_stmt|,
decl|*
name|q2
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|NUMBER
modifier|*
name|r
decl_stmt|;
if|if
condition|(
name|qisfrac
argument_list|(
name|q1
argument_list|)
operator|||
name|qisfrac
argument_list|(
name|q2
argument_list|)
condition|)
name|math_error
argument_list|(
literal|"Non-integers for logical or"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|q1
operator|==
name|q2
operator|)
operator|||
name|qiszero
argument_list|(
name|q2
argument_list|)
condition|)
return|return
name|qlink
argument_list|(
name|q1
argument_list|)
return|;
if|if
condition|(
name|qiszero
argument_list|(
name|q1
argument_list|)
condition|)
return|return
name|qlink
argument_list|(
name|q2
argument_list|)
return|;
name|r
operator|=
name|qalloc
argument_list|()
expr_stmt|;
name|zor
argument_list|(
name|q1
operator|->
name|num
argument_list|,
name|q2
operator|->
name|num
argument_list|,
operator|&
name|r
operator|->
name|num
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_block

begin_comment
comment|/*  * Perform the logical AND of two integers.  */
end_comment

begin_function
name|NUMBER
modifier|*
name|qand
parameter_list|(
name|q1
parameter_list|,
name|q2
parameter_list|)
name|NUMBER
modifier|*
name|q1
decl_stmt|,
decl|*
name|q2
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|NUMBER
modifier|*
name|r
decl_stmt|;
name|ZVALUE
name|res
decl_stmt|;
if|if
condition|(
name|qisfrac
argument_list|(
name|q1
argument_list|)
operator|||
name|qisfrac
argument_list|(
name|q2
argument_list|)
condition|)
name|math_error
argument_list|(
literal|"Non-integers for logical and"
argument_list|)
expr_stmt|;
if|if
condition|(
name|q1
operator|==
name|q2
condition|)
return|return
name|qlink
argument_list|(
name|q1
argument_list|)
return|;
if|if
condition|(
name|qiszero
argument_list|(
name|q1
argument_list|)
operator|||
name|qiszero
argument_list|(
name|q2
argument_list|)
condition|)
return|return
name|qlink
argument_list|(
operator|&
name|_qzero_
argument_list|)
return|;
name|zand
argument_list|(
name|q1
operator|->
name|num
argument_list|,
name|q2
operator|->
name|num
argument_list|,
operator|&
name|res
argument_list|)
expr_stmt|;
if|if
condition|(
name|ziszero
argument_list|(
name|res
argument_list|)
condition|)
block|{
name|zfree
argument_list|(
name|res
argument_list|)
expr_stmt|;
return|return
name|qlink
argument_list|(
operator|&
name|_qzero_
argument_list|)
return|;
block|}
name|r
operator|=
name|qalloc
argument_list|()
expr_stmt|;
name|r
operator|->
name|num
operator|=
name|res
expr_stmt|;
return|return
name|r
return|;
block|}
end_block

begin_comment
comment|/*  * Perform the logical XOR of two integers.  */
end_comment

begin_function
name|NUMBER
modifier|*
name|qxor
parameter_list|(
name|q1
parameter_list|,
name|q2
parameter_list|)
name|NUMBER
modifier|*
name|q1
decl_stmt|,
decl|*
name|q2
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|NUMBER
modifier|*
name|r
decl_stmt|;
name|ZVALUE
name|res
decl_stmt|;
if|if
condition|(
name|qisfrac
argument_list|(
name|q1
argument_list|)
operator|||
name|qisfrac
argument_list|(
name|q2
argument_list|)
condition|)
name|math_error
argument_list|(
literal|"Non-integers for logical xor"
argument_list|)
expr_stmt|;
if|if
condition|(
name|q1
operator|==
name|q2
condition|)
return|return
name|qlink
argument_list|(
operator|&
name|_qzero_
argument_list|)
return|;
if|if
condition|(
name|qiszero
argument_list|(
name|q1
argument_list|)
condition|)
return|return
name|qlink
argument_list|(
name|q2
argument_list|)
return|;
if|if
condition|(
name|qiszero
argument_list|(
name|q2
argument_list|)
condition|)
return|return
name|qlink
argument_list|(
name|q1
argument_list|)
return|;
name|zxor
argument_list|(
name|q1
operator|->
name|num
argument_list|,
name|q2
operator|->
name|num
argument_list|,
operator|&
name|res
argument_list|)
expr_stmt|;
if|if
condition|(
name|ziszero
argument_list|(
name|res
argument_list|)
condition|)
block|{
name|zfree
argument_list|(
name|res
argument_list|)
expr_stmt|;
return|return
name|qlink
argument_list|(
operator|&
name|_qzero_
argument_list|)
return|;
block|}
name|r
operator|=
name|qalloc
argument_list|()
expr_stmt|;
name|r
operator|->
name|num
operator|=
name|res
expr_stmt|;
return|return
name|r
return|;
block|}
end_block

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/*  * Return the number whose binary representation only has the specified  * bit set (counting from zero).  This thus produces a given power of two.  */
end_comment

begin_comment
unit|NUMBER * qbitvalue(n) 	long n; { 	register NUMBER *r;  	if (n<= 0) 		return qlink(&_qone_); 	r = qalloc(); 	zbitvalue(n,&r->num); 	return r; }
comment|/*  * Test to see if the specified bit of a number is on (counted from zero).  * Returns TRUE if the bit is set, or FALSE if it is not.  *	i = qbittest(q, n);  */
end_comment

begin_endif
unit|BOOL qbittest(q, n) 	register NUMBER *q; 	long n; { 	int x, y;  	if ((n< 0) || (n>= (q->num.len * BASEB))) 		return FALSE; 	x = q->num.v[n / BASEB]; 	y = (1<< (n % BASEB)); 	return ((x& y) != 0); }
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Return the precision of a number (usually for examining an epsilon value).  * This is the largest power of two whose reciprocal is not smaller in absolute  * value than the specified number.  For example, qbitprec(1/100) = 6.  * Numbers larger than one have a precision of zero.  */
end_comment

begin_function
name|long
name|qprecision
parameter_list|(
name|q
parameter_list|)
name|NUMBER
modifier|*
name|q
decl_stmt|;
block|{
name|long
name|r
decl_stmt|;
if|if
condition|(
name|qisint
argument_list|(
name|q
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|zisunit
argument_list|(
name|q
operator|->
name|num
argument_list|)
condition|)
return|return
name|zhighbit
argument_list|(
name|q
operator|->
name|den
argument_list|)
return|;
name|r
operator|=
name|zhighbit
argument_list|(
name|q
operator|->
name|den
argument_list|)
operator|-
name|zhighbit
argument_list|(
name|q
operator|->
name|num
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
name|r
operator|=
literal|0
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/*  * Return an integer indicating the sign of a number (-1, 0, or 1).  *	i = qtst(q);  */
end_comment

begin_endif
unit|FLAG qtest(q) 	register NUMBER *q; { 	if (!ztest(q->num)) 		return 0; 	if (q->num.sign) 		return -1; 	return 1; }
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Determine whether or not one number exactly divides another one.  * Returns TRUE if the first number is an integer multiple of the second one.  */
end_comment

begin_function
name|BOOL
name|qdivides
parameter_list|(
name|q1
parameter_list|,
name|q2
parameter_list|)
name|NUMBER
modifier|*
name|q1
decl_stmt|,
decl|*
name|q2
decl_stmt|;
end_function

begin_block
block|{
if|if
condition|(
name|qiszero
argument_list|(
name|q1
argument_list|)
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|qisint
argument_list|(
name|q1
argument_list|)
operator|&&
name|qisint
argument_list|(
name|q2
argument_list|)
condition|)
block|{
if|if
condition|(
name|qisunit
argument_list|(
name|q2
argument_list|)
condition|)
return|return
name|TRUE
return|;
return|return
name|zdivides
argument_list|(
name|q1
operator|->
name|num
argument_list|,
name|q2
operator|->
name|num
argument_list|)
return|;
block|}
return|return
name|zdivides
argument_list|(
name|q1
operator|->
name|num
argument_list|,
name|q2
operator|->
name|num
argument_list|)
operator|&&
name|zdivides
argument_list|(
name|q2
operator|->
name|den
argument_list|,
name|q1
operator|->
name|den
argument_list|)
return|;
block|}
end_block

begin_comment
comment|/*  * Compare two numbers and return an integer indicating their relative size.  *	i = qrel(q1, q2);  */
end_comment

begin_function
name|FLAG
name|qrel
parameter_list|(
name|q1
parameter_list|,
name|q2
parameter_list|)
specifier|register
name|NUMBER
modifier|*
name|q1
decl_stmt|,
decl|*
name|q2
decl_stmt|;
end_function

begin_block
block|{
name|ZVALUE
name|z1
decl_stmt|,
name|z2
decl_stmt|;
name|long
name|wc1
decl_stmt|,
name|wc2
decl_stmt|;
name|int
name|sign
decl_stmt|;
name|int
name|z1f
init|=
literal|0
decl_stmt|,
name|z2f
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|q1
operator|==
name|q2
condition|)
return|return
literal|0
return|;
name|sign
operator|=
name|q2
operator|->
name|num
operator|.
name|sign
operator|-
name|q1
operator|->
name|num
operator|.
name|sign
expr_stmt|;
if|if
condition|(
name|sign
condition|)
return|return
name|sign
return|;
if|if
condition|(
name|qiszero
argument_list|(
name|q2
argument_list|)
condition|)
return|return
operator|!
name|qiszero
argument_list|(
name|q1
argument_list|)
return|;
if|if
condition|(
name|qiszero
argument_list|(
name|q1
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* 	 * Make a quick comparison by calculating the number of words resulting as 	 * if we multiplied through by the denominators, and then comparing the 	 * word counts. 	 */
name|sign
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|qisneg
argument_list|(
name|q1
argument_list|)
condition|)
name|sign
operator|=
operator|-
literal|1
expr_stmt|;
name|wc1
operator|=
name|q1
operator|->
name|num
operator|.
name|len
operator|+
name|q2
operator|->
name|den
operator|.
name|len
expr_stmt|;
name|wc2
operator|=
name|q2
operator|->
name|num
operator|.
name|len
operator|+
name|q1
operator|->
name|den
operator|.
name|len
expr_stmt|;
if|if
condition|(
name|wc1
operator|<
name|wc2
operator|-
literal|1
condition|)
return|return
operator|-
name|sign
return|;
if|if
condition|(
name|wc2
operator|<
name|wc1
operator|-
literal|1
condition|)
return|return
name|sign
return|;
comment|/* 	 * Quick check failed, must actually do the full comparison. 	 */
if|if
condition|(
name|zisunit
argument_list|(
name|q2
operator|->
name|den
argument_list|)
condition|)
name|z1
operator|=
name|q1
operator|->
name|num
expr_stmt|;
elseif|else
if|if
condition|(
name|zisone
argument_list|(
name|q1
operator|->
name|num
argument_list|)
condition|)
name|z1
operator|=
name|q2
operator|->
name|den
expr_stmt|;
else|else
block|{
name|z1f
operator|=
literal|1
expr_stmt|;
name|zmul
argument_list|(
name|q1
operator|->
name|num
argument_list|,
name|q2
operator|->
name|den
argument_list|,
operator|&
name|z1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|zisunit
argument_list|(
name|q1
operator|->
name|den
argument_list|)
condition|)
name|z2
operator|=
name|q2
operator|->
name|num
expr_stmt|;
elseif|else
if|if
condition|(
name|zisone
argument_list|(
name|q2
operator|->
name|num
argument_list|)
condition|)
name|z2
operator|=
name|q1
operator|->
name|den
expr_stmt|;
else|else
block|{
name|z2f
operator|=
literal|1
expr_stmt|;
name|zmul
argument_list|(
name|q2
operator|->
name|num
argument_list|,
name|q1
operator|->
name|den
argument_list|,
operator|&
name|z2
argument_list|)
expr_stmt|;
block|}
name|sign
operator|=
name|zrel
argument_list|(
name|z1
argument_list|,
name|z2
argument_list|)
expr_stmt|;
if|if
condition|(
name|z1f
condition|)
name|zfree
argument_list|(
name|z1
argument_list|)
expr_stmt|;
if|if
condition|(
name|z2f
condition|)
name|zfree
argument_list|(
name|z2
argument_list|)
expr_stmt|;
return|return
name|sign
return|;
block|}
end_block

begin_comment
comment|/*  * Compare two numbers to see if they are equal.  * This differs from qrel in that the numbers are not ordered.  * Returns TRUE if they differ.  */
end_comment

begin_function
name|BOOL
name|qcmp
parameter_list|(
name|q1
parameter_list|,
name|q2
parameter_list|)
specifier|register
name|NUMBER
modifier|*
name|q1
decl_stmt|,
decl|*
name|q2
decl_stmt|;
end_function

begin_block
block|{
if|if
condition|(
name|q1
operator|==
name|q2
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|(
name|q1
operator|->
name|num
operator|.
name|sign
operator|!=
name|q2
operator|->
name|num
operator|.
name|sign
operator|)
operator|||
operator|(
name|q1
operator|->
name|num
operator|.
name|len
operator|!=
name|q2
operator|->
name|num
operator|.
name|len
operator|)
operator|||
operator|(
name|q2
operator|->
name|den
operator|.
name|len
operator|!=
name|q2
operator|->
name|den
operator|.
name|len
operator|)
operator|||
operator|(
operator|*
name|q1
operator|->
name|num
operator|.
name|v
operator|!=
operator|*
name|q2
operator|->
name|num
operator|.
name|v
operator|)
operator|||
operator|(
operator|*
name|q1
operator|->
name|den
operator|.
name|v
operator|!=
operator|*
name|q2
operator|->
name|den
operator|.
name|v
operator|)
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|zcmp
argument_list|(
name|q1
operator|->
name|num
argument_list|,
name|q2
operator|->
name|num
argument_list|)
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|qisint
argument_list|(
name|q1
argument_list|)
condition|)
return|return
name|FALSE
return|;
return|return
name|zcmp
argument_list|(
name|q1
operator|->
name|den
argument_list|,
name|q2
operator|->
name|den
argument_list|)
return|;
block|}
end_block

begin_comment
comment|/*  * Compare a number against a normal small integer.  * Returns 1, 0, or -1, according to whether the first number is greater,  * equal, or less than the second number.  *	n = qreli(q, n);  */
end_comment

begin_function
name|FLAG
name|qreli
parameter_list|(
name|q
parameter_list|,
name|n
parameter_list|)
name|NUMBER
modifier|*
name|q
decl_stmt|;
name|long
name|n
decl_stmt|;
block|{
name|int
name|sign
decl_stmt|;
name|ZVALUE
name|num
decl_stmt|;
name|HALF
name|h2
index|[
literal|2
index|]
decl_stmt|;
name|NUMBER
name|q2
decl_stmt|;
name|sign
operator|=
name|ztest
argument_list|(
name|q
operator|->
name|num
argument_list|)
expr_stmt|;
comment|/* do trivial sign checks */
if|if
condition|(
name|sign
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|n
operator|>
literal|0
condition|)
return|return
operator|-
literal|1
return|;
return|return
operator|(
name|n
operator|<
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|sign
operator|<
literal|0
operator|)
operator|&&
operator|(
name|n
operator|>=
literal|0
operator|)
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|(
name|sign
operator|>
literal|0
operator|)
operator|&&
operator|(
name|n
operator|<=
literal|0
operator|)
condition|)
return|return
literal|1
return|;
name|n
operator|*=
name|sign
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|1
condition|)
block|{
comment|/* quick check against 1 or -1 */
name|num
operator|=
name|q
operator|->
name|num
expr_stmt|;
name|num
operator|.
name|sign
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|sign
operator|*
name|zrel
argument_list|(
name|num
argument_list|,
name|q
operator|->
name|den
argument_list|)
operator|)
return|;
block|}
name|num
operator|.
name|sign
operator|=
operator|(
name|sign
operator|<
literal|0
operator|)
expr_stmt|;
name|num
operator|.
name|len
operator|=
literal|1
operator|+
operator|(
name|n
operator|>=
name|BASE
operator|)
expr_stmt|;
name|num
operator|.
name|v
operator|=
name|h2
expr_stmt|;
name|h2
index|[
literal|0
index|]
operator|=
operator|(
name|n
operator|&
name|BASE1
operator|)
expr_stmt|;
name|h2
index|[
literal|1
index|]
operator|=
operator|(
name|n
operator|>>
name|BASEB
operator|)
expr_stmt|;
if|if
condition|(
name|zisunit
argument_list|(
name|q
operator|->
name|den
argument_list|)
condition|)
comment|/* integer compare if no denominator */
return|return
name|zrel
argument_list|(
name|q
operator|->
name|num
argument_list|,
name|num
argument_list|)
return|;
name|q2
operator|.
name|num
operator|=
name|num
expr_stmt|;
name|q2
operator|.
name|den
operator|=
name|_one_
expr_stmt|;
name|q2
operator|.
name|links
operator|=
literal|1
expr_stmt|;
return|return
name|qrel
argument_list|(
name|q
argument_list|,
operator|&
name|q2
argument_list|)
return|;
comment|/* full fractional compare */
block|}
end_function

begin_comment
comment|/*  * Compare a number against a small integer to see if they are equal.  * Returns TRUE if they differ.  */
end_comment

begin_function
name|BOOL
name|qcmpi
parameter_list|(
name|q
parameter_list|,
name|n
parameter_list|)
name|NUMBER
modifier|*
name|q
decl_stmt|;
name|long
name|n
decl_stmt|;
block|{
name|long
name|len
decl_stmt|;
name|len
operator|=
name|q
operator|->
name|num
operator|.
name|len
expr_stmt|;
if|if
condition|(
operator|(
name|len
operator|>
literal|2
operator|)
operator|||
name|qisfrac
argument_list|(
name|q
argument_list|)
operator|||
operator|(
name|q
operator|->
name|num
operator|.
name|sign
operator|!=
operator|(
name|n
operator|<
literal|0
operator|)
operator|)
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
name|n
operator|=
operator|-
name|n
expr_stmt|;
if|if
condition|(
operator|(
call|(
name|HALF
call|)
argument_list|(
name|n
argument_list|)
operator|)
operator|!=
name|q
operator|->
name|num
operator|.
name|v
index|[
literal|0
index|]
condition|)
return|return
name|TRUE
return|;
name|n
operator|=
operator|(
operator|(
name|FULL
operator|)
name|n
operator|)
operator|>>
name|BASEB
expr_stmt|;
return|return
operator|(
operator|(
operator|(
name|n
operator|!=
literal|0
operator|)
operator|!=
operator|(
name|len
operator|==
literal|2
operator|)
operator|)
operator|||
operator|(
name|n
operator|!=
name|q
operator|->
name|num
operator|.
name|v
index|[
literal|1
index|]
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Number node allocation routines  */
end_comment

begin_define
define|#
directive|define
name|NNALLOC
value|1000
end_define

begin_union
union|union
name|allocNode
block|{
name|NUMBER
name|num
decl_stmt|;
name|union
name|allocNode
modifier|*
name|link
decl_stmt|;
block|}
union|;
end_union

begin_decl_stmt
specifier|static
name|union
name|allocNode
modifier|*
name|freeNum
decl_stmt|;
end_decl_stmt

begin_function
name|NUMBER
modifier|*
name|qalloc
parameter_list|()
block|{
specifier|register
name|union
name|allocNode
modifier|*
name|temp
decl_stmt|;
if|if
condition|(
name|freeNum
operator|==
name|NULL
condition|)
block|{
name|freeNum
operator|=
operator|(
expr|union
name|allocNode
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|NUMBER
argument_list|)
operator|*
name|NNALLOC
argument_list|)
expr_stmt|;
if|if
condition|(
name|freeNum
operator|==
name|NULL
condition|)
name|math_error
argument_list|(
literal|"Not enough memory"
argument_list|)
expr_stmt|;
name|freeNum
index|[
name|NNALLOC
operator|-
literal|1
index|]
operator|.
name|link
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|temp
operator|=
name|freeNum
operator|+
name|NNALLOC
operator|-
literal|2
init|;
name|temp
operator|>=
name|freeNum
condition|;
operator|--
name|temp
control|)
block|{
name|temp
operator|->
name|link
operator|=
name|temp
operator|+
literal|1
expr_stmt|;
block|}
block|}
name|temp
operator|=
name|freeNum
expr_stmt|;
name|freeNum
operator|=
name|temp
operator|->
name|link
expr_stmt|;
name|temp
operator|->
name|num
operator|.
name|links
operator|=
literal|1
expr_stmt|;
name|temp
operator|->
name|num
operator|.
name|num
operator|=
name|_one_
expr_stmt|;
name|temp
operator|->
name|num
operator|.
name|den
operator|=
name|_one_
expr_stmt|;
return|return
operator|&
name|temp
operator|->
name|num
return|;
block|}
end_function

begin_function
name|void
name|qfreenum
parameter_list|(
name|q
parameter_list|)
specifier|register
name|NUMBER
modifier|*
name|q
decl_stmt|;
block|{
name|union
name|allocNode
modifier|*
name|a
decl_stmt|;
if|if
condition|(
name|q
operator|==
name|NULL
condition|)
return|return;
name|zfree
argument_list|(
name|q
operator|->
name|num
argument_list|)
expr_stmt|;
name|zfree
argument_list|(
name|q
operator|->
name|den
argument_list|)
expr_stmt|;
name|a
operator|=
operator|(
expr|union
name|allocNode
operator|*
operator|)
name|q
expr_stmt|;
name|a
operator|->
name|link
operator|=
name|freeNum
expr_stmt|;
name|freeNum
operator|=
name|a
expr_stmt|;
block|}
end_function

begin_comment
comment|/* END CODE */
end_comment

end_unit

