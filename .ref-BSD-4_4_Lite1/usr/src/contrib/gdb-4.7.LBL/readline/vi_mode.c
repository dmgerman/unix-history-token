begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* vi_mode.c -- A vi emulation mode for Bash.    Derived from code written by Jeff Sparkes (jsparkes@bnr.ca).  */
end_comment

begin_comment
comment|/* Copyright (C) 1988, 1991 Free Software Foundation, Inc.     This file is part of the GNU Readline Library (the Library), a set of    routines for providing Emacs style line input to programs that ask    for it.     The Library is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     The Library is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_escape
end_escape

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			VI Emulation Mode			    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|VI_MODE
argument_list|)
end_if

begin_comment
comment|/* Some standard library routines. */
end_comment

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"readline.h"
end_include

begin_include
include|#
directive|include
file|"history.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|digit
end_ifndef

begin_define
define|#
directive|define
name|digit
parameter_list|(
name|c
parameter_list|)
value|((c)>= '0'&& (c)<= '9')
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|isletter
end_ifndef

begin_define
define|#
directive|define
name|isletter
parameter_list|(
name|c
parameter_list|)
value|(((c)>= 'A'&& (c)<= 'Z') || ((c)>= 'a'&& (c)<= 'z'))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|digit_value
end_ifndef

begin_define
define|#
directive|define
name|digit_value
parameter_list|(
name|c
parameter_list|)
value|((c) - '0')
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|member
end_ifndef

begin_define
define|#
directive|define
name|member
parameter_list|(
name|c
parameter_list|,
name|s
parameter_list|)
value|((c) ? index ((s), (c)) : 0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|isident
end_ifndef

begin_define
define|#
directive|define
name|isident
parameter_list|(
name|c
parameter_list|)
value|((isletter(c) || digit(c) || c == '_'))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|exchange
end_ifndef

begin_define
define|#
directive|define
name|exchange
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|{int temp = x; x = y; y = temp;}
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Variables imported from readline.c */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|rl_point
decl_stmt|,
name|rl_end
decl_stmt|,
name|rl_mark
decl_stmt|,
name|rl_done
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|FILE
modifier|*
name|rl_instream
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|rl_line_buffer_len
decl_stmt|,
name|rl_explicit_arg
decl_stmt|,
name|rl_numeric_arg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|Keymap
name|keymap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|rl_prompt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|rl_line_buffer
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|rl_arg_sign
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|xmalloc
argument_list|()
decl_stmt|,
modifier|*
name|xrealloc
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|void
name|rl_extend_line_buffer
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Last string searched for from `/' or `?'. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|vi_last_search
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|vi_histpos
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero means enter insertion mode. */
end_comment

begin_decl_stmt
name|int
name|vi_doing_insert
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* String inserted into the line by rl_vi_comment (). */
end_comment

begin_decl_stmt
name|char
modifier|*
name|rl_vi_comment_begin
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* *** UNCLEAN *** */
end_comment

begin_comment
comment|/* Command keys which do movement for xxx_to commands. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|vi_motion
init|=
literal|" hl^$0ftFt;,%wbeWBE|"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Keymap used for vi replace characters.  Created dynamically since    rarely used. */
end_comment

begin_decl_stmt
specifier|static
name|Keymap
name|vi_replace_map
init|=
operator|(
name|Keymap
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The number of characters inserted in the last replace operation. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|vi_replace_count
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Yank the nth arg from the previous line into this line at point. */
end_comment

begin_macro
name|rl_vi_yank_arg
argument_list|(
argument|count
argument_list|)
end_macro

begin_decl_stmt
name|int
name|count
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* Readline thinks that the first word on a line is the 0th, while vi      thinks the first word on a line is the 1st.  Compensate. */
if|if
condition|(
name|rl_explicit_arg
condition|)
name|rl_yank_nth_arg
argument_list|(
name|count
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|rl_yank_nth_arg
argument_list|(
literal|'$'
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* With an argument, move back that many history lines, else move to the    beginning of history. */
end_comment

begin_macro
name|rl_vi_fetch_history
argument_list|(
argument|count
argument_list|,
argument|c
argument_list|)
end_macro

begin_decl_stmt
name|int
name|count
decl_stmt|,
name|c
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|extern
name|int
name|rl_explicit_arg
decl_stmt|;
name|int
name|current
init|=
name|where_history
argument_list|()
decl_stmt|;
comment|/* Giving an argument of n means we want the nth command in the history      file.  The command number is interpreted the same way that the bash      `history' command does it -- that is, giving an argument count of 450      to this command would get the command listed as number 450 in the      output of `history'. */
if|if
condition|(
name|rl_explicit_arg
condition|)
block|{
name|int
name|wanted
init|=
name|history_base
operator|+
name|current
operator|-
name|count
decl_stmt|;
if|if
condition|(
name|wanted
operator|<=
literal|0
condition|)
name|rl_beginning_of_history
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|rl_get_previous_history
argument_list|(
name|wanted
argument_list|)
expr_stmt|;
block|}
else|else
name|rl_beginning_of_history
argument_list|(
name|count
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Search again for the last thing searched for. */
end_comment

begin_macro
name|rl_vi_search_again
argument_list|(
argument|ignore
argument_list|,
argument|key
argument_list|)
end_macro

begin_decl_stmt
name|int
name|ignore
decl_stmt|,
name|key
decl_stmt|;
end_decl_stmt

begin_block
block|{
switch|switch
condition|(
name|key
condition|)
block|{
case|case
literal|'n'
case|:
name|rl_vi_dosearch
argument_list|(
name|vi_last_search
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
name|rl_vi_dosearch
argument_list|(
name|vi_last_search
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_block

begin_comment
comment|/* Do a vi style search. */
end_comment

begin_macro
name|rl_vi_search
argument_list|(
argument|count
argument_list|,
argument|key
argument_list|)
end_macro

begin_decl_stmt
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|dir
decl_stmt|,
name|c
decl_stmt|,
name|save_pos
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
switch|switch
condition|(
name|key
condition|)
block|{
case|case
literal|'?'
case|:
name|dir
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'/'
case|:
name|dir
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
default|default:
name|ding
argument_list|()
expr_stmt|;
return|return;
block|}
name|vi_histpos
operator|=
name|where_history
argument_list|()
expr_stmt|;
name|maybe_save_line
argument_list|()
expr_stmt|;
name|save_pos
operator|=
name|rl_point
expr_stmt|;
comment|/* Reuse the line input buffer to read the search string. */
name|rl_line_buffer
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|rl_end
operator|=
name|rl_point
operator|=
literal|0
expr_stmt|;
name|p
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
literal|2
operator|+
operator|(
name|rl_prompt
condition|?
name|strlen
argument_list|(
name|rl_prompt
argument_list|)
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|p
argument_list|,
literal|"%s%c"
argument_list|,
name|rl_prompt
condition|?
name|rl_prompt
else|:
literal|""
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|rl_message
argument_list|(
name|p
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|c
operator|=
name|rl_read_key
argument_list|()
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|CTRL
argument_list|(
literal|'H'
argument_list|)
case|:
case|case
name|RUBOUT
case|:
if|if
condition|(
name|rl_point
operator|==
literal|0
condition|)
block|{
name|maybe_unsave_line
argument_list|()
expr_stmt|;
name|rl_clear_message
argument_list|()
expr_stmt|;
name|rl_point
operator|=
name|save_pos
expr_stmt|;
return|return;
block|}
case|case
name|CTRL
argument_list|(
literal|'W'
argument_list|)
case|:
case|case
name|CTRL
argument_list|(
literal|'U'
argument_list|)
case|:
name|rl_dispatch
argument_list|(
name|c
argument_list|,
name|keymap
argument_list|)
expr_stmt|;
break|break;
case|case
name|ESC
case|:
case|case
name|RETURN
case|:
case|case
name|NEWLINE
case|:
goto|goto
name|dosearch
goto|;
break|break;
case|case
name|CTRL
argument_list|(
literal|'C'
argument_list|)
case|:
name|maybe_unsave_line
argument_list|()
expr_stmt|;
name|rl_clear_message
argument_list|()
expr_stmt|;
name|rl_point
operator|=
literal|0
expr_stmt|;
name|ding
argument_list|()
expr_stmt|;
return|return;
default|default:
name|rl_insert
argument_list|(
literal|1
argument_list|,
name|c
argument_list|)
expr_stmt|;
break|break;
block|}
name|rl_redisplay
argument_list|()
expr_stmt|;
block|}
name|dosearch
label|:
if|if
condition|(
name|vi_last_search
condition|)
name|free
argument_list|(
name|vi_last_search
argument_list|)
expr_stmt|;
name|vi_last_search
operator|=
name|savestring
argument_list|(
name|rl_line_buffer
argument_list|)
expr_stmt|;
name|rl_vi_dosearch
argument_list|(
name|rl_line_buffer
argument_list|,
name|dir
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Search for STRING in the history list.  DIR is< 0 for searching    backwards.  POS is an absolute index into the history list at    which point to begin searching.  If the first character of STRING    is `^', the string must match a prefix of a history line, otherwise    a full substring match is performed. */
end_comment

begin_function
specifier|static
name|int
name|vi_history_search_pos
parameter_list|(
name|string
parameter_list|,
name|dir
parameter_list|,
name|pos
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|dir
decl_stmt|,
name|pos
decl_stmt|;
block|{
name|int
name|ret
decl_stmt|,
name|old
init|=
name|where_history
argument_list|()
decl_stmt|;
name|history_set_pos
argument_list|(
name|pos
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|string
operator|==
literal|'^'
condition|)
name|ret
operator|=
name|history_search_prefix
argument_list|(
name|string
operator|+
literal|1
argument_list|,
name|dir
argument_list|)
expr_stmt|;
else|else
name|ret
operator|=
name|history_search
argument_list|(
name|string
argument_list|,
name|dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
operator|-
literal|1
condition|)
block|{
name|history_set_pos
argument_list|(
name|old
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|ret
operator|=
name|where_history
argument_list|()
expr_stmt|;
name|history_set_pos
argument_list|(
name|old
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_macro
name|rl_vi_dosearch
argument_list|(
argument|string
argument_list|,
argument|dir
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|string
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|dir
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|old
decl_stmt|,
name|save
init|=
name|vi_histpos
decl_stmt|;
name|HIST_ENTRY
modifier|*
name|h
decl_stmt|;
if|if
condition|(
name|string
operator|==
literal|0
operator|||
operator|*
name|string
operator|==
literal|0
operator|||
name|vi_histpos
operator|<
literal|0
condition|)
block|{
name|ding
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|save
operator|=
name|vi_history_search_pos
argument_list|(
name|string
argument_list|,
name|dir
argument_list|,
name|vi_histpos
operator|+
name|dir
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|maybe_unsave_line
argument_list|()
expr_stmt|;
name|rl_clear_message
argument_list|()
expr_stmt|;
name|rl_point
operator|=
literal|0
expr_stmt|;
name|ding
argument_list|()
expr_stmt|;
return|return;
block|}
name|vi_histpos
operator|=
name|save
expr_stmt|;
name|old
operator|=
name|where_history
argument_list|()
expr_stmt|;
name|history_set_pos
argument_list|(
name|vi_histpos
argument_list|)
expr_stmt|;
name|h
operator|=
name|current_history
argument_list|()
expr_stmt|;
name|history_set_pos
argument_list|(
name|old
argument_list|)
expr_stmt|;
block|{
name|int
name|line_len
init|=
name|strlen
argument_list|(
name|h
operator|->
name|line
argument_list|)
decl_stmt|;
if|if
condition|(
name|line_len
operator|>=
name|rl_line_buffer_len
condition|)
name|rl_extend_line_buffer
argument_list|(
name|line_len
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|rl_line_buffer
argument_list|,
name|h
operator|->
name|line
argument_list|)
expr_stmt|;
block|}
name|rl_undo_list
operator|=
operator|(
name|UNDO_LIST
operator|*
operator|)
name|h
operator|->
name|data
expr_stmt|;
name|rl_end
operator|=
name|strlen
argument_list|(
name|rl_line_buffer
argument_list|)
expr_stmt|;
name|rl_point
operator|=
literal|0
expr_stmt|;
name|rl_clear_message
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Completion, from vi's point of view. */
end_comment

begin_macro
name|rl_vi_complete
argument_list|(
argument|ignore
argument_list|,
argument|key
argument_list|)
end_macro

begin_decl_stmt
name|int
name|ignore
decl_stmt|,
name|key
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
operator|(
name|rl_point
operator|<
name|rl_end
operator|)
operator|&&
operator|(
operator|!
name|whitespace
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|whitespace
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
operator|+
literal|1
index|]
argument_list|)
condition|)
name|rl_vi_end_word
argument_list|(
literal|1
argument_list|,
literal|'E'
argument_list|)
expr_stmt|;
name|rl_point
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|key
operator|==
literal|'*'
condition|)
name|rl_complete_internal
argument_list|(
literal|'*'
argument_list|)
expr_stmt|;
comment|/* Expansion and replacement. */
elseif|else
if|if
condition|(
name|key
operator|==
literal|'='
condition|)
name|rl_complete_internal
argument_list|(
literal|'?'
argument_list|)
expr_stmt|;
comment|/* List possible completions. */
elseif|else
if|if
condition|(
name|key
operator|==
literal|'\\'
condition|)
name|rl_complete_internal
argument_list|(
name|TAB
argument_list|)
expr_stmt|;
comment|/* Standard Readline completion. */
else|else
name|rl_complete
argument_list|(
literal|0
argument_list|,
name|key
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Previous word in vi mode. */
end_comment

begin_macro
name|rl_vi_prev_word
argument_list|(
argument|count
argument_list|,
argument|key
argument_list|)
end_macro

begin_decl_stmt
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|count
operator|<
literal|0
condition|)
block|{
name|rl_vi_next_word
argument_list|(
operator|-
name|count
argument_list|,
name|key
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|rl_point
operator|==
literal|0
condition|)
block|{
name|ding
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|uppercase_p
argument_list|(
name|key
argument_list|)
condition|)
name|rl_vi_bWord
argument_list|(
name|count
argument_list|)
expr_stmt|;
else|else
name|rl_vi_bword
argument_list|(
name|count
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Next word in vi mode. */
end_comment

begin_macro
name|rl_vi_next_word
argument_list|(
argument|count
argument_list|,
argument|key
argument_list|)
end_macro

begin_decl_stmt
name|int
name|count
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|count
operator|<
literal|0
condition|)
block|{
name|rl_vi_prev_word
argument_list|(
operator|-
name|count
argument_list|,
name|key
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|rl_point
operator|>=
operator|(
name|rl_end
operator|-
literal|1
operator|)
condition|)
block|{
name|ding
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|uppercase_p
argument_list|(
name|key
argument_list|)
condition|)
name|rl_vi_fWord
argument_list|(
name|count
argument_list|)
expr_stmt|;
else|else
name|rl_vi_fword
argument_list|(
name|count
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Move to the end of the ?next? word. */
end_comment

begin_macro
name|rl_vi_end_word
argument_list|(
argument|count
argument_list|,
argument|key
argument_list|)
end_macro

begin_decl_stmt
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|count
operator|<
literal|0
condition|)
block|{
name|ding
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|uppercase_p
argument_list|(
name|key
argument_list|)
condition|)
name|rl_vi_eWord
argument_list|(
name|count
argument_list|)
expr_stmt|;
else|else
name|rl_vi_eword
argument_list|(
name|count
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Move forward a word the way that 'W' does. */
end_comment

begin_macro
name|rl_vi_fWord
argument_list|(
argument|count
argument_list|)
end_macro

begin_decl_stmt
name|int
name|count
decl_stmt|;
end_decl_stmt

begin_block
block|{
while|while
condition|(
name|count
operator|--
operator|&&
name|rl_point
operator|<
operator|(
name|rl_end
operator|-
literal|1
operator|)
condition|)
block|{
comment|/* Skip until whitespace. */
while|while
condition|(
operator|!
name|whitespace
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
operator|&&
name|rl_point
operator|<
name|rl_end
condition|)
name|rl_point
operator|++
expr_stmt|;
comment|/* Now skip whitespace. */
while|while
condition|(
name|whitespace
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
operator|&&
name|rl_point
operator|<
name|rl_end
condition|)
name|rl_point
operator|++
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|rl_vi_bWord
argument_list|(
argument|count
argument_list|)
end_macro

begin_decl_stmt
name|int
name|count
decl_stmt|;
end_decl_stmt

begin_block
block|{
while|while
condition|(
name|count
operator|--
operator|&&
name|rl_point
operator|>
literal|0
condition|)
block|{
comment|/* If we are at the start of a word, move back to whitespace so 	 we will go back to the start of the previous word. */
if|if
condition|(
operator|!
name|whitespace
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
operator|&&
name|whitespace
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
operator|-
literal|1
index|]
argument_list|)
condition|)
name|rl_point
operator|--
expr_stmt|;
while|while
condition|(
name|rl_point
operator|>
literal|0
operator|&&
name|whitespace
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
condition|)
name|rl_point
operator|--
expr_stmt|;
if|if
condition|(
name|rl_point
operator|>
literal|0
condition|)
block|{
while|while
condition|(
operator|--
name|rl_point
operator|>=
literal|0
operator|&&
operator|!
name|whitespace
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
condition|)
empty_stmt|;
name|rl_point
operator|++
expr_stmt|;
block|}
block|}
block|}
end_block

begin_macro
name|rl_vi_eWord
argument_list|(
argument|count
argument_list|)
end_macro

begin_decl_stmt
name|int
name|count
decl_stmt|;
end_decl_stmt

begin_block
block|{
while|while
condition|(
name|count
operator|--
operator|&&
name|rl_point
operator|<
operator|(
name|rl_end
operator|-
literal|1
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|whitespace
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
condition|)
name|rl_point
operator|++
expr_stmt|;
comment|/* Move to the next non-whitespace character (to the start of the 	 next word). */
while|while
condition|(
operator|++
name|rl_point
operator|<
name|rl_end
operator|&&
name|whitespace
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
condition|)
empty_stmt|;
if|if
condition|(
name|rl_point
operator|&&
name|rl_point
operator|<
name|rl_end
condition|)
block|{
comment|/* Skip whitespace. */
while|while
condition|(
name|rl_point
operator|<
name|rl_end
operator|&&
name|whitespace
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
condition|)
name|rl_point
operator|++
expr_stmt|;
comment|/* Skip until whitespace. */
while|while
condition|(
name|rl_point
operator|<
name|rl_end
operator|&&
operator|!
name|whitespace
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
condition|)
name|rl_point
operator|++
expr_stmt|;
comment|/* Move back to the last character of the word. */
name|rl_point
operator|--
expr_stmt|;
block|}
block|}
block|}
end_block

begin_macro
name|rl_vi_fword
argument_list|(
argument|count
argument_list|)
end_macro

begin_decl_stmt
name|int
name|count
decl_stmt|;
end_decl_stmt

begin_block
block|{
while|while
condition|(
name|count
operator|--
operator|&&
name|rl_point
operator|<
operator|(
name|rl_end
operator|-
literal|1
operator|)
condition|)
block|{
comment|/* Move to white space (really non-identifer). */
if|if
condition|(
name|isident
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
condition|)
block|{
while|while
condition|(
name|isident
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
operator|&&
name|rl_point
operator|<
name|rl_end
condition|)
name|rl_point
operator|++
expr_stmt|;
block|}
else|else
comment|/* if (!whitespace (rl_line_buffer[rl_point])) */
block|{
while|while
condition|(
operator|!
name|isident
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
operator|&&
operator|!
name|whitespace
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
operator|&&
name|rl_point
operator|<
name|rl_end
condition|)
name|rl_point
operator|++
expr_stmt|;
block|}
comment|/* Move past whitespace. */
while|while
condition|(
name|whitespace
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
operator|&&
name|rl_point
operator|<
name|rl_end
condition|)
name|rl_point
operator|++
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|rl_vi_bword
argument_list|(
argument|count
argument_list|)
end_macro

begin_decl_stmt
name|int
name|count
decl_stmt|;
end_decl_stmt

begin_block
block|{
while|while
condition|(
name|count
operator|--
operator|&&
name|rl_point
operator|>
literal|0
condition|)
block|{
name|int
name|last_is_ident
decl_stmt|;
comment|/* If we are at the start of a word, move back to whitespace 	 so we will go back to the start of the previous word. */
if|if
condition|(
operator|!
name|whitespace
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
operator|&&
name|whitespace
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
operator|-
literal|1
index|]
argument_list|)
condition|)
name|rl_point
operator|--
expr_stmt|;
comment|/* If this character and the previous character are `opposite', move 	 back so we don't get messed up by the rl_point++ down there in 	 the while loop.  Without this code, words like `l;' screw up the 	 function. */
name|last_is_ident
operator|=
name|isident
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|isident
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
operator|&&
operator|!
name|last_is_ident
operator|)
operator|||
operator|(
operator|!
name|isident
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
operator|&&
name|last_is_ident
operator|)
condition|)
name|rl_point
operator|--
expr_stmt|;
while|while
condition|(
name|rl_point
operator|>
literal|0
operator|&&
name|whitespace
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
condition|)
name|rl_point
operator|--
expr_stmt|;
if|if
condition|(
name|rl_point
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|isident
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
condition|)
while|while
condition|(
operator|--
name|rl_point
operator|>=
literal|0
operator|&&
name|isident
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
condition|)
empty_stmt|;
else|else
while|while
condition|(
operator|--
name|rl_point
operator|>=
literal|0
operator|&&
operator|!
name|isident
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
operator|&&
operator|!
name|whitespace
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
condition|)
empty_stmt|;
name|rl_point
operator|++
expr_stmt|;
block|}
block|}
block|}
end_block

begin_macro
name|rl_vi_eword
argument_list|(
argument|count
argument_list|)
end_macro

begin_decl_stmt
name|int
name|count
decl_stmt|;
end_decl_stmt

begin_block
block|{
while|while
condition|(
name|count
operator|--
operator|&&
name|rl_point
operator|<
name|rl_end
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|whitespace
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
condition|)
name|rl_point
operator|++
expr_stmt|;
while|while
condition|(
name|rl_point
operator|<
name|rl_end
operator|&&
name|whitespace
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
condition|)
name|rl_point
operator|++
expr_stmt|;
if|if
condition|(
name|rl_point
operator|<
name|rl_end
condition|)
block|{
if|if
condition|(
name|isident
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
condition|)
while|while
condition|(
operator|++
name|rl_point
operator|<
name|rl_end
operator|&&
name|isident
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
condition|)
empty_stmt|;
else|else
while|while
condition|(
operator|++
name|rl_point
operator|<
name|rl_end
operator|&&
operator|!
name|isident
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
operator|&&
operator|!
name|whitespace
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
condition|)
empty_stmt|;
block|}
name|rl_point
operator|--
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|rl_vi_insert_beg
argument_list|()
end_macro

begin_block
block|{
name|rl_beg_of_line
argument_list|()
expr_stmt|;
name|rl_vi_insertion_mode
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_macro
name|rl_vi_append_mode
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|rl_point
operator|<
name|rl_end
condition|)
name|rl_point
operator|+=
literal|1
expr_stmt|;
name|rl_vi_insertion_mode
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_macro
name|rl_vi_append_eol
argument_list|()
end_macro

begin_block
block|{
name|rl_end_of_line
argument_list|()
expr_stmt|;
name|rl_vi_append_mode
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* What to do in the case of C-d. */
end_comment

begin_macro
name|rl_vi_eof_maybe
argument_list|(
argument|count
argument_list|,
argument|c
argument_list|)
end_macro

begin_decl_stmt
name|int
name|count
decl_stmt|,
name|c
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|rl_newline
argument_list|(
literal|1
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Insertion mode stuff. */
end_comment

begin_comment
comment|/* Switching from one mode to the other really just involves    switching keymaps. */
end_comment

begin_macro
name|rl_vi_insertion_mode
argument_list|()
end_macro

begin_block
block|{
name|keymap
operator|=
name|vi_insertion_keymap
expr_stmt|;
block|}
end_block

begin_macro
name|rl_vi_movement_mode
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|rl_point
operator|>
literal|0
condition|)
name|rl_backward
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|keymap
operator|=
name|vi_movement_keymap
expr_stmt|;
name|vi_done_inserting
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|vi_done_inserting
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|vi_doing_insert
condition|)
block|{
name|rl_end_undo_group
argument_list|()
expr_stmt|;
name|vi_doing_insert
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|rl_vi_arg_digit
argument_list|(
argument|count
argument_list|,
argument|c
argument_list|)
end_macro

begin_decl_stmt
name|int
name|count
decl_stmt|,
name|c
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|c
operator|==
literal|'0'
operator|&&
name|rl_numeric_arg
operator|==
literal|1
operator|&&
operator|!
name|rl_explicit_arg
condition|)
name|rl_beg_of_line
argument_list|()
expr_stmt|;
else|else
name|rl_digit_argument
argument_list|(
name|count
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|rl_vi_change_case
argument_list|(
argument|count
argument_list|,
argument|ignore
argument_list|)
end_macro

begin_decl_stmt
name|int
name|count
decl_stmt|,
name|ignore
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|c
init|=
literal|0
decl_stmt|;
comment|/* Don't try this on an empty line. */
if|if
condition|(
name|rl_point
operator|>=
name|rl_end
condition|)
return|return;
while|while
condition|(
name|count
operator|--
operator|&&
name|rl_point
operator|<
name|rl_end
condition|)
block|{
if|if
condition|(
name|uppercase_p
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
condition|)
name|c
operator|=
name|to_lower
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|lowercase_p
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
condition|)
name|c
operator|=
name|to_upper
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
expr_stmt|;
comment|/* Vi is kind of strange here. */
if|if
condition|(
name|c
condition|)
block|{
name|rl_begin_undo_group
argument_list|()
expr_stmt|;
name|rl_delete
argument_list|(
literal|1
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|rl_insert
argument_list|(
literal|1
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|rl_end_undo_group
argument_list|()
expr_stmt|;
name|rl_vi_check
argument_list|()
expr_stmt|;
block|}
else|else
name|rl_forward
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|rl_vi_put
argument_list|(
argument|count
argument_list|,
argument|key
argument_list|)
end_macro

begin_decl_stmt
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
operator|!
name|uppercase_p
argument_list|(
name|key
argument_list|)
operator|&&
operator|(
name|rl_point
operator|+
literal|1
operator|<=
name|rl_end
operator|)
condition|)
name|rl_point
operator|++
expr_stmt|;
name|rl_yank
argument_list|()
expr_stmt|;
name|rl_backward
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|rl_vi_check
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|rl_point
operator|&&
name|rl_point
operator|==
name|rl_end
condition|)
name|rl_point
operator|--
expr_stmt|;
block|}
end_block

begin_macro
name|rl_vi_column
argument_list|(
argument|count
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
name|count
operator|>
name|rl_end
condition|)
name|rl_end_of_line
argument_list|()
expr_stmt|;
else|else
name|rl_point
operator|=
name|count
operator|-
literal|1
expr_stmt|;
block|}
end_block

begin_function
name|int
name|rl_vi_domove
parameter_list|(
name|key
parameter_list|,
name|nextkey
parameter_list|)
name|int
name|key
decl_stmt|,
decl|*
name|nextkey
decl_stmt|;
end_function

begin_block
block|{
name|int
name|c
decl_stmt|,
name|save
decl_stmt|;
name|int
name|old_end
decl_stmt|,
name|added_blank
decl_stmt|;
name|added_blank
operator|=
literal|0
expr_stmt|;
name|rl_mark
operator|=
name|rl_point
expr_stmt|;
name|c
operator|=
name|rl_read_key
argument_list|()
expr_stmt|;
operator|*
name|nextkey
operator|=
name|c
expr_stmt|;
if|if
condition|(
operator|!
name|member
argument_list|(
name|c
argument_list|,
name|vi_motion
argument_list|)
condition|)
block|{
if|if
condition|(
name|digit
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|save
operator|=
name|rl_numeric_arg
expr_stmt|;
name|rl_numeric_arg
operator|=
name|digit_value
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|rl_digit_loop1
argument_list|()
expr_stmt|;
name|rl_numeric_arg
operator|*=
name|save
expr_stmt|;
name|c
operator|=
name|rl_read_key
argument_list|()
expr_stmt|;
comment|/* real command */
operator|*
name|nextkey
operator|=
name|c
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|key
operator|==
literal|'d'
operator|&&
name|c
operator|==
literal|'d'
operator|)
operator|||
operator|(
name|key
operator|==
literal|'y'
operator|&&
name|c
operator|==
literal|'y'
operator|)
operator|||
operator|(
name|key
operator|==
literal|'c'
operator|&&
name|c
operator|==
literal|'c'
operator|)
condition|)
block|{
name|rl_mark
operator|=
name|rl_end
expr_stmt|;
name|rl_beg_of_line
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* Append a blank character temporarily so that the motion routines      work right at the end of the line. */
name|old_end
operator|=
name|rl_end
expr_stmt|;
name|rl_line_buffer
index|[
name|rl_end
operator|++
index|]
operator|=
literal|' '
expr_stmt|;
comment|/* This looks pretty bogus to me??? */
name|rl_line_buffer
index|[
name|rl_end
index|]
operator|=
literal|'\0'
expr_stmt|;
name|added_blank
operator|++
expr_stmt|;
name|rl_dispatch
argument_list|(
name|c
argument_list|,
name|keymap
argument_list|)
expr_stmt|;
comment|/* Remove the blank that we added. */
name|rl_end
operator|=
name|old_end
expr_stmt|;
name|rl_line_buffer
index|[
name|rl_end
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|rl_point
operator|>
name|rl_end
condition|)
name|rl_point
operator|=
name|rl_end
operator|-
literal|1
expr_stmt|;
comment|/* No change in position means the command failed. */
if|if
condition|(
name|rl_mark
operator|==
name|rl_point
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* rl_vi_f[wW]ord () leaves the cursor on the first character of the next      word.  If we are not at the end of the line, and we are on a      non-whitespace character, move back one (presumably to whitespace). */
if|if
condition|(
operator|(
name|c
operator|==
literal|'w'
operator|||
name|c
operator|==
literal|'W'
operator|)
operator|&&
operator|(
name|rl_point
operator|<
name|rl_end
operator|)
operator|&&
operator|!
name|whitespace
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
condition|)
name|rl_point
operator|--
expr_stmt|;
comment|/* If cw or cW, back up to the end of a word, so the behaviour of ce      or cE is the actual result.  Brute-force, no subtlety.  Do the same      thing for dw or dW. */
if|if
condition|(
name|key
operator|==
literal|'c'
operator|&&
operator|(
name|to_upper
argument_list|(
name|c
argument_list|)
operator|==
literal|'W'
operator|)
condition|)
block|{
while|while
condition|(
name|rl_point
operator|&&
name|whitespace
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
condition|)
name|rl_point
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|rl_mark
operator|<
name|rl_point
condition|)
name|exchange
argument_list|(
name|rl_point
argument_list|,
name|rl_mark
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/* A simplified loop for vi. Don't dispatch key at end.    Don't recognize minus sign? */
end_comment

begin_macro
name|rl_digit_loop1
argument_list|()
end_macro

begin_block
block|{
name|int
name|key
decl_stmt|,
name|c
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|rl_message
argument_list|(
literal|"(arg: %d) "
argument_list|,
name|rl_arg_sign
operator|*
name|rl_numeric_arg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|key
operator|=
name|c
operator|=
name|rl_read_key
argument_list|()
expr_stmt|;
if|if
condition|(
name|keymap
index|[
name|c
index|]
operator|.
name|type
operator|==
name|ISFUNC
operator|&&
name|keymap
index|[
name|c
index|]
operator|.
name|function
operator|==
name|rl_universal_argument
condition|)
block|{
name|rl_numeric_arg
operator|*=
literal|4
expr_stmt|;
continue|continue;
block|}
name|c
operator|=
name|UNMETA
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|numeric
argument_list|(
name|c
argument_list|)
condition|)
block|{
if|if
condition|(
name|rl_explicit_arg
condition|)
name|rl_numeric_arg
operator|=
operator|(
name|rl_numeric_arg
operator|*
literal|10
operator|)
operator|+
name|digit_value
argument_list|(
name|c
argument_list|)
expr_stmt|;
else|else
name|rl_numeric_arg
operator|=
name|digit_value
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|rl_explicit_arg
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|rl_clear_message
argument_list|()
expr_stmt|;
name|rl_stuff_char
argument_list|(
name|key
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_block

begin_macro
name|rl_vi_delete_to
argument_list|(
argument|count
argument_list|,
argument|key
argument_list|)
end_macro

begin_decl_stmt
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|c
decl_stmt|;
if|if
condition|(
name|uppercase_p
argument_list|(
name|key
argument_list|)
condition|)
name|rl_stuff_char
argument_list|(
literal|'$'
argument_list|)
expr_stmt|;
if|if
condition|(
name|rl_vi_domove
argument_list|(
name|key
argument_list|,
operator|&
name|c
argument_list|)
condition|)
block|{
name|ding
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|c
operator|!=
literal|'l'
operator|)
operator|&&
operator|(
name|c
operator|!=
literal|'|'
operator|)
operator|&&
operator|(
name|c
operator|!=
literal|'h'
operator|)
operator|&&
name|rl_mark
operator|<
name|rl_end
condition|)
name|rl_mark
operator|++
expr_stmt|;
name|rl_kill_text
argument_list|(
name|rl_point
argument_list|,
name|rl_mark
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|rl_vi_change_to
argument_list|(
argument|count
argument_list|,
argument|key
argument_list|)
end_macro

begin_decl_stmt
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|c
decl_stmt|;
if|if
condition|(
name|uppercase_p
argument_list|(
name|key
argument_list|)
condition|)
name|rl_stuff_char
argument_list|(
literal|'$'
argument_list|)
expr_stmt|;
if|if
condition|(
name|rl_vi_domove
argument_list|(
name|key
argument_list|,
operator|&
name|c
argument_list|)
condition|)
block|{
name|ding
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|c
operator|!=
literal|'l'
operator|)
operator|&&
operator|(
name|c
operator|!=
literal|'|'
operator|)
operator|&&
operator|(
name|c
operator|!=
literal|'h'
operator|)
operator|&&
name|rl_mark
operator|<
name|rl_end
condition|)
name|rl_mark
operator|++
expr_stmt|;
name|rl_begin_undo_group
argument_list|()
expr_stmt|;
name|vi_doing_insert
operator|=
literal|1
expr_stmt|;
name|rl_kill_text
argument_list|(
name|rl_point
argument_list|,
name|rl_mark
argument_list|)
expr_stmt|;
name|rl_vi_insertion_mode
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|rl_vi_yank_to
argument_list|(
argument|count
argument_list|,
argument|key
argument_list|)
end_macro

begin_decl_stmt
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|c
decl_stmt|,
name|save
init|=
name|rl_point
decl_stmt|;
if|if
condition|(
name|uppercase_p
argument_list|(
name|key
argument_list|)
condition|)
name|rl_stuff_char
argument_list|(
literal|'$'
argument_list|)
expr_stmt|;
if|if
condition|(
name|rl_vi_domove
argument_list|(
name|key
argument_list|,
operator|&
name|c
argument_list|)
condition|)
block|{
name|ding
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|c
operator|!=
literal|'l'
operator|)
operator|&&
operator|(
name|c
operator|!=
literal|'|'
operator|)
operator|&&
operator|(
name|c
operator|!=
literal|'h'
operator|)
operator|&&
name|rl_mark
operator|<
name|rl_end
condition|)
name|rl_mark
operator|++
expr_stmt|;
name|rl_begin_undo_group
argument_list|()
expr_stmt|;
name|rl_kill_text
argument_list|(
name|rl_point
argument_list|,
name|rl_mark
argument_list|)
expr_stmt|;
name|rl_end_undo_group
argument_list|()
expr_stmt|;
name|rl_do_undo
argument_list|()
expr_stmt|;
name|rl_point
operator|=
name|save
expr_stmt|;
block|}
end_block

begin_macro
name|rl_vi_delete
argument_list|(
argument|count
argument_list|)
end_macro

begin_block
block|{
name|int
name|end
decl_stmt|;
if|if
condition|(
name|rl_end
operator|==
literal|0
condition|)
block|{
name|ding
argument_list|()
expr_stmt|;
return|return;
block|}
name|end
operator|=
name|rl_point
operator|+
name|count
expr_stmt|;
if|if
condition|(
name|end
operator|>=
name|rl_end
condition|)
name|end
operator|=
name|rl_end
expr_stmt|;
name|rl_kill_text
argument_list|(
name|rl_point
argument_list|,
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
name|rl_point
operator|>
literal|0
operator|&&
name|rl_point
operator|==
name|rl_end
condition|)
name|rl_backward
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Turn the current line into a comment in shell history.    A K*rn shell style function. */
end_comment

begin_macro
name|rl_vi_comment
argument_list|()
end_macro

begin_block
block|{
name|rl_beg_of_line
argument_list|()
expr_stmt|;
if|if
condition|(
name|rl_vi_comment_begin
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
name|rl_insert_text
argument_list|(
name|rl_vi_comment_begin
argument_list|)
expr_stmt|;
else|else
name|rl_insert_text
argument_list|(
literal|": "
argument_list|)
expr_stmt|;
comment|/* Default. */
name|rl_redisplay
argument_list|()
expr_stmt|;
name|rl_newline
argument_list|(
literal|1
argument_list|,
literal|'\010'
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|rl_vi_first_print
argument_list|()
end_macro

begin_block
block|{
name|rl_back_to_indent
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|rl_back_to_indent
argument_list|(
argument|ignore1
argument_list|,
argument|ignore2
argument_list|)
end_macro

begin_decl_stmt
name|int
name|ignore1
decl_stmt|,
name|ignore2
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|rl_beg_of_line
argument_list|()
expr_stmt|;
while|while
condition|(
name|rl_point
operator|<
name|rl_end
operator|&&
name|whitespace
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
condition|)
name|rl_point
operator|++
expr_stmt|;
block|}
end_block

begin_comment
comment|/* NOTE: it is necessary that opposite directions are inverses */
end_comment

begin_define
define|#
directive|define
name|FTO
value|1
end_define

begin_comment
comment|/* forward to */
end_comment

begin_define
define|#
directive|define
name|BTO
value|-1
end_define

begin_comment
comment|/* backward to */
end_comment

begin_define
define|#
directive|define
name|FFIND
value|2
end_define

begin_comment
comment|/* forward find */
end_comment

begin_define
define|#
directive|define
name|BFIND
value|-2
end_define

begin_comment
comment|/* backward find */
end_comment

begin_macro
name|rl_vi_char_search
argument_list|(
argument|count
argument_list|,
argument|key
argument_list|)
end_macro

begin_decl_stmt
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|static
name|char
name|target
decl_stmt|;
specifier|static
name|int
name|orig_dir
decl_stmt|,
name|dir
decl_stmt|;
name|int
name|pos
decl_stmt|;
if|if
condition|(
name|key
operator|==
literal|';'
operator|||
name|key
operator|==
literal|','
condition|)
name|dir
operator|=
operator|(
name|key
operator|==
literal|';'
condition|?
name|orig_dir
else|:
operator|-
name|orig_dir
operator|)
expr_stmt|;
else|else
block|{
name|target
operator|=
name|rl_getc
argument_list|(
name|rl_instream
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|key
condition|)
block|{
case|case
literal|'t'
case|:
name|orig_dir
operator|=
name|dir
operator|=
name|FTO
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
name|orig_dir
operator|=
name|dir
operator|=
name|BTO
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|orig_dir
operator|=
name|dir
operator|=
name|FFIND
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
name|orig_dir
operator|=
name|dir
operator|=
name|BFIND
expr_stmt|;
break|break;
block|}
block|}
name|pos
operator|=
name|rl_point
expr_stmt|;
while|while
condition|(
name|count
operator|--
condition|)
block|{
if|if
condition|(
name|dir
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|pos
operator|==
literal|0
condition|)
block|{
name|ding
argument_list|()
expr_stmt|;
return|return;
block|}
name|pos
operator|--
expr_stmt|;
do|do
block|{
if|if
condition|(
name|rl_line_buffer
index|[
name|pos
index|]
operator|==
name|target
condition|)
block|{
if|if
condition|(
name|dir
operator|==
name|BTO
condition|)
name|rl_point
operator|=
name|pos
operator|+
literal|1
expr_stmt|;
else|else
name|rl_point
operator|=
name|pos
expr_stmt|;
break|break;
block|}
block|}
do|while
condition|(
name|pos
operator|--
condition|)
do|;
if|if
condition|(
name|pos
operator|<
literal|0
condition|)
block|{
name|ding
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
comment|/* dir> 0 */
if|if
condition|(
name|pos
operator|>=
name|rl_end
condition|)
block|{
name|ding
argument_list|()
expr_stmt|;
return|return;
block|}
name|pos
operator|++
expr_stmt|;
do|do
block|{
if|if
condition|(
name|rl_line_buffer
index|[
name|pos
index|]
operator|==
name|target
condition|)
block|{
if|if
condition|(
name|dir
operator|==
name|FTO
condition|)
name|rl_point
operator|=
name|pos
operator|-
literal|1
expr_stmt|;
else|else
name|rl_point
operator|=
name|pos
expr_stmt|;
break|break;
block|}
block|}
do|while
condition|(
operator|++
name|pos
operator|<
name|rl_end
condition|)
do|;
if|if
condition|(
name|pos
operator|>=
operator|(
name|rl_end
operator|-
literal|1
operator|)
condition|)
block|{
name|ding
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
block|}
block|}
end_block

begin_comment
comment|/* Match brackets */
end_comment

begin_macro
name|rl_vi_match
argument_list|()
end_macro

begin_block
block|{
name|int
name|count
init|=
literal|1
decl_stmt|,
name|brack
decl_stmt|,
name|pos
decl_stmt|;
name|pos
operator|=
name|rl_point
expr_stmt|;
if|if
condition|(
operator|(
name|brack
operator|=
name|rl_vi_bracktype
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
while|while
condition|(
operator|(
name|brack
operator|=
name|rl_vi_bracktype
argument_list|(
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
operator|)
operator|==
literal|0
operator|&&
name|rl_point
operator|<
name|rl_end
operator|-
literal|1
condition|)
name|rl_forward
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|brack
operator|<=
literal|0
condition|)
block|{
name|rl_point
operator|=
name|pos
expr_stmt|;
name|ding
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
name|pos
operator|=
name|rl_point
expr_stmt|;
if|if
condition|(
name|brack
operator|<
literal|0
condition|)
block|{
while|while
condition|(
name|count
condition|)
block|{
if|if
condition|(
operator|--
name|pos
operator|>=
literal|0
condition|)
block|{
name|int
name|b
init|=
name|rl_vi_bracktype
argument_list|(
name|rl_line_buffer
index|[
name|pos
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|b
operator|==
operator|-
name|brack
condition|)
name|count
operator|--
expr_stmt|;
elseif|else
if|if
condition|(
name|b
operator|==
name|brack
condition|)
name|count
operator|++
expr_stmt|;
block|}
else|else
block|{
name|ding
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
block|}
else|else
block|{
comment|/* brack> 0 */
while|while
condition|(
name|count
condition|)
block|{
if|if
condition|(
operator|++
name|pos
operator|<
name|rl_end
condition|)
block|{
name|int
name|b
init|=
name|rl_vi_bracktype
argument_list|(
name|rl_line_buffer
index|[
name|pos
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|b
operator|==
operator|-
name|brack
condition|)
name|count
operator|--
expr_stmt|;
elseif|else
if|if
condition|(
name|b
operator|==
name|brack
condition|)
name|count
operator|++
expr_stmt|;
block|}
else|else
block|{
name|ding
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
block|}
name|rl_point
operator|=
name|pos
expr_stmt|;
block|}
end_block

begin_function
name|int
name|rl_vi_bracktype
parameter_list|(
name|c
parameter_list|)
name|int
name|c
decl_stmt|;
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'('
case|:
return|return
literal|1
return|;
case|case
literal|')'
case|:
return|return
operator|-
literal|1
return|;
case|case
literal|'['
case|:
return|return
literal|2
return|;
case|case
literal|']'
case|:
return|return
operator|-
literal|2
return|;
case|case
literal|'{'
case|:
return|return
literal|3
return|;
case|case
literal|'}'
case|:
return|return
operator|-
literal|3
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_macro
name|rl_vi_change_char
argument_list|(
argument|count
argument_list|,
argument|key
argument_list|)
end_macro

begin_decl_stmt
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|c
decl_stmt|;
name|c
operator|=
name|rl_getc
argument_list|(
name|rl_instream
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\033'
operator|||
name|c
operator|==
name|CTRL
argument_list|(
literal|'C'
argument_list|)
condition|)
return|return;
while|while
condition|(
name|count
operator|--
operator|&&
name|rl_point
operator|<
name|rl_end
condition|)
block|{
name|rl_begin_undo_group
argument_list|()
expr_stmt|;
name|rl_delete
argument_list|(
literal|1
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|rl_insert
argument_list|(
literal|1
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
name|rl_backward
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|rl_end_undo_group
argument_list|()
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|rl_vi_subst
argument_list|(
argument|count
argument_list|,
argument|key
argument_list|)
end_macro

begin_decl_stmt
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|rl_begin_undo_group
argument_list|()
expr_stmt|;
name|vi_doing_insert
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|uppercase_p
argument_list|(
name|key
argument_list|)
condition|)
block|{
name|rl_beg_of_line
argument_list|()
expr_stmt|;
name|rl_kill_line
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|rl_delete
argument_list|(
name|count
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|rl_end_undo_group
argument_list|()
expr_stmt|;
name|rl_vi_insertion_mode
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|rl_vi_overstrike
argument_list|(
argument|count
argument_list|,
argument|key
argument_list|)
end_macro

begin_decl_stmt
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|vi_doing_insert
operator|==
literal|0
condition|)
block|{
name|vi_doing_insert
operator|=
literal|1
expr_stmt|;
name|rl_begin_undo_group
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|vi_replace_count
operator|++
expr_stmt|;
name|rl_begin_undo_group
argument_list|()
expr_stmt|;
if|if
condition|(
name|rl_point
operator|<
name|rl_end
condition|)
block|{
name|rl_delete
argument_list|(
literal|1
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|rl_insert
argument_list|(
literal|1
argument_list|,
name|key
argument_list|)
expr_stmt|;
block|}
else|else
name|rl_insert
argument_list|(
literal|1
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|rl_end_undo_group
argument_list|()
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|rl_vi_overstrike_delete
argument_list|(
argument|count
argument_list|)
end_macro

begin_decl_stmt
name|int
name|count
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|,
name|s
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|vi_replace_count
operator|==
literal|0
condition|)
block|{
name|ding
argument_list|()
expr_stmt|;
break|break;
block|}
name|s
operator|=
name|rl_point
expr_stmt|;
if|if
condition|(
name|rl_do_undo
argument_list|()
condition|)
name|vi_replace_count
operator|--
expr_stmt|;
if|if
condition|(
name|rl_point
operator|==
name|s
condition|)
name|rl_backward
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|vi_replace_count
operator|==
literal|0
operator|&&
name|vi_doing_insert
condition|)
block|{
name|rl_end_undo_group
argument_list|()
expr_stmt|;
name|rl_do_undo
argument_list|()
expr_stmt|;
name|vi_doing_insert
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|rl_vi_replace
argument_list|(
argument|count
argument_list|,
argument|key
argument_list|)
end_macro

begin_decl_stmt
name|int
name|count
decl_stmt|,
name|key
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
name|vi_replace_count
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|vi_replace_map
condition|)
block|{
name|vi_replace_map
operator|=
name|rl_make_bare_keymap
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|' '
init|;
name|i
operator|<
literal|127
condition|;
name|i
operator|++
control|)
name|vi_replace_map
index|[
name|i
index|]
operator|.
name|function
operator|=
name|rl_vi_overstrike
expr_stmt|;
name|vi_replace_map
index|[
name|RUBOUT
index|]
operator|.
name|function
operator|=
name|rl_vi_overstrike_delete
expr_stmt|;
name|vi_replace_map
index|[
name|ESC
index|]
operator|.
name|function
operator|=
name|rl_vi_movement_mode
expr_stmt|;
name|vi_replace_map
index|[
name|RETURN
index|]
operator|.
name|function
operator|=
name|rl_newline
expr_stmt|;
name|vi_replace_map
index|[
name|NEWLINE
index|]
operator|.
name|function
operator|=
name|rl_newline
expr_stmt|;
comment|/* If the normal vi insertion keymap has ^H bound to erase, do the          same here.  Probably should remove the assignment to RUBOUT up          there, but I don't think it will make a difference in real life. */
if|if
condition|(
name|vi_insertion_keymap
index|[
name|CTRL
argument_list|(
literal|'H'
argument_list|)
index|]
operator|.
name|type
operator|==
name|ISFUNC
operator|&&
name|vi_insertion_keymap
index|[
name|CTRL
argument_list|(
literal|'H'
argument_list|)
index|]
operator|.
name|function
operator|==
name|rl_rubout
condition|)
name|vi_replace_map
index|[
name|CTRL
argument_list|(
literal|'H'
argument_list|)
index|]
operator|.
name|function
operator|=
name|rl_vi_overstrike_delete
expr_stmt|;
block|}
name|keymap
operator|=
name|vi_replace_map
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Try to complete the word we are standing on or the word that ends with  * the previous character. A space matches everything.  * Word delimiters are space and ;.  */
end_comment

begin_macro
name|rl_vi_possible_completions
argument_list|()
end_macro

begin_block
block|{
name|int
name|save_pos
init|=
name|rl_point
decl_stmt|;
if|if
condition|(
operator|!
name|index
argument_list|(
literal|" ;"
argument_list|,
name|rl_line_buffer
index|[
name|rl_point
index|]
argument_list|)
condition|)
block|{
while|while
condition|(
operator|!
name|index
argument_list|(
literal|" ;"
argument_list|,
name|rl_line_buffer
index|[
operator|++
name|rl_point
index|]
argument_list|)
condition|)
empty_stmt|;
block|}
elseif|else
if|if
condition|(
name|rl_line_buffer
index|[
name|rl_point
operator|-
literal|1
index|]
operator|==
literal|';'
condition|)
block|{
name|ding
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|rl_possible_completions
argument_list|()
expr_stmt|;
name|rl_point
operator|=
name|save_pos
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* VI_MODE */
end_comment

end_unit

