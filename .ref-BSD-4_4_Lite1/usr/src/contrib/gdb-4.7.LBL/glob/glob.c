begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* File-name wildcard pattern matching for GNU.    Copyright (C) 1985, 1988, 1989, 1991 Free Software Foundation, Inc.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_escape
end_escape

begin_comment
comment|/* To whomever it may concern: I have never seen the code which most    Unix programs use to perform this function.  I wrote this from scratch    based on specifications for the pattern matching.  --RMS.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|SHELL
argument_list|)
end_if

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|USG
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Xenix
argument_list|)
end_if

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|USGr3
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|USGr4
argument_list|)
end_if

begin_define
define|#
directive|define
name|USGr3
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USGr3 */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USG&& !Xenix */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_POSIX_VERSION
argument_list|)
operator|||
name|defined
argument_list|(
name|USGr3
argument_list|)
operator|||
name|defined
argument_list|(
name|USGr4
argument_list|)
operator|||
name|defined
argument_list|(
name|DIRENT
argument_list|)
end_if

begin_include
include|#
directive|include
file|<dirent.h>
end_include

begin_define
define|#
directive|define
name|direct
value|dirent
end_define

begin_define
define|#
directive|define
name|D_NAMLEN
parameter_list|(
name|d
parameter_list|)
value|strlen((d)->d_name)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|D_NAMLEN
parameter_list|(
name|d
parameter_list|)
value|((d)->d_namlen)
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|Xenix
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/ndir.h>
end_include

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
name|defined
argument_list|(
name|USG
argument_list|)
end_if

begin_include
include|#
directive|include
file|"ndir.h"
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<sys/dir.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USGr3 || DIRENT.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_POSIX_SOURCE
argument_list|)
end_if

begin_comment
comment|/* Posix does not require that the d_ino field be present, and some    systems do not provide it. */
end_comment

begin_define
define|#
directive|define
name|REAL_DIR_ENTRY
parameter_list|(
name|dp
parameter_list|)
value|1
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|REAL_DIR_ENTRY
parameter_list|(
name|dp
parameter_list|)
value|(dp->d_ino != 0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _POSIX_SOURCE */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|NeXT
argument_list|)
end_if

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
name|defined
argument_list|(
name|USG
argument_list|)
end_if

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|isc386
argument_list|)
end_if

begin_include
include|#
directive|include
file|<memory.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|RISC6000
argument_list|)
end_if

begin_function_decl
specifier|extern
name|void
name|bcopy
parameter_list|()
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* RISC6000 */
end_comment

begin_define
define|#
directive|define
name|bcopy
parameter_list|(
name|s
parameter_list|,
name|d
parameter_list|,
name|n
parameter_list|)
value|((void) memcpy ((d), (s), (n)))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* RISC6000 */
end_comment

begin_define
define|#
directive|define
name|rindex
value|strrchr
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !USG */
end_comment

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_function_decl
specifier|extern
name|void
name|bcopy
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !USG */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !NeXT */
end_comment

begin_comment
comment|/* If the opendir () on your system lets you open non-directory files,    then we consider that not robust.  Define OPENDIR_NOT_ROBUST in the    SYSDEP_CFLAGS for your machines entry in machines.h. */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|OPENDIR_NOT_ROBUST
argument_list|)
end_if

begin_if
if|#
directive|if
name|defined
argument_list|(
name|SHELL
argument_list|)
end_if

begin_include
include|#
directive|include
file|"posixstat.h"
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SHELL */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OPENDIR_NOT_ROBUST */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|malloc
argument_list|()
decl_stmt|,
modifier|*
name|realloc
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|void
name|free
parameter_list|()
function_decl|;
end_function_decl

begin_ifndef
ifndef|#
directive|ifndef
name|NULL
end_ifndef

begin_define
define|#
directive|define
name|NULL
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Global variable which controls whether or not * matches .*.    Non-zero means don't match .*.  */
end_comment

begin_decl_stmt
name|int
name|noglob_dot_filenames
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|glob_match_after_star
parameter_list|()
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* Return nonzero if PATTERN has any special globbing chars in it.  */
end_comment

begin_function
name|int
name|glob_pattern_p
parameter_list|(
name|pattern
parameter_list|)
name|char
modifier|*
name|pattern
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
init|=
name|pattern
decl_stmt|;
specifier|register
name|char
name|c
decl_stmt|;
name|int
name|open
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|p
operator|++
operator|)
operator|!=
literal|'\0'
condition|)
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'?'
case|:
case|case
literal|'*'
case|:
return|return
literal|1
return|;
case|case
literal|'['
case|:
comment|/* Only accept an open brace if there is a close */
name|open
operator|++
expr_stmt|;
comment|/* brace to match it.  Bracket expressions must be */
continue|continue;
comment|/* complete, according to Posix.2 */
case|case
literal|']'
case|:
if|if
condition|(
name|open
condition|)
return|return
literal|1
return|;
continue|continue;
case|case
literal|'\\'
case|:
if|if
condition|(
operator|*
name|p
operator|++
operator|==
literal|'\0'
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Match the pattern PATTERN against the string TEXT;    return 1 if it matches, 0 otherwise.     A match means the entire string TEXT is used up in matching.     In the pattern string, `*' matches any sequence of characters,    `?' matches any character, [SET] matches any character in the specified set,    [!SET] matches any character not in the specified set.     A set is composed of characters or ranges; a range looks like    character hyphen character (as in 0-9 or A-Z).    [0-9a-zA-Z_] is the set of characters allowed in C identifiers.    Any other character in the pattern must be matched exactly.     To suppress the special syntactic significance of any of `[]*?!-\',    and match the character exactly, precede it with a `\'.     If DOT_SPECIAL is nonzero,    `*' and `?' do not match `.' at the beginning of TEXT.  */
end_comment

begin_function
name|int
name|glob_match
parameter_list|(
name|pattern
parameter_list|,
name|text
parameter_list|,
name|dot_special
parameter_list|)
name|char
modifier|*
name|pattern
decl_stmt|,
decl|*
name|text
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|dot_special
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
init|=
name|pattern
decl_stmt|,
modifier|*
name|t
init|=
name|text
decl_stmt|;
specifier|register
name|char
name|c
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|p
operator|++
operator|)
operator|!=
literal|'\0'
condition|)
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'?'
case|:
if|if
condition|(
operator|*
name|t
operator|==
literal|'\0'
operator|||
operator|(
name|dot_special
operator|&&
name|t
operator|==
name|text
operator|&&
operator|*
name|t
operator|==
literal|'.'
operator|)
condition|)
return|return
literal|0
return|;
else|else
operator|++
name|t
expr_stmt|;
break|break;
case|case
literal|'\\'
case|:
if|if
condition|(
operator|*
name|p
operator|++
operator|!=
operator|*
name|t
operator|++
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'*'
case|:
if|if
condition|(
name|dot_special
operator|&&
name|t
operator|==
name|text
operator|&&
operator|*
name|t
operator|==
literal|'.'
condition|)
return|return
literal|0
return|;
return|return
name|glob_match_after_star
argument_list|(
name|p
argument_list|,
name|t
argument_list|)
return|;
case|case
literal|'['
case|:
block|{
specifier|register
name|char
name|c1
init|=
operator|*
name|t
operator|++
decl_stmt|;
name|int
name|invert
decl_stmt|;
if|if
condition|(
operator|!
name|c1
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|invert
operator|=
operator|(
operator|(
operator|*
name|p
operator|==
literal|'!'
operator|)
operator|||
operator|(
operator|*
name|p
operator|==
literal|'^'
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|invert
condition|)
name|p
operator|++
expr_stmt|;
name|c
operator|=
operator|*
name|p
operator|++
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
specifier|register
name|char
name|cstart
init|=
name|c
decl_stmt|,
name|cend
init|=
name|c
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
name|cstart
operator|=
operator|*
name|p
operator|++
expr_stmt|;
name|cend
operator|=
name|cstart
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
return|return
literal|0
return|;
name|c
operator|=
operator|*
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'-'
operator|&&
operator|*
name|p
operator|!=
literal|']'
condition|)
block|{
name|cend
operator|=
operator|*
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|cend
operator|==
literal|'\\'
condition|)
name|cend
operator|=
operator|*
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|cend
operator|==
literal|'\0'
condition|)
return|return
literal|0
return|;
name|c
operator|=
operator|*
name|p
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|c1
operator|>=
name|cstart
operator|&&
name|c1
operator|<=
name|cend
condition|)
goto|goto
name|match
goto|;
if|if
condition|(
name|c
operator|==
literal|']'
condition|)
break|break;
block|}
if|if
condition|(
operator|!
name|invert
condition|)
return|return
literal|0
return|;
break|break;
name|match
label|:
comment|/* Skip the rest of the [...] construct that already matched.  */
while|while
condition|(
name|c
operator|!=
literal|']'
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
return|return
literal|0
return|;
name|c
operator|=
operator|*
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
operator|++
name|p
expr_stmt|;
block|}
if|if
condition|(
name|invert
condition|)
return|return
literal|0
return|;
break|break;
block|}
default|default:
if|if
condition|(
name|c
operator|!=
operator|*
name|t
operator|++
condition|)
return|return
literal|0
return|;
block|}
return|return
operator|*
name|t
operator|==
literal|'\0'
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Like glob_match, but match PATTERN against any final segment of TEXT.  */
end_comment

begin_function
specifier|static
name|int
name|glob_match_after_star
parameter_list|(
name|pattern
parameter_list|,
name|text
parameter_list|)
name|char
modifier|*
name|pattern
decl_stmt|,
decl|*
name|text
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
init|=
name|pattern
decl_stmt|,
modifier|*
name|t
init|=
name|text
decl_stmt|;
specifier|register
name|char
name|c
decl_stmt|,
name|c1
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|p
operator|++
operator|)
operator|==
literal|'?'
operator|||
name|c
operator|==
literal|'*'
condition|)
if|if
condition|(
name|c
operator|==
literal|'?'
operator|&&
operator|*
name|t
operator|++
operator|==
literal|'\0'
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
name|c1
operator|=
operator|*
name|p
expr_stmt|;
else|else
name|c1
operator|=
name|c
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
operator|(
name|c
operator|==
literal|'['
operator|||
operator|*
name|t
operator|==
name|c1
operator|)
operator|&&
name|glob_match
argument_list|(
name|p
operator|-
literal|1
argument_list|,
name|t
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|*
name|t
operator|++
operator|==
literal|'\0'
condition|)
return|return
literal|0
return|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Return a vector of names of files in directory DIR    whose names match glob pattern PAT.    The names are not in any particular order.    Wildcards at the beginning of PAT do not match an initial period.     The vector is terminated by an element that is a null pointer.     To free the space allocated, first free the vector's elements,    then free the vector.     Return 0 if cannot get enough memory to hold the pointer    and the names.     Return -1 if cannot access directory DIR.    Look in errno for more information.  */
end_comment

begin_function
name|char
modifier|*
modifier|*
name|glob_vector
parameter_list|(
name|pat
parameter_list|,
name|dir
parameter_list|)
name|char
modifier|*
name|pat
decl_stmt|;
name|char
modifier|*
name|dir
decl_stmt|;
block|{
struct|struct
name|globval
block|{
name|struct
name|globval
modifier|*
name|next
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|}
struct|;
name|DIR
modifier|*
name|d
decl_stmt|;
specifier|register
name|struct
name|direct
modifier|*
name|dp
decl_stmt|;
name|struct
name|globval
modifier|*
name|lastlink
decl_stmt|;
specifier|register
name|struct
name|globval
modifier|*
name|nextlink
decl_stmt|;
specifier|register
name|char
modifier|*
name|nextname
decl_stmt|;
name|unsigned
name|int
name|count
decl_stmt|;
name|int
name|lose
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|name_vector
decl_stmt|;
specifier|register
name|unsigned
name|int
name|i
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|OPENDIR_NOT_ROBUST
argument_list|)
name|struct
name|stat
name|finfo
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|dir
argument_list|,
operator|&
name|finfo
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|(
name|char
operator|*
operator|*
operator|)
operator|-
literal|1
operator|)
return|;
if|if
condition|(
operator|!
name|S_ISDIR
argument_list|(
name|finfo
operator|.
name|st_mode
argument_list|)
condition|)
return|return
operator|(
operator|(
name|char
operator|*
operator|*
operator|)
operator|-
literal|1
operator|)
return|;
endif|#
directive|endif
comment|/* OPENDIR_NOT_ROBUST */
name|d
operator|=
name|opendir
argument_list|(
name|dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|==
name|NULL
condition|)
return|return
operator|(
name|char
operator|*
operator|*
operator|)
operator|-
literal|1
return|;
name|lastlink
operator|=
literal|0
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
name|lose
operator|=
literal|0
expr_stmt|;
comment|/* Scan the directory, finding all names that match.      For each name that matches, allocate a struct globval      on the stack and store the name in it.      Chain those structs together; lastlink is the front of the chain.  */
while|while
condition|(
literal|1
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|SHELL
argument_list|)
comment|/* Make globbing interruptible in the bash shell. */
specifier|extern
name|int
name|interrupt_state
decl_stmt|;
if|if
condition|(
name|interrupt_state
condition|)
block|{
name|closedir
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|lose
operator|=
literal|1
expr_stmt|;
goto|goto
name|lost
goto|;
block|}
endif|#
directive|endif
comment|/* SHELL */
name|dp
operator|=
name|readdir
argument_list|(
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|==
name|NULL
condition|)
break|break;
comment|/* If this directory entry is not to be used, try again. */
if|if
condition|(
operator|!
name|REAL_DIR_ENTRY
argument_list|(
name|dp
argument_list|)
condition|)
continue|continue;
comment|/* If a dot must be explicity matched, check to see if they do. */
if|if
condition|(
name|noglob_dot_filenames
operator|&&
name|dp
operator|->
name|d_name
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|pat
index|[
literal|0
index|]
operator|!=
literal|'.'
condition|)
continue|continue;
if|if
condition|(
name|glob_match
argument_list|(
name|pat
argument_list|,
name|dp
operator|->
name|d_name
argument_list|,
name|noglob_dot_filenames
argument_list|)
condition|)
block|{
name|nextlink
operator|=
operator|(
expr|struct
name|globval
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|globval
argument_list|)
argument_list|)
expr_stmt|;
name|nextlink
operator|->
name|next
operator|=
name|lastlink
expr_stmt|;
name|nextname
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|strlen
argument_list|(
name|dp
operator|->
name|d_name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|nextname
operator|==
name|NULL
condition|)
block|{
name|lose
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|lastlink
operator|=
name|nextlink
expr_stmt|;
name|nextlink
operator|->
name|name
operator|=
name|nextname
expr_stmt|;
name|bcopy
argument_list|(
name|dp
operator|->
name|d_name
argument_list|,
name|nextname
argument_list|,
name|strlen
argument_list|(
name|dp
operator|->
name|d_name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|++
name|count
expr_stmt|;
block|}
block|}
operator|(
name|void
operator|)
name|closedir
argument_list|(
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lose
condition|)
block|{
name|name_vector
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|count
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|lose
operator||=
name|name_vector
operator|==
name|NULL
expr_stmt|;
block|}
comment|/* Have we run out of memory?	 */
name|lost
label|:
if|if
condition|(
name|lose
condition|)
block|{
comment|/* Here free the strings we have got.  */
while|while
condition|(
name|lastlink
condition|)
block|{
name|free
argument_list|(
name|lastlink
operator|->
name|name
argument_list|)
expr_stmt|;
name|lastlink
operator|=
name|lastlink
operator|->
name|next
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
comment|/* Copy the name pointers from the linked list into the vector.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
operator|++
name|i
control|)
block|{
name|name_vector
index|[
name|i
index|]
operator|=
name|lastlink
operator|->
name|name
expr_stmt|;
name|lastlink
operator|=
name|lastlink
operator|->
name|next
expr_stmt|;
block|}
name|name_vector
index|[
name|count
index|]
operator|=
name|NULL
expr_stmt|;
return|return
name|name_vector
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return a new array which is the concatenation    of each string in ARRAY to DIR. */
end_comment

begin_function
specifier|static
name|char
modifier|*
modifier|*
name|glob_dir_to_array
parameter_list|(
name|dir
parameter_list|,
name|array
parameter_list|)
name|char
modifier|*
name|dir
decl_stmt|,
decl|*
modifier|*
name|array
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|unsigned
name|int
name|i
decl_stmt|,
name|l
decl_stmt|;
name|int
name|add_slash
decl_stmt|;
name|char
modifier|*
modifier|*
name|result
decl_stmt|;
name|l
operator|=
name|strlen
argument_list|(
name|dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|==
literal|0
condition|)
return|return
name|array
return|;
name|add_slash
operator|=
name|dir
index|[
name|l
operator|-
literal|1
index|]
operator|!=
literal|'/'
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|array
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
operator|++
name|i
expr_stmt|;
name|result
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|i
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|array
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
name|result
index|[
name|i
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|l
operator|+
operator|(
name|add_slash
condition|?
literal|1
else|:
literal|0
operator|)
operator|+
name|strlen
argument_list|(
name|array
index|[
name|i
index|]
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
index|[
name|i
index|]
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|sprintf
argument_list|(
name|result
index|[
name|i
index|]
argument_list|,
literal|"%s%s%s"
argument_list|,
name|dir
argument_list|,
name|add_slash
condition|?
literal|"/"
else|:
literal|""
argument_list|,
name|array
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|result
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
comment|/* Free the input array.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|array
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
name|free
argument_list|(
name|array
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|array
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Do globbing on PATHNAME.  Return an array of pathnames that match,    marking the end of the array with a null-pointer as an element.    If no pathnames match, then the array is empty (first element is null).    If there isn't enough memory, then return NULL.    If a file system error occurs, return -1; `errno' has the error code.  */
end_comment

begin_function
name|char
modifier|*
modifier|*
name|glob_filename
parameter_list|(
name|pathname
parameter_list|)
name|char
modifier|*
name|pathname
decl_stmt|;
block|{
name|char
modifier|*
modifier|*
name|result
decl_stmt|;
name|unsigned
name|int
name|result_size
decl_stmt|;
name|char
modifier|*
name|directory_name
decl_stmt|,
modifier|*
name|filename
decl_stmt|;
name|unsigned
name|int
name|directory_len
decl_stmt|;
name|result
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|result_size
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|result
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
comment|/* Find the filename.  */
name|filename
operator|=
name|rindex
argument_list|(
name|pathname
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|filename
operator|==
name|NULL
condition|)
block|{
name|filename
operator|=
name|pathname
expr_stmt|;
name|directory_name
operator|=
literal|""
expr_stmt|;
name|directory_len
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|directory_len
operator|=
operator|(
name|filename
operator|-
name|pathname
operator|)
operator|+
literal|1
expr_stmt|;
name|directory_name
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|directory_len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|pathname
argument_list|,
name|directory_name
argument_list|,
name|directory_len
argument_list|)
expr_stmt|;
name|directory_name
index|[
name|directory_len
index|]
operator|=
literal|'\0'
expr_stmt|;
operator|++
name|filename
expr_stmt|;
block|}
comment|/* If directory_name contains globbing characters, then we      have to expand the previous levels.  Just recurse. */
if|if
condition|(
name|glob_pattern_p
argument_list|(
name|directory_name
argument_list|)
condition|)
block|{
name|char
modifier|*
modifier|*
name|directories
decl_stmt|;
specifier|register
name|unsigned
name|int
name|i
decl_stmt|;
if|if
condition|(
name|directory_name
index|[
name|directory_len
operator|-
literal|1
index|]
operator|==
literal|'/'
condition|)
name|directory_name
index|[
name|directory_len
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|directories
operator|=
name|glob_filename
argument_list|(
name|directory_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|directories
operator|==
name|NULL
condition|)
goto|goto
name|memory_error
goto|;
elseif|else
if|if
condition|(
operator|(
name|int
operator|)
name|directories
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|char
operator|*
operator|*
operator|)
operator|-
literal|1
return|;
elseif|else
if|if
condition|(
operator|*
name|directories
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|directories
argument_list|)
expr_stmt|;
return|return
operator|(
name|char
operator|*
operator|*
operator|)
operator|-
literal|1
return|;
block|}
comment|/* We have successfully globbed the preceding directory name. 	 For each name in DIRECTORIES, call glob_vector on it and 	 FILENAME.  Concatenate the results together.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|directories
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
operator|++
name|i
control|)
block|{
name|char
modifier|*
modifier|*
name|temp_results
init|=
name|glob_vector
argument_list|(
name|filename
argument_list|,
name|directories
index|[
name|i
index|]
argument_list|)
decl_stmt|;
comment|/* Handle error cases. */
if|if
condition|(
name|temp_results
operator|==
name|NULL
condition|)
goto|goto
name|memory_error
goto|;
elseif|else
if|if
condition|(
name|temp_results
operator|==
operator|(
name|char
operator|*
operator|*
operator|)
operator|-
literal|1
condition|)
comment|/* This filename is probably not a directory.  Ignore it.  */
empty_stmt|;
else|else
block|{
name|char
modifier|*
modifier|*
name|array
init|=
name|glob_dir_to_array
argument_list|(
name|directories
index|[
name|i
index|]
argument_list|,
name|temp_results
argument_list|)
decl_stmt|;
specifier|register
name|unsigned
name|int
name|l
decl_stmt|;
name|l
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|array
index|[
name|l
index|]
operator|!=
name|NULL
condition|)
operator|++
name|l
expr_stmt|;
name|result
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|realloc
argument_list|(
name|result
argument_list|,
operator|(
name|result_size
operator|+
name|l
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|NULL
condition|)
goto|goto
name|memory_error
goto|;
for|for
control|(
name|l
operator|=
literal|0
init|;
name|array
index|[
name|l
index|]
operator|!=
name|NULL
condition|;
operator|++
name|l
control|)
name|result
index|[
name|result_size
operator|++
operator|-
literal|1
index|]
operator|=
name|array
index|[
name|l
index|]
expr_stmt|;
name|result
index|[
name|result_size
operator|-
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
comment|/* Note that the elements of ARRAY are not freed.  */
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|array
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Free the directories.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|directories
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
name|free
argument_list|(
name|directories
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|directories
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
comment|/* If there is only a directory name, return it. */
if|if
condition|(
operator|*
name|filename
operator|==
literal|'\0'
condition|)
block|{
name|result
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|realloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|result
argument_list|,
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|result
index|[
literal|0
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|directory_len
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
index|[
literal|0
index|]
operator|==
name|NULL
condition|)
goto|goto
name|memory_error
goto|;
name|bcopy
argument_list|(
name|directory_name
argument_list|,
name|result
index|[
literal|0
index|]
argument_list|,
name|directory_len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|result
index|[
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
return|return
name|result
return|;
block|}
else|else
block|{
comment|/* Otherwise, just return what glob_vector 	 returns appended to the directory name. */
name|char
modifier|*
modifier|*
name|temp_results
init|=
name|glob_vector
argument_list|(
name|filename
argument_list|,
operator|(
name|directory_len
operator|==
literal|0
condition|?
literal|"."
else|:
name|directory_name
operator|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|temp_results
operator|==
name|NULL
operator|||
name|temp_results
operator|==
operator|(
name|char
operator|*
operator|*
operator|)
operator|-
literal|1
condition|)
return|return
name|temp_results
return|;
return|return
operator|(
name|glob_dir_to_array
argument_list|(
name|directory_name
argument_list|,
name|temp_results
argument_list|)
operator|)
return|;
block|}
comment|/* We get to memory error if the program has run out of memory, or      if this is the shell, and we have been interrupted. */
name|memory_error
label|:
if|if
condition|(
name|result
operator|!=
name|NULL
condition|)
block|{
specifier|register
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|result
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
operator|++
name|i
control|)
name|free
argument_list|(
name|result
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|result
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|SHELL
argument_list|)
block|{
specifier|extern
name|int
name|interrupt_state
decl_stmt|;
if|if
condition|(
name|interrupt_state
condition|)
name|throw_to_top_level
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SHELL */
return|return
name|NULL
return|;
block|}
end_function

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|TEST
end_ifdef

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
operator|++
name|i
control|)
block|{
name|char
modifier|*
modifier|*
name|value
init|=
name|glob_filename
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|==
name|NULL
condition|)
name|puts
argument_list|(
literal|"Out of memory."
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|int
operator|)
name|value
operator|==
operator|-
literal|1
condition|)
name|perror
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
else|else
for|for
control|(
name|i
operator|=
literal|0
init|;
name|value
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
name|puts
argument_list|(
name|value
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TEST.  */
end_comment

end_unit

