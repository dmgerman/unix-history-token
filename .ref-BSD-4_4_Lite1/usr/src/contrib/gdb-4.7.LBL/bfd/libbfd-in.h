begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* libbfd.h -- Declarations used by bfd library *implementation*.    (This include file is not for users of the library.)    Copyright 1990, 1991 Free Software Foundation, Inc.    Written by Cygnus Support.  This file is part of BFD, the Binary File Descriptor library.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* Align an address upward to a boundary, expressed as a number of bytes.    E.g. align to an 8-byte boundary with argument of 8.  */
end_comment

begin_define
define|#
directive|define
name|BFD_ALIGN
parameter_list|(
name|this
parameter_list|,
name|boundary
parameter_list|)
define|\
value|((( (this) + ((boundary) -1))& (~((boundary)-1))))
end_define

begin_comment
comment|/* If you want to read and write large blocks, you might want to do it    in quanta of this amount */
end_comment

begin_define
define|#
directive|define
name|DEFAULT_BUFFERSIZE
value|8192
end_define

begin_comment
comment|/* Set a tdata field.  Can't use the other macros for this, since they    do casts, and casting to the left of assignment isn't portable.  */
end_comment

begin_define
define|#
directive|define
name|set_tdata
parameter_list|(
name|bfd
parameter_list|,
name|v
parameter_list|)
value|((bfd)->tdata.any = (PTR) (v))
end_define

begin_comment
comment|/* tdata for an archive.  For an input archive, cache    needs to be free()'d.  For an output archive, symdefs do.  */
end_comment

begin_struct
struct|struct
name|artdata
block|{
name|file_ptr
name|first_file_filepos
decl_stmt|;
comment|/* Speed up searching the armap */
name|struct
name|ar_cache
modifier|*
name|cache
decl_stmt|;
name|bfd
modifier|*
name|archive_head
decl_stmt|;
comment|/* Only interesting in output routines */
name|carsym
modifier|*
name|symdefs
decl_stmt|;
comment|/* the symdef entries */
name|symindex
name|symdef_count
decl_stmt|;
comment|/* how many there are */
name|char
modifier|*
name|extended_names
decl_stmt|;
comment|/* clever intel extension */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|bfd_ardata
parameter_list|(
name|bfd
parameter_list|)
value|((bfd)->tdata.aout_ar_data)
end_define

begin_comment
comment|/* Goes in bfd's arelt_data slot */
end_comment

begin_struct
struct|struct
name|areltdata
block|{
name|char
modifier|*
name|arch_header
decl_stmt|;
comment|/* it's actually a string */
name|unsigned
name|int
name|parsed_size
decl_stmt|;
comment|/* octets of filesize not including ar_hdr */
name|char
modifier|*
name|filename
decl_stmt|;
comment|/* null-terminated */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|arelt_size
parameter_list|(
name|bfd
parameter_list|)
value|(((struct areltdata *)((bfd)->arelt_data))->parsed_size)
end_define

begin_comment
comment|/* FIXME -- a lot of my code allocates a large block and subdivides it.    This can't always work, because of alignment restrictions.  We should change    it before it becomes a problem -- Gumby */
end_comment

begin_expr_stmt
name|PROTO
argument_list|(
name|char
operator|*
argument_list|,
name|zalloc
argument_list|,
operator|(
name|bfd_size_type
name|size
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* These routines allocate and free things on the BFD's obstack.  Note    that realloc can never occur in place.  */
end_comment

begin_expr_stmt
name|PROTO
argument_list|(
name|PTR
argument_list|,
name|bfd_alloc
argument_list|,
operator|(
name|bfd
operator|*
name|abfd
operator|,
name|bfd_size_type
name|size
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PROTO
argument_list|(
name|PTR
argument_list|,
name|bfd_zalloc
argument_list|,
operator|(
name|bfd
operator|*
name|abfd
operator|,
name|bfd_size_type
name|size
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PROTO
argument_list|(
name|PTR
argument_list|,
name|bfd_realloc
argument_list|,
operator|(
name|bfd
operator|*
name|abfd
operator|,
name|PTR
name|orig
operator|,
name|bfd_size_type
name|new
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PROTO
argument_list|(
name|void
argument_list|,
name|bfd_alloc_grow
argument_list|,
operator|(
name|bfd
operator|*
name|abfd
operator|,
name|PTR
name|thing
operator|,
name|bfd_size_type
name|size
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PROTO
argument_list|(
name|PTR
argument_list|,
name|bfd_alloc_finish
argument_list|,
operator|(
name|bfd
operator|*
name|abfd
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PROTO
argument_list|(
name|PTR
argument_list|,
name|bfd_alloc_by_size_t
argument_list|,
operator|(
name|bfd
operator|*
name|abfd
operator|,
name|size_t
name|wanted
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|bfd_release
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|(void) obstack_free(&(x->memory),y)
end_define

begin_expr_stmt
name|PROTO
argument_list|(
name|bfd_size_type
argument_list|,
name|bfd_read
argument_list|,
operator|(
name|PTR
name|ptr
operator|,
name|bfd_size_type
name|size
operator|,
name|bfd_size_type
name|nitems
operator|,
name|bfd
operator|*
name|abfd
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PROTO
argument_list|(
name|bfd_size_type
argument_list|,
name|bfd_write
argument_list|,
operator|(
name|CONST
name|PTR
name|ptr
operator|,
name|bfd_size_type
name|size
operator|,
name|bfd_size_type
name|nitems
operator|,
name|bfd
operator|*
name|abfd
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PROTO
argument_list|(
name|int
argument_list|,
name|bfd_seek
argument_list|,
operator|(
name|bfd
operator|*
name|CONST
name|abfd
operator|,
name|CONST
name|file_ptr
name|fp
operator|,
name|CONST
name|int
name|direction
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PROTO
argument_list|(
name|long
argument_list|,
name|bfd_tell
argument_list|,
operator|(
name|bfd
operator|*
name|abfd
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PROTO
argument_list|(
name|bfd
operator|*
argument_list|,
name|_bfd_create_empty_archive_element_shell
argument_list|,
operator|(
name|bfd
operator|*
name|obfd
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PROTO
argument_list|(
name|bfd
operator|*
argument_list|,
name|look_for_bfd_in_cache
argument_list|,
operator|(
name|bfd
operator|*
name|arch_bfd
operator|,
name|file_ptr
name|index
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PROTO
argument_list|(
name|boolean
argument_list|,
name|_bfd_generic_mkarchive
argument_list|,
operator|(
name|bfd
operator|*
name|abfd
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PROTO
argument_list|(
expr|struct
name|areltdata
operator|*
argument_list|,
name|snarf_ar_hdr
argument_list|,
operator|(
name|bfd
operator|*
name|abfd
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PROTO
argument_list|(
name|bfd_target
operator|*
argument_list|,
name|bfd_generic_archive_p
argument_list|,
operator|(
name|bfd
operator|*
name|abfd
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PROTO
argument_list|(
name|boolean
argument_list|,
name|bfd_slurp_bsd_armap
argument_list|,
operator|(
name|bfd
operator|*
name|abfd
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PROTO
argument_list|(
name|boolean
argument_list|,
name|bfd_slurp_coff_armap
argument_list|,
operator|(
name|bfd
operator|*
name|abfd
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PROTO
argument_list|(
name|boolean
argument_list|,
name|_bfd_slurp_extended_name_table
argument_list|,
operator|(
name|bfd
operator|*
name|abfd
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PROTO
argument_list|(
name|boolean
argument_list|,
name|_bfd_write_archive_contents
argument_list|,
operator|(
name|bfd
operator|*
name|abfd
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PROTO
argument_list|(
name|bfd
operator|*
argument_list|,
name|new_bfd
argument_list|,
operator|(
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|DEFAULT_STRING_SPACE_SIZE
value|0x2000
end_define

begin_expr_stmt
name|PROTO
argument_list|(
name|boolean
argument_list|,
name|bfd_add_to_string_table
argument_list|,
operator|(
name|char
operator|*
operator|*
name|table
operator|,
name|char
operator|*
name|new_string
operator|,
name|unsigned
name|int
operator|*
name|table_length
operator|,
name|char
operator|*
operator|*
name|free_ptr
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PROTO
argument_list|(
name|bfd_vma
argument_list|,
name|_do_getb64
argument_list|,
operator|(
name|unsigned
name|char
operator|*
name|addr
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PROTO
argument_list|(
name|bfd_vma
argument_list|,
name|_do_getl64
argument_list|,
operator|(
name|unsigned
name|char
operator|*
name|addr
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PROTO
argument_list|(
name|bfd_vma
argument_list|,
name|_do_getb32
argument_list|,
operator|(
name|unsigned
name|char
operator|*
name|addr
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PROTO
argument_list|(
name|bfd_vma
argument_list|,
name|_do_getl32
argument_list|,
operator|(
name|unsigned
name|char
operator|*
name|addr
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PROTO
argument_list|(
name|bfd_vma
argument_list|,
name|_do_getb16
argument_list|,
operator|(
name|unsigned
name|char
operator|*
name|addr
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PROTO
argument_list|(
name|bfd_vma
argument_list|,
name|_do_getl16
argument_list|,
operator|(
name|unsigned
name|char
operator|*
name|addr
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PROTO
argument_list|(
name|void
argument_list|,
name|_do_putb64
argument_list|,
operator|(
name|bfd_vma
name|data
operator|,
name|unsigned
name|char
operator|*
name|addr
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PROTO
argument_list|(
name|void
argument_list|,
name|_do_putl64
argument_list|,
operator|(
name|bfd_vma
name|data
operator|,
name|unsigned
name|char
operator|*
name|addr
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PROTO
argument_list|(
name|void
argument_list|,
name|_do_putb32
argument_list|,
operator|(
name|bfd_vma
name|data
operator|,
name|unsigned
name|char
operator|*
name|addr
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PROTO
argument_list|(
name|void
argument_list|,
name|_do_putl32
argument_list|,
operator|(
name|bfd_vma
name|data
operator|,
name|unsigned
name|char
operator|*
name|addr
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PROTO
argument_list|(
name|void
argument_list|,
name|_do_putb16
argument_list|,
operator|(
name|bfd_vma
name|data
operator|,
name|unsigned
name|char
operator|*
name|addr
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PROTO
argument_list|(
name|void
argument_list|,
name|_do_putl16
argument_list|,
operator|(
name|bfd_vma
name|data
operator|,
name|unsigned
name|char
operator|*
name|addr
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PROTO
argument_list|(
name|boolean
argument_list|,
name|bfd_false
argument_list|,
operator|(
name|bfd
operator|*
name|ignore
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PROTO
argument_list|(
name|boolean
argument_list|,
name|bfd_true
argument_list|,
operator|(
name|bfd
operator|*
name|ignore
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PROTO
argument_list|(
name|PTR
argument_list|,
name|bfd_nullvoidptr
argument_list|,
operator|(
name|bfd
operator|*
name|ignore
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PROTO
argument_list|(
name|int
argument_list|,
name|bfd_0
argument_list|,
operator|(
name|bfd
operator|*
name|ignore
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|PROTO
argument_list|(
argument|unsigned int
argument_list|,
argument|bfd_0u
argument_list|,
argument|(bfd *ignore)
argument_list|)
end_macro

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|PROTO
argument_list|(
name|void
argument_list|,
name|bfd_void
argument_list|,
operator|(
name|bfd
operator|*
name|ignore
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PROTO
argument_list|(
name|bfd
operator|*
argument_list|,
name|new_bfd_contained_in
argument_list|,
operator|(
name|bfd
operator|*
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PROTO
argument_list|(
name|boolean
argument_list|,
name|_bfd_dummy_new_section_hook
argument_list|,
operator|(
name|bfd
operator|*
name|ignore
operator|,
name|asection
operator|*
name|newsect
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PROTO
argument_list|(
name|char
operator|*
argument_list|,
name|_bfd_dummy_core_file_failing_command
argument_list|,
operator|(
name|bfd
operator|*
name|abfd
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PROTO
argument_list|(
name|int
argument_list|,
name|_bfd_dummy_core_file_failing_signal
argument_list|,
operator|(
name|bfd
operator|*
name|abfd
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PROTO
argument_list|(
name|boolean
argument_list|,
name|_bfd_dummy_core_file_matches_executable_p
argument_list|,
operator|(
name|bfd
operator|*
name|core_bfd
operator|,
name|bfd
operator|*
name|exec_bfd
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PROTO
argument_list|(
name|bfd_target
operator|*
argument_list|,
name|_bfd_dummy_target
argument_list|,
operator|(
name|bfd
operator|*
name|abfd
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PROTO
argument_list|(
name|void
argument_list|,
name|bfd_dont_truncate_arname
argument_list|,
operator|(
name|bfd
operator|*
name|abfd
operator|,
name|CONST
name|char
operator|*
name|filename
operator|,
name|char
operator|*
name|hdr
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PROTO
argument_list|(
name|void
argument_list|,
name|bfd_bsd_truncate_arname
argument_list|,
operator|(
name|bfd
operator|*
name|abfd
operator|,
name|CONST
name|char
operator|*
name|filename
operator|,
name|char
operator|*
name|hdr
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PROTO
argument_list|(
name|void
argument_list|,
name|bfd_gnu_truncate_arname
argument_list|,
operator|(
name|bfd
operator|*
name|abfd
operator|,
name|CONST
name|char
operator|*
name|filename
operator|,
name|char
operator|*
name|hdr
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PROTO
argument_list|(
name|boolean
argument_list|,
name|bsd_write_armap
argument_list|,
operator|(
name|bfd
operator|*
name|arch
operator|,
name|unsigned
name|int
name|elength
operator|,
expr|struct
name|orl
operator|*
name|map
operator|,
name|unsigned
name|int
name|orl_count
operator|,
name|int
name|stridx
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PROTO
argument_list|(
name|boolean
argument_list|,
name|coff_write_armap
argument_list|,
operator|(
name|bfd
operator|*
name|arch
operator|,
name|unsigned
name|int
name|elength
operator|,
expr|struct
name|orl
operator|*
name|map
operator|,
name|unsigned
name|int
name|orl_count
operator|,
name|int
name|stridx
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PROTO
argument_list|(
name|bfd
operator|*
argument_list|,
name|bfd_generic_openr_next_archived_file
argument_list|,
operator|(
name|bfd
operator|*
name|archive
operator|,
name|bfd
operator|*
name|last_file
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PROTO
argument_list|(
name|int
argument_list|,
name|bfd_generic_stat_arch_elt
argument_list|,
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|stat
operator|*
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PROTO
argument_list|(
name|boolean
argument_list|,
name|bfd_generic_get_section_contents
argument_list|,
operator|(
name|bfd
operator|*
name|abfd
operator|,
name|sec_ptr
name|section
operator|,
name|PTR
name|location
operator|,
name|file_ptr
name|offset
operator|,
name|bfd_size_type
name|count
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PROTO
argument_list|(
name|boolean
argument_list|,
name|bfd_generic_set_section_contents
argument_list|,
operator|(
name|bfd
operator|*
name|abfd
operator|,
name|sec_ptr
name|section
operator|,
name|PTR
name|location
operator|,
name|file_ptr
name|offset
operator|,
name|bfd_size_type
name|count
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Macros to tell if bfds are read or write enabled.     Note that bfds open for read may be scribbled into if the fd passed    to bfd_fdopenr is actually open both for read and write    simultaneously.  However an output bfd will never be open for    read.  Therefore sometimes you want to check bfd_read_p or    !bfd_read_p, and only sometimes bfd_write_p. */
end_comment

begin_define
define|#
directive|define
name|bfd_read_p
parameter_list|(
name|abfd
parameter_list|)
value|((abfd)->direction == read_direction || (abfd)->direction == both_direction)
end_define

begin_define
define|#
directive|define
name|bfd_write_p
parameter_list|(
name|abfd
parameter_list|)
value|((abfd)->direction == write_direction || (abfd)->direction == both_direction)
end_define

begin_expr_stmt
name|PROTO
argument_list|(
name|void
argument_list|,
name|bfd_assert
argument_list|,
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|BFD_ASSERT
parameter_list|(
name|x
parameter_list|)
define|\
value|{ if (!(x)) bfd_assert(__FILE__,__LINE__); }
end_define

begin_define
define|#
directive|define
name|BFD_FAIL
parameter_list|()
define|\
value|{ bfd_assert(__FILE__,__LINE__); }
end_define

begin_expr_stmt
name|PROTO
argument_list|(
name|FILE
operator|*
argument_list|,
name|bfd_cache_lookup_worker
argument_list|,
operator|(
name|bfd
operator|*
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|extern
name|bfd
modifier|*
name|bfd_last_cache
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Now Steve, what's the story here? */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|lint
end_ifdef

begin_define
define|#
directive|define
name|itos
parameter_list|(
name|x
parameter_list|)
value|"l"
end_define

begin_define
define|#
directive|define
name|stoi
parameter_list|(
name|x
parameter_list|)
value|1
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|itos
parameter_list|(
name|x
parameter_list|)
value|((char*)(x))
end_define

begin_define
define|#
directive|define
name|stoi
parameter_list|(
name|x
parameter_list|)
value|((int)(x))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Generic routine for close_and_cleanup is really just bfd_true.  */
end_comment

begin_define
define|#
directive|define
name|bfd_generic_close_and_cleanup
value|bfd_true
end_define

begin_comment
comment|/* And more follows */
end_comment

end_unit

