begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Generic BFD library interface and support routines.    Copyright (C) 1990-1991 Free Software Foundation, Inc.    Written by Cygnus Support.  This file is part of BFD, the Binary File Descriptor library.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* SECTION<<typedef bfd>>  	A BFD is has type<<bfd>>; objects of this type are the 	cornerstone of any application using<<libbfd>>. References 	though the BFD and to data in the BFD give the entire BFD 	functionality.  	Here is the struct used to define the type<<bfd>>.  This 	contains the major data about the file, and contains pointers 	to the rest of the data.  CODE_FRAGMENT . .struct _bfd  .{ .    {* The filename the application opened the BFD with.  *} .    CONST char *filename;                 . .    {* A pointer to the target jump table.             *} .    struct bfd_target *xvec; . .    {* To avoid dragging too many header files into every file that .       includes `<<bfd.h>>', IOSTREAM has been declared as a "char .       *", and MTIME as a "long".  Their correct types, to which they .       are cast when used, are "FILE *" and "time_t".    The iostream .       is the result of an fopen on the filename. *} .    char *iostream; . .    {* Is the file being cached *} . .    boolean cacheable; . .    {* Marks whether there was a default target specified when the .       BFD was opened. This is used to select what matching algorithm .       to use to chose the back end. *} . .    boolean target_defaulted; . .    {* The caching routines use these to maintain a .       least-recently-used list of BFDs *} . .    struct _bfd *lru_prev, *lru_next; . .    {* When a file is closed by the caching routines, BFD retains .       state information on the file here:  .     *} . .    file_ptr where;               . .    {* and here:*} . .    boolean opened_once; . .    {* Set if we have a locally maintained mtime value, rather than .       getting it from the file each time: *} . .    boolean mtime_set; . .    {* File modified time, if mtime_set is true: *} . .    long mtime;           . .    {* Reserved for an unimplemented file locking extension.*} . .    int ifd; . .    {* The format which belongs to the BFD.*} . .    bfd_format format; . .    {* The direction the BFD was opened with*} . .    enum bfd_direction {no_direction = 0, .                        read_direction = 1, .                        write_direction = 2, .                        both_direction = 3} direction; . .    {* Format_specific flags*} . .    flagword flags;               . .    {* Currently my_archive is tested before adding origin to .       anything. I believe that this can become always an add of .       origin, with origin set to 0 for non archive files.   *} . .    file_ptr origin;              . .    {* Remember when output has begun, to stop strange things .       happening. *} .    boolean output_has_begun; . .    {* Pointer to linked list of sections*} .    struct sec  *sections; . .    {* The number of sections *} .    unsigned int section_count; . .    {* Stuff only useful for object files:  .       The start address. *} .    bfd_vma start_address; . .    {* Used for input and output*} .    unsigned int symcount; . .    {* Symbol table for output BFD*} .    struct symbol_cache_entry  **outsymbols;              . .    {* Pointer to structure which contains architecture information*} .    struct bfd_arch_info *arch_info; . .    {* Stuff only useful for archives:*} .    PTR arelt_data;               .    struct _bfd *my_archive;      .    struct _bfd *next;            .    struct _bfd *archive_head;    .    boolean has_armap;            . .    {* Used by the back end to hold private data. *} . .    union  .      { .      struct aout_data_struct *aout_data; .      struct artdata *aout_ar_data; .      struct _oasys_data *oasys_obj_data; .      struct _oasys_ar_data *oasys_ar_data; .      struct coff_tdata *coff_obj_data; .      struct ieee_data_struct *ieee_data; .      struct ieee_ar_data_struct *ieee_ar_data; .      struct srec_data_struct *srec_data; .      struct srec_data_struct *tekhex_data; .      struct elf_obj_tdata *elf_obj_data; .      struct bout_data_struct *bout_data; .      struct sun_core_struct *sun_core_data; .      struct trad_core_struct *trad_core_data; .      struct hppa_data_struct *hppa_data; .      PTR any; .      } tdata; .   .    {* Used by the application to hold private data*} .    PTR usrdata; . .    {* Where all the allocated stuff under this BFD goes *} .    struct obstack memory; . .    {* Is this really needed in addition to usrdata?  *} .    asymbol **ld_symbols; .}; . */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_undef
undef|#
directive|undef
name|strerror
end_undef

begin_function_decl
specifier|extern
name|char
modifier|*
name|strerror
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|CONST
name|short
name|_bfd_host_big_endian
init|=
literal|0x0100
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Accessing the above as (*(char*)&_bfd_host_big_endian), will            return 1 if the host is big-endian, 0 otherwise.            (assuming that a short is two bytes long!!!  FIXME)            (See HOST_IS_BIG_ENDIAN_P in bfd.h.)  */
end_comment

begin_escape
end_escape

begin_comment
comment|/** Error handling     o - Most functions return nonzero on success (check doc for         precise semantics); 0 or NULL on error.     o - Internal errors are documented by the value of bfd_error.         If that is system_call_error then check errno.     o - The easiest way to report this to the user is to use bfd_perror. */
end_comment

begin_decl_stmt
name|bfd_ec
name|bfd_error
init|=
name|no_error
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|CONST
name|char
modifier|*
name|CONST
name|bfd_errmsgs
index|[]
init|=
block|{
literal|"No error"
block|,
literal|"System call error"
block|,
literal|"Invalid target"
block|,
literal|"File in wrong format"
block|,
literal|"Invalid operation"
block|,
literal|"Memory exhausted"
block|,
literal|"No symbols"
block|,
literal|"No relocation info"
block|,
literal|"No more archived files"
block|,
literal|"Malformed archive"
block|,
literal|"Symbol not found"
block|,
literal|"File format not recognized"
block|,
literal|"File format is ambiguous"
block|,
literal|"Section has no contents"
block|,
literal|"Nonrepresentable section on output"
block|,
literal|"Symbol needs debug section which does not exist"
block|,
literal|"Bad value"
block|,
literal|"#<Invalid error code>"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|DEFUN
argument_list|(
name|bfd_nonrepresentable_section
argument_list|,
operator|(
name|abfd
operator|,
name|name
operator|)
argument_list|,
name|CONST
name|bfd
operator|*
name|CONST
name|abfd
name|AND
name|CONST
name|char
operator|*
name|CONST
name|name
argument_list|)
block|{
name|printf
argument_list|(
literal|"bfd error writing file %s, format %s can't represent section %s\n"
argument_list|,
name|abfd
operator|->
name|filename
argument_list|,
name|abfd
operator|->
name|xvec
operator|->
name|name
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_decl_stmt
specifier|static
name|void
name|DEFUN
argument_list|(
name|bfd_undefined_symbol
argument_list|,
operator|(
name|relent
operator|,
name|seclet
operator|)
argument_list|,
name|CONST
name|arelent
operator|*
name|relent
name|AND
name|CONST
expr|struct
name|bfd_seclet_struct
operator|*
name|seclet
argument_list|)
block|{
name|asymbol
modifier|*
name|symbol
init|=
operator|*
operator|(
name|relent
operator|->
name|sym_ptr_ptr
operator|)
decl_stmt|;
name|printf
argument_list|(
literal|"bfd error relocating, symbol %s is undefined\n"
argument_list|,
name|symbol
operator|->
name|name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_decl_stmt
specifier|static
name|void
name|DEFUN
argument_list|(
name|bfd_reloc_value_truncated
argument_list|,
operator|(
name|relent
operator|,
name|seclet
operator|)
argument_list|,
name|CONST
name|arelent
operator|*
name|relent
name|AND
expr|struct
name|bfd_seclet_struct
operator|*
name|seclet
argument_list|)
block|{
name|printf
argument_list|(
literal|"bfd error relocating, value truncated\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_decl_stmt
specifier|static
name|void
name|DEFUN
argument_list|(
name|bfd_reloc_is_dangerous
argument_list|,
operator|(
name|relent
operator|,
name|seclet
operator|)
argument_list|,
name|CONST
name|arelent
operator|*
name|relent
name|AND
name|CONST
expr|struct
name|bfd_seclet_struct
operator|*
name|seclet
argument_list|)
block|{
name|printf
argument_list|(
literal|"bfd error relocating, dangerous\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
name|bfd_error_vector_type
name|bfd_error_vector
init|=
block|{
name|bfd_nonrepresentable_section
block|,
name|bfd_undefined_symbol
block|,
name|bfd_reloc_value_truncated
block|,
name|bfd_reloc_is_dangerous
block|,   }
decl_stmt|;
end_decl_stmt

begin_function
name|CONST
name|char
modifier|*
name|bfd_errmsg
parameter_list|(
name|error_tag
parameter_list|)
name|bfd_ec
name|error_tag
decl_stmt|;
block|{
ifndef|#
directive|ifndef
name|errno
specifier|extern
name|int
name|errno
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|error_tag
operator|==
name|system_call_error
condition|)
return|return
name|strerror
argument_list|(
name|errno
argument_list|)
return|;
if|if
condition|(
operator|(
operator|(
operator|(
name|int
operator|)
name|error_tag
operator|<
operator|(
name|int
operator|)
name|no_error
operator|)
operator|||
operator|(
operator|(
name|int
operator|)
name|error_tag
operator|>
operator|(
name|int
operator|)
name|invalid_error_code
operator|)
operator|)
condition|)
name|error_tag
operator|=
name|invalid_error_code
expr_stmt|;
comment|/* sanity check */
return|return
name|bfd_errmsgs
index|[
operator|(
name|int
operator|)
name|error_tag
index|]
return|;
block|}
end_function

begin_function
name|void
name|bfd_default_error_trap
parameter_list|(
name|error_tag
parameter_list|)
name|bfd_ec
name|error_tag
decl_stmt|;
block|{
name|printf
argument_list|(
literal|"bfd assert fail (%s)\n"
argument_list|,
name|bfd_errmsg
argument_list|(
name|error_tag
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function_decl
name|void
function_decl|(
modifier|*
name|bfd_error_trap
function_decl|)
parameter_list|()
init|=
name|bfd_default_error_trap
function_decl|;
end_function_decl

begin_function_decl
name|void
function_decl|(
modifier|*
name|bfd_error_nonrepresentabltrap
function_decl|)
parameter_list|()
init|=
name|bfd_default_error_trap
function_decl|;
end_function_decl

begin_decl_stmt
name|void
name|DEFUN
argument_list|(
name|bfd_perror
argument_list|,
operator|(
name|message
operator|)
argument_list|,
name|CONST
name|char
operator|*
name|message
argument_list|)
block|{
if|if
condition|(
name|bfd_error
operator|==
name|system_call_error
condition|)
name|perror
argument_list|(
operator|(
name|char
operator|*
operator|)
name|message
argument_list|)
expr_stmt|;
comment|/* must be system error then... */
else|else
block|{
if|if
condition|(
name|message
operator|==
name|NULL
operator|||
operator|*
name|message
operator|==
literal|'\0'
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_error
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s\n"
argument_list|,
name|message
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_error
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/** Symbols */
end_comment

begin_comment
comment|/* FUNCTION 	bfd_get_reloc_upper_bound  SYNOPSIS 	unsigned int bfd_get_reloc_upper_bound(bfd *abfd, asection *sect);  DESCRIPTION 	This function return the number of bytes required to store the 	relocation information associated with section<<sect>> 	attached to bfd<<abfd>>  */
end_comment

begin_decl_stmt
name|unsigned
name|int
name|DEFUN
argument_list|(
name|bfd_get_reloc_upper_bound
argument_list|,
operator|(
name|abfd
operator|,
name|asect
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|sec_ptr
name|asect
argument_list|)
block|{
if|if
condition|(
name|abfd
operator|->
name|format
operator|!=
name|bfd_object
condition|)
block|{
name|bfd_error
operator|=
name|invalid_operation
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|BFD_SEND
argument_list|(
name|abfd
argument_list|,
name|_get_reloc_upper_bound
argument_list|,
operator|(
name|abfd
operator|,
name|asect
operator|)
argument_list|)
return|;
block|}
end_decl_stmt

begin_comment
comment|/* FUNCTION 	bfd_canonicalize_reloc  SYNOPSIS 	unsigned int bfd_canonicalize_reloc         	(bfd *abfd, 		asection *sec, 		arelent **loc, 		asymbol	**syms);  DESCRIPTION 	This function calls the back end associated with the open<<abfd>> and translates the external form of the relocation 	information attached to<<sec>> into the internal canonical 	form.  The table is placed into memory at<<loc>>, which has 	been preallocated, usually by a call to<<bfd_get_reloc_upper_bound>>.  	The<<syms>> table is also needed for horrible internal magic 	reasons.   */
end_comment

begin_decl_stmt
name|unsigned
name|int
name|DEFUN
argument_list|(
name|bfd_canonicalize_reloc
argument_list|,
operator|(
name|abfd
operator|,
name|asect
operator|,
name|location
operator|,
name|symbols
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|sec_ptr
name|asect
name|AND
name|arelent
operator|*
operator|*
name|location
name|AND
name|asymbol
operator|*
operator|*
name|symbols
argument_list|)
block|{
if|if
condition|(
name|abfd
operator|->
name|format
operator|!=
name|bfd_object
condition|)
block|{
name|bfd_error
operator|=
name|invalid_operation
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|BFD_SEND
argument_list|(
name|abfd
argument_list|,
name|_bfd_canonicalize_reloc
argument_list|,
operator|(
name|abfd
operator|,
name|asect
operator|,
name|location
operator|,
name|symbols
operator|)
argument_list|)
return|;
block|}
end_decl_stmt

begin_comment
comment|/* FUNCTION 	bfd_set_file_flags  SYNOPSIS 	boolean bfd_set_file_flags(bfd *abfd, flagword flags);  DESCRIPTION 	This function attempts to set the flag word in the referenced 	BFD structure to the value supplied.  	Possible errors are: 	o wrong_format - The target bfd was not of object format. 	o invalid_operation - The target bfd was open for reading. 	o invalid_operation - 	The flag word contained a bit which was not applicable to the 	type of file. eg, an attempt was made to set the D_PAGED bit 	on a bfd format which does not support demand paging  */
end_comment

begin_function
name|boolean
name|bfd_set_file_flags
parameter_list|(
name|abfd
parameter_list|,
name|flags
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|flagword
name|flags
decl_stmt|;
block|{
if|if
condition|(
name|abfd
operator|->
name|format
operator|!=
name|bfd_object
condition|)
block|{
name|bfd_error
operator|=
name|wrong_format
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|bfd_read_p
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
name|bfd_error
operator|=
name|invalid_operation
expr_stmt|;
return|return
name|false
return|;
block|}
name|bfd_get_file_flags
argument_list|(
name|abfd
argument_list|)
operator|=
name|flags
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|bfd_applicable_file_flags
argument_list|(
name|abfd
argument_list|)
operator|)
operator|!=
name|flags
condition|)
block|{
name|bfd_error
operator|=
name|invalid_operation
expr_stmt|;
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* FUNCTION 	bfd_set_reloc  SYNOPSIS 	void bfd_set_reloc 	  (bfd *abfd, asection *sec, arelent **rel, unsigned int count)  DESCRIPTION 	This function sets the relocation pointer and count within a 	section to the supplied values.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|void
name|bfd_set_reloc
parameter_list|(
name|ignore_abfd
parameter_list|,
name|asect
parameter_list|,
name|location
parameter_list|,
name|count
parameter_list|)
name|bfd
modifier|*
name|ignore_abfd
decl_stmt|;
name|sec_ptr
name|asect
decl_stmt|;
name|arelent
modifier|*
modifier|*
name|location
decl_stmt|;
name|unsigned
name|int
name|count
decl_stmt|;
block|{
name|asect
operator|->
name|orelocation
operator|=
name|location
expr_stmt|;
name|asect
operator|->
name|reloc_count
operator|=
name|count
expr_stmt|;
block|}
end_function

begin_function
name|void
name|bfd_assert
parameter_list|(
name|file
parameter_list|,
name|line
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
name|int
name|line
decl_stmt|;
block|{
name|printf
argument_list|(
literal|"bfd assertion fail %s:%d\n"
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* FUNCTION 	bfd_set_start_address  DESCRIPTION 	Marks the entry point of an output BFD.  RETURNS 	Returns<<true>> on success,<<false>> otherwise.  SYNOPSIS  	boolean bfd_set_start_address(bfd *, bfd_vma); */
end_comment

begin_function
name|boolean
name|bfd_set_start_address
parameter_list|(
name|abfd
parameter_list|,
name|vma
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|bfd_vma
name|vma
decl_stmt|;
block|{
name|abfd
operator|->
name|start_address
operator|=
name|vma
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* FUNCTION 	The bfd_get_mtime function  SYNOPSIS 	long bfd_get_mtime(bfd *);  DESCRIPTION 	Return file modification time (as read from file system, or 	from archive header for archive members).  */
end_comment

begin_function
name|long
name|bfd_get_mtime
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
name|struct
name|stat
name|buf
decl_stmt|;
if|if
condition|(
name|abfd
operator|->
name|mtime_set
condition|)
return|return
name|abfd
operator|->
name|mtime
return|;
name|fp
operator|=
name|bfd_cache_lookup
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|!=
name|fstat
argument_list|(
name|fileno
argument_list|(
name|fp
argument_list|)
argument_list|,
operator|&
name|buf
argument_list|)
condition|)
return|return
literal|0
return|;
name|abfd
operator|->
name|mtime
operator|=
name|buf
operator|.
name|st_mtime
expr_stmt|;
comment|/* Save value in case anyone wants it */
return|return
name|buf
operator|.
name|st_mtime
return|;
block|}
end_function

begin_comment
comment|/* FUNCTION 	stuff  DESCRIPTION 	stuff which should be documented  .#define bfd_sizeof_headers(abfd, reloc) \ .     BFD_SEND (abfd, _bfd_sizeof_headers, (abfd, reloc)) . .#define bfd_find_nearest_line(abfd, sec, syms, off, file, func, line) \ .     BFD_SEND (abfd, _bfd_find_nearest_line,  (abfd, sec, syms, off, file, func, line)) . .       {* Do these three do anything useful at all, for any back end?  *} .#define bfd_debug_info_start(abfd) \ .        BFD_SEND (abfd, _bfd_debug_info_start, (abfd)) . .#define bfd_debug_info_end(abfd) \ .        BFD_SEND (abfd, _bfd_debug_info_end, (abfd)) . .#define bfd_debug_info_accumulate(abfd, section) \ .        BFD_SEND (abfd, _bfd_debug_info_accumulate, (abfd, section)) . . .#define bfd_stat_arch_elt(abfd, stat) \ .        BFD_SEND (abfd, _bfd_stat_arch_elt,(abfd, stat)) . .#define bfd_coff_swap_aux_in(a,e,t,c,i) \ .        BFD_SEND (a, _bfd_coff_swap_aux_in, (a,e,t,c,i)) . .#define bfd_coff_swap_sym_in(a,e,i) \ .        BFD_SEND (a, _bfd_coff_swap_sym_in, (a,e,i)) . .#define bfd_coff_swap_lineno_in(a,e,i) \ .        BFD_SEND ( a, _bfd_coff_swap_lineno_in, (a,e,i)) . .#define bfd_set_arch_mach(abfd, arch, mach)\ .        BFD_SEND ( abfd, _bfd_set_arch_mach, (abfd, arch, mach)) . .#define bfd_coff_swap_reloc_out(abfd, i, o) \ .        BFD_SEND (abfd, _bfd_coff_swap_reloc_out, (abfd, i, o)) . .#define bfd_coff_swap_lineno_out(abfd, i, o) \ .        BFD_SEND (abfd, _bfd_coff_swap_lineno_out, (abfd, i, o)) . .#define bfd_coff_swap_aux_out(abfd, i, t,c,o) \ .        BFD_SEND (abfd, _bfd_coff_swap_aux_out, (abfd, i,t,c, o)) . .#define bfd_coff_swap_sym_out(abfd, i,o) \ .        BFD_SEND (abfd, _bfd_coff_swap_sym_out, (abfd, i, o)) . .#define bfd_coff_swap_scnhdr_out(abfd, i,o) \ .        BFD_SEND (abfd, _bfd_coff_swap_scnhdr_out, (abfd, i, o)) . .#define bfd_coff_swap_filehdr_out(abfd, i,o) \ .        BFD_SEND (abfd, _bfd_coff_swap_filehdr_out, (abfd, i, o)) . .#define bfd_coff_swap_aouthdr_out(abfd, i,o) \ .        BFD_SEND (abfd, _bfd_coff_swap_aouthdr_out, (abfd, i, o)) . .#define bfd_get_relocated_section_contents(abfd, seclet, data) \ .	BFD_SEND (abfd, _bfd_get_relocated_section_contents, (abfd, seclet, data)) .  .#define bfd_relax_section(abfd, section, symbols) \ .       BFD_SEND (abfd, _bfd_relax_section, (abfd, section, symbols))  */
end_comment

end_unit

