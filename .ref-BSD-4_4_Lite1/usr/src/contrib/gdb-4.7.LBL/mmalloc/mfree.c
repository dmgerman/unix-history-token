begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Free a block of memory allocated by `mmalloc'.    Copyright 1990, 1991, 1992 Free Software Foundation     Written May 1989 by Mike Haertel.    Heavily modified Mar 1992 by Fred Fish.  (fnf@cygnus.com)  The GNU C Library is free software; you can redistribute it and/or modify it under the terms of the GNU Library General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  The GNU C Library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public License for more details.  You should have received a copy of the GNU Library General Public License along with the GNU C Library; see the file COPYING.LIB.  If not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.     The author may be reached (Email) at the address mike@ai.mit.edu,    or (US mail) as Mike Haertel c/o Free Software Foundation. */
end_comment

begin_include
include|#
directive|include
file|"mmalloc.h"
end_include

begin_comment
comment|/* Return memory to the heap.    Like `mfree' but don't call a mfree_hook if there is one.  */
end_comment

begin_function
name|void
name|__mmalloc_free
parameter_list|(
name|mdp
parameter_list|,
name|ptr
parameter_list|)
name|struct
name|mdesc
modifier|*
name|mdp
decl_stmt|;
name|PTR
name|ptr
decl_stmt|;
block|{
name|int
name|type
decl_stmt|;
name|size_t
name|block
decl_stmt|,
name|blocks
decl_stmt|;
specifier|register
name|size_t
name|i
decl_stmt|;
name|struct
name|list
modifier|*
name|prev
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|block
operator|=
name|BLOCK
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|type
operator|=
name|mdp
operator|->
name|heapinfo
index|[
name|block
index|]
operator|.
name|busy
operator|.
name|type
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
literal|0
case|:
comment|/* Get as many statistics as early as we can.  */
name|mdp
operator|->
name|heapstats
operator|.
name|chunks_used
operator|--
expr_stmt|;
name|mdp
operator|->
name|heapstats
operator|.
name|bytes_used
operator|-=
name|mdp
operator|->
name|heapinfo
index|[
name|block
index|]
operator|.
name|busy
operator|.
name|info
operator|.
name|size
operator|*
name|BLOCKSIZE
expr_stmt|;
name|mdp
operator|->
name|heapstats
operator|.
name|bytes_free
operator|+=
name|mdp
operator|->
name|heapinfo
index|[
name|block
index|]
operator|.
name|busy
operator|.
name|info
operator|.
name|size
operator|*
name|BLOCKSIZE
expr_stmt|;
comment|/* Find the free cluster previous to this one in the free list. 	 Start searching at the last block referenced; this may benefit 	 programs with locality of allocation.  */
name|i
operator|=
name|mdp
operator|->
name|heapindex
expr_stmt|;
if|if
condition|(
name|i
operator|>
name|block
condition|)
block|{
while|while
condition|(
name|i
operator|>
name|block
condition|)
block|{
name|i
operator|=
name|mdp
operator|->
name|heapinfo
index|[
name|i
index|]
operator|.
name|free
operator|.
name|prev
expr_stmt|;
block|}
block|}
else|else
block|{
do|do
block|{
name|i
operator|=
name|mdp
operator|->
name|heapinfo
index|[
name|i
index|]
operator|.
name|free
operator|.
name|next
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|i
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|i
operator|<
name|block
operator|)
condition|)
do|;
name|i
operator|=
name|mdp
operator|->
name|heapinfo
index|[
name|i
index|]
operator|.
name|free
operator|.
name|prev
expr_stmt|;
block|}
comment|/* Determine how to link this block into the free list.  */
if|if
condition|(
name|block
operator|==
name|i
operator|+
name|mdp
operator|->
name|heapinfo
index|[
name|i
index|]
operator|.
name|free
operator|.
name|size
condition|)
block|{
comment|/* Coalesce this block with its predecessor.  */
name|mdp
operator|->
name|heapinfo
index|[
name|i
index|]
operator|.
name|free
operator|.
name|size
operator|+=
name|mdp
operator|->
name|heapinfo
index|[
name|block
index|]
operator|.
name|busy
operator|.
name|info
operator|.
name|size
expr_stmt|;
name|block
operator|=
name|i
expr_stmt|;
block|}
else|else
block|{
comment|/* Really link this block back into the free list.  */
name|mdp
operator|->
name|heapinfo
index|[
name|block
index|]
operator|.
name|free
operator|.
name|size
operator|=
name|mdp
operator|->
name|heapinfo
index|[
name|block
index|]
operator|.
name|busy
operator|.
name|info
operator|.
name|size
expr_stmt|;
name|mdp
operator|->
name|heapinfo
index|[
name|block
index|]
operator|.
name|free
operator|.
name|next
operator|=
name|mdp
operator|->
name|heapinfo
index|[
name|i
index|]
operator|.
name|free
operator|.
name|next
expr_stmt|;
name|mdp
operator|->
name|heapinfo
index|[
name|block
index|]
operator|.
name|free
operator|.
name|prev
operator|=
name|i
expr_stmt|;
name|mdp
operator|->
name|heapinfo
index|[
name|i
index|]
operator|.
name|free
operator|.
name|next
operator|=
name|block
expr_stmt|;
name|mdp
operator|->
name|heapinfo
index|[
name|mdp
operator|->
name|heapinfo
index|[
name|block
index|]
operator|.
name|free
operator|.
name|next
index|]
operator|.
name|free
operator|.
name|prev
operator|=
name|block
expr_stmt|;
name|mdp
operator|->
name|heapstats
operator|.
name|chunks_free
operator|++
expr_stmt|;
block|}
comment|/* Now that the block is linked in, see if we can coalesce it 	 with its successor (by deleting its successor from the list 	 and adding in its size).  */
if|if
condition|(
name|block
operator|+
name|mdp
operator|->
name|heapinfo
index|[
name|block
index|]
operator|.
name|free
operator|.
name|size
operator|==
name|mdp
operator|->
name|heapinfo
index|[
name|block
index|]
operator|.
name|free
operator|.
name|next
condition|)
block|{
name|mdp
operator|->
name|heapinfo
index|[
name|block
index|]
operator|.
name|free
operator|.
name|size
operator|+=
name|mdp
operator|->
name|heapinfo
index|[
name|mdp
operator|->
name|heapinfo
index|[
name|block
index|]
operator|.
name|free
operator|.
name|next
index|]
operator|.
name|free
operator|.
name|size
expr_stmt|;
name|mdp
operator|->
name|heapinfo
index|[
name|block
index|]
operator|.
name|free
operator|.
name|next
operator|=
name|mdp
operator|->
name|heapinfo
index|[
name|mdp
operator|->
name|heapinfo
index|[
name|block
index|]
operator|.
name|free
operator|.
name|next
index|]
operator|.
name|free
operator|.
name|next
expr_stmt|;
name|mdp
operator|->
name|heapinfo
index|[
name|mdp
operator|->
name|heapinfo
index|[
name|block
index|]
operator|.
name|free
operator|.
name|next
index|]
operator|.
name|free
operator|.
name|prev
operator|=
name|block
expr_stmt|;
name|mdp
operator|->
name|heapstats
operator|.
name|chunks_free
operator|--
expr_stmt|;
block|}
comment|/* Now see if we can return stuff to the system.  */
name|blocks
operator|=
name|mdp
operator|->
name|heapinfo
index|[
name|block
index|]
operator|.
name|free
operator|.
name|size
expr_stmt|;
if|if
condition|(
name|blocks
operator|>=
name|FINAL_FREE_BLOCKS
operator|&&
name|block
operator|+
name|blocks
operator|==
name|mdp
operator|->
name|heaplimit
operator|&&
name|mdp
operator|->
name|morecore
argument_list|(
name|mdp
argument_list|,
literal|0
argument_list|)
operator|==
name|ADDRESS
argument_list|(
name|block
operator|+
name|blocks
argument_list|)
condition|)
block|{
specifier|register
name|size_t
name|bytes
init|=
name|blocks
operator|*
name|BLOCKSIZE
decl_stmt|;
name|mdp
operator|->
name|heaplimit
operator|-=
name|blocks
expr_stmt|;
name|mdp
operator|->
name|morecore
argument_list|(
name|mdp
argument_list|,
operator|-
name|bytes
argument_list|)
expr_stmt|;
name|mdp
operator|->
name|heapinfo
index|[
name|mdp
operator|->
name|heapinfo
index|[
name|block
index|]
operator|.
name|free
operator|.
name|prev
index|]
operator|.
name|free
operator|.
name|next
operator|=
name|mdp
operator|->
name|heapinfo
index|[
name|block
index|]
operator|.
name|free
operator|.
name|next
expr_stmt|;
name|mdp
operator|->
name|heapinfo
index|[
name|mdp
operator|->
name|heapinfo
index|[
name|block
index|]
operator|.
name|free
operator|.
name|next
index|]
operator|.
name|free
operator|.
name|prev
operator|=
name|mdp
operator|->
name|heapinfo
index|[
name|block
index|]
operator|.
name|free
operator|.
name|prev
expr_stmt|;
name|block
operator|=
name|mdp
operator|->
name|heapinfo
index|[
name|block
index|]
operator|.
name|free
operator|.
name|prev
expr_stmt|;
name|mdp
operator|->
name|heapstats
operator|.
name|chunks_free
operator|--
expr_stmt|;
name|mdp
operator|->
name|heapstats
operator|.
name|bytes_free
operator|-=
name|bytes
expr_stmt|;
block|}
comment|/* Set the next search to begin at this block.  */
name|mdp
operator|->
name|heapindex
operator|=
name|block
expr_stmt|;
break|break;
default|default:
comment|/* Do some of the statistics.  */
name|mdp
operator|->
name|heapstats
operator|.
name|chunks_used
operator|--
expr_stmt|;
name|mdp
operator|->
name|heapstats
operator|.
name|bytes_used
operator|-=
literal|1
operator|<<
name|type
expr_stmt|;
name|mdp
operator|->
name|heapstats
operator|.
name|chunks_free
operator|++
expr_stmt|;
name|mdp
operator|->
name|heapstats
operator|.
name|bytes_free
operator|+=
literal|1
operator|<<
name|type
expr_stmt|;
comment|/* Get the address of the first free fragment in this block.  */
name|prev
operator|=
operator|(
expr|struct
name|list
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|ADDRESS
argument_list|(
name|block
argument_list|)
operator|+
operator|(
name|mdp
operator|->
name|heapinfo
index|[
name|block
index|]
operator|.
name|busy
operator|.
name|info
operator|.
name|frag
operator|.
name|first
operator|<<
name|type
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|mdp
operator|->
name|heapinfo
index|[
name|block
index|]
operator|.
name|busy
operator|.
name|info
operator|.
name|frag
operator|.
name|nfree
operator|==
operator|(
name|BLOCKSIZE
operator|>>
name|type
operator|)
operator|-
literal|1
condition|)
block|{
comment|/* If all fragments of this block are free, remove them 	     from the fragment list and free the whole block.  */
name|next
operator|=
name|prev
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
call|(
name|size_t
call|)
argument_list|(
name|BLOCKSIZE
operator|>>
name|type
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|next
operator|=
name|next
operator|->
name|next
expr_stmt|;
block|}
name|prev
operator|->
name|prev
operator|->
name|next
operator|=
name|next
expr_stmt|;
if|if
condition|(
name|next
operator|!=
name|NULL
condition|)
block|{
name|next
operator|->
name|prev
operator|=
name|prev
operator|->
name|prev
expr_stmt|;
block|}
name|mdp
operator|->
name|heapinfo
index|[
name|block
index|]
operator|.
name|busy
operator|.
name|type
operator|=
literal|0
expr_stmt|;
name|mdp
operator|->
name|heapinfo
index|[
name|block
index|]
operator|.
name|busy
operator|.
name|info
operator|.
name|size
operator|=
literal|1
expr_stmt|;
comment|/* Keep the statistics accurate.  */
name|mdp
operator|->
name|heapstats
operator|.
name|chunks_used
operator|++
expr_stmt|;
name|mdp
operator|->
name|heapstats
operator|.
name|bytes_used
operator|+=
name|BLOCKSIZE
expr_stmt|;
name|mdp
operator|->
name|heapstats
operator|.
name|chunks_free
operator|-=
name|BLOCKSIZE
operator|>>
name|type
expr_stmt|;
name|mdp
operator|->
name|heapstats
operator|.
name|bytes_free
operator|-=
name|BLOCKSIZE
expr_stmt|;
name|mfree
argument_list|(
operator|(
name|PTR
operator|)
name|mdp
argument_list|,
operator|(
name|PTR
operator|)
name|ADDRESS
argument_list|(
name|block
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mdp
operator|->
name|heapinfo
index|[
name|block
index|]
operator|.
name|busy
operator|.
name|info
operator|.
name|frag
operator|.
name|nfree
operator|!=
literal|0
condition|)
block|{
comment|/* If some fragments of this block are free, link this 	     fragment into the fragment list after the first free 	     fragment of this block. */
name|next
operator|=
operator|(
expr|struct
name|list
operator|*
operator|)
name|ptr
expr_stmt|;
name|next
operator|->
name|next
operator|=
name|prev
operator|->
name|next
expr_stmt|;
name|next
operator|->
name|prev
operator|=
name|prev
expr_stmt|;
name|prev
operator|->
name|next
operator|=
name|next
expr_stmt|;
if|if
condition|(
name|next
operator|->
name|next
operator|!=
name|NULL
condition|)
block|{
name|next
operator|->
name|next
operator|->
name|prev
operator|=
name|next
expr_stmt|;
block|}
operator|++
name|mdp
operator|->
name|heapinfo
index|[
name|block
index|]
operator|.
name|busy
operator|.
name|info
operator|.
name|frag
operator|.
name|nfree
expr_stmt|;
block|}
else|else
block|{
comment|/* No fragments of this block are free, so link this 	     fragment into the fragment list and announce that 	     it is the first free fragment of this block. */
name|prev
operator|=
operator|(
expr|struct
name|list
operator|*
operator|)
name|ptr
expr_stmt|;
name|mdp
operator|->
name|heapinfo
index|[
name|block
index|]
operator|.
name|busy
operator|.
name|info
operator|.
name|frag
operator|.
name|nfree
operator|=
literal|1
expr_stmt|;
name|mdp
operator|->
name|heapinfo
index|[
name|block
index|]
operator|.
name|busy
operator|.
name|info
operator|.
name|frag
operator|.
name|first
operator|=
name|RESIDUAL
argument_list|(
name|ptr
argument_list|,
name|BLOCKSIZE
argument_list|)
operator|>>
name|type
expr_stmt|;
name|prev
operator|->
name|next
operator|=
name|mdp
operator|->
name|fraghead
index|[
name|type
index|]
operator|.
name|next
expr_stmt|;
name|prev
operator|->
name|prev
operator|=
operator|&
name|mdp
operator|->
name|fraghead
index|[
name|type
index|]
expr_stmt|;
name|prev
operator|->
name|prev
operator|->
name|next
operator|=
name|prev
expr_stmt|;
if|if
condition|(
name|prev
operator|->
name|next
operator|!=
name|NULL
condition|)
block|{
name|prev
operator|->
name|next
operator|->
name|prev
operator|=
name|prev
expr_stmt|;
block|}
block|}
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Return memory to the heap.  */
end_comment

begin_function
name|void
name|mfree
parameter_list|(
name|md
parameter_list|,
name|ptr
parameter_list|)
name|PTR
name|md
decl_stmt|;
name|PTR
name|ptr
decl_stmt|;
block|{
name|struct
name|mdesc
modifier|*
name|mdp
decl_stmt|;
specifier|register
name|struct
name|alignlist
modifier|*
name|l
decl_stmt|;
if|if
condition|(
name|ptr
operator|!=
name|NULL
condition|)
block|{
name|mdp
operator|=
name|MD_TO_MDP
argument_list|(
name|md
argument_list|)
expr_stmt|;
for|for
control|(
name|l
operator|=
name|mdp
operator|->
name|aligned_blocks
init|;
name|l
operator|!=
name|NULL
condition|;
name|l
operator|=
name|l
operator|->
name|next
control|)
block|{
if|if
condition|(
name|l
operator|->
name|aligned
operator|==
name|ptr
condition|)
block|{
name|l
operator|->
name|aligned
operator|=
name|NULL
expr_stmt|;
comment|/* Mark the slot in the list as free. */
name|ptr
operator|=
name|l
operator|->
name|exact
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|mdp
operator|->
name|mfree_hook
operator|!=
name|NULL
condition|)
block|{
call|(
modifier|*
name|mdp
operator|->
name|mfree_hook
call|)
argument_list|(
name|md
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|__mmalloc_free
argument_list|(
name|mdp
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* When using this package, provide a version of malloc/realloc/free built    on top of it, so that if we use the default sbrk() region we will not    collide with another malloc package trying to do the same thing, if    the application contains any "hidden" calls to malloc/realloc/free (such    as inside a system library). */
end_comment

begin_function
name|void
name|free
parameter_list|(
name|ptr
parameter_list|)
name|PTR
name|ptr
decl_stmt|;
block|{
name|mfree
argument_list|(
operator|(
name|PTR
operator|)
name|NULL
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

