begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Read AIX xcoff symbol tables and convert to internal format, for GDB.    Copyright 1986, 1987, 1988, 1989, 1990, 1991, 1992    	     Free Software Foundation, Inc.    Derived from coffread.c, dbxread.c, and a lot of hacking.    Contributed by IBM Corporation.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|IBM6000_HOST
argument_list|)
operator|&&
name|defined
argument_list|(
name|IBM6000_TARGET
argument_list|)
end_if

begin_comment
comment|/* Native only:  Need struct tbtable in<sys/debug.h> from host, and  		 need xcoff_add_toc_to_loadinfo in rs6000-tdep.c from target. */
end_comment

begin_comment
comment|/* AIX XCOFF names have a preceeding dot `.' */
end_comment

begin_define
define|#
directive|define
name|NAMES_HAVE_DOT
value|1
end_define

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|NO_SYS_FILE
end_ifndef

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/debug.h>
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"gdbtypes.h"
end_include

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_include
include|#
directive|include
file|"objfiles.h"
end_include

begin_include
include|#
directive|include
file|"buildsym.h"
end_include

begin_include
include|#
directive|include
file|"stabsread.h"
end_include

begin_include
include|#
directive|include
file|"gdb-stabs.h"
end_include

begin_include
include|#
directive|include
file|"coff/internal.h"
end_include

begin_comment
comment|/* FIXME, internal data from BFD */
end_comment

begin_include
include|#
directive|include
file|"libcoff.h"
end_include

begin_comment
comment|/* FIXME, internal data from BFD */
end_comment

begin_include
include|#
directive|include
file|"coff/rs6000.h"
end_include

begin_comment
comment|/* FIXME, raw file-format guts of xcoff */
end_comment

begin_comment
comment|/* Define this if you want gdb use the old xcoff symbol processing. This    way it won't use common `define_symbol()' function and Sun dbx stab    string grammar. And likely it won't be able to do G++ debugging. */
end_comment

begin_comment
comment|/* #define	NO_DEFINE_SYMBOL 1 */
end_comment

begin_comment
comment|/* Define this if you want gdb to ignore typdef stabs. This was needed for    one of Transarc, to reduce the size of the symbol table. Types won't be    recognized, but tag names will be. */
end_comment

begin_comment
comment|/* #define	NO_TYPEDEFS  1 */
end_comment

begin_comment
comment|/* Simplified internal version of coff symbol table information */
end_comment

begin_struct
struct|struct
name|coff_symbol
block|{
name|char
modifier|*
name|c_name
decl_stmt|;
name|int
name|c_symnum
decl_stmt|;
comment|/* symbol number of this entry */
name|int
name|c_nsyms
decl_stmt|;
comment|/* 0 if syment only, 1 if syment + auxent */
name|long
name|c_value
decl_stmt|;
name|int
name|c_sclass
decl_stmt|;
name|int
name|c_secnum
decl_stmt|;
name|unsigned
name|int
name|c_type
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* The COFF line table, in raw form.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|linetab
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Its actual contents */
end_comment

begin_decl_stmt
specifier|static
name|long
name|linetab_offset
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Its offset in the file */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|linetab_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Its size */
end_comment

begin_comment
comment|/* last function's saved coff symbol `cs' */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|coff_symbol
name|fcn_cs_saved
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd
modifier|*
name|symfile_bfd
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Core address of start and end of text of current source file.    This is calculated from the first function seen after a C_FILE    symbol. */
end_comment

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|cur_src_end_addr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Core address of the end of the first object file.  */
end_comment

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|first_object_file_end
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pointer to the string table */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|strtbl
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* length of the string table */
end_comment

begin_decl_stmt
specifier|static
name|int
name|strtbl_len
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pointer to debug section */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|debugsec
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pointer to the a.out symbol table */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|symtbl
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* initial symbol-table-debug-string vector length */
end_comment

begin_define
define|#
directive|define
name|INITIAL_STABVECTOR_LENGTH
value|40
end_define

begin_comment
comment|/* Nonzero if within a function (so symbols should be local,    if nothing says specifically).  */
end_comment

begin_decl_stmt
name|int
name|within_function
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Local variables that hold the shift and mask values for the    COFF file that we are currently reading.  These come back to us    from BFD, and are referenced by their macro names, as well as    internally to the BTYPE, ISPTR, ISFCN, ISARY, ISTAG, and DECREF    macros from ../internalcoff.h .  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|local_n_btshft
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|local_n_tmask
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|N_BTSHFT
end_undef

begin_define
define|#
directive|define
name|N_BTSHFT
value|local_n_btshft
end_define

begin_undef
undef|#
directive|undef
name|N_TMASK
end_undef

begin_define
define|#
directive|define
name|N_TMASK
value|local_n_tmask
end_define

begin_comment
comment|/* Local variables that hold the sizes in the file of various COFF structures.    (We only need to know this to read them from the file -- BFD will then    translate the data in them, into `internal_xxx' structs in the right    byte order, alignment, etc.)  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|local_symesz
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* coff_symfile_init()    is the coff-specific initialization routine for reading symbols.    It is passed a struct sym_fns which contains, among other things,    the BFD for the file whose symbols are being read, and a slot for    a pointer to "private data" which we fill with cookies and other    treats for coff_symfile_read().      We will only be called if this is a COFF or COFF-like file.    BFD handles figuring out the format of the file, and code in symtab.c    uses BFD's determination to vector to us.      The ultimate result is a new symtab (or, FIXME, eventually a psymtab).  */
end_comment

begin_struct
struct|struct
name|coff_symfile_info
block|{
name|file_ptr
name|min_lineno_offset
decl_stmt|;
comment|/* Where in file lowest line#s are */
name|file_ptr
name|max_lineno_offset
decl_stmt|;
comment|/* 1+last byte of line#s in file */
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|void
name|enter_line_range
name|PARAMS
argument_list|(
operator|(
expr|struct
name|subfile
operator|*
operator|,
name|unsigned
operator|,
name|unsigned
operator|,
name|CORE_ADDR
operator|,
name|CORE_ADDR
operator|,
name|unsigned
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|free_debugsection
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|init_debugsection
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|init_stringtab
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|file_ptr
operator|,
expr|struct
name|objfile
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|xcoff_symfile_init
name|PARAMS
argument_list|(
operator|(
expr|struct
name|objfile
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|xcoff_new_init
name|PARAMS
argument_list|(
operator|(
expr|struct
name|objfile
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_struct_decl
struct_decl|struct
name|section_offset
struct_decl|;
end_struct_decl

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|void
name|xcoff_symfile_read
name|PARAMS
argument_list|(
operator|(
expr|struct
name|objfile
operator|*
operator|,
expr|struct
name|section_offset
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|xcoff_symfile_finish
name|PARAMS
argument_list|(
operator|(
expr|struct
name|objfile
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|section_offsets
modifier|*
name|xcoff_symfile_offsets
name|PARAMS
argument_list|(
operator|(
expr|struct
name|objfile
operator|*
operator|,
name|CORE_ADDR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|init_lineno
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|file_ptr
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|find_linenos
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|sec_ptr
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|read_symbol_lineno
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|read_symbol_nvalue
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|symbol
modifier|*
name|process_xcoff_symbol
name|PARAMS
argument_list|(
operator|(
expr|struct
name|coff_symbol
operator|*
operator|,
expr|struct
name|objfile
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|read_xcoff_symtab
name|PARAMS
argument_list|(
operator|(
expr|struct
name|objfile
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_stab_to_list
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
expr|struct
name|pending_stabs
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|sort_syms
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|compare_symbols
name|PARAMS
argument_list|(
operator|(
specifier|const
name|void
operator|*
operator|,
specifier|const
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Call sort_syms to sort alphabetically    the symbols of each block of each symtab.  */
end_comment

begin_function
specifier|static
name|int
name|compare_symbols
parameter_list|(
name|s1p
parameter_list|,
name|s2p
parameter_list|)
specifier|const
name|PTR
name|s1p
decl_stmt|;
specifier|const
name|PTR
name|s2p
decl_stmt|;
block|{
comment|/* Names that are less should come first.  */
specifier|register
name|struct
name|symbol
modifier|*
modifier|*
name|s1
init|=
operator|(
expr|struct
name|symbol
operator|*
operator|*
operator|)
name|s1p
decl_stmt|;
specifier|register
name|struct
name|symbol
modifier|*
modifier|*
name|s2
init|=
operator|(
expr|struct
name|symbol
operator|*
operator|*
operator|)
name|s2p
decl_stmt|;
specifier|register
name|int
name|namediff
init|=
name|strcmp
argument_list|(
name|SYMBOL_NAME
argument_list|(
operator|*
name|s1
argument_list|)
argument_list|,
name|SYMBOL_NAME
argument_list|(
operator|*
name|s2
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|namediff
operator|!=
literal|0
condition|)
return|return
name|namediff
return|;
comment|/* For symbols of the same name, registers should come first.  */
return|return
operator|(
operator|(
name|SYMBOL_CLASS
argument_list|(
operator|*
name|s2
argument_list|)
operator|==
name|LOC_REGISTER
operator|)
operator|-
operator|(
name|SYMBOL_CLASS
argument_list|(
operator|*
name|s1
argument_list|)
operator|==
name|LOC_REGISTER
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Sort a vector of symbols by their value. */
end_comment

begin_function
specifier|static
name|void
name|sort_syms
parameter_list|()
block|{
specifier|register
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
specifier|register
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|nbl
decl_stmt|;
specifier|register
name|struct
name|blockvector
modifier|*
name|bv
decl_stmt|;
specifier|register
name|struct
name|block
modifier|*
name|b
decl_stmt|;
for|for
control|(
name|objfile
operator|=
name|object_files
init|;
name|objfile
operator|!=
name|NULL
condition|;
name|objfile
operator|=
name|objfile
operator|->
name|next
control|)
block|{
for|for
control|(
name|s
operator|=
name|objfile
operator|->
name|symtabs
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
name|bv
operator|=
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|nbl
operator|=
name|BLOCKVECTOR_NBLOCKS
argument_list|(
name|bv
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nbl
condition|;
name|i
operator|++
control|)
block|{
name|b
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|BLOCK_SHOULD_SORT
argument_list|(
name|b
argument_list|)
condition|)
block|{
name|qsort
argument_list|(
operator|&
name|BLOCK_SYM
argument_list|(
name|b
argument_list|,
literal|0
argument_list|)
argument_list|,
name|BLOCK_NSYMS
argument_list|(
name|b
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|symbol
operator|*
argument_list|)
argument_list|,
name|compare_symbols
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* add a given stab string into given stab vector. */
end_comment

begin_function
specifier|static
name|void
name|add_stab_to_list
parameter_list|(
name|stabname
parameter_list|,
name|stabvector
parameter_list|)
name|char
modifier|*
name|stabname
decl_stmt|;
name|struct
name|pending_stabs
modifier|*
modifier|*
name|stabvector
decl_stmt|;
block|{
if|if
condition|(
operator|*
name|stabvector
operator|==
name|NULL
condition|)
block|{
operator|*
name|stabvector
operator|=
operator|(
expr|struct
name|pending_stabs
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|pending_stabs
argument_list|)
operator|+
name|INITIAL_STABVECTOR_LENGTH
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|stabvector
operator|)
operator|->
name|count
operator|=
literal|0
expr_stmt|;
operator|(
operator|*
name|stabvector
operator|)
operator|->
name|length
operator|=
name|INITIAL_STABVECTOR_LENGTH
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|stabvector
operator|)
operator|->
name|count
operator|>=
operator|(
operator|*
name|stabvector
operator|)
operator|->
name|length
condition|)
block|{
operator|(
operator|*
name|stabvector
operator|)
operator|->
name|length
operator|+=
name|INITIAL_STABVECTOR_LENGTH
expr_stmt|;
operator|*
name|stabvector
operator|=
operator|(
expr|struct
name|pending_stabs
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|*
name|stabvector
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pending_stabs
argument_list|)
operator|+
operator|(
operator|*
name|stabvector
operator|)
operator|->
name|length
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|(
operator|*
name|stabvector
operator|)
operator|->
name|stab
index|[
operator|(
operator|*
name|stabvector
operator|)
operator|->
name|count
operator|++
index|]
operator|=
name|stabname
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* for all the stabs in a given stab vector, build appropriate types     and fix their symbols in given symbol vector. */
end_comment

begin_comment
unit|void patch_block_stabs (symbols, stabs) struct pending *symbols; struct pending_stabs *stabs; {   int ii;    if (!stabs)     return;
comment|/* for all the stab entries, find their corresponding symbols and       patch their types! */
end_comment

begin_comment
unit|for (ii=0; ii< stabs->count; ++ii) {     char *name = stabs->stab[ii];     char *pp = (char*) index (name, ':');     struct symbol *sym = find_symbol_in_list (symbols, name, pp-name);     if (!sym) {       ;
comment|/* printf ("ERROR! stab symbol not found!\n"); */
end_comment

begin_comment
comment|/* FIXME */
end_comment

begin_comment
comment|/* The above is a false alarm. There are cases the we can have          a stab, without its symbol. xlc generates this for the extern 	 definitions in inner blocks. */
end_comment

begin_endif
unit|}     else {       pp += 2;        if (*(pp-1) == 'F' || *(pp-1) == 'f') 	SYMBOL_TYPE (sym) = lookup_function_type (read_type (&pp));       else 	SYMBOL_TYPE (sym) = read_type (&pp, objfile);     }   } }
endif|#
directive|endif
end_endif

begin_comment
comment|/* compare line table entry addresses. */
end_comment

begin_function
specifier|static
name|int
name|compare_lte
parameter_list|(
name|lte1
parameter_list|,
name|lte2
parameter_list|)
name|struct
name|linetable_entry
modifier|*
name|lte1
decl_stmt|,
decl|*
name|lte2
decl_stmt|;
end_function

begin_block
block|{
return|return
name|lte1
operator|->
name|pc
operator|-
name|lte2
operator|->
name|pc
return|;
block|}
end_block

begin_comment
comment|/* Give a line table with function entries are marked, arrange its functions    in assending order and strip off function entry markers and return it in    a newly created table. If the old one is good enough, return the old one. */
end_comment

begin_function
specifier|static
name|struct
name|linetable
modifier|*
name|arrange_linetable
parameter_list|(
name|oldLineTb
parameter_list|)
name|struct
name|linetable
modifier|*
name|oldLineTb
decl_stmt|;
comment|/* old linetable */
block|{
name|int
name|ii
decl_stmt|,
name|jj
decl_stmt|,
name|newline
decl_stmt|,
comment|/* new line count */
name|function_count
decl_stmt|;
comment|/* # of functions */
name|struct
name|linetable_entry
modifier|*
name|fentry
decl_stmt|;
comment|/* function entry vector */
name|int
name|fentry_size
decl_stmt|;
comment|/* # of function entries */
name|struct
name|linetable
modifier|*
name|newLineTb
decl_stmt|;
comment|/* new line table */
define|#
directive|define
name|NUM_OF_FUNCTIONS
value|20
name|fentry_size
operator|=
name|NUM_OF_FUNCTIONS
expr_stmt|;
name|fentry
operator|=
operator|(
expr|struct
name|linetable_entry
operator|*
operator|)
name|malloc
argument_list|(
name|fentry_size
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|linetable_entry
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|function_count
operator|=
literal|0
operator|,
name|ii
operator|=
literal|0
init|;
name|ii
operator|<
name|oldLineTb
operator|->
name|nitems
condition|;
operator|++
name|ii
control|)
block|{
if|if
condition|(
name|oldLineTb
operator|->
name|item
index|[
name|ii
index|]
operator|.
name|line
operator|==
literal|0
condition|)
block|{
comment|/* function entry found. */
if|if
condition|(
name|function_count
operator|>=
name|fentry_size
condition|)
block|{
comment|/* make sure you have room. */
name|fentry_size
operator|*=
literal|2
expr_stmt|;
name|fentry
operator|=
operator|(
expr|struct
name|linetable_entry
operator|*
operator|)
name|realloc
argument_list|(
name|fentry
argument_list|,
name|fentry_size
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|linetable_entry
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|fentry
index|[
name|function_count
index|]
operator|.
name|line
operator|=
name|ii
expr_stmt|;
name|fentry
index|[
name|function_count
index|]
operator|.
name|pc
operator|=
name|oldLineTb
operator|->
name|item
index|[
name|ii
index|]
operator|.
name|pc
expr_stmt|;
operator|++
name|function_count
expr_stmt|;
block|}
block|}
if|if
condition|(
name|function_count
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|fentry
argument_list|)
expr_stmt|;
return|return
name|oldLineTb
return|;
block|}
elseif|else
if|if
condition|(
name|function_count
operator|>
literal|1
condition|)
name|qsort
argument_list|(
name|fentry
argument_list|,
name|function_count
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|linetable_entry
argument_list|)
argument_list|,
name|compare_lte
argument_list|)
expr_stmt|;
comment|/* allocate a new line table. */
name|newLineTb
operator|=
operator|(
expr|struct
name|linetable
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|linetable
argument_list|)
operator|+
operator|(
name|oldLineTb
operator|->
name|nitems
operator|-
name|function_count
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|linetable_entry
argument_list|)
argument_list|)
expr_stmt|;
comment|/* if line table does not start with a function beginning, copy up until      a function begin. */
name|newline
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|oldLineTb
operator|->
name|item
index|[
literal|0
index|]
operator|.
name|line
operator|!=
literal|0
condition|)
for|for
control|(
name|newline
operator|=
literal|0
init|;
name|newline
operator|<
name|oldLineTb
operator|->
name|nitems
operator|&&
name|oldLineTb
operator|->
name|item
index|[
name|newline
index|]
operator|.
name|line
condition|;
operator|++
name|newline
control|)
name|newLineTb
operator|->
name|item
index|[
name|newline
index|]
operator|=
name|oldLineTb
operator|->
name|item
index|[
name|newline
index|]
expr_stmt|;
comment|/* Now copy function lines one by one. */
for|for
control|(
name|ii
operator|=
literal|0
init|;
name|ii
operator|<
name|function_count
condition|;
operator|++
name|ii
control|)
block|{
for|for
control|(
name|jj
operator|=
name|fentry
index|[
name|ii
index|]
operator|.
name|line
operator|+
literal|1
init|;
name|jj
operator|<
name|oldLineTb
operator|->
name|nitems
operator|&&
name|oldLineTb
operator|->
name|item
index|[
name|jj
index|]
operator|.
name|line
operator|!=
literal|0
condition|;
operator|++
name|jj
operator|,
operator|++
name|newline
control|)
name|newLineTb
operator|->
name|item
index|[
name|newline
index|]
operator|=
name|oldLineTb
operator|->
name|item
index|[
name|jj
index|]
expr_stmt|;
block|}
name|free
argument_list|(
name|fentry
argument_list|)
expr_stmt|;
name|newLineTb
operator|->
name|nitems
operator|=
name|oldLineTb
operator|->
name|nitems
operator|-
name|function_count
expr_stmt|;
return|return
name|newLineTb
return|;
block|}
end_function

begin_comment
comment|/* We try to detect the beginning of a compilation unit. That info will    be used as an entry in line number recording routines (enter_line_range) */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|first_fun_line_offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|first_fun_bf
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|mark_first_line
parameter_list|(
name|OFFSET
parameter_list|,
name|SYMNUM
parameter_list|)
define|\
value|if (!first_fun_line_offset) {         \     first_fun_line_offset = OFFSET;     \     first_fun_bf = SYMNUM;              \   }
end_define

begin_comment
comment|/* include file support: C_BINCL/C_EINCL pairs will be kept in the     following `IncludeChain'. At the end of each symtab (end_symtab),    we will determine if we should create additional symtab's to    represent if (the include files. */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|_inclTable
block|{
name|char
modifier|*
name|name
decl_stmt|;
comment|/* include filename */
name|int
name|begin
decl_stmt|,
name|end
decl_stmt|;
comment|/* offsets to the line table */
name|struct
name|subfile
modifier|*
name|subfile
decl_stmt|;
name|unsigned
name|funStartLine
decl_stmt|;
comment|/* start line # of its function */
block|}
name|InclTable
typedef|;
end_typedef

begin_define
define|#
directive|define
name|INITIAL_INCLUDE_TABLE_LENGTH
value|20
end_define

begin_decl_stmt
specifier|static
name|InclTable
modifier|*
name|inclTable
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* global include table */
end_comment

begin_decl_stmt
specifier|static
name|int
name|inclIndx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* last entry to table */
end_comment

begin_decl_stmt
specifier|static
name|int
name|inclLength
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* table length */
end_comment

begin_decl_stmt
specifier|static
name|int
name|inclDepth
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* nested include depth */
end_comment

begin_function
specifier|static
name|void
name|record_include_begin
parameter_list|(
name|cs
parameter_list|)
name|struct
name|coff_symbol
modifier|*
name|cs
decl_stmt|;
block|{
comment|/* In xcoff, we assume include files cannot be nested (not in .c files      of course, but in corresponding .s files.) */
if|if
condition|(
name|inclDepth
condition|)
name|fatal
argument_list|(
literal|"xcoff internal: pending include file exists."
argument_list|)
expr_stmt|;
operator|++
name|inclDepth
expr_stmt|;
comment|/* allocate an include file, or make room for the new entry */
if|if
condition|(
name|inclLength
operator|==
literal|0
condition|)
block|{
name|inclTable
operator|=
operator|(
name|InclTable
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|InclTable
argument_list|)
operator|*
name|INITIAL_INCLUDE_TABLE_LENGTH
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|inclTable
argument_list|,
sizeof|sizeof
argument_list|(
name|InclTable
argument_list|)
operator|*
name|INITIAL_INCLUDE_TABLE_LENGTH
argument_list|)
expr_stmt|;
name|inclLength
operator|=
name|INITIAL_INCLUDE_TABLE_LENGTH
expr_stmt|;
name|inclIndx
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|inclIndx
operator|>=
name|inclLength
condition|)
block|{
name|inclLength
operator|+=
name|INITIAL_INCLUDE_TABLE_LENGTH
expr_stmt|;
name|inclTable
operator|=
operator|(
name|InclTable
operator|*
operator|)
name|xrealloc
argument_list|(
name|inclTable
argument_list|,
sizeof|sizeof
argument_list|(
name|InclTable
argument_list|)
operator|*
name|inclLength
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|inclTable
operator|+
name|inclLength
operator|-
name|INITIAL_INCLUDE_TABLE_LENGTH
argument_list|,
sizeof|sizeof
argument_list|(
name|InclTable
argument_list|)
operator|*
name|INITIAL_INCLUDE_TABLE_LENGTH
argument_list|)
expr_stmt|;
block|}
name|inclTable
index|[
name|inclIndx
index|]
operator|.
name|name
operator|=
name|cs
operator|->
name|c_name
expr_stmt|;
name|inclTable
index|[
name|inclIndx
index|]
operator|.
name|begin
operator|=
name|cs
operator|->
name|c_value
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|record_include_end
parameter_list|(
name|cs
parameter_list|)
name|struct
name|coff_symbol
modifier|*
name|cs
decl_stmt|;
block|{
name|InclTable
modifier|*
name|pTbl
decl_stmt|;
if|if
condition|(
name|inclDepth
operator|==
literal|0
condition|)
name|fatal
argument_list|(
literal|"xcoff internal: Mismatch C_BINCL/C_EINCL pair found."
argument_list|)
expr_stmt|;
name|pTbl
operator|=
operator|&
name|inclTable
index|[
name|inclIndx
index|]
expr_stmt|;
name|pTbl
operator|->
name|end
operator|=
name|cs
operator|->
name|c_value
expr_stmt|;
operator|--
name|inclDepth
expr_stmt|;
operator|++
name|inclIndx
expr_stmt|;
block|}
end_function

begin_comment
comment|/* given the start and end addresses of a compilation unit (or a csect, at times)    process its lines and create appropriate line vectors. */
end_comment

begin_function
specifier|static
name|void
name|process_linenos
parameter_list|(
name|start
parameter_list|,
name|end
parameter_list|)
name|CORE_ADDR
name|start
decl_stmt|,
name|end
decl_stmt|;
block|{
name|char
modifier|*
name|pp
decl_stmt|;
name|int
name|offset
decl_stmt|,
name|ii
decl_stmt|;
name|struct
name|subfile
name|main_subfile
decl_stmt|;
comment|/* subfile structure for the main   					   compilation unit. */
comment|/* in the main source file, any time we see a function entry, we reset      this variable to function's absolute starting line number. All the      following line numbers in the function are relative to this, and      we record absolute line numbers in record_line(). */
name|int
name|main_source_baseline
init|=
literal|0
decl_stmt|;
name|unsigned
modifier|*
name|firstLine
decl_stmt|;
name|CORE_ADDR
name|addr
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|offset
operator|=
name|first_fun_line_offset
operator|)
condition|)
goto|goto
name|return_after_cleanup
goto|;
name|bzero
argument_list|(
operator|&
name|main_subfile
argument_list|,
sizeof|sizeof
argument_list|(
name|main_subfile
argument_list|)
argument_list|)
expr_stmt|;
name|first_fun_line_offset
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|inclIndx
operator|==
literal|0
condition|)
comment|/* All source lines were in the main source file. None in include files. */
name|enter_line_range
argument_list|(
operator|&
name|main_subfile
argument_list|,
name|offset
argument_list|,
literal|0
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
operator|&
name|main_source_baseline
argument_list|)
expr_stmt|;
comment|/* else, there was source with line numbers in include files */
else|else
block|{
name|main_source_baseline
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|ii
operator|=
literal|0
init|;
name|ii
operator|<
name|inclIndx
condition|;
operator|++
name|ii
control|)
block|{
name|struct
name|subfile
modifier|*
name|tmpSubfile
decl_stmt|;
comment|/* if there is main file source before include file, enter it. */
if|if
condition|(
name|offset
operator|<
name|inclTable
index|[
name|ii
index|]
operator|.
name|begin
condition|)
block|{
name|enter_line_range
argument_list|(
operator|&
name|main_subfile
argument_list|,
name|offset
argument_list|,
name|inclTable
index|[
name|ii
index|]
operator|.
name|begin
operator|-
name|LINESZ
argument_list|,
name|start
argument_list|,
literal|0
argument_list|,
operator|&
name|main_source_baseline
argument_list|)
expr_stmt|;
block|}
comment|/* Have a new subfile for the include file */
name|tmpSubfile
operator|=
name|inclTable
index|[
name|ii
index|]
operator|.
name|subfile
operator|=
operator|(
expr|struct
name|subfile
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|subfile
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|tmpSubfile
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|subfile
argument_list|)
argument_list|)
expr_stmt|;
name|firstLine
operator|=
operator|&
operator|(
name|inclTable
index|[
name|ii
index|]
operator|.
name|funStartLine
operator|)
expr_stmt|;
comment|/* enter include file's lines now. */
name|enter_line_range
argument_list|(
name|tmpSubfile
argument_list|,
name|inclTable
index|[
name|ii
index|]
operator|.
name|begin
argument_list|,
name|inclTable
index|[
name|ii
index|]
operator|.
name|end
argument_list|,
name|start
argument_list|,
literal|0
argument_list|,
name|firstLine
argument_list|)
expr_stmt|;
name|offset
operator|=
name|inclTable
index|[
name|ii
index|]
operator|.
name|end
operator|+
name|LINESZ
expr_stmt|;
block|}
comment|/* all the include files' line have been processed at this point. Now,        enter remaining lines of the main file, if any left. */
if|if
condition|(
name|offset
operator|<
operator|(
name|linetab_offset
operator|+
name|linetab_size
operator|+
literal|1
operator|-
name|LINESZ
operator|)
condition|)
block|{
name|enter_line_range
argument_list|(
operator|&
name|main_subfile
argument_list|,
name|offset
argument_list|,
literal|0
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
operator|&
name|main_source_baseline
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Process main file's line numbers. */
if|if
condition|(
name|main_subfile
operator|.
name|line_vector
condition|)
block|{
name|struct
name|linetable
modifier|*
name|lineTb
decl_stmt|,
modifier|*
name|lv
decl_stmt|;
name|lv
operator|=
name|main_subfile
operator|.
name|line_vector
expr_stmt|;
comment|/* Line numbers are not necessarily ordered. xlc compilation will        put static function to the end. */
name|lineTb
operator|=
name|arrange_linetable
argument_list|(
name|lv
argument_list|)
expr_stmt|;
if|if
condition|(
name|lv
operator|==
name|lineTb
condition|)
block|{
name|current_subfile
operator|->
name|line_vector
operator|=
operator|(
expr|struct
name|linetable
operator|*
operator|)
name|xrealloc
argument_list|(
name|lv
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|linetable
argument_list|)
operator|+
name|lv
operator|->
name|nitems
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|linetable_entry
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|free
argument_list|(
name|lv
argument_list|)
expr_stmt|;
name|current_subfile
operator|->
name|line_vector
operator|=
name|lineTb
expr_stmt|;
block|}
name|current_subfile
operator|->
name|line_vector_length
operator|=
name|current_subfile
operator|->
name|line_vector
operator|->
name|nitems
expr_stmt|;
block|}
comment|/* Now, process included files' line numbers. */
for|for
control|(
name|ii
operator|=
literal|0
init|;
name|ii
operator|<
name|inclIndx
condition|;
operator|++
name|ii
control|)
block|{
if|if
condition|(
operator|(
name|inclTable
index|[
name|ii
index|]
operator|.
name|subfile
operator|)
operator|->
name|line_vector
condition|)
block|{
comment|/* Useless if!!! FIXMEmgo */
name|struct
name|linetable
modifier|*
name|lineTb
decl_stmt|,
modifier|*
name|lv
decl_stmt|;
name|lv
operator|=
operator|(
name|inclTable
index|[
name|ii
index|]
operator|.
name|subfile
operator|)
operator|->
name|line_vector
expr_stmt|;
comment|/* Line numbers are not necessarily ordered. xlc compilation will            put static function to the end. */
name|lineTb
operator|=
name|arrange_linetable
argument_list|(
name|lv
argument_list|)
expr_stmt|;
name|push_subfile
argument_list|()
expr_stmt|;
comment|/* For the same include file, we might want to have more than one subfile. 	   This happens if we have something like:       		...... 	        #include "foo.h" 		...... 	 	#include "foo.h" 		......  	   while foo.h including code in it. (stupid but possible) 	   Since start_subfile() looks at the name and uses an existing one if finds, 	   we need to provide a fake name and fool it. */
comment|/*	start_subfile (inclTable[ii].name, (char*)0);  */
name|start_subfile
argument_list|(
literal|" ?"
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|current_subfile
operator|->
name|name
operator|=
name|obsavestring
argument_list|(
name|inclTable
index|[
name|ii
index|]
operator|.
name|name
argument_list|,
name|strlen
argument_list|(
name|inclTable
index|[
name|ii
index|]
operator|.
name|name
argument_list|)
argument_list|,
operator|&
name|current_objfile
operator|->
name|symbol_obstack
argument_list|)
expr_stmt|;
if|if
condition|(
name|lv
operator|==
name|lineTb
condition|)
block|{
name|current_subfile
operator|->
name|line_vector
operator|=
operator|(
expr|struct
name|linetable
operator|*
operator|)
name|xrealloc
argument_list|(
name|lv
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|linetable
argument_list|)
operator|+
name|lv
operator|->
name|nitems
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|linetable_entry
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|free
argument_list|(
name|lv
argument_list|)
expr_stmt|;
name|current_subfile
operator|->
name|line_vector
operator|=
name|lineTb
expr_stmt|;
block|}
name|current_subfile
operator|->
name|line_vector_length
operator|=
name|current_subfile
operator|->
name|line_vector
operator|->
name|nitems
expr_stmt|;
name|start_subfile
argument_list|(
name|pop_subfile
argument_list|()
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|return_after_cleanup
label|:
comment|/* We don't want to keep alloc/free'ing the global include file table. */
name|inclIndx
operator|=
literal|0
expr_stmt|;
comment|/* start with a fresh subfile structure for the next file. */
name|bzero
argument_list|(
operator|&
name|main_subfile
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|subfile
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|aix_process_linenos
parameter_list|()
block|{
comment|/* process line numbers and enter them into line vector */
name|process_linenos
argument_list|(
name|last_source_start_addr
argument_list|,
name|cur_src_end_addr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Enter a given range of lines into the line vector.    can be called in the following two ways:      enter_line_range (subfile, beginoffset, endoffset, startaddr, 0, firstLine)  or      enter_line_range (subfile, beginoffset, 0, startaddr, endaddr, firstLine) */
end_comment

begin_function
specifier|static
name|void
name|enter_line_range
parameter_list|(
name|subfile
parameter_list|,
name|beginoffset
parameter_list|,
name|endoffset
parameter_list|,
name|startaddr
parameter_list|,
name|endaddr
parameter_list|,
name|firstLine
parameter_list|)
name|struct
name|subfile
modifier|*
name|subfile
decl_stmt|;
name|unsigned
name|beginoffset
decl_stmt|,
name|endoffset
decl_stmt|;
comment|/* offsets to line table */
name|CORE_ADDR
name|startaddr
decl_stmt|,
name|endaddr
decl_stmt|;
name|unsigned
modifier|*
name|firstLine
decl_stmt|;
block|{
name|char
modifier|*
name|pp
decl_stmt|,
modifier|*
name|limit
decl_stmt|;
name|CORE_ADDR
name|addr
decl_stmt|;
comment|/* Do Byte swapping, if needed. FIXME! */
define|#
directive|define
name|P_LINENO
parameter_list|(
name|PP
parameter_list|)
value|(*(unsigned short*)((struct external_lineno*)(PP))->l_lnno)
define|#
directive|define
name|P_LINEADDR
parameter_list|(
name|PP
parameter_list|)
value|(*(long*)((struct external_lineno*)(PP))->l_addr.l_paddr)
define|#
directive|define
name|P_LINESYM
parameter_list|(
name|PP
parameter_list|)
value|(*(long*)((struct external_lineno*)(PP))->l_addr.l_symndx)
name|pp
operator|=
operator|&
name|linetab
index|[
name|beginoffset
operator|-
name|linetab_offset
index|]
expr_stmt|;
name|limit
operator|=
name|endoffset
condition|?
operator|&
name|linetab
index|[
name|endoffset
operator|-
name|linetab_offset
index|]
else|:
operator|&
name|linetab
index|[
name|linetab_size
operator|-
literal|1
index|]
expr_stmt|;
while|while
condition|(
name|pp
operator|<=
name|limit
condition|)
block|{
comment|/* find the address this line represents */
name|addr
operator|=
name|P_LINENO
argument_list|(
name|pp
argument_list|)
condition|?
name|P_LINEADDR
argument_list|(
name|pp
argument_list|)
else|:
name|read_symbol_nvalue
argument_list|(
name|symtbl
argument_list|,
name|P_LINESYM
argument_list|(
name|pp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|<
name|startaddr
operator|||
operator|(
name|endaddr
operator|&&
name|addr
operator|>
name|endaddr
operator|)
condition|)
return|return;
if|if
condition|(
name|P_LINENO
argument_list|(
name|pp
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|firstLine
operator|=
name|read_symbol_lineno
argument_list|(
name|symtbl
argument_list|,
name|P_LINESYM
argument_list|(
name|pp
argument_list|)
argument_list|)
expr_stmt|;
name|record_line
argument_list|(
name|subfile
argument_list|,
literal|0
argument_list|,
name|addr
argument_list|)
expr_stmt|;
operator|--
operator|(
operator|*
name|firstLine
operator|)
expr_stmt|;
block|}
else|else
name|record_line
argument_list|(
name|subfile
argument_list|,
operator|*
name|firstLine
operator|+
name|P_LINENO
argument_list|(
name|pp
argument_list|)
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|pp
operator|+=
name|LINESZ
expr_stmt|;
block|}
block|}
end_function

begin_typedef
typedef|typedef
struct|struct
block|{
name|int
name|fsize
decl_stmt|;
comment|/* file size */
name|int
name|fixedparms
decl_stmt|;
comment|/* number of fixed parms */
name|int
name|floatparms
decl_stmt|;
comment|/* number of float parms */
name|unsigned
name|int
name|parminfo
decl_stmt|;
comment|/* parameter info.    					   See /usr/include/sys/debug.h 					   tbtable_ext.parminfo */
name|int
name|framesize
decl_stmt|;
comment|/* function frame size */
block|}
name|TracebackInfo
typedef|;
end_typedef

begin_comment
comment|/* Given a function symbol, return its traceback information. */
end_comment

begin_function
name|TracebackInfo
modifier|*
name|retrieve_tracebackinfo
parameter_list|(
name|abfd
parameter_list|,
name|textsec
parameter_list|,
name|cs
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|sec_ptr
name|textsec
decl_stmt|;
name|struct
name|coff_symbol
modifier|*
name|cs
decl_stmt|;
block|{
define|#
directive|define
name|TBTABLE_BUFSIZ
value|2000
define|#
directive|define
name|MIN_TBTABSIZ
value|50
comment|/* minimum buffer size to hold a 					   traceback table. */
specifier|static
name|TracebackInfo
name|tbInfo
decl_stmt|;
name|struct
name|tbtable
modifier|*
name|ptb
decl_stmt|;
specifier|static
name|char
name|buffer
index|[
name|TBTABLE_BUFSIZ
index|]
decl_stmt|;
name|int
modifier|*
name|pinsn
decl_stmt|;
name|int
name|bytesread
init|=
literal|0
decl_stmt|;
comment|/* total # of bytes read so far */
name|int
name|bufferbytes
decl_stmt|;
comment|/* number of bytes in the buffer */
name|int
name|functionstart
init|=
name|cs
operator|->
name|c_value
operator|-
name|textsec
operator|->
name|vma
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|tbInfo
argument_list|,
sizeof|sizeof
argument_list|(
name|tbInfo
argument_list|)
argument_list|)
expr_stmt|;
comment|/* keep reading blocks of data from the text section, until finding a zero      word and a traceback table. */
while|while
condition|(
name|bufferbytes
operator|=
operator|(
operator|(
name|TBTABLE_BUFSIZ
operator|<
operator|(
name|textsec
operator|->
name|_raw_size
operator|-
name|functionstart
operator|-
name|bytesread
operator|)
operator|)
condition|?
name|TBTABLE_BUFSIZ
else|:
operator|(
name|textsec
operator|->
name|_raw_size
operator|-
name|functionstart
operator|-
name|bytesread
operator|)
operator|)
operator|&&
name|bfd_get_section_contents
argument_list|(
name|abfd
argument_list|,
name|textsec
argument_list|,
name|buffer
argument_list|,
call|(
name|file_ptr
call|)
argument_list|(
name|functionstart
operator|+
name|bytesread
argument_list|)
argument_list|,
name|bufferbytes
argument_list|)
condition|)
block|{
name|bytesread
operator|+=
name|bufferbytes
expr_stmt|;
name|pinsn
operator|=
operator|(
name|int
operator|*
operator|)
name|buffer
expr_stmt|;
comment|/* if this is the first time we filled the buffer, retrieve function        framesize info. */
if|if
condition|(
name|bytesread
operator|==
name|bufferbytes
condition|)
block|{
comment|/* skip over unrelated instructions */
if|if
condition|(
operator|*
name|pinsn
operator|==
literal|0x7c0802a6
condition|)
comment|/* mflr r0 */
operator|++
name|pinsn
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|pinsn
operator|&
literal|0xfc00003e
operator|)
operator|==
literal|0x7c000026
condition|)
comment|/* mfcr Rx */
operator|++
name|pinsn
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|pinsn
operator|&
literal|0xfc000000
operator|)
operator|==
literal|0x48000000
condition|)
comment|/* bl foo, save fprs */
operator|++
name|pinsn
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|pinsn
operator|&
literal|0xfc1f0000
operator|)
operator|==
literal|0xbc010000
condition|)
comment|/* stm Rx, NUM(r1) */
operator|++
name|pinsn
expr_stmt|;
do|do
block|{
name|int
name|tmp
init|=
operator|(
operator|*
name|pinsn
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
decl_stmt|;
if|if
condition|(
name|tmp
operator|==
literal|0x9421
condition|)
block|{
comment|/* stu  r1, NUM(r1) */
name|tbInfo
operator|.
name|framesize
operator|=
literal|0x10000
operator|-
operator|(
operator|*
name|pinsn
operator|&
literal|0xffff
operator|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|pinsn
operator|==
literal|0x93e1fffc
operator|)
operator|||
comment|/* st   r31,-4(r1) */
operator|(
name|tmp
operator|==
literal|0x9001
operator|)
condition|)
comment|/* st   r0, NUM(r1) */
empty_stmt|;
comment|/* else, could not find a frame size. */
else|else
return|return
name|NULL
return|;
block|}
do|while
condition|(
operator|++
name|pinsn
operator|&&
operator|*
name|pinsn
condition|)
do|;
if|if
condition|(
operator|!
name|tbInfo
operator|.
name|framesize
condition|)
return|return
name|NULL
return|;
block|}
comment|/* look for a zero word. */
while|while
condition|(
operator|*
name|pinsn
operator|&&
operator|(
name|pinsn
operator|<
operator|(
name|int
operator|*
operator|)
operator|(
name|buffer
operator|+
name|bufferbytes
operator|-
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|)
operator|)
condition|)
operator|++
name|pinsn
expr_stmt|;
if|if
condition|(
name|pinsn
operator|>=
operator|(
name|int
operator|*
operator|)
operator|(
name|buffer
operator|+
name|bufferbytes
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|*
name|pinsn
operator|==
literal|0
condition|)
block|{
comment|/* function size is the amount of bytes we have skipped so far. */
name|tbInfo
operator|.
name|fsize
operator|=
name|bytesread
operator|-
operator|(
name|buffer
operator|+
name|bufferbytes
operator|-
operator|(
name|char
operator|*
operator|)
name|pinsn
operator|)
expr_stmt|;
operator|++
name|pinsn
expr_stmt|;
comment|/* if we don't have the whole traceback table in the buffer, re-read          the whole thing. */
if|if
condition|(
operator|(
name|char
operator|*
operator|)
name|pinsn
operator|>
operator|(
name|buffer
operator|+
name|bufferbytes
operator|-
name|MIN_TBTABSIZ
operator|)
condition|)
block|{
comment|/* In case if we are *very* close to the end of the text section 	   and cannot read properly from that point on, abort by returning 	   NULL. 	   Handle this case more graciously -- FIXME */
if|if
condition|(
operator|!
name|bfd_get_section_contents
argument_list|(
name|abfd
argument_list|,
name|textsec
argument_list|,
name|buffer
argument_list|,
call|(
name|file_ptr
call|)
argument_list|(
name|functionstart
operator|+
name|bytesread
operator|-
operator|(
name|buffer
operator|+
name|bufferbytes
operator|-
operator|(
name|char
operator|*
operator|)
name|pinsn
operator|)
argument_list|)
argument_list|,
name|MIN_TBTABSIZ
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"Abnormal return!..\n"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|ptb
operator|=
operator|(
expr|struct
name|tbtable
operator|*
operator|)
name|buffer
expr_stmt|;
block|}
else|else
name|ptb
operator|=
operator|(
expr|struct
name|tbtable
operator|*
operator|)
name|pinsn
expr_stmt|;
name|tbInfo
operator|.
name|fixedparms
operator|=
name|ptb
operator|->
name|tb
operator|.
name|fixedparms
expr_stmt|;
name|tbInfo
operator|.
name|floatparms
operator|=
name|ptb
operator|->
name|tb
operator|.
name|floatparms
expr_stmt|;
name|tbInfo
operator|.
name|parminfo
operator|=
name|ptb
operator|->
name|tb_ext
operator|.
name|parminfo
expr_stmt|;
return|return
operator|&
name|tbInfo
return|;
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Given a function symbol, return a pointer to its traceback table. */
end_comment

begin_comment
unit|struct tbtable * retrieve_traceback (abfd, textsec, cs, size)   bfd *abfd;   sec_ptr textsec;   struct coff_symbol *cs;   int *size;
comment|/* return function size */
end_comment

begin_define
unit|{
define|#
directive|define
name|TBTABLE_BUFSIZ
value|2000
end_define

begin_define
define|#
directive|define
name|MIN_TBTABSIZ
value|50
end_define

begin_comment
comment|/* minimum buffer size to hold a 					   traceback table. */
end_comment

begin_comment
unit|static char buffer [TBTABLE_BUFSIZ];    int  *pinsn;   int  bytesread=0;
comment|/* total # of bytes read so far */
end_comment

begin_comment
unit|int  bufferbytes;
comment|/* number of bytes in the buffer */
end_comment

begin_comment
unit|int functionstart = cs->c_value - textsec->filepos + textsec->vma;   *size = 0;
comment|/* keep reading blocks of data from the text section, until finding a zero      word and a traceback table. */
end_comment

begin_comment
unit|while (bfd_get_section_contents (abfd, textsec, buffer,  	(file_ptr)(functionstart + bytesread),  	bufferbytes = ( 		(TBTABLE_BUFSIZ< (textsec->size - functionstart - bytesread)) ?  		 TBTABLE_BUFSIZ : (textsec->size - functionstart - bytesread))))   {     bytesread += bufferbytes;     pinsn = (int*) buffer;
comment|/* look for a zero word. */
end_comment

begin_comment
unit|while (*pinsn&& (pinsn< (int*)(buffer + bufferbytes - sizeof(int))))       ++pinsn;      if (pinsn>= (int*)(buffer + bufferbytes))       continue;      if (*pinsn == 0) {
comment|/* function size is the amount of bytes we have skipped so far. */
end_comment

begin_comment
unit|*size = bytesread - (buffer + bufferbytes - pinsn);        ++pinsn;
comment|/* if we don't have the whole traceback table in the buffer, re-read          the whole thing. */
end_comment

begin_comment
unit|if ((char*)pinsn> (buffer + bufferbytes - MIN_TBTABSIZ)) {
comment|/* In case if we are *very* close to the end of the text section 	   and cannot read properly from that point on, abort for now. 	   Handle this case more graciously -- FIXME */
end_comment

begin_comment
unit|if (!bfd_get_section_contents ( 		abfd, textsec, buffer,  		(file_ptr)(functionstart +  		 bytesread - (buffer + bufferbytes - pinsn)),MIN_TBTABSIZ))
comment|/*   abort (); */
end_comment

begin_endif
unit|{ printf ("abort!!!\n"); return NULL; }  	return (struct tbtable *)buffer;       }       else         return (struct tbtable *)pinsn;     }   }   return NULL; }
endif|#
directive|endif
end_endif

begin_comment
comment|/* 0 */
end_comment

begin_comment
comment|/* Save the vital information for use when closing off the current file.    NAME is the file name the symbols came from, START_ADDR is the first    text address for the file, and SIZE is the number of bytes of text.  */
end_comment

begin_define
define|#
directive|define
name|complete_symtab
parameter_list|(
name|name
parameter_list|,
name|start_addr
parameter_list|)
value|{	\   last_source_file = savestring (name, strlen (name));	\   last_source_start_addr = start_addr;			\ }
end_define

begin_comment
comment|/* Refill the symbol table input buffer    and set the variables that control fetching entries from it.    Reports an error if no data available.    This function can read past the end of the symbol table    (into the string table) but this does no harm.  */
end_comment

begin_comment
comment|/* Reading symbol table has to be fast! Keep the followings as macros, rather    than functions. */
end_comment

begin_define
define|#
directive|define
name|RECORD_MINIMAL_SYMBOL
parameter_list|(
name|NAME
parameter_list|,
name|ADDR
parameter_list|,
name|TYPE
parameter_list|,
name|ALLOCED
parameter_list|)
define|\
value|{						\   char *namestr;				\   if (ALLOCED) 					\     namestr = (NAME) + 1;			\   else {					\     (NAME) = namestr = 				\     obstack_copy0 (&objfile->symbol_obstack, (NAME) + 1, strlen ((NAME)+1)); \     (ALLOCED) = 1;						\   }								\   prim_record_minimal_symbol (namestr, (ADDR), (TYPE));		\   misc_func_recorded = 1;					\ }
end_define

begin_comment
comment|/* A parameter template, used by ADD_PARM_TO_PENDING. */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|symbol
name|parmsym
init|=
block|{
comment|/* default parameter symbol */
literal|""
block|,
comment|/* name */
name|VAR_NAMESPACE
block|,
comment|/* namespace */
name|LOC_ARG
block|,
comment|/* class */
name|NULL
block|,
comment|/* type */
literal|0
block|,
comment|/* line number */
literal|0
block|,
comment|/* value */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Add a parameter to a given pending symbol list. */
end_comment

begin_define
define|#
directive|define
name|ADD_PARM_TO_PENDING
parameter_list|(
name|PARM
parameter_list|,
name|VALUE
parameter_list|,
name|PTYPE
parameter_list|,
name|PENDING_SYMBOLS
parameter_list|)
define|\
value|{									\   PARM = (struct symbol *)						\       obstack_alloc (&objfile->symbol_obstack, sizeof (struct symbol));	\   *(PARM) = parmsym;							\   SYMBOL_TYPE (PARM) = PTYPE;						\   SYMBOL_VALUE (PARM) = VALUE;						\   add_symbol_to_list (PARM,&PENDING_SYMBOLS);				\ }
end_define

begin_comment
comment|/* xcoff has static blocks marked in `.bs', `.es' pairs. They cannot be    nested. At any given time, a symbol can only be in one static block.    This is the base address of current static block, zero if non exists. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|static_block_base
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* true if space for symbol name has been allocated. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|symname_alloced
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* read the whole symbol table of a given bfd. */
end_comment

begin_function
specifier|static
name|void
name|read_xcoff_symtab
parameter_list|(
name|objfile
parameter_list|,
name|nsyms
parameter_list|)
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
comment|/* Object file we're reading from */
name|int
name|nsyms
decl_stmt|;
comment|/* # of symbols */
block|{
name|bfd
modifier|*
name|abfd
init|=
name|objfile
operator|->
name|obfd
decl_stmt|;
name|char
modifier|*
name|raw_symbol
decl_stmt|;
comment|/* Pointer into raw seething symbol table */
name|char
modifier|*
name|raw_auxptr
decl_stmt|;
comment|/* Pointer to first raw aux entry for sym */
name|sec_ptr
name|textsec
decl_stmt|;
comment|/* Pointer to text section */
name|TracebackInfo
modifier|*
name|ptb
decl_stmt|;
comment|/* Pointer to traceback table */
name|struct
name|internal_syment
name|symbol
index|[
literal|1
index|]
decl_stmt|;
name|union
name|internal_auxent
name|main_aux
index|[
literal|1
index|]
decl_stmt|;
name|struct
name|coff_symbol
name|cs
index|[
literal|1
index|]
decl_stmt|;
name|CORE_ADDR
name|file_start_addr
init|=
literal|0
decl_stmt|;
name|CORE_ADDR
name|file_end_addr
init|=
literal|0
decl_stmt|;
name|int
name|next_file_symnum
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|just_started
init|=
literal|1
decl_stmt|;
name|int
name|depth
init|=
literal|0
decl_stmt|;
name|int
name|toc_offset
init|=
literal|0
decl_stmt|;
comment|/* toc offset value in data section. */
name|int
name|val
decl_stmt|;
name|int
name|fcn_last_line
decl_stmt|;
name|int
name|fcn_start_addr
decl_stmt|;
name|long
name|fcn_line_offset
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|struct
name|coff_symbol
name|fcn_stab_saved
decl_stmt|;
comment|/* fcn_cs_saved is global because process_xcoff_symbol needs it. */
name|union
name|internal_auxent
name|fcn_aux_saved
decl_stmt|;
name|struct
name|type
modifier|*
name|fcn_type_saved
init|=
name|NULL
decl_stmt|;
name|struct
name|context_stack
modifier|*
name|new
decl_stmt|;
name|char
modifier|*
name|filestring
init|=
literal|" _start_ "
decl_stmt|;
comment|/* Name of the current file. */
name|char
modifier|*
name|last_csect_name
decl_stmt|;
comment|/* last seen csect's name and value */
name|CORE_ADDR
name|last_csect_val
decl_stmt|;
name|int
name|misc_func_recorded
decl_stmt|;
comment|/* true if any misc. function */
name|current_objfile
operator|=
name|objfile
expr_stmt|;
comment|/* Get the appropriate COFF "constants" related to the file we're handling. */
name|N_TMASK
operator|=
name|coff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|local_n_tmask
expr_stmt|;
name|N_BTSHFT
operator|=
name|coff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|local_n_btshft
expr_stmt|;
name|local_symesz
operator|=
name|coff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|local_symesz
expr_stmt|;
name|last_source_file
operator|=
name|NULL
expr_stmt|;
name|last_csect_name
operator|=
literal|0
expr_stmt|;
name|last_csect_val
operator|=
literal|0
expr_stmt|;
name|misc_func_recorded
operator|=
literal|0
expr_stmt|;
name|start_stabs
argument_list|()
expr_stmt|;
name|start_symtab
argument_list|(
name|filestring
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|file_start_addr
argument_list|)
expr_stmt|;
name|symnum
operator|=
literal|0
expr_stmt|;
name|first_object_file_end
operator|=
literal|0
expr_stmt|;
comment|/* Allocate space for the entire symbol table at once, and read it      all in.  The bfd is already positioned at the beginning of      the symbol table.  */
name|size
operator|=
name|coff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|local_symesz
operator|*
name|nsyms
expr_stmt|;
name|symtbl
operator|=
name|xmalloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|val
operator|=
name|bfd_read
argument_list|(
name|symtbl
argument_list|,
name|size
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
name|size
condition|)
name|perror_with_name
argument_list|(
literal|"reading symbol table"
argument_list|)
expr_stmt|;
name|raw_symbol
operator|=
name|symtbl
expr_stmt|;
name|textsec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".text"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|textsec
condition|)
block|{
name|printf
argument_list|(
literal|"Unable to locate text section!\n"
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|symnum
operator|<
name|nsyms
condition|)
block|{
name|QUIT
expr_stmt|;
comment|/* make this command interruptable.  */
comment|/* READ_ONE_SYMBOL (symbol, cs, symname_alloced); */
comment|/* read one symbol into `cs' structure. After processing the whole symbol        table, only string table will be kept in memory, symbol table and debug        section of xcoff will be freed. Thus we can mark symbols with names        in string table as `alloced'. */
block|{
name|int
name|ii
decl_stmt|;
comment|/* Swap and align the symbol into a reasonable C structure.  */
name|bfd_coff_swap_sym_in
argument_list|(
name|abfd
argument_list|,
name|raw_symbol
argument_list|,
name|symbol
argument_list|)
expr_stmt|;
name|cs
operator|->
name|c_symnum
operator|=
name|symnum
expr_stmt|;
name|cs
operator|->
name|c_nsyms
operator|=
name|symbol
operator|->
name|n_numaux
expr_stmt|;
if|if
condition|(
name|symbol
operator|->
name|n_zeroes
condition|)
block|{
name|symname_alloced
operator|=
literal|0
expr_stmt|;
comment|/* We must use the original, unswapped, name here so the name field 	   pointed to by cs->c_name will persist throughout xcoffread.  If 	   we use the new field, it gets overwritten for each symbol.  */
name|cs
operator|->
name|c_name
operator|=
operator|(
operator|(
expr|struct
name|external_syment
operator|*
operator|)
name|raw_symbol
operator|)
operator|->
name|e
operator|.
name|e_name
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|symbol
operator|->
name|n_sclass
operator|&
literal|0x80
condition|)
block|{
name|cs
operator|->
name|c_name
operator|=
name|debugsec
operator|+
name|symbol
operator|->
name|n_offset
expr_stmt|;
name|symname_alloced
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* in string table */
name|cs
operator|->
name|c_name
operator|=
name|strtbl
operator|+
operator|(
name|int
operator|)
name|symbol
operator|->
name|n_offset
expr_stmt|;
name|symname_alloced
operator|=
literal|1
expr_stmt|;
block|}
name|cs
operator|->
name|c_value
operator|=
name|symbol
operator|->
name|n_value
expr_stmt|;
comment|/* n_sclass is signed (FIXME), so we had better not mask off any 	 high bits it contains, since the values we will be comparing 	 it to are also signed (FIXME).  Defined in<coff/internal.h>. 	 At this point (3Jun92, gnu@cygnus.com) I think the fix is to 	 make the fields and values unsigned chars, but changing the next 	 line is a simple patch late in the release cycle, for now.  */
name|cs
operator|->
name|c_sclass
operator|=
name|symbol
operator|->
name|n_sclass
comment|/*& 0xff */
expr_stmt|;
name|cs
operator|->
name|c_secnum
operator|=
name|symbol
operator|->
name|n_scnum
expr_stmt|;
name|cs
operator|->
name|c_type
operator|=
operator|(
name|unsigned
operator|)
name|symbol
operator|->
name|n_type
expr_stmt|;
name|raw_symbol
operator|+=
name|coff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|local_symesz
expr_stmt|;
operator|++
name|symnum
expr_stmt|;
name|raw_auxptr
operator|=
name|raw_symbol
expr_stmt|;
comment|/* Save addr of first aux entry */
comment|/* Skip all the auxents associated with this symbol.  */
for|for
control|(
name|ii
operator|=
name|symbol
operator|->
name|n_numaux
init|;
name|ii
condition|;
operator|--
name|ii
control|)
block|{
name|raw_symbol
operator|+=
name|coff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|local_auxesz
expr_stmt|;
operator|++
name|symnum
expr_stmt|;
block|}
block|}
comment|/* if symbol name starts with ".$" or "$", ignore it. */
if|if
condition|(
name|cs
operator|->
name|c_name
index|[
literal|0
index|]
operator|==
literal|'$'
operator|||
operator|(
name|cs
operator|->
name|c_name
index|[
literal|1
index|]
operator|==
literal|'$'
operator|&&
name|cs
operator|->
name|c_name
index|[
literal|0
index|]
operator|==
literal|'.'
operator|)
condition|)
continue|continue;
if|if
condition|(
name|cs
operator|->
name|c_symnum
operator|==
name|next_file_symnum
operator|&&
name|cs
operator|->
name|c_sclass
operator|!=
name|C_FILE
condition|)
block|{
if|if
condition|(
name|last_source_file
condition|)
block|{
name|end_symtab
argument_list|(
name|cur_src_end_addr
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|end_stabs
argument_list|()
expr_stmt|;
block|}
name|start_stabs
argument_list|()
expr_stmt|;
name|start_symtab
argument_list|(
literal|"_globals_"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|CORE_ADDR
operator|)
literal|0
argument_list|)
expr_stmt|;
name|cur_src_end_addr
operator|=
name|first_object_file_end
expr_stmt|;
comment|/* done with all files, everything from here on is globals */
block|}
comment|/* if explicitly specified as a function, treat is as one. */
if|if
condition|(
name|ISFCN
argument_list|(
name|cs
operator|->
name|c_type
argument_list|)
operator|&&
name|cs
operator|->
name|c_sclass
operator|!=
name|C_TPDEF
condition|)
block|{
name|bfd_coff_swap_aux_in
argument_list|(
name|abfd
argument_list|,
name|raw_auxptr
argument_list|,
name|cs
operator|->
name|c_type
argument_list|,
name|cs
operator|->
name|c_sclass
argument_list|,
name|main_aux
argument_list|)
expr_stmt|;
goto|goto
name|function_entry_point
goto|;
block|}
if|if
condition|(
operator|(
name|cs
operator|->
name|c_sclass
operator|==
name|C_EXT
operator|||
name|cs
operator|->
name|c_sclass
operator|==
name|C_HIDEXT
operator|)
operator|&&
name|cs
operator|->
name|c_nsyms
operator|==
literal|1
condition|)
block|{
comment|/* dealing with a symbol with a csect entry. */
define|#
directive|define
name|CSECT
parameter_list|(
name|PP
parameter_list|)
value|((PP)->x_csect)
define|#
directive|define
name|CSECT_LEN
parameter_list|(
name|PP
parameter_list|)
value|(CSECT(PP).x_scnlen)
define|#
directive|define
name|CSECT_ALIGN
parameter_list|(
name|PP
parameter_list|)
value|(SMTYP_ALIGN(CSECT(PP).x_smtyp))
define|#
directive|define
name|CSECT_SMTYP
parameter_list|(
name|PP
parameter_list|)
value|(SMTYP_SMTYP(CSECT(PP).x_smtyp))
define|#
directive|define
name|CSECT_SCLAS
parameter_list|(
name|PP
parameter_list|)
value|(CSECT(PP).x_smclas)
comment|/* Convert the auxent to something we can access.  */
name|bfd_coff_swap_aux_in
argument_list|(
name|abfd
argument_list|,
name|raw_auxptr
argument_list|,
name|cs
operator|->
name|c_type
argument_list|,
name|cs
operator|->
name|c_sclass
argument_list|,
name|main_aux
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|CSECT_SMTYP
argument_list|(
name|main_aux
argument_list|)
condition|)
block|{
case|case
name|XTY_ER
case|:
continue|continue;
comment|/* ignore all external references. */
case|case
name|XTY_SD
case|:
comment|/* a section description. */
block|{
switch|switch
condition|(
name|CSECT_SCLAS
argument_list|(
name|main_aux
argument_list|)
condition|)
block|{
case|case
name|XMC_PR
case|:
comment|/* a `.text' csect.	*/
block|{
comment|/* A program csect is seen. 		  		   We have to allocate one symbol table for each program csect. Normally 		   gdb prefers one symtab for each compilation unit (CU). In case of AIX, one 		   CU might include more than one prog csect, and they don't have to be 		   adjacent in terms of the space they occupy in memory. Thus, one single 		   CU might get fragmented in the memory and gdb's file start and end address 		   approach does not work!  */
if|if
condition|(
name|last_csect_name
condition|)
block|{
comment|/* if no misc. function recorded in the last seen csect, enter 		     it as a function. This will take care of functions like 		     strcmp() compiled by xlc. */
if|if
condition|(
operator|!
name|misc_func_recorded
condition|)
block|{
name|int
name|alloced
init|=
literal|0
decl_stmt|;
name|RECORD_MINIMAL_SYMBOL
argument_list|(
name|last_csect_name
argument_list|,
name|last_csect_val
argument_list|,
name|mst_text
argument_list|,
name|alloced
argument_list|)
expr_stmt|;
block|}
name|complete_symtab
argument_list|(
name|filestring
argument_list|,
name|file_start_addr
argument_list|)
expr_stmt|;
name|cur_src_end_addr
operator|=
name|file_end_addr
expr_stmt|;
name|end_symtab
argument_list|(
name|file_end_addr
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|end_stabs
argument_list|()
expr_stmt|;
name|start_stabs
argument_list|()
expr_stmt|;
name|start_symtab
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|CORE_ADDR
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* If this is the very first csect seen, basically `__start'. */
if|if
condition|(
name|just_started
condition|)
block|{
name|first_object_file_end
operator|=
name|cs
operator|->
name|c_value
operator|+
name|CSECT_LEN
argument_list|(
name|main_aux
argument_list|)
expr_stmt|;
name|just_started
operator|=
literal|0
expr_stmt|;
block|}
name|file_start_addr
operator|=
name|cs
operator|->
name|c_value
expr_stmt|;
name|file_end_addr
operator|=
name|cs
operator|->
name|c_value
operator|+
name|CSECT_LEN
argument_list|(
name|main_aux
argument_list|)
expr_stmt|;
if|if
condition|(
name|cs
operator|->
name|c_name
operator|&&
name|cs
operator|->
name|c_name
index|[
literal|0
index|]
operator|==
literal|'.'
condition|)
block|{
name|last_csect_name
operator|=
name|cs
operator|->
name|c_name
expr_stmt|;
name|last_csect_val
operator|=
name|cs
operator|->
name|c_value
expr_stmt|;
block|}
block|}
name|misc_func_recorded
operator|=
literal|0
expr_stmt|;
continue|continue;
case|case
name|XMC_RW
case|:
break|break;
comment|/* If the section is not a data description, ignore it. Note that 		 uninitialized data will show up as XTY_CM/XMC_RW pair. */
case|case
name|XMC_TC0
case|:
if|if
condition|(
name|toc_offset
condition|)
name|warning
argument_list|(
literal|"More than one xmc_tc0 symbol found."
argument_list|)
expr_stmt|;
name|toc_offset
operator|=
name|cs
operator|->
name|c_value
expr_stmt|;
continue|continue;
case|case
name|XMC_TC
case|:
comment|/* ignore toc entries	*/
default|default	:
comment|/* any other XMC_XXX	*/
continue|continue;
block|}
block|}
break|break;
comment|/* switch CSECT_SCLAS() */
case|case
name|XTY_LD
case|:
comment|/* a function entry point. */
if|if
condition|(
name|CSECT_SCLAS
argument_list|(
name|main_aux
argument_list|)
operator|==
name|XMC_PR
condition|)
block|{
name|function_entry_point
label|:
name|RECORD_MINIMAL_SYMBOL
argument_list|(
name|cs
operator|->
name|c_name
argument_list|,
name|cs
operator|->
name|c_value
argument_list|,
name|mst_text
argument_list|,
name|symname_alloced
argument_list|)
expr_stmt|;
name|fcn_line_offset
operator|=
name|main_aux
operator|->
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_fcn
operator|.
name|x_lnnoptr
expr_stmt|;
name|fcn_start_addr
operator|=
name|cs
operator|->
name|c_value
expr_stmt|;
comment|/* save the function header info, which will be used 	       when `.bf' is seen. */
name|fcn_cs_saved
operator|=
operator|*
name|cs
expr_stmt|;
name|fcn_aux_saved
operator|=
operator|*
name|main_aux
expr_stmt|;
name|ptb
operator|=
name|NULL
expr_stmt|;
comment|/* If function has two auxent, then debugging information is 	       already available for it. Process traceback table for 	       functions with only one auxent. */
if|if
condition|(
name|cs
operator|->
name|c_nsyms
operator|==
literal|1
condition|)
name|ptb
operator|=
name|retrieve_tracebackinfo
argument_list|(
name|abfd
argument_list|,
name|textsec
argument_list|,
name|cs
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|cs
operator|->
name|c_nsyms
operator|!=
literal|2
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* If there is traceback info, create and add parameters for it. */
if|if
condition|(
name|ptb
operator|&&
operator|(
name|ptb
operator|->
name|fixedparms
operator|||
name|ptb
operator|->
name|floatparms
operator|)
condition|)
block|{
name|int
name|parmcnt
init|=
name|ptb
operator|->
name|fixedparms
operator|+
name|ptb
operator|->
name|floatparms
decl_stmt|;
name|char
modifier|*
name|parmcode
init|=
operator|(
name|char
operator|*
operator|)
operator|&
name|ptb
operator|->
name|parminfo
decl_stmt|;
name|int
name|parmvalue
init|=
name|ptb
operator|->
name|framesize
operator|+
literal|0x18
decl_stmt|;
comment|/* sizeof(LINK AREA) == 0x18 */
name|unsigned
name|int
name|ii
decl_stmt|,
name|mask
decl_stmt|;
for|for
control|(
name|ii
operator|=
literal|0
operator|,
name|mask
operator|=
literal|0x80000000
init|;
name|ii
operator|<
name|parmcnt
condition|;
operator|++
name|ii
control|)
block|{
name|struct
name|symbol
modifier|*
name|parm
decl_stmt|;
if|if
condition|(
name|ptb
operator|->
name|parminfo
operator|&
name|mask
condition|)
block|{
comment|/* float or double */
name|mask
operator|=
name|mask
operator|>>
literal|1
expr_stmt|;
if|if
condition|(
name|ptb
operator|->
name|parminfo
operator|&
name|mask
condition|)
block|{
comment|/* double parm */
name|ADD_PARM_TO_PENDING
argument_list|(
name|parm
argument_list|,
name|parmvalue
argument_list|,
name|builtin_type_double
argument_list|,
name|local_symbols
argument_list|)
expr_stmt|;
name|parmvalue
operator|+=
sizeof|sizeof
argument_list|(
name|double
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* float parm */
name|ADD_PARM_TO_PENDING
argument_list|(
name|parm
argument_list|,
name|parmvalue
argument_list|,
name|builtin_type_float
argument_list|,
name|local_symbols
argument_list|)
expr_stmt|;
name|parmvalue
operator|+=
sizeof|sizeof
argument_list|(
name|float
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* fixed parm, use (int*) for hex rep. */
name|ADD_PARM_TO_PENDING
argument_list|(
name|parm
argument_list|,
name|parmvalue
argument_list|,
name|lookup_pointer_type
argument_list|(
name|builtin_type_int
argument_list|)
argument_list|,
name|local_symbols
argument_list|)
expr_stmt|;
name|parmvalue
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
block|}
name|mask
operator|=
name|mask
operator|>>
literal|1
expr_stmt|;
block|}
comment|/* Fake this as a function. Needed in process_xcoff_symbol() */
name|cs
operator|->
name|c_type
operator|=
literal|32
expr_stmt|;
name|finish_block
argument_list|(
name|process_xcoff_symbol
argument_list|(
name|cs
argument_list|,
name|objfile
argument_list|)
argument_list|,
operator|&
name|local_symbols
argument_list|,
name|pending_blocks
argument_list|,
name|cs
operator|->
name|c_value
argument_list|,
name|cs
operator|->
name|c_value
operator|+
name|ptb
operator|->
name|fsize
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
comment|/* shared library function trampoline code entry point. */
elseif|else
if|if
condition|(
name|CSECT_SCLAS
argument_list|(
name|main_aux
argument_list|)
operator|==
name|XMC_GL
condition|)
block|{
comment|/* record trampoline code entries as mst_unknown symbol. When we 	       lookup mst symbols, we will choose mst_text over mst_unknown. */
if|#
directive|if
literal|1
comment|/* After the implementation of incremental loading of shared 	       libraries, we don't want to access trampoline entries. This 	       approach has a consequence of the necessity to bring the whole  	       shared library at first, in order do anything with it (putting 	       breakpoints, using malloc, etc). On the other side, this is 	       consistient with gdb's behaviour on a SUN platform. */
comment|/* Trying to prefer *real* function entry over its trampoline, 	       by assigning `mst_unknown' type to trampoline entries fails. 	       Gdb treats those entries as chars. FIXME. */
comment|/* Recording this entry is necessary. Single stepping relies on 	       this vector to get an idea about function address boundaries. */
name|prim_record_minimal_symbol
argument_list|(
literal|0
argument_list|,
name|cs
operator|->
name|c_value
argument_list|,
name|mst_unknown
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* record trampoline code entries as mst_unknown symbol. When we 	       lookup mst symbols, we will choose mst_text over mst_unknown. */
name|RECORD_MINIMAL_SYMBOL
argument_list|(
name|cs
operator|->
name|c_name
argument_list|,
name|cs
operator|->
name|c_value
argument_list|,
name|mst_unknown
argument_list|,
name|symname_alloced
argument_list|)
expr_stmt|;
endif|#
directive|endif
continue|continue;
block|}
break|break;
default|default :
comment|/* all other XTY_XXXs */
break|break;
block|}
comment|/* switch CSECT_SMTYP() */
block|}
switch|switch
condition|(
name|cs
operator|->
name|c_sclass
condition|)
block|{
case|case
name|C_FILE
case|:
comment|/* see if the last csect needs to be recorded. */
if|if
condition|(
name|last_csect_name
operator|&&
operator|!
name|misc_func_recorded
condition|)
block|{
comment|/* if no misc. function recorded in the last seen csect, enter 	     it as a function. This will take care of functions like 	     strcmp() compiled by xlc. */
name|int
name|alloced
init|=
literal|0
decl_stmt|;
name|RECORD_MINIMAL_SYMBOL
argument_list|(
name|last_csect_name
argument_list|,
name|last_csect_val
argument_list|,
name|mst_text
argument_list|,
name|alloced
argument_list|)
expr_stmt|;
block|}
comment|/* c_value field contains symnum of next .file entry in table 	 or symnum of first global after last .file. */
name|next_file_symnum
operator|=
name|cs
operator|->
name|c_value
expr_stmt|;
comment|/* complete symbol table for last object file containing 	 debugging information. */
comment|/* Whether or not there was a csect in the previous file, we have to call 	 `end_stabs' and `start_stabs' to reset type_vector,  	 line_vector, etc. structures. */
name|complete_symtab
argument_list|(
name|filestring
argument_list|,
name|file_start_addr
argument_list|)
expr_stmt|;
name|cur_src_end_addr
operator|=
name|file_end_addr
expr_stmt|;
name|end_symtab
argument_list|(
name|file_end_addr
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|end_stabs
argument_list|()
expr_stmt|;
name|start_stabs
argument_list|()
expr_stmt|;
name|start_symtab
argument_list|(
name|cs
operator|->
name|c_name
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|CORE_ADDR
operator|)
literal|0
argument_list|)
expr_stmt|;
name|last_csect_name
operator|=
literal|0
expr_stmt|;
comment|/* reset file start and end addresses. A compilation unit with no text          (only data) should have zero file boundaries. */
name|file_start_addr
operator|=
name|file_end_addr
operator|=
literal|0
expr_stmt|;
name|filestring
operator|=
name|cs
operator|->
name|c_name
expr_stmt|;
break|break;
case|case
name|C_FUN
case|:
ifdef|#
directive|ifdef
name|NO_DEFINE_SYMBOL
comment|/* For a function stab, just save its type in `fcn_type_saved', and leave 	 it for the `.bf' processing. */
block|{
name|char
modifier|*
name|pp
init|=
operator|(
name|char
operator|*
operator|)
name|index
argument_list|(
name|cs
operator|->
name|c_name
argument_list|,
literal|':'
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|pp
operator|||
operator|(
operator|*
operator|(
name|pp
operator|+
literal|1
operator|)
operator|!=
literal|'F'
operator|&&
operator|*
operator|(
name|pp
operator|+
literal|1
operator|)
operator|!=
literal|'f'
operator|)
condition|)
name|fatal
argument_list|(
literal|"Unrecognized stab"
argument_list|)
expr_stmt|;
name|pp
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|fcn_type_saved
condition|)
name|fatal
argument_list|(
literal|"Unprocessed function type"
argument_list|)
expr_stmt|;
name|fcn_type_saved
operator|=
name|lookup_function_type
argument_list|(
name|read_type
argument_list|(
operator|&
name|pp
argument_list|,
name|objfile
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|fcn_stab_saved
operator|=
operator|*
name|cs
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|C_FCN
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|cs
operator|->
name|c_name
argument_list|,
literal|".bf"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|bfd_coff_swap_aux_in
argument_list|(
name|abfd
argument_list|,
name|raw_auxptr
argument_list|,
name|cs
operator|->
name|c_type
argument_list|,
name|cs
operator|->
name|c_sclass
argument_list|,
name|main_aux
argument_list|)
expr_stmt|;
name|within_function
operator|=
literal|1
expr_stmt|;
comment|/* Linenos are now processed on a file-by-file, not fn-by-fn, basis. 	   Metin did it, I'm not sure why.  FIXME.  -- gnu@cygnus.com */
comment|/* Two reasons: 	 	    1) xlc (IBM's native c compiler) postpones static function code 	       emission to the end of a compilation unit. This way it can 	       determine if those functions (statics) are needed or not, and 	       can do some garbage collection (I think). This makes line 	       numbers and corresponding addresses unordered, and we end up 	       with a line table like: 	          			lineno	addr 	        foo()	  10	0x100 			  20	0x200 			  30	0x300  		foo3()	  70	0x400 			  80	0x500 			  90	0x600  		static foo2() 			  40	0x700 			  50	0x800 			  60	0x900		  		and that breaks gdb's binary search on line numbers, if the 		above table is not sorted on line numbers. And that sort 		should be on function based, since gcc can emit line numbers 		like: 		 			10	0x100	- for the init/test part of a for stmt. 			20	0x200 			30	0x300 			10	0x400	- for the increment part of a for stmt.   		arrange_linenos() will do this sorting.		   	     2)	aix symbol table might look like: 	 			c_file		// beginning of a new file 			.bi		// beginning of include file 			.ei		// end of include file 			.bi 			.ei  		basically, .bi/.ei pairs do not necessarily encapsulate 		their scope. They need to be recorded, and processed later 		on when we come the end of the compilation unit. 		Include table (inclTable) and process_linenos() handle 		that. 	*/
name|mark_first_line
argument_list|(
name|fcn_line_offset
argument_list|,
name|cs
operator|->
name|c_symnum
argument_list|)
expr_stmt|;
name|new
operator|=
name|push_context
argument_list|(
literal|0
argument_list|,
name|fcn_start_addr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NO_DEFINE_SYMBOL
name|new
operator|->
name|name
operator|=
name|process_xcoff_symbol
argument_list|(
operator|&
name|fcn_cs_saved
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
comment|/* Between a function symbol and `.bf', there always will be a function 	   stab. We save function type when processing that stab. */
if|if
condition|(
name|fcn_type_saved
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"Unknown function type: symbol 0x%x\n"
argument_list|,
name|cs
operator|->
name|c_symnum
argument_list|)
expr_stmt|;
name|SYMBOL_TYPE
argument_list|(
name|new
operator|->
name|name
argument_list|)
operator|=
name|lookup_function_type
argument_list|(
name|builtin_type_int
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SYMBOL_TYPE
argument_list|(
name|new
operator|->
name|name
argument_list|)
operator|=
name|fcn_type_saved
expr_stmt|;
name|fcn_type_saved
operator|=
name|NULL
expr_stmt|;
block|}
else|#
directive|else
name|new
operator|->
name|name
operator|=
name|define_symbol
argument_list|(
name|fcn_cs_saved
operator|.
name|c_value
argument_list|,
name|fcn_stab_saved
operator|.
name|c_name
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|cs
operator|->
name|c_name
argument_list|,
literal|".ef"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|bfd_coff_swap_aux_in
argument_list|(
name|abfd
argument_list|,
name|raw_auxptr
argument_list|,
name|cs
operator|->
name|c_type
argument_list|,
name|cs
operator|->
name|c_sclass
argument_list|,
name|main_aux
argument_list|)
expr_stmt|;
comment|/* the value of .ef is the address of epilogue code; 	   not useful for gdb */
comment|/* { main_aux.x_sym.x_misc.x_lnsz.x_lnno 	   contains number of lines to '}' */
name|fcn_last_line
operator|=
name|main_aux
operator|->
name|x_sym
operator|.
name|x_misc
operator|.
name|x_lnsz
operator|.
name|x_lnno
expr_stmt|;
name|new
operator|=
name|pop_context
argument_list|()
expr_stmt|;
if|if
condition|(
name|context_stack_depth
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|"invalid symbol data; .bf/.ef/.bb/.eb symbol mismatch, at symbol %d."
argument_list|,
name|symnum
argument_list|)
expr_stmt|;
name|finish_block
argument_list|(
name|new
operator|->
name|name
argument_list|,
operator|&
name|local_symbols
argument_list|,
name|new
operator|->
name|old_blocks
argument_list|,
name|new
operator|->
name|start_addr
argument_list|,
name|fcn_cs_saved
operator|.
name|c_value
operator|+
name|fcn_aux_saved
operator|.
name|x_sym
operator|.
name|x_misc
operator|.
name|x_fsize
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|within_function
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
name|C_BSTAT
case|:
comment|/* begin static block	*/
name|static_block_base
operator|=
name|read_symbol_nvalue
argument_list|(
name|symtbl
argument_list|,
name|cs
operator|->
name|c_value
argument_list|)
expr_stmt|;
break|break;
case|case
name|C_ESTAT
case|:
comment|/* end of static block	*/
name|static_block_base
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|C_ARG
case|:
comment|/* These are not implemented. */
case|case
name|C_REGPARM
case|:
case|case
name|C_TPDEF
case|:
case|case
name|C_STRTAG
case|:
case|case
name|C_UNTAG
case|:
case|case
name|C_ENTAG
case|:
name|printf
argument_list|(
literal|"ERROR: Unimplemented storage class: %d.\n"
argument_list|,
name|cs
operator|->
name|c_sclass
argument_list|)
expr_stmt|;
break|break;
case|case
name|C_HIDEXT
case|:
comment|/* ignore these.. */
case|case
name|C_LABEL
case|:
case|case
name|C_NULL
case|:
break|break;
case|case
name|C_BINCL
case|:
comment|/* beginning of include file */
comment|/* In xlc output, C_BINCL/C_EINCL pair doesn't show up in sorted 	   order. Thus, when wee see them, we might not know enough info 	   to process them. Thus, we'll be saving them into a table  	   (inclTable) and postpone their processing. */
name|record_include_begin
argument_list|(
name|cs
argument_list|)
expr_stmt|;
break|break;
case|case
name|C_EINCL
case|:
comment|/* end of include file */
comment|/* see the comment after case C_BINCL. */
name|record_include_end
argument_list|(
name|cs
argument_list|)
expr_stmt|;
break|break;
case|case
name|C_BLOCK
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|cs
operator|->
name|c_name
argument_list|,
literal|".bb"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|depth
operator|++
expr_stmt|;
name|new
operator|=
name|push_context
argument_list|(
name|depth
argument_list|,
name|cs
operator|->
name|c_value
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|cs
operator|->
name|c_name
argument_list|,
literal|".eb"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|new
operator|=
name|pop_context
argument_list|()
expr_stmt|;
if|if
condition|(
name|depth
operator|!=
name|new
operator|->
name|depth
condition|)
name|error
argument_list|(
literal|"Invalid symbol data: .bb/.eb symbol mismatch at symbol %d."
argument_list|,
name|symnum
argument_list|)
expr_stmt|;
name|depth
operator|--
expr_stmt|;
if|if
condition|(
name|local_symbols
operator|&&
name|context_stack_depth
operator|>
literal|0
condition|)
block|{
comment|/* Make a block for the local symbols within.  */
name|finish_block
argument_list|(
name|new
operator|->
name|name
argument_list|,
operator|&
name|local_symbols
argument_list|,
name|new
operator|->
name|old_blocks
argument_list|,
name|new
operator|->
name|start_addr
argument_list|,
name|cs
operator|->
name|c_value
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
name|local_symbols
operator|=
name|new
operator|->
name|locals
expr_stmt|;
block|}
break|break;
default|default		:
name|process_xcoff_symbol
argument_list|(
name|cs
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* while */
if|if
condition|(
name|last_source_file
condition|)
block|{
name|end_symtab
argument_list|(
name|cur_src_end_addr
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|end_stabs
argument_list|()
expr_stmt|;
block|}
name|free
argument_list|(
name|symtbl
argument_list|)
expr_stmt|;
name|current_objfile
operator|=
name|NULL
expr_stmt|;
comment|/* Record the toc offset value of this symbol table into ldinfo structure.      If no XMC_TC0 is found, toc_offset should be zero. Another place to obtain      this information would be file auxiliary header. */
name|xcoff_add_toc_to_loadinfo
argument_list|(
name|toc_offset
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|SYMBOL_DUP
parameter_list|(
name|SYMBOL1
parameter_list|,
name|SYMBOL2
parameter_list|)
define|\
value|(SYMBOL2) = (struct symbol *)		\   	obstack_alloc (&objfile->symbol_obstack, sizeof (struct symbol)); \   *(SYMBOL2) = *(SYMBOL1);
end_define

begin_define
define|#
directive|define
name|SYMNAME_ALLOC
parameter_list|(
name|NAME
parameter_list|,
name|ALLOCED
parameter_list|)
define|\
value|(ALLOCED) ? (NAME) : obstack_copy0 (&objfile->symbol_obstack, (NAME), strlen (NAME));
end_define

begin_comment
comment|/* process one xcoff symbol. */
end_comment

begin_function
specifier|static
name|struct
name|symbol
modifier|*
name|process_xcoff_symbol
parameter_list|(
name|cs
parameter_list|,
name|objfile
parameter_list|)
specifier|register
name|struct
name|coff_symbol
modifier|*
name|cs
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
name|struct
name|symbol
name|onesymbol
decl_stmt|;
specifier|register
name|struct
name|symbol
modifier|*
name|sym
init|=
operator|&
name|onesymbol
decl_stmt|;
name|struct
name|symbol
modifier|*
name|sym2
init|=
name|NULL
decl_stmt|;
name|struct
name|type
modifier|*
name|ttype
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|pp
decl_stmt|,
modifier|*
name|qq
decl_stmt|;
name|int
name|struct_and_type_combined
decl_stmt|;
name|int
name|nameless
decl_stmt|;
name|name
operator|=
name|cs
operator|->
name|c_name
expr_stmt|;
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'.'
condition|)
operator|++
name|name
expr_stmt|;
name|bzero
argument_list|(
name|sym
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
comment|/* default assumptions */
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|=
name|cs
operator|->
name|c_value
expr_stmt|;
name|SYMBOL_NAMESPACE
argument_list|(
name|sym
argument_list|)
operator|=
name|VAR_NAMESPACE
expr_stmt|;
if|if
condition|(
name|ISFCN
argument_list|(
name|cs
operator|->
name|c_type
argument_list|)
condition|)
block|{
comment|/* At this point, we don't know the type of the function and assume it         is int. This will be patched with the type from its stab entry later         on in patch_block_stabs () */
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
operator|=
name|SYMNAME_ALLOC
argument_list|(
name|name
argument_list|,
name|symname_alloced
argument_list|)
expr_stmt|;
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|=
name|lookup_function_type
argument_list|(
name|lookup_fundamental_type
argument_list|(
name|objfile
argument_list|,
name|FT_INTEGER
argument_list|)
argument_list|)
expr_stmt|;
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_BLOCK
expr_stmt|;
name|SYMBOL_DUP
argument_list|(
name|sym
argument_list|,
name|sym2
argument_list|)
expr_stmt|;
if|if
condition|(
name|cs
operator|->
name|c_sclass
operator|==
name|C_EXT
condition|)
name|add_symbol_to_list
argument_list|(
name|sym2
argument_list|,
operator|&
name|global_symbols
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|cs
operator|->
name|c_sclass
operator|==
name|C_HIDEXT
operator|||
name|cs
operator|->
name|c_sclass
operator|==
name|C_STAT
condition|)
name|add_symbol_to_list
argument_list|(
name|sym2
argument_list|,
operator|&
name|file_symbols
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* in case we can't figure out the type, default is `int'. */
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|=
name|lookup_fundamental_type
argument_list|(
name|objfile
argument_list|,
name|FT_INTEGER
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cs
operator|->
name|c_sclass
condition|)
block|{
if|#
directive|if
literal|0
block|case C_FUN:       if (fcn_cs_saved.c_sclass == C_EXT) 	add_stab_to_list (name,&global_stabs);       else 	add_stab_to_list (name,&file_stabs);       break;
endif|#
directive|endif
case|case
name|C_DECL
case|:
comment|/* a type decleration?? */
if|#
directive|if
name|defined
argument_list|(
name|NO_TYPEDEFS
argument_list|)
operator|||
name|defined
argument_list|(
name|NO_DEFINE_SYMBOL
argument_list|)
name|qq
operator|=
operator|(
name|char
operator|*
operator|)
name|strchr
argument_list|(
name|name
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|qq
condition|)
comment|/* skip if there is no ':' */
return|return
name|NULL
return|;
name|nameless
operator|=
operator|(
name|qq
operator|==
name|name
operator|)
expr_stmt|;
name|struct_and_type_combined
operator|=
operator|(
name|qq
index|[
literal|1
index|]
operator|==
literal|'T'
operator|&&
name|qq
index|[
literal|2
index|]
operator|==
literal|'t'
operator|)
expr_stmt|;
name|pp
operator|=
name|qq
operator|+
operator|(
name|struct_and_type_combined
condition|?
literal|3
else|:
literal|2
operator|)
expr_stmt|;
comment|/* To handle GNU C++ typename abbreviation, we need to be able to fill 	   in a type's name as soon as space for that type is allocated. */
if|if
condition|(
name|struct_and_type_combined
operator|&&
name|name
operator|!=
name|qq
condition|)
block|{
name|int
name|typenums
index|[
literal|2
index|]
decl_stmt|;
name|struct
name|type
modifier|*
name|tmp_type
decl_stmt|;
name|char
modifier|*
name|tmp_pp
init|=
name|pp
decl_stmt|;
name|read_type_number
argument_list|(
operator|&
name|tmp_pp
argument_list|,
name|typenums
argument_list|)
expr_stmt|;
name|tmp_type
operator|=
name|dbx_alloc_type
argument_list|(
name|typenums
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp_type
operator|&&
operator|!
name|TYPE_NAME
argument_list|(
name|tmp_type
argument_list|)
operator|&&
operator|!
name|nameless
condition|)
name|TYPE_NAME
argument_list|(
name|tmp_type
argument_list|)
operator|=
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
operator|=
name|obsavestring
argument_list|(
name|name
argument_list|,
name|qq
operator|-
name|name
argument_list|,
operator|&
name|objfile
operator|->
name|symbol_obstack
argument_list|)
expr_stmt|;
block|}
name|ttype
operator|=
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|=
name|read_type
argument_list|(
operator|&
name|pp
argument_list|)
expr_stmt|;
comment|/* if there is no name for this typedef, you don't have to keep its 	   symbol, since nobody could ask for it. Otherwise, build a symbol 	   and add it into symbol_list. */
if|if
condition|(
name|nameless
condition|)
return|return;
ifdef|#
directive|ifdef
name|NO_TYPEDEFS
comment|/* Transarc wants to eliminate type definitions from the symbol table. 	   Limited debugging capabilities, but faster symbol table processing 	   and less memory usage. Note that tag definitions (starting with 	   'T') will remain intact. */
if|if
condition|(
name|qq
index|[
literal|1
index|]
operator|!=
literal|'T'
operator|&&
operator|(
operator|!
name|TYPE_NAME
argument_list|(
name|ttype
argument_list|)
operator|||
operator|*
operator|(
name|TYPE_NAME
argument_list|(
name|ttype
argument_list|)
operator|)
operator|==
literal|'\0'
operator|)
condition|)
block|{
if|if
condition|(
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
condition|)
name|TYPE_NAME
argument_list|(
name|ttype
argument_list|)
operator|=
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
expr_stmt|;
else|else
name|TYPE_NAME
argument_list|(
name|ttype
argument_list|)
operator|=
name|obsavestring
argument_list|(
name|name
argument_list|,
name|qq
operator|-
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* !NO_TYPEDEFS */
comment|/* read_type() will return null if type (or tag) definition was 	   unnnecessarily duplicated. Also, if the symbol doesn't have a name, 	   there is no need to keep it in symbol table. */
comment|/* The above argument no longer valid. read_type() never returns NULL. */
if|if
condition|(
operator|!
name|ttype
condition|)
return|return
name|NULL
return|;
comment|/* if there is no name for this typedef, you don't have to keep its 	   symbol, since nobody could ask for it. Otherwise, build a symbol 	   and add it into symbol_list. */
if|if
condition|(
name|qq
index|[
literal|1
index|]
operator|==
literal|'T'
condition|)
name|SYMBOL_NAMESPACE
argument_list|(
name|sym
argument_list|)
operator|=
name|STRUCT_NAMESPACE
expr_stmt|;
elseif|else
if|if
condition|(
name|qq
index|[
literal|1
index|]
operator|==
literal|'t'
condition|)
name|SYMBOL_NAMESPACE
argument_list|(
name|sym
argument_list|)
operator|=
name|VAR_NAMESPACE
expr_stmt|;
else|else
block|{
name|warning
argument_list|(
literal|"Unrecognized stab string.\n"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_TYPEDEF
expr_stmt|;
if|if
condition|(
operator|!
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
condition|)
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
operator|=
name|obsavestring
argument_list|(
name|name
argument_list|,
name|qq
operator|-
name|name
argument_list|)
expr_stmt|;
name|SYMBOL_DUP
argument_list|(
name|sym
argument_list|,
name|sym2
argument_list|)
expr_stmt|;
name|add_symbol_to_list
argument_list|(
name|sym2
argument_list|,
name|within_function
condition|?
operator|&
name|local_symbols
else|:
operator|&
name|file_symbols
argument_list|)
expr_stmt|;
comment|/* For a combination of struct and type, add one more symbol 	   for the type. */
if|if
condition|(
name|struct_and_type_combined
condition|)
block|{
name|SYMBOL_DUP
argument_list|(
name|sym
argument_list|,
name|sym2
argument_list|)
expr_stmt|;
name|SYMBOL_NAMESPACE
argument_list|(
name|sym2
argument_list|)
operator|=
name|VAR_NAMESPACE
expr_stmt|;
name|add_symbol_to_list
argument_list|(
name|sym2
argument_list|,
name|within_function
condition|?
operator|&
name|local_symbols
else|:
operator|&
name|file_symbols
argument_list|)
expr_stmt|;
block|}
comment|/*  assign a name to the type node. */
if|if
condition|(
operator|!
name|TYPE_NAME
argument_list|(
name|ttype
argument_list|)
operator|||
operator|*
operator|(
name|TYPE_NAME
argument_list|(
name|ttype
argument_list|)
operator|)
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
name|struct_and_type_combined
condition|)
name|TYPE_NAME
argument_list|(
name|ttype
argument_list|)
operator|=
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|qq
index|[
literal|1
index|]
operator|==
literal|'T'
condition|)
comment|/* struct namespace */
name|TYPE_NAME
argument_list|(
name|ttype
argument_list|)
operator|=
name|concat
argument_list|(
name|TYPE_CODE
argument_list|(
name|ttype
argument_list|)
operator|==
name|TYPE_CODE_UNION
condition|?
literal|"union "
else|:
name|TYPE_CODE
argument_list|(
name|ttype
argument_list|)
operator|==
name|TYPE_CODE_STRUCT
condition|?
literal|"struct "
else|:
literal|"enum "
argument_list|,
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
break|break;
else|#
directive|else
comment|/* !NO_DEFINE_SYMBOL */
return|return
name|define_symbol
argument_list|(
name|cs
operator|->
name|c_value
argument_list|,
name|cs
operator|->
name|c_name
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|objfile
argument_list|)
return|;
endif|#
directive|endif
case|case
name|C_GSYM
case|:
name|add_stab_to_list
argument_list|(
name|name
argument_list|,
operator|&
name|global_stabs
argument_list|)
expr_stmt|;
break|break;
case|case
name|C_PSYM
case|:
case|case
name|C_RPSYM
case|:
ifdef|#
directive|ifdef
name|NO_DEFINE_SYMBOL
if|if
condition|(
operator|*
name|name
operator|==
literal|':'
operator|||
operator|(
name|pp
operator|=
operator|(
name|char
operator|*
operator|)
name|strchr
argument_list|(
name|name
argument_list|,
literal|':'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
operator|=
name|obsavestring
argument_list|(
name|name
argument_list|,
name|pp
operator|-
name|name
argument_list|,
operator|&
name|objfile
operator|->
name|symbol_obstack
argument_list|)
expr_stmt|;
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
operator|(
name|cs
operator|->
name|c_sclass
operator|==
name|C_PSYM
operator|)
condition|?
name|LOC_ARG
else|:
name|LOC_REGPARM
expr_stmt|;
name|pp
operator|+=
literal|2
expr_stmt|;
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|=
name|read_type
argument_list|(
operator|&
name|pp
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|SYMBOL_DUP
argument_list|(
name|sym
argument_list|,
name|sym2
argument_list|)
expr_stmt|;
name|add_symbol_to_list
argument_list|(
name|sym2
argument_list|,
operator|&
name|local_symbols
argument_list|)
expr_stmt|;
break|break;
else|#
directive|else
name|sym
operator|=
name|define_symbol
argument_list|(
name|cs
operator|->
name|c_value
argument_list|,
name|cs
operator|->
name|c_name
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
operator|(
name|cs
operator|->
name|c_sclass
operator|==
name|C_PSYM
operator|)
condition|?
name|LOC_ARG
else|:
name|LOC_REGPARM
expr_stmt|;
return|return
name|sym
return|;
endif|#
directive|endif
case|case
name|C_STSYM
case|:
ifdef|#
directive|ifdef
name|NO_DEFINE_SYMBOL
if|if
condition|(
operator|*
name|name
operator|==
literal|':'
operator|||
operator|(
name|pp
operator|=
operator|(
name|char
operator|*
operator|)
name|strchr
argument_list|(
name|name
argument_list|,
literal|':'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
operator|=
name|obsavestring
argument_list|(
name|name
argument_list|,
name|pp
operator|-
name|name
argument_list|,
operator|&
name|objfile
operator|->
name|symbol_obstack
argument_list|)
expr_stmt|;
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_STATIC
expr_stmt|;
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|+=
name|static_block_base
expr_stmt|;
name|pp
operator|+=
literal|2
expr_stmt|;
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|=
name|read_type
argument_list|(
operator|&
name|pp
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|SYMBOL_DUP
argument_list|(
name|sym
argument_list|,
name|sym2
argument_list|)
expr_stmt|;
name|add_symbol_to_list
argument_list|(
name|sym2
argument_list|,
name|within_function
condition|?
operator|&
name|local_symbols
else|:
operator|&
name|file_symbols
argument_list|)
expr_stmt|;
break|break;
else|#
directive|else
comment|/* If we are going to use Sun dbx's define_symbol(), we need to 	   massage our stab string a little. Change 'V' type to 'S' to be 	   comparible with Sun. */
if|if
condition|(
operator|*
name|name
operator|==
literal|':'
operator|||
operator|(
name|pp
operator|=
operator|(
name|char
operator|*
operator|)
name|index
argument_list|(
name|name
argument_list|,
literal|':'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
operator|++
name|pp
expr_stmt|;
if|if
condition|(
operator|*
name|pp
operator|==
literal|'V'
condition|)
operator|*
name|pp
operator|=
literal|'S'
expr_stmt|;
name|sym
operator|=
name|define_symbol
argument_list|(
name|cs
operator|->
name|c_value
argument_list|,
name|cs
operator|->
name|c_name
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|+=
name|static_block_base
expr_stmt|;
return|return
name|sym
return|;
endif|#
directive|endif
case|case
name|C_LSYM
case|:
if|if
condition|(
operator|*
name|name
operator|==
literal|':'
operator|||
operator|(
name|pp
operator|=
operator|(
name|char
operator|*
operator|)
name|strchr
argument_list|(
name|name
argument_list|,
literal|':'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
operator|=
name|obsavestring
argument_list|(
name|name
argument_list|,
name|pp
operator|-
name|name
argument_list|,
operator|&
name|objfile
operator|->
name|symbol_obstack
argument_list|)
expr_stmt|;
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_LOCAL
expr_stmt|;
name|pp
operator|+=
literal|1
expr_stmt|;
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|=
name|read_type
argument_list|(
operator|&
name|pp
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|SYMBOL_DUP
argument_list|(
name|sym
argument_list|,
name|sym2
argument_list|)
expr_stmt|;
name|add_symbol_to_list
argument_list|(
name|sym2
argument_list|,
operator|&
name|local_symbols
argument_list|)
expr_stmt|;
break|break;
case|case
name|C_AUTO
case|:
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_LOCAL
expr_stmt|;
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
operator|=
name|SYMNAME_ALLOC
argument_list|(
name|name
argument_list|,
name|symname_alloced
argument_list|)
expr_stmt|;
name|SYMBOL_DUP
argument_list|(
name|sym
argument_list|,
name|sym2
argument_list|)
expr_stmt|;
name|add_symbol_to_list
argument_list|(
name|sym2
argument_list|,
operator|&
name|local_symbols
argument_list|)
expr_stmt|;
break|break;
case|case
name|C_EXT
case|:
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_STATIC
expr_stmt|;
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
operator|=
name|SYMNAME_ALLOC
argument_list|(
name|name
argument_list|,
name|symname_alloced
argument_list|)
expr_stmt|;
name|SYMBOL_DUP
argument_list|(
name|sym
argument_list|,
name|sym2
argument_list|)
expr_stmt|;
name|add_symbol_to_list
argument_list|(
name|sym2
argument_list|,
operator|&
name|global_symbols
argument_list|)
expr_stmt|;
break|break;
case|case
name|C_STAT
case|:
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_STATIC
expr_stmt|;
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
operator|=
name|SYMNAME_ALLOC
argument_list|(
name|name
argument_list|,
name|symname_alloced
argument_list|)
expr_stmt|;
name|SYMBOL_DUP
argument_list|(
name|sym
argument_list|,
name|sym2
argument_list|)
expr_stmt|;
name|add_symbol_to_list
argument_list|(
name|sym2
argument_list|,
name|within_function
condition|?
operator|&
name|local_symbols
else|:
operator|&
name|file_symbols
argument_list|)
expr_stmt|;
break|break;
case|case
name|C_REG
case|:
name|printf
argument_list|(
literal|"ERROR! C_REG is not fully implemented!\n"
argument_list|)
expr_stmt|;
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_REGISTER
expr_stmt|;
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
operator|=
name|SYMNAME_ALLOC
argument_list|(
name|name
argument_list|,
name|symname_alloced
argument_list|)
expr_stmt|;
name|SYMBOL_DUP
argument_list|(
name|sym
argument_list|,
name|sym2
argument_list|)
expr_stmt|;
name|add_symbol_to_list
argument_list|(
name|sym2
argument_list|,
operator|&
name|local_symbols
argument_list|)
expr_stmt|;
break|break;
case|case
name|C_RSYM
case|:
ifdef|#
directive|ifdef
name|NO_DEFINE_SYMBOL
name|pp
operator|=
operator|(
name|char
operator|*
operator|)
name|strchr
argument_list|(
name|name
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_REGISTER
expr_stmt|;
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|=
name|STAB_REG_TO_REGNUM
argument_list|(
name|cs
operator|->
name|c_value
argument_list|)
expr_stmt|;
if|if
condition|(
name|pp
condition|)
block|{
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
operator|=
name|obsavestring
argument_list|(
name|name
argument_list|,
name|pp
operator|-
name|name
argument_list|,
operator|&
name|objfile
operator|->
name|symbol_obstack
argument_list|)
expr_stmt|;
name|pp
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
operator|*
name|pp
condition|)
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|=
name|read_type
argument_list|(
operator|&
name|pp
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* else this is not a stab entry, suppose the type is either 	     `int' or `float', depending on the register class. */
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|=
operator|(
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|<
literal|32
operator|)
condition|?
name|lookup_fundamental_type
argument_list|(
name|objfile
argument_list|,
name|FT_INTEGER
argument_list|)
else|:
name|lookup_fundamental_type
argument_list|(
name|objfile
argument_list|,
name|FT_FLOAT
argument_list|)
expr_stmt|;
name|SYMBOL_DUP
argument_list|(
name|sym
argument_list|,
name|sym2
argument_list|)
expr_stmt|;
name|add_symbol_to_list
argument_list|(
name|sym2
argument_list|,
operator|&
name|local_symbols
argument_list|)
expr_stmt|;
break|break;
else|#
directive|else
if|if
condition|(
name|pp
condition|)
block|{
name|sym
operator|=
name|define_symbol
argument_list|(
name|cs
operator|->
name|c_value
argument_list|,
name|cs
operator|->
name|c_name
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
return|return
name|sym
return|;
block|}
else|else
block|{
name|warning
argument_list|(
literal|"A non-stab C_RSYM needs special handling."
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
endif|#
directive|endif
default|default	:
name|warning
argument_list|(
literal|"Unexpected storage class: %d."
argument_list|,
name|cs
operator|->
name|c_sclass
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
return|return
name|sym2
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|read_symbol_nvalue
parameter_list|(
name|symtable
parameter_list|,
name|symno
parameter_list|)
name|char
modifier|*
name|symtable
decl_stmt|;
name|int
name|symno
decl_stmt|;
block|{
name|struct
name|internal_syment
name|symbol
index|[
literal|1
index|]
decl_stmt|;
name|bfd_coff_swap_sym_in
argument_list|(
name|symfile_bfd
argument_list|,
name|symtable
operator|+
operator|(
name|symno
operator|*
name|local_symesz
operator|)
argument_list|,
name|symbol
argument_list|)
expr_stmt|;
return|return
name|symbol
operator|->
name|n_value
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|read_symbol_lineno
parameter_list|(
name|symtable
parameter_list|,
name|symno
parameter_list|)
name|char
modifier|*
name|symtable
decl_stmt|;
name|int
name|symno
decl_stmt|;
block|{
name|struct
name|internal_syment
name|symbol
index|[
literal|1
index|]
decl_stmt|;
name|union
name|internal_auxent
name|main_aux
index|[
literal|1
index|]
decl_stmt|;
name|int
name|ii
decl_stmt|;
for|for
control|(
name|ii
operator|=
literal|0
init|;
name|ii
operator|<
literal|50
condition|;
name|ii
operator|++
control|)
block|{
name|bfd_coff_swap_sym_in
argument_list|(
name|symfile_bfd
argument_list|,
name|symtable
operator|+
operator|(
name|symno
operator|*
name|local_symesz
operator|)
argument_list|,
name|symbol
argument_list|)
expr_stmt|;
if|if
condition|(
name|symbol
operator|->
name|n_sclass
operator|==
name|C_FCN
operator|&&
literal|0
operator|==
name|strcmp
argument_list|(
name|symbol
operator|->
name|n_name
argument_list|,
literal|".bf"
argument_list|)
condition|)
goto|goto
name|gotit
goto|;
name|symno
operator|+=
name|symbol
operator|->
name|n_numaux
operator|+
literal|1
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"GDB Error: `.bf' not found.\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|gotit
label|:
comment|/* take aux entry and return its lineno */
name|symno
operator|++
expr_stmt|;
name|bfd_coff_swap_aux_in
argument_list|(
name|symfile_bfd
argument_list|,
name|symtable
operator|+
operator|(
name|symno
operator|*
name|local_symesz
operator|)
argument_list|,
name|symbol
operator|->
name|n_type
argument_list|,
name|symbol
operator|->
name|n_sclass
argument_list|,
name|main_aux
argument_list|)
expr_stmt|;
return|return
name|main_aux
operator|->
name|x_sym
operator|.
name|x_misc
operator|.
name|x_lnsz
operator|.
name|x_lnno
return|;
block|}
end_function

begin_comment
comment|/* Support for line number handling */
end_comment

begin_comment
comment|/* This function is called for every section; it finds the outer limits  * of the line table (minimum and maximum file offset) so that the  * mainline code can read the whole thing for efficiency.  */
end_comment

begin_function
specifier|static
name|void
name|find_linenos
parameter_list|(
name|abfd
parameter_list|,
name|asect
parameter_list|,
name|vpinfo
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|sec_ptr
name|asect
decl_stmt|;
name|PTR
name|vpinfo
decl_stmt|;
block|{
name|struct
name|coff_symfile_info
modifier|*
name|info
decl_stmt|;
name|int
name|size
decl_stmt|,
name|count
decl_stmt|;
name|file_ptr
name|offset
decl_stmt|,
name|maxoff
decl_stmt|;
name|count
operator|=
name|asect
operator|->
name|lineno_count
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|asect
operator|->
name|name
argument_list|,
literal|".text"
argument_list|)
operator|||
name|count
operator|==
literal|0
condition|)
return|return;
name|size
operator|=
name|count
operator|*
name|coff_data
argument_list|(
name|symfile_bfd
argument_list|)
operator|->
name|local_linesz
expr_stmt|;
name|info
operator|=
operator|(
expr|struct
name|coff_symfile_info
operator|*
operator|)
name|vpinfo
expr_stmt|;
name|offset
operator|=
name|asect
operator|->
name|line_filepos
expr_stmt|;
name|maxoff
operator|=
name|offset
operator|+
name|size
expr_stmt|;
if|if
condition|(
name|offset
operator|<
name|info
operator|->
name|min_lineno_offset
operator|||
name|info
operator|->
name|min_lineno_offset
operator|==
literal|0
condition|)
name|info
operator|->
name|min_lineno_offset
operator|=
name|offset
expr_stmt|;
if|if
condition|(
name|maxoff
operator|>
name|info
operator|->
name|max_lineno_offset
condition|)
name|info
operator|->
name|max_lineno_offset
operator|=
name|maxoff
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Read in all the line numbers for fast lookups later.  Leave them in    external (unswapped) format in memory; we'll swap them as we enter    them into GDB's data structures.  */
end_comment

begin_function
specifier|static
name|int
name|init_lineno
parameter_list|(
name|abfd
parameter_list|,
name|offset
parameter_list|,
name|size
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|file_ptr
name|offset
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
name|int
name|val
decl_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|offset
argument_list|,
name|L_SET
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|linetab
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|val
operator|=
name|bfd_read
argument_list|(
name|linetab
argument_list|,
literal|1
argument_list|,
name|size
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
name|size
condition|)
return|return
operator|-
literal|1
return|;
name|linetab_offset
operator|=
name|offset
expr_stmt|;
name|linetab_size
operator|=
name|size
expr_stmt|;
name|make_cleanup
argument_list|(
name|free
argument_list|,
name|linetab
argument_list|)
expr_stmt|;
comment|/* Be sure it gets de-allocated. */
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* dbx allows the text of a symbol name to be continued into the    next symbol name!  When such a continuation is encountered    (a \ at the end of the text of a name)    call this function to get the continuation.  */
end_comment

begin_comment
comment|/* So far, I haven't seen this happenning xlc output. I doubt we'll need this    for xcoff. */
end_comment

begin_undef
undef|#
directive|undef
name|next_symbol_text
end_undef

begin_define
define|#
directive|define
name|next_symbol_text
parameter_list|()
define|\
value|printf ("Gdb Error: symbol names on multiple lines not implemented.\n")
end_define

begin_comment
comment|/* xlc/dbx combination uses a set of builtin types, starting from -1. return    the proper type node fora given builtin type #. */
end_comment

begin_function
name|struct
name|type
modifier|*
name|builtin_type
parameter_list|(
name|pp
parameter_list|)
name|char
modifier|*
modifier|*
name|pp
decl_stmt|;
block|{
name|int
name|typenums
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
operator|*
operator|*
name|pp
operator|!=
literal|'-'
condition|)
block|{
name|printf
argument_list|(
literal|"ERROR!, unknown built-in type!\n"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
operator|*
name|pp
operator|+=
literal|1
expr_stmt|;
name|read_type_number
argument_list|(
name|pp
argument_list|,
name|typenums
argument_list|)
expr_stmt|;
comment|/* default types are defined in dbxstclass.h. */
switch|switch
condition|(
name|typenums
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|1
case|:
return|return
name|lookup_fundamental_type
argument_list|(
name|current_objfile
argument_list|,
name|FT_INTEGER
argument_list|)
return|;
case|case
literal|2
case|:
return|return
name|lookup_fundamental_type
argument_list|(
name|current_objfile
argument_list|,
name|FT_CHAR
argument_list|)
return|;
case|case
literal|3
case|:
return|return
name|lookup_fundamental_type
argument_list|(
name|current_objfile
argument_list|,
name|FT_SHORT
argument_list|)
return|;
case|case
literal|4
case|:
return|return
name|lookup_fundamental_type
argument_list|(
name|current_objfile
argument_list|,
name|FT_LONG
argument_list|)
return|;
case|case
literal|5
case|:
return|return
name|lookup_fundamental_type
argument_list|(
name|current_objfile
argument_list|,
name|FT_UNSIGNED_CHAR
argument_list|)
return|;
case|case
literal|6
case|:
return|return
name|lookup_fundamental_type
argument_list|(
name|current_objfile
argument_list|,
name|FT_SIGNED_CHAR
argument_list|)
return|;
case|case
literal|7
case|:
return|return
name|lookup_fundamental_type
argument_list|(
name|current_objfile
argument_list|,
name|FT_UNSIGNED_SHORT
argument_list|)
return|;
case|case
literal|8
case|:
return|return
name|lookup_fundamental_type
argument_list|(
name|current_objfile
argument_list|,
name|FT_UNSIGNED_INTEGER
argument_list|)
return|;
case|case
literal|9
case|:
return|return
name|lookup_fundamental_type
argument_list|(
name|current_objfile
argument_list|,
name|FT_UNSIGNED_INTEGER
argument_list|)
return|;
case|case
literal|10
case|:
return|return
name|lookup_fundamental_type
argument_list|(
name|current_objfile
argument_list|,
name|FT_UNSIGNED_LONG
argument_list|)
return|;
case|case
literal|11
case|:
return|return
name|lookup_fundamental_type
argument_list|(
name|current_objfile
argument_list|,
name|FT_VOID
argument_list|)
return|;
case|case
literal|12
case|:
return|return
name|lookup_fundamental_type
argument_list|(
name|current_objfile
argument_list|,
name|FT_FLOAT
argument_list|)
return|;
case|case
literal|13
case|:
return|return
name|lookup_fundamental_type
argument_list|(
name|current_objfile
argument_list|,
name|FT_DBL_PREC_FLOAT
argument_list|)
return|;
case|case
literal|14
case|:
return|return
name|lookup_fundamental_type
argument_list|(
name|current_objfile
argument_list|,
name|FT_EXT_PREC_FLOAT
argument_list|)
return|;
case|case
literal|15
case|:
comment|/* requires a builtin `integer' */
return|return
name|lookup_fundamental_type
argument_list|(
name|current_objfile
argument_list|,
name|FT_INTEGER
argument_list|)
return|;
case|case
literal|16
case|:
return|return
name|lookup_fundamental_type
argument_list|(
name|current_objfile
argument_list|,
name|FT_BOOLEAN
argument_list|)
return|;
case|case
literal|17
case|:
comment|/* requires builtin `short real' */
return|return
name|lookup_fundamental_type
argument_list|(
name|current_objfile
argument_list|,
name|FT_FLOAT
argument_list|)
return|;
case|case
literal|18
case|:
comment|/* requires builtin `real' */
return|return
name|lookup_fundamental_type
argument_list|(
name|current_objfile
argument_list|,
name|FT_FLOAT
argument_list|)
return|;
default|default :
name|printf
argument_list|(
literal|"ERROR! Unknown builtin type -%d\n"
argument_list|,
name|typenums
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|xcoff_new_init
parameter_list|(
name|objfile
parameter_list|)
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{ }
end_function

begin_function
specifier|static
name|void
name|xcoff_symfile_init
parameter_list|(
name|objfile
parameter_list|)
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
name|bfd
modifier|*
name|abfd
init|=
name|objfile
operator|->
name|obfd
decl_stmt|;
comment|/* Allocate struct to keep track of the symfile */
name|objfile
operator|->
name|sym_private
operator|=
name|xmmalloc
argument_list|(
name|objfile
operator|->
name|md
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|coff_symfile_info
argument_list|)
argument_list|)
expr_stmt|;
name|init_entry_point_info
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Perform any local cleanups required when we are done with a particular    objfile.  I.E, we are in the process of discarding all symbol information    for an objfile, freeing up all memory held for it, and unlinking the    objfile struct from the global list of known objfiles. */
end_comment

begin_function
specifier|static
name|void
name|xcoff_symfile_finish
parameter_list|(
name|objfile
parameter_list|)
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
if|if
condition|(
name|objfile
operator|->
name|sym_private
operator|!=
name|NULL
condition|)
block|{
name|mfree
argument_list|(
name|objfile
operator|->
name|md
argument_list|,
name|objfile
operator|->
name|sym_private
argument_list|)
expr_stmt|;
block|}
comment|/* Start with a fresh include table for the next objfile. */
if|if
condition|(
name|inclTable
condition|)
block|{
name|free
argument_list|(
name|inclTable
argument_list|)
expr_stmt|;
name|inclTable
operator|=
name|NULL
expr_stmt|;
block|}
name|inclIndx
operator|=
name|inclLength
operator|=
name|inclDepth
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|init_stringtab
parameter_list|(
name|abfd
parameter_list|,
name|offset
parameter_list|,
name|objfile
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|file_ptr
name|offset
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
name|long
name|length
decl_stmt|;
name|int
name|val
decl_stmt|;
name|unsigned
name|char
name|lengthbuf
index|[
literal|4
index|]
decl_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|offset
argument_list|,
name|L_SET
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|val
operator|=
name|bfd_read
argument_list|(
operator|(
name|char
operator|*
operator|)
name|lengthbuf
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
name|lengthbuf
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
name|length
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
name|lengthbuf
argument_list|)
expr_stmt|;
comment|/* If no string table is needed, then the file may end immediately      after the symbols.  Just return with `strtbl' set to null. */
if|if
condition|(
name|val
operator|!=
sizeof|sizeof
name|length
operator|||
name|length
operator|<
sizeof|sizeof
name|length
condition|)
return|return
literal|0
return|;
comment|/* Allocate string table from symbol_obstack. We will need this table      as long as we have its symbol table around. */
name|strtbl
operator|=
operator|(
name|char
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|symbol_obstack
argument_list|,
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|strtbl
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|bcopy
argument_list|(
operator|&
name|length
argument_list|,
name|strtbl
argument_list|,
sizeof|sizeof
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|==
sizeof|sizeof
name|length
condition|)
return|return
literal|0
return|;
name|val
operator|=
name|bfd_read
argument_list|(
name|strtbl
operator|+
sizeof|sizeof
name|length
argument_list|,
literal|1
argument_list|,
name|length
operator|-
sizeof|sizeof
name|length
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
name|length
operator|-
sizeof|sizeof
name|length
operator|||
name|strtbl
index|[
name|length
operator|-
literal|1
index|]
operator|!=
literal|'\0'
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|init_debugsection
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
specifier|register
name|sec_ptr
name|secp
decl_stmt|;
name|bfd_size_type
name|length
decl_stmt|;
if|if
condition|(
name|debugsec
condition|)
block|{
name|free
argument_list|(
name|debugsec
argument_list|)
expr_stmt|;
name|debugsec
operator|=
name|NULL
expr_stmt|;
block|}
name|secp
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".debug"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|secp
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
operator|(
name|length
operator|=
name|bfd_section_size
argument_list|(
name|abfd
argument_list|,
name|secp
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
name|debugsec
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
name|unsigned
operator|)
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|debugsec
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|!
name|bfd_get_section_contents
argument_list|(
name|abfd
argument_list|,
name|secp
argument_list|,
name|debugsec
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|length
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"Can't read .debug section from symbol file\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|free_debugsection
parameter_list|()
block|{
if|if
condition|(
name|debugsec
condition|)
name|free
argument_list|(
name|debugsec
argument_list|)
expr_stmt|;
name|debugsec
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* xcoff version of symbol file read. */
end_comment

begin_function
specifier|static
name|void
name|xcoff_symfile_read
parameter_list|(
name|objfile
parameter_list|,
name|section_offset
parameter_list|,
name|mainline
parameter_list|)
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|struct
name|section_offset
modifier|*
name|section_offset
decl_stmt|;
name|int
name|mainline
decl_stmt|;
block|{
name|int
name|num_symbols
decl_stmt|;
comment|/* # of symbols */
name|file_ptr
name|symtab_offset
decl_stmt|;
comment|/* symbol table and */
name|file_ptr
name|stringtab_offset
decl_stmt|;
comment|/* string table file offsets */
name|int
name|val
decl_stmt|;
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|coff_symfile_info
modifier|*
name|info
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|info
operator|=
operator|(
expr|struct
name|coff_symfile_info
operator|*
operator|)
name|objfile
operator|->
name|sym_private
expr_stmt|;
name|symfile_bfd
operator|=
name|abfd
operator|=
name|objfile
operator|->
name|obfd
expr_stmt|;
name|name
operator|=
name|objfile
operator|->
name|name
expr_stmt|;
name|num_symbols
operator|=
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
comment|/* # of symbols */
name|symtab_offset
operator|=
name|obj_sym_filepos
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
comment|/* symbol table file offset */
name|stringtab_offset
operator|=
name|symtab_offset
operator|+
name|num_symbols
operator|*
name|coff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|local_symesz
expr_stmt|;
name|info
operator|->
name|min_lineno_offset
operator|=
literal|0
expr_stmt|;
name|info
operator|->
name|max_lineno_offset
operator|=
literal|0
expr_stmt|;
name|bfd_map_over_sections
argument_list|(
name|abfd
argument_list|,
name|find_linenos
argument_list|,
name|info
argument_list|)
expr_stmt|;
comment|/* FIXME!  This stuff should move into symfile_init */
if|if
condition|(
name|info
operator|->
name|min_lineno_offset
operator|!=
literal|0
operator|&&
name|info
operator|->
name|max_lineno_offset
operator|>
name|info
operator|->
name|min_lineno_offset
condition|)
block|{
comment|/* only read in the line # table if one exists */
name|val
operator|=
name|init_lineno
argument_list|(
name|abfd
argument_list|,
name|info
operator|->
name|min_lineno_offset
argument_list|,
call|(
name|int
call|)
argument_list|(
name|info
operator|->
name|max_lineno_offset
operator|-
name|info
operator|->
name|min_lineno_offset
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"\"%s\": error reading line numbers\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
name|val
operator|=
name|init_stringtab
argument_list|(
name|abfd
argument_list|,
name|stringtab_offset
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"\"%s\": can't get string table"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|init_debugsection
argument_list|(
name|abfd
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"Error reading .debug section of `%s'\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
comment|/* Position to read the symbol table.  Do not read it all at once. */
name|val
operator|=
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|symtab_offset
argument_list|,
name|L_SET
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_tell
argument_list|(
name|abfd
argument_list|)
operator|!=
name|symtab_offset
condition|)
name|fatal
argument_list|(
literal|"bfd? BFD!"
argument_list|)
expr_stmt|;
name|init_minimal_symbol_collection
argument_list|()
expr_stmt|;
name|make_cleanup
argument_list|(
name|discard_minimal_symbols
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Initialize load info structure. */
if|if
condition|(
name|mainline
condition|)
name|xcoff_init_loadinfo
argument_list|()
expr_stmt|;
comment|/* Now that the executable file is positioned at symbol table,      process it and define symbols accordingly. */
name|read_xcoff_symtab
argument_list|(
name|objfile
argument_list|,
name|num_symbols
argument_list|)
expr_stmt|;
comment|/* Free debug section. */
name|free_debugsection
argument_list|()
expr_stmt|;
comment|/* Sort symbols alphabetically within each block.  */
name|sort_syms
argument_list|()
expr_stmt|;
comment|/* Install any minimal symbols that have been collected as the current      minimal symbols for this objfile. */
name|install_minimal_symbols
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
comment|/* Make a default for file to list.  */
name|select_source_symtab
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* XCOFF-specific parsing routine for section offsets.    Plain and simple for now.  */
end_comment

begin_function
specifier|static
name|struct
name|section_offsets
modifier|*
name|xcoff_symfile_offsets
parameter_list|(
name|objfile
parameter_list|,
name|addr
parameter_list|)
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|CORE_ADDR
name|addr
decl_stmt|;
block|{
name|struct
name|section_offsets
modifier|*
name|section_offsets
decl_stmt|;
name|int
name|i
decl_stmt|;
name|section_offsets
operator|=
operator|(
expr|struct
name|section_offsets
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|psymbol_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|section_offsets
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|section_offsets
operator|->
name|offsets
argument_list|)
operator|*
operator|(
name|SECT_OFF_MAX
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SECT_OFF_MAX
condition|;
name|i
operator|++
control|)
name|ANOFFSET
argument_list|(
name|section_offsets
argument_list|,
name|i
argument_list|)
operator|=
name|addr
expr_stmt|;
return|return
name|section_offsets
return|;
block|}
end_function

begin_comment
comment|/* Register our ability to parse symbols for xcoff BFD files. */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|sym_fns
name|xcoff_sym_fns
init|=
block|{
literal|"aixcoff-rs6000"
block|,
comment|/* sym_name: name or name prefix of BFD target type */
literal|15
block|,
comment|/* sym_namelen: number of significant sym_name chars */
name|xcoff_new_init
block|,
comment|/* sym_new_init: init anything gbl to entire symtab */
name|xcoff_symfile_init
block|,
comment|/* sym_init: read initial info, setup for sym_read() */
name|xcoff_symfile_read
block|,
comment|/* sym_read: read a symbol file into symtab */
name|xcoff_symfile_finish
block|,
comment|/* sym_finish: finished with file, cleanup */
name|xcoff_symfile_offsets
block|,
comment|/* sym_offsets: xlate offsets ext->int form */
name|NULL
comment|/* next: pointer to next struct sym_fns */
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|_initialize_xcoffread
parameter_list|()
block|{
name|add_symtab_fns
argument_list|(
operator|&
name|xcoff_sym_fns
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* IBM6000_HOST */
end_comment

begin_function
name|struct
name|type
modifier|*
name|builtin_type
parameter_list|(
name|ignore
parameter_list|)
name|char
modifier|*
modifier|*
name|ignore
decl_stmt|;
block|{
name|fatal
argument_list|(
literal|"GDB internal error: builtin_type called on non-RS/6000!"
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* IBM6000_HOST */
end_comment

end_unit

