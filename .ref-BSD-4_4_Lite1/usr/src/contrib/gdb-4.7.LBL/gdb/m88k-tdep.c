begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Target-machine dependent code for Motorola 88000 series, for GDB.    Copyright (C) 1988, 1990, 1991 Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|USG
end_ifdef

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/dir.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|<sys/user.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|USER
end_ifndef

begin_comment
comment|/* added to support BCS ptrace_user */
end_comment

begin_define
define|#
directive|define
name|USER
value|ptrace_user
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"setjmp.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_function_decl
name|void
name|frame_find_saved_regs
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Given a GDB frame, determine the address of the calling function's frame.    This will be used to create a new GDB frame struct, and then    INIT_EXTRA_FRAME_INFO and INIT_FRAME_PC will be called for the new frame.     For us, the frame address is its stack pointer value, so we look up    the function prologue to determine the caller's sp value, and return it.  */
end_comment

begin_function
name|FRAME_ADDR
name|frame_chain
parameter_list|(
name|thisframe
parameter_list|)
name|FRAME
name|thisframe
decl_stmt|;
block|{
name|frame_find_saved_regs
argument_list|(
name|thisframe
argument_list|,
operator|(
expr|struct
name|frame_saved_regs
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
comment|/* NOTE:  this depends on frame_find_saved_regs returning the VALUE, not  	    the ADDRESS, of SP_REGNUM.  It also depends on the cache of 	    frame_find_saved_regs results.  */
if|if
condition|(
name|thisframe
operator|->
name|fsr
operator|->
name|regs
index|[
name|SP_REGNUM
index|]
condition|)
return|return
name|thisframe
operator|->
name|fsr
operator|->
name|regs
index|[
name|SP_REGNUM
index|]
return|;
else|else
return|return
name|thisframe
operator|->
name|frame
return|;
comment|/* Leaf fn -- next frame up has same SP. */
block|}
end_function

begin_function
name|int
name|frameless_function_invocation
parameter_list|(
name|frame
parameter_list|)
name|FRAME
name|frame
decl_stmt|;
block|{
name|frame_find_saved_regs
argument_list|(
name|frame
argument_list|,
operator|(
expr|struct
name|frame_saved_regs
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
comment|/* NOTE:  this depends on frame_find_saved_regs returning the VALUE, not  	    the ADDRESS, of SP_REGNUM.  It also depends on the cache of 	    frame_find_saved_regs results.  */
if|if
condition|(
name|frame
operator|->
name|fsr
operator|->
name|regs
index|[
name|SP_REGNUM
index|]
condition|)
return|return
literal|0
return|;
comment|/* Frameful -- return addr saved somewhere */
else|else
return|return
literal|1
return|;
comment|/* Frameless -- no saved return address */
block|}
end_function

begin_function
name|int
name|frame_chain_valid
parameter_list|(
name|chain
parameter_list|,
name|thisframe
parameter_list|)
name|CORE_ADDR
name|chain
decl_stmt|;
name|struct
name|frame_info
modifier|*
name|thisframe
decl_stmt|;
block|{
return|return
operator|(
name|chain
operator|!=
literal|0
operator|&&
operator|!
name|inside_entry_file
argument_list|(
name|FRAME_SAVED_PC
argument_list|(
name|thisframe
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|init_extra_frame_info
parameter_list|(
name|fromleaf
parameter_list|,
name|fi
parameter_list|)
name|int
name|fromleaf
decl_stmt|;
name|struct
name|frame_info
modifier|*
name|fi
decl_stmt|;
block|{
name|fi
operator|->
name|fsr
operator|=
literal|0
expr_stmt|;
comment|/* Not yet allocated */
name|fi
operator|->
name|args_pointer
operator|=
literal|0
expr_stmt|;
comment|/* Unknown */
name|fi
operator|->
name|locals_pointer
operator|=
literal|0
expr_stmt|;
comment|/* Unknown */
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Examine an m88k function prologue, recording the addresses at which    registers are saved explicitly by the prologue code, and returning    the address of the first instruction after the prologue (but not    after the instruction at address LIMIT, as explained below).     LIMIT places an upper bound on addresses of the instructions to be    examined.  If the prologue code scan reaches LIMIT, the scan is    aborted and LIMIT is returned.  This is used, when examining the    prologue for the current frame, to keep examine_prologue () from    claiming that a given register has been saved when in fact the    instruction that saves it has not yet been executed.  LIMIT is used    at other times to stop the scan when we hit code after the true    function prologue (e.g. for the first source line) which might    otherwise be mistaken for function prologue.     The format of the function prologue matched by this routine is    derived from examination of the source to gcc 1.95, particularly    the routine output_prologue () in config/out-m88k.c.     subu r31,r31,n			# stack pointer update     (st rn,r31,offset)?			# save incoming regs    (st.d rn,r31,offset)?     (addu r30,r31,n)?			# frame pointer update     (pic sequence)?			# PIC code prologue     (or   rn,rm,0)?			# Move parameters to other regs */
end_comment

begin_comment
comment|/* Macros for extracting fields from instructions.  */
end_comment

begin_define
define|#
directive|define
name|BITMASK
parameter_list|(
name|pos
parameter_list|,
name|width
parameter_list|)
value|(((0x1<< (width)) - 1)<< (pos))
end_define

begin_define
define|#
directive|define
name|EXTRACT_FIELD
parameter_list|(
name|val
parameter_list|,
name|pos
parameter_list|,
name|width
parameter_list|)
value|((val)>> (pos)& BITMASK (0, width))
end_define

begin_comment
comment|/* Prologue code that handles position-independent-code setup.  */
end_comment

begin_struct
struct|struct
name|pic_prologue_code
block|{
name|unsigned
name|long
name|insn
decl_stmt|,
name|mask
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|pic_prologue_code
name|pic_prologue_code
index|[]
init|=
block|{
comment|/* FIXME -- until this is translated to hex, we won't match it... */
literal|0xffffffff
block|,
literal|0
block|,
comment|/* or r10,r1,0  (if not saved) */
comment|/* bsr.n LabN */
comment|/* or.u r25,r0,const */
comment|/*LabN: or r25,r25,const2 */
comment|/* addu r25,r25,1 */
comment|/* or r1,r10,0  (if not saved) */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Fetch the instruction at ADDR, returning 0 if ADDR is beyond LIM or    is not the address of a valid instruction, the address of the next    instruction beyond ADDR otherwise.  *PWORD1 receives the first word    of the instruction.  PWORD2 is ignored -- a remnant of the original    i960 version.  */
end_comment

begin_define
define|#
directive|define
name|NEXT_PROLOGUE_INSN
parameter_list|(
name|addr
parameter_list|,
name|lim
parameter_list|,
name|pword1
parameter_list|,
name|pword2
parameter_list|)
define|\
value|(((addr)< (lim)) ? next_insn (addr, pword1) : 0)
end_define

begin_comment
comment|/* Read the m88k instruction at 'memaddr' and return the address of     the next instruction after that, or 0 if 'memaddr' is not the    address of a valid instruction.  The instruction    is stored at 'pword1'.  */
end_comment

begin_function
name|CORE_ADDR
name|next_insn
parameter_list|(
name|memaddr
parameter_list|,
name|pword1
parameter_list|)
name|unsigned
name|long
modifier|*
name|pword1
decl_stmt|;
name|CORE_ADDR
name|memaddr
decl_stmt|;
block|{
name|unsigned
name|long
name|buf
index|[
literal|1
index|]
decl_stmt|;
name|read_memory
argument_list|(
name|memaddr
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|pword1
operator|=
name|buf
index|[
literal|0
index|]
expr_stmt|;
name|SWAP_TARGET_AND_HOST
argument_list|(
name|pword1
argument_list|,
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|memaddr
operator|+
literal|4
return|;
block|}
end_function

begin_comment
comment|/* Read a register from frames called by us (or from the hardware regs).  */
end_comment

begin_function
name|int
name|read_next_frame_reg
parameter_list|(
name|fi
parameter_list|,
name|regno
parameter_list|)
name|FRAME
name|fi
decl_stmt|;
name|int
name|regno
decl_stmt|;
block|{
for|for
control|(
init|;
name|fi
condition|;
name|fi
operator|=
name|fi
operator|->
name|next
control|)
block|{
if|if
condition|(
name|regno
operator|==
name|SP_REGNUM
condition|)
return|return
name|fi
operator|->
name|frame
return|;
elseif|else
if|if
condition|(
name|fi
operator|->
name|fsr
operator|->
name|regs
index|[
name|regno
index|]
condition|)
return|return
name|read_memory_integer
argument_list|(
name|fi
operator|->
name|fsr
operator|->
name|regs
index|[
name|regno
index|]
argument_list|,
literal|4
argument_list|)
return|;
block|}
return|return
name|read_register
argument_list|(
name|regno
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Examine the prologue of a function.  `ip' points to the first instruction.    `limit' is the limit of the prologue (e.g. the addr of the first     linenumber, or perhaps the program counter if we're stepping through).    `frame_sp' is the stack pointer value in use in this frame.      `fsr' is a pointer to a frame_saved_regs structure into which we put    info about the registers saved by this frame.      `fi' is a struct frame_info pointer; we fill in various fields in it    to reflect the offsets of the arg pointer and the locals pointer.  */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|examine_prologue
parameter_list|(
name|ip
parameter_list|,
name|limit
parameter_list|,
name|frame_sp
parameter_list|,
name|fsr
parameter_list|,
name|fi
parameter_list|)
specifier|register
name|CORE_ADDR
name|ip
decl_stmt|;
specifier|register
name|CORE_ADDR
name|limit
decl_stmt|;
name|FRAME_ADDR
name|frame_sp
decl_stmt|;
name|struct
name|frame_saved_regs
modifier|*
name|fsr
decl_stmt|;
name|struct
name|frame_info
modifier|*
name|fi
decl_stmt|;
block|{
specifier|register
name|CORE_ADDR
name|next_ip
decl_stmt|;
specifier|register
name|int
name|src
decl_stmt|;
specifier|register
name|struct
name|pic_prologue_code
modifier|*
name|pcode
decl_stmt|;
name|unsigned
name|int
name|insn1
decl_stmt|,
name|insn2
decl_stmt|;
name|int
name|size
decl_stmt|,
name|offset
decl_stmt|;
name|char
name|must_adjust
index|[
literal|32
index|]
decl_stmt|;
comment|/* If set, must adjust offsets in fsr */
name|int
name|sp_offset
init|=
operator|-
literal|1
decl_stmt|;
comment|/* -1 means not set (valid must be mult of 8) */
name|int
name|fp_offset
init|=
operator|-
literal|1
decl_stmt|;
comment|/* -1 means not set */
name|CORE_ADDR
name|frame_fp
decl_stmt|;
name|bzero
argument_list|(
name|must_adjust
argument_list|,
sizeof|sizeof
argument_list|(
name|must_adjust
argument_list|)
argument_list|)
expr_stmt|;
name|next_ip
operator|=
name|NEXT_PROLOGUE_INSN
argument_list|(
name|ip
argument_list|,
name|limit
argument_list|,
operator|&
name|insn1
argument_list|,
operator|&
name|insn2
argument_list|)
expr_stmt|;
comment|/* Accept move of incoming registers to other registers, using      "or rd,rs,0" or "or.u rd,rs,0" or "or rd,r0,rs" or "or rd,rs,r0".      We don't have to worry about walking into the first lines of code,      since the first line number will stop us (assuming we have symbols).      What we have actually seen is "or r10,r0,r12".  */
define|#
directive|define
name|OR_MOVE_INSN
value|0x58000000
comment|/* or/or.u with immed of 0 */
define|#
directive|define
name|OR_MOVE_MASK
value|0xF800FFFF
define|#
directive|define
name|OR_REG_MOVE1_INSN
value|0xF4005800
comment|/* or rd,r0,rs */
define|#
directive|define
name|OR_REG_MOVE1_MASK
value|0xFC1FFFE0
define|#
directive|define
name|OR_REG_MOVE2_INSN
value|0xF4005800
comment|/* or rd,rs,r0 */
define|#
directive|define
name|OR_REG_MOVE2_MASK
value|0xFC00FFFF
while|while
condition|(
name|next_ip
operator|&&
operator|(
operator|(
name|insn1
operator|&
name|OR_MOVE_MASK
operator|)
operator|==
name|OR_MOVE_INSN
operator|||
operator|(
name|insn1
operator|&
name|OR_REG_MOVE1_MASK
operator|)
operator|==
name|OR_REG_MOVE1_INSN
operator|||
operator|(
name|insn1
operator|&
name|OR_REG_MOVE2_MASK
operator|)
operator|==
name|OR_REG_MOVE2_INSN
operator|)
condition|)
block|{
comment|/* We don't care what moves to where.  The result of the moves   	 has already been reflected in what the compiler tells us is the 	 location of these parameters.  */
name|ip
operator|=
name|next_ip
expr_stmt|;
name|next_ip
operator|=
name|NEXT_PROLOGUE_INSN
argument_list|(
name|ip
argument_list|,
name|limit
argument_list|,
operator|&
name|insn1
argument_list|,
operator|&
name|insn2
argument_list|)
expr_stmt|;
block|}
comment|/* Accept an optional "subu sp,sp,n" to set up the stack pointer.  */
define|#
directive|define
name|SUBU_SP_INSN
value|0x67ff0000
define|#
directive|define
name|SUBU_SP_MASK
value|0xffff0007
comment|/* Note offset must be mult. of 8 */
define|#
directive|define
name|SUBU_OFFSET
parameter_list|(
name|x
parameter_list|)
value|((unsigned)(x& 0xFFFF))
if|if
condition|(
name|next_ip
operator|&&
operator|(
operator|(
name|insn1
operator|&
name|SUBU_SP_MASK
operator|)
operator|==
name|SUBU_SP_INSN
operator|)
condition|)
comment|/* subu r31, r31, N */
block|{
name|sp_offset
operator|=
operator|-
name|SUBU_OFFSET
argument_list|(
name|insn1
argument_list|)
expr_stmt|;
name|ip
operator|=
name|next_ip
expr_stmt|;
name|next_ip
operator|=
name|NEXT_PROLOGUE_INSN
argument_list|(
name|ip
argument_list|,
name|limit
argument_list|,
operator|&
name|insn1
argument_list|,
operator|&
name|insn2
argument_list|)
expr_stmt|;
block|}
comment|/* The function must start with a stack-pointer adjustment, or      we don't know WHAT'S going on... */
if|if
condition|(
name|sp_offset
operator|==
operator|-
literal|1
condition|)
return|return
name|ip
return|;
comment|/* Accept zero or more instances of "st rx,sp,n" or "st.d rx,sp,n".        This may cause us to mistake the copying of a register      parameter to the frame for the saving of a callee-saved      register, but that can't be helped, since with the      "-fcall-saved" flag, any register can be made callee-saved.      This probably doesn't matter, since the ``saved'' caller's values of      non-callee-saved registers are not relevant anyway.  */
define|#
directive|define
name|STD_STACK_INSN
value|0x201f0000
define|#
directive|define
name|STD_STACK_MASK
value|0xfc1f0000
define|#
directive|define
name|ST_STACK_INSN
value|0x241f0000
define|#
directive|define
name|ST_STACK_MASK
value|0xfc1f0000
define|#
directive|define
name|ST_OFFSET
parameter_list|(
name|x
parameter_list|)
value|((unsigned)((x)& 0xFFFF))
define|#
directive|define
name|ST_SRC
parameter_list|(
name|x
parameter_list|)
value|EXTRACT_FIELD ((x), 21, 5)
while|while
condition|(
name|next_ip
condition|)
block|{
if|if
condition|(
operator|(
name|insn1
operator|&
name|ST_STACK_MASK
operator|)
operator|==
name|ST_STACK_INSN
condition|)
name|size
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|insn1
operator|&
name|STD_STACK_MASK
operator|)
operator|==
name|STD_STACK_INSN
condition|)
name|size
operator|=
literal|2
expr_stmt|;
else|else
break|break;
name|src
operator|=
name|ST_SRC
argument_list|(
name|insn1
argument_list|)
expr_stmt|;
name|offset
operator|=
name|ST_OFFSET
argument_list|(
name|insn1
argument_list|)
expr_stmt|;
while|while
condition|(
name|size
operator|--
condition|)
block|{
name|must_adjust
index|[
name|src
index|]
operator|=
literal|1
expr_stmt|;
name|fsr
operator|->
name|regs
index|[
name|src
operator|++
index|]
operator|=
name|offset
expr_stmt|;
comment|/* Will be adjusted later */
name|offset
operator|+=
literal|4
expr_stmt|;
block|}
name|ip
operator|=
name|next_ip
expr_stmt|;
name|next_ip
operator|=
name|NEXT_PROLOGUE_INSN
argument_list|(
name|ip
argument_list|,
name|limit
argument_list|,
operator|&
name|insn1
argument_list|,
operator|&
name|insn2
argument_list|)
expr_stmt|;
block|}
comment|/* Accept an optional "addu r30,r31,n" to set up the frame pointer.  */
define|#
directive|define
name|ADDU_FP_INSN
value|0x63df0000
define|#
directive|define
name|ADDU_FP_MASK
value|0xffff0000
define|#
directive|define
name|ADDU_OFFSET
parameter_list|(
name|x
parameter_list|)
value|((unsigned)(x& 0xFFFF))
if|if
condition|(
name|next_ip
operator|&&
operator|(
operator|(
name|insn1
operator|&
name|ADDU_FP_MASK
operator|)
operator|==
name|ADDU_FP_INSN
operator|)
condition|)
comment|/* addu r30, r31, N */
block|{
name|fp_offset
operator|=
name|ADDU_OFFSET
argument_list|(
name|insn1
argument_list|)
expr_stmt|;
name|ip
operator|=
name|next_ip
expr_stmt|;
name|next_ip
operator|=
name|NEXT_PROLOGUE_INSN
argument_list|(
name|ip
argument_list|,
name|limit
argument_list|,
operator|&
name|insn1
argument_list|,
operator|&
name|insn2
argument_list|)
expr_stmt|;
block|}
comment|/* Accept the PIC prologue code if present.  */
name|pcode
operator|=
name|pic_prologue_code
expr_stmt|;
name|size
operator|=
sizeof|sizeof
argument_list|(
name|pic_prologue_code
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|pic_prologue_code
argument_list|)
expr_stmt|;
comment|/* If return addr is saved, we don't use first or last insn of PICstuff.  */
if|if
condition|(
name|fsr
operator|->
name|regs
index|[
name|SRP_REGNUM
index|]
condition|)
block|{
name|pcode
operator|++
expr_stmt|;
name|size
operator|-=
literal|2
expr_stmt|;
block|}
while|while
condition|(
name|size
operator|--
operator|&&
name|next_ip
operator|&&
operator|(
name|pcode
operator|->
name|insn
operator|==
operator|(
name|pcode
operator|->
name|mask
operator|&
name|insn1
operator|)
operator|)
condition|)
block|{
name|pcode
operator|++
expr_stmt|;
name|ip
operator|=
name|next_ip
expr_stmt|;
name|next_ip
operator|=
name|NEXT_PROLOGUE_INSN
argument_list|(
name|ip
argument_list|,
name|limit
argument_list|,
operator|&
name|insn1
argument_list|,
operator|&
name|insn2
argument_list|)
expr_stmt|;
block|}
comment|/* Accept moves of parameter registers to other registers, using      "or rd,rs,0" or "or.u rd,rs,0" or "or rd,r0,rs" or "or rd,rs,r0".      We don't have to worry about walking into the first lines of code,      since the first line number will stop us (assuming we have symbols).      What gcc actually seems to produce is "or rd,r0,rs".  */
define|#
directive|define
name|OR_MOVE_INSN
value|0x58000000
comment|/* or/or.u with immed of 0 */
define|#
directive|define
name|OR_MOVE_MASK
value|0xF800FFFF
define|#
directive|define
name|OR_REG_MOVE1_INSN
value|0xF4005800
comment|/* or rd,r0,rs */
define|#
directive|define
name|OR_REG_MOVE1_MASK
value|0xFC1FFFE0
define|#
directive|define
name|OR_REG_MOVE2_INSN
value|0xF4005800
comment|/* or rd,rs,r0 */
define|#
directive|define
name|OR_REG_MOVE2_MASK
value|0xFC00FFFF
while|while
condition|(
name|next_ip
operator|&&
operator|(
operator|(
name|insn1
operator|&
name|OR_MOVE_MASK
operator|)
operator|==
name|OR_MOVE_INSN
operator|||
operator|(
name|insn1
operator|&
name|OR_REG_MOVE1_MASK
operator|)
operator|==
name|OR_REG_MOVE1_INSN
operator|||
operator|(
name|insn1
operator|&
name|OR_REG_MOVE2_MASK
operator|)
operator|==
name|OR_REG_MOVE2_INSN
operator|)
condition|)
block|{
comment|/* We don't care what moves to where.  The result of the moves   	 has already been reflected in what the compiler tells us is the 	 location of these parameters.  */
name|ip
operator|=
name|next_ip
expr_stmt|;
name|next_ip
operator|=
name|NEXT_PROLOGUE_INSN
argument_list|(
name|ip
argument_list|,
name|limit
argument_list|,
operator|&
name|insn1
argument_list|,
operator|&
name|insn2
argument_list|)
expr_stmt|;
block|}
comment|/* We're done with the prologue.  If we don't care about the stack      frame itself, just return.  (Note that fsr->regs has been trashed,      but the one caller who calls with fi==0 passes a dummy there.)  */
if|if
condition|(
name|fi
operator|==
literal|0
condition|)
return|return
name|ip
return|;
comment|/* OK, now we have: 	sp_offset	original negative displacement of SP 	fp_offset	positive displacement between new SP and new FP, or -1 	fsr->regs[0..31]	offset from original SP where reg is stored 	must_adjust[0..31]	set if corresp. offset was set       The current SP (frame_sp) might not be the original new SP as set      by the function prologue, if alloca has been called.  This can      only occur if fp_offset is set, though (the compiler allocates an      FP when it sees alloca).  In that case, we have the FP,      and can calculate the original new SP from the FP.       Then, we figure out where the arguments and locals are, and      relocate the offsets in fsr->regs to absolute addresses.  */
if|if
condition|(
name|fp_offset
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* We have a frame pointer, so get it, and base our calc's on it.  */
name|frame_fp
operator|=
operator|(
name|CORE_ADDR
operator|)
name|read_next_frame_reg
argument_list|(
name|fi
operator|->
name|next
argument_list|,
name|FP_REGNUM
argument_list|)
expr_stmt|;
name|frame_sp
operator|=
name|frame_fp
operator|-
name|fp_offset
expr_stmt|;
block|}
else|else
block|{
comment|/* We have no frame pointer, therefore frame_sp is still the same value        as set by prologue.  But where is the frame itself?  */
if|if
condition|(
name|must_adjust
index|[
name|SRP_REGNUM
index|]
condition|)
block|{
comment|/* Function header saved SRP (r1), the return address.  Frame starts 	 4 bytes down from where it was saved.  */
name|frame_fp
operator|=
name|frame_sp
operator|+
name|fsr
operator|->
name|regs
index|[
name|SRP_REGNUM
index|]
operator|-
literal|4
expr_stmt|;
name|fi
operator|->
name|locals_pointer
operator|=
name|frame_fp
expr_stmt|;
block|}
else|else
block|{
comment|/* Function header didn't save SRP (r1), so we are in a leaf fn or 	 are otherwise confused.  */
name|frame_fp
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
comment|/* The locals are relative to the FP (whether it exists as an allocated      register, or just as an assumed offset from the SP) */
name|fi
operator|->
name|locals_pointer
operator|=
name|frame_fp
expr_stmt|;
comment|/* The arguments are just above the SP as it was before we adjusted it      on entry.  */
name|fi
operator|->
name|args_pointer
operator|=
name|frame_sp
operator|-
name|sp_offset
expr_stmt|;
comment|/* Now that we know the SP value used by the prologue, we know where      it saved all the registers.  */
for|for
control|(
name|src
operator|=
literal|0
init|;
name|src
operator|<
literal|32
condition|;
name|src
operator|++
control|)
if|if
condition|(
name|must_adjust
index|[
name|src
index|]
condition|)
name|fsr
operator|->
name|regs
index|[
name|src
index|]
operator|+=
name|frame_sp
expr_stmt|;
comment|/* The saved value of the SP is always known.  */
comment|/* (we hope...) */
if|if
condition|(
name|fsr
operator|->
name|regs
index|[
name|SP_REGNUM
index|]
operator|!=
literal|0
operator|&&
name|fsr
operator|->
name|regs
index|[
name|SP_REGNUM
index|]
operator|!=
name|frame_sp
operator|-
name|sp_offset
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Bad saved SP value %x != %x, offset %x!\n"
argument_list|,
name|fsr
operator|->
name|regs
index|[
name|SP_REGNUM
index|]
argument_list|,
name|frame_sp
operator|-
name|sp_offset
argument_list|,
name|sp_offset
argument_list|)
expr_stmt|;
name|fsr
operator|->
name|regs
index|[
name|SP_REGNUM
index|]
operator|=
name|frame_sp
operator|-
name|sp_offset
expr_stmt|;
return|return
operator|(
name|ip
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Given an ip value corresponding to the start of a function,    return the ip of the first instruction after the function     prologue.  */
end_comment

begin_function_decl
name|CORE_ADDR
name|skip_prologue
parameter_list|(
name|ip
parameter_list|)
function_decl|CORE_ADDR
parameter_list|(
name|ip
parameter_list|)
function_decl|;
end_function_decl

begin_block
block|{
name|struct
name|frame_saved_regs
name|saved_regs_dummy
decl_stmt|;
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
name|CORE_ADDR
name|limit
decl_stmt|;
name|sal
operator|=
name|find_pc_line
argument_list|(
name|ip
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|limit
operator|=
operator|(
name|sal
operator|.
name|end
operator|)
condition|?
name|sal
operator|.
name|end
else|:
literal|0xffffffff
expr_stmt|;
return|return
operator|(
name|examine_prologue
argument_list|(
name|ip
argument_list|,
name|limit
argument_list|,
operator|(
name|FRAME_ADDR
operator|)
literal|0
argument_list|,
operator|&
name|saved_regs_dummy
argument_list|,
operator|(
expr|struct
name|frame_info
operator|*
operator|)
literal|0
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Put here the code to store, into a struct frame_saved_regs,    the addresses of the saved registers of frame described by FRAME_INFO.    This includes special registers such as pc and fp saved in special    ways in the stack frame.  sp is even more special:    the address we return for it IS the sp for the next frame.     We cache the result of doing this in the frame_cache_obstack, since    it is fairly expensive.  */
end_comment

begin_function
name|void
name|frame_find_saved_regs
parameter_list|(
name|fi
parameter_list|,
name|fsr
parameter_list|)
name|struct
name|frame_info
modifier|*
name|fi
decl_stmt|;
name|struct
name|frame_saved_regs
modifier|*
name|fsr
decl_stmt|;
block|{
specifier|register
name|CORE_ADDR
name|next_addr
decl_stmt|;
specifier|register
name|CORE_ADDR
modifier|*
name|saved_regs
decl_stmt|;
specifier|register
name|int
name|regnum
decl_stmt|;
specifier|register
name|struct
name|frame_saved_regs
modifier|*
name|cache_fsr
decl_stmt|;
specifier|extern
name|struct
name|obstack
name|frame_cache_obstack
decl_stmt|;
name|CORE_ADDR
name|ip
decl_stmt|;
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
name|CORE_ADDR
name|limit
decl_stmt|;
if|if
condition|(
operator|!
name|fi
operator|->
name|fsr
condition|)
block|{
name|cache_fsr
operator|=
operator|(
expr|struct
name|frame_saved_regs
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|frame_cache_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|frame_saved_regs
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|cache_fsr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|frame_saved_regs
argument_list|)
argument_list|)
expr_stmt|;
name|fi
operator|->
name|fsr
operator|=
name|cache_fsr
expr_stmt|;
comment|/* Find the start and end of the function prologue.  If the PC 	 is in the function prologue, we only consider the part that 	 has executed already.  */
name|ip
operator|=
name|get_pc_function_start
argument_list|(
name|fi
operator|->
name|pc
argument_list|)
expr_stmt|;
name|sal
operator|=
name|find_pc_line
argument_list|(
name|ip
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|limit
operator|=
operator|(
name|sal
operator|.
name|end
operator|&&
name|sal
operator|.
name|end
operator|<
name|fi
operator|->
name|pc
operator|)
condition|?
name|sal
operator|.
name|end
else|:
name|fi
operator|->
name|pc
expr_stmt|;
comment|/* This will fill in fields in *fi as well as in cache_fsr.  */
name|examine_prologue
argument_list|(
name|ip
argument_list|,
name|limit
argument_list|,
name|fi
operator|->
name|frame
argument_list|,
name|cache_fsr
argument_list|,
name|fi
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fsr
condition|)
operator|*
name|fsr
operator|=
operator|*
name|fi
operator|->
name|fsr
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the address of the locals block for the frame    described by FI.  Returns 0 if the address is unknown.    NOTE!  Frame locals are referred to by negative offsets from the    argument pointer, so this is the same as frame_args_address().  */
end_comment

begin_function
name|CORE_ADDR
name|frame_locals_address
parameter_list|(
name|fi
parameter_list|)
name|struct
name|frame_info
modifier|*
name|fi
decl_stmt|;
block|{
specifier|register
name|FRAME
name|frame
decl_stmt|;
name|struct
name|frame_saved_regs
name|fsr
decl_stmt|;
name|CORE_ADDR
name|ap
decl_stmt|;
if|if
condition|(
name|fi
operator|->
name|args_pointer
condition|)
comment|/* Cached value is likely there.  */
return|return
name|fi
operator|->
name|args_pointer
return|;
comment|/* Nope, generate it.  */
name|get_frame_saved_regs
argument_list|(
name|fi
argument_list|,
operator|&
name|fsr
argument_list|)
expr_stmt|;
return|return
name|fi
operator|->
name|args_pointer
return|;
block|}
end_function

begin_comment
comment|/* Return the address of the argument block for the frame    described by FI.  Returns 0 if the address is unknown.  */
end_comment

begin_function
name|CORE_ADDR
name|frame_args_address
parameter_list|(
name|fi
parameter_list|)
name|struct
name|frame_info
modifier|*
name|fi
decl_stmt|;
block|{
specifier|register
name|FRAME
name|frame
decl_stmt|;
name|struct
name|frame_saved_regs
name|fsr
decl_stmt|;
name|CORE_ADDR
name|ap
decl_stmt|;
if|if
condition|(
name|fi
operator|->
name|args_pointer
condition|)
comment|/* Cached value is likely there.  */
return|return
name|fi
operator|->
name|args_pointer
return|;
comment|/* Nope, generate it.  */
name|get_frame_saved_regs
argument_list|(
name|fi
argument_list|,
operator|&
name|fsr
argument_list|)
expr_stmt|;
return|return
name|fi
operator|->
name|args_pointer
return|;
block|}
end_function

begin_comment
comment|/* Return the saved PC from this frame.     If the frame has a memory copy of SRP_REGNUM, use that.  If not,    just use the register SRP_REGNUM itself.  */
end_comment

begin_function
name|CORE_ADDR
name|frame_saved_pc
parameter_list|(
name|frame
parameter_list|)
name|FRAME
name|frame
decl_stmt|;
block|{
return|return
name|read_next_frame_reg
argument_list|(
name|frame
argument_list|,
name|SRP_REGNUM
argument_list|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|TARGET_BYTE_ORDER
operator|!=
name|HOST_BYTE_ORDER
end_if

begin_function
name|you
name|lose
else|#
directive|else
comment|/* Host and target byte order the same.  */
define|#
directive|define
name|SINGLE_EXP_BITS
value|8
define|#
directive|define
name|DOUBLE_EXP_BITS
value|11
name|int
name|IEEE_isNAN
parameter_list|(
name|fp
parameter_list|,
name|len
parameter_list|)
name|int
modifier|*
name|fp
decl_stmt|,
name|len
decl_stmt|;
comment|/* fp points to a single precision OR double precision       * floating point value; len is the number of bytes, either 4 or 8.       * Returns 1 iff fp points to a valid IEEE floating point number.       * Returns 0 if fp points to a denormalized number or a NaN       */
block|{
name|int
name|exponent
decl_stmt|;
if|if
condition|(
name|len
operator|==
literal|4
condition|)
block|{
name|exponent
operator|=
operator|*
name|fp
expr_stmt|;
name|exponent
operator|=
name|exponent
operator|<<
literal|1
operator|>>
operator|(
literal|32
operator|-
name|SINGLE_EXP_BITS
operator|-
literal|1
operator|)
expr_stmt|;
return|return
operator|(
operator|(
name|exponent
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
operator|!
name|exponent
operator|&&
operator|*
name|fp
operator|)
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|len
operator|==
literal|8
condition|)
block|{
name|exponent
operator|=
operator|*
operator|(
name|fp
operator|+
literal|1
operator|)
expr_stmt|;
name|exponent
operator|=
name|exponent
operator|<<
literal|1
operator|>>
operator|(
literal|32
operator|-
name|DOUBLE_EXP_BITS
operator|-
literal|1
operator|)
expr_stmt|;
return|return
operator|(
operator|(
name|exponent
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
operator|!
name|exponent
operator|&&
operator|*
name|fp
operator|*
operator|*
operator|(
name|fp
operator|+
literal|1
operator|)
operator|)
operator|)
return|;
block|}
else|else
return|return
literal|1
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Host and target byte order the same.  */
end_comment

begin_function
specifier|static
name|int
name|pushed_size
parameter_list|(
name|prev_words
parameter_list|,
name|v
parameter_list|)
name|int
name|prev_words
decl_stmt|;
name|struct
name|value
modifier|*
name|v
decl_stmt|;
block|{
switch|switch
condition|(
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|v
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|TYPE_CODE_VOID
case|:
comment|/* Void type (values zero length) */
return|return
literal|0
return|;
comment|/* That was easy! */
case|case
name|TYPE_CODE_PTR
case|:
comment|/* Pointer type */
case|case
name|TYPE_CODE_ENUM
case|:
comment|/* Enumeration type */
case|case
name|TYPE_CODE_INT
case|:
comment|/* Integer type */
case|case
name|TYPE_CODE_REF
case|:
comment|/* C++ Reference types */
case|case
name|TYPE_CODE_ARRAY
case|:
comment|/* Array type, lower bound zero */
return|return
literal|1
return|;
case|case
name|TYPE_CODE_FLT
case|:
comment|/* Floating type */
if|if
condition|(
name|TYPE_LENGTH
argument_list|(
name|VALUE_TYPE
argument_list|(
name|v
argument_list|)
argument_list|)
operator|==
literal|4
condition|)
return|return
literal|1
return|;
elseif|else
comment|/* Assume that it must be a double.  */
if|if
condition|(
name|prev_words
operator|&
literal|1
condition|)
comment|/* at an odd-word boundary */
return|return
literal|3
return|;
comment|/* round to 8-byte boundary */
else|else
return|return
literal|2
return|;
case|case
name|TYPE_CODE_STRUCT
case|:
comment|/* C struct or Pascal record */
case|case
name|TYPE_CODE_UNION
case|:
comment|/* C union or Pascal variant part */
return|return
operator|(
operator|(
operator|(
name|TYPE_LENGTH
argument_list|(
name|VALUE_TYPE
argument_list|(
name|v
argument_list|)
argument_list|)
operator|+
literal|3
operator|)
operator|/
literal|4
operator|)
operator|*
literal|4
operator|)
return|;
case|case
name|TYPE_CODE_FUNC
case|:
comment|/* Function type */
case|case
name|TYPE_CODE_SET
case|:
comment|/* Pascal sets */
case|case
name|TYPE_CODE_RANGE
case|:
comment|/* Range (integers within bounds) */
case|case
name|TYPE_CODE_PASCAL_ARRAY
case|:
comment|/* Array with explicit type of index */
case|case
name|TYPE_CODE_MEMBER
case|:
comment|/* Member type */
case|case
name|TYPE_CODE_METHOD
case|:
comment|/* Method type */
comment|/* Don't know how to pass these yet.  */
case|case
name|TYPE_CODE_UNDEF
case|:
comment|/* Not used; catches errors */
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|store_parm_word
parameter_list|(
name|address
parameter_list|,
name|val
parameter_list|)
name|CORE_ADDR
name|address
decl_stmt|;
name|int
name|val
decl_stmt|;
block|{
name|write_memory
argument_list|(
name|address
argument_list|,
operator|&
name|val
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|store_parm
parameter_list|(
name|prev_words
parameter_list|,
name|left_parm_addr
parameter_list|,
name|v
parameter_list|)
name|unsigned
name|int
name|prev_words
decl_stmt|;
name|CORE_ADDR
name|left_parm_addr
decl_stmt|;
name|struct
name|value
modifier|*
name|v
decl_stmt|;
block|{
name|CORE_ADDR
name|start
init|=
name|left_parm_addr
operator|+
operator|(
name|prev_words
operator|*
literal|4
operator|)
decl_stmt|;
name|int
modifier|*
name|val_addr
init|=
operator|(
name|int
operator|*
operator|)
name|VALUE_CONTENTS
argument_list|(
name|v
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|v
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|TYPE_CODE_VOID
case|:
comment|/* Void type (values zero length) */
return|return
literal|0
return|;
case|case
name|TYPE_CODE_PTR
case|:
comment|/* Pointer type */
case|case
name|TYPE_CODE_ENUM
case|:
comment|/* Enumeration type */
case|case
name|TYPE_CODE_INT
case|:
comment|/* Integer type */
case|case
name|TYPE_CODE_ARRAY
case|:
comment|/* Array type, lower bound zero */
case|case
name|TYPE_CODE_REF
case|:
comment|/* C++ Reference types */
name|store_parm_word
argument_list|(
name|start
argument_list|,
operator|*
name|val_addr
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
name|TYPE_CODE_FLT
case|:
comment|/* Floating type */
if|if
condition|(
name|TYPE_LENGTH
argument_list|(
name|VALUE_TYPE
argument_list|(
name|v
argument_list|)
argument_list|)
operator|==
literal|4
condition|)
block|{
name|store_parm_word
argument_list|(
name|start
argument_list|,
operator|*
name|val_addr
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
block|{
name|store_parm_word
argument_list|(
name|start
operator|+
operator|(
operator|(
name|prev_words
operator|&
literal|1
operator|)
operator|*
literal|4
operator|)
argument_list|,
name|val_addr
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|store_parm_word
argument_list|(
name|start
operator|+
operator|(
operator|(
name|prev_words
operator|&
literal|1
operator|)
operator|*
literal|4
operator|)
operator|+
literal|4
argument_list|,
name|val_addr
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
literal|2
operator|+
operator|(
name|prev_words
operator|&
literal|1
operator|)
return|;
block|}
case|case
name|TYPE_CODE_STRUCT
case|:
comment|/* C struct or Pascal record */
case|case
name|TYPE_CODE_UNION
case|:
comment|/* C union or Pascal variant part */
block|{
name|unsigned
name|int
name|words
init|=
operator|(
operator|(
operator|(
name|TYPE_LENGTH
argument_list|(
name|VALUE_TYPE
argument_list|(
name|v
argument_list|)
argument_list|)
operator|+
literal|3
operator|)
operator|/
literal|4
operator|)
operator|*
literal|4
operator|)
decl_stmt|;
name|unsigned
name|int
name|word
decl_stmt|;
for|for
control|(
name|word
operator|=
literal|0
init|;
name|word
operator|<
name|words
condition|;
name|word
operator|++
control|)
name|store_parm_word
argument_list|(
name|start
operator|+
operator|(
name|word
operator|*
literal|4
operator|)
argument_list|,
name|val_addr
index|[
name|word
index|]
argument_list|)
expr_stmt|;
return|return
name|words
return|;
block|}
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This routine sets up all of the parameter values needed to make a pseudo     call.  The name "push_parameters" is a misnomer on some archs,     because (on the m88k) most parameters generally end up being passed in     registers rather than on the stack.  In this routine however, we do     end up storing *all* parameter values onto the stack (even if we will     realize later that some of these stores were unnecessary).  */
end_comment

begin_define
define|#
directive|define
name|FIRST_PARM_REGNUM
value|2
end_define

begin_function
name|void
name|push_parameters
parameter_list|(
name|return_type
parameter_list|,
name|struct_conv
parameter_list|,
name|nargs
parameter_list|,
name|args
parameter_list|)
name|struct
name|type
modifier|*
name|return_type
decl_stmt|;
name|int
name|struct_conv
decl_stmt|;
name|int
name|nargs
decl_stmt|;
name|value
modifier|*
name|args
decl_stmt|;
block|{
name|int
name|parm_num
decl_stmt|;
name|unsigned
name|int
name|p_words
init|=
literal|0
decl_stmt|;
name|CORE_ADDR
name|left_parm_addr
decl_stmt|;
comment|/* Start out by creating a space for the return value (if need be).  We       only need to do this if the return value is a struct or union.  If we       do make a space for a struct or union return value, then we must also       arrange for the base address of that space to go into r12, which is the       standard place to pass the address of the return value area to the       callee.  Note that only structs and unions are returned in this fashion.       Ints, enums, pointers, and floats are returned into r2.  Doubles are       returned into the register pair {r2,r3}.  Note also that the space       reserved for a struct or union return value only has to be word aligned       (not double-word) but it is double-word aligned here anyway (just in       case that becomes important someday).  */
switch|switch
condition|(
name|TYPE_CODE
argument_list|(
name|return_type
argument_list|)
condition|)
block|{
case|case
name|TYPE_CODE_STRUCT
case|:
case|case
name|TYPE_CODE_UNION
case|:
block|{
name|int
name|return_bytes
init|=
operator|(
operator|(
name|TYPE_LENGTH
argument_list|(
name|return_type
argument_list|)
operator|+
literal|7
operator|)
operator|/
literal|8
operator|)
operator|*
literal|8
decl_stmt|;
name|CORE_ADDR
name|rv_addr
decl_stmt|;
name|rv_addr
operator|=
name|read_register
argument_list|(
name|SP_REGNUM
argument_list|)
operator|-
name|return_bytes
expr_stmt|;
name|write_register
argument_list|(
name|SP_REGNUM
argument_list|,
name|rv_addr
argument_list|)
expr_stmt|;
comment|/* push space onto the stack */
name|write_register
argument_list|(
name|SRA_REGNUM
argument_list|,
name|rv_addr
argument_list|)
expr_stmt|;
comment|/* set return value register */
block|}
block|}
comment|/* Here we make a pre-pass on the whole parameter list to figure out exactly       how many words worth of stuff we are going to pass.  */
for|for
control|(
name|p_words
operator|=
literal|0
operator|,
name|parm_num
operator|=
literal|0
init|;
name|parm_num
operator|<
name|nargs
condition|;
name|parm_num
operator|++
control|)
name|p_words
operator|+=
name|pushed_size
argument_list|(
name|p_words
argument_list|,
name|value_arg_coerce
argument_list|(
name|args
index|[
name|parm_num
index|]
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now, check to see if we have to round up the number of parameter words       to get up to the next 8-bytes boundary.  This may be necessary because       of the software convention to always keep the stack aligned on an 8-byte       boundary.  */
if|if
condition|(
name|p_words
operator|&
literal|1
condition|)
name|p_words
operator|++
expr_stmt|;
comment|/* round to 8-byte boundary */
comment|/* Now figure out the absolute address of the leftmost parameter, and update       the stack pointer to point at that address.  */
name|left_parm_addr
operator|=
name|read_register
argument_list|(
name|SP_REGNUM
argument_list|)
operator|-
operator|(
name|p_words
operator|*
literal|4
operator|)
expr_stmt|;
name|write_register
argument_list|(
name|SP_REGNUM
argument_list|,
name|left_parm_addr
argument_list|)
expr_stmt|;
comment|/* Now we can go through all of the parameters (in left-to-right order)       and write them to their parameter stack slots.  Note that we are not       really "pushing" the parameter values.  The stack space for these values       was already allocated above.  Now we are just filling it up.  */
for|for
control|(
name|p_words
operator|=
literal|0
operator|,
name|parm_num
operator|=
literal|0
init|;
name|parm_num
operator|<
name|nargs
condition|;
name|parm_num
operator|++
control|)
name|p_words
operator|+=
name|store_parm
argument_list|(
name|p_words
argument_list|,
name|left_parm_addr
argument_list|,
name|value_arg_coerce
argument_list|(
name|args
index|[
name|parm_num
index|]
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now that we are all done storing the parameter values into the stack, we       must go back and load up the parameter registers with the values from the       corresponding stack slots.  Note that in the two cases of (a) gaps in the       parameter word sequence causes by (otherwise) misaligned doubles, and (b)       slots correcponding to structs or unions, the work we do here in loading       some parameter registers may be unnecessary, but who cares?  */
for|for
control|(
name|p_words
operator|=
literal|0
init|;
name|p_words
operator|<
literal|8
condition|;
name|p_words
operator|++
control|)
block|{
name|write_register
argument_list|(
name|FIRST_PARM_REGNUM
operator|+
name|p_words
argument_list|,
name|read_memory_integer
argument_list|(
name|left_parm_addr
operator|+
operator|(
name|p_words
operator|*
literal|4
operator|)
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|pop_frame
parameter_list|()
block|{
name|error
argument_list|(
literal|"Feature not implemented for the m88k yet."
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|collect_returned_value
parameter_list|(
name|rval
parameter_list|,
name|value_type
parameter_list|,
name|struct_return
parameter_list|,
name|nargs
parameter_list|,
name|args
parameter_list|)
name|value
modifier|*
name|rval
decl_stmt|;
name|struct
name|type
modifier|*
name|value_type
decl_stmt|;
name|int
name|struct_return
decl_stmt|;
name|int
name|nargs
decl_stmt|;
name|value
modifier|*
name|args
decl_stmt|;
block|{
name|char
name|retbuf
index|[
name|REGISTER_BYTES
index|]
decl_stmt|;
name|bcopy
argument_list|(
name|registers
argument_list|,
name|retbuf
argument_list|,
name|REGISTER_BYTES
argument_list|)
expr_stmt|;
operator|*
name|rval
operator|=
name|value_being_returned
argument_list|(
name|value_type
argument_list|,
name|retbuf
argument_list|,
name|struct_return
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Now handled in a machine independent way with CALL_DUMMY_LOCATION.  */
end_comment

begin_comment
comment|/* Stuff a breakpoint instruction onto the stack (or elsewhere if the stack     is not a good place for it).  Return the address at which the instruction     got stuffed, or zero if we were unable to stuff it anywhere.  */
end_comment

begin_comment
unit|CORE_ADDR push_breakpoint () {   static char breakpoint_insn[] = BREAKPOINT;   extern CORE_ADDR text_end;
comment|/* of inferior */
end_comment

begin_comment
unit|static char readback_buffer[] = BREAKPOINT;   int i;
comment|/* With a little bit of luck, we can just stash the breakpoint instruction      in the word just beyond the end of normal text space.  For systems on      which the hardware will not allow us to execute out of the stack segment,      we have to hope that we *are* at least allowed to effectively extend the      text segment by one word.  If the actual end of user's the text segment      happens to fall right at a page boundary this trick may fail.  Note that      we check for this by reading after writing, and comparing in order to      be sure that the write worked.  */
end_comment

begin_comment
unit|write_memory (text_end,&breakpoint_insn, 4);
comment|/* Fill the readback buffer with some garbage which is certain to be      unequal to the breakpoint insn.  That way we can tell if the      following read doesn't actually succeed.  */
end_comment

begin_comment
unit|for (i = 0; i< sizeof (readback_buffer); i++)     readback_buffer[i] = ~ readback_buffer[i];
comment|/* Invert the bits */
end_comment

begin_comment
comment|/* Now check that the breakpoint insn was successfully installed.  */
end_comment

begin_comment
unit|read_memory (text_end, readback_buffer, sizeof (readback_buffer));   for (i = 0; i< sizeof (readback_buffer); i++)     if (readback_buffer[i] != breakpoint_insn[i])       return 0;
comment|/* Failed to install! */
end_comment

begin_endif
unit|return text_end; }
endif|#
directive|endif
end_endif

end_unit

