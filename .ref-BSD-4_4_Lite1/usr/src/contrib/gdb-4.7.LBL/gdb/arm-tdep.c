begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Target-dependent code for the Acorn Risc Machine, for GDB, the GNU Debugger.    Copyright 1988, 1989, 1991 Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"arm-opcode.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/dir.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/ptrace.h>
end_include

begin_include
include|#
directive|include
file|<machine/reg.h>
end_include

begin_define
define|#
directive|define
name|N_TXTADDR
parameter_list|(
name|hdr
parameter_list|)
value|0x8000
end_define

begin_define
define|#
directive|define
name|N_DATADDR
parameter_list|(
name|hdr
parameter_list|)
value|(hdr.a_text + 0x8000)
end_define

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|<sys/user.h>
end_include

begin_comment
comment|/* After a.out.h  */
end_comment

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_escape
end_escape

begin_comment
comment|/* Work with core dump and executable files, for GDB.     This code would be in core.c if it weren't machine-dependent. */
end_comment

begin_comment
comment|/* Structure to describe the chain of shared libraries used    by the execfile.    e.g. prog shares Xt which shares X11 which shares c. */
end_comment

begin_struct
struct|struct
name|shared_library
block|{
name|struct
name|exec_header
name|header
decl_stmt|;
name|char
name|name
index|[
name|SHLIBLEN
index|]
decl_stmt|;
name|CORE_ADDR
name|text_start
decl_stmt|;
comment|/* CORE_ADDR of 1st byte of text, this file */
name|long
name|data_offset
decl_stmt|;
comment|/* offset of data section in file */
name|int
name|chan
decl_stmt|;
comment|/* file descriptor for the file */
name|struct
name|shared_library
modifier|*
name|shares
decl_stmt|;
comment|/* library this one shares */
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|shared_library
modifier|*
name|shlib
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Hook for `exec_file_command' command to call.  */
end_comment

begin_function_decl
specifier|extern
name|void
function_decl|(
modifier|*
name|exec_file_display_hook
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|unshared_text_start
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* extended header from exec file (for shared library info) */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|exec_header
name|exec_header
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|exec_file_command
parameter_list|(
name|filename
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|int
name|val
decl_stmt|;
comment|/* Eliminate all traces of old exec file.      Mark text segment as empty.  */
if|if
condition|(
name|execfile
condition|)
name|free
argument_list|(
name|execfile
argument_list|)
expr_stmt|;
name|execfile
operator|=
literal|0
expr_stmt|;
name|data_start
operator|=
literal|0
expr_stmt|;
name|data_end
operator|-=
name|exec_data_start
expr_stmt|;
name|text_start
operator|=
literal|0
expr_stmt|;
name|unshared_text_start
operator|=
literal|0
expr_stmt|;
name|text_end
operator|=
literal|0
expr_stmt|;
name|exec_data_start
operator|=
literal|0
expr_stmt|;
name|exec_data_end
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|execchan
operator|>=
literal|0
condition|)
name|close
argument_list|(
name|execchan
argument_list|)
expr_stmt|;
name|execchan
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|shlib
condition|)
block|{
name|close_shared_library
argument_list|(
name|shlib
argument_list|)
expr_stmt|;
name|shlib
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Now open and digest the file the user requested, if any.  */
if|if
condition|(
name|filename
condition|)
block|{
name|filename
operator|=
name|tilde_expand
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|free
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|execchan
operator|=
name|openp
argument_list|(
name|getenv
argument_list|(
literal|"PATH"
argument_list|)
argument_list|,
literal|1
argument_list|,
name|filename
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|,
operator|&
name|execfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|execchan
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
name|filename
argument_list|)
expr_stmt|;
block|{
name|struct
name|stat
name|st_exec
decl_stmt|;
ifdef|#
directive|ifdef
name|HEADER_SEEK_FD
name|HEADER_SEEK_FD
argument_list|(
name|execchan
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|val
operator|=
name|myread
argument_list|(
name|execchan
argument_list|,
operator|&
name|exec_header
argument_list|,
sizeof|sizeof
name|exec_header
argument_list|)
expr_stmt|;
name|exec_aouthdr
operator|=
name|exec_header
operator|.
name|a_exec
expr_stmt|;
if|if
condition|(
name|val
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|text_start
operator|=
literal|0x8000
expr_stmt|;
comment|/* Look for shared library if needed */
if|if
condition|(
name|exec_header
operator|.
name|a_exec
operator|.
name|a_magic
operator|&
name|MF_USES_SL
condition|)
name|shlib
operator|=
name|open_shared_library
argument_list|(
name|exec_header
operator|.
name|a_shlibname
argument_list|,
name|text_start
argument_list|)
expr_stmt|;
name|text_offset
operator|=
name|N_TXTOFF
argument_list|(
name|exec_aouthdr
argument_list|)
expr_stmt|;
name|exec_data_offset
operator|=
name|N_TXTOFF
argument_list|(
name|exec_aouthdr
argument_list|)
operator|+
name|exec_aouthdr
operator|.
name|a_text
expr_stmt|;
if|if
condition|(
name|shlib
condition|)
block|{
name|unshared_text_start
operator|=
name|shared_text_end
argument_list|(
name|shlib
argument_list|)
operator|&
operator|~
literal|0x7fff
expr_stmt|;
name|stack_start
operator|=
name|shlib
operator|->
name|header
operator|.
name|a_exec
operator|.
name|a_sldatabase
expr_stmt|;
name|stack_end
operator|=
name|STACK_END_ADDR
expr_stmt|;
block|}
else|else
name|unshared_text_start
operator|=
literal|0x8000
expr_stmt|;
name|text_end
operator|=
name|unshared_text_start
operator|+
name|exec_aouthdr
operator|.
name|a_text
expr_stmt|;
name|exec_data_start
operator|=
name|unshared_text_start
operator|+
name|exec_aouthdr
operator|.
name|a_text
expr_stmt|;
name|exec_data_end
operator|=
name|exec_data_start
operator|+
name|exec_aouthdr
operator|.
name|a_data
expr_stmt|;
name|data_start
operator|=
name|exec_data_start
expr_stmt|;
name|data_end
operator|+=
name|exec_data_start
expr_stmt|;
name|fstat
argument_list|(
name|execchan
argument_list|,
operator|&
name|st_exec
argument_list|)
expr_stmt|;
name|exec_mtime
operator|=
name|st_exec
operator|.
name|st_mtime
expr_stmt|;
block|}
name|validate_files
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|from_tty
condition|)
name|printf
argument_list|(
literal|"No exec file now.\n"
argument_list|)
expr_stmt|;
comment|/* Tell display code (if any) about the changed file name.  */
if|if
condition|(
name|exec_file_display_hook
condition|)
call|(
modifier|*
name|exec_file_display_hook
call|)
argument_list|(
name|filename
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Read from the program's memory (except for inferior processes).    This function is misnamed, since it only reads, never writes; and    since it will use the core file and/or executable file as necessary.     It should be extended to write as well as read, FIXME, for patching files.     Return 0 if address could be read, EIO if addresss out of bounds.  */
end_comment

begin_function
name|int
name|xfer_core_file
parameter_list|(
name|memaddr
parameter_list|,
name|myaddr
parameter_list|,
name|len
parameter_list|)
name|CORE_ADDR
name|memaddr
decl_stmt|;
name|char
modifier|*
name|myaddr
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|val
decl_stmt|;
name|int
name|xferchan
decl_stmt|;
name|char
modifier|*
modifier|*
name|xferfile
decl_stmt|;
name|int
name|fileptr
decl_stmt|;
name|int
name|returnval
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|xferfile
operator|=
literal|0
expr_stmt|;
name|xferchan
operator|=
literal|0
expr_stmt|;
comment|/* Determine which file the next bunch of addresses reside in, 	 and where in the file.  Set the file's read/write pointer 	 to point at the proper place for the desired address 	 and set xferfile and xferchan for the correct file.  	 If desired address is nonexistent, leave them zero.  	 i is set to the number of bytes that can be handled 	 along with the next address.  	 We put the most likely tests first for efficiency.  */
comment|/* Note that if there is no core file 	 data_start and data_end are equal.  */
if|if
condition|(
name|memaddr
operator|>=
name|data_start
operator|&&
name|memaddr
operator|<
name|data_end
condition|)
block|{
name|i
operator|=
name|min
argument_list|(
name|len
argument_list|,
name|data_end
operator|-
name|memaddr
argument_list|)
expr_stmt|;
name|fileptr
operator|=
name|memaddr
operator|-
name|data_start
operator|+
name|data_offset
expr_stmt|;
name|xferfile
operator|=
operator|&
name|corefile
expr_stmt|;
name|xferchan
operator|=
name|corechan
expr_stmt|;
block|}
comment|/* Note that if there is no core file 	 stack_start and stack_end define the shared library data.  */
elseif|else
if|if
condition|(
name|memaddr
operator|>=
name|stack_start
operator|&&
name|memaddr
operator|<
name|stack_end
condition|)
block|{
if|if
condition|(
name|corechan
operator|<
literal|0
condition|)
block|{
name|struct
name|shared_library
modifier|*
name|lib
decl_stmt|;
for|for
control|(
name|lib
operator|=
name|shlib
init|;
name|lib
condition|;
name|lib
operator|=
name|lib
operator|->
name|shares
control|)
if|if
condition|(
name|memaddr
operator|>=
name|lib
operator|->
name|header
operator|.
name|a_exec
operator|.
name|a_sldatabase
operator|&&
name|memaddr
operator|<
name|lib
operator|->
name|header
operator|.
name|a_exec
operator|.
name|a_sldatabase
operator|+
name|lib
operator|->
name|header
operator|.
name|a_exec
operator|.
name|a_data
condition|)
break|break;
if|if
condition|(
name|lib
condition|)
block|{
name|i
operator|=
name|min
argument_list|(
name|len
argument_list|,
name|lib
operator|->
name|header
operator|.
name|a_exec
operator|.
name|a_sldatabase
operator|+
name|lib
operator|->
name|header
operator|.
name|a_exec
operator|.
name|a_data
operator|-
name|memaddr
argument_list|)
expr_stmt|;
name|fileptr
operator|=
name|lib
operator|->
name|data_offset
operator|+
name|memaddr
operator|-
name|lib
operator|->
name|header
operator|.
name|a_exec
operator|.
name|a_sldatabase
expr_stmt|;
name|xferfile
operator|=
name|execfile
expr_stmt|;
name|xferchan
operator|=
name|lib
operator|->
name|chan
expr_stmt|;
block|}
block|}
else|else
block|{
name|i
operator|=
name|min
argument_list|(
name|len
argument_list|,
name|stack_end
operator|-
name|memaddr
argument_list|)
expr_stmt|;
name|fileptr
operator|=
name|memaddr
operator|-
name|stack_start
operator|+
name|stack_offset
expr_stmt|;
name|xferfile
operator|=
operator|&
name|corefile
expr_stmt|;
name|xferchan
operator|=
name|corechan
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|corechan
operator|<
literal|0
operator|&&
name|memaddr
operator|>=
name|exec_data_start
operator|&&
name|memaddr
operator|<
name|exec_data_end
condition|)
block|{
name|i
operator|=
name|min
argument_list|(
name|len
argument_list|,
name|exec_data_end
operator|-
name|memaddr
argument_list|)
expr_stmt|;
name|fileptr
operator|=
name|memaddr
operator|-
name|exec_data_start
operator|+
name|exec_data_offset
expr_stmt|;
name|xferfile
operator|=
operator|&
name|execfile
expr_stmt|;
name|xferchan
operator|=
name|execchan
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|memaddr
operator|>=
name|text_start
operator|&&
name|memaddr
operator|<
name|text_end
condition|)
block|{
name|struct
name|shared_library
modifier|*
name|lib
decl_stmt|;
for|for
control|(
name|lib
operator|=
name|shlib
init|;
name|lib
condition|;
name|lib
operator|=
name|lib
operator|->
name|shares
control|)
if|if
condition|(
name|memaddr
operator|>=
name|lib
operator|->
name|text_start
operator|&&
name|memaddr
operator|<
name|lib
operator|->
name|text_start
operator|+
name|lib
operator|->
name|header
operator|.
name|a_exec
operator|.
name|a_text
condition|)
break|break;
if|if
condition|(
name|lib
condition|)
block|{
name|i
operator|=
name|min
argument_list|(
name|len
argument_list|,
name|lib
operator|->
name|header
operator|.
name|a_exec
operator|.
name|a_text
operator|+
name|lib
operator|->
name|text_start
operator|-
name|memaddr
argument_list|)
expr_stmt|;
name|fileptr
operator|=
name|memaddr
operator|-
name|lib
operator|->
name|text_start
operator|+
name|text_offset
expr_stmt|;
name|xferfile
operator|=
operator|&
name|execfile
expr_stmt|;
name|xferchan
operator|=
name|lib
operator|->
name|chan
expr_stmt|;
block|}
else|else
block|{
name|i
operator|=
name|min
argument_list|(
name|len
argument_list|,
name|text_end
operator|-
name|memaddr
argument_list|)
expr_stmt|;
name|fileptr
operator|=
name|memaddr
operator|-
name|unshared_text_start
operator|+
name|text_offset
expr_stmt|;
name|xferfile
operator|=
operator|&
name|execfile
expr_stmt|;
name|xferchan
operator|=
name|execchan
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|memaddr
operator|<
name|text_start
condition|)
block|{
name|i
operator|=
name|min
argument_list|(
name|len
argument_list|,
name|text_start
operator|-
name|memaddr
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|memaddr
operator|>=
name|text_end
operator|&&
name|memaddr
operator|<
operator|(
name|corechan
operator|>=
literal|0
condition|?
name|data_start
else|:
name|exec_data_start
operator|)
condition|)
block|{
name|i
operator|=
name|min
argument_list|(
name|len
argument_list|,
name|data_start
operator|-
name|memaddr
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|corechan
operator|>=
literal|0
operator|&&
name|memaddr
operator|>=
name|data_end
operator|&&
name|memaddr
operator|<
name|stack_start
condition|)
block|{
name|i
operator|=
name|min
argument_list|(
name|len
argument_list|,
name|stack_start
operator|-
name|memaddr
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|corechan
operator|<
literal|0
operator|&&
name|memaddr
operator|>=
name|exec_data_end
condition|)
block|{
name|i
operator|=
name|min
argument_list|(
name|len
argument_list|,
operator|-
name|memaddr
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|memaddr
operator|>=
name|stack_end
operator|&&
name|stack_end
operator|!=
literal|0
condition|)
block|{
name|i
operator|=
name|min
argument_list|(
name|len
argument_list|,
operator|-
name|memaddr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Address did not classify into one of the known ranges. 	     This shouldn't happen; we catch the endpoints.  */
name|fatal
argument_list|(
literal|"Internal: Bad case logic in xfer_core_file."
argument_list|)
expr_stmt|;
block|}
comment|/* Now we know which file to use. 	 Set up its pointer and transfer the data.  */
if|if
condition|(
name|xferfile
condition|)
block|{
if|if
condition|(
operator|*
name|xferfile
operator|==
literal|0
condition|)
if|if
condition|(
name|xferfile
operator|==
operator|&
name|execfile
condition|)
name|error
argument_list|(
literal|"No program file to examine."
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"No core dump file or running program to examine."
argument_list|)
expr_stmt|;
name|val
operator|=
name|lseek
argument_list|(
name|xferchan
argument_list|,
name|fileptr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
operator|*
name|xferfile
argument_list|)
expr_stmt|;
name|val
operator|=
name|myread
argument_list|(
name|xferchan
argument_list|,
name|myaddr
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
operator|*
name|xferfile
argument_list|)
expr_stmt|;
block|}
comment|/* If this address is for nonexistent memory, 	 read zeros if reading, or do nothing if writing. 	 Actually, we never right.  */
else|else
block|{
name|bzero
argument_list|(
name|myaddr
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|returnval
operator|=
name|EIO
expr_stmt|;
block|}
name|memaddr
operator|+=
name|i
expr_stmt|;
name|myaddr
operator|+=
name|i
expr_stmt|;
name|len
operator|-=
name|i
expr_stmt|;
block|}
return|return
name|returnval
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* APCS (ARM procedure call standard) defines the following prologue:     mov		ip, sp   [stmfd	sp!, {a1,a2,a3,a4}]    stmfd	sp!, {...,fp,ip,lr,pc}   [stfe		f7, [sp, #-12]!]   [stfe		f6, [sp, #-12]!]   [stfe		f5, [sp, #-12]!]   [stfe		f4, [sp, #-12]!]    sub		fp, ip, #nn	// nn == 20 or 4 depending on second ins */
end_comment

begin_function
name|CORE_ADDR
name|skip_prologue
parameter_list|(
name|pc
parameter_list|)
name|CORE_ADDR
name|pc
decl_stmt|;
block|{
name|union
name|insn_fmt
name|op
decl_stmt|;
name|CORE_ADDR
name|skip_pc
init|=
name|pc
decl_stmt|;
name|op
operator|.
name|ins
operator|=
name|read_memory_integer
argument_list|(
name|skip_pc
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* look for the "mov ip,sp" */
if|if
condition|(
name|op
operator|.
name|generic
operator|.
name|type
operator|!=
name|TYPE_ARITHMETIC
operator|||
name|op
operator|.
name|arith
operator|.
name|opcode
operator|!=
name|OPCODE_MOV
operator|||
name|op
operator|.
name|arith
operator|.
name|dest
operator|!=
name|SPTEMP
operator|||
name|op
operator|.
name|arith
operator|.
name|operand2
operator|!=
name|SP
condition|)
return|return
name|pc
return|;
name|skip_pc
operator|+=
literal|4
expr_stmt|;
comment|/* skip the "stmfd sp!,{a1,a2,a3,a4}" if its there */
name|op
operator|.
name|ins
operator|=
name|read_memory_integer
argument_list|(
name|skip_pc
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|.
name|generic
operator|.
name|type
operator|==
name|TYPE_BLOCK_BRANCH
operator|&&
name|op
operator|.
name|generic
operator|.
name|subtype
operator|==
name|SUBTYPE_BLOCK
operator|&&
name|op
operator|.
name|block
operator|.
name|mask
operator|==
literal|0xf
operator|&&
name|op
operator|.
name|block
operator|.
name|base
operator|==
name|SP
operator|&&
name|op
operator|.
name|block
operator|.
name|is_load
operator|==
literal|0
operator|&&
name|op
operator|.
name|block
operator|.
name|writeback
operator|==
literal|1
operator|&&
name|op
operator|.
name|block
operator|.
name|increment
operator|==
literal|0
operator|&&
name|op
operator|.
name|block
operator|.
name|before
operator|==
literal|1
condition|)
name|skip_pc
operator|+=
literal|4
expr_stmt|;
comment|/* skip the "stmfd sp!,{...,fp,ip,lr,pc} */
name|op
operator|.
name|ins
operator|=
name|read_memory_integer
argument_list|(
name|skip_pc
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|.
name|generic
operator|.
name|type
operator|!=
name|TYPE_BLOCK_BRANCH
operator|||
name|op
operator|.
name|generic
operator|.
name|subtype
operator|!=
name|SUBTYPE_BLOCK
operator|||
comment|/* the mask should look like 110110xxxxxx0000 */
operator|(
name|op
operator|.
name|block
operator|.
name|mask
operator|&
literal|0xd800
operator|)
operator|!=
literal|0xd800
operator|||
name|op
operator|.
name|block
operator|.
name|base
operator|!=
name|SP
operator|||
name|op
operator|.
name|block
operator|.
name|is_load
operator|!=
literal|0
operator|||
name|op
operator|.
name|block
operator|.
name|writeback
operator|!=
literal|1
operator|||
name|op
operator|.
name|block
operator|.
name|increment
operator|!=
literal|0
operator|||
name|op
operator|.
name|block
operator|.
name|before
operator|!=
literal|1
condition|)
return|return
name|pc
return|;
name|skip_pc
operator|+=
literal|4
expr_stmt|;
comment|/* check for "sub fp,ip,#nn" */
name|op
operator|.
name|ins
operator|=
name|read_memory_integer
argument_list|(
name|skip_pc
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|.
name|generic
operator|.
name|type
operator|!=
name|TYPE_ARITHMETIC
operator|||
name|op
operator|.
name|arith
operator|.
name|opcode
operator|!=
name|OPCODE_SUB
operator|||
name|op
operator|.
name|arith
operator|.
name|dest
operator|!=
name|FP
operator|||
name|op
operator|.
name|arith
operator|.
name|operand1
operator|!=
name|SPTEMP
condition|)
return|return
name|pc
return|;
return|return
name|skip_pc
operator|+
literal|4
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_fpu_flags
parameter_list|(
name|flags
parameter_list|)
name|int
name|flags
decl_stmt|;
block|{
if|if
condition|(
name|flags
operator|&
operator|(
literal|1
operator|<<
literal|0
operator|)
condition|)
name|fputs
argument_list|(
literal|"IVO "
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
operator|(
literal|1
operator|<<
literal|1
operator|)
condition|)
name|fputs
argument_list|(
literal|"DVZ "
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
operator|(
literal|1
operator|<<
literal|2
operator|)
condition|)
name|fputs
argument_list|(
literal|"OFL "
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
operator|(
literal|1
operator|<<
literal|3
operator|)
condition|)
name|fputs
argument_list|(
literal|"UFL "
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
operator|(
literal|1
operator|<<
literal|4
operator|)
condition|)
name|fputs
argument_list|(
literal|"INX "
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|arm_float_info
parameter_list|()
block|{
specifier|register
name|unsigned
name|long
name|status
init|=
name|read_register
argument_list|(
name|FPS_REGNUM
argument_list|)
decl_stmt|;
name|int
name|type
decl_stmt|;
name|type
operator|=
operator|(
name|status
operator|>>
literal|24
operator|)
operator|&
literal|127
expr_stmt|;
name|printf
argument_list|(
literal|"%s FPU type %d\n"
argument_list|,
operator|(
name|status
operator|&
operator|(
literal|1
operator|<<
literal|31
operator|)
operator|)
condition|?
literal|"Hardware"
else|:
literal|"Software"
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"mask: "
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|print_fpu_flags
argument_list|(
name|status
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"flags: "
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|print_fpu_flags
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

