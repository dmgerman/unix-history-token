begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Machine-dependent code which would otherwise be in inflow.c and core.c,    for GDB, the GNU debugger.  This code is for the HP PA-RISC cpu.    Copyright 1986, 1987, 1989, 1990, 1991, 1992 Free Software Foundation, Inc.     Contributed by the Center for Software Science at the    University of Utah (pa-gdb-bugs@cs.utah.edu).  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_comment
comment|/* For argument passing to the inferior */
end_comment

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|USG
end_ifdef

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/dir.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|COFF_ENCAPSULATE
end_ifdef

begin_include
include|#
directive|include
file|"a.out.encap.h"
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<a.out.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|N_SET_MAGIC
end_ifndef

begin_define
define|#
directive|define
name|N_SET_MAGIC
parameter_list|(
name|exec
parameter_list|,
name|val
parameter_list|)
value|((exec).a_magic = (val))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*#include<sys/user.h>		After a.out.h  */
end_comment

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<machine/psl.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|KERNELDEBUG
end_ifdef

begin_include
include|#
directive|include
file|<sys/vmmac.h>
end_include

begin_include
include|#
directive|include
file|<machine/machparam.h>
end_include

begin_include
include|#
directive|include
file|<machine/vmparam.h>
end_include

begin_include
include|#
directive|include
file|<machine/pde.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpu.h>
end_include

begin_include
include|#
directive|include
file|<machine/iomod.h>
end_include

begin_include
include|#
directive|include
file|<machine/pcb.h>
end_include

begin_include
include|#
directive|include
file|<machine/rpb.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_decl_stmt
specifier|extern
name|int
name|kernel_debugging
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|CORE_ADDR
name|startup_file_start
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|CORE_ADDR
name|startup_file_end
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|KERNOFF
value|((unsigned)KERNBASE)
end_define

begin_define
define|#
directive|define
name|INKERNEL
parameter_list|(
name|x
parameter_list|)
value|((x)>= KERNOFF&& (x)< KERNOFF + ctob(slr))
end_define

begin_function_decl
specifier|static
name|int
name|ok_to_cache
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|set_kernel_boundaries
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|devmem
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|vtophys_ready
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|kerneltype
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|OS_BSD
value|1
end_define

begin_define
define|#
directive|define
name|OS_MACH
value|2
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Last modification time of executable file.    Also used in source.c to compare against mtime of a source file.  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|exec_mtime
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Virtual addresses of bounds of the two areas of memory in the core file.  */
end_comment

begin_comment
comment|/* extern CORE_ADDR data_start; */
end_comment

begin_decl_stmt
specifier|extern
name|CORE_ADDR
name|data_end
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|CORE_ADDR
name|stack_start
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|CORE_ADDR
name|stack_end
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Virtual addresses of bounds of two areas of memory in the exec file.    Note that the data area in the exec file is used only when there is no core file.  */
end_comment

begin_decl_stmt
specifier|extern
name|CORE_ADDR
name|text_start
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|CORE_ADDR
name|text_end
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|CORE_ADDR
name|exec_data_start
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|CORE_ADDR
name|exec_data_end
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Address in executable file of start of text area data.  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|text_offset
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Address in executable file of start of data area data.  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|exec_data_offset
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Address in core file of start of data area data.  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|data_offset
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Address in core file of start of stack area data.  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|stack_offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|header
name|file_hdr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|som_exec_auxhdr
name|exec_hdr
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|KERNELDEBUG
end_ifdef

begin_comment
comment|/*  * Kernel debugging routines.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|pcb
name|pcb
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|pde
modifier|*
name|pdir
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|hte
modifier|*
name|htbl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int
name|npdir
decl_stmt|,
name|nhtbl
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|CORE_ADDR
name|ksym_lookup
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|lookup_misc_func
argument_list|(
name|name
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"kernel symbol `%s' not found."
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|misc_function_vector
index|[
name|i
index|]
operator|.
name|address
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * (re-)set the variables that tell "inside_entry_file" where to end  * a stack backtrace.  */
end_comment

begin_function
name|void
name|set_kernel_boundaries
parameter_list|()
block|{
switch|switch
condition|(
name|kerneltype
condition|)
block|{
case|case
name|OS_MACH
case|:
name|startup_file_start
operator|=
name|ksym_lookup
argument_list|(
literal|"$syscall"
argument_list|)
expr_stmt|;
name|startup_file_end
operator|=
name|ksym_lookup
argument_list|(
literal|"trap"
argument_list|)
expr_stmt|;
break|break;
case|case
name|OS_BSD
case|:
name|startup_file_start
operator|=
name|ksym_lookup
argument_list|(
literal|"syscallinit"
argument_list|)
expr_stmt|;
name|startup_file_end
operator|=
name|ksym_lookup
argument_list|(
literal|"$syscallexit"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * return true if 'len' bytes starting at 'addr' can be read out as  * longwords and/or locally cached (this is mostly for memory mapped  * i/o register access when debugging remote kernels).  */
end_comment

begin_function
specifier|static
name|int
name|ok_to_cache
parameter_list|(
name|addr
parameter_list|,
name|len
parameter_list|)
block|{
specifier|static
name|CORE_ADDR
name|ioptr
decl_stmt|;
if|if
condition|(
operator|!
name|ioptr
condition|)
name|ioptr
operator|=
name|ksym_lookup
argument_list|(
literal|"ioptr"
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|>=
name|ioptr
operator|&&
name|addr
operator|<
name|SPA_HIGH
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_expr_stmt
specifier|static
name|physrd
argument_list|(
argument|addr
argument_list|,
argument|dat
argument_list|,
argument|len
argument_list|)
name|u_int
name|addr
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
modifier|*
name|dat
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|lseek
argument_list|(
name|corechan
argument_list|,
name|addr
argument_list|,
name|L_SET
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|read
argument_list|(
name|corechan
argument_list|,
name|dat
argument_list|,
name|len
argument_list|)
operator|!=
name|len
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * When looking at kernel data space through /dev/mem or with a core file, do  * virtual memory mapping.  */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|vtophys
parameter_list|(
name|space
parameter_list|,
name|addr
parameter_list|)
name|unsigned
name|space
decl_stmt|;
name|CORE_ADDR
name|addr
decl_stmt|;
block|{
name|struct
name|pde
modifier|*
name|pptr
decl_stmt|;
name|u_int
name|hindx
decl_stmt|,
name|vpageno
decl_stmt|,
name|ppageno
decl_stmt|;
name|CORE_ADDR
name|phys
init|=
operator|~
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|vtophys_ready
condition|)
block|{
name|phys
operator|=
name|addr
expr_stmt|;
comment|/* XXX for kvread */
block|}
elseif|else
if|if
condition|(
name|kerneltype
operator|==
name|OS_BSD
condition|)
block|{
comment|/* make offset into a virtual page no */
name|vpageno
operator|=
name|btop
argument_list|(
name|addr
argument_list|)
expr_stmt|;
comment|/* 		 *  Determine index into hash table, initialize pptr to this 		 *  entry (since first word of pte& hte are same), and set 		 *  physical page number for first entry in chain. 		 */
name|hindx
operator|=
name|pdirhash
argument_list|(
name|space
argument_list|,
name|addr
argument_list|)
operator|&
operator|(
name|nhtbl
operator|-
literal|1
operator|)
expr_stmt|;
name|pptr
operator|=
operator|(
expr|struct
name|pde
operator|*
operator|)
operator|&
name|htbl
index|[
name|hindx
index|]
expr_stmt|;
name|ppageno
operator|=
name|pptr
operator|->
name|pde_next
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|pptr
operator|->
name|pde_end
condition|)
break|break;
name|pptr
operator|=
operator|&
name|pdir
index|[
name|ppageno
index|]
expr_stmt|;
comment|/* 			 *  If space id& virtual page number match, return 			 *  "next PDIR entry of previous PDIR entry" as the 			 *  physical page or'd with offset into page. 			 */
if|if
condition|(
name|pptr
operator|->
name|pde_space
operator|==
name|space
operator|&&
name|pptr
operator|->
name|pde_page
operator|==
name|vpageno
condition|)
block|{
name|phys
operator|=
call|(
name|CORE_ADDR
call|)
argument_list|(
operator|(
name|u_int
operator|)
name|ptob
argument_list|(
name|ppageno
argument_list|)
operator||
operator|(
name|addr
operator|&
name|PGOFSET
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|ppageno
operator|=
name|pptr
operator|->
name|pde_next
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|MACHKERNELDEBUG
elseif|else
if|if
condition|(
name|kerneltype
operator|==
name|OS_MACH
condition|)
block|{
name|mach_vtophys
argument_list|(
name|space
argument_list|,
name|addr
argument_list|,
operator|&
name|phys
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|#
directive|if
literal|0
block|printf("vtophys(%x.%x) -> %x\n", space, addr, phys);
endif|#
directive|endif
return|return
operator|(
name|phys
operator|)
return|;
block|}
end_function

begin_expr_stmt
specifier|static
name|kvread
argument_list|(
argument|addr
argument_list|)
name|CORE_ADDR
name|addr
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|CORE_ADDR
name|paddr
decl_stmt|;
name|paddr
operator|=
name|vtophys
argument_list|(
literal|0
argument_list|,
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|paddr
operator|!=
operator|~
literal|0
condition|)
if|if
condition|(
name|physrd
argument_list|(
name|paddr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|addr
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|addr
operator|)
return|;
return|return
operator|(
operator|~
literal|0
operator|)
return|;
block|}
end_block

begin_function
specifier|static
name|void
name|read_pcb
parameter_list|(
name|addr
parameter_list|)
name|u_int
name|addr
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|off
decl_stmt|;
specifier|extern
name|char
name|registers
index|[]
decl_stmt|;
specifier|static
name|int
name|reg2pcb
index|[]
init|=
block|{
comment|/* RPB */
operator|-
literal|1
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|7
block|,
literal|8
block|,
literal|9
block|,
literal|10
block|,
literal|11
block|,
literal|12
block|,
literal|13
block|,
literal|14
block|,
literal|15
block|,
literal|16
block|,
literal|17
block|,
literal|18
block|,
literal|19
block|,
literal|20
block|,
literal|21
block|,
literal|22
block|,
literal|23
block|,
literal|24
block|,
literal|25
block|,
literal|26
block|,
literal|27
block|,
literal|28
block|,
literal|29
block|,
literal|30
block|,
literal|31
block|,
literal|32
block|,
literal|33
block|,
literal|45
block|,
literal|52
block|,
literal|51
block|,
literal|75
block|,
literal|74
block|,
literal|49
block|,
literal|53
block|,
literal|54
block|,
literal|55
block|,
literal|56
block|,
operator|-
literal|1
block|,
literal|70
block|,
literal|66
block|,
literal|67
block|,
literal|68
block|,
literal|69
block|,
literal|71
block|,
literal|72
block|,
literal|73
block|,
literal|34
block|,
literal|42
block|,
literal|43
block|,
literal|44
block|,
literal|46
block|,
literal|47
block|,
literal|58
block|,
literal|59
block|,
literal|60
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
comment|/* BSD */
operator|-
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|7
block|,
literal|8
block|,
literal|9
block|,
literal|10
block|,
literal|11
block|,
literal|12
block|,
literal|13
block|,
literal|14
block|,
literal|15
block|,
literal|16
block|,
literal|17
block|,
literal|18
block|,
literal|19
block|,
literal|20
block|,
literal|21
block|,
literal|22
block|,
literal|23
block|,
literal|24
block|,
literal|25
block|,
literal|26
block|,
literal|27
block|,
literal|28
block|,
literal|29
block|,
literal|30
block|,
literal|43
block|,
literal|64
block|,
literal|67
block|,
literal|68
block|,
literal|67
block|,
literal|47
block|,
literal|51
block|,
literal|52
block|,
literal|53
block|,
literal|54
block|,
operator|-
literal|1
block|,
literal|35
block|,
literal|31
block|,
literal|32
block|,
literal|33
block|,
literal|34
block|,
literal|36
block|,
literal|37
block|,
literal|38
block|,
literal|39
block|,
literal|40
block|,
literal|41
block|,
literal|42
block|,
literal|44
block|,
literal|45
block|,
literal|56
block|,
literal|57
block|,
literal|58
block|,
literal|102
block|,
literal|103
block|,
literal|104
block|,
operator|-
literal|1
block|,
literal|70
block|,
literal|71
block|,
literal|72
block|,
literal|73
block|,
literal|74
block|,
literal|75
block|,
literal|76
block|,
literal|77
block|,
literal|78
block|,
literal|80
block|,
literal|82
block|,
literal|84
block|,
literal|86
block|,
literal|88
block|,
literal|90
block|,
literal|92
block|,
literal|94
block|,
literal|96
block|,
literal|98
block|,
literal|100
block|,
comment|/* Mach */
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|7
block|,
literal|8
block|,
literal|9
block|,
literal|10
block|,
literal|11
block|,
literal|12
block|,
literal|13
block|,
literal|14
block|,
literal|15
block|,
literal|16
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|17
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|18
block|,
operator|-
literal|1
block|,
literal|25
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|30
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|20
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|19
block|,
literal|21
block|,
literal|22
block|,
literal|23
block|,
literal|24
block|,
literal|26
block|,
literal|27
block|,
operator|-
literal|1
block|,
literal|28
block|,
literal|29
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|34
block|,
literal|35
block|,
literal|36
block|,
literal|37
block|,
literal|38
block|,
literal|39
block|,
literal|40
block|,
literal|41
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|42
block|,
literal|44
block|,
literal|46
block|,
literal|48
block|}
decl_stmt|;
specifier|static
name|struct
name|rpb
modifier|*
name|rpbaddr
init|=
operator|(
expr|struct
name|rpb
operator|*
operator|)
literal|0
decl_stmt|;
specifier|static
name|u_int
name|rpbpcbaddr
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|remote_debugging
condition|)
block|{
comment|/* 		 * If we are debugging a post-mortem and this is the first 		 * call of read_pcb, read the RPB.  Also assoicate the 		 * thread/proc running at the time with the RPB. 		 */
if|if
condition|(
operator|!
name|devmem
operator|&&
name|rpbpcbaddr
operator|==
literal|0
condition|)
block|{
name|CORE_ADDR
name|raddr
init|=
name|ksym_lookup
argument_list|(
literal|"rpb"
argument_list|)
decl_stmt|;
name|int
name|usepcb
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|raddr
operator|!=
operator|~
literal|0
condition|)
block|{
name|rpbaddr
operator|=
operator|(
expr|struct
name|rpb
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|rpbaddr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|physrd
argument_list|(
name|raddr
argument_list|,
operator|(
name|char
operator|*
operator|)
name|rpbaddr
argument_list|,
sizeof|sizeof
expr|*
name|rpbaddr
argument_list|)
condition|)
block|{
name|rpbpcbaddr
operator|=
name|addr
expr_stmt|;
name|usepcb
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|usepcb
condition|)
block|{
name|error
argument_list|(
literal|"cannot read rpb, using pcb for registers\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rpbaddr
condition|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|rpbaddr
argument_list|)
expr_stmt|;
name|rpbpcbaddr
operator|=
operator|~
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|physrd
argument_list|(
name|addr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|pcb
argument_list|,
sizeof|sizeof
name|pcb
argument_list|)
condition|)
name|error
argument_list|(
literal|"cannot read pcb at %x.\n"
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|remote_read_inferior_memory
argument_list|(
name|addr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|pcb
argument_list|,
sizeof|sizeof
name|pcb
argument_list|)
condition|)
name|error
argument_list|(
literal|"cannot read pcb at %x.\n"
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|kerneltype
operator|==
name|OS_BSD
condition|)
block|{
name|printf
argument_list|(
literal|"p0br %lx p0lr %lx p1br %lx p1lr %lx\n"
argument_list|,
name|pcb
operator|.
name|pcb_p0br
argument_list|,
name|pcb
operator|.
name|pcb_p0lr
argument_list|,
name|pcb
operator|.
name|pcb_p1br
argument_list|,
name|pcb
operator|.
name|pcb_p1lr
argument_list|)
expr_stmt|;
name|off
operator|=
name|NUM_REGS
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"pcb %lx psw %lx ksp %lx\n"
argument_list|,
name|addr
argument_list|,
operator|(
operator|(
name|int
operator|*
operator|)
operator|&
name|pcb
operator|)
index|[
literal|31
index|]
argument_list|,
operator|(
operator|(
name|int
operator|*
operator|)
operator|&
name|pcb
operator|)
index|[
literal|32
index|]
argument_list|)
expr_stmt|;
name|off
operator|=
name|NUM_REGS
operator|*
literal|2
expr_stmt|;
block|}
comment|/* 	 * get the register values out of the sys pcb and 	 * store them where `read_register' will find them. 	 */
name|bzero
argument_list|(
name|registers
argument_list|,
name|REGISTER_BYTES
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_REGS
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|reg2pcb
index|[
name|i
operator|+
name|off
index|]
operator|!=
operator|-
literal|1
condition|)
name|supply_register
argument_list|(
name|i
argument_list|,
operator|&
operator|(
operator|(
name|int
operator|*
operator|)
operator|&
name|pcb
operator|)
index|[
name|reg2pcb
index|[
name|i
operator|+
name|off
index|]
index|]
argument_list|)
expr_stmt|;
comment|/* 	 * If the RPB is valid for this thread/proc use the register values 	 * contained there. 	 */
if|if
condition|(
name|addr
operator|==
name|rpbpcbaddr
condition|)
block|{
name|off
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_REGS
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|reg2pcb
index|[
name|i
operator|+
name|off
index|]
operator|!=
operator|-
literal|1
condition|)
name|supply_register
argument_list|(
name|i
argument_list|,
operator|&
operator|(
operator|(
name|int
operator|*
operator|)
name|rpbaddr
operator|)
index|[
name|reg2pcb
index|[
name|i
operator|+
name|off
index|]
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|setup_kernel_debugging
parameter_list|()
block|{
name|struct
name|stat
name|stb
decl_stmt|;
name|CORE_ADDR
name|addr
decl_stmt|;
name|fstat
argument_list|(
name|corechan
argument_list|,
operator|&
name|stb
argument_list|)
expr_stmt|;
name|devmem
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|stb
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|==
name|S_IFCHR
operator|&&
name|stb
operator|.
name|st_rdev
operator|==
name|makedev
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|)
condition|)
name|devmem
operator|=
literal|1
expr_stmt|;
comment|/* XXX */
if|if
condition|(
name|lookup_misc_func
argument_list|(
literal|"Sysmap"
argument_list|)
operator|<
literal|0
condition|)
name|kerneltype
operator|=
name|OS_MACH
expr_stmt|;
else|else
name|kerneltype
operator|=
name|OS_BSD
expr_stmt|;
if|if
condition|(
name|kerneltype
operator|==
name|OS_BSD
condition|)
block|{
name|int
name|len
decl_stmt|,
name|err
init|=
literal|0
decl_stmt|;
comment|/* 		 * Hash table and PDIR are equivalently mapped 		 */
name|nhtbl
operator|=
name|kvread
argument_list|(
name|ksym_lookup
argument_list|(
literal|"nhtbl"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nhtbl
operator|!=
operator|~
literal|0
condition|)
block|{
name|len
operator|=
name|nhtbl
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|htbl
argument_list|)
expr_stmt|;
name|htbl
operator|=
operator|(
expr|struct
name|hte
operator|*
operator|)
name|malloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|htbl
condition|)
block|{
name|addr
operator|=
name|kvread
argument_list|(
name|ksym_lookup
argument_list|(
literal|"htbl"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|physrd
argument_list|(
name|addr
argument_list|,
operator|(
name|char
operator|*
operator|)
name|htbl
argument_list|,
name|len
argument_list|)
condition|)
name|err
operator|++
expr_stmt|;
block|}
else|else
name|err
operator|++
expr_stmt|;
block|}
else|else
name|err
operator|++
expr_stmt|;
name|npdir
operator|=
name|kvread
argument_list|(
name|ksym_lookup
argument_list|(
literal|"npdir"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|npdir
operator|!=
operator|~
literal|0
condition|)
block|{
name|len
operator|=
name|npdir
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|pdir
argument_list|)
expr_stmt|;
name|pdir
operator|=
operator|(
expr|struct
name|pde
operator|*
operator|)
name|malloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|pdir
condition|)
block|{
name|addr
operator|=
name|kvread
argument_list|(
name|ksym_lookup
argument_list|(
literal|"pdir"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|physrd
argument_list|(
name|addr
argument_list|,
operator|(
name|char
operator|*
operator|)
name|pdir
argument_list|,
name|len
argument_list|)
condition|)
name|err
operator|++
expr_stmt|;
block|}
else|else
name|err
operator|++
expr_stmt|;
block|}
else|else
name|err
operator|++
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|error
argument_list|(
literal|"cannot read PDIR/HTBL"
argument_list|)
expr_stmt|;
return|return;
block|}
name|vtophys_ready
operator|=
literal|1
expr_stmt|;
comment|/* 		 * pcb where "panic" saved registers in first thing in 		 * current u-area.  The current u-area is pointed to by 		 * "uptr". 		 */
name|addr
operator|=
name|kvread
argument_list|(
name|ksym_lookup
argument_list|(
literal|"uptr"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|==
operator|~
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"cannot read current u-area address"
argument_list|)
expr_stmt|;
return|return;
block|}
name|read_pcb
argument_list|(
name|vtophys
argument_list|(
literal|0
argument_list|,
name|addr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* XXX space */
if|if
condition|(
operator|!
name|devmem
condition|)
block|{
comment|/* find stack frame */
name|CORE_ADDR
name|panicstr
decl_stmt|;
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|panicstr
operator|=
name|kvread
argument_list|(
name|ksym_lookup
argument_list|(
literal|"panicstr"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|panicstr
operator|==
operator|~
literal|0
condition|)
return|return;
name|kernel_core_file_hook
argument_list|(
name|panicstr
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|buf
init|;
name|cp
operator|<
operator|&
name|buf
index|[
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
index|]
operator|&&
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
if|if
condition|(
operator|!
name|isascii
argument_list|(
operator|*
name|cp
argument_list|)
operator|||
operator|(
operator|!
name|isprint
argument_list|(
operator|*
name|cp
argument_list|)
operator|&&
operator|!
name|isspace
argument_list|(
operator|*
name|cp
argument_list|)
operator|)
condition|)
operator|*
name|cp
operator|=
literal|'?'
expr_stmt|;
if|if
condition|(
operator|*
name|cp
condition|)
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
name|printf
argument_list|(
literal|"panic: %s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|MACHKERNELDEBUG
else|else
block|{
name|int
modifier|*
name|thread
decl_stmt|;
comment|/* 		 * Set up address translation 		 */
if|if
condition|(
name|mach_vtophys_init
argument_list|()
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"cannot initialize vtophys for Mach"
argument_list|)
expr_stmt|;
return|return;
block|}
name|vtophys_ready
operator|=
literal|1
expr_stmt|;
comment|/* 		 * Locate active thread and read PCB 		 * XXX MAJOR HACK 		 *	- assumes uni-processor 		 *	- assumes position of pcb to avoid mach includes 		 */
name|thread
operator|=
operator|(
name|int
operator|*
operator|)
name|kvread
argument_list|(
name|ksym_lookup
argument_list|(
literal|"active_threads"
argument_list|)
argument_list|)
expr_stmt|;
name|addr
operator|=
name|kvread
argument_list|(
operator|&
name|thread
index|[
literal|9
index|]
argument_list|)
expr_stmt|;
comment|/* XXX: pcb addr */
name|read_pcb
argument_list|(
name|vtophys
argument_list|(
literal|0
argument_list|,
name|addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_macro
name|vtop_command
argument_list|(
argument|arg
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|arg
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|u_int
name|sp
decl_stmt|,
name|off
decl_stmt|,
name|pa
decl_stmt|;
if|if
condition|(
operator|!
name|arg
condition|)
name|error_no_arg
argument_list|(
literal|"kernel virtual address"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|kernel_debugging
condition|)
name|error
argument_list|(
literal|"not debugging kernel"
argument_list|)
expr_stmt|;
name|sp
operator|=
literal|0
expr_stmt|;
comment|/* XXX */
name|off
operator|=
operator|(
name|u_int
operator|)
name|parse_and_eval_address
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|pa
operator|=
name|vtophys
argument_list|(
name|sp
argument_list|,
name|off
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%lx.%lx -> "
argument_list|,
name|sp
argument_list|,
name|off
argument_list|)
expr_stmt|;
if|if
condition|(
name|pa
operator|==
operator|~
literal|0
condition|)
name|printf
argument_list|(
literal|"<invalid>\n"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%lx\n"
argument_list|,
name|pa
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|set_paddr_command
argument_list|(
argument|arg
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|arg
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|u_int
name|addr
decl_stmt|;
if|if
condition|(
operator|!
name|arg
condition|)
block|{
if|if
condition|(
name|kerneltype
operator|==
name|OS_BSD
condition|)
name|error_no_arg
argument_list|(
literal|"ps-style address for new process"
argument_list|)
expr_stmt|;
else|else
name|error_no_arg
argument_list|(
literal|"thread structure virtual address"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|kernel_debugging
condition|)
name|error
argument_list|(
literal|"not debugging kernel"
argument_list|)
expr_stmt|;
name|addr
operator|=
operator|(
name|u_int
operator|)
name|parse_and_eval_address
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|kerneltype
operator|==
name|OS_BSD
condition|)
name|addr
operator|=
name|ctob
argument_list|(
name|addr
argument_list|)
expr_stmt|;
else|else
block|{
name|addr
operator|=
name|kvread
argument_list|(
operator|&
operator|(
operator|(
operator|(
name|int
operator|*
operator|)
name|addr
operator|)
index|[
literal|9
index|]
operator|)
argument_list|)
expr_stmt|;
comment|/* XXX: pcb addr */
name|addr
operator|=
name|vtophys
argument_list|(
literal|0
argument_list|,
name|addr
argument_list|)
expr_stmt|;
comment|/* XXX space */
block|}
name|read_pcb
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|flush_cached_frames
argument_list|()
expr_stmt|;
name|set_current_frame
argument_list|(
name|create_new_frame
argument_list|(
name|read_register
argument_list|(
name|FP_REGNUM
argument_list|)
argument_list|,
name|read_pc
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|select_frame
argument_list|(
name|get_current_frame
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * read len bytes from kernel virtual address 'addr' into local   * buffer 'buf'.  Return 0 if read ok, 1 otherwise.  On read  * errors, portion of buffer not read is zeroed.  */
end_comment

begin_macro
name|kernel_core_file_hook
argument_list|(
argument|addr
argument_list|,
argument|buf
argument_list|,
argument|len
argument_list|)
end_macro

begin_decl_stmt
name|CORE_ADDR
name|addr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|buf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|len
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
name|CORE_ADDR
name|paddr
decl_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|paddr
operator|=
name|vtophys
argument_list|(
literal|0
argument_list|,
name|addr
argument_list|)
expr_stmt|;
comment|/* XXX space */
if|if
condition|(
name|paddr
operator|==
operator|~
literal|0
condition|)
block|{
name|bzero
argument_list|(
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* we can't read across a page boundary */
name|i
operator|=
name|min
argument_list|(
name|len
argument_list|,
name|NBPG
operator|-
operator|(
name|addr
operator|&
name|PGOFSET
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|physrd
argument_list|(
name|paddr
argument_list|,
name|buf
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|bzero
argument_list|(
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|buf
operator|+=
name|i
expr_stmt|;
name|addr
operator|+=
name|i
expr_stmt|;
name|len
operator|-=
name|i
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Routines to extract various sized constants out of hppa     instructions. */
end_comment

begin_comment
comment|/* This assumes that no garbage lies outside of the lower bits of     value. */
end_comment

begin_function
name|int
name|sign_extend
parameter_list|(
name|val
parameter_list|,
name|bits
parameter_list|)
name|unsigned
name|val
decl_stmt|,
name|bits
decl_stmt|;
block|{
return|return
call|(
name|int
call|)
argument_list|(
name|val
operator|>>
name|bits
operator|-
literal|1
condition|?
operator|(
operator|-
literal|1
operator|<<
name|bits
operator|)
operator||
name|val
else|:
name|val
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* For many immediate values the sign bit is the low bit! */
end_comment

begin_function
name|int
name|low_sign_extend
parameter_list|(
name|val
parameter_list|,
name|bits
parameter_list|)
name|unsigned
name|val
decl_stmt|,
name|bits
decl_stmt|;
block|{
return|return
call|(
name|int
call|)
argument_list|(
operator|(
name|val
operator|&
literal|0x1
condition|?
operator|(
operator|-
literal|1
operator|<<
operator|(
name|bits
operator|-
literal|1
operator|)
operator|)
else|:
literal|0
operator|)
operator||
name|val
operator|>>
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* extract the immediate field from a ld{bhw}s instruction */
end_comment

begin_function
name|unsigned
name|get_field
parameter_list|(
name|val
parameter_list|,
name|from
parameter_list|,
name|to
parameter_list|)
name|unsigned
name|val
decl_stmt|,
name|from
decl_stmt|,
name|to
decl_stmt|;
block|{
name|val
operator|=
name|val
operator|>>
literal|31
operator|-
name|to
expr_stmt|;
return|return
name|val
operator|&
operator|(
operator|(
literal|1
operator|<<
literal|32
operator|-
name|from
operator|)
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|unsigned
name|set_field
parameter_list|(
name|val
parameter_list|,
name|from
parameter_list|,
name|to
parameter_list|,
name|new_val
parameter_list|)
name|unsigned
modifier|*
name|val
decl_stmt|,
name|from
decl_stmt|,
name|to
decl_stmt|;
block|{
name|unsigned
name|mask
init|=
operator|~
operator|(
operator|(
literal|1
operator|<<
operator|(
name|to
operator|-
name|from
operator|+
literal|1
operator|)
operator|)
operator|<<
operator|(
literal|31
operator|-
name|from
operator|)
operator|)
decl_stmt|;
return|return
operator|*
name|val
operator|=
operator|*
name|val
operator|&
name|mask
operator||
operator|(
name|new_val
operator|<<
operator|(
literal|31
operator|-
name|from
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* extract a 3-bit space register number from a be, ble, mtsp or mfsp */
end_comment

begin_macro
name|extract_3
argument_list|(
argument|word
argument_list|)
end_macro

begin_decl_stmt
name|unsigned
name|word
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
name|GET_FIELD
argument_list|(
name|word
argument_list|,
literal|18
argument_list|,
literal|18
argument_list|)
operator|<<
literal|2
operator||
name|GET_FIELD
argument_list|(
name|word
argument_list|,
literal|16
argument_list|,
literal|17
argument_list|)
return|;
block|}
end_block

begin_macro
name|extract_5_load
argument_list|(
argument|word
argument_list|)
end_macro

begin_decl_stmt
name|unsigned
name|word
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
name|low_sign_extend
argument_list|(
name|word
operator|>>
literal|16
operator|&
name|MASK_5
argument_list|,
literal|5
argument_list|)
return|;
block|}
end_block

begin_comment
comment|/* extract the immediate field from a st{bhw}s instruction */
end_comment

begin_function
name|int
name|extract_5_store
parameter_list|(
name|word
parameter_list|)
name|unsigned
name|word
decl_stmt|;
block|{
return|return
name|low_sign_extend
argument_list|(
name|word
operator|&
name|MASK_5
argument_list|,
literal|5
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* extract an 11 bit immediate field */
end_comment

begin_function
name|int
name|extract_11
parameter_list|(
name|word
parameter_list|)
name|unsigned
name|word
decl_stmt|;
block|{
return|return
name|low_sign_extend
argument_list|(
name|word
operator|&
name|MASK_11
argument_list|,
literal|11
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* extract a 14 bit immediate field */
end_comment

begin_function
name|int
name|extract_14
parameter_list|(
name|word
parameter_list|)
name|unsigned
name|word
decl_stmt|;
block|{
return|return
name|low_sign_extend
argument_list|(
name|word
operator|&
name|MASK_14
argument_list|,
literal|14
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* deposit a 14 bit constant in a word */
end_comment

begin_function
name|unsigned
name|deposit_14
parameter_list|(
name|opnd
parameter_list|,
name|word
parameter_list|)
name|int
name|opnd
decl_stmt|;
name|unsigned
name|word
decl_stmt|;
block|{
name|unsigned
name|sign
init|=
operator|(
name|opnd
operator|<
literal|0
condition|?
literal|1
else|:
literal|0
operator|)
decl_stmt|;
return|return
name|word
operator||
operator|(
operator|(
name|unsigned
operator|)
name|opnd
operator|<<
literal|1
operator|&
name|MASK_14
operator|)
operator||
name|sign
return|;
block|}
end_function

begin_comment
comment|/* extract a 21 bit constant */
end_comment

begin_function
name|int
name|extract_21
parameter_list|(
name|word
parameter_list|)
name|unsigned
name|word
decl_stmt|;
block|{
name|int
name|val
decl_stmt|;
name|word
operator|&=
name|MASK_21
expr_stmt|;
name|word
operator|<<=
literal|11
expr_stmt|;
name|val
operator|=
name|GET_FIELD
argument_list|(
name|word
argument_list|,
literal|20
argument_list|,
literal|20
argument_list|)
expr_stmt|;
name|val
operator|<<=
literal|11
expr_stmt|;
name|val
operator||=
name|GET_FIELD
argument_list|(
name|word
argument_list|,
literal|9
argument_list|,
literal|19
argument_list|)
expr_stmt|;
name|val
operator|<<=
literal|2
expr_stmt|;
name|val
operator||=
name|GET_FIELD
argument_list|(
name|word
argument_list|,
literal|5
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|val
operator|<<=
literal|5
expr_stmt|;
name|val
operator||=
name|GET_FIELD
argument_list|(
name|word
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|val
operator|<<=
literal|2
expr_stmt|;
name|val
operator||=
name|GET_FIELD
argument_list|(
name|word
argument_list|,
literal|7
argument_list|,
literal|8
argument_list|)
expr_stmt|;
return|return
name|sign_extend
argument_list|(
name|val
argument_list|,
literal|21
argument_list|)
operator|<<
literal|11
return|;
block|}
end_function

begin_comment
comment|/* deposit a 21 bit constant in a word. Although 21 bit constants are    usually the top 21 bits of a 32 bit constant, we assume that only    the low 21 bits of opnd are relevant */
end_comment

begin_function
name|unsigned
name|deposit_21
parameter_list|(
name|opnd
parameter_list|,
name|word
parameter_list|)
name|unsigned
name|opnd
decl_stmt|,
name|word
decl_stmt|;
block|{
name|unsigned
name|val
init|=
literal|0
decl_stmt|;
name|val
operator||=
name|GET_FIELD
argument_list|(
name|opnd
argument_list|,
literal|11
operator|+
literal|14
argument_list|,
literal|11
operator|+
literal|18
argument_list|)
expr_stmt|;
name|val
operator|<<=
literal|2
expr_stmt|;
name|val
operator||=
name|GET_FIELD
argument_list|(
name|opnd
argument_list|,
literal|11
operator|+
literal|12
argument_list|,
literal|11
operator|+
literal|13
argument_list|)
expr_stmt|;
name|val
operator|<<=
literal|2
expr_stmt|;
name|val
operator||=
name|GET_FIELD
argument_list|(
name|opnd
argument_list|,
literal|11
operator|+
literal|19
argument_list|,
literal|11
operator|+
literal|20
argument_list|)
expr_stmt|;
name|val
operator|<<=
literal|11
expr_stmt|;
name|val
operator||=
name|GET_FIELD
argument_list|(
name|opnd
argument_list|,
literal|11
operator|+
literal|1
argument_list|,
literal|11
operator|+
literal|11
argument_list|)
expr_stmt|;
name|val
operator|<<=
literal|1
expr_stmt|;
name|val
operator||=
name|GET_FIELD
argument_list|(
name|opnd
argument_list|,
literal|11
operator|+
literal|0
argument_list|,
literal|11
operator|+
literal|0
argument_list|)
expr_stmt|;
return|return
name|word
operator||
name|val
return|;
block|}
end_function

begin_comment
comment|/* extract a 12 bit constant from branch instructions */
end_comment

begin_function
name|int
name|extract_12
parameter_list|(
name|word
parameter_list|)
name|unsigned
name|word
decl_stmt|;
block|{
return|return
name|sign_extend
argument_list|(
name|GET_FIELD
argument_list|(
name|word
argument_list|,
literal|19
argument_list|,
literal|28
argument_list|)
operator||
name|GET_FIELD
argument_list|(
name|word
argument_list|,
literal|29
argument_list|,
literal|29
argument_list|)
operator|<<
literal|10
operator||
operator|(
name|word
operator|&
literal|0x1
operator|)
operator|<<
literal|11
argument_list|,
literal|12
argument_list|)
operator|<<
literal|2
return|;
block|}
end_function

begin_comment
comment|/* extract a 17 bit constant from branch instructions, returning the    19 bit signed value. */
end_comment

begin_function
name|int
name|extract_17
parameter_list|(
name|word
parameter_list|)
name|unsigned
name|word
decl_stmt|;
block|{
return|return
name|sign_extend
argument_list|(
name|GET_FIELD
argument_list|(
name|word
argument_list|,
literal|19
argument_list|,
literal|28
argument_list|)
operator||
name|GET_FIELD
argument_list|(
name|word
argument_list|,
literal|29
argument_list|,
literal|29
argument_list|)
operator|<<
literal|10
operator||
name|GET_FIELD
argument_list|(
name|word
argument_list|,
literal|11
argument_list|,
literal|15
argument_list|)
operator|<<
literal|11
operator||
operator|(
name|word
operator|&
literal|0x1
operator|)
operator|<<
literal|16
argument_list|,
literal|17
argument_list|)
operator|<<
literal|2
return|;
block|}
end_function

begin_function
name|CORE_ADDR
name|frame_saved_pc
parameter_list|(
name|frame
parameter_list|)
name|FRAME
name|frame
decl_stmt|;
block|{
if|if
condition|(
name|get_current_frame
argument_list|()
operator|==
name|frame
condition|)
block|{
name|struct
name|frame_saved_regs
name|saved_regs
decl_stmt|;
name|get_frame_saved_regs
argument_list|(
name|frame
argument_list|,
operator|&
name|saved_regs
argument_list|)
expr_stmt|;
if|if
condition|(
name|saved_regs
operator|.
name|regs
index|[
name|RP_REGNUM
index|]
condition|)
return|return
name|read_memory_integer
argument_list|(
name|saved_regs
operator|.
name|regs
index|[
name|RP_REGNUM
index|]
argument_list|,
literal|4
argument_list|)
return|;
else|else
return|return
name|read_register
argument_list|(
name|RP_REGNUM
argument_list|)
return|;
block|}
return|return
name|read_memory_integer
argument_list|(
name|frame
operator|->
name|frame
operator|-
literal|20
argument_list|,
literal|4
argument_list|)
operator|&
operator|~
literal|0x3
return|;
block|}
end_function

begin_comment
comment|/* To see if a frame chain is valid, see if the caller looks like it    was compiled with gcc. */
end_comment

begin_function
name|int
name|frame_chain_valid
parameter_list|(
name|chain
parameter_list|,
name|thisframe
parameter_list|)
name|FRAME_ADDR
name|chain
decl_stmt|;
name|FRAME
name|thisframe
decl_stmt|;
block|{
if|if
condition|(
name|chain
operator|&&
operator|(
name|chain
operator|>
literal|0x60000000
comment|/* || remote_debugging   -this is no longer used */
ifdef|#
directive|ifdef
name|KERNELDEBUG
operator|||
name|kernel_debugging
endif|#
directive|endif
operator|)
condition|)
block|{
name|CORE_ADDR
name|pc
init|=
name|get_pc_function_start
argument_list|(
name|FRAME_SAVED_PC
argument_list|(
name|thisframe
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|inside_entry_file
argument_list|(
name|pc
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* look for stw rp, -20(0,sp); copy 4,1; copy sp, 4 */
if|if
condition|(
name|read_memory_integer
argument_list|(
name|pc
argument_list|,
literal|4
argument_list|)
operator|==
literal|0x6BC23FD9
condition|)
name|pc
operator|=
name|pc
operator|+
literal|4
expr_stmt|;
if|if
condition|(
name|read_memory_integer
argument_list|(
name|pc
argument_list|,
literal|4
argument_list|)
operator|==
literal|0x8040241
operator|&&
name|read_memory_integer
argument_list|(
name|pc
operator|+
literal|4
argument_list|,
literal|4
argument_list|)
operator|==
literal|0x81E0244
condition|)
return|return
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
else|else
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Some helper functions. gcc_p returns 1 if the function beginning at     pc appears to have been compiled with gcc. hpux_cc_p returns 1 if    fn was compiled with hpux cc. gcc functions look like :     stw     rp,-0x14(sp) ; optional    or      r4,r0,r1    or      sp,r0,r4    stwm    r1,framesize(sp)     hpux cc functions look like:     stw     rp,-0x14(sp) ; optional.    stwm    r3,framesiz(sp)    */
end_comment

begin_macro
name|gcc_p
argument_list|(
argument|pc
argument_list|)
end_macro

begin_decl_stmt
name|CORE_ADDR
name|pc
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|read_memory_integer
argument_list|(
name|pc
argument_list|,
literal|4
argument_list|)
operator|==
literal|0x6BC23FD9
condition|)
name|pc
operator|=
name|pc
operator|+
literal|4
expr_stmt|;
if|if
condition|(
name|read_memory_integer
argument_list|(
name|pc
argument_list|,
literal|4
argument_list|)
operator|==
literal|0x8040241
operator|&&
name|read_memory_integer
argument_list|(
name|pc
operator|+
literal|4
argument_list|,
literal|4
argument_list|)
operator|==
literal|0x81E0244
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_block

begin_macro
name|find_dummy_frame_regs
argument_list|(
argument|frame
argument_list|,
argument|frame_saved_regs
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|frame_info
modifier|*
name|frame
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|frame_saved_regs
modifier|*
name|frame_saved_regs
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|CORE_ADDR
name|fp
init|=
name|frame
operator|->
name|frame
decl_stmt|;
name|int
name|i
decl_stmt|;
name|frame_saved_regs
operator|->
name|regs
index|[
name|RP_REGNUM
index|]
operator|=
name|fp
operator|-
literal|20
operator|&
operator|~
literal|0x3
expr_stmt|;
name|frame_saved_regs
operator|->
name|regs
index|[
name|FP_REGNUM
index|]
operator|=
name|fp
expr_stmt|;
name|frame_saved_regs
operator|->
name|regs
index|[
literal|1
index|]
operator|=
name|fp
operator|+
literal|8
expr_stmt|;
name|frame_saved_regs
operator|->
name|regs
index|[
literal|3
index|]
operator|=
name|fp
operator|+
literal|12
expr_stmt|;
for|for
control|(
name|fp
operator|+=
literal|16
operator|,
name|i
operator|=
literal|3
init|;
name|i
operator|<
literal|30
condition|;
name|fp
operator|+=
literal|4
operator|,
name|i
operator|++
control|)
name|frame_saved_regs
operator|->
name|regs
index|[
name|i
index|]
operator|=
name|fp
expr_stmt|;
name|frame_saved_regs
operator|->
name|regs
index|[
literal|31
index|]
operator|=
name|fp
expr_stmt|;
name|fp
operator|+=
literal|4
expr_stmt|;
for|for
control|(
name|i
operator|=
name|FP0_REGNUM
init|;
name|i
operator|<
name|NUM_REGS
condition|;
name|i
operator|++
operator|,
name|fp
operator|+=
literal|8
control|)
name|frame_saved_regs
operator|->
name|regs
index|[
name|i
index|]
operator|=
name|fp
expr_stmt|;
comment|/* depend on last increment of fp */
name|frame_saved_regs
operator|->
name|regs
index|[
name|IPSW_REGNUM
index|]
operator|=
name|fp
operator|-
literal|4
expr_stmt|;
name|frame_saved_regs
operator|->
name|regs
index|[
name|SAR_REGNUM
index|]
operator|=
name|fp
expr_stmt|;
name|fp
operator|+=
literal|4
expr_stmt|;
name|frame_saved_regs
operator|->
name|regs
index|[
name|PCOQ_TAIL_REGNUM
index|]
operator|=
name|fp
expr_stmt|;
name|frame_saved_regs
operator|->
name|regs
index|[
name|PCSQ_TAIL_REGNUM
index|]
operator|=
name|fp
expr_stmt|;
block|}
end_block

begin_function
name|CORE_ADDR
name|hp_push_arguments
parameter_list|(
name|nargs
parameter_list|,
name|args
parameter_list|,
name|sp
parameter_list|,
name|struct_return
parameter_list|,
name|struct_addr
parameter_list|)
name|int
name|nargs
decl_stmt|;
name|value
modifier|*
name|args
decl_stmt|;
name|CORE_ADDR
name|sp
decl_stmt|;
name|int
name|struct_return
decl_stmt|;
name|CORE_ADDR
name|struct_addr
decl_stmt|;
block|{
comment|/* array of arguments' offsets */
name|int
modifier|*
name|offset
init|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|nargs
argument_list|)
decl_stmt|;
name|int
name|cum
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|,
name|alignment
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nargs
condition|;
name|i
operator|++
control|)
block|{
name|cum
operator|+=
name|TYPE_LENGTH
argument_list|(
name|VALUE_TYPE
argument_list|(
name|args
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
comment|/* value must go at proper alignment. Assume alignment is a 	 power of two.*/
name|alignment
operator|=
name|hp_alignof
argument_list|(
name|VALUE_TYPE
argument_list|(
name|args
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cum
operator|%
name|alignment
condition|)
name|cum
operator|=
operator|(
name|cum
operator|+
name|alignment
operator|)
operator|&
operator|-
name|alignment
expr_stmt|;
name|offset
index|[
name|i
index|]
operator|=
operator|-
name|cum
expr_stmt|;
block|}
for|for
control|(
name|i
operator|==
literal|0
init|;
name|i
operator|<
name|nargs
condition|;
name|i
operator|++
control|)
block|{
name|write_memory
argument_list|(
name|sp
operator|+
name|offset
index|[
name|i
index|]
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|args
index|[
name|i
index|]
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|sp
operator|+=
name|min
argument_list|(
operator|(
name|cum
operator|+
literal|7
operator|)
operator|&
operator|-
literal|8
argument_list|,
literal|48
argument_list|)
expr_stmt|;
if|if
condition|(
name|struct_return
condition|)
name|write_register
argument_list|(
literal|28
argument_list|,
name|struct_addr
argument_list|)
expr_stmt|;
return|return
name|sp
operator|+
literal|48
return|;
block|}
end_function

begin_comment
comment|/* return the alignment of a type in bytes. Structures have the maximum    alignment required by their fields. */
end_comment

begin_function
name|int
name|hp_alignof
parameter_list|(
name|arg
parameter_list|)
name|struct
name|type
modifier|*
name|arg
decl_stmt|;
block|{
name|int
name|max_align
decl_stmt|,
name|align
decl_stmt|,
name|i
decl_stmt|;
switch|switch
condition|(
name|TYPE_CODE
argument_list|(
name|arg
argument_list|)
condition|)
block|{
case|case
name|TYPE_CODE_PTR
case|:
case|case
name|TYPE_CODE_INT
case|:
case|case
name|TYPE_CODE_FLT
case|:
return|return
name|TYPE_LENGTH
argument_list|(
name|arg
argument_list|)
return|;
case|case
name|TYPE_CODE_ARRAY
case|:
return|return
name|hp_alignof
argument_list|(
name|TYPE_FIELD_TYPE
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
case|case
name|TYPE_CODE_STRUCT
case|:
case|case
name|TYPE_CODE_UNION
case|:
name|max_align
operator|=
literal|2
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TYPE_NFIELDS
argument_list|(
name|arg
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
comment|/* Bit fields have no real alignment. */
if|if
condition|(
operator|!
name|TYPE_FIELD_BITPOS
argument_list|(
name|arg
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|align
operator|=
name|hp_alignof
argument_list|(
name|TYPE_FIELD_TYPE
argument_list|(
name|arg
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|max_align
operator|=
name|max
argument_list|(
name|max_align
argument_list|,
name|align
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|max_align
return|;
default|default:
return|return
literal|4
return|;
block|}
block|}
end_function

begin_comment
comment|/* Print the register regnum, or all registers if regnum is -1 */
end_comment

begin_macro
name|pa_do_registers_info
argument_list|(
argument|regnum
argument_list|,
argument|fpregs
argument_list|)
end_macro

begin_decl_stmt
name|int
name|regnum
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|fpregs
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|raw_regs
index|[
name|REGISTER_BYTES
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_REGS
condition|;
name|i
operator|++
control|)
name|read_relative_register_raw_bytes
argument_list|(
name|i
argument_list|,
name|raw_regs
operator|+
name|REGISTER_BYTE
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|regnum
operator|=
operator|-
literal|1
condition|)
name|pa_print_registers
argument_list|(
name|raw_regs
argument_list|,
name|regnum
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|regnum
operator|<
name|FP0_REGNUM
condition|)
block|{
name|printf
argument_list|(
literal|"%s %x\n"
argument_list|,
name|reg_names
index|[
name|regnum
index|]
argument_list|,
operator|*
operator|(
name|long
operator|*
operator|)
operator|(
name|raw_regs
operator|+
name|REGISTER_BYTE
argument_list|(
name|regnum
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
name|pa_print_fp_reg
argument_list|(
name|regnum
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|pa_print_registers
argument_list|(
argument|raw_regs
argument_list|,
argument|regnum
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|raw_regs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|regnum
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|18
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"%8.8s: %8x  %8.8s: %8x  %8.8s: %8x  %8.8s: %8x\n"
argument_list|,
name|reg_names
index|[
name|i
index|]
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
operator|(
name|raw_regs
operator|+
name|REGISTER_BYTE
argument_list|(
name|i
argument_list|)
operator|)
argument_list|,
name|reg_names
index|[
name|i
operator|+
literal|18
index|]
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
operator|(
name|raw_regs
operator|+
name|REGISTER_BYTE
argument_list|(
name|i
operator|+
literal|18
argument_list|)
operator|)
argument_list|,
name|reg_names
index|[
name|i
operator|+
literal|36
index|]
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
operator|(
name|raw_regs
operator|+
name|REGISTER_BYTE
argument_list|(
name|i
operator|+
literal|36
argument_list|)
operator|)
argument_list|,
name|reg_names
index|[
name|i
operator|+
literal|54
index|]
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
operator|(
name|raw_regs
operator|+
name|REGISTER_BYTE
argument_list|(
name|i
operator|+
literal|54
argument_list|)
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|72
init|;
name|i
operator|<
name|NUM_REGS
condition|;
name|i
operator|++
control|)
name|pa_print_fp_reg
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|pa_print_fp_reg
argument_list|(
argument|i
argument_list|)
end_macro

begin_decl_stmt
name|int
name|i
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|unsigned
name|char
name|raw_buffer
index|[
name|MAX_REGISTER_RAW_SIZE
index|]
decl_stmt|;
name|unsigned
name|char
name|virtual_buffer
index|[
name|MAX_REGISTER_VIRTUAL_SIZE
index|]
decl_stmt|;
name|REGISTER_TYPE
name|val
decl_stmt|;
comment|/* Get the data in raw format, then convert also to virtual format.  */
name|read_relative_register_raw_bytes
argument_list|(
name|i
argument_list|,
name|raw_buffer
argument_list|)
expr_stmt|;
name|REGISTER_CONVERT_TO_VIRTUAL
argument_list|(
name|i
argument_list|,
name|raw_buffer
argument_list|,
name|virtual_buffer
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
name|reg_names
index|[
name|i
index|]
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|print_spaces_filtered
argument_list|(
literal|15
operator|-
name|strlen
argument_list|(
name|reg_names
index|[
name|i
index|]
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|val_print
argument_list|(
name|REGISTER_VIRTUAL_TYPE
argument_list|(
name|i
argument_list|)
argument_list|,
name|virtual_buffer
argument_list|,
literal|0
argument_list|,
name|stdout
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|Val_pretty_default
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Virtual to physical translation routines for Utah's Mach 3.0  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|MACHKERNELDEBUG
end_ifdef

begin_define
define|#
directive|define
name|STATIC
end_define

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* too many includes to resolve, too much crap */
end_comment

begin_include
include|#
directive|include
file|<kern/queue.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<mach/vm_prot.h>
end_include

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* queue.h */
end_comment

begin_struct
struct|struct
name|queue_entry
block|{
name|struct
name|queue_entry
modifier|*
name|next
decl_stmt|;
comment|/* next element */
name|struct
name|queue_entry
modifier|*
name|prev
decl_stmt|;
comment|/* previous element */
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|queue_entry
modifier|*
name|queue_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|queue_entry
name|queue_head_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|queue_entry
name|queue_chain_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|queue_entry
modifier|*
name|queue_entry_t
typedef|;
end_typedef

begin_comment
comment|/* pmap.h */
end_comment

begin_define
define|#
directive|define
name|HP800_HASHSIZE
value|1024
end_define

begin_define
define|#
directive|define
name|HP800_HASHSIZE_LOG2
value|10
end_define

begin_define
define|#
directive|define
name|pmap_hash
parameter_list|(
name|space
parameter_list|,
name|offset
parameter_list|)
define|\
value|(((unsigned) (space)<< 5 ^ \ 	  ((unsigned) (offset)>> 19 | (unsigned) (space)<< 13) ^ \ 	  (unsigned) (offset)>> 11)& (HP800_HASHSIZE-1))
end_define

begin_struct
struct|struct
name|mapping
block|{
name|queue_head_t
name|hash_link
decl_stmt|;
comment|/* hash table links */
name|queue_head_t
name|phys_link
decl_stmt|;
comment|/* for mappings of a given PA */
name|space_t
name|space
decl_stmt|;
comment|/* virtual space */
name|unsigned
name|offset
decl_stmt|;
comment|/* virtual page number */
name|unsigned
name|tlbpage
decl_stmt|;
comment|/* physical page (for TLB load) */
name|unsigned
name|tlbprot
decl_stmt|;
comment|/* prot/access rights (for TLB load) */
name|struct
name|pmap
modifier|*
name|pmap
decl_stmt|;
comment|/* pmap mapping belongs to */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|phys_entry
block|{
name|queue_head_t
name|phys_link
decl_stmt|;
comment|/* head of mappings of a given PA */
name|struct
name|mapping
modifier|*
name|writer
decl_stmt|;
comment|/* mapping with R/W access */
name|unsigned
name|tlbprot
decl_stmt|;
comment|/* TLB format protection */
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|atop
parameter_list|(
name|a
parameter_list|)
value|((unsigned)(a)>> 11)
end_define

begin_define
define|#
directive|define
name|ptoa
parameter_list|(
name|p
parameter_list|)
value|((unsigned)(p)<< 11)
end_define

begin_define
define|#
directive|define
name|trunc_page
parameter_list|(
name|a
parameter_list|)
value|((unsigned)(a)& ~2047)
end_define

begin_decl_stmt
name|STATIC
name|long
name|equiv_end
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|queue_head_t
modifier|*
name|Ovtop_table
decl_stmt|,
modifier|*
name|vtop_table
decl_stmt|,
modifier|*
name|Ofree_mapping
decl_stmt|,
name|free_mapping
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|struct
name|phys_entry
modifier|*
name|Ophys_table
decl_stmt|,
modifier|*
name|phys_table
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|long
name|vm_last_phys
decl_stmt|,
name|vm_first_phys
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|struct
name|mapping
modifier|*
name|firstmap
decl_stmt|,
modifier|*
name|lastmap
decl_stmt|,
modifier|*
name|Omap_table
decl_stmt|,
modifier|*
name|map_table
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|unsigned
name|Omlow
decl_stmt|,
name|Omhigh
decl_stmt|,
name|Omhead
decl_stmt|,
name|Ovlow
decl_stmt|,
name|Ovhigh
decl_stmt|,
name|Oplow
decl_stmt|,
name|Ophigh
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|unsigned
name|mlow
decl_stmt|,
name|mhigh
decl_stmt|,
name|mhead
decl_stmt|,
name|vlow
decl_stmt|,
name|vhigh
decl_stmt|,
name|plow
decl_stmt|,
name|phigh
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|int
name|vtopsize
decl_stmt|,
name|physsize
decl_stmt|,
name|mapsize
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|int
name|kmemfd
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|IS_OVTOPPTR
parameter_list|(
name|p
parameter_list|)
value|((unsigned)(p)>= Ovlow&& (unsigned)(p)< Ovhigh)
end_define

begin_define
define|#
directive|define
name|IS_OMAPPTR
parameter_list|(
name|p
parameter_list|)
value|((unsigned)(p)>= Omlow&& (unsigned)(p)< Omhigh)
end_define

begin_define
define|#
directive|define
name|IS_OPHYSPTR
parameter_list|(
name|p
parameter_list|)
value|((unsigned)(p)>= Oplow&& (unsigned)(p)< Ophigh)
end_define

begin_define
define|#
directive|define
name|IS_VTOPPTR
parameter_list|(
name|p
parameter_list|)
value|((unsigned)(p)>= vlow&& (unsigned)(p)< vhigh)
end_define

begin_define
define|#
directive|define
name|IS_MAPPTR
parameter_list|(
name|p
parameter_list|)
value|((unsigned)(p)>= mlow&& (unsigned)(p)< mhigh)
end_define

begin_define
define|#
directive|define
name|IS_PHYSPTR
parameter_list|(
name|p
parameter_list|)
value|((unsigned)(p)>= plow&& (unsigned)(p)< phigh)
end_define

begin_struct
struct|struct
name|mapstate
block|{
name|char
name|unused
decl_stmt|;
name|char
name|flags
decl_stmt|;
name|short
name|hashix
decl_stmt|;
name|short
name|physix
decl_stmt|;
block|}
modifier|*
name|mapstate
struct|;
end_struct

begin_comment
comment|/* flags */
end_comment

begin_define
define|#
directive|define
name|M_ISFREE
value|1
end_define

begin_define
define|#
directive|define
name|M_ISHASH
value|2
end_define

begin_define
define|#
directive|define
name|M_ISPHYS
value|4
end_define

begin_macro
name|mach_vtophys_init
argument_list|()
end_macro

begin_block
block|{
name|int
name|errors
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|readdata
argument_list|()
condition|)
name|errors
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|verifydata
argument_list|()
condition|)
name|errors
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|errors
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"translate: may not be able to translate all addresses\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|mach_vtophys
argument_list|(
argument|space
argument_list|,
argument|off
argument_list|,
argument|pa
argument_list|)
end_macro

begin_decl_stmt
name|unsigned
name|space
decl_stmt|,
name|off
decl_stmt|,
modifier|*
name|pa
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|queue_t
name|qp
decl_stmt|;
specifier|register
name|struct
name|mapping
modifier|*
name|mp
decl_stmt|;
name|int
name|poff
decl_stmt|;
comment|/* 	 * Kernel IO or equivilently mapped, one to one. 	 */
if|if
condition|(
name|space
operator|==
literal|0
operator|&&
operator|(
name|long
operator|)
name|off
operator|<
name|equiv_end
condition|)
block|{
operator|*
name|pa
operator|=
name|off
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * Else look it up in specified space 	 */
name|poff
operator|=
name|off
operator|-
name|trunc_page
argument_list|(
name|off
argument_list|)
expr_stmt|;
name|off
operator|=
name|trunc_page
argument_list|(
name|off
argument_list|)
expr_stmt|;
name|qp
operator|=
operator|&
name|vtop_table
index|[
name|pmap_hash
argument_list|(
name|space
argument_list|,
name|off
argument_list|)
index|]
expr_stmt|;
for|for
control|(
name|mp
operator|=
operator|(
expr|struct
name|mapping
operator|*
operator|)
name|qp
operator|->
name|next
init|;
name|qp
operator|!=
operator|(
name|queue_entry_t
operator|)
name|mp
condition|;
name|mp
operator|=
operator|(
expr|struct
name|mapping
operator|*
operator|)
name|mp
operator|->
name|hash_link
operator|.
name|next
control|)
block|{
if|if
condition|(
name|mp
operator|->
name|space
operator|==
name|space
operator|&&
name|mp
operator|->
name|offset
operator|==
name|off
condition|)
block|{
operator|*
name|pa
operator|=
operator|(
name|mp
operator|->
name|tlbpage
operator|<<
literal|7
operator|)
operator||
name|poff
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_function
name|STATIC
name|readdata
parameter_list|()
block|{
name|char
modifier|*
name|tmp
decl_stmt|,
modifier|*
name|mach_malloc
argument_list|()
decl_stmt|;
name|long
name|size
decl_stmt|;
comment|/* easy scalars */
name|mach_read
argument_list|(
literal|"equiv_end"
argument_list|,
operator|~
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|equiv_end
argument_list|,
sizeof|sizeof
name|equiv_end
argument_list|)
expr_stmt|;
name|mach_read
argument_list|(
literal|"vm_first_phys"
argument_list|,
operator|~
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|vm_first_phys
argument_list|,
sizeof|sizeof
name|vm_first_phys
argument_list|)
expr_stmt|;
name|mach_read
argument_list|(
literal|"vm_last_phys"
argument_list|,
operator|~
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|vm_last_phys
argument_list|,
sizeof|sizeof
name|vm_last_phys
argument_list|)
expr_stmt|;
name|mach_read
argument_list|(
literal|"firstmap"
argument_list|,
operator|~
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|firstmap
argument_list|,
sizeof|sizeof
name|firstmap
argument_list|)
expr_stmt|;
name|mach_read
argument_list|(
literal|"lastmap"
argument_list|,
operator|~
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|lastmap
argument_list|,
sizeof|sizeof
name|lastmap
argument_list|)
expr_stmt|;
comment|/* virtual to physical hash table */
name|vtopsize
operator|=
name|HP800_HASHSIZE
expr_stmt|;
name|size
operator|=
name|vtopsize
operator|*
sizeof|sizeof
argument_list|(
name|queue_head_t
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|mach_malloc
argument_list|(
literal|"vtop table"
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|mach_read
argument_list|(
literal|"vtop_table"
argument_list|,
operator|~
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|Ovtop_table
argument_list|,
sizeof|sizeof
name|Ovtop_table
argument_list|)
expr_stmt|;
name|mach_read
argument_list|(
literal|"vtop table"
argument_list|,
operator|(
name|CORE_ADDR
operator|)
name|Ovtop_table
argument_list|,
name|tmp
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|vtop_table
operator|=
operator|(
name|queue_head_t
operator|*
operator|)
name|tmp
expr_stmt|;
comment|/* inverted page table */
name|physsize
operator|=
name|atop
argument_list|(
name|vm_last_phys
operator|-
name|vm_first_phys
argument_list|)
expr_stmt|;
name|size
operator|=
name|physsize
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|phys_entry
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|mach_malloc
argument_list|(
literal|"phys table"
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|mach_read
argument_list|(
literal|"phys_table"
argument_list|,
operator|~
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|Ophys_table
argument_list|,
sizeof|sizeof
name|Ophys_table
argument_list|)
expr_stmt|;
name|mach_read
argument_list|(
literal|"phys table"
argument_list|,
operator|(
name|CORE_ADDR
operator|)
name|Ophys_table
argument_list|,
name|tmp
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|phys_table
operator|=
operator|(
expr|struct
name|phys_entry
operator|*
operator|)
name|tmp
expr_stmt|;
comment|/* mapping structures */
name|Ofree_mapping
operator|=
operator|(
name|queue_head_t
operator|*
operator|)
name|ksym_lookup
argument_list|(
literal|"free_mapping"
argument_list|)
expr_stmt|;
name|mach_read
argument_list|(
literal|"free mapping"
argument_list|,
operator|(
name|CORE_ADDR
operator|)
name|Ofree_mapping
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|free_mapping
argument_list|,
sizeof|sizeof
name|free_mapping
argument_list|)
expr_stmt|;
name|Omap_table
operator|=
name|firstmap
expr_stmt|;
name|mapsize
operator|=
name|lastmap
operator|-
name|firstmap
expr_stmt|;
name|size
operator|=
name|mapsize
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|mapping
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|mach_malloc
argument_list|(
literal|"mapping table"
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|mach_read
argument_list|(
literal|"mapping table"
argument_list|,
operator|(
name|CORE_ADDR
operator|)
name|Omap_table
argument_list|,
name|tmp
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|map_table
operator|=
operator|(
expr|struct
name|mapping
operator|*
operator|)
name|tmp
expr_stmt|;
comment|/* set limits */
name|Ovlow
operator|=
operator|(
name|unsigned
operator|)
name|Ovtop_table
expr_stmt|;
name|Ovhigh
operator|=
operator|(
name|unsigned
operator|)
operator|&
name|Ovtop_table
index|[
name|vtopsize
index|]
expr_stmt|;
name|Oplow
operator|=
operator|(
name|unsigned
operator|)
name|Ophys_table
expr_stmt|;
name|Ophigh
operator|=
operator|(
name|unsigned
operator|)
operator|&
name|Ophys_table
index|[
name|physsize
index|]
expr_stmt|;
name|Omhead
operator|=
operator|(
name|unsigned
operator|)
name|Ofree_mapping
expr_stmt|;
name|Omlow
operator|=
operator|(
name|unsigned
operator|)
name|firstmap
expr_stmt|;
name|Omhigh
operator|=
operator|(
name|unsigned
operator|)
name|lastmap
expr_stmt|;
name|mlow
operator|=
operator|(
name|unsigned
operator|)
name|map_table
expr_stmt|;
name|mhigh
operator|=
operator|(
name|unsigned
operator|)
operator|&
name|map_table
index|[
name|mapsize
index|]
expr_stmt|;
name|mhead
operator|=
operator|(
name|unsigned
operator|)
operator|&
name|free_mapping
expr_stmt|;
name|vlow
operator|=
operator|(
name|unsigned
operator|)
name|vtop_table
expr_stmt|;
name|vhigh
operator|=
operator|(
name|unsigned
operator|)
operator|&
name|vtop_table
index|[
name|vtopsize
index|]
expr_stmt|;
name|plow
operator|=
operator|(
name|unsigned
operator|)
name|phys_table
expr_stmt|;
name|phigh
operator|=
operator|(
name|unsigned
operator|)
operator|&
name|phys_table
index|[
name|physsize
index|]
expr_stmt|;
if|#
directive|if
literal|0
block|fprintf(stderr, "Ovtop [%#x-%#x) Ophys [%#x-%#x) Omap %#x [%#x-%#x)\n", 		Ovlow, Ovhigh, Oplow, Ophigh, Omhead, Omlow, Omhigh); 	fprintf(stderr, "vtop [%#x-%#x) phys [%#x-%#x) map %#x [%#x-%#x)\n", 		vlow, vhigh, plow, phigh, mhead, mlow, mhigh);
endif|#
directive|endif
return|return
operator|(
name|adjustdata
argument_list|()
operator|)
return|;
block|}
end_function

begin_function
name|STATIC
name|unsigned
name|ptrcvt
parameter_list|(
name|ptr
parameter_list|)
name|unsigned
name|ptr
decl_stmt|;
block|{
name|unsigned
name|ret
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
if|if
condition|(
name|ptr
operator|==
literal|0
condition|)
block|{
name|ret
operator|=
name|ptr
expr_stmt|;
name|str
operator|=
literal|"null"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IS_OVTOPPTR
argument_list|(
name|ptr
argument_list|)
condition|)
block|{
name|ret
operator|=
name|vlow
operator|+
operator|(
name|ptr
operator|-
name|Ovlow
operator|)
expr_stmt|;
name|str
operator|=
literal|"vtop"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IS_OPHYSPTR
argument_list|(
name|ptr
argument_list|)
condition|)
block|{
name|ret
operator|=
name|plow
operator|+
operator|(
name|ptr
operator|-
name|Oplow
operator|)
expr_stmt|;
name|str
operator|=
literal|"phys"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IS_OMAPPTR
argument_list|(
name|ptr
argument_list|)
condition|)
block|{
name|ret
operator|=
name|mlow
operator|+
operator|(
name|ptr
operator|-
name|Omlow
operator|)
expr_stmt|;
name|str
operator|=
literal|"map"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ptr
operator|==
name|Omhead
condition|)
block|{
name|ret
operator|=
name|mhead
expr_stmt|;
name|str
operator|=
literal|"maphead"
expr_stmt|;
block|}
else|else
block|{
name|error
argument_list|(
literal|"bogus pointer %#x"
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
name|str
operator|=
literal|"wild"
expr_stmt|;
name|ret
operator|=
name|ptr
expr_stmt|;
block|}
if|#
directive|if
literal|0
block|fprintf(stderr, "%x (%s) -> %x\n", ptr, str, ret);
endif|#
directive|endif
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|STATIC
name|int
name|adjustdata
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|lim
decl_stmt|;
name|queue_head_t
modifier|*
name|nq
decl_stmt|;
name|struct
name|phys_entry
modifier|*
name|np
decl_stmt|;
name|struct
name|mapping
modifier|*
name|nm
decl_stmt|;
comment|/* hash table */
name|lim
operator|=
name|vtopsize
expr_stmt|;
for|for
control|(
name|nq
operator|=
name|vtop_table
init|;
name|nq
operator|<
operator|&
name|vtop_table
index|[
name|lim
index|]
condition|;
name|nq
operator|++
control|)
block|{
name|nq
operator|->
name|next
operator|=
operator|(
name|queue_entry_t
operator|)
name|ptrcvt
argument_list|(
operator|(
name|unsigned
operator|)
name|nq
operator|->
name|next
argument_list|)
expr_stmt|;
name|nq
operator|->
name|prev
operator|=
operator|(
name|queue_entry_t
operator|)
name|ptrcvt
argument_list|(
operator|(
name|unsigned
operator|)
name|nq
operator|->
name|prev
argument_list|)
expr_stmt|;
block|}
comment|/* IPT */
name|lim
operator|=
name|physsize
expr_stmt|;
for|for
control|(
name|np
operator|=
name|phys_table
init|;
name|np
operator|<
operator|&
name|phys_table
index|[
name|lim
index|]
condition|;
name|np
operator|++
control|)
block|{
name|np
operator|->
name|phys_link
operator|.
name|next
operator|=
operator|(
name|queue_entry_t
operator|)
name|ptrcvt
argument_list|(
operator|(
name|unsigned
operator|)
name|np
operator|->
name|phys_link
operator|.
name|next
argument_list|)
expr_stmt|;
name|np
operator|->
name|phys_link
operator|.
name|prev
operator|=
operator|(
name|queue_entry_t
operator|)
name|ptrcvt
argument_list|(
operator|(
name|unsigned
operator|)
name|np
operator|->
name|phys_link
operator|.
name|prev
argument_list|)
expr_stmt|;
name|np
operator|->
name|writer
operator|=
operator|(
expr|struct
name|mapping
operator|*
operator|)
name|ptrcvt
argument_list|(
operator|(
name|unsigned
operator|)
name|np
operator|->
name|writer
argument_list|)
expr_stmt|;
block|}
comment|/* mapping table */
name|free_mapping
operator|.
name|next
operator|=
operator|(
name|queue_entry_t
operator|)
name|ptrcvt
argument_list|(
operator|(
name|unsigned
operator|)
name|free_mapping
operator|.
name|next
argument_list|)
expr_stmt|;
name|free_mapping
operator|.
name|prev
operator|=
operator|(
name|queue_entry_t
operator|)
name|ptrcvt
argument_list|(
operator|(
name|unsigned
operator|)
name|free_mapping
operator|.
name|prev
argument_list|)
expr_stmt|;
name|lim
operator|=
name|mapsize
expr_stmt|;
for|for
control|(
name|nm
operator|=
name|map_table
init|;
name|nm
operator|<
operator|&
name|map_table
index|[
name|lim
index|]
condition|;
name|nm
operator|++
control|)
block|{
name|nm
operator|->
name|hash_link
operator|.
name|next
operator|=
operator|(
name|queue_entry_t
operator|)
name|ptrcvt
argument_list|(
operator|(
name|unsigned
operator|)
name|nm
operator|->
name|hash_link
operator|.
name|next
argument_list|)
expr_stmt|;
name|nm
operator|->
name|hash_link
operator|.
name|prev
operator|=
operator|(
name|queue_entry_t
operator|)
name|ptrcvt
argument_list|(
operator|(
name|unsigned
operator|)
name|nm
operator|->
name|hash_link
operator|.
name|prev
argument_list|)
expr_stmt|;
name|nm
operator|->
name|phys_link
operator|.
name|next
operator|=
operator|(
name|queue_entry_t
operator|)
name|ptrcvt
argument_list|(
operator|(
name|unsigned
operator|)
name|nm
operator|->
name|phys_link
operator|.
name|next
argument_list|)
expr_stmt|;
name|nm
operator|->
name|phys_link
operator|.
name|prev
operator|=
operator|(
name|queue_entry_t
operator|)
name|ptrcvt
argument_list|(
operator|(
name|unsigned
operator|)
name|nm
operator|->
name|phys_link
operator|.
name|prev
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Consistency checks, make sure:  *  *	1. all mappings are accounted for  *	2. no cycles  *	3. no wild pointers  *	4. consisent TLB state  */
end_comment

begin_function
name|STATIC
name|int
name|verifydata
parameter_list|()
block|{
specifier|register
name|struct
name|mapstate
modifier|*
name|ms
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|errors
init|=
literal|0
decl_stmt|;
name|mapstate
operator|=
operator|(
expr|struct
name|mapstate
operator|*
operator|)
name|mach_malloc
argument_list|(
literal|"map state"
argument_list|,
name|mapsize
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|mapstate
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|ms
operator|=
name|mapstate
init|;
name|ms
operator|<
operator|&
name|mapstate
index|[
name|mapsize
index|]
condition|;
name|ms
operator|++
control|)
block|{
name|ms
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|ms
operator|->
name|hashix
operator|=
name|ms
operator|->
name|physix
operator|=
operator|-
literal|2
expr_stmt|;
block|}
comment|/* 	 * Check the free list 	 */
name|checkhashchain
argument_list|(
operator|&
name|free_mapping
argument_list|,
name|M_ISFREE
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * Check every hash chain 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|vtopsize
condition|;
name|i
operator|++
control|)
name|checkhashchain
argument_list|(
operator|&
name|vtop_table
index|[
name|i
index|]
argument_list|,
name|M_ISHASH
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* 	 * Check every phys chain 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|physsize
condition|;
name|i
operator|++
control|)
name|checkphyschain
argument_list|(
operator|&
name|phys_table
index|[
name|i
index|]
operator|.
name|phys_link
argument_list|,
name|M_ISPHYS
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* 	 * Cycle through mapstate looking for anomolies 	 */
name|ms
operator|=
name|mapstate
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mapsize
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|ms
operator|->
name|flags
condition|)
block|{
case|case
name|M_ISFREE
case|:
case|case
name|M_ISHASH
operator||
name|M_ISPHYS
case|:
break|break;
case|case
literal|0
case|:
name|merror
argument_list|(
name|ms
argument_list|,
literal|"not found"
argument_list|)
expr_stmt|;
name|errors
operator|++
expr_stmt|;
break|break;
case|case
name|M_ISHASH
case|:
name|merror
argument_list|(
name|ms
argument_list|,
literal|"in vtop but not phys"
argument_list|)
expr_stmt|;
name|errors
operator|++
expr_stmt|;
break|break;
case|case
name|M_ISPHYS
case|:
name|merror
argument_list|(
name|ms
argument_list|,
literal|"in phys but not vtop"
argument_list|)
expr_stmt|;
name|errors
operator|++
expr_stmt|;
break|break;
default|default:
name|merror
argument_list|(
name|ms
argument_list|,
literal|"totally bogus"
argument_list|)
expr_stmt|;
name|errors
operator|++
expr_stmt|;
break|break;
block|}
name|ms
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|errors
condition|?
literal|0
else|:
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|STATIC
name|void
name|checkhashchain
parameter_list|(
name|qhp
parameter_list|,
name|flag
parameter_list|,
name|ix
parameter_list|)
name|queue_entry_t
name|qhp
decl_stmt|;
block|{
specifier|register
name|queue_entry_t
name|qp
decl_stmt|,
name|pqp
decl_stmt|;
specifier|register
name|struct
name|mapping
modifier|*
name|mp
decl_stmt|;
name|struct
name|mapstate
modifier|*
name|ms
decl_stmt|;
name|qp
operator|=
name|qhp
operator|->
name|next
expr_stmt|;
comment|/* 	 * First element is not a mapping structure, 	 * chain must be empty. 	 */
if|if
condition|(
operator|!
name|IS_MAPPTR
argument_list|(
name|qp
argument_list|)
condition|)
block|{
if|if
condition|(
name|qp
operator|!=
name|qhp
operator|||
name|qp
operator|!=
name|qhp
operator|->
name|prev
condition|)
name|fatal
argument_list|(
literal|"bad vtop_table header pointer"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pqp
operator|=
name|qhp
expr_stmt|;
do|do
block|{
name|mp
operator|=
operator|(
expr|struct
name|mapping
operator|*
operator|)
name|qp
expr_stmt|;
name|qp
operator|=
operator|&
name|mp
operator|->
name|hash_link
expr_stmt|;
if|if
condition|(
name|qp
operator|->
name|prev
operator|!=
name|pqp
condition|)
name|fatal
argument_list|(
literal|"bad hash_link prev pointer"
argument_list|)
expr_stmt|;
name|ms
operator|=
operator|&
name|mapstate
index|[
name|mp
operator|-
name|map_table
index|]
expr_stmt|;
name|ms
operator|->
name|flags
operator||=
name|flag
expr_stmt|;
name|ms
operator|->
name|hashix
operator|=
name|ix
expr_stmt|;
name|pqp
operator|=
operator|(
name|queue_entry_t
operator|)
name|mp
expr_stmt|;
name|qp
operator|=
name|qp
operator|->
name|next
expr_stmt|;
block|}
do|while
condition|(
name|IS_MAPPTR
argument_list|(
name|qp
argument_list|)
condition|)
do|;
if|if
condition|(
name|qp
operator|!=
name|qhp
condition|)
name|fatal
argument_list|(
literal|"bad hash_link next pointer"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|STATIC
name|void
name|checkphyschain
parameter_list|(
name|qhp
parameter_list|,
name|flag
parameter_list|,
name|ix
parameter_list|)
name|queue_entry_t
name|qhp
decl_stmt|;
block|{
specifier|register
name|queue_entry_t
name|qp
decl_stmt|,
name|pqp
decl_stmt|;
specifier|register
name|struct
name|mapping
modifier|*
name|mp
decl_stmt|;
name|struct
name|mapstate
modifier|*
name|ms
decl_stmt|;
name|qp
operator|=
name|qhp
operator|->
name|next
expr_stmt|;
comment|/* 	 * First element is not a mapping structure, 	 * chain must be empty. 	 */
if|if
condition|(
operator|!
name|IS_MAPPTR
argument_list|(
name|qp
argument_list|)
condition|)
block|{
if|if
condition|(
name|qp
operator|!=
name|qhp
operator|||
name|qp
operator|!=
name|qhp
operator|->
name|prev
condition|)
name|fatal
argument_list|(
literal|"bad phys_table header pointer"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pqp
operator|=
name|qhp
expr_stmt|;
do|do
block|{
name|mp
operator|=
operator|(
expr|struct
name|mapping
operator|*
operator|)
name|qp
expr_stmt|;
name|qp
operator|=
operator|&
name|mp
operator|->
name|phys_link
expr_stmt|;
if|if
condition|(
name|qp
operator|->
name|prev
operator|!=
name|pqp
condition|)
name|fatal
argument_list|(
literal|"bad phys_link prev pointer"
argument_list|)
expr_stmt|;
name|ms
operator|=
operator|&
name|mapstate
index|[
name|mp
operator|-
name|map_table
index|]
expr_stmt|;
name|ms
operator|->
name|flags
operator||=
name|flag
expr_stmt|;
name|ms
operator|->
name|physix
operator|=
name|ix
expr_stmt|;
name|pqp
operator|=
operator|(
name|queue_entry_t
operator|)
name|mp
expr_stmt|;
name|qp
operator|=
name|qp
operator|->
name|next
expr_stmt|;
block|}
do|while
condition|(
name|IS_MAPPTR
argument_list|(
name|qp
argument_list|)
condition|)
do|;
if|if
condition|(
name|qp
operator|!=
name|qhp
condition|)
name|fatal
argument_list|(
literal|"bad phys_link next pointer"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|STATIC
name|void
name|merror
parameter_list|(
name|ms
parameter_list|,
name|str
parameter_list|)
name|struct
name|mapstate
modifier|*
name|ms
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|terminal_ours
argument_list|()
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"vtophys: %s: %c%c%c, hashix %d, physix %d, mapping %x\n"
argument_list|,
name|str
argument_list|,
operator|(
name|ms
operator|->
name|flags
operator|&
name|M_ISFREE
operator|)
condition|?
literal|'F'
else|:
literal|'-'
argument_list|,
operator|(
name|ms
operator|->
name|flags
operator|&
name|M_ISHASH
operator|)
condition|?
literal|'H'
else|:
literal|'-'
argument_list|,
operator|(
name|ms
operator|->
name|flags
operator|&
name|M_ISPHYS
operator|)
condition|?
literal|'P'
else|:
literal|'-'
argument_list|,
name|ms
operator|->
name|hashix
argument_list|,
name|ms
operator|->
name|physix
argument_list|,
operator|&
name|map_table
index|[
name|ms
operator|-
name|mapstate
index|]
argument_list|)
expr_stmt|;
name|return_to_top_level
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|STATIC
name|int
name|mach_read
parameter_list|(
name|str
parameter_list|,
name|from
parameter_list|,
name|top
parameter_list|,
name|size
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
name|CORE_ADDR
name|from
decl_stmt|;
name|char
modifier|*
name|top
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
name|CORE_ADDR
name|paddr
decl_stmt|;
if|if
condition|(
name|from
operator|==
operator|~
literal|0
condition|)
name|from
operator|=
name|ksym_lookup
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|paddr
operator|=
name|vtophys
argument_list|(
literal|0
argument_list|,
name|from
argument_list|)
expr_stmt|;
if|if
condition|(
name|paddr
operator|==
operator|~
literal|0
operator|||
name|physrd
argument_list|(
name|paddr
argument_list|,
name|top
argument_list|,
name|size
argument_list|)
operator|!=
literal|0
condition|)
name|fatal
argument_list|(
literal|"cannot read %s"
argument_list|,
name|str
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|STATIC
name|char
modifier|*
name|mach_malloc
parameter_list|(
name|str
parameter_list|,
name|size
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
name|char
modifier|*
name|ptr
init|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
name|ptr
operator|==
literal|0
condition|)
name|fatal
argument_list|(
literal|"no memory for %s"
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return
operator|(
name|ptr
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|KERNELDEBUG
end_ifdef

begin_function
name|void
name|_initialize_hp9k8_dep
parameter_list|()
block|{
name|add_com
argument_list|(
literal|"process-address"
argument_list|,
name|class_obscure
argument_list|,
name|set_paddr_command
argument_list|,
literal|"The process identified by (ps-style) ADDR becomes the\n\ \"current\" process context for kernel debugging."
argument_list|)
expr_stmt|;
name|add_com_alias
argument_list|(
literal|"paddr"
argument_list|,
literal|"process-address"
argument_list|,
name|class_obscure
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"virtual-to-physical"
argument_list|,
name|class_obscure
argument_list|,
name|vtop_command
argument_list|,
literal|"Translates the kernel virtual address ADDR into a physical address."
argument_list|)
expr_stmt|;
name|add_com_alias
argument_list|(
literal|"vtop"
argument_list|,
literal|"virtual-to-physical"
argument_list|,
name|class_obscure
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

