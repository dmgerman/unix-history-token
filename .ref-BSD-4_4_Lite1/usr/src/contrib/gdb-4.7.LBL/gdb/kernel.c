begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1992 Regents of the University of California.  * All rights reserved.  *  * Redistribution and use in source and binary forms are permitted  * provided that the above copyright notice and this paragraph are  * duplicated in all such forms and that any documentation,  * advertising materials, and other materials related to such  * distribution and use acknowledge that the software was developed  * by the University of California, Lawrence Berkeley Laboratory,  * Berkeley, CA.  The name of the University may not be used to  * endorse or promote products derived from this software without  * specific prior written permission.  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"@(#) $Header: kernel.c,v 1.2 93/02/19 15:24:35 mccanne Exp $ (LBL)"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|KERNELDEBUG
end_ifdef

begin_include
include|#
directive|include
file|"kernel.h"
end_include

begin_function
name|int
name|is_a_vmunix
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
name|name
operator|&&
operator|(
name|cp
operator|=
name|strstr
argument_list|(
name|name
argument_list|,
literal|"vmunix"
argument_list|)
operator|)
operator|&&
operator|(
name|cp
operator|==
name|name
operator|||
name|cp
index|[
operator|-
literal|1
index|]
operator|==
literal|'/'
operator|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Lookup the address of a symbol and report a meaningful message   * if not found.  */
end_comment

begin_function
name|CORE_ADDR
name|ksym_lookup
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|struct
name|minimal_symbol
modifier|*
name|sym
decl_stmt|;
if|if
condition|(
operator|(
name|sym
operator|=
name|lookup_minimal_symbol
argument_list|(
name|name
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"Kernel symbol `%s' not found."
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|sym
operator|->
name|address
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Read the panic string and print it out if set.  */
end_comment

begin_function
specifier|static
name|void
name|panicinfo
parameter_list|()
block|{
name|CORE_ADDR
name|addr
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
comment|/* print out the panic string if there is one */
if|if
condition|(
name|target_read_memory
argument_list|(
name|ksym_lookup
argument_list|(
literal|"panicstr"
argument_list|)
argument_list|,
operator|&
name|addr
argument_list|,
literal|4
argument_list|)
operator|||
name|addr
operator|==
literal|0
operator|||
name|target_read_memory
argument_list|(
name|addr
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
condition|)
return|return;
for|for
control|(
name|cp
operator|=
name|buf
init|;
name|cp
operator|<
operator|&
name|buf
index|[
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
index|]
operator|&&
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
if|if
condition|(
operator|!
name|isascii
argument_list|(
operator|*
name|cp
argument_list|)
operator|||
operator|(
operator|!
name|isprint
argument_list|(
operator|*
name|cp
argument_list|)
operator|&&
operator|!
name|isspace
argument_list|(
operator|*
name|cp
argument_list|)
operator|)
condition|)
operator|*
name|cp
operator|=
literal|'?'
expr_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|printf
argument_list|(
literal|"panic: %s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Print info about the kernel crashdump.  */
end_comment

begin_function
name|void
name|kerninfo
parameter_list|()
block|{
name|printf
argument_list|(
literal|"sp=%x pc=%x psr=%x\n"
argument_list|,
name|read_register
argument_list|(
name|SP_REGNUM
argument_list|)
argument_list|,
name|read_register
argument_list|(
name|PC_REGNUM
argument_list|)
argument_list|,
name|read_register
argument_list|(
name|PS_REGNUM
argument_list|)
argument_list|)
expr_stmt|;
name|panicinfo
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * XXX this needs serious work to really work right.  */
end_comment

begin_function
name|void
name|set_procaddr_com
parameter_list|(
name|arg
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|u_int
name|paddr
decl_stmt|,
name|uaddr
decl_stmt|;
if|if
condition|(
operator|!
name|kernel_debugging
condition|)
name|error
argument_list|(
literal|"Not kernel debugging."
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|set_procaddr
argument_list|(
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|paddr
operator|=
operator|(
name|u_int
operator|)
name|parse_and_eval_address
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|set_procaddr
argument_list|(
name|paddr
argument_list|)
condition|)
name|error
argument_list|(
literal|"invalid proc address"
argument_list|)
expr_stmt|;
name|flush_cached_frames
argument_list|()
expr_stmt|;
name|set_current_frame
argument_list|(
name|create_new_frame
argument_list|(
name|read_register
argument_list|(
name|FP_REGNUM
argument_list|)
argument_list|,
name|read_pc
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|select_frame
argument_list|(
name|get_current_frame
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|_initialize_kernel
parameter_list|()
block|{
name|add_com
argument_list|(
literal|"process-address"
argument_list|,
name|class_obscure
argument_list|,
name|set_procaddr_com
argument_list|,
literal|"The process with proc structure at ADDR becomes the\n\ \"current\" process context for kernel debugging."
argument_list|)
expr_stmt|;
name|add_com_alias
argument_list|(
literal|"paddr"
argument_list|,
literal|"process-address"
argument_list|,
name|class_obscure
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

