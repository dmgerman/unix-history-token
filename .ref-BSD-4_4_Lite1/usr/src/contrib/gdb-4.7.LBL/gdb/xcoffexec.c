begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Execute AIXcoff files, for GDB.    Copyright 1988, 1989, 1991, 1992 Free Software Foundation, Inc.    Derived from exec.c.  Modified by IBM Corporation.    Donated by IBM Corporation and Cygnus Support.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* xcoff-exec -	deal with executing XCOFF files.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/ldr.h>
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_include
include|#
directive|include
file|"objfiles.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_comment
comment|/* BFD internals (sigh!)  FIXME */
end_comment

begin_include
include|#
directive|include
file|"xcoffsolib.h"
end_include

begin_comment
comment|/* Prototypes for local functions */
end_comment

begin_decl_stmt
specifier|static
name|void
name|file_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|exec_close
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|section_table
modifier|*
name|exec_sections
decl_stmt|,
modifier|*
name|exec_sections_end
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|eq
parameter_list|(
name|s0
parameter_list|,
name|s1
parameter_list|)
value|!strcmp(s0, s1)
end_define

begin_comment
comment|/* Whether to open exec and core files read-only or read-write.  */
end_comment

begin_decl_stmt
name|int
name|write_files
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|info_verbose
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bfd
modifier|*
name|exec_bfd
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* needed by core.c	*/
end_comment

begin_function_decl
specifier|extern
name|char
modifier|*
name|getenv
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|add_syms_addr_command
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|symbol_file_command
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|exec_files_info
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|struct
name|objfile
modifier|*
name|lookup_objfile_bfd
parameter_list|()
function_decl|;
end_function_decl

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/*  * the vmap struct is used to describe the virtual address space of  * the target we are manipulating.  The first entry is always the "exec"  * file.  Subsequent entries correspond to other objects that are  * mapped into the address space of a process created from the "exec" file.  * These are either in response to exec()ing the file, in which case all  * shared libraries are loaded, or a "load" system call, followed by the  * user's issuance of a "load" command.  */
end_comment

begin_comment
unit|struct vmap { 	struct vmap *nxt;
comment|/* ^ to next in chain			*/
end_comment

begin_comment
unit|bfd *bfd;
comment|/* BFD for mappable object library	*/
end_comment

begin_comment
unit|char *name;
comment|/* ^ to object file name		*/
end_comment

begin_comment
unit|char *member;
comment|/* ^ to member name			*/
end_comment

begin_comment
unit|CORE_ADDR tstart;
comment|/* virtual addr where member is mapped	*/
end_comment

begin_comment
unit|CORE_ADDR tend;
comment|/* virtual upper bound of member	*/
end_comment

begin_comment
unit|CORE_ADDR tadj;
comment|/* heuristically derived adjustment	*/
end_comment

begin_comment
unit|CORE_ADDR dstart;
comment|/* virtual address of data start	*/
end_comment

begin_comment
unit|CORE_ADDR dend;
comment|/* vitrual address of data end		*/
end_comment

begin_comment
unit|};   struct vmap_and_bfd {   bfd *pbfd;   struct vmap *pvmap; };  static struct vmap *vmap;
comment|/* current vmap				*/
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* 0 */
end_comment

begin_decl_stmt
name|struct
name|vmap
modifier|*
name|vmap
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current vmap */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|target_ops
name|exec_ops
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* exec_close -	done with exec file, clean up all resources. */
end_comment

begin_function
specifier|static
name|void
name|exec_close
parameter_list|(
name|quitting
parameter_list|)
block|{
specifier|register
name|struct
name|vmap
modifier|*
name|vp
decl_stmt|,
modifier|*
name|nxt
decl_stmt|;
name|struct
name|objfile
modifier|*
name|obj
decl_stmt|;
for|for
control|(
name|nxt
operator|=
name|vmap
init|;
name|vp
operator|=
name|nxt
condition|;
control|)
block|{
name|nxt
operator|=
name|vp
operator|->
name|nxt
expr_stmt|;
comment|/* if there is an objfile associated with this bfd, 	 free_objfile() will do proper cleanup of objfile *and* bfd. */
if|if
condition|(
name|obj
operator|=
name|lookup_objfile_bfd
argument_list|(
name|vp
operator|->
name|bfd
argument_list|)
condition|)
name|free_objfile
argument_list|(
name|obj
argument_list|)
expr_stmt|;
else|else
name|bfd_close
argument_list|(
name|vp
operator|->
name|bfd
argument_list|)
expr_stmt|;
name|free_named_symtabs
argument_list|(
name|vp
operator|->
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|vp
argument_list|)
expr_stmt|;
block|}
name|vmap
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|exec_bfd
condition|)
block|{
name|bfd_close
argument_list|(
name|exec_bfd
argument_list|)
expr_stmt|;
name|exec_bfd
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|exec_ops
operator|.
name|to_sections
condition|)
block|{
name|free
argument_list|(
name|exec_ops
operator|.
name|to_sections
argument_list|)
expr_stmt|;
name|exec_ops
operator|.
name|to_sections
operator|=
name|NULL
expr_stmt|;
name|exec_ops
operator|.
name|to_sections_end
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * exec_file_command -	handle the "exec" command,&c.  */
end_comment

begin_function
name|void
name|exec_file_command
parameter_list|(
name|filename
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|target_preopen
argument_list|(
name|from_tty
argument_list|)
expr_stmt|;
comment|/* Remove any previous exec file.  */
name|unpush_target
argument_list|(
operator|&
name|exec_ops
argument_list|)
expr_stmt|;
comment|/* Now open and digest the file the user requested, if any. */
if|if
condition|(
name|filename
condition|)
block|{
name|char
modifier|*
name|scratch_pathname
decl_stmt|;
name|int
name|scratch_chan
decl_stmt|;
name|filename
operator|=
name|tilde_expand
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|free
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|scratch_chan
operator|=
name|openp
argument_list|(
name|getenv
argument_list|(
literal|"PATH"
argument_list|)
argument_list|,
literal|1
argument_list|,
name|filename
argument_list|,
name|write_files
condition|?
name|O_RDWR
else|:
name|O_RDONLY
argument_list|,
literal|0
argument_list|,
operator|&
name|scratch_pathname
argument_list|)
expr_stmt|;
if|if
condition|(
name|scratch_chan
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|exec_bfd
operator|=
name|bfd_fdopenr
argument_list|(
name|scratch_pathname
argument_list|,
name|NULL
argument_list|,
name|scratch_chan
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|exec_bfd
condition|)
name|error
argument_list|(
literal|"Could not open `%s' as an executable file: %s"
argument_list|,
name|scratch_pathname
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_error
argument_list|)
argument_list|)
expr_stmt|;
comment|/* make sure we have an object file */
if|if
condition|(
operator|!
name|bfd_check_format
argument_list|(
name|exec_bfd
argument_list|,
name|bfd_object
argument_list|)
condition|)
name|error
argument_list|(
literal|"\"%s\": not in executable format: %s."
argument_list|,
name|scratch_pathname
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_error
argument_list|)
argument_list|)
expr_stmt|;
comment|/* setup initial vmap */
name|map_vmap
argument_list|(
name|exec_bfd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|vmap
condition|)
name|error
argument_list|(
literal|"Can't find the file sections in `%s': %s"
argument_list|,
name|exec_bfd
operator|->
name|filename
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_error
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|build_section_table
argument_list|(
name|exec_bfd
argument_list|,
operator|&
name|exec_ops
operator|.
name|to_sections
argument_list|,
operator|&
name|exec_ops
operator|.
name|to_sections_end
argument_list|)
condition|)
name|error
argument_list|(
literal|"Can't find the file sections in `%s': %s"
argument_list|,
name|exec_bfd
operator|->
name|filename
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_error
argument_list|)
argument_list|)
expr_stmt|;
comment|/* make sure core, if present, matches */
name|validate_files
argument_list|()
expr_stmt|;
name|push_target
argument_list|(
operator|&
name|exec_ops
argument_list|)
expr_stmt|;
comment|/* Tell display code(if any) about the changed file name. */
if|if
condition|(
name|exec_file_display_hook
condition|)
call|(
modifier|*
name|exec_file_display_hook
call|)
argument_list|(
name|filename
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|exec_close
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* just in case	*/
if|if
condition|(
name|from_tty
condition|)
name|printf
argument_list|(
literal|"No exec file now.\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Set both the exec file and the symbol file, in one command.  What a  * novelty.  Why did GDB go through four major releases before this  * command was added?  */
end_comment

begin_function
specifier|static
name|void
name|file_command
parameter_list|(
name|arg
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|exec_file_command
argument_list|(
name|arg
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
name|symbol_file_command
argument_list|(
name|arg
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Locate all mappable sections of a BFD file.     table_pp_char is a char * to get it through bfd_map_over_sections;    we cast it back to its proper type.  */
end_comment

begin_function
specifier|static
name|void
name|add_to_section_table
parameter_list|(
name|abfd
parameter_list|,
name|asect
parameter_list|,
name|table_pp_char
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|sec_ptr
name|asect
decl_stmt|;
name|char
modifier|*
name|table_pp_char
decl_stmt|;
block|{
name|struct
name|section_table
modifier|*
modifier|*
name|table_pp
init|=
operator|(
expr|struct
name|section_table
operator|*
operator|*
operator|)
name|table_pp_char
decl_stmt|;
name|flagword
name|aflag
decl_stmt|;
name|aflag
operator|=
name|bfd_get_section_flags
argument_list|(
name|abfd
argument_list|,
name|asect
argument_list|)
expr_stmt|;
comment|/* FIXME, we need to handle BSS segment here...it alloc's but doesn't load */
if|if
condition|(
operator|!
operator|(
name|aflag
operator|&
name|SEC_LOAD
operator|)
condition|)
return|return;
if|if
condition|(
literal|0
operator|==
name|bfd_section_size
argument_list|(
name|abfd
argument_list|,
name|asect
argument_list|)
condition|)
return|return;
operator|(
operator|*
name|table_pp
operator|)
operator|->
name|bfd
operator|=
name|abfd
expr_stmt|;
operator|(
operator|*
name|table_pp
operator|)
operator|->
name|sec_ptr
operator|=
name|asect
expr_stmt|;
operator|(
operator|*
name|table_pp
operator|)
operator|->
name|addr
operator|=
name|bfd_section_vma
argument_list|(
name|abfd
argument_list|,
name|asect
argument_list|)
expr_stmt|;
operator|(
operator|*
name|table_pp
operator|)
operator|->
name|endaddr
operator|=
operator|(
operator|*
name|table_pp
operator|)
operator|->
name|addr
operator|+
name|bfd_section_size
argument_list|(
name|abfd
argument_list|,
name|asect
argument_list|)
expr_stmt|;
operator|(
operator|*
name|table_pp
operator|)
operator|++
expr_stmt|;
block|}
end_function

begin_function
name|int
name|build_section_table
parameter_list|(
name|some_bfd
parameter_list|,
name|start
parameter_list|,
name|end
parameter_list|)
name|bfd
modifier|*
name|some_bfd
decl_stmt|;
name|struct
name|section_table
modifier|*
modifier|*
name|start
decl_stmt|,
decl|*
modifier|*
name|end
decl_stmt|;
end_function

begin_block
block|{
name|unsigned
name|count
decl_stmt|;
name|count
operator|=
name|bfd_count_sections
argument_list|(
name|some_bfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* return 1? */
if|if
condition|(
operator|*
name|start
condition|)
name|free
argument_list|(
operator|*
name|start
argument_list|)
expr_stmt|;
operator|*
name|start
operator|=
operator|(
expr|struct
name|section_table
operator|*
operator|)
name|xmalloc
argument_list|(
name|count
operator|*
sizeof|sizeof
argument_list|(
operator|*
operator|*
name|start
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|end
operator|=
operator|*
name|start
expr_stmt|;
name|bfd_map_over_sections
argument_list|(
name|some_bfd
argument_list|,
name|add_to_section_table
argument_list|,
operator|(
name|char
operator|*
operator|)
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|end
operator|>
operator|*
name|start
operator|+
name|count
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* We could realloc the table, but it probably loses for most files.  */
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/*  * lookup_symtab_bfd -	find if we currently have any symbol tables from bfd  */
end_comment

begin_function
name|struct
name|objfile
modifier|*
name|lookup_objfile_bfd
parameter_list|(
name|bfd
modifier|*
name|bfd
parameter_list|)
block|{
specifier|register
name|struct
name|objfile
modifier|*
name|s
decl_stmt|;
for|for
control|(
name|s
operator|=
name|object_files
init|;
name|s
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
if|if
condition|(
name|s
operator|->
name|obfd
operator|==
name|bfd
condition|)
return|return
name|s
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|sex_to_vmap
parameter_list|(
name|bfd
modifier|*
name|bf
parameter_list|,
name|sec_ptr
name|sex
parameter_list|,
name|struct
name|vmap_and_bfd
modifier|*
name|vmap_bfd
parameter_list|)
block|{
specifier|register
name|struct
name|vmap
modifier|*
name|vp
decl_stmt|,
modifier|*
modifier|*
name|vpp
decl_stmt|;
specifier|register
name|struct
name|symtab
modifier|*
name|syms
decl_stmt|;
name|bfd
modifier|*
name|arch
init|=
name|vmap_bfd
operator|->
name|pbfd
decl_stmt|;
name|vp
operator|=
name|vmap_bfd
operator|->
name|pvmap
expr_stmt|;
if|if
condition|(
operator|(
name|bfd_get_section_flags
argument_list|(
name|bf
argument_list|,
name|sex
argument_list|)
operator|&
name|SEC_LOAD
operator|)
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|bfd_section_name
argument_list|(
name|bf
argument_list|,
name|sex
argument_list|)
argument_list|,
literal|".text"
argument_list|)
condition|)
block|{
name|vp
operator|->
name|tstart
operator|=
literal|0
expr_stmt|;
name|vp
operator|->
name|tend
operator|=
name|vp
operator|->
name|tstart
operator|+
name|bfd_section_size
argument_list|(
name|bf
argument_list|,
name|sex
argument_list|)
expr_stmt|;
comment|/* When it comes to this adjustment value, in contrast to our previous        belief shared objects should behave the same as the main load segment.        This is the offset from the beginning of text section to the first        real instruction. */
name|vp
operator|->
name|tadj
operator|=
name|sex
operator|->
name|filepos
operator|-
name|bfd_section_vma
argument_list|(
name|bf
argument_list|,
name|sex
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|bfd_section_name
argument_list|(
name|bf
argument_list|,
name|sex
argument_list|)
argument_list|,
literal|".data"
argument_list|)
condition|)
block|{
name|vp
operator|->
name|dstart
operator|=
literal|0
expr_stmt|;
name|vp
operator|->
name|dend
operator|=
name|vp
operator|->
name|dstart
operator|+
name|bfd_section_size
argument_list|(
name|bf
argument_list|,
name|sex
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|bfd_section_name
argument_list|(
name|bf
argument_list|,
name|sex
argument_list|)
argument_list|,
literal|".bss"
argument_list|)
condition|)
comment|/* FIXMEmgo */
name|printf
argument_list|(
literal|"bss section in exec! Don't know what the heck to do!\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Make a vmap for the BFD "bf", which might be a member of the archive    BFD "arch".  If we have not yet read in symbols for this file, do so.  */
end_comment

begin_macro
name|map_vmap
argument_list|(
argument|bfd *bf
argument_list|,
argument|bfd *arch
argument_list|)
end_macro

begin_block
block|{
name|struct
name|vmap_and_bfd
name|vmap_bfd
decl_stmt|;
name|struct
name|vmap
modifier|*
name|vp
decl_stmt|,
modifier|*
modifier|*
name|vpp
decl_stmt|;
name|struct
name|objfile
modifier|*
name|obj
decl_stmt|;
name|vp
operator|=
operator|(
name|void
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|vp
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|vp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|vp
argument_list|)
argument_list|)
expr_stmt|;
name|vp
operator|->
name|nxt
operator|=
literal|0
expr_stmt|;
name|vp
operator|->
name|bfd
operator|=
name|bf
expr_stmt|;
name|vp
operator|->
name|name
operator|=
name|bfd_get_filename
argument_list|(
name|arch
condition|?
name|arch
else|:
name|bf
argument_list|)
expr_stmt|;
name|vp
operator|->
name|member
operator|=
name|arch
condition|?
name|bfd_get_filename
argument_list|(
name|bf
argument_list|)
else|:
literal|""
expr_stmt|;
name|vmap_bfd
operator|.
name|pbfd
operator|=
name|arch
expr_stmt|;
name|vmap_bfd
operator|.
name|pvmap
operator|=
name|vp
expr_stmt|;
name|bfd_map_over_sections
argument_list|(
name|bf
argument_list|,
name|sex_to_vmap
argument_list|,
operator|&
name|vmap_bfd
argument_list|)
expr_stmt|;
name|obj
operator|=
name|lookup_objfile_bfd
argument_list|(
name|bf
argument_list|)
expr_stmt|;
if|if
condition|(
name|exec_bfd
operator|&&
operator|!
name|obj
condition|)
block|{
name|obj
operator|=
name|allocate_objfile
argument_list|(
name|bf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* This is only needed if we want to load shared libraries no matter what.        Since we provide the choice of incremental loading of shared objects        now, we do not have to load them as default anymore. */
block|syms_from_objfile (obj, 0, 0, 0);     new_symfile_objfile (obj, 0, 0);
endif|#
directive|endif
block|}
comment|/* find the end of the list, and append. */
for|for
control|(
name|vpp
operator|=
operator|&
name|vmap
init|;
operator|*
name|vpp
condition|;
name|vpp
operator|=
operator|&
operator|(
operator|*
name|vpp
operator|)
operator|->
name|nxt
control|)
empty_stmt|;
operator|*
name|vpp
operator|=
name|vp
expr_stmt|;
block|}
end_block

begin_comment
comment|/* true, if symbol table and minimal symbol table are relocated. */
end_comment

begin_decl_stmt
name|int
name|symtab_relocated
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  vmap_symtab -	handle symbol translation on vmapping */
end_comment

begin_expr_stmt
name|vmap_symtab
argument_list|(
name|vp
argument_list|,
name|old_start
argument_list|,
name|vip
argument_list|)
specifier|register
expr|struct
name|vmap
operator|*
name|vp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|CORE_ADDR
name|old_start
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|stat
modifier|*
name|vip
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
specifier|register
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
specifier|register
name|struct
name|minimal_symbol
modifier|*
name|msymbol
decl_stmt|;
comment|/*    * for each symbol table generated from the vp->bfd    */
name|ALL_OBJFILES
argument_list|(
argument|objfile
argument_list|)
block|{
for|for
control|(
name|s
operator|=
name|objfile
operator|->
name|symtabs
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
comment|/* skip over if this is not relocatable and doesn't have a line table */
if|if
condition|(
name|s
operator|->
name|nonreloc
operator|&&
operator|!
name|LINETABLE
argument_list|(
name|s
argument_list|)
condition|)
continue|continue;
comment|/* matching the symbol table's BFD and the *vp's BFD is hairy. 	   exec_file creates a seperate BFD for possibly the 	   same file as symbol_file.FIXME ALL THIS MUST BE RECTIFIED. */
if|if
condition|(
name|objfile
operator|->
name|obfd
operator|==
name|vp
operator|->
name|bfd
condition|)
block|{
comment|/* if they match, we luck out. */
empty_stmt|;
block|}
elseif|else
if|if
condition|(
name|vp
operator|->
name|member
index|[
literal|0
index|]
condition|)
block|{
comment|/* no match, and member present, not this one. */
continue|continue;
block|}
else|else
block|{
name|struct
name|stat
name|si
decl_stmt|;
name|FILE
modifier|*
name|io
decl_stmt|;
comment|/* 	   * no match, and no member. need to be sure. 	   */
name|io
operator|=
name|bfd_cache_lookup
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|io
condition|)
name|fatal
argument_list|(
literal|"cannot find BFD's iostream for sym"
argument_list|)
expr_stmt|;
comment|/* 	   * see if we are referring to the same file 	   */
if|if
condition|(
name|fstat
argument_list|(
name|fileno
argument_list|(
name|io
argument_list|)
argument_list|,
operator|&
name|si
argument_list|)
operator|<
literal|0
condition|)
name|fatal
argument_list|(
literal|"cannot fstat BFD for sym"
argument_list|)
expr_stmt|;
if|if
condition|(
name|vip
operator|&&
operator|(
name|si
operator|.
name|st_dev
operator|!=
name|vip
operator|->
name|st_dev
operator|||
name|si
operator|.
name|st_ino
operator|!=
name|vip
operator|->
name|st_ino
operator|)
condition|)
continue|continue;
block|}
if|if
condition|(
name|vp
operator|->
name|tstart
operator|!=
name|old_start
condition|)
block|{
comment|/* Once we find a relocation base address for one of the symtabs 	     in this objfile, it will be the same for all symtabs in this 	     objfile. Clean this algorithm. FIXME. */
for|for
control|(
init|;
name|s
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
if|if
condition|(
operator|!
name|s
operator|->
name|nonreloc
operator|||
name|LINETABLE
argument_list|(
name|s
argument_list|)
condition|)
name|vmap_symtab_1
argument_list|(
name|s
argument_list|,
name|vp
argument_list|,
name|old_start
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|Himm.., recently we nullified trampoline entry names in order not 	  to confuse them with real symbols.  Appearently this turned into a 	  problem, and msymbol vector did not get relocated properly.  If 	  msymbols have to have non-null names, then we should name 	  trampoline entries with empty strings.   	  ALL_MSYMBOLS (objfile, msymbol)
else|#
directive|else
for|for
control|(
name|msymbol
operator|=
name|objfile
operator|->
name|msymbols
init|;
name|msymbol
operator|->
name|name
operator|||
name|msymbol
operator|->
name|address
condition|;
operator|(
name|msymbol
operator|)
operator|++
control|)
endif|#
directive|endif
if|if
condition|(
name|msymbol
operator|->
name|address
operator|<
name|TEXT_SEGMENT_BASE
condition|)
name|msymbol
operator|->
name|address
operator|+=
name|vp
operator|->
name|tstart
operator|-
name|old_start
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|vp
operator|->
name|tstart
operator|!=
name|old_start
condition|)
block|{
comment|/* breakpoints need to be relocated as well. */
name|fixup_breakpoints
argument_list|(
literal|0
argument_list|,
name|TEXT_SEGMENT_BASE
argument_list|,
name|vp
operator|->
name|tstart
operator|-
name|old_start
argument_list|)
expr_stmt|;
block|}
name|symtab_relocated
operator|=
literal|1
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|vmap_symtab_1
argument_list|(
name|s
argument_list|,
name|vp
argument_list|,
name|old_start
argument_list|)
specifier|register
expr|struct
name|symtab
operator|*
name|s
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|vmap
modifier|*
name|vp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|CORE_ADDR
name|old_start
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|len
decl_stmt|,
name|blen
decl_stmt|;
specifier|register
name|struct
name|linetable
modifier|*
name|l
decl_stmt|;
name|struct
name|blockvector
modifier|*
name|bv
decl_stmt|;
specifier|register
name|struct
name|block
modifier|*
name|b
decl_stmt|;
name|int
name|depth
decl_stmt|;
specifier|register
name|ulong
name|reloc
decl_stmt|,
name|dreloc
decl_stmt|;
if|if
condition|(
operator|(
name|reloc
operator|=
name|vp
operator|->
name|tstart
operator|-
name|old_start
operator|)
operator|==
literal|0
condition|)
return|return;
name|dreloc
operator|=
name|vp
operator|->
name|dstart
expr_stmt|;
comment|/* data relocation */
comment|/*      * The line table must be relocated.  This is only present for      * .text sections, so only vp->text type maps need be considered.      */
name|l
operator|=
name|LINETABLE
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
condition|)
block|{
name|len
operator|=
name|l
operator|->
name|nitems
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
name|l
operator|->
name|item
index|[
name|i
index|]
operator|.
name|pc
operator|+=
name|reloc
expr_stmt|;
block|}
comment|/* if this symbol table is not relocatable, only line table should        be relocated and the rest ignored. */
if|if
condition|(
name|s
operator|->
name|nonreloc
condition|)
return|return;
name|bv
operator|=
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|len
operator|=
name|BLOCKVECTOR_NBLOCKS
argument_list|(
name|bv
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|b
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|BLOCK_START
argument_list|(
name|b
argument_list|)
operator|+=
name|reloc
expr_stmt|;
name|BLOCK_END
argument_list|(
name|b
argument_list|)
operator|+=
name|reloc
expr_stmt|;
name|blen
operator|=
name|BLOCK_NSYMS
argument_list|(
name|b
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|blen
condition|;
name|j
operator|++
control|)
block|{
specifier|register
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
name|sym
operator|=
name|BLOCK_SYM
argument_list|(
name|b
argument_list|,
name|j
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|SYMBOL_NAMESPACE
argument_list|(
name|sym
argument_list|)
condition|)
block|{
case|case
name|STRUCT_NAMESPACE
case|:
case|case
name|UNDEF_NAMESPACE
case|:
continue|continue;
case|case
name|LABEL_NAMESPACE
case|:
case|case
name|VAR_NAMESPACE
case|:
break|break;
block|}
switch|switch
condition|(
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
condition|)
block|{
case|case
name|LOC_CONST
case|:
case|case
name|LOC_CONST_BYTES
case|:
case|case
name|LOC_LOCAL
case|:
case|case
name|LOC_REGISTER
case|:
case|case
name|LOC_ARG
case|:
case|case
name|LOC_LOCAL_ARG
case|:
case|case
name|LOC_REF_ARG
case|:
case|case
name|LOC_REGPARM
case|:
case|case
name|LOC_TYPEDEF
case|:
continue|continue;
ifdef|#
directive|ifdef
name|FIXME
case|case
name|LOC_EXTERNAL
case|:
endif|#
directive|endif
case|case
name|LOC_LABEL
case|:
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|sym
argument_list|)
operator|+=
name|reloc
expr_stmt|;
break|break;
case|case
name|LOC_STATIC
case|:
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|sym
argument_list|)
operator|+=
name|dreloc
expr_stmt|;
break|break;
case|case
name|LOC_BLOCK
case|:
break|break;
default|default:
name|fatal
argument_list|(
literal|"botched symbol class %x"
argument_list|,
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
end_block

begin_comment
comment|/*  * add_vmap -	add a new vmap entry based on ldinfo() information  */
end_comment

begin_expr_stmt
name|add_vmap
argument_list|(
name|ldi
argument_list|)
specifier|register
expr|struct
name|ld_info
operator|*
name|ldi
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|bfd
modifier|*
name|bfd
decl_stmt|,
modifier|*
name|last
decl_stmt|;
specifier|register
name|char
modifier|*
name|mem
decl_stmt|,
modifier|*
name|objname
decl_stmt|;
comment|/* This ldi structure was allocated using alloca() in  	   xcoff_relocate_symtab(). Now we need to have persistent object  	   and member names, so we should save them. */
name|mem
operator|=
name|ldi
operator|->
name|ldinfo_filename
operator|+
name|strlen
argument_list|(
name|ldi
operator|->
name|ldinfo_filename
argument_list|)
operator|+
literal|1
expr_stmt|;
name|mem
operator|=
name|savestring
argument_list|(
name|mem
argument_list|,
name|strlen
argument_list|(
name|mem
argument_list|)
argument_list|)
expr_stmt|;
name|objname
operator|=
name|savestring
argument_list|(
name|ldi
operator|->
name|ldinfo_filename
argument_list|,
name|strlen
argument_list|(
name|ldi
operator|->
name|ldinfo_filename
argument_list|)
argument_list|)
expr_stmt|;
name|bfd
operator|=
name|bfd_fdopenr
argument_list|(
name|objname
argument_list|,
name|NULL
argument_list|,
name|ldi
operator|->
name|ldinfo_fd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd
condition|)
name|error
argument_list|(
literal|"Could not open `%s' as an executable file: %s"
argument_list|,
name|objname
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_error
argument_list|)
argument_list|)
expr_stmt|;
comment|/* make sure we have an object file */
if|if
condition|(
name|bfd_check_format
argument_list|(
name|bfd
argument_list|,
name|bfd_object
argument_list|)
condition|)
name|map_vmap
argument_list|(
name|bfd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|bfd_check_format
argument_list|(
name|bfd
argument_list|,
name|bfd_archive
argument_list|)
condition|)
block|{
name|last
operator|=
literal|0
expr_stmt|;
comment|/* 		 * FIXME??? am I tossing BFDs?  bfd? 		 */
while|while
condition|(
name|last
operator|=
name|bfd_openr_next_archived_file
argument_list|(
name|bfd
argument_list|,
name|last
argument_list|)
condition|)
if|if
condition|(
name|eq
argument_list|(
name|mem
argument_list|,
name|last
operator|->
name|filename
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|!
name|last
condition|)
block|{
name|bfd_close
argument_list|(
name|bfd
argument_list|)
expr_stmt|;
comment|/* FIXME -- should be error */
name|warning
argument_list|(
literal|"\"%s\": member \"%s\" missing."
argument_list|,
name|bfd
operator|->
name|filename
argument_list|,
name|mem
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|bfd_check_format
argument_list|(
name|last
argument_list|,
name|bfd_object
argument_list|)
condition|)
block|{
name|bfd_close
argument_list|(
name|last
argument_list|)
expr_stmt|;
comment|/* XXX???	*/
goto|goto
name|obj_err
goto|;
block|}
name|map_vmap
argument_list|(
name|last
argument_list|,
name|bfd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|obj_err
label|:
name|bfd_close
argument_list|(
name|bfd
argument_list|)
expr_stmt|;
comment|/* FIXME -- should be error */
name|warning
argument_list|(
literal|"\"%s\": not in executable format: %s."
argument_list|,
name|objname
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_error
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_block

begin_comment
comment|/* As well as symbol tables, exec_sections need relocation. After    the inferior process' termination, there will be a relocated symbol    table exist with no corresponding inferior process. At that time, we    need to use `exec' bfd, rather than the inferior process's memory space    to look up symbols.     `exec_sections' need to be relocated only once, as long as the exec    file remains unchanged. */
end_comment

begin_macro
name|vmap_exec
argument_list|()
end_macro

begin_block
block|{
specifier|static
name|bfd
modifier|*
name|execbfd
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|execbfd
operator|==
name|exec_bfd
condition|)
return|return;
name|execbfd
operator|=
name|exec_bfd
expr_stmt|;
if|if
condition|(
operator|!
name|vmap
operator|||
operator|!
name|exec_ops
operator|.
name|to_sections
condition|)
name|error
argument_list|(
literal|"vmap_exec: vmap or exec_ops.to_sections == 0\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|&
name|exec_ops
operator|.
name|to_sections
index|[
name|i
index|]
operator|<
name|exec_ops
operator|.
name|to_sections_end
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
literal|".text"
argument_list|,
name|exec_ops
operator|.
name|to_sections
index|[
name|i
index|]
operator|.
name|sec_ptr
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|exec_ops
operator|.
name|to_sections
index|[
name|i
index|]
operator|.
name|addr
operator|+=
name|vmap
operator|->
name|tstart
expr_stmt|;
name|exec_ops
operator|.
name|to_sections
index|[
name|i
index|]
operator|.
name|endaddr
operator|+=
name|vmap
operator|->
name|tstart
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
literal|".data"
argument_list|,
name|exec_ops
operator|.
name|to_sections
index|[
name|i
index|]
operator|.
name|sec_ptr
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|exec_ops
operator|.
name|to_sections
index|[
name|i
index|]
operator|.
name|addr
operator|+=
name|vmap
operator|->
name|dstart
expr_stmt|;
name|exec_ops
operator|.
name|to_sections
index|[
name|i
index|]
operator|.
name|endaddr
operator|+=
name|vmap
operator|->
name|dstart
expr_stmt|;
block|}
block|}
block|}
end_block

begin_function
name|int
name|text_adjustment
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
specifier|static
name|bfd
modifier|*
name|execbfd
decl_stmt|;
specifier|static
name|int
name|adjustment
decl_stmt|;
name|sec_ptr
name|sect
decl_stmt|;
if|if
condition|(
name|exec_bfd
operator|==
name|execbfd
condition|)
return|return
name|adjustment
return|;
name|sect
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".text"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sect
condition|)
name|adjustment
operator|=
name|sect
operator|->
name|filepos
operator|-
name|sect
operator|->
name|vma
expr_stmt|;
else|else
name|adjustment
operator|=
literal|0x200
expr_stmt|;
comment|/* just a wild assumption */
return|return
name|adjustment
return|;
block|}
end_function

begin_comment
comment|/*  * vmap_ldinfo -	update VMAP info with ldinfo() information  *  * Input:  *	ldi	-	^ to ldinfo() results.  */
end_comment

begin_expr_stmt
name|vmap_ldinfo
argument_list|(
name|ldi
argument_list|)
specifier|register
expr|struct
name|ld_info
operator|*
name|ldi
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|struct
name|stat
name|ii
decl_stmt|,
name|vi
decl_stmt|;
specifier|register
name|struct
name|vmap
modifier|*
name|vp
decl_stmt|;
specifier|register
name|got_one
operator|,
name|retried
expr_stmt|;
name|CORE_ADDR
name|ostart
decl_stmt|;
comment|/*    * for each *ldi, see if we have a corresponding *vp    *	if so, update the mapping, and symbol table.    *	if not, add an entry and symbol table.    */
do|do
block|{
name|char
modifier|*
name|name
init|=
name|ldi
operator|->
name|ldinfo_filename
decl_stmt|;
name|char
modifier|*
name|memb
init|=
name|name
operator|+
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
decl_stmt|;
name|retried
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|fstat
argument_list|(
name|ldi
operator|->
name|ldinfo_fd
argument_list|,
operator|&
name|ii
argument_list|)
operator|<
literal|0
condition|)
name|fatal
argument_list|(
literal|"cannot fstat(%d) on %s"
argument_list|,
name|ldi
operator|->
name|ldinfo_fd
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|retry
label|:
for|for
control|(
name|got_one
operator|=
literal|0
operator|,
name|vp
operator|=
name|vmap
init|;
name|vp
condition|;
name|vp
operator|=
name|vp
operator|->
name|nxt
control|)
block|{
name|FILE
modifier|*
name|io
decl_stmt|;
comment|/* First try to find a `vp', which is the same as in ldinfo. 	     If not the same, just continue and grep the next `vp'. If same, 	     relocate its tstart, tend, dstart, dend values. If no such `vp' 	     found, get out of this for loop, add this ldi entry as a new vmap 	     (add_vmap) and come back, fins its `vp' and so on... */
comment|/* The filenames are not always sufficient to match on. */
if|if
condition|(
operator|(
name|name
index|[
literal|0
index|]
operator|==
literal|"/"
operator|&&
operator|!
name|eq
argument_list|(
name|name
argument_list|,
name|vp
operator|->
name|name
argument_list|)
operator|)
operator|||
operator|(
name|memb
index|[
literal|0
index|]
operator|&&
operator|!
name|eq
argument_list|(
name|memb
argument_list|,
name|vp
operator|->
name|member
argument_list|)
operator|)
condition|)
continue|continue;
name|io
operator|=
name|bfd_cache_lookup
argument_list|(
name|vp
operator|->
name|bfd
argument_list|)
expr_stmt|;
comment|/* totally opaque! */
if|if
condition|(
operator|!
name|io
condition|)
name|fatal
argument_list|(
literal|"cannot find BFD's iostream for %s"
argument_list|,
name|vp
operator|->
name|name
argument_list|)
expr_stmt|;
comment|/* see if we are referring to the same file */
if|if
condition|(
name|fstat
argument_list|(
name|fileno
argument_list|(
name|io
argument_list|)
argument_list|,
operator|&
name|vi
argument_list|)
operator|<
literal|0
condition|)
name|fatal
argument_list|(
literal|"cannot fstat BFD for %s"
argument_list|,
name|vp
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|ii
operator|.
name|st_dev
operator|!=
name|vi
operator|.
name|st_dev
operator|||
name|ii
operator|.
name|st_ino
operator|!=
name|vi
operator|.
name|st_ino
condition|)
continue|continue;
if|if
condition|(
operator|!
name|retried
condition|)
name|close
argument_list|(
name|ldi
operator|->
name|ldinfo_fd
argument_list|)
expr_stmt|;
operator|++
name|got_one
expr_stmt|;
comment|/* found a corresponding VMAP. remap! */
name|ostart
operator|=
name|vp
operator|->
name|tstart
expr_stmt|;
name|vp
operator|->
name|tstart
operator|=
name|ldi
operator|->
name|ldinfo_textorg
expr_stmt|;
name|vp
operator|->
name|tend
operator|=
name|vp
operator|->
name|tstart
operator|+
name|ldi
operator|->
name|ldinfo_textsize
expr_stmt|;
name|vp
operator|->
name|dstart
operator|=
name|ldi
operator|->
name|ldinfo_dataorg
expr_stmt|;
name|vp
operator|->
name|dend
operator|=
name|vp
operator|->
name|dstart
operator|+
name|ldi
operator|->
name|ldinfo_datasize
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|tadj
condition|)
block|{
name|vp
operator|->
name|tstart
operator|+=
name|vp
operator|->
name|tadj
expr_stmt|;
name|vp
operator|->
name|tend
operator|+=
name|vp
operator|->
name|tadj
expr_stmt|;
block|}
comment|/* relocate symbol table(s). */
name|vmap_symtab
argument_list|(
name|vp
argument_list|,
name|ostart
argument_list|,
operator|&
name|vi
argument_list|)
expr_stmt|;
comment|/* there may be more, so we don't break out of the loop. */
block|}
comment|/* if there was no matching *vp, we must perforce create the sucker(s) */
if|if
condition|(
operator|!
name|got_one
operator|&&
operator|!
name|retried
condition|)
block|{
name|add_vmap
argument_list|(
name|ldi
argument_list|)
expr_stmt|;
operator|++
name|retried
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
block|}
do|while
condition|(
name|ldi
operator|->
name|ldinfo_next
operator|&&
operator|(
name|ldi
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|ldi
operator|->
name|ldinfo_next
operator|+
operator|(
name|char
operator|*
operator|)
name|ldi
operator|)
operator|)
condition|)
do|;
block|}
end_block

begin_comment
comment|/*  * vmap_inferior -	print VMAP info for inferior  */
end_comment

begin_macro
name|vmap_inferior
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|inferior_pid
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* normal processing	*/
name|exec_files_info
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
block|}
end_block

begin_comment
comment|/* Read or write the exec file.     Args are address within exec file, address within gdb address-space,    length, and a flag indicating whether to read or write.     Result is a length:  	0:    We cannot handle this address and length.> 0:  We have handled N bytes starting at this address. 	      (If N == length, we did it all.)  We might be able 	      to handle more bytes beyond this length, but no 	      promises.< 0:  We cannot handle this address, but if somebody 	      else handles (-N) bytes, we can start from there.      The same routine is used to handle both core and exec files;     we just tail-call it with more arguments to select between them.  */
end_comment

begin_function
name|int
name|xfer_memory
parameter_list|(
name|memaddr
parameter_list|,
name|myaddr
parameter_list|,
name|len
parameter_list|,
name|write
parameter_list|,
name|target
parameter_list|)
name|CORE_ADDR
name|memaddr
decl_stmt|;
name|char
modifier|*
name|myaddr
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|write
decl_stmt|;
name|struct
name|target_ops
modifier|*
name|target
decl_stmt|;
block|{
name|boolean
name|res
decl_stmt|;
name|struct
name|section_table
modifier|*
name|p
decl_stmt|;
name|CORE_ADDR
name|nextsectaddr
decl_stmt|,
name|memend
decl_stmt|;
name|boolean
argument_list|(
argument|*xfer_fn
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|sec_ptr
operator|,
name|PTR
operator|,
name|file_ptr
operator|,
name|bfd_size_type
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|memend
operator|=
name|memaddr
operator|+
name|len
expr_stmt|;
name|xfer_fn
operator|=
name|write
condition|?
name|bfd_set_section_contents
else|:
name|bfd_get_section_contents
expr_stmt|;
name|nextsectaddr
operator|=
name|memend
expr_stmt|;
for|for
control|(
name|p
operator|=
name|target
operator|->
name|to_sections
init|;
name|p
operator|<
name|target
operator|->
name|to_sections_end
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
name|p
operator|->
name|addr
operator|<=
name|memaddr
condition|)
if|if
condition|(
name|p
operator|->
name|endaddr
operator|>=
name|memend
condition|)
block|{
comment|/* Entire transfer is within this section.  */
name|res
operator|=
name|xfer_fn
argument_list|(
name|p
operator|->
name|bfd
argument_list|,
name|p
operator|->
name|sec_ptr
argument_list|,
name|myaddr
argument_list|,
name|memaddr
operator|-
name|p
operator|->
name|addr
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
operator|(
name|res
operator|!=
name|false
operator|)
condition|?
name|len
else|:
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|endaddr
operator|<=
name|memaddr
condition|)
block|{
comment|/* This section ends before the transfer starts.  */
continue|continue;
block|}
else|else
block|{
comment|/* This section overlaps the transfer.  Just do half.  */
name|len
operator|=
name|p
operator|->
name|endaddr
operator|-
name|memaddr
expr_stmt|;
name|res
operator|=
name|xfer_fn
argument_list|(
name|p
operator|->
name|bfd
argument_list|,
name|p
operator|->
name|sec_ptr
argument_list|,
name|myaddr
argument_list|,
name|memaddr
operator|-
name|p
operator|->
name|addr
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
operator|(
name|res
operator|!=
name|false
operator|)
condition|?
name|len
else|:
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|addr
operator|<
name|nextsectaddr
condition|)
name|nextsectaddr
operator|=
name|p
operator|->
name|addr
expr_stmt|;
block|}
if|if
condition|(
name|nextsectaddr
operator|>=
name|memend
condition|)
return|return
literal|0
return|;
comment|/* We can't help */
else|else
return|return
operator|-
operator|(
name|nextsectaddr
operator|-
name|memaddr
operator|)
return|;
comment|/* Next boundary where we can help */
block|}
end_function

begin_function
name|void
name|print_section_info
parameter_list|(
name|t
parameter_list|,
name|abfd
parameter_list|)
name|struct
name|target_ops
modifier|*
name|t
decl_stmt|;
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|struct
name|section_table
modifier|*
name|p
decl_stmt|;
name|printf_filtered
argument_list|(
literal|"\t`%s', "
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
name|wrap_here
argument_list|(
literal|"        "
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"file type %s.\n"
argument_list|,
name|bfd_get_target
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|t
operator|->
name|to_sections
init|;
name|p
operator|<
name|t
operator|->
name|to_sections_end
condition|;
name|p
operator|++
control|)
block|{
name|printf_filtered
argument_list|(
literal|"\t%s"
argument_list|,
name|local_hex_string_custom
argument_list|(
name|p
operator|->
name|addr
argument_list|,
literal|"08"
argument_list|)
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|" - %s"
argument_list|,
name|local_hex_string_custom
argument_list|(
name|p
operator|->
name|endaddr
argument_list|,
literal|"08"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|info_verbose
condition|)
name|printf_filtered
argument_list|(
literal|" @ %s"
argument_list|,
name|local_hex_string_custom
argument_list|(
name|p
operator|->
name|sec_ptr
operator|->
name|filepos
argument_list|,
literal|"08"
argument_list|)
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|" is %s"
argument_list|,
name|bfd_section_name
argument_list|(
name|p
operator|->
name|bfd
argument_list|,
name|p
operator|->
name|sec_ptr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|bfd
operator|!=
name|abfd
condition|)
block|{
name|printf_filtered
argument_list|(
literal|" in %s"
argument_list|,
name|bfd_get_filename
argument_list|(
name|p
operator|->
name|bfd
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|exec_files_info
parameter_list|(
name|t
parameter_list|)
name|struct
name|target_ops
modifier|*
name|t
decl_stmt|;
block|{
specifier|register
name|struct
name|vmap
modifier|*
name|vp
init|=
name|vmap
decl_stmt|;
name|print_section_info
argument_list|(
name|t
argument_list|,
name|exec_bfd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|vp
condition|)
return|return;
name|printf
argument_list|(
literal|"\tMapping info for file `%s'.\n"
argument_list|,
name|vp
operator|->
name|name
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\t  %8.8s   %8.8s   %8.8s   %8.8s %8.8s %s\n"
argument_list|,
literal|"tstart"
argument_list|,
literal|"tend"
argument_list|,
literal|"dstart"
argument_list|,
literal|"dend"
argument_list|,
literal|"section"
argument_list|,
literal|"file(member)"
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|vp
condition|;
name|vp
operator|=
name|vp
operator|->
name|nxt
control|)
name|printf
argument_list|(
literal|"\t0x%8.8x 0x%8.8x 0x%8.8x 0x%8.8x %s%s%s%s\n"
argument_list|,
name|vp
operator|->
name|tstart
argument_list|,
name|vp
operator|->
name|tend
argument_list|,
name|vp
operator|->
name|dstart
argument_list|,
name|vp
operator|->
name|dend
argument_list|,
name|vp
operator|->
name|name
argument_list|,
operator|*
name|vp
operator|->
name|member
condition|?
literal|"("
else|:
literal|""
argument_list|,
name|vp
operator|->
name|member
argument_list|,
operator|*
name|vp
operator|->
name|member
condition|?
literal|")"
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DAMON
end_ifdef

begin_comment
comment|/*  Damon's implementation of set_section_command! It is based on the sex member   (which is a section pointer from vmap) of vmap.   We will not have multiple vmap entries (one for each section), rather transmit   text and data base offsets and fix them at the same time. Elimination of sex   entry in vmap make this function obsolute, use the one from exec.c.    Need further testing!!	FIXMEmgo.  */
end_comment

begin_function
specifier|static
name|void
name|set_section_command
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
block|{
specifier|register
name|struct
name|vmap
modifier|*
name|vp
init|=
name|vmap
decl_stmt|;
name|char
modifier|*
name|secname
decl_stmt|;
name|unsigned
name|seclen
decl_stmt|;
name|unsigned
name|long
name|secaddr
decl_stmt|;
name|char
name|secprint
index|[
literal|100
index|]
decl_stmt|;
name|long
name|offset
decl_stmt|;
if|if
condition|(
name|args
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"Must specify section name and its virtual address"
argument_list|)
expr_stmt|;
comment|/* Parse out section name */
for|for
control|(
name|secname
operator|=
name|args
init|;
operator|!
name|isspace
argument_list|(
operator|*
name|args
argument_list|)
condition|;
name|args
operator|++
control|)
empty_stmt|;
name|seclen
operator|=
name|args
operator|-
name|secname
expr_stmt|;
comment|/* Parse out new virtual address */
name|secaddr
operator|=
name|parse_and_eval_address
argument_list|(
name|args
argument_list|)
expr_stmt|;
for|for
control|(
name|vp
operator|=
name|vmap
init|;
name|vp
condition|;
name|vp
operator|=
name|vp
operator|->
name|nxt
control|)
block|{
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|secname
argument_list|,
name|bfd_section_name
argument_list|(
name|vp
operator|->
name|bfd
argument_list|,
name|vp
operator|->
name|sex
argument_list|)
argument_list|,
name|seclen
argument_list|)
operator|&&
name|bfd_section_name
argument_list|(
name|vp
operator|->
name|bfd
argument_list|,
name|vp
operator|->
name|sex
argument_list|)
index|[
name|seclen
index|]
operator|==
literal|'\0'
condition|)
block|{
name|offset
operator|=
name|secaddr
operator|-
name|vp
operator|->
name|tstart
expr_stmt|;
name|vp
operator|->
name|tstart
operator|+=
name|offset
expr_stmt|;
name|vp
operator|->
name|tend
operator|+=
name|offset
expr_stmt|;
name|exec_files_info
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|seclen
operator|>=
sizeof|sizeof
argument_list|(
name|secprint
argument_list|)
condition|)
name|seclen
operator|=
sizeof|sizeof
argument_list|(
name|secprint
argument_list|)
operator|-
literal|1
expr_stmt|;
name|strncpy
argument_list|(
name|secprint
argument_list|,
name|secname
argument_list|,
name|seclen
argument_list|)
expr_stmt|;
name|secprint
index|[
name|seclen
index|]
operator|=
literal|'\0'
expr_stmt|;
name|error
argument_list|(
literal|"Section %s not found"
argument_list|,
name|secprint
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
specifier|static
name|void
name|set_section_command
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|struct
name|section_table
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|secname
decl_stmt|;
name|unsigned
name|seclen
decl_stmt|;
name|unsigned
name|long
name|secaddr
decl_stmt|;
name|char
name|secprint
index|[
literal|100
index|]
decl_stmt|;
name|long
name|offset
decl_stmt|;
if|if
condition|(
name|args
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"Must specify section name and its virtual address"
argument_list|)
expr_stmt|;
comment|/* Parse out section name */
for|for
control|(
name|secname
operator|=
name|args
init|;
operator|!
name|isspace
argument_list|(
operator|*
name|args
argument_list|)
condition|;
name|args
operator|++
control|)
empty_stmt|;
name|seclen
operator|=
name|args
operator|-
name|secname
expr_stmt|;
comment|/* Parse out new virtual address */
name|secaddr
operator|=
name|parse_and_eval_address
argument_list|(
name|args
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|exec_ops
operator|.
name|to_sections
init|;
name|p
operator|<
name|exec_ops
operator|.
name|to_sections_end
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|secname
argument_list|,
name|bfd_section_name
argument_list|(
name|exec_bfd
argument_list|,
name|p
operator|->
name|sec_ptr
argument_list|)
argument_list|,
name|seclen
argument_list|)
operator|&&
name|bfd_section_name
argument_list|(
name|exec_bfd
argument_list|,
name|p
operator|->
name|sec_ptr
argument_list|)
index|[
name|seclen
index|]
operator|==
literal|'\0'
condition|)
block|{
name|offset
operator|=
name|secaddr
operator|-
name|p
operator|->
name|addr
expr_stmt|;
name|p
operator|->
name|addr
operator|+=
name|offset
expr_stmt|;
name|p
operator|->
name|endaddr
operator|+=
name|offset
expr_stmt|;
if|if
condition|(
name|from_tty
condition|)
name|exec_files_info
argument_list|(
operator|&
name|exec_ops
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|seclen
operator|>=
sizeof|sizeof
argument_list|(
name|secprint
argument_list|)
condition|)
name|seclen
operator|=
sizeof|sizeof
argument_list|(
name|secprint
argument_list|)
operator|-
literal|1
expr_stmt|;
name|strncpy
argument_list|(
name|secprint
argument_list|,
name|secname
argument_list|,
name|seclen
argument_list|)
expr_stmt|;
name|secprint
index|[
name|seclen
index|]
operator|=
literal|'\0'
expr_stmt|;
name|error
argument_list|(
literal|"Section %s not found"
argument_list|,
name|secprint
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !DAMON */
end_comment

begin_decl_stmt
name|struct
name|target_ops
name|exec_ops
init|=
block|{
literal|"exec"
block|,
literal|"Local exec file"
block|,
literal|"Use an executable file as a target.\n\ Specify the filename of the executable file."
block|,
name|exec_file_command
block|,
name|exec_close
block|,
comment|/* open, close */
name|find_default_attach
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* attach, detach, resume, wait, */
literal|0
block|,
literal|0
block|,
comment|/* fetch_registers, store_registers, */
literal|0
block|,
comment|/* prepare_to_store */
name|xfer_memory
block|,
name|exec_files_info
block|,
literal|0
block|,
literal|0
block|,
comment|/* insert_breakpoint, remove_breakpoint, */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* terminal stuff */
literal|0
block|,
literal|0
block|,
comment|/* kill, load */
literal|0
block|,
comment|/* lookup sym */
name|find_default_create_inferior
block|,
literal|0
block|,
comment|/* mourn_inferior */
literal|0
block|,
comment|/* can_run */
literal|0
block|,
comment|/* notice_signals */
name|file_stratum
block|,
literal|0
block|,
comment|/* next */
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* all mem, mem, stack, regs, exec */
literal|0
block|,
literal|0
block|,
comment|/* section pointers */
name|OPS_MAGIC
block|,
comment|/* Always the last thing */
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|_initialize_exec
parameter_list|()
block|{
name|add_com
argument_list|(
literal|"file"
argument_list|,
name|class_files
argument_list|,
name|file_command
argument_list|,
literal|"Use FILE as program to be debugged.\n\ It is read for its symbols, for getting the contents of pure memory,\n\ and it is the program executed when you use the `run' command.\n\ If FILE cannot be found as specified, your execution directory path\n\ ($PATH) is searched for a command of that name.\n\ No arg means to have no executable file and no symbols."
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"exec-file"
argument_list|,
name|class_files
argument_list|,
name|exec_file_command
argument_list|,
literal|"Use FILE as program for getting contents of pure memory.\n\ If FILE cannot be found as specified, your execution directory path\n\ is searched for a command of that name.\n\ No arg means have no executable file."
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"section"
argument_list|,
name|class_files
argument_list|,
name|set_section_command
argument_list|,
literal|"Change the base address of section SECTION of the exec file to ADDR.\n\ This can be used if the exec file does not contain section addresses,\n\ (such as in the a.out format), or when the addresses specified in the\n\ file itself are wrong.  Each section must be changed separately.  The\n\ ``info files'' command lists all the sections and their addresses."
argument_list|)
expr_stmt|;
name|add_target
argument_list|(
operator|&
name|exec_ops
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

