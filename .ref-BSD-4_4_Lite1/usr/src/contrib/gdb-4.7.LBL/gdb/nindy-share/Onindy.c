begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*****************************************************************************  *  Copyright 1990, 1992 Free Software Foundation, Inc.  *  *   This code was donated by Intel Corp.  *  * Intel hereby grants you permission to copy, modify, and   * distribute this software and its documentation.  Intel grants  * this permission provided that the above copyright notice   * appears in all copies and that both the copyright notice and  * this permission notice appear in supporting documentation.  In  * addition, Intel grants this permission provided that you  * prominently mark as not part of the original any modifications  * made to this software or documentation, and that the name of   * Intel Corporation not be used in advertising or publicity   * pertaining to distribution of the software or the documentation   * without specific, written prior permission.    *  * Intel Corporation does not warrant, guarantee or make any   * representations regarding the use of, or the results of the use  * of, the software and documentation in terms of correctness,   * accuracy, reliability, currentness, or otherwise; and you rely  * on the software, documentation and results solely at your own risk.  *****************************************************************************/
end_comment

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"Id: Onindy.c,v 1.1.1.1 1991/03/28 16:20:43 rich Exp $"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/******************************************************************************  *  *	 		NINDY INTERFACE ROUTINES  *  * This version of the NINDY interface routines supports NINDY versions  * 2.13 and older.  The older versions used a hex communication protocol,  * instead of the (faster) current binary protocol.   These routines have  * been renamed by prepending the letter 'O' to their names, to avoid  * conflict with the current version.  The old versions are kept only for  * backward compatibility, and well disappear in a future release.  *  ******************************************************************************/
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_comment
comment|/* Needed by file.h on Sys V */
end_comment

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_comment
comment|/* Needed on Sys V */
end_comment

begin_include
include|#
directive|include
file|"ttycntl.h"
end_include

begin_include
include|#
directive|include
file|"block_io.h"
end_include

begin_include
include|#
directive|include
file|"wait.h"
end_include

begin_include
include|#
directive|include
file|"env.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|USG
end_ifdef

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"sysv.h"
end_include

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* BSD */
end_comment

begin_include
include|#
directive|include
file|"string.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|TRUE
end_ifndef

begin_define
define|#
directive|define
name|TRUE
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|FALSE
end_ifndef

begin_define
define|#
directive|define
name|FALSE
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|ERROR
end_ifndef

begin_define
define|#
directive|define
name|ERROR
value|-1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|REGISTER_BYTES
value|((36*4) + (4*8))
end_define

begin_function_decl
specifier|extern
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|free
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|int
name|quiet
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* TRUE => stifle unnecessary messages */
end_comment

begin_decl_stmt
specifier|static
name|int
name|nindy_fd
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* File descriptor of tty connected to 960/NINDY board*/
end_comment

begin_expr_stmt
specifier|static
name|OninStrGet
argument_list|()
expr_stmt|;
end_expr_stmt

begin_escape
end_escape

begin_comment
comment|/**************************** 		 *                          * 		 *  MISCELLANEOUS UTILTIES  * 		 *                          * 		 ****************************/
end_comment

begin_comment
comment|/******************************************************************************  * fromhex:  *	Convert a hex ascii digit h to a binary integer  ******************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|fromhex
parameter_list|(
name|h
parameter_list|)
name|int
name|h
decl_stmt|;
block|{
if|if
condition|(
name|h
operator|>=
literal|'0'
operator|&&
name|h
operator|<=
literal|'9'
condition|)
block|{
name|h
operator|-=
literal|'0'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|h
operator|>=
literal|'a'
operator|&&
name|h
operator|<=
literal|'f'
condition|)
block|{
name|h
operator|-=
literal|'a'
operator|-
literal|10
expr_stmt|;
block|}
else|else
block|{
name|h
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|h
operator|&
literal|0xff
operator|)
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * hexbin:  *	Convert a string of ASCII hex digits to a string of binary bytes.  ******************************************************************************/
end_comment

begin_expr_stmt
specifier|static
name|hexbin
argument_list|(
argument|n
argument_list|,
argument|hexp
argument_list|,
argument|binp
argument_list|)
name|int
name|n
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Number of bytes to convert (twice this many digits)*/
end_comment

begin_decl_stmt
name|char
modifier|*
name|hexp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Get hex from here		*/
end_comment

begin_decl_stmt
name|char
modifier|*
name|binp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Put binary here		*/
end_comment

begin_block
block|{
while|while
condition|(
name|n
operator|--
condition|)
block|{
operator|*
name|binp
operator|++
operator|=
operator|(
name|fromhex
argument_list|(
operator|*
name|hexp
argument_list|)
operator|<<
literal|4
operator|)
operator||
name|fromhex
argument_list|(
operator|*
operator|(
name|hexp
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|hexp
operator|+=
literal|2
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/******************************************************************************  * binhex:  *	Convert a string of binary bytes to a string of ASCII hex digits  ******************************************************************************/
end_comment

begin_expr_stmt
specifier|static
name|binhex
argument_list|(
argument|n
argument_list|,
argument|binp
argument_list|,
argument|hexp
argument_list|)
name|int
name|n
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Number of bytes to convert   */
end_comment

begin_decl_stmt
name|char
modifier|*
name|binp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Get binary from here         */
end_comment

begin_decl_stmt
name|char
modifier|*
name|hexp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Place hex here               */
end_comment

begin_block
block|{
specifier|static
name|char
name|tohex
index|[]
init|=
literal|"0123456789abcdef"
decl_stmt|;
while|while
condition|(
name|n
operator|--
condition|)
block|{
operator|*
name|hexp
operator|++
operator|=
name|tohex
index|[
operator|(
operator|*
name|binp
operator|>>
literal|4
operator|)
operator|&
literal|0xf
index|]
expr_stmt|;
operator|*
name|hexp
operator|++
operator|=
name|tohex
index|[
operator|*
name|binp
operator|&
literal|0xf
index|]
expr_stmt|;
name|binp
operator|++
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/******************************************************************************  * byte_order:  *	If the host byte order is different from 960 byte order (i.e., the  *	host is big-endian), reverse the bytes in the passed value;  otherwise,  *	return the passed value unchanged.  *  ******************************************************************************/
end_comment

begin_function
specifier|static
name|long
name|byte_order
parameter_list|(
name|n
parameter_list|)
name|long
name|n
decl_stmt|;
block|{
name|long
name|rev
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|static
name|short
name|test
init|=
literal|0x1234
decl_stmt|;
if|if
condition|(
operator|*
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
name|test
operator|)
operator|==
literal|0x12
condition|)
block|{
comment|/* 		 * Big-endian host, swap the bytes. 		 */
name|rev
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|n
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|rev
operator|<<=
literal|8
expr_stmt|;
name|rev
operator||=
name|n
operator|&
literal|0xff
expr_stmt|;
name|n
operator|>>=
literal|8
expr_stmt|;
block|}
name|n
operator|=
name|rev
expr_stmt|;
block|}
return|return
name|n
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * say:  *	This is a printf that takes at most two arguments (in addition to the  *	format string) and that outputs nothing if verbose output has been  *	suppressed.  ******************************************************************************/
end_comment

begin_expr_stmt
specifier|static
name|say
argument_list|(
argument|fmt
argument_list|,
argument|arg1
argument_list|,
argument|arg2
argument_list|)
name|char
operator|*
name|fmt
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|arg1
decl_stmt|,
name|arg2
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
operator|!
name|quiet
condition|)
block|{
name|printf
argument_list|(
name|fmt
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/******************************************************************************  * exists:  *	Creates a full pathname by concatenating up to three name components  *	onto a specified base name; optionally looks up the base name as a  *	runtime environment variable;  and checks to see if the file or  *	directory specified by the pathname actually exists.  *  *	Returns:  the full pathname if it exists, NULL otherwise.  *		(returned pathname is in malloc'd memory and must be freed  *		by caller).  *****************************************************************************/
end_comment

begin_function
specifier|static
name|char
modifier|*
name|exists
parameter_list|(
name|base
parameter_list|,
name|c1
parameter_list|,
name|c2
parameter_list|,
name|c3
parameter_list|,
name|env
parameter_list|)
name|char
modifier|*
name|base
decl_stmt|;
comment|/* Base directory of path */
name|char
modifier|*
name|c1
decl_stmt|,
decl|*
name|c2
decl_stmt|,
modifier|*
name|c3
decl_stmt|;
end_function

begin_comment
comment|/* Components (subdirectories and/or file name) to be 			 *	appended onto the base directory name.  One or 			 *	more may be omitted by passing NULL pointers. 			 */
end_comment

begin_decl_stmt
name|int
name|env
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If 1, '*base' is the name of an environment variable 			 *	to be examined for the base directory name; 			 *	otherwise, '*base' is the actual name of the 			 *	base directory. 			 */
end_comment

begin_block
block|{
name|struct
name|stat
name|buf
decl_stmt|;
comment|/* For call to 'stat' -- never examined */
name|char
modifier|*
name|path
decl_stmt|;
comment|/* Pointer to full pathname (malloc'd memory) */
name|int
name|len
decl_stmt|;
comment|/* Length of full pathname (incl. terminator) */
specifier|extern
name|char
modifier|*
name|getenv
parameter_list|()
function_decl|;
if|if
condition|(
name|env
condition|)
block|{
name|base
operator|=
name|getenv
argument_list|(
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
name|base
operator|==
name|NULL
condition|)
block|{
return|return
name|NULL
return|;
block|}
block|}
name|len
operator|=
name|strlen
argument_list|(
name|base
argument_list|)
operator|+
literal|4
expr_stmt|;
comment|/* +4 for terminator and "/" before each component */
if|if
condition|(
name|c1
operator|!=
name|NULL
condition|)
block|{
name|len
operator|+=
name|strlen
argument_list|(
name|c1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|c2
operator|!=
name|NULL
condition|)
block|{
name|len
operator|+=
name|strlen
argument_list|(
name|c2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|c3
operator|!=
name|NULL
condition|)
block|{
name|len
operator|+=
name|strlen
argument_list|(
name|c3
argument_list|)
expr_stmt|;
block|}
name|path
operator|=
name|malloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|path
argument_list|,
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
name|c1
operator|!=
name|NULL
condition|)
block|{
name|strcat
argument_list|(
name|path
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|path
argument_list|,
name|c1
argument_list|)
expr_stmt|;
if|if
condition|(
name|c2
operator|!=
name|NULL
condition|)
block|{
name|strcat
argument_list|(
name|path
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|path
argument_list|,
name|c2
argument_list|)
expr_stmt|;
if|if
condition|(
name|c3
operator|!=
name|NULL
condition|)
block|{
name|strcat
argument_list|(
name|path
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|path
argument_list|,
name|c3
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|stat
argument_list|(
name|path
argument_list|,
operator|&
name|buf
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|path
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|path
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/***************************** 		 *                           * 		 *  LOW-LEVEL COMMUNICATION  * 		 *                           * 		 *****************************/
end_comment

begin_comment
comment|/******************************************************************************  * readchar:  *	Wait for a character to come in on the NINDY tty, and return it.  ******************************************************************************/
end_comment

begin_expr_stmt
specifier|static
name|readchar
argument_list|()
block|{
name|unsigned
name|char
name|c
block|;
while|while
condition|(
name|read
argument_list|(
name|nindy_fd
argument_list|,
operator|&
name|c
argument_list|,
literal|1
argument_list|)
operator|!=
literal|1
condition|)
block|{
empty_stmt|;
block|}
end_expr_stmt

begin_return
return|return
name|c
return|;
end_return

begin_comment
unit|}
comment|/******************************************************************************  * getpkt:  *	Read a packet from a remote NINDY, with error checking, and return  *	it in the indicated buffer.  ******************************************************************************/
end_comment

begin_macro
unit|static
name|getpkt
argument_list|(
argument|buf
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|buf
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|unsigned
name|char
name|recv
decl_stmt|;
comment|/* Checksum received		*/
name|unsigned
name|char
name|csum
decl_stmt|;
comment|/* Checksum calculated		*/
name|char
modifier|*
name|bp
decl_stmt|;
comment|/* Poointer into the buffer	*/
name|int
name|c
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|csum
operator|=
literal|0
expr_stmt|;
name|bp
operator|=
name|buf
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|readchar
argument_list|()
operator|)
operator|!=
literal|'#'
condition|)
block|{
operator|*
name|bp
operator|++
operator|=
name|c
expr_stmt|;
name|csum
operator|+=
name|c
expr_stmt|;
block|}
operator|*
name|bp
operator|=
literal|0
expr_stmt|;
name|recv
operator|=
name|fromhex
argument_list|(
name|readchar
argument_list|()
argument_list|)
operator|<<
literal|4
expr_stmt|;
name|recv
operator||=
name|fromhex
argument_list|(
name|readchar
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|csum
operator|==
name|recv
condition|)
block|{
break|break;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Bad checksum (recv=0x%02x; calc=0x%02x); retrying\r\n"
argument_list|,
name|recv
argument_list|,
name|csum
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|nindy_fd
argument_list|,
literal|"-"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|write
argument_list|(
name|nindy_fd
argument_list|,
literal|"+"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/******************************************************************************  * putpkt:  *	Checksum and send a gdb command to a remote NINDY, and wait for  *	positive acknowledgement.  *  ******************************************************************************/
end_comment

begin_expr_stmt
specifier|static
name|putpkt
argument_list|(
argument|cmd
argument_list|)
name|char
operator|*
name|cmd
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Command to be sent, without lead ^P (\020) 		 * or trailing checksum 		 */
end_comment

begin_block
block|{
name|char
name|ack
decl_stmt|;
comment|/* Response received from NINDY		*/
name|char
name|checksum
index|[
literal|4
index|]
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|unsigned
name|int
name|s
decl_stmt|;
name|char
name|resend
decl_stmt|;
for|for
control|(
name|s
operator|=
literal|'\020'
operator|,
name|p
operator|=
name|cmd
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
block|{
name|s
operator|+=
operator|*
name|p
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|checksum
argument_list|,
literal|"#%02x"
argument_list|,
name|s
operator|&
literal|0xff
argument_list|)
expr_stmt|;
comment|/* Send checksummed message over and over until we get a positive ack 	 */
name|resend
operator|=
name|TRUE
expr_stmt|;
do|do
block|{
if|if
condition|(
name|resend
condition|)
block|{
name|write
argument_list|(
name|nindy_fd
argument_list|,
literal|"\020"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|nindy_fd
argument_list|,
name|cmd
argument_list|,
name|strlen
argument_list|(
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|nindy_fd
argument_list|,
name|checksum
argument_list|,
name|strlen
argument_list|(
name|checksum
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|read
argument_list|(
name|nindy_fd
argument_list|,
operator|&
name|ack
argument_list|,
literal|1
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"oink\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ack
operator|==
literal|'-'
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Remote NAK, resending\r\n"
argument_list|)
expr_stmt|;
name|resend
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ack
operator|!=
literal|'+'
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Bad ACK, ignored:<%c>\r\n"
argument_list|,
name|ack
argument_list|)
expr_stmt|;
name|resend
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
do|while
condition|(
name|ack
operator|!=
literal|'+'
condition|)
do|;
block|}
end_block

begin_comment
comment|/******************************************************************************  * send:  *	Send a message to a remote NINDY and return the reply in the same  *	buffer (clobbers the input message).  Check for error responses  *	as indicated by the second argument.  *  ******************************************************************************/
end_comment

begin_expr_stmt
specifier|static
name|send
argument_list|(
argument|buf
argument_list|,
argument|ack_required
argument_list|)
name|char
operator|*
name|buf
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Message to be sent to NINDY; replaced by 			 *	NINDY's response. 			 */
end_comment

begin_decl_stmt
name|int
name|ack_required
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* TRUE means NINDY's response MUST be either "X00" (no 			 *	error) or an error code "Xnn". 			 * FALSE means the it's OK as long as it doesn't 			 *	begin with "Xnn". 			 */
end_comment

begin_block
block|{
name|int
name|errnum
decl_stmt|;
specifier|static
name|char
modifier|*
name|errmsg
index|[]
init|=
block|{
literal|""
block|,
comment|/* X00 */
literal|"Buffer overflow"
block|,
comment|/* X01 */
literal|"Unknown command"
block|,
comment|/* X02 */
literal|"Wrong amount of data to load register(s)"
block|,
comment|/* X03 */
literal|"Missing command argument(s)"
block|,
comment|/* X04 */
literal|"Odd number of digits sent to load memory"
block|,
comment|/* X05 */
literal|"Unknown register name"
block|,
comment|/* X06 */
literal|"No such memory segment"
block|,
comment|/* X07 */
literal|"No breakpoint available"
block|,
comment|/* X08 */
literal|"Can't set requested baud rate"
block|,
comment|/* X09 */
block|}
decl_stmt|;
define|#
directive|define
name|NUMERRS
value|( sizeof(errmsg) / sizeof(errmsg[0]) )
specifier|static
name|char
name|err0
index|[]
init|=
literal|"NINDY failed to acknowledge command:<%s>\r\n"
decl_stmt|;
specifier|static
name|char
name|err1
index|[]
init|=
literal|"Unknown error response from NINDY:<%s>\r\n"
decl_stmt|;
specifier|static
name|char
name|err2
index|[]
init|=
literal|"Error response %s from NINDY: %s\r\n"
decl_stmt|;
name|putpkt
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|getpkt
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|!=
literal|'X'
condition|)
block|{
if|if
condition|(
name|ack_required
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|err0
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|buf
argument_list|,
literal|"X00"
argument_list|)
condition|)
block|{
name|sscanf
argument_list|(
operator|&
name|buf
index|[
literal|1
index|]
argument_list|,
literal|"%x"
argument_list|,
operator|&
name|errnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|errnum
operator|>
name|NUMERRS
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|err1
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|err2
argument_list|,
name|buf
argument_list|,
name|errmsg
index|[
name|errnum
index|]
argument_list|)
expr_stmt|;
block|}
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/************************ 		 *                      * 		 *  BAUD RATE ROUTINES  * 		 *                      * 		 ************************/
end_comment

begin_comment
comment|/* Table of baudrates known to be acceptable to NINDY.  Each baud rate  * appears both as character string and as a Unix baud rate constant.  */
end_comment

begin_struct
struct|struct
name|baudrate
block|{
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|rate
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|baudrate
name|baudtab
index|[]
init|=
block|{
literal|"1200"
block|,
name|B1200
block|,
literal|"2400"
block|,
name|B2400
block|,
literal|"4800"
block|,
name|B4800
block|,
literal|"9600"
block|,
name|B9600
block|,
literal|"19200"
block|,
name|B19200
block|,
literal|"38400"
block|,
name|B38400
block|,
name|NULL
block|,
literal|0
comment|/* End of table */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/******************************************************************************  * parse_baudrate:  *	Look up the passed baud rate in the baudrate table.  If found, change  *	our internal record of the current baud rate, but don't do anything  *	about the tty just now.  *  *	Return pointer to baudrate structure on success, NULL on failure.  ******************************************************************************/
end_comment

begin_function
specifier|static
name|struct
name|baudrate
modifier|*
name|parse_baudrate
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
comment|/* Desired baud rate, as an ASCII (decimal) string */
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|baudtab
index|[
name|i
index|]
operator|.
name|string
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|baudtab
index|[
name|i
index|]
operator|.
name|string
argument_list|,
name|s
argument_list|)
condition|)
block|{
return|return
operator|&
name|baudtab
index|[
name|i
index|]
return|;
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * try_baudrate:  *	Try speaking to NINDY via the specified file descriptor at the  *	specified baudrate.  Assume success it we can send an empty command  *	with a bogus checksum and receive a NAK (response of '-') back within  *	one second.  *  *	Return 1 on success, 0 on failure.  ******************************************************************************/
end_comment

begin_decl_stmt
specifier|static
name|int
name|saw_alarm
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|alarm_handler
parameter_list|()
block|{
name|saw_alarm
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|try_baudrate
parameter_list|(
name|fd
parameter_list|,
name|brp
parameter_list|)
name|int
name|fd
decl_stmt|;
name|struct
name|baudrate
modifier|*
name|brp
decl_stmt|;
block|{
name|TTY_STRUCT
name|tty
decl_stmt|;
name|char
name|c
decl_stmt|;
name|int
name|n
decl_stmt|;
name|void
function_decl|(
modifier|*
name|old_alarm
function_decl|)
parameter_list|()
function_decl|;
comment|/* Save alarm signal handler here on entry */
comment|/* Set specified baud rate and flush all pending input */
name|ioctl
argument_list|(
name|fd
argument_list|,
name|TIOCGETP
argument_list|,
operator|&
name|tty
argument_list|)
expr_stmt|;
name|TTY_REMOTE
argument_list|(
name|tty
argument_list|,
name|brp
operator|->
name|rate
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
name|fd
argument_list|,
name|TIOCSETP
argument_list|,
operator|&
name|tty
argument_list|)
expr_stmt|;
name|tty_flush
argument_list|(
name|fd
argument_list|)
expr_stmt|;
comment|/* Send bogus command */
name|write
argument_list|(
name|fd
argument_list|,
literal|"\020#00"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Wait until reponse comes back or one second passes */
name|old_alarm
operator|=
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|alarm_handler
argument_list|)
expr_stmt|;
name|saw_alarm
operator|=
literal|0
expr_stmt|;
name|alarm
argument_list|(
literal|1
argument_list|)
expr_stmt|;
do|do
block|{
name|n
operator|=
literal|1
expr_stmt|;
name|TTY_NBREAD
argument_list|(
name|fd
argument_list|,
name|n
argument_list|,
operator|&
name|c
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|n
operator|<=
literal|0
operator|&&
operator|!
name|saw_alarm
condition|)
do|;
comment|/* Turn off alarm */
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|old_alarm
argument_list|)
expr_stmt|;
comment|/* Did we get a '-' back ? */
if|if
condition|(
operator|(
name|n
operator|>
literal|0
operator|)
operator|&&
operator|(
name|c
operator|==
literal|'-'
operator|)
condition|)
block|{
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * autobaud:  *	Get NINDY talking over the specified file descriptor at the specified  *	baud rate.  First see if NINDY's already talking at 'baudrate'.  If  *	not, run through all the legal baudrates in 'baudtab' until one works,  *	and then tell NINDY to talk at 'baudrate' instead.  ******************************************************************************/
end_comment

begin_expr_stmt
specifier|static
name|autobaud
argument_list|(
argument|fd
argument_list|,
argument|brp
argument_list|)
name|int
name|fd
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|baudrate
modifier|*
name|brp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
name|TTY_STRUCT
name|tty
decl_stmt|;
name|say
argument_list|(
literal|"NINDY at wrong baud rate? Trying to autobaud...\n"
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|say
argument_list|(
literal|"\r%s...   "
argument_list|,
name|baudtab
index|[
name|i
index|]
operator|.
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|try_baudrate
argument_list|(
name|fd
argument_list|,
operator|&
name|baudtab
index|[
name|i
index|]
argument_list|)
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|baudtab
index|[
operator|++
name|i
index|]
operator|.
name|string
operator|==
name|NULL
condition|)
block|{
comment|/* End of table -- wraparound */
name|i
operator|=
literal|0
expr_stmt|;
name|say
argument_list|(
literal|"\nAutobaud failed. Trying again...\n"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Found NINDY's current baud rate;  now change it. 	 */
name|say
argument_list|(
literal|"Changing NINDY baudrate to %s\n"
argument_list|,
name|brp
operator|->
name|string
argument_list|)
expr_stmt|;
name|OninBaud
argument_list|(
name|brp
operator|->
name|string
argument_list|)
expr_stmt|;
comment|/* Change our baud rate back to rate to which we just set NINDY. 	 */
name|ioctl
argument_list|(
name|fd
argument_list|,
name|TIOCGETP
argument_list|,
operator|&
name|tty
argument_list|)
expr_stmt|;
name|TTY_REMOTE
argument_list|(
name|tty
argument_list|,
name|brp
operator|->
name|rate
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
name|fd
argument_list|,
name|TIOCSETP
argument_list|,
operator|&
name|tty
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/********************************** 		 *				  * 		 *   NINDY INTERFACE ROUTINES	  * 		 *                            	  * 		 * ninConnect *MUST* be the first * 		 * one of these routines called.  * 		 **********************************/
end_comment

begin_comment
comment|/******************************************************************************  * ninBaud:  *	Ask NINDY to change the baud rate on its serial port.  *	Assumes we know the baud rate at which NINDY's currently talking.  ******************************************************************************/
end_comment

begin_macro
name|OninBaud
argument_list|(
argument|baudrate
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|baudrate
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Desired baud rate, as a string of ASCII decimal 			 * digits. 			 */
end_comment

begin_block
block|{
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
comment|/* Message buffer	*/
name|char
modifier|*
name|p
decl_stmt|;
comment|/* Pointer into buffer	*/
name|unsigned
name|char
name|csum
decl_stmt|;
comment|/* Calculated checksum	*/
name|tty_flush
argument_list|(
name|nindy_fd
argument_list|)
expr_stmt|;
comment|/* Can't use putpkt() because after the baudrate change 	 * NINDY's ack/nak will look like gibberish. 	 */
for|for
control|(
name|p
operator|=
name|baudrate
operator|,
name|csum
operator|=
literal|020
operator|+
literal|'z'
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
block|{
name|csum
operator|+=
operator|*
name|p
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"\020z%s#%02x"
argument_list|,
name|baudrate
argument_list|,
name|csum
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|nindy_fd
argument_list|,
name|buf
argument_list|,
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/******************************************************************************  * ninBptDel:  *	Ask NINDY to delete the specified type of *hardware* breakpoint at  *	the specified address.  If the 'addr' is -1, all breakpoints of  *	the specified type are deleted.  ******************************************************************************/
end_comment

begin_macro
name|OninBptDel
argument_list|(
argument|addr
argument_list|,
argument|data
argument_list|)
end_macro

begin_decl_stmt
name|long
name|addr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Address in 960 memory	*/
end_comment

begin_decl_stmt
name|int
name|data
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* '1' => data bkpt, '0' => instruction breakpoint */
end_comment

begin_block
block|{
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
if|if
condition|(
name|addr
operator|==
operator|-
literal|1
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"b%c"
argument_list|,
name|data
condition|?
literal|'1'
else|:
literal|'0'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"b%c%x"
argument_list|,
name|data
condition|?
literal|'1'
else|:
literal|'0'
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
return|return
name|send
argument_list|(
name|buf
argument_list|,
name|FALSE
argument_list|)
return|;
block|}
end_block

begin_comment
comment|/******************************************************************************  * ninBptSet:  *	Ask NINDY to set the specified type of *hardware* breakpoint at  *	the specified address.  ******************************************************************************/
end_comment

begin_macro
name|OninBptSet
argument_list|(
argument|addr
argument_list|,
argument|data
argument_list|)
end_macro

begin_decl_stmt
name|long
name|addr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Address in 960 memory	*/
end_comment

begin_decl_stmt
name|int
name|data
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* '1' => data bkpt, '0' => instruction breakpoint */
end_comment

begin_block
block|{
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"B%c%x"
argument_list|,
name|data
condition|?
literal|'1'
else|:
literal|'0'
argument_list|,
name|addr
argument_list|)
expr_stmt|;
return|return
name|send
argument_list|(
name|buf
argument_list|,
name|FALSE
argument_list|)
return|;
block|}
end_block

begin_comment
comment|/******************************************************************************  * ninConnect:  *	Open the specified tty.  Get communications working at the specified  *	Flush any pending I/O on the tty.  *  *	Return the file descriptor, or -1 on failure.  ******************************************************************************/
end_comment

begin_function
name|int
name|OninConnect
parameter_list|(
name|name
parameter_list|,
name|baudrate
parameter_list|,
name|brk
parameter_list|,
name|silent
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
comment|/* "/dev/ttyXX" to be opened			*/
name|char
modifier|*
name|baudrate
decl_stmt|;
comment|/* baud rate: a string of ascii decimal digits (eg,"9600")*/
name|int
name|brk
decl_stmt|;
comment|/* 1 => send break to tty first thing after opening it*/
name|int
name|silent
decl_stmt|;
comment|/* 1 => stifle unnecessary messages when talking to  			 *	this tty. 			 */
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|struct
name|baudrate
modifier|*
name|brp
decl_stmt|;
comment|/* We will try each of the following paths when trying to open the tty 	 */
specifier|static
name|char
modifier|*
name|prefix
index|[]
init|=
block|{
literal|""
block|,
literal|"/dev/"
block|,
literal|"/dev/tty"
block|,
name|NULL
block|}
decl_stmt|;
name|quiet
operator|=
name|silent
expr_stmt|;
comment|/* Make global to this file */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|prefix
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
name|p
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|prefix
index|[
name|i
index|]
argument_list|)
operator|+
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|p
argument_list|,
name|prefix
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|p
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|nindy_fd
operator|=
name|open
argument_list|(
name|p
argument_list|,
name|O_RDWR
argument_list|)
expr_stmt|;
if|if
condition|(
name|nindy_fd
operator|>=
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|TIOCEXCL
comment|/* Exclusive use mode (hp9000 does not support it) */
name|ioctl
argument_list|(
name|nindy_fd
argument_list|,
name|TIOCEXCL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|brk
condition|)
block|{
name|send_break
argument_list|(
name|nindy_fd
argument_list|)
expr_stmt|;
block|}
name|brp
operator|=
name|parse_baudrate
argument_list|(
name|baudrate
argument_list|)
expr_stmt|;
if|if
condition|(
name|brp
operator|==
name|NULL
condition|)
block|{
name|say
argument_list|(
literal|"Illegal baudrate %s ignored; using 9600\n"
argument_list|,
name|baudrate
argument_list|)
expr_stmt|;
name|brp
operator|=
name|parse_baudrate
argument_list|(
literal|"9600"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|try_baudrate
argument_list|(
name|nindy_fd
argument_list|,
name|brp
argument_list|)
condition|)
block|{
name|autobaud
argument_list|(
name|nindy_fd
argument_list|,
name|brp
argument_list|)
expr_stmt|;
block|}
name|tty_flush
argument_list|(
name|nindy_fd
argument_list|)
expr_stmt|;
name|say
argument_list|(
literal|"Connected to %s\n"
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
block|}
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
return|return
name|nindy_fd
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * ninDownload:  *	Ask NINDY to start up it's COFF downloader. Invoke 'sx' to perform  *	the XMODEM download from the host end.  *  *	Return 1 on success, 0 on failure.  ******************************************************************************/
end_comment

begin_define
define|#
directive|define
name|XMODEM
value|"sx"
end_define

begin_comment
comment|/* Name of xmodem transfer utility	*/
end_comment

begin_function
name|int
name|OninDownload
parameter_list|(
name|fn
parameter_list|,
name|quiet
parameter_list|)
name|char
modifier|*
name|fn
decl_stmt|;
comment|/* Stripped copy of object file			*/
name|int
name|quiet
decl_stmt|;
block|{
name|char
modifier|*
name|p
decl_stmt|;
comment|/* Pointer to full pathname of sx utility	*/
name|int
name|success
decl_stmt|;
comment|/* Return value					*/
name|int
name|pid
decl_stmt|;
comment|/* Process ID of xmodem transfer utility	*/
name|WAITTYPE
name|w
decl_stmt|;
comment|/* xmodem transfer completion status		*/
name|char
name|buf
index|[
literal|200
index|]
decl_stmt|;
comment|/* Make sure the xmodem utility is findable.  This must be done before 	 * we start up the NINDY end of the download (NINDY will hang if we 	 * don't complete the download). 	 */
if|if
condition|(
operator|(
operator|(
name|p
operator|=
name|exists
argument_list|(
literal|"G960BIN"
argument_list|,
name|XMODEM
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
name|NULL
operator|)
operator|&&
operator|(
operator|(
name|p
operator|=
name|exists
argument_list|(
literal|"G960BASE"
argument_list|,
literal|"bin"
argument_list|,
name|XMODEM
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
name|NULL
operator|)
ifdef|#
directive|ifdef
name|HOST
operator|&&
operator|(
operator|(
name|p
operator|=
name|exists
argument_list|(
name|DEFAULT_BASE
argument_list|,
name|HOST
argument_list|,
literal|"bin"
argument_list|,
name|XMODEM
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|NULL
operator|)
endif|#
directive|endif
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't find '%s' download utility\n"
argument_list|,
name|XMODEM
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Check env variables G960BIN and G960BASE\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|quiet
condition|)
block|{
name|printf
argument_list|(
literal|"Downloading %s\n"
argument_list|,
name|fn
argument_list|)
expr_stmt|;
block|}
comment|/* Reset NINDY,  wait until "reset-complete" ack, 	 * and start up the NINDY end of the download. 	 */
name|OninReset
argument_list|()
expr_stmt|;
name|putpkt
argument_list|(
literal|"D"
argument_list|)
expr_stmt|;
comment|/* Invoke x-modem transfer, a separate process.  DON'T 	 * use system() to do this -- under system V Unix, the 	 * redirection of stdin/stdout causes the nindy tty to 	 * lose all the transmission parameters we've set up. 	 */
name|success
operator|=
literal|0
expr_stmt|;
name|pid
operator|=
name|fork
argument_list|()
expr_stmt|;
if|if
condition|(
name|pid
operator|==
operator|-
literal|1
condition|)
block|{
name|perror
argument_list|(
literal|"Can't fork process:"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pid
operator|==
literal|0
condition|)
block|{
comment|/* CHILD */
name|dup2
argument_list|(
name|nindy_fd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Redirect stdin */
name|dup2
argument_list|(
name|nindy_fd
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Redirect stout */
if|if
condition|(
name|quiet
condition|)
block|{
name|execl
argument_list|(
name|p
argument_list|,
name|p
argument_list|,
literal|"-q"
argument_list|,
name|fn
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|execl
argument_list|(
name|p
argument_list|,
name|p
argument_list|,
name|fn
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Don't get here unless execl fails */
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"Can't exec %s"
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|perror
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* PARENT */
if|if
condition|(
name|wait
argument_list|(
operator|&
name|w
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|perror
argument_list|(
literal|"Wait failed"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|WIFEXITED
argument_list|(
name|w
argument_list|)
operator|&&
operator|(
name|WEXITSTATUS
argument_list|(
name|w
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|success
operator|=
literal|1
expr_stmt|;
block|}
block|}
return|return
name|success
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * ninGdbExit:  *	Ask NINDY to leave GDB mode and print a NINDY prompt.  *	Since it'll no longer be in GDB mode, don't wait for a response.  ******************************************************************************/
end_comment

begin_macro
name|OninGdbExit
argument_list|()
end_macro

begin_block
block|{
name|putpkt
argument_list|(
literal|"E"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/******************************************************************************  * ninGo:  *	Ask NINDY to start or continue execution of an application program  *	in it's memory at the current ip.  ******************************************************************************/
end_comment

begin_macro
name|OninGo
argument_list|(
argument|step_flag
argument_list|)
end_macro

begin_decl_stmt
name|int
name|step_flag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1 => run in single-step mode */
end_comment

begin_block
block|{
name|putpkt
argument_list|(
name|step_flag
condition|?
literal|"s"
else|:
literal|"c"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/******************************************************************************  * ninMemGet:  *	Read a string of bytes from NINDY's address space (960 memory).  ******************************************************************************/
end_comment

begin_macro
name|OninMemGet
argument_list|(
argument|ninaddr
argument_list|,
argument|hostaddr
argument_list|,
argument|len
argument_list|)
end_macro

begin_decl_stmt
name|long
name|ninaddr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Source address, in the 960 memory space	*/
end_comment

begin_decl_stmt
name|char
modifier|*
name|hostaddr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Destination address, in our memory space	*/
end_comment

begin_decl_stmt
name|int
name|len
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of bytes to read			*/
end_comment

begin_block
block|{
name|char
name|buf
index|[
literal|2
operator|*
name|BUFSIZE
operator|+
literal|20
index|]
decl_stmt|;
comment|/* Buffer: hex in, binary out		*/
name|int
name|cnt
decl_stmt|;
comment|/* Number of bytes in next transfer	*/
for|for
control|(
init|;
name|len
operator|>
literal|0
condition|;
name|len
operator|-=
name|BUFSIZE
control|)
block|{
name|cnt
operator|=
name|len
operator|>
name|BUFSIZE
condition|?
name|BUFSIZE
else|:
name|len
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"m%x,%x"
argument_list|,
name|ninaddr
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
name|send
argument_list|(
name|buf
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|hexbin
argument_list|(
name|cnt
argument_list|,
name|buf
argument_list|,
name|hostaddr
argument_list|)
expr_stmt|;
name|ninaddr
operator|+=
name|cnt
expr_stmt|;
name|hostaddr
operator|+=
name|cnt
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/******************************************************************************  * ninMemPut:  *	Write a string of bytes into NINDY's address space (960 memory).  ******************************************************************************/
end_comment

begin_macro
name|OninMemPut
argument_list|(
argument|destaddr
argument_list|,
argument|srcaddr
argument_list|,
argument|len
argument_list|)
end_macro

begin_decl_stmt
name|long
name|destaddr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Destination address, in NINDY memory space	*/
end_comment

begin_decl_stmt
name|char
modifier|*
name|srcaddr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Source address, in our memory space		*/
end_comment

begin_decl_stmt
name|int
name|len
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of bytes to write			*/
end_comment

begin_block
block|{
name|char
name|buf
index|[
literal|2
operator|*
name|BUFSIZE
operator|+
literal|20
index|]
decl_stmt|;
comment|/* Buffer: binary in, hex out		*/
name|char
modifier|*
name|p
decl_stmt|;
comment|/* Pointer into buffer			*/
name|int
name|cnt
decl_stmt|;
comment|/* Number of bytes in next transfer	*/
for|for
control|(
init|;
name|len
operator|>
literal|0
condition|;
name|len
operator|-=
name|BUFSIZE
control|)
block|{
name|cnt
operator|=
name|len
operator|>
name|BUFSIZE
condition|?
name|BUFSIZE
else|:
name|len
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"M%x,"
argument_list|,
name|destaddr
argument_list|)
expr_stmt|;
name|p
operator|=
name|buf
operator|+
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|binhex
argument_list|(
name|cnt
argument_list|,
name|srcaddr
argument_list|,
name|p
argument_list|)
expr_stmt|;
operator|*
operator|(
name|p
operator|+
operator|(
literal|2
operator|*
name|cnt
operator|)
operator|)
operator|=
literal|'\0'
expr_stmt|;
name|send
argument_list|(
name|buf
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|srcaddr
operator|+=
name|cnt
expr_stmt|;
name|destaddr
operator|+=
name|cnt
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/******************************************************************************  * ninRegGet:  *	Retrieve the contents of a 960 register, and return them as a long  *	in host byte order.  *  *	THIS ROUTINE CAN ONLY BE USED TO READ THE LOCAL, GLOBAL, AND  *	ip/ac/pc/tc REGISTERS.  *  ******************************************************************************/
end_comment

begin_function
name|long
name|OninRegGet
parameter_list|(
name|regname
parameter_list|)
name|char
modifier|*
name|regname
decl_stmt|;
comment|/* Register name recognized by NINDY, subject to the 			 * above limitations. 			 */
block|{
name|char
name|buf
index|[
literal|200
index|]
decl_stmt|;
name|long
name|val
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"u%s"
argument_list|,
name|regname
argument_list|)
expr_stmt|;
name|send
argument_list|(
name|buf
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|hexbin
argument_list|(
literal|4
argument_list|,
name|buf
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|val
argument_list|)
expr_stmt|;
return|return
name|byte_order
argument_list|(
name|val
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * ninRegPut:  *	Set the contents of a 960 register.  *  *	THIS ROUTINE CAN ONLY BE USED TO SET THE LOCAL, GLOBAL, AND  *	ip/ac/pc/tc REGISTERS.  *  ******************************************************************************/
end_comment

begin_macro
name|OninRegPut
argument_list|(
argument|regname
argument_list|,
argument|val
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|regname
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Register name recognized by NINDY, subject to the 			 * above limitations. 			 */
end_comment

begin_decl_stmt
name|long
name|val
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* New contents of register, in host byte-order	*/
end_comment

begin_block
block|{
name|char
name|buf
index|[
literal|200
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"U%s,%08x"
argument_list|,
name|regname
argument_list|,
name|byte_order
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
name|send
argument_list|(
name|buf
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/******************************************************************************  * ninRegsGet:  *	Get a dump of the contents of the entire 960 register set.  The  *	individual registers appear in the dump in the following order:  *  *		pfp  sp   rip  r3   r4   r5   r6   r7   *		r8   r9   r10  r11  r12  r13  r14  r15   *		g0   g1   g2   g3   g4   g5   g6   g7   *		g8   g9   g10  g11  g12  g13  g14  fp   *		pc   ac   ip   tc   fp0  fp1  fp2  fp3  *  *	Each individual register comprises exactly 4 bytes, except for  *	fp0-fp3, which are 8 bytes.  *  * WARNING:  *	Each register value is in 960 (little-endian) byte order.  *  ******************************************************************************/
end_comment

begin_macro
name|OninRegsGet
argument_list|(
argument|regp
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|regp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Where to place the register dump */
end_comment

begin_block
block|{
name|char
name|buf
index|[
operator|(
literal|2
operator|*
name|REGISTER_BYTES
operator|)
operator|+
literal|10
index|]
decl_stmt|;
comment|/* Registers in ASCII hex */
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|send
argument_list|(
name|buf
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|hexbin
argument_list|(
name|REGISTER_BYTES
argument_list|,
name|buf
argument_list|,
name|regp
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/******************************************************************************  * ninRegsPut:  *	Initialize the entire 960 register set to a specified set of values.  *	The format of the register value data should be the same as that  *	returned by ninRegsGet.  *  * WARNING:  *	Each register value should be in 960 (little-endian) byte order.  *  ******************************************************************************/
end_comment

begin_macro
name|OninRegsPut
argument_list|(
argument|regp
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|regp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointer to desired values of registers */
end_comment

begin_block
block|{
name|char
name|buf
index|[
operator|(
literal|2
operator|*
name|REGISTER_BYTES
operator|)
operator|+
literal|10
index|]
decl_stmt|;
comment|/* Registers in ASCII hex */
name|buf
index|[
literal|0
index|]
operator|=
literal|'R'
expr_stmt|;
name|binhex
argument_list|(
name|REGISTER_BYTES
argument_list|,
name|regp
argument_list|,
name|buf
operator|+
literal|1
argument_list|)
expr_stmt|;
name|buf
index|[
operator|(
literal|2
operator|*
name|REGISTER_BYTES
operator|)
operator|+
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|send
argument_list|(
name|buf
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/******************************************************************************  * ninReset:  *      Ask NINDY to perform a soft reset; wait for the reset to complete.  ******************************************************************************/
end_comment

begin_macro
name|OninReset
argument_list|()
end_macro

begin_block
block|{
name|putpkt
argument_list|(
literal|"X"
argument_list|)
expr_stmt|;
while|while
condition|(
name|readchar
argument_list|()
operator|!=
literal|'+'
condition|)
block|{
empty_stmt|;
block|}
block|}
end_block

begin_comment
comment|/******************************************************************************  * ninSrq:  *	Assume NINDY has stopped execution of the 960 application program in  *	order to process a host service request (srq).  Ask NINDY for the  *	srq arguments, perform the requested service, and send an "srq  *	complete" message so NINDY will return control to the application.  *  ******************************************************************************/
end_comment

begin_macro
name|OninSrq
argument_list|()
end_macro

begin_block
block|{
name|char
name|buf
index|[
name|BUFSIZE
index|]
decl_stmt|;
name|int
name|retcode
decl_stmt|;
name|unsigned
name|char
name|srqnum
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|argp
decl_stmt|;
name|int
name|nargs
decl_stmt|;
name|int
name|arg
index|[
name|MAX_SRQ_ARGS
index|]
decl_stmt|;
comment|/* Get srq number and arguments 	 */
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|"!"
argument_list|)
expr_stmt|;
name|send
argument_list|(
name|buf
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|hexbin
argument_list|(
literal|1
argument_list|,
name|buf
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|srqnum
argument_list|)
expr_stmt|;
comment|/* Set up array of pointers the each of the individual 	 * comma-separated args 	 */
name|nargs
operator|=
literal|0
expr_stmt|;
name|argp
operator|=
name|p
operator|=
name|buf
operator|+
literal|2
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
while|while
condition|(
operator|*
name|p
operator|!=
literal|','
operator|&&
operator|*
name|p
operator|!=
literal|'\0'
condition|)
block|{
name|p
operator|++
expr_stmt|;
block|}
name|sscanf
argument_list|(
name|argp
argument_list|,
literal|"%x"
argument_list|,
operator|&
name|arg
index|[
name|nargs
operator|++
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
operator|||
name|nargs
operator|==
name|MAX_SRQ_ARGS
condition|)
block|{
break|break;
block|}
name|argp
operator|=
operator|++
name|p
expr_stmt|;
block|}
comment|/* Process Srq 	 */
switch|switch
condition|(
name|srqnum
condition|)
block|{
case|case
name|BS_CLOSE
case|:
comment|/* args: file descriptor */
if|if
condition|(
name|arg
index|[
literal|0
index|]
operator|>
literal|2
condition|)
block|{
name|retcode
operator|=
name|close
argument_list|(
name|arg
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|retcode
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
name|BS_CREAT
case|:
comment|/* args: filename, mode */
name|OninStrGet
argument_list|(
name|arg
index|[
literal|0
index|]
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|retcode
operator|=
name|creat
argument_list|(
name|buf
argument_list|,
name|arg
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|BS_OPEN
case|:
comment|/* args: filename, flags, mode */
name|OninStrGet
argument_list|(
name|arg
index|[
literal|0
index|]
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|retcode
operator|=
name|open
argument_list|(
name|buf
argument_list|,
name|arg
index|[
literal|1
index|]
argument_list|,
name|arg
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|BS_READ
case|:
comment|/* args: file descriptor, buffer, count */
name|retcode
operator|=
name|read
argument_list|(
name|arg
index|[
literal|0
index|]
argument_list|,
name|buf
argument_list|,
name|arg
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|retcode
operator|>
literal|0
condition|)
block|{
name|OninMemPut
argument_list|(
name|arg
index|[
literal|1
index|]
argument_list|,
name|buf
argument_list|,
name|retcode
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|BS_SEEK
case|:
comment|/* args: file descriptor, offset, whence */
name|retcode
operator|=
name|lseek
argument_list|(
name|arg
index|[
literal|0
index|]
argument_list|,
name|arg
index|[
literal|1
index|]
argument_list|,
name|arg
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|BS_WRITE
case|:
comment|/* args: file descriptor, buffer, count */
name|OninMemGet
argument_list|(
name|arg
index|[
literal|1
index|]
argument_list|,
name|buf
argument_list|,
name|arg
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|retcode
operator|=
name|write
argument_list|(
name|arg
index|[
literal|0
index|]
argument_list|,
name|buf
argument_list|,
name|arg
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
break|break;
default|default:
name|retcode
operator|=
name|ERROR
expr_stmt|;
break|break;
block|}
comment|/* Tell NINDY to continue 	 */
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"e%x"
argument_list|,
name|retcode
argument_list|)
expr_stmt|;
name|send
argument_list|(
name|buf
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/******************************************************************************  * ninStopWhy:  *	Assume the application program has stopped (i.e., a DLE was received  *	from NINDY).  Ask NINDY for status information describing the  *	reason for the halt.  *  *	Returns a non-zero value if the user program has exited, 0 otherwise.  *	Also returns the following information, through passed pointers:  *           - why: an exit code if program the exited; otherwise the reason  *			why the program halted (see stop.h for values).  *	    - contents of register ip (little-endian byte order)  *	    - contents of register sp (little-endian byte order)  *	    - contents of register fp (little-endian byte order)  ******************************************************************************/
end_comment

begin_function
name|char
name|OninStopWhy
parameter_list|(
name|whyp
parameter_list|,
name|ipp
parameter_list|,
name|fpp
parameter_list|,
name|spp
parameter_list|)
name|char
modifier|*
name|whyp
decl_stmt|;
comment|/* Return the 'why' code through this pointer	*/
name|char
modifier|*
name|ipp
decl_stmt|;
comment|/* Return contents of register ip through this pointer	*/
name|char
modifier|*
name|fpp
decl_stmt|;
comment|/* Return contents of register fp through this pointer	*/
name|char
modifier|*
name|spp
decl_stmt|;
comment|/* Return contents of register sp through this pointer	*/
block|{
name|char
name|buf
index|[
literal|30
index|]
decl_stmt|;
name|char
name|stop_exit
decl_stmt|;
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|"?"
argument_list|)
expr_stmt|;
name|send
argument_list|(
name|buf
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|hexbin
argument_list|(
literal|1
argument_list|,
name|buf
argument_list|,
operator|&
name|stop_exit
argument_list|)
expr_stmt|;
name|hexbin
argument_list|(
literal|1
argument_list|,
name|buf
operator|+
literal|2
argument_list|,
name|whyp
argument_list|)
expr_stmt|;
name|hexbin
argument_list|(
literal|4
argument_list|,
name|buf
operator|+
literal|4
argument_list|,
name|ipp
argument_list|)
expr_stmt|;
name|hexbin
argument_list|(
literal|4
argument_list|,
name|buf
operator|+
literal|12
argument_list|,
name|fpp
argument_list|)
expr_stmt|;
name|hexbin
argument_list|(
literal|4
argument_list|,
name|buf
operator|+
literal|20
argument_list|,
name|spp
argument_list|)
expr_stmt|;
return|return
name|stop_exit
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * ninStrGet:  *	Read a '\0'-terminated string of data out of the 960 memory space.  *  ******************************************************************************/
end_comment

begin_expr_stmt
specifier|static
name|OninStrGet
argument_list|(
argument|ninaddr
argument_list|,
argument|hostaddr
argument_list|)
name|unsigned
name|long
name|ninaddr
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Address of string in NINDY memory space */
end_comment

begin_decl_stmt
name|char
modifier|*
name|hostaddr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Address of the buffer to which string should 				 *	be copied. 				 */
end_comment

begin_block
block|{
name|char
name|buf
index|[
name|BUFSIZE
index|]
decl_stmt|;
comment|/* String as 2 ASCII hex digits per byte */
name|int
name|numchars
decl_stmt|;
comment|/* Length of string in bytes.		*/
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"\"%x"
argument_list|,
name|ninaddr
argument_list|)
expr_stmt|;
name|send
argument_list|(
name|buf
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|numchars
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
operator|/
literal|2
expr_stmt|;
name|hexbin
argument_list|(
name|numchars
argument_list|,
name|buf
argument_list|,
name|hostaddr
argument_list|)
expr_stmt|;
name|hostaddr
index|[
name|numchars
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
end_block

begin_comment
comment|/******************************************************************************  * ninVersion:  *	Ask NINDY for version information about itself.  *	The information is sent as an ascii string in the form "x.xx,<arch>",  *	where,  *		x.xx	is the version number  *<arch>	is the processor architecture: "KA", "KB", "MC", "CA" *  *  ******************************************************************************/
end_comment

begin_function
name|int
name|OninVersion
parameter_list|(
name|p
parameter_list|)
name|char
modifier|*
name|p
decl_stmt|;
comment|/* Where to place version string */
block|{
name|char
name|buf
index|[
name|BUFSIZE
index|]
decl_stmt|;
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|"v"
argument_list|)
expr_stmt|;
name|send
argument_list|(
name|buf
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|p
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return
name|strlen
argument_list|(
name|buf
argument_list|)
return|;
block|}
end_function

end_unit

