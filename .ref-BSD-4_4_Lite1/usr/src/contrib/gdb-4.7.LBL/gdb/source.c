begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* List lines of source files for GDB, the GNU debugger.    Copyright (C) 1986, 1987, 1988, 1989, 1991 Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"expression.h"
end_include

begin_include
include|#
directive|include
file|"language.h"
end_include

begin_include
include|#
directive|include
file|"command.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|USG
end_ifdef

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"regex.h"
end_include

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_include
include|#
directive|include
file|"objfiles.h"
end_include

begin_comment
comment|/* Prototypes for local functions. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|open_source_file
name|PARAMS
argument_list|(
operator|(
expr|struct
name|symtab
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|get_filename_and_charpos
name|PARAMS
argument_list|(
operator|(
expr|struct
name|symtab
operator|*
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|reverse_search_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|forward_search_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|line_info
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|list_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ambiguous_line_spec
name|PARAMS
argument_list|(
operator|(
expr|struct
name|symtabs_and_lines
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|source_info
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|show_directories
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|find_source_lines
name|PARAMS
argument_list|(
operator|(
expr|struct
name|symtab
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If we use this declaration, it breaks because of fucking ANSI "const" stuff    on some systems.  We just have to not declare it at all, have it default    to int, and possibly botch on a few systems.  Thanks, ANSIholes... */
end_comment

begin_comment
comment|/* extern char *strstr(); */
end_comment

begin_comment
comment|/* Path of directories to search for source files.    Same format as the PATH environment variable's value.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|source_path
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Symtab of default file for listing lines of.  */
end_comment

begin_decl_stmt
name|struct
name|symtab
modifier|*
name|current_source_symtab
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Default next line to list.  */
end_comment

begin_decl_stmt
name|int
name|current_source_line
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Default number of lines to print with commands like "list".    This is based on guessing how many long (i.e. more than chars_per_line    characters) lines there will be.  To be completely correct, "list"    and friends should be rewritten to count characters and see where    things are wrapping, but that would be a fair amount of work.  */
end_comment

begin_decl_stmt
name|int
name|lines_to_list
init|=
literal|10
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Line number of last line printed.  Default for various commands.    current_source_line is usually, but not always, the same as this.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|last_line_listed
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* First line number listed by last listing command.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|first_line_listed
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Set the source file default for the "list" command, specifying a    symtab.  Sigh.  Behavior specification: If it is called with a    non-zero argument, that is the symtab to select.  If it is not,    first lookup "main"; if it exists, use the symtab and line it    defines.  If not, take the last symtab in the symtab lists (if it    exists) or the last symtab in the psymtab lists (if *it* exists).  If    none of this works, report an error.   */
end_comment

begin_function
name|void
name|select_source_symtab
parameter_list|(
name|s
parameter_list|)
specifier|register
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
block|{
name|struct
name|symtabs_and_lines
name|sals
decl_stmt|;
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
name|struct
name|partial_symtab
modifier|*
name|ps
decl_stmt|;
name|struct
name|partial_symtab
modifier|*
name|cs_pst
init|=
literal|0
decl_stmt|;
name|struct
name|objfile
modifier|*
name|ofp
decl_stmt|;
if|if
condition|(
name|s
condition|)
block|{
name|current_source_symtab
operator|=
name|s
expr_stmt|;
name|current_source_line
operator|=
literal|1
expr_stmt|;
return|return;
block|}
comment|/* Make the default place to list be the function `main'      if one exists.  */
if|if
condition|(
name|lookup_symbol
argument_list|(
literal|"main"
argument_list|,
literal|0
argument_list|,
name|VAR_NAMESPACE
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|sals
operator|=
name|decode_line_spec
argument_list|(
literal|"main"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sal
operator|=
name|sals
operator|.
name|sals
index|[
literal|0
index|]
expr_stmt|;
name|free
argument_list|(
name|sals
operator|.
name|sals
argument_list|)
expr_stmt|;
name|current_source_symtab
operator|=
name|sal
operator|.
name|symtab
expr_stmt|;
name|current_source_line
operator|=
name|max
argument_list|(
name|sal
operator|.
name|line
operator|-
operator|(
name|lines_to_list
operator|-
literal|1
operator|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_source_symtab
condition|)
return|return;
block|}
comment|/* All right; find the last file in the symtab list (ignoring .h's).  */
name|current_source_line
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|ofp
operator|=
name|object_files
init|;
name|ofp
operator|!=
name|NULL
condition|;
name|ofp
operator|=
name|ofp
operator|->
name|next
control|)
block|{
for|for
control|(
name|s
operator|=
name|ofp
operator|->
name|symtabs
init|;
name|s
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
name|char
modifier|*
name|name
init|=
name|s
operator|->
name|filename
decl_stmt|;
name|int
name|len
init|=
name|strlen
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|len
operator|>
literal|2
operator|&&
operator|(
name|strcmp
argument_list|(
operator|&
name|name
index|[
name|len
operator|-
literal|2
index|]
argument_list|,
literal|".h"
argument_list|)
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
name|current_source_symtab
operator|=
name|s
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|current_source_symtab
condition|)
return|return;
comment|/* Howabout the partial symbol tables? */
for|for
control|(
name|ofp
operator|=
name|object_files
init|;
name|ofp
operator|!=
name|NULL
condition|;
name|ofp
operator|=
name|ofp
operator|->
name|next
control|)
block|{
for|for
control|(
name|ps
operator|=
name|ofp
operator|->
name|psymtabs
init|;
name|ps
operator|!=
name|NULL
condition|;
name|ps
operator|=
name|ps
operator|->
name|next
control|)
block|{
name|char
modifier|*
name|name
init|=
name|ps
operator|->
name|filename
decl_stmt|;
name|int
name|len
init|=
name|strlen
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|len
operator|>
literal|2
operator|&&
operator|(
name|strcmp
argument_list|(
operator|&
name|name
index|[
name|len
operator|-
literal|2
index|]
argument_list|,
literal|".h"
argument_list|)
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
name|cs_pst
operator|=
name|ps
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|cs_pst
condition|)
block|{
if|if
condition|(
name|cs_pst
operator|->
name|readin
condition|)
block|{
name|fatal
argument_list|(
literal|"Internal: select_source_symtab: readin pst found and no symtabs."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|current_source_symtab
operator|=
name|PSYMTAB_TO_SYMTAB
argument_list|(
name|cs_pst
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|current_source_symtab
condition|)
return|return;
name|error
argument_list|(
literal|"Can't find a default source file"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|show_directories
parameter_list|(
name|ignore
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|ignore
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|printf_filtered
argument_list|(
literal|"Source directories searched: %s\n"
argument_list|,
name|source_path
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Forget what we learned about line positions in source files,    and which directories contain them;    must check again now since files may be found in    a different directory now.  */
end_comment

begin_function
name|void
name|forget_cached_source_info
parameter_list|()
block|{
specifier|register
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
specifier|register
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
for|for
control|(
name|objfile
operator|=
name|object_files
init|;
name|objfile
operator|!=
name|NULL
condition|;
name|objfile
operator|=
name|objfile
operator|->
name|next
control|)
block|{
for|for
control|(
name|s
operator|=
name|objfile
operator|->
name|symtabs
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
if|if
condition|(
name|s
operator|->
name|line_charpos
operator|!=
name|NULL
condition|)
block|{
name|mfree
argument_list|(
name|objfile
operator|->
name|md
argument_list|,
name|s
operator|->
name|line_charpos
argument_list|)
expr_stmt|;
name|s
operator|->
name|line_charpos
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|->
name|fullname
operator|!=
name|NULL
condition|)
block|{
name|mfree
argument_list|(
name|objfile
operator|->
name|md
argument_list|,
name|s
operator|->
name|fullname
argument_list|)
expr_stmt|;
name|s
operator|->
name|fullname
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
name|void
name|init_source_path
parameter_list|()
block|{
name|source_path
operator|=
name|savestring
argument_list|(
literal|"$cdir:$cwd"
argument_list|,
comment|/* strlen of it */
literal|10
argument_list|)
expr_stmt|;
name|forget_cached_source_info
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add zero or more directories to the front of the source path.  */
end_comment

begin_function
name|void
name|directory_command
parameter_list|(
name|dirname
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|dirname
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|dont_repeat
argument_list|()
expr_stmt|;
comment|/* FIXME, this goes to "delete dir"... */
if|if
condition|(
name|dirname
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|query
argument_list|(
literal|"Reinitialize source path to empty? "
argument_list|,
literal|""
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|source_path
argument_list|)
expr_stmt|;
name|init_source_path
argument_list|()
expr_stmt|;
block|}
block|}
else|else
name|mod_path
argument_list|(
name|dirname
argument_list|,
operator|&
name|source_path
argument_list|)
expr_stmt|;
if|if
condition|(
name|from_tty
condition|)
name|show_directories
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
name|forget_cached_source_info
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add zero or more directories to the front of an arbitrary path.  */
end_comment

begin_function
name|void
name|mod_path
parameter_list|(
name|dirname
parameter_list|,
name|which_path
parameter_list|)
name|char
modifier|*
name|dirname
decl_stmt|;
name|char
modifier|*
modifier|*
name|which_path
decl_stmt|;
block|{
name|char
modifier|*
name|old
init|=
operator|*
name|which_path
decl_stmt|;
name|int
name|prefix
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|dirname
operator|==
literal|0
condition|)
return|return;
name|dirname
operator|=
name|strsave
argument_list|(
name|dirname
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|free
argument_list|,
name|dirname
argument_list|)
expr_stmt|;
do|do
block|{
name|char
modifier|*
name|name
init|=
name|dirname
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
block|{
name|char
modifier|*
name|colon
init|=
name|strchr
argument_list|(
name|name
argument_list|,
literal|':'
argument_list|)
decl_stmt|;
name|char
modifier|*
name|space
init|=
name|strchr
argument_list|(
name|name
argument_list|,
literal|' '
argument_list|)
decl_stmt|;
name|char
modifier|*
name|tab
init|=
name|strchr
argument_list|(
name|name
argument_list|,
literal|'\t'
argument_list|)
decl_stmt|;
if|if
condition|(
name|colon
operator|==
literal|0
operator|&&
name|space
operator|==
literal|0
operator|&&
name|tab
operator|==
literal|0
condition|)
name|p
operator|=
name|dirname
operator|=
name|name
operator|+
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
else|else
block|{
name|p
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|colon
operator|!=
literal|0
operator|&&
operator|(
name|p
operator|==
literal|0
operator|||
name|colon
operator|<
name|p
operator|)
condition|)
name|p
operator|=
name|colon
expr_stmt|;
if|if
condition|(
name|space
operator|!=
literal|0
operator|&&
operator|(
name|p
operator|==
literal|0
operator|||
name|space
operator|<
name|p
operator|)
condition|)
name|p
operator|=
name|space
expr_stmt|;
if|if
condition|(
name|tab
operator|!=
literal|0
operator|&&
operator|(
name|p
operator|==
literal|0
operator|||
name|tab
operator|<
name|p
operator|)
condition|)
name|p
operator|=
name|tab
expr_stmt|;
name|dirname
operator|=
name|p
operator|+
literal|1
expr_stmt|;
while|while
condition|(
operator|*
name|dirname
operator|==
literal|':'
operator|||
operator|*
name|dirname
operator|==
literal|' '
operator|||
operator|*
name|dirname
operator|==
literal|'\t'
condition|)
operator|++
name|dirname
expr_stmt|;
block|}
block|}
if|if
condition|(
name|p
index|[
operator|-
literal|1
index|]
operator|==
literal|'/'
condition|)
comment|/* Sigh. "foo/" => "foo" */
operator|--
name|p
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
name|p
index|[
operator|-
literal|1
index|]
operator|==
literal|'.'
condition|)
block|{
if|if
condition|(
name|p
operator|-
name|name
operator|==
literal|1
condition|)
block|{
comment|/* "." => getwd ().  */
name|name
operator|=
name|current_directory
expr_stmt|;
goto|goto
name|append
goto|;
block|}
elseif|else
if|if
condition|(
name|p
index|[
operator|-
literal|2
index|]
operator|==
literal|'/'
condition|)
block|{
if|if
condition|(
name|p
operator|-
name|name
operator|==
literal|2
condition|)
block|{
comment|/* "/." => "/".  */
operator|*
operator|--
name|p
operator|=
literal|'\0'
expr_stmt|;
goto|goto
name|append
goto|;
block|}
else|else
block|{
comment|/* "...foo/." => "...foo".  */
name|p
operator|-=
literal|2
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
continue|continue;
block|}
block|}
else|else
break|break;
block|}
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'~'
condition|)
name|name
operator|=
name|tilde_expand
argument_list|(
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|!=
literal|'/'
operator|&&
name|name
index|[
literal|0
index|]
operator|!=
literal|'$'
condition|)
name|name
operator|=
name|concat
argument_list|(
name|current_directory
argument_list|,
literal|"/"
argument_list|,
name|name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
name|name
operator|=
name|savestring
argument_list|(
name|name
argument_list|,
name|p
operator|-
name|name
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|free
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* Unless it's a variable, check existence.  */
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|!=
literal|'$'
condition|)
block|{
if|if
condition|(
name|stat
argument_list|(
name|name
argument_list|,
operator|&
name|st
argument_list|)
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|st
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|!=
name|S_IFDIR
condition|)
name|error
argument_list|(
literal|"%s is not a directory."
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
name|append
label|:
block|{
specifier|register
name|unsigned
name|int
name|len
init|=
name|strlen
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|p
operator|=
operator|*
name|which_path
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|p
argument_list|,
name|name
argument_list|,
name|len
argument_list|)
operator|&&
operator|(
name|p
index|[
name|len
index|]
operator|==
literal|'\0'
operator|||
name|p
index|[
name|len
index|]
operator|==
literal|':'
operator|)
condition|)
block|{
comment|/* Found it in the search path, remove old copy */
if|if
condition|(
name|p
operator|>
operator|*
name|which_path
condition|)
name|p
operator|--
expr_stmt|;
comment|/* Back over leading colon */
if|if
condition|(
name|prefix
operator|>
name|p
operator|-
operator|*
name|which_path
condition|)
goto|goto
name|skip_dup
goto|;
comment|/* Same dir twice in one cmd */
name|strcpy
argument_list|(
name|p
argument_list|,
operator|&
name|p
index|[
name|len
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* Copy from next \0 or  : */
block|}
name|p
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
literal|0
condition|)
operator|++
name|p
expr_stmt|;
else|else
break|break;
block|}
if|if
condition|(
name|p
operator|==
literal|0
condition|)
block|{
comment|/* If we have already tacked on a name(s) in this command,			   be sure they stay on the front as we tack on some more.  */
if|if
condition|(
name|prefix
condition|)
block|{
name|char
modifier|*
name|temp
decl_stmt|,
name|c
decl_stmt|;
name|c
operator|=
name|old
index|[
name|prefix
index|]
expr_stmt|;
name|old
index|[
name|prefix
index|]
operator|=
literal|'\0'
expr_stmt|;
name|temp
operator|=
name|concat
argument_list|(
name|old
argument_list|,
literal|":"
argument_list|,
name|name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|old
index|[
name|prefix
index|]
operator|=
name|c
expr_stmt|;
operator|*
name|which_path
operator|=
name|concat
argument_list|(
name|temp
argument_list|,
literal|""
argument_list|,
operator|&
name|old
index|[
name|prefix
index|]
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|prefix
operator|=
name|strlen
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|which_path
operator|=
name|concat
argument_list|(
name|name
argument_list|,
operator|(
name|old
index|[
literal|0
index|]
condition|?
literal|":"
else|:
name|old
operator|)
argument_list|,
name|old
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|prefix
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|old
argument_list|)
expr_stmt|;
name|old
operator|=
operator|*
name|which_path
expr_stmt|;
block|}
block|}
name|skip_dup
label|:
empty_stmt|;
block|}
do|while
condition|(
operator|*
name|dirname
operator|!=
literal|'\0'
condition|)
do|;
block|}
end_function

begin_function
specifier|static
name|void
name|source_info
parameter_list|(
name|ignore
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|ignore
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
specifier|register
name|struct
name|symtab
modifier|*
name|s
init|=
name|current_source_symtab
decl_stmt|;
if|if
condition|(
operator|!
name|s
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"No current source file.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|printf_filtered
argument_list|(
literal|"Current source file is %s\n"
argument_list|,
name|s
operator|->
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|dirname
condition|)
name|printf_filtered
argument_list|(
literal|"Compilation directory is %s\n"
argument_list|,
name|s
operator|->
name|dirname
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|fullname
condition|)
name|printf_filtered
argument_list|(
literal|"Located in %s\n"
argument_list|,
name|s
operator|->
name|fullname
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|nlines
condition|)
name|printf_filtered
argument_list|(
literal|"Contains %d lines\n"
argument_list|,
name|s
operator|->
name|nlines
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"Source language %s.\n"
argument_list|,
name|language_str
argument_list|(
name|s
operator|->
name|language
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Open a file named STRING, searching path PATH (dir names sep by colons)    using mode MODE and protection bits PROT in the calls to open.    If TRY_CWD_FIRST, try to open ./STRING before searching PATH.    (ie pretend the first element of PATH is ".")    If FILENAMED_OPENED is non-null, set it to a newly allocated string naming    the actual file opened (this string will always start with a "/".  We    have to take special pains to avoid doubling the "/" between the directory    and the file, sigh!  Emacs gets confuzzed by this when we print the    source file name!!!      If a file is found, return the descriptor.    Otherwise, return -1, with errno set for the last name we tried to open.  */
end_comment

begin_comment
comment|/*>>>> This should only allow files of certain types,>>>>  eg executable, non-directory */
end_comment

begin_function
name|int
name|openp
parameter_list|(
name|path
parameter_list|,
name|try_cwd_first
parameter_list|,
name|string
parameter_list|,
name|mode
parameter_list|,
name|prot
parameter_list|,
name|filename_opened
parameter_list|)
name|char
modifier|*
name|path
decl_stmt|;
name|int
name|try_cwd_first
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|mode
decl_stmt|;
name|int
name|prot
decl_stmt|;
name|char
modifier|*
modifier|*
name|filename_opened
decl_stmt|;
block|{
specifier|register
name|int
name|fd
decl_stmt|;
specifier|register
name|char
modifier|*
name|filename
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|p1
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
name|int
name|alloclen
decl_stmt|;
if|if
condition|(
operator|!
name|path
condition|)
name|path
operator|=
literal|"."
expr_stmt|;
comment|/* ./foo => foo */
while|while
condition|(
name|string
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|string
index|[
literal|1
index|]
operator|==
literal|'/'
condition|)
name|string
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|try_cwd_first
operator|||
name|string
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
block|{
name|filename
operator|=
name|string
expr_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|filename
argument_list|,
name|mode
argument_list|,
name|prot
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|>=
literal|0
operator|||
name|string
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
goto|goto
name|done
goto|;
block|}
name|alloclen
operator|=
name|strlen
argument_list|(
name|path
argument_list|)
operator|+
name|strlen
argument_list|(
name|string
argument_list|)
operator|+
literal|2
expr_stmt|;
name|filename
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|alloclen
argument_list|)
expr_stmt|;
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|p
operator|=
name|path
init|;
name|p
condition|;
name|p
operator|=
name|p1
condition|?
name|p1
operator|+
literal|1
else|:
literal|0
control|)
block|{
name|p1
operator|=
operator|(
name|char
operator|*
operator|)
name|strchr
argument_list|(
name|p
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p1
condition|)
name|len
operator|=
name|p1
operator|-
name|p
expr_stmt|;
else|else
name|len
operator|=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|4
operator|&&
name|p
index|[
literal|0
index|]
operator|==
literal|'$'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'c'
operator|&&
name|p
index|[
literal|2
index|]
operator|==
literal|'w'
operator|&&
name|p
index|[
literal|3
index|]
operator|==
literal|'d'
condition|)
block|{
comment|/* Name is $cwd -- insert current directory name instead.  */
name|int
name|newlen
decl_stmt|;
comment|/* First, realloc the filename buffer if too short. */
name|len
operator|=
name|strlen
argument_list|(
name|current_directory
argument_list|)
expr_stmt|;
name|newlen
operator|=
name|len
operator|+
name|strlen
argument_list|(
name|string
argument_list|)
operator|+
literal|2
expr_stmt|;
if|if
condition|(
name|newlen
operator|>
name|alloclen
condition|)
block|{
name|alloclen
operator|=
name|newlen
expr_stmt|;
name|filename
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|alloclen
argument_list|)
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|filename
argument_list|,
name|current_directory
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Normal file name in path -- just use it.  */
name|strncpy
argument_list|(
name|filename
argument_list|,
name|p
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|filename
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Remove trailing slashes */
while|while
condition|(
name|len
operator|>
literal|0
operator|&&
name|filename
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|'/'
condition|)
name|filename
index|[
operator|--
name|len
index|]
operator|=
literal|0
expr_stmt|;
name|strcat
argument_list|(
name|filename
operator|+
name|len
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|filename
argument_list|,
name|string
argument_list|)
expr_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|filename
argument_list|,
name|mode
argument_list|,
name|prot
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|>=
literal|0
condition|)
break|break;
block|}
name|done
label|:
if|if
condition|(
name|filename_opened
condition|)
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
operator|*
name|filename_opened
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|filename
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
operator|*
name|filename_opened
operator|=
name|savestring
argument_list|(
name|filename
argument_list|,
name|strlen
argument_list|(
name|filename
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Beware the // my son, the Emacs barfs, the botch that catch... */
operator|*
name|filename_opened
operator|=
name|concat
argument_list|(
name|current_directory
argument_list|,
literal|'/'
operator|==
name|current_directory
index|[
name|strlen
argument_list|(
name|current_directory
argument_list|)
operator|-
literal|1
index|]
condition|?
literal|""
else|:
literal|"/"
argument_list|,
name|filename
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
return|return
name|fd
return|;
block|}
end_function

begin_comment
comment|/* Open a source file given a symtab S.  Returns a file descriptor    or negative number for error.  */
end_comment

begin_function
specifier|static
name|int
name|open_source_file
parameter_list|(
name|s
parameter_list|)
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
block|{
name|char
modifier|*
name|path
init|=
name|source_path
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|result
decl_stmt|;
name|char
modifier|*
name|fullname
decl_stmt|;
comment|/* Quick way out if we already know its full name */
if|if
condition|(
name|s
operator|->
name|fullname
condition|)
block|{
name|result
operator|=
name|open
argument_list|(
name|s
operator|->
name|fullname
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|>=
literal|0
condition|)
return|return
name|result
return|;
comment|/* Didn't work -- free old one, try again. */
name|mfree
argument_list|(
name|s
operator|->
name|objfile
operator|->
name|md
argument_list|,
name|s
operator|->
name|fullname
argument_list|)
expr_stmt|;
name|s
operator|->
name|fullname
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|->
name|dirname
operator|!=
name|NULL
condition|)
block|{
comment|/* Replace a path entry of  $cdir  with the compilation directory name */
define|#
directive|define
name|cdir_len
value|5
comment|/* We cast strstr's result in case an ANSIhole has made it const, 	 which produces a "required warning" when assigned to a nonconst. */
name|p
operator|=
operator|(
name|char
operator|*
operator|)
name|strstr
argument_list|(
name|source_path
argument_list|,
literal|"$cdir"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|&&
operator|(
name|p
operator|==
name|path
operator|||
name|p
index|[
operator|-
literal|1
index|]
operator|==
literal|':'
operator|)
operator|&&
operator|(
name|p
index|[
name|cdir_len
index|]
operator|==
literal|':'
operator|||
name|p
index|[
name|cdir_len
index|]
operator|==
literal|'\0'
operator|)
condition|)
block|{
name|int
name|len
decl_stmt|;
name|path
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|source_path
argument_list|)
operator|+
literal|1
operator|+
name|strlen
argument_list|(
name|s
operator|->
name|dirname
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|len
operator|=
name|p
operator|-
name|source_path
expr_stmt|;
name|strncpy
argument_list|(
name|path
argument_list|,
name|source_path
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* Before $cdir */
name|strcpy
argument_list|(
name|path
operator|+
name|len
argument_list|,
name|s
operator|->
name|dirname
argument_list|)
expr_stmt|;
comment|/* new stuff */
name|strcat
argument_list|(
name|path
operator|+
name|len
argument_list|,
name|source_path
operator|+
name|len
operator|+
name|cdir_len
argument_list|)
expr_stmt|;
comment|/* After $cdir */
block|}
block|}
name|result
operator|=
name|openp
argument_list|(
name|path
argument_list|,
literal|0
argument_list|,
name|s
operator|->
name|filename
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|,
operator|&
name|s
operator|->
name|fullname
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|<
literal|0
condition|)
block|{
comment|/* Didn't work.  Try using just the basename. */
name|p
operator|=
name|basename
argument_list|(
name|s
operator|->
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|s
operator|->
name|filename
condition|)
name|result
operator|=
name|openp
argument_list|(
name|path
argument_list|,
literal|0
argument_list|,
name|p
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|,
operator|&
name|s
operator|->
name|fullname
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|>=
literal|0
condition|)
block|{
name|fullname
operator|=
name|s
operator|->
name|fullname
expr_stmt|;
name|s
operator|->
name|fullname
operator|=
name|mstrsave
argument_list|(
name|s
operator|->
name|objfile
operator|->
name|md
argument_list|,
name|s
operator|->
name|fullname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|fullname
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Create and initialize the table S->line_charpos that records    the positions of the lines in the source file, which is assumed    to be open on descriptor DESC.    All set S->nlines to the number of such lines.  */
end_comment

begin_function
specifier|static
name|void
name|find_source_lines
parameter_list|(
name|s
parameter_list|,
name|desc
parameter_list|)
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
name|int
name|desc
decl_stmt|;
block|{
name|struct
name|stat
name|st
decl_stmt|;
name|char
name|c
decl_stmt|;
specifier|register
name|char
modifier|*
name|data
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
name|end
decl_stmt|;
name|int
name|nlines
init|=
literal|0
decl_stmt|;
name|int
name|lines_allocated
init|=
literal|1000
decl_stmt|;
name|int
modifier|*
name|line_charpos
decl_stmt|;
name|long
name|exec_mtime
decl_stmt|;
name|int
name|size
decl_stmt|;
name|line_charpos
operator|=
operator|(
name|int
operator|*
operator|)
name|xmmalloc
argument_list|(
name|s
operator|->
name|objfile
operator|->
name|md
argument_list|,
name|lines_allocated
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fstat
argument_list|(
name|desc
argument_list|,
operator|&
name|st
argument_list|)
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
name|s
operator|->
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|exec_bfd
condition|)
block|{
name|exec_mtime
operator|=
name|bfd_get_mtime
argument_list|(
name|exec_bfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|exec_mtime
operator|&&
name|exec_mtime
operator|<
name|st
operator|.
name|st_mtime
condition|)
name|printf_filtered
argument_list|(
literal|"Source file is more recent than executable.\n"
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|LSEEK_NOT_LINEAR
comment|/* Have to read it byte by byte to find out where the chars live */
name|line_charpos
index|[
literal|0
index|]
operator|=
name|tell
argument_list|(
name|desc
argument_list|)
expr_stmt|;
name|nlines
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|myread
argument_list|(
name|desc
argument_list|,
operator|&
name|c
argument_list|,
literal|1
argument_list|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
if|if
condition|(
name|nlines
operator|==
name|lines_allocated
condition|)
block|{
name|lines_allocated
operator|*=
literal|2
expr_stmt|;
name|line_charpos
operator|=
operator|(
name|int
operator|*
operator|)
name|xmrealloc
argument_list|(
name|s
operator|->
name|objfile
operator|->
name|md
argument_list|,
operator|(
name|char
operator|*
operator|)
name|line_charpos
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
name|lines_allocated
argument_list|)
expr_stmt|;
block|}
name|line_charpos
index|[
name|nlines
operator|++
index|]
operator|=
name|tell
argument_list|(
name|desc
argument_list|)
expr_stmt|;
block|}
block|}
else|#
directive|else
comment|/* st_size might be a large type, but we only support source files whose       size fits in an int.  FIXME. */
name|size
operator|=
operator|(
name|int
operator|)
name|st
operator|.
name|st_size
expr_stmt|;
ifdef|#
directive|ifdef
name|BROKEN_LARGE_ALLOCA
name|data
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|free
argument_list|,
name|data
argument_list|)
expr_stmt|;
else|#
directive|else
name|data
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|size
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|myread
argument_list|(
name|desc
argument_list|,
name|data
argument_list|,
name|size
argument_list|)
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
name|s
operator|->
name|filename
argument_list|)
expr_stmt|;
name|end
operator|=
name|data
operator|+
name|size
expr_stmt|;
name|p
operator|=
name|data
expr_stmt|;
name|line_charpos
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|nlines
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|p
operator|!=
name|end
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|++
operator|==
literal|'\n'
comment|/* A newline at the end does not start a new line.  */
operator|&&
name|p
operator|!=
name|end
condition|)
block|{
if|if
condition|(
name|nlines
operator|==
name|lines_allocated
condition|)
block|{
name|lines_allocated
operator|*=
literal|2
expr_stmt|;
name|line_charpos
operator|=
operator|(
name|int
operator|*
operator|)
name|xmrealloc
argument_list|(
name|s
operator|->
name|objfile
operator|->
name|md
argument_list|,
operator|(
name|char
operator|*
operator|)
name|line_charpos
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
name|lines_allocated
argument_list|)
expr_stmt|;
block|}
name|line_charpos
index|[
name|nlines
operator|++
index|]
operator|=
name|p
operator|-
name|data
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|s
operator|->
name|nlines
operator|=
name|nlines
expr_stmt|;
name|s
operator|->
name|line_charpos
operator|=
operator|(
name|int
operator|*
operator|)
name|xmrealloc
argument_list|(
name|s
operator|->
name|objfile
operator|->
name|md
argument_list|,
operator|(
name|char
operator|*
operator|)
name|line_charpos
argument_list|,
name|nlines
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the character position of a line LINE in symtab S.    Return 0 if anything is invalid.  */
end_comment

begin_function
name|int
name|source_line_charpos
parameter_list|(
name|s
parameter_list|,
name|line
parameter_list|)
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
name|int
name|line
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|s
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|s
operator|->
name|line_charpos
operator|||
name|line
operator|<=
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|line
operator|>
name|s
operator|->
name|nlines
condition|)
name|line
operator|=
name|s
operator|->
name|nlines
expr_stmt|;
return|return
name|s
operator|->
name|line_charpos
index|[
name|line
operator|-
literal|1
index|]
return|;
block|}
end_function

begin_comment
comment|/* Return the line number of character position POS in symtab S.  */
end_comment

begin_function
name|int
name|source_charpos_line
parameter_list|(
name|s
parameter_list|,
name|chr
parameter_list|)
specifier|register
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
specifier|register
name|int
name|chr
decl_stmt|;
block|{
specifier|register
name|int
name|line
init|=
literal|0
decl_stmt|;
specifier|register
name|int
modifier|*
name|lnp
decl_stmt|;
if|if
condition|(
name|s
operator|==
literal|0
operator|||
name|s
operator|->
name|line_charpos
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|lnp
operator|=
name|s
operator|->
name|line_charpos
expr_stmt|;
comment|/* Files are usually short, so sequential search is Ok */
while|while
condition|(
name|line
operator|<
name|s
operator|->
name|nlines
operator|&&
operator|*
name|lnp
operator|<=
name|chr
condition|)
block|{
name|line
operator|++
expr_stmt|;
name|lnp
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|line
operator|>=
name|s
operator|->
name|nlines
condition|)
name|line
operator|=
name|s
operator|->
name|nlines
expr_stmt|;
return|return
name|line
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Get full pathname and line number positions for a symtab.    Return nonzero if line numbers may have changed.    Set *FULLNAME to actual name of the file as found by `openp',    or to 0 if the file is not found.  */
end_comment

begin_function
name|int
name|get_filename_and_charpos
parameter_list|(
name|s
parameter_list|,
name|fullname
parameter_list|)
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
name|char
modifier|*
modifier|*
name|fullname
decl_stmt|;
block|{
specifier|register
name|int
name|desc
decl_stmt|,
name|linenums_changed
init|=
literal|0
decl_stmt|;
name|desc
operator|=
name|open_source_file
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|desc
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|fullname
condition|)
operator|*
name|fullname
operator|=
name|NULL
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|fullname
condition|)
operator|*
name|fullname
operator|=
name|s
operator|->
name|fullname
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|line_charpos
operator|==
literal|0
condition|)
name|linenums_changed
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|linenums_changed
condition|)
name|find_source_lines
argument_list|(
name|s
argument_list|,
name|desc
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|desc
argument_list|)
expr_stmt|;
return|return
name|linenums_changed
return|;
block|}
end_function

begin_comment
comment|/* Print text describing the full name of the source file S    and the line number LINE and its corresponding character position.    The text starts with two Ctrl-z so that the Emacs-GDB interface    can easily find it.     MID_STATEMENT is nonzero if the PC is not at the beginning of that line.     Return 1 if successful, 0 if could not find the file.  */
end_comment

begin_function
name|int
name|identify_source_line
parameter_list|(
name|s
parameter_list|,
name|line
parameter_list|,
name|mid_statement
parameter_list|)
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
name|int
name|line
decl_stmt|;
name|int
name|mid_statement
decl_stmt|;
block|{
if|if
condition|(
name|s
operator|->
name|line_charpos
operator|==
literal|0
condition|)
name|get_filename_and_charpos
argument_list|(
name|s
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|fullname
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|printf
argument_list|(
literal|"\032\032%s:%d:%d:%s:0x%x\n"
argument_list|,
name|s
operator|->
name|fullname
argument_list|,
name|line
argument_list|,
name|s
operator|->
name|line_charpos
index|[
name|line
operator|-
literal|1
index|]
argument_list|,
name|mid_statement
condition|?
literal|"middle"
else|:
literal|"beg"
argument_list|,
name|get_frame_pc
argument_list|(
name|get_current_frame
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|current_source_line
operator|=
name|line
expr_stmt|;
name|first_line_listed
operator|=
name|line
expr_stmt|;
name|last_line_listed
operator|=
name|line
expr_stmt|;
name|current_source_symtab
operator|=
name|s
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print source lines from the file of symtab S,    starting with line number LINE and stopping before line number STOPLINE.  */
end_comment

begin_function
name|void
name|print_source_lines
parameter_list|(
name|s
parameter_list|,
name|line
parameter_list|,
name|stopline
parameter_list|,
name|noerror
parameter_list|)
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
name|int
name|line
decl_stmt|,
name|stopline
decl_stmt|;
name|int
name|noerror
decl_stmt|;
block|{
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|int
name|desc
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|stream
decl_stmt|;
name|int
name|nlines
init|=
name|stopline
operator|-
name|line
decl_stmt|;
comment|/* Regardless of whether we can open the file, set current_source_symtab. */
name|current_source_symtab
operator|=
name|s
expr_stmt|;
name|current_source_line
operator|=
name|line
expr_stmt|;
name|first_line_listed
operator|=
name|line
expr_stmt|;
name|desc
operator|=
name|open_source_file
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|desc
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|noerror
operator|&&
name|line
operator|+
literal|1
operator|==
name|stopline
condition|)
block|{
comment|/* can't find the file - tell user where we are anyway */
name|current_source_symtab
operator|=
name|s
expr_stmt|;
name|current_source_line
operator|=
name|line
expr_stmt|;
name|first_line_listed
operator|=
name|line
expr_stmt|;
name|last_line_listed
operator|=
name|line
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"%d\t(%s)\n"
argument_list|,
name|current_source_line
operator|++
argument_list|,
name|s
operator|->
name|filename
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|noerror
condition|)
block|{
name|char
modifier|*
name|name
init|=
name|alloca
argument_list|(
name|strlen
argument_list|(
name|s
operator|->
name|filename
argument_list|)
operator|+
literal|100
argument_list|)
decl_stmt|;
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"%s:%d"
argument_list|,
name|s
operator|->
name|filename
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|print_sys_errmsg
argument_list|(
name|name
argument_list|,
name|errno
argument_list|)
expr_stmt|;
block|}
block|}
return|return;
block|}
if|if
condition|(
name|s
operator|->
name|line_charpos
operator|==
literal|0
condition|)
name|find_source_lines
argument_list|(
name|s
argument_list|,
name|desc
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
operator|<
literal|1
operator|||
name|line
operator|>
name|s
operator|->
name|nlines
condition|)
block|{
name|close
argument_list|(
name|desc
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"Line number %d out of range; %s has %d lines."
argument_list|,
name|line
argument_list|,
name|s
operator|->
name|filename
argument_list|,
name|s
operator|->
name|nlines
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lseek
argument_list|(
name|desc
argument_list|,
name|s
operator|->
name|line_charpos
index|[
name|line
operator|-
literal|1
index|]
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|close
argument_list|(
name|desc
argument_list|)
expr_stmt|;
name|perror_with_name
argument_list|(
name|s
operator|->
name|filename
argument_list|)
expr_stmt|;
block|}
name|stream
operator|=
name|fdopen
argument_list|(
name|desc
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|clearerr
argument_list|(
name|stream
argument_list|)
expr_stmt|;
while|while
condition|(
name|nlines
operator|--
operator|>
literal|0
condition|)
block|{
name|c
operator|=
name|fgetc
argument_list|(
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
break|break;
name|last_line_listed
operator|=
name|current_source_line
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"%d\t"
argument_list|,
name|current_source_line
operator|++
argument_list|)
expr_stmt|;
do|do
block|{
if|if
condition|(
name|c
operator|<
literal|040
operator|&&
name|c
operator|!=
literal|'\t'
operator|&&
name|c
operator|!=
literal|'\n'
operator|&&
name|c
operator|!=
literal|'\r'
condition|)
name|printf_filtered
argument_list|(
literal|"^%c"
argument_list|,
name|c
operator|+
literal|0100
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|0177
condition|)
name|printf_filtered
argument_list|(
literal|"^?"
argument_list|)
expr_stmt|;
else|else
name|printf_filtered
argument_list|(
literal|"%c"
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|c
operator|!=
literal|'\n'
operator|&&
operator|(
name|c
operator|=
name|fgetc
argument_list|(
name|stream
argument_list|)
operator|)
operator|>=
literal|0
condition|)
do|;
block|}
name|fclose
argument_list|(
name|stream
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*    C++   Print a list of files and line numbers which a user may choose from   in order to list a function which was specified ambiguously   (as with `list classname::overloadedfuncname', for example).   The vector in SALS provides the filenames and line numbers.   */
end_comment

begin_function
specifier|static
name|void
name|ambiguous_line_spec
parameter_list|(
name|sals
parameter_list|)
name|struct
name|symtabs_and_lines
modifier|*
name|sals
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sals
operator|->
name|nelts
condition|;
operator|++
name|i
control|)
name|printf_filtered
argument_list|(
literal|"file: \"%s\", line number: %d\n"
argument_list|,
name|sals
operator|->
name|sals
index|[
name|i
index|]
operator|.
name|symtab
operator|->
name|filename
argument_list|,
name|sals
operator|->
name|sals
index|[
name|i
index|]
operator|.
name|line
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|setfile_command
parameter_list|(
name|arg
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|struct
name|symtabs_and_lines
name|sals
decl_stmt|;
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
name|char
modifier|*
name|arg1
decl_stmt|;
name|int
name|linenum_beg
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
comment|/* Pull in a current source symtab if necessary */
if|if
condition|(
name|arg
operator|==
literal|0
operator|||
name|arg
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|current_source_symtab
operator|==
literal|0
condition|)
name|select_source_symtab
argument_list|(
literal|0
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|current_source_symtab
operator|->
name|filename
argument_list|)
expr_stmt|;
return|return;
block|}
name|arg1
operator|=
name|arg
expr_stmt|;
name|sals
operator|=
name|decode_line_1
argument_list|(
operator|&
name|arg1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sals
operator|.
name|nelts
condition|)
return|return;
comment|/*  C++  */
if|if
condition|(
name|sals
operator|.
name|nelts
operator|>
literal|1
condition|)
block|{
name|ambiguous_line_spec
argument_list|(
operator|&
name|sals
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sals
operator|.
name|sals
argument_list|)
expr_stmt|;
return|return;
block|}
name|sal
operator|=
name|sals
operator|.
name|sals
index|[
literal|0
index|]
expr_stmt|;
name|free
argument_list|(
name|sals
operator|.
name|sals
argument_list|)
expr_stmt|;
comment|/* Record whether the BEG arg is all digits.  */
for|for
control|(
name|p
operator|=
name|arg
init|;
name|p
operator|!=
name|arg1
operator|&&
operator|*
name|p
operator|>=
literal|'0'
operator|&&
operator|*
name|p
operator|<=
literal|'9'
condition|;
operator|++
name|p
control|)
empty_stmt|;
name|linenum_beg
operator|=
operator|(
name|p
operator|==
name|arg1
operator|)
expr_stmt|;
comment|/* if line was specified by address,      print exactly which line, and which file.      In this case, sal.symtab == 0 means address is outside      of all known source files, not that user failed to give a filename.  */
if|if
condition|(
operator|*
name|arg
operator|==
literal|'*'
condition|)
block|{
if|if
condition|(
name|sal
operator|.
name|symtab
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"No source file for address 0x%x."
argument_list|,
name|sal
operator|.
name|pc
argument_list|)
expr_stmt|;
name|sym
operator|=
name|find_pc_function
argument_list|(
name|sal
operator|.
name|pc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
condition|)
name|printf
argument_list|(
literal|"0x%x is in %s (%s, line %d).\n"
argument_list|,
name|sal
operator|.
name|pc
argument_list|,
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
name|sal
operator|.
name|symtab
operator|->
name|filename
argument_list|,
name|sal
operator|.
name|line
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"0x%x is in %s, line %d.\n"
argument_list|,
name|sal
operator|.
name|pc
argument_list|,
name|sal
operator|.
name|symtab
operator|->
name|filename
argument_list|,
name|sal
operator|.
name|line
argument_list|)
expr_stmt|;
block|}
comment|/* If line was not specified by just a line number,      and it does not imply a symtab, it must be an undebuggable symbol      which means no source code.  */
if|if
condition|(
name|sal
operator|.
name|symtab
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|linenum_beg
condition|)
name|error
argument_list|(
literal|"No line number known for %s."
argument_list|,
name|arg
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"No default source file yet.  Do \"help list\"."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|current_source_symtab
operator|=
name|sal
operator|.
name|symtab
expr_stmt|;
name|current_source_line
operator|=
name|sal
operator|.
name|line
expr_stmt|;
name|first_line_listed
operator|=
name|sal
operator|.
name|line
expr_stmt|;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|PUSH_STACK_SIZE
value|32
end_define

begin_struct
specifier|static
struct|struct
block|{
name|struct
name|symtab
modifier|*
name|symtab
decl_stmt|;
name|int
name|line
decl_stmt|;
block|}
name|push_stack
index|[
name|PUSH_STACK_SIZE
index|]
struct|;
end_struct

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|push_stack_ptr
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|push_to_file_command
parameter_list|(
name|arg
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|struct
name|symtab
modifier|*
name|cursym
init|=
name|current_source_symtab
decl_stmt|;
name|int
name|curline
init|=
name|current_source_line
decl_stmt|;
specifier|register
name|unsigned
name|int
name|i
decl_stmt|;
name|setfile_command
argument_list|(
name|arg
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
comment|/* if we got back, command was successful */
name|i
operator|=
name|push_stack_ptr
expr_stmt|;
name|push_stack
index|[
name|i
index|]
operator|.
name|symtab
operator|=
name|cursym
expr_stmt|;
name|push_stack
index|[
name|i
index|]
operator|.
name|line
operator|=
name|curline
expr_stmt|;
name|push_stack_ptr
operator|=
operator|(
name|i
operator|+
literal|1
operator|)
operator|&
operator|(
name|PUSH_STACK_SIZE
operator|-
literal|1
operator|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|pop_file_command
parameter_list|(
name|arg
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
specifier|register
name|unsigned
name|int
name|i
init|=
name|push_stack_ptr
decl_stmt|;
comment|/* if there's something on the stack, pop it& clear the slot. */
name|i
operator|=
operator|(
name|i
operator|+
operator|(
name|PUSH_STACK_SIZE
operator|-
literal|1
operator|)
operator|)
operator|&
operator|(
name|PUSH_STACK_SIZE
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|push_stack
index|[
name|i
index|]
operator|.
name|symtab
condition|)
block|{
name|current_source_symtab
operator|=
name|push_stack
index|[
name|i
index|]
operator|.
name|symtab
expr_stmt|;
name|first_line_listed
operator|=
name|current_source_line
operator|=
name|push_stack
index|[
name|i
index|]
operator|.
name|line
expr_stmt|;
name|push_stack
index|[
name|i
index|]
operator|.
name|symtab
operator|=
name|NULL
expr_stmt|;
name|push_stack_ptr
operator|=
name|i
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|list_command
parameter_list|(
name|arg
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|struct
name|symtabs_and_lines
name|sals
decl_stmt|,
name|sals_end
decl_stmt|;
name|struct
name|symtab_and_line
name|sal
decl_stmt|,
name|sal_end
decl_stmt|;
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
name|char
modifier|*
name|arg1
decl_stmt|;
name|int
name|no_end
init|=
literal|1
decl_stmt|;
name|int
name|dummy_end
init|=
literal|0
decl_stmt|;
name|int
name|dummy_beg
init|=
literal|0
decl_stmt|;
name|int
name|linenum_beg
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|!
name|have_full_symbols
argument_list|()
operator|&&
operator|!
name|have_partial_symbols
argument_list|()
condition|)
name|error
argument_list|(
literal|"No symbol table is loaded.  Use the \"file\" command."
argument_list|)
expr_stmt|;
comment|/* Pull in a current source symtab if necessary */
if|if
condition|(
name|current_source_symtab
operator|==
literal|0
operator|&&
operator|(
name|arg
operator|==
literal|0
operator|||
name|arg
index|[
literal|0
index|]
operator|==
literal|'+'
operator|||
name|arg
index|[
literal|0
index|]
operator|==
literal|'-'
operator|)
condition|)
name|select_source_symtab
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* "l" or "l +" lists next ten lines.  */
if|if
condition|(
name|arg
operator|==
literal|0
operator|||
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"+"
argument_list|)
condition|)
block|{
if|if
condition|(
name|current_source_symtab
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"No default source file yet.  Do \"help list\"."
argument_list|)
expr_stmt|;
name|print_source_lines
argument_list|(
name|current_source_symtab
argument_list|,
name|current_source_line
argument_list|,
name|current_source_line
operator|+
name|lines_to_list
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* "l -" lists previous ten lines, the ones before the ten just listed.  */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"-"
argument_list|)
condition|)
block|{
if|if
condition|(
name|current_source_symtab
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"No default source file yet.  Do \"help list\"."
argument_list|)
expr_stmt|;
name|print_source_lines
argument_list|(
name|current_source_symtab
argument_list|,
name|max
argument_list|(
name|first_line_listed
operator|-
name|lines_to_list
argument_list|,
literal|1
argument_list|)
argument_list|,
name|first_line_listed
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Now if there is only one argument, decode it in SAL      and set NO_END.      If there are two arguments, decode them in SAL and SAL_END      and clear NO_END; however, if one of the arguments is blank,      set DUMMY_BEG or DUMMY_END to record that fact.  */
name|arg1
operator|=
name|arg
expr_stmt|;
if|if
condition|(
operator|*
name|arg1
operator|==
literal|','
condition|)
name|dummy_beg
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|sals
operator|=
name|decode_line_1
argument_list|(
operator|&
name|arg1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sals
operator|.
name|nelts
condition|)
return|return;
comment|/*  C++  */
if|if
condition|(
name|sals
operator|.
name|nelts
operator|>
literal|1
condition|)
block|{
name|ambiguous_line_spec
argument_list|(
operator|&
name|sals
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sals
operator|.
name|sals
argument_list|)
expr_stmt|;
return|return;
block|}
name|sal
operator|=
name|sals
operator|.
name|sals
index|[
literal|0
index|]
expr_stmt|;
name|free
argument_list|(
name|sals
operator|.
name|sals
argument_list|)
expr_stmt|;
block|}
comment|/* Record whether the BEG arg is all digits.  */
for|for
control|(
name|p
operator|=
name|arg
init|;
name|p
operator|!=
name|arg1
operator|&&
operator|*
name|p
operator|>=
literal|'0'
operator|&&
operator|*
name|p
operator|<=
literal|'9'
condition|;
name|p
operator|++
control|)
empty_stmt|;
name|linenum_beg
operator|=
operator|(
name|p
operator|==
name|arg1
operator|)
expr_stmt|;
while|while
condition|(
operator|*
name|arg1
operator|==
literal|' '
operator|||
operator|*
name|arg1
operator|==
literal|'\t'
condition|)
name|arg1
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|arg1
operator|==
literal|','
condition|)
block|{
name|no_end
operator|=
literal|0
expr_stmt|;
name|arg1
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|arg1
operator|==
literal|' '
operator|||
operator|*
name|arg1
operator|==
literal|'\t'
condition|)
name|arg1
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|arg1
operator|==
literal|0
condition|)
name|dummy_end
operator|=
literal|1
expr_stmt|;
else|else
block|{
if|if
condition|(
name|dummy_beg
condition|)
name|sals_end
operator|=
name|decode_line_1
argument_list|(
operator|&
name|arg1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|sals_end
operator|=
name|decode_line_1
argument_list|(
operator|&
name|arg1
argument_list|,
literal|0
argument_list|,
name|sal
operator|.
name|symtab
argument_list|,
name|sal
operator|.
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|sals_end
operator|.
name|nelts
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|sals_end
operator|.
name|nelts
operator|>
literal|1
condition|)
block|{
name|ambiguous_line_spec
argument_list|(
operator|&
name|sals_end
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sals_end
operator|.
name|sals
argument_list|)
expr_stmt|;
return|return;
block|}
name|sal_end
operator|=
name|sals_end
operator|.
name|sals
index|[
literal|0
index|]
expr_stmt|;
name|free
argument_list|(
name|sals_end
operator|.
name|sals
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|*
name|arg1
condition|)
name|error
argument_list|(
literal|"Junk at end of line specification."
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|no_end
operator|&&
operator|!
name|dummy_beg
operator|&&
operator|!
name|dummy_end
operator|&&
name|sal
operator|.
name|symtab
operator|!=
name|sal_end
operator|.
name|symtab
condition|)
name|error
argument_list|(
literal|"Specified start and end are in different files."
argument_list|)
expr_stmt|;
if|if
condition|(
name|dummy_beg
operator|&&
name|dummy_end
condition|)
name|error
argument_list|(
literal|"Two empty args do not say what lines to list."
argument_list|)
expr_stmt|;
comment|/* if line was specified by address,      first print exactly which line, and which file.      In this case, sal.symtab == 0 means address is outside      of all known source files, not that user failed to give a filename.  */
if|if
condition|(
operator|*
name|arg
operator|==
literal|'*'
condition|)
block|{
if|if
condition|(
name|sal
operator|.
name|symtab
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"No source file for address %s."
argument_list|,
name|local_hex_string
argument_list|(
name|sal
operator|.
name|pc
argument_list|)
argument_list|)
expr_stmt|;
name|sym
operator|=
name|find_pc_function
argument_list|(
name|sal
operator|.
name|pc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"%s is in "
argument_list|,
name|local_hex_string
argument_list|(
name|sal
operator|.
name|pc
argument_list|)
argument_list|)
expr_stmt|;
name|fprint_symbol
argument_list|(
name|stdout
argument_list|,
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|" (%s:%d).\n"
argument_list|,
name|sal
operator|.
name|symtab
operator|->
name|filename
argument_list|,
name|sal
operator|.
name|line
argument_list|)
expr_stmt|;
block|}
else|else
name|printf_filtered
argument_list|(
literal|"%s is at %s:%d.\n"
argument_list|,
name|local_hex_string
argument_list|(
name|sal
operator|.
name|pc
argument_list|)
argument_list|,
name|sal
operator|.
name|symtab
operator|->
name|filename
argument_list|,
name|sal
operator|.
name|line
argument_list|)
expr_stmt|;
block|}
comment|/* If line was not specified by just a line number,      and it does not imply a symtab, it must be an undebuggable symbol      which means no source code.  */
if|if
condition|(
operator|!
name|linenum_beg
operator|&&
name|sal
operator|.
name|symtab
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"No line number known for %s."
argument_list|,
name|arg
argument_list|)
expr_stmt|;
comment|/* If this command is repeated with RET,      turn it into the no-arg variant.  */
if|if
condition|(
name|from_tty
condition|)
operator|*
name|arg
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dummy_beg
operator|&&
name|sal_end
operator|.
name|symtab
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"No default source file yet.  Do \"help list\"."
argument_list|)
expr_stmt|;
if|if
condition|(
name|dummy_beg
condition|)
name|print_source_lines
argument_list|(
name|sal_end
operator|.
name|symtab
argument_list|,
name|max
argument_list|(
name|sal_end
operator|.
name|line
operator|-
operator|(
name|lines_to_list
operator|-
literal|1
operator|)
argument_list|,
literal|1
argument_list|)
argument_list|,
name|sal_end
operator|.
name|line
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sal
operator|.
name|symtab
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"No default source file yet.  Do \"help list\"."
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|no_end
condition|)
name|print_source_lines
argument_list|(
name|sal
operator|.
name|symtab
argument_list|,
name|max
argument_list|(
name|sal
operator|.
name|line
operator|-
operator|(
name|lines_to_list
operator|/
literal|2
operator|)
argument_list|,
literal|1
argument_list|)
argument_list|,
name|sal
operator|.
name|line
operator|+
operator|(
name|lines_to_list
operator|/
literal|2
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|print_source_lines
argument_list|(
name|sal
operator|.
name|symtab
argument_list|,
name|sal
operator|.
name|line
argument_list|,
operator|(
name|dummy_end
condition|?
name|sal
operator|.
name|line
operator|+
name|lines_to_list
else|:
name|sal_end
operator|.
name|line
operator|+
literal|1
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print info on range of pc's in a specified line.  */
end_comment

begin_function
specifier|static
name|void
name|line_info
parameter_list|(
name|arg
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|struct
name|symtabs_and_lines
name|sals
decl_stmt|;
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
name|CORE_ADDR
name|start_pc
decl_stmt|,
name|end_pc
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|arg
operator|==
literal|0
condition|)
block|{
name|sal
operator|.
name|symtab
operator|=
name|current_source_symtab
expr_stmt|;
name|sal
operator|.
name|line
operator|=
name|last_line_listed
expr_stmt|;
name|sals
operator|.
name|nelts
operator|=
literal|1
expr_stmt|;
name|sals
operator|.
name|sals
operator|=
operator|(
expr|struct
name|symtab_and_line
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|symtab_and_line
argument_list|)
argument_list|)
expr_stmt|;
name|sals
operator|.
name|sals
index|[
literal|0
index|]
operator|=
name|sal
expr_stmt|;
block|}
else|else
block|{
name|sals
operator|=
name|decode_line_spec_1
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If this command is repeated with RET, 	 turn it into the no-arg variant.  */
if|if
condition|(
name|from_tty
condition|)
operator|*
name|arg
operator|=
literal|0
expr_stmt|;
block|}
comment|/* C++  More than one line may have been specified, as when the user      specifies an overloaded function name. Print info on them all. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sals
operator|.
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|sal
operator|=
name|sals
operator|.
name|sals
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|sal
operator|.
name|symtab
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"No source file specified."
argument_list|)
expr_stmt|;
if|if
condition|(
name|sal
operator|.
name|line
operator|>
literal|0
operator|&&
name|find_line_pc_range
argument_list|(
name|sal
operator|.
name|symtab
argument_list|,
name|sal
operator|.
name|line
argument_list|,
operator|&
name|start_pc
argument_list|,
operator|&
name|end_pc
argument_list|)
condition|)
block|{
if|if
condition|(
name|start_pc
operator|==
name|end_pc
condition|)
name|printf_filtered
argument_list|(
literal|"Line %d of \"%s\" is at pc %s but contains no code.\n"
argument_list|,
name|sal
operator|.
name|line
argument_list|,
name|sal
operator|.
name|symtab
operator|->
name|filename
argument_list|,
name|local_hex_string
argument_list|(
name|start_pc
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|printf_filtered
argument_list|(
literal|"Line %d of \"%s\" starts at pc %s"
argument_list|,
name|sal
operator|.
name|line
argument_list|,
name|sal
operator|.
name|symtab
operator|->
name|filename
argument_list|,
name|local_hex_string
argument_list|(
name|start_pc
argument_list|)
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|" and ends at %s.\n"
argument_list|,
name|local_hex_string
argument_list|(
name|end_pc
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* x/i should display this line's code.  */
name|set_next_address
argument_list|(
name|start_pc
argument_list|)
expr_stmt|;
comment|/* Repeating "info line" should do the following line.  */
name|last_line_listed
operator|=
name|sal
operator|.
name|line
operator|+
literal|1
expr_stmt|;
block|}
else|else
name|printf_filtered
argument_list|(
literal|"Line number %d is out of range for \"%s\".\n"
argument_list|,
name|sal
operator|.
name|line
argument_list|,
name|sal
operator|.
name|symtab
operator|->
name|filename
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Commands to search the source file for a regexp.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|forward_search_command
parameter_list|(
name|regex
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|regex
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|int
name|desc
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|stream
decl_stmt|;
name|int
name|line
init|=
name|last_line_listed
operator|+
literal|1
decl_stmt|;
name|char
modifier|*
name|msg
decl_stmt|;
name|msg
operator|=
operator|(
name|char
operator|*
operator|)
name|re_comp
argument_list|(
name|regex
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
condition|)
name|error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_source_symtab
operator|==
literal|0
condition|)
name|select_source_symtab
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Search from last_line_listed+1 in current_source_symtab */
name|desc
operator|=
name|open_source_file
argument_list|(
name|current_source_symtab
argument_list|)
expr_stmt|;
if|if
condition|(
name|desc
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
name|current_source_symtab
operator|->
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_source_symtab
operator|->
name|line_charpos
operator|==
literal|0
condition|)
name|find_source_lines
argument_list|(
name|current_source_symtab
argument_list|,
name|desc
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
operator|<
literal|1
operator|||
name|line
operator|>
name|current_source_symtab
operator|->
name|nlines
condition|)
block|{
name|close
argument_list|(
name|desc
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"Expression not found"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lseek
argument_list|(
name|desc
argument_list|,
name|current_source_symtab
operator|->
name|line_charpos
index|[
name|line
operator|-
literal|1
index|]
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|close
argument_list|(
name|desc
argument_list|)
expr_stmt|;
name|perror_with_name
argument_list|(
name|current_source_symtab
operator|->
name|filename
argument_list|)
expr_stmt|;
block|}
name|stream
operator|=
name|fdopen
argument_list|(
name|desc
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|clearerr
argument_list|(
name|stream
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
comment|/* FIXME!!!  We walk right off the end of buf if we get a long line!!! */
name|char
name|buf
index|[
literal|4096
index|]
decl_stmt|;
comment|/* Should be reasonable??? */
specifier|register
name|char
modifier|*
name|p
init|=
name|buf
decl_stmt|;
name|c
operator|=
name|getc
argument_list|(
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
break|break;
do|do
block|{
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
block|}
do|while
condition|(
name|c
operator|!=
literal|'\n'
operator|&&
operator|(
name|c
operator|=
name|getc
argument_list|(
name|stream
argument_list|)
operator|)
operator|>=
literal|0
condition|)
do|;
comment|/* we now have a source line in buf, null terminate and match */
operator|*
name|p
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|re_exec
argument_list|(
name|buf
argument_list|)
operator|>
literal|0
condition|)
block|{
comment|/* Match! */
name|fclose
argument_list|(
name|stream
argument_list|)
expr_stmt|;
name|print_source_lines
argument_list|(
name|current_source_symtab
argument_list|,
name|line
argument_list|,
name|line
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|current_source_line
operator|=
name|max
argument_list|(
name|line
operator|-
name|lines_to_list
operator|/
literal|2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
name|line
operator|++
expr_stmt|;
block|}
name|printf_filtered
argument_list|(
literal|"Expression not found\n"
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|stream
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|reverse_search_command
parameter_list|(
name|regex
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|regex
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|int
name|desc
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|stream
decl_stmt|;
name|int
name|line
init|=
name|last_line_listed
operator|-
literal|1
decl_stmt|;
name|char
modifier|*
name|msg
decl_stmt|;
name|msg
operator|=
operator|(
name|char
operator|*
operator|)
name|re_comp
argument_list|(
name|regex
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
condition|)
name|error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_source_symtab
operator|==
literal|0
condition|)
name|select_source_symtab
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Search from last_line_listed-1 in current_source_symtab */
name|desc
operator|=
name|open_source_file
argument_list|(
name|current_source_symtab
argument_list|)
expr_stmt|;
if|if
condition|(
name|desc
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
name|current_source_symtab
operator|->
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_source_symtab
operator|->
name|line_charpos
operator|==
literal|0
condition|)
name|find_source_lines
argument_list|(
name|current_source_symtab
argument_list|,
name|desc
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
operator|<
literal|1
operator|||
name|line
operator|>
name|current_source_symtab
operator|->
name|nlines
condition|)
block|{
name|close
argument_list|(
name|desc
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"Expression not found"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lseek
argument_list|(
name|desc
argument_list|,
name|current_source_symtab
operator|->
name|line_charpos
index|[
name|line
operator|-
literal|1
index|]
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|close
argument_list|(
name|desc
argument_list|)
expr_stmt|;
name|perror_with_name
argument_list|(
name|current_source_symtab
operator|->
name|filename
argument_list|)
expr_stmt|;
block|}
name|stream
operator|=
name|fdopen
argument_list|(
name|desc
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|clearerr
argument_list|(
name|stream
argument_list|)
expr_stmt|;
while|while
condition|(
name|line
operator|>
literal|1
condition|)
block|{
comment|/* FIXME!!!  We walk right off the end of buf if we get a long line!!! */
name|char
name|buf
index|[
literal|4096
index|]
decl_stmt|;
comment|/* Should be reasonable??? */
specifier|register
name|char
modifier|*
name|p
init|=
name|buf
decl_stmt|;
name|c
operator|=
name|getc
argument_list|(
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
break|break;
do|do
block|{
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
block|}
do|while
condition|(
name|c
operator|!=
literal|'\n'
operator|&&
operator|(
name|c
operator|=
name|getc
argument_list|(
name|stream
argument_list|)
operator|)
operator|>=
literal|0
condition|)
do|;
comment|/* We now have a source line in buf; null terminate and match.  */
operator|*
name|p
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|re_exec
argument_list|(
name|buf
argument_list|)
operator|>
literal|0
condition|)
block|{
comment|/* Match! */
name|fclose
argument_list|(
name|stream
argument_list|)
expr_stmt|;
name|print_source_lines
argument_list|(
name|current_source_symtab
argument_list|,
name|line
argument_list|,
name|line
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|current_source_line
operator|=
name|max
argument_list|(
name|line
operator|-
name|lines_to_list
operator|/
literal|2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
name|line
operator|--
expr_stmt|;
if|if
condition|(
name|fseek
argument_list|(
name|stream
argument_list|,
name|current_source_symtab
operator|->
name|line_charpos
index|[
name|line
operator|-
literal|1
index|]
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fclose
argument_list|(
name|stream
argument_list|)
expr_stmt|;
name|perror_with_name
argument_list|(
name|current_source_symtab
operator|->
name|filename
argument_list|)
expr_stmt|;
block|}
block|}
name|printf_filtered
argument_list|(
literal|"Expression not found\n"
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|stream
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|_initialize_source
parameter_list|()
block|{
name|current_source_symtab
operator|=
literal|0
expr_stmt|;
name|init_source_path
argument_list|()
expr_stmt|;
name|add_com
argument_list|(
literal|"directory"
argument_list|,
name|class_files
argument_list|,
name|directory_command
argument_list|,
literal|"Add directory DIR to beginning of search path for source files.\n\ Forget cached info on source file locations and line positions.\n\ DIR can also be $cwd for the current working directory, or $cdir for the\n\ directory in which the source file was compiled into object code.\n\ With no argument, reset the search path to $cdir:$cwd, the default."
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"directories"
argument_list|,
name|no_class
argument_list|,
name|show_directories
argument_list|,
literal|"Current search path for finding source files.\n\ $cwd in the path means the current working directory.\n\ $cdir in the path means the compilation directory of the source file."
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|add_info
argument_list|(
literal|"source"
argument_list|,
name|source_info
argument_list|,
literal|"Information about the current source file."
argument_list|)
expr_stmt|;
name|add_info
argument_list|(
literal|"line"
argument_list|,
name|line_info
argument_list|,
literal|"Core addresses of the code for a source line.\n\ Line can be specified as\n\   LINENUM, to list around that line in current file,\n\   FILE:LINENUM, to list around that line in that file,\n\   FUNCTION, to list around beginning of that function,\n\   FILE:FUNCTION, to distinguish among like-named static functions.\n\ Default is to describe the last source line that was listed.\n\n\ This sets the default address for \"x\" to the line's first instruction\n\ so that \"x/i\" suffices to start examining the machine code.\n\ The address is also stored as the value of \"$_\"."
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"forward-search"
argument_list|,
name|class_files
argument_list|,
name|forward_search_command
argument_list|,
literal|"Search for regular expression (see regex(3)) from last line listed."
argument_list|)
expr_stmt|;
name|add_com_alias
argument_list|(
literal|"search"
argument_list|,
literal|"forward-search"
argument_list|,
name|class_files
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"reverse-search"
argument_list|,
name|class_files
argument_list|,
name|reverse_search_command
argument_list|,
literal|"Search backward for regular expression (see regex(3)) from last line listed."
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"list"
argument_list|,
name|class_files
argument_list|,
name|list_command
argument_list|,
literal|"List specified function or line.\n\ With no argument, lists ten more lines after or around previous listing.\n\ \"list -\" lists the ten lines before a previous ten-line listing.\n\ One argument specifies a line, and ten lines are listed around that line.\n\ Two arguments with comma between specify starting and ending lines to list.\n\ Lines can be specified in these ways:\n\   LINENUM, to list around that line in current file,\n\   FILE:LINENUM, to list around that line in that file,\n\   FUNCTION, to list around beginning of that function,\n\   FILE:FUNCTION, to distinguish among like-named static functions.\n\   *ADDRESS, to list around the line containing that address.\n\ With two args if one is empty it stands for ten lines away from the other arg."
argument_list|)
expr_stmt|;
name|add_com_alias
argument_list|(
literal|"l"
argument_list|,
literal|"list"
argument_list|,
name|class_files
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"listsize"
argument_list|,
name|class_support
argument_list|,
name|var_uinteger
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|lines_to_list
argument_list|,
literal|"Set number of source lines gdb will list by default."
argument_list|,
operator|&
name|setlist
argument_list|)
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"setfile"
argument_list|,
name|class_files
argument_list|,
name|setfile_command
argument_list|,
literal|"Select current file, function and line for display or list.\n\ Specification can have the form:\n\   LINENUM, to select that line in current file,\n\   FILE:LINENUM, to select that line in that file,\n\   FUNCTION, to select beginning of that function,\n\   FILE:FUNCTION, to distinguish among like-named static functions.\n\   *ADDRESS, to select the line containing that address."
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"push-to-file"
argument_list|,
name|class_files
argument_list|,
name|push_to_file_command
argument_list|,
literal|"Like \"file\" command but remembers current file& line on a stack.\n\ Can later return to current file with \"pop-file\" command.\n\ Up to 32 file positions can be pushed on stack."
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"pop-file"
argument_list|,
name|class_files
argument_list|,
name|pop_file_command
argument_list|,
literal|"Pops back to file position saved by most recent \"push-to-file\".\n\ If everything has been popped from stack, command does nothing."
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

