begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1992 Regents of the University of California.  * All rights reserved.  *  * Redistribution and use in source and binary forms are permitted  * provided that the above copyright notice and this paragraph are  * duplicated in all such forms and that any documentation,  * advertising materials, and other materials related to such  * distribution and use acknowledge that the software was developed  * by the University of California, Lawrence Berkeley Laboratory,  * Berkeley, CA.  The name of the University may not be used to  * endorse or promote products derived from this software without  * specific prior written permission.  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"@(#) $Header: /usr/src/contrib/gdb-4.7.lbl/gdb/RCS/cmdparse.c,v 1.2 1993/06/03 03:01:29 mccanne Exp $ (LBL)"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"../readline/readline.h"
end_include

begin_include
include|#
directive|include
file|"../readline/history.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"expression.h"
end_include

begin_decl_stmt
specifier|extern
name|FILE
modifier|*
name|instream
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
function_decl|(
modifier|*
name|window_hook
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|char
name|nullbuf
index|[]
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|prevline
init|=
name|nullbuf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|history_expansion_p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|command_editing_p
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Save current line so we can remember it for auto-repeat.  */
end_comment

begin_function
specifier|static
name|void
name|saveline
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
specifier|register
name|int
name|len
init|=
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
literal|1
decl_stmt|;
specifier|static
name|int
name|linesize
init|=
literal|128
decl_stmt|;
if|if
condition|(
name|prevline
operator|==
name|nullbuf
condition|)
name|prevline
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|linesize
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|linesize
condition|)
block|{
name|prevline
operator|=
name|xrealloc
argument_list|(
name|prevline
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|linesize
operator|=
name|len
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|prevline
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Call this routine when you want to cancel auto-repeat.  * (i.e., the step command should auto-repeat, but break shouldn't)  */
end_comment

begin_function
name|void
name|dont_repeat
parameter_list|()
block|{
if|if
condition|(
name|instream
operator|==
name|stdin
condition|)
name|prevline
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|char
modifier|*
name|finish_command_input
parameter_list|(
name|inputline
parameter_list|,
name|repeat
parameter_list|,
name|interactive
parameter_list|)
specifier|register
name|char
modifier|*
name|inputline
decl_stmt|;
name|int
name|repeat
decl_stmt|;
name|int
name|interactive
decl_stmt|;
block|{
specifier|static
name|char
modifier|*
name|do_free
decl_stmt|;
if|if
condition|(
name|do_free
condition|)
block|{
name|free
argument_list|(
name|do_free
argument_list|)
expr_stmt|;
name|do_free
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Do history expansion if enabled. */
if|if
condition|(
name|interactive
operator|&&
name|history_expansion_p
condition|)
block|{
name|int
name|expanded
decl_stmt|;
name|expanded
operator|=
name|history_expand
argument_list|(
name|inputline
argument_list|,
operator|&
name|do_free
argument_list|)
expr_stmt|;
if|if
condition|(
name|expanded
condition|)
block|{
comment|/* Print the changes.  */
name|puts
argument_list|(
name|do_free
argument_list|)
expr_stmt|;
comment|/* An error acts like no input. */
if|if
condition|(
name|expanded
operator|<
literal|0
condition|)
block|{
operator|*
name|do_free
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|do_free
operator|)
return|;
block|}
block|}
name|inputline
operator|=
name|do_free
expr_stmt|;
block|}
comment|/* get rid of any leading whitespace */
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|inputline
argument_list|)
condition|)
operator|++
name|inputline
expr_stmt|;
comment|/* 	 * If just return was hit, return the previous line. 	 * Some commands disable auto-repeat (by calling dont_repeat()), 	 * in which case repeat is false. 	 */
if|if
condition|(
operator|*
name|inputline
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|repeat
condition|)
return|return
operator|(
name|prevline
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|interactive
condition|)
name|add_history
argument_list|(
name|inputline
argument_list|)
expr_stmt|;
comment|/* 	 * If line is a comment, clear it out.  (We allow it to be added 	 * to the history above, so that it can be later edited.) 	 */
if|if
condition|(
operator|*
name|inputline
operator|==
literal|'#'
condition|)
operator|*
name|inputline
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|repeat
condition|)
name|saveline
argument_list|(
name|inputline
argument_list|)
expr_stmt|;
return|return
operator|(
name|inputline
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|get_a_cmd_line
parameter_list|(
name|prompt
parameter_list|,
name|interactive
parameter_list|)
name|char
modifier|*
name|prompt
decl_stmt|;
name|int
name|interactive
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|extern
name|char
modifier|*
name|gdb_readline
parameter_list|()
function_decl|;
comment|/* Control-C quits instantly if typed while reading input. */
name|immediate_quit
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|STOP_SIGNAL
comment|/* XXX */
name|signal
argument_list|(
name|STOP_SIGNAL
argument_list|,
name|stop_sig
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|notdef
comment|/* 	 * Do manual flushes to get around some System V brokeness 	 * (stdio should be line buffered). 	 */
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|interactive
operator|&&
name|command_editing_p
condition|)
block|{
specifier|extern
name|int
function_decl|(
modifier|*
name|rl_event_hook
function_decl|)
parameter_list|()
function_decl|;
name|rl_event_hook
operator|=
name|window_hook
expr_stmt|;
name|cp
operator|=
name|readline
argument_list|(
name|prompt
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|window_hook
operator|&&
name|interactive
condition|)
block|{
name|print_prompt
argument_list|()
expr_stmt|;
call|(
modifier|*
name|window_hook
call|)
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|interactive
condition|)
name|prompt
operator|=
name|NULL
expr_stmt|;
name|cp
operator|=
name|gdb_readline
argument_list|(
name|prompt
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cp
operator|==
operator|(
name|char
operator|*
operator|)
name|EOF
condition|)
name|cp
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|STOP_SIGNAL
name|signal
argument_list|(
name|SIGTSTP
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|--
name|immediate_quit
expr_stmt|;
return|return
operator|(
name|cp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Read a command line.  */
end_comment

begin_function
name|char
modifier|*
name|command_line_input
parameter_list|(
name|prompt
parameter_list|,
name|repeat
parameter_list|)
name|char
modifier|*
name|prompt
decl_stmt|;
name|int
name|repeat
decl_stmt|;
block|{
specifier|static
name|char
modifier|*
name|do_free
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|interactive
init|=
operator|(
name|instream
operator|==
name|stdin
operator|&&
name|ISATTY
argument_list|(
name|instream
argument_list|)
operator|)
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|do_free
condition|)
block|{
name|free
argument_list|(
name|do_free
argument_list|)
expr_stmt|;
name|do_free
operator|=
literal|0
expr_stmt|;
block|}
name|cp
operator|=
name|get_a_cmd_line
argument_list|(
name|prompt
argument_list|,
name|interactive
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
literal|0
condition|)
return|return
operator|(
name|cp
operator|)
return|;
comment|/* 	 * handle continued lines (this loop is not particularly 	 * efficient because it's rare). 	 */
while|while
condition|(
name|cp
operator|&&
name|cp
index|[
name|i
operator|=
name|strlen
argument_list|(
name|cp
argument_list|)
operator|-
literal|1
index|]
operator|==
literal|'\\'
condition|)
block|{
specifier|register
name|char
modifier|*
name|np
init|=
name|get_a_cmd_line
argument_list|(
name|prompt
argument_list|,
name|interactive
argument_list|)
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|;
if|if
condition|(
name|np
operator|==
name|NULL
condition|)
block|{
name|cp
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|j
operator|=
name|strlen
argument_list|(
name|np
argument_list|)
expr_stmt|;
name|cp
operator|=
name|xrealloc
argument_list|(
name|cp
argument_list|,
name|i
operator|+
name|j
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|cp
operator|+
name|i
argument_list|,
name|np
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|np
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cp
operator|==
literal|0
condition|)
return|return
operator|(
name|cp
operator|)
return|;
name|do_free
operator|=
name|cp
expr_stmt|;
return|return
operator|(
name|finish_command_input
argument_list|(
name|cp
argument_list|,
name|repeat
argument_list|,
name|interactive
argument_list|)
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|MAX_USER_ARGS
value|32
end_define

begin_struct
specifier|static
struct|struct
name|user_args
block|{
struct|struct
block|{
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|len
decl_stmt|;
block|}
name|a
index|[
literal|10
index|]
struct|;
block|}
name|uargs
index|[
name|MAX_USER_ARGS
index|]
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|user_args
modifier|*
name|user_arg
init|=
name|uargs
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|arg_cleanup
parameter_list|(
name|ap
parameter_list|)
name|struct
name|user_args
modifier|*
name|ap
decl_stmt|;
block|{
name|user_arg
operator|=
name|ap
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Bind arguments $arg0, $arg1, ..., for a user defined command. */
end_comment

begin_function
name|struct
name|cleanup
modifier|*
name|setup_user_args
parameter_list|(
name|p
parameter_list|)
name|char
modifier|*
name|p
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
init|=
name|make_cleanup
argument_list|(
name|arg_cleanup
argument_list|,
name|user_arg
argument_list|)
decl_stmt|;
if|if
condition|(
operator|++
name|user_arg
operator|>=
operator|&
name|uargs
index|[
name|MAX_USER_ARGS
index|]
condition|)
name|error
argument_list|(
literal|"user defined functions nested too deeply\n"
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|user_arg
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|user_arg
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
block|{
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
operator|++
name|p
expr_stmt|;
name|user_arg
operator|->
name|a
index|[
name|i
index|]
operator|.
name|arg
operator|=
name|p
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|&&
operator|!
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
operator|++
name|p
expr_stmt|;
name|user_arg
operator|->
name|a
index|[
name|i
index|]
operator|.
name|len
operator|=
name|p
operator|-
name|user_arg
operator|->
name|a
index|[
name|i
index|]
operator|.
name|arg
expr_stmt|;
operator|++
name|i
expr_stmt|;
block|}
return|return
operator|(
name|old_chain
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|findarg
parameter_list|(
name|str
parameter_list|)
specifier|register
name|char
modifier|*
name|str
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|cp
init|=
name|str
decl_stmt|;
specifier|extern
name|char
modifier|*
name|index
parameter_list|()
function_decl|;
while|while
condition|(
name|cp
operator|=
name|index
argument_list|(
name|cp
argument_list|,
literal|'$'
argument_list|)
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|cp
argument_list|,
literal|"$arg"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
operator|&&
name|isdigit
argument_list|(
name|cp
index|[
literal|4
index|]
argument_list|)
condition|)
return|return
operator|(
name|cp
operator|)
return|;
operator|++
name|cp
expr_stmt|;
block|}
return|return
operator|(
name|char
operator|*
operator|)
literal|0
return|;
block|}
end_function

begin_comment
comment|/* expand arguments from "line" into "new" */
end_comment

begin_function
specifier|static
name|void
name|expand_args
parameter_list|(
name|line
parameter_list|,
name|new
parameter_list|)
specifier|register
name|char
modifier|*
name|line
decl_stmt|,
decl|*
name|new
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
while|while
condition|(
name|cp
operator|=
name|findarg
argument_list|(
name|line
argument_list|)
condition|)
block|{
name|int
name|i
decl_stmt|,
name|len
decl_stmt|;
name|bcopy
argument_list|(
name|line
argument_list|,
name|new
argument_list|,
name|cp
operator|-
name|line
argument_list|)
expr_stmt|;
name|new
operator|+=
name|cp
operator|-
name|line
expr_stmt|;
name|i
operator|=
name|cp
index|[
literal|4
index|]
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|len
operator|=
name|user_arg
operator|->
name|a
index|[
name|i
index|]
operator|.
name|len
condition|)
block|{
name|bcopy
argument_list|(
name|user_arg
operator|->
name|a
index|[
name|i
index|]
operator|.
name|arg
argument_list|,
name|new
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|new
operator|+=
name|len
expr_stmt|;
block|}
name|line
operator|=
name|cp
operator|+
literal|5
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|new
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* expand any arguments in "line" then execute the result */
end_comment

begin_function
specifier|static
name|void
name|expand_and_execute
parameter_list|(
name|line
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|line
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|void
name|execute_command
parameter_list|()
function_decl|;
name|char
name|new
index|[
literal|1024
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|findarg
argument_list|(
name|line
argument_list|)
condition|)
block|{
name|execute_command
argument_list|(
name|line
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
return|return;
block|}
name|expand_args
argument_list|(
name|line
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|execute_command
argument_list|(
name|new
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|char
modifier|*
name|read_one_command_line
parameter_list|(
name|prompt
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|prompt
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|p1
decl_stmt|;
name|dont_repeat
argument_list|()
expr_stmt|;
name|p
operator|=
name|command_line_input
argument_list|(
name|prompt
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
comment|/* Remove trailing blanks.  */
name|p1
operator|=
name|p
operator|+
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|p1
operator|>
name|p
operator|&&
operator|(
operator|*
name|p1
operator|==
literal|' '
operator|||
operator|*
name|p1
operator|==
literal|'\t'
operator|)
condition|)
empty_stmt|;
name|p1
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|char
name|cmd_prompt
index|[]
init|=
literal|"> "
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|parse_control_structure
parameter_list|(
name|rootcmd
parameter_list|,
name|from_tty
parameter_list|,
name|level
parameter_list|)
name|struct
name|command_line
modifier|*
name|rootcmd
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|struct
name|command_line
modifier|*
name|cmd
decl_stmt|;
name|char
modifier|*
name|prompt
decl_stmt|;
operator|++
name|level
expr_stmt|;
name|prompt
operator|=
name|from_tty
condition|?
operator|&
name|cmd_prompt
index|[
sizeof|sizeof
argument_list|(
name|cmd_prompt
argument_list|)
operator|-
literal|1
operator|-
literal|2
operator|*
name|level
index|]
else|:
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
name|cmd
operator|=
operator|(
expr|struct
name|command_line
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|cmd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
name|rootcmd
operator|->
name|body
operator|=
name|cmd
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|char
modifier|*
name|p
init|=
name|read_one_command_line
argument_list|(
name|prompt
argument_list|,
name|from_tty
argument_list|)
decl_stmt|;
name|p
operator|=
name|strsave
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|cmd
operator|->
name|line
operator|=
name|p
expr_stmt|;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"while "
argument_list|,
literal|6
argument_list|)
condition|)
block|{
name|cmd
operator|->
name|type
operator|=
name|CL_WHILE
expr_stmt|;
if|if
condition|(
name|parse_control_structure
argument_list|(
name|cmd
argument_list|,
name|from_tty
argument_list|,
name|level
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"if "
argument_list|,
literal|3
argument_list|)
condition|)
block|{
name|cmd
operator|->
name|type
operator|=
name|CL_IF
expr_stmt|;
if|if
condition|(
name|parse_control_structure
argument_list|(
name|cmd
argument_list|,
name|from_tty
argument_list|,
name|level
argument_list|)
condition|)
block|{
name|struct
name|command_line
modifier|*
name|tmp
decl_stmt|;
name|int
name|stat
decl_stmt|;
name|cmd
operator|->
name|elsebody
operator|=
name|cmd
operator|->
name|body
expr_stmt|;
name|stat
operator|=
name|parse_control_structure
argument_list|(
name|cmd
argument_list|,
name|from_tty
argument_list|,
name|level
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|cmd
operator|->
name|elsebody
expr_stmt|;
name|cmd
operator|->
name|elsebody
operator|=
name|cmd
operator|->
name|body
expr_stmt|;
name|cmd
operator|->
name|body
operator|=
name|tmp
expr_stmt|;
if|if
condition|(
name|stat
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"else"
argument_list|)
condition|)
block|{
name|cmd
operator|->
name|type
operator|=
name|CL_END
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"end"
argument_list|)
condition|)
block|{
name|cmd
operator|->
name|type
operator|=
name|CL_END
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"exitloop"
argument_list|)
condition|)
block|{
name|cmd
operator|->
name|type
operator|=
name|CL_EXITLOOP
expr_stmt|;
block|}
else|else
block|{
name|cmd
operator|->
name|type
operator|=
name|CL_NORMAL
expr_stmt|;
block|}
name|cmd
operator|->
name|next
operator|=
operator|(
expr|struct
name|command_line
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
name|cmd
operator|=
name|cmd
operator|->
name|next
expr_stmt|;
name|bzero
argument_list|(
name|cmd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* NOTREACHED */
block|}
end_function

begin_function
name|int
name|execute_control_structure
parameter_list|(
name|cmd
parameter_list|)
specifier|register
name|struct
name|command_line
modifier|*
name|cmd
decl_stmt|;
block|{
name|char
name|expn
index|[
literal|1024
index|]
decl_stmt|;
name|struct
name|expression
modifier|*
name|cond
decl_stmt|;
name|int
name|stat
decl_stmt|;
while|while
condition|(
name|cmd
condition|)
block|{
name|QUIT
expr_stmt|;
switch|switch
condition|(
name|cmd
operator|->
name|type
condition|)
block|{
case|case
name|CL_END
case|:
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|CL_NORMAL
case|:
name|expand_and_execute
argument_list|(
name|cmd
operator|->
name|line
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|CL_WHILE
case|:
name|expand_args
argument_list|(
name|cmd
operator|->
name|line
operator|+
literal|6
argument_list|,
name|expn
argument_list|)
expr_stmt|;
name|cond
operator|=
name|parse_expression
argument_list|(
name|expn
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|value_zerop
argument_list|(
name|evaluate_expression
argument_list|(
name|cond
argument_list|)
argument_list|)
condition|)
if|if
condition|(
name|execute_control_structure
argument_list|(
name|cmd
operator|->
name|body
argument_list|)
condition|)
break|break;
name|free
argument_list|(
name|cond
argument_list|)
expr_stmt|;
break|break;
case|case
name|CL_IF
case|:
name|expand_args
argument_list|(
name|cmd
operator|->
name|line
operator|+
literal|3
argument_list|,
name|expn
argument_list|)
expr_stmt|;
name|cond
operator|=
name|parse_expression
argument_list|(
name|expn
argument_list|)
expr_stmt|;
name|stat
operator|=
name|value_zerop
argument_list|(
name|evaluate_expression
argument_list|(
name|cond
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cond
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|execute_control_structure
argument_list|(
name|cmd
operator|->
name|body
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|cmd
operator|->
name|elsebody
condition|)
block|{
if|if
condition|(
name|execute_control_structure
argument_list|(
name|cmd
operator|->
name|elsebody
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
break|break;
case|case
name|CL_EXITLOOP
case|:
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|cmd
operator|=
name|cmd
operator|->
name|next
expr_stmt|;
block|}
name|free_all_values
argument_list|()
expr_stmt|;
block|}
end_function

begin_macro
name|execute_command_lines
argument_list|(
argument|cmd
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|command_line
modifier|*
name|cmd
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|extern
name|void
name|source_cleanup
parameter_list|()
function_decl|;
name|struct
name|cleanup
modifier|*
name|old_chain
init|=
name|make_cleanup
argument_list|(
name|source_cleanup
argument_list|,
name|instream
argument_list|)
decl_stmt|;
comment|/* 	 * Set the instream to 0, indicating execution of a user-defined 	 * function.   	 */
operator|++
name|immediate_quit
expr_stmt|;
name|instream
operator|=
operator|(
name|FILE
operator|*
operator|)
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|execute_control_structure
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
operator|--
name|immediate_quit
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* do following command lines if expression true */
end_comment

begin_macro
name|if_command
argument_list|(
argument|p
argument_list|,
argument|from_tty
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|from_tty
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|struct
name|command_line
modifier|*
name|cmd
init|=
operator|(
expr|struct
name|command_line
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|cmd
argument_list|)
argument_list|)
decl_stmt|;
name|char
name|buf
index|[
literal|128
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"if %s"
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|cmd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
name|old_chain
operator|=
name|make_cleanup
argument_list|(
name|free_command_lines
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|cmd
operator|->
name|type
operator|=
name|CL_IF
expr_stmt|;
name|cmd
operator|->
name|line
operator|=
name|strsave
argument_list|(
name|buf
argument_list|)
expr_stmt|;
comment|/* XXX cmd->line? */
if|if
condition|(
name|parse_control_structure
argument_list|(
name|cmd
argument_list|,
name|from_tty
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|struct
name|command_line
modifier|*
name|tmp
decl_stmt|;
name|cmd
operator|->
name|elsebody
operator|=
name|cmd
operator|->
name|body
expr_stmt|;
operator|(
name|void
operator|)
name|parse_control_structure
argument_list|(
name|cmd
argument_list|,
name|from_tty
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|cmd
operator|->
name|elsebody
expr_stmt|;
name|cmd
operator|->
name|elsebody
operator|=
name|cmd
operator|->
name|body
expr_stmt|;
name|cmd
operator|->
name|body
operator|=
name|tmp
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|execute_command_lines
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* do following command lines while expression true */
end_comment

begin_macro
name|while_command
argument_list|(
argument|p
argument_list|,
argument|from_tty
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|from_tty
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|struct
name|command_line
modifier|*
name|cmd
init|=
operator|(
expr|struct
name|command_line
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|cmd
argument_list|)
argument_list|)
decl_stmt|;
name|char
name|buf
index|[
literal|128
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"while %s"
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|cmd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
name|old_chain
operator|=
name|make_cleanup
argument_list|(
name|free_command_lines
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|cmd
operator|->
name|type
operator|=
name|CL_WHILE
expr_stmt|;
name|cmd
operator|->
name|line
operator|=
name|strsave
argument_list|(
name|buf
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|parse_control_structure
argument_list|(
name|cmd
argument_list|,
name|from_tty
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|execute_command_lines
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Read lines from the input stream and accumulate them in a chain of struct  * command_line's which is then returned.    */
end_comment

begin_function
name|struct
name|command_line
modifier|*
name|read_command_lines
parameter_list|(
name|from_tty
parameter_list|)
name|int
name|from_tty
decl_stmt|;
block|{
specifier|register
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
specifier|register
name|struct
name|command_line
modifier|*
name|cmd
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|cmd
operator|=
operator|(
expr|struct
name|command_line
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cmd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
name|old_chain
operator|=
name|make_cleanup
argument_list|(
name|free_command_lines
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|cmd
operator|->
name|type
operator|=
name|CL_NOP
expr_stmt|;
operator|(
name|void
operator|)
name|parse_control_structure
argument_list|(
name|cmd
argument_list|,
name|from_tty
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dont_repeat
argument_list|()
expr_stmt|;
name|p
operator|=
name|cmd
operator|->
name|body
expr_stmt|;
name|discard_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cmd
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Free a chain of struct command_line's.  */
end_comment

begin_function
name|void
name|free_command_lines
parameter_list|(
name|cmds
parameter_list|)
name|struct
name|command_line
modifier|*
name|cmds
decl_stmt|;
block|{
name|struct
name|command_line
modifier|*
name|next
decl_stmt|;
while|while
condition|(
name|cmds
condition|)
block|{
if|if
condition|(
name|cmds
operator|->
name|body
condition|)
name|free
argument_list|(
name|cmds
operator|->
name|body
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmds
operator|->
name|elsebody
condition|)
name|free
argument_list|(
name|cmds
operator|->
name|elsebody
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmds
operator|->
name|line
condition|)
name|free
argument_list|(
name|cmds
operator|->
name|line
argument_list|)
expr_stmt|;
name|next
operator|=
name|cmds
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|cmds
argument_list|)
expr_stmt|;
name|cmds
operator|=
name|next
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|_initialize_cmdparse
parameter_list|()
block|{
name|command_editing_p
operator|=
literal|1
expr_stmt|;
name|history_expansion_p
operator|=
literal|0
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"expansion"
argument_list|,
name|no_class
argument_list|,
name|var_boolean
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|history_expansion_p
argument_list|,
literal|"Set history expansion on command input.\n\ Without an argument, history expansion is enabled."
argument_list|,
operator|&
name|sethistlist
argument_list|)
argument_list|,
operator|&
name|showhistlist
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"editing"
argument_list|,
name|class_support
argument_list|,
name|var_boolean
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|command_editing_p
argument_list|,
literal|"Set editing of command lines as they are typed.\n\ Use \"on\" to enable to enable the editing, and \"off\" to disable it.\n\ Without an argument, command line editing is enabled.  To edit, use\n\ EMACS-like or VI-like commands like control-P or ESC."
argument_list|,
operator|&
name|setlist
argument_list|)
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

