begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* HP/UX interface for HP 300's, for GDB when running under Unix.    Copyright (C) 1986, 1987, 1989, 1991 Free Software Foundation, Inc.     This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_comment
comment|/* Defining this means some system include files define some extra stuff.  */
end_comment

begin_define
define|#
directive|define
name|WOPR
end_define

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/dir.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<sys/user.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/ptrace.h>
end_include

begin_include
include|#
directive|include
file|<sys/reg.h>
end_include

begin_include
include|#
directive|include
file|<sys/trap.h>
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_define
define|#
directive|define
name|INFERIOR_AR0
parameter_list|(
name|u
parameter_list|)
define|\
value|((ptrace								\     (PT_RUAREA, inferior_pid,						\      (PTRACE_ARG3_TYPE) ((char *)&u.u_ar0 - (char *)&u), 0))		\    - KERNEL_U_ADDR)
end_define

begin_function
specifier|static
name|void
name|fetch_inferior_register
parameter_list|(
name|regno
parameter_list|,
name|regaddr
parameter_list|)
specifier|register
name|int
name|regno
decl_stmt|;
specifier|register
name|unsigned
name|int
name|regaddr
decl_stmt|;
block|{
ifndef|#
directive|ifndef
name|HPUX_VERSION_5
if|if
condition|(
name|regno
operator|==
name|PS_REGNUM
condition|)
block|{
union|union
block|{
name|int
name|i
decl_stmt|;
name|short
name|s
index|[
literal|2
index|]
decl_stmt|;
block|}
name|ps_val
union|;
name|int
name|regval
decl_stmt|;
name|ps_val
operator|.
name|i
operator|=
operator|(
name|ptrace
argument_list|(
name|PT_RUAREA
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
name|regaddr
argument_list|,
literal|0
argument_list|)
operator|)
expr_stmt|;
name|regval
operator|=
name|ps_val
operator|.
name|s
index|[
literal|0
index|]
expr_stmt|;
name|supply_register
argument_list|(
name|regno
argument_list|,
operator|&
name|regval
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
comment|/* not HPUX_VERSION_5 */
block|{
name|char
name|buf
index|[
name|MAX_REGISTER_RAW_SIZE
index|]
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|REGISTER_RAW_SIZE
argument_list|(
name|regno
argument_list|)
condition|;
name|i
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
control|)
block|{
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|buf
index|[
name|i
index|]
operator|=
name|ptrace
argument_list|(
name|PT_RUAREA
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
name|regaddr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|regaddr
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
block|}
name|supply_register
argument_list|(
name|regno
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|store_inferior_register_1
parameter_list|(
name|regno
parameter_list|,
name|regaddr
parameter_list|,
name|value
parameter_list|)
name|int
name|regno
decl_stmt|;
name|unsigned
name|int
name|regaddr
decl_stmt|;
name|int
name|value
decl_stmt|;
block|{
name|errno
operator|=
literal|0
expr_stmt|;
name|ptrace
argument_list|(
name|PT_WUAREA
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
name|regaddr
argument_list|,
name|value
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* HP-UX randomly sets errno to non-zero for regno == 25.      However, the value is correctly written, so ignore errno. */
block|if (errno != 0)     {       char string_buf[64];              sprintf (string_buf, "writing register number %d", regno);       perror_with_name (string_buf);     }
endif|#
directive|endif
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|store_inferior_register
parameter_list|(
name|regno
parameter_list|,
name|regaddr
parameter_list|)
specifier|register
name|int
name|regno
decl_stmt|;
specifier|register
name|unsigned
name|int
name|regaddr
decl_stmt|;
block|{
ifndef|#
directive|ifndef
name|HPUX_VERSION_5
if|if
condition|(
name|regno
operator|==
name|PS_REGNUM
condition|)
block|{
union|union
block|{
name|int
name|i
decl_stmt|;
name|short
name|s
index|[
literal|2
index|]
decl_stmt|;
block|}
name|ps_val
union|;
name|ps_val
operator|.
name|i
operator|=
operator|(
name|ptrace
argument_list|(
name|PT_RUAREA
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
name|regaddr
argument_list|,
literal|0
argument_list|)
operator|)
expr_stmt|;
name|ps_val
operator|.
name|s
index|[
literal|0
index|]
operator|=
operator|(
name|read_register
argument_list|(
name|regno
argument_list|)
operator|)
expr_stmt|;
name|store_inferior_register_1
argument_list|(
name|regno
argument_list|,
name|regaddr
argument_list|,
name|ps_val
operator|.
name|i
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
comment|/* not HPUX_VERSION_5 */
block|{
name|char
name|buf
index|[
name|MAX_REGISTER_RAW_SIZE
index|]
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|extern
name|char
name|registers
index|[]
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|REGISTER_RAW_SIZE
argument_list|(
name|regno
argument_list|)
condition|;
name|i
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
control|)
block|{
name|store_inferior_register_1
argument_list|(
name|regno
argument_list|,
name|regaddr
argument_list|,
operator|(
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
operator|(
name|REGISTER_BYTE
argument_list|(
name|regno
argument_list|)
operator|)
operator|+
name|i
index|]
operator|)
argument_list|)
expr_stmt|;
name|regaddr
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
block|}
block|}
return|return;
block|}
end_function

begin_function
name|void
name|fetch_inferior_registers
parameter_list|(
name|regno
parameter_list|)
name|int
name|regno
decl_stmt|;
block|{
name|struct
name|user
name|u
decl_stmt|;
specifier|register
name|unsigned
name|int
name|ar0_offset
decl_stmt|;
name|ar0_offset
operator|=
operator|(
name|INFERIOR_AR0
argument_list|(
name|u
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|regno
operator|==
operator|-
literal|1
condition|)
block|{
for|for
control|(
name|regno
operator|=
literal|0
init|;
operator|(
name|regno
operator|<
name|FP0_REGNUM
operator|)
condition|;
name|regno
operator|++
control|)
name|fetch_inferior_register
argument_list|(
name|regno
argument_list|,
operator|(
name|REGISTER_ADDR
argument_list|(
name|ar0_offset
argument_list|,
name|regno
argument_list|)
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
init|;
operator|(
name|regno
operator|<
name|NUM_REGS
operator|)
condition|;
name|regno
operator|++
control|)
name|fetch_inferior_register
argument_list|(
name|regno
argument_list|,
operator|(
name|FP_REGISTER_ADDR
argument_list|(
name|u
argument_list|,
name|regno
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
name|fetch_inferior_register
argument_list|(
name|regno
argument_list|,
operator|(
name|regno
operator|<
name|FP0_REGNUM
condition|?
name|REGISTER_ADDR
argument_list|(
name|ar0_offset
argument_list|,
name|regno
argument_list|)
else|:
name|FP_REGISTER_ADDR
argument_list|(
name|u
argument_list|,
name|regno
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Store our register values back into the inferior.    If REGNO is -1, do this for all registers.    Otherwise, REGNO specifies which register (so we can save time).  */
end_comment

begin_function
name|void
name|store_inferior_registers
parameter_list|(
name|regno
parameter_list|)
specifier|register
name|int
name|regno
decl_stmt|;
block|{
name|struct
name|user
name|u
decl_stmt|;
specifier|register
name|unsigned
name|int
name|ar0_offset
decl_stmt|;
specifier|extern
name|char
name|registers
index|[]
decl_stmt|;
if|if
condition|(
name|regno
operator|>=
name|FP0_REGNUM
condition|)
block|{
name|store_inferior_register
argument_list|(
name|regno
argument_list|,
operator|(
name|FP_REGISTER_ADDR
argument_list|(
name|u
argument_list|,
name|regno
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|ar0_offset
operator|=
operator|(
name|INFERIOR_AR0
argument_list|(
name|u
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|regno
operator|>=
literal|0
condition|)
block|{
name|store_inferior_register
argument_list|(
name|regno
argument_list|,
operator|(
name|REGISTER_ADDR
argument_list|(
name|ar0_offset
argument_list|,
name|regno
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|regno
operator|=
literal|0
init|;
operator|(
name|regno
operator|<
name|FP0_REGNUM
operator|)
condition|;
name|regno
operator|++
control|)
name|store_inferior_register
argument_list|(
name|regno
argument_list|,
operator|(
name|REGISTER_ADDR
argument_list|(
name|ar0_offset
argument_list|,
name|regno
argument_list|)
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
init|;
operator|(
name|regno
operator|<
name|NUM_REGS
operator|)
condition|;
name|regno
operator|++
control|)
name|store_inferior_register
argument_list|(
name|regno
argument_list|,
operator|(
name|FP_REGISTER_ADDR
argument_list|(
name|u
argument_list|,
name|regno
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Take the register values out of a core file and store    them where `read_register' will find them.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HPUX_VERSION_5
end_ifdef

begin_define
define|#
directive|define
name|e_PS
value|e_regs[PS]
end_define

begin_define
define|#
directive|define
name|e_PC
value|e_regs[PC]
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HPUX_VERSION_5 */
end_comment

begin_function
name|void
name|fetch_core_registers
parameter_list|(
name|core_reg_sect
parameter_list|,
name|core_reg_size
parameter_list|,
name|which
parameter_list|,
name|reg_addr
parameter_list|)
name|char
modifier|*
name|core_reg_sect
decl_stmt|;
name|int
name|core_reg_size
decl_stmt|;
name|int
name|which
decl_stmt|;
name|unsigned
name|int
name|reg_addr
decl_stmt|;
comment|/* Unused in this version */
block|{
name|int
name|val
decl_stmt|,
name|regno
decl_stmt|;
name|struct
name|user
name|u
decl_stmt|;
name|struct
name|exception_stack
modifier|*
name|pes
init|=
operator|(
expr|struct
name|exception_stack
operator|*
operator|)
name|core_reg_sect
decl_stmt|;
define|#
directive|define
name|es
value|(*pes)
name|char
modifier|*
name|buf
decl_stmt|;
if|if
condition|(
name|which
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|core_reg_size
operator|<
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
name|es
operator|.
name|e_offset
operator|-
operator|(
name|char
operator|*
operator|)
operator|&
name|es
operator|.
name|e_regs
index|[
name|R0
index|]
operator|)
condition|)
name|error
argument_list|(
literal|"Not enough registers in core file"
argument_list|)
expr_stmt|;
for|for
control|(
name|regno
operator|=
literal|0
init|;
operator|(
name|regno
operator|<
name|PS_REGNUM
operator|)
condition|;
name|regno
operator|++
control|)
name|supply_register
argument_list|(
name|regno
argument_list|,
operator|&
name|es
operator|.
name|e_regs
index|[
name|regno
operator|+
name|R0
index|]
argument_list|)
expr_stmt|;
name|val
operator|=
name|es
operator|.
name|e_PS
expr_stmt|;
name|supply_register
argument_list|(
name|regno
operator|++
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|regno
operator|++
argument_list|,
operator|&
name|es
operator|.
name|e_PC
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|which
operator|==
literal|2
condition|)
block|{
comment|/* FIXME: This may not work if the float regs and control regs are        discontinuous.  */
for|for
control|(
name|regno
operator|=
name|FP0_REGNUM
operator|,
name|buf
operator|=
name|core_reg_sect
init|;
operator|(
name|regno
operator|<
name|NUM_REGS
operator|)
condition|;
name|buf
operator|+=
name|REGISTER_RAW_SIZE
argument_list|(
name|regno
argument_list|)
operator|,
name|regno
operator|++
control|)
block|{
name|supply_register
argument_list|(
name|regno
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

end_unit

