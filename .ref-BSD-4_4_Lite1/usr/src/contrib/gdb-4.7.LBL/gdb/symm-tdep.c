begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Sequent Symmetry target interface, for GDB when running under Unix.    Copyright (C) 1986, 1987, 1989, 1991 Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* many 387-specific items of use taken from i386-dep.c */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/user.h>
end_include

begin_include
include|#
directive|include
file|<sys/dir.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_function_decl
specifier|static
name|long
name|i386_get_frame_setup
parameter_list|()
function_decl|;
end_function_decl

begin_expr_stmt
specifier|static
name|i386_follow_jump
argument_list|()
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sgtty.h>
end_include

begin_define
define|#
directive|define
name|TERMINAL
value|struct sgttyb
end_define

begin_macro
name|exec_file_command
argument_list|(
argument|filename
argument_list|,
argument|from_tty
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|filename
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|from_tty
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|val
decl_stmt|;
comment|/* Eliminate all traces of old exec file.      Mark text segment as empty.  */
if|if
condition|(
name|execfile
condition|)
name|free
argument_list|(
name|execfile
argument_list|)
expr_stmt|;
name|execfile
operator|=
literal|0
expr_stmt|;
name|data_start
operator|=
literal|0
expr_stmt|;
name|data_end
operator|-=
name|exec_data_start
expr_stmt|;
name|text_start
operator|=
literal|0
expr_stmt|;
name|text_end
operator|=
literal|0
expr_stmt|;
name|exec_data_start
operator|=
literal|0
expr_stmt|;
name|exec_data_end
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|execchan
operator|>=
literal|0
condition|)
name|close
argument_list|(
name|execchan
argument_list|)
expr_stmt|;
name|execchan
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Now open and digest the file the user requested, if any.  */
if|if
condition|(
name|filename
condition|)
block|{
name|filename
operator|=
name|tilde_expand
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|free
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|execchan
operator|=
name|openp
argument_list|(
name|getenv
argument_list|(
literal|"PATH"
argument_list|)
argument_list|,
literal|1
argument_list|,
name|filename
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|,
operator|&
name|execfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|execchan
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
name|filename
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|COFF_FORMAT
block|{
name|int
name|aout_hdrsize
decl_stmt|;
name|int
name|num_sections
decl_stmt|;
if|if
condition|(
name|read_file_hdr
argument_list|(
name|execchan
argument_list|,
operator|&
name|file_hdr
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"\"%s\": not in executable format."
argument_list|,
name|execfile
argument_list|)
expr_stmt|;
name|aout_hdrsize
operator|=
name|file_hdr
operator|.
name|f_opthdr
expr_stmt|;
name|num_sections
operator|=
name|file_hdr
operator|.
name|f_nscns
expr_stmt|;
if|if
condition|(
name|read_aout_hdr
argument_list|(
name|execchan
argument_list|,
operator|&
name|exec_aouthdr
argument_list|,
name|aout_hdrsize
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"\"%s\": can't read optional aouthdr"
argument_list|,
name|execfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|read_section_hdr
argument_list|(
name|execchan
argument_list|,
name|_TEXT
argument_list|,
operator|&
name|text_hdr
argument_list|,
name|num_sections
argument_list|,
name|aout_hdrsize
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"\"%s\": can't read text section header"
argument_list|,
name|execfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|read_section_hdr
argument_list|(
name|execchan
argument_list|,
name|_DATA
argument_list|,
operator|&
name|data_hdr
argument_list|,
name|num_sections
argument_list|,
name|aout_hdrsize
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"\"%s\": can't read data section header"
argument_list|,
name|execfile
argument_list|)
expr_stmt|;
name|text_start
operator|=
name|exec_aouthdr
operator|.
name|text_start
expr_stmt|;
name|text_end
operator|=
name|text_start
operator|+
name|exec_aouthdr
operator|.
name|tsize
expr_stmt|;
name|text_offset
operator|=
name|text_hdr
operator|.
name|s_scnptr
expr_stmt|;
name|exec_data_start
operator|=
name|exec_aouthdr
operator|.
name|data_start
expr_stmt|;
name|exec_data_end
operator|=
name|exec_data_start
operator|+
name|exec_aouthdr
operator|.
name|dsize
expr_stmt|;
name|exec_data_offset
operator|=
name|data_hdr
operator|.
name|s_scnptr
expr_stmt|;
name|data_start
operator|=
name|exec_data_start
expr_stmt|;
name|data_end
operator|+=
name|exec_data_start
expr_stmt|;
name|exec_mtime
operator|=
name|file_hdr
operator|.
name|f_timdat
expr_stmt|;
block|}
else|#
directive|else
comment|/* not COFF_FORMAT */
block|{
name|struct
name|stat
name|st_exec
decl_stmt|;
name|val
operator|=
name|myread
argument_list|(
name|execchan
argument_list|,
operator|&
name|exec_aouthdr
argument_list|,
sizeof|sizeof
argument_list|(
name|AOUTHDR
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|text_start
operator|=
name|N_ADDRADJ
argument_list|(
name|exec_aouthdr
argument_list|)
expr_stmt|;
name|exec_data_start
operator|=
name|round
argument_list|(
name|exec_aouthdr
operator|.
name|a_text
argument_list|,
name|NBPG
operator|*
name|CLSIZE
argument_list|)
expr_stmt|;
name|text_offset
operator|=
name|N_TXTOFF
argument_list|(
name|exec_aouthdr
argument_list|)
expr_stmt|;
name|exec_data_offset
operator|=
name|N_TXTOFF
argument_list|(
name|exec_aouthdr
argument_list|)
operator|+
name|exec_aouthdr
operator|.
name|a_text
expr_stmt|;
name|text_end
operator|=
name|exec_aouthdr
operator|.
name|a_text
expr_stmt|;
name|exec_data_end
operator|=
name|exec_data_start
operator|+
name|exec_aouthdr
operator|.
name|a_data
expr_stmt|;
name|data_start
operator|=
name|exec_data_start
expr_stmt|;
name|data_end
operator|=
name|data_start
operator|+
name|exec_aouthdr
operator|.
name|a_data
expr_stmt|;
name|exec_data_offset
operator|=
name|N_TXTOFF
argument_list|(
name|exec_aouthdr
argument_list|)
expr_stmt|;
name|fstat
argument_list|(
name|execchan
argument_list|,
operator|&
name|st_exec
argument_list|)
expr_stmt|;
name|exec_mtime
operator|=
name|st_exec
operator|.
name|st_mtime
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* not COFF_FORMAT */
name|validate_files
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|from_tty
condition|)
name|printf
argument_list|(
literal|"No exec file now.\n"
argument_list|)
expr_stmt|;
comment|/* Tell display code (if any) about the changed file name.  */
if|if
condition|(
name|exec_file_display_hook
condition|)
call|(
modifier|*
name|exec_file_display_hook
call|)
argument_list|(
name|filename
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* rounds 'one' up to divide evenly by 'two' */
end_comment

begin_function
name|int
name|round
parameter_list|(
name|one
parameter_list|,
name|two
parameter_list|)
specifier|register
name|int
name|one
decl_stmt|,
name|two
decl_stmt|;
block|{
specifier|register
name|int
name|temp
decl_stmt|;
name|temp
operator|=
operator|(
name|one
operator|/
name|two
operator|)
operator|*
name|two
expr_stmt|;
if|if
condition|(
name|one
operator|!=
name|temp
condition|)
block|{
name|temp
operator|+=
name|two
expr_stmt|;
block|}
return|return
name|temp
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|codestream_next_addr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|codestream_addr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|codestream_buf
index|[
sizeof|sizeof
argument_list|(
name|int
argument_list|)
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|codestream_off
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|codestream_cnt
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|codestream_tell
parameter_list|()
value|(codestream_addr + codestream_off)
end_define

begin_define
define|#
directive|define
name|codestream_peek
parameter_list|()
value|(codestream_cnt == 0 ? \ 			   codestream_fill(1): codestream_buf[codestream_off])
end_define

begin_define
define|#
directive|define
name|codestream_get
parameter_list|()
value|(codestream_cnt-- == 0 ? \ 			 codestream_fill(0) : codestream_buf[codestream_off++])
end_define

begin_function
specifier|static
name|unsigned
name|char
name|codestream_fill
parameter_list|(
name|peek_flag
parameter_list|)
block|{
name|codestream_addr
operator|=
name|codestream_next_addr
expr_stmt|;
name|codestream_next_addr
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|codestream_off
operator|=
literal|0
expr_stmt|;
name|codestream_cnt
operator|=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|read_memory
argument_list|(
name|codestream_addr
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|codestream_buf
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|peek_flag
condition|)
return|return
operator|(
name|codestream_peek
argument_list|()
operator|)
return|;
else|else
return|return
operator|(
name|codestream_get
argument_list|()
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|codestream_seek
parameter_list|(
name|place
parameter_list|)
block|{
name|codestream_next_addr
operator|=
name|place
operator|&
operator|-
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|codestream_cnt
operator|=
literal|0
expr_stmt|;
name|codestream_fill
argument_list|(
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
name|codestream_tell
argument_list|()
operator|!=
name|place
condition|)
name|codestream_get
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|codestream_read
parameter_list|(
name|buf
parameter_list|,
name|count
parameter_list|)
name|unsigned
name|char
modifier|*
name|buf
decl_stmt|;
block|{
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|;
name|p
operator|=
name|buf
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
operator|*
name|p
operator|++
operator|=
name|codestream_get
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Following macro translates i386 opcode register numbers to Symmetry  * register numbers.  This is used by FRAME_FIND_SAVED_REGS.  *  *           %eax  %ecx  %edx  %ebx  %esp  %ebp  %esi  %edi  * i386        0     1     2     3     4     5     6     7  * Symmetry    0     2     1     5    14    15     6     7  *  */
end_comment

begin_define
define|#
directive|define
name|I386_REGNO_TO_SYMMETRY
parameter_list|(
name|n
parameter_list|)
define|\
value|((n)==0?0 :(n)==1?2 :(n)==2?1 :(n)==3?5 :(n)==4?14 :(n)==5?15 :(n))
end_define

begin_comment
comment|/* from i386-dep.c */
end_comment

begin_macro
name|i386_frame_find_saved_regs
argument_list|(
argument|fip
argument_list|,
argument|fsrp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|frame_info
modifier|*
name|fip
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|frame_saved_regs
modifier|*
name|fsrp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|unsigned
name|long
name|locals
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|unsigned
name|char
name|op
decl_stmt|;
name|CORE_ADDR
name|dummy_bottom
decl_stmt|;
name|CORE_ADDR
name|adr
decl_stmt|;
name|int
name|i
decl_stmt|;
name|bzero
argument_list|(
name|fsrp
argument_list|,
sizeof|sizeof
expr|*
name|fsrp
argument_list|)
expr_stmt|;
comment|/* if frame is the end of a dummy, compute where the    * beginning would be    */
name|dummy_bottom
operator|=
name|fip
operator|->
name|frame
operator|-
literal|4
operator|-
name|NUM_REGS
operator|*
literal|4
operator|-
name|CALL_DUMMY_LENGTH
expr_stmt|;
comment|/* check if the PC is in the stack, in a dummy frame */
if|if
condition|(
name|dummy_bottom
operator|<=
name|fip
operator|->
name|pc
operator|&&
name|fip
operator|->
name|pc
operator|<=
name|fip
operator|->
name|frame
condition|)
block|{
comment|/* all regs were saved by push_call_dummy () */
name|adr
operator|=
name|fip
operator|->
name|frame
operator|-
literal|4
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_REGS
condition|;
name|i
operator|++
control|)
block|{
name|fsrp
operator|->
name|regs
index|[
name|i
index|]
operator|=
name|adr
expr_stmt|;
name|adr
operator|-=
literal|4
expr_stmt|;
block|}
return|return;
block|}
name|locals
operator|=
name|i386_get_frame_setup
argument_list|(
name|get_pc_function_start
argument_list|(
name|fip
operator|->
name|pc
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|locals
operator|>=
literal|0
condition|)
block|{
name|adr
operator|=
name|fip
operator|->
name|frame
operator|-
literal|4
operator|-
name|locals
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
name|op
operator|=
name|codestream_get
argument_list|()
expr_stmt|;
if|if
condition|(
name|op
operator|<
literal|0x50
operator|||
name|op
operator|>
literal|0x57
condition|)
break|break;
name|fsrp
operator|->
name|regs
index|[
name|I386_REGNO_TO_SYMMETRY
argument_list|(
name|op
operator|-
literal|0x50
argument_list|)
index|]
operator|=
name|adr
expr_stmt|;
name|adr
operator|-=
literal|4
expr_stmt|;
block|}
block|}
name|fsrp
operator|->
name|regs
index|[
name|PC_REGNUM
index|]
operator|=
name|fip
operator|->
name|frame
operator|+
literal|4
expr_stmt|;
name|fsrp
operator|->
name|regs
index|[
name|FP_REGNUM
index|]
operator|=
name|fip
operator|->
name|frame
expr_stmt|;
block|}
end_block

begin_function
specifier|static
name|long
name|i386_get_frame_setup
parameter_list|(
name|pc
parameter_list|)
block|{
name|unsigned
name|char
name|op
decl_stmt|;
name|codestream_seek
argument_list|(
name|pc
argument_list|)
expr_stmt|;
name|i386_follow_jump
argument_list|()
expr_stmt|;
name|op
operator|=
name|codestream_get
argument_list|()
expr_stmt|;
if|if
condition|(
name|op
operator|==
literal|0x58
condition|)
comment|/* popl %eax */
block|{
comment|/*        * this function must start with        *         *    popl %eax		  0x58        *    xchgl %eax, (%esp)  0x87 0x04 0x24        * or xchgl %eax, 0(%esp) 0x87 0x44 0x24 0x00        *        * (the system 5 compiler puts out the second xchg        * inst, and the assembler doesn't try to optimize it,        * so the 'sib' form gets generated)        *         * this sequence is used to get the address of the return        * buffer for a function that returns a structure        */
name|int
name|pos
decl_stmt|;
name|unsigned
name|char
name|buf
index|[
literal|4
index|]
decl_stmt|;
specifier|static
name|unsigned
name|char
name|proto1
index|[
literal|3
index|]
init|=
block|{
literal|0x87
block|,
literal|0x04
block|,
literal|0x24
block|}
decl_stmt|;
specifier|static
name|unsigned
name|char
name|proto2
index|[
literal|4
index|]
init|=
block|{
literal|0x87
block|,
literal|0x44
block|,
literal|0x24
block|,
literal|0x00
block|}
decl_stmt|;
name|pos
operator|=
name|codestream_tell
argument_list|()
expr_stmt|;
name|codestream_read
argument_list|(
name|buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|bcmp
argument_list|(
name|buf
argument_list|,
name|proto1
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
name|pos
operator|+=
literal|3
expr_stmt|;
elseif|else
if|if
condition|(
name|bcmp
argument_list|(
name|buf
argument_list|,
name|proto2
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
name|pos
operator|+=
literal|4
expr_stmt|;
name|codestream_seek
argument_list|(
name|pos
argument_list|)
expr_stmt|;
name|op
operator|=
name|codestream_get
argument_list|()
expr_stmt|;
comment|/* update next opcode */
block|}
if|if
condition|(
name|op
operator|==
literal|0x55
condition|)
comment|/* pushl %esp */
block|{
if|if
condition|(
name|codestream_get
argument_list|()
operator|!=
literal|0x8b
condition|)
comment|/* movl %esp, %ebp (2bytes) */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|codestream_get
argument_list|()
operator|!=
literal|0xec
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/*        * check for stack adjustment         *        *  subl $XXX, %esp        *        * note: you can't subtract a 16 bit immediate        * from a 32 bit reg, so we don't have to worry        * about a data16 prefix         */
name|op
operator|=
name|codestream_peek
argument_list|()
expr_stmt|;
if|if
condition|(
name|op
operator|==
literal|0x83
condition|)
comment|/* subl with 8 bit immed */
block|{
name|codestream_get
argument_list|()
expr_stmt|;
if|if
condition|(
name|codestream_get
argument_list|()
operator|!=
literal|0xec
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* subl with signed byte immediate  	   * (though it wouldn't make sense to be negative) 	   */
return|return
operator|(
name|codestream_get
argument_list|()
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|op
operator|==
literal|0x81
condition|)
comment|/* subl with 32 bit immed */
block|{
name|int
name|locals
decl_stmt|;
if|if
condition|(
name|codestream_get
argument_list|()
operator|!=
literal|0xec
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* subl with 32 bit immediate */
name|codestream_read
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|locals
argument_list|,
literal|4
argument_list|)
expr_stmt|;
return|return
operator|(
name|locals
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|op
operator|==
literal|0xc8
condition|)
block|{
comment|/* enter instruction: arg is 16 unsigned immed */
name|unsigned
name|short
name|slocals
decl_stmt|;
name|codestream_read
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|slocals
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|codestream_get
argument_list|()
expr_stmt|;
comment|/* flush final byte of enter instruction */
return|return
operator|(
name|slocals
operator|)
return|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* next instruction is a jump, move to target */
end_comment

begin_expr_stmt
specifier|static
name|i386_follow_jump
argument_list|()
block|{
name|int
name|long_delta
block|;
name|short
name|short_delta
block|;
name|char
name|byte_delta
block|;
name|int
name|data16
block|;
name|int
name|pos
block|;
name|pos
operator|=
name|codestream_tell
argument_list|()
block|;
name|data16
operator|=
literal|0
block|;
if|if
condition|(
name|codestream_peek
argument_list|()
operator|==
literal|0x66
condition|)
block|{
name|codestream_get
argument_list|()
expr_stmt|;
name|data16
operator|=
literal|1
expr_stmt|;
block|}
end_expr_stmt

begin_switch
switch|switch
condition|(
name|codestream_get
argument_list|()
condition|)
block|{
case|case
literal|0xe9
case|:
comment|/* relative jump: if data16 == 0, disp32, else disp16 */
if|if
condition|(
name|data16
condition|)
block|{
name|codestream_read
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|short_delta
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|pos
operator|+=
name|short_delta
operator|+
literal|3
expr_stmt|;
comment|/* include size of jmp inst */
block|}
else|else
block|{
name|codestream_read
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|long_delta
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|pos
operator|+=
name|long_delta
operator|+
literal|5
expr_stmt|;
block|}
break|break;
case|case
literal|0xeb
case|:
comment|/* relative jump, disp8 (ignore data16) */
name|codestream_read
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|byte_delta
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pos
operator|+=
name|byte_delta
operator|+
literal|2
expr_stmt|;
break|break;
block|}
end_switch

begin_expr_stmt
name|codestream_seek
argument_list|(
name|pos
operator|+
name|data16
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|/* return pc of first real instruction */
end_comment

begin_comment
comment|/* from i386-dep.c */
end_comment

begin_expr_stmt
unit|i386_skip_prologue
operator|(
name|pc
operator|)
block|{
name|unsigned
name|char
name|op
block|;
name|int
name|i
block|;
if|if
condition|(
name|i386_get_frame_setup
argument_list|(
name|pc
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|pc
operator|)
return|;
end_expr_stmt

begin_comment
comment|/* found valid frame setup - codestream now points to     * start of push instructions for saving registers    */
end_comment

begin_comment
comment|/* skip over register saves */
end_comment

begin_for
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
name|op
operator|=
name|codestream_peek
argument_list|()
expr_stmt|;
comment|/* break if not pushl inst */
if|if
condition|(
name|op
operator|<
literal|0x50
operator|||
name|op
operator|>
literal|0x57
condition|)
break|break;
name|codestream_get
argument_list|()
expr_stmt|;
block|}
end_for

begin_expr_stmt
name|i386_follow_jump
argument_list|()
expr_stmt|;
end_expr_stmt

begin_return
return|return
operator|(
name|codestream_tell
argument_list|()
operator|)
return|;
end_return

begin_expr_stmt
unit|}  symmetry_extract_return_value
operator|(
name|type
operator|,
name|regbuf
operator|,
name|valbuf
operator|)
expr|struct
name|type
operator|*
name|type
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
modifier|*
name|regbuf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|valbuf
decl_stmt|;
end_decl_stmt

begin_block
block|{
union|union
block|{
name|double
name|d
decl_stmt|;
name|int
name|l
index|[
literal|2
index|]
decl_stmt|;
block|}
name|xd
union|;
name|struct
name|minimal_symbol
modifier|*
name|msymbol
decl_stmt|;
name|float
name|f
decl_stmt|;
if|if
condition|(
name|TYPE_CODE_FLT
operator|==
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|msymbol
operator|=
name|lookup_minimal_symbol
argument_list|(
literal|"1167_flt"
argument_list|,
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|msymbol
operator|!=
name|NULL
condition|)
block|{
comment|/* found "1167_flt" means 1167, %fp2-%fp3 */
comment|/* float& double; 19= %fp2, 20= %fp3 */
comment|/* no single precision on 1167 */
name|xd
operator|.
name|l
index|[
literal|1
index|]
operator|=
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
operator|&
name|regbuf
index|[
name|REGISTER_BYTE
argument_list|(
literal|19
argument_list|)
index|]
operator|)
expr_stmt|;
name|xd
operator|.
name|l
index|[
literal|0
index|]
operator|=
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
operator|&
name|regbuf
index|[
name|REGISTER_BYTE
argument_list|(
literal|20
argument_list|)
index|]
operator|)
expr_stmt|;
switch|switch
condition|(
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
literal|4
case|:
name|f
operator|=
operator|(
name|float
operator|)
name|xd
operator|.
name|d
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|f
argument_list|,
name|valbuf
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|bcopy
argument_list|(
operator|&
name|xd
operator|.
name|d
argument_list|,
name|valbuf
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"Unknown floating point size"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
comment|/* 387 %st(0), gcc uses this */
name|i387_to_double
argument_list|(
operator|(
operator|(
name|int
operator|*
operator|)
operator|&
name|regbuf
index|[
name|REGISTER_BYTE
argument_list|(
literal|3
argument_list|)
index|]
operator|)
argument_list|,
operator|&
name|xd
operator|.
name|d
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
literal|4
case|:
comment|/* float */
name|f
operator|=
operator|(
name|float
operator|)
name|xd
operator|.
name|d
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|f
argument_list|,
name|valbuf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
break|break;
case|case
literal|8
case|:
comment|/* double */
name|bcopy
argument_list|(
operator|&
name|xd
operator|.
name|d
argument_list|,
name|valbuf
argument_list|,
literal|8
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"Unknown floating point size"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
else|else
block|{
name|bcopy
argument_list|(
name|regbuf
argument_list|,
name|valbuf
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_block

end_unit

