begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Host-dependent code for SPARC host systems, for GDB, the GNU debugger.    Copyright 1986, 1987, 1989, 1990, 1991  Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_comment
comment|/* This code only compiles when we have the definitions in tm-sparc.h.  */
end_comment

begin_define
define|#
directive|define
name|TM_FILE_OVERRIDE
end_define

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"tm-sparc.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/ptrace.h>
end_include

begin_include
include|#
directive|include
file|<machine/reg.h>
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_decl_stmt
specifier|extern
name|char
name|register_valid
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|deferred_stores
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Fetch one or more registers from the inferior.  REGNO == -1 to get  * them all.  We actually fetch more than requested, when convenient,  * marking them as valid so we won't fetch them again.  */
end_comment

begin_function
name|void
name|fetch_inferior_registers
parameter_list|(
name|regno
parameter_list|)
name|int
name|regno
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|CORE_ADDR
name|sp
decl_stmt|;
name|struct
name|trapframe
name|tf
decl_stmt|;
name|struct
name|fpstate
name|fpstate
decl_stmt|;
comment|/* 	 * We should never be called with deferred stores, because a 	 * prerequisitefor writing regs is to have fetched them all 	 * (PREPARE_TO_STORE), sigh. 	 */
if|if
condition|(
name|deferred_stores
condition|)
name|abort
argument_list|()
expr_stmt|;
name|DO_DEFERRED_STORES
expr_stmt|;
name|ptrace
argument_list|(
name|PT_GETREGS
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|tf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|tf
operator|.
name|tf_global
argument_list|,
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
literal|0
argument_list|)
index|]
argument_list|,
literal|16
operator|*
literal|4
argument_list|)
expr_stmt|;
comment|/* 	 * Get state registers. 	 */
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|tf
operator|.
name|tf_psr
argument_list|,
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|PS_REGNUM
argument_list|)
index|]
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|tf
operator|.
name|tf_pc
argument_list|,
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|PC_REGNUM
argument_list|)
index|]
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|tf
operator|.
name|tf_npc
argument_list|,
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|NPC_REGNUM
argument_list|)
index|]
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|tf
operator|.
name|tf_y
argument_list|,
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|Y_REGNUM
argument_list|)
index|]
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* 	 * Read locals and ins from the kernel save area indicated by 	 * the frame pointer (o6). 	 * XXX Don't do this if we don't have to.  (See sparc-xdep.c) 	 * FIXME 	 */
name|sp
operator|=
name|tf
operator|.
name|tf_out
index|[
literal|6
index|]
expr_stmt|;
name|target_read_memory
argument_list|(
name|sp
argument_list|,
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
literal|16
argument_list|)
index|]
argument_list|,
literal|16
operator|*
literal|4
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|G0_REGNUM
init|;
name|i
operator|<=
name|I7_REGNUM
condition|;
name|i
operator|++
control|)
name|register_valid
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
name|register_valid
index|[
name|Y_REGNUM
index|]
operator|=
literal|1
expr_stmt|;
name|register_valid
index|[
name|PS_REGNUM
index|]
operator|=
literal|1
expr_stmt|;
name|register_valid
index|[
name|PC_REGNUM
index|]
operator|=
literal|1
expr_stmt|;
name|register_valid
index|[
name|NPC_REGNUM
index|]
operator|=
literal|1
expr_stmt|;
comment|/* 	 * If we don't set these valid, read_register_bytes() rereads 	 * all the regs every time it is called!  FIXME. 	 */
name|register_valid
index|[
name|WIM_REGNUM
index|]
operator|=
literal|1
expr_stmt|;
name|register_valid
index|[
name|TBR_REGNUM
index|]
operator|=
literal|1
expr_stmt|;
name|register_valid
index|[
name|FPS_REGNUM
index|]
operator|=
literal|1
expr_stmt|;
name|register_valid
index|[
name|CPS_REGNUM
index|]
operator|=
literal|1
expr_stmt|;
comment|/* 	 * Get floating point register set, if wanted. 	 */
if|if
condition|(
name|regno
operator|>
literal|0
operator|&&
name|regno
operator|<
name|FP0_REGNUM
operator|&&
name|regno
operator|>
name|FP0_REGNUM
operator|+
literal|31
condition|)
return|return;
name|ptrace
argument_list|(
name|PT_GETFPREGS
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|fpstate
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|fpstate
operator|.
name|fs_regs
index|[
literal|0
index|]
argument_list|,
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|FP0_REGNUM
argument_list|)
index|]
argument_list|,
sizeof|sizeof
name|fpstate
operator|.
name|fs_regs
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|fpstate
operator|.
name|fs_fsr
argument_list|,
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|FPS_REGNUM
argument_list|)
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|fpstate
operator|.
name|fs_fsr
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|FP0_REGNUM
init|;
name|i
operator|<=
name|FP0_REGNUM
operator|+
literal|31
condition|;
name|i
operator|++
control|)
name|register_valid
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
name|register_valid
index|[
name|FPS_REGNUM
index|]
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|void
name|store_inferior_ksaregs
parameter_list|(
name|regno
parameter_list|)
name|int
name|regno
decl_stmt|;
block|{
name|CORE_ADDR
name|addr
decl_stmt|;
comment|/* 	 * Write locals and ins into kernel save area on stack. 	 */
name|bcopy
argument_list|(
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|SP_REGNUM
argument_list|)
index|]
argument_list|,
operator|&
name|addr
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|>
literal|0
condition|)
block|{
comment|/* 		 * Just write the one register in. 		 */
name|addr
operator|+=
operator|(
name|regno
operator|-
literal|16
operator|)
operator|*
literal|4
expr_stmt|;
name|target_write_memory
argument_list|(
name|addr
argument_list|,
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|regno
argument_list|)
index|]
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
else|else
name|target_write_memory
argument_list|(
name|addr
argument_list|,
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
literal|16
argument_list|)
index|]
argument_list|,
literal|64
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|store_inferior_cpuregs
parameter_list|()
block|{
name|struct
name|trapframe
name|tf
decl_stmt|;
name|bcopy
argument_list|(
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
literal|0
argument_list|)
index|]
argument_list|,
operator|(
name|caddr_t
operator|)
name|tf
operator|.
name|tf_global
argument_list|,
literal|16
operator|*
literal|4
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|PS_REGNUM
argument_list|)
index|]
argument_list|,
operator|&
name|tf
operator|.
name|tf_psr
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|PC_REGNUM
argument_list|)
index|]
argument_list|,
operator|&
name|tf
operator|.
name|tf_pc
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|NPC_REGNUM
argument_list|)
index|]
argument_list|,
operator|&
name|tf
operator|.
name|tf_npc
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|Y_REGNUM
argument_list|)
index|]
argument_list|,
operator|&
name|tf
operator|.
name|tf_y
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|ptrace
argument_list|(
name|PT_SETREGS
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|tf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|store_inferior_fpregs
parameter_list|()
block|{
name|struct
name|fpstate
name|fpstate
decl_stmt|;
name|bcopy
argument_list|(
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|FP0_REGNUM
argument_list|)
index|]
argument_list|,
operator|&
name|fpstate
operator|.
name|fs_regs
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
name|fpstate
operator|.
name|fs_regs
argument_list|)
expr_stmt|;
name|fpstate
operator|.
name|fs_fsr
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|FPS_REGNUM
argument_list|)
index|]
expr_stmt|;
name|fpstate
operator|.
name|fs_qsize
operator|=
literal|0
expr_stmt|;
name|ptrace
argument_list|(
name|PT_SETFPREGS
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|fpstate
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|RF_KSA
value|1
end_define

begin_define
define|#
directive|define
name|RF_CPU
value|2
end_define

begin_define
define|#
directive|define
name|RF_FPU
value|4
end_define

begin_define
define|#
directive|define
name|RF_ALL
value|(RF_KSA|RF_CPU|RF_FPU)
end_define

begin_function
specifier|static
name|void
name|storeregs
parameter_list|(
name|rf
parameter_list|,
name|regno
parameter_list|)
specifier|register
name|int
name|rf
decl_stmt|;
block|{
if|if
condition|(
name|rf
operator|&
name|RF_KSA
condition|)
name|store_inferior_ksaregs
argument_list|(
name|regno
argument_list|)
expr_stmt|;
if|if
condition|(
name|rf
operator|&
name|RF_CPU
condition|)
name|store_inferior_cpuregs
argument_list|()
expr_stmt|;
if|if
condition|(
name|rf
operator|&
name|RF_FPU
condition|)
name|store_inferior_fpregs
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Store our register values back into the inferior.  * If REGNO is -1, do this for all registers.  * Otherwise, REGNO specifies which register (so we can save time).  */
end_comment

begin_function
name|void
name|store_inferior_registers
parameter_list|(
name|regno
parameter_list|)
name|int
name|regno
decl_stmt|;
block|{
specifier|register
name|int
name|rf
decl_stmt|;
if|if
condition|(
name|regno
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|regno
operator|==
operator|-
literal|2
condition|)
block|{
name|rf
operator|=
name|deferred_stores
expr_stmt|;
name|deferred_stores
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|rf
operator|=
name|RF_ALL
expr_stmt|;
name|storeregs
argument_list|(
name|rf
argument_list|,
name|regno
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|regno
operator|>=
name|FP0_REGNUM
operator|&&
name|regno
operator|<
name|FP0_REGNUM
operator|+
literal|32
condition|)
name|deferred_stores
operator||=
name|RF_FPU
expr_stmt|;
elseif|else
if|if
condition|(
name|regno
operator|<
name|L0_REGNUM
operator|||
name|regno
operator|>
name|I7_REGNUM
condition|)
name|deferred_stores
operator||=
name|RF_CPU
expr_stmt|;
else|else
name|storeregs
argument_list|(
name|RF_KSA
argument_list|,
name|regno
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|fetch_core_intregs
parameter_list|(
name|tf
parameter_list|)
specifier|register
name|struct
name|trapframe
modifier|*
name|tf
decl_stmt|;
block|{
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
literal|0
argument_list|)
index|]
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* The globals and output registers.  */
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|tf
operator|->
name|tf_global
index|[
literal|0
index|]
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|G0_REGNUM
argument_list|)
index|]
argument_list|,
literal|15
operator|*
name|REGISTER_RAW_SIZE
argument_list|(
name|G1_REGNUM
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|tf
operator|->
name|tf_psr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|PS_REGNUM
argument_list|)
index|]
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|tf
operator|->
name|tf_pc
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|PC_REGNUM
argument_list|)
index|]
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|tf
operator|->
name|tf_npc
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|NPC_REGNUM
argument_list|)
index|]
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|tf
operator|->
name|tf_y
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|Y_REGNUM
argument_list|)
index|]
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* 	 * Try to read KSA from stack.  This might not 	 * work if the stack pointer got trashed. 	 */
if|if
condition|(
name|target_read_memory
argument_list|(
operator|(
name|CORE_ADDR
operator|)
name|tf
operator|->
name|tf_out
index|[
literal|6
index|]
argument_list|,
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|L0_REGNUM
argument_list|)
index|]
argument_list|,
literal|16
operator|*
literal|4
argument_list|)
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Couldn't read input and local registers from core file\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fetch_core_fpregs
parameter_list|(
name|fps
parameter_list|,
name|size
parameter_list|)
name|struct
name|fpstate
modifier|*
name|fps
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
comment|/* Floating point registers */
if|if
condition|(
name|size
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|fps
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Couldn't read float regs from core file\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|fps
operator|->
name|fs_regs
argument_list|,
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|FP0_REGNUM
argument_list|)
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|fps
operator|->
name|fs_regs
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|fps
operator|->
name|fs_fsr
argument_list|,
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|FPS_REGNUM
argument_list|)
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|fps
operator|->
name|fs_fsr
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|fetch_core_registers
parameter_list|(
name|core_reg_sect
parameter_list|,
name|core_reg_size
parameter_list|,
name|which
parameter_list|,
name|reg_addr
parameter_list|)
name|char
modifier|*
name|core_reg_sect
decl_stmt|;
name|unsigned
name|core_reg_size
decl_stmt|;
name|int
name|which
decl_stmt|;
name|unsigned
name|int
name|reg_addr
decl_stmt|;
block|{
if|if
condition|(
name|which
operator|==
literal|0
condition|)
name|fetch_core_intregs
argument_list|(
operator|(
expr|struct
name|trapframe
operator|*
operator|)
name|core_reg_sect
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|which
operator|==
literal|2
condition|)
name|fetch_core_fpregs
argument_list|(
operator|(
expr|struct
name|fpstate
operator|*
operator|)
name|core_reg_sect
argument_list|,
name|core_reg_size
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|get_longjmp_target
parameter_list|(
name|pc
parameter_list|)
name|CORE_ADDR
modifier|*
name|pc
decl_stmt|;
block|{
name|error
argument_list|(
literal|"cannot step over longjmp"
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

