begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Target-machine dependent code for the Intel 960    Copyright (C) 1991 Free Software Foundation, Inc.    Contributed by Intel Corporation.    examine_prologue and other parts contributed by Wind River Systems.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* Miscellaneous i80960-dependent routines.    Most are called from macros defined in "tm-i960.h".  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"ieee-float.h"
end_include

begin_comment
comment|/* Structure of i960 extended floating point format.  */
end_comment

begin_decl_stmt
specifier|const
name|struct
name|ext_format
name|ext_format_i960
init|=
block|{
comment|/* tot sbyte smask expbyte manbyte */
literal|12
block|,
literal|9
block|,
literal|0x80
block|,
literal|9
block|,
literal|8
block|,
literal|4
block|,
literal|0
block|,
comment|/* i960 */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* gdb960 is always running on a non-960 host.  Check its characteristics.    This routine must be called as part of gdb initialization.  */
end_comment

begin_function
specifier|static
name|void
name|check_host
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
specifier|static
struct|struct
name|typestruct
block|{
name|int
name|hostsize
decl_stmt|;
comment|/* Size of type on host		*/
name|int
name|i960size
decl_stmt|;
comment|/* Size of type on i960		*/
name|char
modifier|*
name|typename
decl_stmt|;
comment|/* Name of type, for error msg	*/
block|}
name|types
index|[]
init|=
block|{
block|{
sizeof|sizeof
argument_list|(
name|short
argument_list|)
block|,
literal|2
block|,
literal|"short"
block|}
block|,
block|{
sizeof|sizeof
argument_list|(
name|int
argument_list|)
block|,
literal|4
block|,
literal|"int"
block|}
block|,
block|{
sizeof|sizeof
argument_list|(
name|long
argument_list|)
block|,
literal|4
block|,
literal|"long"
block|}
block|,
block|{
sizeof|sizeof
argument_list|(
name|float
argument_list|)
block|,
literal|4
block|,
literal|"float"
block|}
block|,
block|{
sizeof|sizeof
argument_list|(
name|double
argument_list|)
block|,
literal|8
block|,
literal|"double"
block|}
block|,
block|{
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
block|,
literal|4
block|,
literal|"pointer"
block|}
block|, 	}
struct|;
define|#
directive|define
name|TYPELEN
value|(sizeof(types) / sizeof(struct typestruct))
comment|/* Make sure that host type sizes are same as i960 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TYPELEN
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|types
index|[
name|i
index|]
operator|.
name|hostsize
operator|!=
name|types
index|[
name|i
index|]
operator|.
name|i960size
condition|)
block|{
name|printf
argument_list|(
literal|"sizeof(%s) != %d:  PROCEED AT YOUR OWN RISK!\n"
argument_list|,
name|types
index|[
name|i
index|]
operator|.
name|typename
argument_list|,
name|types
index|[
name|i
index|]
operator|.
name|i960size
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Examine an i960 function prologue, recording the addresses at which    registers are saved explicitly by the prologue code, and returning    the address of the first instruction after the prologue (but not    after the instruction at address LIMIT, as explained below).     LIMIT places an upper bound on addresses of the instructions to be    examined.  If the prologue code scan reaches LIMIT, the scan is    aborted and LIMIT is returned.  This is used, when examining the    prologue for the current frame, to keep examine_prologue () from    claiming that a given register has been saved when in fact the    instruction that saves it has not yet been executed.  LIMIT is used    at other times to stop the scan when we hit code after the true    function prologue (e.g. for the first source line) which might    otherwise be mistaken for function prologue.     The format of the function prologue matched by this routine is    derived from examination of the source to gcc960 1.21, particularly    the routine i960_function_prologue ().  A "regular expression" for    the function prologue is given below:     (lda LRn, g14     mov g14, g[0-7]     (mov 0, g14) | (lda 0, g14))?     (mov[qtl]? g[0-15], r[4-15])*    ((addo [1-31], sp, sp) | (lda n(sp), sp))?    (st[qtl]? g[0-15], n(fp))*     (cmpobne 0, g14, LFn     mov sp, g14     lda 0x30(sp), sp     LFn: stq g0, (g14)     stq g4, 0x10(g14)     stq g8, 0x20(g14))?     (st g14, n(fp))?    (mov g13,r[4-15])? */
end_comment

begin_comment
comment|/* Macros for extracting fields from i960 instructions.  */
end_comment

begin_define
define|#
directive|define
name|BITMASK
parameter_list|(
name|pos
parameter_list|,
name|width
parameter_list|)
value|(((0x1<< (width)) - 1)<< (pos))
end_define

begin_define
define|#
directive|define
name|EXTRACT_FIELD
parameter_list|(
name|val
parameter_list|,
name|pos
parameter_list|,
name|width
parameter_list|)
value|((val)>> (pos)& BITMASK (0, width))
end_define

begin_define
define|#
directive|define
name|REG_SRC1
parameter_list|(
name|insn
parameter_list|)
value|EXTRACT_FIELD (insn, 0, 5)
end_define

begin_define
define|#
directive|define
name|REG_SRC2
parameter_list|(
name|insn
parameter_list|)
value|EXTRACT_FIELD (insn, 14, 5)
end_define

begin_define
define|#
directive|define
name|REG_SRCDST
parameter_list|(
name|insn
parameter_list|)
value|EXTRACT_FIELD (insn, 19, 5)
end_define

begin_define
define|#
directive|define
name|MEM_SRCDST
parameter_list|(
name|insn
parameter_list|)
value|EXTRACT_FIELD (insn, 19, 5)
end_define

begin_define
define|#
directive|define
name|MEMA_OFFSET
parameter_list|(
name|insn
parameter_list|)
value|EXTRACT_FIELD (insn, 0, 12)
end_define

begin_comment
comment|/* Fetch the instruction at ADDR, returning 0 if ADDR is beyond LIM or    is not the address of a valid instruction, the address of the next    instruction beyond ADDR otherwise.  *PWORD1 receives the first word    of the instruction, and (for two-word instructions), *PWORD2 receives    the second.  */
end_comment

begin_define
define|#
directive|define
name|NEXT_PROLOGUE_INSN
parameter_list|(
name|addr
parameter_list|,
name|lim
parameter_list|,
name|pword1
parameter_list|,
name|pword2
parameter_list|)
define|\
value|(((addr)< (lim)) ? next_insn (addr, pword1, pword2) : 0)
end_define

begin_function
specifier|static
name|CORE_ADDR
name|examine_prologue
parameter_list|(
name|ip
parameter_list|,
name|limit
parameter_list|,
name|frame_addr
parameter_list|,
name|fsr
parameter_list|)
specifier|register
name|CORE_ADDR
name|ip
decl_stmt|;
specifier|register
name|CORE_ADDR
name|limit
decl_stmt|;
name|FRAME_ADDR
name|frame_addr
decl_stmt|;
name|struct
name|frame_saved_regs
modifier|*
name|fsr
decl_stmt|;
block|{
specifier|register
name|CORE_ADDR
name|next_ip
decl_stmt|;
specifier|register
name|int
name|src
decl_stmt|,
name|dst
decl_stmt|;
specifier|register
name|unsigned
name|int
modifier|*
name|pcode
decl_stmt|;
name|unsigned
name|int
name|insn1
decl_stmt|,
name|insn2
decl_stmt|;
name|int
name|size
decl_stmt|;
name|int
name|within_leaf_prologue
decl_stmt|;
name|CORE_ADDR
name|save_addr
decl_stmt|;
specifier|static
name|unsigned
name|int
name|varargs_prologue_code
index|[]
init|=
block|{
literal|0x3507a00c
block|,
comment|/* cmpobne 0x0, g14, LFn */
literal|0x5cf01601
block|,
comment|/* mov sp, g14		 */
literal|0x8c086030
block|,
comment|/* lda 0x30(sp), sp	 */
literal|0xb2879000
block|,
comment|/* LFn: stq  g0, (g14)   */
literal|0xb2a7a010
block|,
comment|/* stq g4, 0x10(g14)	 */
literal|0xb2c7a020
comment|/* stq g8, 0x20(g14)	 */
block|}
decl_stmt|;
comment|/* Accept a leaf procedure prologue code fragment if present.      Note that ip might point to either the leaf or non-leaf      entry point; we look for the non-leaf entry point first:  */
name|within_leaf_prologue
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|next_ip
operator|=
name|NEXT_PROLOGUE_INSN
argument_list|(
name|ip
argument_list|,
name|limit
argument_list|,
operator|&
name|insn1
argument_list|,
operator|&
name|insn2
argument_list|)
operator|)
operator|&&
operator|(
operator|(
name|insn1
operator|&
literal|0xfffff000
operator|)
operator|==
literal|0x8cf00000
comment|/* lda LRx, g14 (MEMA) */
operator|||
operator|(
name|insn1
operator|&
literal|0xfffffc60
operator|)
operator|==
literal|0x8cf03000
operator|)
condition|)
comment|/* lda LRx, g14 (MEMB) */
block|{
name|within_leaf_prologue
operator|=
literal|1
expr_stmt|;
name|next_ip
operator|=
name|NEXT_PROLOGUE_INSN
argument_list|(
name|next_ip
argument_list|,
name|limit
argument_list|,
operator|&
name|insn1
argument_list|,
operator|&
name|insn2
argument_list|)
expr_stmt|;
block|}
comment|/* Now look for the prologue code at a leaf entry point:  */
if|if
condition|(
name|next_ip
operator|&&
operator|(
name|insn1
operator|&
literal|0xff87ffff
operator|)
operator|==
literal|0x5c80161e
comment|/* mov g14, gx */
operator|&&
name|REG_SRCDST
argument_list|(
name|insn1
argument_list|)
operator|<=
name|G0_REGNUM
operator|+
literal|7
condition|)
block|{
name|within_leaf_prologue
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|next_ip
operator|=
name|NEXT_PROLOGUE_INSN
argument_list|(
name|next_ip
argument_list|,
name|limit
argument_list|,
operator|&
name|insn1
argument_list|,
operator|&
name|insn2
argument_list|)
operator|)
operator|&&
operator|(
name|insn1
operator|==
literal|0x8cf00000
comment|/* lda 0, g14 */
operator|||
name|insn1
operator|==
literal|0x5cf01e00
operator|)
condition|)
comment|/* mov 0, g14 */
block|{
name|ip
operator|=
name|next_ip
expr_stmt|;
name|next_ip
operator|=
name|NEXT_PROLOGUE_INSN
argument_list|(
name|ip
argument_list|,
name|limit
argument_list|,
operator|&
name|insn1
argument_list|,
operator|&
name|insn2
argument_list|)
expr_stmt|;
name|within_leaf_prologue
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* If something that looks like the beginning of a leaf prologue      has been seen, but the remainder of the prologue is missing, bail.      We don't know what we've got.  */
if|if
condition|(
name|within_leaf_prologue
condition|)
return|return
operator|(
name|ip
operator|)
return|;
comment|/* Accept zero or more instances of "mov[qtl]? gx, ry", where y>= 4.      This may cause us to mistake the moving of a register      parameter to a local register for the saving of a callee-saved      register, but that can't be helped, since with the      "-fcall-saved" flag, any register can be made callee-saved.  */
while|while
condition|(
name|next_ip
operator|&&
operator|(
name|insn1
operator|&
literal|0xfc802fb0
operator|)
operator|==
literal|0x5c000610
operator|&&
operator|(
name|dst
operator|=
name|REG_SRCDST
argument_list|(
name|insn1
argument_list|)
operator|)
operator|>=
operator|(
name|R0_REGNUM
operator|+
literal|4
operator|)
condition|)
block|{
name|src
operator|=
name|REG_SRC1
argument_list|(
name|insn1
argument_list|)
expr_stmt|;
name|size
operator|=
name|EXTRACT_FIELD
argument_list|(
name|insn1
argument_list|,
literal|24
argument_list|,
literal|2
argument_list|)
operator|+
literal|1
expr_stmt|;
name|save_addr
operator|=
name|frame_addr
operator|+
operator|(
operator|(
name|dst
operator|-
name|R0_REGNUM
operator|)
operator|*
literal|4
operator|)
expr_stmt|;
while|while
condition|(
name|size
operator|--
condition|)
block|{
name|fsr
operator|->
name|regs
index|[
name|src
operator|++
index|]
operator|=
name|save_addr
expr_stmt|;
name|save_addr
operator|+=
literal|4
expr_stmt|;
block|}
name|ip
operator|=
name|next_ip
expr_stmt|;
name|next_ip
operator|=
name|NEXT_PROLOGUE_INSN
argument_list|(
name|ip
argument_list|,
name|limit
argument_list|,
operator|&
name|insn1
argument_list|,
operator|&
name|insn2
argument_list|)
expr_stmt|;
block|}
comment|/* Accept an optional "addo n, sp, sp" or "lda n(sp), sp".  */
if|if
condition|(
name|next_ip
operator|&&
operator|(
operator|(
name|insn1
operator|&
literal|0xffffffe0
operator|)
operator|==
literal|0x59084800
comment|/* addo n, sp, sp */
operator|||
operator|(
name|insn1
operator|&
literal|0xfffff000
operator|)
operator|==
literal|0x8c086000
comment|/* lda n(sp), sp (MEMA) */
operator|||
operator|(
name|insn1
operator|&
literal|0xfffffc60
operator|)
operator|==
literal|0x8c087400
operator|)
condition|)
comment|/* lda n(sp), sp (MEMB) */
block|{
name|ip
operator|=
name|next_ip
expr_stmt|;
name|next_ip
operator|=
name|NEXT_PROLOGUE_INSN
argument_list|(
name|ip
argument_list|,
name|limit
argument_list|,
operator|&
name|insn1
argument_list|,
operator|&
name|insn2
argument_list|)
expr_stmt|;
block|}
comment|/* Accept zero or more instances of "st[qtl]? gx, n(fp)".        This may cause us to mistake the copying of a register      parameter to the frame for the saving of a callee-saved      register, but that can't be helped, since with the      "-fcall-saved" flag, any register can be made callee-saved.      We can, however, refuse to accept a save of register g14,      since that is matched explicitly below.  */
while|while
condition|(
name|next_ip
operator|&&
operator|(
operator|(
name|insn1
operator|&
literal|0xf787f000
operator|)
operator|==
literal|0x9287e000
comment|/* stl? gx, n(fp) (MEMA) */
operator|||
operator|(
name|insn1
operator|&
literal|0xf787fc60
operator|)
operator|==
literal|0x9287f400
comment|/* stl? gx, n(fp) (MEMB) */
operator|||
operator|(
name|insn1
operator|&
literal|0xef87f000
operator|)
operator|==
literal|0xa287e000
comment|/* st[tq] gx, n(fp) (MEMA) */
operator|||
operator|(
name|insn1
operator|&
literal|0xef87fc60
operator|)
operator|==
literal|0xa287f400
operator|)
comment|/* st[tq] gx, n(fp) (MEMB) */
operator|&&
operator|(
operator|(
name|src
operator|=
name|MEM_SRCDST
argument_list|(
name|insn1
argument_list|)
operator|)
operator|!=
name|G14_REGNUM
operator|)
condition|)
block|{
name|save_addr
operator|=
name|frame_addr
operator|+
operator|(
operator|(
name|insn1
operator|&
name|BITMASK
argument_list|(
literal|12
argument_list|,
literal|1
argument_list|)
operator|)
condition|?
name|insn2
else|:
name|MEMA_OFFSET
argument_list|(
name|insn1
argument_list|)
operator|)
expr_stmt|;
name|size
operator|=
operator|(
name|insn1
operator|&
name|BITMASK
argument_list|(
literal|29
argument_list|,
literal|1
argument_list|)
operator|)
condition|?
operator|(
operator|(
name|insn1
operator|&
name|BITMASK
argument_list|(
literal|28
argument_list|,
literal|1
argument_list|)
operator|)
condition|?
literal|4
else|:
literal|3
operator|)
else|:
operator|(
operator|(
name|insn1
operator|&
name|BITMASK
argument_list|(
literal|27
argument_list|,
literal|1
argument_list|)
operator|)
condition|?
literal|2
else|:
literal|1
operator|)
expr_stmt|;
while|while
condition|(
name|size
operator|--
condition|)
block|{
name|fsr
operator|->
name|regs
index|[
name|src
operator|++
index|]
operator|=
name|save_addr
expr_stmt|;
name|save_addr
operator|+=
literal|4
expr_stmt|;
block|}
name|ip
operator|=
name|next_ip
expr_stmt|;
name|next_ip
operator|=
name|NEXT_PROLOGUE_INSN
argument_list|(
name|ip
argument_list|,
name|limit
argument_list|,
operator|&
name|insn1
argument_list|,
operator|&
name|insn2
argument_list|)
expr_stmt|;
block|}
comment|/* Accept the varargs prologue code if present.  */
name|size
operator|=
sizeof|sizeof
argument_list|(
name|varargs_prologue_code
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|pcode
operator|=
name|varargs_prologue_code
expr_stmt|;
while|while
condition|(
name|size
operator|--
operator|&&
name|next_ip
operator|&&
operator|*
name|pcode
operator|++
operator|==
name|insn1
condition|)
block|{
name|ip
operator|=
name|next_ip
expr_stmt|;
name|next_ip
operator|=
name|NEXT_PROLOGUE_INSN
argument_list|(
name|ip
argument_list|,
name|limit
argument_list|,
operator|&
name|insn1
argument_list|,
operator|&
name|insn2
argument_list|)
expr_stmt|;
block|}
comment|/* Accept an optional "st g14, n(fp)".  */
if|if
condition|(
name|next_ip
operator|&&
operator|(
operator|(
name|insn1
operator|&
literal|0xfffff000
operator|)
operator|==
literal|0x92f7e000
comment|/* st g14, n(fp) (MEMA) */
operator|||
operator|(
name|insn1
operator|&
literal|0xfffffc60
operator|)
operator|==
literal|0x92f7f400
operator|)
condition|)
comment|/* st g14, n(fp) (MEMB) */
block|{
name|fsr
operator|->
name|regs
index|[
name|G14_REGNUM
index|]
operator|=
name|frame_addr
operator|+
operator|(
operator|(
name|insn1
operator|&
name|BITMASK
argument_list|(
literal|12
argument_list|,
literal|1
argument_list|)
operator|)
condition|?
name|insn2
else|:
name|MEMA_OFFSET
argument_list|(
name|insn1
argument_list|)
operator|)
expr_stmt|;
name|ip
operator|=
name|next_ip
expr_stmt|;
name|next_ip
operator|=
name|NEXT_PROLOGUE_INSN
argument_list|(
name|ip
argument_list|,
name|limit
argument_list|,
operator|&
name|insn1
argument_list|,
operator|&
name|insn2
argument_list|)
expr_stmt|;
block|}
comment|/* Accept zero or one instance of "mov g13, ry", where y>= 4.      This is saving the address where a struct should be returned.  */
if|if
condition|(
name|next_ip
operator|&&
operator|(
name|insn1
operator|&
literal|0xff802fbf
operator|)
operator|==
literal|0x5c00061d
operator|&&
operator|(
name|dst
operator|=
name|REG_SRCDST
argument_list|(
name|insn1
argument_list|)
operator|)
operator|>=
operator|(
name|R0_REGNUM
operator|+
literal|4
operator|)
condition|)
block|{
name|save_addr
operator|=
name|frame_addr
operator|+
operator|(
operator|(
name|dst
operator|-
name|R0_REGNUM
operator|)
operator|*
literal|4
operator|)
expr_stmt|;
name|fsr
operator|->
name|regs
index|[
name|G0_REGNUM
operator|+
literal|13
index|]
operator|=
name|save_addr
expr_stmt|;
name|ip
operator|=
name|next_ip
expr_stmt|;
if|#
directive|if
literal|0
comment|/* We'll need this once there is a subsequent instruction examined. */
block|next_ip = NEXT_PROLOGUE_INSN (ip, limit,&insn1,&insn2);
endif|#
directive|endif
block|}
return|return
operator|(
name|ip
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Given an ip value corresponding to the start of a function,    return the ip of the first instruction after the function     prologue.  */
end_comment

begin_function_decl
name|CORE_ADDR
name|skip_prologue
parameter_list|(
name|ip
parameter_list|)
function_decl|CORE_ADDR
parameter_list|(
name|ip
parameter_list|)
function_decl|;
end_function_decl

begin_block
block|{
name|struct
name|frame_saved_regs
name|saved_regs_dummy
decl_stmt|;
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
name|CORE_ADDR
name|limit
decl_stmt|;
name|sal
operator|=
name|find_pc_line
argument_list|(
name|ip
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|limit
operator|=
operator|(
name|sal
operator|.
name|end
operator|)
condition|?
name|sal
operator|.
name|end
else|:
literal|0xffffffff
expr_stmt|;
return|return
operator|(
name|examine_prologue
argument_list|(
name|ip
argument_list|,
name|limit
argument_list|,
operator|(
name|FRAME_ADDR
operator|)
literal|0
argument_list|,
operator|&
name|saved_regs_dummy
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Put here the code to store, into a struct frame_saved_regs,    the addresses of the saved registers of frame described by FRAME_INFO.    This includes special registers such as pc and fp saved in special    ways in the stack frame.  sp is even more special:    the address we return for it IS the sp for the next frame.     We cache the result of doing this in the frame_cache_obstack, since    it is fairly expensive.  */
end_comment

begin_function
name|void
name|frame_find_saved_regs
parameter_list|(
name|fi
parameter_list|,
name|fsr
parameter_list|)
name|struct
name|frame_info
modifier|*
name|fi
decl_stmt|;
name|struct
name|frame_saved_regs
modifier|*
name|fsr
decl_stmt|;
block|{
specifier|register
name|CORE_ADDR
name|next_addr
decl_stmt|;
specifier|register
name|CORE_ADDR
modifier|*
name|saved_regs
decl_stmt|;
specifier|register
name|int
name|regnum
decl_stmt|;
specifier|register
name|struct
name|frame_saved_regs
modifier|*
name|cache_fsr
decl_stmt|;
specifier|extern
name|struct
name|obstack
name|frame_cache_obstack
decl_stmt|;
name|CORE_ADDR
name|ip
decl_stmt|;
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
name|CORE_ADDR
name|limit
decl_stmt|;
if|if
condition|(
operator|!
name|fi
operator|->
name|fsr
condition|)
block|{
name|cache_fsr
operator|=
operator|(
expr|struct
name|frame_saved_regs
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|frame_cache_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|frame_saved_regs
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|cache_fsr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|frame_saved_regs
argument_list|)
argument_list|)
expr_stmt|;
name|fi
operator|->
name|fsr
operator|=
name|cache_fsr
expr_stmt|;
comment|/* Find the start and end of the function prologue.  If the PC 	 is in the function prologue, we only consider the part that 	 has executed already.  */
name|ip
operator|=
name|get_pc_function_start
argument_list|(
name|fi
operator|->
name|pc
argument_list|)
expr_stmt|;
name|sal
operator|=
name|find_pc_line
argument_list|(
name|ip
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|limit
operator|=
operator|(
name|sal
operator|.
name|end
operator|&&
name|sal
operator|.
name|end
operator|<
name|fi
operator|->
name|pc
operator|)
condition|?
name|sal
operator|.
name|end
else|:
name|fi
operator|->
name|pc
expr_stmt|;
name|examine_prologue
argument_list|(
name|ip
argument_list|,
name|limit
argument_list|,
name|fi
operator|->
name|frame
argument_list|,
name|cache_fsr
argument_list|)
expr_stmt|;
comment|/* Record the addresses at which the local registers are saved. 	 Strictly speaking, we should only do this for non-leaf procedures, 	 but no one will ever look at these values if it is a leaf procedure, 	 since local registers are always caller-saved.  */
name|next_addr
operator|=
operator|(
name|CORE_ADDR
operator|)
name|fi
operator|->
name|frame
expr_stmt|;
name|saved_regs
operator|=
name|cache_fsr
operator|->
name|regs
expr_stmt|;
for|for
control|(
name|regnum
operator|=
name|R0_REGNUM
init|;
name|regnum
operator|<=
name|R15_REGNUM
condition|;
name|regnum
operator|++
control|)
block|{
operator|*
name|saved_regs
operator|++
operator|=
name|next_addr
expr_stmt|;
name|next_addr
operator|+=
literal|4
expr_stmt|;
block|}
name|cache_fsr
operator|->
name|regs
index|[
name|FP_REGNUM
index|]
operator|=
name|cache_fsr
operator|->
name|regs
index|[
name|PFP_REGNUM
index|]
expr_stmt|;
block|}
operator|*
name|fsr
operator|=
operator|*
name|fi
operator|->
name|fsr
expr_stmt|;
comment|/* Fetch the value of the sp from memory every time, since it      is conceivable that it has changed since the cache was flushed.        This unfortunately undoes much of the savings from caching the       saved register values.  I suggest adding an argument to       get_frame_saved_regs () specifying the register number we're      interested in (or -1 for all registers).  This would be passed      through to FRAME_FIND_SAVED_REGS (), permitting more efficient      computation of saved register addresses (e.g., on the i960,      we don't have to examine the prologue to find local registers).  	-- markf@wrs.com       FIXME, we don't need to refetch this, since the cache is cleared      every time the child process is restarted.  If GDB itself      modifies SP, it has to clear the cache by hand (does it?).  -gnu */
name|fsr
operator|->
name|regs
index|[
name|SP_REGNUM
index|]
operator|=
name|read_memory_integer
argument_list|(
name|fsr
operator|->
name|regs
index|[
name|SP_REGNUM
index|]
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the address of the argument block for the frame    described by FI.  Returns 0 if the address is unknown.  */
end_comment

begin_function
name|CORE_ADDR
name|frame_args_address
parameter_list|(
name|fi
parameter_list|,
name|must_be_correct
parameter_list|)
name|struct
name|frame_info
modifier|*
name|fi
decl_stmt|;
block|{
specifier|register
name|FRAME
name|frame
decl_stmt|;
name|struct
name|frame_saved_regs
name|fsr
decl_stmt|;
name|CORE_ADDR
name|ap
decl_stmt|;
comment|/* If g14 was saved in the frame by the function prologue code, return      the saved value.  If the frame is current and we are being sloppy,      return the value of g14.  Otherwise, return zero.  */
name|frame
operator|=
name|FRAME_INFO_ID
argument_list|(
name|fi
argument_list|)
expr_stmt|;
name|get_frame_saved_regs
argument_list|(
name|fi
argument_list|,
operator|&
name|fsr
argument_list|)
expr_stmt|;
if|if
condition|(
name|fsr
operator|.
name|regs
index|[
name|G14_REGNUM
index|]
condition|)
name|ap
operator|=
name|read_memory_integer
argument_list|(
name|fsr
operator|.
name|regs
index|[
name|G14_REGNUM
index|]
argument_list|,
literal|4
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|must_be_correct
condition|)
return|return
literal|0
return|;
comment|/* Don't cache this result */
if|if
condition|(
name|get_next_frame
argument_list|(
name|frame
argument_list|)
condition|)
name|ap
operator|=
literal|0
expr_stmt|;
else|else
name|ap
operator|=
name|read_register
argument_list|(
name|G14_REGNUM
argument_list|)
expr_stmt|;
if|if
condition|(
name|ap
operator|==
literal|0
condition|)
name|ap
operator|=
name|fi
operator|->
name|frame
expr_stmt|;
block|}
name|fi
operator|->
name|arg_pointer
operator|=
name|ap
expr_stmt|;
comment|/* Cache it for next time */
return|return
name|ap
return|;
block|}
end_function

begin_comment
comment|/* Return the address of the return struct for the frame    described by FI.  Returns 0 if the address is unknown.  */
end_comment

begin_function
name|CORE_ADDR
name|frame_struct_result_address
parameter_list|(
name|fi
parameter_list|)
name|struct
name|frame_info
modifier|*
name|fi
decl_stmt|;
block|{
specifier|register
name|FRAME
name|frame
decl_stmt|;
name|struct
name|frame_saved_regs
name|fsr
decl_stmt|;
name|CORE_ADDR
name|ap
decl_stmt|;
comment|/* If the frame is non-current, check to see if g14 was saved in the      frame by the function prologue code; return the saved value if so,      zero otherwise.  If the frame is current, return the value of g14.       FIXME, shouldn't this use the saved value as long as we are past      the function prologue, and only use the current value if we have      no saved value and are at TOS?   -- gnu@cygnus.com */
name|frame
operator|=
name|FRAME_INFO_ID
argument_list|(
name|fi
argument_list|)
expr_stmt|;
if|if
condition|(
name|get_next_frame
argument_list|(
name|frame
argument_list|)
condition|)
block|{
name|get_frame_saved_regs
argument_list|(
name|fi
argument_list|,
operator|&
name|fsr
argument_list|)
expr_stmt|;
if|if
condition|(
name|fsr
operator|.
name|regs
index|[
name|G13_REGNUM
index|]
condition|)
name|ap
operator|=
name|read_memory_integer
argument_list|(
name|fsr
operator|.
name|regs
index|[
name|G13_REGNUM
index|]
argument_list|,
literal|4
argument_list|)
expr_stmt|;
else|else
name|ap
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|ap
operator|=
name|read_register
argument_list|(
name|G13_REGNUM
argument_list|)
expr_stmt|;
block|}
return|return
name|ap
return|;
block|}
end_function

begin_comment
comment|/* Return address to which the currently executing leafproc will return,    or 0 if ip is not in a leafproc (or if we can't tell if it is).       Do this by finding the starting address of the routine in which ip lies.    If the instruction there is "mov g14, gx" (where x is in [0,7]), this    is a leafproc and the return address is in register gx.  Well, this is    true unless the return address points at a RET instruction in the current    procedure, which indicates that we have a 'dual entry' routine that    has been entered through the CALL entry point.  */
end_comment

begin_function
name|CORE_ADDR
name|leafproc_return
parameter_list|(
name|ip
parameter_list|)
name|CORE_ADDR
name|ip
decl_stmt|;
comment|/* ip from currently executing function	*/
block|{
specifier|register
name|struct
name|minimal_symbol
modifier|*
name|msymbol
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|dst
decl_stmt|;
name|unsigned
name|int
name|insn1
decl_stmt|,
name|insn2
decl_stmt|;
name|CORE_ADDR
name|return_addr
decl_stmt|;
name|char
modifier|*
name|index
parameter_list|()
function_decl|;
if|if
condition|(
operator|(
name|msymbol
operator|=
name|lookup_minimal_symbol_by_pc
argument_list|(
name|ip
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|p
operator|=
name|index
argument_list|(
name|msymbol
operator|->
name|name
argument_list|,
literal|'.'
argument_list|)
operator|)
operator|&&
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|".lf"
argument_list|)
condition|)
block|{
if|if
condition|(
name|next_insn
argument_list|(
name|msymbol
operator|->
name|address
argument_list|,
operator|&
name|insn1
argument_list|,
operator|&
name|insn2
argument_list|)
operator|&&
operator|(
name|insn1
operator|&
literal|0xff87ffff
operator|)
operator|==
literal|0x5c80161e
comment|/* mov g14, gx */
operator|&&
operator|(
name|dst
operator|=
name|REG_SRCDST
argument_list|(
name|insn1
argument_list|)
operator|)
operator|<=
name|G0_REGNUM
operator|+
literal|7
condition|)
block|{
comment|/* Get the return address.  If the "mov g14, gx"  		 instruction hasn't been executed yet, read 		 the return address from g14; otherwise, read it 		 from the register into which g14 was moved.  */
name|return_addr
operator|=
name|read_register
argument_list|(
operator|(
name|ip
operator|==
name|msymbol
operator|->
name|address
operator|)
condition|?
name|G14_REGNUM
else|:
name|dst
argument_list|)
expr_stmt|;
comment|/* We know we are in a leaf procedure, but we don't know 		 whether the caller actually did a "bal" to the ".lf" 		 entry point, or a normal "call" to the non-leaf entry 		 point one instruction before.  In the latter case, the 		 return address will be the address of a "ret" 		 instruction within the procedure itself.  We test for 		 this below.  */
if|if
condition|(
operator|!
name|next_insn
argument_list|(
name|return_addr
argument_list|,
operator|&
name|insn1
argument_list|,
operator|&
name|insn2
argument_list|)
operator|||
operator|(
name|insn1
operator|&
literal|0xff000000
operator|)
operator|!=
literal|0xa000000
comment|/* ret */
operator|||
name|lookup_minimal_symbol_by_pc
argument_list|(
name|return_addr
argument_list|)
operator|!=
name|msymbol
condition|)
return|return
operator|(
name|return_addr
operator|)
return|;
block|}
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Immediately after a function call, return the saved pc.    Can't go through the frames for this because on some machines    the new frame is not set up until the new function executes    some instructions.     On the i960, the frame *is* set up immediately after the call,    unless the function is a leaf procedure.  */
end_comment

begin_function
name|CORE_ADDR
name|saved_pc_after_call
parameter_list|(
name|frame
parameter_list|)
name|FRAME
name|frame
decl_stmt|;
block|{
name|CORE_ADDR
name|saved_pc
decl_stmt|;
name|CORE_ADDR
name|get_frame_pc
parameter_list|()
function_decl|;
name|saved_pc
operator|=
name|leafproc_return
argument_list|(
name|get_frame_pc
argument_list|(
name|frame
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|saved_pc
condition|)
name|saved_pc
operator|=
name|FRAME_SAVED_PC
argument_list|(
name|frame
argument_list|)
expr_stmt|;
return|return
operator|(
name|saved_pc
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Discard from the stack the innermost frame,    restoring all saved registers.  */
end_comment

begin_macro
name|pop_frame
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|frame_info
modifier|*
name|current_fi
decl_stmt|,
modifier|*
name|prev_fi
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|CORE_ADDR
name|save_addr
decl_stmt|;
name|CORE_ADDR
name|leaf_return_addr
decl_stmt|;
name|struct
name|frame_saved_regs
name|fsr
decl_stmt|;
name|char
name|local_regs_buf
index|[
literal|16
operator|*
literal|4
index|]
decl_stmt|;
name|current_fi
operator|=
name|get_frame_info
argument_list|(
name|get_current_frame
argument_list|()
argument_list|)
expr_stmt|;
comment|/* First, undo what the hardware does when we return.      If this is a non-leaf procedure, restore local registers from      the save area in the calling frame.  Otherwise, load the return      address obtained from leafproc_return () into the rip.  */
name|leaf_return_addr
operator|=
name|leafproc_return
argument_list|(
name|current_fi
operator|->
name|pc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|leaf_return_addr
condition|)
block|{
comment|/* Non-leaf procedure.  Restore local registers, incl IP.  */
name|prev_fi
operator|=
name|get_frame_info
argument_list|(
name|get_prev_frame
argument_list|(
name|FRAME_INFO_ID
argument_list|(
name|current_fi
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|read_memory
argument_list|(
name|prev_fi
operator|->
name|frame
argument_list|,
name|local_regs_buf
argument_list|,
sizeof|sizeof
argument_list|(
name|local_regs_buf
argument_list|)
argument_list|)
expr_stmt|;
name|write_register_bytes
argument_list|(
name|REGISTER_BYTE
argument_list|(
name|R0_REGNUM
argument_list|)
argument_list|,
name|local_regs_buf
argument_list|,
sizeof|sizeof
argument_list|(
name|local_regs_buf
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Restore frame pointer.  */
name|write_register
argument_list|(
name|FP_REGNUM
argument_list|,
name|prev_fi
operator|->
name|frame
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Leaf procedure.  Just restore the return address into the IP.  */
name|write_register
argument_list|(
name|RIP_REGNUM
argument_list|,
name|leaf_return_addr
argument_list|)
expr_stmt|;
block|}
comment|/* Now restore any global regs that the current function had saved. */
name|get_frame_saved_regs
argument_list|(
name|current_fi
argument_list|,
operator|&
name|fsr
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|G0_REGNUM
init|;
name|i
operator|<
name|G14_REGNUM
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|save_addr
operator|=
name|fsr
operator|.
name|regs
index|[
name|i
index|]
condition|)
name|write_register
argument_list|(
name|i
argument_list|,
name|read_memory_integer
argument_list|(
name|save_addr
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Flush the frame cache, create a frame for the new innermost frame,      and make it the current frame.  */
name|flush_cached_frames
argument_list|()
expr_stmt|;
name|set_current_frame
argument_list|(
name|create_new_frame
argument_list|(
name|read_register
argument_list|(
name|FP_REGNUM
argument_list|)
argument_list|,
name|read_pc
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Print out text describing a "signal number" with which the i80960 halted.       See the file "fault.c" in the nindy monitor source code for a list    of stop codes.  */
end_comment

begin_function
name|void
name|print_fault
parameter_list|(
name|siggnal
parameter_list|)
name|int
name|siggnal
decl_stmt|;
comment|/* Signal number, as returned by target_wait() */
block|{
specifier|static
name|char
name|unknown
index|[]
init|=
literal|"Unknown fault or trace"
decl_stmt|;
specifier|static
name|char
modifier|*
name|sigmsgs
index|[]
init|=
block|{
comment|/* FAULTS */
literal|"parallel fault"
block|,
comment|/* 0x00 */
name|unknown
block|,
comment|/* 0x01 */
literal|"operation fault"
block|,
comment|/* 0x02 */
literal|"arithmetic fault"
block|,
comment|/* 0x03 */
literal|"floating point fault"
block|,
comment|/* 0x04 */
literal|"constraint fault"
block|,
comment|/* 0x05 */
literal|"virtual memory fault"
block|,
comment|/* 0x06 */
literal|"protection fault"
block|,
comment|/* 0x07 */
literal|"machine fault"
block|,
comment|/* 0x08 */
literal|"structural fault"
block|,
comment|/* 0x09 */
literal|"type fault"
block|,
comment|/* 0x0a */
literal|"reserved (0xb) fault"
block|,
comment|/* 0x0b */
literal|"process fault"
block|,
comment|/* 0x0c */
literal|"descriptor fault"
block|,
comment|/* 0x0d */
literal|"event fault"
block|,
comment|/* 0x0e */
literal|"reserved (0xf) fault"
block|,
comment|/* 0x0f */
comment|/* TRACES */
literal|"single-step trace"
block|,
comment|/* 0x10 */
literal|"branch trace"
block|,
comment|/* 0x11 */
literal|"call trace"
block|,
comment|/* 0x12 */
literal|"return trace"
block|,
comment|/* 0x13 */
literal|"pre-return trace"
block|,
comment|/* 0x14 */
literal|"supervisor call trace"
block|,
comment|/* 0x15 */
literal|"breakpoint trace"
block|,
comment|/* 0x16 */
block|}
decl_stmt|;
define|#
directive|define
name|NUMMSGS
value|((int)( sizeof(sigmsgs) / sizeof(sigmsgs[0]) ))
if|if
condition|(
name|siggnal
operator|<
name|NSIG
condition|)
block|{
name|printf
argument_list|(
literal|"\nProgram received signal %d, %s\n"
argument_list|,
name|siggnal
argument_list|,
name|safe_strsignal
argument_list|(
name|siggnal
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* The various target_wait()s bias the 80960 "signal number" 		   by adding NSIG to it, so it won't get confused with any 		   of the Unix signals elsewhere in GDB.  We need to 		   "unbias" it before using it.  */
name|siggnal
operator|-=
name|NSIG
expr_stmt|;
name|printf
argument_list|(
literal|"Program stopped for reason #%d: %s.\n"
argument_list|,
name|siggnal
argument_list|,
operator|(
name|siggnal
operator|<
name|NUMMSGS
operator|&&
name|siggnal
operator|>=
literal|0
operator|)
condition|?
name|sigmsgs
index|[
name|siggnal
index|]
else|:
name|unknown
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Initialization stub */
end_comment

begin_macro
name|_initialize_i960_tdep
argument_list|()
end_macro

begin_block
block|{
name|check_host
argument_list|()
expr_stmt|;
block|}
end_block

end_unit

