begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1990, 1991, 1992 Regents of the University of California.  * All rights reserved.  *  * Redistribution and use in source and binary forms are permitted  * provided that the above copyright notice and this paragraph are  * duplicated in all such forms and that any documentation,  * advertising materials, and other materials related to such  * distribution and use acknowledge that the software was developed  * by the University of California, Lawrence Berkeley Laboratory,  * Berkeley, CA.  The name of the University may not be used to  * endorse or promote products derived from this software without  * specific prior written permission.  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$Header: remote.c,v 1.3 93/04/26 16:23:50 mccanne Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|<varargs.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"wait.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_include
include|#
directive|include
file|"remote.h"
end_include

begin_include
include|#
directive|include
file|"kgdb_proto.h"
end_include

begin_decl_stmt
specifier|extern
name|struct
name|target_ops
name|remote_ops
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Forward decl */
end_comment

begin_decl_stmt
specifier|static
name|int
name|remote_debugging
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|remote_quiet
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|to_clamp
init|=
literal|8000
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|to_base
init|=
literal|1000
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Eponentially back off a timer value.  Clamp the value at to_clamp.  */
end_comment

begin_define
define|#
directive|define
name|BACKOFF
parameter_list|(
name|to
parameter_list|)
value|((2 * (to)< to_clamp) ? 2 * (to) : to_clamp)
end_define

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|kiodebug
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|icache
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|remote_cache_valid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|remote_instub
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|remote_signal
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|remote_debug
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_msg
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|remote_fn
name|remote_fn
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_char
modifier|*
name|inbuffer
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_char
modifier|*
name|outbuffer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Statistics.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|remote_ierrs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|remote_oerrs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|remote_seqerrs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|remote_spurious
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|PUTCMD
parameter_list|(
name|cmd
parameter_list|)
value|m_xchg(cmd, (u_char *)0, 0, (u_char *)0, (int *)0)
end_define

begin_comment
comment|/*  * Send an outbound message to the remote machine and read the reply.  * Either or both message buffers may be NULL.  */
end_comment

begin_function
specifier|static
name|int
name|m_xchg
parameter_list|(
name|type
parameter_list|,
name|out
parameter_list|,
name|outlen
parameter_list|,
name|in
parameter_list|,
name|inlen
parameter_list|)
name|int
name|type
decl_stmt|;
name|u_char
modifier|*
name|out
decl_stmt|;
name|int
name|outlen
decl_stmt|;
name|u_char
modifier|*
name|in
decl_stmt|;
name|int
modifier|*
name|inlen
decl_stmt|;
block|{
specifier|register
name|int
name|err
decl_stmt|,
name|nrecv
decl_stmt|;
specifier|register
name|int
function_decl|(
modifier|*
name|send
function_decl|)
parameter_list|()
init|=
name|remote_fn
operator|.
name|send
operator|,
parameter_list|(
function_decl|*recv
block|)
parameter_list|()
init|=
name|remote_fn
operator|.
name|recv
function|;
end_function

begin_decl_stmt
name|int
name|ack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_long
name|to
init|=
name|to_base
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|seqbit
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
operator|!
name|remote_instub
condition|)
block|{
name|remote_instub
operator|=
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|PUTCMD
argument_list|(
name|KGDB_EXEC
argument_list|)
expr_stmt|;
block|}
end_if

begin_expr_stmt
name|seqbit
operator|^=
name|KGDB_SEQ
expr_stmt|;
end_expr_stmt

begin_while
while|while
condition|(
literal|1
condition|)
block|{
name|nrecv
operator|=
literal|0
expr_stmt|;
name|err
operator|=
call|(
modifier|*
name|send
call|)
argument_list|(
name|type
operator||
name|seqbit
argument_list|,
name|out
argument_list|,
name|outlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
operator|++
name|remote_oerrs
expr_stmt|;
if|if
condition|(
name|kiodebug
condition|)
name|remote_debug
argument_list|(
literal|"send error %d\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
comment|/* XXX shouldn't we retry the !@#$^*ing send? */
block|}
if|if
condition|(
name|kiodebug
condition|)
name|print_msg
argument_list|(
name|type
operator||
name|seqbit
argument_list|,
name|out
argument_list|,
name|outlen
argument_list|,
literal|'O'
argument_list|)
expr_stmt|;
name|again
label|:
name|err
operator|=
call|(
modifier|*
name|recv
call|)
argument_list|(
operator|&
name|ack
argument_list|,
name|in
argument_list|,
name|inlen
argument_list|,
name|to
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
operator|++
name|remote_ierrs
expr_stmt|;
if|if
condition|(
name|kiodebug
condition|)
name|remote_debug
argument_list|(
literal|"recv error %d\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|remote_cache_valid
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|err
operator|==
name|EKGDB_TIMEOUT
condition|)
block|{
name|to
operator|=
name|BACKOFF
argument_list|(
name|to
argument_list|)
expr_stmt|;
if|if
condition|(
name|to
operator|>=
name|to_clamp
condition|)
name|error
argument_list|(
literal|"remote host not responding"
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|++
name|nrecv
operator|<
literal|5
condition|)
comment|/* 				 * Try to receive five times before 				 * retransmitting. 				 */
goto|goto
name|again
goto|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|kiodebug
condition|)
name|print_msg
argument_list|(
name|ack
argument_list|,
name|in
argument_list|,
name|inlen
condition|?
operator|*
name|inlen
else|:
literal|0
argument_list|,
literal|'I'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ack
operator|&
name|KGDB_ACK
operator|)
operator|==
literal|0
operator|||
name|KGDB_CMD
argument_list|(
name|ack
argument_list|)
operator|!=
name|KGDB_CMD
argument_list|(
name|type
argument_list|)
condition|)
block|{
operator|++
name|remote_spurious
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|ack
operator|&
name|KGDB_SEQ
operator|)
operator|^
name|seqbit
condition|)
block|{
operator|++
name|remote_seqerrs
expr_stmt|;
goto|goto
name|again
goto|;
block|}
return|return
name|ack
return|;
block|}
end_while

begin_comment
unit|}
comment|/*  * Wait for the specified message type.  Discard anything else.  * (this is used by 'remote-signal' to help us resync with other side.)  */
end_comment

begin_function
unit|static
name|void
name|m_recv
parameter_list|(
name|type
parameter_list|,
name|in
parameter_list|,
name|inlen
parameter_list|)
name|int
name|type
decl_stmt|;
name|u_char
modifier|*
name|in
decl_stmt|;
name|int
modifier|*
name|inlen
decl_stmt|;
block|{
name|int
name|reply
decl_stmt|,
name|err
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|err
operator|=
call|(
modifier|*
name|remote_fn
operator|.
name|recv
call|)
argument_list|(
operator|&
name|reply
argument_list|,
name|in
argument_list|,
name|inlen
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
operator|++
name|remote_ierrs
expr_stmt|;
if|if
condition|(
name|kiodebug
condition|)
name|remote_debug
argument_list|(
literal|"recv error %d\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|kiodebug
condition|)
name|print_msg
argument_list|(
name|reply
argument_list|,
name|in
argument_list|,
name|inlen
condition|?
operator|*
name|inlen
else|:
literal|0
argument_list|,
literal|'I'
argument_list|)
expr_stmt|;
if|if
condition|(
name|KGDB_CMD
argument_list|(
name|reply
argument_list|)
operator|==
name|type
condition|)
return|return;
operator|++
name|remote_spurious
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Send a message.  Do not wait for *any* response from the other side.  * Some other thread of control will pick up the ack that will be generated.  */
end_comment

begin_function
specifier|static
name|void
name|m_send
parameter_list|(
name|type
parameter_list|,
name|buf
parameter_list|,
name|len
parameter_list|)
name|int
name|type
decl_stmt|;
name|u_char
modifier|*
name|buf
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|int
name|err
decl_stmt|;
if|if
condition|(
operator|!
name|remote_instub
condition|)
block|{
name|remote_instub
operator|=
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|PUTCMD
argument_list|(
name|KGDB_EXEC
argument_list|)
expr_stmt|;
block|}
name|err
operator|=
call|(
modifier|*
name|remote_fn
operator|.
name|send
call|)
argument_list|(
name|type
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
operator|++
name|remote_ierrs
expr_stmt|;
if|if
condition|(
name|kiodebug
condition|)
name|remote_debug
argument_list|(
literal|"[send error %d] "
argument_list|,
name|err
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|kiodebug
condition|)
name|print_msg
argument_list|(
name|type
argument_list|,
name|buf
argument_list|,
name|len
argument_list|,
literal|'O'
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|start_remote
parameter_list|()
block|{
name|init_wait_for_inferior
argument_list|()
expr_stmt|;
name|remote_go
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|restart_remote
parameter_list|()
block|{
name|init_wait_for_inferior_keep_brkpts
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|notdef
name|inferior_pid
operator|=
literal|3
expr_stmt|;
endif|#
directive|endif
name|remote_go
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|remote_bail
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|printf
argument_list|(
literal|"Remote attach interrupted.\n"
argument_list|)
expr_stmt|;
name|remote_quiet
operator|=
literal|1
expr_stmt|;
name|pop_target
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Open a connection to a remote debugger.  * NAME is the filename used for communication.  */
end_comment

begin_function
name|void
name|remote_open
parameter_list|(
name|name
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
specifier|extern
name|void
name|sl_open
argument_list|()
decl_stmt|,
name|fp_open
argument_list|()
decl_stmt|;
name|void
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|()
function_decl|;
name|struct
name|cleanup
modifier|*
name|chain
decl_stmt|;
if|if
condition|(
name|name
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"\ To open a remote debug connection, you need to specify what serial\n\ device is attached to the remote system (e.g. /dev/ttya).\ "
argument_list|)
expr_stmt|;
if|if
condition|(
name|remote_debugging
condition|)
name|error
argument_list|(
literal|"Already remote debugging.  Detach first.\n"
argument_list|)
expr_stmt|;
name|target_preopen
argument_list|(
name|from_tty
argument_list|)
expr_stmt|;
comment|/* Right now, we only support fastpath and serial debugging */
ifndef|#
directive|ifndef
name|NOFASTPATH
if|if
condition|(
operator|*
name|name
operator|==
literal|'@'
condition|)
block|{
operator|++
name|name
expr_stmt|;
name|func
operator|=
name|fp_open
expr_stmt|;
block|}
else|else
endif|#
directive|endif
name|func
operator|=
name|sl_open
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|remote_fn
argument_list|,
sizeof|sizeof
argument_list|(
name|remote_fn
argument_list|)
argument_list|)
expr_stmt|;
call|(
modifier|*
name|func
call|)
argument_list|(
name|name
argument_list|,
operator|&
name|remote_fn
argument_list|)
expr_stmt|;
if|if
condition|(
name|from_tty
condition|)
name|printf
argument_list|(
literal|"Remote debugging using %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|remote_debugging
operator|=
literal|1
expr_stmt|;
name|remote_cache_valid
operator|=
literal|0
expr_stmt|;
comment|/* remote protocol limits max data to one byte */
if|if
condition|(
name|remote_fn
operator|.
name|maxdata
operator|>
literal|255
condition|)
name|remote_fn
operator|.
name|maxdata
operator|=
literal|255
expr_stmt|;
comment|/* allocate msg buffers */
name|inbuffer
operator|=
operator|(
name|u_char
operator|*
operator|)
name|malloc
argument_list|(
name|remote_fn
operator|.
name|rpcsize
argument_list|)
expr_stmt|;
name|outbuffer
operator|=
operator|(
name|u_char
operator|*
operator|)
name|malloc
argument_list|(
name|remote_fn
operator|.
name|rpcsize
argument_list|)
expr_stmt|;
name|chain
operator|=
name|make_cleanup
argument_list|(
name|remote_bail
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|push_target
argument_list|(
operator|&
name|remote_ops
argument_list|)
expr_stmt|;
name|remote_ierrs
operator|=
literal|0
expr_stmt|;
name|remote_oerrs
operator|=
literal|0
expr_stmt|;
name|remote_spurious
operator|=
literal|0
expr_stmt|;
comment|/* 	 * XXX 	 * Signal the remote kernel and set things up 	 * so gdb views it as a process. 	 */
name|remote_signal
argument_list|()
expr_stmt|;
name|start_remote
argument_list|()
expr_stmt|;
name|discard_cleanups
argument_list|(
name|chain
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Take the remote kernel out of debugging mode.  */
end_comment

begin_function
name|void
name|remote_kill
parameter_list|()
block|{
comment|/* XXX 	 * Clear all breakpoints. 	 * It's a very, very bad idea to go away leaving 	 * breakpoints in a remote kernel or to leave it 	 * stopped at a breakpoint. 	 */
name|clear_breakpoints
argument_list|()
expr_stmt|;
comment|/* 	 * Take remote machine out of debug mode. 	 */
operator|(
name|void
operator|)
name|PUTCMD
argument_list|(
name|KGDB_KILL
argument_list|)
expr_stmt|;
name|remote_debugging
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Close the open connection to the remote debugger. Use this when you want  * to detach and do something else with your gdb.  */
end_comment

begin_function
name|void
name|remote_detach
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
if|if
condition|(
name|args
condition|)
block|{
if|if
condition|(
name|args
index|[
literal|0
index|]
operator|==
literal|'q'
condition|)
name|remote_quiet
operator|=
literal|1
expr_stmt|;
else|else
name|error
argument_list|(
literal|"Bad argument to remote \"detach\"."
argument_list|)
expr_stmt|;
block|}
comment|/* this will invoke remote_close() */
name|pop_target
argument_list|()
expr_stmt|;
if|if
condition|(
name|from_tty
condition|)
name|printf
argument_list|(
literal|"Ending remote debugging.\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|remote_close
parameter_list|(
name|quitting
parameter_list|)
name|int
name|quitting
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|notdef
if|if
condition|(
operator|!
name|remote_debugging
condition|)
name|error
argument_list|(
literal|"Remote debugging not enabled"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|remote_quiet
condition|)
block|{
name|remote_quiet
operator|=
literal|0
expr_stmt|;
name|remote_kill
argument_list|()
expr_stmt|;
block|}
else|else
name|remote_debugging
operator|=
literal|0
expr_stmt|;
call|(
name|void
call|)
argument_list|(
operator|*
name|remote_fn
operator|.
name|close
argument_list|)
argument_list|()
expr_stmt|;
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|inbuffer
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|outbuffer
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Tell the remote machine to resume.  */
end_comment

begin_function
name|void
name|remote_resume
parameter_list|(
name|step
parameter_list|,
name|sig
parameter_list|)
name|int
name|step
decl_stmt|,
name|sig
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|notdef
if|if
condition|(
name|sig
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|"Cannot signal a remote system"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|step
condition|)
block|{
operator|(
name|void
operator|)
name|PUTCMD
argument_list|(
name|KGDB_CONT
argument_list|)
expr_stmt|;
name|remote_instub
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|NO_SINGLE_STEP
name|single_step
argument_list|(
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|PUTCMD
argument_list|(
name|KGDB_STEP
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function

begin_comment
comment|/*  * Wait until the remote machine stops, then return, storing status in STATUS  * just as `wait' would.  */
end_comment

begin_function
name|int
name|remote_wait
parameter_list|(
name|status
parameter_list|)
name|WAITTYPE
modifier|*
name|status
decl_stmt|;
block|{
name|int
name|len
decl_stmt|;
name|WSETEXIT
argument_list|(
operator|(
operator|*
name|status
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * When the machine stops, it will send us a KGDB_SIGNAL message, 	 * so we wait for one of these. 	 */
name|m_recv
argument_list|(
name|KGDB_SIGNAL
argument_list|,
name|inbuffer
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
name|WSETSTOP
argument_list|(
operator|(
operator|*
name|status
operator|)
argument_list|,
name|inbuffer
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* 	 * Let the machine dependent module have a chance to  	 * lookup current process context etc. 	 */
name|set_curproc
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Register context as of last remote_fetch_registers().  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|reg_cache
index|[
name|REGISTER_BYTES
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
name|registers
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Read the remote registers into the block REGS.  */
end_comment

begin_comment
comment|/* XXX Currently we just read all the registers, so we don't use regno.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|void
name|remote_fetch_registers
parameter_list|(
name|unused_regno
parameter_list|)
name|int
name|unused_regno
decl_stmt|;
block|{
name|int
name|regno
decl_stmt|,
name|len
decl_stmt|,
name|rlen
decl_stmt|,
name|ack
decl_stmt|;
name|u_char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|ep
decl_stmt|;
name|regno
operator|=
operator|-
literal|1
expr_stmt|;
do|do
block|{
name|outbuffer
index|[
literal|0
index|]
operator|=
name|regno
operator|+
literal|1
expr_stmt|;
name|ack
operator|=
name|m_xchg
argument_list|(
name|remote_cache_valid
condition|?
name|KGDB_REG_R
operator||
name|KGDB_DELTA
else|:
name|KGDB_REG_R
argument_list|,
name|outbuffer
argument_list|,
literal|1
argument_list|,
name|inbuffer
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
name|cp
operator|=
name|inbuffer
expr_stmt|;
name|ep
operator|=
name|cp
operator|+
name|len
expr_stmt|;
while|while
condition|(
name|cp
operator|<
name|ep
condition|)
block|{
name|regno
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
name|rlen
operator|=
name|REGISTER_RAW_SIZE
argument_list|(
name|regno
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|cp
argument_list|,
operator|&
name|reg_cache
index|[
name|REGISTER_BYTE
argument_list|(
name|regno
argument_list|)
index|]
argument_list|,
name|rlen
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|rlen
expr_stmt|;
block|}
block|}
do|while
condition|(
name|ack
operator|&
name|KGDB_MORE
condition|)
do|;
name|remote_cache_valid
operator|=
literal|1
expr_stmt|;
name|bcopy
argument_list|(
name|reg_cache
argument_list|,
name|registers
argument_list|,
name|REGISTER_BYTES
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Store the remote registers from the contents of the block REGS.  */
end_comment

begin_comment
comment|/* XXX Currently we just read all the registers, so we don't use regno.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|void
name|remote_store_registers
parameter_list|(
name|unused_regno
parameter_list|)
name|int
name|unused_regno
decl_stmt|;
block|{
name|char
modifier|*
name|regs
init|=
name|registers
decl_stmt|;
name|u_char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|ep
decl_stmt|;
name|int
name|regno
decl_stmt|,
name|off
decl_stmt|,
name|rlen
decl_stmt|;
name|cp
operator|=
name|outbuffer
expr_stmt|;
name|ep
operator|=
name|cp
operator|+
name|remote_fn
operator|.
name|maxdata
expr_stmt|;
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|NUM_REGS
condition|;
operator|++
name|regno
control|)
block|{
name|off
operator|=
name|REGISTER_BYTE
argument_list|(
name|regno
argument_list|)
expr_stmt|;
name|rlen
operator|=
name|REGISTER_RAW_SIZE
argument_list|(
name|regno
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|remote_cache_valid
operator|||
name|bcmp
argument_list|(
operator|&
name|regs
index|[
name|off
index|]
argument_list|,
operator|&
name|reg_cache
index|[
name|off
index|]
argument_list|,
name|rlen
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|cp
operator|+
name|rlen
operator|+
literal|1
operator|>=
name|ep
condition|)
block|{
operator|(
name|void
operator|)
name|m_xchg
argument_list|(
name|KGDB_REG_W
argument_list|,
name|outbuffer
argument_list|,
name|cp
operator|-
name|outbuffer
argument_list|,
operator|(
name|u_char
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|int
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|cp
operator|=
name|outbuffer
expr_stmt|;
block|}
operator|*
name|cp
operator|++
operator|=
name|regno
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|regs
index|[
name|off
index|]
argument_list|,
operator|(
name|caddr_t
operator|)
name|cp
argument_list|,
name|rlen
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|rlen
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cp
operator|!=
name|outbuffer
condition|)
operator|(
name|void
operator|)
name|m_xchg
argument_list|(
name|KGDB_REG_W
argument_list|,
name|outbuffer
argument_list|,
name|cp
operator|-
name|outbuffer
argument_list|,
operator|(
name|u_char
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|int
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|regs
argument_list|,
name|reg_cache
argument_list|,
name|REGISTER_BYTES
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * XXX DOES THE NEW PROTOCOL NEED THIS?  * Prepare to store registers.  Since we send them all, we have to  * read out the ones we don't want to change first.  */
end_comment

begin_function
name|void
name|remote_prepare_to_store
parameter_list|()
block|{
name|remote_fetch_registers
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Store a chunk of memory into the remote host.  * 'remote_addr' is the address in the remote memory space.  * 'cp' is the address of the buffer in our space, and 'len' is  * the number of bytes.  Returns an errno status.  */
end_comment

begin_function
name|int
name|remote_write
parameter_list|(
name|addr
parameter_list|,
name|cp
parameter_list|,
name|len
parameter_list|)
name|CORE_ADDR
name|addr
decl_stmt|;
name|u_char
modifier|*
name|cp
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|int
name|cnt
decl_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
comment|/* XXX assumes sizeof(CORE_ADDR) is 4? */
name|cnt
operator|=
name|min
argument_list|(
name|len
argument_list|,
name|remote_fn
operator|.
name|maxdata
operator|-
literal|4
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|addr
argument_list|,
operator|(
name|caddr_t
operator|)
name|outbuffer
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|SWAP_TARGET_AND_HOST
argument_list|(
name|outbuffer
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|cp
argument_list|,
operator|(
name|caddr_t
operator|)
name|outbuffer
operator|+
literal|4
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|m_xchg
argument_list|(
name|KGDB_MEM_W
argument_list|,
name|outbuffer
argument_list|,
name|cnt
operator|+
literal|4
argument_list|,
name|inbuffer
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|inbuffer
index|[
literal|0
index|]
condition|)
return|return
operator|(
name|inbuffer
index|[
literal|0
index|]
operator|)
return|;
name|addr
operator|+=
name|cnt
expr_stmt|;
name|cp
operator|+=
name|cnt
expr_stmt|;
name|len
operator|-=
name|cnt
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Read memory data directly from the remote machine.  * 'addr' is the address in the remote memory space.  * 'cp' is the address of the buffer in our space, and 'len' is  * the number of bytes.  Returns an errno status.  */
end_comment

begin_comment
comment|/* XXX is this really needed? */
end_comment

begin_function
specifier|static
name|int
name|remote_read
parameter_list|(
name|addr
parameter_list|,
name|cp
parameter_list|,
name|len
parameter_list|)
name|CORE_ADDR
name|addr
decl_stmt|;
name|u_char
modifier|*
name|cp
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|int
name|cnt
decl_stmt|,
name|inlen
decl_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|cnt
operator|=
name|min
argument_list|(
name|len
argument_list|,
name|remote_fn
operator|.
name|maxdata
argument_list|)
expr_stmt|;
name|outbuffer
index|[
literal|0
index|]
operator|=
name|cnt
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|addr
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|outbuffer
index|[
literal|1
index|]
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|SWAP_TARGET_AND_HOST
argument_list|(
operator|&
name|outbuffer
index|[
literal|1
index|]
argument_list|,
literal|4
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|m_xchg
argument_list|(
name|KGDB_MEM_R
argument_list|,
name|outbuffer
argument_list|,
literal|5
argument_list|,
name|inbuffer
argument_list|,
operator|&
name|inlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|inlen
operator|<
literal|1
condition|)
name|error
argument_list|(
literal|"remote_read(): remote protocol botch"
argument_list|)
expr_stmt|;
comment|/* Return errno from remote side */
if|if
condition|(
name|inbuffer
index|[
literal|0
index|]
condition|)
return|return
operator|(
name|inbuffer
index|[
literal|0
index|]
operator|)
return|;
operator|--
name|inlen
expr_stmt|;
if|if
condition|(
name|inlen
operator|<=
literal|0
condition|)
name|error
argument_list|(
literal|"remote_read(): inlen too small (%d)"
argument_list|,
name|inlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|inlen
operator|>
name|cnt
condition|)
block|{
name|printf
argument_list|(
literal|"remote_read(): warning: asked for %d, got %d\n"
argument_list|,
name|cnt
argument_list|,
name|inlen
argument_list|)
expr_stmt|;
name|inlen
operator|=
name|cnt
expr_stmt|;
block|}
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|inbuffer
index|[
literal|1
index|]
argument_list|,
operator|(
name|caddr_t
operator|)
name|cp
argument_list|,
name|inlen
argument_list|)
expr_stmt|;
name|addr
operator|+=
name|inlen
expr_stmt|;
name|cp
operator|+=
name|inlen
expr_stmt|;
name|len
operator|-=
name|inlen
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|remote_read_text
parameter_list|(
name|addr
parameter_list|,
name|cp
parameter_list|,
name|len
parameter_list|,
name|target
parameter_list|)
name|CORE_ADDR
name|addr
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|len
decl_stmt|;
name|struct
name|target_ops
modifier|*
name|target
decl_stmt|;
block|{
specifier|register
name|int
name|cc
decl_stmt|;
comment|/* 	 * Look down the target stack (we're on top) for the text file. 	 * If it can transfer the whole chunk, let it.  Otherwise, 	 * revert to the remote call. 	 */
for|for
control|(
init|;
name|target
operator|!=
literal|0
condition|;
name|target
operator|=
name|target
operator|->
name|to_next
control|)
block|{
if|if
condition|(
name|target
operator|->
name|to_stratum
operator|!=
name|file_stratum
condition|)
continue|continue;
name|cc
operator|=
name|target
operator|->
name|to_xfer_memory
argument_list|(
name|addr
argument_list|,
name|cp
argument_list|,
name|len
argument_list|,
literal|0
argument_list|,
name|target
argument_list|)
expr_stmt|;
if|if
condition|(
name|cc
operator|==
name|len
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|remote_read
argument_list|(
name|addr
argument_list|,
name|cp
argument_list|,
name|len
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Read or write LEN bytes from inferior memory at MEMADDR, transferring  * to or from debugger address MYADDR.  Write to inferior if SHOULD_WRITE is  * nonzero.  Returns length of data written or read; 0 for error.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|remote_xfer_memory
parameter_list|(
name|addr
parameter_list|,
name|cp
parameter_list|,
name|len
parameter_list|,
name|should_write
parameter_list|,
name|target
parameter_list|)
specifier|register
name|CORE_ADDR
name|addr
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
name|int
name|should_write
decl_stmt|;
name|struct
name|target_ops
modifier|*
name|target
decl_stmt|;
block|{
specifier|register
name|int
name|st
decl_stmt|;
if|if
condition|(
name|should_write
condition|)
name|st
operator|=
name|remote_write
argument_list|(
name|addr
argument_list|,
name|cp
argument_list|,
name|len
argument_list|)
expr_stmt|;
else|else
block|{
ifdef|#
directive|ifdef
name|NEED_TEXT_START_END
specifier|extern
name|CORE_ADDR
name|text_start
decl_stmt|,
name|text_end
decl_stmt|;
name|st
operator|=
operator|(
name|icache
operator|&&
name|addr
operator|>=
name|text_start
operator|&&
name|addr
operator|+
name|len
operator|<=
name|text_end
operator|)
condition|?
name|remote_read_text
argument_list|(
name|addr
argument_list|,
name|cp
argument_list|,
name|len
argument_list|,
name|target
argument_list|)
else|:
name|remote_read
argument_list|(
name|addr
argument_list|,
name|cp
argument_list|,
name|len
argument_list|)
expr_stmt|;
else|#
directive|else
name|st
operator|=
name|remote_read
argument_list|(
name|addr
argument_list|,
name|cp
argument_list|,
name|len
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
return|return
operator|(
operator|(
name|st
operator|==
literal|0
operator|)
condition|?
name|len
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Signal the remote machine.  The remote end might be idle or it might  * already be in debug mode -- we need to handle both case.  Thus, we use  * the framing character as the wakeup byte, and send a SIGNAL packet.  * If the remote host is idle, the framing character will wake it up.  * If it is in the kgdb stub, then we will get a SIGNAL reply.  */
end_comment

begin_function
specifier|static
name|void
name|remote_signal
parameter_list|()
block|{
if|if
condition|(
operator|!
name|remote_debugging
condition|)
name|printf
argument_list|(
literal|"Remote agent not active.\n"
argument_list|)
expr_stmt|;
else|else
block|{
name|remote_instub
operator|=
literal|0
expr_stmt|;
name|m_send
argument_list|(
name|KGDB_SIGNAL
argument_list|,
operator|(
name|u_char
operator|*
operator|)
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|remote_signal_command
parameter_list|()
block|{
if|if
condition|(
operator|!
name|remote_debugging
condition|)
name|error
argument_list|(
literal|"Remote agent not active.\n"
argument_list|)
expr_stmt|;
name|remote_cache_valid
operator|=
literal|0
expr_stmt|;
name|remote_signal
argument_list|()
expr_stmt|;
name|restart_remote
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Print a message for debugging.  */
end_comment

begin_function
specifier|static
name|void
name|print_msg
parameter_list|(
name|type
parameter_list|,
name|buf
parameter_list|,
name|len
parameter_list|,
name|dir
parameter_list|)
name|int
name|type
decl_stmt|;
name|u_char
modifier|*
name|buf
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|dir
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
switch|switch
condition|(
name|KGDB_CMD
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|KGDB_MEM_R
case|:
name|s
operator|=
literal|"memr"
expr_stmt|;
break|break;
case|case
name|KGDB_MEM_W
case|:
name|s
operator|=
literal|"memw"
expr_stmt|;
break|break;
case|case
name|KGDB_REG_R
case|:
name|s
operator|=
literal|"regr"
expr_stmt|;
break|break;
case|case
name|KGDB_REG_W
case|:
name|s
operator|=
literal|"regw"
expr_stmt|;
break|break;
case|case
name|KGDB_CONT
case|:
name|s
operator|=
literal|"cont"
expr_stmt|;
break|break;
case|case
name|KGDB_STEP
case|:
name|s
operator|=
literal|"step"
expr_stmt|;
break|break;
case|case
name|KGDB_KILL
case|:
name|s
operator|=
literal|"kill"
expr_stmt|;
break|break;
case|case
name|KGDB_SIGNAL
case|:
name|s
operator|=
literal|"sig "
expr_stmt|;
break|break;
case|case
name|KGDB_EXEC
case|:
name|s
operator|=
literal|"exec"
expr_stmt|;
break|break;
default|default:
name|s
operator|=
literal|"unk "
expr_stmt|;
break|break;
block|}
name|remote_debug
argument_list|(
literal|"%c %c%c%c%c %s (%02x): "
argument_list|,
name|dir
argument_list|,
operator|(
name|type
operator|&
name|KGDB_ACK
operator|)
condition|?
literal|'A'
else|:
literal|'.'
argument_list|,
operator|(
name|type
operator|&
name|KGDB_DELTA
operator|)
condition|?
literal|'D'
else|:
literal|'.'
argument_list|,
operator|(
name|type
operator|&
name|KGDB_MORE
operator|)
condition|?
literal|'M'
else|:
literal|'.'
argument_list|,
operator|(
name|type
operator|&
name|KGDB_SEQ
operator|)
condition|?
literal|'-'
else|:
literal|'+'
argument_list|,
name|s
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
control|)
name|remote_debug
argument_list|(
literal|"%02x"
argument_list|,
name|buf
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|remote_debug
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|remote_debug_command
parameter_list|(
name|arg
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
name|kiodebug
operator|!=
literal|0
operator|&&
name|kiodebug
operator|!=
name|stderr
condition|)
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|kiodebug
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
operator|==
literal|0
condition|)
block|{
name|kiodebug
operator|=
literal|0
expr_stmt|;
name|printf
argument_list|(
literal|"Remote debugging off.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|arg
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
name|kiodebug
operator|=
name|stderr
expr_stmt|;
name|name
operator|=
literal|"stderr"
expr_stmt|;
block|}
else|else
block|{
name|kiodebug
operator|=
name|fopen
argument_list|(
name|arg
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|kiodebug
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Cannot open '%s'.\n"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return;
block|}
name|name
operator|=
name|arg
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"Remote debugging output routed to %s.\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|remote_files_info
parameter_list|()
block|{
name|printf
argument_list|(
literal|"Using %s for text references.\n"
argument_list|,
name|icache
condition|?
literal|"local executable"
else|:
literal|"remote"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Protocol debugging is %s.\n"
argument_list|,
name|kiodebug
condition|?
literal|"on"
else|:
literal|"off"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%d spurious input messages.\n"
argument_list|,
name|remote_spurious
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%d input errors; %d output errors; %d sequence errors.\n"
argument_list|,
name|remote_ierrs
argument_list|,
name|remote_oerrs
argument_list|,
name|remote_seqerrs
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* VARARGS */
end_comment

begin_function
specifier|static
name|void
name|remote_debug
parameter_list|(
name|va_alist
parameter_list|)
function|va_dcl
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|cp
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|vfprintf
argument_list|(
name|kiodebug
argument_list|,
name|cp
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|kiodebug
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Define the target subroutine names */
end_comment

begin_decl_stmt
name|struct
name|target_ops
name|remote_ops
init|=
block|{
literal|"remote"
block|,
comment|/* shortname */
literal|"Remote serial target in gdb-specific protocol"
block|,
comment|/* longname */
literal|"Debug a remote host, using a gdb-specific protocol.\n\ Specify the target as an argument (e.g. /dev/ttya for a serial link).\n\ Use \"detach\" or \"quit\" to end remote debugging gracefully, which\n\ removes breakpoints from and resumes the remote kernel.\n\ Use \"detach quiet\" to end remote debugging with no negotiation.\n\ This latter method is desirable, for instance, when the remote kernel\n\ has crashed and messages from gdb could wreak havoc.\n"
block|,
name|remote_open
block|,
comment|/* open */
name|remote_close
block|,
comment|/* close */
literal|0
block|,
comment|/* attach */
name|remote_detach
block|,
comment|/* detach */
name|remote_resume
block|,
comment|/* resume */
name|remote_wait
block|,
comment|/* wait */
name|remote_fetch_registers
block|,
comment|/* fetch_registers */
name|remote_store_registers
block|,
comment|/* store_registers */
name|remote_prepare_to_store
block|,
comment|/* prepare_to_store */
name|remote_xfer_memory
block|,
comment|/* xfer_memory */
name|remote_files_info
block|,
comment|/* files_info */
literal|0
block|,
comment|/* insert_breakpoint */
literal|0
block|,
comment|/* remove_breakpoint */
literal|0
block|,
comment|/* terminal_init */
literal|0
block|,
comment|/* terminal_inferior */
literal|0
block|,
comment|/* terminal_ours_for_output */
literal|0
block|,
comment|/* terminal_ours */
literal|0
block|,
comment|/* terminal_info */
name|remote_kill
block|,
comment|/* kill */
literal|0
block|,
comment|/* load */
literal|0
block|,
comment|/* lookup_symbol */
literal|0
block|,
comment|/* create_inferior */
literal|0
block|,
comment|/* mourn_inferior */
literal|0
block|,
comment|/* can_run */
literal|0
block|,
comment|/* notice_signals */
name|process_stratum
block|,
comment|/* stratum */
literal|0
block|,
comment|/* next */
literal|1
block|,
comment|/* has_all_memory */
literal|1
block|,
comment|/* has_memory */
literal|1
block|,
comment|/* has_stack */
literal|1
block|,
comment|/* has_registers */
literal|1
block|,
comment|/* has_execution XXX can't start an inferior */
literal|0
block|,
comment|/* sections */
literal|0
block|,
comment|/* sections_end */
name|OPS_MAGIC
block|,
comment|/* magic */
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|_initialize_remote
parameter_list|()
block|{
name|struct
name|cmd_list_element
modifier|*
name|c
decl_stmt|;
specifier|extern
name|struct
name|cmd_list_element
modifier|*
name|setlist
decl_stmt|;
name|add_com
argument_list|(
literal|"remote-signal"
argument_list|,
name|class_run
argument_list|,
name|remote_signal_command
argument_list|,
literal|"If remote debugging, send interrupt signal to remote."
argument_list|)
expr_stmt|;
name|c
operator|=
name|add_set_cmd
argument_list|(
literal|"remote-text-refs"
argument_list|,
name|class_support
argument_list|,
name|var_boolean
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|icache
argument_list|,
literal|"Set use of local executable for text segment references.\n\ If on, all memory read/writes go to remote.\n\ If off, text segment reads use the local executable."
argument_list|,
operator|&
name|setlist
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|c
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|c
operator|=
name|add_set_cmd
argument_list|(
literal|"remote-timeout"
argument_list|,
name|class_support
argument_list|,
name|var_uinteger
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|to_base
argument_list|,
literal|"Set remote timeout interval (in msec).  The gdb remote protocol\n\ uses an exponential backoff retransmit timer that begins initialized\n\ to this value (on each transmission)."
argument_list|,
operator|&
name|setlist
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|c
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"remote-debug"
argument_list|,
name|class_run
argument_list|,
name|remote_debug_command
argument_list|,
literal|"With a file name argument, enables output of remote protocol debugging\n\ messages to said file.  If file is `-', stderr is used.\n\ With no argument, remote debugging is disabled."
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|notdef
name|add_info
argument_list|(
literal|"remote"
argument_list|,
name|remote_info
argument_list|,
literal|"Show current settings of remote debugging options."
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|add_target
argument_list|(
operator|&
name|remote_ops
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

