begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Machine independent support for SVR4 /proc (process file system) for GDB.    Copyright 1991, 1992 Free Software Foundation, Inc.    Written by Fred Fish at Cygnus Support.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/*			N  O  T  E  S  For information on the details of using /proc consult section proc(4) in the UNIX System V Release 4 System Administrator's Reference Manual.  The general register and floating point register sets are manipulated by separate ioctl's.  This file makes the assumption that if FP0_REGNUM is defined, then support for the floating point register set is desired, regardless of whether or not the actual target has floating point hardware.   */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|<sys/procfs.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"command.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"nm.h"
end_include

begin_define
define|#
directive|define
name|MAX_SYSCALLS
value|256
end_define

begin_comment
comment|/* Maximum number of syscalls for table */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|PROC_NAME_FMT
end_ifndef

begin_define
define|#
directive|define
name|PROC_NAME_FMT
value|"/proc/%05d"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|struct
name|target_ops
name|procfs_ops
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Forward declaration */
end_comment

begin_if
if|#
directive|if
literal|1
end_if

begin_comment
comment|/* FIXME: Gross and ugly hack to resolve coredep.c global */
end_comment

begin_decl_stmt
name|CORE_ADDR
name|kernel_u_addr
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|BROKEN_SIGINFO_H
end_ifdef

begin_comment
comment|/* Workaround broken SGS<sys/siginfo.h> */
end_comment

begin_undef
undef|#
directive|undef
name|si_pid
end_undef

begin_define
define|#
directive|define
name|si_pid
value|_data._proc.pid
end_define

begin_undef
undef|#
directive|undef
name|si_uid
end_undef

begin_define
define|#
directive|define
name|si_uid
value|_data._proc._pdata._kill.uid
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* BROKEN_SIGINFO_H */
end_comment

begin_comment
comment|/*  All access to the inferior, either one started by gdb or one that has     been attached to, is controlled by an instance of a procinfo structure,     defined below.  Since gdb currently only handles one inferior at a time,     the procinfo structure for the inferior is statically allocated and     only one exists at any given time.  There is a separate procinfo     structure for use by the "info proc" command, so that we can print     useful information about any random process without interfering with     the inferior's procinfo information. */
end_comment

begin_struct
struct|struct
name|procinfo
block|{
name|int
name|valid
decl_stmt|;
comment|/* Nonzero if pid, fd,& pathname are valid */
name|int
name|pid
decl_stmt|;
comment|/* Process ID of inferior */
name|int
name|fd
decl_stmt|;
comment|/* File descriptor for /proc entry */
name|char
modifier|*
name|pathname
decl_stmt|;
comment|/* Pathname to /proc entry */
name|int
name|was_stopped
decl_stmt|;
comment|/* Nonzero if was stopped prior to attach */
name|int
name|nopass_next_sigstop
decl_stmt|;
comment|/* Don't pass a sigstop on next resume */
name|prrun_t
name|prrun
decl_stmt|;
comment|/* Control state when it is run */
name|prstatus_t
name|prstatus
decl_stmt|;
comment|/* Current process status info */
name|gregset_t
name|gregset
decl_stmt|;
comment|/* General register set */
name|fpregset_t
name|fpregset
decl_stmt|;
comment|/* Floating point register set */
name|fltset_t
name|fltset
decl_stmt|;
comment|/* Current traced hardware fault set */
name|sigset_t
name|trace
decl_stmt|;
comment|/* Current traced signal set */
name|sysset_t
name|exitset
decl_stmt|;
comment|/* Current traced system call exit set */
name|sysset_t
name|entryset
decl_stmt|;
comment|/* Current traced system call entry set */
name|fltset_t
name|saved_fltset
decl_stmt|;
comment|/* Saved traced hardware fault set */
name|sigset_t
name|saved_trace
decl_stmt|;
comment|/* Saved traced signal set */
name|sigset_t
name|saved_sighold
decl_stmt|;
comment|/* Saved held signal set */
name|sysset_t
name|saved_exitset
decl_stmt|;
comment|/* Saved traced system call exit set */
name|sysset_t
name|saved_entryset
decl_stmt|;
comment|/* Saved traced system call entry set */
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|procinfo
name|pi
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Inferior's process information */
end_comment

begin_comment
comment|/*  Much of the information used in the /proc interface, particularly for     printing status information, is kept as tables of structures of the     following form.  These tables can be used to map numeric values to     their symbolic names and to a string that describes their specific use. */
end_comment

begin_struct
struct|struct
name|trans
block|{
name|int
name|value
decl_stmt|;
comment|/* The numeric value */
name|char
modifier|*
name|name
decl_stmt|;
comment|/* The equivalent symbolic value */
name|char
modifier|*
name|desc
decl_stmt|;
comment|/* Short description of value */
block|}
struct|;
end_struct

begin_comment
comment|/*  Translate bits in the pr_flags member of the prstatus structure, into the     names and desc information. */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|trans
name|pr_flag_table
index|[]
init|=
block|{
if|#
directive|if
name|defined
argument_list|(
name|PR_STOPPED
argument_list|)
name|PR_STOPPED
block|,
literal|"PR_STOPPED"
block|,
literal|"Process is stopped"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|PR_ISTOP
argument_list|)
name|PR_ISTOP
block|,
literal|"PR_ISTOP"
block|,
literal|"Stopped on an event of interest"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|PR_DSTOP
argument_list|)
name|PR_DSTOP
block|,
literal|"PR_DSTOP"
block|,
literal|"A stop directive is in effect"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|PR_ASLEEP
argument_list|)
name|PR_ASLEEP
block|,
literal|"PR_ASLEEP"
block|,
literal|"Sleeping in an interruptible system call"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|PR_FORK
argument_list|)
name|PR_FORK
block|,
literal|"PR_FORK"
block|,
literal|"Inherit-on-fork is in effect"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|PR_RLC
argument_list|)
name|PR_RLC
block|,
literal|"PR_RLC"
block|,
literal|"Run-on-last-close is in effect"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|PR_PTRACE
argument_list|)
name|PR_PTRACE
block|,
literal|"PR_PTRACE"
block|,
literal|"Process is being controlled by ptrace"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|PR_PCINVAL
argument_list|)
name|PR_PCINVAL
block|,
literal|"PR_PCINVAL"
block|,
literal|"PC refers to an invalid virtual address"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|PR_ISSYS
argument_list|)
name|PR_ISSYS
block|,
literal|"PR_ISSYS"
block|,
literal|"Is a system process"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|PR_STEP
argument_list|)
name|PR_STEP
block|,
literal|"PR_STEP"
block|,
literal|"Process has single step pending"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|PR_KLC
argument_list|)
name|PR_KLC
block|,
literal|"PR_KLC"
block|,
literal|"Kill-on-last-close is in effect"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|PR_ASYNC
argument_list|)
name|PR_ASYNC
block|,
literal|"PR_ASYNC"
block|,
literal|"Asynchronous stop is in effect"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|PR_PCOMPAT
argument_list|)
name|PR_PCOMPAT
block|,
literal|"PR_PCOMPAT"
block|,
literal|"Ptrace compatibility mode in effect"
block|,
endif|#
directive|endif
literal|0
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  Translate values in the pr_why field of the prstatus struct. */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|trans
name|pr_why_table
index|[]
init|=
block|{
if|#
directive|if
name|defined
argument_list|(
name|PR_REQUESTED
argument_list|)
name|PR_REQUESTED
block|,
literal|"PR_REQUESTED"
block|,
literal|"Directed to stop via PIOCSTOP/PIOCWSTOP"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|PR_SIGNALLED
argument_list|)
name|PR_SIGNALLED
block|,
literal|"PR_SIGNALLED"
block|,
literal|"Receipt of a traced signal"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|PR_FAULTED
argument_list|)
name|PR_FAULTED
block|,
literal|"PR_FAULTED"
block|,
literal|"Incurred a traced hardware fault"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|PR_SYSENTRY
argument_list|)
name|PR_SYSENTRY
block|,
literal|"PR_SYSENTRY"
block|,
literal|"Entry to a traced system call"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|PR_SYSEXIT
argument_list|)
name|PR_SYSEXIT
block|,
literal|"PR_SYSEXIT"
block|,
literal|"Exit from a traced system call"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|PR_JOBCONTROL
argument_list|)
name|PR_JOBCONTROL
block|,
literal|"PR_JOBCONTROL"
block|,
literal|"Default job control stop signal action"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|PR_SUSPENDED
argument_list|)
name|PR_SUSPENDED
block|,
literal|"PR_SUSPENDED"
block|,
literal|"Process suspended"
block|,
endif|#
directive|endif
literal|0
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  Hardware fault translation table. */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|trans
name|faults_table
index|[]
init|=
block|{
if|#
directive|if
name|defined
argument_list|(
name|FLTILL
argument_list|)
name|FLTILL
block|,
literal|"FLTILL"
block|,
literal|"Illegal instruction"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|FLTPRIV
argument_list|)
name|FLTPRIV
block|,
literal|"FLTPRIV"
block|,
literal|"Privileged instruction"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|FLTBPT
argument_list|)
name|FLTBPT
block|,
literal|"FLTBPT"
block|,
literal|"Breakpoint trap"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|FLTTRACE
argument_list|)
name|FLTTRACE
block|,
literal|"FLTTRACE"
block|,
literal|"Trace trap"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|FLTACCESS
argument_list|)
name|FLTACCESS
block|,
literal|"FLTACCESS"
block|,
literal|"Memory access fault"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|FLTBOUNDS
argument_list|)
name|FLTBOUNDS
block|,
literal|"FLTBOUNDS"
block|,
literal|"Memory bounds violation"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|FLTIOVF
argument_list|)
name|FLTIOVF
block|,
literal|"FLTIOVF"
block|,
literal|"Integer overflow"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|FLTIZDIV
argument_list|)
name|FLTIZDIV
block|,
literal|"FLTIZDIV"
block|,
literal|"Integer zero divide"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|FLTFPE
argument_list|)
name|FLTFPE
block|,
literal|"FLTFPE"
block|,
literal|"Floating-point exception"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|FLTSTACK
argument_list|)
name|FLTSTACK
block|,
literal|"FLTSTACK"
block|,
literal|"Unrecoverable stack fault"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|FLTPAGE
argument_list|)
name|FLTPAGE
block|,
literal|"FLTPAGE"
block|,
literal|"Recoverable page fault"
block|,
endif|#
directive|endif
literal|0
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Translation table for signal generation information.  See UNIX System    V Release 4 Programmer's Reference Manual, siginfo(5).  */
end_comment

begin_struct
specifier|static
struct|struct
name|sigcode
block|{
name|int
name|signo
decl_stmt|;
name|int
name|code
decl_stmt|;
name|char
modifier|*
name|codename
decl_stmt|;
name|char
modifier|*
name|desc
decl_stmt|;
block|}
name|siginfo_table
index|[]
init|=
block|{
if|#
directive|if
name|defined
argument_list|(
name|SIGILL
argument_list|)
operator|&&
name|defined
argument_list|(
name|ILL_ILLOPC
argument_list|)
name|SIGILL
block|,
name|ILL_ILLOPC
block|,
literal|"ILL_ILLOPC"
block|,
literal|"Illegal opcode"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGILL
argument_list|)
operator|&&
name|defined
argument_list|(
name|ILL_ILLOPN
argument_list|)
name|SIGILL
block|,
name|ILL_ILLOPN
block|,
literal|"ILL_ILLOPN"
block|,
literal|"Illegal operand"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGILL
argument_list|)
operator|&&
name|defined
argument_list|(
name|ILL_ILLADR
argument_list|)
name|SIGILL
block|,
name|ILL_ILLADR
block|,
literal|"ILL_ILLADR"
block|,
literal|"Illegal addressing mode"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGILL
argument_list|)
operator|&&
name|defined
argument_list|(
name|ILL_ILLTRP
argument_list|)
name|SIGILL
block|,
name|ILL_ILLTRP
block|,
literal|"ILL_ILLTRP"
block|,
literal|"Illegal trap"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGILL
argument_list|)
operator|&&
name|defined
argument_list|(
name|ILL_PRVOPC
argument_list|)
name|SIGILL
block|,
name|ILL_PRVOPC
block|,
literal|"ILL_PRVOPC"
block|,
literal|"Privileged opcode"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGILL
argument_list|)
operator|&&
name|defined
argument_list|(
name|ILL_PRVREG
argument_list|)
name|SIGILL
block|,
name|ILL_PRVREG
block|,
literal|"ILL_PRVREG"
block|,
literal|"Privileged register"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGILL
argument_list|)
operator|&&
name|defined
argument_list|(
name|ILL_COPROC
argument_list|)
name|SIGILL
block|,
name|ILL_COPROC
block|,
literal|"ILL_COPROC"
block|,
literal|"Coprocessor error"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGILL
argument_list|)
operator|&&
name|defined
argument_list|(
name|ILL_BADSTK
argument_list|)
name|SIGILL
block|,
name|ILL_BADSTK
block|,
literal|"ILL_BADSTK"
block|,
literal|"Internal stack error"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGFPE
argument_list|)
operator|&&
name|defined
argument_list|(
name|FPE_INTDIV
argument_list|)
name|SIGFPE
block|,
name|FPE_INTDIV
block|,
literal|"FPE_INTDIV"
block|,
literal|"Integer divide by zero"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGFPE
argument_list|)
operator|&&
name|defined
argument_list|(
name|FPE_INTOVF
argument_list|)
name|SIGFPE
block|,
name|FPE_INTOVF
block|,
literal|"FPE_INTOVF"
block|,
literal|"Integer overflow"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGFPE
argument_list|)
operator|&&
name|defined
argument_list|(
name|FPE_FLTDIV
argument_list|)
name|SIGFPE
block|,
name|FPE_FLTDIV
block|,
literal|"FPE_FLTDIV"
block|,
literal|"Floating point divide by zero"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGFPE
argument_list|)
operator|&&
name|defined
argument_list|(
name|FPE_FLTOVF
argument_list|)
name|SIGFPE
block|,
name|FPE_FLTOVF
block|,
literal|"FPE_FLTOVF"
block|,
literal|"Floating point overflow"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGFPE
argument_list|)
operator|&&
name|defined
argument_list|(
name|FPE_FLTUND
argument_list|)
name|SIGFPE
block|,
name|FPE_FLTUND
block|,
literal|"FPE_FLTUND"
block|,
literal|"Floating point underflow"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGFPE
argument_list|)
operator|&&
name|defined
argument_list|(
name|FPE_FLTRES
argument_list|)
name|SIGFPE
block|,
name|FPE_FLTRES
block|,
literal|"FPE_FLTRES"
block|,
literal|"Floating point inexact result"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGFPE
argument_list|)
operator|&&
name|defined
argument_list|(
name|FPE_FLTINV
argument_list|)
name|SIGFPE
block|,
name|FPE_FLTINV
block|,
literal|"FPE_FLTINV"
block|,
literal|"Invalid floating point operation"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGFPE
argument_list|)
operator|&&
name|defined
argument_list|(
name|FPE_FLTSUB
argument_list|)
name|SIGFPE
block|,
name|FPE_FLTSUB
block|,
literal|"FPE_FLTSUB"
block|,
literal|"Subscript out of range"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGSEGV
argument_list|)
operator|&&
name|defined
argument_list|(
name|SEGV_MAPERR
argument_list|)
name|SIGSEGV
block|,
name|SEGV_MAPERR
block|,
literal|"SEGV_MAPERR"
block|,
literal|"Address not mapped to object"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGSEGV
argument_list|)
operator|&&
name|defined
argument_list|(
name|SEGV_ACCERR
argument_list|)
name|SIGSEGV
block|,
name|SEGV_ACCERR
block|,
literal|"SEGV_ACCERR"
block|,
literal|"Invalid permissions for object"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGBUS
argument_list|)
operator|&&
name|defined
argument_list|(
name|BUS_ADRALN
argument_list|)
name|SIGBUS
block|,
name|BUS_ADRALN
block|,
literal|"BUS_ADRALN"
block|,
literal|"Invalid address alignment"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGBUS
argument_list|)
operator|&&
name|defined
argument_list|(
name|BUS_ADRERR
argument_list|)
name|SIGBUS
block|,
name|BUS_ADRERR
block|,
literal|"BUS_ADRERR"
block|,
literal|"Non-existent physical address"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGBUS
argument_list|)
operator|&&
name|defined
argument_list|(
name|BUS_OBJERR
argument_list|)
name|SIGBUS
block|,
name|BUS_OBJERR
block|,
literal|"BUS_OBJERR"
block|,
literal|"Object specific hardware error"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGTRAP
argument_list|)
operator|&&
name|defined
argument_list|(
name|TRAP_BRKPT
argument_list|)
name|SIGTRAP
block|,
name|TRAP_BRKPT
block|,
literal|"TRAP_BRKPT"
block|,
literal|"Process breakpoint"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGTRAP
argument_list|)
operator|&&
name|defined
argument_list|(
name|TRAP_TRACE
argument_list|)
name|SIGTRAP
block|,
name|TRAP_TRACE
block|,
literal|"TRAP_TRACE"
block|,
literal|"Process trace trap"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGCLD
argument_list|)
operator|&&
name|defined
argument_list|(
name|CLD_EXITED
argument_list|)
name|SIGCLD
block|,
name|CLD_EXITED
block|,
literal|"CLD_EXITED"
block|,
literal|"Child has exited"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGCLD
argument_list|)
operator|&&
name|defined
argument_list|(
name|CLD_KILLED
argument_list|)
name|SIGCLD
block|,
name|CLD_KILLED
block|,
literal|"CLD_KILLED"
block|,
literal|"Child was killed"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGCLD
argument_list|)
operator|&&
name|defined
argument_list|(
name|CLD_DUMPED
argument_list|)
name|SIGCLD
block|,
name|CLD_DUMPED
block|,
literal|"CLD_DUMPED"
block|,
literal|"Child has terminated abnormally"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGCLD
argument_list|)
operator|&&
name|defined
argument_list|(
name|CLD_TRAPPED
argument_list|)
name|SIGCLD
block|,
name|CLD_TRAPPED
block|,
literal|"CLD_TRAPPED"
block|,
literal|"Traced child has trapped"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGCLD
argument_list|)
operator|&&
name|defined
argument_list|(
name|CLD_STOPPED
argument_list|)
name|SIGCLD
block|,
name|CLD_STOPPED
block|,
literal|"CLD_STOPPED"
block|,
literal|"Child has stopped"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGCLD
argument_list|)
operator|&&
name|defined
argument_list|(
name|CLD_CONTINUED
argument_list|)
name|SIGCLD
block|,
name|CLD_CONTINUED
block|,
literal|"CLD_CONTINUED"
block|,
literal|"Stopped child had continued"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGPOLL
argument_list|)
operator|&&
name|defined
argument_list|(
name|POLL_IN
argument_list|)
name|SIGPOLL
block|,
name|POLL_IN
block|,
literal|"POLL_IN"
block|,
literal|"Input input available"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGPOLL
argument_list|)
operator|&&
name|defined
argument_list|(
name|POLL_OUT
argument_list|)
name|SIGPOLL
block|,
name|POLL_OUT
block|,
literal|"POLL_OUT"
block|,
literal|"Output buffers available"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGPOLL
argument_list|)
operator|&&
name|defined
argument_list|(
name|POLL_MSG
argument_list|)
name|SIGPOLL
block|,
name|POLL_MSG
block|,
literal|"POLL_MSG"
block|,
literal|"Input message available"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGPOLL
argument_list|)
operator|&&
name|defined
argument_list|(
name|POLL_ERR
argument_list|)
name|SIGPOLL
block|,
name|POLL_ERR
block|,
literal|"POLL_ERR"
block|,
literal|"I/O error"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGPOLL
argument_list|)
operator|&&
name|defined
argument_list|(
name|POLL_PRI
argument_list|)
name|SIGPOLL
block|,
name|POLL_PRI
block|,
literal|"POLL_PRI"
block|,
literal|"High priority input available"
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGPOLL
argument_list|)
operator|&&
name|defined
argument_list|(
name|POLL_HUP
argument_list|)
name|SIGPOLL
block|,
name|POLL_HUP
block|,
literal|"POLL_HUP"
block|,
literal|"Device disconnected"
block|,
endif|#
directive|endif
literal|0
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|char
modifier|*
name|syscall_table
index|[
name|MAX_SYSCALLS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Prototypes for local functions */
end_comment

begin_decl_stmt
specifier|static
name|void
name|set_proc_siginfo
name|PARAMS
argument_list|(
operator|(
expr|struct
name|procinfo
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|init_syscall_table
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|syscallname
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|signalname
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|errnoname
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|proc_address_to_fd
name|PARAMS
argument_list|(
operator|(
name|CORE_ADDR
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|open_proc_file
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|procinfo
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|close_proc_file
name|PARAMS
argument_list|(
operator|(
expr|struct
name|procinfo
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|unconditionally_kill_inferior
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|proc_init_failed
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|info_proc
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|info_proc_flags
name|PARAMS
argument_list|(
operator|(
expr|struct
name|procinfo
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|info_proc_stop
name|PARAMS
argument_list|(
operator|(
expr|struct
name|procinfo
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|info_proc_siginfo
name|PARAMS
argument_list|(
operator|(
expr|struct
name|procinfo
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|info_proc_syscalls
name|PARAMS
argument_list|(
operator|(
expr|struct
name|procinfo
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|info_proc_mappings
name|PARAMS
argument_list|(
operator|(
expr|struct
name|procinfo
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|info_proc_signals
name|PARAMS
argument_list|(
operator|(
expr|struct
name|procinfo
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|info_proc_faults
name|PARAMS
argument_list|(
operator|(
expr|struct
name|procinfo
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|mappingflags
name|PARAMS
argument_list|(
operator|(
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|lookupname
name|PARAMS
argument_list|(
operator|(
expr|struct
name|trans
operator|*
operator|,
name|unsigned
name|int
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|lookupdesc
name|PARAMS
argument_list|(
operator|(
expr|struct
name|trans
operator|*
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|do_attach
name|PARAMS
argument_list|(
operator|(
name|int
name|pid
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_detach
name|PARAMS
argument_list|(
operator|(
name|int
name|siggnal
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|procfs_create_inferior
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|procfs_notice_signals
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* External function prototypes that can't be easily included in any    header file because the args are typedefs in system include files. */
end_comment

begin_decl_stmt
specifier|extern
name|void
name|supply_gregset
name|PARAMS
argument_list|(
operator|(
name|gregset_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|fill_gregset
name|PARAMS
argument_list|(
operator|(
name|gregset_t
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|supply_fpregset
name|PARAMS
argument_list|(
operator|(
name|fpregset_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|fill_fpregset
name|PARAMS
argument_list|(
operator|(
name|fpregset_t
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  LOCAL FUNCTION  	lookupdesc -- translate a value to a summary desc string  SYNOPSIS  	static char *lookupdesc (struct trans *transp, unsigned int val);  DESCRIPTION 	 	Given a pointer to a translation table and a value to be translated, 	lookup the desc string and return it.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|lookupdesc
parameter_list|(
name|transp
parameter_list|,
name|val
parameter_list|)
name|struct
name|trans
modifier|*
name|transp
decl_stmt|;
name|unsigned
name|int
name|val
decl_stmt|;
block|{
name|char
modifier|*
name|desc
decl_stmt|;
for|for
control|(
name|desc
operator|=
name|NULL
init|;
name|transp
operator|->
name|name
operator|!=
name|NULL
condition|;
name|transp
operator|++
control|)
block|{
if|if
condition|(
name|transp
operator|->
name|value
operator|==
name|val
condition|)
block|{
name|desc
operator|=
name|transp
operator|->
name|desc
expr_stmt|;
break|break;
block|}
block|}
comment|/* Didn't find a translation for the specified value, set a default one. */
if|if
condition|(
name|desc
operator|==
name|NULL
condition|)
block|{
name|desc
operator|=
literal|"Unknown"
expr_stmt|;
block|}
return|return
operator|(
name|desc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	lookupname -- translate a value to symbolic name  SYNOPSIS  	static char *lookupname (struct trans *transp, unsigned int val, 				 char *prefix);  DESCRIPTION 	 	Given a pointer to a translation table, a value to be translated, 	and a default prefix to return if the value can't be translated, 	match the value with one of the translation table entries and 	return a pointer to the symbolic name.  	If no match is found it just returns the value as a printable string, 	with the given prefix.  The previous such value, if any, is freed 	at this time.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|lookupname
parameter_list|(
name|transp
parameter_list|,
name|val
parameter_list|,
name|prefix
parameter_list|)
name|struct
name|trans
modifier|*
name|transp
decl_stmt|;
name|unsigned
name|int
name|val
decl_stmt|;
name|char
modifier|*
name|prefix
decl_stmt|;
block|{
specifier|static
name|char
modifier|*
name|locbuf
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
for|for
control|(
name|name
operator|=
name|NULL
init|;
name|transp
operator|->
name|name
operator|!=
name|NULL
condition|;
name|transp
operator|++
control|)
block|{
if|if
condition|(
name|transp
operator|->
name|value
operator|==
name|val
condition|)
block|{
name|name
operator|=
name|transp
operator|->
name|name
expr_stmt|;
break|break;
block|}
block|}
comment|/* Didn't find a translation for the specified value, build a default      one using the specified prefix and return it.  The lifetime of      the value is only until the next one is needed. */
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|locbuf
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|locbuf
argument_list|)
expr_stmt|;
block|}
name|locbuf
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|prefix
argument_list|)
operator|+
literal|16
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|locbuf
argument_list|,
literal|"%s %u"
argument_list|,
name|prefix
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|name
operator|=
name|locbuf
expr_stmt|;
block|}
return|return
operator|(
name|name
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|sigcodename
parameter_list|(
name|sip
parameter_list|)
name|siginfo_t
modifier|*
name|sip
decl_stmt|;
block|{
name|struct
name|sigcode
modifier|*
name|scp
decl_stmt|;
name|char
modifier|*
name|name
init|=
name|NULL
decl_stmt|;
specifier|static
name|char
name|locbuf
index|[
literal|32
index|]
decl_stmt|;
for|for
control|(
name|scp
operator|=
name|siginfo_table
init|;
name|scp
operator|->
name|codename
operator|!=
name|NULL
condition|;
name|scp
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|scp
operator|->
name|signo
operator|==
name|sip
operator|->
name|si_signo
operator|)
operator|&&
operator|(
name|scp
operator|->
name|code
operator|==
name|sip
operator|->
name|si_code
operator|)
condition|)
block|{
name|name
operator|=
name|scp
operator|->
name|codename
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
block|{
name|sprintf
argument_list|(
name|locbuf
argument_list|,
literal|"sigcode %u"
argument_list|,
name|sip
operator|->
name|si_signo
argument_list|)
expr_stmt|;
name|name
operator|=
name|locbuf
expr_stmt|;
block|}
return|return
operator|(
name|name
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|sigcodedesc
parameter_list|(
name|sip
parameter_list|)
name|siginfo_t
modifier|*
name|sip
decl_stmt|;
block|{
name|struct
name|sigcode
modifier|*
name|scp
decl_stmt|;
name|char
modifier|*
name|desc
init|=
name|NULL
decl_stmt|;
for|for
control|(
name|scp
operator|=
name|siginfo_table
init|;
name|scp
operator|->
name|codename
operator|!=
name|NULL
condition|;
name|scp
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|scp
operator|->
name|signo
operator|==
name|sip
operator|->
name|si_signo
operator|)
operator|&&
operator|(
name|scp
operator|->
name|code
operator|==
name|sip
operator|->
name|si_code
operator|)
condition|)
block|{
name|desc
operator|=
name|scp
operator|->
name|desc
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|desc
operator|==
name|NULL
condition|)
block|{
name|desc
operator|=
literal|"Unrecognized signal or trap use"
expr_stmt|;
block|}
return|return
operator|(
name|desc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	syscallname - translate a system call number into a system call name  SYNOPSIS  	char *syscallname (int syscallnum)  DESCRIPTION  	Given a system call number, translate it into the printable name 	of a system call, or into "syscall<num>" if it is an unknown 	number.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|syscallname
parameter_list|(
name|syscallnum
parameter_list|)
name|int
name|syscallnum
decl_stmt|;
block|{
specifier|static
name|char
name|locbuf
index|[
literal|32
index|]
decl_stmt|;
name|char
modifier|*
name|rtnval
decl_stmt|;
if|if
condition|(
name|syscallnum
operator|>=
literal|0
operator|&&
name|syscallnum
operator|<
name|MAX_SYSCALLS
condition|)
block|{
name|rtnval
operator|=
name|syscall_table
index|[
name|syscallnum
index|]
expr_stmt|;
block|}
else|else
block|{
name|sprintf
argument_list|(
name|locbuf
argument_list|,
literal|"syscall %u"
argument_list|,
name|syscallnum
argument_list|)
expr_stmt|;
name|rtnval
operator|=
name|locbuf
expr_stmt|;
block|}
return|return
operator|(
name|rtnval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	init_syscall_table - initialize syscall translation table  SYNOPSIS  	void init_syscall_table (void)  DESCRIPTION  	Dynamically initialize the translation table to convert system 	call numbers into printable system call names.  Done once per 	gdb run, on initialization.  NOTES  	This is awfully ugly, but preprocessor tricks to make it prettier 	tend to be nonportable.  */
end_comment

begin_function
specifier|static
name|void
name|init_syscall_table
parameter_list|()
block|{
if|#
directive|if
name|defined
argument_list|(
name|SYS_exit
argument_list|)
name|syscall_table
index|[
name|SYS_exit
index|]
operator|=
literal|"exit"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_fork
argument_list|)
name|syscall_table
index|[
name|SYS_fork
index|]
operator|=
literal|"fork"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_read
argument_list|)
name|syscall_table
index|[
name|SYS_read
index|]
operator|=
literal|"read"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_write
argument_list|)
name|syscall_table
index|[
name|SYS_write
index|]
operator|=
literal|"write"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_open
argument_list|)
name|syscall_table
index|[
name|SYS_open
index|]
operator|=
literal|"open"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_close
argument_list|)
name|syscall_table
index|[
name|SYS_close
index|]
operator|=
literal|"close"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_wait
argument_list|)
name|syscall_table
index|[
name|SYS_wait
index|]
operator|=
literal|"wait"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_creat
argument_list|)
name|syscall_table
index|[
name|SYS_creat
index|]
operator|=
literal|"creat"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_link
argument_list|)
name|syscall_table
index|[
name|SYS_link
index|]
operator|=
literal|"link"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_unlink
argument_list|)
name|syscall_table
index|[
name|SYS_unlink
index|]
operator|=
literal|"unlink"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_exec
argument_list|)
name|syscall_table
index|[
name|SYS_exec
index|]
operator|=
literal|"exec"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_execv
argument_list|)
name|syscall_table
index|[
name|SYS_execv
index|]
operator|=
literal|"execv"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_execve
argument_list|)
name|syscall_table
index|[
name|SYS_execve
index|]
operator|=
literal|"execve"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_chdir
argument_list|)
name|syscall_table
index|[
name|SYS_chdir
index|]
operator|=
literal|"chdir"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_time
argument_list|)
name|syscall_table
index|[
name|SYS_time
index|]
operator|=
literal|"time"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_mknod
argument_list|)
name|syscall_table
index|[
name|SYS_mknod
index|]
operator|=
literal|"mknod"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_chmod
argument_list|)
name|syscall_table
index|[
name|SYS_chmod
index|]
operator|=
literal|"chmod"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_chown
argument_list|)
name|syscall_table
index|[
name|SYS_chown
index|]
operator|=
literal|"chown"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_brk
argument_list|)
name|syscall_table
index|[
name|SYS_brk
index|]
operator|=
literal|"brk"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_stat
argument_list|)
name|syscall_table
index|[
name|SYS_stat
index|]
operator|=
literal|"stat"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_lseek
argument_list|)
name|syscall_table
index|[
name|SYS_lseek
index|]
operator|=
literal|"lseek"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_getpid
argument_list|)
name|syscall_table
index|[
name|SYS_getpid
index|]
operator|=
literal|"getpid"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_mount
argument_list|)
name|syscall_table
index|[
name|SYS_mount
index|]
operator|=
literal|"mount"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_umount
argument_list|)
name|syscall_table
index|[
name|SYS_umount
index|]
operator|=
literal|"umount"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_setuid
argument_list|)
name|syscall_table
index|[
name|SYS_setuid
index|]
operator|=
literal|"setuid"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_getuid
argument_list|)
name|syscall_table
index|[
name|SYS_getuid
index|]
operator|=
literal|"getuid"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_stime
argument_list|)
name|syscall_table
index|[
name|SYS_stime
index|]
operator|=
literal|"stime"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_ptrace
argument_list|)
name|syscall_table
index|[
name|SYS_ptrace
index|]
operator|=
literal|"ptrace"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_alarm
argument_list|)
name|syscall_table
index|[
name|SYS_alarm
index|]
operator|=
literal|"alarm"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_fstat
argument_list|)
name|syscall_table
index|[
name|SYS_fstat
index|]
operator|=
literal|"fstat"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_pause
argument_list|)
name|syscall_table
index|[
name|SYS_pause
index|]
operator|=
literal|"pause"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_utime
argument_list|)
name|syscall_table
index|[
name|SYS_utime
index|]
operator|=
literal|"utime"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_stty
argument_list|)
name|syscall_table
index|[
name|SYS_stty
index|]
operator|=
literal|"stty"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_gtty
argument_list|)
name|syscall_table
index|[
name|SYS_gtty
index|]
operator|=
literal|"gtty"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_access
argument_list|)
name|syscall_table
index|[
name|SYS_access
index|]
operator|=
literal|"access"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_nice
argument_list|)
name|syscall_table
index|[
name|SYS_nice
index|]
operator|=
literal|"nice"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_statfs
argument_list|)
name|syscall_table
index|[
name|SYS_statfs
index|]
operator|=
literal|"statfs"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_sync
argument_list|)
name|syscall_table
index|[
name|SYS_sync
index|]
operator|=
literal|"sync"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_kill
argument_list|)
name|syscall_table
index|[
name|SYS_kill
index|]
operator|=
literal|"kill"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_fstatfs
argument_list|)
name|syscall_table
index|[
name|SYS_fstatfs
index|]
operator|=
literal|"fstatfs"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_pgrpsys
argument_list|)
name|syscall_table
index|[
name|SYS_pgrpsys
index|]
operator|=
literal|"pgrpsys"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_xenix
argument_list|)
name|syscall_table
index|[
name|SYS_xenix
index|]
operator|=
literal|"xenix"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_dup
argument_list|)
name|syscall_table
index|[
name|SYS_dup
index|]
operator|=
literal|"dup"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_pipe
argument_list|)
name|syscall_table
index|[
name|SYS_pipe
index|]
operator|=
literal|"pipe"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_times
argument_list|)
name|syscall_table
index|[
name|SYS_times
index|]
operator|=
literal|"times"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_profil
argument_list|)
name|syscall_table
index|[
name|SYS_profil
index|]
operator|=
literal|"profil"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_plock
argument_list|)
name|syscall_table
index|[
name|SYS_plock
index|]
operator|=
literal|"plock"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_setgid
argument_list|)
name|syscall_table
index|[
name|SYS_setgid
index|]
operator|=
literal|"setgid"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_getgid
argument_list|)
name|syscall_table
index|[
name|SYS_getgid
index|]
operator|=
literal|"getgid"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_signal
argument_list|)
name|syscall_table
index|[
name|SYS_signal
index|]
operator|=
literal|"signal"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_msgsys
argument_list|)
name|syscall_table
index|[
name|SYS_msgsys
index|]
operator|=
literal|"msgsys"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_sys3b
argument_list|)
name|syscall_table
index|[
name|SYS_sys3b
index|]
operator|=
literal|"sys3b"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_acct
argument_list|)
name|syscall_table
index|[
name|SYS_acct
index|]
operator|=
literal|"acct"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_shmsys
argument_list|)
name|syscall_table
index|[
name|SYS_shmsys
index|]
operator|=
literal|"shmsys"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_semsys
argument_list|)
name|syscall_table
index|[
name|SYS_semsys
index|]
operator|=
literal|"semsys"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_ioctl
argument_list|)
name|syscall_table
index|[
name|SYS_ioctl
index|]
operator|=
literal|"ioctl"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_uadmin
argument_list|)
name|syscall_table
index|[
name|SYS_uadmin
index|]
operator|=
literal|"uadmin"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_utssys
argument_list|)
name|syscall_table
index|[
name|SYS_utssys
index|]
operator|=
literal|"utssys"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_fsync
argument_list|)
name|syscall_table
index|[
name|SYS_fsync
index|]
operator|=
literal|"fsync"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_umask
argument_list|)
name|syscall_table
index|[
name|SYS_umask
index|]
operator|=
literal|"umask"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_chroot
argument_list|)
name|syscall_table
index|[
name|SYS_chroot
index|]
operator|=
literal|"chroot"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_fcntl
argument_list|)
name|syscall_table
index|[
name|SYS_fcntl
index|]
operator|=
literal|"fcntl"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_ulimit
argument_list|)
name|syscall_table
index|[
name|SYS_ulimit
index|]
operator|=
literal|"ulimit"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_rfsys
argument_list|)
name|syscall_table
index|[
name|SYS_rfsys
index|]
operator|=
literal|"rfsys"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_rmdir
argument_list|)
name|syscall_table
index|[
name|SYS_rmdir
index|]
operator|=
literal|"rmdir"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_mkdir
argument_list|)
name|syscall_table
index|[
name|SYS_mkdir
index|]
operator|=
literal|"mkdir"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_getdents
argument_list|)
name|syscall_table
index|[
name|SYS_getdents
index|]
operator|=
literal|"getdents"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_sysfs
argument_list|)
name|syscall_table
index|[
name|SYS_sysfs
index|]
operator|=
literal|"sysfs"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_getmsg
argument_list|)
name|syscall_table
index|[
name|SYS_getmsg
index|]
operator|=
literal|"getmsg"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_putmsg
argument_list|)
name|syscall_table
index|[
name|SYS_putmsg
index|]
operator|=
literal|"putmsg"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_poll
argument_list|)
name|syscall_table
index|[
name|SYS_poll
index|]
operator|=
literal|"poll"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_lstat
argument_list|)
name|syscall_table
index|[
name|SYS_lstat
index|]
operator|=
literal|"lstat"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_symlink
argument_list|)
name|syscall_table
index|[
name|SYS_symlink
index|]
operator|=
literal|"symlink"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_readlink
argument_list|)
name|syscall_table
index|[
name|SYS_readlink
index|]
operator|=
literal|"readlink"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_setgroups
argument_list|)
name|syscall_table
index|[
name|SYS_setgroups
index|]
operator|=
literal|"setgroups"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_getgroups
argument_list|)
name|syscall_table
index|[
name|SYS_getgroups
index|]
operator|=
literal|"getgroups"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_fchmod
argument_list|)
name|syscall_table
index|[
name|SYS_fchmod
index|]
operator|=
literal|"fchmod"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_fchown
argument_list|)
name|syscall_table
index|[
name|SYS_fchown
index|]
operator|=
literal|"fchown"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_sigprocmask
argument_list|)
name|syscall_table
index|[
name|SYS_sigprocmask
index|]
operator|=
literal|"sigprocmask"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_sigsuspend
argument_list|)
name|syscall_table
index|[
name|SYS_sigsuspend
index|]
operator|=
literal|"sigsuspend"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_sigaltstack
argument_list|)
name|syscall_table
index|[
name|SYS_sigaltstack
index|]
operator|=
literal|"sigaltstack"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_sigaction
argument_list|)
name|syscall_table
index|[
name|SYS_sigaction
index|]
operator|=
literal|"sigaction"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_sigpending
argument_list|)
name|syscall_table
index|[
name|SYS_sigpending
index|]
operator|=
literal|"sigpending"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_context
argument_list|)
name|syscall_table
index|[
name|SYS_context
index|]
operator|=
literal|"context"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_evsys
argument_list|)
name|syscall_table
index|[
name|SYS_evsys
index|]
operator|=
literal|"evsys"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_evtrapret
argument_list|)
name|syscall_table
index|[
name|SYS_evtrapret
index|]
operator|=
literal|"evtrapret"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_statvfs
argument_list|)
name|syscall_table
index|[
name|SYS_statvfs
index|]
operator|=
literal|"statvfs"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_fstatvfs
argument_list|)
name|syscall_table
index|[
name|SYS_fstatvfs
index|]
operator|=
literal|"fstatvfs"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_nfssys
argument_list|)
name|syscall_table
index|[
name|SYS_nfssys
index|]
operator|=
literal|"nfssys"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_waitsys
argument_list|)
name|syscall_table
index|[
name|SYS_waitsys
index|]
operator|=
literal|"waitsys"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_sigsendsys
argument_list|)
name|syscall_table
index|[
name|SYS_sigsendsys
index|]
operator|=
literal|"sigsendsys"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_hrtsys
argument_list|)
name|syscall_table
index|[
name|SYS_hrtsys
index|]
operator|=
literal|"hrtsys"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_acancel
argument_list|)
name|syscall_table
index|[
name|SYS_acancel
index|]
operator|=
literal|"acancel"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_async
argument_list|)
name|syscall_table
index|[
name|SYS_async
index|]
operator|=
literal|"async"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_priocntlsys
argument_list|)
name|syscall_table
index|[
name|SYS_priocntlsys
index|]
operator|=
literal|"priocntlsys"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_pathconf
argument_list|)
name|syscall_table
index|[
name|SYS_pathconf
index|]
operator|=
literal|"pathconf"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_mincore
argument_list|)
name|syscall_table
index|[
name|SYS_mincore
index|]
operator|=
literal|"mincore"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_mmap
argument_list|)
name|syscall_table
index|[
name|SYS_mmap
index|]
operator|=
literal|"mmap"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_mprotect
argument_list|)
name|syscall_table
index|[
name|SYS_mprotect
index|]
operator|=
literal|"mprotect"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_munmap
argument_list|)
name|syscall_table
index|[
name|SYS_munmap
index|]
operator|=
literal|"munmap"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_fpathconf
argument_list|)
name|syscall_table
index|[
name|SYS_fpathconf
index|]
operator|=
literal|"fpathconf"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_vfork
argument_list|)
name|syscall_table
index|[
name|SYS_vfork
index|]
operator|=
literal|"vfork"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_fchdir
argument_list|)
name|syscall_table
index|[
name|SYS_fchdir
index|]
operator|=
literal|"fchdir"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_readv
argument_list|)
name|syscall_table
index|[
name|SYS_readv
index|]
operator|=
literal|"readv"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_writev
argument_list|)
name|syscall_table
index|[
name|SYS_writev
index|]
operator|=
literal|"writev"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_xstat
argument_list|)
name|syscall_table
index|[
name|SYS_xstat
index|]
operator|=
literal|"xstat"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_lxstat
argument_list|)
name|syscall_table
index|[
name|SYS_lxstat
index|]
operator|=
literal|"lxstat"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_fxstat
argument_list|)
name|syscall_table
index|[
name|SYS_fxstat
index|]
operator|=
literal|"fxstat"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_xmknod
argument_list|)
name|syscall_table
index|[
name|SYS_xmknod
index|]
operator|=
literal|"xmknod"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_clocal
argument_list|)
name|syscall_table
index|[
name|SYS_clocal
index|]
operator|=
literal|"clocal"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_setrlimit
argument_list|)
name|syscall_table
index|[
name|SYS_setrlimit
index|]
operator|=
literal|"setrlimit"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_getrlimit
argument_list|)
name|syscall_table
index|[
name|SYS_getrlimit
index|]
operator|=
literal|"getrlimit"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_lchown
argument_list|)
name|syscall_table
index|[
name|SYS_lchown
index|]
operator|=
literal|"lchown"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_memcntl
argument_list|)
name|syscall_table
index|[
name|SYS_memcntl
index|]
operator|=
literal|"memcntl"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_getpmsg
argument_list|)
name|syscall_table
index|[
name|SYS_getpmsg
index|]
operator|=
literal|"getpmsg"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_putpmsg
argument_list|)
name|syscall_table
index|[
name|SYS_putpmsg
index|]
operator|=
literal|"putpmsg"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_rename
argument_list|)
name|syscall_table
index|[
name|SYS_rename
index|]
operator|=
literal|"rename"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_uname
argument_list|)
name|syscall_table
index|[
name|SYS_uname
index|]
operator|=
literal|"uname"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_setegid
argument_list|)
name|syscall_table
index|[
name|SYS_setegid
index|]
operator|=
literal|"setegid"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_sysconfig
argument_list|)
name|syscall_table
index|[
name|SYS_sysconfig
index|]
operator|=
literal|"sysconfig"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_adjtime
argument_list|)
name|syscall_table
index|[
name|SYS_adjtime
index|]
operator|=
literal|"adjtime"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_systeminfo
argument_list|)
name|syscall_table
index|[
name|SYS_systeminfo
index|]
operator|=
literal|"systeminfo"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_seteuid
argument_list|)
name|syscall_table
index|[
name|SYS_seteuid
index|]
operator|=
literal|"seteuid"
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  GLOBAL FUNCTION  	ptrace -- override library version to force errors for /proc version  SYNOPSIS  	int ptrace (int request, int pid, PTRACE_ARG3_TYPE arg3, int arg4)  DESCRIPTION  	When gdb is configured to use /proc, it should not be calling 	or otherwise attempting to use ptrace.  In order to catch errors 	where use of /proc is configured, but some routine is still calling 	ptrace, we provide a local version of a function with that name 	that does nothing but issue an error message. */
end_comment

begin_function
name|int
name|ptrace
parameter_list|(
name|request
parameter_list|,
name|pid
parameter_list|,
name|arg3
parameter_list|,
name|arg4
parameter_list|)
name|int
name|request
decl_stmt|;
name|int
name|pid
decl_stmt|;
name|PTRACE_ARG3_TYPE
name|arg3
decl_stmt|;
name|int
name|arg4
decl_stmt|;
block|{
name|error
argument_list|(
literal|"internal error - there is a call to ptrace() somewhere"
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	procfs_kill_inferior - kill any currently inferior  SYNOPSIS  	void procfs_kill_inferior (void)  DESCRIPTION  	Kill any current inferior.  NOTES  	Kills even attached inferiors.  Presumably the user has already 	been prompted that the inferior is an attached one rather than 	one started by gdb.  (FIXME?)  */
end_comment

begin_function
specifier|static
name|void
name|procfs_kill_inferior
parameter_list|()
block|{
if|if
condition|(
name|inferior_pid
operator|!=
literal|0
condition|)
block|{
name|unconditionally_kill_inferior
argument_list|()
expr_stmt|;
name|target_mourn_inferior
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	unconditionally_kill_inferior - terminate the inferior  SYNOPSIS  	static void unconditionally_kill_inferior (void)  DESCRIPTION  	Kill the current inferior.  Should not be called until it 	is at least tested that there is an inferior.  NOTE  	A possibly useful enhancement would be to first try sending 	the inferior a terminate signal, politely asking it to commit 	suicide, before we murder it.  */
end_comment

begin_function
specifier|static
name|void
name|unconditionally_kill_inferior
parameter_list|()
block|{
name|int
name|signo
decl_stmt|;
name|signo
operator|=
name|SIGKILL
expr_stmt|;
name|ioctl
argument_list|(
name|pi
operator|.
name|fd
argument_list|,
name|PIOCKILL
argument_list|,
operator|&
name|signo
argument_list|)
expr_stmt|;
name|close_proc_file
argument_list|(
operator|&
name|pi
argument_list|)
expr_stmt|;
name|wait
argument_list|(
operator|(
name|int
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	procfs_xfer_memory -- copy data to or from inferior memory space  SYNOPSIS  	int procfs_xfer_memory (CORE_ADDR memaddr, char *myaddr, int len, 		int dowrite, struct target_ops target)  DESCRIPTION  	Copy LEN bytes to/from inferior's memory starting at MEMADDR 	from/to debugger memory starting at MYADDR.  Copy from inferior 	if DOWRITE is zero or to inferior if DOWRITE is nonzero.    	Returns the length copied, which is either the LEN argument or 	zero.  This xfer function does not do partial moves, since procfs_ops 	doesn't allow memory operations to cross below us in the target stack 	anyway.  NOTES  	The /proc interface makes this an almost trivial task.  */
end_comment

begin_function
specifier|static
name|int
name|procfs_xfer_memory
parameter_list|(
name|memaddr
parameter_list|,
name|myaddr
parameter_list|,
name|len
parameter_list|,
name|dowrite
parameter_list|,
name|target
parameter_list|)
name|CORE_ADDR
name|memaddr
decl_stmt|;
name|char
modifier|*
name|myaddr
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|dowrite
decl_stmt|;
name|struct
name|target_ops
modifier|*
name|target
decl_stmt|;
comment|/* ignored */
block|{
name|int
name|nbytes
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|lseek
argument_list|(
name|pi
operator|.
name|fd
argument_list|,
operator|(
name|off_t
operator|)
name|memaddr
argument_list|,
literal|0
argument_list|)
operator|==
operator|(
name|off_t
operator|)
name|memaddr
condition|)
block|{
if|if
condition|(
name|dowrite
condition|)
block|{
name|nbytes
operator|=
name|write
argument_list|(
name|pi
operator|.
name|fd
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nbytes
operator|=
name|read
argument_list|(
name|pi
operator|.
name|fd
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nbytes
operator|<
literal|0
condition|)
block|{
name|nbytes
operator|=
literal|0
expr_stmt|;
block|}
block|}
return|return
operator|(
name|nbytes
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	procfs_store_registers -- copy register values back to inferior  SYNOPSIS  	void procfs_store_registers (int regno)  DESCRIPTION  	Store our current register values back into the inferior.  If 	REGNO is -1 then store all the register, otherwise store just 	the value specified by REGNO.  NOTES  	If we are storing only a single register, we first have to get all 	the current values from the process, overwrite the desired register 	in the gregset with the one we want from gdb's registers, and then 	send the whole set back to the process.  For writing all the 	registers, all we have to do is generate the gregset and send it to 	the process.  	Also note that the process has to be stopped on an event of interest 	for this to work, which basically means that it has to have been 	run under the control of one of the other /proc ioctl calls and not 	ptrace.  Since we don't use ptrace anyway, we don't worry about this 	fine point, but it is worth noting for future reference.  	Gdb is confused about what this function is supposed to return. 	Some versions return a value, others return nothing.  Some are 	declared to return a value and actually return nothing.  Gdb ignores 	anything returned.  (FIXME)   */
end_comment

begin_function
specifier|static
name|void
name|procfs_store_registers
parameter_list|(
name|regno
parameter_list|)
name|int
name|regno
decl_stmt|;
block|{
if|if
condition|(
name|regno
operator|!=
operator|-
literal|1
condition|)
block|{
name|ioctl
argument_list|(
name|pi
operator|.
name|fd
argument_list|,
name|PIOCGREG
argument_list|,
operator|&
name|pi
operator|.
name|gregset
argument_list|)
expr_stmt|;
block|}
name|fill_gregset
argument_list|(
operator|&
name|pi
operator|.
name|gregset
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
name|pi
operator|.
name|fd
argument_list|,
name|PIOCSREG
argument_list|,
operator|&
name|pi
operator|.
name|gregset
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|FP0_REGNUM
argument_list|)
comment|/* Now repeat everything using the floating point register set, if the      target has floating point hardware. Since we ignore the returned value,      we'll never know whether it worked or not anyway. */
if|if
condition|(
name|regno
operator|!=
operator|-
literal|1
condition|)
block|{
name|ioctl
argument_list|(
name|pi
operator|.
name|fd
argument_list|,
name|PIOCGFPREG
argument_list|,
operator|&
name|pi
operator|.
name|fpregset
argument_list|)
expr_stmt|;
block|}
name|fill_fpregset
argument_list|(
operator|&
name|pi
operator|.
name|fpregset
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
name|pi
operator|.
name|fd
argument_list|,
name|PIOCSFPREG
argument_list|,
operator|&
name|pi
operator|.
name|fpregset
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* FP0_REGNUM */
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	procfs_init_inferior - initialize access to a /proc entry  SYNOPSIS  	void procfs_init_inferior (int pid)  DESCRIPTION  	When gdb starts an inferior, this function is called in the parent 	process immediately after the fork.  It waits for the child to stop 	on the return from the exec system call (the child itself takes care 	of ensuring that this is set up), then sets up the set of signals 	and faults that are to be traced.  NOTES  	If proc_init_failed ever gets called, control returns to the command 	processing loop via the standard error handling code.   */
end_comment

begin_function
specifier|static
name|void
name|procfs_init_inferior
parameter_list|(
name|pid
parameter_list|)
name|int
name|pid
decl_stmt|;
block|{
name|push_target
argument_list|(
operator|&
name|procfs_ops
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|open_proc_file
argument_list|(
name|pid
argument_list|,
operator|&
name|pi
argument_list|,
name|O_RDWR
argument_list|)
condition|)
block|{
name|proc_init_failed
argument_list|(
literal|"can't open process file"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|pi
operator|.
name|prrun
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|pi
operator|.
name|prrun
argument_list|)
argument_list|)
expr_stmt|;
name|prfillset
argument_list|(
operator|&
name|pi
operator|.
name|prrun
operator|.
name|pr_trace
argument_list|)
expr_stmt|;
name|procfs_notice_signals
argument_list|()
expr_stmt|;
name|prfillset
argument_list|(
operator|&
name|pi
operator|.
name|prrun
operator|.
name|pr_fault
argument_list|)
expr_stmt|;
name|prdelset
argument_list|(
operator|&
name|pi
operator|.
name|prrun
operator|.
name|pr_fault
argument_list|,
name|FLTPAGE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|pi
operator|.
name|fd
argument_list|,
name|PIOCWSTOP
argument_list|,
operator|&
name|pi
operator|.
name|prstatus
argument_list|)
operator|<
literal|0
condition|)
block|{
name|proc_init_failed
argument_list|(
literal|"PIOCWSTOP failed"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ioctl
argument_list|(
name|pi
operator|.
name|fd
argument_list|,
name|PIOCSFAULT
argument_list|,
operator|&
name|pi
operator|.
name|prrun
operator|.
name|pr_fault
argument_list|)
operator|<
literal|0
condition|)
block|{
name|proc_init_failed
argument_list|(
literal|"PIOCSFAULT failed"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  GLOBAL FUNCTION  	procfs_notice_signals  SYNOPSIS  	static void procfs_notice_signals (void);  DESCRIPTION  	When the user changes the state of gdb's signal handling via the 	"handle" command, this function gets called to see if any change 	in the /proc interface is required.  It is also called internally 	by other /proc interface functions to initialize the state of 	the traced signal set.  	One thing it does is that signals for which the state is "nostop", 	"noprint", and "pass", have their trace bits reset in the pr_trace 	field, so that they are no longer traced.  This allows them to be 	delivered directly to the inferior without the debugger ever being 	involved.  */
end_comment

begin_function
specifier|static
name|void
name|procfs_notice_signals
parameter_list|()
block|{
name|int
name|signo
decl_stmt|;
if|if
condition|(
name|pi
operator|.
name|valid
condition|)
block|{
for|for
control|(
name|signo
operator|=
literal|0
init|;
name|signo
operator|<
name|NSIG
condition|;
name|signo
operator|++
control|)
block|{
if|if
condition|(
name|signal_stop_state
argument_list|(
name|signo
argument_list|)
operator|==
literal|0
operator|&&
name|signal_print_state
argument_list|(
name|signo
argument_list|)
operator|==
literal|0
operator|&&
name|signal_pass_state
argument_list|(
name|signo
argument_list|)
operator|==
literal|1
condition|)
block|{
name|prdelset
argument_list|(
operator|&
name|pi
operator|.
name|prrun
operator|.
name|pr_trace
argument_list|,
name|signo
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|praddset
argument_list|(
operator|&
name|pi
operator|.
name|prrun
operator|.
name|pr_trace
argument_list|,
name|signo
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ioctl
argument_list|(
name|pi
operator|.
name|fd
argument_list|,
name|PIOCSTRACE
argument_list|,
operator|&
name|pi
operator|.
name|prrun
operator|.
name|pr_trace
argument_list|)
condition|)
block|{
name|print_sys_errmsg
argument_list|(
literal|"PIOCSTRACE failed"
argument_list|,
name|errno
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	proc_set_exec_trap -- arrange for exec'd child to halt at startup  SYNOPSIS  	void proc_set_exec_trap (void)  DESCRIPTION  	This function is called in the child process when starting up 	an inferior, prior to doing the exec of the actual inferior. 	It sets the child process's exitset to make exit from the exec 	system call an event of interest to stop on, and then simply 	returns.  The child does the exec, the system call returns, and 	the child stops at the first instruction, ready for the gdb 	parent process to take control of it.  NOTE  	We need to use all local variables since the child may be sharing 	it's data space with the parent, if vfork was used rather than 	fork.  	Also note that we want to turn off the inherit-on-fork flag in 	the child process so that any grand-children start with all 	tracing flags cleared.  */
end_comment

begin_function
specifier|static
name|void
name|proc_set_exec_trap
parameter_list|()
block|{
name|sysset_t
name|exitset
decl_stmt|;
specifier|auto
name|char
name|procname
index|[
literal|32
index|]
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|sprintf
argument_list|(
name|procname
argument_list|,
name|PROC_NAME_FMT
argument_list|,
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|procname
argument_list|,
name|O_RDWR
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
name|procname
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|127
argument_list|)
expr_stmt|;
block|}
name|premptyset
argument_list|(
operator|&
name|exitset
argument_list|)
expr_stmt|;
comment|/* GW: Rationale...      Not all systems with /proc have all the exec* syscalls with the same      names.  On the SGI, for example, there is no SYS_exec, but there      *is* a SYS_execv.  So, we try to account for that. */
ifdef|#
directive|ifdef
name|SYS_exec
name|praddset
argument_list|(
operator|&
name|exitset
argument_list|,
name|SYS_exec
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SYS_execve
name|praddset
argument_list|(
operator|&
name|exitset
argument_list|,
name|SYS_execve
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SYS_execv
name|praddset
argument_list|(
operator|&
name|exitset
argument_list|,
name|SYS_execv
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|PIOCSEXIT
argument_list|,
operator|&
name|exitset
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
name|procname
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|127
argument_list|)
expr_stmt|;
block|}
comment|/* Turn off inherit-on-fork flag so that all grand-children of gdb      start with tracing flags cleared. */
if|#
directive|if
name|defined
argument_list|(
name|PIOCRESET
argument_list|)
comment|/* New method */
block|{
name|long
name|pr_flags
decl_stmt|;
name|pr_flags
operator|=
name|PR_FORK
expr_stmt|;
name|ioctl
argument_list|(
name|fd
argument_list|,
name|PIOCRESET
argument_list|,
operator|&
name|pr_flags
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
if|#
directive|if
name|defined
argument_list|(
name|PIOCRFORK
argument_list|)
comment|/* Original method */
name|ioctl
argument_list|(
name|fd
argument_list|,
name|PIOCRFORK
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* Turn on run-on-last-close flag so that this process will not hang      if GDB goes away for some reason.  */
if|#
directive|if
name|defined
argument_list|(
name|PIOCSET
argument_list|)
comment|/* New method */
block|{
name|long
name|pr_flags
decl_stmt|;
name|pr_flags
operator|=
name|PR_RLC
expr_stmt|;
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|fd
argument_list|,
name|PIOCSET
argument_list|,
operator|&
name|pr_flags
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
if|#
directive|if
name|defined
argument_list|(
name|PIOCSRLC
argument_list|)
comment|/* Original method */
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|fd
argument_list|,
name|PIOCSRLC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  GLOBAL FUNCTION  	proc_iterate_over_mappings -- call function for every mapped space  SYNOPSIS  	int proc_iterate_over_mappings (int (*func)())  DESCRIPTION  	Given a pointer to a function, call that function for every 	mapped address space, passing it an open file descriptor for 	the file corresponding to that mapped address space (if any) 	and the base address of the mapped space.  Quit when we hit 	the end of the mappings or the function returns nonzero.  */
end_comment

begin_function_decl
name|int
name|proc_iterate_over_mappings
parameter_list|(
name|func
parameter_list|)
function_decl|int
parameter_list|(
function_decl|*func
end_function_decl

begin_expr_stmt
unit|)
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|CORE_ADDR
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|int
name|nmap
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|int
name|funcstat
init|=
literal|0
decl_stmt|;
name|struct
name|prmap
modifier|*
name|prmaps
decl_stmt|;
name|struct
name|prmap
modifier|*
name|prmap
decl_stmt|;
if|if
condition|(
name|pi
operator|.
name|valid
operator|&&
operator|(
name|ioctl
argument_list|(
name|pi
operator|.
name|fd
argument_list|,
name|PIOCNMAP
argument_list|,
operator|&
name|nmap
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|prmaps
operator|=
operator|(
expr|struct
name|prmap
operator|*
operator|)
name|alloca
argument_list|(
operator|(
name|nmap
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|prmaps
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|pi
operator|.
name|fd
argument_list|,
name|PIOCMAP
argument_list|,
name|prmaps
argument_list|)
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|prmap
operator|=
name|prmaps
init|;
name|prmap
operator|->
name|pr_size
operator|&&
name|funcstat
operator|==
literal|0
condition|;
operator|++
name|prmap
control|)
block|{
name|fd
operator|=
name|proc_address_to_fd
argument_list|(
operator|(
name|CORE_ADDR
operator|)
name|prmap
operator|->
name|pr_vaddr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|funcstat
operator|=
call|(
modifier|*
name|func
call|)
argument_list|(
name|fd
argument_list|,
operator|(
name|CORE_ADDR
operator|)
name|prmap
operator|->
name|pr_vaddr
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
operator|(
name|funcstat
operator|)
return|;
block|}
end_block

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Currently unused */
end_comment

begin_comment
comment|/*  GLOBAL FUNCTION  	proc_base_address -- find base address for segment containing address  SYNOPSIS  	CORE_ADDR proc_base_address (CORE_ADDR addr)  DESCRIPTION  	Given an address of a location in the inferior, find and return 	the base address of the mapped segment containing that address.  	This is used for example, by the shared library support code, 	where we have the pc value for some location in the shared library 	where we are stopped, and need to know the base address of the 	segment containing that address. */
end_comment

begin_endif
unit|CORE_ADDR proc_base_address (addr)      CORE_ADDR addr; {   int nmap;   struct prmap *prmaps;   struct prmap *prmap;   CORE_ADDR baseaddr = 0;    if (pi.valid&& (ioctl (pi.fd, PIOCNMAP,&nmap) == 0))     {       prmaps = (struct prmap *) alloca ((nmap + 1) * sizeof (*prmaps));       if (ioctl (pi.fd, PIOCMAP, prmaps) == 0) 	{ 	  for (prmap = prmaps; prmap -> pr_size; ++prmap) 	    { 	      if ((prmap -> pr_vaddr<= (caddr_t) addr)&& 		  (prmap -> pr_vaddr + prmap -> pr_size> (caddr_t) addr)) 		{ 		  baseaddr = (CORE_ADDR) prmap -> pr_vaddr; 		  break; 		} 	    } 	}     }   return (baseaddr); }
endif|#
directive|endif
end_endif

begin_comment
comment|/* 0 */
end_comment

begin_comment
comment|/*  LOCAL FUNCTION  	proc_address_to_fd -- return open fd for file mapped to address  SYNOPSIS  	int proc_address_to_fd (CORE_ADDR addr, complain)  DESCRIPTION  	Given an address in the current inferior's address space, use the 	/proc interface to find an open file descriptor for the file that 	this address was mapped in from.  Return -1 if there is no current 	inferior.  Print a warning message if there is an inferior but 	the address corresponds to no file (IE a bogus address).  */
end_comment

begin_function
specifier|static
name|int
name|proc_address_to_fd
parameter_list|(
name|addr
parameter_list|,
name|complain
parameter_list|)
name|CORE_ADDR
name|addr
decl_stmt|;
name|int
name|complain
decl_stmt|;
block|{
name|int
name|fd
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|pi
operator|.
name|valid
condition|)
block|{
if|if
condition|(
operator|(
name|fd
operator|=
name|ioctl
argument_list|(
name|pi
operator|.
name|fd
argument_list|,
name|PIOCOPENM
argument_list|,
operator|(
name|caddr_t
operator|*
operator|)
operator|&
name|addr
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|complain
condition|)
block|{
name|print_sys_errmsg
argument_list|(
name|pi
operator|.
name|pathname
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"can't find mapped file for address 0x%x"
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
operator|(
name|fd
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Attach to process PID, then initialize for debugging it    and wait for the trace-trap that results from attaching.  */
end_comment

begin_function
specifier|static
name|void
name|procfs_attach
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|char
modifier|*
name|exec_file
decl_stmt|;
name|int
name|pid
decl_stmt|;
if|if
condition|(
operator|!
name|args
condition|)
name|error_no_arg
argument_list|(
literal|"process-id to attach"
argument_list|)
expr_stmt|;
name|pid
operator|=
name|atoi
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|pid
operator|==
name|getpid
argument_list|()
condition|)
comment|/* Trying to masturbate? */
name|error
argument_list|(
literal|"I refuse to debug myself!"
argument_list|)
expr_stmt|;
if|if
condition|(
name|from_tty
condition|)
block|{
name|exec_file
operator|=
operator|(
name|char
operator|*
operator|)
name|get_exec_file
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|exec_file
condition|)
name|printf
argument_list|(
literal|"Attaching program `%s', pid %d\n"
argument_list|,
name|exec_file
argument_list|,
name|pid
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"Attaching pid %d\n"
argument_list|,
name|pid
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
name|do_attach
argument_list|(
name|pid
argument_list|)
expr_stmt|;
name|inferior_pid
operator|=
name|pid
expr_stmt|;
name|push_target
argument_list|(
operator|&
name|procfs_ops
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Take a program previously attached to and detaches it.    The program resumes execution and will no longer stop    on signals, etc.  We'd better not have left any breakpoints    in the program or it'll die when it hits one.  For this    to work, it may be necessary for the process to have been    previously attached.  It *might* work if the program was    started via the normal ptrace (PTRACE_TRACEME).  */
end_comment

begin_function
specifier|static
name|void
name|procfs_detach
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|int
name|siggnal
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|from_tty
condition|)
block|{
name|char
modifier|*
name|exec_file
init|=
name|get_exec_file
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|exec_file
operator|==
literal|0
condition|)
name|exec_file
operator|=
literal|""
expr_stmt|;
name|printf
argument_list|(
literal|"Detaching program: %s pid %d\n"
argument_list|,
name|exec_file
argument_list|,
name|inferior_pid
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|args
condition|)
name|siggnal
operator|=
name|atoi
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|do_detach
argument_list|(
name|siggnal
argument_list|)
expr_stmt|;
name|inferior_pid
operator|=
literal|0
expr_stmt|;
name|unpush_target
argument_list|(
operator|&
name|procfs_ops
argument_list|)
expr_stmt|;
comment|/* Pop out of handling an inferior */
block|}
end_function

begin_comment
comment|/* Get ready to modify the registers array.  On machines which store    individual registers, this doesn't need to do anything.  On machines    which store all the registers in one fell swoop, this makes sure    that registers contains all the registers from the program being    debugged.  */
end_comment

begin_function
specifier|static
name|void
name|procfs_prepare_to_store
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|CHILD_PREPARE_TO_STORE
name|CHILD_PREPARE_TO_STORE
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Print status information about what we're accessing.  */
end_comment

begin_function
specifier|static
name|void
name|procfs_files_info
parameter_list|(
name|ignore
parameter_list|)
name|struct
name|target_ops
modifier|*
name|ignore
decl_stmt|;
block|{
name|printf
argument_list|(
literal|"\tUsing the running image of %s process %d via /proc.\n"
argument_list|,
name|attach_flag
condition|?
literal|"attached"
else|:
literal|"child"
argument_list|,
name|inferior_pid
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|procfs_open
parameter_list|(
name|arg
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|error
argument_list|(
literal|"Use the \"run\" command to start a Unix child process."
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	do_attach -- attach to an already existing process  SYNOPSIS  	int do_attach (int pid)  DESCRIPTION  	Attach to an already existing process with the specified process 	id.  If the process is not already stopped, query whether to 	stop it or not.  NOTES  	The option of stopping at attach time is specific to the /proc 	versions of gdb.  Versions using ptrace force the attachee 	to stop.  (I have changed this version to do so, too.  All you 	have to do is "continue" to make it go on. -- gnu@cygnus.com)  */
end_comment

begin_function
specifier|static
name|int
name|do_attach
parameter_list|(
name|pid
parameter_list|)
name|int
name|pid
decl_stmt|;
block|{
name|int
name|result
decl_stmt|;
if|if
condition|(
operator|!
name|open_proc_file
argument_list|(
name|pid
argument_list|,
operator|&
name|pi
argument_list|,
name|O_RDWR
argument_list|)
condition|)
block|{
name|perror_with_name
argument_list|(
name|pi
operator|.
name|pathname
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
comment|/*  Get current status of process and if it is not already stopped,       then stop it.  Remember whether or not it was stopped when we first       examined it. */
if|if
condition|(
name|ioctl
argument_list|(
name|pi
operator|.
name|fd
argument_list|,
name|PIOCSTATUS
argument_list|,
operator|&
name|pi
operator|.
name|prstatus
argument_list|)
operator|<
literal|0
condition|)
block|{
name|print_sys_errmsg
argument_list|(
name|pi
operator|.
name|pathname
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|close_proc_file
argument_list|(
operator|&
name|pi
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"PIOCSTATUS failed"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pi
operator|.
name|prstatus
operator|.
name|pr_flags
operator|&
operator|(
name|PR_STOPPED
operator||
name|PR_ISTOP
operator|)
condition|)
block|{
name|pi
operator|.
name|was_stopped
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|pi
operator|.
name|was_stopped
operator|=
literal|0
expr_stmt|;
if|if
condition|(
literal|1
operator|||
name|query
argument_list|(
literal|"Process is currently running, stop it? "
argument_list|)
condition|)
block|{
comment|/* Make it run again when we close it.  */
if|#
directive|if
name|defined
argument_list|(
name|PIOCSET
argument_list|)
comment|/* New method */
block|{
name|long
name|pr_flags
decl_stmt|;
name|pr_flags
operator|=
name|PR_RLC
expr_stmt|;
name|result
operator|=
name|ioctl
argument_list|(
name|pi
operator|.
name|fd
argument_list|,
name|PIOCSET
argument_list|,
operator|&
name|pr_flags
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
if|#
directive|if
name|defined
argument_list|(
name|PIOCSRLC
argument_list|)
comment|/* Original method */
name|result
operator|=
name|ioctl
argument_list|(
name|pi
operator|.
name|fd
argument_list|,
name|PIOCSRLC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
if|if
condition|(
name|result
operator|<
literal|0
condition|)
block|{
name|print_sys_errmsg
argument_list|(
name|pi
operator|.
name|pathname
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|close_proc_file
argument_list|(
operator|&
name|pi
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"PIOCSRLC or PIOCSET failed"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ioctl
argument_list|(
name|pi
operator|.
name|fd
argument_list|,
name|PIOCSTOP
argument_list|,
operator|&
name|pi
operator|.
name|prstatus
argument_list|)
operator|<
literal|0
condition|)
block|{
name|print_sys_errmsg
argument_list|(
name|pi
operator|.
name|pathname
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|close_proc_file
argument_list|(
operator|&
name|pi
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"PIOCSTOP failed"
argument_list|)
expr_stmt|;
block|}
name|pi
operator|.
name|nopass_next_sigstop
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"Ok, gdb will wait for process %u to stop.\n"
argument_list|,
name|pid
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*  Remember some things about the inferior that we will, or might, change       so that we can restore them when we detach. */
name|ioctl
argument_list|(
name|pi
operator|.
name|fd
argument_list|,
name|PIOCGTRACE
argument_list|,
operator|&
name|pi
operator|.
name|saved_trace
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
name|pi
operator|.
name|fd
argument_list|,
name|PIOCGHOLD
argument_list|,
operator|&
name|pi
operator|.
name|saved_sighold
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
name|pi
operator|.
name|fd
argument_list|,
name|PIOCGFAULT
argument_list|,
operator|&
name|pi
operator|.
name|saved_fltset
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
name|pi
operator|.
name|fd
argument_list|,
name|PIOCGENTRY
argument_list|,
operator|&
name|pi
operator|.
name|saved_entryset
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
name|pi
operator|.
name|fd
argument_list|,
name|PIOCGEXIT
argument_list|,
operator|&
name|pi
operator|.
name|saved_exitset
argument_list|)
expr_stmt|;
comment|/* Set up trace and fault sets, as gdb expects them. */
name|memset
argument_list|(
operator|&
name|pi
operator|.
name|prrun
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|pi
operator|.
name|prrun
argument_list|)
argument_list|)
expr_stmt|;
name|prfillset
argument_list|(
operator|&
name|pi
operator|.
name|prrun
operator|.
name|pr_trace
argument_list|)
expr_stmt|;
name|procfs_notice_signals
argument_list|()
expr_stmt|;
name|prfillset
argument_list|(
operator|&
name|pi
operator|.
name|prrun
operator|.
name|pr_fault
argument_list|)
expr_stmt|;
name|prdelset
argument_list|(
operator|&
name|pi
operator|.
name|prrun
operator|.
name|pr_fault
argument_list|,
name|FLTPAGE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|pi
operator|.
name|fd
argument_list|,
name|PIOCSFAULT
argument_list|,
operator|&
name|pi
operator|.
name|prrun
operator|.
name|pr_fault
argument_list|)
condition|)
block|{
name|print_sys_errmsg
argument_list|(
literal|"PIOCSFAULT failed"
argument_list|,
name|errno
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ioctl
argument_list|(
name|pi
operator|.
name|fd
argument_list|,
name|PIOCSTRACE
argument_list|,
operator|&
name|pi
operator|.
name|prrun
operator|.
name|pr_trace
argument_list|)
condition|)
block|{
name|print_sys_errmsg
argument_list|(
literal|"PIOCSTRACE failed"
argument_list|,
name|errno
argument_list|)
expr_stmt|;
block|}
name|attach_flag
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|pid
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	do_detach -- detach from an attached-to process  SYNOPSIS  	void do_detach (int signal)  DESCRIPTION  	Detach from the current attachee.  	If signal is non-zero, the attachee is started running again and sent 	the specified signal.  	If signal is zero and the attachee was not already stopped when we 	attached to it, then we make it runnable again when we detach.  	Otherwise, we query whether or not to make the attachee runnable 	again, since we may simply want to leave it in the state it was in 	when we attached.  	We report any problems, but do not consider them errors, since we 	MUST detach even if some things don't seem to go right.  This may not 	be the ideal situation.  (FIXME).  */
end_comment

begin_function
specifier|static
name|void
name|do_detach
parameter_list|(
name|signal
parameter_list|)
name|int
name|signal
decl_stmt|;
block|{
name|int
name|result
decl_stmt|;
if|if
condition|(
name|signal
condition|)
block|{
name|set_proc_siginfo
argument_list|(
operator|&
name|pi
argument_list|,
name|signal
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ioctl
argument_list|(
name|pi
operator|.
name|fd
argument_list|,
name|PIOCSEXIT
argument_list|,
operator|&
name|pi
operator|.
name|saved_exitset
argument_list|)
operator|<
literal|0
condition|)
block|{
name|print_sys_errmsg
argument_list|(
name|pi
operator|.
name|pathname
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"PIOCSEXIT failed.\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ioctl
argument_list|(
name|pi
operator|.
name|fd
argument_list|,
name|PIOCSENTRY
argument_list|,
operator|&
name|pi
operator|.
name|saved_entryset
argument_list|)
operator|<
literal|0
condition|)
block|{
name|print_sys_errmsg
argument_list|(
name|pi
operator|.
name|pathname
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"PIOCSENTRY failed.\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ioctl
argument_list|(
name|pi
operator|.
name|fd
argument_list|,
name|PIOCSTRACE
argument_list|,
operator|&
name|pi
operator|.
name|saved_trace
argument_list|)
operator|<
literal|0
condition|)
block|{
name|print_sys_errmsg
argument_list|(
name|pi
operator|.
name|pathname
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"PIOCSTRACE failed.\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ioctl
argument_list|(
name|pi
operator|.
name|fd
argument_list|,
name|PIOCSHOLD
argument_list|,
operator|&
name|pi
operator|.
name|saved_sighold
argument_list|)
operator|<
literal|0
condition|)
block|{
name|print_sys_errmsg
argument_list|(
name|pi
operator|.
name|pathname
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"PIOSCHOLD failed.\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ioctl
argument_list|(
name|pi
operator|.
name|fd
argument_list|,
name|PIOCSFAULT
argument_list|,
operator|&
name|pi
operator|.
name|saved_fltset
argument_list|)
operator|<
literal|0
condition|)
block|{
name|print_sys_errmsg
argument_list|(
name|pi
operator|.
name|pathname
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"PIOCSFAULT failed.\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ioctl
argument_list|(
name|pi
operator|.
name|fd
argument_list|,
name|PIOCSTATUS
argument_list|,
operator|&
name|pi
operator|.
name|prstatus
argument_list|)
operator|<
literal|0
condition|)
block|{
name|print_sys_errmsg
argument_list|(
name|pi
operator|.
name|pathname
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"PIOCSTATUS failed.\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|signal
operator|||
operator|(
name|pi
operator|.
name|prstatus
operator|.
name|pr_flags
operator|&
operator|(
name|PR_STOPPED
operator||
name|PR_ISTOP
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|signal
operator|||
operator|!
name|pi
operator|.
name|was_stopped
operator|||
name|query
argument_list|(
literal|"Was stopped when attached, make it runnable again? "
argument_list|)
condition|)
block|{
comment|/* Clear any fault that might have stopped it.  */
if|if
condition|(
name|ioctl
argument_list|(
name|pi
operator|.
name|fd
argument_list|,
name|PIOCCFAULT
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|print_sys_errmsg
argument_list|(
name|pi
operator|.
name|pathname
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"PIOCCFAULT failed.\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Make it run again when we close it.  */
if|#
directive|if
name|defined
argument_list|(
name|PIOCSET
argument_list|)
comment|/* New method */
block|{
name|long
name|pr_flags
decl_stmt|;
name|pr_flags
operator|=
name|PR_RLC
expr_stmt|;
name|result
operator|=
name|ioctl
argument_list|(
name|pi
operator|.
name|fd
argument_list|,
name|PIOCSET
argument_list|,
operator|&
name|pr_flags
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
if|#
directive|if
name|defined
argument_list|(
name|PIOCSRLC
argument_list|)
comment|/* Original method */
name|result
operator|=
name|ioctl
argument_list|(
name|pi
operator|.
name|fd
argument_list|,
name|PIOCSRLC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
if|if
condition|(
name|result
condition|)
block|{
name|print_sys_errmsg
argument_list|(
name|pi
operator|.
name|pathname
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"PIOCSRLC or PIOCSET failed.\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
name|close_proc_file
argument_list|(
operator|&
name|pi
argument_list|)
expr_stmt|;
name|attach_flag
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	procfs_wait -- emulate wait() as much as possible 	Wait for child to do something.  Return pid of child, or -1 in case 	of error; store status through argument pointer STATUS.   SYNOPSIS  	int procfs_wait (int *statloc)  DESCRIPTION  	Try to emulate wait() as much as possible.  Not sure why we can't 	just use wait(), but it seems to have problems when applied to a 	process being controlled with the /proc interface.  NOTES  	We have a race problem here with no obvious solution.  We need to let 	the inferior run until it stops on an event of interest, which means 	that we need to use the PIOCWSTOP ioctl.  However, we cannot use this 	ioctl if the process is already stopped on something that is not an 	event of interest, or the call will hang indefinitely.  Thus we first 	use PIOCSTATUS to see if the process is not stopped.  If not, then we 	use PIOCWSTOP.  But during the window between the two, if the process 	stops for any reason that is not an event of interest (such as a job 	control signal) then gdb will hang.  One possible workaround is to set 	an alarm to wake up every minute of so and check to see if the process 	is still running, and if so, then reissue the PIOCWSTOP.  But this is 	a real kludge, so has not been implemented.  FIXME: investigate 	alternatives.  	FIXME:  Investigate why wait() seems to have problems with programs 	being control by /proc routines.   */
end_comment

begin_function
specifier|static
name|int
name|procfs_wait
parameter_list|(
name|statloc
parameter_list|)
name|int
modifier|*
name|statloc
decl_stmt|;
block|{
name|short
name|what
decl_stmt|;
name|short
name|why
decl_stmt|;
name|int
name|statval
init|=
literal|0
decl_stmt|;
name|int
name|checkerr
init|=
literal|0
decl_stmt|;
name|int
name|rtnval
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|pi
operator|.
name|fd
argument_list|,
name|PIOCSTATUS
argument_list|,
operator|&
name|pi
operator|.
name|prstatus
argument_list|)
operator|<
literal|0
condition|)
block|{
name|checkerr
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|pi
operator|.
name|prstatus
operator|.
name|pr_flags
operator|&
operator|(
name|PR_STOPPED
operator||
name|PR_ISTOP
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|ioctl
argument_list|(
name|pi
operator|.
name|fd
argument_list|,
name|PIOCWSTOP
argument_list|,
operator|&
name|pi
operator|.
name|prstatus
argument_list|)
operator|<
literal|0
condition|)
block|{
name|checkerr
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|checkerr
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ENOENT
condition|)
block|{
name|rtnval
operator|=
name|wait
argument_list|(
operator|&
name|statval
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtnval
operator|!=
name|inferior_pid
condition|)
block|{
name|print_sys_errmsg
argument_list|(
name|pi
operator|.
name|pathname
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"PIOCWSTOP, wait failed, returned %d"
argument_list|,
name|rtnval
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
block|}
else|else
block|{
name|print_sys_errmsg
argument_list|(
name|pi
operator|.
name|pathname
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"PIOCSTATUS or PIOCWSTOP failed."
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
block|}
elseif|else
if|if
condition|(
name|pi
operator|.
name|prstatus
operator|.
name|pr_flags
operator|&
operator|(
name|PR_STOPPED
operator||
name|PR_ISTOP
operator|)
condition|)
block|{
name|rtnval
operator|=
name|pi
operator|.
name|prstatus
operator|.
name|pr_pid
expr_stmt|;
name|why
operator|=
name|pi
operator|.
name|prstatus
operator|.
name|pr_why
expr_stmt|;
name|what
operator|=
name|pi
operator|.
name|prstatus
operator|.
name|pr_what
expr_stmt|;
if|if
condition|(
name|why
operator|==
name|PR_SIGNALLED
condition|)
block|{
name|statval
operator|=
operator|(
name|what
operator|<<
literal|8
operator|)
operator||
literal|0177
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|why
operator|==
name|PR_SYSEXIT
operator|)
operator|&&
operator|(
ifdef|#
directive|ifdef
name|SYS_exec
name|what
operator|==
name|SYS_exec
else|#
directive|else
literal|0
operator|==
literal|0
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SYS_execve
operator|||
name|what
operator|==
name|SYS_execve
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SYS_execv
operator|||
name|what
operator|==
name|SYS_execv
endif|#
directive|endif
operator|)
condition|)
block|{
name|statval
operator|=
operator|(
name|SIGTRAP
operator|<<
literal|8
operator|)
operator||
literal|0177
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|why
operator|==
name|PR_REQUESTED
condition|)
block|{
name|statval
operator|=
operator|(
name|SIGSTOP
operator|<<
literal|8
operator|)
operator||
literal|0177
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|why
operator|==
name|PR_JOBCONTROL
condition|)
block|{
name|statval
operator|=
operator|(
name|what
operator|<<
literal|8
operator|)
operator||
literal|0177
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|why
operator|==
name|PR_FAULTED
condition|)
block|{
switch|switch
condition|(
name|what
condition|)
block|{
case|case
name|FLTPRIV
case|:
case|case
name|FLTILL
case|:
name|statval
operator|=
operator|(
name|SIGILL
operator|<<
literal|8
operator|)
operator||
literal|0177
expr_stmt|;
break|break;
case|case
name|FLTBPT
case|:
case|case
name|FLTTRACE
case|:
name|statval
operator|=
operator|(
name|SIGTRAP
operator|<<
literal|8
operator|)
operator||
literal|0177
expr_stmt|;
break|break;
case|case
name|FLTSTACK
case|:
case|case
name|FLTACCESS
case|:
case|case
name|FLTBOUNDS
case|:
name|statval
operator|=
operator|(
name|SIGSEGV
operator|<<
literal|8
operator|)
operator||
literal|0177
expr_stmt|;
break|break;
case|case
name|FLTIOVF
case|:
case|case
name|FLTIZDIV
case|:
case|case
name|FLTFPE
case|:
name|statval
operator|=
operator|(
name|SIGFPE
operator|<<
literal|8
operator|)
operator||
literal|0177
expr_stmt|;
break|break;
case|case
name|FLTPAGE
case|:
comment|/* Recoverable page fault */
default|default:
name|rtnval
operator|=
operator|-
literal|1
expr_stmt|;
name|error
argument_list|(
literal|"PIOCWSTOP, unknown why %d, what %d"
argument_list|,
name|why
argument_list|,
name|what
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
block|}
else|else
block|{
name|rtnval
operator|=
operator|-
literal|1
expr_stmt|;
name|error
argument_list|(
literal|"PIOCWSTOP, unknown why %d, what %d"
argument_list|,
name|why
argument_list|,
name|what
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
block|}
else|else
block|{
name|error
argument_list|(
literal|"PIOCWSTOP, stopped for unknown/unhandled reason, flags %#x"
argument_list|,
name|pi
operator|.
name|prstatus
operator|.
name|pr_flags
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
if|if
condition|(
name|statloc
condition|)
block|{
operator|*
name|statloc
operator|=
name|statval
expr_stmt|;
block|}
if|if
condition|(
name|rtnval
operator|==
operator|-
literal|1
condition|)
comment|/* No more children to wait for */
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Child process unexpectedly missing.\n"
argument_list|)
expr_stmt|;
operator|*
name|statloc
operator|=
literal|42
expr_stmt|;
comment|/* Claim it exited with signal 42 */
return|return
name|rtnval
return|;
block|}
return|return
operator|(
name|rtnval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	set_proc_siginfo - set a process's current signal info  SYNOPSIS  	void set_proc_siginfo (struct procinfo *pip, int signo);  DESCRIPTION  	Given a pointer to a process info struct in PIP and a signal number 	in SIGNO, set the process's current signal and its associated signal 	information.  The signal will be delivered to the process immediately 	after execution is resumed, even if it is being held.  In addition, 	this particular delivery will not cause another PR_SIGNALLED stop 	even if the signal is being traced.  	If we are not delivering the same signal that the prstatus siginfo 	struct contains information about, then synthesize a siginfo struct 	to match the signal we are doing to deliver, make it of the type 	"generated by a user process", and send this synthesized copy.  When 	used to set the inferior's signal state, this will be required if we 	are not currently stopped because of a traced signal, or if we decide 	to continue with a different signal.  	Note that when continuing the inferior from a stop due to receipt 	of a traced signal, we either have set PRCSIG to clear the existing 	signal, or we have to call this function to do a PIOCSSIG with either 	the existing siginfo struct from pr_info, or one we have synthesized 	appropriately for the signal we want to deliver.  Otherwise if the 	signal is still being traced, the inferior will immediately stop 	again.  	See siginfo(5) for more details. */
end_comment

begin_function
specifier|static
name|void
name|set_proc_siginfo
parameter_list|(
name|pip
parameter_list|,
name|signo
parameter_list|)
name|struct
name|procinfo
modifier|*
name|pip
decl_stmt|;
name|int
name|signo
decl_stmt|;
block|{
name|struct
name|siginfo
name|newsiginfo
decl_stmt|;
name|struct
name|siginfo
modifier|*
name|sip
decl_stmt|;
if|if
condition|(
name|pip
operator|->
name|valid
condition|)
block|{
if|if
condition|(
name|signo
operator|==
name|pip
operator|->
name|prstatus
operator|.
name|pr_info
operator|.
name|si_signo
condition|)
block|{
name|sip
operator|=
operator|&
name|pip
operator|->
name|prstatus
operator|.
name|pr_info
expr_stmt|;
block|}
else|else
block|{
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|newsiginfo
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|newsiginfo
argument_list|)
argument_list|)
expr_stmt|;
name|sip
operator|=
operator|&
name|newsiginfo
expr_stmt|;
name|sip
operator|->
name|si_signo
operator|=
name|signo
expr_stmt|;
name|sip
operator|->
name|si_code
operator|=
literal|0
expr_stmt|;
name|sip
operator|->
name|si_errno
operator|=
literal|0
expr_stmt|;
name|sip
operator|->
name|si_pid
operator|=
name|getpid
argument_list|()
expr_stmt|;
name|sip
operator|->
name|si_uid
operator|=
name|getuid
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|ioctl
argument_list|(
name|pip
operator|->
name|fd
argument_list|,
name|PIOCSSIG
argument_list|,
name|sip
argument_list|)
operator|<
literal|0
condition|)
block|{
name|print_sys_errmsg
argument_list|(
name|pip
operator|->
name|pathname
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"PIOCSSIG failed"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	procfs_resume -- resume execution of the inferior process  SYNOPSIS  	void procfs_resume (int step, int signo)  DESCRIPTION  	Resume execution of the inferior process.  If STEP is nozero, then 	just single step it.  If SIGNAL is nonzero, restart it with that 	signal activated.  NOTE  	It may not be absolutely necessary to specify the PC value for 	restarting, but to be safe we use the value that gdb considers 	to be current.  One case where this might be necessary is if the 	user explicitly changes the PC value that gdb considers to be 	current.  FIXME:  Investigate if this is necessary or not.  	When attaching to a child process, if we forced it to stop with 	a PIOCSTOP, then we will have set the nopass_next_sigstop flag. 	Upon resuming the first time after such a stop, we explicitly 	inhibit sending it another SIGSTOP, which would be the normal 	result of default signal handling.  One potential drawback to 	this is that we will also ignore any attempt to by the user 	to explicitly continue after the attach with a SIGSTOP.  Ultimately 	this problem should be dealt with by making the routines that 	deal with the inferior a little smarter, and possibly even allow 	an inferior to continue running at the same time as gdb.  (FIXME?)  */
end_comment

begin_function
specifier|static
name|void
name|procfs_resume
parameter_list|(
name|step
parameter_list|,
name|signo
parameter_list|)
name|int
name|step
decl_stmt|;
name|int
name|signo
decl_stmt|;
block|{
name|errno
operator|=
literal|0
expr_stmt|;
name|pi
operator|.
name|prrun
operator|.
name|pr_flags
operator|=
name|PRSTRACE
operator||
name|PRSFAULT
operator||
name|PRCFAULT
expr_stmt|;
ifdef|#
directive|ifdef
name|PRSVADDR_BROKEN
comment|/* Can't do this under Solaris running on a Sparc, as there seems to be no    place to put nPC.  In fact, if you use this, nPC seems to be set to some    random garbage.  We have to rely on the fact that PC and nPC have been    written previously via PIOCSREG during a register flush. */
name|pi
operator|.
name|prrun
operator|.
name|pr_vaddr
operator|=
operator|(
name|caddr_t
operator|)
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|PC_REGNUM
argument_list|)
index|]
expr_stmt|;
name|pi
operator|.
name|prrun
operator|.
name|pr_flags
operator|!=
name|PRSVADDR
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|signo
operator|&&
operator|!
operator|(
name|signo
operator|==
name|SIGSTOP
operator|&&
name|pi
operator|.
name|nopass_next_sigstop
operator|)
condition|)
block|{
name|set_proc_siginfo
argument_list|(
operator|&
name|pi
argument_list|,
name|signo
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pi
operator|.
name|prrun
operator|.
name|pr_flags
operator||=
name|PRCSIG
expr_stmt|;
block|}
name|pi
operator|.
name|nopass_next_sigstop
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|step
condition|)
block|{
name|pi
operator|.
name|prrun
operator|.
name|pr_flags
operator||=
name|PRSTEP
expr_stmt|;
block|}
if|if
condition|(
name|ioctl
argument_list|(
name|pi
operator|.
name|fd
argument_list|,
name|PIOCRUN
argument_list|,
operator|&
name|pi
operator|.
name|prrun
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|perror_with_name
argument_list|(
name|pi
operator|.
name|pathname
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	procfs_fetch_registers -- fetch current registers from inferior  SYNOPSIS  	void procfs_fetch_registers (int regno)  DESCRIPTION  	Read the current values of the inferior's registers, both the 	general register set and floating point registers (if supported) 	and update gdb's idea of their current values.  */
end_comment

begin_function
specifier|static
name|void
name|procfs_fetch_registers
parameter_list|(
name|regno
parameter_list|)
name|int
name|regno
decl_stmt|;
block|{
if|if
condition|(
name|ioctl
argument_list|(
name|pi
operator|.
name|fd
argument_list|,
name|PIOCGREG
argument_list|,
operator|&
name|pi
operator|.
name|gregset
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|supply_gregset
argument_list|(
operator|&
name|pi
operator|.
name|gregset
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|FP0_REGNUM
argument_list|)
if|if
condition|(
name|ioctl
argument_list|(
name|pi
operator|.
name|fd
argument_list|,
name|PIOCGFPREG
argument_list|,
operator|&
name|pi
operator|.
name|fpregset
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|supply_fpregset
argument_list|(
operator|&
name|pi
operator|.
name|fpregset
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  GLOBAL FUNCTION  	fetch_core_registers -- fetch current registers from core file data  SYNOPSIS  	void fetch_core_registers (char *core_reg_sect, unsigned core_reg_size, 				   int which, unsigned in reg_addr)  DESCRIPTION  	Read the values of either the general register set (WHICH equals 0) 	or the floating point register set (WHICH equals 2) from the core 	file data (pointed to by CORE_REG_SECT), and update gdb's idea of 	their current values.  The CORE_REG_SIZE parameter is ignored.  NOTES  	Use the indicated sizes to validate the gregset and fpregset 	structures. */
end_comment

begin_function
name|void
name|fetch_core_registers
parameter_list|(
name|core_reg_sect
parameter_list|,
name|core_reg_size
parameter_list|,
name|which
parameter_list|,
name|reg_addr
parameter_list|)
name|char
modifier|*
name|core_reg_sect
decl_stmt|;
name|unsigned
name|core_reg_size
decl_stmt|;
name|int
name|which
decl_stmt|;
name|unsigned
name|int
name|reg_addr
decl_stmt|;
comment|/* Unused in this version */
block|{
if|if
condition|(
name|which
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|core_reg_size
operator|!=
sizeof|sizeof
argument_list|(
name|pi
operator|.
name|gregset
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|"wrong size gregset struct in core file"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|pi
operator|.
name|gregset
argument_list|,
name|core_reg_sect
argument_list|,
sizeof|sizeof
argument_list|(
name|pi
operator|.
name|gregset
argument_list|)
argument_list|)
expr_stmt|;
name|supply_gregset
argument_list|(
operator|&
name|pi
operator|.
name|gregset
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|which
operator|==
literal|2
condition|)
block|{
if|if
condition|(
name|core_reg_size
operator|!=
sizeof|sizeof
argument_list|(
name|pi
operator|.
name|fpregset
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|"wrong size fpregset struct in core file"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|pi
operator|.
name|fpregset
argument_list|,
name|core_reg_sect
argument_list|,
sizeof|sizeof
argument_list|(
name|pi
operator|.
name|fpregset
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|FP0_REGNUM
argument_list|)
name|supply_fpregset
argument_list|(
operator|&
name|pi
operator|.
name|fpregset
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	proc_init_failed - called whenever /proc access initialization fails  SYNOPSIS  	static void proc_init_failed (char *why)  DESCRIPTION  	This function is called whenever initialization of access to a /proc 	entry fails.  It prints a suitable error message, does some cleanup, 	and then invokes the standard error processing routine which dumps 	us back into the command loop.  */
end_comment

begin_function
specifier|static
name|void
name|proc_init_failed
parameter_list|(
name|why
parameter_list|)
name|char
modifier|*
name|why
decl_stmt|;
block|{
name|print_sys_errmsg
argument_list|(
name|pi
operator|.
name|pathname
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|kill
argument_list|(
name|pi
operator|.
name|pid
argument_list|,
name|SIGKILL
argument_list|)
expr_stmt|;
name|close_proc_file
argument_list|(
operator|&
name|pi
argument_list|)
expr_stmt|;
name|error
argument_list|(
name|why
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	close_proc_file - close any currently open /proc entry  SYNOPSIS  	static void close_proc_file (struct procinfo *pip)  DESCRIPTION  	Close any currently open /proc entry and mark the process information 	entry as invalid.  In order to ensure that we don't try to reuse any 	stale information, the pid, fd, and pathnames are explicitly 	invalidated, which may be overkill.   */
end_comment

begin_function
specifier|static
name|void
name|close_proc_file
parameter_list|(
name|pip
parameter_list|)
name|struct
name|procinfo
modifier|*
name|pip
decl_stmt|;
block|{
name|pip
operator|->
name|pid
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pip
operator|->
name|valid
condition|)
block|{
name|close
argument_list|(
name|pip
operator|->
name|fd
argument_list|)
expr_stmt|;
block|}
name|pip
operator|->
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|pip
operator|->
name|pathname
condition|)
block|{
name|free
argument_list|(
name|pip
operator|->
name|pathname
argument_list|)
expr_stmt|;
name|pip
operator|->
name|pathname
operator|=
name|NULL
expr_stmt|;
block|}
name|pip
operator|->
name|valid
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	open_proc_file - open a /proc entry for a given process id  SYNOPSIS  	static int open_proc_file (int pid, struct procinfo *pip, int mode)  DESCRIPTION  	Given a process id and a mode, close the existing open /proc 	entry (if any) and open one for the new process id, in the 	specified mode.  Once it is open, then mark the local process 	information structure as valid, which guarantees that the pid, 	fd, and pathname fields match an open /proc entry.  Returns 	zero if the open fails, nonzero otherwise.  	Note that the pathname is left intact, even when the open fails, 	so that callers can use it to construct meaningful error messages 	rather than just "file open failed".  */
end_comment

begin_function
specifier|static
name|int
name|open_proc_file
parameter_list|(
name|pid
parameter_list|,
name|pip
parameter_list|,
name|mode
parameter_list|)
name|int
name|pid
decl_stmt|;
name|struct
name|procinfo
modifier|*
name|pip
decl_stmt|;
name|int
name|mode
decl_stmt|;
block|{
name|pip
operator|->
name|valid
operator|=
literal|0
expr_stmt|;
comment|/* FIXME, what is this? ?!  */
if|if
condition|(
name|pip
operator|->
name|valid
condition|)
block|{
name|close
argument_list|(
name|pip
operator|->
name|fd
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pip
operator|->
name|pathname
operator|==
name|NULL
condition|)
block|{
name|pip
operator|->
name|pathname
operator|=
name|xmalloc
argument_list|(
literal|32
argument_list|)
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|pip
operator|->
name|pathname
argument_list|,
name|PROC_NAME_FMT
argument_list|,
name|pid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pip
operator|->
name|fd
operator|=
name|open
argument_list|(
name|pip
operator|->
name|pathname
argument_list|,
name|mode
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
name|pip
operator|->
name|valid
operator|=
literal|1
expr_stmt|;
name|pip
operator|->
name|pid
operator|=
name|pid
expr_stmt|;
block|}
return|return
operator|(
name|pip
operator|->
name|valid
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|mappingflags
parameter_list|(
name|flags
parameter_list|)
name|long
name|flags
decl_stmt|;
block|{
specifier|static
name|char
name|asciiflags
index|[
literal|8
index|]
decl_stmt|;
name|strcpy
argument_list|(
name|asciiflags
argument_list|,
literal|"-------"
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|MA_PHYS
argument_list|)
if|if
condition|(
name|flags
operator|&
name|MA_PHYS
condition|)
name|asciiflags
index|[
literal|0
index|]
operator|=
literal|'d'
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|flags
operator|&
name|MA_STACK
condition|)
name|asciiflags
index|[
literal|1
index|]
operator|=
literal|'s'
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|MA_BREAK
condition|)
name|asciiflags
index|[
literal|2
index|]
operator|=
literal|'b'
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|MA_SHARED
condition|)
name|asciiflags
index|[
literal|3
index|]
operator|=
literal|'s'
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|MA_READ
condition|)
name|asciiflags
index|[
literal|4
index|]
operator|=
literal|'r'
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|MA_WRITE
condition|)
name|asciiflags
index|[
literal|5
index|]
operator|=
literal|'w'
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|MA_EXEC
condition|)
name|asciiflags
index|[
literal|6
index|]
operator|=
literal|'x'
expr_stmt|;
return|return
operator|(
name|asciiflags
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|info_proc_flags
parameter_list|(
name|pip
parameter_list|,
name|summary
parameter_list|)
name|struct
name|procinfo
modifier|*
name|pip
decl_stmt|;
name|int
name|summary
decl_stmt|;
block|{
name|struct
name|trans
modifier|*
name|transp
decl_stmt|;
name|printf_filtered
argument_list|(
literal|"%-32s"
argument_list|,
literal|"Process status flags:"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|summary
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"\n\n"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|transp
operator|=
name|pr_flag_table
init|;
name|transp
operator|->
name|name
operator|!=
name|NULL
condition|;
name|transp
operator|++
control|)
block|{
if|if
condition|(
name|pip
operator|->
name|prstatus
operator|.
name|pr_flags
operator|&
name|transp
operator|->
name|value
condition|)
block|{
if|if
condition|(
name|summary
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"%s "
argument_list|,
name|transp
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf_filtered
argument_list|(
literal|"\t%-16s %s.\n"
argument_list|,
name|transp
operator|->
name|name
argument_list|,
name|transp
operator|->
name|desc
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|info_proc_stop
parameter_list|(
name|pip
parameter_list|,
name|summary
parameter_list|)
name|struct
name|procinfo
modifier|*
name|pip
decl_stmt|;
name|int
name|summary
decl_stmt|;
block|{
name|struct
name|trans
modifier|*
name|transp
decl_stmt|;
name|int
name|why
decl_stmt|;
name|int
name|what
decl_stmt|;
name|why
operator|=
name|pip
operator|->
name|prstatus
operator|.
name|pr_why
expr_stmt|;
name|what
operator|=
name|pip
operator|->
name|prstatus
operator|.
name|pr_what
expr_stmt|;
if|if
condition|(
name|pip
operator|->
name|prstatus
operator|.
name|pr_flags
operator|&
name|PR_STOPPED
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"%-32s"
argument_list|,
literal|"Reason for stopping:"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|summary
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"\n\n"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|transp
operator|=
name|pr_why_table
init|;
name|transp
operator|->
name|name
operator|!=
name|NULL
condition|;
name|transp
operator|++
control|)
block|{
if|if
condition|(
name|why
operator|==
name|transp
operator|->
name|value
condition|)
block|{
if|if
condition|(
name|summary
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"%s "
argument_list|,
name|transp
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf_filtered
argument_list|(
literal|"\t%-16s %s.\n"
argument_list|,
name|transp
operator|->
name|name
argument_list|,
name|transp
operator|->
name|desc
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
comment|/* Use the pr_why field to determine what the pr_what field means, and 	 print more information. */
switch|switch
condition|(
name|why
condition|)
block|{
case|case
name|PR_REQUESTED
case|:
comment|/* pr_what is unused for this case */
break|break;
case|case
name|PR_JOBCONTROL
case|:
case|case
name|PR_SIGNALLED
case|:
if|if
condition|(
name|summary
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"%s "
argument_list|,
name|signalname
argument_list|(
name|what
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf_filtered
argument_list|(
literal|"\t%-16s %s.\n"
argument_list|,
name|signalname
argument_list|(
name|what
argument_list|)
argument_list|,
name|safe_strsignal
argument_list|(
name|what
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PR_SYSENTRY
case|:
if|if
condition|(
name|summary
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"%s "
argument_list|,
name|syscallname
argument_list|(
name|what
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf_filtered
argument_list|(
literal|"\t%-16s %s.\n"
argument_list|,
name|syscallname
argument_list|(
name|what
argument_list|)
argument_list|,
literal|"Entered this system call"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PR_SYSEXIT
case|:
if|if
condition|(
name|summary
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"%s "
argument_list|,
name|syscallname
argument_list|(
name|what
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf_filtered
argument_list|(
literal|"\t%-16s %s.\n"
argument_list|,
name|syscallname
argument_list|(
name|what
argument_list|)
argument_list|,
literal|"Returned from this system call"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PR_FAULTED
case|:
if|if
condition|(
name|summary
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"%s "
argument_list|,
name|lookupname
argument_list|(
name|faults_table
argument_list|,
name|what
argument_list|,
literal|"fault"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf_filtered
argument_list|(
literal|"\t%-16s %s.\n"
argument_list|,
name|lookupname
argument_list|(
name|faults_table
argument_list|,
name|what
argument_list|,
literal|"fault"
argument_list|)
argument_list|,
name|lookupdesc
argument_list|(
name|faults_table
argument_list|,
name|what
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|info_proc_siginfo
parameter_list|(
name|pip
parameter_list|,
name|summary
parameter_list|)
name|struct
name|procinfo
modifier|*
name|pip
decl_stmt|;
name|int
name|summary
decl_stmt|;
block|{
name|struct
name|siginfo
modifier|*
name|sip
decl_stmt|;
if|if
condition|(
operator|(
name|pip
operator|->
name|prstatus
operator|.
name|pr_flags
operator|&
name|PR_STOPPED
operator|)
operator|&&
operator|(
name|pip
operator|->
name|prstatus
operator|.
name|pr_why
operator|==
name|PR_SIGNALLED
operator|||
name|pip
operator|->
name|prstatus
operator|.
name|pr_why
operator|==
name|PR_FAULTED
operator|)
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"%-32s"
argument_list|,
literal|"Additional signal/fault info:"
argument_list|)
expr_stmt|;
name|sip
operator|=
operator|&
name|pip
operator|->
name|prstatus
operator|.
name|pr_info
expr_stmt|;
if|if
condition|(
name|summary
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"%s "
argument_list|,
name|signalname
argument_list|(
name|sip
operator|->
name|si_signo
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sip
operator|->
name|si_errno
operator|>
literal|0
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"%s "
argument_list|,
name|errnoname
argument_list|(
name|sip
operator|->
name|si_errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sip
operator|->
name|si_code
operator|<=
literal|0
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"sent by pid %d, uid %d "
argument_list|,
name|sip
operator|->
name|si_pid
argument_list|,
name|sip
operator|->
name|si_uid
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf_filtered
argument_list|(
literal|"%s "
argument_list|,
name|sigcodename
argument_list|(
name|sip
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sip
operator|->
name|si_signo
operator|==
name|SIGILL
operator|)
operator|||
operator|(
name|sip
operator|->
name|si_signo
operator|==
name|SIGFPE
operator|)
operator|||
operator|(
name|sip
operator|->
name|si_signo
operator|==
name|SIGSEGV
operator|)
operator|||
operator|(
name|sip
operator|->
name|si_signo
operator|==
name|SIGBUS
operator|)
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"addr=%#x "
argument_list|,
name|sip
operator|->
name|si_addr
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|sip
operator|->
name|si_signo
operator|==
name|SIGCHLD
operator|)
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"child pid %u, status %u "
argument_list|,
name|sip
operator|->
name|si_pid
argument_list|,
name|sip
operator|->
name|si_status
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|sip
operator|->
name|si_signo
operator|==
name|SIGPOLL
operator|)
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"band %u "
argument_list|,
name|sip
operator|->
name|si_band
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|printf_filtered
argument_list|(
literal|"\n\n"
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\t%-16s %s.\n"
argument_list|,
name|signalname
argument_list|(
name|sip
operator|->
name|si_signo
argument_list|)
argument_list|,
name|safe_strsignal
argument_list|(
name|sip
operator|->
name|si_signo
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sip
operator|->
name|si_errno
operator|>
literal|0
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"\t%-16s %s.\n"
argument_list|,
name|errnoname
argument_list|(
name|sip
operator|->
name|si_errno
argument_list|)
argument_list|,
name|safe_strerror
argument_list|(
name|sip
operator|->
name|si_errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sip
operator|->
name|si_code
operator|<=
literal|0
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"\t%-16u %s\n"
argument_list|,
name|sip
operator|->
name|si_pid
argument_list|,
literal|"PID of process sending signal"
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\t%-16u %s\n"
argument_list|,
name|sip
operator|->
name|si_uid
argument_list|,
literal|"UID of process sending signal"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf_filtered
argument_list|(
literal|"\t%-16s %s.\n"
argument_list|,
name|sigcodename
argument_list|(
name|sip
argument_list|)
argument_list|,
name|sigcodedesc
argument_list|(
name|sip
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sip
operator|->
name|si_signo
operator|==
name|SIGILL
operator|)
operator|||
operator|(
name|sip
operator|->
name|si_signo
operator|==
name|SIGFPE
operator|)
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"\t%-16#x %s.\n"
argument_list|,
name|sip
operator|->
name|si_addr
argument_list|,
literal|"Address of faulting instruction"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|sip
operator|->
name|si_signo
operator|==
name|SIGSEGV
operator|)
operator|||
operator|(
name|sip
operator|->
name|si_signo
operator|==
name|SIGBUS
operator|)
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"\t%-16#x %s.\n"
argument_list|,
name|sip
operator|->
name|si_addr
argument_list|,
literal|"Address of faulting memory reference"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|sip
operator|->
name|si_signo
operator|==
name|SIGCHLD
operator|)
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"\t%-16u %s.\n"
argument_list|,
name|sip
operator|->
name|si_pid
argument_list|,
literal|"Child process ID"
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\t%-16u %s.\n"
argument_list|,
name|sip
operator|->
name|si_status
argument_list|,
literal|"Child process exit value or signal"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|sip
operator|->
name|si_signo
operator|==
name|SIGPOLL
operator|)
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"\t%-16u %s.\n"
argument_list|,
name|sip
operator|->
name|si_band
argument_list|,
literal|"Band event for POLL_{IN,OUT,MSG}"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|info_proc_syscalls
parameter_list|(
name|pip
parameter_list|,
name|summary
parameter_list|)
name|struct
name|procinfo
modifier|*
name|pip
decl_stmt|;
name|int
name|summary
decl_stmt|;
block|{
name|int
name|syscallnum
decl_stmt|;
if|if
condition|(
operator|!
name|summary
condition|)
block|{
if|#
directive|if
literal|0
comment|/* FIXME:  Needs to use gdb-wide configured info about system calls. */
block|if (pip -> prstatus.pr_flags& PR_ASLEEP) 	{ 	  int syscallnum = pip -> prstatus.pr_reg[R_D0]; 	  if (summary) 	    { 	      printf_filtered ("%-32s", "Sleeping in system call:"); 	      printf_filtered ("%s", syscallname (syscallnum)); 	    } 	  else 	    { 	      printf_filtered ("Sleeping in system call '%s'.\n", 			       syscallname (syscallnum)); 	    } 	}
endif|#
directive|endif
if|if
condition|(
name|ioctl
argument_list|(
name|pip
operator|->
name|fd
argument_list|,
name|PIOCGENTRY
argument_list|,
operator|&
name|pip
operator|->
name|entryset
argument_list|)
operator|<
literal|0
condition|)
block|{
name|print_sys_errmsg
argument_list|(
name|pip
operator|->
name|pathname
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"PIOCGENTRY failed"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ioctl
argument_list|(
name|pip
operator|->
name|fd
argument_list|,
name|PIOCGEXIT
argument_list|,
operator|&
name|pip
operator|->
name|exitset
argument_list|)
operator|<
literal|0
condition|)
block|{
name|print_sys_errmsg
argument_list|(
name|pip
operator|->
name|pathname
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"PIOCGEXIT failed"
argument_list|)
expr_stmt|;
block|}
name|printf_filtered
argument_list|(
literal|"System call tracing information:\n\n"
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\t%-12s %-8s %-8s\n"
argument_list|,
literal|"System call"
argument_list|,
literal|"Entry"
argument_list|,
literal|"Exit"
argument_list|)
expr_stmt|;
for|for
control|(
name|syscallnum
operator|=
literal|0
init|;
name|syscallnum
operator|<
name|MAX_SYSCALLS
condition|;
name|syscallnum
operator|++
control|)
block|{
name|QUIT
expr_stmt|;
if|if
condition|(
name|syscall_table
index|[
name|syscallnum
index|]
operator|!=
name|NULL
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"\t%-12s "
argument_list|,
name|syscall_table
index|[
name|syscallnum
index|]
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"%-8s "
argument_list|,
name|prismember
argument_list|(
operator|&
name|pip
operator|->
name|entryset
argument_list|,
name|syscallnum
argument_list|)
condition|?
literal|"on"
else|:
literal|"off"
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"%-8s "
argument_list|,
name|prismember
argument_list|(
operator|&
name|pip
operator|->
name|exitset
argument_list|,
name|syscallnum
argument_list|)
condition|?
literal|"on"
else|:
literal|"off"
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|signalname
parameter_list|(
name|signo
parameter_list|)
name|int
name|signo
decl_stmt|;
block|{
name|char
modifier|*
name|name
decl_stmt|;
specifier|static
name|char
name|locbuf
index|[
literal|32
index|]
decl_stmt|;
name|name
operator|=
name|strsigno
argument_list|(
name|signo
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
block|{
name|sprintf
argument_list|(
name|locbuf
argument_list|,
literal|"Signal %d"
argument_list|,
name|signo
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sprintf
argument_list|(
name|locbuf
argument_list|,
literal|"%s (%d)"
argument_list|,
name|name
argument_list|,
name|signo
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|locbuf
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|errnoname
parameter_list|(
name|errnum
parameter_list|)
name|int
name|errnum
decl_stmt|;
block|{
name|char
modifier|*
name|name
decl_stmt|;
specifier|static
name|char
name|locbuf
index|[
literal|32
index|]
decl_stmt|;
name|name
operator|=
name|strerrno
argument_list|(
name|errnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
block|{
name|sprintf
argument_list|(
name|locbuf
argument_list|,
literal|"Errno %d"
argument_list|,
name|errnum
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sprintf
argument_list|(
name|locbuf
argument_list|,
literal|"%s (%d)"
argument_list|,
name|name
argument_list|,
name|errnum
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|locbuf
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|info_proc_signals
parameter_list|(
name|pip
parameter_list|,
name|summary
parameter_list|)
name|struct
name|procinfo
modifier|*
name|pip
decl_stmt|;
name|int
name|summary
decl_stmt|;
block|{
name|int
name|signo
decl_stmt|;
if|if
condition|(
operator|!
name|summary
condition|)
block|{
if|if
condition|(
name|ioctl
argument_list|(
name|pip
operator|->
name|fd
argument_list|,
name|PIOCGTRACE
argument_list|,
operator|&
name|pip
operator|->
name|trace
argument_list|)
operator|<
literal|0
condition|)
block|{
name|print_sys_errmsg
argument_list|(
name|pip
operator|->
name|pathname
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"PIOCGTRACE failed"
argument_list|)
expr_stmt|;
block|}
name|printf_filtered
argument_list|(
literal|"Disposition of signals:\n\n"
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\t%-15s %-8s %-8s %-8s  %s\n\n"
argument_list|,
literal|"Signal"
argument_list|,
literal|"Trace"
argument_list|,
literal|"Hold"
argument_list|,
literal|"Pending"
argument_list|,
literal|"Description"
argument_list|)
expr_stmt|;
for|for
control|(
name|signo
operator|=
literal|0
init|;
name|signo
operator|<
name|NSIG
condition|;
name|signo
operator|++
control|)
block|{
name|QUIT
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\t%-15s "
argument_list|,
name|signalname
argument_list|(
name|signo
argument_list|)
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"%-8s "
argument_list|,
name|prismember
argument_list|(
operator|&
name|pip
operator|->
name|trace
argument_list|,
name|signo
argument_list|)
condition|?
literal|"on"
else|:
literal|"off"
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"%-8s "
argument_list|,
name|prismember
argument_list|(
operator|&
name|pip
operator|->
name|prstatus
operator|.
name|pr_sighold
argument_list|,
name|signo
argument_list|)
condition|?
literal|"on"
else|:
literal|"off"
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"%-8s "
argument_list|,
name|prismember
argument_list|(
operator|&
name|pip
operator|->
name|prstatus
operator|.
name|pr_sigpend
argument_list|,
name|signo
argument_list|)
condition|?
literal|"yes"
else|:
literal|"no"
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|" %s\n"
argument_list|,
name|safe_strsignal
argument_list|(
name|signo
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|info_proc_faults
parameter_list|(
name|pip
parameter_list|,
name|summary
parameter_list|)
name|struct
name|procinfo
modifier|*
name|pip
decl_stmt|;
name|int
name|summary
decl_stmt|;
block|{
name|struct
name|trans
modifier|*
name|transp
decl_stmt|;
if|if
condition|(
operator|!
name|summary
condition|)
block|{
if|if
condition|(
name|ioctl
argument_list|(
name|pip
operator|->
name|fd
argument_list|,
name|PIOCGFAULT
argument_list|,
operator|&
name|pip
operator|->
name|fltset
argument_list|)
operator|<
literal|0
condition|)
block|{
name|print_sys_errmsg
argument_list|(
name|pip
operator|->
name|pathname
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"PIOCGFAULT failed"
argument_list|)
expr_stmt|;
block|}
name|printf_filtered
argument_list|(
literal|"Current traced hardware fault set:\n\n"
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\t%-12s %-8s\n"
argument_list|,
literal|"Fault"
argument_list|,
literal|"Trace"
argument_list|)
expr_stmt|;
for|for
control|(
name|transp
operator|=
name|faults_table
init|;
name|transp
operator|->
name|name
operator|!=
name|NULL
condition|;
name|transp
operator|++
control|)
block|{
name|QUIT
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\t%-12s "
argument_list|,
name|transp
operator|->
name|name
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"%-8s"
argument_list|,
name|prismember
argument_list|(
operator|&
name|pip
operator|->
name|fltset
argument_list|,
name|transp
operator|->
name|value
argument_list|)
condition|?
literal|"on"
else|:
literal|"off"
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|info_proc_mappings
parameter_list|(
name|pip
parameter_list|,
name|summary
parameter_list|)
name|struct
name|procinfo
modifier|*
name|pip
decl_stmt|;
name|int
name|summary
decl_stmt|;
block|{
name|int
name|nmap
decl_stmt|;
name|struct
name|prmap
modifier|*
name|prmaps
decl_stmt|;
name|struct
name|prmap
modifier|*
name|prmap
decl_stmt|;
if|if
condition|(
operator|!
name|summary
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"Mapped address spaces:\n\n"
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\t%10s %10s %10s %10s %7s\n"
argument_list|,
literal|"Start Addr"
argument_list|,
literal|"  End Addr"
argument_list|,
literal|"      Size"
argument_list|,
literal|"    Offset"
argument_list|,
literal|"Flags"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|pip
operator|->
name|fd
argument_list|,
name|PIOCNMAP
argument_list|,
operator|&
name|nmap
argument_list|)
operator|==
literal|0
condition|)
block|{
name|prmaps
operator|=
operator|(
expr|struct
name|prmap
operator|*
operator|)
name|alloca
argument_list|(
operator|(
name|nmap
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|prmaps
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|pip
operator|->
name|fd
argument_list|,
name|PIOCMAP
argument_list|,
name|prmaps
argument_list|)
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|prmap
operator|=
name|prmaps
init|;
name|prmap
operator|->
name|pr_size
condition|;
operator|++
name|prmap
control|)
block|{
name|printf_filtered
argument_list|(
literal|"\t%#10x %#10x %#10x %#10x %7s\n"
argument_list|,
name|prmap
operator|->
name|pr_vaddr
argument_list|,
name|prmap
operator|->
name|pr_vaddr
operator|+
name|prmap
operator|->
name|pr_size
operator|-
literal|1
argument_list|,
name|prmap
operator|->
name|pr_size
argument_list|,
name|prmap
operator|->
name|pr_off
argument_list|,
name|mappingflags
argument_list|(
name|prmap
operator|->
name|pr_mflags
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	info_proc -- implement the "info proc" command  SYNOPSIS  	void info_proc (char *args, int from_tty)  DESCRIPTION  	Implement gdb's "info proc" command by using the /proc interface 	to print status information about any currently running process.  	Examples of the use of "info proc" are:  	info proc		(prints summary info for current inferior) 	info proc 123		(prints summary info for process with pid 123) 	info proc mappings	(prints address mappings) 	info proc times		(prints process/children times) 	info proc id		(prints pid, ppid, gid, sid, etc) 		FIXME:  i proc id not implemented. 	info proc status	(prints general process state info) 		FIXME:  i proc status not implemented. 	info proc signals	(prints info about signal handling) 	info proc all		(prints all info)   */
end_comment

begin_function
specifier|static
name|void
name|info_proc
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|int
name|pid
decl_stmt|;
name|struct
name|procinfo
name|pii
decl_stmt|;
name|struct
name|procinfo
modifier|*
name|pip
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|int
name|argsize
decl_stmt|;
name|int
name|summary
init|=
literal|1
decl_stmt|;
name|int
name|flags
init|=
literal|0
decl_stmt|;
name|int
name|syscalls
init|=
literal|0
decl_stmt|;
name|int
name|signals
init|=
literal|0
decl_stmt|;
name|int
name|faults
init|=
literal|0
decl_stmt|;
name|int
name|mappings
init|=
literal|0
decl_stmt|;
name|int
name|times
init|=
literal|0
decl_stmt|;
name|int
name|id
init|=
literal|0
decl_stmt|;
name|int
name|status
init|=
literal|0
decl_stmt|;
name|int
name|all
init|=
literal|0
decl_stmt|;
name|old_chain
operator|=
name|make_cleanup
argument_list|(
name|null_cleanup
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Default to using the current inferior if no pid specified */
name|pip
operator|=
operator|&
name|pi
expr_stmt|;
if|if
condition|(
name|args
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|argv
operator|=
name|buildargv
argument_list|(
name|args
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|nomem
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|make_cleanup
argument_list|(
name|freeargv
argument_list|,
operator|(
name|char
operator|*
operator|)
name|argv
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|argv
operator|!=
name|NULL
condition|)
block|{
name|argsize
operator|=
name|strlen
argument_list|(
operator|*
name|argv
argument_list|)
expr_stmt|;
if|if
condition|(
name|argsize
operator|>=
literal|1
operator|&&
name|strncmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"all"
argument_list|,
name|argsize
argument_list|)
operator|==
literal|0
condition|)
block|{
name|summary
operator|=
literal|0
expr_stmt|;
name|all
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|argsize
operator|>=
literal|2
operator|&&
name|strncmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"faults"
argument_list|,
name|argsize
argument_list|)
operator|==
literal|0
condition|)
block|{
name|summary
operator|=
literal|0
expr_stmt|;
name|faults
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|argsize
operator|>=
literal|2
operator|&&
name|strncmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"flags"
argument_list|,
name|argsize
argument_list|)
operator|==
literal|0
condition|)
block|{
name|summary
operator|=
literal|0
expr_stmt|;
name|flags
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|argsize
operator|>=
literal|1
operator|&&
name|strncmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"id"
argument_list|,
name|argsize
argument_list|)
operator|==
literal|0
condition|)
block|{
name|summary
operator|=
literal|0
expr_stmt|;
name|id
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|argsize
operator|>=
literal|1
operator|&&
name|strncmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"mappings"
argument_list|,
name|argsize
argument_list|)
operator|==
literal|0
condition|)
block|{
name|summary
operator|=
literal|0
expr_stmt|;
name|mappings
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|argsize
operator|>=
literal|2
operator|&&
name|strncmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"signals"
argument_list|,
name|argsize
argument_list|)
operator|==
literal|0
condition|)
block|{
name|summary
operator|=
literal|0
expr_stmt|;
name|signals
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|argsize
operator|>=
literal|2
operator|&&
name|strncmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"status"
argument_list|,
name|argsize
argument_list|)
operator|==
literal|0
condition|)
block|{
name|summary
operator|=
literal|0
expr_stmt|;
name|status
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|argsize
operator|>=
literal|2
operator|&&
name|strncmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"syscalls"
argument_list|,
name|argsize
argument_list|)
operator|==
literal|0
condition|)
block|{
name|summary
operator|=
literal|0
expr_stmt|;
name|syscalls
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|argsize
operator|>=
literal|1
operator|&&
name|strncmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"times"
argument_list|,
name|argsize
argument_list|)
operator|==
literal|0
condition|)
block|{
name|summary
operator|=
literal|0
expr_stmt|;
name|times
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|pii
operator|.
name|pid
operator|=
name|atoi
argument_list|(
operator|*
name|argv
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|pid
operator|=
name|pii
operator|.
name|pid
expr_stmt|;
name|pip
operator|=
operator|&
name|pii
expr_stmt|;
name|memset
argument_list|(
operator|&
name|pii
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|pii
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|open_proc_file
argument_list|(
name|pid
argument_list|,
name|pip
argument_list|,
name|O_RDONLY
argument_list|)
condition|)
block|{
name|perror_with_name
argument_list|(
name|pip
operator|->
name|pathname
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
name|make_cleanup
argument_list|(
name|close_proc_file
argument_list|,
name|pip
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
operator|*
name|argv
operator|!=
literal|'\000'
condition|)
block|{
name|error
argument_list|(
literal|"Unrecognized or ambiguous keyword `%s'."
argument_list|,
operator|*
name|argv
argument_list|)
expr_stmt|;
block|}
name|argv
operator|++
expr_stmt|;
block|}
block|}
comment|/* If we don't have a valid open process at this point, then we have no      inferior or didn't specify a specific pid. */
if|if
condition|(
operator|!
name|pip
operator|->
name|valid
condition|)
block|{
name|error
argument_list|(
literal|"No process.  Run an inferior or specify an explicit pid."
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ioctl
argument_list|(
name|pip
operator|->
name|fd
argument_list|,
name|PIOCSTATUS
argument_list|,
operator|&
operator|(
name|pip
operator|->
name|prstatus
operator|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|print_sys_errmsg
argument_list|(
name|pip
operator|->
name|pathname
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"PIOCSTATUS failed"
argument_list|)
expr_stmt|;
block|}
comment|/* Print verbose information of the requested type(s), or just a summary      of the information for all types. */
name|printf_filtered
argument_list|(
literal|"\nInformation for %s:\n\n"
argument_list|,
name|pip
operator|->
name|pathname
argument_list|)
expr_stmt|;
if|if
condition|(
name|summary
operator|||
name|all
operator|||
name|flags
condition|)
block|{
name|info_proc_flags
argument_list|(
name|pip
argument_list|,
name|summary
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|summary
operator|||
name|all
condition|)
block|{
name|info_proc_stop
argument_list|(
name|pip
argument_list|,
name|summary
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|summary
operator|||
name|all
operator|||
name|signals
operator|||
name|faults
condition|)
block|{
name|info_proc_siginfo
argument_list|(
name|pip
argument_list|,
name|summary
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|summary
operator|||
name|all
operator|||
name|syscalls
condition|)
block|{
name|info_proc_syscalls
argument_list|(
name|pip
argument_list|,
name|summary
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|summary
operator|||
name|all
operator|||
name|mappings
condition|)
block|{
name|info_proc_mappings
argument_list|(
name|pip
argument_list|,
name|summary
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|summary
operator|||
name|all
operator|||
name|signals
condition|)
block|{
name|info_proc_signals
argument_list|(
name|pip
argument_list|,
name|summary
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|summary
operator|||
name|all
operator|||
name|faults
condition|)
block|{
name|info_proc_faults
argument_list|(
name|pip
argument_list|,
name|summary
argument_list|)
expr_stmt|;
block|}
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* All done, deal with closing any temporary process info structure,      freeing temporary memory , etc. */
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Fork an inferior process, and start debugging it with /proc.  */
end_comment

begin_function
specifier|static
name|void
name|procfs_create_inferior
parameter_list|(
name|exec_file
parameter_list|,
name|allargs
parameter_list|,
name|env
parameter_list|)
name|char
modifier|*
name|exec_file
decl_stmt|;
name|char
modifier|*
name|allargs
decl_stmt|;
name|char
modifier|*
modifier|*
name|env
decl_stmt|;
block|{
name|fork_inferior
argument_list|(
name|exec_file
argument_list|,
name|allargs
argument_list|,
name|env
argument_list|,
name|proc_set_exec_trap
argument_list|,
name|procfs_init_inferior
argument_list|)
expr_stmt|;
comment|/* We are at the first instruction we care about.  */
comment|/* Pedal to the metal... */
name|proceed
argument_list|(
operator|(
name|CORE_ADDR
operator|)
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Clean up after the inferior dies.  */
end_comment

begin_function
specifier|static
name|void
name|procfs_mourn_inferior
parameter_list|()
block|{
name|unpush_target
argument_list|(
operator|&
name|procfs_ops
argument_list|)
expr_stmt|;
name|generic_mourn_inferior
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Mark our target-struct as eligible for stray "run" and "attach" commands.  */
end_comment

begin_function
specifier|static
name|int
name|procfs_can_run
parameter_list|()
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_decl_stmt
name|struct
name|target_ops
name|procfs_ops
init|=
block|{
literal|"procfs"
block|,
comment|/* to_shortname */
literal|"Unix /proc child process"
block|,
comment|/* to_longname */
literal|"Unix /proc child process (started by the \"run\" command)."
block|,
comment|/* to_doc */
name|procfs_open
block|,
comment|/* to_open */
literal|0
block|,
comment|/* to_close */
name|procfs_attach
block|,
comment|/* to_attach */
name|procfs_detach
block|,
comment|/* to_detach */
name|procfs_resume
block|,
comment|/* to_resume */
name|procfs_wait
block|,
comment|/* to_wait */
name|procfs_fetch_registers
block|,
comment|/* to_fetch_registers */
name|procfs_store_registers
block|,
comment|/* to_store_registers */
name|procfs_prepare_to_store
block|,
comment|/* to_prepare_to_store */
name|procfs_xfer_memory
block|,
comment|/* to_xfer_memory */
name|procfs_files_info
block|,
comment|/* to_files_info */
name|memory_insert_breakpoint
block|,
comment|/* to_insert_breakpoint */
name|memory_remove_breakpoint
block|,
comment|/* to_remove_breakpoint */
name|terminal_init_inferior
block|,
comment|/* to_terminal_init */
name|terminal_inferior
block|,
comment|/* to_terminal_inferior */
name|terminal_ours_for_output
block|,
comment|/* to_terminal_ours_for_output */
name|terminal_ours
block|,
comment|/* to_terminal_ours */
name|child_terminal_info
block|,
comment|/* to_terminal_info */
name|procfs_kill_inferior
block|,
comment|/* to_kill */
literal|0
block|,
comment|/* to_load */
literal|0
block|,
comment|/* to_lookup_symbol */
name|procfs_create_inferior
block|,
comment|/* to_create_inferior */
name|procfs_mourn_inferior
block|,
comment|/* to_mourn_inferior */
name|procfs_can_run
block|,
comment|/* to_can_run */
name|procfs_notice_signals
block|,
comment|/* to_notice_signals */
name|process_stratum
block|,
comment|/* to_stratum */
literal|0
block|,
comment|/* to_next */
literal|1
block|,
comment|/* to_has_all_memory */
literal|1
block|,
comment|/* to_has_memory */
literal|1
block|,
comment|/* to_has_stack */
literal|1
block|,
comment|/* to_has_registers */
literal|1
block|,
comment|/* to_has_execution */
literal|0
block|,
comment|/* sections */
literal|0
block|,
comment|/* sections_end */
name|OPS_MAGIC
comment|/* to_magic */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  GLOBAL FUNCTION  	_initialize_procfs -- initialize the process file system stuff  SYNOPSIS  	void _initialize_procfs (void)  DESCRIPTION  	Do required initializations during gdb startup for using the 	/proc file system interface.  */
end_comment

begin_function
name|void
name|_initialize_procfs
parameter_list|()
block|{
name|add_target
argument_list|(
operator|&
name|procfs_ops
argument_list|)
expr_stmt|;
name|add_info
argument_list|(
literal|"proc"
argument_list|,
name|info_proc
argument_list|,
literal|"Show process status information using /proc entry.\n\ Specify process id or use current inferior by default.\n\ Specify keywords for detailed information; default is summary.\n\ Keywords are: `all', `faults', `flags', `id', `mappings', `signals',\n\ `status', `syscalls', and `times'.\n\ Unambiguous abbreviations may be used."
argument_list|)
expr_stmt|;
name|init_syscall_table
argument_list|()
expr_stmt|;
block|}
end_function

end_unit

