begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Perform arithmetic and other operations on values, for GDB.    Copyright 1986, 1989, 1991, 1992 Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"gdbtypes.h"
end_include

begin_include
include|#
directive|include
file|"expression.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_decl_stmt
specifier|static
name|value
name|value_subscripted_rvalue
name|PARAMS
argument_list|(
operator|(
name|value
operator|,
name|value
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_function
name|value
name|value_add
parameter_list|(
name|arg1
parameter_list|,
name|arg2
parameter_list|)
name|value
name|arg1
decl_stmt|,
name|arg2
decl_stmt|;
block|{
specifier|register
name|value
name|valint
decl_stmt|,
name|valptr
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
name|COERCE_ARRAY
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|COERCE_ARRAY
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_PTR
operator|||
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg2
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_PTR
operator|)
operator|&&
operator|(
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_INT
operator|||
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg2
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_INT
operator|)
condition|)
comment|/* Exactly one argument is a pointer, and one is an integer.  */
block|{
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_PTR
condition|)
block|{
name|valptr
operator|=
name|arg1
expr_stmt|;
name|valint
operator|=
name|arg2
expr_stmt|;
block|}
else|else
block|{
name|valptr
operator|=
name|arg2
expr_stmt|;
name|valint
operator|=
name|arg1
expr_stmt|;
block|}
name|len
operator|=
name|TYPE_LENGTH
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|valptr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
name|len
operator|=
literal|1
expr_stmt|;
comment|/* For (void *) */
return|return
name|value_from_longest
argument_list|(
name|VALUE_TYPE
argument_list|(
name|valptr
argument_list|)
argument_list|,
name|value_as_long
argument_list|(
name|valptr
argument_list|)
operator|+
operator|(
name|len
operator|*
name|value_as_long
argument_list|(
name|valint
argument_list|)
operator|)
argument_list|)
return|;
block|}
return|return
name|value_binop
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|,
name|BINOP_ADD
argument_list|)
return|;
block|}
end_function

begin_function
name|value
name|value_sub
parameter_list|(
name|arg1
parameter_list|,
name|arg2
parameter_list|)
name|value
name|arg1
decl_stmt|,
name|arg2
decl_stmt|;
block|{
name|COERCE_ARRAY
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|COERCE_ARRAY
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_PTR
condition|)
block|{
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg2
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_INT
condition|)
block|{
comment|/* pointer - integer.  */
return|return
name|value_from_longest
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|value_as_long
argument_list|(
name|arg1
argument_list|)
operator|-
operator|(
name|TYPE_LENGTH
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
argument_list|)
operator|*
name|value_as_long
argument_list|(
name|arg2
argument_list|)
operator|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
operator|==
name|VALUE_TYPE
argument_list|(
name|arg2
argument_list|)
condition|)
block|{
comment|/* pointer to<type x> - pointer to<type x>.  */
return|return
name|value_from_longest
argument_list|(
name|builtin_type_long
argument_list|,
comment|/* FIXME -- should be ptrdiff_t */
operator|(
name|value_as_long
argument_list|(
name|arg1
argument_list|)
operator|-
name|value_as_long
argument_list|(
name|arg2
argument_list|)
operator|)
operator|/
name|TYPE_LENGTH
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
else|else
block|{
name|error
argument_list|(
literal|"\ First argument of `-' is a pointer and second argument is neither\n\ an integer nor a pointer of the same type."
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|value_binop
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|,
name|BINOP_SUB
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return the value of ARRAY[IDX].  */
end_comment

begin_function
name|value
name|value_subscript
parameter_list|(
name|array
parameter_list|,
name|idx
parameter_list|)
name|value
name|array
decl_stmt|,
name|idx
decl_stmt|;
block|{
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|array
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_ARRAY
operator|&&
name|VALUE_LVAL
argument_list|(
name|array
argument_list|)
operator|!=
name|lval_memory
condition|)
return|return
name|value_subscripted_rvalue
argument_list|(
name|array
argument_list|,
name|idx
argument_list|)
return|;
else|else
return|return
name|value_ind
argument_list|(
name|value_add
argument_list|(
name|array
argument_list|,
name|idx
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return the value of EXPR[IDX], expr an aggregate rvalue    (eg, a vector register).  This routine used to promote floats    to doubles, but no longer does.  */
end_comment

begin_function
specifier|static
name|value
name|value_subscripted_rvalue
parameter_list|(
name|array
parameter_list|,
name|idx
parameter_list|)
name|value
name|array
decl_stmt|,
name|idx
decl_stmt|;
block|{
name|struct
name|type
modifier|*
name|elt_type
init|=
name|TYPE_TARGET_TYPE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|array
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|elt_size
init|=
name|TYPE_LENGTH
argument_list|(
name|elt_type
argument_list|)
decl_stmt|;
name|int
name|elt_offs
init|=
name|elt_size
operator|*
name|longest_to_int
argument_list|(
name|value_as_long
argument_list|(
name|idx
argument_list|)
argument_list|)
decl_stmt|;
name|value
name|v
decl_stmt|;
if|if
condition|(
name|elt_offs
operator|>=
name|TYPE_LENGTH
argument_list|(
name|VALUE_TYPE
argument_list|(
name|array
argument_list|)
argument_list|)
condition|)
name|error
argument_list|(
literal|"no such vector element"
argument_list|)
expr_stmt|;
name|v
operator|=
name|allocate_value
argument_list|(
name|elt_type
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|VALUE_CONTENTS
argument_list|(
name|v
argument_list|)
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|array
argument_list|)
operator|+
name|elt_offs
argument_list|,
name|elt_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|VALUE_LVAL
argument_list|(
name|array
argument_list|)
operator|==
name|lval_internalvar
condition|)
name|VALUE_LVAL
argument_list|(
name|v
argument_list|)
operator|=
name|lval_internalvar_component
expr_stmt|;
else|else
name|VALUE_LVAL
argument_list|(
name|v
argument_list|)
operator|=
name|not_lval
expr_stmt|;
name|VALUE_ADDRESS
argument_list|(
name|v
argument_list|)
operator|=
name|VALUE_ADDRESS
argument_list|(
name|array
argument_list|)
expr_stmt|;
name|VALUE_OFFSET
argument_list|(
name|v
argument_list|)
operator|=
name|VALUE_OFFSET
argument_list|(
name|array
argument_list|)
operator|+
name|elt_offs
expr_stmt|;
name|VALUE_BITSIZE
argument_list|(
name|v
argument_list|)
operator|=
name|elt_size
operator|*
literal|8
expr_stmt|;
return|return
name|v
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Check to see if either argument is a structure.  This is called so    we know whether to go ahead with the normal binop or look for a     user defined function instead.     For now, we do not overload the `=' operator.  */
end_comment

begin_function
name|int
name|binop_user_defined_p
parameter_list|(
name|op
parameter_list|,
name|arg1
parameter_list|,
name|arg2
parameter_list|)
name|enum
name|exp_opcode
name|op
decl_stmt|;
name|value
name|arg1
decl_stmt|,
name|arg2
decl_stmt|;
block|{
if|if
condition|(
name|op
operator|==
name|BINOP_ASSIGN
condition|)
return|return
literal|0
return|;
return|return
operator|(
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_STRUCT
operator|||
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg2
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_STRUCT
operator|||
operator|(
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_REF
operator|&&
name|TYPE_CODE
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_STRUCT
operator|)
operator|||
operator|(
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg2
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_REF
operator|&&
name|TYPE_CODE
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg2
argument_list|)
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_STRUCT
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Check to see if argument is a structure.  This is called so    we know whether to go ahead with the normal unop or look for a     user defined function instead.     For now, we do not overload the `&' operator.  */
end_comment

begin_function
name|int
name|unop_user_defined_p
parameter_list|(
name|op
parameter_list|,
name|arg1
parameter_list|)
name|enum
name|exp_opcode
name|op
decl_stmt|;
name|value
name|arg1
decl_stmt|;
block|{
if|if
condition|(
name|op
operator|==
name|UNOP_ADDR
condition|)
return|return
literal|0
return|;
return|return
operator|(
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_STRUCT
operator|||
operator|(
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_REF
operator|&&
name|TYPE_CODE
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_STRUCT
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* We know either arg1 or arg2 is a structure, so try to find the right    user defined function.  Create an argument vector that calls     arg1.operator @ (arg1,arg2) and return that value (where '@' is any    binary operator which is legal for GNU C++).     OP is the operatore, and if it is BINOP_ASSIGN_MODIFY, then OTHEROP    is the opcode saying how to modify it.  Otherwise, OTHEROP is    unused.  */
end_comment

begin_function
name|value
name|value_x_binop
parameter_list|(
name|arg1
parameter_list|,
name|arg2
parameter_list|,
name|op
parameter_list|,
name|otherop
parameter_list|)
name|value
name|arg1
decl_stmt|,
name|arg2
decl_stmt|;
name|enum
name|exp_opcode
name|op
decl_stmt|,
name|otherop
decl_stmt|;
block|{
name|value
modifier|*
name|argvec
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
name|char
name|tstr
index|[
literal|13
index|]
decl_stmt|;
name|int
name|static_memfuncp
decl_stmt|;
name|COERCE_REF
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|COERCE_REF
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
name|COERCE_ENUM
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|COERCE_ENUM
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
comment|/* now we know that what we have to do is construct our      arg vector and find the right function to call it with.  */
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|!=
name|TYPE_CODE_STRUCT
condition|)
name|error
argument_list|(
literal|"Can't do that binary op on that type"
argument_list|)
expr_stmt|;
comment|/* FIXME be explicit */
name|argvec
operator|=
operator|(
name|value
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
name|value
argument_list|)
operator|*
literal|4
argument_list|)
expr_stmt|;
name|argvec
index|[
literal|1
index|]
operator|=
name|value_addr
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|argvec
index|[
literal|2
index|]
operator|=
name|arg2
expr_stmt|;
name|argvec
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
comment|/* make the right function name up */
name|strcpy
argument_list|(
name|tstr
argument_list|,
literal|"operator__"
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|tstr
operator|+
literal|8
expr_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|BINOP_ADD
case|:
name|strcpy
argument_list|(
name|ptr
argument_list|,
literal|"+"
argument_list|)
expr_stmt|;
break|break;
case|case
name|BINOP_SUB
case|:
name|strcpy
argument_list|(
name|ptr
argument_list|,
literal|"-"
argument_list|)
expr_stmt|;
break|break;
case|case
name|BINOP_MUL
case|:
name|strcpy
argument_list|(
name|ptr
argument_list|,
literal|"*"
argument_list|)
expr_stmt|;
break|break;
case|case
name|BINOP_DIV
case|:
name|strcpy
argument_list|(
name|ptr
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
break|break;
case|case
name|BINOP_REM
case|:
name|strcpy
argument_list|(
name|ptr
argument_list|,
literal|"%"
argument_list|)
expr_stmt|;
break|break;
case|case
name|BINOP_LSH
case|:
name|strcpy
argument_list|(
name|ptr
argument_list|,
literal|"<<"
argument_list|)
expr_stmt|;
break|break;
case|case
name|BINOP_RSH
case|:
name|strcpy
argument_list|(
name|ptr
argument_list|,
literal|">>"
argument_list|)
expr_stmt|;
break|break;
case|case
name|BINOP_LOGAND
case|:
name|strcpy
argument_list|(
name|ptr
argument_list|,
literal|"&"
argument_list|)
expr_stmt|;
break|break;
case|case
name|BINOP_LOGIOR
case|:
name|strcpy
argument_list|(
name|ptr
argument_list|,
literal|"|"
argument_list|)
expr_stmt|;
break|break;
case|case
name|BINOP_LOGXOR
case|:
name|strcpy
argument_list|(
name|ptr
argument_list|,
literal|"^"
argument_list|)
expr_stmt|;
break|break;
case|case
name|BINOP_AND
case|:
name|strcpy
argument_list|(
name|ptr
argument_list|,
literal|"&&"
argument_list|)
expr_stmt|;
break|break;
case|case
name|BINOP_OR
case|:
name|strcpy
argument_list|(
name|ptr
argument_list|,
literal|"||"
argument_list|)
expr_stmt|;
break|break;
case|case
name|BINOP_MIN
case|:
name|strcpy
argument_list|(
name|ptr
argument_list|,
literal|"<?"
argument_list|)
expr_stmt|;
break|break;
case|case
name|BINOP_MAX
case|:
name|strcpy
argument_list|(
name|ptr
argument_list|,
literal|">?"
argument_list|)
expr_stmt|;
break|break;
case|case
name|BINOP_ASSIGN
case|:
name|strcpy
argument_list|(
name|ptr
argument_list|,
literal|"="
argument_list|)
expr_stmt|;
break|break;
case|case
name|BINOP_ASSIGN_MODIFY
case|:
switch|switch
condition|(
name|otherop
condition|)
block|{
case|case
name|BINOP_ADD
case|:
name|strcpy
argument_list|(
name|ptr
argument_list|,
literal|"+="
argument_list|)
expr_stmt|;
break|break;
case|case
name|BINOP_SUB
case|:
name|strcpy
argument_list|(
name|ptr
argument_list|,
literal|"-="
argument_list|)
expr_stmt|;
break|break;
case|case
name|BINOP_MUL
case|:
name|strcpy
argument_list|(
name|ptr
argument_list|,
literal|"*="
argument_list|)
expr_stmt|;
break|break;
case|case
name|BINOP_DIV
case|:
name|strcpy
argument_list|(
name|ptr
argument_list|,
literal|"/="
argument_list|)
expr_stmt|;
break|break;
case|case
name|BINOP_REM
case|:
name|strcpy
argument_list|(
name|ptr
argument_list|,
literal|"%="
argument_list|)
expr_stmt|;
break|break;
case|case
name|BINOP_LOGAND
case|:
name|strcpy
argument_list|(
name|ptr
argument_list|,
literal|"&="
argument_list|)
expr_stmt|;
break|break;
case|case
name|BINOP_LOGIOR
case|:
name|strcpy
argument_list|(
name|ptr
argument_list|,
literal|"|="
argument_list|)
expr_stmt|;
break|break;
case|case
name|BINOP_LOGXOR
case|:
name|strcpy
argument_list|(
name|ptr
argument_list|,
literal|"^="
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"Invalid binary operation specified."
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|BINOP_SUBSCRIPT
case|:
name|strcpy
argument_list|(
name|ptr
argument_list|,
literal|"[]"
argument_list|)
expr_stmt|;
break|break;
case|case
name|BINOP_EQUAL
case|:
name|strcpy
argument_list|(
name|ptr
argument_list|,
literal|"=="
argument_list|)
expr_stmt|;
break|break;
case|case
name|BINOP_NOTEQUAL
case|:
name|strcpy
argument_list|(
name|ptr
argument_list|,
literal|"!="
argument_list|)
expr_stmt|;
break|break;
case|case
name|BINOP_LESS
case|:
name|strcpy
argument_list|(
name|ptr
argument_list|,
literal|"<"
argument_list|)
expr_stmt|;
break|break;
case|case
name|BINOP_GTR
case|:
name|strcpy
argument_list|(
name|ptr
argument_list|,
literal|">"
argument_list|)
expr_stmt|;
break|break;
case|case
name|BINOP_GEQ
case|:
name|strcpy
argument_list|(
name|ptr
argument_list|,
literal|">="
argument_list|)
expr_stmt|;
break|break;
case|case
name|BINOP_LEQ
case|:
name|strcpy
argument_list|(
name|ptr
argument_list|,
literal|"<="
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"Invalid binary operation specified."
argument_list|)
expr_stmt|;
block|}
name|argvec
index|[
literal|0
index|]
operator|=
name|value_struct_elt
argument_list|(
operator|&
name|arg1
argument_list|,
name|argvec
operator|+
literal|1
argument_list|,
name|tstr
argument_list|,
operator|&
name|static_memfuncp
argument_list|,
literal|"structure"
argument_list|)
expr_stmt|;
if|if
condition|(
name|argvec
index|[
literal|0
index|]
condition|)
block|{
if|if
condition|(
name|static_memfuncp
condition|)
block|{
name|argvec
index|[
literal|1
index|]
operator|=
name|argvec
index|[
literal|0
index|]
expr_stmt|;
name|argvec
operator|++
expr_stmt|;
block|}
return|return
name|call_function_by_hand
argument_list|(
name|argvec
index|[
literal|0
index|]
argument_list|,
literal|2
operator|-
name|static_memfuncp
argument_list|,
name|argvec
operator|+
literal|1
argument_list|)
return|;
block|}
name|error
argument_list|(
literal|"member function %s not found"
argument_list|,
name|tstr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|lint
return|return
name|call_function_by_hand
argument_list|(
name|argvec
index|[
literal|0
index|]
argument_list|,
literal|2
operator|-
name|static_memfuncp
argument_list|,
name|argvec
operator|+
literal|1
argument_list|)
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* We know that arg1 is a structure, so try to find a unary user    defined operator that matches the operator in question.      Create an argument vector that calls arg1.operator @ (arg1)    and return that value (where '@' is (almost) any unary operator which    is legal for GNU C++).  */
end_comment

begin_function
name|value
name|value_x_unop
parameter_list|(
name|arg1
parameter_list|,
name|op
parameter_list|)
name|value
name|arg1
decl_stmt|;
name|enum
name|exp_opcode
name|op
decl_stmt|;
block|{
name|value
modifier|*
name|argvec
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
name|char
name|tstr
index|[
literal|13
index|]
decl_stmt|;
name|int
name|static_memfuncp
decl_stmt|;
name|COERCE_ENUM
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
comment|/* now we know that what we have to do is construct our      arg vector and find the right function to call it with.  */
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|!=
name|TYPE_CODE_STRUCT
condition|)
name|error
argument_list|(
literal|"Can't do that unary op on that type"
argument_list|)
expr_stmt|;
comment|/* FIXME be explicit */
name|argvec
operator|=
operator|(
name|value
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
name|value
argument_list|)
operator|*
literal|3
argument_list|)
expr_stmt|;
name|argvec
index|[
literal|1
index|]
operator|=
name|value_addr
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|argvec
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
comment|/* make the right function name up */
name|strcpy
argument_list|(
name|tstr
argument_list|,
literal|"operator__"
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|tstr
operator|+
literal|8
expr_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|UNOP_PREINCREMENT
case|:
name|strcpy
argument_list|(
name|ptr
argument_list|,
literal|"++"
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNOP_PREDECREMENT
case|:
name|strcpy
argument_list|(
name|ptr
argument_list|,
literal|"++"
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNOP_POSTINCREMENT
case|:
name|strcpy
argument_list|(
name|ptr
argument_list|,
literal|"++"
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNOP_POSTDECREMENT
case|:
name|strcpy
argument_list|(
name|ptr
argument_list|,
literal|"++"
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNOP_ZEROP
case|:
name|strcpy
argument_list|(
name|ptr
argument_list|,
literal|"!"
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNOP_LOGNOT
case|:
name|strcpy
argument_list|(
name|ptr
argument_list|,
literal|"~"
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNOP_NEG
case|:
name|strcpy
argument_list|(
name|ptr
argument_list|,
literal|"-"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"Invalid binary operation specified."
argument_list|)
expr_stmt|;
block|}
name|argvec
index|[
literal|0
index|]
operator|=
name|value_struct_elt
argument_list|(
operator|&
name|arg1
argument_list|,
name|argvec
operator|+
literal|1
argument_list|,
name|tstr
argument_list|,
operator|&
name|static_memfuncp
argument_list|,
literal|"structure"
argument_list|)
expr_stmt|;
if|if
condition|(
name|argvec
index|[
literal|0
index|]
condition|)
block|{
if|if
condition|(
name|static_memfuncp
condition|)
block|{
name|argvec
index|[
literal|1
index|]
operator|=
name|argvec
index|[
literal|0
index|]
expr_stmt|;
name|argvec
operator|++
expr_stmt|;
block|}
return|return
name|call_function_by_hand
argument_list|(
name|argvec
index|[
literal|0
index|]
argument_list|,
literal|1
operator|-
name|static_memfuncp
argument_list|,
name|argvec
operator|+
literal|1
argument_list|)
return|;
block|}
name|error
argument_list|(
literal|"member function %s not found"
argument_list|,
name|tstr
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
comment|/* For lint -- never reached */
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Perform a binary operation on two integers or two floats.    Does not support addition and subtraction on pointers;    use value_add or value_sub if you want to handle those possibilities.  */
end_comment

begin_function
name|value
name|value_binop
parameter_list|(
name|arg1
parameter_list|,
name|arg2
parameter_list|,
name|op
parameter_list|)
name|value
name|arg1
decl_stmt|,
name|arg2
decl_stmt|;
name|enum
name|exp_opcode
name|op
decl_stmt|;
block|{
specifier|register
name|value
name|val
decl_stmt|;
name|COERCE_ENUM
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|COERCE_ENUM
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|!=
name|TYPE_CODE_FLT
operator|&&
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|!=
name|TYPE_CODE_INT
operator|)
operator|||
operator|(
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg2
argument_list|)
argument_list|)
operator|!=
name|TYPE_CODE_FLT
operator|&&
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg2
argument_list|)
argument_list|)
operator|!=
name|TYPE_CODE_INT
operator|)
condition|)
name|error
argument_list|(
literal|"Argument to arithmetic operation not a number."
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_FLT
operator|||
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg2
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_FLT
condition|)
block|{
name|double
name|v1
decl_stmt|,
name|v2
decl_stmt|,
name|v
decl_stmt|;
name|v1
operator|=
name|value_as_double
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|v2
operator|=
name|value_as_double
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|BINOP_ADD
case|:
name|v
operator|=
name|v1
operator|+
name|v2
expr_stmt|;
break|break;
case|case
name|BINOP_SUB
case|:
name|v
operator|=
name|v1
operator|-
name|v2
expr_stmt|;
break|break;
case|case
name|BINOP_MUL
case|:
name|v
operator|=
name|v1
operator|*
name|v2
expr_stmt|;
break|break;
case|case
name|BINOP_DIV
case|:
name|v
operator|=
name|v1
operator|/
name|v2
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"Integer-only operation on floating point number."
argument_list|)
expr_stmt|;
block|}
name|val
operator|=
name|allocate_value
argument_list|(
name|builtin_type_double
argument_list|)
expr_stmt|;
name|SWAP_TARGET_AND_HOST
argument_list|(
operator|&
name|v
argument_list|,
sizeof|sizeof
argument_list|(
name|v
argument_list|)
argument_list|)
expr_stmt|;
operator|*
operator|(
name|double
operator|*
operator|)
name|VALUE_CONTENTS_RAW
argument_list|(
name|val
argument_list|)
operator|=
name|v
expr_stmt|;
block|}
else|else
comment|/* Integral operations here.  */
block|{
comment|/* Should we promote to unsigned longest?  */
if|if
condition|(
operator|(
name|TYPE_UNSIGNED
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|||
name|TYPE_UNSIGNED
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg2
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
name|TYPE_LENGTH
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|>=
expr|sizeof
operator|(
name|unsigned
name|LONGEST
operator|)
operator|||
name|TYPE_LENGTH
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg2
argument_list|)
argument_list|)
operator|>=
expr|sizeof
operator|(
name|unsigned
name|LONGEST
operator|)
operator|)
condition|)
block|{
name|unsigned
name|LONGEST
name|v1
decl_stmt|,
name|v2
decl_stmt|,
name|v
decl_stmt|;
name|v1
operator|=
operator|(
name|unsigned
name|LONGEST
operator|)
name|value_as_long
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|v2
operator|=
operator|(
name|unsigned
name|LONGEST
operator|)
name|value_as_long
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|BINOP_ADD
case|:
name|v
operator|=
name|v1
operator|+
name|v2
expr_stmt|;
break|break;
case|case
name|BINOP_SUB
case|:
name|v
operator|=
name|v1
operator|-
name|v2
expr_stmt|;
break|break;
case|case
name|BINOP_MUL
case|:
name|v
operator|=
name|v1
operator|*
name|v2
expr_stmt|;
break|break;
case|case
name|BINOP_DIV
case|:
name|v
operator|=
name|v1
operator|/
name|v2
expr_stmt|;
break|break;
case|case
name|BINOP_REM
case|:
name|v
operator|=
name|v1
operator|%
name|v2
expr_stmt|;
break|break;
case|case
name|BINOP_LSH
case|:
name|v
operator|=
name|v1
operator|<<
name|v2
expr_stmt|;
break|break;
case|case
name|BINOP_RSH
case|:
name|v
operator|=
name|v1
operator|>>
name|v2
expr_stmt|;
break|break;
case|case
name|BINOP_LOGAND
case|:
name|v
operator|=
name|v1
operator|&
name|v2
expr_stmt|;
break|break;
case|case
name|BINOP_LOGIOR
case|:
name|v
operator|=
name|v1
operator||
name|v2
expr_stmt|;
break|break;
case|case
name|BINOP_LOGXOR
case|:
name|v
operator|=
name|v1
operator|^
name|v2
expr_stmt|;
break|break;
case|case
name|BINOP_AND
case|:
name|v
operator|=
name|v1
operator|&&
name|v2
expr_stmt|;
break|break;
case|case
name|BINOP_OR
case|:
name|v
operator|=
name|v1
operator|||
name|v2
expr_stmt|;
break|break;
case|case
name|BINOP_MIN
case|:
name|v
operator|=
name|v1
operator|<
name|v2
condition|?
name|v1
else|:
name|v2
expr_stmt|;
break|break;
case|case
name|BINOP_MAX
case|:
name|v
operator|=
name|v1
operator|>
name|v2
condition|?
name|v1
else|:
name|v2
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"Invalid binary operation on numbers."
argument_list|)
expr_stmt|;
block|}
name|val
operator|=
name|allocate_value
argument_list|(
name|BUILTIN_TYPE_UNSIGNED_LONGEST
argument_list|)
expr_stmt|;
name|SWAP_TARGET_AND_HOST
argument_list|(
operator|&
name|v
argument_list|,
sizeof|sizeof
argument_list|(
name|v
argument_list|)
argument_list|)
expr_stmt|;
operator|*
operator|(
name|unsigned
name|LONGEST
operator|*
operator|)
name|VALUE_CONTENTS_RAW
argument_list|(
name|val
argument_list|)
operator|=
name|v
expr_stmt|;
block|}
else|else
block|{
name|LONGEST
name|v1
decl_stmt|,
name|v2
decl_stmt|,
name|v
decl_stmt|;
name|v1
operator|=
name|value_as_long
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|v2
operator|=
name|value_as_long
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|BINOP_ADD
case|:
name|v
operator|=
name|v1
operator|+
name|v2
expr_stmt|;
break|break;
case|case
name|BINOP_SUB
case|:
name|v
operator|=
name|v1
operator|-
name|v2
expr_stmt|;
break|break;
case|case
name|BINOP_MUL
case|:
name|v
operator|=
name|v1
operator|*
name|v2
expr_stmt|;
break|break;
case|case
name|BINOP_DIV
case|:
name|v
operator|=
name|v1
operator|/
name|v2
expr_stmt|;
break|break;
case|case
name|BINOP_REM
case|:
name|v
operator|=
name|v1
operator|%
name|v2
expr_stmt|;
break|break;
case|case
name|BINOP_LSH
case|:
name|v
operator|=
name|v1
operator|<<
name|v2
expr_stmt|;
break|break;
case|case
name|BINOP_RSH
case|:
name|v
operator|=
name|v1
operator|>>
name|v2
expr_stmt|;
break|break;
case|case
name|BINOP_LOGAND
case|:
name|v
operator|=
name|v1
operator|&
name|v2
expr_stmt|;
break|break;
case|case
name|BINOP_LOGIOR
case|:
name|v
operator|=
name|v1
operator||
name|v2
expr_stmt|;
break|break;
case|case
name|BINOP_LOGXOR
case|:
name|v
operator|=
name|v1
operator|^
name|v2
expr_stmt|;
break|break;
case|case
name|BINOP_AND
case|:
name|v
operator|=
name|v1
operator|&&
name|v2
expr_stmt|;
break|break;
case|case
name|BINOP_OR
case|:
name|v
operator|=
name|v1
operator|||
name|v2
expr_stmt|;
break|break;
case|case
name|BINOP_MIN
case|:
name|v
operator|=
name|v1
operator|<
name|v2
condition|?
name|v1
else|:
name|v2
expr_stmt|;
break|break;
case|case
name|BINOP_MAX
case|:
name|v
operator|=
name|v1
operator|>
name|v2
condition|?
name|v1
else|:
name|v2
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"Invalid binary operation on numbers."
argument_list|)
expr_stmt|;
block|}
name|val
operator|=
name|allocate_value
argument_list|(
name|BUILTIN_TYPE_LONGEST
argument_list|)
expr_stmt|;
name|SWAP_TARGET_AND_HOST
argument_list|(
operator|&
name|v
argument_list|,
sizeof|sizeof
argument_list|(
name|v
argument_list|)
argument_list|)
expr_stmt|;
operator|*
operator|(
name|LONGEST
operator|*
operator|)
name|VALUE_CONTENTS_RAW
argument_list|(
name|val
argument_list|)
operator|=
name|v
expr_stmt|;
block|}
block|}
return|return
name|val
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Simulate the C operator ! -- return 1 if ARG1 contains zero.  */
end_comment

begin_function
name|int
name|value_zerop
parameter_list|(
name|arg1
parameter_list|)
name|value
name|arg1
decl_stmt|;
block|{
specifier|register
name|int
name|len
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|COERCE_ARRAY
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_FLT
condition|)
return|return
literal|0
operator|==
name|value_as_double
argument_list|(
name|arg1
argument_list|)
return|;
name|len
operator|=
name|TYPE_LENGTH
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|=
name|VALUE_CONTENTS
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|len
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|++
condition|)
break|break;
block|}
return|return
name|len
operator|<
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Simulate the C operator == by returning a 1    iff ARG1 and ARG2 have equal contents.  */
end_comment

begin_function
name|int
name|value_equal
parameter_list|(
name|arg1
parameter_list|,
name|arg2
parameter_list|)
specifier|register
name|value
name|arg1
decl_stmt|,
name|arg2
decl_stmt|;
block|{
specifier|register
name|int
name|len
decl_stmt|;
specifier|register
name|char
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
name|enum
name|type_code
name|code1
decl_stmt|;
name|enum
name|type_code
name|code2
decl_stmt|;
name|COERCE_ARRAY
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|COERCE_ARRAY
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
name|code1
operator|=
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
expr_stmt|;
name|code2
operator|=
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|code1
operator|==
name|TYPE_CODE_INT
operator|&&
name|code2
operator|==
name|TYPE_CODE_INT
condition|)
return|return
name|value_as_long
argument_list|(
name|arg1
argument_list|)
operator|==
name|value_as_long
argument_list|(
name|arg2
argument_list|)
return|;
elseif|else
if|if
condition|(
operator|(
name|code1
operator|==
name|TYPE_CODE_FLT
operator|||
name|code1
operator|==
name|TYPE_CODE_INT
operator|)
operator|&&
operator|(
name|code2
operator|==
name|TYPE_CODE_FLT
operator|||
name|code2
operator|==
name|TYPE_CODE_INT
operator|)
condition|)
return|return
name|value_as_double
argument_list|(
name|arg1
argument_list|)
operator|==
name|value_as_double
argument_list|(
name|arg2
argument_list|)
return|;
comment|/* FIXME: Need to promote to either CORE_ADDR or LONGEST, whichever      is bigger.  */
elseif|else
if|if
condition|(
name|code1
operator|==
name|TYPE_CODE_PTR
operator|&&
name|code2
operator|==
name|TYPE_CODE_INT
condition|)
return|return
name|value_as_pointer
argument_list|(
name|arg1
argument_list|)
operator|==
operator|(
name|CORE_ADDR
operator|)
name|value_as_long
argument_list|(
name|arg2
argument_list|)
return|;
elseif|else
if|if
condition|(
name|code2
operator|==
name|TYPE_CODE_PTR
operator|&&
name|code1
operator|==
name|TYPE_CODE_INT
condition|)
return|return
operator|(
name|CORE_ADDR
operator|)
name|value_as_long
argument_list|(
name|arg1
argument_list|)
operator|==
name|value_as_pointer
argument_list|(
name|arg2
argument_list|)
return|;
elseif|else
if|if
condition|(
name|code1
operator|==
name|code2
operator|&&
operator|(
operator|(
name|len
operator|=
name|TYPE_LENGTH
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|)
operator|==
name|TYPE_LENGTH
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg2
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|p1
operator|=
name|VALUE_CONTENTS
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|p2
operator|=
name|VALUE_CONTENTS
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|len
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
operator|*
name|p1
operator|++
operator|!=
operator|*
name|p2
operator|++
condition|)
break|break;
block|}
return|return
name|len
operator|<
literal|0
return|;
block|}
else|else
block|{
name|error
argument_list|(
literal|"Invalid type combination in equality test."
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
comment|/* For lint -- never reached */
block|}
block|}
end_function

begin_comment
comment|/* Simulate the C operator< by returning 1    iff ARG1's contents are less than ARG2's.  */
end_comment

begin_function
name|int
name|value_less
parameter_list|(
name|arg1
parameter_list|,
name|arg2
parameter_list|)
specifier|register
name|value
name|arg1
decl_stmt|,
name|arg2
decl_stmt|;
block|{
specifier|register
name|enum
name|type_code
name|code1
decl_stmt|;
specifier|register
name|enum
name|type_code
name|code2
decl_stmt|;
name|COERCE_ARRAY
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|COERCE_ARRAY
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
name|code1
operator|=
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
expr_stmt|;
name|code2
operator|=
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|code1
operator|==
name|TYPE_CODE_INT
operator|&&
name|code2
operator|==
name|TYPE_CODE_INT
condition|)
block|{
if|if
condition|(
name|TYPE_UNSIGNED
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|||
name|TYPE_UNSIGNED
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg2
argument_list|)
argument_list|)
condition|)
return|return
operator|(
operator|(
name|unsigned
name|LONGEST
operator|)
name|value_as_long
argument_list|(
name|arg1
argument_list|)
operator|<
operator|(
name|unsigned
name|LONGEST
operator|)
name|value_as_long
argument_list|(
name|arg2
argument_list|)
operator|)
return|;
else|else
return|return
name|value_as_long
argument_list|(
name|arg1
argument_list|)
operator|<
name|value_as_long
argument_list|(
name|arg2
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|code1
operator|==
name|TYPE_CODE_FLT
operator|||
name|code1
operator|==
name|TYPE_CODE_INT
operator|)
operator|&&
operator|(
name|code2
operator|==
name|TYPE_CODE_FLT
operator|||
name|code2
operator|==
name|TYPE_CODE_INT
operator|)
condition|)
return|return
name|value_as_double
argument_list|(
name|arg1
argument_list|)
operator|<
name|value_as_double
argument_list|(
name|arg2
argument_list|)
return|;
elseif|else
if|if
condition|(
name|code1
operator|==
name|TYPE_CODE_PTR
operator|&&
name|code2
operator|==
name|TYPE_CODE_PTR
condition|)
return|return
name|value_as_pointer
argument_list|(
name|arg1
argument_list|)
operator|<
name|value_as_pointer
argument_list|(
name|arg2
argument_list|)
return|;
comment|/* FIXME: Need to promote to either CORE_ADDR or LONGEST, whichever      is bigger.  */
elseif|else
if|if
condition|(
name|code1
operator|==
name|TYPE_CODE_PTR
operator|&&
name|code2
operator|==
name|TYPE_CODE_INT
condition|)
return|return
name|value_as_pointer
argument_list|(
name|arg1
argument_list|)
operator|<
operator|(
name|CORE_ADDR
operator|)
name|value_as_long
argument_list|(
name|arg2
argument_list|)
return|;
elseif|else
if|if
condition|(
name|code2
operator|==
name|TYPE_CODE_PTR
operator|&&
name|code1
operator|==
name|TYPE_CODE_INT
condition|)
return|return
operator|(
name|CORE_ADDR
operator|)
name|value_as_long
argument_list|(
name|arg1
argument_list|)
operator|<
name|value_as_pointer
argument_list|(
name|arg2
argument_list|)
return|;
else|else
block|{
name|error
argument_list|(
literal|"Invalid type combination in ordering comparison."
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The unary operators - and ~.  Both free the argument ARG1.  */
end_comment

begin_function
name|value
name|value_neg
parameter_list|(
name|arg1
parameter_list|)
specifier|register
name|value
name|arg1
decl_stmt|;
block|{
specifier|register
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|COERCE_ENUM
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|type
operator|=
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_FLT
condition|)
return|return
name|value_from_double
argument_list|(
name|type
argument_list|,
operator|-
name|value_as_double
argument_list|(
name|arg1
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_INT
condition|)
return|return
name|value_from_longest
argument_list|(
name|type
argument_list|,
operator|-
name|value_as_long
argument_list|(
name|arg1
argument_list|)
argument_list|)
return|;
else|else
block|{
name|error
argument_list|(
literal|"Argument to negate operation not a number."
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
comment|/* For lint -- never reached */
block|}
block|}
end_function

begin_function
name|value
name|value_lognot
parameter_list|(
name|arg1
parameter_list|)
specifier|register
name|value
name|arg1
decl_stmt|;
block|{
name|COERCE_ENUM
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|!=
name|TYPE_CODE_INT
condition|)
name|error
argument_list|(
literal|"Argument to complement operation not an integer."
argument_list|)
expr_stmt|;
return|return
name|value_from_longest
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|,
operator|~
name|value_as_long
argument_list|(
name|arg1
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

end_unit

