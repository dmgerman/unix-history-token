begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1992 Regents of the University of California.  * All rights reserved.  *  * Redistribution and use in source and binary forms are permitted  * provided that the above copyright notice and this paragraph are  * duplicated in all such forms and that any documentation,  * advertising materials, and other materials related to such  * distribution and use acknowledge that the software was developed  * by the University of California, Lawrence Berkeley Laboratory,  * Berkeley, CA.  The name of the University may not be used to  * endorse or promote products derived from this software without  * specific prior written permission.  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.  *  * Target dependent code for a sparcstation running SunOS.  * This is mostly kernel debugging support.  * Common code is in sparc-tcmn.c.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"@(#) $Header: sparc-tdep.c,v 1.2 93/02/19 15:25:07 mccanne Exp $ (LBL)"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|<machine/reg.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|KERNELDEBUG
end_ifdef

begin_include
include|#
directive|include
file|"kernel.h"
end_include

begin_include
include|#
directive|include
file|<kvm.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/dir.h>
end_include

begin_include
include|#
directive|include
file|<sys/user.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_decl_stmt
specifier|extern
name|int
name|kernel_debugging
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|CORE_ADDR
name|ksym_lookup
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*  * Read the "thing" at address 'addr' into the space pointed to by P.  * The length of the "thing" is determined by the type of P.  * Result is non-zero if transfer fails.  */
end_comment

begin_define
define|#
directive|define
name|READMEM
parameter_list|(
name|addr
parameter_list|,
name|p
parameter_list|)
define|\
value|(target_read_memory((CORE_ADDR)(addr), (char *)(p), sizeof(*(p))))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Return the address of the saved pc in frame.  */
end_comment

begin_function
name|CORE_ADDR
name|addr_of_pc
parameter_list|(
name|frame
parameter_list|)
name|struct
name|frame_info
modifier|*
name|frame
decl_stmt|;
block|{
specifier|register
name|CORE_ADDR
name|addr
decl_stmt|;
specifier|register
name|struct
name|rwindow
modifier|*
name|rw
decl_stmt|;
ifdef|#
directive|ifdef
name|KERNELDEBUG
comment|/* 	 * If we are kernel debugging, we must special case trap frames. 	 * We can tell if we are a trap frame by looking at the return  	 * address of the frame below us.  If it is in locore, then 	 * we are such a frame and we can find our saved pc in %l1. 	 */
if|if
condition|(
name|kernel_debugging
operator|&&
name|frame
operator|->
name|next
condition|)
block|{
specifier|static
name|CORE_ADDR
name|locore_h
decl_stmt|,
name|locore_t
decl_stmt|;
if|if
condition|(
name|locore_h
operator|==
literal|0
condition|)
block|{
name|locore_h
operator|=
name|ksym_lookup
argument_list|(
literal|"sys_trap"
argument_list|)
expr_stmt|;
name|locore_t
operator|=
name|ksym_lookup
argument_list|(
literal|"kadb_tcode"
argument_list|)
expr_stmt|;
block|}
name|rw
operator|=
operator|(
expr|struct
name|rwindow
operator|*
operator|)
name|frame
operator|->
name|next
operator|->
name|bottom
expr_stmt|;
name|addr
operator|=
name|read_memory_integer
argument_list|(
operator|(
name|CORE_ADDR
operator|)
operator|&
name|rw
operator|->
name|rw_in
index|[
literal|7
index|]
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|>
name|locore_h
operator|&&
name|addr
operator|<
name|locore_t
condition|)
block|{
name|rw
operator|=
operator|(
expr|struct
name|rwindow
operator|*
operator|)
name|frame
operator|->
name|bottom
expr_stmt|;
return|return
operator|(
name|CORE_ADDR
operator|)
operator|&
name|rw
operator|->
name|rw_local
index|[
literal|1
index|]
return|;
block|}
block|}
endif|#
directive|endif
name|rw
operator|=
operator|(
expr|struct
name|rwindow
operator|*
operator|)
name|frame
operator|->
name|bottom
expr_stmt|;
return|return
operator|(
name|CORE_ADDR
operator|)
operator|&
name|rw
operator|->
name|rw_in
index|[
literal|7
index|]
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|KERNELDEBUG
end_ifdef

begin_comment
comment|/*  * The code below implements kernel debugging of crashdumps (or /dev/kmem)  * or remote systems (via a serial link).  For remote kernels, the remote  * context does most the work, so there is very little to do -- we just  * manage the kernel stack boundaries so we know where to stop a backtrace.  *  * The crashdump/kmem (kvm) support is a bit more grungy, but thanks to  * libkvm (see kcore.c) not too bad.  The main work is kvm_fetch_registers  * which sucks the register state out of the current processes pcb.  * There is a command that let's you set the current process -- hopefully,  * to something that's blocked (in the live kernel case).  */
end_comment

begin_comment
comment|/* XXX For misc_function_vector. */
end_comment

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_comment
comment|/*  * Address ranges for the kernel interrupt stack (fixed) and the current  * process' kernel stack (dynamic).  */
end_comment

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|intstack_top
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|intstack_bottom
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|kernstack_top
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|kernstack_bottom
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|proc
modifier|*
name|curproc
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
name|set_curproc
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*  * Return true if ADDR is a valid stack address according to the  * current boundaries (which are determined by the currently running   * user process).  */
end_comment

begin_function
name|int
name|inside_kernstack
parameter_list|(
name|addr
parameter_list|)
name|CORE_ADDR
name|addr
decl_stmt|;
block|{
if|if
condition|(
name|curproc
operator|==
literal|0
condition|)
name|set_curproc
argument_list|()
expr_stmt|;
return|return
operator|(
name|addr
operator|>
name|intstack_bottom
operator|&&
name|addr
operator|<
name|intstack_top
operator|)
operator|||
operator|(
name|addr
operator|>
name|kernstack_bottom
operator|&&
name|addr
operator|<
name|kernstack_top
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * (re-)set the variables that make inside_kernstack() work.  */
end_comment

begin_function
name|void
name|set_kernel_boundaries
parameter_list|(
name|p
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
name|CORE_ADDR
name|kstack
decl_stmt|;
if|if
condition|(
name|intstack_top
operator|==
literal|0
condition|)
block|{
name|intstack_top
operator|=
name|ksym_lookup
argument_list|(
literal|"eintstack"
argument_list|)
expr_stmt|;
name|intstack_bottom
operator|=
name|ksym_lookup
argument_list|(
literal|"intstack"
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * During boot, if masterprocp is still NULL the kernel 	 * stack lives in [ubasic..ubasic+KERNSTACK). 	 */
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
name|kstack
operator|=
name|ksym_lookup
argument_list|(
literal|"ubasic"
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|READMEM
argument_list|(
operator|&
name|p
operator|->
name|p_segu
argument_list|,
operator|&
name|kstack
argument_list|)
condition|)
name|error
argument_list|(
literal|"cannot read kernel stack pointer at %x\n"
argument_list|,
operator|&
name|p
operator|->
name|p_segu
argument_list|)
expr_stmt|;
block|}
name|kernstack_bottom
operator|=
name|kstack
expr_stmt|;
name|kernstack_top
operator|=
name|kstack
operator|+
name|KERNSTACK
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Return the current proc.  masterprocp points to  * current proc which points to current u area.  */
end_comment

begin_function
name|struct
name|proc
modifier|*
name|fetch_curproc
parameter_list|()
block|{
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
specifier|static
name|CORE_ADDR
name|addr
decl_stmt|;
if|if
condition|(
name|addr
operator|==
literal|0
condition|)
name|addr
operator|=
name|ksym_lookup
argument_list|(
literal|"masterprocp"
argument_list|)
expr_stmt|;
if|if
condition|(
name|READMEM
argument_list|(
name|addr
argument_list|,
operator|&
name|p
argument_list|)
condition|)
name|error
argument_list|(
literal|"cannot read proc pointer at %x\n"
argument_list|,
name|addr
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/*  * Called from remote_wait, after the remote kernel has stopped.  * Look up the current proc, and set up boundaries.  * This is for active kernels only.  */
end_comment

begin_function
name|void
name|set_curproc
parameter_list|()
block|{
name|curproc
operator|=
name|fetch_curproc
argument_list|()
expr_stmt|;
name|set_kernel_boundaries
argument_list|(
name|curproc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * All code below is exclusively for support of kernel core files.  */
end_comment

begin_comment
comment|/*  * Fetch registers from a crashdump or /dev/kmem.  */
end_comment

begin_function
name|void
name|kvm_fetch_registers
parameter_list|(
name|p
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
name|struct
name|user
modifier|*
name|uaddr
decl_stmt|;
name|int
name|i
decl_stmt|;
name|u_long
name|cps
decl_stmt|,
name|reg
decl_stmt|,
name|sp
decl_stmt|;
name|float
name|freg
decl_stmt|;
name|struct
name|rwindow
name|win
decl_stmt|;
name|struct
name|pcb
name|pcb
decl_stmt|;
comment|/* find the pcb for the current process */
if|if
condition|(
name|READMEM
argument_list|(
operator|&
name|p
operator|->
name|p_uarea
argument_list|,
operator|&
name|uaddr
argument_list|)
condition|)
name|error
argument_list|(
literal|"cannot u area ptr for proc at 0x%x"
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|READMEM
argument_list|(
operator|&
name|uaddr
operator|->
name|u_pcb
argument_list|,
operator|&
name|pcb
argument_list|)
condition|)
name|error
argument_list|(
literal|"cannot read pcb at 0x%x"
argument_list|,
operator|&
name|uaddr
operator|->
name|u_pcb
argument_list|)
expr_stmt|;
comment|/*          * Invalidate all the registers then fill in the ones we know about.          */
name|registers_changed
argument_list|()
expr_stmt|;
name|sp
operator|=
name|pcb
operator|.
name|pcb_sp
expr_stmt|;
name|supply_register
argument_list|(
name|SP_REGNUM
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|pcb
operator|.
name|pcb_sp
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|PC_REGNUM
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|pcb
operator|.
name|pcb_pc
argument_list|)
expr_stmt|;
comment|/* PC came from o7. */
name|supply_register
argument_list|(
literal|15
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|pcb
operator|.
name|pcb_pc
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|PS_REGNUM
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|pcb
operator|.
name|pcb_psr
argument_list|)
expr_stmt|;
comment|/* XXX There should be a WIM_REGNUM. */
name|supply_register
argument_list|(
literal|66
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|pcb
operator|.
name|pcb_uwm
argument_list|)
expr_stmt|;
comment|/*          * Read last register window saved on stack.          */
if|if
condition|(
name|READMEM
argument_list|(
name|sp
argument_list|,
operator|&
name|win
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"cannot read register window at sp=%x\n"
argument_list|,
name|pcb
operator|.
name|pcb_sp
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|win
argument_list|,
sizeof|sizeof
name|win
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
operator|++
name|i
control|)
name|supply_register
argument_list|(
name|i
operator|+
literal|16
argument_list|,
operator|&
name|win
operator|.
name|rw_local
index|[
name|i
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
operator|++
name|i
control|)
name|supply_register
argument_list|(
name|i
operator|+
literal|24
argument_list|,
operator|&
name|win
operator|.
name|rw_in
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/*          * read the globals& outs saved on the stack (for a trap frame).          */
name|sp
operator|+=
literal|92
operator|+
literal|12
expr_stmt|;
comment|/* XXX - MINFRAME + R_Y */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
literal|14
condition|;
operator|++
name|i
control|)
block|{
name|u_long
name|val
decl_stmt|;
if|if
condition|(
name|READMEM
argument_list|(
name|sp
operator|+
name|i
operator|*
literal|4
argument_list|,
operator|&
name|val
argument_list|)
operator|==
literal|0
condition|)
name|supply_register
argument_list|(
name|i
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|val
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|READMEM
argument_list|(
name|pcb
operator|.
name|pcb_cpctxp
argument_list|,
operator|&
name|cps
argument_list|)
operator|==
literal|0
condition|)
name|supply_register
argument_list|(
name|CPS_REGNUM
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|cps
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set the process context to that of the proc structure at  * system address paddr.  Read in the register state.  */
end_comment

begin_function
name|int
name|set_procaddr
parameter_list|(
name|paddr
parameter_list|)
name|CORE_ADDR
name|paddr
decl_stmt|;
block|{
name|struct
name|proc
name|proc
decl_stmt|;
name|struct
name|user
modifier|*
name|uaddr
decl_stmt|;
if|if
condition|(
name|paddr
operator|==
literal|0
condition|)
name|paddr
operator|=
operator|(
name|CORE_ADDR
operator|)
name|fetch_curproc
argument_list|()
expr_stmt|;
if|if
condition|(
name|paddr
operator|<
name|KERNELBASE
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|READMEM
argument_list|(
name|paddr
argument_list|,
operator|&
name|proc
argument_list|)
condition|)
name|error
argument_list|(
literal|"cannot read proc struct at 0x%x"
argument_list|,
name|paddr
argument_list|)
expr_stmt|;
comment|/* 	 * This is REALLY STUPID.  The only way to tell libkvm that we want to 	 * change user address maps is with kvm_getu. 	 * If the getu fails, revert to the old address. 	 */
if|if
condition|(
name|kernel_getu
argument_list|(
operator|(
name|u_long
operator|*
operator|)
operator|&
name|proc
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|READMEM
argument_list|(
name|curproc
argument_list|,
operator|&
name|proc
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|kernel_getu
argument_list|(
operator|(
name|u_long
operator|*
operator|)
operator|&
name|proc
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"cannot read uarea for proc at 0x%x"
argument_list|,
name|paddr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|curproc
operator|=
operator|(
expr|struct
name|proc
operator|*
operator|)
name|paddr
expr_stmt|;
name|set_kernel_boundaries
argument_list|(
name|curproc
argument_list|)
expr_stmt|;
name|kvm_fetch_registers
argument_list|(
name|curproc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get the registers out of a crashdump or /dev/kmem.  * XXX This somehow belongs in kcore.c.  *  * We just get all the registers, so we don't use regno.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|void
name|kernel_core_registers
parameter_list|(
name|regno
parameter_list|)
name|int
name|regno
decl_stmt|;
block|{
comment|/*          * Need to find current u area to get kernel stack and pcb          * where "panic" saved registers.          * (libkvm also needs to know current u area to get user          * address space mapping). 	 */
operator|(
name|void
operator|)
name|set_procaddr
argument_list|(
name|curproc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Building in support for stepping through a longjmp is silly.  * Couldn't the gdb maintainers spend their time more productively?  */
end_comment

begin_function
name|int
name|get_longjmp_target
parameter_list|(
name|pc
parameter_list|)
name|CORE_ADDR
modifier|*
name|pc
decl_stmt|;
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

