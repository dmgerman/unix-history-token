begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Convex host-dependent code for GDB.    Copyright 1990, 1991, 1992 Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"command.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"wait.h"
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/dir.h>
end_include

begin_include
include|#
directive|include
file|<sys/user.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/pcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/thread.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_include
include|#
directive|include
file|<convex/vmparam.h>
end_include

begin_include
include|#
directive|include
file|<convex/filehdr.h>
end_include

begin_include
include|#
directive|include
file|<convex/opthdr.h>
end_include

begin_include
include|#
directive|include
file|<convex/scnhdr.h>
end_include

begin_include
include|#
directive|include
file|<convex/core.h>
end_include

begin_comment
comment|/* Per-thread data, read from the inferior at each stop and written    back at each resume.  */
end_comment

begin_comment
comment|/* Number of active threads.    Tables are valid for thread numbers less than this.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|n_threads
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|MAXTHREADS
value|8
end_define

begin_comment
comment|/* Thread state.  The remaining data is valid only if this is PI_TALIVE.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|thread_state
index|[
name|MAXTHREADS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Stop pc, signal, signal subcode */
end_comment

begin_decl_stmt
specifier|static
name|int
name|thread_pc
index|[
name|MAXTHREADS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|thread_signal
index|[
name|MAXTHREADS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|thread_sigcode
index|[
name|MAXTHREADS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Thread registers.    If thread is selected, the regs are in registers[] instead.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|thread_regs
index|[
name|MAXTHREADS
index|]
index|[
name|REGISTER_BYTES
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1 if the top frame on the thread's stack was a context frame,    meaning that the kernel is up to something and we should not    touch the thread at all except to resume it.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|thread_is_in_kernel
index|[
name|MAXTHREADS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The currently selected thread's number.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|inferior_thread
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Inferior process's file handle and a process control block    to feed args to ioctl with.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|inferior_fd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|pcntl
name|ps
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* SOFF file headers for exec or core file.  */
end_comment

begin_decl_stmt
specifier|static
name|FILEHDR
name|filehdr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|OPTHDR
name|opthdr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|SCNHDR
name|scnhdr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Address maps constructed from section headers of exec and core files.    Defines process address -> file address translation.  */
end_comment

begin_struct
struct|struct
name|pmap
block|{
name|long
name|mem_addr
decl_stmt|;
comment|/* process start address */
name|long
name|mem_end
decl_stmt|;
comment|/* process end+1 address */
name|long
name|file_addr
decl_stmt|;
comment|/* file start address */
name|long
name|thread
decl_stmt|;
comment|/* -1 shared; 0,1,... thread-local */
name|long
name|type
decl_stmt|;
comment|/* S_TEXT S_DATA S_BSS S_TBSS etc */
name|long
name|which
decl_stmt|;
comment|/* used to sort map for info files */
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|int
name|n_exec
decl_stmt|,
name|n_core
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|pmap
name|exec_map
index|[
literal|100
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|pmap
name|core_map
index|[
literal|100
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Offsets in the core file of core_context and core_tcontext blocks.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|context_offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|tcontext_offset
index|[
name|MAXTHREADS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Core file control blocks.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|core_context_v70
name|c
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|core_tcontext_v70
name|tc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|user
name|u
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|thread_t
name|th
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|proc_t
name|pr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The registers of the currently selected thread.  */
end_comment

begin_decl_stmt
specifier|extern
name|char
name|registers
index|[
name|REGISTER_BYTES
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Vector and communication registers from core dump or from inferior.    These are read on demand, ie, not normally valid.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|vecst
name|vector_registers
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|creg_ctx
name|comm_registers
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Flag, set on a vanilla CONT command and cleared when the inferior    is continued.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|all_continue
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Flag, set when the inferior is continued by a vanilla CONT command,    cleared if it is continued for any other purpose.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|thread_switch_ok
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Stack of signals recieved from threads but not yet delivered to gdb.  */
end_comment

begin_struct
struct|struct
name|threadpid
block|{
name|int
name|pid
decl_stmt|;
name|int
name|thread
decl_stmt|;
name|int
name|signo
decl_stmt|;
name|int
name|subsig
decl_stmt|;
name|int
name|pc
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|threadpid
name|signal_stack_bot
index|[
literal|100
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|threadpid
modifier|*
name|signal_stack
init|=
name|signal_stack_bot
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* How to detect empty stack -- bottom frame is all zero.  */
end_comment

begin_define
define|#
directive|define
name|signal_stack_is_empty
parameter_list|()
value|(signal_stack->pid == 0)
end_define

begin_comment
comment|/* Mode controlled by SET PIPE command, controls the psw SEQ bit    which forces each instruction to complete before the next one starts.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|sequential
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Mode controlled by the SET PARALLEL command.  Values are:    0  concurrency limit 1 thread, dynamic scheduling    1  no concurrency limit, dynamic scheduling    2  no concurrency limit, fixed scheduling  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|parallel
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Mode controlled by SET BASE command, output radix for unformatted    integer typeout, as in argument lists, aggregates, and so on.    Zero means guess whether it's an address (hex) or not (decimal).  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|output_radix
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Signal subcode at last thread stop.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|stop_sigcode
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Hack, see wait() below.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|exec_trap_timer
decl_stmt|;
end_decl_stmt

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_comment
comment|/* Nonzero if we are debugging an attached outside process    rather than an inferior.  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|attach_flag
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|struct
name|type
modifier|*
name|vector_type
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|long
modifier|*
name|read_vector_register
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|long
modifier|*
name|read_vector_register_1
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|write_vector_register
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|REGISTER_TYPE
name|read_comm_register
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|write_comm_register
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|convex_cont_command
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|thread_continue
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|select_thread
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|scan_stack
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|set_fixed_scheduling
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|subsig_name
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|psw_info
parameter_list|()
function_decl|;
end_function_decl

begin_expr_stmt
specifier|static
name|sig_noop
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|ptr_cmp
argument_list|()
expr_stmt|;
end_expr_stmt

begin_escape
end_escape

begin_comment
comment|/* Execute ptrace.  Convex V7 replaced ptrace with pattach.    Allow ptrace (0) as a no-op.  */
end_comment

begin_function
name|int
name|call_ptrace
parameter_list|(
name|request
parameter_list|,
name|pid
parameter_list|,
name|procaddr
parameter_list|,
name|buf
parameter_list|)
name|int
name|request
decl_stmt|,
name|pid
decl_stmt|;
name|PTRACE_ARG3_TYPE
name|procaddr
decl_stmt|;
name|int
name|buf
decl_stmt|;
block|{
if|if
condition|(
name|request
operator|==
literal|0
condition|)
return|return;
name|error
argument_list|(
literal|"no ptrace"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Replacement for system execle routine.    Convert it to an equivalent exect, which pattach insists on.  */
end_comment

begin_macro
name|execle
argument_list|(
argument|name
argument_list|,
argument|argv
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|argv
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
modifier|*
modifier|*
name|envp
init|=
operator|(
name|char
operator|*
operator|*
operator|*
operator|)
operator|&
name|argv
decl_stmt|;
while|while
condition|(
operator|*
name|envp
operator|++
condition|)
empty_stmt|;
name|signal
argument_list|(
name|SIGTRAP
argument_list|,
name|sig_noop
argument_list|)
expr_stmt|;
name|exect
argument_list|(
name|name
argument_list|,
operator|&
name|argv
argument_list|,
operator|*
name|envp
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Stupid handler for stupid trace trap that otherwise causes    startup to stupidly hang.  */
end_comment

begin_expr_stmt
specifier|static
name|sig_noop
argument_list|()
block|{}
comment|/* Read registers from inferior into registers[] array.    For convex, they are already there, read in when the inferior stops.  */
name|void
name|fetch_inferior_registers
argument_list|(
argument|regno
argument_list|)
name|int
name|regno
expr_stmt|;
end_expr_stmt

begin_block
block|{ }
end_block

begin_comment
comment|/* Store our register values back into the inferior.    For Convex, do this only once, right before resuming inferior.  */
end_comment

begin_function
name|void
name|store_inferior_registers
parameter_list|(
name|regno
parameter_list|)
name|int
name|regno
decl_stmt|;
block|{ }
end_function

begin_comment
comment|/* Copy LEN bytes from inferior's memory starting at MEMADDR    to debugger memory starting at MYADDR.     On failure (cannot read from inferior, usually because address is out    of bounds) returns the value of errno. */
end_comment

begin_function
name|int
name|read_inferior_memory
parameter_list|(
name|memaddr
parameter_list|,
name|myaddr
parameter_list|,
name|len
parameter_list|)
name|CORE_ADDR
name|memaddr
decl_stmt|;
name|char
modifier|*
name|myaddr
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|errno
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
comment|/* little-known undocumented max request size */
name|int
name|i
init|=
operator|(
name|len
operator|<
literal|12288
operator|)
condition|?
name|len
else|:
literal|12288
decl_stmt|;
name|lseek
argument_list|(
name|inferior_fd
argument_list|,
name|memaddr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|read
argument_list|(
name|inferior_fd
argument_list|,
name|myaddr
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|memaddr
operator|+=
name|i
expr_stmt|;
name|myaddr
operator|+=
name|i
expr_stmt|;
name|len
operator|-=
name|i
expr_stmt|;
block|}
if|if
condition|(
name|errno
condition|)
name|bzero
argument_list|(
name|myaddr
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
name|errno
return|;
block|}
end_function

begin_comment
comment|/* Copy LEN bytes of data from debugger memory at MYADDR    to inferior's memory at MEMADDR.    Returns errno on failure (cannot write the inferior) */
end_comment

begin_function
name|int
name|write_inferior_memory
parameter_list|(
name|memaddr
parameter_list|,
name|myaddr
parameter_list|,
name|len
parameter_list|)
name|CORE_ADDR
name|memaddr
decl_stmt|;
name|char
modifier|*
name|myaddr
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|errno
operator|=
literal|0
expr_stmt|;
name|lseek
argument_list|(
name|inferior_fd
argument_list|,
name|memaddr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|inferior_fd
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
name|errno
return|;
block|}
end_function

begin_comment
comment|/* Here from create_inferior when the inferior process has been created    and started up.  We must do a pattach to grab it for debugging.     Also, intercept the CONT command by altering its dispatch address.  */
end_comment

begin_macro
name|create_inferior_hook
argument_list|(
argument|pid
argument_list|)
end_macro

begin_decl_stmt
name|int
name|pid
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|static
name|char
name|cont
index|[]
init|=
literal|"cont"
decl_stmt|;
specifier|static
name|char
name|cont1
index|[]
init|=
literal|"c"
decl_stmt|;
name|char
modifier|*
name|linep
init|=
name|cont
decl_stmt|;
name|char
modifier|*
name|linep1
init|=
name|cont1
decl_stmt|;
name|char
modifier|*
modifier|*
name|line
init|=
operator|&
name|linep
decl_stmt|;
name|char
modifier|*
modifier|*
name|line1
init|=
operator|&
name|linep1
decl_stmt|;
name|struct
name|cmd_list_element
modifier|*
name|c
decl_stmt|;
name|c
operator|=
name|lookup_cmd
argument_list|(
name|line
argument_list|,
name|cmdlist
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|c
operator|->
name|function
operator|=
name|convex_cont_command
expr_stmt|;
name|c
operator|=
name|lookup_cmd
argument_list|(
name|line1
argument_list|,
name|cmdlist
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|c
operator|->
name|function
operator|=
name|convex_cont_command
expr_stmt|;
name|inferior_fd
operator|=
name|pattach
argument_list|(
name|pid
argument_list|,
name|O_EXCL
argument_list|)
expr_stmt|;
if|if
condition|(
name|inferior_fd
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
literal|"pattach"
argument_list|)
expr_stmt|;
name|inferior_thread
operator|=
literal|0
expr_stmt|;
name|set_fixed_scheduling
argument_list|(
name|pid
argument_list|,
name|parallel
operator|==
literal|2
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Attach process PID for debugging.  */
end_comment

begin_macro
name|attach
argument_list|(
argument|pid
argument_list|)
end_macro

begin_decl_stmt
name|int
name|pid
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|fd
init|=
name|pattach
argument_list|(
name|pid
argument_list|,
name|O_EXCL
argument_list|)
decl_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
literal|"pattach"
argument_list|)
expr_stmt|;
name|attach_flag
operator|=
literal|1
expr_stmt|;
comment|/* wait for strange kernel reverberations to go away */
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|setpgrp
argument_list|(
name|pid
argument_list|,
name|pid
argument_list|)
expr_stmt|;
name|inferior_fd
operator|=
name|fd
expr_stmt|;
name|inferior_thread
operator|=
literal|0
expr_stmt|;
return|return
name|pid
return|;
block|}
end_block

begin_comment
comment|/* Stop debugging the process whose number is PID    and continue it with signal number SIGNAL.    SIGNAL = 0 means just continue it.  */
end_comment

begin_function
name|void
name|detach
parameter_list|(
name|signal
parameter_list|)
name|int
name|signal
decl_stmt|;
block|{
name|signal_stack
operator|=
name|signal_stack_bot
expr_stmt|;
name|thread_continue
argument_list|(
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
name|signal
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
name|inferior_fd
argument_list|,
name|PIXDETACH
argument_list|,
operator|&
name|ps
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|inferior_fd
argument_list|)
expr_stmt|;
name|inferior_fd
operator|=
literal|0
expr_stmt|;
name|attach_flag
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Kill off the inferior process.  */
end_comment

begin_macro
name|kill_inferior
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|inferior_pid
operator|==
literal|0
condition|)
return|return;
name|ioctl
argument_list|(
name|inferior_fd
argument_list|,
name|PIXTERMINATE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|wait
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|target_mourn_inferior
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Read vector register REG, and return a pointer to the value.  */
end_comment

begin_function
specifier|static
name|long
modifier|*
name|read_vector_register
parameter_list|(
name|reg
parameter_list|)
name|int
name|reg
decl_stmt|;
block|{
if|if
condition|(
name|have_inferior_p
argument_list|()
condition|)
block|{
name|errno
operator|=
literal|0
expr_stmt|;
name|ps
operator|.
name|pi_buffer
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|vector_registers
expr_stmt|;
name|ps
operator|.
name|pi_nbytes
operator|=
sizeof|sizeof
name|vector_registers
expr_stmt|;
name|ps
operator|.
name|pi_offset
operator|=
literal|0
expr_stmt|;
name|ps
operator|.
name|pi_thread
operator|=
name|inferior_thread
expr_stmt|;
name|ioctl
argument_list|(
name|inferior_fd
argument_list|,
name|PIXRDVREGS
argument_list|,
operator|&
name|ps
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
condition|)
name|bzero
argument_list|(
operator|&
name|vector_registers
argument_list|,
sizeof|sizeof
name|vector_registers
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|corechan
operator|>=
literal|0
condition|)
block|{
name|lseek
argument_list|(
name|corechan
argument_list|,
name|tcontext_offset
index|[
name|inferior_thread
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|myread
argument_list|(
name|corechan
argument_list|,
operator|&
name|tc
argument_list|,
sizeof|sizeof
name|tc
argument_list|)
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
name|corefile
argument_list|)
expr_stmt|;
name|lseek
argument_list|(
name|corechan
argument_list|,
name|tc
operator|.
name|core_thread_p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|myread
argument_list|(
name|corechan
argument_list|,
operator|&
name|th
argument_list|,
sizeof|sizeof
name|th
argument_list|)
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
name|corefile
argument_list|)
expr_stmt|;
name|lseek
argument_list|(
name|corechan
argument_list|,
name|tc
operator|.
name|core_vregs_p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|myread
argument_list|(
name|corechan
argument_list|,
operator|&
name|vector_registers
argument_list|,
literal|16
operator|*
literal|128
argument_list|)
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
name|corefile
argument_list|)
expr_stmt|;
name|vector_registers
operator|.
name|vm
index|[
literal|0
index|]
operator|=
name|th
operator|.
name|t_vect_ctx
operator|.
name|vc_vm
index|[
literal|0
index|]
expr_stmt|;
name|vector_registers
operator|.
name|vm
index|[
literal|1
index|]
operator|=
name|th
operator|.
name|t_vect_ctx
operator|.
name|vc_vm
index|[
literal|1
index|]
expr_stmt|;
name|vector_registers
operator|.
name|vls
operator|=
name|th
operator|.
name|t_vect_ctx
operator|.
name|vc_vls
expr_stmt|;
block|}
return|return
name|read_vector_register_1
argument_list|(
name|reg
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return a pointer to vector register REG, which must already have been    fetched from the inferior or core file.  */
end_comment

begin_function
specifier|static
name|long
modifier|*
name|read_vector_register_1
parameter_list|(
name|reg
parameter_list|)
name|int
name|reg
decl_stmt|;
block|{
switch|switch
condition|(
name|reg
condition|)
block|{
case|case
name|VM_REGNUM
case|:
return|return
operator|(
name|long
operator|*
operator|)
name|vector_registers
operator|.
name|vm
return|;
case|case
name|VS_REGNUM
case|:
return|return
operator|(
name|long
operator|*
operator|)
operator|&
name|vector_registers
operator|.
name|vls
return|;
case|case
name|VL_REGNUM
case|:
return|return
literal|1
operator|+
operator|(
name|long
operator|*
operator|)
operator|&
name|vector_registers
operator|.
name|vls
return|;
default|default:
return|return
operator|(
name|long
operator|*
operator|)
operator|&
name|vector_registers
operator|.
name|vr
index|[
name|reg
index|]
return|;
block|}
block|}
end_function

begin_comment
comment|/* Write vector register REG, element ELEMENT, new value VAL.    NB: must use read-modify-write on the entire vector state,    since pattach does not do offsetted writes correctly.  */
end_comment

begin_function
specifier|static
name|void
name|write_vector_register
parameter_list|(
name|reg
parameter_list|,
name|element
parameter_list|,
name|val
parameter_list|)
name|int
name|reg
decl_stmt|,
name|element
decl_stmt|;
name|REGISTER_TYPE
name|val
decl_stmt|;
block|{
if|if
condition|(
name|have_inferior_p
argument_list|()
condition|)
block|{
name|errno
operator|=
literal|0
expr_stmt|;
name|ps
operator|.
name|pi_thread
operator|=
name|inferior_thread
expr_stmt|;
name|ps
operator|.
name|pi_offset
operator|=
literal|0
expr_stmt|;
name|ps
operator|.
name|pi_buffer
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|vector_registers
expr_stmt|;
name|ps
operator|.
name|pi_nbytes
operator|=
sizeof|sizeof
name|vector_registers
expr_stmt|;
name|ioctl
argument_list|(
name|inferior_fd
argument_list|,
name|PIXRDVREGS
argument_list|,
operator|&
name|ps
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|reg
condition|)
block|{
case|case
name|VL_REGNUM
case|:
name|vector_registers
operator|.
name|vls
operator|=
operator|(
name|vector_registers
operator|.
name|vls
operator|&
literal|0xffffffff00000000LL
operator|)
operator|+
operator|(
name|unsigned
name|long
operator|)
name|val
expr_stmt|;
break|break;
case|case
name|VS_REGNUM
case|:
name|vector_registers
operator|.
name|vls
operator|=
operator|(
name|val
operator|<<
literal|32
operator|)
operator|+
operator|(
name|unsigned
name|long
operator|)
name|vector_registers
operator|.
name|vls
expr_stmt|;
break|break;
default|default:
name|vector_registers
operator|.
name|vr
index|[
name|reg
index|]
operator|.
name|el
index|[
name|element
index|]
operator|=
name|val
expr_stmt|;
break|break;
block|}
name|ioctl
argument_list|(
name|inferior_fd
argument_list|,
name|PIXWRVREGS
argument_list|,
operator|&
name|ps
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
condition|)
name|perror_with_name
argument_list|(
literal|"writing vector register"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return the contents of communication register NUM.  */
end_comment

begin_function
specifier|static
name|REGISTER_TYPE
name|read_comm_register
parameter_list|(
name|num
parameter_list|)
name|int
name|num
decl_stmt|;
block|{
if|if
condition|(
name|have_inferior_p
argument_list|()
condition|)
block|{
name|ps
operator|.
name|pi_buffer
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|comm_registers
expr_stmt|;
name|ps
operator|.
name|pi_nbytes
operator|=
sizeof|sizeof
name|comm_registers
expr_stmt|;
name|ps
operator|.
name|pi_offset
operator|=
literal|0
expr_stmt|;
name|ps
operator|.
name|pi_thread
operator|=
name|inferior_thread
expr_stmt|;
name|ioctl
argument_list|(
name|inferior_fd
argument_list|,
name|PIXRDCREGS
argument_list|,
operator|&
name|ps
argument_list|)
expr_stmt|;
block|}
return|return
name|comm_registers
operator|.
name|crreg
operator|.
name|r4
index|[
name|num
index|]
return|;
block|}
end_function

begin_comment
comment|/* Store a new value VAL into communication register NUM.      NB: Must use read-modify-write on the whole comm register set    since pattach does not do offsetted writes correctly.  */
end_comment

begin_function
specifier|static
name|void
name|write_comm_register
parameter_list|(
name|num
parameter_list|,
name|val
parameter_list|)
name|int
name|num
decl_stmt|;
name|REGISTER_TYPE
name|val
decl_stmt|;
block|{
if|if
condition|(
name|have_inferior_p
argument_list|()
condition|)
block|{
name|ps
operator|.
name|pi_buffer
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|comm_registers
expr_stmt|;
name|ps
operator|.
name|pi_nbytes
operator|=
sizeof|sizeof
name|comm_registers
expr_stmt|;
name|ps
operator|.
name|pi_offset
operator|=
literal|0
expr_stmt|;
name|ps
operator|.
name|pi_thread
operator|=
name|inferior_thread
expr_stmt|;
name|ioctl
argument_list|(
name|inferior_fd
argument_list|,
name|PIXRDCREGS
argument_list|,
operator|&
name|ps
argument_list|)
expr_stmt|;
name|comm_registers
operator|.
name|crreg
operator|.
name|r4
index|[
name|num
index|]
operator|=
name|val
expr_stmt|;
name|ioctl
argument_list|(
name|inferior_fd
argument_list|,
name|PIXWRCREGS
argument_list|,
operator|&
name|ps
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Resume execution of the inferior process.    If STEP is nonzero, single-step it.    If SIGNAL is nonzero, give it that signal.  */
end_comment

begin_function
name|void
name|resume
parameter_list|(
name|step
parameter_list|,
name|signal
parameter_list|)
name|int
name|step
decl_stmt|;
name|int
name|signal
decl_stmt|;
block|{
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|step
operator|||
name|signal
condition|)
name|thread_continue
argument_list|(
name|inferior_thread
argument_list|,
name|step
argument_list|,
name|signal
argument_list|)
expr_stmt|;
else|else
name|thread_continue
argument_list|(
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Maybe resume some threads.    THREAD is which thread to resume, or -1 to resume them all.    STEP and SIGNAL are as in resume.     Global variable ALL_CONTINUE is set when we are here to do a    `cont' command; otherwise we may be doing `finish' or a call or    something else that will not tolerate an automatic thread switch.     If there are stopped threads waiting to deliver signals, and    ALL_CONTINUE, do not actually resume anything.  gdb will do a wait    and see one of the stopped threads in the queue.  */
end_comment

begin_function
specifier|static
name|void
name|thread_continue
parameter_list|(
name|thread
parameter_list|,
name|step
parameter_list|,
name|signal
parameter_list|)
name|int
name|thread
decl_stmt|,
name|step
decl_stmt|,
name|signal
decl_stmt|;
block|{
name|int
name|n
decl_stmt|;
comment|/* If we are to continue all threads, but not for the CONTINUE command,      pay no attention and continue only the selected thread.  */
if|if
condition|(
name|thread
operator|<
literal|0
operator|&&
operator|!
name|all_continue
condition|)
name|thread
operator|=
name|inferior_thread
expr_stmt|;
comment|/* If we are not stepping, we have now executed the continue part      of a CONTINUE command.  */
if|if
condition|(
operator|!
name|step
condition|)
name|all_continue
operator|=
literal|0
expr_stmt|;
comment|/* Allow wait() to switch threads if this is an all-out continue.  */
name|thread_switch_ok
operator|=
name|thread
operator|<
literal|0
expr_stmt|;
comment|/* If there are threads queued up, don't resume.  */
if|if
condition|(
name|thread_switch_ok
operator|&&
operator|!
name|signal_stack_is_empty
argument_list|()
condition|)
return|return;
comment|/* OK, do it.  */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|n_threads
condition|;
name|n
operator|++
control|)
if|if
condition|(
name|thread_state
index|[
name|n
index|]
operator|==
name|PI_TALIVE
condition|)
block|{
name|select_thread
argument_list|(
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|thread
operator|<
literal|0
operator|||
name|n
operator|==
name|thread
operator|)
operator|&&
operator|!
name|thread_is_in_kernel
index|[
name|n
index|]
condition|)
block|{
comment|/* Blam the trace bits in the stack's saved psws to match  	       the desired step mode.  This is required so that 	       single-stepping a return doesn't restore a psw with a 	       clear trace bit and fly away, and conversely, 	       proceeding through a return in a routine that was 	       stepped into doesn't cause a phantom break by restoring 	       a psw with the trace bit set. */
name|scan_stack
argument_list|(
name|PSW_T_BIT
argument_list|,
name|step
argument_list|)
expr_stmt|;
name|scan_stack
argument_list|(
name|PSW_S_BIT
argument_list|,
name|sequential
argument_list|)
expr_stmt|;
block|}
name|ps
operator|.
name|pi_buffer
operator|=
name|registers
expr_stmt|;
name|ps
operator|.
name|pi_nbytes
operator|=
name|REGISTER_BYTES
expr_stmt|;
name|ps
operator|.
name|pi_offset
operator|=
literal|0
expr_stmt|;
name|ps
operator|.
name|pi_thread
operator|=
name|n
expr_stmt|;
if|if
condition|(
operator|!
name|thread_is_in_kernel
index|[
name|n
index|]
condition|)
if|if
condition|(
name|ioctl
argument_list|(
name|inferior_fd
argument_list|,
name|PIXWRREGS
argument_list|,
operator|&
name|ps
argument_list|)
condition|)
name|perror_with_name
argument_list|(
literal|"PIXWRREGS"
argument_list|)
expr_stmt|;
if|if
condition|(
name|thread
operator|<
literal|0
operator|||
name|n
operator|==
name|thread
condition|)
block|{
name|ps
operator|.
name|pi_pc
operator|=
literal|1
expr_stmt|;
name|ps
operator|.
name|pi_signo
operator|=
name|signal
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|inferior_fd
argument_list|,
name|step
condition|?
name|PIXSTEP
else|:
name|PIXCONTINUE
argument_list|,
operator|&
name|ps
argument_list|)
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
literal|"PIXCONTINUE"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ioctl
argument_list|(
name|inferior_fd
argument_list|,
name|PIXRUN
argument_list|,
operator|&
name|ps
argument_list|)
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
literal|"PIXRUN"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Replacement for system wait routine.       The system wait returns with one or more threads stopped by    signals.  Put stopped threads on a stack and return them one by    one, so that it appears that wait returns one thread at a time.     Global variable THREAD_SWITCH_OK is set when gdb can tolerate wait    returning a new thread.  If it is false, then only one thread is    running; we will do a real wait, the thread will do something, and    we will return that.  */
end_comment

begin_function
name|pid_t
name|wait
parameter_list|(
name|w
parameter_list|)
name|union
name|wait
modifier|*
name|w
decl_stmt|;
block|{
name|int
name|pid
decl_stmt|;
if|if
condition|(
operator|!
name|w
condition|)
return|return
name|wait3
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
comment|/* Do a real wait if we were told to, or if there are no queued threads.  */
if|if
condition|(
operator|!
name|thread_switch_ok
operator|||
name|signal_stack_is_empty
argument_list|()
condition|)
block|{
name|int
name|thread
decl_stmt|;
name|pid
operator|=
name|wait3
argument_list|(
name|w
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|WIFSTOPPED
argument_list|(
operator|*
name|w
argument_list|)
operator|||
name|pid
operator|!=
name|inferior_pid
condition|)
return|return
name|pid
return|;
comment|/* The inferior has done something and stopped.  Read in all the 	 threads' registers, and queue up any signals that happened.  */
if|if
condition|(
name|ioctl
argument_list|(
name|inferior_fd
argument_list|,
name|PIXGETTHCOUNT
argument_list|,
operator|&
name|ps
argument_list|)
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
literal|"PIXGETTHCOUNT"
argument_list|)
expr_stmt|;
name|n_threads
operator|=
name|ps
operator|.
name|pi_othdcnt
expr_stmt|;
for|for
control|(
name|thread
operator|=
literal|0
init|;
name|thread
operator|<
name|n_threads
condition|;
name|thread
operator|++
control|)
block|{
name|ps
operator|.
name|pi_thread
operator|=
name|thread
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|inferior_fd
argument_list|,
name|PIXGETSUBCODE
argument_list|,
operator|&
name|ps
argument_list|)
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
literal|"PIXGETSUBCODE"
argument_list|)
expr_stmt|;
name|thread_state
index|[
name|thread
index|]
operator|=
name|ps
operator|.
name|pi_otstate
expr_stmt|;
if|if
condition|(
name|ps
operator|.
name|pi_otstate
operator|==
name|PI_TALIVE
condition|)
block|{
name|select_thread
argument_list|(
name|thread
argument_list|)
expr_stmt|;
name|ps
operator|.
name|pi_buffer
operator|=
name|registers
expr_stmt|;
name|ps
operator|.
name|pi_nbytes
operator|=
name|REGISTER_BYTES
expr_stmt|;
name|ps
operator|.
name|pi_offset
operator|=
literal|0
expr_stmt|;
name|ps
operator|.
name|pi_thread
operator|=
name|thread
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|inferior_fd
argument_list|,
name|PIXRDREGS
argument_list|,
operator|&
name|ps
argument_list|)
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
literal|"PIXRDREGS"
argument_list|)
expr_stmt|;
name|registers_fetched
argument_list|()
expr_stmt|;
name|thread_pc
index|[
name|thread
index|]
operator|=
name|read_pc
argument_list|()
expr_stmt|;
name|thread_signal
index|[
name|thread
index|]
operator|=
name|ps
operator|.
name|pi_osigno
expr_stmt|;
name|thread_sigcode
index|[
name|thread
index|]
operator|=
name|ps
operator|.
name|pi_osigcode
expr_stmt|;
comment|/* If the thread's stack has a context frame 		 on top, something fucked is going on.  I do not 		 know what, but do I know this: the only thing you 		 can do with such a thread is continue it.  */
name|thread_is_in_kernel
index|[
name|thread
index|]
operator|=
operator|(
operator|(
name|read_register
argument_list|(
name|PS_REGNUM
argument_list|)
operator|>>
literal|25
operator|)
operator|&
literal|3
operator|)
operator|==
literal|0
expr_stmt|;
comment|/* Signals push an extended frame and then fault 		 with a ridiculous pc.  Pop the frame.  */
if|if
condition|(
name|thread_pc
index|[
name|thread
index|]
operator|>
name|STACK_END_ADDR
condition|)
block|{
name|POP_FRAME
expr_stmt|;
if|if
condition|(
name|is_break_pc
argument_list|(
name|thread_pc
index|[
name|thread
index|]
argument_list|)
condition|)
name|thread_pc
index|[
name|thread
index|]
operator|=
name|read_pc
argument_list|()
operator|-
literal|2
expr_stmt|;
else|else
name|thread_pc
index|[
name|thread
index|]
operator|=
name|read_pc
argument_list|()
expr_stmt|;
name|write_register
argument_list|(
name|PC_REGNUM
argument_list|,
name|thread_pc
index|[
name|thread
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ps
operator|.
name|pi_osigno
operator|||
name|ps
operator|.
name|pi_osigcode
condition|)
block|{
name|signal_stack
operator|++
expr_stmt|;
name|signal_stack
operator|->
name|pid
operator|=
name|pid
expr_stmt|;
name|signal_stack
operator|->
name|thread
operator|=
name|thread
expr_stmt|;
name|signal_stack
operator|->
name|signo
operator|=
name|thread_signal
index|[
name|thread
index|]
expr_stmt|;
name|signal_stack
operator|->
name|subsig
operator|=
name|thread_sigcode
index|[
name|thread
index|]
expr_stmt|;
name|signal_stack
operator|->
name|pc
operator|=
name|thread_pc
index|[
name|thread
index|]
expr_stmt|;
block|}
comment|/* The following hackery is caused by a unix 7.1 feature: 		 the inferior's fixed scheduling mode is cleared when 		 it execs the shell (since the shell is not a parallel 		 program).  So, note the 5.4 trap we get when 		 the shell does its exec, then catch the 5.0 trap  		 that occurs when the debuggee starts, and set fixed 		 scheduling mode properly.  */
if|if
condition|(
name|ps
operator|.
name|pi_osigno
operator|==
literal|5
operator|&&
name|ps
operator|.
name|pi_osigcode
operator|==
literal|4
condition|)
name|exec_trap_timer
operator|=
literal|1
expr_stmt|;
else|else
name|exec_trap_timer
operator|--
expr_stmt|;
if|if
condition|(
name|ps
operator|.
name|pi_osigno
operator|==
literal|5
operator|&&
name|exec_trap_timer
operator|==
literal|0
condition|)
name|set_fixed_scheduling
argument_list|(
name|pid
argument_list|,
name|parallel
operator|==
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|signal_stack_is_empty
argument_list|()
condition|)
name|error
argument_list|(
literal|"no active threads?!"
argument_list|)
expr_stmt|;
block|}
comment|/* Select the thread that stopped, and return *w saying why.  */
name|select_thread
argument_list|(
name|signal_stack
operator|->
name|thread
argument_list|)
expr_stmt|;
name|stop_signal
operator|=
name|signal_stack
operator|->
name|signo
expr_stmt|;
name|stop_sigcode
operator|=
name|signal_stack
operator|->
name|subsig
expr_stmt|;
name|WSETSTOP
argument_list|(
operator|*
name|w
argument_list|,
name|signal_stack
operator|->
name|signo
argument_list|)
expr_stmt|;
name|w
operator|->
name|w_thread
operator|=
name|signal_stack
operator|->
name|thread
expr_stmt|;
return|return
operator|(
name|signal_stack
operator|--
operator|)
operator|->
name|pid
return|;
block|}
end_function

begin_comment
comment|/* Select thread THREAD -- its registers, stack, per-thread memory.    This is the only routine that may assign to inferior_thread    or thread_regs[].  */
end_comment

begin_function
specifier|static
name|void
name|select_thread
parameter_list|(
name|thread
parameter_list|)
name|int
name|thread
decl_stmt|;
block|{
if|if
condition|(
name|thread
operator|==
name|inferior_thread
condition|)
return|return;
name|bcopy
argument_list|(
name|registers
argument_list|,
name|thread_regs
index|[
name|inferior_thread
index|]
argument_list|,
name|REGISTER_BYTES
argument_list|)
expr_stmt|;
name|ps
operator|.
name|pi_thread
operator|=
name|inferior_thread
operator|=
name|thread
expr_stmt|;
if|if
condition|(
name|have_inferior_p
argument_list|()
condition|)
name|ioctl
argument_list|(
name|inferior_fd
argument_list|,
name|PISETRWTID
argument_list|,
operator|&
name|ps
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|thread_regs
index|[
name|thread
index|]
argument_list|,
name|registers
argument_list|,
name|REGISTER_BYTES
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Routine to set or clear a psw bit in the psw and also all psws    saved on the stack.  Quits when we get to a frame in which the    saved psw is correct. */
end_comment

begin_function
specifier|static
name|void
name|scan_stack
parameter_list|(
name|bit
parameter_list|,
name|val
parameter_list|)
name|long
name|bit
decl_stmt|,
name|val
decl_stmt|;
block|{
name|long
name|ps
init|=
name|read_register
argument_list|(
name|PS_REGNUM
argument_list|)
decl_stmt|;
name|long
name|fp
decl_stmt|;
if|if
condition|(
name|val
condition|?
operator|!
operator|(
name|ps
operator|&
name|bit
operator|)
else|:
operator|(
name|ps
operator|&
name|bit
operator|)
condition|)
block|{
name|ps
operator|^=
name|bit
expr_stmt|;
name|write_register
argument_list|(
name|PS_REGNUM
argument_list|,
name|ps
argument_list|)
expr_stmt|;
name|fp
operator|=
name|read_register
argument_list|(
name|FP_REGNUM
argument_list|)
expr_stmt|;
while|while
condition|(
name|fp
operator|&
literal|0x80000000
condition|)
block|{
name|ps
operator|=
name|read_memory_integer
argument_list|(
name|fp
operator|+
literal|4
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
condition|?
operator|(
name|ps
operator|&
name|bit
operator|)
else|:
operator|!
operator|(
name|ps
operator|&
name|bit
operator|)
condition|)
break|break;
name|ps
operator|^=
name|bit
expr_stmt|;
name|write_memory
argument_list|(
name|fp
operator|+
literal|4
argument_list|,
operator|&
name|ps
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|fp
operator|=
name|read_memory_integer
argument_list|(
name|fp
operator|+
literal|8
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Set fixed scheduling (alliant mode) of process PID to ARG (0 or 1).  */
end_comment

begin_function
specifier|static
name|void
name|set_fixed_scheduling
parameter_list|(
name|pid
parameter_list|,
name|arg
parameter_list|)
name|int
name|arg
decl_stmt|;
block|{
name|struct
name|pattributes
name|pattr
decl_stmt|;
name|getpattr
argument_list|(
name|pid
argument_list|,
operator|&
name|pattr
argument_list|)
expr_stmt|;
name|pattr
operator|.
name|pattr_pfixed
operator|=
name|arg
expr_stmt|;
name|setpattr
argument_list|(
name|pid
argument_list|,
operator|&
name|pattr
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|core_file_command
parameter_list|(
name|filename
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|int
name|n
decl_stmt|;
comment|/* Discard all vestiges of any previous core file      and mark data and stack spaces as empty.  */
if|if
condition|(
name|corefile
condition|)
name|free
argument_list|(
name|corefile
argument_list|)
expr_stmt|;
name|corefile
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|corechan
operator|>=
literal|0
condition|)
name|close
argument_list|(
name|corechan
argument_list|)
expr_stmt|;
name|corechan
operator|=
operator|-
literal|1
expr_stmt|;
name|data_start
operator|=
literal|0
expr_stmt|;
name|data_end
operator|=
literal|0
expr_stmt|;
name|stack_start
operator|=
name|STACK_END_ADDR
expr_stmt|;
name|stack_end
operator|=
name|STACK_END_ADDR
expr_stmt|;
name|n_core
operator|=
literal|0
expr_stmt|;
comment|/* Now, if a new core file was specified, open it and digest it.  */
if|if
condition|(
name|filename
condition|)
block|{
name|filename
operator|=
name|tilde_expand
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|free
argument_list|,
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|have_inferior_p
argument_list|()
condition|)
name|error
argument_list|(
literal|"To look at a core file, you must kill the inferior with \"kill\"."
argument_list|)
expr_stmt|;
name|corechan
operator|=
name|open
argument_list|(
name|filename
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|corechan
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|myread
argument_list|(
name|corechan
argument_list|,
operator|&
name|filehdr
argument_list|,
sizeof|sizeof
name|filehdr
argument_list|)
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|IS_CORE_SOFF_MAGIC
argument_list|(
name|filehdr
operator|.
name|h_magic
argument_list|)
condition|)
name|error
argument_list|(
literal|"%s: not a core file.\n"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|myread
argument_list|(
name|corechan
argument_list|,
operator|&
name|opthdr
argument_list|,
name|filehdr
operator|.
name|h_opthdr
argument_list|)
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
name|filename
argument_list|)
expr_stmt|;
comment|/* Read through the section headers. 	 For text, data, etc, record an entry in the core file map. 	 For context and tcontext, record the file address of 	 the context blocks.  */
name|lseek
argument_list|(
name|corechan
argument_list|,
operator|(
name|long
operator|)
name|filehdr
operator|.
name|h_scnptr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|n_threads
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|filehdr
operator|.
name|h_nscns
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|myread
argument_list|(
name|corechan
argument_list|,
operator|&
name|scnhdr
argument_list|,
sizeof|sizeof
name|scnhdr
argument_list|)
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|scnhdr
operator|.
name|s_flags
operator|&
name|S_TYPMASK
operator|)
operator|>=
name|S_TEXT
operator|&&
operator|(
name|scnhdr
operator|.
name|s_flags
operator|&
name|S_TYPMASK
operator|)
operator|<=
name|S_COMON
condition|)
block|{
name|core_map
index|[
name|n_core
index|]
operator|.
name|mem_addr
operator|=
name|scnhdr
operator|.
name|s_vaddr
expr_stmt|;
name|core_map
index|[
name|n_core
index|]
operator|.
name|mem_end
operator|=
name|scnhdr
operator|.
name|s_vaddr
operator|+
name|scnhdr
operator|.
name|s_size
expr_stmt|;
name|core_map
index|[
name|n_core
index|]
operator|.
name|file_addr
operator|=
name|scnhdr
operator|.
name|s_scnptr
expr_stmt|;
name|core_map
index|[
name|n_core
index|]
operator|.
name|type
operator|=
name|scnhdr
operator|.
name|s_flags
operator|&
name|S_TYPMASK
expr_stmt|;
if|if
condition|(
name|core_map
index|[
name|n_core
index|]
operator|.
name|type
operator|!=
name|S_TBSS
operator|&&
name|core_map
index|[
name|n_core
index|]
operator|.
name|type
operator|!=
name|S_TDATA
operator|&&
name|core_map
index|[
name|n_core
index|]
operator|.
name|type
operator|!=
name|S_TTEXT
condition|)
name|core_map
index|[
name|n_core
index|]
operator|.
name|thread
operator|=
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|n_core
operator|==
literal|0
operator|||
name|core_map
index|[
name|n_core
operator|-
literal|1
index|]
operator|.
name|mem_addr
operator|!=
name|scnhdr
operator|.
name|s_vaddr
condition|)
name|core_map
index|[
name|n_core
index|]
operator|.
name|thread
operator|=
literal|0
expr_stmt|;
else|else
name|core_map
index|[
name|n_core
index|]
operator|.
name|thread
operator|=
name|core_map
index|[
name|n_core
operator|-
literal|1
index|]
operator|.
name|thread
operator|+
literal|1
expr_stmt|;
name|n_core
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|scnhdr
operator|.
name|s_flags
operator|&
name|S_TYPMASK
operator|)
operator|==
name|S_CONTEXT
condition|)
name|context_offset
operator|=
name|scnhdr
operator|.
name|s_scnptr
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|scnhdr
operator|.
name|s_flags
operator|&
name|S_TYPMASK
operator|)
operator|==
name|S_TCONTEXT
condition|)
name|tcontext_offset
index|[
name|n_threads
operator|++
index|]
operator|=
name|scnhdr
operator|.
name|s_scnptr
expr_stmt|;
block|}
comment|/* Read the context block, struct user, struct proc, 	 and the comm regs.  */
name|lseek
argument_list|(
name|corechan
argument_list|,
name|context_offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|myread
argument_list|(
name|corechan
argument_list|,
operator|&
name|c
argument_list|,
sizeof|sizeof
name|c
argument_list|)
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|lseek
argument_list|(
name|corechan
argument_list|,
name|c
operator|.
name|core_user_p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|myread
argument_list|(
name|corechan
argument_list|,
operator|&
name|u
argument_list|,
sizeof|sizeof
name|u
argument_list|)
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|lseek
argument_list|(
name|corechan
argument_list|,
name|c
operator|.
name|core_proc_p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|myread
argument_list|(
name|corechan
argument_list|,
operator|&
name|pr
argument_list|,
sizeof|sizeof
name|pr
argument_list|)
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|comm_registers
operator|=
name|pr
operator|.
name|p_creg
expr_stmt|;
comment|/* Core file apparently is really there.  Make it really exist 	 for xfer_core_file so we can do read_memory on it. */
if|if
condition|(
name|filename
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
name|corefile
operator|=
name|savestring
argument_list|(
name|filename
argument_list|,
name|strlen
argument_list|(
name|filename
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|corefile
operator|=
name|concat
argument_list|(
name|current_directory
argument_list|,
literal|"/"
argument_list|,
name|filename
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"Program %s "
argument_list|,
name|u
operator|.
name|u_comm
argument_list|)
expr_stmt|;
comment|/* Read the thread registers and fill in the thread_xxx[] data.  */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|n_threads
condition|;
name|n
operator|++
control|)
block|{
name|select_thread
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|lseek
argument_list|(
name|corechan
argument_list|,
name|tcontext_offset
index|[
name|n
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|myread
argument_list|(
name|corechan
argument_list|,
operator|&
name|tc
argument_list|,
sizeof|sizeof
name|tc
argument_list|)
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
name|corefile
argument_list|)
expr_stmt|;
name|lseek
argument_list|(
name|corechan
argument_list|,
name|tc
operator|.
name|core_thread_p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|myread
argument_list|(
name|corechan
argument_list|,
operator|&
name|th
argument_list|,
sizeof|sizeof
name|th
argument_list|)
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
name|corefile
argument_list|)
expr_stmt|;
name|lseek
argument_list|(
name|corechan
argument_list|,
name|tc
operator|.
name|core_syscall_context_p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|myread
argument_list|(
name|corechan
argument_list|,
name|registers
argument_list|,
name|REGISTER_BYTES
argument_list|)
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
name|corefile
argument_list|)
expr_stmt|;
name|thread_signal
index|[
name|n
index|]
operator|=
name|th
operator|.
name|t_cursig
expr_stmt|;
name|thread_sigcode
index|[
name|n
index|]
operator|=
name|th
operator|.
name|t_code
expr_stmt|;
name|thread_state
index|[
name|n
index|]
operator|=
name|th
operator|.
name|t_state
expr_stmt|;
name|thread_pc
index|[
name|n
index|]
operator|=
name|read_pc
argument_list|()
expr_stmt|;
if|if
condition|(
name|thread_pc
index|[
name|n
index|]
operator|>
name|STACK_END_ADDR
condition|)
block|{
name|POP_FRAME
expr_stmt|;
if|if
condition|(
name|is_break_pc
argument_list|(
name|thread_pc
index|[
name|n
index|]
argument_list|)
condition|)
name|thread_pc
index|[
name|n
index|]
operator|=
name|read_pc
argument_list|()
operator|-
literal|2
expr_stmt|;
else|else
name|thread_pc
index|[
name|n
index|]
operator|=
name|read_pc
argument_list|()
expr_stmt|;
name|write_register
argument_list|(
name|PC_REGNUM
argument_list|,
name|thread_pc
index|[
name|n
index|]
argument_list|)
expr_stmt|;
block|}
name|printf_filtered
argument_list|(
literal|"thread %d received signal %d, %s\n"
argument_list|,
name|n
argument_list|,
name|thread_signal
index|[
name|n
index|]
argument_list|,
name|safe_strsignal
argument_list|(
name|thread_signal
index|[
name|n
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Select an interesting thread -- also-rans died with SIGKILL, 	 so find one that didn't.  */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|n_threads
condition|;
name|n
operator|++
control|)
if|if
condition|(
name|thread_signal
index|[
name|n
index|]
operator|!=
literal|0
operator|&&
name|thread_signal
index|[
name|n
index|]
operator|!=
name|SIGKILL
condition|)
block|{
name|select_thread
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|stop_signal
operator|=
name|thread_signal
index|[
name|n
index|]
expr_stmt|;
name|stop_sigcode
operator|=
name|thread_sigcode
index|[
name|n
index|]
expr_stmt|;
break|break;
block|}
name|core_aouthdr
operator|.
name|a_magic
operator|=
literal|0
expr_stmt|;
name|flush_cached_frames
argument_list|()
expr_stmt|;
name|set_current_frame
argument_list|(
name|create_new_frame
argument_list|(
name|read_register
argument_list|(
name|FP_REGNUM
argument_list|)
argument_list|,
name|read_pc
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|select_frame
argument_list|(
name|get_current_frame
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|validate_files
argument_list|()
expr_stmt|;
name|print_stack_frame
argument_list|(
name|selected_frame
argument_list|,
name|selected_frame_level
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|from_tty
condition|)
name|printf_filtered
argument_list|(
literal|"No core file now.\n"
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

