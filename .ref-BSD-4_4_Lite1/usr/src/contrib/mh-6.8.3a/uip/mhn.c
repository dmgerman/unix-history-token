begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* mhn.c - multi-media MH */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|ident
index|[]
init|=
literal|"@(#)$Id: mhn.c,v 2.35 1993/10/26 22:17:44 jromine Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* lint */
end_comment

begin_include
include|#
directive|include
file|"../h/mh.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"../zotnet/mts.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|BSD42
end_ifdef

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|LOCALE
end_ifdef

begin_include
include|#
directive|include
file|<locale.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*
comment|*/
end_comment

begin_decl_stmt
specifier|static
name|struct
name|swit
name|switches
index|[]
init|=
block|{
define|#
directive|define
name|AUTOSW
value|0
literal|"auto"
block|,
literal|0
block|,
define|#
directive|define
name|NAUTOSW
value|1
literal|"noauto"
block|,
literal|0
block|,
define|#
directive|define
name|CACHESW
value|2
literal|"cache"
block|,
literal|0
block|,
define|#
directive|define
name|NCACHESW
value|3
literal|"nocache"
block|,
literal|0
block|,
define|#
directive|define
name|CHECKSW
value|4
literal|"check"
block|,
literal|0
block|,
define|#
directive|define
name|NCHECKSW
value|5
literal|"nocheck"
block|,
literal|0
block|,
define|#
directive|define
name|DEBUGSW
value|6
literal|"debug"
block|,
operator|-
literal|5
block|,
define|#
directive|define
name|EBCDICSW
value|7
literal|"ebcdicsafe"
block|,
literal|0
block|,
define|#
directive|define
name|NEBCDICSW
value|8
literal|"noebcdicsafe"
block|,
literal|0
block|,
define|#
directive|define
name|FILESW
value|9
comment|/* interface from show */
literal|"file file"
block|,
literal|0
block|,
define|#
directive|define
name|FORMSW
value|10
literal|"form formfile"
block|,
literal|4
block|,
define|#
directive|define
name|HEADSW
value|11
literal|"headers"
block|,
literal|0
block|,
define|#
directive|define
name|NHEADSW
value|12
literal|"noheaders"
block|,
literal|0
block|,
define|#
directive|define
name|LISTSW
value|13
literal|"list"
block|,
literal|0
block|,
define|#
directive|define
name|NLISTSW
value|14
literal|"nolist"
block|,
literal|0
block|,
define|#
directive|define
name|PARTSW
value|15
literal|"part number"
block|,
literal|0
block|,
define|#
directive|define
name|PAUSESW
value|16
literal|"pause"
block|,
literal|0
block|,
define|#
directive|define
name|NPAUSESW
value|17
literal|"nopause"
block|,
literal|0
block|,
define|#
directive|define
name|RCACHESW
value|18
literal|"rcache policy"
block|,
literal|0
block|,
define|#
directive|define
name|SIZESW
value|19
literal|"realsize"
block|,
literal|0
block|,
define|#
directive|define
name|NSIZESW
value|20
literal|"norealsize"
block|,
literal|0
block|,
define|#
directive|define
name|RFC934SW
value|21
literal|"rfc934mode"
block|,
literal|0
block|,
define|#
directive|define
name|NRFC934SW
value|22
literal|"norfc934mode"
block|,
literal|0
block|,
define|#
directive|define
name|SERIALSW
value|23
literal|"serialonly"
block|,
literal|0
block|,
define|#
directive|define
name|NSERIALSW
value|24
literal|"noserialonly"
block|,
literal|0
block|,
define|#
directive|define
name|SHOWSW
value|25
literal|"show"
block|,
literal|0
block|,
define|#
directive|define
name|NSHOWSW
value|26
literal|"noshow"
block|,
literal|0
block|,
define|#
directive|define
name|STORESW
value|27
literal|"store"
block|,
literal|0
block|,
define|#
directive|define
name|NSTORESW
value|28
literal|"nostore"
block|,
literal|0
block|,
define|#
directive|define
name|TYPESW
value|29
literal|"type content"
block|,
literal|0
block|,
define|#
directive|define
name|VERBSW
value|30
literal|"verbose"
block|,
literal|0
block|,
define|#
directive|define
name|NVERBSW
value|31
literal|"noverbose"
block|,
literal|0
block|,
define|#
directive|define
name|WCACHESW
value|32
literal|"wcache policy"
block|,
literal|0
block|,
define|#
directive|define
name|HELPSW
value|33
literal|"help"
block|,
literal|4
block|,
define|#
directive|define
name|PROGSW
value|34
literal|"moreproc program"
block|,
operator|-
literal|4
block|,
define|#
directive|define
name|NPROGSW
value|35
literal|"nomoreproc"
block|,
operator|-
literal|3
block|,
define|#
directive|define
name|LENSW
value|36
literal|"length lines"
block|,
operator|-
literal|4
block|,
define|#
directive|define
name|WIDSW
value|37
literal|"width columns"
block|,
operator|-
literal|4
block|,
define|#
directive|define
name|VIAMSW
value|38
literal|"viamail mailpath"
block|,
operator|-
literal|7
block|,
define|#
directive|define
name|VIASSW
value|39
literal|"viasubj subject"
block|,
operator|-
literal|7
block|,
define|#
directive|define
name|VIAPSW
value|40
literal|"viaparm arguments"
block|,
operator|-
literal|7
block|,
define|#
directive|define
name|VIADSW
value|41
literal|"viadesc text"
block|,
operator|-
literal|7
block|,
define|#
directive|define
name|VIACSW
value|42
literal|"viacmnt text"
block|,
operator|-
literal|7
block|,
define|#
directive|define
name|VIAZSW
value|43
literal|"viadelay seconds"
block|,
operator|-
literal|8
block|,
define|#
directive|define
name|VIAFSW
value|44
literal|"viafrom mailpath"
block|,
operator|-
literal|7
block|,
name|NULL
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*
comment|*/
end_comment

begin_define
define|#
directive|define
name|NPARTS
value|50
end_define

begin_define
define|#
directive|define
name|NTYPES
value|20
end_define

begin_decl_stmt
specifier|static
name|struct
name|swit
name|caches
index|[]
init|=
block|{
define|#
directive|define
name|CACHE_NEVER
value|0
literal|"never"
block|,
literal|0
block|,
define|#
directive|define
name|CACHE_PRIVATE
value|1
literal|"private"
block|,
literal|0
block|,
define|#
directive|define
name|CACHE_PUBLIC
value|2
literal|"public"
block|,
literal|0
block|,
define|#
directive|define
name|CACHE_ASK
value|3
literal|"ask"
block|,
literal|0
block|,
name|NULL
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|autosw
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|cachesw
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|checksw
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|debugsw
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ebcdicsw
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|formsw
init|=
name|NULLCP
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|headsw
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|listsw
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nolist
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nomore
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|npart
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|parts
index|[
name|NPARTS
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pausesw
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|progsw
init|=
name|NULLCP
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|rcachesw
init|=
name|CACHE_ASK
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|rfc934sw
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|serialsw
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|showsw
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sizesw
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|storesw
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ntype
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|types
index|[
name|NTYPES
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|verbosw
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|wcachesw
init|=
name|CACHE_ASK
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|endian
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|mm_charset
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|xpid
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|userrs
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|cache_public
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|cache_private
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|cwdlen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|cwd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|dir
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|errs
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|tmp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|BSD44
end_ifndef

begin_decl_stmt
specifier|extern
name|int
name|sys_nerr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|sys_errlist
index|[]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
name|off_t
name|lseek
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|time_t
name|time
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*
comment|*/
end_comment

begin_define
define|#
directive|define
name|LSTFMT1
value|"%4s %-5s %-24s %5s %-36s\n"
end_define

begin_define
define|#
directive|define
name|LSTFMT2a
value|"%4d "
end_define

begin_define
define|#
directive|define
name|LSTFMT2b
value|"%-5s %-24.24s "
end_define

begin_define
define|#
directive|define
name|LSTFMT2c1
value|"%5lu"
end_define

begin_define
define|#
directive|define
name|LSTFMT2c2
value|"%4lu%c"
end_define

begin_define
define|#
directive|define
name|LSTFMT2c3
value|"huge "
end_define

begin_define
define|#
directive|define
name|LSTFMT2c4
value|"     "
end_define

begin_define
define|#
directive|define
name|LSTFMT2d1
value|" %-36.36s"
end_define

begin_define
define|#
directive|define
name|LSTFMT2d2
value|"\t     %-65.65s\n"
end_define

begin_function_decl
specifier|static
name|void
name|build_comp
parameter_list|()
function_decl|;
end_function_decl

begin_typedef
typedef|typedef
struct|struct
name|CTinfo
block|{
name|char
modifier|*
name|ci_type
decl_stmt|;
name|char
modifier|*
name|ci_subtype
decl_stmt|;
define|#
directive|define
name|NPARMS
value|10
name|char
modifier|*
name|ci_attrs
index|[
name|NPARMS
operator|+
literal|2
index|]
decl_stmt|;
name|char
modifier|*
name|ci_values
index|[
name|NPARMS
index|]
decl_stmt|;
name|char
modifier|*
name|ci_comment
decl_stmt|;
name|char
modifier|*
name|ci_magic
decl_stmt|;
block|}
name|CTInfo
operator|,
typedef|*
name|CI
typedef|;
end_typedef

begin_define
define|#
directive|define
name|NULLCI
value|((CI) 0)
end_define

begin_function_decl
specifier|static
name|int
name|get_ctinfo
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|get_comment
parameter_list|()
function_decl|;
end_function_decl

begin_typedef
typedef|typedef
struct|struct
name|Content
block|{
name|char
modifier|*
name|c_partno
decl_stmt|;
comment|/* within multipart content */
name|char
modifier|*
name|c_vrsn
decl_stmt|;
comment|/* Body-Version: */
name|char
modifier|*
name|c_ctline
decl_stmt|;
comment|/* Content-Type: */
name|CTInfo
name|c_ctinfo
decl_stmt|;
name|int
name|c_type
decl_stmt|;
comment|/* internal form */
define|#
directive|define
name|CT_UNKNOWN
value|0x00
define|#
directive|define
name|CT_APPLICATION
value|0x01
define|#
directive|define
name|CT_AUDIO
value|0x02
define|#
directive|define
name|CT_IMAGE
value|0x03
define|#
directive|define
name|CT_MESSAGE
value|0x04
define|#
directive|define
name|CT_MULTIPART
value|0x05
define|#
directive|define
name|CT_TEXT
value|0x06
define|#
directive|define
name|CT_VIDEO
value|0x07
define|#
directive|define
name|CT_EXTENSION
value|0x08
name|int
name|c_subtype
decl_stmt|;
comment|/* filled-in by c_ctinitfnx */
name|caddr_t
name|c_ctparams
decl_stmt|;
comment|/*   .. */
name|caddr_t
name|c_ctextern
decl_stmt|;
comment|/*   .. */
name|char
modifier|*
name|c_showproc
decl_stmt|;
comment|/* default, if not in profile */
name|char
modifier|*
name|c_termproc
decl_stmt|;
comment|/* for charset madness... */
name|char
modifier|*
name|c_storeproc
decl_stmt|;
comment|/* overrides profile entry, if any */
name|int
function_decl|(
modifier|*
name|c_ctinitfnx
function_decl|)
parameter_list|()
function_decl|;
comment|/* parse content */
name|int
function_decl|(
modifier|*
name|c_ctlistfnx
function_decl|)
parameter_list|()
function_decl|;
comment|/* list content */
name|int
function_decl|(
modifier|*
name|c_ctshowfnx
function_decl|)
parameter_list|()
function_decl|;
comment|/* show content */
name|int
function_decl|(
modifier|*
name|c_ctstorefnx
function_decl|)
parameter_list|()
function_decl|;
comment|/* store content */
name|int
function_decl|(
modifier|*
name|c_ctfreefnx
function_decl|)
parameter_list|()
function_decl|;
comment|/* free content-specific structures */
name|char
modifier|*
name|c_celine
decl_stmt|;
comment|/* Content-Transfer-Encoding: */
name|int
name|c_encoding
decl_stmt|;
comment|/* internal form */
define|#
directive|define
name|CE_UNKNOWN
value|0x00
define|#
directive|define
name|CE_BASE64
value|0x01
define|#
directive|define
name|CE_QUOTED
value|0x02
define|#
directive|define
name|CE_8BIT
value|0x03
define|#
directive|define
name|CE_7BIT
value|0x04
define|#
directive|define
name|CE_BINARY
value|0x05
define|#
directive|define
name|CE_EXTENSION
value|0x06
define|#
directive|define
name|CE_EXTERNAL
value|0x07
comment|/* for external-body */
name|caddr_t
name|c_ceparams
decl_stmt|;
comment|/* filled-in by encoding initfnx */
name|int
function_decl|(
modifier|*
name|c_ceopenfnx
function_decl|)
parameter_list|()
function_decl|;
comment|/* get a stream to decoded contents */
name|int
function_decl|(
modifier|*
name|c_ceclosefnx
function_decl|)
parameter_list|()
function_decl|;
comment|/* release stream */
name|int
function_decl|(
modifier|*
name|c_celistfnx
function_decl|)
parameter_list|()
function_decl|;
comment|/* list decoding info */
name|unsigned
name|long
function_decl|(
modifier|*
name|c_cesizefnx
function_decl|)
parameter_list|()
function_decl|;
comment|/* size of decoded contents */
name|int
function_decl|(
modifier|*
name|c_cefreefnx
function_decl|)
parameter_list|()
function_decl|;
comment|/* free encoding-specific structures */
name|char
modifier|*
name|c_id
decl_stmt|;
comment|/* Content-ID: */
name|char
modifier|*
name|c_descr
decl_stmt|;
comment|/* Content-Description: */
name|int
name|c_digested
decl_stmt|;
comment|/* Content-MD5: */
name|unsigned
name|char
name|c_digest
index|[
literal|16
index|]
decl_stmt|;
comment|/*   .. */
name|FILE
modifier|*
name|c_fp
decl_stmt|;
comment|/* read contents (stream) */
name|char
modifier|*
name|c_file
decl_stmt|;
comment|/* read contents (file) */
name|int
name|c_unlink
decl_stmt|;
comment|/* remove file when done? */
name|int
name|c_umask
decl_stmt|;
comment|/* associated umask */
name|long
name|c_begin
decl_stmt|;
comment|/* where content starts in file */
name|long
name|c_end
decl_stmt|;
comment|/*   ..		 ends           */
name|int
name|c_pid
decl_stmt|;
comment|/* process doing display */
name|char
modifier|*
name|c_storage
decl_stmt|;
comment|/* write contents (file) */
name|int
name|c_rfc934
decl_stmt|;
comment|/* rfc934 compatibility */
block|}
name|Content
operator|,
typedef|*
name|CT
typedef|;
end_typedef

begin_define
define|#
directive|define
name|NULLCT
value|((CT) 0)
end_define

begin_function_decl
specifier|static
name|CT
name|get_content
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|int
name|list_content
argument_list|()
decl_stmt|,
name|show_content
argument_list|()
decl_stmt|,
name|store_content
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|cache_content
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|int
name|user_content
argument_list|()
decl_stmt|,
name|compose_content
argument_list|()
decl_stmt|,
name|output_content
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|free_content
argument_list|()
decl_stmt|,
name|flush_errors
argument_list|()
decl_stmt|,
name|set_id
argument_list|()
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__STDC__
argument_list|)
operator|&&
name|defined
argument_list|(
name|VSPRINTF
argument_list|)
end_if

begin_function_decl
specifier|static
name|void
name|content_error
parameter_list|(
name|char
modifier|*
parameter_list|,
specifier|register
name|CT
parameter_list|,
name|char
modifier|*
parameter_list|,
modifier|...
parameter_list|)
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_function_decl
specifier|static
name|void
name|content_error
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|init_encoding
argument_list|()
decl_stmt|,
name|type_ok
argument_list|()
decl_stmt|,
name|copy_some_headers
argument_list|()
decl_stmt|,
name|set_endian
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|make_intermediates
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|int
name|find_cache
argument_list|()
decl_stmt|,
name|find_cache_aux
argument_list|()
decl_stmt|,
name|find_cache_aux2
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|write7Bit
argument_list|()
decl_stmt|,
name|writeQuoted
argument_list|()
decl_stmt|,
name|writeBase64
argument_list|()
decl_stmt|,
name|writeBase64aux
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|writeDigest
argument_list|()
decl_stmt|,
name|readDigest
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|via_mail
argument_list|()
decl_stmt|,
name|via_post
argument_list|()
decl_stmt|,
name|pidcheck
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|CT
modifier|*
name|cts
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|quitser
value|pipeser
end_define

begin_function_decl
specifier|static
name|TYPESIG
name|pipeser
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|fgetstr
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*
comment|*/
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|f6
init|=
literal|0
decl_stmt|,
name|msgp
init|=
literal|0
decl_stmt|,
name|msgnum
decl_stmt|,
modifier|*
name|icachesw
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|f1
init|=
name|NULL
decl_stmt|,
modifier|*
name|f2
init|=
name|NULL
decl_stmt|,
modifier|*
name|f3
init|=
name|NULL
decl_stmt|,
modifier|*
name|f4
init|=
name|NULL
decl_stmt|,
modifier|*
name|f5
init|=
name|NULL
decl_stmt|,
modifier|*
name|f7
init|=
name|NULL
decl_stmt|,
modifier|*
name|file
init|=
name|NULL
decl_stmt|,
modifier|*
name|folder
init|=
name|NULL
decl_stmt|,
modifier|*
name|maildir
decl_stmt|,
name|buf
index|[
literal|100
index|]
decl_stmt|,
modifier|*
modifier|*
name|ap
decl_stmt|,
modifier|*
modifier|*
name|argp
decl_stmt|,
modifier|*
name|arguments
index|[
name|MAXARGS
index|]
decl_stmt|,
modifier|*
name|msgs
index|[
name|MAXARGS
index|]
decl_stmt|;
name|struct
name|msgs
modifier|*
name|mp
decl_stmt|;
specifier|register
name|CT
name|ct
decl_stmt|,
modifier|*
name|ctp
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
ifdef|#
directive|ifdef
name|LOCALE
name|setlocale
argument_list|(
name|LC_ALL
argument_list|,
literal|""
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|invo_name
operator|=
name|r1bindex
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|argv
index|[
literal|1
index|]
operator|&&
name|uprf
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"-via"
argument_list|)
condition|)
name|m_foil
argument_list|(
name|NULLCP
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|m_find
argument_list|(
name|invo_name
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|ap
operator|=
name|brkstring
argument_list|(
name|cp
operator|=
name|getcpy
argument_list|(
name|cp
argument_list|)
argument_list|,
literal|" "
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|ap
operator|=
name|copyip
argument_list|(
name|ap
argument_list|,
name|arguments
argument_list|)
expr_stmt|;
block|}
else|else
name|ap
operator|=
name|arguments
expr_stmt|;
operator|(
name|void
operator|)
name|copyip
argument_list|(
name|argv
operator|+
literal|1
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|argp
operator|=
name|arguments
expr_stmt|;
comment|/*
comment|*/
while|while
condition|(
name|cp
operator|=
operator|*
name|argp
operator|++
condition|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|'-'
condition|)
switch|switch
condition|(
name|smatch
argument_list|(
operator|++
name|cp
argument_list|,
name|switches
argument_list|)
condition|)
block|{
case|case
name|AMBIGSW
case|:
name|ambigsw
argument_list|(
name|cp
argument_list|,
name|switches
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
case|case
name|UNKWNSW
case|:
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"-%s unknown"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
case|case
name|HELPSW
case|:
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s [+folder] [msgs] [switches]"
argument_list|,
name|invo_name
argument_list|)
expr_stmt|;
name|help
argument_list|(
name|buf
argument_list|,
name|switches
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
case|case
name|AUTOSW
case|:
name|autosw
operator|++
expr_stmt|;
continue|continue;
case|case
name|NAUTOSW
case|:
name|autosw
operator|=
literal|0
expr_stmt|;
continue|continue;
case|case
name|CACHESW
case|:
name|cachesw
operator|++
expr_stmt|;
continue|continue;
case|case
name|NCACHESW
case|:
name|cachesw
operator|=
literal|0
expr_stmt|;
continue|continue;
case|case
name|RCACHESW
case|:
name|icachesw
operator|=
operator|&
name|rcachesw
expr_stmt|;
goto|goto
name|do_cache
goto|;
case|case
name|WCACHESW
case|:
name|icachesw
operator|=
operator|&
name|wcachesw
expr_stmt|;
name|do_cache
label|:
empty_stmt|;
if|if
condition|(
operator|!
operator|(
name|cp
operator|=
operator|*
name|argp
operator|++
operator|)
operator|||
operator|*
name|cp
operator|==
literal|'-'
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"missing argument to %s"
argument_list|,
name|argp
index|[
operator|-
literal|2
index|]
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|*
name|icachesw
operator|=
name|smatch
argument_list|(
name|cp
argument_list|,
name|caches
argument_list|)
condition|)
block|{
case|case
name|AMBIGSW
case|:
name|ambigsw
argument_list|(
name|cp
argument_list|,
name|caches
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
case|case
name|UNKWNSW
case|:
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"%s unknown"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
default|default:
break|break;
block|}
continue|continue;
case|case
name|CHECKSW
case|:
name|checksw
operator|++
expr_stmt|;
continue|continue;
case|case
name|NCHECKSW
case|:
name|checksw
operator|=
literal|0
expr_stmt|;
continue|continue;
case|case
name|DEBUGSW
case|:
name|debugsw
operator|++
expr_stmt|;
continue|continue;
case|case
name|EBCDICSW
case|:
name|ebcdicsw
operator|++
expr_stmt|;
continue|continue;
case|case
name|NEBCDICSW
case|:
name|ebcdicsw
operator|=
literal|0
expr_stmt|;
continue|continue;
case|case
name|FORMSW
case|:
if|if
condition|(
operator|!
operator|(
name|cp
operator|=
operator|*
name|argp
operator|++
operator|)
operator|||
operator|*
name|cp
operator|==
literal|'-'
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"missing argument to %s"
argument_list|,
name|argp
index|[
operator|-
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|formsw
condition|)
name|free
argument_list|(
name|formsw
argument_list|)
expr_stmt|;
name|formsw
operator|=
name|getcpy
argument_list|(
name|libpath
argument_list|(
name|cp
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|HEADSW
case|:
name|headsw
operator|++
expr_stmt|;
continue|continue;
case|case
name|NHEADSW
case|:
name|headsw
operator|=
literal|0
expr_stmt|;
continue|continue;
case|case
name|LISTSW
case|:
name|listsw
operator|++
expr_stmt|;
continue|continue;
case|case
name|NLISTSW
case|:
name|listsw
operator|=
literal|0
expr_stmt|;
continue|continue;
case|case
name|PARTSW
case|:
if|if
condition|(
operator|!
operator|(
name|cp
operator|=
operator|*
name|argp
operator|++
operator|)
operator|||
operator|*
name|cp
operator|==
literal|'-'
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"missing argument to %s"
argument_list|,
name|argp
index|[
operator|-
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|npart
operator|>=
name|NPARTS
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"too many parts (starting with %s), %d max"
argument_list|,
name|cp
argument_list|,
name|NPARTS
argument_list|)
expr_stmt|;
name|parts
index|[
name|npart
operator|++
index|]
operator|=
name|cp
expr_stmt|;
continue|continue;
case|case
name|PAUSESW
case|:
name|pausesw
operator|++
expr_stmt|;
continue|continue;
case|case
name|NPAUSESW
case|:
name|pausesw
operator|=
literal|0
expr_stmt|;
continue|continue;
case|case
name|RFC934SW
case|:
name|rfc934sw
operator|++
expr_stmt|;
continue|continue;
case|case
name|NRFC934SW
case|:
name|rfc934sw
operator|=
literal|0
expr_stmt|;
continue|continue;
case|case
name|SERIALSW
case|:
name|serialsw
operator|++
expr_stmt|;
continue|continue;
case|case
name|NSERIALSW
case|:
name|serialsw
operator|=
literal|0
expr_stmt|;
continue|continue;
case|case
name|SHOWSW
case|:
name|showsw
operator|++
expr_stmt|;
continue|continue;
case|case
name|NSHOWSW
case|:
name|showsw
operator|=
literal|0
expr_stmt|;
continue|continue;
case|case
name|SIZESW
case|:
name|sizesw
operator|++
expr_stmt|;
continue|continue;
case|case
name|NSIZESW
case|:
name|sizesw
operator|=
literal|0
expr_stmt|;
continue|continue;
case|case
name|STORESW
case|:
name|storesw
operator|++
expr_stmt|;
continue|continue;
case|case
name|NSTORESW
case|:
name|storesw
operator|=
literal|0
expr_stmt|;
continue|continue;
case|case
name|TYPESW
case|:
if|if
condition|(
operator|!
operator|(
name|cp
operator|=
operator|*
name|argp
operator|++
operator|)
operator|||
operator|*
name|cp
operator|==
literal|'-'
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"missing argument to %s"
argument_list|,
name|argp
index|[
operator|-
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ntype
operator|>=
name|NTYPES
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"too many types (starting with %s), %d max"
argument_list|,
name|cp
argument_list|,
name|NTYPES
argument_list|)
expr_stmt|;
name|types
index|[
name|ntype
operator|++
index|]
operator|=
name|cp
expr_stmt|;
continue|continue;
case|case
name|VERBSW
case|:
name|verbosw
operator|++
expr_stmt|;
continue|continue;
case|case
name|NVERBSW
case|:
name|verbosw
operator|=
literal|0
expr_stmt|;
continue|continue;
case|case
name|PROGSW
case|:
if|if
condition|(
operator|!
operator|(
name|progsw
operator|=
operator|*
name|argp
operator|++
operator|)
operator|||
operator|*
name|progsw
operator|==
literal|'-'
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"missing argument to %s"
argument_list|,
name|argp
index|[
operator|-
literal|2
index|]
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|NPROGSW
case|:
name|nomore
operator|++
expr_stmt|;
continue|continue;
case|case
name|LENSW
case|:
case|case
name|WIDSW
case|:
if|if
condition|(
operator|!
operator|(
name|cp
operator|=
operator|*
name|argp
operator|++
operator|)
operator|||
operator|*
name|cp
operator|==
literal|'-'
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"missing argument to %s"
argument_list|,
name|argp
index|[
operator|-
literal|2
index|]
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|FILESW
case|:
if|if
condition|(
operator|!
operator|(
name|cp
operator|=
operator|*
name|argp
operator|++
operator|)
operator|||
operator|(
operator|*
name|cp
operator|==
literal|'-'
operator|&&
name|cp
index|[
literal|1
index|]
operator|)
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"missing argument to %s"
argument_list|,
name|argp
index|[
operator|-
literal|2
index|]
argument_list|)
expr_stmt|;
name|file
operator|=
operator|*
name|cp
operator|==
literal|'-'
condition|?
name|cp
else|:
name|path
argument_list|(
name|cp
argument_list|,
name|TFILE
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|VIAMSW
case|:
if|if
condition|(
operator|!
operator|(
name|f1
operator|=
operator|*
name|argp
operator|++
operator|)
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"missing argument to %s"
argument_list|,
name|argp
index|[
operator|-
literal|2
index|]
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|VIASSW
case|:
if|if
condition|(
operator|!
operator|(
name|f2
operator|=
operator|*
name|argp
operator|++
operator|)
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"missing argument to %s"
argument_list|,
name|argp
index|[
operator|-
literal|2
index|]
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|VIAPSW
case|:
if|if
condition|(
operator|!
operator|(
name|f3
operator|=
operator|*
name|argp
operator|++
operator|)
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"missing argument to %s"
argument_list|,
name|argp
index|[
operator|-
literal|2
index|]
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|VIADSW
case|:
if|if
condition|(
operator|!
operator|(
name|f4
operator|=
operator|*
name|argp
operator|++
operator|)
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"missing argument to %s"
argument_list|,
name|argp
index|[
operator|-
literal|2
index|]
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|VIACSW
case|:
if|if
condition|(
operator|!
operator|(
name|f5
operator|=
operator|*
name|argp
operator|++
operator|)
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"missing argument to %s"
argument_list|,
name|argp
index|[
operator|-
literal|2
index|]
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|VIAZSW
case|:
if|if
condition|(
operator|!
operator|(
name|cp
operator|=
operator|*
name|argp
operator|++
operator|)
operator|||
operator|*
name|cp
operator|==
literal|'-'
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"missing argument to %s"
argument_list|,
name|argp
index|[
operator|-
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|sscanf
argument_list|(
name|cp
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|f6
argument_list|)
operator|!=
literal|1
operator|||
name|f6
operator|<
literal|0
condition|)
name|f6
operator|=
literal|300
expr_stmt|;
continue|continue;
case|case
name|VIAFSW
case|:
if|if
condition|(
operator|!
operator|(
name|f7
operator|=
operator|*
name|argp
operator|++
operator|)
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"missing argument to %s"
argument_list|,
name|argp
index|[
operator|-
literal|2
index|]
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|*
name|cp
operator|==
literal|'+'
operator|||
operator|*
name|cp
operator|==
literal|'@'
condition|)
block|{
if|if
condition|(
name|folder
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"only one folder at a time!"
argument_list|)
expr_stmt|;
else|else
name|folder
operator|=
name|path
argument_list|(
name|cp
operator|+
literal|1
argument_list|,
operator|*
name|cp
operator|==
literal|'+'
condition|?
name|TFOLDER
else|:
name|TSUBCWF
argument_list|)
expr_stmt|;
block|}
else|else
name|msgs
index|[
name|msgp
operator|++
index|]
operator|=
name|cp
expr_stmt|;
block|}
name|parts
index|[
name|npart
index|]
operator|=
name|NULL
operator|,
name|types
index|[
name|ntype
index|]
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|formsw
condition|)
name|formsw
operator|=
name|getcpy
argument_list|(
name|libpath
argument_list|(
literal|"mhl.headers"
argument_list|)
argument_list|)
expr_stmt|;
name|set_endian
argument_list|()
expr_stmt|;
comment|/*
comment|*/
if|if
condition|(
name|f1
condition|)
block|{
name|via_mail
argument_list|(
name|f1
argument_list|,
name|f2
argument_list|,
name|f3
argument_list|,
name|f4
argument_list|,
name|f5
argument_list|,
name|f6
argument_list|,
name|f7
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
elseif|else
if|if
condition|(
name|f2
operator|||
name|f3
operator|||
name|f4
operator|||
name|f5
operator|||
name|f6
operator|||
name|f7
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"missing -viamail \"mailpath\" switch"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|=
name|getenv
argument_list|(
literal|"MHN"
argument_list|)
condition|)
block|{
if|if
condition|(
name|fp
operator|=
name|fopen
argument_list|(
name|cp
argument_list|,
literal|"r"
argument_list|)
condition|)
block|{
name|m_readefs
argument_list|(
operator|(
expr|struct
name|node
operator|*
operator|*
operator|)
literal|0
argument_list|,
name|fp
argument_list|,
name|cp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
else|else
name|admonish
argument_list|(
literal|""
argument_list|,
literal|"unable to read $MHN profile (%s)"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fp
operator|=
name|fopen
argument_list|(
name|cp
operator|=
name|libpath
argument_list|(
literal|"mhn_defaults"
argument_list|)
argument_list|,
literal|"r"
argument_list|)
condition|)
block|{
name|m_readefs
argument_list|(
operator|(
expr|struct
name|node
operator|*
operator|*
operator|)
literal|0
argument_list|,
name|fp
argument_list|,
name|cp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s-cache"
argument_list|,
name|invo_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cache_public
operator|=
name|m_find
argument_list|(
name|buf
argument_list|)
operator|)
operator|&&
operator|*
name|cache_public
operator|!=
literal|'/'
condition|)
name|cache_public
operator|=
name|NULL
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s-private-cache"
argument_list|,
name|invo_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|cache_private
operator|=
name|m_find
argument_list|(
name|buf
argument_list|)
operator|)
condition|)
name|cache_private
operator|=
literal|".cache"
expr_stmt|;
name|cache_private
operator|=
name|getcpy
argument_list|(
name|m_maildir
argument_list|(
name|cache_private
argument_list|)
argument_list|)
expr_stmt|;
name|cwdlen
operator|=
name|strlen
argument_list|(
name|cwd
operator|=
name|getcpy
argument_list|(
name|pwd
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s-storage"
argument_list|,
name|invo_name
argument_list|)
expr_stmt|;
name|dir
operator|=
name|getcpy
argument_list|(
operator|(
name|cp
operator|=
name|m_find
argument_list|(
name|buf
argument_list|)
operator|)
operator|&&
operator|*
name|cp
condition|?
name|cp
else|:
name|cwd
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|cp
operator|&&
operator|*
name|cp
condition|?
name|concat
argument_list|(
name|cp
argument_list|,
literal|"/"
argument_list|,
name|invo_name
argument_list|,
name|NULLCP
argument_list|)
else|:
name|add
argument_list|(
name|m_maildir
argument_list|(
name|invo_name
argument_list|)
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m_find
argument_list|(
literal|"path"
argument_list|)
condition|)
name|free
argument_list|(
name|path
argument_list|(
literal|"./"
argument_list|,
name|TFOLDER
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|msgp
operator|==
literal|1
operator|&&
operator|!
name|folder
operator|&&
operator|!
name|npart
operator|&&
operator|!
name|cachesw
operator|&&
operator|!
name|showsw
operator|&&
operator|!
name|storesw
operator|&&
operator|!
name|ntype
operator|&&
operator|!
name|file
operator|&&
operator|(
name|cp
operator|=
name|getenv
argument_list|(
literal|"mhdraft"
argument_list|)
operator|)
operator|&&
name|strcmp
argument_list|(
name|cp
argument_list|,
name|msgs
index|[
literal|0
index|]
argument_list|)
operator|==
literal|0
condition|)
block|{
name|build_comp
argument_list|(
name|cp
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
if|if
condition|(
name|file
condition|)
block|{
name|int
name|stdinP
decl_stmt|;
if|if
condition|(
name|msgp
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"only one file at a time!"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cts
operator|=
operator|(
name|CT
operator|*
operator|)
name|calloc
argument_list|(
operator|(
name|unsigned
operator|)
literal|2
argument_list|,
sizeof|sizeof
expr|*
name|cts
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
name|ctp
operator|=
name|cts
expr_stmt|;
if|if
condition|(
name|stdinP
operator|=
operator|(
name|strcmp
argument_list|(
name|file
argument_list|,
literal|"-"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|file
operator|=
name|add
argument_list|(
name|m_tmpfil
argument_list|(
name|invo_name
argument_list|)
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|file
argument_list|,
literal|"w+"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|adios
argument_list|(
name|file
argument_list|,
literal|"unable to fopen for writing and reading"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|chmod
argument_list|(
name|file
argument_list|,
literal|0600
argument_list|)
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
name|buffer
argument_list|,
name|stdin
argument_list|)
condition|)
operator|(
name|void
operator|)
name|fputs
argument_list|(
name|buffer
argument_list|,
name|fp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|stdin
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|adios
argument_list|(
literal|"stdin"
argument_list|,
literal|"error reading"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ferror
argument_list|(
name|fp
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|adios
argument_list|(
name|file
argument_list|,
literal|"error writing"
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fseek
argument_list|(
name|fp
argument_list|,
literal|0L
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|file
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|adios
argument_list|(
name|file
argument_list|,
literal|"unable to read"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ct
operator|=
name|get_content
argument_list|(
name|fp
argument_list|,
name|file
argument_list|,
literal|1
argument_list|)
condition|)
block|{
if|if
condition|(
name|stdinP
condition|)
name|ct
operator|->
name|c_unlink
operator|=
literal|1
expr_stmt|;
name|ct
operator|->
name|c_fp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ct
operator|->
name|c_end
operator|==
literal|0L
condition|)
block|{
operator|(
name|void
operator|)
name|fseek
argument_list|(
name|fp
argument_list|,
literal|0L
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|ct
operator|->
name|c_end
operator|=
name|ftell
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ct
operator|->
name|c_ctinitfnx
operator|&&
call|(
modifier|*
name|ct
operator|->
name|c_ctinitfnx
call|)
argument_list|(
name|ct
argument_list|)
operator|==
name|NOTOK
condition|)
name|free_content
argument_list|(
name|ct
argument_list|)
expr_stmt|;
else|else
operator|*
name|ctp
operator|++
operator|=
name|ct
expr_stmt|;
block|}
else|else
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"unable to decode %s"
argument_list|,
name|file
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|mp
operator|=
name|NULL
expr_stmt|;
goto|goto
name|go_to_it
goto|;
block|}
if|if
condition|(
operator|!
name|msgp
condition|)
name|msgs
index|[
name|msgp
operator|++
index|]
operator|=
literal|"cur"
expr_stmt|;
if|if
condition|(
operator|!
name|folder
condition|)
name|folder
operator|=
name|m_getfolder
argument_list|()
expr_stmt|;
name|maildir
operator|=
name|m_maildir
argument_list|(
name|folder
argument_list|)
expr_stmt|;
if|if
condition|(
name|chdir
argument_list|(
name|maildir
argument_list|)
operator|==
name|NOTOK
condition|)
name|adios
argument_list|(
name|maildir
argument_list|,
literal|"unable to change directory to"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|mp
operator|=
name|m_gmsg
argument_list|(
name|folder
argument_list|)
operator|)
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"unable to read folder %s"
argument_list|,
name|folder
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|hghmsg
operator|==
literal|0
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"no messages in %s"
argument_list|,
name|folder
argument_list|)
expr_stmt|;
for|for
control|(
name|msgnum
operator|=
literal|0
init|;
name|msgnum
operator|<
name|msgp
condition|;
name|msgnum
operator|++
control|)
if|if
condition|(
operator|!
name|m_convert
argument_list|(
name|mp
argument_list|,
name|msgs
index|[
name|msgnum
index|]
argument_list|)
condition|)
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|m_setseq
argument_list|(
name|mp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cts
operator|=
operator|(
name|CT
operator|*
operator|)
name|calloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|mp
operator|->
name|numsel
operator|+
literal|1
argument_list|)
argument_list|,
sizeof|sizeof
expr|*
name|cts
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
name|ctp
operator|=
name|cts
expr_stmt|;
for|for
control|(
name|msgnum
operator|=
name|mp
operator|->
name|lowsel
init|;
name|msgnum
operator|<=
name|mp
operator|->
name|hghsel
condition|;
name|msgnum
operator|++
control|)
if|if
condition|(
name|mp
operator|->
name|msgstats
index|[
name|msgnum
index|]
operator|&
name|SELECTED
condition|)
block|{
name|char
modifier|*
name|msgnam
decl_stmt|;
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|msgnam
operator|=
name|m_name
argument_list|(
name|msgnum
argument_list|)
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|adios
argument_list|(
name|msgnam
argument_list|,
literal|"unable to read message"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ct
operator|=
name|get_content
argument_list|(
name|fp
argument_list|,
name|msgnam
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|ct
operator|->
name|c_fp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ct
operator|->
name|c_end
operator|==
literal|0L
condition|)
block|{
operator|(
name|void
operator|)
name|fseek
argument_list|(
name|fp
argument_list|,
literal|0L
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|ct
operator|->
name|c_end
operator|=
name|ftell
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ct
operator|->
name|c_ctinitfnx
operator|&&
call|(
modifier|*
name|ct
operator|->
name|c_ctinitfnx
call|)
argument_list|(
name|ct
argument_list|)
operator|==
name|NOTOK
condition|)
name|free_content
argument_list|(
name|ct
argument_list|)
expr_stmt|;
else|else
operator|*
name|ctp
operator|++
operator|=
name|ct
expr_stmt|;
block|}
else|else
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"unable to decode message %s"
argument_list|,
name|msgnam
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
name|go_to_it
label|:
empty_stmt|;
if|if
condition|(
operator|!
operator|*
name|cts
condition|)
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|listsw
operator|&&
operator|!
name|showsw
operator|&&
operator|!
name|storesw
operator|&&
operator|!
name|cachesw
condition|)
name|showsw
operator|++
expr_stmt|;
comment|/* listsw&& showsw		-> user wants per-message listing, 				   so delay until showsw processing&& storesw&& sizesw	-> evaluating size will cause more work, 				   so delay until after storesw processing  */
name|userrs
operator|=
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|quitser
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGPIPE
argument_list|,
name|pipeser
argument_list|)
expr_stmt|;
for|for
control|(
name|ctp
operator|=
name|cts
init|;
name|ct
operator|=
operator|*
name|ctp
condition|;
name|ctp
operator|++
control|)
if|if
condition|(
name|type_ok
argument_list|(
name|ct
argument_list|,
literal|1
argument_list|)
operator|&&
operator|(
name|ct
operator|->
name|c_ctlistfnx
operator|||
name|ct
operator|->
name|c_ctstorefnx
operator|||
name|ct
operator|->
name|c_ctshowfnx
operator|)
condition|)
block|{
name|struct
name|stat
name|st
decl_stmt|;
if|if
condition|(
operator|!
name|ct
operator|->
name|c_umask
condition|)
name|ct
operator|->
name|c_umask
operator|=
operator|~
operator|(
name|stat
argument_list|(
name|ct
operator|->
name|c_file
argument_list|,
operator|&
name|st
argument_list|)
operator|!=
name|NOTOK
condition|?
operator|(
name|st
operator|.
name|st_mode
operator|&
literal|0777
operator|)
else|:
name|m_gmprot
argument_list|()
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|listsw
operator|&&
operator|!
name|showsw
operator|&&
operator|(
operator|!
name|storesw
operator|||
operator|!
name|sizesw
operator|)
condition|)
block|{
if|if
condition|(
name|headsw
condition|)
name|printf
argument_list|(
name|LSTFMT1
argument_list|,
literal|"msg"
argument_list|,
literal|"part"
argument_list|,
literal|"type/subtype"
argument_list|,
literal|"size"
argument_list|,
literal|"description"
argument_list|)
expr_stmt|;
for|for
control|(
name|ctp
operator|=
name|cts
init|;
name|ct
operator|=
operator|*
name|ctp
condition|;
name|ctp
operator|++
control|)
if|if
condition|(
name|type_ok
argument_list|(
name|ct
argument_list|,
literal|1
argument_list|)
operator|&&
name|ct
operator|->
name|c_ctlistfnx
condition|)
block|{
operator|(
name|void
operator|)
name|umask
argument_list|(
name|ct
operator|->
name|c_umask
argument_list|)
expr_stmt|;
call|(
name|void
call|)
argument_list|(
operator|*
name|ct
operator|->
name|c_ctlistfnx
argument_list|)
argument_list|(
name|ct
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ct
operator|->
name|c_fp
condition|)
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|ct
operator|->
name|c_fp
argument_list|)
operator|,
name|ct
operator|->
name|c_fp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ct
operator|->
name|c_ceclosefnx
condition|)
call|(
modifier|*
name|ct
operator|->
name|c_ceclosefnx
call|)
argument_list|(
name|ct
argument_list|)
expr_stmt|;
block|}
name|flush_errors
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|storesw
condition|)
block|{
for|for
control|(
name|ctp
operator|=
name|cts
init|;
name|ct
operator|=
operator|*
name|ctp
condition|;
name|ctp
operator|++
control|)
if|if
condition|(
name|type_ok
argument_list|(
name|ct
argument_list|,
literal|1
argument_list|)
operator|&&
name|ct
operator|->
name|c_ctstorefnx
condition|)
block|{
operator|(
name|void
operator|)
name|umask
argument_list|(
name|ct
operator|->
name|c_umask
argument_list|)
expr_stmt|;
call|(
name|void
call|)
argument_list|(
operator|*
name|ct
operator|->
name|c_ctstorefnx
argument_list|)
argument_list|(
name|ct
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
if|if
condition|(
name|ct
operator|->
name|c_fp
condition|)
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|ct
operator|->
name|c_fp
argument_list|)
operator|,
name|ct
operator|->
name|c_fp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ct
operator|->
name|c_ceclosefnx
condition|)
call|(
modifier|*
name|ct
operator|->
name|c_ceclosefnx
call|)
argument_list|(
name|ct
argument_list|)
expr_stmt|;
block|}
name|flush_errors
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|cachesw
condition|)
block|{
for|for
control|(
name|ctp
operator|=
name|cts
init|;
name|ct
operator|=
operator|*
name|ctp
condition|;
name|ctp
operator|++
control|)
if|if
condition|(
name|type_ok
argument_list|(
name|ct
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|cache_content
argument_list|(
name|ct
argument_list|)
expr_stmt|;
if|if
condition|(
name|ct
operator|->
name|c_fp
condition|)
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|ct
operator|->
name|c_fp
argument_list|)
operator|,
name|ct
operator|->
name|c_fp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ct
operator|->
name|c_ceclosefnx
condition|)
call|(
modifier|*
name|ct
operator|->
name|c_ceclosefnx
call|)
argument_list|(
name|ct
argument_list|)
expr_stmt|;
block|}
name|flush_errors
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|listsw
operator|&&
operator|!
name|showsw
operator|&&
name|storesw
operator|&&
name|sizesw
condition|)
block|{
if|if
condition|(
name|headsw
condition|)
name|printf
argument_list|(
name|LSTFMT1
argument_list|,
literal|"msg"
argument_list|,
literal|"part"
argument_list|,
literal|"type/subtype"
argument_list|,
literal|"size"
argument_list|,
literal|"description"
argument_list|)
expr_stmt|;
for|for
control|(
name|ctp
operator|=
name|cts
init|;
name|ct
operator|=
operator|*
name|ctp
condition|;
name|ctp
operator|++
control|)
if|if
condition|(
name|type_ok
argument_list|(
name|ct
argument_list|,
literal|1
argument_list|)
operator|&&
name|ct
operator|->
name|c_ctlistfnx
condition|)
block|{
operator|(
name|void
operator|)
name|umask
argument_list|(
name|ct
operator|->
name|c_umask
argument_list|)
expr_stmt|;
call|(
name|void
call|)
argument_list|(
operator|*
name|ct
operator|->
name|c_ctlistfnx
argument_list|)
argument_list|(
name|ct
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ct
operator|->
name|c_fp
condition|)
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|ct
operator|->
name|c_fp
argument_list|)
operator|,
name|ct
operator|->
name|c_fp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ct
operator|->
name|c_ceclosefnx
condition|)
call|(
modifier|*
name|ct
operator|->
name|c_ceclosefnx
call|)
argument_list|(
name|ct
argument_list|)
expr_stmt|;
block|}
name|flush_errors
argument_list|()
expr_stmt|;
name|listsw
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|showsw
condition|)
for|for
control|(
name|ctp
operator|=
name|cts
init|;
name|ct
operator|=
operator|*
name|ctp
condition|;
name|ctp
operator|++
control|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|BSD42
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|WAITINT
argument_list|)
name|union
name|wait
name|status
decl_stmt|;
else|#
directive|else
name|int
name|status
decl_stmt|;
endif|#
directive|endif
name|TYPESIG
argument_list|(
operator|*
name|hstat
argument_list|)
argument_list|()
decl_stmt|,
argument_list|(
operator|*
name|istat
argument_list|)
argument_list|()
decl_stmt|,
argument_list|(
operator|*
name|qstat
argument_list|)
argument_list|()
decl_stmt|,
argument_list|(
operator|*
name|tstat
argument_list|)
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|type_ok
argument_list|(
name|ct
argument_list|,
literal|0
argument_list|)
condition|)
continue|continue;
operator|(
name|void
operator|)
name|umask
argument_list|(
name|ct
operator|->
name|c_umask
argument_list|)
expr_stmt|;
if|if
condition|(
name|listsw
condition|)
block|{
if|if
condition|(
name|headsw
condition|)
name|printf
argument_list|(
name|LSTFMT1
argument_list|,
literal|"msg"
argument_list|,
literal|"part"
argument_list|,
literal|"type/subtype"
argument_list|,
literal|"size"
argument_list|,
literal|"description"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ct
operator|->
name|c_ctlistfnx
condition|)
call|(
name|void
call|)
argument_list|(
operator|*
name|ct
operator|->
name|c_ctlistfnx
argument_list|)
argument_list|(
name|ct
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ct
operator|->
name|c_ctshowfnx
condition|)
block|{
if|if
condition|(
name|ct
operator|->
name|c_fp
condition|)
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|ct
operator|->
name|c_fp
argument_list|)
operator|,
name|ct
operator|->
name|c_fp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ct
operator|->
name|c_ceclosefnx
condition|)
call|(
modifier|*
name|ct
operator|->
name|c_ceclosefnx
call|)
argument_list|(
name|ct
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|formsw
argument_list|,
literal|"mhl.null"
argument_list|)
condition|)
block|{
name|int
name|child_id
decl_stmt|,
name|i
decl_stmt|,
name|vecp
decl_stmt|;
name|char
modifier|*
name|vec
index|[
literal|8
index|]
decl_stmt|;
name|vecp
operator|=
literal|0
expr_stmt|;
name|vec
index|[
name|vecp
operator|++
index|]
operator|=
name|r1bindex
argument_list|(
name|mhlproc
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
name|vec
index|[
name|vecp
operator|++
index|]
operator|=
literal|"-form"
expr_stmt|;
name|vec
index|[
name|vecp
operator|++
index|]
operator|=
name|formsw
expr_stmt|;
name|vec
index|[
name|vecp
operator|++
index|]
operator|=
literal|"-nobody"
expr_stmt|;
name|vec
index|[
name|vecp
operator|++
index|]
operator|=
name|ct
operator|->
name|c_file
expr_stmt|;
if|if
condition|(
name|nomore
condition|)
name|vec
index|[
name|vecp
operator|++
index|]
operator|=
literal|"-nomoreproc"
expr_stmt|;
elseif|else
if|if
condition|(
name|progsw
condition|)
block|{
name|vec
index|[
name|vecp
operator|++
index|]
operator|=
literal|"-moreproc"
expr_stmt|;
name|vec
index|[
name|vecp
operator|++
index|]
operator|=
name|progsw
expr_stmt|;
block|}
name|vec
index|[
name|vecp
index|]
operator|=
name|NULL
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|child_id
operator|=
name|vfork
argument_list|()
operator|)
operator|==
name|NOTOK
operator|&&
name|i
operator|<
literal|5
condition|;
name|i
operator|++
control|)
name|sleep
argument_list|(
literal|5
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|child_id
condition|)
block|{
case|case
name|NOTOK
case|:
name|adios
argument_list|(
literal|"fork"
argument_list|,
literal|"unable to"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
case|case
name|OK
case|:
operator|(
name|void
operator|)
name|execvp
argument_list|(
name|mhlproc
argument_list|,
name|vec
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"unable to exec "
argument_list|)
expr_stmt|;
name|perror
argument_list|(
name|mhlproc
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
default|default:
name|xpid
operator|=
operator|-
name|child_id
expr_stmt|;
break|break;
block|}
block|}
else|else
name|xpid
operator|=
literal|0
expr_stmt|;
call|(
name|void
call|)
argument_list|(
operator|*
name|ct
operator|->
name|c_ctshowfnx
argument_list|)
argument_list|(
name|ct
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ct
operator|->
name|c_fp
condition|)
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|ct
operator|->
name|c_fp
argument_list|)
operator|,
name|ct
operator|->
name|c_fp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ct
operator|->
name|c_ceclosefnx
condition|)
call|(
modifier|*
name|ct
operator|->
name|c_ceclosefnx
call|)
argument_list|(
name|ct
argument_list|)
expr_stmt|;
name|hstat
operator|=
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|istat
operator|=
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|qstat
operator|=
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|tstat
operator|=
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
while|while
condition|(
name|wait
argument_list|(
operator|&
name|status
argument_list|)
operator|!=
name|NOTOK
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|BSD42
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|WAITINT
argument_list|)
operator|(
name|void
operator|)
name|pidcheck
argument_list|(
name|status
operator|.
name|w_status
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|pidcheck
argument_list|(
name|status
argument_list|)
expr_stmt|;
endif|#
directive|endif
continue|continue;
block|}
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|hstat
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|istat
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|qstat
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|tstat
argument_list|)
expr_stmt|;
name|xpid
operator|=
literal|0
expr_stmt|;
name|flush_errors
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|ctp
operator|=
name|cts
init|;
operator|*
name|ctp
condition|;
name|ctp
operator|++
control|)
name|free_content
argument_list|(
operator|*
name|ctp
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cts
argument_list|)
expr_stmt|;
name|cts
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|mp
condition|)
block|{
name|m_replace
argument_list|(
name|pfolder
argument_list|,
name|folder
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|hghsel
operator|!=
name|mp
operator|->
name|curmsg
condition|)
name|m_setcur
argument_list|(
name|mp
argument_list|,
name|mp
operator|->
name|hghsel
argument_list|)
expr_stmt|;
name|m_sync
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|m_update
argument_list|()
expr_stmt|;
block|}
name|done
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|TYPESIG
name|pipeser
parameter_list|(
name|i
parameter_list|)
name|int
name|i
decl_stmt|;
block|{
if|if
condition|(
name|i
operator|==
name|SIGQUIT
condition|)
block|{
operator|(
name|void
operator|)
name|unlink
argument_list|(
literal|"core"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_include
include|#
directive|include
file|"../h/mhn.h"
end_include

begin_struct
struct|struct
name|str2init
block|{
name|char
modifier|*
name|si_key
decl_stmt|;
name|int
name|si_value
decl_stmt|;
name|int
function_decl|(
modifier|*
name|si_init
function_decl|)
parameter_list|()
function_decl|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|int
name|InitApplication
argument_list|()
decl_stmt|,
name|InitMessage
argument_list|()
decl_stmt|,
name|InitMultiPart
argument_list|()
decl_stmt|,
name|InitText
argument_list|()
decl_stmt|,
name|InitGeneric
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|str2init
name|str2cts
index|[]
init|=
block|{
literal|"application"
block|,
name|CT_APPLICATION
block|,
name|InitApplication
block|,
literal|"audio"
block|,
name|CT_AUDIO
block|,
name|InitGeneric
block|,
literal|"image"
block|,
name|CT_IMAGE
block|,
name|InitGeneric
block|,
literal|"message"
block|,
name|CT_MESSAGE
block|,
name|InitMessage
block|,
literal|"multipart"
block|,
name|CT_MULTIPART
block|,
name|InitMultiPart
block|,
literal|"text"
block|,
name|CT_TEXT
block|,
name|InitText
block|,
literal|"video"
block|,
name|CT_VIDEO
block|,
name|InitGeneric
block|,
name|NULL
block|,
name|CT_EXTENSION
block|,
name|NULL
block|,
comment|/* these two must be last! */
name|NULL
block|,
name|CT_UNKNOWN
block|,
name|NULL
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|InitBase64
argument_list|()
decl_stmt|,
name|InitQuoted
argument_list|()
decl_stmt|,
name|Init7Bit
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|str2init
name|str2ces
index|[]
init|=
block|{
literal|"base64"
block|,
name|CE_BASE64
block|,
name|InitBase64
block|,
literal|"quoted-printable"
block|,
name|CE_QUOTED
block|,
name|InitQuoted
block|,
literal|"8bit"
block|,
name|CE_8BIT
block|,
name|Init7Bit
block|,
literal|"7bit"
block|,
name|CE_7BIT
block|,
name|Init7Bit
block|,
literal|"binary"
block|,
name|CE_BINARY
block|,
name|NULL
block|,
name|NULL
block|,
name|CE_EXTENSION
block|,
name|NULL
block|,
comment|/* these two must be last! */
name|NULL
block|,
name|CE_UNKNOWN
block|,
name|NULL
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|CT
name|get_content
parameter_list|(
name|in
parameter_list|,
name|file
parameter_list|,
name|toplevel
parameter_list|)
name|FILE
modifier|*
name|in
decl_stmt|;
name|char
modifier|*
name|file
decl_stmt|;
name|int
name|toplevel
decl_stmt|;
block|{
name|int
name|compnum
decl_stmt|,
name|state
decl_stmt|;
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|,
name|name
index|[
name|NAMESZ
index|]
decl_stmt|;
specifier|register
name|CT
name|ct
decl_stmt|;
if|if
condition|(
operator|(
name|ct
operator|=
operator|(
name|CT
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
expr|*
name|ct
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
name|ct
operator|->
name|c_begin
operator|=
name|ftell
argument_list|(
name|ct
operator|->
name|c_fp
operator|=
name|in
argument_list|)
operator|+
literal|1
expr_stmt|;
name|ct
operator|->
name|c_file
operator|=
name|add
argument_list|(
name|file
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
for|for
control|(
name|compnum
operator|=
literal|1
operator|,
name|state
operator|=
name|FLD
init|;
condition|;
control|)
block|{
switch|switch
condition|(
name|state
operator|=
name|m_getfld
argument_list|(
name|state
argument_list|,
name|name
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|in
argument_list|)
condition|)
block|{
case|case
name|FLD
case|:
case|case
name|FLDPLUS
case|:
case|case
name|FLDEOF
case|:
name|compnum
operator|++
expr_stmt|;
if|if
condition|(
name|uleq
argument_list|(
name|name
argument_list|,
name|VRSN_FIELD
argument_list|)
condition|)
block|{
name|int
name|ucmp
decl_stmt|;
name|char
name|c
decl_stmt|,
modifier|*
name|cp
decl_stmt|,
modifier|*
name|dp
decl_stmt|;
name|cp
operator|=
name|add
argument_list|(
name|buf
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
while|while
condition|(
name|state
operator|==
name|FLDPLUS
condition|)
block|{
name|state
operator|=
name|m_getfld
argument_list|(
name|state
argument_list|,
name|name
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|in
argument_list|)
expr_stmt|;
name|cp
operator|=
name|add
argument_list|(
name|buf
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ct
operator|->
name|c_vrsn
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"message %s has multiple %s: fields (%s)"
argument_list|,
name|ct
operator|->
name|c_file
argument_list|,
name|VRSN_FIELD
argument_list|,
name|dp
operator|=
name|trimcpy
argument_list|(
name|cp
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cp
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ct
operator|->
name|c_vrsn
operator|=
name|cp
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
name|cp
operator|++
expr_stmt|;
for|for
control|(
name|dp
operator|=
name|index
argument_list|(
name|cp
argument_list|,
literal|'\n'
argument_list|)
init|;
name|dp
condition|;
name|dp
operator|=
name|index
argument_list|(
name|dp
argument_list|,
literal|'\n'
argument_list|)
control|)
operator|*
name|dp
operator|++
operator|=
literal|' '
expr_stmt|;
for|for
control|(
name|dp
operator|=
name|cp
operator|+
name|strlen
argument_list|(
name|cp
argument_list|)
operator|-
literal|1
init|;
name|dp
operator|>=
name|cp
condition|;
name|dp
operator|--
control|)
if|if
condition|(
operator|!
name|isspace
argument_list|(
operator|*
name|dp
argument_list|)
condition|)
break|break;
operator|*
operator|++
name|dp
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|debugsw
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s\n"
argument_list|,
name|VRSN_FIELD
argument_list|,
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'('
operator|&&
name|get_comment
argument_list|(
name|ct
argument_list|,
operator|&
name|cp
argument_list|,
literal|0
argument_list|)
operator|==
name|NOTOK
condition|)
goto|goto
name|out
goto|;
for|for
control|(
name|dp
operator|=
name|cp
init|;
name|istoken
argument_list|(
operator|*
name|dp
argument_list|)
condition|;
name|dp
operator|++
control|)
continue|continue;
name|c
operator|=
operator|*
name|dp
operator|,
operator|*
name|dp
operator|=
literal|'\0'
expr_stmt|;
name|ucmp
operator|=
name|uleq
argument_list|(
name|cp
argument_list|,
name|VRSN_VALUE
argument_list|)
expr_stmt|;
operator|*
name|dp
operator|=
name|c
expr_stmt|;
if|if
condition|(
operator|!
name|ucmp
condition|)
name|admonish
argument_list|(
name|NULLCP
argument_list|,
literal|"message %s has unknown value for %s: field (%s)"
argument_list|,
name|ct
operator|->
name|c_file
argument_list|,
name|VRSN_FIELD
argument_list|,
name|cp
argument_list|)
expr_stmt|;
goto|goto
name|got_header
goto|;
block|}
if|if
condition|(
name|uleq
argument_list|(
name|name
argument_list|,
name|TYPE_FIELD
argument_list|)
condition|)
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|struct
name|str2init
modifier|*
name|s2i
decl_stmt|;
specifier|register
name|CI
name|ci
init|=
operator|&
name|ct
operator|->
name|c_ctinfo
decl_stmt|;
name|cp
operator|=
name|add
argument_list|(
name|buf
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
while|while
condition|(
name|state
operator|==
name|FLDPLUS
condition|)
block|{
name|state
operator|=
name|m_getfld
argument_list|(
name|state
argument_list|,
name|name
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|in
argument_list|)
expr_stmt|;
name|cp
operator|=
name|add
argument_list|(
name|buf
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ct
operator|->
name|c_ctline
condition|)
block|{
name|char
modifier|*
name|dp
init|=
name|trimcpy
argument_list|(
name|cp
argument_list|)
decl_stmt|;
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"message %s has multiple %s: fields (%s)"
argument_list|,
name|ct
operator|->
name|c_file
argument_list|,
name|TYPE_FIELD
argument_list|,
name|dp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cp
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|get_ctinfo
argument_list|(
name|cp
argument_list|,
name|ct
argument_list|,
literal|0
argument_list|)
operator|==
name|NOTOK
condition|)
goto|goto
name|out
goto|;
for|for
control|(
name|s2i
operator|=
name|str2cts
init|;
name|s2i
operator|->
name|si_key
condition|;
name|s2i
operator|++
control|)
if|if
condition|(
name|uleq
argument_list|(
name|ci
operator|->
name|ci_type
argument_list|,
name|s2i
operator|->
name|si_key
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|!
name|s2i
operator|->
name|si_key
operator|&&
operator|!
name|uprf
argument_list|(
name|ci
operator|->
name|ci_type
argument_list|,
literal|"X-"
argument_list|)
condition|)
name|s2i
operator|++
expr_stmt|;
name|ct
operator|->
name|c_type
operator|=
name|s2i
operator|->
name|si_value
expr_stmt|;
name|ct
operator|->
name|c_ctinitfnx
operator|=
name|s2i
operator|->
name|si_init
expr_stmt|;
goto|goto
name|got_header
goto|;
block|}
if|if
condition|(
name|uleq
argument_list|(
name|name
argument_list|,
name|ENCODING_FIELD
argument_list|)
condition|)
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|dp
decl_stmt|;
name|char
name|c
decl_stmt|;
specifier|register
name|struct
name|str2init
modifier|*
name|s2i
decl_stmt|;
name|cp
operator|=
name|add
argument_list|(
name|buf
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
while|while
condition|(
name|state
operator|==
name|FLDPLUS
condition|)
block|{
name|state
operator|=
name|m_getfld
argument_list|(
name|state
argument_list|,
name|name
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|in
argument_list|)
expr_stmt|;
name|cp
operator|=
name|add
argument_list|(
name|buf
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ct
operator|->
name|c_celine
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"message %s has multiple %s: fields (%s)"
argument_list|,
name|ct
operator|->
name|c_file
argument_list|,
name|ENCODING_FIELD
argument_list|,
name|dp
operator|=
name|trimcpy
argument_list|(
name|cp
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cp
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ct
operator|->
name|c_celine
operator|=
name|cp
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
name|cp
operator|++
expr_stmt|;
for|for
control|(
name|dp
operator|=
name|cp
init|;
name|istoken
argument_list|(
operator|*
name|dp
argument_list|)
condition|;
name|dp
operator|++
control|)
continue|continue;
name|c
operator|=
operator|*
name|dp
operator|,
operator|*
name|dp
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|s2i
operator|=
name|str2ces
init|;
name|s2i
operator|->
name|si_key
condition|;
name|s2i
operator|++
control|)
if|if
condition|(
name|uleq
argument_list|(
name|cp
argument_list|,
name|s2i
operator|->
name|si_key
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|!
name|s2i
operator|->
name|si_key
operator|&&
operator|!
name|uprf
argument_list|(
name|cp
argument_list|,
literal|"X-"
argument_list|)
condition|)
name|s2i
operator|++
expr_stmt|;
operator|*
name|dp
operator|=
name|c
expr_stmt|;
name|ct
operator|->
name|c_encoding
operator|=
name|s2i
operator|->
name|si_value
expr_stmt|;
if|if
condition|(
name|s2i
operator|->
name|si_init
operator|&&
call|(
modifier|*
name|s2i
operator|->
name|si_init
call|)
argument_list|(
name|ct
argument_list|)
operator|==
name|NOTOK
condition|)
goto|goto
name|out
goto|;
goto|goto
name|got_header
goto|;
block|}
if|if
condition|(
name|uleq
argument_list|(
name|name
argument_list|,
name|ID_FIELD
argument_list|)
condition|)
block|{
name|ct
operator|->
name|c_id
operator|=
name|add
argument_list|(
name|buf
argument_list|,
name|ct
operator|->
name|c_id
argument_list|)
expr_stmt|;
while|while
condition|(
name|state
operator|==
name|FLDPLUS
condition|)
block|{
name|state
operator|=
name|m_getfld
argument_list|(
name|state
argument_list|,
name|name
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|in
argument_list|)
expr_stmt|;
name|ct
operator|->
name|c_id
operator|=
name|add
argument_list|(
name|buf
argument_list|,
name|ct
operator|->
name|c_id
argument_list|)
expr_stmt|;
block|}
goto|goto
name|got_header
goto|;
block|}
if|if
condition|(
name|uleq
argument_list|(
name|name
argument_list|,
name|DESCR_FIELD
argument_list|)
condition|)
block|{
name|ct
operator|->
name|c_descr
operator|=
name|add
argument_list|(
name|buf
argument_list|,
name|ct
operator|->
name|c_descr
argument_list|)
expr_stmt|;
while|while
condition|(
name|state
operator|==
name|FLDPLUS
condition|)
block|{
name|state
operator|=
name|m_getfld
argument_list|(
name|state
argument_list|,
name|name
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|in
argument_list|)
expr_stmt|;
name|ct
operator|->
name|c_descr
operator|=
name|add
argument_list|(
name|buf
argument_list|,
name|ct
operator|->
name|c_descr
argument_list|)
expr_stmt|;
block|}
goto|goto
name|got_header
goto|;
block|}
if|if
condition|(
name|uleq
argument_list|(
name|name
argument_list|,
name|MD5_FIELD
argument_list|)
condition|)
block|{
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|dp
decl_stmt|,
modifier|*
name|ep
decl_stmt|;
name|cp
operator|=
name|add
argument_list|(
name|buf
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
while|while
condition|(
name|state
operator|==
name|FLDPLUS
condition|)
block|{
name|state
operator|=
name|m_getfld
argument_list|(
name|state
argument_list|,
name|name
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|in
argument_list|)
expr_stmt|;
name|cp
operator|=
name|add
argument_list|(
name|buf
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|checksw
condition|)
block|{
name|free
argument_list|(
name|cp
argument_list|)
expr_stmt|;
goto|goto
name|got_header
goto|;
block|}
if|if
condition|(
name|ct
operator|->
name|c_digested
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"message %s has multiple %s: fields (%s)"
argument_list|,
name|ct
operator|->
name|c_file
argument_list|,
name|MD5_FIELD
argument_list|,
name|dp
operator|=
name|trimcpy
argument_list|(
name|cp
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cp
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ep
operator|=
name|cp
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
name|cp
operator|++
expr_stmt|;
for|for
control|(
name|dp
operator|=
name|index
argument_list|(
name|cp
argument_list|,
literal|'\n'
argument_list|)
init|;
name|dp
condition|;
name|dp
operator|=
name|index
argument_list|(
name|dp
argument_list|,
literal|'\n'
argument_list|)
control|)
operator|*
name|dp
operator|++
operator|=
literal|' '
expr_stmt|;
for|for
control|(
name|dp
operator|=
name|cp
operator|+
name|strlen
argument_list|(
name|cp
argument_list|)
operator|-
literal|1
init|;
name|dp
operator|>=
name|cp
condition|;
name|dp
operator|--
control|)
if|if
condition|(
operator|!
name|isspace
argument_list|(
operator|*
name|dp
argument_list|)
condition|)
break|break;
operator|*
operator|++
name|dp
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|debugsw
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s\n"
argument_list|,
name|MD5_FIELD
argument_list|,
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'('
operator|&&
name|get_comment
argument_list|(
name|ct
argument_list|,
operator|&
name|cp
argument_list|,
literal|0
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
name|free
argument_list|(
name|ep
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
for|for
control|(
name|dp
operator|=
name|cp
init|;
operator|*
name|dp
operator|&&
operator|!
name|isspace
argument_list|(
operator|*
name|dp
argument_list|)
condition|;
name|dp
operator|++
control|)
continue|continue;
operator|*
name|dp
operator|=
literal|'\0'
expr_stmt|;
operator|(
name|void
operator|)
name|readDigest
argument_list|(
name|ct
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ep
argument_list|)
expr_stmt|;
name|ct
operator|->
name|c_digested
operator|++
expr_stmt|;
goto|goto
name|got_header
goto|;
block|}
ifdef|#
directive|ifdef
name|notdef
if|if
condition|(
name|uprf
argument_list|(
name|name
argument_list|,
name|XXX_FIELD_PRF
argument_list|)
condition|)
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"unknown field (%s) in message %s"
argument_list|,
name|name
argument_list|,
name|ct
operator|->
name|c_file
argument_list|)
expr_stmt|;
comment|/* and fall... */
endif|#
directive|endif
while|while
condition|(
name|state
operator|==
name|FLDPLUS
condition|)
name|state
operator|=
name|m_getfld
argument_list|(
name|state
argument_list|,
name|name
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|in
argument_list|)
expr_stmt|;
name|got_header
label|:
empty_stmt|;
if|if
condition|(
name|state
operator|!=
name|FLDEOF
condition|)
block|{
name|ct
operator|->
name|c_begin
operator|=
name|ftell
argument_list|(
name|in
argument_list|)
operator|+
literal|1
expr_stmt|;
continue|continue;
block|}
comment|/* else fall... */
case|case
name|BODY
case|:
case|case
name|BODYEOF
case|:
break|break;
case|case
name|FILEEOF
case|:
name|ct
operator|->
name|c_begin
operator|=
name|ftell
argument_list|(
name|in
argument_list|)
expr_stmt|;
break|break;
case|case
name|LENERR
case|:
case|case
name|FMTERR
case|:
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"message format error in component #%d"
argument_list|,
name|compnum
argument_list|)
expr_stmt|;
default|default:
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"getfld() returned %d"
argument_list|,
name|state
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
operator|!
name|ct
operator|->
name|c_ctline
condition|)
block|{
if|if
condition|(
name|toplevel
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|get_ctinfo
argument_list|(
literal|"message/rfc822"
argument_list|,
name|ct
argument_list|,
literal|0
argument_list|)
operator|==
name|NOTOK
condition|)
goto|goto
name|out
goto|;
name|ct
operator|->
name|c_type
operator|=
name|CT_MESSAGE
expr_stmt|;
name|ct
operator|->
name|c_ctinitfnx
operator|=
name|InitMessage
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|get_ctinfo
argument_list|(
literal|"text/plain"
argument_list|,
name|ct
argument_list|,
literal|0
argument_list|)
operator|==
name|NOTOK
condition|)
goto|goto
name|out
goto|;
name|ct
operator|->
name|c_type
operator|=
name|CT_TEXT
expr_stmt|;
name|ct
operator|->
name|c_ctinitfnx
operator|=
name|InitText
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|ct
operator|->
name|c_ctlistfnx
condition|)
name|ct
operator|->
name|c_ctlistfnx
operator|=
name|list_content
expr_stmt|;
if|if
condition|(
operator|!
name|ct
operator|->
name|c_ctshowfnx
condition|)
name|ct
operator|->
name|c_ctshowfnx
operator|=
name|show_content
expr_stmt|;
if|if
condition|(
operator|!
name|ct
operator|->
name|c_ctstorefnx
condition|)
name|ct
operator|->
name|c_ctstorefnx
operator|=
name|store_content
expr_stmt|;
if|if
condition|(
operator|!
name|ct
operator|->
name|c_celine
condition|)
block|{
name|ct
operator|->
name|c_encoding
operator|=
name|CE_7BIT
expr_stmt|;
operator|(
name|void
operator|)
name|Init7Bit
argument_list|(
name|ct
argument_list|)
expr_stmt|;
block|}
return|return
name|ct
return|;
name|out
label|:
name|free_content
argument_list|(
name|ct
argument_list|)
expr_stmt|;
return|return
name|NULLCT
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|get_ctinfo
parameter_list|(
name|cp
parameter_list|,
name|ct
parameter_list|,
name|magic
parameter_list|)
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|CT
name|ct
decl_stmt|;
name|int
name|magic
decl_stmt|;
block|{
name|int
name|i
init|=
name|strlen
argument_list|(
name|invo_name
argument_list|)
operator|+
literal|2
decl_stmt|;
specifier|register
name|char
modifier|*
name|dp
decl_stmt|,
modifier|*
modifier|*
name|ap
decl_stmt|,
modifier|*
modifier|*
name|ep
decl_stmt|;
name|char
name|c
decl_stmt|;
specifier|register
name|CI
name|ci
init|=
operator|&
name|ct
operator|->
name|c_ctinfo
decl_stmt|;
name|cp
operator|=
name|ct
operator|->
name|c_ctline
operator|=
name|add
argument_list|(
name|cp
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
name|cp
operator|++
expr_stmt|;
for|for
control|(
name|dp
operator|=
name|index
argument_list|(
name|cp
argument_list|,
literal|'\n'
argument_list|)
init|;
name|dp
condition|;
name|dp
operator|=
name|index
argument_list|(
name|dp
argument_list|,
literal|'\n'
argument_list|)
control|)
operator|*
name|dp
operator|++
operator|=
literal|' '
expr_stmt|;
for|for
control|(
name|dp
operator|=
name|cp
operator|+
name|strlen
argument_list|(
name|cp
argument_list|)
operator|-
literal|1
init|;
name|dp
operator|>=
name|cp
condition|;
name|dp
operator|--
control|)
if|if
condition|(
operator|!
name|isspace
argument_list|(
operator|*
name|dp
argument_list|)
condition|)
break|break;
operator|*
operator|++
name|dp
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|debugsw
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s\n"
argument_list|,
name|TYPE_FIELD
argument_list|,
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'('
operator|&&
name|get_comment
argument_list|(
name|ct
argument_list|,
operator|&
name|cp
argument_list|,
literal|1
argument_list|)
operator|==
name|NOTOK
condition|)
return|return
name|NOTOK
return|;
for|for
control|(
name|dp
operator|=
name|cp
init|;
name|istoken
argument_list|(
operator|*
name|dp
argument_list|)
condition|;
name|dp
operator|++
control|)
continue|continue;
name|c
operator|=
operator|*
name|dp
operator|,
operator|*
name|dp
operator|=
literal|'\0'
expr_stmt|;
name|ci
operator|->
name|ci_type
operator|=
name|add
argument_list|(
name|cp
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
operator|*
name|dp
operator|=
name|c
operator|,
name|cp
operator|=
name|dp
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|ci
operator|->
name|ci_type
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"invalid %s: field in message %s (empty type)"
argument_list|,
name|TYPE_FIELD
argument_list|,
name|ct
operator|->
name|c_file
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
for|for
control|(
name|dp
operator|=
name|ci
operator|->
name|ci_type
init|;
operator|*
name|dp
condition|;
name|dp
operator|++
control|)
if|if
condition|(
name|isalpha
argument_list|(
operator|*
name|dp
argument_list|)
operator|&&
name|isupper
argument_list|(
operator|*
name|dp
argument_list|)
condition|)
operator|*
name|dp
operator|=
name|tolower
argument_list|(
operator|*
name|dp
argument_list|)
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
name|cp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'('
operator|&&
name|get_comment
argument_list|(
name|ct
argument_list|,
operator|&
name|cp
argument_list|,
literal|1
argument_list|)
operator|==
name|NOTOK
condition|)
return|return
name|NOTOK
return|;
if|if
condition|(
operator|*
name|cp
operator|!=
literal|'/'
condition|)
block|{
if|if
condition|(
operator|!
name|magic
condition|)
name|ci
operator|->
name|ci_subtype
operator|=
name|add
argument_list|(
literal|""
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
goto|goto
name|magic_skip
goto|;
block|}
name|cp
operator|++
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
name|cp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'('
operator|&&
name|get_comment
argument_list|(
name|ct
argument_list|,
operator|&
name|cp
argument_list|,
literal|1
argument_list|)
operator|==
name|NOTOK
condition|)
return|return
name|NOTOK
return|;
for|for
control|(
name|dp
operator|=
name|cp
init|;
name|istoken
argument_list|(
operator|*
name|dp
argument_list|)
condition|;
name|dp
operator|++
control|)
continue|continue;
name|c
operator|=
operator|*
name|dp
operator|,
operator|*
name|dp
operator|=
literal|'\0'
expr_stmt|;
name|ci
operator|->
name|ci_subtype
operator|=
name|add
argument_list|(
name|cp
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
operator|*
name|dp
operator|=
name|c
operator|,
name|cp
operator|=
name|dp
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|ci
operator|->
name|ci_subtype
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"invalid %s: field in message %s (empty subtype for \"%s\")"
argument_list|,
name|TYPE_FIELD
argument_list|,
name|ct
operator|->
name|c_file
argument_list|,
name|ci
operator|->
name|ci_type
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
for|for
control|(
name|dp
operator|=
name|ci
operator|->
name|ci_subtype
init|;
operator|*
name|dp
condition|;
name|dp
operator|++
control|)
if|if
condition|(
name|isalpha
argument_list|(
operator|*
name|dp
argument_list|)
operator|&&
name|isupper
argument_list|(
operator|*
name|dp
argument_list|)
condition|)
operator|*
name|dp
operator|=
name|tolower
argument_list|(
operator|*
name|dp
argument_list|)
expr_stmt|;
name|magic_skip
label|:
empty_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
name|cp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'('
operator|&&
name|get_comment
argument_list|(
name|ct
argument_list|,
operator|&
name|cp
argument_list|,
literal|1
argument_list|)
operator|==
name|NOTOK
condition|)
return|return
name|NOTOK
return|;
name|ep
operator|=
operator|(
name|ap
operator|=
name|ci
operator|->
name|ci_attrs
operator|)
operator|+
name|NPARMS
expr_stmt|;
while|while
condition|(
operator|*
name|cp
operator|==
literal|';'
condition|)
block|{
name|char
modifier|*
name|vp
decl_stmt|,
modifier|*
name|up
decl_stmt|;
if|if
condition|(
name|ap
operator|>=
name|ep
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"too many parameters in message %s's %s: field (%d max)"
argument_list|,
name|ct
operator|->
name|c_file
argument_list|,
name|TYPE_FIELD
argument_list|,
name|NPARMS
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
name|cp
operator|++
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
name|cp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'('
operator|&&
name|get_comment
argument_list|(
name|ct
argument_list|,
operator|&
name|cp
argument_list|,
literal|1
argument_list|)
operator|==
name|NOTOK
condition|)
return|return
name|NOTOK
return|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|0
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"extraneous trailing ';' in message %s's %s: parameter list"
argument_list|,
name|ct
operator|->
name|c_file
argument_list|,
name|TYPE_FIELD
argument_list|)
expr_stmt|;
return|return
name|OK
return|;
block|}
for|for
control|(
name|dp
operator|=
name|cp
init|;
name|istoken
argument_list|(
operator|*
name|dp
argument_list|)
condition|;
name|dp
operator|++
control|)
if|if
condition|(
name|isalpha
argument_list|(
operator|*
name|dp
argument_list|)
operator|&&
name|isupper
argument_list|(
operator|*
name|dp
argument_list|)
condition|)
operator|*
name|dp
operator|=
name|tolower
argument_list|(
operator|*
name|dp
argument_list|)
expr_stmt|;
for|for
control|(
name|up
operator|=
name|dp
init|;
name|isspace
argument_list|(
operator|*
name|dp
argument_list|)
condition|;
control|)
name|dp
operator|++
expr_stmt|;
if|if
condition|(
name|dp
operator|==
name|cp
operator|||
operator|*
name|dp
operator|!=
literal|'='
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"invalid parameter in message %s's %s: field\n%*.*sparameter %s (error detected at offset %d)"
argument_list|,
name|ct
operator|->
name|c_file
argument_list|,
name|TYPE_FIELD
argument_list|,
name|i
argument_list|,
name|i
argument_list|,
literal|""
argument_list|,
name|cp
argument_list|,
name|dp
operator|-
name|cp
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
name|vp
operator|=
operator|(
operator|*
name|ap
operator|=
name|add
argument_list|(
name|cp
argument_list|,
name|NULLCP
argument_list|)
operator|)
operator|+
operator|(
name|up
operator|-
name|cp
operator|)
expr_stmt|;
operator|*
name|vp
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|dp
operator|++
init|;
name|isspace
argument_list|(
operator|*
name|dp
argument_list|)
condition|;
control|)
name|dp
operator|++
expr_stmt|;
name|ci
operator|->
name|ci_values
index|[
name|ap
operator|-
name|ci
operator|->
name|ci_attrs
index|]
operator|=
name|vp
operator|=
operator|*
name|ap
operator|+
operator|(
name|dp
operator|-
name|cp
operator|)
expr_stmt|;
if|if
condition|(
operator|*
name|dp
operator|==
literal|'"'
condition|)
block|{
for|for
control|(
name|cp
operator|=
operator|++
name|dp
operator|,
name|dp
operator|=
name|vp
init|;
condition|;
control|)
block|{
switch|switch
condition|(
name|c
operator|=
operator|*
name|cp
operator|++
condition|)
block|{
case|case
literal|'\0'
case|:
name|bad_quote
label|:
empty_stmt|;
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"invalid quoted-string in message %s's %s: field\n%*.*s(parameter %s)"
argument_list|,
name|ct
operator|->
name|c_file
argument_list|,
name|TYPE_FIELD
argument_list|,
name|i
argument_list|,
name|i
argument_list|,
literal|""
argument_list|,
operator|*
name|ap
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
case|case
literal|'\\'
case|:
operator|*
name|dp
operator|++
operator|=
name|c
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
operator|*
name|cp
operator|++
operator|)
operator|==
literal|'\0'
condition|)
goto|goto
name|bad_quote
goto|;
comment|/* else fall... */
default|default:
operator|*
name|dp
operator|++
operator|=
name|c
expr_stmt|;
continue|continue;
case|case
literal|'"'
case|:
operator|*
name|dp
operator|=
literal|'\0'
expr_stmt|;
break|break;
block|}
break|break;
block|}
block|}
else|else
block|{
for|for
control|(
name|cp
operator|=
name|dp
operator|,
name|dp
operator|=
name|vp
init|;
name|istoken
argument_list|(
operator|*
name|cp
argument_list|)
condition|;
name|cp
operator|++
operator|,
name|dp
operator|++
control|)
continue|continue;
operator|*
name|dp
operator|=
literal|'\0'
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|*
name|vp
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"invalid parameter in message %s's %s: field\n%*.*s(parameter %s)"
argument_list|,
name|ct
operator|->
name|c_file
argument_list|,
name|TYPE_FIELD
argument_list|,
name|i
argument_list|,
name|i
argument_list|,
literal|""
argument_list|,
operator|*
name|ap
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
name|ap
operator|++
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
name|cp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'('
operator|&&
name|get_comment
argument_list|(
name|ct
argument_list|,
operator|&
name|cp
argument_list|,
literal|1
argument_list|)
operator|==
name|NOTOK
condition|)
return|return
name|NOTOK
return|;
block|}
if|if
condition|(
name|magic
operator|&&
operator|*
name|cp
operator|==
literal|'<'
condition|)
block|{
if|if
condition|(
name|ct
operator|->
name|c_id
condition|)
name|free
argument_list|(
name|ct
operator|->
name|c_id
argument_list|)
operator|,
name|ct
operator|->
name|c_id
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|dp
operator|=
name|index
argument_list|(
name|ct
operator|->
name|c_id
operator|=
operator|++
name|cp
argument_list|,
literal|'>'
argument_list|)
operator|)
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"invalid ID in message %s"
argument_list|,
name|ct
operator|->
name|c_file
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
name|c
operator|=
operator|*
name|dp
operator|,
operator|*
name|dp
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|*
name|ct
operator|->
name|c_id
condition|)
name|ct
operator|->
name|c_id
operator|=
name|concat
argument_list|(
literal|"<"
argument_list|,
name|ct
operator|->
name|c_id
argument_list|,
literal|">\n"
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
else|else
name|ct
operator|->
name|c_id
operator|=
name|NULL
expr_stmt|;
operator|*
name|dp
operator|++
operator|=
name|c
operator|,
name|cp
operator|=
name|dp
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
name|cp
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|magic
operator|&&
operator|*
name|cp
operator|==
literal|'['
condition|)
block|{
name|ct
operator|->
name|c_descr
operator|=
operator|++
name|cp
expr_stmt|;
for|for
control|(
name|dp
operator|=
name|cp
operator|+
name|strlen
argument_list|(
name|cp
argument_list|)
operator|-
literal|1
init|;
name|dp
operator|>=
name|cp
condition|;
name|dp
operator|--
control|)
if|if
condition|(
operator|*
name|dp
operator|==
literal|']'
condition|)
break|break;
if|if
condition|(
name|dp
operator|<
name|cp
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"invalid description in message %s"
argument_list|,
name|ct
operator|->
name|c_file
argument_list|)
expr_stmt|;
name|ct
operator|->
name|c_descr
operator|=
name|NULL
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
name|c
operator|=
operator|*
name|dp
operator|,
operator|*
name|dp
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|*
name|ct
operator|->
name|c_descr
condition|)
name|ct
operator|->
name|c_descr
operator|=
name|concat
argument_list|(
name|ct
operator|->
name|c_descr
argument_list|,
literal|"\n"
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
else|else
name|ct
operator|->
name|c_descr
operator|=
name|NULL
expr_stmt|;
operator|*
name|dp
operator|++
operator|=
name|c
operator|,
name|cp
operator|=
name|dp
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
name|cp
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|cp
condition|)
block|{
if|if
condition|(
name|magic
condition|)
name|ci
operator|->
name|ci_magic
operator|=
name|add
argument_list|(
name|cp
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
else|else
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"extraneous information in message %s's %s: field\n%*.*s(%s)"
argument_list|,
name|ct
operator|->
name|c_file
argument_list|,
name|TYPE_FIELD
argument_list|,
name|i
argument_list|,
name|i
argument_list|,
literal|""
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
return|return
name|OK
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|get_comment
parameter_list|(
name|ct
parameter_list|,
name|ap
parameter_list|,
name|istype
parameter_list|)
name|CT
name|ct
decl_stmt|;
name|char
modifier|*
modifier|*
name|ap
decl_stmt|;
name|int
name|istype
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|bp
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
name|char
name|c
decl_stmt|,
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|,
modifier|*
name|dp
decl_stmt|;
specifier|register
name|CI
name|ci
init|=
operator|&
name|ct
operator|->
name|c_ctinfo
decl_stmt|;
name|cp
operator|=
operator|*
name|ap
expr_stmt|;
name|bp
operator|=
name|buffer
expr_stmt|;
name|cp
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
condition|;
control|)
block|{
switch|switch
condition|(
name|c
operator|=
operator|*
name|cp
operator|++
condition|)
block|{
case|case
literal|'\0'
case|:
name|invalid
label|:
empty_stmt|;
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"invalid comment in message %s's %s: field"
argument_list|,
name|ct
operator|->
name|c_file
argument_list|,
name|istype
condition|?
name|TYPE_FIELD
else|:
name|VRSN_FIELD
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
case|case
literal|'\\'
case|:
operator|*
name|bp
operator|++
operator|=
name|c
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
operator|*
name|cp
operator|++
operator|)
operator|==
literal|'\0'
condition|)
goto|goto
name|invalid
goto|;
operator|*
name|bp
operator|++
operator|=
name|c
expr_stmt|;
continue|continue;
case|case
literal|'('
case|:
name|i
operator|++
expr_stmt|;
comment|/* and fall... */
default|default:
operator|*
name|bp
operator|++
operator|=
name|c
expr_stmt|;
continue|continue;
case|case
literal|')'
case|:
if|if
condition|(
operator|--
name|i
operator|<
literal|0
condition|)
break|break;
operator|*
name|bp
operator|++
operator|=
name|c
expr_stmt|;
continue|continue;
block|}
break|break;
block|}
operator|*
name|bp
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|istype
condition|)
block|{
if|if
condition|(
name|dp
operator|=
name|ci
operator|->
name|ci_comment
condition|)
block|{
name|ci
operator|->
name|ci_comment
operator|=
name|concat
argument_list|(
name|dp
argument_list|,
literal|" "
argument_list|,
name|buffer
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dp
argument_list|)
expr_stmt|;
block|}
else|else
name|ci
operator|->
name|ci_comment
operator|=
name|add
argument_list|(
name|buffer
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
name|cp
operator|++
expr_stmt|;
operator|*
name|ap
operator|=
name|cp
expr_stmt|;
return|return
name|OK
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_define
define|#
directive|define
name|empty
parameter_list|(
name|s
parameter_list|)
value|((s) ? (s) : "")
end_define

begin_function
specifier|static
name|int
name|list_content
parameter_list|(
name|ct
parameter_list|,
name|toplevel
parameter_list|)
specifier|register
name|CT
name|ct
decl_stmt|;
name|int
name|toplevel
decl_stmt|;
block|{
name|unsigned
name|long
name|size
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|ap
decl_stmt|,
modifier|*
modifier|*
name|ep
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|,
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
specifier|register
name|CI
name|ci
init|=
operator|&
name|ct
operator|->
name|c_ctinfo
decl_stmt|;
name|printf
argument_list|(
name|toplevel
operator|>
literal|0
condition|?
name|LSTFMT2a
else|:
name|toplevel
operator|<
literal|0
condition|?
literal|"part "
else|:
literal|"     "
argument_list|,
name|atoi
argument_list|(
name|r1bindex
argument_list|(
name|empty
argument_list|(
name|ct
operator|->
name|c_file
argument_list|)
argument_list|,
literal|'/'
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%s/%s"
argument_list|,
name|empty
argument_list|(
name|ci
operator|->
name|ci_type
argument_list|)
argument_list|,
name|empty
argument_list|(
name|ci
operator|->
name|ci_subtype
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|LSTFMT2b
argument_list|,
name|empty
argument_list|(
name|ct
operator|->
name|c_partno
argument_list|)
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|size
operator|=
name|ct
operator|->
name|c_cesizefnx
operator|&&
name|sizesw
condition|?
call|(
modifier|*
name|ct
operator|->
name|c_cesizefnx
call|)
argument_list|(
name|ct
argument_list|)
else|:
name|ct
operator|->
name|c_end
operator|-
name|ct
operator|->
name|c_begin
expr_stmt|;
for|for
control|(
name|cp
operator|=
literal|" KMGT"
init|;
name|size
operator|>
literal|9999
condition|;
name|size
operator|>>=
literal|10
control|)
if|if
condition|(
operator|!
operator|*
operator|++
name|cp
condition|)
break|break;
switch|switch
condition|(
operator|*
name|cp
condition|)
block|{
case|case
literal|' '
case|:
if|if
condition|(
name|size
operator|>
literal|0
operator|||
name|ct
operator|->
name|c_encoding
operator|!=
name|CE_EXTERNAL
condition|)
name|printf
argument_list|(
name|LSTFMT2c1
argument_list|,
name|size
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
name|LSTFMT2c4
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
name|LSTFMT2c2
argument_list|,
name|size
argument_list|,
operator|*
name|cp
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\0'
case|:
name|printf
argument_list|(
name|LSTFMT2c3
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ct
operator|->
name|c_descr
condition|)
block|{
name|char
modifier|*
name|dp
decl_stmt|;
name|dp
operator|=
name|trimcpy
argument_list|(
name|cp
operator|=
name|add
argument_list|(
name|ct
operator|->
name|c_descr
argument_list|,
name|NULLCP
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|LSTFMT2d1
argument_list|,
name|dp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dp
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbosw
operator|&&
name|ci
operator|->
name|ci_comment
condition|)
block|{
name|char
modifier|*
name|dp
decl_stmt|;
name|dp
operator|=
name|trimcpy
argument_list|(
name|cp
operator|=
name|add
argument_list|(
name|ci
operator|->
name|ci_comment
argument_list|,
name|NULLCP
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"(%s)"
argument_list|,
name|dp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|LSTFMT2d2
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|debugsw
condition|)
return|return
name|OK
return|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  partno \"%s\"\n"
argument_list|,
name|empty
argument_list|(
name|ct
operator|->
name|c_partno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ct
operator|->
name|c_vrsn
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  %s:%s\n"
argument_list|,
name|VRSN_FIELD
argument_list|,
name|ct
operator|->
name|c_vrsn
argument_list|)
expr_stmt|;
if|if
condition|(
name|ct
operator|->
name|c_ctline
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  %s:%s"
argument_list|,
name|TYPE_FIELD
argument_list|,
name|ct
operator|->
name|c_ctline
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"    type \"%s\"  subtype \"%s\"  comment \"%s\"  magic \"%s\"\n"
argument_list|,
name|empty
argument_list|(
name|ci
operator|->
name|ci_type
argument_list|)
argument_list|,
name|empty
argument_list|(
name|ci
operator|->
name|ci_subtype
argument_list|)
argument_list|,
name|empty
argument_list|(
name|ci
operator|->
name|ci_comment
argument_list|)
argument_list|,
name|empty
argument_list|(
name|ci
operator|->
name|ci_magic
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|ap
operator|=
name|ci
operator|->
name|ci_attrs
operator|,
name|ep
operator|=
name|ci
operator|->
name|ci_values
init|;
operator|*
name|ap
condition|;
name|ap
operator|++
operator|,
name|ep
operator|++
control|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"      parameter %s=\"%s\"\n"
argument_list|,
operator|*
name|ap
argument_list|,
operator|*
name|ep
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"    type 0x%x subtype 0x%x params 0x%x\n"
argument_list|,
name|ct
operator|->
name|c_type
argument_list|,
name|ct
operator|->
name|c_subtype
argument_list|,
name|ct
operator|->
name|c_ctparams
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"     showproc \"%s\"\n"
argument_list|,
name|empty
argument_list|(
name|ct
operator|->
name|c_showproc
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"     termproc \"%s\"\n"
argument_list|,
name|empty
argument_list|(
name|ct
operator|->
name|c_termproc
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"    storeproc \"%s\"\n"
argument_list|,
name|empty
argument_list|(
name|ct
operator|->
name|c_storeproc
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ct
operator|->
name|c_celine
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  %s:%s"
argument_list|,
name|ENCODING_FIELD
argument_list|,
name|ct
operator|->
name|c_celine
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"    encoding 0x%x params 0x%x\n"
argument_list|,
name|ct
operator|->
name|c_encoding
argument_list|,
name|ct
operator|->
name|c_ceparams
argument_list|)
expr_stmt|;
if|if
condition|(
name|ct
operator|->
name|c_id
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  %s:%s"
argument_list|,
name|ID_FIELD
argument_list|,
name|ct
operator|->
name|c_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|ct
operator|->
name|c_descr
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  %s:%s"
argument_list|,
name|DESCR_FIELD
argument_list|,
name|ct
operator|->
name|c_descr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  fp 0x%x file \"%s\" begin %d end %d\n"
argument_list|,
name|ct
operator|->
name|c_fp
argument_list|,
name|empty
argument_list|(
name|ct
operator|->
name|c_file
argument_list|)
argument_list|,
name|ct
operator|->
name|c_begin
argument_list|,
name|ct
operator|->
name|c_end
argument_list|)
expr_stmt|;
if|if
condition|(
name|ct
operator|->
name|c_celistfnx
condition|)
call|(
name|void
call|)
argument_list|(
operator|*
name|ct
operator|->
name|c_celistfnx
argument_list|)
argument_list|(
name|ct
argument_list|)
expr_stmt|;
return|return
name|OK
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|empty
end_undef

begin_comment
comment|/*
comment|*/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|VSPRINTF
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<varargs.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|VSPRINTF
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_decl_stmt
specifier|static
name|void
name|content_error
argument_list|(
name|char
operator|*
name|what
argument_list|,
specifier|register
name|CT
name|ct
argument_list|,
name|char
operator|*
name|fmt
argument_list|,
operator|...
argument_list|)
else|#
directive|else
decl|static
name|void
name|content_error
argument_list|(
name|va_alist
argument_list|)
name|va_dcl
endif|#
directive|endif
else|#
directive|else
comment|/* !VSPRINTF */
comment|/* VARARGS3 */
decl|static
name|void
name|content_error
argument_list|(
name|what
argument_list|,
name|ct
argument_list|,
name|fmt
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|,
name|e
argument_list|,
name|f
argument_list|)
name|char
modifier|*
name|what
decl_stmt|,
modifier|*
name|fmt
decl_stmt|,
modifier|*
name|a
decl_stmt|,
modifier|*
name|b
decl_stmt|,
modifier|*
name|c
decl_stmt|,
modifier|*
name|d
decl_stmt|,
modifier|*
name|e
decl_stmt|,
modifier|*
name|f
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|CT
name|ct
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
ifdef|#
directive|ifdef
name|VSPRINTF
name|va_list
name|arglist
decl_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|VSPRINTF
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__STDC__
argument_list|)
name|char
modifier|*
name|what
decl_stmt|,
modifier|*
name|fmt
decl_stmt|;
specifier|register
name|CT
name|ct
decl_stmt|;
endif|#
directive|endif
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|bp
decl_stmt|;
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
specifier|register
name|CI
name|ci
decl_stmt|;
name|bp
operator|=
name|buffer
expr_stmt|;
if|if
condition|(
name|userrs
operator|&&
name|invo_name
operator|&&
operator|*
name|invo_name
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|bp
argument_list|,
literal|"%s: "
argument_list|,
name|invo_name
argument_list|)
expr_stmt|;
name|bp
operator|+=
name|strlen
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|VSPRINTF
ifdef|#
directive|ifdef
name|__STDC__
name|va_start
argument_list|(
name|arglist
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
else|#
directive|else
name|va_start
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|what
operator|=
name|va_arg
argument_list|(
name|arglist
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
name|ct
operator|=
name|va_arg
argument_list|(
name|arglist
argument_list|,
name|CT
argument_list|)
expr_stmt|;
name|fmt
operator|=
name|va_arg
argument_list|(
name|arglist
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|vsprintf
argument_list|(
name|bp
argument_list|,
name|fmt
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
name|bp
operator|+=
name|strlen
argument_list|(
name|bp
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|bp
argument_list|,
name|fmt
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|,
name|e
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|bp
operator|+=
name|strlen
argument_list|(
name|bp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ci
operator|=
operator|&
name|ct
operator|->
name|c_ctinfo
expr_stmt|;
if|if
condition|(
name|what
condition|)
block|{
if|if
condition|(
operator|*
name|what
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|bp
argument_list|,
literal|" %s: "
argument_list|,
name|what
argument_list|)
expr_stmt|;
name|bp
operator|+=
name|strlen
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|errno
operator|>
literal|0
operator|&&
name|errno
operator|<
name|sys_nerr
condition|)
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|bp
argument_list|,
literal|"%s"
argument_list|,
name|sys_errlist
index|[
name|errno
index|]
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|bp
argument_list|,
literal|"Error %d"
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|bp
operator|+=
name|strlen
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
name|i
operator|=
name|strlen
argument_list|(
name|invo_name
argument_list|)
operator|+
literal|2
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|bp
argument_list|,
literal|"\n%*.*s(content %s/%s"
argument_list|,
name|i
argument_list|,
name|i
argument_list|,
literal|""
argument_list|,
name|ci
operator|->
name|ci_type
argument_list|,
name|ci
operator|->
name|ci_subtype
argument_list|)
expr_stmt|;
name|bp
operator|+=
name|strlen
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ct
operator|->
name|c_file
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|bp
argument_list|,
literal|" in message %s"
argument_list|,
name|ct
operator|->
name|c_file
argument_list|)
expr_stmt|;
name|bp
operator|+=
name|strlen
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ct
operator|->
name|c_partno
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|bp
argument_list|,
literal|", part %s"
argument_list|,
name|ct
operator|->
name|c_partno
argument_list|)
expr_stmt|;
name|bp
operator|+=
name|strlen
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
block|}
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|bp
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
name|bp
operator|+=
name|strlen
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|userrs
condition|)
block|{
operator|*
name|bp
operator|++
operator|=
literal|'\n'
expr_stmt|;
operator|*
name|bp
operator|=
literal|'\0'
expr_stmt|;
name|errs
operator|=
name|add
argument_list|(
name|buffer
argument_list|,
name|errs
argument_list|)
expr_stmt|;
block|}
else|else
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"%s"
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
specifier|static
name|void
name|flush_errors
parameter_list|()
block|{
if|if
condition|(
name|errs
condition|)
block|{
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s"
argument_list|,
name|errs
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|errs
argument_list|)
expr_stmt|;
name|errs
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_decl_stmt
specifier|static
name|jmp_buf
name|intrenv
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|TYPESIG
name|intrser
parameter_list|(
name|i
parameter_list|)
name|int
name|i
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|BSD42
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|intrser
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|longjmp
argument_list|(
name|intrenv
argument_list|,
name|DONE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_decl_stmt
specifier|static
name|int
name|show_content_aux
argument_list|()
decl_stmt|,
name|show_content_aux2
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|show_content
parameter_list|(
name|ct
parameter_list|,
name|serial
parameter_list|,
name|alternate
parameter_list|)
specifier|register
name|CT
name|ct
decl_stmt|;
name|int
name|serial
decl_stmt|,
name|alternate
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
specifier|register
name|CI
name|ci
init|=
operator|&
name|ct
operator|->
name|c_ctinfo
decl_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%s-show-%s/%s"
argument_list|,
name|invo_name
argument_list|,
name|ci
operator|->
name|ci_type
argument_list|,
name|ci
operator|->
name|ci_subtype
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|m_find
argument_list|(
name|buffer
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|*
name|cp
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%s-show-%s"
argument_list|,
name|invo_name
argument_list|,
name|ci
operator|->
name|ci_type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|cp
operator|=
name|m_find
argument_list|(
name|buffer
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|*
name|cp
operator|==
literal|0
operator|)
operator|&&
operator|(
name|cp
operator|=
name|ct
operator|->
name|c_showproc
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|alternate
condition|)
name|content_error
argument_list|(
name|NULLCP
argument_list|,
name|ct
argument_list|,
literal|"don't know how to display content"
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
block|}
return|return
name|show_content_aux
argument_list|(
name|ct
argument_list|,
name|serial
argument_list|,
name|alternate
argument_list|,
name|cp
argument_list|,
name|NULLCP
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|show_content_aux
parameter_list|(
name|ct
parameter_list|,
name|serial
parameter_list|,
name|alternate
parameter_list|,
name|cp
parameter_list|,
name|cracked
parameter_list|)
specifier|register
name|CT
name|ct
decl_stmt|;
name|int
name|serial
decl_stmt|,
name|alternate
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|char
modifier|*
name|cracked
decl_stmt|;
block|{
name|int
name|fd
decl_stmt|,
name|xlist
decl_stmt|,
name|xpause
decl_stmt|,
name|xstdin
decl_stmt|,
name|xtty
decl_stmt|;
specifier|register
name|char
modifier|*
name|bp
decl_stmt|;
name|char
modifier|*
name|file
decl_stmt|,
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
specifier|register
name|CI
name|ci
init|=
operator|&
name|ct
operator|->
name|c_ctinfo
decl_stmt|;
if|if
condition|(
operator|!
name|ct
operator|->
name|c_ceopenfnx
condition|)
block|{
if|if
condition|(
operator|!
name|alternate
condition|)
name|content_error
argument_list|(
name|NULLCP
argument_list|,
name|ct
argument_list|,
literal|"don't know how to decode content"
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
name|file
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
call|(
modifier|*
name|ct
operator|->
name|c_ceopenfnx
call|)
argument_list|(
name|ct
argument_list|,
operator|&
name|file
argument_list|)
operator|)
operator|==
name|NOTOK
condition|)
return|return
name|NOTOK
return|;
if|if
condition|(
name|ct
operator|->
name|c_showproc
operator|&&
name|strcmp
argument_list|(
name|ct
operator|->
name|c_showproc
argument_list|,
literal|"true"
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|alternate
condition|?
name|DONE
else|:
name|OK
operator|)
return|;
name|xlist
operator|=
name|xpause
operator|=
name|xstdin
operator|=
name|xtty
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cracked
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|buffer
argument_list|,
name|cp
argument_list|)
expr_stmt|;
goto|goto
name|got_command
goto|;
block|}
name|buffer
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|bp
operator|=
name|buffer
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
if|if
condition|(
operator|*
name|cp
operator|==
literal|'%'
condition|)
block|{
switch|switch
condition|(
operator|*
operator|++
name|cp
condition|)
block|{
case|case
literal|'a'
case|:
comment|/* additional arguments */
block|{
specifier|register
name|char
modifier|*
modifier|*
name|ap
decl_stmt|,
modifier|*
modifier|*
name|ep
decl_stmt|;
name|char
modifier|*
name|s
init|=
literal|""
decl_stmt|;
for|for
control|(
name|ap
operator|=
name|ci
operator|->
name|ci_attrs
operator|,
name|ep
operator|=
name|ci
operator|->
name|ci_values
init|;
operator|*
name|ap
condition|;
name|ap
operator|++
operator|,
name|ep
operator|++
control|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|bp
argument_list|,
literal|"%s%s=\"%s\""
argument_list|,
name|s
argument_list|,
operator|*
name|ap
argument_list|,
operator|*
name|ep
argument_list|)
expr_stmt|;
name|bp
operator|+=
name|strlen
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|s
operator|=
literal|" "
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'d'
case|:
comment|/* content description */
if|if
condition|(
name|ct
operator|->
name|c_descr
condition|)
block|{
name|char
modifier|*
name|s
decl_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|bp
argument_list|,
name|s
operator|=
name|trimcpy
argument_list|(
name|ct
operator|->
name|c_descr
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'e'
case|:
comment|/* exclusive execution */
name|xtty
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
comment|/* %e, %f, and stdin is terminal not content */
name|xstdin
operator|=
name|xtty
operator|=
literal|1
expr_stmt|;
comment|/* and fall... */
case|case
literal|'f'
case|:
comment|/* filename */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|bp
argument_list|,
literal|"%s"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
comment|/* pause prior to displaying content */
name|xpause
operator|=
name|pausesw
expr_stmt|;
comment|/* and fall... */
case|case
literal|'l'
case|:
comment|/* display listing prior to displaying 				   content */
name|xlist
operator|=
operator|!
name|nolist
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
comment|/* subtype */
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|bp
argument_list|,
name|ci
operator|->
name|ci_subtype
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'%'
case|:
goto|goto
name|raw
goto|;
default|default:
operator|*
name|bp
operator|++
operator|=
operator|*
operator|--
name|cp
expr_stmt|;
operator|*
name|bp
operator|=
literal|'\0'
expr_stmt|;
continue|continue;
block|}
name|bp
operator|+=
name|strlen
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|raw
label|:
empty_stmt|;
operator|*
name|bp
operator|++
operator|=
operator|*
name|cp
expr_stmt|;
operator|*
name|bp
operator|=
literal|'\0'
expr_stmt|;
block|}
if|if
condition|(
name|ct
operator|->
name|c_termproc
condition|)
block|{
name|char
name|term
index|[
name|BUFSIZ
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|term
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buffer
argument_list|,
name|ct
operator|->
name|c_termproc
argument_list|,
name|term
argument_list|)
expr_stmt|;
block|}
name|got_command
label|:
empty_stmt|;
return|return
name|show_content_aux2
argument_list|(
name|ct
argument_list|,
name|serial
argument_list|,
name|alternate
argument_list|,
name|cracked
argument_list|,
name|buffer
argument_list|,
name|fd
argument_list|,
name|xlist
argument_list|,
name|xpause
argument_list|,
name|xstdin
argument_list|,
name|xtty
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|show_content_aux2
parameter_list|(
name|ct
parameter_list|,
name|serial
parameter_list|,
name|alternate
parameter_list|,
name|cracked
parameter_list|,
name|buffer
parameter_list|,
name|fd
parameter_list|,
name|xlist
parameter_list|,
name|xpause
parameter_list|,
name|xstdin
parameter_list|,
name|xtty
parameter_list|)
specifier|register
name|CT
name|ct
decl_stmt|;
name|int
name|serial
decl_stmt|,
name|alternate
decl_stmt|;
name|char
modifier|*
name|cracked
decl_stmt|,
decl|*
name|buffer
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|fd
decl_stmt|,
name|xlist
decl_stmt|,
name|xpause
decl_stmt|,
name|xstdin
decl_stmt|,
name|xtty
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|child_id
decl_stmt|,
name|i
decl_stmt|;
name|char
modifier|*
name|vec
index|[
literal|4
index|]
decl_stmt|,
name|exec
index|[
name|BUFSIZ
operator|+
sizeof|sizeof
decl|"exec "]
decl_stmt|;
specifier|register
name|CI
name|ci
init|=
operator|&
name|ct
operator|->
name|c_ctinfo
decl_stmt|;
if|if
condition|(
name|debugsw
operator|||
name|cracked
condition|)
block|{
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s msg %s"
argument_list|,
name|cracked
condition|?
literal|"storing"
else|:
literal|"show"
argument_list|,
name|ct
operator|->
name|c_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|ct
operator|->
name|c_partno
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" part %s"
argument_list|,
name|ct
operator|->
name|c_partno
argument_list|)
expr_stmt|;
if|if
condition|(
name|cracked
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" using command (cd %s; %s)\n"
argument_list|,
name|cracked
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" using command %s\n"
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|xpid
operator|<
literal|0
operator|||
operator|(
name|xtty
operator|&&
name|xpid
operator|)
condition|)
block|{
if|if
condition|(
name|xpid
operator|<
literal|0
condition|)
name|xpid
operator|=
operator|-
name|xpid
expr_stmt|;
operator|(
name|void
operator|)
name|pidcheck
argument_list|(
name|pidwait
argument_list|(
name|xpid
argument_list|,
name|NOTOK
argument_list|)
argument_list|)
expr_stmt|;
name|xpid
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|xlist
condition|)
block|{
name|char
name|prompt
index|[
name|BUFSIZ
index|]
decl_stmt|;
if|if
condition|(
name|ct
operator|->
name|c_ctlistfnx
condition|)
block|{
if|if
condition|(
name|ct
operator|->
name|c_type
operator|==
name|CT_MULTIPART
condition|)
operator|(
name|void
operator|)
name|list_content
argument_list|(
name|ct
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
else|else
call|(
modifier|*
name|ct
operator|->
name|c_ctlistfnx
call|)
argument_list|(
name|ct
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|xpause
operator|&&
name|SOprintf
argument_list|(
literal|"Press<return> to show content..."
argument_list|)
condition|)
name|printf
argument_list|(
literal|"Press<return> to show content..."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|register
name|char
modifier|*
name|pp
decl_stmt|;
name|pp
operator|=
name|prompt
expr_stmt|;
if|if
condition|(
name|ct
operator|->
name|c_descr
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|pp
argument_list|,
literal|"%s ("
argument_list|,
name|ct
operator|->
name|c_descr
argument_list|)
expr_stmt|;
name|pp
operator|+=
name|strlen
argument_list|(
name|pp
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|pp
argument_list|,
literal|"content %s/%s"
argument_list|,
name|ci
operator|->
name|ci_type
argument_list|,
name|ci
operator|->
name|ci_subtype
argument_list|)
expr_stmt|;
name|pp
operator|+=
name|strlen
argument_list|(
name|pp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ct
operator|->
name|c_file
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|pp
argument_list|,
literal|" in message %s"
argument_list|,
name|ct
operator|->
name|c_file
argument_list|)
expr_stmt|;
name|pp
operator|+=
name|strlen
argument_list|(
name|pp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ct
operator|->
name|c_partno
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|pp
argument_list|,
literal|", part %s"
argument_list|,
name|ct
operator|->
name|c_partno
argument_list|)
expr_stmt|;
name|pp
operator|+=
name|strlen
argument_list|(
name|pp
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ct
operator|->
name|c_descr
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|pp
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
name|pp
operator|+=
name|strlen
argument_list|(
name|pp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|xpause
condition|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|prompt
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|SOprintf
argument_list|(
literal|"Press<return> to show %s..."
argument_list|,
name|prompt
argument_list|)
condition|)
name|printf
argument_list|(
literal|"Press<return> to show %s..."
argument_list|,
name|prompt
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|xpause
condition|)
block|{
name|int
name|intr
decl_stmt|;
name|TYPESIG
function_decl|(
modifier|*
name|istat
function_decl|)
parameter_list|()
function_decl|;
name|istat
operator|=
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|intrser
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|intr
operator|=
name|setjmp
argument_list|(
name|intrenv
argument_list|)
operator|)
operator|==
name|OK
condition|)
block|{
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|prompt
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|read
argument_list|(
name|fileno
argument_list|(
name|stdout
argument_list|)
argument_list|,
name|prompt
argument_list|,
sizeof|sizeof
name|prompt
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|istat
argument_list|)
expr_stmt|;
if|if
condition|(
name|intr
operator|!=
name|OK
condition|)
block|{
call|(
name|void
call|)
argument_list|(
operator|*
name|ct
operator|->
name|c_ceclosefnx
argument_list|)
argument_list|(
name|ct
argument_list|)
expr_stmt|;
return|return
operator|(
name|alternate
condition|?
name|DONE
else|:
name|NOTOK
operator|)
return|;
block|}
block|}
block|}
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|exec
argument_list|,
literal|"exec %s"
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|vec
index|[
literal|0
index|]
operator|=
literal|"/bin/sh"
expr_stmt|;
name|vec
index|[
literal|1
index|]
operator|=
literal|"-c"
expr_stmt|;
name|vec
index|[
literal|2
index|]
operator|=
name|exec
expr_stmt|;
name|vec
index|[
literal|3
index|]
operator|=
name|NULL
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|child_id
operator|=
name|vfork
argument_list|()
operator|)
operator|==
name|NOTOK
operator|&&
name|i
operator|<
literal|5
condition|;
name|i
operator|++
control|)
name|sleep
argument_list|(
literal|5
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|child_id
condition|)
block|{
case|case
name|NOTOK
case|:
name|advise
argument_list|(
literal|"fork"
argument_list|,
literal|"unable to"
argument_list|)
expr_stmt|;
call|(
name|void
call|)
argument_list|(
operator|*
name|ct
operator|->
name|c_ceclosefnx
argument_list|)
argument_list|(
name|ct
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
case|case
name|OK
case|:
if|if
condition|(
name|cracked
condition|)
operator|(
name|void
operator|)
name|chdir
argument_list|(
name|cracked
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|xstdin
condition|)
operator|(
name|void
operator|)
name|dup2
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|execvp
argument_list|(
literal|"/bin/sh"
argument_list|,
name|vec
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"unable to exec "
argument_list|)
expr_stmt|;
name|perror
argument_list|(
literal|"/bin/sh"
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
default|default:
if|if
condition|(
operator|!
name|serial
condition|)
block|{
name|ct
operator|->
name|c_pid
operator|=
name|child_id
expr_stmt|;
if|if
condition|(
name|xtty
condition|)
name|xpid
operator|=
name|child_id
expr_stmt|;
block|}
else|else
operator|(
name|void
operator|)
name|pidcheck
argument_list|(
name|pidXwait
argument_list|(
name|child_id
argument_list|,
name|NULLCP
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|!=
name|NOTOK
condition|)
call|(
name|void
call|)
argument_list|(
operator|*
name|ct
operator|->
name|c_ceclosefnx
argument_list|)
argument_list|(
name|ct
argument_list|)
expr_stmt|;
return|return
operator|(
name|alternate
condition|?
name|DONE
else|:
name|OK
operator|)
return|;
block|}
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|store_content
parameter_list|(
name|ct
parameter_list|,
name|append
parameter_list|)
specifier|register
name|CT
name|ct
decl_stmt|;
name|char
modifier|*
name|append
decl_stmt|;
block|{
name|int
name|appending
init|=
name|append
operator|&&
operator|*
name|append
decl_stmt|;
name|long
name|last
decl_stmt|,
name|pos
decl_stmt|;
specifier|register
name|char
modifier|*
name|bp
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
name|char
modifier|*
name|file
decl_stmt|,
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
specifier|register
name|CI
name|ci
init|=
operator|&
name|ct
operator|->
name|c_ctinfo
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
if|if
condition|(
name|appending
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|buffer
argument_list|,
name|append
argument_list|)
expr_stmt|;
goto|goto
name|got_filename
goto|;
block|}
if|if
condition|(
operator|(
name|cp
operator|=
name|ct
operator|->
name|c_storeproc
operator|)
operator|==
name|NULL
operator|||
operator|*
name|cp
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%s-store-%s/%s"
argument_list|,
name|invo_name
argument_list|,
name|ci
operator|->
name|ci_type
argument_list|,
name|ci
operator|->
name|ci_subtype
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|m_find
argument_list|(
name|buffer
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|*
name|cp
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%s-store-%s"
argument_list|,
name|invo_name
argument_list|,
name|ci
operator|->
name|ci_type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|m_find
argument_list|(
name|buffer
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|*
name|cp
operator|==
literal|0
condition|)
name|cp
operator|=
name|ct
operator|->
name|c_type
operator|==
name|CT_MESSAGE
condition|?
literal|"+"
else|:
literal|"%m%P.%s"
expr_stmt|;
block|}
block|}
switch|switch
condition|(
operator|*
name|cp
condition|)
block|{
case|case
literal|'+'
case|:
case|case
literal|'@'
case|:
block|{
name|char
modifier|*
name|folder
init|=
name|cp
index|[
literal|1
index|]
condition|?
name|path
argument_list|(
name|cp
operator|+
literal|1
argument_list|,
operator|*
name|cp
operator|==
literal|'+'
condition|?
name|TFOLDER
else|:
name|TSUBCWF
argument_list|)
else|:
name|m_getfolder
argument_list|()
decl_stmt|;
name|struct
name|msgs
modifier|*
name|mp
init|=
name|NULL
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|bp
operator|=
name|m_mailpath
argument_list|(
name|folder
argument_list|)
argument_list|,
operator|&
name|st
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
name|int
name|answer
decl_stmt|;
name|char
modifier|*
name|ep
decl_stmt|;
if|if
condition|(
name|errno
operator|!=
name|ENOENT
condition|)
block|{
name|advise
argument_list|(
name|bp
argument_list|,
literal|"error on folder"
argument_list|)
expr_stmt|;
goto|goto
name|losing_folder
goto|;
block|}
name|ep
operator|=
name|concat
argument_list|(
literal|"Create folder \""
argument_list|,
name|bp
argument_list|,
literal|"\"? "
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
name|answer
operator|=
name|getanswer
argument_list|(
name|ep
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ep
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|answer
condition|)
goto|goto
name|losing_folder
goto|;
if|if
condition|(
operator|!
name|makedir
argument_list|(
name|bp
argument_list|)
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"unable to create folder %s"
argument_list|,
name|bp
argument_list|)
expr_stmt|;
goto|goto
name|losing_folder
goto|;
block|}
block|}
if|if
condition|(
name|mp
operator|=
name|m_gmsg
argument_list|(
name|folder
argument_list|)
condition|)
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%s/%d"
argument_list|,
name|mp
operator|->
name|foldpath
argument_list|,
name|mp
operator|->
name|hghmsg
operator|+
literal|1
argument_list|)
expr_stmt|;
else|else
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"unable to read folder %s"
argument_list|,
name|folder
argument_list|)
expr_stmt|;
name|losing_folder
label|:
empty_stmt|;
if|if
condition|(
name|cp
index|[
literal|1
index|]
condition|)
name|free
argument_list|(
name|folder
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
condition|)
name|m_fmsg
argument_list|(
name|mp
argument_list|)
expr_stmt|;
else|else
return|return
name|NOTOK
return|;
block|}
goto|goto
name|got_filename
goto|;
case|case
literal|'/'
case|:
case|case
literal|'|'
case|:
case|case
literal|'!'
case|:
name|bp
operator|=
name|buffer
expr_stmt|;
name|buffer
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
break|break;
default|default:
name|bp
operator|=
name|autosw
condition|?
name|cwd
else|:
name|dir
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%s/"
argument_list|,
name|bp
index|[
literal|1
index|]
condition|?
name|bp
else|:
literal|""
argument_list|)
expr_stmt|;
name|bp
operator|=
name|buffer
operator|+
name|strlen
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
break|break;
block|}
for|for
control|(
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
if|if
condition|(
operator|*
name|cp
operator|==
literal|'%'
condition|)
block|{
switch|switch
condition|(
operator|*
operator|++
name|cp
condition|)
block|{
case|case
literal|'a'
case|:
comment|/* additional arguments */
if|if
condition|(
name|buffer
index|[
literal|0
index|]
operator|!=
literal|'|'
operator|&&
name|buffer
index|[
literal|0
index|]
operator|!=
literal|'!'
condition|)
block|{
operator|*
name|bp
operator|++
operator|=
operator|*
operator|--
name|cp
expr_stmt|;
operator|*
name|bp
operator|=
literal|'\0'
expr_stmt|;
continue|continue;
block|}
else|else
block|{
specifier|register
name|char
modifier|*
modifier|*
name|ap
decl_stmt|,
modifier|*
modifier|*
name|ep
decl_stmt|;
name|char
modifier|*
name|s
init|=
literal|""
decl_stmt|;
for|for
control|(
name|ap
operator|=
name|ci
operator|->
name|ci_attrs
operator|,
name|ep
operator|=
name|ci
operator|->
name|ci_values
init|;
operator|*
name|ap
condition|;
name|ap
operator|++
operator|,
name|ep
operator|++
control|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|bp
argument_list|,
literal|"%s%s=\"%s\""
argument_list|,
name|s
argument_list|,
operator|*
name|ap
argument_list|,
operator|*
name|ep
argument_list|)
expr_stmt|;
name|bp
operator|+=
name|strlen
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|s
operator|=
literal|" "
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'m'
case|:
comment|/* message */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|bp
argument_list|,
literal|"%s"
argument_list|,
name|r1bindex
argument_list|(
name|ct
operator|->
name|c_file
argument_list|,
literal|'/'
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
comment|/* .part */
if|if
condition|(
name|ct
operator|->
name|c_partno
condition|)
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|bp
argument_list|,
literal|".%s"
argument_list|,
name|ct
operator|->
name|c_partno
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
comment|/* part */
if|if
condition|(
name|ct
operator|->
name|c_partno
condition|)
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|bp
argument_list|,
name|ct
operator|->
name|c_partno
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
comment|/* type */
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|bp
argument_list|,
name|ci
operator|->
name|ci_type
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
comment|/* subtype */
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|bp
argument_list|,
name|ci
operator|->
name|ci_subtype
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'%'
case|:
goto|goto
name|raw
goto|;
default|default:
operator|*
name|bp
operator|++
operator|=
operator|*
operator|--
name|cp
expr_stmt|;
operator|*
name|bp
operator|=
literal|'\0'
expr_stmt|;
continue|continue;
block|}
name|bp
operator|+=
name|strlen
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|raw
label|:
empty_stmt|;
operator|*
name|bp
operator|++
operator|=
operator|*
name|cp
expr_stmt|;
operator|*
name|bp
operator|=
literal|'\0'
expr_stmt|;
block|}
if|if
condition|(
name|buffer
index|[
literal|0
index|]
operator|==
literal|'|'
operator|||
name|buffer
index|[
literal|0
index|]
operator|==
literal|'!'
condition|)
return|return
name|show_content_aux
argument_list|(
name|ct
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|buffer
operator|+
literal|1
argument_list|,
name|autosw
condition|?
name|cwd
else|:
name|dir
argument_list|)
return|;
name|got_filename
label|:
empty_stmt|;
name|ct
operator|->
name|c_storage
operator|=
name|add
argument_list|(
name|buffer
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"storing message %s"
argument_list|,
name|ct
operator|->
name|c_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|ct
operator|->
name|c_partno
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" part %s"
argument_list|,
name|ct
operator|->
name|c_partno
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" as file %s\n"
argument_list|,
name|strncmp
argument_list|(
name|ct
operator|->
name|c_storage
argument_list|,
name|cwd
argument_list|,
name|cwdlen
argument_list|)
operator|||
name|ct
operator|->
name|c_storage
index|[
name|cwdlen
index|]
operator|!=
literal|'/'
condition|?
name|ct
operator|->
name|c_storage
else|:
name|ct
operator|->
name|c_storage
operator|+
name|cwdlen
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
argument_list|(
name|ct
operator|->
name|c_storage
argument_list|,
literal|'/'
argument_list|)
operator|&&
name|make_intermediates
argument_list|(
name|ct
operator|->
name|c_storage
argument_list|)
operator|==
name|NOTOK
condition|)
return|return
name|NOTOK
return|;
if|if
condition|(
name|ct
operator|->
name|c_encoding
operator|!=
name|CE_7BIT
condition|)
block|{
name|int
name|cc
decl_stmt|,
name|fd
decl_stmt|;
if|if
condition|(
operator|!
name|ct
operator|->
name|c_ceopenfnx
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"don't know how to decode part %s of message %s"
argument_list|,
name|ct
operator|->
name|c_partno
argument_list|,
name|ct
operator|->
name|c_file
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
name|file
operator|=
name|appending
operator|||
operator|!
name|strcmp
argument_list|(
name|ct
operator|->
name|c_storage
argument_list|,
literal|"-"
argument_list|)
condition|?
name|NULLCP
else|:
name|ct
operator|->
name|c_storage
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
call|(
modifier|*
name|ct
operator|->
name|c_ceopenfnx
call|)
argument_list|(
name|ct
argument_list|,
operator|&
name|file
argument_list|)
operator|)
operator|==
name|NOTOK
condition|)
return|return
name|NOTOK
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|file
argument_list|,
name|ct
operator|->
name|c_storage
argument_list|)
operator|==
literal|0
condition|)
block|{
call|(
name|void
call|)
argument_list|(
operator|*
name|ct
operator|->
name|c_ceclosefnx
argument_list|)
argument_list|(
name|ct
argument_list|)
expr_stmt|;
return|return
name|OK
return|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ct
operator|->
name|c_storage
argument_list|,
literal|"-"
argument_list|)
condition|)
block|{
name|int
name|gd
decl_stmt|;
if|if
condition|(
operator|(
name|gd
operator|=
name|dup
argument_list|(
name|fileno
argument_list|(
name|stdout
argument_list|)
argument_list|)
operator|)
operator|==
name|NOTOK
condition|)
block|{
name|advise
argument_list|(
literal|"stdout"
argument_list|,
literal|"unable to dup"
argument_list|)
expr_stmt|;
name|losing
label|:
empty_stmt|;
call|(
name|void
call|)
argument_list|(
operator|*
name|ct
operator|->
name|c_ceclosefnx
argument_list|)
argument_list|(
name|ct
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
if|if
condition|(
operator|(
name|fp
operator|=
name|fdopen
argument_list|(
name|gd
argument_list|,
name|appending
condition|?
literal|"a"
else|:
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|advise
argument_list|(
literal|"stdout"
argument_list|,
literal|"unable to fdopen (%d, \"%s\") from"
argument_list|,
name|gd
argument_list|,
name|appending
condition|?
literal|"a"
else|:
literal|"w"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|gd
argument_list|)
expr_stmt|;
goto|goto
name|losing
goto|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|ct
operator|->
name|c_storage
argument_list|,
name|appending
condition|?
literal|"a"
else|:
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|advise
argument_list|(
name|ct
operator|->
name|c_storage
argument_list|,
literal|"unable to fopen for %s"
argument_list|,
name|appending
condition|?
literal|"appending"
else|:
literal|"writing"
argument_list|)
expr_stmt|;
goto|goto
name|losing
goto|;
block|}
if|if
condition|(
name|append
operator|&&
operator|!
operator|*
name|append
condition|)
operator|(
name|void
operator|)
name|copy_some_headers
argument_list|(
name|fp
argument_list|,
name|ct
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
switch|switch
condition|(
name|cc
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|buffer
argument_list|,
sizeof|sizeof
name|buffer
argument_list|)
condition|)
block|{
case|case
name|NOTOK
case|:
name|advise
argument_list|(
name|file
argument_list|,
literal|"error reading content from"
argument_list|)
expr_stmt|;
break|break;
case|case
name|OK
case|:
break|break;
default|default:
operator|(
name|void
operator|)
name|fwrite
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
expr|*
name|buffer
argument_list|,
name|cc
argument_list|,
name|fp
argument_list|)
expr_stmt|;
continue|continue;
block|}
break|break;
block|}
call|(
name|void
call|)
argument_list|(
operator|*
name|ct
operator|->
name|c_ceclosefnx
argument_list|)
argument_list|(
name|ct
argument_list|)
expr_stmt|;
if|if
condition|(
name|cc
operator|!=
name|NOTOK
operator|&&
name|fflush
argument_list|(
name|fp
argument_list|)
condition|)
name|advise
argument_list|(
name|ct
operator|->
name|c_storage
argument_list|,
literal|"error writing to"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return
operator|(
name|cc
operator|!=
name|NOTOK
condition|?
name|OK
else|:
name|NOTOK
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|ct
operator|->
name|c_fp
operator|&&
operator|(
name|ct
operator|->
name|c_fp
operator|=
name|fopen
argument_list|(
name|ct
operator|->
name|c_file
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|advise
argument_list|(
name|ct
operator|->
name|c_file
argument_list|,
literal|"unable to open for reading"
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
operator|(
name|void
operator|)
name|fseek
argument_list|(
name|ct
operator|->
name|c_fp
argument_list|,
name|pos
operator|=
name|ct
operator|->
name|c_begin
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|last
operator|=
name|ct
operator|->
name|c_end
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ct
operator|->
name|c_storage
argument_list|,
literal|"-"
argument_list|)
condition|)
block|{
name|int
name|gd
decl_stmt|;
if|if
condition|(
operator|(
name|gd
operator|=
name|dup
argument_list|(
name|fileno
argument_list|(
name|stdout
argument_list|)
argument_list|)
operator|)
operator|==
name|NOTOK
condition|)
block|{
name|advise
argument_list|(
literal|"stdout"
argument_list|,
literal|"unable to dup"
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
if|if
condition|(
operator|(
name|fp
operator|=
name|fdopen
argument_list|(
name|gd
argument_list|,
name|appending
condition|?
literal|"a"
else|:
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|advise
argument_list|(
literal|"stdout"
argument_list|,
literal|"unable to fdopen (%d, \"%s\") from"
argument_list|,
name|gd
argument_list|,
name|appending
condition|?
literal|"a"
else|:
literal|"w"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|gd
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|ct
operator|->
name|c_storage
argument_list|,
name|appending
condition|?
literal|"a"
else|:
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|advise
argument_list|(
name|ct
operator|->
name|c_storage
argument_list|,
literal|"unable to fopen for %s"
argument_list|,
name|appending
condition|?
literal|"appending"
else|:
literal|"writing"
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
if|if
condition|(
name|append
operator|&&
operator|!
operator|*
name|append
condition|)
block|{
operator|(
name|void
operator|)
name|copy_some_headers
argument_list|(
name|fp
argument_list|,
name|ct
argument_list|)
expr_stmt|;
name|appending
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|appending
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
name|buffer
operator|-
literal|1
argument_list|,
name|ct
operator|->
name|c_fp
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|pos
operator|+=
name|strlen
argument_list|(
name|buffer
argument_list|)
operator|)
operator|>
name|last
condition|)
block|{
name|int
name|diff
init|=
name|strlen
argument_list|(
name|buffer
argument_list|)
operator|-
operator|(
name|pos
operator|-
name|last
operator|)
decl_stmt|;
if|if
condition|(
name|diff
operator|>=
literal|0
condition|)
name|buffer
index|[
name|diff
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
if|if
condition|(
name|appending
condition|)
switch|switch
condition|(
name|buffer
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|' '
case|:
case|case
literal|'\t'
case|:
if|if
condition|(
name|appending
operator|<
literal|0
condition|)
name|buffer
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'\n'
case|:
name|appending
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
if|if
condition|(
operator|!
name|uprf
argument_list|(
name|buffer
argument_list|,
name|XXX_FIELD_PRF
argument_list|)
operator|&&
operator|!
name|uprf
argument_list|(
name|buffer
argument_list|,
literal|"Encrypted:"
argument_list|)
operator|&&
operator|!
name|uprf
argument_list|(
name|buffer
argument_list|,
literal|"Message-ID:"
argument_list|)
condition|)
block|{
name|appending
operator|=
operator|-
literal|1
expr_stmt|;
name|buffer
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|appending
operator|=
literal|1
expr_stmt|;
break|break;
block|}
operator|(
name|void
operator|)
name|fputs
argument_list|(
name|buffer
argument_list|,
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|>=
name|last
condition|)
break|break;
block|}
if|if
condition|(
name|fflush
argument_list|(
name|fp
argument_list|)
condition|)
name|advise
argument_list|(
name|ct
operator|->
name|c_storage
argument_list|,
literal|"error writing to"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|ct
operator|->
name|c_fp
argument_list|)
operator|,
name|ct
operator|->
name|c_fp
operator|=
name|NULL
expr_stmt|;
return|return
name|OK
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|copy_some_headers
parameter_list|(
name|out
parameter_list|,
name|ct
parameter_list|)
name|FILE
modifier|*
name|out
decl_stmt|;
specifier|register
name|CT
name|ct
decl_stmt|;
block|{
name|int
name|state
decl_stmt|;
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|,
name|name
index|[
name|NAMESZ
index|]
decl_stmt|;
name|FILE
modifier|*
name|in
decl_stmt|;
if|if
condition|(
operator|(
name|in
operator|=
name|fopen
argument_list|(
name|ct
operator|->
name|c_file
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|advise
argument_list|(
name|ct
operator|->
name|c_file
argument_list|,
literal|"unable to open for reading"
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
for|for
control|(
name|state
operator|=
name|FLD
init|;
condition|;
control|)
block|{
switch|switch
condition|(
name|state
operator|=
name|m_getfld
argument_list|(
name|state
argument_list|,
name|name
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|in
argument_list|)
condition|)
block|{
case|case
name|FLD
case|:
case|case
name|FLDPLUS
case|:
case|case
name|FLDEOF
case|:
if|if
condition|(
name|uprf
argument_list|(
name|name
argument_list|,
name|XXX_FIELD_PRF
argument_list|)
operator|||
name|uleq
argument_list|(
name|name
argument_list|,
literal|"Encrypted"
argument_list|)
operator|||
name|uleq
argument_list|(
name|name
argument_list|,
literal|"Message-ID"
argument_list|)
condition|)
block|{
while|while
condition|(
name|state
operator|==
name|FLDPLUS
condition|)
name|state
operator|=
name|m_getfld
argument_list|(
name|state
argument_list|,
name|name
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|in
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"%s:%s"
argument_list|,
name|name
argument_list|,
name|buf
argument_list|)
expr_stmt|;
while|while
condition|(
name|state
operator|==
name|FLDPLUS
condition|)
block|{
name|state
operator|=
name|m_getfld
argument_list|(
name|state
argument_list|,
name|name
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|in
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fputs
argument_list|(
name|buf
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|state
operator|!=
name|FLDEOF
condition|)
continue|continue;
comment|/* else fall... */
case|case
name|BODY
case|:
case|case
name|BODYEOF
case|:
case|case
name|FILEEOF
case|:
break|break;
case|case
name|LENERR
case|:
case|case
name|FMTERR
case|:
default|default:
break|break;
block|}
break|break;
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|in
argument_list|)
expr_stmt|;
return|return
name|OK
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|make_intermediates
parameter_list|(
name|file
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
for|for
control|(
name|cp
operator|=
name|file
operator|+
literal|1
init|;
name|cp
operator|=
name|index
argument_list|(
name|cp
argument_list|,
literal|'/'
argument_list|)
condition|;
name|cp
operator|++
control|)
block|{
name|struct
name|stat
name|st
decl_stmt|;
operator|*
name|cp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|file
argument_list|,
operator|&
name|st
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
name|int
name|answer
decl_stmt|;
name|char
modifier|*
name|ep
decl_stmt|;
if|if
condition|(
name|errno
operator|!=
name|ENOENT
condition|)
block|{
name|advise
argument_list|(
name|file
argument_list|,
literal|"error on directory"
argument_list|)
expr_stmt|;
name|losing_directory
label|:
empty_stmt|;
operator|*
name|cp
operator|=
literal|'/'
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
name|ep
operator|=
name|concat
argument_list|(
literal|"Create directory \""
argument_list|,
name|file
argument_list|,
literal|"\"? "
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
name|answer
operator|=
name|getanswer
argument_list|(
name|ep
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ep
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|answer
condition|)
goto|goto
name|losing_directory
goto|;
if|if
condition|(
operator|!
name|makedir
argument_list|(
name|file
argument_list|)
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"unable to create directory %s"
argument_list|,
name|file
argument_list|)
expr_stmt|;
goto|goto
name|losing_directory
goto|;
block|}
block|}
operator|*
name|cp
operator|=
literal|'/'
expr_stmt|;
block|}
return|return
name|OK
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|void
name|free_ctinfo
parameter_list|(
name|ct
parameter_list|)
specifier|register
name|CT
name|ct
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
modifier|*
name|ap
decl_stmt|;
specifier|register
name|CI
name|ci
init|=
operator|&
name|ct
operator|->
name|c_ctinfo
decl_stmt|;
if|if
condition|(
name|ci
operator|->
name|ci_type
condition|)
name|free
argument_list|(
name|ci
operator|->
name|ci_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|ci
operator|->
name|ci_subtype
condition|)
name|free
argument_list|(
name|ci
operator|->
name|ci_subtype
argument_list|)
expr_stmt|;
for|for
control|(
name|ap
operator|=
name|ci
operator|->
name|ci_attrs
init|;
operator|*
name|ap
condition|;
name|ap
operator|++
control|)
name|free
argument_list|(
operator|*
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
name|ci
operator|->
name|ci_comment
condition|)
name|free
argument_list|(
name|ci
operator|->
name|ci_comment
argument_list|)
expr_stmt|;
if|if
condition|(
name|ci
operator|->
name|ci_magic
condition|)
name|free
argument_list|(
name|ci
operator|->
name|ci_magic
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|free_content
parameter_list|(
name|ct
parameter_list|)
specifier|register
name|CT
name|ct
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|ct
condition|)
return|return;
if|if
condition|(
name|ct
operator|->
name|c_partno
condition|)
name|free
argument_list|(
name|ct
operator|->
name|c_partno
argument_list|)
expr_stmt|;
if|if
condition|(
name|ct
operator|->
name|c_vrsn
condition|)
name|free
argument_list|(
name|ct
operator|->
name|c_vrsn
argument_list|)
expr_stmt|;
if|if
condition|(
name|ct
operator|->
name|c_ctline
condition|)
name|free
argument_list|(
name|ct
operator|->
name|c_ctline
argument_list|)
expr_stmt|;
name|free_ctinfo
argument_list|(
name|ct
argument_list|)
expr_stmt|;
if|if
condition|(
name|ct
operator|->
name|c_ctfreefnx
condition|)
call|(
name|void
call|)
argument_list|(
operator|*
name|ct
operator|->
name|c_ctfreefnx
argument_list|)
argument_list|(
name|ct
argument_list|)
expr_stmt|;
if|if
condition|(
name|ct
operator|->
name|c_showproc
condition|)
name|free
argument_list|(
name|ct
operator|->
name|c_showproc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ct
operator|->
name|c_termproc
condition|)
name|free
argument_list|(
name|ct
operator|->
name|c_termproc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ct
operator|->
name|c_storeproc
condition|)
name|free
argument_list|(
name|ct
operator|->
name|c_storeproc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ct
operator|->
name|c_celine
condition|)
name|free
argument_list|(
name|ct
operator|->
name|c_celine
argument_list|)
expr_stmt|;
if|if
condition|(
name|ct
operator|->
name|c_cefreefnx
condition|)
call|(
name|void
call|)
argument_list|(
operator|*
name|ct
operator|->
name|c_cefreefnx
argument_list|)
argument_list|(
name|ct
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ct
operator|->
name|c_id
condition|)
name|free
argument_list|(
name|ct
operator|->
name|c_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|ct
operator|->
name|c_descr
condition|)
name|free
argument_list|(
name|ct
operator|->
name|c_descr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ct
operator|->
name|c_file
condition|)
block|{
if|if
condition|(
name|ct
operator|->
name|c_unlink
condition|)
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|ct
operator|->
name|c_file
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ct
operator|->
name|c_file
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ct
operator|->
name|c_fp
condition|)
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|ct
operator|->
name|c_fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ct
operator|->
name|c_storage
condition|)
operator|(
name|void
operator|)
name|free
argument_list|(
name|ct
operator|->
name|c_storage
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ct
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|part_ok
parameter_list|(
name|ct
parameter_list|,
name|sP
parameter_list|)
specifier|register
name|CT
name|ct
decl_stmt|;
name|int
name|sP
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
modifier|*
name|ap
decl_stmt|;
if|if
condition|(
operator|(
name|ct
operator|->
name|c_type
operator|==
name|CT_MULTIPART
operator|&&
operator|(
name|sP
operator|||
name|ct
operator|->
name|c_subtype
operator|)
operator|)
operator|||
name|npart
operator|==
literal|0
condition|)
return|return
literal|1
return|;
for|for
control|(
name|ap
operator|=
name|parts
init|;
operator|*
name|ap
condition|;
name|ap
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|ap
argument_list|,
name|ct
operator|->
name|c_partno
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|type_ok
parameter_list|(
name|ct
parameter_list|,
name|sP
parameter_list|)
specifier|register
name|CT
name|ct
decl_stmt|;
name|int
name|sP
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
modifier|*
name|ap
decl_stmt|;
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
specifier|register
name|CI
name|ci
init|=
operator|&
name|ct
operator|->
name|c_ctinfo
decl_stmt|;
if|if
condition|(
operator|(
name|ct
operator|->
name|c_type
operator|==
name|CT_MULTIPART
operator|&&
operator|(
name|sP
operator|||
name|ct
operator|->
name|c_subtype
operator|)
operator|)
operator|||
name|ntype
operator|==
literal|0
condition|)
return|return
literal|1
return|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%s/%s"
argument_list|,
name|ci
operator|->
name|ci_type
argument_list|,
name|ci
operator|->
name|ci_subtype
argument_list|)
expr_stmt|;
for|for
control|(
name|ap
operator|=
name|types
init|;
operator|*
name|ap
condition|;
name|ap
operator|++
control|)
if|if
condition|(
name|uleq
argument_list|(
operator|*
name|ap
argument_list|,
name|ci
operator|->
name|ci_type
argument_list|)
operator|||
name|uleq
argument_list|(
operator|*
name|ap
argument_list|,
name|buffer
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*
comment|CONTENTS */
end_comment

begin_struct
struct|struct
name|k2v
block|{
name|char
modifier|*
name|kv_key
decl_stmt|;
name|int
name|kv_value
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|InitGeneric
parameter_list|(
name|ct
parameter_list|)
specifier|register
name|CT
name|ct
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
modifier|*
name|ap
decl_stmt|,
modifier|*
modifier|*
name|ep
decl_stmt|;
specifier|register
name|CI
name|ci
init|=
operator|&
name|ct
operator|->
name|c_ctinfo
decl_stmt|;
for|for
control|(
name|ap
operator|=
name|ci
operator|->
name|ci_attrs
operator|,
name|ep
operator|=
name|ci
operator|->
name|ci_values
init|;
operator|*
name|ap
condition|;
name|ap
operator|++
operator|,
name|ep
operator|++
control|)
if|if
condition|(
name|autosw
operator|&&
operator|!
name|ct
operator|->
name|c_storeproc
operator|&&
name|uleq
argument_list|(
operator|*
name|ap
argument_list|,
literal|"x-name"
argument_list|)
condition|)
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
operator|*
operator|(
name|cp
operator|=
operator|*
name|ep
operator|)
operator|!=
literal|'/'
operator|&&
operator|*
name|cp
operator|!=
literal|'.'
operator|&&
operator|*
name|cp
operator|!=
literal|'|'
operator|&&
operator|*
name|cp
operator|!=
literal|'!'
operator|&&
operator|!
name|index
argument_list|(
name|cp
argument_list|,
literal|'%'
argument_list|)
condition|)
name|ct
operator|->
name|c_storeproc
operator|=
name|add
argument_list|(
name|cp
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
block|}
return|return
name|OK
return|;
block|}
end_function

begin_comment
comment|/*
comment|TEXT */
end_comment

begin_define
define|#
directive|define
name|TEXT_UNKNOWN
value|0x00
end_define

begin_define
define|#
directive|define
name|TEXT_PLAIN
value|0x01
end_define

begin_define
define|#
directive|define
name|TEXT_RICHTEXT
value|0x02
end_define

begin_struct
struct|struct
name|text
block|{
name|int
name|tx_charset
decl_stmt|;
define|#
directive|define
name|CHARSET_UNKNOWN
value|0x00
define|#
directive|define
name|CHARSET_USASCII
value|0x01
define|#
directive|define
name|CHARSET_LATIN
value|0x02
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|k2v
name|Charset
index|[]
init|=
block|{
literal|"us-ascii"
block|,
name|CHARSET_USASCII
block|,
literal|"iso-8859-1"
block|,
name|CHARSET_LATIN
block|,
name|NULL
block|,
name|CHARSET_UNKNOWN
comment|/* this one must be last! */
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|free_text
parameter_list|(
name|ct
parameter_list|)
specifier|register
name|CT
name|ct
decl_stmt|;
block|{
specifier|register
name|struct
name|text
modifier|*
name|t
init|=
operator|(
expr|struct
name|text
operator|*
operator|)
name|ct
operator|->
name|c_ctparams
decl_stmt|;
if|if
condition|(
operator|!
name|t
condition|)
return|return;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|t
argument_list|)
expr_stmt|;
name|ct
operator|->
name|c_ctparams
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|k2v
name|SubText
index|[]
init|=
block|{
literal|"plain"
block|,
name|TEXT_PLAIN
block|,
literal|"richtext"
block|,
name|TEXT_RICHTEXT
block|,
name|NULL
block|,
name|TEXT_UNKNOWN
comment|/* this one must be last! */
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|InitText
parameter_list|(
name|ct
parameter_list|)
specifier|register
name|CT
name|ct
decl_stmt|;
block|{
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|ap
decl_stmt|,
modifier|*
modifier|*
name|ep
decl_stmt|;
specifier|register
name|struct
name|k2v
modifier|*
name|kv
decl_stmt|;
specifier|register
name|CI
name|ci
init|=
operator|&
name|ct
operator|->
name|c_ctinfo
decl_stmt|;
if|if
condition|(
operator|!
operator|*
name|ci
operator|->
name|ci_subtype
condition|)
comment|/* XXX: attmail bogosity! */
name|ci
operator|->
name|ci_subtype
operator|=
name|add
argument_list|(
literal|"plain"
argument_list|,
name|ci
operator|->
name|ci_subtype
argument_list|)
expr_stmt|;
for|for
control|(
name|kv
operator|=
name|SubText
init|;
name|kv
operator|->
name|kv_key
condition|;
name|kv
operator|++
control|)
if|if
condition|(
name|uleq
argument_list|(
name|ci
operator|->
name|ci_subtype
argument_list|,
name|kv
operator|->
name|kv_key
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|(
name|ct
operator|->
name|c_subtype
operator|=
name|kv
operator|->
name|kv_value
operator|)
operator|==
name|TEXT_PLAIN
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%%p%s '%%F'"
argument_list|,
name|progsw
condition|?
name|progsw
else|:
name|moreproc
operator|&&
operator|*
name|moreproc
condition|?
name|moreproc
else|:
literal|"more"
argument_list|)
expr_stmt|;
name|ct
operator|->
name|c_showproc
operator|=
name|add
argument_list|(
name|buffer
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|ap
operator|=
name|ci
operator|->
name|ci_attrs
operator|,
name|ep
operator|=
name|ci
operator|->
name|ci_values
init|;
operator|*
name|ap
condition|;
name|ap
operator|++
operator|,
name|ep
operator|++
control|)
if|if
condition|(
operator|!
name|ct
operator|->
name|c_ctparams
operator|&&
name|uleq
argument_list|(
operator|*
name|ap
argument_list|,
literal|"charset"
argument_list|)
condition|)
block|{
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|struct
name|text
modifier|*
name|t
decl_stmt|;
if|if
condition|(
operator|(
name|t
operator|=
operator|(
expr|struct
name|text
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
expr|*
name|t
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
name|ct
operator|->
name|c_ctparams
operator|=
operator|(
name|caddr_t
operator|)
name|t
expr_stmt|;
name|ct
operator|->
name|c_ctfreefnx
operator|=
name|free_text
expr_stmt|;
for|for
control|(
name|kv
operator|=
name|Charset
init|;
name|kv
operator|->
name|kv_key
condition|;
name|kv
operator|++
control|)
if|if
condition|(
name|uleq
argument_list|(
operator|*
name|ep
argument_list|,
name|kv
operator|->
name|kv_key
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%s-charset-%s"
argument_list|,
name|invo_name
argument_list|,
name|kv
operator|->
name|kv_key
argument_list|)
expr_stmt|;
break|break;
block|}
name|t
operator|->
name|tx_charset
operator|=
name|kv
operator|->
name|kv_value
expr_stmt|;
if|if
condition|(
operator|!
name|kv
operator|->
name|kv_key
condition|)
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%s-charset-%s"
argument_list|,
name|invo_name
argument_list|,
operator|*
name|ep
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|mm_charset
operator|||
operator|!
name|uleq
argument_list|(
name|mm_charset
argument_list|,
operator|*
name|ep
argument_list|)
operator|)
operator|&&
operator|(
name|cp
operator|=
name|m_find
argument_list|(
name|buffer
argument_list|)
operator|)
condition|)
name|ct
operator|->
name|c_termproc
operator|=
name|getcpy
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|autosw
operator|&&
operator|!
name|ct
operator|->
name|c_storeproc
operator|&&
name|uleq
argument_list|(
operator|*
name|ap
argument_list|,
literal|"x-name"
argument_list|)
condition|)
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
operator|*
operator|(
name|cp
operator|=
operator|*
name|ep
operator|)
operator|!=
literal|'/'
operator|&&
operator|*
name|cp
operator|!=
literal|'.'
operator|&&
operator|*
name|cp
operator|!=
literal|'|'
operator|&&
operator|*
name|cp
operator|!=
literal|'!'
operator|&&
operator|!
name|index
argument_list|(
name|cp
argument_list|,
literal|'%'
argument_list|)
condition|)
name|ct
operator|->
name|c_storeproc
operator|=
name|add
argument_list|(
name|cp
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
block|}
return|return
name|OK
return|;
block|}
end_function

begin_comment
comment|/*
comment|MULTIPART */
end_comment

begin_define
define|#
directive|define
name|MULTI_UNKNOWN
value|0x00
end_define

begin_define
define|#
directive|define
name|MULTI_MIXED
value|0x01
end_define

begin_define
define|#
directive|define
name|MULTI_ALTERNATE
value|0x02
end_define

begin_define
define|#
directive|define
name|MULTI_DIGEST
value|0x03
end_define

begin_define
define|#
directive|define
name|MULTI_PARALLEL
value|0x04
end_define

begin_struct
struct|struct
name|multipart
block|{
name|char
modifier|*
name|mp_start
decl_stmt|;
name|char
modifier|*
name|mp_stop
decl_stmt|;
struct|struct
name|part
block|{
name|CT
name|mp_part
decl_stmt|;
name|struct
name|part
modifier|*
name|mp_next
decl_stmt|;
block|}
modifier|*
name|mp_parts
struct|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|list_multi
parameter_list|(
name|ct
parameter_list|,
name|toplevel
parameter_list|)
specifier|register
name|CT
name|ct
decl_stmt|;
name|int
name|toplevel
decl_stmt|;
block|{
specifier|register
name|struct
name|multipart
modifier|*
name|m
init|=
operator|(
expr|struct
name|multipart
operator|*
operator|)
name|ct
operator|->
name|c_ctparams
decl_stmt|;
specifier|register
name|struct
name|part
modifier|*
name|part
decl_stmt|;
operator|(
name|void
operator|)
name|list_content
argument_list|(
name|ct
argument_list|,
name|toplevel
argument_list|)
expr_stmt|;
for|for
control|(
name|part
operator|=
name|m
operator|->
name|mp_parts
init|;
name|part
condition|;
name|part
operator|=
name|part
operator|->
name|mp_next
control|)
block|{
specifier|register
name|CT
name|p
init|=
name|part
operator|->
name|mp_part
decl_stmt|;
if|if
condition|(
name|part_ok
argument_list|(
name|p
argument_list|,
literal|1
argument_list|)
operator|&&
name|type_ok
argument_list|(
name|p
argument_list|,
literal|1
argument_list|)
operator|&&
name|p
operator|->
name|c_ctlistfnx
condition|)
call|(
name|void
call|)
argument_list|(
operator|*
name|p
operator|->
name|c_ctlistfnx
argument_list|)
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|OK
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|show_multi
parameter_list|(
name|ct
parameter_list|,
name|serial
parameter_list|,
name|alternate
parameter_list|)
specifier|register
name|CT
name|ct
decl_stmt|;
name|int
name|serial
decl_stmt|,
name|alternate
decl_stmt|;
block|{
name|int
name|alternating
decl_stmt|,
name|nowalternate
decl_stmt|,
name|nowserial
decl_stmt|,
name|result
decl_stmt|;
specifier|register
name|struct
name|multipart
modifier|*
name|m
init|=
operator|(
expr|struct
name|multipart
operator|*
operator|)
name|ct
operator|->
name|c_ctparams
decl_stmt|;
specifier|register
name|struct
name|part
modifier|*
name|part
decl_stmt|;
specifier|register
name|CT
name|p
decl_stmt|;
name|TYPESIG
argument_list|(
operator|*
name|hstat
argument_list|)
argument_list|()
decl_stmt|,
argument_list|(
operator|*
name|istat
argument_list|)
argument_list|()
decl_stmt|,
argument_list|(
operator|*
name|qstat
argument_list|)
argument_list|()
decl_stmt|,
argument_list|(
operator|*
name|tstat
argument_list|)
argument_list|()
decl_stmt|;
name|alternating
operator|=
literal|0
expr_stmt|;
name|nowalternate
operator|=
name|alternate
expr_stmt|;
switch|switch
condition|(
name|ct
operator|->
name|c_subtype
condition|)
block|{
case|case
name|MULTI_PARALLEL
case|:
if|if
condition|(
operator|!
operator|(
name|nowserial
operator|=
name|serialsw
operator|)
condition|)
block|{
name|set_signals
label|:
empty_stmt|;
name|hstat
operator|=
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|istat
operator|=
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|qstat
operator|=
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|tstat
operator|=
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|MULTI_ALTERNATE
case|:
name|nowalternate
operator|=
name|alternating
operator|=
literal|1
expr_stmt|;
comment|/* and fall... */
default|default:
if|if
condition|(
operator|!
operator|(
name|nowserial
operator|=
name|serial
operator|)
condition|)
goto|goto
name|set_signals
goto|;
break|break;
block|}
comment|/* alternate -> we're inside an alternative    alternating -> we are an alternative  */
name|result
operator|=
name|alternate
condition|?
name|NOTOK
else|:
name|OK
expr_stmt|;
for|for
control|(
name|part
operator|=
name|m
operator|->
name|mp_parts
init|;
name|part
condition|;
name|part
operator|=
name|part
operator|->
name|mp_next
control|)
block|{
name|p
operator|=
name|part
operator|->
name|mp_part
expr_stmt|;
if|if
condition|(
name|part_ok
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
operator|&&
name|type_ok
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
operator|&&
name|p
operator|->
name|c_ctshowfnx
condition|)
block|{
name|int
name|inneresult
decl_stmt|;
switch|switch
condition|(
name|inneresult
operator|=
call|(
modifier|*
name|p
operator|->
name|c_ctshowfnx
call|)
argument_list|(
name|p
argument_list|,
name|nowserial
argument_list|,
name|nowalternate
argument_list|)
condition|)
block|{
case|case
name|NOTOK
case|:
if|if
condition|(
name|alternate
operator|&&
operator|!
name|alternating
condition|)
block|{
name|result
operator|=
name|NOTOK
expr_stmt|;
goto|goto
name|out
goto|;
block|}
continue|continue;
case|case
name|OK
case|:
case|case
name|DONE
case|:
if|if
condition|(
name|alternating
condition|)
block|{
name|result
operator|=
name|DONE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|alternate
condition|)
block|{
name|alternate
operator|=
name|nowalternate
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|NOTOK
condition|)
name|result
operator|=
name|inneresult
expr_stmt|;
block|}
continue|continue;
block|}
break|break;
block|}
block|}
if|if
condition|(
name|alternating
operator|&&
operator|!
name|part
condition|)
block|{
if|if
condition|(
operator|!
name|alternate
condition|)
name|content_error
argument_list|(
name|NULLCP
argument_list|,
name|ct
argument_list|,
literal|"don't know how to display any of the contents"
argument_list|)
expr_stmt|;
name|result
operator|=
name|NOTOK
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|serial
operator|&&
operator|!
name|nowserial
condition|)
block|{
name|int
name|pid
decl_stmt|,
name|kids
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|BSD42
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|WAITINT
argument_list|)
name|union
name|wait
name|status
decl_stmt|;
else|#
directive|else
name|int
name|status
decl_stmt|;
endif|#
directive|endif
name|kids
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|part
operator|=
name|m
operator|->
name|mp_parts
init|;
name|part
condition|;
name|part
operator|=
name|part
operator|->
name|mp_next
control|)
block|{
name|p
operator|=
name|part
operator|->
name|mp_part
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|c_pid
operator|>
name|OK
condition|)
if|if
condition|(
name|kill
argument_list|(
name|p
operator|->
name|c_pid
argument_list|,
literal|0
argument_list|)
operator|==
name|NOTOK
condition|)
name|p
operator|->
name|c_pid
operator|=
literal|0
expr_stmt|;
else|else
name|kids
operator|++
expr_stmt|;
block|}
while|while
condition|(
name|kids
operator|>
literal|0
operator|&&
operator|(
name|pid
operator|=
name|wait
argument_list|(
operator|&
name|status
argument_list|)
operator|)
operator|!=
name|NOTOK
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|BSD42
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|WAITINT
argument_list|)
operator|(
name|void
operator|)
name|pidcheck
argument_list|(
name|status
operator|.
name|w_status
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|pidcheck
argument_list|(
name|status
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|part
operator|=
name|m
operator|->
name|mp_parts
init|;
name|part
condition|;
name|part
operator|=
name|part
operator|->
name|mp_next
control|)
block|{
name|p
operator|=
name|part
operator|->
name|mp_part
expr_stmt|;
if|if
condition|(
name|xpid
operator|==
name|pid
condition|)
name|xpid
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|c_pid
operator|==
name|pid
condition|)
block|{
name|p
operator|->
name|c_pid
operator|=
literal|0
expr_stmt|;
name|kids
operator|--
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
name|out
label|:
empty_stmt|;
if|if
condition|(
operator|!
name|nowserial
condition|)
block|{
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|hstat
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|istat
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|qstat
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|tstat
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|show_unknown_multi
parameter_list|(
name|ct
parameter_list|,
name|serial
parameter_list|,
name|alternate
parameter_list|)
specifier|register
name|CT
name|ct
decl_stmt|;
name|int
name|serial
decl_stmt|,
name|alternate
decl_stmt|;
block|{
name|int
name|xlist
decl_stmt|,
name|xpause
decl_stmt|,
name|xtty
decl_stmt|;
specifier|register
name|char
modifier|*
name|bp
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
specifier|register
name|struct
name|multipart
modifier|*
name|m
init|=
operator|(
expr|struct
name|multipart
operator|*
operator|)
name|ct
operator|->
name|c_ctparams
decl_stmt|;
specifier|register
name|struct
name|part
modifier|*
name|part
decl_stmt|;
specifier|register
name|CI
name|ci
init|=
operator|&
name|ct
operator|->
name|c_ctinfo
decl_stmt|;
specifier|register
name|CT
name|p
decl_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%s-show-%s/%s"
argument_list|,
name|invo_name
argument_list|,
name|ci
operator|->
name|ci_type
argument_list|,
name|ci
operator|->
name|ci_subtype
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|m_find
argument_list|(
name|buffer
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|*
name|cp
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%s-show-%s"
argument_list|,
name|invo_name
argument_list|,
name|ci
operator|->
name|ci_type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|cp
operator|=
name|m_find
argument_list|(
name|buffer
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|*
name|cp
operator|==
literal|0
operator|)
operator|&&
operator|(
name|cp
operator|=
name|ct
operator|->
name|c_showproc
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|alternate
condition|)
name|content_error
argument_list|(
name|NULLCP
argument_list|,
name|ct
argument_list|,
literal|"don't know how to display content"
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
block|}
for|for
control|(
name|part
operator|=
name|m
operator|->
name|mp_parts
init|;
name|part
condition|;
name|part
operator|=
name|part
operator|->
name|mp_next
control|)
block|{
name|p
operator|=
name|part
operator|->
name|mp_part
expr_stmt|;
if|if
condition|(
operator|!
name|p
operator|->
name|c_ceopenfnx
condition|)
block|{
if|if
condition|(
operator|!
name|alternate
condition|)
name|content_error
argument_list|(
name|NULLCP
argument_list|,
name|p
argument_list|,
literal|"don't know how to decode content"
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
if|if
condition|(
name|p
operator|->
name|c_storage
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
call|(
modifier|*
name|p
operator|->
name|c_ceopenfnx
call|)
argument_list|(
name|p
argument_list|,
operator|&
name|p
operator|->
name|c_storage
argument_list|)
operator|==
name|NOTOK
condition|)
return|return
name|NOTOK
return|;
if|if
condition|(
name|p
operator|->
name|c_showproc
operator|&&
name|strcmp
argument_list|(
name|p
operator|->
name|c_showproc
argument_list|,
literal|"true"
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|alternate
condition|?
name|DONE
else|:
name|OK
operator|)
return|;
call|(
modifier|*
name|p
operator|->
name|c_ceclosefnx
call|)
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
name|xlist
operator|=
name|xpause
operator|=
name|xtty
operator|=
literal|0
expr_stmt|;
name|buffer
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|bp
operator|=
name|buffer
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
if|if
condition|(
operator|*
name|cp
operator|==
literal|'%'
condition|)
block|{
switch|switch
condition|(
operator|*
operator|++
name|cp
condition|)
block|{
case|case
literal|'a'
case|:
comment|/* additional arguments */
block|{
specifier|register
name|char
modifier|*
modifier|*
name|ap
decl_stmt|,
modifier|*
modifier|*
name|ep
decl_stmt|;
name|char
modifier|*
name|s
init|=
literal|""
decl_stmt|;
for|for
control|(
name|ap
operator|=
name|ci
operator|->
name|ci_attrs
operator|,
name|ep
operator|=
name|ci
operator|->
name|ci_values
init|;
operator|*
name|ap
condition|;
name|ap
operator|++
operator|,
name|ep
operator|++
control|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|bp
argument_list|,
literal|"%s%s=\"%s\""
argument_list|,
name|s
argument_list|,
operator|*
name|ap
argument_list|,
operator|*
name|ep
argument_list|)
expr_stmt|;
name|bp
operator|+=
name|strlen
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|s
operator|=
literal|" "
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'d'
case|:
comment|/* content description */
if|if
condition|(
name|ct
operator|->
name|c_descr
condition|)
block|{
name|char
modifier|*
name|s
decl_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|bp
argument_list|,
name|s
operator|=
name|trimcpy
argument_list|(
name|ct
operator|->
name|c_descr
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'e'
case|:
comment|/* exclusive execution */
name|xtty
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
comment|/* %e and %f */
name|xtty
operator|=
literal|1
expr_stmt|;
comment|/* and fall... */
case|case
literal|'f'
case|:
comment|/* filename(s) */
block|{
name|char
modifier|*
name|s
init|=
literal|""
decl_stmt|;
for|for
control|(
name|part
operator|=
name|m
operator|->
name|mp_parts
init|;
name|part
condition|;
name|part
operator|=
name|part
operator|->
name|mp_next
control|)
block|{
name|p
operator|=
name|part
operator|->
name|mp_part
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|bp
argument_list|,
literal|"%s'%s'"
argument_list|,
name|s
argument_list|,
name|p
operator|->
name|c_storage
argument_list|)
expr_stmt|;
name|bp
operator|+=
name|strlen
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|s
operator|=
literal|" "
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'p'
case|:
comment|/* pause prior to displaying content */
name|xpause
operator|=
name|pausesw
expr_stmt|;
comment|/* and fall... */
case|case
literal|'l'
case|:
comment|/* display listing prior to displaying 				   content */
name|xlist
operator|=
operator|!
name|nolist
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
comment|/* subtype */
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|bp
argument_list|,
name|ci
operator|->
name|ci_subtype
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'%'
case|:
goto|goto
name|raw
goto|;
default|default:
operator|*
name|bp
operator|++
operator|=
operator|*
operator|--
name|cp
expr_stmt|;
operator|*
name|bp
operator|=
literal|'\0'
expr_stmt|;
continue|continue;
block|}
name|bp
operator|+=
name|strlen
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|raw
label|:
empty_stmt|;
operator|*
name|bp
operator|++
operator|=
operator|*
name|cp
expr_stmt|;
operator|*
name|bp
operator|=
literal|'\0'
expr_stmt|;
block|}
if|if
condition|(
name|ct
operator|->
name|c_termproc
condition|)
block|{
name|char
name|term
index|[
name|BUFSIZ
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|term
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buffer
argument_list|,
name|ct
operator|->
name|c_termproc
argument_list|,
name|term
argument_list|)
expr_stmt|;
block|}
return|return
name|show_content_aux2
argument_list|(
name|ct
argument_list|,
name|serial
argument_list|,
name|alternate
argument_list|,
name|NULLCP
argument_list|,
name|buffer
argument_list|,
name|NOTOK
argument_list|,
name|xlist
argument_list|,
name|xpause
argument_list|,
literal|0
argument_list|,
name|xtty
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|store_multi
parameter_list|(
name|ct
parameter_list|,
name|unused
parameter_list|)
specifier|register
name|CT
name|ct
decl_stmt|;
name|char
modifier|*
name|unused
decl_stmt|;
block|{
name|int
name|result
decl_stmt|;
specifier|register
name|struct
name|multipart
modifier|*
name|m
init|=
operator|(
expr|struct
name|multipart
operator|*
operator|)
name|ct
operator|->
name|c_ctparams
decl_stmt|;
specifier|register
name|struct
name|part
modifier|*
name|part
decl_stmt|;
name|result
operator|=
name|NOTOK
expr_stmt|;
for|for
control|(
name|part
operator|=
name|m
operator|->
name|mp_parts
init|;
name|part
condition|;
name|part
operator|=
name|part
operator|->
name|mp_next
control|)
block|{
specifier|register
name|CT
name|p
init|=
name|part
operator|->
name|mp_part
decl_stmt|;
if|if
condition|(
name|part_ok
argument_list|(
name|p
argument_list|,
literal|1
argument_list|)
operator|&&
name|type_ok
argument_list|(
name|p
argument_list|,
literal|1
argument_list|)
operator|&&
name|p
operator|->
name|c_ctstorefnx
operator|&&
operator|(
name|result
operator|=
call|(
modifier|*
name|p
operator|->
name|c_ctstorefnx
call|)
argument_list|(
name|p
argument_list|,
name|NULLCP
argument_list|)
operator|)
operator|==
name|OK
operator|&&
name|ct
operator|->
name|c_subtype
operator|==
name|MULTI_ALTERNATE
condition|)
break|break;
block|}
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|free_multi
parameter_list|(
name|ct
parameter_list|)
specifier|register
name|CT
name|ct
decl_stmt|;
block|{
specifier|register
name|struct
name|multipart
modifier|*
name|m
init|=
operator|(
expr|struct
name|multipart
operator|*
operator|)
name|ct
operator|->
name|c_ctparams
decl_stmt|;
specifier|register
name|struct
name|part
modifier|*
name|part
decl_stmt|,
modifier|*
name|next
decl_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
return|return;
if|if
condition|(
name|m
operator|->
name|mp_start
condition|)
name|free
argument_list|(
name|m
operator|->
name|mp_start
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|mp_stop
condition|)
name|free
argument_list|(
name|m
operator|->
name|mp_stop
argument_list|)
expr_stmt|;
for|for
control|(
name|part
operator|=
name|m
operator|->
name|mp_parts
init|;
name|part
condition|;
name|part
operator|=
name|next
control|)
block|{
name|next
operator|=
name|part
operator|->
name|mp_next
expr_stmt|;
name|free_content
argument_list|(
name|part
operator|->
name|mp_part
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|part
argument_list|)
expr_stmt|;
block|}
name|m
operator|->
name|mp_parts
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|m
argument_list|)
expr_stmt|;
name|ct
operator|->
name|c_ctparams
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|k2v
name|SubMultiPart
index|[]
init|=
block|{
literal|"mixed"
block|,
name|MULTI_MIXED
block|,
literal|"alternative"
block|,
name|MULTI_ALTERNATE
block|,
literal|"digest"
block|,
name|MULTI_DIGEST
block|,
literal|"parallel"
block|,
name|MULTI_PARALLEL
block|,
name|NULL
block|,
name|MULTI_UNKNOWN
comment|/* this one must be last! */
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|InitMultiPart
parameter_list|(
name|ct
parameter_list|)
specifier|register
name|CT
name|ct
decl_stmt|;
block|{
name|int
name|inout
decl_stmt|;
name|long
name|last
decl_stmt|,
name|pos
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|dp
decl_stmt|,
modifier|*
modifier|*
name|ap
decl_stmt|,
modifier|*
modifier|*
name|ep
decl_stmt|;
name|char
modifier|*
name|bp
decl_stmt|,
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
specifier|register
name|struct
name|multipart
modifier|*
name|m
decl_stmt|;
specifier|register
name|struct
name|k2v
modifier|*
name|kv
decl_stmt|;
specifier|register
name|struct
name|part
modifier|*
name|part
decl_stmt|,
modifier|*
modifier|*
name|next
decl_stmt|;
specifier|register
name|CI
name|ci
init|=
operator|&
name|ct
operator|->
name|c_ctinfo
decl_stmt|;
specifier|register
name|CT
name|p
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|ct
operator|->
name|c_ctshowfnx
operator|=
name|NULL
expr_stmt|;
name|ct
operator|->
name|c_ctstorefnx
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ct
operator|->
name|c_encoding
operator|!=
name|CE_7BIT
condition|)
block|{
name|admonish
argument_list|(
name|NULLCP
argument_list|,
literal|"\"%s/%s\" type in message %s should be encoded in 7bit"
argument_list|,
name|ci
operator|->
name|ci_type
argument_list|,
name|ci
operator|->
name|ci_subtype
argument_list|,
name|ct
operator|->
name|c_file
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
for|for
control|(
name|kv
operator|=
name|SubMultiPart
init|;
name|kv
operator|->
name|kv_key
condition|;
name|kv
operator|++
control|)
if|if
condition|(
name|uleq
argument_list|(
name|ci
operator|->
name|ci_subtype
argument_list|,
name|kv
operator|->
name|kv_key
argument_list|)
condition|)
break|break;
name|ct
operator|->
name|c_subtype
operator|=
name|kv
operator|->
name|kv_value
expr_stmt|;
for|for
control|(
name|ap
operator|=
name|ci
operator|->
name|ci_attrs
operator|,
name|ep
operator|=
name|ci
operator|->
name|ci_values
init|;
operator|*
name|ap
condition|;
name|ap
operator|++
operator|,
name|ep
operator|++
control|)
if|if
condition|(
name|uleq
argument_list|(
operator|*
name|ap
argument_list|,
literal|"boundary"
argument_list|)
condition|)
block|{
name|bp
operator|=
operator|*
name|ep
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
operator|*
name|ap
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"a \"boundary\" parameter is mandatory for \"%s/%s\" type in message %s's %s: field"
argument_list|,
name|ci
operator|->
name|ci_type
argument_list|,
name|ci
operator|->
name|ci_subtype
argument_list|,
name|ct
operator|->
name|c_file
argument_list|,
name|TYPE_FIELD
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
if|if
condition|(
operator|(
name|m
operator|=
operator|(
expr|struct
name|multipart
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
expr|*
name|m
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
name|ct
operator|->
name|c_ctparams
operator|=
operator|(
name|caddr_t
operator|)
name|m
expr_stmt|;
name|ct
operator|->
name|c_ctlistfnx
operator|=
name|list_multi
expr_stmt|;
name|ct
operator|->
name|c_ctshowfnx
operator|=
name|ct
operator|->
name|c_subtype
operator|!=
name|MULTI_UNKNOWN
condition|?
name|show_multi
else|:
name|show_unknown_multi
expr_stmt|;
name|ct
operator|->
name|c_ctstorefnx
operator|=
name|store_multi
expr_stmt|;
name|ct
operator|->
name|c_ctfreefnx
operator|=
name|free_multi
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|bp
init|;
name|isspace
argument_list|(
operator|*
name|cp
argument_list|)
condition|;
name|cp
operator|++
control|)
continue|continue;
if|if
condition|(
operator|!
operator|*
name|cp
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"invalid \"boundary\" parameter for \"%s/%s\" type in message %s's %s: field"
argument_list|,
name|ci
operator|->
name|ci_type
argument_list|,
name|ci
operator|->
name|ci_subtype
argument_list|,
name|ct
operator|->
name|c_file
argument_list|,
name|TYPE_FIELD
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
for|for
control|(
name|cp
operator|=
name|bp
operator|,
name|dp
operator|=
name|cp
operator|+
name|strlen
argument_list|(
name|cp
argument_list|)
operator|-
literal|1
init|;
name|dp
operator|>
name|cp
condition|;
name|dp
operator|--
control|)
if|if
condition|(
operator|!
name|isspace
argument_list|(
operator|*
name|dp
argument_list|)
condition|)
break|break;
operator|*
operator|++
name|dp
operator|=
literal|'\0'
expr_stmt|;
name|m
operator|->
name|mp_start
operator|=
name|concat
argument_list|(
name|bp
argument_list|,
literal|"\n"
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
name|m
operator|->
name|mp_stop
operator|=
name|concat
argument_list|(
name|bp
argument_list|,
literal|"--\n"
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ct
operator|->
name|c_fp
operator|&&
operator|(
name|ct
operator|->
name|c_fp
operator|=
name|fopen
argument_list|(
name|ct
operator|->
name|c_file
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|advise
argument_list|(
name|ct
operator|->
name|c_file
argument_list|,
literal|"unable to open for reading"
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
operator|(
name|void
operator|)
name|fseek
argument_list|(
name|fp
operator|=
name|ct
operator|->
name|c_fp
argument_list|,
name|pos
operator|=
name|ct
operator|->
name|c_begin
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|last
operator|=
name|ct
operator|->
name|c_end
expr_stmt|;
name|next
operator|=
operator|&
name|m
operator|->
name|mp_parts
operator|,
name|part
operator|=
name|NULL
operator|,
name|inout
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
name|buffer
operator|-
literal|1
argument_list|,
name|fp
argument_list|)
condition|)
block|{
if|if
condition|(
name|pos
operator|>
name|last
condition|)
break|break;
name|pos
operator|+=
name|strlen
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|buffer
index|[
literal|0
index|]
operator|!=
literal|'-'
operator|||
name|buffer
index|[
literal|1
index|]
operator|!=
literal|'-'
condition|)
continue|continue;
if|if
condition|(
name|inout
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|buffer
operator|+
literal|2
argument_list|,
name|m
operator|->
name|mp_start
argument_list|)
condition|)
continue|continue;
name|next_part
label|:
empty_stmt|;
if|if
condition|(
operator|(
name|part
operator|=
operator|(
expr|struct
name|part
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
expr|*
name|part
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
operator|*
name|next
operator|=
name|part
operator|,
name|next
operator|=
operator|&
name|part
operator|->
name|mp_next
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|get_content
argument_list|(
name|fp
argument_list|,
name|ct
operator|->
name|c_file
argument_list|,
name|rfc934sw
operator|&&
name|ct
operator|->
name|c_subtype
operator|==
name|MULTI_DIGEST
condition|?
operator|-
literal|1
else|:
literal|0
argument_list|)
operator|)
operator|==
name|NULLCT
condition|)
block|{
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|ct
operator|->
name|c_fp
argument_list|)
operator|,
name|ct
operator|->
name|c_fp
operator|=
name|NULL
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
name|p
operator|->
name|c_fp
operator|=
name|NULL
expr_stmt|;
name|part
operator|->
name|mp_part
operator|=
name|p
expr_stmt|;
operator|(
name|void
operator|)
name|fseek
argument_list|(
name|fp
argument_list|,
name|pos
operator|=
name|p
operator|->
name|c_begin
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|inout
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|buffer
operator|+
literal|2
argument_list|,
name|m
operator|->
name|mp_start
argument_list|)
operator|==
literal|0
condition|)
block|{
name|inout
operator|=
literal|1
expr_stmt|;
name|end_part
label|:
empty_stmt|;
name|p
operator|=
name|part
operator|->
name|mp_part
expr_stmt|;
name|p
operator|->
name|c_end
operator|=
name|ftell
argument_list|(
name|fp
argument_list|)
operator|-
operator|(
name|strlen
argument_list|(
name|buffer
argument_list|)
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|c_end
operator|<
name|p
operator|->
name|c_begin
condition|)
name|p
operator|->
name|c_begin
operator|=
name|p
operator|->
name|c_end
expr_stmt|;
if|if
condition|(
name|inout
condition|)
goto|goto
name|next_part
goto|;
goto|goto
name|last_part
goto|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|buffer
operator|+
literal|2
argument_list|,
name|m
operator|->
name|mp_stop
argument_list|)
operator|==
literal|0
condition|)
goto|goto
name|end_part
goto|;
block|}
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"bogus multipart content in message %s"
argument_list|,
name|ct
operator|->
name|c_file
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|inout
operator|&&
name|part
condition|)
block|{
name|p
operator|=
name|part
operator|->
name|mp_part
expr_stmt|;
name|p
operator|->
name|c_end
operator|=
name|ct
operator|->
name|c_end
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|c_begin
operator|>=
name|p
operator|->
name|c_end
condition|)
block|{
for|for
control|(
name|next
operator|=
operator|&
name|m
operator|->
name|mp_parts
init|;
operator|*
name|next
operator|!=
name|part
condition|;
name|next
operator|=
operator|&
operator|(
operator|(
operator|*
name|next
operator|)
operator|->
name|mp_next
operator|)
control|)
continue|continue;
operator|*
name|next
operator|=
name|NULL
expr_stmt|;
name|free_content
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|part
argument_list|)
expr_stmt|;
block|}
block|}
name|last_part
label|:
empty_stmt|;
if|if
condition|(
name|ct
operator|->
name|c_subtype
operator|==
name|MULTI_ALTERNATE
operator|&&
name|m
operator|->
name|mp_parts
operator|->
name|mp_next
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|part
modifier|*
modifier|*
name|base
decl_stmt|,
modifier|*
modifier|*
name|bmp
decl_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|part
operator|=
name|m
operator|->
name|mp_parts
init|;
name|part
condition|;
name|part
operator|=
name|part
operator|->
name|mp_next
control|)
name|i
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|base
operator|=
operator|(
expr|struct
name|part
operator|*
operator|*
operator|)
name|calloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|i
operator|+
literal|1
argument_list|)
argument_list|,
sizeof|sizeof
expr|*
name|base
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
name|bmp
operator|=
name|base
expr_stmt|;
for|for
control|(
name|part
operator|=
name|m
operator|->
name|mp_parts
init|;
name|part
condition|;
name|part
operator|=
name|part
operator|->
name|mp_next
control|)
operator|*
name|bmp
operator|++
operator|=
name|part
expr_stmt|;
operator|*
name|bmp
operator|=
name|NULL
expr_stmt|;
name|next
operator|=
operator|&
name|m
operator|->
name|mp_parts
expr_stmt|;
for|for
control|(
name|bmp
operator|--
init|;
name|bmp
operator|>=
name|base
condition|;
name|bmp
operator|--
control|)
block|{
name|part
operator|=
operator|*
name|bmp
expr_stmt|;
operator|*
name|next
operator|=
name|part
operator|,
name|next
operator|=
operator|&
name|part
operator|->
name|mp_next
expr_stmt|;
block|}
operator|*
name|next
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|base
argument_list|)
expr_stmt|;
block|}
block|{
name|int
name|partnum
decl_stmt|;
specifier|register
name|char
modifier|*
name|pp
decl_stmt|;
name|char
name|partnam
index|[
name|BUFSIZ
index|]
decl_stmt|;
if|if
condition|(
name|ct
operator|->
name|c_partno
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|partnam
argument_list|,
literal|"%s."
argument_list|,
name|ct
operator|->
name|c_partno
argument_list|)
expr_stmt|;
name|pp
operator|=
name|partnam
operator|+
name|strlen
argument_list|(
name|partnam
argument_list|)
expr_stmt|;
block|}
else|else
name|pp
operator|=
name|partnam
expr_stmt|;
for|for
control|(
name|part
operator|=
name|m
operator|->
name|mp_parts
operator|,
name|partnum
operator|=
literal|1
init|;
name|part
condition|;
name|part
operator|=
name|part
operator|->
name|mp_next
operator|,
name|partnum
operator|++
control|)
block|{
name|p
operator|=
name|part
operator|->
name|mp_part
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|pp
argument_list|,
literal|"%d"
argument_list|,
name|partnum
argument_list|)
expr_stmt|;
name|p
operator|->
name|c_partno
operator|=
name|add
argument_list|(
name|partnam
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|c_ctinitfnx
operator|&&
call|(
modifier|*
name|p
operator|->
name|c_ctinitfnx
call|)
argument_list|(
name|p
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|ct
operator|->
name|c_fp
argument_list|)
operator|,
name|ct
operator|->
name|c_fp
operator|=
name|NULL
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
block|}
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|ct
operator|->
name|c_fp
argument_list|)
operator|,
name|ct
operator|->
name|c_fp
operator|=
name|NULL
expr_stmt|;
return|return
name|OK
return|;
block|}
end_function

begin_comment
comment|/*
comment|MESSAGE */
end_comment

begin_define
define|#
directive|define
name|MESSAGE_UNKNOWN
value|0x00
end_define

begin_define
define|#
directive|define
name|MESSAGE_RFC822
value|0x01
end_define

begin_define
define|#
directive|define
name|MESSAGE_PARTIAL
value|0x02
end_define

begin_define
define|#
directive|define
name|MESSAGE_EXTERNAL
value|0x03
end_define

begin_struct
struct|struct
name|partial
block|{
name|char
modifier|*
name|pm_partid
decl_stmt|;
name|int
name|pm_partno
decl_stmt|;
name|int
name|pm_maxno
decl_stmt|;
name|int
name|pm_marked
decl_stmt|;
name|int
name|pm_stored
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|list_partial
parameter_list|(
name|ct
parameter_list|,
name|toplevel
parameter_list|)
specifier|register
name|CT
name|ct
decl_stmt|;
name|int
name|toplevel
decl_stmt|;
block|{
specifier|register
name|struct
name|partial
modifier|*
name|p
init|=
operator|(
expr|struct
name|partial
operator|*
operator|)
name|ct
operator|->
name|c_ctparams
decl_stmt|;
operator|(
name|void
operator|)
name|list_content
argument_list|(
name|ct
argument_list|,
name|toplevel
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbosw
condition|)
block|{
name|printf
argument_list|(
literal|"\t     [message %s, part %d"
argument_list|,
name|p
operator|->
name|pm_partid
argument_list|,
name|p
operator|->
name|pm_partno
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|pm_maxno
condition|)
name|printf
argument_list|(
literal|" of %d"
argument_list|,
name|p
operator|->
name|pm_maxno
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"]\n"
argument_list|)
expr_stmt|;
block|}
return|return
name|OK
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ct_compar
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
name|CT
modifier|*
name|a
decl_stmt|,
decl|*
name|b
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|struct
name|partial
modifier|*
name|am
init|=
operator|(
expr|struct
name|partial
operator|*
operator|)
operator|(
operator|(
operator|*
name|a
operator|)
operator|->
name|c_ctparams
operator|)
decl_stmt|;
specifier|register
name|struct
name|partial
modifier|*
name|bm
init|=
operator|(
expr|struct
name|partial
operator|*
operator|)
operator|(
operator|(
operator|*
name|b
operator|)
operator|->
name|c_ctparams
operator|)
decl_stmt|;
return|return
operator|(
name|am
operator|->
name|pm_marked
operator|-
name|bm
operator|->
name|pm_marked
operator|)
return|;
block|}
end_block

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|store_partial
parameter_list|(
name|ct
parameter_list|,
name|unused
parameter_list|)
specifier|register
name|CT
name|ct
decl_stmt|;
name|char
modifier|*
name|unused
decl_stmt|;
block|{
name|int
name|cur
decl_stmt|,
name|hi
decl_stmt|,
name|i
decl_stmt|;
specifier|register
name|CT
name|p
decl_stmt|,
modifier|*
name|ctp
decl_stmt|,
modifier|*
name|ctq
decl_stmt|;
name|CT
modifier|*
name|base
decl_stmt|;
name|struct
name|partial
modifier|*
name|qm
init|=
operator|(
expr|struct
name|partial
operator|*
operator|)
name|ct
operator|->
name|c_ctparams
decl_stmt|;
if|if
condition|(
name|qm
operator|->
name|pm_stored
condition|)
return|return
name|OK
return|;
name|hi
operator|=
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|ctp
operator|=
name|cts
init|;
name|p
operator|=
operator|*
name|ctp
condition|;
name|ctp
operator|++
control|)
if|if
condition|(
name|p
operator|->
name|c_type
operator|==
name|CT_MESSAGE
operator|&&
name|p
operator|->
name|c_subtype
operator|==
name|ct
operator|->
name|c_subtype
condition|)
block|{
specifier|register
name|struct
name|partial
modifier|*
name|pm
init|=
operator|(
expr|struct
name|partial
operator|*
operator|)
name|p
operator|->
name|c_ctparams
decl_stmt|;
if|if
condition|(
operator|!
name|pm
operator|->
name|pm_stored
operator|&&
name|strcmp
argument_list|(
name|qm
operator|->
name|pm_partid
argument_list|,
name|pm
operator|->
name|pm_partid
argument_list|)
operator|==
literal|0
condition|)
block|{
name|pm
operator|->
name|pm_marked
operator|=
name|pm
operator|->
name|pm_partno
expr_stmt|;
if|if
condition|(
name|pm
operator|->
name|pm_maxno
condition|)
name|hi
operator|=
name|pm
operator|->
name|pm_maxno
expr_stmt|;
name|pm
operator|->
name|pm_stored
operator|=
literal|1
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
else|else
name|pm
operator|->
name|pm_marked
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|hi
operator|==
literal|0
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"missing (at least) last part of multipart message"
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
if|if
condition|(
operator|(
name|base
operator|=
operator|(
name|CT
operator|*
operator|)
name|calloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|i
operator|+
literal|1
argument_list|)
argument_list|,
sizeof|sizeof
expr|*
name|base
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
name|ctq
operator|=
name|base
expr_stmt|;
for|for
control|(
name|ctp
operator|=
name|cts
init|;
name|p
operator|=
operator|*
name|ctp
condition|;
name|ctp
operator|++
control|)
if|if
condition|(
name|p
operator|->
name|c_type
operator|==
name|CT_MESSAGE
operator|&&
name|p
operator|->
name|c_subtype
operator|==
name|ct
operator|->
name|c_subtype
condition|)
block|{
specifier|register
name|struct
name|partial
modifier|*
name|pm
init|=
operator|(
expr|struct
name|partial
operator|*
operator|)
name|p
operator|->
name|c_ctparams
decl_stmt|;
if|if
condition|(
name|pm
operator|->
name|pm_marked
condition|)
operator|*
name|ctq
operator|++
operator|=
name|p
expr_stmt|;
block|}
operator|*
name|ctq
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|1
condition|)
name|qsort
argument_list|(
operator|(
name|char
operator|*
operator|)
name|base
argument_list|,
name|i
argument_list|,
sizeof|sizeof
expr|*
name|base
argument_list|,
name|ct_compar
argument_list|)
expr_stmt|;
name|cur
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|ctq
operator|=
name|base
init|;
name|p
operator|=
operator|*
name|ctq
condition|;
name|ctq
operator|++
control|)
block|{
specifier|register
name|struct
name|partial
modifier|*
name|pm
init|=
operator|(
expr|struct
name|partial
operator|*
operator|)
name|p
operator|->
name|c_ctparams
decl_stmt|;
if|if
condition|(
name|pm
operator|->
name|pm_marked
operator|!=
name|cur
condition|)
block|{
if|if
condition|(
name|pm
operator|->
name|pm_marked
operator|==
name|cur
operator|-
literal|1
condition|)
block|{
name|admonish
argument_list|(
name|NULLCP
argument_list|,
literal|"duplicate part %d of %d part multipart message"
argument_list|,
name|pm
operator|->
name|pm_marked
argument_list|,
name|hi
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|missing_part
label|:
empty_stmt|;
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"missing %spart %d of %d part multipart message"
argument_list|,
name|cur
operator|!=
name|hi
condition|?
literal|"(at least) "
else|:
literal|""
argument_list|,
name|cur
argument_list|,
name|hi
argument_list|)
expr_stmt|;
goto|goto
name|losing
goto|;
block|}
else|else
name|cur
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|hi
operator|!=
operator|--
name|cur
condition|)
block|{
name|cur
operator|=
name|hi
expr_stmt|;
goto|goto
name|missing_part
goto|;
block|}
name|ctq
operator|=
name|base
expr_stmt|;
name|ct
operator|=
operator|*
name|ctq
operator|++
expr_stmt|;
if|if
condition|(
name|store_content
argument_list|(
name|ct
argument_list|,
literal|""
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
name|losing
label|:
empty_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|base
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
for|for
control|(
init|;
name|p
operator|=
operator|*
name|ctq
condition|;
name|ctq
operator|++
control|)
if|if
condition|(
name|store_content
argument_list|(
name|p
argument_list|,
name|ct
operator|->
name|c_storage
argument_list|)
operator|==
name|NOTOK
condition|)
goto|goto
name|losing
goto|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|base
argument_list|)
expr_stmt|;
return|return
name|OK
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|free_partial
parameter_list|(
name|ct
parameter_list|)
specifier|register
name|CT
name|ct
decl_stmt|;
block|{
specifier|register
name|struct
name|partial
modifier|*
name|p
init|=
operator|(
expr|struct
name|partial
operator|*
operator|)
name|ct
operator|->
name|c_ctparams
decl_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
return|return;
if|if
condition|(
name|p
operator|->
name|pm_partid
condition|)
name|free
argument_list|(
name|p
operator|->
name|pm_partid
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p
argument_list|)
expr_stmt|;
name|ct
operator|->
name|c_ctparams
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_struct
struct|struct
name|exbody
block|{
name|CT
name|eb_parent
decl_stmt|;
name|CT
name|eb_content
decl_stmt|;
name|char
modifier|*
name|eb_partno
decl_stmt|;
name|char
modifier|*
name|eb_access
decl_stmt|;
name|int
name|eb_flags
decl_stmt|;
name|char
modifier|*
name|eb_name
decl_stmt|;
name|char
modifier|*
name|eb_permission
decl_stmt|;
name|char
modifier|*
name|eb_site
decl_stmt|;
name|char
modifier|*
name|eb_dir
decl_stmt|;
name|char
modifier|*
name|eb_mode
decl_stmt|;
name|unsigned
name|long
name|eb_size
decl_stmt|;
name|char
modifier|*
name|eb_server
decl_stmt|;
name|char
modifier|*
name|eb_subject
decl_stmt|;
name|char
modifier|*
name|eb_body
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|int
name|openFile
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|openFTP
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|openMail
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* NOTE WELL: si_key MUST NOT have value of NOTOK */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|str2init
name|str2methods
index|[]
init|=
block|{
literal|"afs"
block|,
literal|1
block|,
name|openFile
block|,
literal|"anon-ftp"
block|,
literal|1
block|,
name|openFTP
block|,
literal|"ftp"
block|,
literal|0
block|,
name|openFTP
block|,
literal|"local-file"
block|,
literal|0
block|,
name|openFile
block|,
literal|"mail-server"
block|,
literal|0
block|,
name|openMail
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|params_external
parameter_list|(
name|ct
parameter_list|,
name|composing
parameter_list|)
specifier|register
name|CT
name|ct
decl_stmt|;
name|int
name|composing
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
modifier|*
name|ap
decl_stmt|,
modifier|*
modifier|*
name|ep
decl_stmt|;
specifier|register
name|struct
name|exbody
modifier|*
name|e
init|=
operator|(
expr|struct
name|exbody
operator|*
operator|)
name|ct
operator|->
name|c_ctparams
decl_stmt|;
specifier|register
name|CI
name|ci
init|=
operator|&
name|ct
operator|->
name|c_ctinfo
decl_stmt|;
for|for
control|(
name|ap
operator|=
name|ci
operator|->
name|ci_attrs
operator|,
name|ep
operator|=
name|ci
operator|->
name|ci_values
init|;
operator|*
name|ap
condition|;
name|ap
operator|++
operator|,
name|ep
operator|++
control|)
block|{
if|if
condition|(
name|uleq
argument_list|(
operator|*
name|ap
argument_list|,
literal|"access-type"
argument_list|)
condition|)
block|{
specifier|register
name|struct
name|str2init
modifier|*
name|s2i
decl_stmt|;
specifier|register
name|CT
name|p
init|=
name|e
operator|->
name|eb_content
decl_stmt|;
for|for
control|(
name|s2i
operator|=
name|str2methods
init|;
name|s2i
operator|->
name|si_key
condition|;
name|s2i
operator|++
control|)
if|if
condition|(
name|uleq
argument_list|(
operator|*
name|ep
argument_list|,
name|s2i
operator|->
name|si_key
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|!
name|s2i
operator|->
name|si_key
condition|)
block|{
name|e
operator|->
name|eb_access
operator|=
operator|*
name|ep
expr_stmt|;
name|e
operator|->
name|eb_flags
operator|=
name|NOTOK
expr_stmt|;
name|p
operator|->
name|c_encoding
operator|=
name|CE_EXTERNAL
expr_stmt|;
continue|continue;
block|}
name|e
operator|->
name|eb_access
operator|=
name|s2i
operator|->
name|si_key
expr_stmt|;
name|e
operator|->
name|eb_flags
operator|=
name|s2i
operator|->
name|si_value
expr_stmt|;
name|p
operator|->
name|c_encoding
operator|=
name|CE_EXTERNAL
expr_stmt|;
if|if
condition|(
name|init_encoding
argument_list|(
name|p
argument_list|,
name|s2i
operator|->
name|si_init
argument_list|)
operator|==
name|NOTOK
condition|)
return|return
name|NOTOK
return|;
continue|continue;
block|}
if|if
condition|(
name|uleq
argument_list|(
operator|*
name|ap
argument_list|,
literal|"name"
argument_list|)
condition|)
block|{
name|e
operator|->
name|eb_name
operator|=
operator|*
name|ep
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|uleq
argument_list|(
operator|*
name|ap
argument_list|,
literal|"permission"
argument_list|)
condition|)
block|{
name|e
operator|->
name|eb_permission
operator|=
operator|*
name|ep
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|uleq
argument_list|(
operator|*
name|ap
argument_list|,
literal|"site"
argument_list|)
condition|)
block|{
name|e
operator|->
name|eb_site
operator|=
operator|*
name|ep
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|uleq
argument_list|(
operator|*
name|ap
argument_list|,
literal|"directory"
argument_list|)
condition|)
block|{
name|e
operator|->
name|eb_dir
operator|=
operator|*
name|ep
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|uleq
argument_list|(
operator|*
name|ap
argument_list|,
literal|"mode"
argument_list|)
condition|)
block|{
name|e
operator|->
name|eb_mode
operator|=
operator|*
name|ep
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|uleq
argument_list|(
operator|*
name|ap
argument_list|,
literal|"size"
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|sscanf
argument_list|(
operator|*
name|ep
argument_list|,
literal|"%lu"
argument_list|,
operator|&
name|e
operator|->
name|eb_size
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|uleq
argument_list|(
operator|*
name|ap
argument_list|,
literal|"server"
argument_list|)
condition|)
block|{
name|e
operator|->
name|eb_server
operator|=
operator|*
name|ep
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|uleq
argument_list|(
operator|*
name|ap
argument_list|,
literal|"subject"
argument_list|)
condition|)
block|{
name|e
operator|->
name|eb_subject
operator|=
operator|*
name|ep
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|composing
operator|&&
name|uleq
argument_list|(
operator|*
name|ap
argument_list|,
literal|"body"
argument_list|)
condition|)
block|{
name|e
operator|->
name|eb_body
operator|=
name|getcpy
argument_list|(
operator|*
name|ep
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
operator|!
name|e
operator|->
name|eb_access
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"invalid parameters for \"%s/%s\" type in message %s's %s field"
argument_list|,
name|ci
operator|->
name|ci_type
argument_list|,
name|ci
operator|->
name|ci_subtype
argument_list|,
name|ct
operator|->
name|c_file
argument_list|,
name|TYPE_FIELD
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
return|return
name|OK
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|list_external
parameter_list|(
name|ct
parameter_list|,
name|toplevel
parameter_list|)
specifier|register
name|CT
name|ct
decl_stmt|;
name|int
name|toplevel
decl_stmt|;
block|{
specifier|register
name|struct
name|exbody
modifier|*
name|e
init|=
operator|(
expr|struct
name|exbody
operator|*
operator|)
name|ct
operator|->
name|c_ctparams
decl_stmt|;
operator|(
name|void
operator|)
name|list_content
argument_list|(
name|ct
argument_list|,
name|toplevel
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbosw
condition|)
block|{
if|if
condition|(
name|e
operator|->
name|eb_name
condition|)
name|printf
argument_list|(
literal|"\t     retrieve %s\n"
argument_list|,
name|e
operator|->
name|eb_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|eb_dir
condition|)
name|printf
argument_list|(
literal|"\t in directory %s\n"
argument_list|,
name|e
operator|->
name|eb_dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|eb_site
condition|)
name|printf
argument_list|(
literal|"\t         from %s\n"
argument_list|,
name|e
operator|->
name|eb_site
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|eb_server
condition|)
name|printf
argument_list|(
literal|"\t from mailbox %s\n"
argument_list|,
name|e
operator|->
name|eb_server
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|eb_subject
condition|)
name|printf
argument_list|(
literal|"\t with subject %s\n"
argument_list|,
name|e
operator|->
name|eb_subject
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\t        using %s"
argument_list|,
name|e
operator|->
name|eb_access
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|eb_mode
condition|)
name|printf
argument_list|(
literal|" (in %s mode)"
argument_list|,
name|e
operator|->
name|eb_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|eb_permission
condition|)
name|printf
argument_list|(
literal|" (permission %s)"
argument_list|,
name|e
operator|->
name|eb_permission
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|eb_flags
operator|==
name|NOTOK
condition|)
name|printf
argument_list|(
literal|" [service unavailable]"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|list_content
argument_list|(
name|e
operator|->
name|eb_content
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|OK
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|show_external
parameter_list|(
name|ct
parameter_list|,
name|serial
parameter_list|,
name|alternate
parameter_list|)
specifier|register
name|CT
name|ct
decl_stmt|;
name|int
name|serial
decl_stmt|,
name|alternate
decl_stmt|;
block|{
specifier|register
name|struct
name|exbody
modifier|*
name|e
init|=
operator|(
expr|struct
name|exbody
operator|*
operator|)
name|ct
operator|->
name|c_ctparams
decl_stmt|;
specifier|register
name|CT
name|p
init|=
name|e
operator|->
name|eb_content
decl_stmt|;
if|if
condition|(
operator|!
name|type_ok
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|OK
return|;
if|if
condition|(
name|p
operator|->
name|c_ctshowfnx
condition|)
return|return
call|(
modifier|*
name|p
operator|->
name|c_ctshowfnx
call|)
argument_list|(
name|p
argument_list|,
name|serial
argument_list|,
name|alternate
argument_list|)
return|;
name|content_error
argument_list|(
name|NULLCP
argument_list|,
name|p
argument_list|,
literal|"don't know how to display content"
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|store_external
parameter_list|(
name|ct
parameter_list|)
specifier|register
name|CT
name|ct
decl_stmt|;
block|{
name|int
name|result
init|=
name|NOTOK
decl_stmt|;
specifier|register
name|struct
name|exbody
modifier|*
name|e
init|=
operator|(
expr|struct
name|exbody
operator|*
operator|)
name|ct
operator|->
name|c_ctparams
decl_stmt|;
specifier|register
name|CT
name|p
init|=
name|e
operator|->
name|eb_content
decl_stmt|;
if|if
condition|(
operator|!
name|type_ok
argument_list|(
name|p
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|OK
return|;
name|p
operator|->
name|c_partno
operator|=
name|ct
operator|->
name|c_partno
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|c_ctstorefnx
condition|)
name|result
operator|=
call|(
modifier|*
name|p
operator|->
name|c_ctstorefnx
call|)
argument_list|(
name|p
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
name|p
operator|->
name|c_partno
operator|=
name|NULL
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|free_external
parameter_list|(
name|ct
parameter_list|)
specifier|register
name|CT
name|ct
decl_stmt|;
block|{
specifier|register
name|struct
name|exbody
modifier|*
name|e
init|=
operator|(
expr|struct
name|exbody
operator|*
operator|)
name|ct
operator|->
name|c_ctparams
decl_stmt|;
if|if
condition|(
operator|!
name|e
condition|)
return|return;
name|free_content
argument_list|(
name|e
operator|->
name|eb_content
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|eb_body
condition|)
name|free
argument_list|(
name|e
operator|->
name|eb_body
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|e
argument_list|)
expr_stmt|;
name|ct
operator|->
name|c_ctparams
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|k2v
name|SubMessage
index|[]
init|=
block|{
literal|"rfc822"
block|,
name|MESSAGE_RFC822
block|,
literal|"partial"
block|,
name|MESSAGE_PARTIAL
block|,
literal|"external-body"
block|,
name|MESSAGE_EXTERNAL
block|,
name|NULL
block|,
name|MESSAGE_UNKNOWN
comment|/* this one must be last! */
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|InitMessage
parameter_list|(
name|ct
parameter_list|)
specifier|register
name|CT
name|ct
decl_stmt|;
block|{
specifier|register
name|struct
name|k2v
modifier|*
name|kv
decl_stmt|;
specifier|register
name|CI
name|ci
init|=
operator|&
name|ct
operator|->
name|c_ctinfo
decl_stmt|;
if|if
condition|(
name|ct
operator|->
name|c_encoding
operator|!=
name|CE_7BIT
condition|)
block|{
name|admonish
argument_list|(
name|NULLCP
argument_list|,
literal|"\"%s/%s\" type in message %s should be encoded in 7bit"
argument_list|,
name|ci
operator|->
name|ci_type
argument_list|,
name|ci
operator|->
name|ci_subtype
argument_list|,
name|ct
operator|->
name|c_file
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
if|if
condition|(
operator|!
operator|*
name|ci
operator|->
name|ci_subtype
condition|)
comment|/* XXX: attmail bogosity! */
name|ci
operator|->
name|ci_subtype
operator|=
name|add
argument_list|(
literal|"rfc822"
argument_list|,
name|ci
operator|->
name|ci_subtype
argument_list|)
expr_stmt|;
for|for
control|(
name|kv
operator|=
name|SubMessage
init|;
name|kv
operator|->
name|kv_key
condition|;
name|kv
operator|++
control|)
if|if
condition|(
name|uleq
argument_list|(
name|ci
operator|->
name|ci_subtype
argument_list|,
name|kv
operator|->
name|kv_key
argument_list|)
condition|)
break|break;
switch|switch
condition|(
name|ct
operator|->
name|c_subtype
operator|=
name|kv
operator|->
name|kv_value
condition|)
block|{
case|case
name|MESSAGE_RFC822
case|:
name|ct
operator|->
name|c_showproc
operator|=
name|add
argument_list|(
literal|"%pshow -file '%F'"
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
break|break;
case|case
name|MESSAGE_PARTIAL
case|:
block|{
specifier|register
name|char
modifier|*
modifier|*
name|ap
decl_stmt|,
modifier|*
modifier|*
name|ep
decl_stmt|;
specifier|register
name|struct
name|partial
modifier|*
name|p
decl_stmt|;
name|ct
operator|->
name|c_ctshowfnx
operator|=
name|NULL
expr_stmt|;
name|ct
operator|->
name|c_ctstorefnx
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
operator|(
expr|struct
name|partial
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
expr|*
name|p
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
name|ct
operator|->
name|c_ctparams
operator|=
operator|(
name|caddr_t
operator|)
name|p
expr_stmt|;
name|ct
operator|->
name|c_ctfreefnx
operator|=
name|free_partial
expr_stmt|;
for|for
control|(
name|ap
operator|=
name|ci
operator|->
name|ci_attrs
operator|,
name|ep
operator|=
name|ci
operator|->
name|ci_values
init|;
operator|*
name|ap
condition|;
name|ap
operator|++
operator|,
name|ep
operator|++
control|)
block|{
if|if
condition|(
name|uleq
argument_list|(
operator|*
name|ap
argument_list|,
literal|"id"
argument_list|)
condition|)
block|{
name|p
operator|->
name|pm_partid
operator|=
name|add
argument_list|(
operator|*
name|ep
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|uleq
argument_list|(
operator|*
name|ap
argument_list|,
literal|"number"
argument_list|)
condition|)
block|{
if|if
condition|(
name|sscanf
argument_list|(
operator|*
name|ep
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|p
operator|->
name|pm_partno
argument_list|)
operator|!=
literal|1
operator|||
name|p
operator|->
name|pm_partno
operator|<
literal|1
condition|)
block|{
name|invalid_param
label|:
empty_stmt|;
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"invalid %s parameter for \"%s/%s\" type in message %s's %s field"
argument_list|,
operator|*
name|ap
argument_list|,
name|ci
operator|->
name|ci_type
argument_list|,
name|ci
operator|->
name|ci_subtype
argument_list|,
name|ct
operator|->
name|c_file
argument_list|,
name|TYPE_FIELD
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
continue|continue;
block|}
if|if
condition|(
name|uleq
argument_list|(
operator|*
name|ap
argument_list|,
literal|"total"
argument_list|)
condition|)
block|{
if|if
condition|(
name|sscanf
argument_list|(
operator|*
name|ep
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|p
operator|->
name|pm_maxno
argument_list|)
operator|!=
literal|1
operator|||
name|p
operator|->
name|pm_maxno
operator|<
literal|1
condition|)
goto|goto
name|invalid_param
goto|;
continue|continue;
block|}
block|}
if|if
condition|(
operator|!
name|p
operator|->
name|pm_partid
operator|||
operator|!
name|p
operator|->
name|pm_partno
operator|||
operator|(
name|p
operator|->
name|pm_maxno
operator|&&
name|p
operator|->
name|pm_partno
operator|>
name|p
operator|->
name|pm_maxno
operator|)
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"invalid parameters for \"%s/%s\" type in message %s's %s field"
argument_list|,
name|ci
operator|->
name|ci_type
argument_list|,
name|ci
operator|->
name|ci_subtype
argument_list|,
name|ct
operator|->
name|c_file
argument_list|,
name|TYPE_FIELD
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
name|ct
operator|->
name|c_ctlistfnx
operator|=
name|list_partial
expr_stmt|;
name|ct
operator|->
name|c_ctstorefnx
operator|=
name|store_partial
expr_stmt|;
block|}
break|break;
case|case
name|MESSAGE_EXTERNAL
case|:
block|{
name|int
name|exresult
decl_stmt|;
specifier|register
name|struct
name|exbody
modifier|*
name|e
decl_stmt|;
name|CT
name|p
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|ct
operator|->
name|c_ctshowfnx
operator|=
name|NULL
expr_stmt|;
name|ct
operator|->
name|c_ctstorefnx
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|e
operator|=
operator|(
expr|struct
name|exbody
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
expr|*
name|e
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
name|ct
operator|->
name|c_ctparams
operator|=
operator|(
name|caddr_t
operator|)
name|e
expr_stmt|;
name|ct
operator|->
name|c_ctfreefnx
operator|=
name|free_external
expr_stmt|;
if|if
condition|(
operator|!
name|ct
operator|->
name|c_fp
operator|&&
operator|(
name|ct
operator|->
name|c_fp
operator|=
name|fopen
argument_list|(
name|ct
operator|->
name|c_file
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|advise
argument_list|(
name|ct
operator|->
name|c_file
argument_list|,
literal|"unable to open for reading"
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
operator|(
name|void
operator|)
name|fseek
argument_list|(
name|fp
operator|=
name|ct
operator|->
name|c_fp
argument_list|,
name|ct
operator|->
name|c_begin
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|get_content
argument_list|(
name|fp
argument_list|,
name|ct
operator|->
name|c_file
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|NULLCT
condition|)
block|{
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|ct
operator|->
name|c_fp
argument_list|)
operator|,
name|ct
operator|->
name|c_fp
operator|=
name|NULL
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
name|e
operator|->
name|eb_parent
operator|=
name|ct
expr_stmt|;
name|e
operator|->
name|eb_content
operator|=
name|p
expr_stmt|;
name|p
operator|->
name|c_ctextern
operator|=
operator|(
name|caddr_t
operator|)
name|e
expr_stmt|;
if|if
condition|(
operator|(
name|exresult
operator|=
name|params_external
argument_list|(
name|ct
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
name|NOTOK
operator|&&
name|p
operator|->
name|c_ceopenfnx
operator|==
name|openMail
condition|)
block|{
name|int
name|cc
decl_stmt|,
name|size
decl_stmt|;
name|char
modifier|*
name|bp
decl_stmt|;
if|if
condition|(
operator|(
name|size
operator|=
name|ct
operator|->
name|c_end
operator|-
name|p
operator|->
name|c_begin
operator|)
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|e
operator|->
name|eb_subject
condition|)
name|content_error
argument_list|(
name|NULLCP
argument_list|,
name|ct
argument_list|,
literal|"empty body for access-type=mail-server"
argument_list|)
expr_stmt|;
goto|goto
name|no_body
goto|;
block|}
if|if
condition|(
operator|(
name|e
operator|->
name|eb_body
operator|=
name|bp
operator|=
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|size
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fseek
argument_list|(
name|p
operator|->
name|c_fp
argument_list|,
name|p
operator|->
name|c_begin
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|size
operator|>
literal|0
condition|)
switch|switch
condition|(
name|cc
operator|=
name|fread
argument_list|(
name|bp
argument_list|,
sizeof|sizeof
expr|*
name|bp
argument_list|,
name|size
argument_list|,
name|p
operator|->
name|c_fp
argument_list|)
condition|)
block|{
case|case
name|NOTOK
case|:
name|adios
argument_list|(
literal|"failed"
argument_list|,
literal|"fread"
argument_list|)
expr_stmt|;
case|case
name|OK
case|:
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"unexpected EOF from fread"
argument_list|)
expr_stmt|;
default|default:
name|bp
operator|+=
name|cc
operator|,
name|size
operator|-=
name|cc
expr_stmt|;
break|break;
block|}
operator|*
name|bp
operator|=
literal|0
expr_stmt|;
name|no_body
label|:
empty_stmt|;
block|}
name|p
operator|->
name|c_fp
operator|=
name|NULL
expr_stmt|;
name|p
operator|->
name|c_end
operator|=
name|p
operator|->
name|c_begin
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|ct
operator|->
name|c_fp
argument_list|)
operator|,
name|ct
operator|->
name|c_fp
operator|=
name|NULL
expr_stmt|;
name|ct
operator|->
name|c_ctlistfnx
operator|=
name|list_external
expr_stmt|;
if|if
condition|(
name|exresult
operator|==
name|NOTOK
condition|)
return|return
name|NOTOK
return|;
if|if
condition|(
name|e
operator|->
name|eb_flags
operator|==
name|NOTOK
condition|)
return|return
name|OK
return|;
if|if
condition|(
name|e
operator|->
name|eb_name
operator|&&
name|autosw
condition|)
block|{
name|char
modifier|*
name|cp
init|=
name|e
operator|->
name|eb_name
decl_stmt|;
if|if
condition|(
operator|*
name|cp
operator|!=
literal|'/'
operator|&&
operator|*
name|cp
operator|!=
literal|'.'
operator|&&
operator|*
name|cp
operator|!=
literal|'|'
operator|&&
operator|*
name|cp
operator|!=
literal|'!'
operator|&&
operator|!
name|index
argument_list|(
name|cp
argument_list|,
literal|'%'
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|ct
operator|->
name|c_storeproc
condition|)
name|ct
operator|->
name|c_storeproc
operator|=
name|add
argument_list|(
name|cp
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p
operator|->
name|c_storeproc
condition|)
name|p
operator|->
name|c_storeproc
operator|=
name|add
argument_list|(
name|cp
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
block|}
block|}
name|ct
operator|->
name|c_ctshowfnx
operator|=
name|show_external
expr_stmt|;
name|ct
operator|->
name|c_ctstorefnx
operator|=
name|store_external
expr_stmt|;
switch|switch
condition|(
name|p
operator|->
name|c_type
condition|)
block|{
case|case
name|CT_MULTIPART
case|:
break|break;
case|case
name|CT_MESSAGE
case|:
if|if
condition|(
name|p
operator|->
name|c_subtype
operator|!=
name|MESSAGE_RFC822
condition|)
break|break;
comment|/* else fall... */
default|default:
name|e
operator|->
name|eb_partno
operator|=
name|ct
operator|->
name|c_partno
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|c_ctinitfnx
condition|)
call|(
name|void
call|)
argument_list|(
operator|*
name|p
operator|->
name|c_ctinitfnx
argument_list|)
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
break|break;
default|default:
break|break;
block|}
return|return
name|OK
return|;
block|}
end_function

begin_comment
comment|/*
comment|APPLICATION */
end_comment

begin_define
define|#
directive|define
name|APPLICATION_UNKNOWN
value|0x00
end_define

begin_define
define|#
directive|define
name|APPLICATION_OCTETS
value|0x01
end_define

begin_define
define|#
directive|define
name|APPLICATION_POSTSCRIPT
value|0x02
end_define

begin_function
specifier|static
name|int
name|list_application
parameter_list|(
name|ct
parameter_list|,
name|toplevel
parameter_list|)
specifier|register
name|CT
name|ct
decl_stmt|;
name|int
name|toplevel
decl_stmt|;
block|{
operator|(
name|void
operator|)
name|list_content
argument_list|(
name|ct
argument_list|,
name|toplevel
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbosw
condition|)
block|{
specifier|register
name|char
modifier|*
modifier|*
name|ap
decl_stmt|,
modifier|*
modifier|*
name|ep
decl_stmt|;
specifier|register
name|CI
name|ci
init|=
operator|&
name|ct
operator|->
name|c_ctinfo
decl_stmt|;
for|for
control|(
name|ap
operator|=
name|ci
operator|->
name|ci_attrs
operator|,
name|ep
operator|=
name|ci
operator|->
name|ci_values
init|;
operator|*
name|ap
condition|;
name|ap
operator|++
operator|,
name|ep
operator|++
control|)
name|printf
argument_list|(
literal|"\t     %s=\"%s\"\n"
argument_list|,
operator|*
name|ap
argument_list|,
operator|*
name|ep
argument_list|)
expr_stmt|;
block|}
return|return
name|OK
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|k2v
name|SubApplication
index|[]
init|=
block|{
literal|"octet-stream"
block|,
name|APPLICATION_OCTETS
block|,
literal|"postscript"
block|,
name|APPLICATION_POSTSCRIPT
block|,
name|NULL
block|,
name|APPLICATION_UNKNOWN
comment|/* this one must be last! */
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|InitApplication
parameter_list|(
name|ct
parameter_list|)
specifier|register
name|CT
name|ct
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
modifier|*
name|ap
decl_stmt|,
modifier|*
modifier|*
name|ep
decl_stmt|;
specifier|register
name|struct
name|k2v
modifier|*
name|kv
decl_stmt|;
specifier|register
name|CI
name|ci
init|=
operator|&
name|ct
operator|->
name|c_ctinfo
decl_stmt|;
name|ct
operator|->
name|c_ctlistfnx
operator|=
name|list_application
expr_stmt|;
for|for
control|(
name|kv
operator|=
name|SubApplication
init|;
name|kv
operator|->
name|kv_key
condition|;
name|kv
operator|++
control|)
if|if
condition|(
name|uleq
argument_list|(
name|ci
operator|->
name|ci_subtype
argument_list|,
name|kv
operator|->
name|kv_key
argument_list|)
condition|)
break|break;
for|for
control|(
name|ap
operator|=
name|ci
operator|->
name|ci_attrs
operator|,
name|ep
operator|=
name|ci
operator|->
name|ci_values
init|;
operator|*
name|ap
condition|;
name|ap
operator|++
operator|,
name|ep
operator|++
control|)
if|if
condition|(
name|autosw
operator|&&
operator|!
name|ct
operator|->
name|c_storeproc
operator|&&
name|uleq
argument_list|(
operator|*
name|ap
argument_list|,
literal|"x-name"
argument_list|)
condition|)
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
operator|*
operator|(
name|cp
operator|=
operator|*
name|ep
operator|)
operator|!=
literal|'/'
operator|&&
operator|*
name|cp
operator|!=
literal|'.'
operator|&&
operator|*
name|cp
operator|!=
literal|'|'
operator|&&
operator|*
name|cp
operator|!=
literal|'!'
operator|&&
operator|!
name|index
argument_list|(
name|cp
argument_list|,
literal|'%'
argument_list|)
condition|)
name|ct
operator|->
name|c_storeproc
operator|=
name|add
argument_list|(
name|cp
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ct
operator|->
name|c_subtype
operator|=
name|kv
operator|->
name|kv_value
operator|)
operator|==
name|APPLICATION_OCTETS
condition|)
block|{
name|int
name|tarP
decl_stmt|,
name|zP
decl_stmt|;
name|tarP
operator|=
name|zP
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|ap
operator|=
name|ci
operator|->
name|ci_attrs
operator|,
name|ep
operator|=
name|ci
operator|->
name|ci_values
init|;
operator|*
name|ap
condition|;
name|ap
operator|++
operator|,
name|ep
operator|++
control|)
block|{
if|if
condition|(
name|uleq
argument_list|(
operator|*
name|ap
argument_list|,
literal|"type"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|uleq
argument_list|(
operator|*
name|ep
argument_list|,
literal|"tar"
argument_list|)
condition|)
break|break;
name|tarP
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|uleq
argument_list|(
operator|*
name|ap
argument_list|,
literal|"conversions"
argument_list|)
operator|||
name|uleq
argument_list|(
operator|*
name|ap
argument_list|,
literal|"x-conversions"
argument_list|)
operator|)
operator|&&
operator|(
name|uleq
argument_list|(
operator|*
name|ep
argument_list|,
literal|"compress"
argument_list|)
operator|||
name|uleq
argument_list|(
operator|*
name|ep
argument_list|,
literal|"x-compress"
argument_list|)
operator|)
condition|)
block|{
name|zP
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
name|tarP
condition|)
block|{
name|ct
operator|->
name|c_showproc
operator|=
name|add
argument_list|(
name|zP
condition|?
literal|"%euncompress | tar tvf -"
else|:
literal|"%etar tvf -"
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ct
operator|->
name|c_storeproc
condition|)
if|if
condition|(
name|autosw
condition|)
block|{
name|ct
operator|->
name|c_storeproc
operator|=
name|add
argument_list|(
name|zP
condition|?
literal|"| uncompress | tar xvpf -"
else|:
literal|"| tar xvpf -"
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
name|ct
operator|->
name|c_umask
operator|=
literal|0022
expr_stmt|;
block|}
else|else
name|ct
operator|->
name|c_storeproc
operator|=
name|add
argument_list|(
name|zP
condition|?
literal|"%m%P.tar.Z"
else|:
literal|"%m%P.tar"
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|OK
return|;
block|}
end_function

begin_comment
comment|/*
comment|ENCODINGS */
end_comment

begin_include
include|#
directive|include
file|"md5.c"
end_include

begin_struct
struct|struct
name|cefile
block|{
name|char
modifier|*
name|ce_file
decl_stmt|;
name|int
name|ce_unlink
decl_stmt|;
name|FILE
modifier|*
name|ce_fp
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|list_encoding
parameter_list|(
name|ct
parameter_list|)
specifier|register
name|CT
name|ct
decl_stmt|;
block|{
specifier|register
name|struct
name|cefile
modifier|*
name|ce
init|=
operator|(
expr|struct
name|cefile
operator|*
operator|)
name|ct
operator|->
name|c_ceparams
decl_stmt|;
if|if
condition|(
name|ce
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  decoded fp 0x%x file \"%s\"\n"
argument_list|,
name|ce
operator|->
name|ce_fp
argument_list|,
name|ce
operator|->
name|ce_file
condition|?
name|ce
operator|->
name|ce_file
else|:
literal|""
argument_list|)
expr_stmt|;
return|return
name|OK
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|close_encoding
parameter_list|(
name|ct
parameter_list|)
specifier|register
name|CT
name|ct
decl_stmt|;
block|{
specifier|register
name|struct
name|cefile
modifier|*
name|ce
init|=
operator|(
expr|struct
name|cefile
operator|*
operator|)
name|ct
operator|->
name|c_ceparams
decl_stmt|;
if|if
condition|(
operator|!
name|ce
condition|)
return|return;
if|if
condition|(
name|ce
operator|->
name|ce_fp
condition|)
block|{
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|ce
operator|->
name|ce_fp
argument_list|)
expr_stmt|;
name|ce
operator|->
name|ce_fp
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|unsigned
name|long
name|size_encoding
parameter_list|(
name|ct
parameter_list|)
specifier|register
name|CT
name|ct
decl_stmt|;
block|{
name|int
name|fd
decl_stmt|;
name|unsigned
name|long
name|size
decl_stmt|;
name|char
modifier|*
name|file
decl_stmt|;
specifier|register
name|struct
name|cefile
modifier|*
name|ce
init|=
operator|(
expr|struct
name|cefile
operator|*
operator|)
name|ct
operator|->
name|c_ceparams
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
if|if
condition|(
operator|!
name|ce
condition|)
block|{
name|estimate
label|:
empty_stmt|;
return|return
operator|(
name|ct
operator|->
name|c_end
operator|-
name|ct
operator|->
name|c_begin
operator|)
return|;
block|}
if|if
condition|(
name|ce
operator|->
name|ce_fp
operator|&&
name|fstat
argument_list|(
name|fileno
argument_list|(
name|ce
operator|->
name|ce_fp
argument_list|)
argument_list|,
operator|&
name|st
argument_list|)
operator|!=
name|NOTOK
condition|)
return|return
operator|(
name|long
operator|)
name|st
operator|.
name|st_size
return|;
if|if
condition|(
name|ce
operator|->
name|ce_file
condition|)
return|return
name|stat
argument_list|(
name|ce
operator|->
name|ce_file
argument_list|,
operator|&
name|st
argument_list|)
operator|!=
name|NOTOK
condition|?
operator|(
name|long
operator|)
name|st
operator|.
name|st_size
else|:
literal|0L
return|;
if|if
condition|(
name|ct
operator|->
name|c_encoding
operator|==
name|CE_EXTERNAL
condition|)
goto|goto
name|estimate
goto|;
name|file
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
call|(
modifier|*
name|ct
operator|->
name|c_ceopenfnx
call|)
argument_list|(
name|ct
argument_list|,
operator|&
name|file
argument_list|)
operator|)
operator|==
name|NOTOK
condition|)
goto|goto
name|estimate
goto|;
name|size
operator|=
name|fstat
argument_list|(
name|fd
argument_list|,
operator|&
name|st
argument_list|)
operator|!=
name|NOTOK
condition|?
operator|(
name|long
operator|)
name|st
operator|.
name|st_size
else|:
literal|0L
expr_stmt|;
call|(
modifier|*
name|ct
operator|->
name|c_ceclosefnx
call|)
argument_list|(
name|ct
argument_list|)
expr_stmt|;
return|return
name|size
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|free_encoding
parameter_list|(
name|ct
parameter_list|,
name|toplevel
parameter_list|)
specifier|register
name|CT
name|ct
decl_stmt|;
name|int
name|toplevel
decl_stmt|;
block|{
specifier|register
name|struct
name|cefile
modifier|*
name|ce
init|=
operator|(
expr|struct
name|cefile
operator|*
operator|)
name|ct
operator|->
name|c_ceparams
decl_stmt|;
if|if
condition|(
operator|!
name|ce
condition|)
return|return;
if|if
condition|(
name|ce
operator|->
name|ce_fp
condition|)
block|{
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|ce
operator|->
name|ce_fp
argument_list|)
expr_stmt|;
name|ce
operator|->
name|ce_fp
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|ce
operator|->
name|ce_file
condition|)
block|{
if|if
condition|(
name|ce
operator|->
name|ce_unlink
condition|)
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|ce
operator|->
name|ce_file
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ce
operator|->
name|ce_file
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|toplevel
condition|)
block|{
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ce
argument_list|)
expr_stmt|;
name|ct
operator|->
name|c_ceparams
operator|=
name|NULL
expr_stmt|;
block|}
else|else
name|ct
operator|->
name|c_ceopenfnx
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_expr_stmt
specifier|static
name|init_encoding
argument_list|(
name|ct
argument_list|,
name|openfnx
argument_list|)
specifier|register
name|CT
name|ct
expr_stmt|;
end_expr_stmt

begin_function_decl
name|int
function_decl|(
modifier|*
name|openfnx
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_block
block|{
specifier|register
name|struct
name|cefile
modifier|*
name|ce
decl_stmt|;
if|if
condition|(
operator|(
name|ce
operator|=
operator|(
expr|struct
name|cefile
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
expr|*
name|ce
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
name|ct
operator|->
name|c_ceparams
operator|=
operator|(
name|caddr_t
operator|)
name|ce
expr_stmt|;
name|ct
operator|->
name|c_ceopenfnx
operator|=
name|openfnx
expr_stmt|;
name|ct
operator|->
name|c_ceclosefnx
operator|=
name|close_encoding
expr_stmt|;
name|ct
operator|->
name|c_cesizefnx
operator|=
name|size_encoding
expr_stmt|;
name|ct
operator|->
name|c_celistfnx
operator|=
name|list_encoding
expr_stmt|;
name|ct
operator|->
name|c_cefreefnx
operator|=
name|free_encoding
expr_stmt|;
return|return
name|OK
return|;
block|}
end_block

begin_comment
comment|/*
comment|BASE64 */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|b642nib
index|[
literal|0x80
index|]
init|=
block|{
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0x3e
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0x3f
block|,
literal|0x34
block|,
literal|0x35
block|,
literal|0x36
block|,
literal|0x37
block|,
literal|0x38
block|,
literal|0x39
block|,
literal|0x3a
block|,
literal|0x3b
block|,
literal|0x3c
block|,
literal|0x3d
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0x00
block|,
literal|0x01
block|,
literal|0x02
block|,
literal|0x03
block|,
literal|0x04
block|,
literal|0x05
block|,
literal|0x06
block|,
literal|0x07
block|,
literal|0x08
block|,
literal|0x09
block|,
literal|0x0a
block|,
literal|0x0b
block|,
literal|0x0c
block|,
literal|0x0d
block|,
literal|0x0e
block|,
literal|0x0f
block|,
literal|0x10
block|,
literal|0x11
block|,
literal|0x12
block|,
literal|0x13
block|,
literal|0x14
block|,
literal|0x15
block|,
literal|0x16
block|,
literal|0x17
block|,
literal|0x18
block|,
literal|0x19
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0x1a
block|,
literal|0x1b
block|,
literal|0x1c
block|,
literal|0x1d
block|,
literal|0x1e
block|,
literal|0x1f
block|,
literal|0x20
block|,
literal|0x21
block|,
literal|0x22
block|,
literal|0x23
block|,
literal|0x24
block|,
literal|0x25
block|,
literal|0x26
block|,
literal|0x27
block|,
literal|0x28
block|,
literal|0x29
block|,
literal|0x2a
block|,
literal|0x2b
block|,
literal|0x2c
block|,
literal|0x2d
block|,
literal|0x2e
block|,
literal|0x2f
block|,
literal|0x30
block|,
literal|0x31
block|,
literal|0x32
block|,
literal|0x33
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|openBase64
parameter_list|(
name|ct
parameter_list|,
name|file
parameter_list|)
specifier|register
name|CT
name|ct
decl_stmt|;
name|char
modifier|*
modifier|*
name|file
decl_stmt|;
block|{
name|int
name|bitno
decl_stmt|,
name|cc
decl_stmt|,
name|digested
decl_stmt|,
name|fd
decl_stmt|,
name|len
decl_stmt|,
name|skip
decl_stmt|;
name|unsigned
name|long
name|bits
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|ep
decl_stmt|;
name|unsigned
name|char
name|value
decl_stmt|,
modifier|*
name|b
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|bits
decl_stmt|,
modifier|*
name|b1
init|=
operator|&
name|b
index|[
name|endian
operator|>
literal|0
condition|?
literal|1
else|:
literal|2
index|]
decl_stmt|,
modifier|*
name|b2
init|=
operator|&
name|b
index|[
name|endian
operator|>
literal|0
condition|?
literal|2
else|:
literal|1
index|]
decl_stmt|,
modifier|*
name|b3
init|=
operator|&
name|b
index|[
name|endian
operator|>
literal|0
condition|?
literal|3
else|:
literal|0
index|]
decl_stmt|;
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
specifier|register
name|struct
name|cefile
modifier|*
name|ce
init|=
operator|(
expr|struct
name|cefile
operator|*
operator|)
name|ct
operator|->
name|c_ceparams
decl_stmt|;
name|MD5_CTX
name|mdContext
decl_stmt|;
if|if
condition|(
name|ce
operator|->
name|ce_fp
condition|)
goto|goto
name|ready_to_go
goto|;
if|if
condition|(
name|ce
operator|->
name|ce_file
condition|)
block|{
if|if
condition|(
operator|(
name|ce
operator|->
name|ce_fp
operator|=
name|fopen
argument_list|(
name|ce
operator|->
name|ce_file
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|content_error
argument_list|(
name|ce
operator|->
name|ce_file
argument_list|,
name|ct
argument_list|,
literal|"unable to fopen for reading"
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
operator|*
name|file
operator|=
name|ce
operator|->
name|ce_file
expr_stmt|;
return|return
name|fileno
argument_list|(
name|ce
operator|->
name|ce_fp
argument_list|)
return|;
block|}
name|ce
operator|->
name|ce_unlink
operator|=
operator|*
name|file
operator|==
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|ce
operator|->
name|ce_fp
operator|=
name|fopen
argument_list|(
name|ce
operator|->
name|ce_file
operator|=
name|add
argument_list|(
operator|*
name|file
condition|?
operator|*
name|file
else|:
name|m_scratch
argument_list|(
literal|""
argument_list|,
name|tmp
argument_list|)
argument_list|,
name|NULLCP
argument_list|)
argument_list|,
literal|"w+"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|content_error
argument_list|(
name|ce
operator|->
name|ce_file
argument_list|,
name|ct
argument_list|,
literal|"unable to fopen for writing and reading"
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
if|if
condition|(
operator|(
name|len
operator|=
name|ct
operator|->
name|c_end
operator|-
name|ct
operator|->
name|c_begin
operator|)
operator|<
literal|0
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"internal error(1)"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ct
operator|->
name|c_fp
operator|&&
operator|(
name|ct
operator|->
name|c_fp
operator|=
name|fopen
argument_list|(
name|ct
operator|->
name|c_file
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|content_error
argument_list|(
name|ct
operator|->
name|c_file
argument_list|,
name|ct
argument_list|,
literal|"unable to open for reading"
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
if|if
condition|(
name|digested
operator|=
name|ct
operator|->
name|c_digested
condition|)
name|MD5Init
argument_list|(
operator|&
name|mdContext
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|lseek
argument_list|(
name|fd
operator|=
name|fileno
argument_list|(
name|ct
operator|->
name|c_fp
argument_list|)
argument_list|,
operator|(
name|off_t
operator|)
name|ct
operator|->
name|c_begin
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bitno
operator|=
literal|18
operator|,
name|bits
operator|=
literal|0L
operator|,
name|skip
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
condition|)
switch|switch
condition|(
name|cc
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|buffer
argument_list|,
sizeof|sizeof
name|buffer
operator|-
literal|1
argument_list|)
condition|)
block|{
case|case
name|NOTOK
case|:
name|content_error
argument_list|(
name|ct
operator|->
name|c_file
argument_list|,
name|ct
argument_list|,
literal|"error reading from"
argument_list|)
expr_stmt|;
goto|goto
name|clean_up
goto|;
case|case
name|OK
case|:
name|content_error
argument_list|(
name|NULLCP
argument_list|,
name|ct
argument_list|,
literal|"premature eof"
argument_list|)
expr_stmt|;
goto|goto
name|clean_up
goto|;
default|default:
if|if
condition|(
name|cc
operator|>
name|len
condition|)
name|cc
operator|=
name|len
expr_stmt|;
name|len
operator|-=
name|cc
expr_stmt|;
for|for
control|(
name|ep
operator|=
operator|(
name|cp
operator|=
name|buffer
operator|)
operator|+
name|cc
init|;
name|cp
operator|<
name|ep
condition|;
name|cp
operator|++
control|)
switch|switch
condition|(
operator|*
name|cp
condition|)
block|{
default|default:
if|if
condition|(
name|isspace
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
break|break;
if|if
condition|(
name|skip
operator|||
operator|(
operator|*
name|cp
operator|&
literal|0x80
operator|)
operator|||
operator|(
name|value
operator|=
name|b642nib
index|[
operator|*
name|cp
operator|&
literal|0x7f
index|]
operator|)
operator|>
literal|0x3f
condition|)
block|{
if|if
condition|(
name|debugsw
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"*cp=0x%x pos=%ld skip=%d\n"
argument_list|,
operator|*
name|cp
argument_list|,
operator|(
name|long
operator|)
name|lseek
argument_list|(
name|fd
argument_list|,
operator|(
name|off_t
operator|)
literal|0
argument_list|,
literal|1
argument_list|)
operator|-
operator|(
name|ep
operator|-
name|cp
operator|)
argument_list|,
name|skip
argument_list|)
expr_stmt|;
name|content_error
argument_list|(
name|NULLCP
argument_list|,
name|ct
argument_list|,
literal|"invalid BASE64 encoding -- continuing"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|bits
operator||=
name|value
operator|<<
name|bitno
expr_stmt|;
name|test_end
label|:
empty_stmt|;
if|if
condition|(
operator|(
name|bitno
operator|-=
literal|6
operator|)
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|putc
argument_list|(
operator|(
name|char
operator|)
operator|*
name|b1
argument_list|,
name|ce
operator|->
name|ce_fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|digested
condition|)
name|MD5Update
argument_list|(
operator|&
name|mdContext
argument_list|,
name|b1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|skip
operator|<
literal|2
condition|)
block|{
operator|(
name|void
operator|)
name|putc
argument_list|(
operator|(
name|char
operator|)
operator|*
name|b2
argument_list|,
name|ce
operator|->
name|ce_fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|digested
condition|)
name|MD5Update
argument_list|(
operator|&
name|mdContext
argument_list|,
name|b2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|skip
operator|<
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|putc
argument_list|(
operator|(
name|char
operator|)
operator|*
name|b3
argument_list|,
name|ce
operator|->
name|ce_fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|digested
condition|)
name|MD5Update
argument_list|(
operator|&
name|mdContext
argument_list|,
name|b3
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ferror
argument_list|(
name|ce
operator|->
name|ce_fp
argument_list|)
condition|)
block|{
name|content_error
argument_list|(
name|ce
operator|->
name|ce_file
argument_list|,
name|ct
argument_list|,
literal|"error writing to"
argument_list|)
expr_stmt|;
goto|goto
name|clean_up
goto|;
block|}
name|bitno
operator|=
literal|18
operator|,
name|bits
operator|=
literal|0L
operator|,
name|skip
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
literal|'='
case|:
if|if
condition|(
operator|++
name|skip
operator|>
literal|3
condition|)
goto|goto
name|self_delimiting
goto|;
goto|goto
name|test_end
goto|;
block|}
block|}
if|if
condition|(
name|bitno
operator|!=
literal|18
condition|)
block|{
if|if
condition|(
name|debugsw
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"premature ending (bitno %d)\n"
argument_list|,
name|bitno
argument_list|)
expr_stmt|;
name|content_error
argument_list|(
name|NULLCP
argument_list|,
name|ct
argument_list|,
literal|"invalid BASE64 encoding"
argument_list|)
expr_stmt|;
goto|goto
name|clean_up
goto|;
block|}
name|self_delimiting
label|:
empty_stmt|;
operator|(
name|void
operator|)
name|fseek
argument_list|(
name|ct
operator|->
name|c_fp
argument_list|,
literal|0L
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fflush
argument_list|(
name|ce
operator|->
name|ce_fp
argument_list|)
condition|)
block|{
name|content_error
argument_list|(
name|ce
operator|->
name|ce_file
argument_list|,
name|ct
argument_list|,
literal|"error writing to"
argument_list|)
expr_stmt|;
goto|goto
name|clean_up
goto|;
block|}
if|if
condition|(
name|digested
condition|)
block|{
name|unsigned
name|char
name|digest
index|[
literal|16
index|]
decl_stmt|;
name|MD5Final
argument_list|(
name|digest
argument_list|,
operator|&
name|mdContext
argument_list|)
expr_stmt|;
if|if
condition|(
name|bcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|digest
argument_list|,
operator|(
name|char
operator|*
operator|)
name|ct
operator|->
name|c_digest
argument_list|,
sizeof|sizeof
name|digest
operator|/
sizeof|sizeof
name|digest
index|[
literal|0
index|]
argument_list|)
condition|)
name|content_error
argument_list|(
name|NULLCP
argument_list|,
name|ct
argument_list|,
literal|"content integrity suspect (digest mismatch) -- continuing"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|debugsw
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"content integrity confirmed\n"
argument_list|)
expr_stmt|;
block|}
name|ready_to_go
label|:
empty_stmt|;
operator|(
name|void
operator|)
name|fseek
argument_list|(
name|ce
operator|->
name|ce_fp
argument_list|,
literal|0L
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|file
operator|=
name|ce
operator|->
name|ce_file
expr_stmt|;
return|return
name|fileno
argument_list|(
name|ce
operator|->
name|ce_fp
argument_list|)
return|;
name|clean_up
label|:
empty_stmt|;
name|free_encoding
argument_list|(
name|ct
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|InitBase64
parameter_list|(
name|ct
parameter_list|)
specifier|register
name|CT
name|ct
decl_stmt|;
block|{
return|return
name|init_encoding
argument_list|(
name|ct
argument_list|,
name|openBase64
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|set_endian
parameter_list|()
block|{
name|char
modifier|*
name|cp
decl_stmt|;
union|union
block|{
name|long
name|l
decl_stmt|;
name|char
name|c
index|[
sizeof|sizeof
argument_list|(
name|long
argument_list|)
index|]
decl_stmt|;
block|}
name|un
union|;
name|un
operator|.
name|l
operator|=
literal|1
expr_stmt|;
name|endian
operator|=
name|un
operator|.
name|c
index|[
literal|0
index|]
condition|?
operator|-
literal|1
else|:
literal|1
expr_stmt|;
if|if
condition|(
name|debugsw
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s endian architecture\n"
argument_list|,
name|endian
operator|>
literal|0
condition|?
literal|"big"
else|:
literal|"little"
argument_list|)
expr_stmt|;
name|mm_charset
operator|=
name|getenv
argument_list|(
literal|"MM_CHARSET"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|getenv
argument_list|(
literal|"MM_NOASK"
argument_list|)
operator|)
operator|&&
name|strcmp
argument_list|(
name|cp
argument_list|,
literal|"1"
argument_list|)
operator|==
literal|0
condition|)
name|nolist
operator|=
literal|1
operator|,
name|listsw
operator|=
name|pausesw
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*
comment|QUOTED */
end_comment

begin_decl_stmt
specifier|static
name|char
name|hex2nib
index|[
literal|0x80
index|]
init|=
block|{
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x01
block|,
literal|0x02
block|,
literal|0x03
block|,
literal|0x04
block|,
literal|0x05
block|,
literal|0x06
block|,
literal|0x07
block|,
literal|0x08
block|,
literal|0x09
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x0A
block|,
literal|0x0B
block|,
literal|0x0C
block|,
literal|0x0D
block|,
literal|0x0E
block|,
literal|0x0F
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x0a
block|,
literal|0x0b
block|,
literal|0x0c
block|,
literal|0x0d
block|,
literal|0x0e
block|,
literal|0x0f
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|openQuoted
parameter_list|(
name|ct
parameter_list|,
name|file
parameter_list|)
specifier|register
name|CT
name|ct
decl_stmt|;
name|char
modifier|*
modifier|*
name|file
decl_stmt|;
block|{
name|int
name|cc
decl_stmt|,
name|digested
decl_stmt|,
name|len
decl_stmt|,
name|quoted
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|ep
decl_stmt|;
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|unsigned
name|char
name|mask
decl_stmt|;
specifier|register
name|struct
name|cefile
modifier|*
name|ce
init|=
operator|(
expr|struct
name|cefile
operator|*
operator|)
name|ct
operator|->
name|c_ceparams
decl_stmt|;
name|MD5_CTX
name|mdContext
decl_stmt|;
if|if
condition|(
name|ce
operator|->
name|ce_fp
condition|)
goto|goto
name|ready_to_go
goto|;
if|if
condition|(
name|ce
operator|->
name|ce_file
condition|)
block|{
if|if
condition|(
operator|(
name|ce
operator|->
name|ce_fp
operator|=
name|fopen
argument_list|(
name|ce
operator|->
name|ce_file
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|content_error
argument_list|(
name|ce
operator|->
name|ce_file
argument_list|,
name|ct
argument_list|,
literal|"unable to fopen for reading"
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
operator|*
name|file
operator|=
name|ce
operator|->
name|ce_file
expr_stmt|;
return|return
name|fileno
argument_list|(
name|ce
operator|->
name|ce_fp
argument_list|)
return|;
block|}
name|ce
operator|->
name|ce_unlink
operator|=
operator|*
name|file
operator|==
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|ce
operator|->
name|ce_fp
operator|=
name|fopen
argument_list|(
name|ce
operator|->
name|ce_file
operator|=
name|add
argument_list|(
operator|*
name|file
condition|?
operator|*
name|file
else|:
name|m_scratch
argument_list|(
literal|""
argument_list|,
name|tmp
argument_list|)
argument_list|,
name|NULLCP
argument_list|)
argument_list|,
literal|"w+"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|content_error
argument_list|(
name|ce
operator|->
name|ce_file
argument_list|,
name|ct
argument_list|,
literal|"unable to fopen for writing and reading"
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
if|if
condition|(
operator|(
name|len
operator|=
name|ct
operator|->
name|c_end
operator|-
name|ct
operator|->
name|c_begin
operator|)
operator|<
literal|0
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"internal error(2)"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ct
operator|->
name|c_fp
operator|&&
operator|(
name|ct
operator|->
name|c_fp
operator|=
name|fopen
argument_list|(
name|ct
operator|->
name|c_file
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|content_error
argument_list|(
name|ct
operator|->
name|c_file
argument_list|,
name|ct
argument_list|,
literal|"unable to open for reading"
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
if|if
condition|(
name|digested
operator|=
name|ct
operator|->
name|c_digested
condition|)
name|MD5Init
argument_list|(
operator|&
name|mdContext
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fseek
argument_list|(
name|ct
operator|->
name|c_fp
argument_list|,
name|ct
operator|->
name|c_begin
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|quoted
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|lint
name|mask
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|char
modifier|*
name|dp
decl_stmt|;
if|if
condition|(
name|fgets
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
name|buffer
operator|-
literal|1
argument_list|,
name|ct
operator|->
name|c_fp
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|content_error
argument_list|(
name|NULLCP
argument_list|,
name|ct
argument_list|,
literal|"premature eof"
argument_list|)
expr_stmt|;
goto|goto
name|clean_up
goto|;
block|}
if|if
condition|(
operator|(
name|cc
operator|=
name|strlen
argument_list|(
name|buffer
argument_list|)
operator|)
operator|>
name|len
condition|)
name|cc
operator|=
name|len
expr_stmt|;
name|len
operator|-=
name|cc
expr_stmt|;
for|for
control|(
name|ep
operator|=
operator|(
name|cp
operator|=
name|buffer
operator|)
operator|+
name|cc
operator|-
literal|1
init|;
name|cp
operator|<=
name|ep
condition|;
name|ep
operator|--
control|)
if|if
condition|(
operator|!
name|isspace
argument_list|(
operator|*
name|ep
argument_list|)
condition|)
break|break;
operator|*
operator|++
name|ep
operator|=
literal|'\n'
operator|,
name|ep
operator|++
expr_stmt|;
for|for
control|(
init|;
name|cp
operator|<
name|ep
condition|;
name|cp
operator|++
control|)
block|{
if|if
condition|(
name|quoted
condition|)
block|{
if|if
condition|(
name|quoted
operator|>
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|isxdigit
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
block|{
name|invalid_hex
label|:
empty_stmt|;
name|dp
operator|=
literal|"expecting hexidecimal-digit"
expr_stmt|;
goto|goto
name|invalid_encoding
goto|;
block|}
name|mask
operator|<<=
literal|4
expr_stmt|;
name|mask
operator||=
name|hex2nib
index|[
operator|*
name|cp
operator|&
literal|0x7f
index|]
expr_stmt|;
operator|(
name|void
operator|)
name|putc
argument_list|(
name|mask
argument_list|,
name|ce
operator|->
name|ce_fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|digested
condition|)
name|MD5Update
argument_list|(
operator|&
name|mdContext
argument_list|,
operator|&
name|mask
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
switch|switch
condition|(
operator|*
name|cp
condition|)
block|{
case|case
literal|':'
case|:
operator|(
name|void
operator|)
name|putc
argument_list|(
operator|*
name|cp
argument_list|,
name|ce
operator|->
name|ce_fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|digested
condition|)
name|MD5Update
argument_list|(
operator|&
name|mdContext
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
literal|":"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
operator|!
name|isxdigit
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
goto|goto
name|invalid_hex
goto|;
name|mask
operator|=
name|hex2nib
index|[
operator|*
name|cp
operator|&
literal|0x7f
index|]
expr_stmt|;
name|quoted
operator|=
literal|2
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|ferror
argument_list|(
name|ce
operator|->
name|ce_fp
argument_list|)
condition|)
block|{
name|content_error
argument_list|(
name|ce
operator|->
name|ce_file
argument_list|,
name|ct
argument_list|,
literal|"error writing to"
argument_list|)
expr_stmt|;
goto|goto
name|clean_up
goto|;
block|}
name|quoted
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
switch|switch
condition|(
operator|*
name|cp
condition|)
block|{
default|default:
if|if
condition|(
operator|*
name|cp
operator|<
literal|'!'
operator|||
operator|*
name|cp
operator|>
literal|'~'
condition|)
block|{
name|int
name|i
decl_stmt|;
name|dp
operator|=
literal|"expecting character in range [!..~]"
expr_stmt|;
name|invalid_encoding
label|:
empty_stmt|;
name|i
operator|=
name|strlen
argument_list|(
name|invo_name
argument_list|)
operator|+
literal|2
expr_stmt|;
name|content_error
argument_list|(
name|NULLCP
argument_list|,
name|ct
argument_list|,
literal|"invalid QUOTED-PRINTABLE encoding -- %s,\n%*.*sbut got char 0x%x"
argument_list|,
name|dp
argument_list|,
name|i
argument_list|,
name|i
argument_list|,
literal|""
argument_list|,
operator|*
name|cp
argument_list|)
expr_stmt|;
goto|goto
name|clean_up
goto|;
block|}
comment|/* and fall...*/
case|case
literal|' '
case|:
case|case
literal|'\t'
case|:
case|case
literal|'\n'
case|:
operator|(
name|void
operator|)
name|putc
argument_list|(
operator|*
name|cp
argument_list|,
name|ce
operator|->
name|ce_fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|digested
condition|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\n'
condition|)
name|MD5Update
argument_list|(
operator|&
name|mdContext
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
literal|"\r\n"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
else|else
name|MD5Update
argument_list|(
operator|&
name|mdContext
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|cp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ferror
argument_list|(
name|ce
operator|->
name|ce_fp
argument_list|)
condition|)
block|{
name|content_error
argument_list|(
name|ce
operator|->
name|ce_file
argument_list|,
name|ct
argument_list|,
literal|"error writing to"
argument_list|)
expr_stmt|;
goto|goto
name|clean_up
goto|;
block|}
break|break;
case|case
literal|'='
case|:
if|if
condition|(
operator|*
operator|++
name|cp
operator|!=
literal|'\n'
condition|)
block|{
name|quoted
operator|=
literal|1
expr_stmt|;
name|cp
operator|--
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
if|if
condition|(
name|quoted
condition|)
block|{
name|content_error
argument_list|(
name|NULLCP
argument_list|,
name|ct
argument_list|,
literal|"invalid QUOTED-PRINTABLE encoding -- end-of-content while still quoting"
argument_list|)
expr_stmt|;
goto|goto
name|clean_up
goto|;
block|}
operator|(
name|void
operator|)
name|fseek
argument_list|(
name|ct
operator|->
name|c_fp
argument_list|,
literal|0L
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fflush
argument_list|(
name|ce
operator|->
name|ce_fp
argument_list|)
condition|)
block|{
name|content_error
argument_list|(
name|ce
operator|->
name|ce_file
argument_list|,
name|ct
argument_list|,
literal|"error writing to"
argument_list|)
expr_stmt|;
goto|goto
name|clean_up
goto|;
block|}
if|if
condition|(
name|digested
condition|)
block|{
name|unsigned
name|char
name|digest
index|[
literal|16
index|]
decl_stmt|;
name|MD5Final
argument_list|(
name|digest
argument_list|,
operator|&
name|mdContext
argument_list|)
expr_stmt|;
if|if
condition|(
name|bcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|digest
argument_list|,
operator|(
name|char
operator|*
operator|)
name|ct
operator|->
name|c_digest
argument_list|,
sizeof|sizeof
name|digest
operator|/
sizeof|sizeof
name|digest
index|[
literal|0
index|]
argument_list|)
condition|)
name|content_error
argument_list|(
name|NULLCP
argument_list|,
name|ct
argument_list|,
literal|"content integrity suspect (digest mismatch) -- continuing"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|debugsw
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"content integrity confirmed\n"
argument_list|)
expr_stmt|;
block|}
name|ready_to_go
label|:
empty_stmt|;
operator|(
name|void
operator|)
name|fseek
argument_list|(
name|ce
operator|->
name|ce_fp
argument_list|,
literal|0L
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|file
operator|=
name|ce
operator|->
name|ce_file
expr_stmt|;
return|return
name|fileno
argument_list|(
name|ce
operator|->
name|ce_fp
argument_list|)
return|;
name|clean_up
label|:
empty_stmt|;
name|free_encoding
argument_list|(
name|ct
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|InitQuoted
parameter_list|(
name|ct
parameter_list|)
specifier|register
name|CT
name|ct
decl_stmt|;
block|{
return|return
name|init_encoding
argument_list|(
name|ct
argument_list|,
name|openQuoted
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*
comment|7BIT */
end_comment

begin_function
specifier|static
name|int
name|open7Bit
parameter_list|(
name|ct
parameter_list|,
name|file
parameter_list|)
specifier|register
name|CT
name|ct
decl_stmt|;
name|char
modifier|*
modifier|*
name|file
decl_stmt|;
block|{
name|int
name|cc
decl_stmt|,
name|fd
decl_stmt|,
name|len
decl_stmt|;
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
specifier|register
name|struct
name|cefile
modifier|*
name|ce
init|=
operator|(
expr|struct
name|cefile
operator|*
operator|)
name|ct
operator|->
name|c_ceparams
decl_stmt|;
if|if
condition|(
name|ce
operator|->
name|ce_fp
condition|)
goto|goto
name|ready_to_go
goto|;
if|if
condition|(
name|ce
operator|->
name|ce_file
condition|)
block|{
if|if
condition|(
operator|(
name|ce
operator|->
name|ce_fp
operator|=
name|fopen
argument_list|(
name|ce
operator|->
name|ce_file
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|content_error
argument_list|(
name|ce
operator|->
name|ce_file
argument_list|,
name|ct
argument_list|,
literal|"unable to fopen for reading"
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
operator|*
name|file
operator|=
name|ce
operator|->
name|ce_file
expr_stmt|;
return|return
name|fileno
argument_list|(
name|ce
operator|->
name|ce_fp
argument_list|)
return|;
block|}
name|ce
operator|->
name|ce_unlink
operator|=
operator|*
name|file
operator|==
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|ce
operator|->
name|ce_fp
operator|=
name|fopen
argument_list|(
name|ce
operator|->
name|ce_file
operator|=
name|add
argument_list|(
operator|*
name|file
condition|?
operator|*
name|file
else|:
name|m_scratch
argument_list|(
literal|""
argument_list|,
name|tmp
argument_list|)
argument_list|,
name|NULLCP
argument_list|)
argument_list|,
literal|"w+"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|content_error
argument_list|(
name|ce
operator|->
name|ce_file
argument_list|,
name|ct
argument_list|,
literal|"unable to fopen for writing and reading"
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
if|if
condition|(
name|ct
operator|->
name|c_type
operator|==
name|CT_MULTIPART
condition|)
block|{
specifier|register
name|char
modifier|*
modifier|*
name|ap
decl_stmt|,
modifier|*
modifier|*
name|ep
decl_stmt|;
specifier|register
name|CI
name|ci
init|=
operator|&
name|ct
operator|->
name|c_ctinfo
decl_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
name|fprintf
argument_list|(
name|ce
operator|->
name|ce_fp
argument_list|,
literal|"%s: %s/%s"
argument_list|,
name|TYPE_FIELD
argument_list|,
name|ci
operator|->
name|ci_type
argument_list|,
name|ci
operator|->
name|ci_subtype
argument_list|)
expr_stmt|;
name|len
operator|+=
name|strlen
argument_list|(
name|TYPE_FIELD
argument_list|)
operator|+
literal|2
operator|+
name|strlen
argument_list|(
name|ci
operator|->
name|ci_type
argument_list|)
operator|+
literal|1
operator|+
name|strlen
argument_list|(
name|ci
operator|->
name|ci_subtype
argument_list|)
expr_stmt|;
for|for
control|(
name|ap
operator|=
name|ci
operator|->
name|ci_attrs
operator|,
name|ep
operator|=
name|ci
operator|->
name|ci_values
init|;
operator|*
name|ap
condition|;
name|ap
operator|++
operator|,
name|ep
operator|++
control|)
block|{
operator|(
name|void
operator|)
name|putc
argument_list|(
literal|';'
argument_list|,
name|ce
operator|->
name|ce_fp
argument_list|)
expr_stmt|;
name|len
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%s=\"%s\""
argument_list|,
operator|*
name|ap
argument_list|,
operator|*
name|ep
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|+
literal|1
operator|+
operator|(
name|cc
operator|=
name|strlen
argument_list|(
name|buffer
argument_list|)
operator|)
operator|>=
name|CPERLIN
condition|)
block|{
operator|(
name|void
operator|)
name|fputs
argument_list|(
literal|"\n\t"
argument_list|,
name|ce
operator|->
name|ce_fp
argument_list|)
expr_stmt|;
name|len
operator|=
literal|8
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|putc
argument_list|(
literal|' '
argument_list|,
name|ce
operator|->
name|ce_fp
argument_list|)
expr_stmt|;
name|len
operator|++
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|ce
operator|->
name|ce_fp
argument_list|,
literal|"%s"
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|len
operator|+=
name|cc
expr_stmt|;
block|}
if|if
condition|(
name|ci
operator|->
name|ci_comment
condition|)
block|{
if|if
condition|(
name|len
operator|+
literal|1
operator|+
operator|(
name|cc
operator|=
literal|2
operator|+
name|strlen
argument_list|(
name|ci
operator|->
name|ci_comment
argument_list|)
operator|)
operator|>=
name|CPERLIN
condition|)
block|{
operator|(
name|void
operator|)
name|fputs
argument_list|(
literal|"\n\t"
argument_list|,
name|ce
operator|->
name|ce_fp
argument_list|)
expr_stmt|;
name|len
operator|=
literal|8
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|putc
argument_list|(
literal|' '
argument_list|,
name|ce
operator|->
name|ce_fp
argument_list|)
expr_stmt|;
name|len
operator|++
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|ce
operator|->
name|ce_fp
argument_list|,
literal|"(%s)"
argument_list|,
name|ci
operator|->
name|ci_comment
argument_list|)
expr_stmt|;
name|len
operator|+=
name|cc
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|ce
operator|->
name|ce_fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ct
operator|->
name|c_id
condition|)
name|fprintf
argument_list|(
name|ce
operator|->
name|ce_fp
argument_list|,
literal|"%s:%s"
argument_list|,
name|ID_FIELD
argument_list|,
name|ct
operator|->
name|c_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|ct
operator|->
name|c_descr
condition|)
name|fprintf
argument_list|(
name|ce
operator|->
name|ce_fp
argument_list|,
literal|"%s:%s"
argument_list|,
name|DESCR_FIELD
argument_list|,
name|ct
operator|->
name|c_descr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|ce
operator|->
name|ce_fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|len
operator|=
name|ct
operator|->
name|c_end
operator|-
name|ct
operator|->
name|c_begin
operator|)
operator|<
literal|0
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"internal error(3)"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ct
operator|->
name|c_fp
operator|&&
operator|(
name|ct
operator|->
name|c_fp
operator|=
name|fopen
argument_list|(
name|ct
operator|->
name|c_file
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|content_error
argument_list|(
name|ct
operator|->
name|c_file
argument_list|,
name|ct
argument_list|,
literal|"unable to open for reading"
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
operator|(
name|void
operator|)
name|lseek
argument_list|(
name|fd
operator|=
name|fileno
argument_list|(
name|ct
operator|->
name|c_fp
argument_list|)
argument_list|,
operator|(
name|off_t
operator|)
name|ct
operator|->
name|c_begin
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
condition|)
switch|switch
condition|(
name|cc
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|buffer
argument_list|,
sizeof|sizeof
name|buffer
operator|-
literal|1
argument_list|)
condition|)
block|{
case|case
name|NOTOK
case|:
name|content_error
argument_list|(
name|ct
operator|->
name|c_file
argument_list|,
name|ct
argument_list|,
literal|"error reading from"
argument_list|)
expr_stmt|;
goto|goto
name|clean_up
goto|;
case|case
name|OK
case|:
name|content_error
argument_list|(
name|NULLCP
argument_list|,
name|ct
argument_list|,
literal|"premature eof"
argument_list|)
expr_stmt|;
goto|goto
name|clean_up
goto|;
default|default:
if|if
condition|(
name|cc
operator|>
name|len
condition|)
name|cc
operator|=
name|len
expr_stmt|;
name|len
operator|-=
name|cc
expr_stmt|;
operator|(
name|void
operator|)
name|fwrite
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
expr|*
name|buffer
argument_list|,
name|cc
argument_list|,
name|ce
operator|->
name|ce_fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|ce
operator|->
name|ce_fp
argument_list|)
condition|)
block|{
name|content_error
argument_list|(
name|ce
operator|->
name|ce_file
argument_list|,
name|ct
argument_list|,
literal|"error writing to"
argument_list|)
expr_stmt|;
goto|goto
name|clean_up
goto|;
block|}
block|}
operator|(
name|void
operator|)
name|fseek
argument_list|(
name|ct
operator|->
name|c_fp
argument_list|,
literal|0L
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fflush
argument_list|(
name|ce
operator|->
name|ce_fp
argument_list|)
condition|)
block|{
name|content_error
argument_list|(
name|ce
operator|->
name|ce_file
argument_list|,
name|ct
argument_list|,
literal|"error writing to"
argument_list|)
expr_stmt|;
goto|goto
name|clean_up
goto|;
block|}
name|ready_to_go
label|:
empty_stmt|;
operator|(
name|void
operator|)
name|fseek
argument_list|(
name|ce
operator|->
name|ce_fp
argument_list|,
literal|0L
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|file
operator|=
name|ce
operator|->
name|ce_file
expr_stmt|;
return|return
name|fileno
argument_list|(
name|ce
operator|->
name|ce_fp
argument_list|)
return|;
name|clean_up
label|:
empty_stmt|;
name|free_encoding
argument_list|(
name|ct
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|Init7Bit
parameter_list|(
name|ct
parameter_list|)
specifier|register
name|CT
name|ct
decl_stmt|;
block|{
if|if
condition|(
name|init_encoding
argument_list|(
name|ct
argument_list|,
name|open7Bit
argument_list|)
operator|==
name|NOTOK
condition|)
return|return
name|NOTOK
return|;
name|ct
operator|->
name|c_cesizefnx
operator|=
name|NULL
expr_stmt|;
return|return
name|OK
return|;
block|}
end_function

begin_comment
comment|/*
comment|External */
end_comment

begin_function
specifier|static
name|int
name|openExternal
parameter_list|(
name|ct
parameter_list|,
name|cb
parameter_list|,
name|ce
parameter_list|,
name|file
parameter_list|,
name|fd
parameter_list|)
specifier|register
name|CT
name|ct
decl_stmt|;
name|CT
name|cb
decl_stmt|;
name|struct
name|cefile
modifier|*
name|ce
decl_stmt|;
name|char
modifier|*
modifier|*
name|file
decl_stmt|;
name|int
modifier|*
name|fd
decl_stmt|;
block|{
name|char
name|cachefile
index|[
name|BUFSIZ
index|]
decl_stmt|;
if|if
condition|(
name|ce
operator|->
name|ce_fp
condition|)
block|{
operator|(
name|void
operator|)
name|fseek
argument_list|(
name|ce
operator|->
name|ce_fp
argument_list|,
literal|0L
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ready_already
label|:
empty_stmt|;
operator|*
name|file
operator|=
name|ce
operator|->
name|ce_file
operator|,
operator|*
name|fd
operator|=
name|fileno
argument_list|(
name|ce
operator|->
name|ce_fp
argument_list|)
expr_stmt|;
return|return
name|DONE
return|;
block|}
if|if
condition|(
name|ce
operator|->
name|ce_file
condition|)
block|{
if|if
condition|(
operator|(
name|ce
operator|->
name|ce_fp
operator|=
name|fopen
argument_list|(
name|ce
operator|->
name|ce_file
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|content_error
argument_list|(
name|ce
operator|->
name|ce_file
argument_list|,
name|ct
argument_list|,
literal|"unable to fopen for reading"
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
goto|goto
name|ready_already
goto|;
block|}
if|if
condition|(
name|find_cache
argument_list|(
name|ct
argument_list|,
name|rcachesw
argument_list|,
operator|(
name|int
operator|*
operator|)
literal|0
argument_list|,
name|cb
operator|->
name|c_id
argument_list|,
name|cachefile
argument_list|)
operator|!=
name|NOTOK
condition|)
block|{
if|if
condition|(
name|ce
operator|->
name|ce_fp
operator|=
name|fopen
argument_list|(
name|cachefile
argument_list|,
literal|"r"
argument_list|)
condition|)
block|{
name|ce
operator|->
name|ce_unlink
operator|=
literal|0
expr_stmt|;
name|ce
operator|->
name|ce_file
operator|=
name|getcpy
argument_list|(
name|cachefile
argument_list|)
expr_stmt|;
goto|goto
name|ready_already
goto|;
block|}
else|else
name|admonish
argument_list|(
name|cachefile
argument_list|,
literal|"unable to fopen for reading"
argument_list|)
expr_stmt|;
block|}
return|return
name|OK
return|;
block|}
end_function

begin_comment
comment|/*
comment|File */
end_comment

begin_function
specifier|static
name|int
name|openFile
parameter_list|(
name|ct
parameter_list|,
name|file
parameter_list|)
specifier|register
name|CT
name|ct
decl_stmt|;
name|char
modifier|*
modifier|*
name|file
decl_stmt|;
block|{
name|int
name|fd
decl_stmt|,
name|cachetype
decl_stmt|;
name|char
name|cachefile
index|[
name|BUFSIZ
index|]
decl_stmt|;
specifier|register
name|struct
name|exbody
modifier|*
name|e
init|=
operator|(
expr|struct
name|exbody
operator|*
operator|)
name|ct
operator|->
name|c_ctextern
decl_stmt|;
specifier|register
name|struct
name|cefile
modifier|*
name|ce
init|=
operator|(
expr|struct
name|cefile
operator|*
operator|)
name|ct
operator|->
name|c_ceparams
decl_stmt|;
switch|switch
condition|(
name|openExternal
argument_list|(
name|e
operator|->
name|eb_parent
argument_list|,
name|e
operator|->
name|eb_content
argument_list|,
name|ce
argument_list|,
name|file
argument_list|,
operator|&
name|fd
argument_list|)
condition|)
block|{
case|case
name|NOTOK
case|:
return|return
name|NOTOK
return|;
case|case
name|OK
case|:
break|break;
case|case
name|DONE
case|:
return|return
name|fd
return|;
block|}
if|if
condition|(
operator|!
name|e
operator|->
name|eb_name
condition|)
block|{
name|content_error
argument_list|(
name|NULLCP
argument_list|,
name|ct
argument_list|,
literal|"missing name parameter"
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
name|ce
operator|->
name|ce_unlink
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|ce
operator|->
name|ce_fp
operator|=
name|fopen
argument_list|(
name|ce
operator|->
name|ce_file
operator|=
name|getcpy
argument_list|(
name|e
operator|->
name|eb_name
argument_list|)
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|content_error
argument_list|(
name|ce
operator|->
name|ce_file
argument_list|,
name|ct
argument_list|,
literal|"unable to fopen for reading"
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
if|if
condition|(
operator|(
operator|!
name|e
operator|->
name|eb_permission
operator|||
operator|!
name|uleq
argument_list|(
name|e
operator|->
name|eb_permission
argument_list|,
literal|"read-write"
argument_list|)
operator|)
operator|&&
name|find_cache
argument_list|(
name|NULLCT
argument_list|,
name|wcachesw
argument_list|,
operator|&
name|cachetype
argument_list|,
name|e
operator|->
name|eb_content
operator|->
name|c_id
argument_list|,
name|cachefile
argument_list|)
operator|!=
name|NOTOK
condition|)
block|{
name|int
name|mask
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|mask
operator|=
name|umask
argument_list|(
name|cachetype
condition|?
operator|~
name|m_gmprot
argument_list|()
else|:
literal|0222
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|=
name|fopen
argument_list|(
name|cachefile
argument_list|,
literal|"w"
argument_list|)
condition|)
block|{
name|int
name|cc
decl_stmt|;
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|FILE
modifier|*
name|gp
init|=
name|ce
operator|->
name|ce_fp
decl_stmt|;
operator|(
name|void
operator|)
name|fseek
argument_list|(
name|gp
argument_list|,
literal|0L
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|cc
operator|=
name|fread
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
expr|*
name|buffer
argument_list|,
sizeof|sizeof
name|buffer
argument_list|,
name|gp
argument_list|)
operator|)
operator|>
literal|0
condition|)
operator|(
name|void
operator|)
name|fwrite
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
expr|*
name|buffer
argument_list|,
name|cc
argument_list|,
name|fp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|gp
argument_list|)
condition|)
block|{
name|admonish
argument_list|(
name|ce
operator|->
name|ce_file
argument_list|,
literal|"error reading"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|cachefile
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ferror
argument_list|(
name|fp
argument_list|)
condition|)
block|{
name|admonish
argument_list|(
name|cachefile
argument_list|,
literal|"error writing"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|cachefile
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|umask
argument_list|(
name|mask
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fseek
argument_list|(
name|ce
operator|->
name|ce_fp
argument_list|,
literal|0L
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|file
operator|=
name|ce
operator|->
name|ce_file
expr_stmt|;
return|return
name|fileno
argument_list|(
name|ce
operator|->
name|ce_fp
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*
comment|FTP */
end_comment

begin_function
specifier|static
name|int
name|openFTP
parameter_list|(
name|ct
parameter_list|,
name|file
parameter_list|)
specifier|register
name|CT
name|ct
decl_stmt|;
name|char
modifier|*
modifier|*
name|file
decl_stmt|;
block|{
name|int
name|cachetype
decl_stmt|,
name|caching
decl_stmt|,
name|fd
decl_stmt|;
name|char
modifier|*
name|bp
decl_stmt|,
modifier|*
name|ftp
decl_stmt|,
modifier|*
name|user
decl_stmt|,
modifier|*
name|pass
decl_stmt|,
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|,
name|cachefile
index|[
name|BUFSIZ
index|]
decl_stmt|;
specifier|register
name|struct
name|exbody
modifier|*
name|e
init|=
operator|(
expr|struct
name|exbody
operator|*
operator|)
name|ct
operator|->
name|c_ctextern
decl_stmt|;
specifier|register
name|struct
name|cefile
modifier|*
name|ce
init|=
operator|(
expr|struct
name|cefile
operator|*
operator|)
name|ct
operator|->
name|c_ceparams
decl_stmt|;
specifier|static
name|char
modifier|*
name|username
init|=
name|NULL
decl_stmt|;
specifier|static
name|char
modifier|*
name|password
init|=
name|NULL
decl_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%s-access-ftp"
argument_list|,
name|invo_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ftp
operator|=
name|m_find
argument_list|(
name|buffer
argument_list|)
operator|)
operator|&&
operator|!
operator|*
name|ftp
condition|)
name|ftp
operator|=
name|NULLCP
expr_stmt|;
ifndef|#
directive|ifndef
name|FTP
if|if
condition|(
operator|!
name|ftp
condition|)
return|return
name|NOTOK
return|;
endif|#
directive|endif
switch|switch
condition|(
name|openExternal
argument_list|(
name|e
operator|->
name|eb_parent
argument_list|,
name|e
operator|->
name|eb_content
argument_list|,
name|ce
argument_list|,
name|file
argument_list|,
operator|&
name|fd
argument_list|)
condition|)
block|{
case|case
name|NOTOK
case|:
return|return
name|NOTOK
return|;
case|case
name|OK
case|:
break|break;
case|case
name|DONE
case|:
return|return
name|fd
return|;
block|}
if|if
condition|(
operator|!
name|e
operator|->
name|eb_name
operator|||
operator|!
name|e
operator|->
name|eb_site
condition|)
block|{
name|content_error
argument_list|(
name|NULLCP
argument_list|,
name|ct
argument_list|,
literal|"missing %s parameter"
argument_list|,
name|e
operator|->
name|eb_name
condition|?
literal|"site"
else|:
literal|"name"
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
if|if
condition|(
name|xpid
condition|)
block|{
if|if
condition|(
name|xpid
operator|<
literal|0
condition|)
name|xpid
operator|=
operator|-
name|xpid
expr_stmt|;
operator|(
name|void
operator|)
name|pidcheck
argument_list|(
name|pidwait
argument_list|(
name|xpid
argument_list|,
name|NOTOK
argument_list|)
argument_list|)
expr_stmt|;
name|xpid
operator|=
literal|0
expr_stmt|;
block|}
name|bp
operator|=
name|buffer
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|bp
argument_list|,
literal|"Retrieve %s"
argument_list|,
name|e
operator|->
name|eb_name
argument_list|)
expr_stmt|;
name|bp
operator|+=
name|strlen
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|eb_partno
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|bp
argument_list|,
literal|" (content %s)"
argument_list|,
name|e
operator|->
name|eb_partno
argument_list|)
expr_stmt|;
name|bp
operator|+=
name|strlen
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|bp
argument_list|,
literal|"\n    using %sFTP from site %s"
argument_list|,
name|e
operator|->
name|eb_flags
condition|?
literal|"anonymous "
else|:
literal|""
argument_list|,
name|e
operator|->
name|eb_site
argument_list|)
expr_stmt|;
name|bp
operator|+=
name|strlen
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|eb_size
operator|>
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|bp
argument_list|,
literal|" (%lu octets)"
argument_list|,
name|e
operator|->
name|eb_size
argument_list|)
expr_stmt|;
name|bp
operator|+=
name|strlen
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|bp
argument_list|,
literal|"? "
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|getanswer
argument_list|(
name|buffer
argument_list|)
condition|)
return|return
name|NOTOK
return|;
if|if
condition|(
name|e
operator|->
name|eb_flags
condition|)
block|{
name|user
operator|=
literal|"anonymous"
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|pass
operator|=
name|buffer
argument_list|,
literal|"%s@%s"
argument_list|,
name|getusr
argument_list|()
argument_list|,
name|LocalName
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ruserpass
argument_list|(
name|e
operator|->
name|eb_site
argument_list|,
operator|&
name|username
argument_list|,
operator|&
name|password
argument_list|)
expr_stmt|;
name|user
operator|=
name|username
operator|,
name|pass
operator|=
name|password
expr_stmt|;
block|}
name|ce
operator|->
name|ce_unlink
operator|=
operator|*
name|file
operator|==
name|NULL
operator|,
name|caching
operator|=
literal|0
operator|,
name|cachefile
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|e
operator|->
name|eb_permission
operator|||
operator|!
name|uleq
argument_list|(
name|e
operator|->
name|eb_permission
argument_list|,
literal|"read-write"
argument_list|)
operator|)
operator|&&
name|find_cache
argument_list|(
name|NULLCT
argument_list|,
name|wcachesw
argument_list|,
operator|&
name|cachetype
argument_list|,
name|e
operator|->
name|eb_content
operator|->
name|c_id
argument_list|,
name|cachefile
argument_list|)
operator|!=
name|NOTOK
condition|)
block|{
if|if
condition|(
operator|*
name|file
operator|==
name|NULL
condition|)
block|{
name|ce
operator|->
name|ce_unlink
operator|=
literal|0
expr_stmt|;
name|caching
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|ce
operator|->
name|ce_fp
operator|=
name|fopen
argument_list|(
name|ce
operator|->
name|ce_file
operator|=
name|add
argument_list|(
operator|*
name|file
condition|?
operator|*
name|file
else|:
name|caching
condition|?
name|cachefile
else|:
name|m_scratch
argument_list|(
literal|""
argument_list|,
name|tmp
argument_list|)
argument_list|,
name|NULLCP
argument_list|)
argument_list|,
literal|"w+"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|content_error
argument_list|(
name|ce
operator|->
name|ce_file
argument_list|,
name|ct
argument_list|,
literal|"unable to fopen for writing and reading"
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
ifdef|#
directive|ifdef
name|FTP
if|if
condition|(
name|ftp
condition|)
endif|#
directive|endif
block|{
name|int
name|child_id
decl_stmt|,
name|i
decl_stmt|,
name|vecp
decl_stmt|;
name|char
modifier|*
name|vec
index|[
literal|9
index|]
decl_stmt|;
name|vecp
operator|=
literal|0
expr_stmt|;
name|vec
index|[
name|vecp
operator|++
index|]
operator|=
name|r1bindex
argument_list|(
name|ftp
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
name|vec
index|[
name|vecp
operator|++
index|]
operator|=
name|e
operator|->
name|eb_site
expr_stmt|;
name|vec
index|[
name|vecp
operator|++
index|]
operator|=
name|user
expr_stmt|;
name|vec
index|[
name|vecp
operator|++
index|]
operator|=
name|pass
expr_stmt|;
name|vec
index|[
name|vecp
operator|++
index|]
operator|=
name|e
operator|->
name|eb_dir
expr_stmt|;
name|vec
index|[
name|vecp
operator|++
index|]
operator|=
name|e
operator|->
name|eb_name
expr_stmt|;
name|vec
index|[
name|vecp
operator|++
index|]
operator|=
name|ce
operator|->
name|ce_file
operator|,
name|vec
index|[
name|vecp
operator|++
index|]
operator|=
name|e
operator|->
name|eb_mode
operator|&&
name|uleq
argument_list|(
name|e
operator|->
name|eb_mode
argument_list|,
literal|"ascii"
argument_list|)
condition|?
literal|"ascii"
else|:
literal|"binary"
expr_stmt|;
name|vec
index|[
name|vecp
index|]
operator|=
name|NULL
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|child_id
operator|=
name|vfork
argument_list|()
operator|)
operator|==
name|NOTOK
operator|&&
name|i
operator|<
literal|5
condition|;
name|i
operator|++
control|)
name|sleep
argument_list|(
literal|5
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|child_id
condition|)
block|{
case|case
name|NOTOK
case|:
name|adios
argument_list|(
literal|"fork"
argument_list|,
literal|"unable to"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
case|case
name|OK
case|:
operator|(
name|void
operator|)
name|close
argument_list|(
name|fileno
argument_list|(
name|ce
operator|->
name|ce_fp
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|execvp
argument_list|(
name|ftp
argument_list|,
name|vec
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"unable to exec "
argument_list|)
expr_stmt|;
name|perror
argument_list|(
name|ftp
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
default|default:
if|if
condition|(
name|pidXwait
argument_list|(
name|child_id
argument_list|,
name|NULLCP
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|FTP
name|losing_ftp
label|:
empty_stmt|;
endif|#
directive|endif
name|username
operator|=
name|password
operator|=
name|NULL
expr_stmt|;
name|ce
operator|->
name|ce_unlink
operator|=
literal|1
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
break|break;
block|}
block|}
ifdef|#
directive|ifdef
name|FTP
elseif|else
if|if
condition|(
name|ftp_get
argument_list|(
name|e
operator|->
name|eb_site
argument_list|,
name|user
argument_list|,
name|pass
argument_list|,
name|e
operator|->
name|eb_dir
argument_list|,
name|e
operator|->
name|eb_name
argument_list|,
name|ce
operator|->
name|ce_file
argument_list|,
name|e
operator|->
name|eb_mode
operator|&&
name|uleq
argument_list|(
name|e
operator|->
name|eb_mode
argument_list|,
literal|"ascii"
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|NOTOK
condition|)
goto|goto
name|losing_ftp
goto|;
endif|#
directive|endif
if|if
condition|(
name|cachefile
index|[
literal|0
index|]
condition|)
if|if
condition|(
name|caching
condition|)
operator|(
name|void
operator|)
name|chmod
argument_list|(
name|cachefile
argument_list|,
name|cachetype
condition|?
name|m_gmprot
argument_list|()
else|:
literal|0444
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|mask
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|mask
operator|=
name|umask
argument_list|(
name|cachetype
condition|?
operator|~
name|m_gmprot
argument_list|()
else|:
literal|0222
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|=
name|fopen
argument_list|(
name|cachefile
argument_list|,
literal|"w"
argument_list|)
condition|)
block|{
name|int
name|cc
decl_stmt|;
name|FILE
modifier|*
name|gp
init|=
name|ce
operator|->
name|ce_fp
decl_stmt|;
operator|(
name|void
operator|)
name|fseek
argument_list|(
name|gp
argument_list|,
literal|0L
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|cc
operator|=
name|fread
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
expr|*
name|buffer
argument_list|,
sizeof|sizeof
name|buffer
argument_list|,
name|gp
argument_list|)
operator|)
operator|>
literal|0
condition|)
operator|(
name|void
operator|)
name|fwrite
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
expr|*
name|buffer
argument_list|,
name|cc
argument_list|,
name|fp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|gp
argument_list|)
condition|)
block|{
name|admonish
argument_list|(
name|ce
operator|->
name|ce_file
argument_list|,
literal|"error reading"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|cachefile
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ferror
argument_list|(
name|fp
argument_list|)
condition|)
block|{
name|admonish
argument_list|(
name|cachefile
argument_list|,
literal|"error writing"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|cachefile
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|umask
argument_list|(
name|mask
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fseek
argument_list|(
name|ce
operator|->
name|ce_fp
argument_list|,
literal|0L
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|file
operator|=
name|ce
operator|->
name|ce_file
expr_stmt|;
return|return
name|fileno
argument_list|(
name|ce
operator|->
name|ce_fp
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*
comment|Mail */
end_comment

begin_function
specifier|static
name|int
name|openMail
parameter_list|(
name|ct
parameter_list|,
name|file
parameter_list|)
specifier|register
name|CT
name|ct
decl_stmt|;
name|char
modifier|*
modifier|*
name|file
decl_stmt|;
block|{
name|int
name|child_id
decl_stmt|,
name|fd
decl_stmt|,
name|i
decl_stmt|,
name|vecp
decl_stmt|;
name|char
modifier|*
name|bp
decl_stmt|,
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|,
modifier|*
name|vec
index|[
literal|7
index|]
decl_stmt|;
specifier|register
name|struct
name|exbody
modifier|*
name|e
init|=
operator|(
expr|struct
name|exbody
operator|*
operator|)
name|ct
operator|->
name|c_ctextern
decl_stmt|;
specifier|register
name|struct
name|cefile
modifier|*
name|ce
init|=
operator|(
expr|struct
name|cefile
operator|*
operator|)
name|ct
operator|->
name|c_ceparams
decl_stmt|;
switch|switch
condition|(
name|openExternal
argument_list|(
name|e
operator|->
name|eb_parent
argument_list|,
name|e
operator|->
name|eb_content
argument_list|,
name|ce
argument_list|,
name|file
argument_list|,
operator|&
name|fd
argument_list|)
condition|)
block|{
case|case
name|NOTOK
case|:
return|return
name|NOTOK
return|;
case|case
name|OK
case|:
break|break;
case|case
name|DONE
case|:
return|return
name|fd
return|;
block|}
if|if
condition|(
operator|!
name|e
operator|->
name|eb_server
condition|)
block|{
name|content_error
argument_list|(
name|NULLCP
argument_list|,
name|ct
argument_list|,
literal|"missing server parameter"
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
if|if
condition|(
name|xpid
condition|)
block|{
if|if
condition|(
name|xpid
operator|<
literal|0
condition|)
name|xpid
operator|=
operator|-
name|xpid
expr_stmt|;
operator|(
name|void
operator|)
name|pidcheck
argument_list|(
name|pidwait
argument_list|(
name|xpid
argument_list|,
name|NOTOK
argument_list|)
argument_list|)
expr_stmt|;
name|xpid
operator|=
literal|0
expr_stmt|;
block|}
name|bp
operator|=
name|buffer
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|bp
argument_list|,
literal|"Retrieve content"
argument_list|)
expr_stmt|;
name|bp
operator|+=
name|strlen
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|eb_partno
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|bp
argument_list|,
literal|" %s"
argument_list|,
name|e
operator|->
name|eb_partno
argument_list|)
expr_stmt|;
name|bp
operator|+=
name|strlen
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|bp
argument_list|,
literal|" by asking %s\n\n%s\n? "
argument_list|,
name|e
operator|->
name|eb_server
argument_list|,
name|e
operator|->
name|eb_subject
condition|?
name|e
operator|->
name|eb_subject
else|:
name|e
operator|->
name|eb_body
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|getanswer
argument_list|(
name|buffer
argument_list|)
condition|)
return|return
name|NOTOK
return|;
name|vecp
operator|=
literal|0
expr_stmt|;
name|vec
index|[
name|vecp
operator|++
index|]
operator|=
name|r1bindex
argument_list|(
name|mailproc
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
name|vec
index|[
name|vecp
operator|++
index|]
operator|=
name|e
operator|->
name|eb_server
expr_stmt|;
name|vec
index|[
name|vecp
operator|++
index|]
operator|=
literal|"-subject"
expr_stmt|;
name|vec
index|[
name|vecp
operator|++
index|]
operator|=
name|e
operator|->
name|eb_subject
condition|?
name|e
operator|->
name|eb_subject
else|:
literal|"mail-server request"
expr_stmt|;
name|vec
index|[
name|vecp
operator|++
index|]
operator|=
literal|"-body"
expr_stmt|;
name|vec
index|[
name|vecp
operator|++
index|]
operator|=
name|e
operator|->
name|eb_body
expr_stmt|;
name|vec
index|[
name|vecp
index|]
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|child_id
operator|=
name|vfork
argument_list|()
operator|)
operator|==
name|NOTOK
operator|&&
name|i
operator|<
literal|5
condition|;
name|i
operator|++
control|)
name|sleep
argument_list|(
literal|5
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|child_id
condition|)
block|{
case|case
name|NOTOK
case|:
name|advise
argument_list|(
literal|"fork"
argument_list|,
literal|"unable to"
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
case|case
name|OK
case|:
operator|(
name|void
operator|)
name|execvp
argument_list|(
name|mailproc
argument_list|,
name|vec
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"unable to exec "
argument_list|)
expr_stmt|;
name|perror
argument_list|(
name|mailproc
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
default|default:
if|if
condition|(
name|pidXwait
argument_list|(
name|child_id
argument_list|,
name|NULLCP
argument_list|)
operator|==
name|OK
condition|)
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"request sent"
argument_list|)
expr_stmt|;
break|break;
block|}
name|ce
operator|->
name|ce_unlink
operator|=
operator|*
name|file
operator|==
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|ce
operator|->
name|ce_fp
operator|=
name|fopen
argument_list|(
name|ce
operator|->
name|ce_file
operator|=
name|add
argument_list|(
operator|*
name|file
condition|?
operator|*
name|file
else|:
name|m_scratch
argument_list|(
literal|""
argument_list|,
name|tmp
argument_list|)
argument_list|,
name|NULLCP
argument_list|)
argument_list|,
literal|"w+"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|content_error
argument_list|(
name|ce
operator|->
name|ce_file
argument_list|,
name|ct
argument_list|,
literal|"unable to fopen for writing and reading"
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
if|if
condition|(
name|ct
operator|->
name|c_showproc
condition|)
name|free
argument_list|(
name|ct
operator|->
name|c_showproc
argument_list|)
expr_stmt|;
name|ct
operator|->
name|c_showproc
operator|=
name|add
argument_list|(
literal|"true"
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fseek
argument_list|(
name|ce
operator|->
name|ce_fp
argument_list|,
literal|0L
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|file
operator|=
name|ce
operator|->
name|ce_file
expr_stmt|;
return|return
name|fileno
argument_list|(
name|ce
operator|->
name|ce_fp
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*
comment|CACHE */
end_comment

begin_function
specifier|static
name|int
name|find_cache
parameter_list|(
name|ct
parameter_list|,
name|policy
parameter_list|,
name|writing
parameter_list|,
name|id
parameter_list|,
name|buffer
parameter_list|)
name|CT
name|ct
decl_stmt|;
name|int
name|policy
decl_stmt|,
decl|*
name|writing
decl_stmt|;
end_function

begin_decl_stmt
name|char
modifier|*
name|id
decl_stmt|,
modifier|*
name|buffer
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|status
init|=
name|NOTOK
decl_stmt|;
if|if
condition|(
name|id
operator|==
name|NULL
condition|)
return|return
name|NOTOK
return|;
name|id
operator|=
name|trimcpy
argument_list|(
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|debugsw
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"find_cache %s(%d) %s %s\n"
argument_list|,
name|caches
index|[
name|policy
index|]
operator|.
name|sw
argument_list|,
name|policy
argument_list|,
name|writing
condition|?
literal|"writing"
else|:
literal|"reading"
argument_list|,
name|id
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|policy
condition|)
block|{
case|case
name|CACHE_NEVER
case|:
default|default:
break|break;
case|case
name|CACHE_ASK
case|:
case|case
name|CACHE_PUBLIC
case|:
if|if
condition|(
name|cache_private
operator|&&
operator|!
name|writing
operator|&&
name|find_cache_aux
argument_list|(
name|writing
condition|?
literal|2
else|:
literal|0
argument_list|,
name|cache_private
argument_list|,
name|id
argument_list|,
name|buffer
argument_list|)
operator|==
name|OK
condition|)
block|{
if|if
condition|(
name|access
argument_list|(
name|buffer
argument_list|,
literal|04
argument_list|)
operator|!=
name|NOTOK
condition|)
block|{
name|got_private
label|:
empty_stmt|;
if|if
condition|(
name|writing
condition|)
operator|*
name|writing
operator|=
literal|1
expr_stmt|;
name|got_it
label|:
empty_stmt|;
name|status
operator|=
name|OK
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|cache_public
operator|&&
name|find_cache_aux
argument_list|(
name|writing
condition|?
literal|1
else|:
literal|0
argument_list|,
name|cache_public
argument_list|,
name|id
argument_list|,
name|buffer
argument_list|)
operator|==
name|OK
condition|)
block|{
if|if
condition|(
name|writing
operator|||
name|access
argument_list|(
name|buffer
argument_list|,
literal|04
argument_list|)
operator|!=
name|NOTOK
condition|)
block|{
if|if
condition|(
name|writing
condition|)
operator|*
name|writing
operator|=
literal|0
expr_stmt|;
goto|goto
name|got_it
goto|;
block|}
block|}
break|break;
case|case
name|CACHE_PRIVATE
case|:
if|if
condition|(
name|cache_private
operator|&&
name|find_cache_aux
argument_list|(
name|writing
condition|?
literal|2
else|:
literal|0
argument_list|,
name|cache_private
argument_list|,
name|id
argument_list|,
name|buffer
argument_list|)
operator|==
name|OK
condition|)
block|{
if|if
condition|(
name|writing
operator|||
name|access
argument_list|(
name|buffer
argument_list|,
literal|04
argument_list|)
operator|!=
name|NOTOK
condition|)
goto|goto
name|got_private
goto|;
block|}
break|break;
block|}
if|if
condition|(
name|status
operator|==
name|OK
operator|&&
name|policy
operator|==
name|CACHE_ASK
condition|)
block|{
name|char
modifier|*
name|bp
decl_stmt|,
name|query
index|[
name|BUFSIZ
index|]
decl_stmt|;
if|if
condition|(
name|xpid
condition|)
block|{
if|if
condition|(
name|xpid
operator|<
literal|0
condition|)
name|xpid
operator|=
operator|-
name|xpid
expr_stmt|;
operator|(
name|void
operator|)
name|pidcheck
argument_list|(
name|pidwait
argument_list|(
name|xpid
argument_list|,
name|NOTOK
argument_list|)
argument_list|)
expr_stmt|;
name|xpid
operator|=
literal|0
expr_stmt|;
block|}
name|bp
operator|=
name|query
expr_stmt|;
if|if
condition|(
name|writing
condition|)
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|bp
argument_list|,
literal|"Make cached, publically-accessible copy"
argument_list|)
expr_stmt|;
else|else
block|{
name|struct
name|stat
name|st
decl_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|bp
argument_list|,
literal|"Use cached copy"
argument_list|)
expr_stmt|;
name|bp
operator|+=
name|strlen
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ct
operator|->
name|c_partno
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|bp
argument_list|,
literal|" of content %s"
argument_list|,
name|ct
operator|->
name|c_partno
argument_list|)
expr_stmt|;
name|bp
operator|+=
name|strlen
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|stat
argument_list|(
name|buffer
argument_list|,
operator|&
name|st
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|bp
argument_list|,
literal|" (size %lu octets)"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|st
operator|.
name|st_size
argument_list|)
expr_stmt|;
block|}
name|bp
operator|+=
name|strlen
argument_list|(
name|bp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|bp
argument_list|,
literal|"\n    in file %s? "
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|getanswer
argument_list|(
name|query
argument_list|)
condition|)
name|status
operator|=
name|NOTOK
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|==
name|OK
operator|&&
name|writing
condition|)
block|{
if|if
condition|(
operator|*
name|writing
operator|&&
name|index
argument_list|(
name|buffer
argument_list|,
literal|'/'
argument_list|)
condition|)
operator|(
name|void
operator|)
name|make_intermediates
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|id
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|find_cache_aux
parameter_list|(
name|writing
parameter_list|,
name|directory
parameter_list|,
name|id
parameter_list|,
name|buffer
parameter_list|)
name|int
name|writing
decl_stmt|;
name|char
modifier|*
name|directory
decl_stmt|,
decl|*
name|id
decl_stmt|,
modifier|*
name|buffer
decl_stmt|;
end_function

begin_block
block|{
name|int
name|mask
decl_stmt|;
ifdef|#
directive|ifdef
name|BSD42
name|int
name|usemap
init|=
name|index
argument_list|(
name|id
argument_list|,
literal|'/'
argument_list|)
condition|?
literal|1
else|:
literal|0
decl_stmt|;
else|#
directive|else
name|int
name|usemap
init|=
literal|1
decl_stmt|;
endif|#
directive|endif
name|char
name|mapfile
index|[
name|BUFSIZ
index|]
decl_stmt|,
name|mapname
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
specifier|static
name|int
name|partno
decl_stmt|,
name|pid
decl_stmt|;
specifier|static
name|long
name|clock
init|=
literal|0L
decl_stmt|;
if|if
condition|(
name|debugsw
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"find_cache_aux %s usemap=%d\n"
argument_list|,
name|directory
argument_list|,
name|usemap
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|mapfile
argument_list|,
literal|"%s/cache.map"
argument_list|,
name|directory
argument_list|)
expr_stmt|;
if|if
condition|(
name|find_cache_aux2
argument_list|(
name|mapfile
argument_list|,
name|id
argument_list|,
name|mapname
argument_list|)
operator|==
name|OK
condition|)
goto|goto
name|done_map
goto|;
if|if
condition|(
operator|!
name|writing
condition|)
block|{
if|if
condition|(
name|usemap
condition|)
return|return
name|NOTOK
return|;
name|use_raw
label|:
empty_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%s/%s"
argument_list|,
name|directory
argument_list|,
name|id
argument_list|)
expr_stmt|;
return|return
name|OK
return|;
block|}
if|if
condition|(
operator|!
name|usemap
operator|&&
name|access
argument_list|(
name|mapfile
argument_list|,
literal|02
argument_list|)
operator|==
name|NOTOK
condition|)
goto|goto
name|use_raw
goto|;
if|if
condition|(
name|clock
operator|!=
literal|0L
condition|)
block|{
name|long
name|now
decl_stmt|;
operator|(
name|void
operator|)
name|time
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
if|if
condition|(
name|now
operator|>
name|clock
condition|)
name|clock
operator|=
literal|0L
expr_stmt|;
block|}
else|else
name|pid
operator|=
name|getpid
argument_list|()
expr_stmt|;
if|if
condition|(
name|clock
operator|==
literal|0L
condition|)
block|{
operator|(
name|void
operator|)
name|time
argument_list|(
operator|&
name|clock
argument_list|)
expr_stmt|;
name|partno
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|partno
operator|>
literal|0xff
condition|)
name|clock
operator|++
operator|,
name|partno
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|mapname
argument_list|,
literal|"%08x%04x%02x"
argument_list|,
name|clock
operator|&
literal|0xffffffff
argument_list|,
name|pid
operator|&
literal|0xffff
argument_list|,
name|partno
operator|++
operator|&
literal|0xff
argument_list|)
expr_stmt|;
if|if
condition|(
name|debugsw
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"creating mapping %s -> %s\n"
argument_list|,
name|mapname
argument_list|,
name|id
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|make_intermediates
argument_list|(
name|mapfile
argument_list|)
expr_stmt|;
name|mask
operator|=
name|umask
argument_list|(
name|writing
operator|==
literal|2
condition|?
literal|0077
else|:
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|fp
operator|=
name|lkfopen
argument_list|(
name|mapfile
argument_list|,
literal|"a"
argument_list|)
operator|)
operator|&&
name|errno
operator|==
name|ENOENT
condition|)
block|{
name|int
name|fd
init|=
name|creat
argument_list|(
name|mapfile
argument_list|,
literal|0666
argument_list|)
decl_stmt|;
if|if
condition|(
name|fd
operator|!=
name|NOTOK
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|fp
operator|=
name|lkfopen
argument_list|(
name|mapfile
argument_list|,
literal|"a"
argument_list|)
expr_stmt|;
block|}
block|}
operator|(
name|void
operator|)
name|umask
argument_list|(
name|mask
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fp
condition|)
return|return
name|NOTOK
return|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s: %s\n"
argument_list|,
name|mapname
argument_list|,
name|id
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|lkfclose
argument_list|(
name|fp
argument_list|,
name|mapfile
argument_list|)
expr_stmt|;
name|done_map
label|:
empty_stmt|;
if|if
condition|(
operator|*
name|mapname
operator|==
literal|'/'
condition|)
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|buffer
argument_list|,
name|mapname
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%s/%s"
argument_list|,
name|directory
argument_list|,
name|mapname
argument_list|)
expr_stmt|;
if|if
condition|(
name|debugsw
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"use %s\n"
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
return|return
name|OK
return|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|find_cache_aux2
parameter_list|(
name|mapfile
parameter_list|,
name|id
parameter_list|,
name|mapname
parameter_list|)
name|char
modifier|*
name|mapfile
decl_stmt|,
decl|*
name|id
decl_stmt|,
modifier|*
name|mapname
decl_stmt|;
end_function

begin_block
block|{
name|int
name|state
decl_stmt|;
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|,
name|name
index|[
name|NAMESZ
index|]
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|fp
operator|=
name|lkfopen
argument_list|(
name|mapfile
argument_list|,
literal|"r"
argument_list|)
operator|)
condition|)
return|return
name|NOTOK
return|;
for|for
control|(
name|state
operator|=
name|FLD
init|;
condition|;
control|)
block|{
name|int
name|result
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|dp
decl_stmt|;
switch|switch
condition|(
name|state
operator|=
name|m_getfld
argument_list|(
name|state
argument_list|,
name|name
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|fp
argument_list|)
condition|)
block|{
case|case
name|FLD
case|:
case|case
name|FLDPLUS
case|:
case|case
name|FLDEOF
case|:
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|mapname
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|!=
name|FLDPLUS
condition|)
name|cp
operator|=
name|buf
expr_stmt|;
else|else
block|{
name|cp
operator|=
name|add
argument_list|(
name|buf
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
while|while
condition|(
name|state
operator|==
name|FLDPLUS
condition|)
block|{
name|state
operator|=
name|m_getfld
argument_list|(
name|state
argument_list|,
name|name
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|cp
operator|=
name|add
argument_list|(
name|buf
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
block|}
name|dp
operator|=
name|trimcpy
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|buf
condition|)
name|free
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|debugsw
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"compare %s to %s<- %s\n"
argument_list|,
name|id
argument_list|,
name|dp
argument_list|,
name|mapname
argument_list|)
expr_stmt|;
name|result
operator|=
name|strcmp
argument_list|(
name|id
argument_list|,
name|dp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dp
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|lkfclose
argument_list|(
name|fp
argument_list|,
name|mapfile
argument_list|)
expr_stmt|;
return|return
name|OK
return|;
block|}
if|if
condition|(
name|state
operator|!=
name|FLDEOF
condition|)
continue|continue;
comment|/* else fall... */
case|case
name|BODY
case|:
case|case
name|BODYEOF
case|:
case|case
name|FILEEOF
case|:
default|default:
break|break;
block|}
break|break;
block|}
operator|(
name|void
operator|)
name|lkfclose
argument_list|(
name|fp
argument_list|,
name|mapfile
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|cache_content
parameter_list|(
name|ct
parameter_list|)
specifier|register
name|CT
name|ct
decl_stmt|;
block|{
name|int
name|cachetype
decl_stmt|;
name|char
modifier|*
name|file
decl_stmt|,
name|cachefile
index|[
name|BUFSIZ
index|]
decl_stmt|;
specifier|register
name|struct
name|cefile
modifier|*
name|ce
init|=
operator|(
expr|struct
name|cefile
operator|*
operator|)
name|ct
operator|->
name|c_ceparams
decl_stmt|;
if|if
condition|(
operator|!
name|ct
operator|->
name|c_id
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"no %s: field in %s"
argument_list|,
name|ID_FIELD
argument_list|,
name|ct
operator|->
name|c_file
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|ce
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"unable to decode %s"
argument_list|,
name|ct
operator|->
name|c_file
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ct
operator|->
name|c_ceopenfnx
operator|==
name|openMail
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"a radish may no know Greek, but I do..."
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|find_cache
argument_list|(
name|NULLCT
argument_list|,
name|wcachesw
operator|!=
name|CACHE_NEVER
condition|?
name|wcachesw
else|:
name|CACHE_ASK
argument_list|,
operator|&
name|cachetype
argument_list|,
name|ct
operator|->
name|c_id
argument_list|,
name|cachefile
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
name|advise
argument_list|(
name|NULLCP
argument_list|,
literal|"unable to cache %s's contents"
argument_list|,
name|ct
operator|->
name|c_file
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|wcachesw
operator|!=
name|CACHE_NEVER
operator|&&
name|wcachesw
operator|!=
name|CACHE_ASK
condition|)
block|{
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"caching message %s as file %s\n"
argument_list|,
name|ct
operator|->
name|c_file
argument_list|,
name|cachefile
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ce
operator|->
name|ce_file
condition|)
block|{
name|int
name|mask
init|=
name|umask
argument_list|(
name|cachetype
condition|?
operator|~
name|m_gmprot
argument_list|()
else|:
literal|0222
argument_list|)
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
if|if
condition|(
name|debugsw
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"caching by copying %s...\n"
argument_list|,
name|ce
operator|->
name|ce_file
argument_list|)
expr_stmt|;
name|file
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
call|(
modifier|*
name|ct
operator|->
name|c_ceopenfnx
call|)
argument_list|(
name|ct
argument_list|,
operator|&
name|file
argument_list|)
operator|==
name|NOTOK
condition|)
goto|goto
name|reset_umask
goto|;
if|if
condition|(
name|fp
operator|=
name|fopen
argument_list|(
name|cachefile
argument_list|,
literal|"w"
argument_list|)
condition|)
block|{
name|int
name|cc
decl_stmt|;
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|FILE
modifier|*
name|gp
init|=
name|ce
operator|->
name|ce_fp
decl_stmt|;
operator|(
name|void
operator|)
name|fseek
argument_list|(
name|gp
argument_list|,
literal|0L
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|cc
operator|=
name|fread
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
expr|*
name|buffer
argument_list|,
sizeof|sizeof
name|buffer
argument_list|,
name|gp
argument_list|)
operator|)
operator|>
literal|0
condition|)
operator|(
name|void
operator|)
name|fwrite
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
expr|*
name|buffer
argument_list|,
name|cc
argument_list|,
name|fp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|gp
argument_list|)
condition|)
block|{
name|admonish
argument_list|(
name|ce
operator|->
name|ce_file
argument_list|,
literal|"error reading"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|cachefile
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ferror
argument_list|(
name|fp
argument_list|)
condition|)
block|{
name|admonish
argument_list|(
name|cachefile
argument_list|,
literal|"error writing"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|cachefile
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
else|else
name|content_error
argument_list|(
name|cachefile
argument_list|,
name|ct
argument_list|,
literal|"unable to fopen for writing"
argument_list|)
expr_stmt|;
name|reset_umask
label|:
empty_stmt|;
operator|(
name|void
operator|)
name|umask
argument_list|(
name|mask
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|debugsw
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"in place caching...\n"
argument_list|)
expr_stmt|;
name|file
operator|=
name|cachefile
expr_stmt|;
if|if
condition|(
call|(
modifier|*
name|ct
operator|->
name|c_ceopenfnx
call|)
argument_list|(
name|ct
argument_list|,
operator|&
name|file
argument_list|)
operator|!=
name|NOTOK
condition|)
operator|(
name|void
operator|)
name|chmod
argument_list|(
name|cachefile
argument_list|,
name|cachetype
condition|?
name|m_gmprot
argument_list|()
else|:
literal|0444
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*
comment|COMPOSITION */
end_comment

begin_decl_stmt
specifier|static
name|char
name|prefix
index|[]
init|=
literal|"----- =_aaaaaaaaaa"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|free_file
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|CT
name|free_ct
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|build_comp
parameter_list|(
name|file
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
block|{
name|int
name|compnum
decl_stmt|,
name|state
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|,
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|,
name|name
index|[
name|NAMESZ
index|]
decl_stmt|,
name|tmpfil
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|struct
name|multipart
modifier|*
name|m
decl_stmt|;
specifier|register
name|struct
name|part
modifier|*
modifier|*
name|pp
decl_stmt|;
name|CT
name|ct
decl_stmt|;
name|FILE
modifier|*
name|in
decl_stmt|,
modifier|*
name|out
decl_stmt|;
if|if
condition|(
operator|(
name|in
operator|=
name|fopen
argument_list|(
name|file
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|adios
argument_list|(
name|file
argument_list|,
literal|"unable to open for reading"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|umask
argument_list|(
operator|~
name|m_gmprot
argument_list|()
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|tmpfil
argument_list|,
name|m_scratch
argument_list|(
name|file
argument_list|,
name|invo_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|out
operator|=
name|fopen
argument_list|(
name|tmpfil
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|adios
argument_list|(
name|tmpfil
argument_list|,
literal|"unable to open for writing"
argument_list|)
expr_stmt|;
name|free_file
operator|=
name|tmpfil
expr_stmt|;
for|for
control|(
name|compnum
operator|=
literal|1
operator|,
name|state
operator|=
name|FLD
init|;
condition|;
control|)
block|{
switch|switch
condition|(
name|state
operator|=
name|m_getfld
argument_list|(
name|state
argument_list|,
name|name
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|in
argument_list|)
condition|)
block|{
case|case
name|FLD
case|:
case|case
name|FLDPLUS
case|:
case|case
name|FLDEOF
case|:
name|compnum
operator|++
expr_stmt|;
if|if
condition|(
name|uleq
argument_list|(
name|name
argument_list|,
name|VRSN_FIELD
argument_list|)
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"draft shouldn't contain %s: field"
argument_list|,
name|VRSN_FIELD
argument_list|)
expr_stmt|;
if|if
condition|(
name|uleq
argument_list|(
name|name
argument_list|,
name|TYPE_FIELD
argument_list|)
condition|)
block|{
while|while
condition|(
name|state
operator|==
name|FLDPLUS
condition|)
name|state
operator|=
name|m_getfld
argument_list|(
name|state
argument_list|,
name|name
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|in
argument_list|)
expr_stmt|;
goto|goto
name|finish_field
goto|;
block|}
if|if
condition|(
name|uleq
argument_list|(
name|name
argument_list|,
name|ENCODING_FIELD
argument_list|)
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"draft shouldn't contain %s: field"
argument_list|,
name|ENCODING_FIELD
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"%s:%s"
argument_list|,
name|name
argument_list|,
name|buf
argument_list|)
expr_stmt|;
while|while
condition|(
name|state
operator|==
name|FLDPLUS
condition|)
block|{
name|state
operator|=
name|m_getfld
argument_list|(
name|state
argument_list|,
name|name
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|in
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fputs
argument_list|(
name|buf
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
name|finish_field
label|:
empty_stmt|;
if|if
condition|(
name|state
operator|!=
name|FLDEOF
condition|)
continue|continue;
comment|/* else fall... */
case|case
name|FILEEOF
case|:
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"draft has empty body -- no directives!"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
case|case
name|BODY
case|:
case|case
name|BODYEOF
case|:
operator|(
name|void
operator|)
name|fseek
argument_list|(
name|in
argument_list|,
call|(
name|long
call|)
argument_list|(
operator|-
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|LENERR
case|:
case|case
name|FMTERR
case|:
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"message format error in component #%d"
argument_list|,
name|compnum
argument_list|)
expr_stmt|;
default|default:
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"getfld() returned %d"
argument_list|,
name|state
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
operator|(
name|free_ct
operator|=
name|ct
operator|=
operator|(
name|CT
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
expr|*
name|ct
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
if|if
condition|(
name|get_ctinfo
argument_list|(
literal|"multipart/mixed"
argument_list|,
name|ct
argument_list|,
literal|0
argument_list|)
operator|==
name|NOTOK
condition|)
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|ct
operator|->
name|c_type
operator|=
name|CT_MULTIPART
expr_stmt|;
name|ct
operator|->
name|c_subtype
operator|=
name|MULTI_MIXED
expr_stmt|;
name|ct
operator|->
name|c_ctlistfnx
operator|=
name|list_multi
expr_stmt|;
name|ct
operator|->
name|c_ctfreefnx
operator|=
name|free_multi
expr_stmt|;
name|ct
operator|->
name|c_file
operator|=
name|add
argument_list|(
name|file
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|=
operator|(
expr|struct
name|multipart
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
expr|*
name|m
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
name|ct
operator|->
name|c_ctparams
operator|=
operator|(
name|caddr_t
operator|)
name|m
expr_stmt|;
name|pp
operator|=
operator|&
name|m
operator|->
name|mp_parts
expr_stmt|;
while|while
condition|(
name|fgetstr
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
operator|-
literal|1
argument_list|,
name|in
argument_list|)
condition|)
block|{
specifier|register
name|struct
name|part
modifier|*
name|part
decl_stmt|;
name|CT
name|p
decl_stmt|;
if|if
condition|(
name|user_content
argument_list|(
name|in
argument_list|,
name|file
argument_list|,
name|buf
argument_list|,
operator|&
name|p
argument_list|)
operator|==
name|DONE
condition|)
block|{
name|admonish
argument_list|(
name|NULLCP
argument_list|,
literal|"ignoring spurious #end"
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|p
condition|)
continue|continue;
if|if
condition|(
operator|(
name|part
operator|=
operator|(
expr|struct
name|part
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
expr|*
name|part
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
operator|*
name|pp
operator|=
name|part
operator|,
name|pp
operator|=
operator|&
name|part
operator|->
name|mp_next
expr_stmt|;
name|part
operator|->
name|mp_part
operator|=
name|p
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
operator|->
name|mp_parts
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"no content directives found"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
operator|->
name|mp_parts
operator|->
name|mp_next
condition|)
block|{
name|CT
name|p
init|=
name|m
operator|->
name|mp_parts
operator|->
name|mp_part
decl_stmt|;
name|m
operator|->
name|mp_parts
operator|->
name|mp_part
operator|=
name|NULL
expr_stmt|;
name|free_content
argument_list|(
name|ct
argument_list|)
expr_stmt|;
name|free_ct
operator|=
name|ct
operator|=
name|p
expr_stmt|;
block|}
else|else
name|set_id
argument_list|(
name|ct
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|index
argument_list|(
name|prefix
argument_list|,
literal|'a'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"internal error(4)"
argument_list|)
expr_stmt|;
while|while
condition|(
name|compose_content
argument_list|(
name|ct
argument_list|)
operator|==
name|NOTOK
condition|)
if|if
condition|(
operator|*
name|cp
operator|<
literal|'z'
condition|)
operator|(
operator|*
name|cp
operator|)
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
operator|++
name|cp
operator|==
literal|0
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"giving up trying to find a unique delimiter string"
argument_list|)
expr_stmt|;
else|else
operator|(
operator|*
name|cp
operator|)
operator|++
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"%s: %s\n"
argument_list|,
name|VRSN_FIELD
argument_list|,
name|VRSN_VALUE
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|output_content
argument_list|(
name|ct
argument_list|,
name|out
argument_list|)
expr_stmt|;
if|if
condition|(
name|fflush
argument_list|(
name|out
argument_list|)
condition|)
name|adios
argument_list|(
name|tmpfil
argument_list|,
literal|"error writing to"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|out
argument_list|)
expr_stmt|;
if|if
condition|(
name|listsw
operator|&&
name|ct
operator|->
name|c_ctlistfnx
condition|)
block|{
name|char
modifier|*
name|savfile
decl_stmt|;
if|if
condition|(
name|headsw
condition|)
name|printf
argument_list|(
name|LSTFMT1
argument_list|,
literal|"msg"
argument_list|,
literal|"part"
argument_list|,
literal|"type/subtype"
argument_list|,
literal|"size"
argument_list|,
literal|"description"
argument_list|)
expr_stmt|;
comment|/* to get msgno */
name|savfile
operator|=
name|ct
operator|->
name|c_file
operator|,
name|ct
operator|->
name|c_file
operator|=
name|file
expr_stmt|;
call|(
modifier|*
name|ct
operator|->
name|c_ctlistfnx
call|)
argument_list|(
name|ct
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ct
operator|->
name|c_file
operator|=
name|savfile
expr_stmt|;
block|}
name|free_content
argument_list|(
name|ct
argument_list|)
expr_stmt|;
name|free_ct
operator|=
name|NULL
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s.orig"
argument_list|,
name|m_backup
argument_list|(
name|file
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rename
argument_list|(
name|file
argument_list|,
name|buf
argument_list|)
operator|==
name|NOTOK
condition|)
name|adios
argument_list|(
name|buf
argument_list|,
literal|"unable to rename %s to"
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|rename
argument_list|(
name|tmpfil
argument_list|,
name|file
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
name|advise
argument_list|(
name|file
argument_list|,
literal|"unable to rename %s to"
argument_list|,
name|tmpfil
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|rename
argument_list|(
name|buf
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|free_file
operator|=
name|NULL
expr_stmt|;
name|done
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|char
modifier|*
name|fgetstr
parameter_list|(
name|s
parameter_list|,
name|n
parameter_list|,
name|stream
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|n
decl_stmt|;
name|FILE
modifier|*
name|stream
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|ep
decl_stmt|;
for|for
control|(
name|ep
operator|=
operator|(
name|cp
operator|=
name|s
operator|)
operator|+
name|n
init|;
name|cp
operator|<
name|ep
condition|;
control|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|fgets
argument_list|(
name|cp
argument_list|,
name|n
argument_list|,
name|stream
argument_list|)
condition|)
return|return
operator|(
name|cp
operator|!=
name|s
condition|?
name|s
else|:
name|NULL
operator|)
return|;
if|if
condition|(
name|cp
operator|==
name|s
operator|&&
operator|*
name|cp
operator|!=
literal|'#'
condition|)
return|return
name|s
return|;
name|cp
operator|+=
operator|(
name|i
operator|=
name|strlen
argument_list|(
name|cp
argument_list|)
operator|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|i
operator|<=
literal|1
operator|||
operator|*
name|cp
operator|--
operator|!=
literal|'\n'
operator|||
operator|*
name|cp
operator|!=
literal|'\\'
condition|)
break|break;
operator|*
name|cp
operator|=
literal|0
operator|,
name|n
operator|-=
operator|(
name|i
operator|-
literal|2
operator|)
expr_stmt|;
block|}
return|return
name|s
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|user_content
parameter_list|(
name|in
parameter_list|,
name|file
parameter_list|,
name|buf
parameter_list|,
name|ctp
parameter_list|)
name|FILE
modifier|*
name|in
decl_stmt|;
name|char
modifier|*
name|file
decl_stmt|,
decl|*
name|buf
decl_stmt|;
end_function

begin_decl_stmt
name|CT
modifier|*
name|ctp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|extrnal
decl_stmt|,
name|vrsn
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
modifier|*
name|ap
decl_stmt|;
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|struct
name|multipart
modifier|*
name|m
decl_stmt|;
specifier|register
name|struct
name|part
modifier|*
modifier|*
name|pp
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
specifier|register
name|struct
name|str2init
modifier|*
name|s2i
decl_stmt|;
specifier|register
name|CI
name|ci
decl_stmt|;
specifier|register
name|CT
name|ct
decl_stmt|;
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'\n'
operator|||
name|strcmp
argument_list|(
name|buf
argument_list|,
literal|"#\n"
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|ctp
operator|=
name|NULL
expr_stmt|;
return|return
name|OK
return|;
block|}
if|if
condition|(
operator|(
name|ct
operator|=
operator|(
name|CT
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
expr|*
name|ct
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
operator|*
name|ctp
operator|=
name|ct
expr_stmt|;
name|ci
operator|=
operator|&
name|ct
operator|->
name|c_ctinfo
expr_stmt|;
name|ct
operator|->
name|c_ctlistfnx
operator|=
name|list_content
expr_stmt|;
name|set_id
argument_list|(
name|ct
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|!=
literal|'#'
operator|||
name|buf
index|[
literal|1
index|]
operator|==
literal|'#'
operator|||
name|buf
index|[
literal|1
index|]
operator|==
literal|'<'
condition|)
block|{
name|int
name|headers
decl_stmt|,
name|inlineD
decl_stmt|;
name|long
name|pos
decl_stmt|;
name|char
name|content
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|FILE
modifier|*
name|out
decl_stmt|;
name|ct
operator|->
name|c_file
operator|=
name|add
argument_list|(
name|m_tmpfil
argument_list|(
name|invo_name
argument_list|)
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
name|ct
operator|->
name|c_unlink
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|out
operator|=
name|fopen
argument_list|(
name|ct
operator|->
name|c_file
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|adios
argument_list|(
name|ct
operator|->
name|c_file
argument_list|,
literal|"unable to open for writing"
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'#'
operator|&&
name|buf
index|[
literal|1
index|]
operator|==
literal|'<'
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|content
argument_list|,
name|buf
operator|+
literal|2
argument_list|)
expr_stmt|;
name|inlineD
operator|=
literal|1
expr_stmt|;
goto|goto
name|rock_and_roll
goto|;
block|}
else|else
name|inlineD
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|content
argument_list|,
literal|"text/plain"
argument_list|)
expr_stmt|;
name|headers
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|buffer
argument_list|,
name|buf
index|[
literal|0
index|]
operator|!=
literal|'#'
condition|?
name|buf
else|:
name|buf
operator|+
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|headers
operator|>=
literal|0
operator|&&
name|uprf
argument_list|(
name|buffer
argument_list|,
name|DESCR_FIELD
argument_list|)
operator|&&
name|buffer
index|[
name|i
operator|=
name|strlen
argument_list|(
name|DESCR_FIELD
argument_list|)
index|]
operator|==
literal|':'
condition|)
block|{
name|headers
operator|=
literal|1
expr_stmt|;
name|again_descr
label|:
empty_stmt|;
name|ct
operator|->
name|c_descr
operator|=
name|add
argument_list|(
name|buffer
operator|+
name|i
operator|+
literal|1
argument_list|,
name|ct
operator|->
name|c_descr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fgetstr
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
name|buffer
operator|-
literal|1
argument_list|,
name|in
argument_list|)
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"end-of-file after %s: field in plaintext"
argument_list|,
name|DESCR_FIELD
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|buffer
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|' '
case|:
case|case
literal|'\t'
case|:
name|i
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|again_descr
goto|;
case|case
literal|'#'
case|:
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"#-directive after %s: field in plaintext"
argument_list|,
name|DESCR_FIELD
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
default|default:
break|break;
block|}
block|}
if|if
condition|(
name|headers
operator|!=
literal|1
operator|||
name|buffer
index|[
literal|0
index|]
operator|!=
literal|'\n'
condition|)
operator|(
name|void
operator|)
name|fputs
argument_list|(
name|buffer
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|rock_and_roll
label|:
empty_stmt|;
name|headers
operator|=
operator|-
literal|1
expr_stmt|;
name|pos
operator|=
name|ftell
argument_list|(
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|fgetstr
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
name|buffer
operator|-
literal|1
argument_list|,
name|in
argument_list|)
operator|)
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
name|buffer
index|[
literal|0
index|]
operator|==
literal|'#'
condition|)
block|{
specifier|register
name|char
modifier|*
name|bp
decl_stmt|;
if|if
condition|(
name|buffer
index|[
literal|1
index|]
operator|!=
literal|'#'
condition|)
break|break;
for|for
control|(
name|cp
operator|=
operator|(
name|bp
operator|=
name|buffer
operator|)
operator|+
literal|1
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
operator|*
name|bp
operator|++
operator|=
operator|*
name|cp
expr_stmt|;
operator|*
name|bp
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
if|if
condition|(
name|listsw
condition|)
name|ct
operator|->
name|c_end
operator|=
name|ftell
argument_list|(
name|out
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|out
argument_list|)
expr_stmt|;
if|if
condition|(
name|get_ctinfo
argument_list|(
name|content
argument_list|,
name|ct
argument_list|,
name|inlineD
argument_list|)
operator|==
name|NOTOK
condition|)
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|s2i
operator|=
name|str2cts
init|;
name|s2i
operator|->
name|si_key
condition|;
name|s2i
operator|++
control|)
if|if
condition|(
name|uleq
argument_list|(
name|ci
operator|->
name|ci_type
argument_list|,
name|s2i
operator|->
name|si_key
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|!
name|s2i
operator|->
name|si_key
operator|&&
operator|!
name|uprf
argument_list|(
name|ci
operator|->
name|ci_type
argument_list|,
literal|"X-"
argument_list|)
condition|)
name|s2i
operator|++
expr_stmt|;
switch|switch
condition|(
name|ct
operator|->
name|c_type
operator|=
name|s2i
operator|->
name|si_value
condition|)
block|{
case|case
name|CT_MESSAGE
case|:
if|if
condition|(
name|uleq
argument_list|(
name|ci
operator|->
name|ci_subtype
argument_list|,
literal|"rfc822"
argument_list|)
condition|)
block|{
name|ct
operator|->
name|c_encoding
operator|=
name|CE_7BIT
expr_stmt|;
comment|/* XXX */
goto|goto
name|call_init
goto|;
block|}
comment|/* else fall... */
case|case
name|CT_MULTIPART
case|:
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"it makes sense to define a in-line %s content... NOT!"
argument_list|,
name|ct
operator|->
name|c_type
operator|==
name|CT_MESSAGE
condition|?
literal|"message"
else|:
literal|"multipart"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
default|default:
name|call_init
label|:
empty_stmt|;
if|if
condition|(
name|ct
operator|->
name|c_ctinitfnx
operator|=
name|s2i
operator|->
name|si_init
condition|)
call|(
name|void
call|)
argument_list|(
operator|*
name|ct
operator|->
name|c_ctinitfnx
argument_list|)
argument_list|(
name|ct
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|cp
condition|)
operator|(
name|void
operator|)
name|fseek
argument_list|(
name|in
argument_list|,
name|pos
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|OK
return|;
block|}
name|extrnal
operator|=
name|buf
index|[
literal|1
index|]
operator|==
literal|'@'
expr_stmt|;
if|if
condition|(
name|get_ctinfo
argument_list|(
name|buf
operator|+
operator|(
name|extrnal
condition|?
literal|2
else|:
literal|1
operator|)
argument_list|,
name|ct
argument_list|,
literal|1
argument_list|)
operator|==
name|NOTOK
condition|)
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|s2i
operator|=
name|str2cts
init|;
name|s2i
operator|->
name|si_key
condition|;
name|s2i
operator|++
control|)
if|if
condition|(
name|uleq
argument_list|(
name|ci
operator|->
name|ci_type
argument_list|,
name|s2i
operator|->
name|si_key
argument_list|)
condition|)
break|break;
if|if
condition|(
name|s2i
operator|->
name|si_key
condition|)
block|{
comment|/* type/subtype [file] */
if|if
condition|(
operator|!
name|ci
operator|->
name|ci_subtype
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"missing subtype in \"#%s\""
argument_list|,
name|ci
operator|->
name|ci_type
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ct
operator|->
name|c_type
operator|=
name|s2i
operator|->
name|si_value
condition|)
block|{
case|case
name|CT_MULTIPART
case|:
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"use \"#begin ... #end\" instead of \"#%s/%s\""
argument_list|,
name|ci
operator|->
name|ci_type
argument_list|,
name|ci
operator|->
name|ci_subtype
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
case|case
name|CT_MESSAGE
case|:
if|if
condition|(
name|uleq
argument_list|(
name|ci
operator|->
name|ci_subtype
argument_list|,
literal|"partial"
argument_list|)
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"sorry, \"#%s/%s\" isn't supported"
argument_list|,
name|ci
operator|->
name|ci_type
argument_list|,
name|ci
operator|->
name|ci_subtype
argument_list|)
expr_stmt|;
if|if
condition|(
name|uleq
argument_list|(
name|ci
operator|->
name|ci_subtype
argument_list|,
literal|"external-body"
argument_list|)
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"use \"#@type/subtype ... [] ...\" instead of \"#%s/%s\""
argument_list|,
name|ci
operator|->
name|ci_type
argument_list|,
name|ci
operator|->
name|ci_subtype
argument_list|)
expr_stmt|;
name|use_forw
label|:
empty_stmt|;
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"use \"#forw [+folder] [msgs]\" instead of \"#%s/%s\""
argument_list|,
name|ci
operator|->
name|ci_type
argument_list|,
name|ci
operator|->
name|ci_subtype
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
default|default:
if|if
condition|(
name|ct
operator|->
name|c_ctinitfnx
operator|=
name|s2i
operator|->
name|si_init
condition|)
call|(
name|void
call|)
argument_list|(
operator|*
name|ct
operator|->
name|c_ctinitfnx
argument_list|)
argument_list|(
name|ct
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|extrnal
condition|)
block|{
specifier|register
name|struct
name|exbody
modifier|*
name|e
decl_stmt|;
name|CT
name|p
decl_stmt|;
if|if
condition|(
operator|!
name|ci
operator|->
name|ci_magic
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"need external information for \"#@%s/%s\""
argument_list|,
name|ci
operator|->
name|ci_type
argument_list|,
name|ci
operator|->
name|ci_subtype
argument_list|)
expr_stmt|;
name|p
operator|=
name|ct
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"message/external-body; %s"
argument_list|,
name|ci
operator|->
name|ci_magic
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ci
operator|->
name|ci_magic
argument_list|)
operator|,
name|ci
operator|->
name|ci_magic
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|ct
operator|=
operator|(
name|CT
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
expr|*
name|ct
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
operator|*
name|ctp
operator|=
name|ct
expr_stmt|;
name|ci
operator|=
operator|&
name|ct
operator|->
name|c_ctinfo
expr_stmt|;
name|ct
operator|->
name|c_ctlistfnx
operator|=
name|list_content
expr_stmt|;
if|if
condition|(
name|get_ctinfo
argument_list|(
name|buffer
argument_list|,
name|ct
argument_list|,
literal|0
argument_list|)
operator|==
name|NOTOK
condition|)
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|ct
operator|->
name|c_type
operator|=
name|CT_MESSAGE
expr_stmt|;
name|ct
operator|->
name|c_subtype
operator|=
name|MESSAGE_EXTERNAL
expr_stmt|;
if|if
condition|(
operator|(
name|e
operator|=
operator|(
expr|struct
name|exbody
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
expr|*
name|e
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
name|ct
operator|->
name|c_ctparams
operator|=
operator|(
name|caddr_t
operator|)
name|e
expr_stmt|;
name|ct
operator|->
name|c_ctfreefnx
operator|=
name|free_external
expr_stmt|;
name|e
operator|->
name|eb_parent
operator|=
name|ct
expr_stmt|;
name|e
operator|->
name|eb_content
operator|=
name|p
expr_stmt|;
name|p
operator|->
name|c_ctextern
operator|=
operator|(
name|caddr_t
operator|)
name|e
expr_stmt|;
name|ct
operator|->
name|c_ctlistfnx
operator|=
name|list_external
expr_stmt|;
if|if
condition|(
name|params_external
argument_list|(
name|ct
argument_list|,
literal|1
argument_list|)
operator|==
name|NOTOK
condition|)
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
name|OK
return|;
block|}
if|if
condition|(
name|ci
operator|->
name|ci_magic
condition|)
block|{
if|if
condition|(
operator|*
name|ci
operator|->
name|ci_magic
operator|==
literal|'|'
operator|||
operator|*
name|ci
operator|->
name|ci_magic
operator|==
literal|'!'
condition|)
block|{
for|for
control|(
name|cp
operator|=
name|ci
operator|->
name|ci_magic
operator|+
literal|1
init|;
name|isspace
argument_list|(
operator|*
name|cp
argument_list|)
condition|;
name|cp
operator|++
control|)
continue|continue;
if|if
condition|(
operator|!
operator|*
name|cp
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"empty pipe command for #%s directive"
argument_list|,
name|ci
operator|->
name|ci_type
argument_list|)
expr_stmt|;
name|cp
operator|=
name|add
argument_list|(
name|cp
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ci
operator|->
name|ci_magic
argument_list|)
expr_stmt|;
name|ci
operator|->
name|ci_magic
operator|=
name|cp
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|access
argument_list|(
name|ct
operator|->
name|c_file
operator|=
name|ci
operator|->
name|ci_magic
argument_list|,
literal|04
argument_list|)
operator|==
name|NOTOK
condition|)
name|adios
argument_list|(
literal|"reading"
argument_list|,
literal|"unable to access %s for"
argument_list|,
name|ct
operator|->
name|c_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|listsw
operator|&&
name|stat
argument_list|(
name|ct
operator|->
name|c_file
argument_list|,
operator|&
name|st
argument_list|)
operator|!=
name|NOTOK
condition|)
name|ct
operator|->
name|c_end
operator|=
operator|(
name|long
operator|)
name|st
operator|.
name|st_size
expr_stmt|;
name|ci
operator|->
name|ci_magic
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|OK
return|;
block|}
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%s-compose-%s/%s"
argument_list|,
name|invo_name
argument_list|,
name|ci
operator|->
name|ci_type
argument_list|,
name|ci
operator|->
name|ci_subtype
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|m_find
argument_list|(
name|buffer
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|*
name|cp
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%s-compose-%s"
argument_list|,
name|invo_name
argument_list|,
name|ci
operator|->
name|ci_type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|m_find
argument_list|(
name|buffer
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|*
name|cp
operator|==
literal|0
condition|)
block|{
name|content_error
argument_list|(
name|NULLCP
argument_list|,
name|ct
argument_list|,
literal|"don't know how to compose content"
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|ci
operator|->
name|ci_magic
operator|=
name|add
argument_list|(
name|cp
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
return|return
name|OK
return|;
block|}
if|if
condition|(
name|extrnal
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"externally definition not allowed for \"#%s\""
argument_list|,
name|ci
operator|->
name|ci_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|uleq
argument_list|(
name|ci
operator|->
name|ci_type
argument_list|,
literal|"forw"
argument_list|)
condition|)
block|{
comment|/* #forw [+folder] [msgs] */
name|int
name|msgnum
decl_stmt|;
name|char
modifier|*
name|folder
decl_stmt|,
modifier|*
name|arguments
index|[
name|MAXARGS
index|]
decl_stmt|;
name|struct
name|msgs
modifier|*
name|mp
decl_stmt|;
if|if
condition|(
name|ci
operator|->
name|ci_magic
condition|)
block|{
name|ap
operator|=
name|brkstring
argument_list|(
name|ci
operator|->
name|ci_magic
argument_list|,
literal|" "
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|ap
operator|=
name|copyip
argument_list|(
name|ap
argument_list|,
name|arguments
argument_list|)
expr_stmt|;
block|}
else|else
name|arguments
index|[
literal|0
index|]
operator|=
literal|"cur"
operator|,
name|arguments
index|[
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
name|folder
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|ap
operator|=
name|arguments
init|;
name|cp
operator|=
operator|*
name|ap
condition|;
name|ap
operator|++
control|)
if|if
condition|(
operator|*
name|cp
operator|==
literal|'+'
operator|||
operator|*
name|cp
operator|==
literal|'@'
condition|)
if|if
condition|(
name|folder
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"only one folder per #forw directive"
argument_list|)
expr_stmt|;
else|else
name|folder
operator|=
name|path
argument_list|(
name|cp
operator|+
literal|1
argument_list|,
operator|*
name|cp
operator|==
literal|'+'
condition|?
name|TFOLDER
else|:
name|TSUBCWF
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|folder
condition|)
name|folder
operator|=
name|add
argument_list|(
name|m_getfolder
argument_list|()
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|mp
operator|=
name|m_gmsg
argument_list|(
name|folder
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"unable to read folder %s"
argument_list|,
name|folder
argument_list|)
expr_stmt|;
for|for
control|(
name|ap
operator|=
name|arguments
init|;
name|cp
operator|=
operator|*
name|ap
condition|;
name|ap
operator|++
control|)
if|if
condition|(
operator|*
name|cp
operator|!=
literal|'+'
operator|&&
operator|*
name|cp
operator|!=
literal|'@'
condition|)
if|if
condition|(
operator|!
name|m_convert
argument_list|(
name|mp
argument_list|,
name|cp
argument_list|)
condition|)
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|folder
argument_list|)
expr_stmt|;
name|free_ctinfo
argument_list|(
name|ct
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|numsel
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|get_ctinfo
argument_list|(
literal|"multipart/digest"
argument_list|,
name|ct
argument_list|,
literal|0
argument_list|)
operator|==
name|NOTOK
condition|)
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|ct
operator|->
name|c_type
operator|=
name|CT_MULTIPART
expr_stmt|;
name|ct
operator|->
name|c_subtype
operator|=
name|MULTI_DIGEST
expr_stmt|;
name|ct
operator|->
name|c_ctlistfnx
operator|=
name|list_multi
expr_stmt|;
name|ct
operator|->
name|c_ctfreefnx
operator|=
name|free_multi
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|=
operator|(
expr|struct
name|multipart
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
expr|*
name|m
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
name|ct
operator|->
name|c_ctparams
operator|=
operator|(
name|caddr_t
operator|)
name|m
expr_stmt|;
name|pp
operator|=
operator|&
name|m
operator|->
name|mp_parts
expr_stmt|;
block|}
else|else
name|free_content
argument_list|(
name|ct
argument_list|)
expr_stmt|;
for|for
control|(
name|msgnum
operator|=
name|mp
operator|->
name|lowsel
init|;
name|msgnum
operator|<=
name|mp
operator|->
name|hghsel
condition|;
name|msgnum
operator|++
control|)
if|if
condition|(
name|mp
operator|->
name|msgstats
index|[
name|msgnum
index|]
operator|&
name|SELECTED
condition|)
block|{
specifier|register
name|struct
name|part
modifier|*
name|part
decl_stmt|;
specifier|register
name|CT
name|p
decl_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
operator|(
name|CT
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
expr|*
name|p
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
if|if
condition|(
name|get_ctinfo
argument_list|(
literal|"message/rfc822"
argument_list|,
name|p
argument_list|,
literal|0
argument_list|)
operator|==
name|NOTOK
condition|)
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|p
operator|->
name|c_type
operator|=
name|CT_MESSAGE
expr_stmt|;
name|p
operator|->
name|c_subtype
operator|=
name|MESSAGE_RFC822
expr_stmt|;
name|p
operator|->
name|c_ctlistfnx
operator|=
name|list_content
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%s/%d"
argument_list|,
name|mp
operator|->
name|foldpath
argument_list|,
name|msgnum
argument_list|)
expr_stmt|;
name|p
operator|->
name|c_file
operator|=
name|add
argument_list|(
name|buffer
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
if|if
condition|(
name|listsw
operator|&&
name|stat
argument_list|(
name|p
operator|->
name|c_file
argument_list|,
operator|&
name|st
argument_list|)
operator|!=
name|NOTOK
condition|)
name|p
operator|->
name|c_end
operator|=
operator|(
name|long
operator|)
name|st
operator|.
name|st_size
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|numsel
operator|>
literal|1
condition|)
block|{
if|if
condition|(
operator|(
name|part
operator|=
operator|(
expr|struct
name|part
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
expr|*
name|part
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
operator|*
name|pp
operator|=
name|part
operator|,
name|pp
operator|=
operator|&
name|part
operator|->
name|mp_next
expr_stmt|;
name|part
operator|->
name|mp_part
operator|=
name|p
expr_stmt|;
block|}
else|else
operator|*
name|ctp
operator|=
name|ct
operator|=
name|p
expr_stmt|;
block|}
name|m_fmsg
argument_list|(
name|mp
argument_list|)
expr_stmt|;
return|return
name|OK
return|;
block|}
if|if
condition|(
name|uleq
argument_list|(
name|ci
operator|->
name|ci_type
argument_list|,
literal|"end"
argument_list|)
condition|)
block|{
name|free_content
argument_list|(
name|ct
argument_list|)
expr_stmt|;
operator|*
name|ctp
operator|=
name|NULL
expr_stmt|;
return|return
name|DONE
return|;
block|}
if|if
condition|(
operator|!
name|uleq
argument_list|(
name|ci
operator|->
name|ci_type
argument_list|,
literal|"begin"
argument_list|)
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"unknown directive \"#%s\""
argument_list|,
name|ci
operator|->
name|ci_type
argument_list|)
expr_stmt|;
comment|/* #begin [ alternative | parallel ] */
if|if
condition|(
operator|!
name|ci
operator|->
name|ci_magic
condition|)
name|cp
operator|=
name|SubMultiPart
index|[
operator|(
name|vrsn
operator|=
name|MULTI_MIXED
operator|)
operator|-
literal|1
index|]
operator|.
name|kv_key
expr_stmt|;
elseif|else
if|if
condition|(
name|uleq
argument_list|(
name|ci
operator|->
name|ci_magic
argument_list|,
literal|"alternative"
argument_list|)
condition|)
name|cp
operator|=
name|SubMultiPart
index|[
operator|(
name|vrsn
operator|=
name|MULTI_ALTERNATE
operator|)
operator|-
literal|1
index|]
operator|.
name|kv_key
expr_stmt|;
elseif|else
if|if
condition|(
name|uleq
argument_list|(
name|ci
operator|->
name|ci_magic
argument_list|,
literal|"parallel"
argument_list|)
condition|)
name|cp
operator|=
name|SubMultiPart
index|[
operator|(
name|vrsn
operator|=
name|MULTI_PARALLEL
operator|)
operator|-
literal|1
index|]
operator|.
name|kv_key
expr_stmt|;
elseif|else
if|if
condition|(
name|uprf
argument_list|(
name|ci
operator|->
name|ci_magic
argument_list|,
literal|"digest"
argument_list|)
condition|)
goto|goto
name|use_forw
goto|;
else|else
name|cp
operator|=
name|ci
operator|->
name|ci_magic
operator|,
name|vrsn
operator|=
name|MULTI_UNKNOWN
expr_stmt|;
name|free_ctinfo
argument_list|(
name|ct
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"multipart/%s"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|get_ctinfo
argument_list|(
name|buffer
argument_list|,
name|ct
argument_list|,
literal|0
argument_list|)
operator|==
name|NOTOK
condition|)
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|ct
operator|->
name|c_type
operator|=
name|CT_MULTIPART
expr_stmt|;
name|ct
operator|->
name|c_subtype
operator|=
name|vrsn
expr_stmt|;
name|ct
operator|->
name|c_ctlistfnx
operator|=
name|list_multi
expr_stmt|;
name|ct
operator|->
name|c_ctfreefnx
operator|=
name|free_multi
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|=
operator|(
expr|struct
name|multipart
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
expr|*
name|m
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
name|ct
operator|->
name|c_ctparams
operator|=
operator|(
name|caddr_t
operator|)
name|m
expr_stmt|;
name|pp
operator|=
operator|&
name|m
operator|->
name|mp_parts
expr_stmt|;
while|while
condition|(
name|fgetstr
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
name|buffer
operator|-
literal|1
argument_list|,
name|in
argument_list|)
condition|)
block|{
specifier|register
name|struct
name|part
modifier|*
name|part
decl_stmt|;
name|CT
name|p
decl_stmt|;
if|if
condition|(
name|user_content
argument_list|(
name|in
argument_list|,
name|file
argument_list|,
name|buffer
argument_list|,
operator|&
name|p
argument_list|)
operator|==
name|DONE
condition|)
block|{
if|if
condition|(
operator|!
name|m
operator|->
name|mp_parts
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"empty \"#begin ... #end\" sequence"
argument_list|)
expr_stmt|;
return|return
name|OK
return|;
block|}
if|if
condition|(
operator|!
name|p
condition|)
continue|continue;
if|if
condition|(
operator|(
name|part
operator|=
operator|(
expr|struct
name|part
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
expr|*
name|part
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
operator|*
name|pp
operator|=
name|part
operator|,
name|pp
operator|=
operator|&
name|part
operator|->
name|mp_next
expr_stmt|;
name|part
operator|->
name|mp_part
operator|=
name|p
expr_stmt|;
block|}
name|admonish
argument_list|(
name|NULLCP
argument_list|,
literal|"premature end-of-file, missing #end"
argument_list|)
expr_stmt|;
return|return
name|OK
return|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|void
name|set_id
parameter_list|(
name|ct
parameter_list|,
name|top
parameter_list|)
name|CT
name|ct
decl_stmt|;
name|int
name|top
decl_stmt|;
block|{
name|char
name|msgid
index|[
name|BUFSIZ
index|]
decl_stmt|;
specifier|static
name|int
name|partno
decl_stmt|;
specifier|static
name|long
name|clock
init|=
literal|0L
decl_stmt|;
specifier|static
name|char
modifier|*
name|msgfmt
decl_stmt|;
if|if
condition|(
name|clock
operator|==
literal|0L
condition|)
block|{
operator|(
name|void
operator|)
name|time
argument_list|(
operator|&
name|clock
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|msgid
argument_list|,
literal|"<%d.%ld.%%d@%s>\n"
argument_list|,
name|getpid
argument_list|()
argument_list|,
name|clock
argument_list|,
name|LocalName
argument_list|()
argument_list|)
expr_stmt|;
name|partno
operator|=
literal|0
expr_stmt|;
name|msgfmt
operator|=
name|getcpy
argument_list|(
name|msgid
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|msgid
argument_list|,
name|msgfmt
argument_list|,
name|top
condition|?
literal|0
else|:
operator|++
name|partno
argument_list|)
expr_stmt|;
name|ct
operator|->
name|c_id
operator|=
name|getcpy
argument_list|(
name|msgid
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_decl_stmt
specifier|static
name|char
name|ebcdicsafe
index|[
literal|0x100
index|]
init|=
block|{
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x01
block|,
literal|0x01
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x01
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x01
block|,
literal|0x01
block|,
literal|0x01
block|,
literal|0x01
block|,
literal|0x01
block|,
literal|0x01
block|,
literal|0x01
block|,
literal|0x01
block|,
literal|0x01
block|,
literal|0x01
block|,
literal|0x01
block|,
literal|0x01
block|,
literal|0x01
block|,
literal|0x01
block|,
literal|0x01
block|,
literal|0x01
block|,
literal|0x01
block|,
literal|0x01
block|,
literal|0x01
block|,
literal|0x01
block|,
literal|0x01
block|,
literal|0x01
block|,
literal|0x01
block|,
literal|0x01
block|,
literal|0x01
block|,
literal|0x01
block|,
literal|0x01
block|,
literal|0x00
block|,
literal|0x01
block|,
literal|0x01
block|,
literal|0x01
block|,
literal|0x01
block|,
literal|0x01
block|,
literal|0x01
block|,
literal|0x01
block|,
literal|0x01
block|,
literal|0x01
block|,
literal|0x01
block|,
literal|0x01
block|,
literal|0x01
block|,
literal|0x01
block|,
literal|0x01
block|,
literal|0x01
block|,
literal|0x01
block|,
literal|0x01
block|,
literal|0x01
block|,
literal|0x01
block|,
literal|0x01
block|,
literal|0x01
block|,
literal|0x01
block|,
literal|0x01
block|,
literal|0x01
block|,
literal|0x01
block|,
literal|0x01
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x01
block|,
literal|0x00
block|,
literal|0x01
block|,
literal|0x01
block|,
literal|0x01
block|,
literal|0x01
block|,
literal|0x01
block|,
literal|0x01
block|,
literal|0x01
block|,
literal|0x01
block|,
literal|0x01
block|,
literal|0x01
block|,
literal|0x01
block|,
literal|0x01
block|,
literal|0x01
block|,
literal|0x01
block|,
literal|0x01
block|,
literal|0x01
block|,
literal|0x01
block|,
literal|0x01
block|,
literal|0x01
block|,
literal|0x01
block|,
literal|0x01
block|,
literal|0x01
block|,
literal|0x01
block|,
literal|0x01
block|,
literal|0x01
block|,
literal|0x01
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|compose_content
parameter_list|(
name|ct
parameter_list|)
specifier|register
name|CT
name|ct
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
specifier|register
name|CI
name|ci
init|=
operator|&
name|ct
operator|->
name|c_ctinfo
decl_stmt|;
if|if
condition|(
name|ct
operator|->
name|c_type
operator|==
name|CT_MESSAGE
operator|&&
name|ct
operator|->
name|c_subtype
operator|==
name|MESSAGE_EXTERNAL
condition|)
return|return
name|OK
return|;
switch|switch
condition|(
name|ct
operator|->
name|c_type
condition|)
block|{
case|case
name|CT_MULTIPART
case|:
block|{
name|int
name|partnum
decl_stmt|;
specifier|register
name|char
modifier|*
name|pp
decl_stmt|;
name|char
name|partnam
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|struct
name|multipart
modifier|*
name|m
init|=
operator|(
expr|struct
name|multipart
operator|*
operator|)
name|ct
operator|->
name|c_ctparams
decl_stmt|;
specifier|register
name|struct
name|part
modifier|*
name|part
decl_stmt|;
if|if
condition|(
name|ct
operator|->
name|c_partno
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|partnam
argument_list|,
literal|"%s."
argument_list|,
name|ct
operator|->
name|c_partno
argument_list|)
expr_stmt|;
name|pp
operator|=
name|partnam
operator|+
name|strlen
argument_list|(
name|partnam
argument_list|)
expr_stmt|;
block|}
else|else
name|pp
operator|=
name|partnam
expr_stmt|;
for|for
control|(
name|part
operator|=
name|m
operator|->
name|mp_parts
operator|,
name|partnum
operator|=
literal|1
init|;
name|part
condition|;
name|part
operator|=
name|part
operator|->
name|mp_next
operator|,
name|partnum
operator|++
control|)
block|{
specifier|register
name|CT
name|p
init|=
name|part
operator|->
name|mp_part
decl_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|pp
argument_list|,
literal|"%d"
argument_list|,
name|partnum
argument_list|)
expr_stmt|;
name|p
operator|->
name|c_partno
operator|=
name|add
argument_list|(
name|partnam
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
if|if
condition|(
name|compose_content
argument_list|(
name|p
argument_list|)
operator|==
name|NOTOK
condition|)
return|return
name|NOTOK
return|;
block|}
if|if
condition|(
name|rfc934sw
operator|&&
name|ct
operator|->
name|c_subtype
operator|==
name|MULTI_DIGEST
condition|)
block|{
name|int
name|is934
init|=
literal|1
decl_stmt|;
for|for
control|(
name|part
operator|=
name|m
operator|->
name|mp_parts
init|;
name|part
condition|;
name|part
operator|=
name|part
operator|->
name|mp_next
control|)
block|{
specifier|register
name|CT
name|p
init|=
name|part
operator|->
name|mp_part
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|c_subtype
operator|!=
name|MESSAGE_RFC822
condition|)
block|{
name|is934
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
name|ct
operator|->
name|c_rfc934
operator|=
name|is934
expr_stmt|;
for|for
control|(
name|part
operator|=
name|m
operator|->
name|mp_parts
init|;
name|part
condition|;
name|part
operator|=
name|part
operator|->
name|mp_next
control|)
block|{
specifier|register
name|CT
name|p
init|=
name|part
operator|->
name|mp_part
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|c_rfc934
operator|=
name|is934
condition|)
name|p
operator|->
name|c_end
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|listsw
condition|)
block|{
name|ct
operator|->
name|c_end
operator|=
operator|(
name|partnum
operator|=
name|strlen
argument_list|(
name|prefix
argument_list|)
operator|+
literal|2
operator|)
operator|+
literal|2
expr_stmt|;
if|if
condition|(
name|ct
operator|->
name|c_rfc934
condition|)
name|ct
operator|->
name|c_end
operator|+=
literal|1
expr_stmt|;
for|for
control|(
name|part
operator|=
name|m
operator|->
name|mp_parts
init|;
name|part
condition|;
name|part
operator|=
name|part
operator|->
name|mp_next
control|)
name|ct
operator|->
name|c_end
operator|+=
name|part
operator|->
name|mp_part
operator|->
name|c_end
operator|+
name|partnum
expr_stmt|;
block|}
block|}
break|break;
default|default:
if|if
condition|(
operator|!
name|ct
operator|->
name|c_file
condition|)
block|{
name|int
name|child_id
decl_stmt|,
name|i
decl_stmt|,
name|xstdout
decl_stmt|;
specifier|register
name|char
modifier|*
name|bp
decl_stmt|,
modifier|*
modifier|*
name|ap
decl_stmt|;
name|char
modifier|*
name|vec
index|[
literal|4
index|]
decl_stmt|;
name|FILE
modifier|*
name|out
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|cp
operator|=
name|ci
operator|->
name|ci_magic
operator|)
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"internal error(5)"
argument_list|)
expr_stmt|;
name|ct
operator|->
name|c_file
operator|=
name|add
argument_list|(
name|m_tmpfil
argument_list|(
name|invo_name
argument_list|)
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
name|ct
operator|->
name|c_unlink
operator|=
literal|1
expr_stmt|;
name|xstdout
operator|=
literal|0
expr_stmt|;
name|buffer
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|bp
operator|=
name|buffer
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
if|if
condition|(
operator|*
name|cp
operator|==
literal|'%'
condition|)
block|{
switch|switch
condition|(
operator|*
operator|++
name|cp
condition|)
block|{
case|case
literal|'a'
case|:
comment|/* additional arguments */
block|{
specifier|register
name|char
modifier|*
modifier|*
name|ep
decl_stmt|;
name|char
modifier|*
name|s
init|=
literal|""
decl_stmt|;
for|for
control|(
name|ap
operator|=
name|ci
operator|->
name|ci_attrs
operator|,
name|ep
operator|=
name|ci
operator|->
name|ci_values
init|;
operator|*
name|ap
condition|;
name|ap
operator|++
operator|,
name|ep
operator|++
control|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|bp
argument_list|,
literal|"%s%s=\"%s\""
argument_list|,
name|s
argument_list|,
operator|*
name|ap
argument_list|,
operator|*
name|ep
argument_list|)
expr_stmt|;
name|bp
operator|+=
name|strlen
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|s
operator|=
literal|" "
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'F'
case|:
comment|/* %f, and stdout is not-redirected */
name|xstdout
operator|=
literal|1
expr_stmt|;
comment|/* and fall... */
case|case
literal|'f'
case|:
comment|/* filename */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|bp
argument_list|,
literal|"%s"
argument_list|,
name|ct
operator|->
name|c_file
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
comment|/* subtype */
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|bp
argument_list|,
name|ci
operator|->
name|ci_subtype
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'%'
case|:
goto|goto
name|raw
goto|;
default|default:
operator|*
name|bp
operator|++
operator|=
operator|*
operator|--
name|cp
expr_stmt|;
operator|*
name|bp
operator|=
literal|'\0'
expr_stmt|;
continue|continue;
block|}
name|bp
operator|+=
name|strlen
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|raw
label|:
empty_stmt|;
operator|*
name|bp
operator|++
operator|=
operator|*
name|cp
expr_stmt|;
operator|*
name|bp
operator|=
literal|'\0'
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"composing content %s/%s from command\n\t%s\n"
argument_list|,
name|ci
operator|->
name|ci_type
argument_list|,
name|ci
operator|->
name|ci_subtype
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|vec
index|[
literal|0
index|]
operator|=
literal|"/bin/sh"
expr_stmt|;
name|vec
index|[
literal|1
index|]
operator|=
literal|"-c"
expr_stmt|;
name|vec
index|[
literal|2
index|]
operator|=
name|buffer
expr_stmt|;
name|vec
index|[
literal|3
index|]
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|out
operator|=
name|fopen
argument_list|(
name|ct
operator|->
name|c_file
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|adios
argument_list|(
name|ct
operator|->
name|c_file
argument_list|,
literal|"unable to open for writing"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|child_id
operator|=
name|vfork
argument_list|()
operator|)
operator|==
name|NOTOK
operator|&&
name|i
operator|>
literal|5
condition|;
name|i
operator|++
control|)
name|sleep
argument_list|(
literal|5
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|child_id
condition|)
block|{
case|case
name|NOTOK
case|:
name|adios
argument_list|(
literal|"fork"
argument_list|,
literal|"unable to fork"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
case|case
name|OK
case|:
if|if
condition|(
operator|!
name|xstdout
condition|)
operator|(
name|void
operator|)
name|dup2
argument_list|(
name|fileno
argument_list|(
name|out
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fileno
argument_list|(
name|out
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|execvp
argument_list|(
literal|"/bin/sh"
argument_list|,
name|vec
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"unable to exec "
argument_list|)
expr_stmt|;
name|perror
argument_list|(
literal|"/bin/sh"
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
default|default:
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|out
argument_list|)
expr_stmt|;
if|if
condition|(
name|pidXwait
argument_list|(
name|child_id
argument_list|,
name|NULLCP
argument_list|)
condition|)
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|listsw
operator|&&
name|ct
operator|->
name|c_end
operator|==
literal|0L
condition|)
block|{
name|struct
name|stat
name|st
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|ct
operator|->
name|c_file
argument_list|,
operator|&
name|st
argument_list|)
operator|!=
name|NOTOK
condition|)
name|ct
operator|->
name|c_end
operator|=
operator|(
name|long
operator|)
name|st
operator|.
name|st_size
expr_stmt|;
block|}
if|if
condition|(
name|ct
operator|->
name|c_type
operator|!=
name|CT_TEXT
operator|&&
operator|!
operator|(
name|ct
operator|->
name|c_type
operator|==
name|CT_APPLICATION
operator|&&
name|ct
operator|->
name|c_subtype
operator|==
name|APPLICATION_POSTSCRIPT
operator|)
condition|)
break|break;
comment|/* else fall... */
case|case
name|CT_MESSAGE
case|:
block|{
name|int
name|charset
decl_stmt|,
name|len
decl_stmt|,
name|linelen
decl_stmt|,
name|result
decl_stmt|;
name|FILE
modifier|*
name|in
decl_stmt|;
if|if
condition|(
operator|(
name|in
operator|=
name|fopen
argument_list|(
name|ct
operator|->
name|c_file
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|adios
argument_list|(
name|ct
operator|->
name|c_file
argument_list|,
literal|"unable to open for reading"
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|prefix
argument_list|)
expr_stmt|;
name|result
operator|=
name|OK
expr_stmt|;
switch|switch
condition|(
name|ct
operator|->
name|c_type
condition|)
block|{
case|case
name|CT_TEXT
case|:
name|charset
operator|=
name|ct
operator|->
name|c_ctparams
condition|?
literal|0
else|:
operator|-
literal|1
expr_stmt|;
name|linelen
operator|=
name|ct
operator|->
name|c_subtype
operator|==
name|TEXT_PLAIN
condition|?
literal|0
else|:
operator|-
literal|1
expr_stmt|;
break|break;
case|case
name|CT_APPLICATION
case|:
name|charset
operator|=
name|linelen
operator|=
name|ct
operator|->
name|c_encoding
condition|?
literal|0
else|:
operator|-
literal|1
expr_stmt|;
break|break;
default|default:
name|charset
operator|=
name|linelen
operator|=
literal|0
expr_stmt|;
break|break;
block|}
while|while
condition|(
name|fgets
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
name|buffer
operator|-
literal|1
argument_list|,
name|in
argument_list|)
condition|)
block|{
if|if
condition|(
name|charset
operator|==
operator|-
literal|1
condition|)
block|{
for|for
control|(
name|cp
operator|=
name|buffer
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|isascii
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
block|{
name|charset
operator|=
name|CHARSET_UNKNOWN
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|linelen
operator|==
operator|-
literal|1
operator|&&
name|ebcdicsw
operator|&&
operator|!
name|ebcdicsafe
index|[
operator|*
name|cp
operator|&
literal|0xff
index|]
condition|)
name|linelen
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|linelen
operator|==
operator|-
literal|1
operator|)
operator|&&
operator|(
name|cp
operator|-
name|buffer
operator|>
name|CPERLIN
operator|+
literal|1
operator|)
condition|)
name|linelen
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|NOTOK
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
operator|(
name|linelen
operator|==
operator|-
literal|1
operator|)
operator|&&
operator|(
name|strlen
argument_list|(
name|buffer
argument_list|)
operator|>
name|CPERLIN
operator|+
literal|1
operator|)
condition|)
name|linelen
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|NOTOK
condition|)
continue|continue;
if|if
condition|(
name|linelen
operator|==
operator|-
literal|1
operator|&&
operator|(
name|cp
operator|=
name|buffer
operator|+
name|strlen
argument_list|(
name|buffer
argument_list|)
operator|-
literal|2
operator|)
operator|>
name|buffer
operator|&&
name|isspace
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
name|linelen
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|buffer
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|buffer
index|[
literal|1
index|]
operator|==
literal|'-'
condition|)
block|{
for|for
control|(
name|cp
operator|=
name|buffer
operator|+
name|strlen
argument_list|(
name|buffer
argument_list|)
operator|-
literal|1
init|;
name|cp
operator|>=
name|buffer
condition|;
name|cp
operator|--
control|)
if|if
condition|(
operator|!
name|isspace
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
break|break;
operator|*
operator|++
name|cp
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|buffer
operator|+
literal|2
argument_list|,
name|prefix
argument_list|,
name|len
argument_list|)
operator|==
literal|0
operator|&&
name|isdigit
argument_list|(
name|buffer
index|[
literal|2
operator|+
name|len
index|]
argument_list|)
condition|)
block|{
name|result
operator|=
name|NOTOK
expr_stmt|;
if|if
condition|(
name|charset
operator|!=
operator|-
literal|1
operator|&&
name|linelen
operator|!=
operator|-
literal|1
condition|)
break|break;
block|}
block|}
block|}
if|if
condition|(
name|ct
operator|->
name|c_type
operator|==
name|CT_APPLICATION
operator|&&
operator|!
name|ct
operator|->
name|c_encoding
condition|)
name|ct
operator|->
name|c_encoding
operator|=
name|linelen
operator|==
operator|-
literal|1
operator|&&
name|charset
operator|!=
name|CHARSET_UNKNOWN
condition|?
name|CE_7BIT
else|:
name|CE_QUOTED
expr_stmt|;
if|if
condition|(
name|ct
operator|->
name|c_type
operator|==
name|CT_TEXT
operator|&&
operator|!
name|ct
operator|->
name|c_ctparams
condition|)
block|{
specifier|register
name|char
modifier|*
modifier|*
name|ap
decl_stmt|,
modifier|*
modifier|*
name|ep
decl_stmt|;
specifier|register
name|struct
name|text
modifier|*
name|t
decl_stmt|;
if|if
condition|(
name|charset
operator|==
name|CHARSET_UNKNOWN
operator|&&
name|mm_charset
condition|)
name|charset
operator|=
operator|-
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|charset
operator|==
operator|-
literal|1
condition|)
name|charset
operator|=
name|CHARSET_USASCII
expr_stmt|;
if|if
condition|(
operator|(
name|t
operator|=
operator|(
expr|struct
name|text
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
expr|*
name|t
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
name|ct
operator|->
name|c_ctparams
operator|=
operator|(
name|caddr_t
operator|)
name|t
expr_stmt|;
for|for
control|(
name|ap
operator|=
name|ci
operator|->
name|ci_attrs
operator|,
name|ep
operator|=
name|ci
operator|->
name|ci_values
init|;
operator|*
name|ap
condition|;
name|ap
operator|++
operator|,
name|ep
operator|++
control|)
continue|continue;
switch|switch
condition|(
name|t
operator|->
name|tx_charset
operator|=
name|charset
condition|)
block|{
case|case
name|CHARSET_USASCII
case|:
operator|*
name|ap
operator|=
name|add
argument_list|(
literal|"charset=us-ascii"
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
break|break;
case|case
name|CHARSET_UNKNOWN
case|:
default|default:
operator|*
name|ap
operator|=
name|add
argument_list|(
literal|"charset=x-unknown"
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
break|break;
case|case
operator|-
literal|2
case|:
operator|*
name|ap
operator|=
name|concat
argument_list|(
literal|"charset="
argument_list|,
name|mm_charset
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
break|break;
block|}
name|cp
operator|=
name|index
argument_list|(
operator|*
name|ap
operator|++
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
operator|*
name|ap
operator|=
name|NULL
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|ep
operator|=
name|cp
expr_stmt|;
block|}
if|if
condition|(
name|ct
operator|->
name|c_type
operator|==
name|CT_TEXT
operator|&&
name|ct
operator|->
name|c_subtype
operator|!=
name|TEXT_PLAIN
condition|)
name|ct
operator|->
name|c_encoding
operator|=
name|linelen
operator|==
operator|-
literal|1
condition|?
name|CE_7BIT
else|:
name|CE_QUOTED
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|in
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
block|}
return|return
name|OK
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|output_content
parameter_list|(
name|ct
parameter_list|,
name|out
parameter_list|)
specifier|register
name|CT
name|ct
decl_stmt|;
name|FILE
modifier|*
name|out
decl_stmt|;
block|{
name|int
name|cc
decl_stmt|,
name|mailbody
decl_stmt|,
name|len
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|ap
decl_stmt|,
modifier|*
modifier|*
name|ep
decl_stmt|;
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
specifier|register
name|CI
name|ci
init|=
operator|&
name|ct
operator|->
name|c_ctinfo
decl_stmt|;
if|if
condition|(
name|ct
operator|->
name|c_type
operator|==
name|CT_MULTIPART
condition|)
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|static
name|int
name|encl
init|=
literal|0
decl_stmt|;
name|ap
operator|=
name|ci
operator|->
name|ci_attrs
operator|,
name|ep
operator|=
name|ci
operator|->
name|ci_values
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"boundary=%s%d"
argument_list|,
name|prefix
argument_list|,
name|encl
operator|++
argument_list|)
expr_stmt|;
name|cp
operator|=
name|index
argument_list|(
operator|*
name|ap
operator|++
operator|=
name|add
argument_list|(
name|buffer
argument_list|,
name|NULLCP
argument_list|)
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
operator|*
name|ap
operator|=
name|NULL
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|ep
operator|=
name|cp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ct
operator|->
name|c_type
operator|==
name|CT_MESSAGE
operator|&&
name|ct
operator|->
name|c_rfc934
condition|)
goto|goto
name|rfc934_mode
goto|;
name|len
operator|=
literal|0
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"%s: %s/%s"
argument_list|,
name|TYPE_FIELD
argument_list|,
name|ci
operator|->
name|ci_type
argument_list|,
name|ci
operator|->
name|ci_subtype
argument_list|)
expr_stmt|;
name|len
operator|+=
name|strlen
argument_list|(
name|TYPE_FIELD
argument_list|)
operator|+
literal|2
operator|+
name|strlen
argument_list|(
name|ci
operator|->
name|ci_type
argument_list|)
operator|+
literal|1
operator|+
name|strlen
argument_list|(
name|ci
operator|->
name|ci_subtype
argument_list|)
expr_stmt|;
name|mailbody
operator|=
name|ct
operator|->
name|c_type
operator|==
name|CT_MESSAGE
operator|&&
name|ct
operator|->
name|c_subtype
operator|==
name|MESSAGE_EXTERNAL
operator|&&
operator|(
operator|(
expr|struct
name|exbody
operator|*
operator|)
name|ct
operator|->
name|c_ctparams
operator|)
operator|->
name|eb_body
expr_stmt|;
for|for
control|(
name|ap
operator|=
name|ci
operator|->
name|ci_attrs
operator|,
name|ep
operator|=
name|ci
operator|->
name|ci_values
init|;
operator|*
name|ap
condition|;
name|ap
operator|++
operator|,
name|ep
operator|++
control|)
block|{
if|if
condition|(
name|mailbody
operator|&&
name|uleq
argument_list|(
operator|*
name|ap
argument_list|,
literal|"body"
argument_list|)
condition|)
continue|continue;
operator|(
name|void
operator|)
name|putc
argument_list|(
literal|';'
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|len
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%s=\"%s\""
argument_list|,
operator|*
name|ap
argument_list|,
operator|*
name|ep
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|+
literal|1
operator|+
operator|(
name|cc
operator|=
name|strlen
argument_list|(
name|buffer
argument_list|)
operator|)
operator|>=
name|CPERLIN
condition|)
block|{
operator|(
name|void
operator|)
name|fputs
argument_list|(
literal|"\n\t"
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|len
operator|=
literal|8
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|putc
argument_list|(
literal|' '
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|len
operator|++
expr_stmt|;
block|}
name|fputs
argument_list|(
name|buffer
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|len
operator|+=
name|cc
expr_stmt|;
block|}
if|if
condition|(
name|ci
operator|->
name|ci_comment
condition|)
block|{
if|if
condition|(
name|len
operator|+
literal|1
operator|+
operator|(
name|cc
operator|=
literal|2
operator|+
name|strlen
argument_list|(
name|ci
operator|->
name|ci_comment
argument_list|)
operator|)
operator|>=
name|CPERLIN
condition|)
block|{
operator|(
name|void
operator|)
name|fputs
argument_list|(
literal|"\n\t"
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|len
operator|=
literal|8
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|putc
argument_list|(
literal|' '
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|len
operator|++
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"(%s)"
argument_list|,
name|ci
operator|->
name|ci_comment
argument_list|)
expr_stmt|;
name|len
operator|+=
name|cc
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|out
argument_list|)
expr_stmt|;
if|if
condition|(
name|ct
operator|->
name|c_id
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"%s: %s"
argument_list|,
name|ID_FIELD
argument_list|,
name|ct
operator|->
name|c_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|ct
operator|->
name|c_descr
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"%s: %s"
argument_list|,
name|DESCR_FIELD
argument_list|,
name|ct
operator|->
name|c_descr
argument_list|)
expr_stmt|;
name|rfc934_mode
label|:
empty_stmt|;
if|if
condition|(
name|ct
operator|->
name|c_ctextern
condition|)
return|return
name|OK
return|;
switch|switch
condition|(
name|ct
operator|->
name|c_type
condition|)
block|{
case|case
name|CT_MULTIPART
case|:
block|{
name|struct
name|multipart
modifier|*
name|m
init|=
operator|(
expr|struct
name|multipart
operator|*
operator|)
name|ct
operator|->
name|c_ctparams
decl_stmt|;
specifier|register
name|struct
name|part
modifier|*
name|part
decl_stmt|;
if|if
condition|(
name|ct
operator|->
name|c_rfc934
condition|)
operator|(
name|void
operator|)
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|out
argument_list|)
expr_stmt|;
for|for
control|(
name|part
operator|=
name|m
operator|->
name|mp_parts
init|;
name|part
condition|;
name|part
operator|=
name|part
operator|->
name|mp_next
control|)
block|{
specifier|register
name|CT
name|p
init|=
name|part
operator|->
name|mp_part
decl_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\n--%s\n"
argument_list|,
name|ci
operator|->
name|ci_values
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|c_type
operator|==
name|CT_MESSAGE
operator|&&
name|p
operator|->
name|c_subtype
operator|!=
name|MESSAGE_EXTERNAL
operator|&&
operator|!
name|p
operator|->
name|c_rfc934
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"%s: %s\n"
argument_list|,
name|VRSN_FIELD
argument_list|,
name|VRSN_VALUE
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|output_content
argument_list|(
name|p
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\n--%s--\n"
argument_list|,
name|ci
operator|->
name|ci_values
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CT_TEXT
case|:
if|if
condition|(
name|ct
operator|->
name|c_ctparams
operator|&&
operator|(
operator|(
expr|struct
name|text
operator|*
operator|)
name|ct
operator|->
name|c_ctparams
operator|)
operator|->
name|tx_charset
operator|!=
name|CHARSET_USASCII
condition|)
block|{
name|quoted_printable
label|:
empty_stmt|;
if|if
condition|(
name|checksw
condition|)
name|writeDigest
argument_list|(
name|ct
argument_list|,
name|out
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"%s: %s\n\n"
argument_list|,
name|ENCODING_FIELD
argument_list|,
literal|"quoted-printable"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|writeQuoted
argument_list|(
name|ct
argument_list|,
name|out
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|ct
operator|->
name|c_subtype
operator|!=
name|TEXT_PLAIN
operator|&&
name|ct
operator|->
name|c_encoding
operator|!=
name|CE_7BIT
operator|)
operator|||
name|checksw
condition|)
goto|goto
name|quoted_printable
goto|;
comment|/* else fall... */
case|case
name|CT_MESSAGE
case|:
name|seven_bit
label|:
empty_stmt|;
operator|(
name|void
operator|)
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|out
argument_list|)
expr_stmt|;
if|if
condition|(
name|ct
operator|->
name|c_type
operator|==
name|CT_MESSAGE
operator|&&
name|ct
operator|->
name|c_subtype
operator|==
name|MESSAGE_EXTERNAL
condition|)
block|{
specifier|register
name|struct
name|exbody
modifier|*
name|e
init|=
operator|(
expr|struct
name|exbody
operator|*
operator|)
name|ct
operator|->
name|c_ctparams
decl_stmt|;
operator|(
name|void
operator|)
name|output_content
argument_list|(
name|e
operator|->
name|eb_content
argument_list|,
name|out
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|eb_body
condition|)
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|out
argument_list|)
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|e
operator|->
name|eb_body
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
block|{
name|CT
name|ct2
init|=
name|e
operator|->
name|eb_content
decl_stmt|;
name|CI
name|ci2
init|=
operator|&
name|ct2
operator|->
name|c_ctinfo
decl_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\\'
condition|)
switch|switch
condition|(
operator|*
operator|++
name|cp
condition|)
block|{
case|case
literal|'I'
case|:
if|if
condition|(
name|ct2
operator|->
name|c_id
condition|)
block|{
name|char
modifier|*
name|dp
init|=
name|trimcpy
argument_list|(
name|ct2
operator|->
name|c_id
argument_list|)
decl_stmt|;
operator|(
name|void
operator|)
name|fputs
argument_list|(
name|dp
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dp
argument_list|)
expr_stmt|;
block|}
continue|continue;
case|case
literal|'N'
case|:
for|for
control|(
name|ap
operator|=
name|ci2
operator|->
name|ci_attrs
operator|,
name|ep
operator|=
name|ci2
operator|->
name|ci_values
init|;
operator|*
name|ap
condition|;
name|ap
operator|++
operator|,
name|ep
operator|++
control|)
if|if
condition|(
name|uleq
argument_list|(
operator|*
name|ap
argument_list|,
literal|"name"
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"%s"
argument_list|,
operator|*
name|ep
argument_list|)
expr_stmt|;
break|break;
block|}
continue|continue;
case|case
literal|'T'
case|:
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"%s/%s"
argument_list|,
name|ci2
operator|->
name|ci_type
argument_list|,
name|ci2
operator|->
name|ci_subtype
argument_list|)
expr_stmt|;
for|for
control|(
name|ap
operator|=
name|ci2
operator|->
name|ci_attrs
operator|,
name|ep
operator|=
name|ci2
operator|->
name|ci_values
init|;
operator|*
name|ap
condition|;
name|ap
operator|++
operator|,
name|ep
operator|++
control|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"; %s=\"%s\""
argument_list|,
operator|*
name|ap
argument_list|,
operator|*
name|ep
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'n'
case|:
operator|(
name|void
operator|)
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|out
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'t'
case|:
operator|(
name|void
operator|)
name|putc
argument_list|(
literal|'\t'
argument_list|,
name|out
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'\0'
case|:
name|cp
operator|--
expr_stmt|;
break|break;
case|case
literal|'\\'
case|:
case|case
literal|'"'
case|:
break|break;
default|default:
operator|(
name|void
operator|)
name|putc
argument_list|(
literal|'\\'
argument_list|,
name|out
argument_list|)
expr_stmt|;
break|break;
block|}
operator|(
name|void
operator|)
name|putc
argument_list|(
operator|*
name|cp
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
block|}
else|else
operator|(
name|void
operator|)
name|write7Bit
argument_list|(
name|ct
argument_list|,
name|out
argument_list|)
expr_stmt|;
break|break;
case|case
name|CT_APPLICATION
case|:
if|if
condition|(
name|ct
operator|->
name|c_subtype
operator|==
name|APPLICATION_POSTSCRIPT
condition|)
block|{
if|if
condition|(
name|ct
operator|->
name|c_encoding
operator|==
name|CE_7BIT
condition|)
goto|goto
name|seven_bit
goto|;
goto|goto
name|quoted_printable
goto|;
block|}
comment|/* else fall... */
default|default:
if|if
condition|(
name|checksw
condition|)
name|writeDigest
argument_list|(
name|ct
argument_list|,
name|out
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"%s: %s\n\n"
argument_list|,
name|ENCODING_FIELD
argument_list|,
literal|"base64"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|writeBase64
argument_list|(
name|ct
argument_list|,
name|out
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|OK
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|write7Bit
parameter_list|(
name|ct
parameter_list|,
name|out
parameter_list|)
specifier|register
name|CT
name|ct
decl_stmt|;
name|FILE
modifier|*
name|out
decl_stmt|;
block|{
name|char
name|c
decl_stmt|,
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|FILE
modifier|*
name|in
decl_stmt|;
if|if
condition|(
operator|(
name|in
operator|=
name|fopen
argument_list|(
name|ct
operator|->
name|c_file
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|adios
argument_list|(
name|ct
operator|->
name|c_file
argument_list|,
literal|"unable to open for reading"
argument_list|)
expr_stmt|;
name|c
operator|=
literal|'\n'
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
name|buffer
operator|-
literal|1
argument_list|,
name|in
argument_list|)
condition|)
block|{
name|c
operator|=
name|buffer
index|[
name|strlen
argument_list|(
name|buffer
argument_list|)
operator|-
literal|1
index|]
expr_stmt|;
operator|(
name|void
operator|)
name|fputs
argument_list|(
name|buffer
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|!=
literal|'\n'
condition|)
operator|(
name|void
operator|)
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|out
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|in
argument_list|)
expr_stmt|;
return|return
name|OK
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|writeQuoted
parameter_list|(
name|ct
parameter_list|,
name|out
parameter_list|)
specifier|register
name|CT
name|ct
decl_stmt|;
name|FILE
modifier|*
name|out
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|char
name|c
decl_stmt|,
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|FILE
modifier|*
name|in
decl_stmt|;
if|if
condition|(
operator|(
name|in
operator|=
name|fopen
argument_list|(
name|ct
operator|->
name|c_file
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|adios
argument_list|(
name|ct
operator|->
name|c_file
argument_list|,
literal|"unable to open for reading"
argument_list|)
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
name|buffer
operator|-
literal|1
argument_list|,
name|in
argument_list|)
condition|)
block|{
specifier|register
name|int
name|n
decl_stmt|;
name|cp
operator|=
name|buffer
operator|+
name|strlen
argument_list|(
name|buffer
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
operator|*
name|cp
operator|)
operator|==
literal|'\n'
condition|)
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|cp
operator|=
name|buffer
argument_list|,
literal|"From "
argument_list|,
sizeof|sizeof
expr|"From "
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"=%02X"
argument_list|,
operator|*
name|cp
operator|++
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|n
operator|=
literal|3
expr_stmt|;
block|}
else|else
name|n
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
block|{
if|if
condition|(
name|n
operator|>
name|CPERLIN
operator|-
literal|3
condition|)
block|{
operator|(
name|void
operator|)
name|fputs
argument_list|(
literal|"=\n"
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
block|}
switch|switch
condition|(
operator|*
name|cp
condition|)
block|{
case|case
literal|' '
case|:
case|case
literal|'\t'
case|:
operator|(
name|void
operator|)
name|putc
argument_list|(
operator|*
name|cp
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|n
operator|++
expr_stmt|;
break|break;
default|default:
if|if
condition|(
operator|*
name|cp
operator|<
literal|'!'
operator|||
operator|*
name|cp
operator|>
literal|'~'
operator|||
operator|(
name|ebcdicsw
operator|&&
operator|!
name|ebcdicsafe
index|[
operator|*
name|cp
operator|&
literal|0xff
index|]
operator|)
condition|)
goto|goto
name|three_print
goto|;
operator|(
name|void
operator|)
name|putc
argument_list|(
operator|*
name|cp
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|n
operator|++
expr_stmt|;
break|break;
case|case
literal|'='
case|:
name|three_print
label|:
empty_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"=%02X"
argument_list|,
operator|*
name|cp
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|n
operator|+=
literal|3
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
if|if
condition|(
name|cp
operator|>
name|buffer
operator|&&
operator|(
operator|*
operator|--
name|cp
operator|==
literal|' '
operator|||
operator|*
name|cp
operator|==
literal|'\t'
operator|)
condition|)
operator|(
name|void
operator|)
name|fputs
argument_list|(
literal|"=\n"
argument_list|,
name|out
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
else|else
operator|(
name|void
operator|)
name|fputs
argument_list|(
literal|"=\n"
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|in
argument_list|)
expr_stmt|;
return|return
name|OK
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_decl_stmt
specifier|static
name|char
name|nib2b64
index|[
literal|0x40
operator|+
literal|1
index|]
init|=
literal|"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|writeBase64
parameter_list|(
name|ct
parameter_list|,
name|out
parameter_list|)
specifier|register
name|CT
name|ct
decl_stmt|;
name|FILE
modifier|*
name|out
decl_stmt|;
block|{
name|int
name|result
decl_stmt|;
name|FILE
modifier|*
name|in
decl_stmt|;
if|if
condition|(
operator|(
name|in
operator|=
name|fopen
argument_list|(
name|ct
operator|->
name|c_file
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|adios
argument_list|(
name|ct
operator|->
name|c_file
argument_list|,
literal|"unable to open for reading"
argument_list|)
expr_stmt|;
name|result
operator|=
name|writeBase64aux
argument_list|(
name|in
argument_list|,
name|out
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|in
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|writeBase64aux
parameter_list|(
name|in
parameter_list|,
name|out
parameter_list|)
name|FILE
modifier|*
name|in
decl_stmt|,
decl|*
name|out
decl_stmt|;
end_function

begin_block
block|{
name|int
name|cc
decl_stmt|,
name|n
decl_stmt|;
name|char
name|inbuf
index|[
literal|3
index|]
decl_stmt|;
name|n
operator|=
name|BPERLIN
expr_stmt|;
while|while
condition|(
operator|(
name|cc
operator|=
name|fread
argument_list|(
name|inbuf
argument_list|,
sizeof|sizeof
expr|*
name|inbuf
argument_list|,
sizeof|sizeof
name|inbuf
argument_list|,
name|in
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|unsigned
name|long
name|bits
decl_stmt|;
specifier|register
name|char
modifier|*
name|bp
decl_stmt|;
name|char
name|outbuf
index|[
literal|4
index|]
decl_stmt|;
if|if
condition|(
name|cc
operator|<
sizeof|sizeof
name|inbuf
condition|)
block|{
name|inbuf
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cc
operator|<
sizeof|sizeof
name|inbuf
operator|-
literal|1
condition|)
name|inbuf
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|bits
operator|=
operator|(
name|inbuf
index|[
literal|0
index|]
operator|&
literal|0xff
operator|)
operator|<<
literal|16
expr_stmt|;
name|bits
operator||=
operator|(
name|inbuf
index|[
literal|1
index|]
operator|&
literal|0xff
operator|)
operator|<<
literal|8
expr_stmt|;
name|bits
operator||=
name|inbuf
index|[
literal|2
index|]
operator|&
literal|0xff
expr_stmt|;
for|for
control|(
name|bp
operator|=
name|outbuf
operator|+
sizeof|sizeof
name|outbuf
init|;
name|bp
operator|>
name|outbuf
condition|;
name|bits
operator|>>=
literal|6
control|)
operator|*
operator|--
name|bp
operator|=
name|nib2b64
index|[
name|bits
operator|&
literal|0x3f
index|]
expr_stmt|;
if|if
condition|(
name|cc
operator|<
sizeof|sizeof
name|inbuf
condition|)
block|{
name|outbuf
index|[
literal|3
index|]
operator|=
literal|'='
expr_stmt|;
if|if
condition|(
name|cc
operator|<
sizeof|sizeof
name|inbuf
operator|-
literal|1
condition|)
name|outbuf
index|[
literal|2
index|]
operator|=
literal|'='
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fwrite
argument_list|(
name|outbuf
argument_list|,
sizeof|sizeof
expr|*
name|outbuf
argument_list|,
sizeof|sizeof
name|outbuf
argument_list|,
name|out
argument_list|)
expr_stmt|;
if|if
condition|(
name|cc
operator|<
sizeof|sizeof
name|inbuf
condition|)
block|{
operator|(
name|void
operator|)
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|out
argument_list|)
expr_stmt|;
return|return
name|OK
return|;
block|}
if|if
condition|(
operator|--
name|n
operator|<=
literal|0
condition|)
block|{
name|n
operator|=
name|BPERLIN
expr_stmt|;
operator|(
name|void
operator|)
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|n
operator|!=
name|BPERLIN
condition|)
operator|(
name|void
operator|)
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|out
argument_list|)
expr_stmt|;
return|return
name|OK
return|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|writeDigest
parameter_list|(
name|ct
parameter_list|,
name|out
parameter_list|,
name|asciiP
parameter_list|)
specifier|register
name|CT
name|ct
decl_stmt|;
name|FILE
modifier|*
name|out
decl_stmt|;
name|int
name|asciiP
decl_stmt|;
block|{
name|int
name|cc
decl_stmt|;
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|dp
decl_stmt|;
name|unsigned
name|char
name|digest
index|[
literal|16
index|]
decl_stmt|;
name|FILE
modifier|*
name|in
decl_stmt|;
name|MD5_CTX
name|mdContext
decl_stmt|;
if|if
condition|(
operator|(
name|in
operator|=
name|fopen
argument_list|(
name|ct
operator|->
name|c_file
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|adios
argument_list|(
name|ct
operator|->
name|c_file
argument_list|,
literal|"unable to open for reading"
argument_list|)
expr_stmt|;
name|MD5Init
argument_list|(
operator|&
name|mdContext
argument_list|)
expr_stmt|;
if|if
condition|(
name|asciiP
condition|)
block|{
while|while
condition|(
name|fgets
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
name|buffer
operator|-
literal|1
argument_list|,
name|in
argument_list|)
condition|)
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|char
name|c
decl_stmt|;
name|cp
operator|=
name|buffer
operator|+
name|strlen
argument_list|(
name|buffer
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
operator|*
name|cp
operator|)
operator|==
literal|'\n'
condition|)
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
name|MD5Update
argument_list|(
operator|&
name|mdContext
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|buffer
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|strlen
argument_list|(
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
name|MD5Update
argument_list|(
operator|&
name|mdContext
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
literal|"\r\n"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
else|else
while|while
condition|(
operator|(
name|cc
operator|=
name|fread
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
expr|*
name|buffer
argument_list|,
sizeof|sizeof
name|buffer
argument_list|,
name|in
argument_list|)
operator|)
operator|>
literal|0
condition|)
name|MD5Update
argument_list|(
operator|&
name|mdContext
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|buffer
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|cc
argument_list|)
expr_stmt|;
name|MD5Final
argument_list|(
name|digest
argument_list|,
operator|&
name|mdContext
argument_list|)
expr_stmt|;
if|if
condition|(
name|debugsw
condition|)
block|{
name|unsigned
name|char
modifier|*
name|ep
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"MD5 digest="
argument_list|)
expr_stmt|;
for|for
control|(
name|ep
operator|=
operator|(
name|dp
operator|=
name|digest
operator|)
operator|+
sizeof|sizeof
name|digest
operator|/
sizeof|sizeof
name|digest
index|[
literal|0
index|]
init|;
name|dp
operator|<
name|ep
condition|;
name|dp
operator|++
control|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%02x"
argument_list|,
operator|*
name|dp
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"%s: "
argument_list|,
name|MD5_FIELD
argument_list|)
expr_stmt|;
for|for
control|(
name|dp
operator|=
name|digest
operator|,
name|cc
operator|=
sizeof|sizeof
name|digest
operator|/
sizeof|sizeof
name|digest
index|[
literal|0
index|]
init|;
name|cc
operator|>
literal|0
condition|;
name|cc
operator|-=
literal|3
control|)
block|{
name|unsigned
name|long
name|bits
decl_stmt|;
specifier|register
name|char
modifier|*
name|bp
decl_stmt|;
name|char
name|outbuf
index|[
literal|4
index|]
decl_stmt|;
name|bits
operator|=
operator|(
operator|*
name|dp
operator|++
operator|&
literal|0xff
operator|)
operator|<<
literal|16
expr_stmt|;
if|if
condition|(
name|cc
operator|>
literal|1
condition|)
block|{
name|bits
operator||=
operator|(
operator|*
name|dp
operator|++
operator|&
literal|0xff
operator|)
operator|<<
literal|8
expr_stmt|;
if|if
condition|(
name|cc
operator|>
literal|2
condition|)
name|bits
operator||=
operator|*
name|dp
operator|++
operator|&
literal|0xff
expr_stmt|;
block|}
for|for
control|(
name|bp
operator|=
name|outbuf
operator|+
sizeof|sizeof
name|outbuf
init|;
name|bp
operator|>
name|outbuf
condition|;
name|bits
operator|>>=
literal|6
control|)
operator|*
operator|--
name|bp
operator|=
name|nib2b64
index|[
name|bits
operator|&
literal|0x3f
index|]
expr_stmt|;
if|if
condition|(
name|cc
operator|<
literal|3
condition|)
block|{
name|outbuf
index|[
literal|3
index|]
operator|=
literal|'='
expr_stmt|;
if|if
condition|(
name|cc
operator|<
literal|2
condition|)
name|outbuf
index|[
literal|2
index|]
operator|=
literal|'='
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fwrite
argument_list|(
name|outbuf
argument_list|,
sizeof|sizeof
expr|*
name|outbuf
argument_list|,
sizeof|sizeof
name|outbuf
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|readDigest
parameter_list|(
name|ct
parameter_list|,
name|cp
parameter_list|)
specifier|register
name|CT
name|ct
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
block|{
name|int
name|bitno
decl_stmt|,
name|skip
decl_stmt|;
name|unsigned
name|long
name|bits
decl_stmt|;
name|char
modifier|*
name|bp
init|=
name|cp
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|dp
decl_stmt|;
name|unsigned
name|char
name|value
decl_stmt|,
modifier|*
name|ep
decl_stmt|,
modifier|*
name|b
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|bits
decl_stmt|,
modifier|*
name|b1
init|=
operator|&
name|b
index|[
name|endian
operator|>
literal|0
condition|?
literal|1
else|:
literal|2
index|]
decl_stmt|,
modifier|*
name|b2
init|=
operator|&
name|b
index|[
name|endian
operator|>
literal|0
condition|?
literal|2
else|:
literal|1
index|]
decl_stmt|,
modifier|*
name|b3
init|=
operator|&
name|b
index|[
name|endian
operator|>
literal|0
condition|?
literal|3
else|:
literal|0
index|]
decl_stmt|;
name|bitno
operator|=
literal|18
operator|,
name|bits
operator|=
literal|0L
operator|,
name|skip
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|ep
operator|=
operator|(
name|dp
operator|=
name|ct
operator|->
name|c_digest
operator|)
operator|+
sizeof|sizeof
name|ct
operator|->
name|c_digest
operator|/
sizeof|sizeof
name|ct
operator|->
name|c_digest
index|[
literal|0
index|]
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
switch|switch
condition|(
operator|*
name|cp
condition|)
block|{
default|default:
if|if
condition|(
name|skip
operator|||
operator|(
operator|*
name|cp
operator|&
literal|0x80
operator|)
operator|||
operator|(
name|value
operator|=
name|b642nib
index|[
operator|*
name|cp
operator|&
literal|0x7f
index|]
operator|)
operator|>
literal|0x3f
condition|)
block|{
if|if
condition|(
name|debugsw
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"invalid BASE64 encoding\n"
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
name|bits
operator||=
name|value
operator|<<
name|bitno
expr_stmt|;
name|test_end
label|:
empty_stmt|;
if|if
condition|(
operator|(
name|bitno
operator|-=
literal|6
operator|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|dp
operator|+
operator|(
literal|3
operator|-
name|skip
operator|)
operator|>
name|ep
condition|)
goto|goto
name|invalid_digest
goto|;
operator|*
name|dp
operator|++
operator|=
operator|*
name|b1
expr_stmt|;
if|if
condition|(
name|skip
operator|<
literal|2
condition|)
block|{
operator|*
name|dp
operator|++
operator|=
operator|*
name|b2
expr_stmt|;
if|if
condition|(
name|skip
operator|<
literal|1
condition|)
operator|*
name|dp
operator|++
operator|=
operator|*
name|b3
expr_stmt|;
block|}
name|bitno
operator|=
literal|18
operator|,
name|bits
operator|=
literal|0L
operator|,
name|skip
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
literal|'='
case|:
if|if
condition|(
operator|++
name|skip
operator|>
literal|3
condition|)
goto|goto
name|self_delimiting
goto|;
goto|goto
name|test_end
goto|;
block|}
if|if
condition|(
name|bitno
operator|!=
literal|18
condition|)
block|{
if|if
condition|(
name|debugsw
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"premature ending (bitno %d)\n"
argument_list|,
name|bitno
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
name|self_delimiting
label|:
empty_stmt|;
if|if
condition|(
name|dp
operator|!=
name|ep
condition|)
block|{
name|invalid_digest
label|:
empty_stmt|;
if|if
condition|(
name|debugsw
condition|)
block|{
while|while
condition|(
operator|*
name|cp
condition|)
name|cp
operator|++
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"invalid MD5 digest (got %d octets)\n"
argument_list|,
name|cp
operator|-
name|bp
argument_list|)
expr_stmt|;
block|}
return|return
name|NOTOK
return|;
block|}
if|if
condition|(
name|debugsw
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"MD5 digest="
argument_list|)
expr_stmt|;
for|for
control|(
name|dp
operator|=
name|ct
operator|->
name|c_digest
init|;
name|dp
operator|<
name|ep
condition|;
name|dp
operator|++
control|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%02x"
argument_list|,
operator|*
name|dp
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
return|return
name|OK
return|;
block|}
end_function

begin_comment
comment|/*
comment|VIAMAIL */
end_comment

begin_include
include|#
directive|include
file|"../zotnet/tws.h"
end_include

begin_function
specifier|static
name|int
name|via_mail
parameter_list|(
name|mailsw
parameter_list|,
name|subjsw
parameter_list|,
name|parmsw
parameter_list|,
name|descsw
parameter_list|,
name|cmntsw
parameter_list|,
name|slowsw
parameter_list|,
name|fromsw
parameter_list|)
name|char
modifier|*
name|mailsw
decl_stmt|,
decl|*
name|subjsw
decl_stmt|,
modifier|*
name|parmsw
decl_stmt|,
modifier|*
name|descsw
decl_stmt|,
modifier|*
name|cmntsw
decl_stmt|,
modifier|*
name|fromsw
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|slowsw
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|nlines
decl_stmt|,
name|nparts
decl_stmt|,
name|status
decl_stmt|;
name|long
name|pos
decl_stmt|;
name|long
name|offset
decl_stmt|;
name|char
name|tmpfil
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
operator|(
name|void
operator|)
name|umask
argument_list|(
operator|~
name|m_gmprot
argument_list|()
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|tmpfil
argument_list|,
name|m_tmpfil
argument_list|(
name|invo_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|tmpfil
argument_list|,
literal|"w+"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|adios
argument_list|(
name|tmpfil
argument_list|,
literal|"unable to open for writing"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|chmod
argument_list|(
name|tmpfil
argument_list|,
literal|0600
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|index
argument_list|(
name|mailsw
argument_list|,
literal|'@'
argument_list|)
condition|)
name|mailsw
operator|=
name|concat
argument_list|(
name|mailsw
argument_list|,
literal|"@"
argument_list|,
name|LocalName
argument_list|()
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"To: %s\n"
argument_list|,
name|mailsw
argument_list|)
expr_stmt|;
name|nlines
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|subjsw
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"Subject: %s\n"
argument_list|,
name|subjsw
argument_list|)
operator|,
name|nlines
operator|++
expr_stmt|;
if|if
condition|(
name|fromsw
condition|)
block|{
if|if
condition|(
operator|!
name|index
argument_list|(
name|fromsw
argument_list|,
literal|'@'
argument_list|)
condition|)
name|fromsw
operator|=
name|concat
argument_list|(
name|fromsw
argument_list|,
literal|"@"
argument_list|,
name|LocalName
argument_list|()
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"From: %s\n"
argument_list|,
name|fromsw
argument_list|)
operator|,
name|nlines
operator|++
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s: %s\n"
argument_list|,
name|VRSN_FIELD
argument_list|,
name|VRSN_VALUE
argument_list|)
operator|,
name|nlines
operator|++
expr_stmt|;
name|offset
operator|=
name|ftell
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s: application/octet-stream"
argument_list|,
name|TYPE_FIELD
argument_list|)
expr_stmt|;
if|if
condition|(
name|parmsw
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"; %s"
argument_list|,
name|parmsw
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmntsw
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\n\t(%s)"
argument_list|,
name|cmntsw
argument_list|)
operator|,
name|nlines
operator|++
expr_stmt|;
if|if
condition|(
name|descsw
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\n%s: %s"
argument_list|,
name|DESCR_FIELD
argument_list|,
name|descsw
argument_list|)
operator|,
name|nlines
operator|++
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\n%s: %s\n\n"
argument_list|,
name|ENCODING_FIELD
argument_list|,
literal|"base64"
argument_list|)
operator|,
name|nlines
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|fflush
argument_list|(
name|fp
argument_list|)
condition|)
name|adios
argument_list|(
name|tmpfil
argument_list|,
literal|"error writing to"
argument_list|)
expr_stmt|;
name|pos
operator|=
name|ftell
argument_list|(
name|fp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|writeBase64aux
argument_list|(
name|stdin
argument_list|,
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|fflush
argument_list|(
name|fp
argument_list|)
condition|)
name|adios
argument_list|(
name|tmpfil
argument_list|,
literal|"error writing to"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fstat
argument_list|(
name|fileno
argument_list|(
name|fp
argument_list|)
argument_list|,
operator|&
name|st
argument_list|)
operator|==
name|NOTOK
condition|)
name|adios
argument_list|(
literal|"failed"
argument_list|,
literal|"fstat of %s"
argument_list|,
name|tmpfil
argument_list|)
expr_stmt|;
name|nlines
operator|+=
operator|(
operator|(
operator|(
name|long
operator|)
name|st
operator|.
name|st_size
operator|-
name|pos
operator|)
operator|+
name|CPERLIN
operator|)
operator|/
operator|(
name|CPERLIN
operator|+
literal|1
operator|)
expr_stmt|;
name|nparts
operator|=
operator|(
name|nlines
operator|+
operator|(
name|LPERMSG
operator|-
literal|1
operator|)
operator|)
operator|/
name|LPERMSG
expr_stmt|;
if|if
condition|(
name|nparts
operator|<=
literal|1
condition|)
name|status
operator|=
name|via_post
argument_list|(
name|tmpfil
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|partno
decl_stmt|;
name|long
name|clock
decl_stmt|;
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|,
name|msgid
index|[
name|BUFSIZ
index|]
decl_stmt|;
if|if
condition|(
name|verbosw
condition|)
block|{
name|printf
argument_list|(
literal|"sending binary image as %d partial messages\n"
argument_list|,
name|nparts
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|time
argument_list|(
operator|&
name|clock
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|msgid
argument_list|,
literal|"<%d.%ld@%s>"
argument_list|,
name|getpid
argument_list|()
argument_list|,
name|clock
argument_list|,
name|LocalName
argument_list|()
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fseek
argument_list|(
name|fp
argument_list|,
name|offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|partno
operator|=
literal|1
init|;
name|partno
operator|<=
name|nparts
condition|;
name|partno
operator|++
control|)
block|{
name|int
name|lineno
decl_stmt|;
name|char
name|tmpdrf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|FILE
modifier|*
name|out
decl_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|tmpdrf
argument_list|,
name|m_tmpfil
argument_list|(
name|invo_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|out
operator|=
name|fopen
argument_list|(
name|tmpdrf
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|adios
argument_list|(
name|tmpdrf
argument_list|,
literal|"unable to open for writing"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|chmod
argument_list|(
name|tmpdrf
argument_list|,
literal|0600
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"To: %s\n"
argument_list|,
name|mailsw
argument_list|)
expr_stmt|;
if|if
condition|(
name|subjsw
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"Subject: %s\n"
argument_list|,
name|subjsw
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"%s: %s\n"
argument_list|,
name|VRSN_FIELD
argument_list|,
name|VRSN_VALUE
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"%s: message/partial; id=\"%s\";\n\tnumber=%d; total=%d\n"
argument_list|,
name|TYPE_FIELD
argument_list|,
name|msgid
argument_list|,
name|partno
argument_list|,
name|nparts
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"%s: part %d of %d\n\n"
argument_list|,
name|DESCR_FIELD
argument_list|,
name|partno
argument_list|,
name|nparts
argument_list|)
expr_stmt|;
if|if
condition|(
name|partno
operator|==
literal|1
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"Message-ID: %s\n"
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
for|for
control|(
name|lineno
operator|=
name|LPERMSG
init|;
name|lineno
operator|>
literal|0
condition|;
name|lineno
operator|--
control|)
block|{
if|if
condition|(
operator|!
name|fgets
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
name|buffer
argument_list|,
name|fp
argument_list|)
condition|)
block|{
if|if
condition|(
name|partno
operator|==
name|nparts
condition|)
break|break;
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"premature eof"
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fputs
argument_list|(
name|buffer
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
name|offset
operator|=
name|ftell
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|fflush
argument_list|(
name|out
argument_list|)
condition|)
name|adios
argument_list|(
name|tmpdrf
argument_list|,
literal|"error writing to"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|status
operator|=
name|via_post
argument_list|(
name|tmpdrf
argument_list|,
name|slowsw
operator|==
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|tmpdrf
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
break|break;
if|if
condition|(
name|slowsw
operator|>
literal|0
operator|&&
name|partno
operator|<
name|nparts
condition|)
block|{
if|if
condition|(
name|verbosw
condition|)
block|{
name|printf
argument_list|(
literal|"pausing %d seconds before sending part %d...\n"
argument_list|,
name|slowsw
argument_list|,
name|partno
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
name|sleep
argument_list|(
operator|(
name|unsigned
operator|)
name|slowsw
argument_list|)
expr_stmt|;
block|}
block|}
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|tmpfil
argument_list|)
expr_stmt|;
name|done
argument_list|(
name|status
condition|?
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|via_post
parameter_list|(
name|file
parameter_list|,
name|queued
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
name|int
name|queued
decl_stmt|;
block|{
name|int
name|child_id
decl_stmt|,
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|child_id
operator|=
name|fork
argument_list|()
operator|)
operator|==
name|NOTOK
operator|&&
name|i
operator|<
literal|5
condition|;
name|i
operator|++
control|)
name|sleep
argument_list|(
literal|5
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|child_id
condition|)
block|{
case|case
name|NOTOK
case|:
name|adios
argument_list|(
literal|"fork"
argument_list|,
literal|"unable to"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
case|case
name|OK
case|:
operator|(
name|void
operator|)
name|execlp
argument_list|(
name|postproc
argument_list|,
name|r1bindex
argument_list|(
name|postproc
argument_list|,
literal|'/'
argument_list|)
argument_list|,
name|file
argument_list|,
name|queued
condition|?
literal|"-queued"
else|:
name|NULLCP
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"unable to exec "
argument_list|)
expr_stmt|;
name|perror
argument_list|(
name|postproc
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
default|default:
return|return
name|pidXwait
argument_list|(
name|child_id
argument_list|,
name|postproc
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
name|void
name|done
parameter_list|(
name|status
parameter_list|)
name|int
name|status
decl_stmt|;
block|{
specifier|register
name|CT
modifier|*
name|ctp
decl_stmt|;
if|if
condition|(
name|ctp
operator|=
name|cts
condition|)
for|for
control|(
init|;
operator|*
name|ctp
condition|;
name|ctp
operator|++
control|)
name|free_content
argument_list|(
operator|*
name|ctp
argument_list|)
expr_stmt|;
if|if
condition|(
name|free_ct
condition|)
name|free_content
argument_list|(
name|free_ct
argument_list|)
expr_stmt|;
if|if
condition|(
name|free_file
condition|)
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|free_file
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|pidcheck
parameter_list|(
name|status
parameter_list|)
name|int
name|status
decl_stmt|;
block|{
if|if
condition|(
operator|(
name|status
operator|&
literal|0xff00
operator|)
operator|==
literal|0xff00
operator|||
operator|(
name|status
operator|&
literal|0x007f
operator|)
operator|!=
name|SIGQUIT
condition|)
return|return
name|status
return|;
operator|(
name|void
operator|)
name|unlink
argument_list|(
literal|"core"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_function

end_unit

