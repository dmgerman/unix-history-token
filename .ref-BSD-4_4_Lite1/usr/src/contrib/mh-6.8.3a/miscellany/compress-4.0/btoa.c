begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* btoa: version 4.0  * stream filter to change 8 bit bytes into printable ascii  * computes the number of bytes, and three kinds of simple checksums  * incoming bytes are collected into 32-bit words, then printed in base 85  *  exp(85,5)> exp(2,32)  * the ASCII characters used are between '!' and 'u'  * 'z' encodes 32-bit zero; 'x' is used to mark the end of encoded data.  *  *  Paul Rutter		Joe Orost  *  philabs!per		petsd!joe  *  *  WARNING: this version is not compatible with the original as sent out  *  on the net.  The original encoded from ' ' to 't'; which cause problems  *  with some mailers (stripping off trailing blanks).  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_define
define|#
directive|define
name|reg
value|register
end_define

begin_define
define|#
directive|define
name|MAXPERLINE
value|78
end_define

begin_decl_stmt
name|long
name|int
name|Ceor
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|int
name|Csum
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|int
name|Crot
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|int
name|ccount
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|int
name|bcount
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|int
name|word
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|EN
parameter_list|(
name|c
parameter_list|)
value|(int) ((c) + '!')
end_define

begin_macro
name|encode
argument_list|(
argument|c
argument_list|)
end_macro

begin_decl_stmt
name|reg
name|c
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|Ceor
operator|^=
name|c
expr_stmt|;
name|Csum
operator|+=
name|c
expr_stmt|;
name|Csum
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|Crot
operator|&
literal|0x80000000
operator|)
condition|)
block|{
name|Crot
operator|<<=
literal|1
expr_stmt|;
name|Crot
operator|+=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|Crot
operator|<<=
literal|1
expr_stmt|;
block|}
name|Crot
operator|+=
name|c
expr_stmt|;
name|word
operator|<<=
literal|8
expr_stmt|;
name|word
operator||=
name|c
expr_stmt|;
if|if
condition|(
name|bcount
operator|==
literal|3
condition|)
block|{
name|wordout
argument_list|(
name|word
argument_list|)
expr_stmt|;
name|bcount
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|bcount
operator|+=
literal|1
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|wordout
argument_list|(
argument|word
argument_list|)
end_macro

begin_decl_stmt
name|reg
name|long
name|int
name|word
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|word
operator|==
literal|0
condition|)
block|{
name|charout
argument_list|(
literal|'z'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|reg
name|int
name|tmp
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|word
operator|<
literal|0
condition|)
block|{
comment|/* Because some don't support unsigned long */
name|tmp
operator|=
literal|32
expr_stmt|;
name|word
operator|=
name|word
operator|-
call|(
name|long
call|)
argument_list|(
literal|85
operator|*
literal|85
operator|*
literal|85
operator|*
literal|85
operator|*
literal|32
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|word
operator|<
literal|0
condition|)
block|{
name|tmp
operator|=
literal|64
expr_stmt|;
name|word
operator|=
name|word
operator|-
call|(
name|long
call|)
argument_list|(
literal|85
operator|*
literal|85
operator|*
literal|85
operator|*
literal|85
operator|*
literal|32
argument_list|)
expr_stmt|;
block|}
name|charout
argument_list|(
name|EN
argument_list|(
operator|(
name|word
operator|/
call|(
name|long
call|)
argument_list|(
literal|85
operator|*
literal|85
operator|*
literal|85
operator|*
literal|85
argument_list|)
operator|)
operator|+
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
name|word
operator|%=
call|(
name|long
call|)
argument_list|(
literal|85
operator|*
literal|85
operator|*
literal|85
operator|*
literal|85
argument_list|)
expr_stmt|;
name|charout
argument_list|(
name|EN
argument_list|(
name|word
operator|/
operator|(
literal|85
operator|*
literal|85
operator|*
literal|85
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|word
operator|%=
operator|(
literal|85
operator|*
literal|85
operator|*
literal|85
operator|)
expr_stmt|;
name|charout
argument_list|(
name|EN
argument_list|(
name|word
operator|/
operator|(
literal|85
operator|*
literal|85
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|word
operator|%=
operator|(
literal|85
operator|*
literal|85
operator|)
expr_stmt|;
name|charout
argument_list|(
name|EN
argument_list|(
name|word
operator|/
literal|85
argument_list|)
argument_list|)
expr_stmt|;
name|word
operator|%=
literal|85
expr_stmt|;
name|charout
argument_list|(
name|EN
argument_list|(
name|word
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|charout
argument_list|(
argument|c
argument_list|)
end_macro

begin_block
block|{
name|putchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|ccount
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|ccount
operator|==
name|MAXPERLINE
condition|)
block|{
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|ccount
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_block

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|reg
name|c
decl_stmt|;
name|reg
name|long
name|int
name|n
decl_stmt|;
if|if
condition|(
name|argc
operator|!=
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"bad args to %s\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"xbtoa Begin\n"
argument_list|)
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getchar
argument_list|()
operator|)
operator|!=
name|EOF
condition|)
block|{
name|encode
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|n
operator|+=
literal|1
expr_stmt|;
block|}
while|while
condition|(
name|bcount
operator|!=
literal|0
condition|)
block|{
name|encode
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* n is written twice as crude cross check*/
name|printf
argument_list|(
literal|"\nxbtoa End N %ld %lx E %lx S %lx R %lx\n"
argument_list|,
name|n
argument_list|,
name|n
argument_list|,
name|Ceor
argument_list|,
name|Csum
argument_list|,
name|Crot
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

