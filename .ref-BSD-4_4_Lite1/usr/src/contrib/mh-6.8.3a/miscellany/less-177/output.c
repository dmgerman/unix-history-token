begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * High level routines dealing with the output to the screen.  */
end_comment

begin_include
include|#
directive|include
file|"less.h"
end_include

begin_decl_stmt
name|public
name|int
name|errmsgs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Count of messages displayed by error() */
end_comment

begin_decl_stmt
name|public
name|int
name|need_clr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|sigs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|sc_width
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|so_s_width
decl_stmt|,
name|so_e_width
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|screen_trashed
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|any_display
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|__MSDOS__
end_if

begin_decl_stmt
specifier|extern
name|int
name|output_mode
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Display the line which is in the line buffer.  */
end_comment

begin_function
name|public
name|void
name|put_line
parameter_list|()
block|{
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|a
decl_stmt|;
name|int
name|curr_attr
decl_stmt|;
if|if
condition|(
name|sigs
condition|)
block|{
comment|/* 		 * Don't output if a signal is pending. 		 */
name|screen_trashed
operator|=
literal|1
expr_stmt|;
return|return;
block|}
name|curr_attr
operator|=
name|NORMAL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|c
operator|=
name|gline
argument_list|(
name|i
argument_list|,
operator|&
name|a
argument_list|)
operator|)
operator|!=
literal|'\0'
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|a
operator|!=
name|curr_attr
condition|)
block|{
comment|/* 			 * Changing attributes. 			 * Display the exit sequence for the old attribute 			 * and the enter sequence for the new one. 			 */
switch|switch
condition|(
name|curr_attr
condition|)
block|{
case|case
name|UNDERLINE
case|:
name|ul_exit
argument_list|()
expr_stmt|;
break|break;
case|case
name|BOLD
case|:
name|bo_exit
argument_list|()
expr_stmt|;
break|break;
case|case
name|BLINK
case|:
name|bl_exit
argument_list|()
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|a
condition|)
block|{
case|case
name|UNDERLINE
case|:
name|ul_enter
argument_list|()
expr_stmt|;
break|break;
case|case
name|BOLD
case|:
name|bo_enter
argument_list|()
expr_stmt|;
break|break;
case|case
name|BLINK
case|:
name|bl_enter
argument_list|()
expr_stmt|;
break|break;
block|}
name|curr_attr
operator|=
name|a
expr_stmt|;
block|}
if|if
condition|(
name|curr_attr
operator|==
name|INVIS
condition|)
continue|continue;
if|if
condition|(
name|c
operator|==
literal|'\b'
condition|)
name|putbs
argument_list|()
expr_stmt|;
else|else
name|putchr
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
specifier|static
name|char
name|obuf
index|[
literal|1024
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|ob
init|=
name|obuf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Flush buffered output.  *  * If we haven't displayed any file data yet,  * output messages on error output (file descriptor 2),  * otherwise output on standard output (file descriptor 1).  *  * This has the desirable effect of producing all  * error messages on error output if standard output  * is directed to a file.  It also does the same if  * we never produce any real output; for example, if  * the input file(s) cannot be opened.  If we do  * eventually produce output, code in edit() makes  * sure these messages can be seen before they are  * overwritten or scrolled away.  */
end_comment

begin_function
name|public
name|void
name|flush
parameter_list|()
block|{
specifier|register
name|int
name|n
decl_stmt|;
specifier|register
name|int
name|fd
decl_stmt|;
if|#
directive|if
name|__MSDOS__
if|if
condition|(
name|output_mode
operator|==
literal|0
condition|)
block|{
operator|*
name|ob
operator|=
literal|'\0'
expr_stmt|;
name|cputs
argument_list|(
name|obuf
argument_list|)
expr_stmt|;
name|ob
operator|=
name|obuf
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|n
operator|=
name|ob
operator|-
name|obuf
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
return|return;
name|fd
operator|=
operator|(
name|any_display
operator|)
condition|?
literal|1
else|:
literal|2
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|fd
argument_list|,
name|obuf
argument_list|,
name|n
argument_list|)
operator|!=
name|n
condition|)
name|screen_trashed
operator|=
literal|1
expr_stmt|;
name|ob
operator|=
name|obuf
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Output a character.  */
end_comment

begin_function
name|public
name|void
name|putchr
parameter_list|(
name|c
parameter_list|)
name|int
name|c
decl_stmt|;
block|{
if|if
condition|(
name|ob
operator|>=
operator|&
name|obuf
index|[
sizeof|sizeof
argument_list|(
name|obuf
argument_list|)
index|]
condition|)
name|flush
argument_list|()
expr_stmt|;
if|if
condition|(
name|need_clr
condition|)
block|{
name|need_clr
operator|=
literal|0
expr_stmt|;
name|lower_left
argument_list|()
expr_stmt|;
name|clear_eol
argument_list|()
expr_stmt|;
block|}
if|#
directive|if
name|__MSDOS__
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
operator|*
name|ob
operator|++
operator|=
literal|'\r'
expr_stmt|;
endif|#
directive|endif
operator|*
name|ob
operator|++
operator|=
name|c
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Output a string.  */
end_comment

begin_function
name|public
name|void
name|putstr
parameter_list|(
name|s
parameter_list|)
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
block|{
while|while
condition|(
operator|*
name|s
operator|!=
literal|'\0'
condition|)
name|putchr
argument_list|(
operator|*
name|s
operator|++
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Output an integer in a given radix.  */
end_comment

begin_function
specifier|static
name|int
name|iprintnum
parameter_list|(
name|num
parameter_list|,
name|radix
parameter_list|)
name|int
name|num
decl_stmt|;
name|int
name|radix
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|r
decl_stmt|;
name|int
name|neg
decl_stmt|;
name|char
name|buf
index|[
literal|10
index|]
decl_stmt|;
if|if
condition|(
name|neg
operator|=
operator|(
name|num
operator|<
literal|0
operator|)
condition|)
name|num
operator|=
operator|-
name|num
expr_stmt|;
name|s
operator|=
name|buf
expr_stmt|;
do|do
block|{
operator|*
name|s
operator|++
operator|=
operator|(
name|num
operator|%
name|radix
operator|)
operator|+
literal|'0'
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|num
operator|/=
name|radix
operator|)
operator|!=
literal|0
condition|)
do|;
if|if
condition|(
name|neg
condition|)
operator|*
name|s
operator|++
operator|=
literal|'-'
expr_stmt|;
name|r
operator|=
name|s
operator|-
name|buf
expr_stmt|;
while|while
condition|(
name|s
operator|>
name|buf
condition|)
name|putchr
argument_list|(
operator|*
operator|--
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This function implements printf-like functionality  * using a more portable argument list mechanism than printf's.  */
end_comment

begin_function
specifier|static
name|int
name|iprintf
parameter_list|(
name|fmt
parameter_list|,
name|parg
parameter_list|)
specifier|register
name|char
modifier|*
name|fmt
decl_stmt|;
name|PARG
modifier|*
name|parg
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
specifier|register
name|int
name|col
decl_stmt|;
name|col
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|fmt
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|*
name|fmt
operator|!=
literal|'%'
condition|)
block|{
name|putchr
argument_list|(
operator|*
name|fmt
operator|++
argument_list|)
expr_stmt|;
name|col
operator|++
expr_stmt|;
block|}
else|else
block|{
operator|++
name|fmt
expr_stmt|;
switch|switch
condition|(
operator|*
name|fmt
operator|++
condition|)
block|{
case|case
literal|'s'
case|:
name|s
operator|=
name|parg
operator|->
name|p_string
expr_stmt|;
name|parg
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|s
operator|!=
literal|'\0'
condition|)
block|{
name|putchr
argument_list|(
operator|*
name|s
operator|++
argument_list|)
expr_stmt|;
name|col
operator|++
expr_stmt|;
block|}
break|break;
case|case
literal|'d'
case|:
name|n
operator|=
name|parg
operator|->
name|p_int
expr_stmt|;
name|parg
operator|++
expr_stmt|;
name|col
operator|+=
name|iprintnum
argument_list|(
name|n
argument_list|,
literal|10
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
return|return
operator|(
name|col
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Output a message in the lower left corner of the screen  * and wait for carriage return.  */
end_comment

begin_function
name|public
name|void
name|error
parameter_list|(
name|fmt
parameter_list|,
name|parg
parameter_list|)
name|char
modifier|*
name|fmt
decl_stmt|;
name|PARG
modifier|*
name|parg
decl_stmt|;
block|{
name|int
name|c
decl_stmt|;
name|int
name|col
init|=
literal|0
decl_stmt|;
specifier|static
name|char
name|return_to_continue
index|[]
init|=
literal|"  (press RETURN)"
decl_stmt|;
name|errmsgs
operator|++
expr_stmt|;
if|if
condition|(
name|any_display
condition|)
block|{
name|lower_left
argument_list|()
expr_stmt|;
name|clear_eol
argument_list|()
expr_stmt|;
name|so_enter
argument_list|()
expr_stmt|;
name|col
operator|+=
name|so_s_width
expr_stmt|;
block|}
name|col
operator|+=
name|iprintf
argument_list|(
name|fmt
argument_list|,
name|parg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|any_display
condition|)
block|{
name|putchr
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
return|return;
block|}
name|putstr
argument_list|(
name|return_to_continue
argument_list|)
expr_stmt|;
name|so_exit
argument_list|()
expr_stmt|;
name|col
operator|+=
sizeof|sizeof
argument_list|(
name|return_to_continue
argument_list|)
operator|+
name|so_e_width
expr_stmt|;
if|#
directive|if
name|ONLY_RETURN
while|while
condition|(
operator|(
name|c
operator|=
name|getchr
argument_list|()
operator|)
operator|!=
literal|'\n'
operator|&&
name|c
operator|!=
literal|'\r'
condition|)
name|bell
argument_list|()
expr_stmt|;
else|#
directive|else
name|c
operator|=
name|getchr
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'\n'
operator|&&
name|c
operator|!=
literal|'\r'
operator|&&
name|c
operator|!=
literal|' '
operator|&&
name|c
operator|!=
name|READ_INTR
condition|)
name|ungetcc
argument_list|(
name|c
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|lower_left
argument_list|()
expr_stmt|;
if|if
condition|(
name|col
operator|>=
name|sc_width
condition|)
comment|/* 		 * Printing the message has probably scrolled the screen. 		 * {{ Unless the terminal doesn't have auto margins, 		 *    in which case we just hammered on the right margin. }} 		 */
name|screen_trashed
operator|=
literal|1
expr_stmt|;
name|flush
argument_list|()
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|char
name|intr_to_abort
index|[]
init|=
literal|"... (interrupt to abort)"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Output a message in the lower left corner of the screen  * and don't wait for carriage return.  * Usually used to warn that we are beginning a potentially  * time-consuming operation.  */
end_comment

begin_function
name|public
name|void
name|ierror
parameter_list|(
name|fmt
parameter_list|,
name|parg
parameter_list|)
name|char
modifier|*
name|fmt
decl_stmt|;
name|PARG
modifier|*
name|parg
decl_stmt|;
block|{
name|lower_left
argument_list|()
expr_stmt|;
name|clear_eol
argument_list|()
expr_stmt|;
name|so_enter
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|iprintf
argument_list|(
name|fmt
argument_list|,
name|parg
argument_list|)
expr_stmt|;
name|putstr
argument_list|(
name|intr_to_abort
argument_list|)
expr_stmt|;
name|so_exit
argument_list|()
expr_stmt|;
name|flush
argument_list|()
expr_stmt|;
name|need_clr
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Output a message in the lower left corner of the screen  * and return a single-character response.  */
end_comment

begin_function
name|public
name|int
name|query
parameter_list|(
name|fmt
parameter_list|,
name|parg
parameter_list|)
name|char
modifier|*
name|fmt
decl_stmt|;
name|PARG
modifier|*
name|parg
decl_stmt|;
block|{
specifier|register
name|int
name|c
decl_stmt|;
name|int
name|col
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|any_display
condition|)
block|{
name|lower_left
argument_list|()
expr_stmt|;
name|clear_eol
argument_list|()
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|iprintf
argument_list|(
name|fmt
argument_list|,
name|parg
argument_list|)
expr_stmt|;
name|c
operator|=
name|getchr
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|any_display
condition|)
block|{
name|putchr
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
return|return
operator|(
name|c
operator|)
return|;
block|}
name|lower_left
argument_list|()
expr_stmt|;
if|if
condition|(
name|col
operator|>=
name|sc_width
condition|)
name|screen_trashed
operator|=
literal|1
expr_stmt|;
name|flush
argument_list|()
expr_stmt|;
return|return
operator|(
name|c
operator|)
return|;
block|}
end_function

end_unit

