begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Routines to execute other programs.  * Necessarily very OS dependent.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|"less.h"
end_include

begin_include
include|#
directive|include
file|"position.h"
end_include

begin_if
if|#
directive|if
name|__MSDOS__
end_if

begin_include
include|#
directive|include
file|<process.h>
end_include

begin_include
include|#
directive|include
file|<dos.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<io.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<dir.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_function_decl
name|char
name|get_swchar
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|swchar_to_dos
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|swchar_to_unix
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|extern
name|char
modifier|*
name|getenv
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|int
name|screen_trashed
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|IFILE
name|curr_ifile
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Pass the specified command to a shell to be executed.  * Like plain "system()", but handles resetting terminal modes, etc.  */
end_comment

begin_function
name|public
name|void
name|lsystem
parameter_list|(
name|cmd
parameter_list|)
name|char
modifier|*
name|cmd
decl_stmt|;
block|{
specifier|register
name|int
name|inp
decl_stmt|;
specifier|register
name|char
modifier|*
name|shell
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|char
modifier|*
name|curr_filename
decl_stmt|;
comment|/* 	 * Print the command which is to be executed, 	 * unless the command starts with a "-". 	 */
if|if
condition|(
name|cmd
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
name|cmd
operator|++
expr_stmt|;
else|else
block|{
name|lower_left
argument_list|()
expr_stmt|;
name|clear_eol
argument_list|()
expr_stmt|;
name|putstr
argument_list|(
literal|"!"
argument_list|)
expr_stmt|;
name|putstr
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|putstr
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Close the current input file. 	 */
name|curr_filename
operator|=
name|get_filename
argument_list|(
name|curr_ifile
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|edit
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * De-initialize the terminal and take out of raw mode. 	 */
name|deinit
argument_list|()
expr_stmt|;
name|flush
argument_list|()
expr_stmt|;
comment|/* Make sure the deinit chars get out */
name|raw_mode
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Restore signals to their defaults. 	 */
name|init_signals
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Force standard input to be the user's terminal 	 * (the normal standard input), even if less's standard input  	 * is coming from a pipe. 	 */
if|#
directive|if
name|__MSDOS__
block|{
specifier|register
name|int
name|inp2
decl_stmt|;
name|inp
operator|=
name|dup
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|inp2
operator|=
name|open
argument_list|(
literal|"CON"
argument_list|,
name|O_TEXT
operator||
name|O_RDONLY
argument_list|)
expr_stmt|;
name|dup2
argument_list|(
literal|0
argument_list|,
name|inp2
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|inp
operator|=
name|dup
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|close
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|open
argument_list|(
literal|"/dev/tty"
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
name|dup
argument_list|(
name|inp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Pass the command to the system to be executed. 	 * If we have a SHELL environment variable, use 	 *<$SHELL -c "command"> instead of just<command>. 	 * If the command is empty, just invoke a shell. 	 */
if|#
directive|if
name|__MSDOS__
block|{
name|int
name|result
decl_stmt|;
name|char
name|sw_char
decl_stmt|;
name|sw_char
operator|=
name|get_swchar
argument_list|()
expr_stmt|;
name|swchar_to_dos
argument_list|()
expr_stmt|;
name|result
operator|=
name|system
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
literal|0
condition|)
name|perror
argument_list|(
literal|"less"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sw_char
operator|==
literal|'-'
condition|)
name|swchar_to_unix
argument_list|()
expr_stmt|;
block|}
else|#
directive|else
name|p
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|shell
operator|=
name|getenv
argument_list|(
literal|"SHELL"
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
operator|*
name|shell
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|*
name|cmd
operator|==
literal|'\0'
condition|)
name|p
operator|=
name|save
argument_list|(
name|shell
argument_list|)
expr_stmt|;
else|else
block|{
name|p
operator|=
operator|(
name|char
operator|*
operator|)
name|ecalloc
argument_list|(
name|strlen
argument_list|(
name|shell
argument_list|)
operator|+
name|strlen
argument_list|(
name|cmd
argument_list|)
operator|+
literal|7
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|p
argument_list|,
literal|"%s -c \"%s\""
argument_list|,
name|shell
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|*
name|cmd
operator|==
literal|'\0'
condition|)
name|p
operator|=
name|save
argument_list|(
literal|"sh"
argument_list|)
expr_stmt|;
else|else
name|p
operator|=
name|save
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
block|}
name|system
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Restore standard input, reset signals, raw mode, etc. 	 */
if|#
directive|if
name|__MSDOS__
name|close
argument_list|(
name|inp2
argument_list|)
expr_stmt|;
name|dup2
argument_list|(
literal|0
argument_list|,
name|inp
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|inp
argument_list|)
expr_stmt|;
else|#
directive|else
name|close
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|dup
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|inp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|init_signals
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|raw_mode
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|init
argument_list|()
expr_stmt|;
name|screen_trashed
operator|=
literal|1
expr_stmt|;
comment|/* 	 * Reopen the current input file. 	 */
operator|(
name|void
operator|)
name|edit
argument_list|(
name|curr_filename
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|SIGWINCH
argument_list|)
operator|||
name|defined
argument_list|(
name|SIGWIND
argument_list|)
comment|/* 	 * Since we were ignoring window change signals while we executed 	 * the system command, we must assume the window changed. 	 * Warning: this leaves a signal pending (in "sigs"), 	 * so psignals() should be called soon after lsystem(). 	 */
name|winch
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_if
if|#
directive|if
name|PIPEC
end_if

begin_comment
comment|/*  * Pipe a section of the input file into the given shell command.  * The section to be piped is the section "between" the current  * position and the position marked by the given letter.  *  * The "current" position means the top line displayed if the mark  * is after the current screen, or the bottom line displayed if  * the mark is before the current screen.  * If the mark is on the current screen, the whole screen is displayed.  */
end_comment

begin_function
name|public
name|int
name|pipe_mark
parameter_list|(
name|c
parameter_list|,
name|cmd
parameter_list|)
name|int
name|c
decl_stmt|;
name|char
modifier|*
name|cmd
decl_stmt|;
block|{
name|POSITION
name|mpos
decl_stmt|,
name|tpos
decl_stmt|,
name|bpos
decl_stmt|;
comment|/* 	 * mpos = the marked position. 	 * tpos = top of screen. 	 * bpos = bottom of screen. 	 */
name|mpos
operator|=
name|markpos
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|mpos
operator|==
name|NULL_POSITION
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|tpos
operator|=
name|position
argument_list|(
name|TOP
argument_list|)
expr_stmt|;
if|if
condition|(
name|tpos
operator|==
name|NULL_POSITION
condition|)
name|tpos
operator|=
name|ch_zero
argument_list|()
expr_stmt|;
name|bpos
operator|=
name|position
argument_list|(
name|BOTTOM
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'.'
condition|)
return|return
operator|(
name|pipe_data
argument_list|(
name|cmd
argument_list|,
name|tpos
argument_list|,
name|bpos
argument_list|)
operator|)
return|;
elseif|else
if|if
condition|(
name|mpos
operator|<=
name|tpos
condition|)
return|return
operator|(
name|pipe_data
argument_list|(
name|cmd
argument_list|,
name|mpos
argument_list|,
name|tpos
argument_list|)
operator|)
return|;
elseif|else
if|if
condition|(
name|bpos
operator|==
name|NULL_POSITION
condition|)
return|return
operator|(
name|pipe_data
argument_list|(
name|cmd
argument_list|,
name|tpos
argument_list|,
name|bpos
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
name|pipe_data
argument_list|(
name|cmd
argument_list|,
name|tpos
argument_list|,
name|mpos
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Create a pipe to the given shell command.  * Feed it the file contents between the positions spos and epos.  */
end_comment

begin_function
name|public
name|int
name|pipe_data
parameter_list|(
name|cmd
parameter_list|,
name|spos
parameter_list|,
name|epos
parameter_list|)
name|char
modifier|*
name|cmd
decl_stmt|;
name|POSITION
name|spos
decl_stmt|;
name|POSITION
name|epos
decl_stmt|;
block|{
specifier|register
name|FILE
modifier|*
name|f
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
specifier|extern
name|FILE
modifier|*
name|popen
parameter_list|()
function_decl|;
comment|/* 	 * This is structured much like lsystem(). 	 * Since we're running a shell program, we must be careful 	 * to perform the necessary deinitialization before running 	 * the command, and reinitialization after it. 	 */
if|if
condition|(
name|ch_seek
argument_list|(
name|spos
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"Cannot seek to start position"
argument_list|,
name|NULL_PARG
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|f
operator|=
name|popen
argument_list|(
name|cmd
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"Cannot create pipe"
argument_list|,
name|NULL_PARG
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|lower_left
argument_list|()
expr_stmt|;
name|clear_eol
argument_list|()
expr_stmt|;
name|putstr
argument_list|(
literal|"!"
argument_list|)
expr_stmt|;
name|putstr
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|putstr
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|deinit
argument_list|()
expr_stmt|;
name|flush
argument_list|()
expr_stmt|;
name|raw_mode
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|init_signals
argument_list|(
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGPIPE
name|SIGNAL
argument_list|(
name|SIGPIPE
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
name|epos
operator|==
name|NULL_POSITION
operator|||
name|spos
operator|++
operator|<=
name|epos
condition|)
block|{
comment|/* 		 * Read a character from the file and give it to the pipe. 		 */
name|c
operator|=
name|ch_forw_get
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOI
condition|)
break|break;
if|if
condition|(
name|putc
argument_list|(
name|c
argument_list|,
name|f
argument_list|)
operator|==
name|EOF
condition|)
break|break;
block|}
comment|/* 	 * Finish up the last line. 	 */
while|while
condition|(
name|c
operator|!=
literal|'\n'
operator|&&
name|c
operator|!=
name|EOI
condition|)
block|{
name|c
operator|=
name|ch_forw_get
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOI
condition|)
break|break;
if|if
condition|(
name|putc
argument_list|(
name|c
argument_list|,
name|f
argument_list|)
operator|==
name|EOF
condition|)
break|break;
block|}
name|pclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGPIPE
name|SIGNAL
argument_list|(
name|SIGPIPE
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|init_signals
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|raw_mode
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|init
argument_list|()
expr_stmt|;
name|screen_trashed
operator|=
literal|1
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|SIGWINCH
argument_list|)
operator|||
name|defined
argument_list|(
name|SIGWIND
argument_list|)
comment|/* {{ Probably don't need this here. }} */
name|winch
argument_list|()
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

