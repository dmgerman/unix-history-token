begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Routines to mess around with filenames (and files).  * Much of this is very OS dependent.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"less.h"
end_include

begin_function_decl
specifier|extern
name|char
modifier|*
name|getenv
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|int
name|force_open
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|IFILE
name|curr_ifile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|IFILE
name|old_ifile
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Return the full pathname of the given file in the "home directory".  */
end_comment

begin_function
name|public
name|char
modifier|*
name|homefile
parameter_list|(
name|filename
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|pathname
decl_stmt|;
specifier|register
name|char
modifier|*
name|homedir
decl_stmt|;
name|homedir
operator|=
name|getenv
argument_list|(
literal|"HOME"
argument_list|)
expr_stmt|;
if|#
directive|if
name|__MSDOS__
comment|/* 	 * Most MSDOS users do not have $HOME defined, 	 * so if no $HOME then look for "_less" anywhere  	 * on search path (always begins at current directory). 	 */
if|if
condition|(
name|homedir
operator|==
name|NULL
condition|)
block|{
specifier|extern
name|char
modifier|*
name|searchpath
parameter_list|()
function_decl|;
name|pathname
operator|=
name|searchpath
argument_list|(
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|pathname
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|pathname
operator|=
name|save
argument_list|(
name|pathname
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pathname
operator|=
operator|(
name|char
operator|*
operator|)
name|calloc
argument_list|(
name|strlen
argument_list|(
name|homedir
argument_list|)
operator|+
name|strlen
argument_list|(
name|filename
argument_list|)
operator|+
literal|2
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pathname
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|sprintf
argument_list|(
name|pathname
argument_list|,
literal|"%s\\%s"
argument_list|,
name|homedir
argument_list|,
name|filename
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
if|if
condition|(
name|homedir
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|pathname
operator|=
operator|(
name|char
operator|*
operator|)
name|calloc
argument_list|(
name|strlen
argument_list|(
name|homedir
argument_list|)
operator|+
name|strlen
argument_list|(
name|filename
argument_list|)
operator|+
literal|2
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pathname
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|sprintf
argument_list|(
name|pathname
argument_list|,
literal|"%s/%s"
argument_list|,
name|homedir
argument_list|,
name|filename
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|pathname
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Find out where the help file is.  */
end_comment

begin_function
name|public
name|char
modifier|*
name|find_helpfile
parameter_list|()
block|{
specifier|register
name|char
modifier|*
name|helpfile
decl_stmt|;
if|#
directive|if
name|__MSDOS__
specifier|extern
name|char
modifier|*
name|searchpath
parameter_list|()
function_decl|;
comment|/* 	 * Look in current directory. 	 */
if|if
condition|(
name|access
argument_list|(
name|HELPFILE
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|HELPFILE
operator|)
return|;
comment|/* 	 * Find the basename of HELPFILE, 	 * and look for it in each directory in the search path. 	 */
if|if
condition|(
operator|(
name|helpfile
operator|=
name|strrchr
argument_list|(
name|HELPFILE
argument_list|,
literal|'\\'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|helpfile
operator|=
name|HELPFILE
expr_stmt|;
else|else
name|helpfile
operator|++
expr_stmt|;
return|return
operator|(
name|save
argument_list|(
name|searchpath
argument_list|(
name|helpfile
argument_list|)
argument_list|)
operator|)
return|;
else|#
directive|else
if|if
condition|(
operator|(
name|helpfile
operator|=
name|getenv
argument_list|(
literal|"LESSHELP"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
return|return
operator|(
name|save
argument_list|(
name|helpfile
argument_list|)
operator|)
return|;
return|return
operator|(
name|save
argument_list|(
name|HELPFILE
argument_list|)
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Expand a string, substituting any "%" with the current filename,  * and any "#" with the previous filename.  */
end_comment

begin_function
name|public
name|char
modifier|*
name|fexpand
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|fr
decl_stmt|,
modifier|*
name|to
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
specifier|register
name|char
modifier|*
name|e
decl_stmt|;
comment|/* 	 * Make one pass to see how big a buffer we  	 * need to allocate for the expanded string. 	 */
name|n
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|fr
operator|=
name|s
init|;
operator|*
name|fr
operator|!=
literal|'\0'
condition|;
name|fr
operator|++
control|)
block|{
switch|switch
condition|(
operator|*
name|fr
condition|)
block|{
case|case
literal|'%'
case|:
name|n
operator|+=
name|strlen
argument_list|(
name|get_filename
argument_list|(
name|curr_ifile
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'#'
case|:
if|if
condition|(
name|old_ifile
operator|==
name|NULL_IFILE
condition|)
block|{
name|error
argument_list|(
literal|"No previous file"
argument_list|,
name|NULL_PARG
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|n
operator|+=
name|strlen
argument_list|(
name|get_filename
argument_list|(
name|old_ifile
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|n
operator|++
expr_stmt|;
break|break;
block|}
block|}
name|e
operator|=
operator|(
name|char
operator|*
operator|)
name|ecalloc
argument_list|(
name|n
operator|+
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Now copy the string, expanding any "%" or "#". 	 */
name|to
operator|=
name|e
expr_stmt|;
for|for
control|(
name|fr
operator|=
name|s
init|;
operator|*
name|fr
operator|!=
literal|'\0'
condition|;
name|fr
operator|++
control|)
block|{
switch|switch
condition|(
operator|*
name|fr
condition|)
block|{
case|case
literal|'%'
case|:
name|strcpy
argument_list|(
name|to
argument_list|,
name|get_filename
argument_list|(
name|curr_ifile
argument_list|)
argument_list|)
expr_stmt|;
name|to
operator|+=
name|strlen
argument_list|(
name|to
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'#'
case|:
name|strcpy
argument_list|(
name|to
argument_list|,
name|get_filename
argument_list|(
name|old_ifile
argument_list|)
argument_list|)
expr_stmt|;
name|to
operator|+=
name|strlen
argument_list|(
name|to
argument_list|)
expr_stmt|;
break|break;
default|default:
operator|*
name|to
operator|++
operator|=
operator|*
name|fr
expr_stmt|;
break|break;
block|}
block|}
operator|*
name|to
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|e
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Try to determine if a file is "binary".  * This is just a guess, and we need not try too hard to make it accurate.  */
end_comment

begin_function
name|int
name|bin_file
parameter_list|(
name|f
parameter_list|)
name|int
name|f
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|n
decl_stmt|;
name|char
name|data
index|[
literal|64
index|]
decl_stmt|;
name|n
operator|=
name|read
argument_list|(
name|f
argument_list|,
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|data
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|binary_char
argument_list|(
name|data
index|[
name|i
index|]
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Try to determine the size of a file by seeking to the end.  */
end_comment

begin_function
specifier|static
name|POSITION
name|seek_filesize
parameter_list|(
name|f
parameter_list|)
name|int
name|f
decl_stmt|;
block|{
name|offset_t
name|spos
decl_stmt|;
name|spos
operator|=
name|lseek
argument_list|(
name|f
argument_list|,
operator|(
name|offset_t
operator|)
literal|0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|spos
operator|==
name|BAD_LSEEK
condition|)
return|return
operator|(
name|NULL_POSITION
operator|)
return|;
return|return
operator|(
operator|(
name|POSITION
operator|)
name|spos
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Expand a filename, substituting any environment variables, etc.  */
end_comment

begin_if
if|#
directive|if
name|GLOB
end_if

begin_function_decl
name|FILE
modifier|*
name|popen
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|public
name|char
modifier|*
name|glob
parameter_list|(
name|filename
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|FILE
modifier|*
name|f
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|ch
decl_stmt|;
name|int
name|len
decl_stmt|;
name|char
modifier|*
name|cmd
decl_stmt|;
name|char
modifier|*
name|gfilename
decl_stmt|;
name|filename
operator|=
name|fexpand
argument_list|(
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|filename
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* 	 * We get the shell to expand the filename for us by passing 	 * an "echo" command to the shell and reading its output. 	 */
name|p
operator|=
name|getenv
argument_list|(
literal|"SHELL"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
operator|||
operator|*
name|p
operator|==
literal|'\0'
condition|)
block|{
comment|/* 		 * Read the output of<echo filename>. 		 */
name|cmd
operator|=
operator|(
name|char
operator|*
operator|)
name|ecalloc
argument_list|(
name|strlen
argument_list|(
name|filename
argument_list|)
operator|+
literal|6
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|cmd
argument_list|,
literal|"echo %s"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Read the output of<$SHELL -c "echo filename">. 		 */
name|cmd
operator|=
operator|(
name|char
operator|*
operator|)
name|ecalloc
argument_list|(
name|strlen
argument_list|(
name|p
argument_list|)
operator|+
name|strlen
argument_list|(
name|filename
argument_list|)
operator|+
literal|12
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|cmd
argument_list|,
literal|"%s -c \"echo %s\""
argument_list|,
name|p
argument_list|,
name|filename
argument_list|)
expr_stmt|;
block|}
name|f
operator|=
name|popen
argument_list|(
name|cmd
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
return|return
operator|(
name|filename
operator|)
return|;
name|free
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|len
operator|=
literal|100
expr_stmt|;
name|gfilename
operator|=
operator|(
name|char
operator|*
operator|)
name|ecalloc
argument_list|(
name|len
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|gfilename
init|;
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|ch
operator|=
name|getc
argument_list|(
name|f
argument_list|)
operator|)
operator|==
literal|'\n'
operator|||
name|ch
operator|==
name|EOF
condition|)
break|break;
if|if
condition|(
name|p
operator|-
name|gfilename
operator|>=
name|len
operator|-
literal|1
condition|)
block|{
name|len
operator|*=
literal|2
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|p
operator|=
operator|(
name|char
operator|*
operator|)
name|ecalloc
argument_list|(
name|len
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|p
argument_list|,
name|gfilename
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|gfilename
argument_list|)
expr_stmt|;
name|gfilename
operator|=
name|p
expr_stmt|;
name|p
operator|=
name|gfilename
operator|+
name|strlen
argument_list|(
name|gfilename
argument_list|)
expr_stmt|;
block|}
operator|*
name|p
operator|=
name|ch
expr_stmt|;
block|}
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|pclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|gfilename
operator|==
literal|'\0'
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
return|return
operator|(
name|gfilename
operator|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
name|public
name|char
modifier|*
name|glob
parameter_list|(
name|filename
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
block|{
return|return
operator|(
name|fexpand
argument_list|(
name|filename
argument_list|)
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|STAT
end_if

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_comment
comment|/*  * Returns NULL if the file can be opened and  * is an ordinary file, otherwise an error message  * (if it cannot be opened or is a directory, etc.)  */
end_comment

begin_function
name|public
name|char
modifier|*
name|bad_file
parameter_list|(
name|filename
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|m
decl_stmt|;
name|struct
name|stat
name|statbuf
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|filename
argument_list|,
operator|&
name|statbuf
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|errno_message
argument_list|(
name|filename
argument_list|)
operator|)
return|;
if|if
condition|(
name|force_open
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
operator|(
name|statbuf
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|==
name|S_IFDIR
condition|)
block|{
specifier|static
name|char
name|is_dir
index|[]
init|=
literal|" is a directory"
decl_stmt|;
name|m
operator|=
operator|(
name|char
operator|*
operator|)
name|ecalloc
argument_list|(
name|strlen
argument_list|(
name|filename
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|is_dir
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|m
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|m
argument_list|,
name|is_dir
argument_list|)
expr_stmt|;
return|return
operator|(
name|m
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|statbuf
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|!=
name|S_IFREG
condition|)
block|{
specifier|static
name|char
name|not_reg
index|[]
init|=
literal|" is not a regular file"
decl_stmt|;
name|m
operator|=
operator|(
name|char
operator|*
operator|)
name|ecalloc
argument_list|(
name|strlen
argument_list|(
name|filename
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|not_reg
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|m
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|m
argument_list|,
name|not_reg
argument_list|)
expr_stmt|;
return|return
operator|(
name|m
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return the size of a file, as cheaply as possible.  * In Unix, we can stat the file.  */
end_comment

begin_function
name|public
name|POSITION
name|filesize
parameter_list|(
name|f
parameter_list|)
name|int
name|f
decl_stmt|;
block|{
name|struct
name|stat
name|statbuf
decl_stmt|;
if|if
condition|(
name|fstat
argument_list|(
name|f
argument_list|,
operator|&
name|statbuf
argument_list|)
operator|<
literal|0
condition|)
comment|/* 		 * Can't stat; try seeking to the end. 		 */
return|return
operator|(
name|seek_filesize
argument_list|(
name|f
argument_list|)
operator|)
return|;
return|return
operator|(
operator|(
name|POSITION
operator|)
name|statbuf
operator|.
name|st_size
operator|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/*  * If we have no way to find out, just say the file is good.  */
end_comment

begin_function
name|public
name|char
modifier|*
name|bad_file
parameter_list|(
name|filename
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * We can find the file size by seeking.  */
end_comment

begin_function
name|public
name|POSITION
name|filesize
parameter_list|(
name|f
parameter_list|)
name|int
name|f
decl_stmt|;
block|{
return|return
operator|(
name|seek_filesize
argument_list|(
name|f
argument_list|)
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

