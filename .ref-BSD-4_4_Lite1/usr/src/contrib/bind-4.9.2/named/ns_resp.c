begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|lint
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|SABER
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)ns_resp.c	4.65 (Berkeley) 3/3/91"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$Id: ns_resp.c,v 4.9.1.10 1993/12/06 00:43:02 vixie Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/*  * ++Copyright++ 1986, 1988, 1990  * -  * Copyright (c) 1986, 1988, 1990  *    The Regents of the University of California.  All rights reserved.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  * 	This product includes software developed by the University of  * 	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  * -  * Portions Copyright (c) 1993 by Digital Equipment Corporation.  *   * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies, and that  * the name of Digital Equipment Corporation not be used in advertising or  * publicity pertaining to distribution of the document or software without  * specific, written prior permission.  *   * THE SOFTWARE IS PROVIDED "AS IS" AND DIGITAL EQUIPMENT CORP. DISCLAIMS ALL  * WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS.   IN NO EVENT SHALL DIGITAL EQUIPMENT  * CORPORATION BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL  * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR  * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS  * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS  * SOFTWARE.  * -  * --Copyright--  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<arpa/nameser.h>
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<resolv.h>
end_include

begin_include
include|#
directive|include
file|"named.h"
end_include

begin_decl_stmt
specifier|static
name|void
name|check_root
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|,
name|check_ns
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|norootlogged
index|[
name|MAXCLASS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|skipnameFailedAnswer
index|[]
init|=
literal|"skipname failed in answer"
decl_stmt|,
name|skipnameFailedQuery
index|[]
init|=
literal|"skipname failed in query"
decl_stmt|,
name|outofDataQuery
index|[]
init|=
literal|"ran out of data in query"
decl_stmt|,
name|outofDataAnswer
index|[]
init|=
literal|"ran out of data in answer"
decl_stmt|,
name|dlenOverrunAnswer
index|[]
init|=
literal|"dlen overrun in answer"
decl_stmt|,
name|dlenUnderrunAnswer
index|[]
init|=
literal|"dlen underrun in answer"
decl_stmt|,
name|outofDataFinal
index|[]
init|=
literal|"out of data in final pass"
decl_stmt|,
name|outofDataAFinal
index|[]
init|=
literal|"out of data after final pass"
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|ns_resp
parameter_list|(
name|msg
parameter_list|,
name|msglen
parameter_list|)
name|u_char
modifier|*
name|msg
decl_stmt|;
name|int
name|msglen
decl_stmt|;
block|{
specifier|register
name|struct
name|qinfo
modifier|*
name|qp
decl_stmt|;
specifier|register
name|HEADER
modifier|*
name|hp
decl_stmt|;
specifier|register
name|struct
name|qserv
modifier|*
name|qs
decl_stmt|;
specifier|register
name|struct
name|databuf
modifier|*
name|ns
decl_stmt|,
modifier|*
name|ns2
decl_stmt|;
specifier|register
name|u_char
modifier|*
name|cp
decl_stmt|;
ifdef|#
directive|ifdef
name|VALIDATE
specifier|register
name|u_char
modifier|*
name|tempcp
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|server
init|=
operator|&
name|from_addr
decl_stmt|;
name|int
modifier|*
name|validatelist
decl_stmt|;
name|int
name|lesscount
decl_stmt|;
endif|#
directive|endif
name|struct
name|databuf
modifier|*
name|nsp
index|[
name|NSMAX
index|]
decl_stmt|,
modifier|*
modifier|*
name|nspp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|c
decl_stmt|,
name|n
decl_stmt|,
name|ancount
decl_stmt|,
name|aucount
decl_stmt|,
name|nscount
decl_stmt|,
name|arcount
decl_stmt|;
name|int
name|old_ancount
decl_stmt|;
name|int
name|type
decl_stmt|,
name|class
decl_stmt|,
name|dbflags
decl_stmt|;
name|int
name|cname
init|=
literal|0
decl_stmt|;
comment|/* flag for processing cname response */
name|int
name|count
decl_stmt|,
name|founddata
decl_stmt|,
name|foundname
decl_stmt|;
name|int
name|buflen
decl_stmt|;
name|int
name|newmsglen
decl_stmt|;
name|char
name|name
index|[
name|MAXDNAME
index|]
decl_stmt|,
modifier|*
name|dname
decl_stmt|;
name|char
modifier|*
name|fname
decl_stmt|;
name|char
modifier|*
name|formerrmsg
init|=
literal|"brain damage"
decl_stmt|;
name|u_char
name|newmsg
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|u_char
modifier|*
modifier|*
name|dpp
decl_stmt|,
modifier|*
name|tp
decl_stmt|;
name|time_t
name|rtrip
decl_stmt|;
name|struct
name|hashbuf
modifier|*
name|htp
decl_stmt|;
name|struct
name|namebuf
modifier|*
name|np
decl_stmt|;
name|struct
name|netinfo
modifier|*
name|lp
decl_stmt|;
name|struct
name|fwdinfo
modifier|*
name|fwd
decl_stmt|;
name|stats
index|[
name|S_RESPONSES
index|]
operator|.
name|cnt
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|DATUMREFCNT
name|nsp
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
name|hp
operator|=
operator|(
name|HEADER
operator|*
operator|)
name|msg
expr_stmt|;
if|if
condition|(
operator|(
name|qp
operator|=
name|qfindid
argument_list|(
name|hp
operator|->
name|id
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"DUP? dropped (id %d)\n"
operator|,
name|ntohs
argument_list|(
name|hp
operator|->
name|id
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|stats
index|[
name|S_DUPRESP
index|]
operator|.
name|cnt
operator|++
expr_stmt|;
return|return;
block|}
name|dprintf
argument_list|(
literal|2
argument_list|,
operator|(
name|ddt
operator|,
literal|"Response (%s %s %s) nsid=%d id=%d\n"
operator|,
operator|(
name|qp
operator|->
name|q_flags
operator|&
name|Q_SYSTEM
operator|)
condition|?
literal|"SYSTEM"
else|:
literal|"USER"
operator|,
operator|(
name|qp
operator|->
name|q_flags
operator|&
name|Q_PRIMING
operator|)
condition|?
literal|"PRIMING"
else|:
literal|"NORMAL"
operator|,
operator|(
name|qp
operator|->
name|q_flags
operator|&
name|Q_ZSERIAL
operator|)
condition|?
literal|"ZSERIAL"
else|:
literal|"-"
operator|,
name|ntohs
argument_list|(
name|qp
operator|->
name|q_nsid
argument_list|)
operator|,
name|ntohs
argument_list|(
name|qp
operator|->
name|q_id
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 *  Here we handle bad responses from servers. 	 *  Several possibilities come to mind: 	 *	The server is sick and returns SERVFAIL 	 *	The server returns some garbage opcode (its sick) 	 *	The server can't understand our query and return FORMERR 	 *  In all these cases, we simply drop the packet and force 	 *  a retry.  This will make him look bad due to unresponsiveness. 	 *  Be sure not to include authoritative NXDOMAIN 	 */
if|if
condition|(
operator|(
name|hp
operator|->
name|rcode
operator|!=
name|NOERROR
operator|&&
name|hp
operator|->
name|rcode
operator|!=
name|NXDOMAIN
operator|)
ifndef|#
directive|ifndef
name|NCACHE
operator|||
operator|(
name|hp
operator|->
name|rcode
operator|==
name|NXDOMAIN
operator|&&
operator|!
name|hp
operator|->
name|aa
operator|)
comment|/* must accept this one if 						   * we allow negative caching 						   */
endif|#
directive|endif
comment|/*NCACHE*/
operator|||
name|hp
operator|->
name|opcode
operator|!=
name|QUERY
condition|)
block|{
name|dprintf
argument_list|(
literal|2
argument_list|,
operator|(
name|ddt
operator|,
literal|"resp: error (ret %d, op %d), dropped\n"
operator|,
name|hp
operator|->
name|rcode
operator|,
name|hp
operator|->
name|opcode
operator|)
argument_list|)
expr_stmt|;
name|stats
index|[
name|S_BADRESPONSES
index|]
operator|.
name|cnt
operator|++
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|ALLOW_UPDATES
if|if
condition|(
operator|(
name|hp
operator|->
name|rcode
operator|==
name|NOERROR
operator|)
operator|&&
operator|(
name|hp
operator|->
name|opcode
operator|==
name|UPDATEA
operator|||
name|hp
operator|->
name|opcode
operator|==
name|UPDATED
operator|||
name|hp
operator|->
name|opcode
operator|==
name|UPDATEDA
operator|||
name|hp
operator|->
name|opcode
operator|==
name|UPDATEM
operator|||
name|hp
operator|->
name|opcode
operator|==
name|UPDATEMA
operator|)
condition|)
block|{
comment|/* 		 * Update the secondary's copy, now that the primary 		 * successfully completed the update.  Zone doesn't matter 		 * for dyn. update -- doupdate calls findzone to find it 		 */
name|doupdate
argument_list|(
name|qp
operator|->
name|q_msg
argument_list|,
name|qp
operator|->
name|q_msglen
argument_list|,
name|qp
operator|->
name|q_msg
operator|+
sizeof|sizeof
argument_list|(
name|HEADER
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|databuf
operator|*
operator|)
literal|0
argument_list|,
literal|0
ifdef|#
directive|ifdef
name|CRED
argument_list|,
name|DB_C_AUTH
endif|#
directive|endif
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"resp: leaving, UPDATE*\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* return code filled in by doupdate */
goto|goto
name|return_msg
goto|;
block|}
endif|#
directive|endif
comment|/* ALLOW_UPDATES */
comment|/* 	 * Determine if the response came from a forwarder.  Packets from 	 * anyplace not listed as a forwarder or as a server to whom we 	 * might have forwarded the query will be dropped. 	 */
for|for
control|(
name|fwd
operator|=
name|fwdtab
init|;
name|fwd
operator|!=
operator|(
expr|struct
name|fwdinfo
operator|*
operator|)
name|NULL
condition|;
name|fwd
operator|=
name|fwd
operator|->
name|next
control|)
block|{
if|if
condition|(
name|fwd
operator|->
name|fwdaddr
operator|.
name|sin_addr
operator|.
name|s_addr
operator|==
name|from_addr
operator|.
name|sin_addr
operator|.
name|s_addr
condition|)
block|{
comment|/* XXX - should put this in STATS somewhere */
break|break;
block|}
block|}
comment|/* 	 * If we were using nameservers, find the qinfo pointer and update 	 * the rtt and fact that we have called on this server before. 	 */
if|if
condition|(
name|fwd
operator|==
operator|(
expr|struct
name|fwdinfo
operator|*
operator|)
name|NULL
condition|)
block|{
name|struct
name|timeval
modifier|*
name|stp
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
operator|,
name|qs
operator|=
name|qp
operator|->
name|q_addr
init|;
name|n
operator|<
name|qp
operator|->
name|q_naddr
condition|;
name|n
operator|++
operator|,
name|qs
operator|++
control|)
if|if
condition|(
name|qs
operator|->
name|ns_addr
operator|.
name|sin_addr
operator|.
name|s_addr
operator|==
name|from_addr
operator|.
name|sin_addr
operator|.
name|s_addr
condition|)
break|break;
if|if
condition|(
name|n
operator|>=
name|qp
operator|->
name|q_naddr
condition|)
block|{
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"Response from unexpected source [%s].%d\n"
operator|,
name|inet_ntoa
argument_list|(
name|from_addr
operator|.
name|sin_addr
argument_list|)
operator|,
name|ntohs
argument_list|(
name|from_addr
operator|.
name|sin_port
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|stats
index|[
name|S_MARTIANS
index|]
operator|.
name|cnt
operator|++
expr_stmt|;
comment|/*  			 * We don't know who this response came from so it 			 * gets dropped on the floor. 			 */
return|return;
block|}
name|stp
operator|=
operator|&
name|qs
operator|->
name|stime
expr_stmt|;
comment|/* Handle response from different (untried) interface */
if|if
condition|(
operator|(
name|qs
operator|->
name|ns
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|stp
operator|->
name|tv_sec
operator|==
literal|0
operator|)
condition|)
block|{
name|ns
operator|=
name|qs
operator|->
name|ns
expr_stmt|;
while|while
condition|(
name|qs
operator|>
name|qp
operator|->
name|q_addr
operator|&&
operator|(
name|qs
operator|->
name|stime
operator|.
name|tv_sec
operator|==
literal|0
operator|||
name|qs
operator|->
name|ns
operator|!=
name|ns
operator|)
condition|)
name|qs
operator|--
expr_stmt|;
operator|*
name|stp
operator|=
name|qs
operator|->
name|stime
expr_stmt|;
comment|/* XXX - sometimes stp still ends up pointing to 			 * a zero timeval, in spite of the above attempt. 			 * Why?  What should we do about it? 			 */
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"Response from unused address %s, assuming %s\n"
operator|,
name|inet_ntoa
argument_list|(
name|from_addr
operator|.
name|sin_addr
argument_list|)
operator|,
name|inet_ntoa
argument_list|(
name|qs
operator|->
name|ns_addr
operator|.
name|sin_addr
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* XXX - catch aliases here */
block|}
comment|/* compute query round trip time */
comment|/* XXX - avoid integer overflow, which is quite likely if stp 		 * points to a zero timeval (see above). 		 * rtrip is of type time_t, which we assume is at least 		 * as big as an int. 		 */
if|if
condition|(
operator|(
name|tt
operator|.
name|tv_sec
operator|-
name|stp
operator|->
name|tv_sec
operator|)
operator|>
operator|(
name|INT_MAX
operator|-
literal|999
operator|)
operator|/
literal|1000
condition|)
block|{
name|rtrip
operator|=
name|INT_MAX
expr_stmt|;
block|}
else|else
block|{
name|rtrip
operator|=
operator|(
operator|(
name|tt
operator|.
name|tv_sec
operator|-
name|stp
operator|->
name|tv_sec
operator|)
operator|*
literal|1000
operator|+
operator|(
name|tt
operator|.
name|tv_usec
operator|-
name|stp
operator|->
name|tv_usec
operator|)
operator|/
literal|1000
operator|)
expr_stmt|;
block|}
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"stime %d/%d  now %d/%d rtt %d\n"
operator|,
name|stp
operator|->
name|tv_sec
operator|,
name|stp
operator|->
name|tv_usec
operator|,
name|tt
operator|.
name|tv_sec
operator|,
name|tt
operator|.
name|tv_usec
operator|,
name|rtrip
operator|)
argument_list|)
expr_stmt|;
comment|/* prevent floating point overflow, limit to 1000 sec */
if|if
condition|(
name|rtrip
operator|>
literal|1000000
condition|)
block|{
name|rtrip
operator|=
literal|1000000
expr_stmt|;
block|}
name|ns
operator|=
name|qs
operator|->
name|nsdata
expr_stmt|;
comment|/* 		 * Don't update nstime if this doesn't look 		 * like an address databuf now.			XXX 		 */
if|if
condition|(
name|ns
operator|&&
operator|(
name|ns
operator|->
name|d_type
operator|==
name|T_A
operator|)
operator|&&
operator|(
name|ns
operator|->
name|d_class
operator|==
name|qs
operator|->
name|ns
operator|->
name|d_class
operator|)
condition|)
block|{
if|if
condition|(
name|ns
operator|->
name|d_nstime
operator|==
literal|0
condition|)
name|ns
operator|->
name|d_nstime
operator|=
operator|(
name|u_int32_t
operator|)
name|rtrip
expr_stmt|;
else|else
name|ns
operator|->
name|d_nstime
operator|=
call|(
name|u_int32_t
call|)
argument_list|(
name|ns
operator|->
name|d_nstime
operator|*
name|ALPHA
operator|+
operator|(
literal|1
operator|-
name|ALPHA
operator|)
operator|*
operator|(
name|u_int32_t
operator|)
name|rtrip
argument_list|)
expr_stmt|;
comment|/* prevent floating point overflow, 			 * limit to 1000 sec 			 */
if|if
condition|(
name|ns
operator|->
name|d_nstime
operator|>
literal|1000000
condition|)
name|ns
operator|->
name|d_nstime
operator|=
literal|1000000
expr_stmt|;
block|}
comment|/* 		 * Record the source so that we do not use this NS again. 		 */
if|if
condition|(
name|ns
operator|&&
name|qs
operator|->
name|ns
operator|&&
operator|(
name|qp
operator|->
name|q_nusedns
operator|<
name|NSMAX
operator|)
condition|)
block|{
name|qp
operator|->
name|q_usedns
index|[
name|qp
operator|->
name|q_nusedns
operator|++
index|]
operator|=
name|qs
operator|->
name|ns
expr_stmt|;
name|dprintf
argument_list|(
literal|2
argument_list|,
operator|(
name|ddt
operator|,
literal|"NS #%d addr [%s] used, rtt %d\n"
operator|,
name|n
operator|,
name|inet_ntoa
argument_list|(
name|qs
operator|->
name|ns_addr
operator|.
name|sin_addr
argument_list|)
operator|,
name|ns
operator|->
name|d_nstime
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Penalize those who had earlier chances but failed 		 * by multiplying round-trip times by BETA (>1). 		 * Improve nstime for unused addresses by applying GAMMA. 		 * The GAMMA factor makes unused entries slowly 		 * improve, so they eventually get tried again. 		 * GAMMA should be slightly less than 1. 		 * Watch out for records that may have timed out 		 * and are no longer the correct type.			XXX 		 */
for|for
control|(
name|n
operator|=
literal|0
operator|,
name|qs
operator|=
name|qp
operator|->
name|q_addr
init|;
name|n
operator|<
name|qp
operator|->
name|q_naddr
condition|;
name|n
operator|++
operator|,
name|qs
operator|++
control|)
block|{
name|ns2
operator|=
name|qs
operator|->
name|nsdata
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|ns2
operator|)
operator|||
operator|(
name|ns2
operator|==
name|ns
operator|)
condition|)
continue|continue;
if|if
condition|(
name|ns2
operator|->
name|d_type
operator|!=
name|T_A
operator|||
name|ns2
operator|->
name|d_class
operator|!=
name|qs
operator|->
name|ns
operator|->
name|d_class
condition|)
comment|/* XXX */
continue|continue;
if|if
condition|(
name|qs
operator|->
name|stime
operator|.
name|tv_sec
condition|)
block|{
if|if
condition|(
name|ns2
operator|->
name|d_nstime
operator|==
literal|0
condition|)
name|ns2
operator|->
name|d_nstime
operator|=
call|(
name|u_int32_t
call|)
argument_list|(
name|rtrip
operator|*
name|BETA
argument_list|)
expr_stmt|;
else|else
name|ns2
operator|->
name|d_nstime
operator|=
call|(
name|u_int32_t
call|)
argument_list|(
name|ns2
operator|->
name|d_nstime
operator|*
name|BETA
operator|+
operator|(
literal|1
operator|-
name|ALPHA
operator|)
operator|*
name|rtrip
argument_list|)
expr_stmt|;
if|if
condition|(
name|ns2
operator|->
name|d_nstime
operator|>
literal|1000000
condition|)
name|ns2
operator|->
name|d_nstime
operator|=
literal|1000000
expr_stmt|;
block|}
else|else
name|ns2
operator|->
name|d_nstime
operator|=
call|(
name|u_int32_t
call|)
argument_list|(
name|ns2
operator|->
name|d_nstime
operator|*
name|GAMMA
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
literal|2
argument_list|,
operator|(
name|ddt
operator|,
literal|"NS #%d [%s] rtt now %d\n"
operator|,
name|n
operator|,
name|inet_ntoa
argument_list|(
name|qs
operator|->
name|ns_addr
operator|.
name|sin_addr
argument_list|)
operator|,
name|ns2
operator|->
name|d_nstime
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Skip query section 	 */
name|free_addinfo
argument_list|()
expr_stmt|;
comment|/* sets addcount to zero */
name|cp
operator|=
name|msg
operator|+
sizeof|sizeof
argument_list|(
name|HEADER
argument_list|)
expr_stmt|;
name|dpp
operator|=
name|dnptrs
expr_stmt|;
operator|*
name|dpp
operator|++
operator|=
name|msg
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|cp
operator|&
name|INDIR_MASK
operator|)
operator|==
literal|0
condition|)
operator|*
name|dpp
operator|++
operator|=
name|cp
expr_stmt|;
operator|*
name|dpp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|qdcount
condition|)
block|{
name|n
operator|=
name|dn_skipname
argument_list|(
name|cp
argument_list|,
name|msg
operator|+
name|msglen
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<=
literal|0
condition|)
block|{
name|formerrmsg
operator|=
name|skipnameFailedQuery
expr_stmt|;
goto|goto
name|formerr
goto|;
block|}
name|cp
operator|+=
name|n
expr_stmt|;
name|GETSHORT
argument_list|(
name|type
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|GETSHORT
argument_list|(
name|class
argument_list|,
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|-
name|msg
operator|>
name|msglen
condition|)
block|{
name|formerrmsg
operator|=
name|outofDataQuery
expr_stmt|;
goto|goto
name|formerr
goto|;
block|}
block|}
comment|/* 	 * Save answers, authority, and additional records for future use. 	 */
name|ancount
operator|=
name|ntohs
argument_list|(
name|hp
operator|->
name|ancount
argument_list|)
expr_stmt|;
name|aucount
operator|=
name|ntohs
argument_list|(
name|hp
operator|->
name|nscount
argument_list|)
expr_stmt|;
name|arcount
operator|=
name|ntohs
argument_list|(
name|hp
operator|->
name|arcount
argument_list|)
expr_stmt|;
name|nscount
operator|=
literal|0
expr_stmt|;
name|tp
operator|=
name|cp
expr_stmt|;
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"resp: ancount %d, aucount %d, arcount %d\n"
operator|,
name|ancount
operator|,
name|aucount
operator|,
name|arcount
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 *  If there's an answer, check if it's a CNAME response; 	 *  if no answer but aucount> 0, see if there is an NS 	 *  or just an SOA.  (NOTE: ancount might be 1 with a CNAME, 	 *  and NS records may still be in the authority section; 	 *  we don't bother counting them, as we only use nscount 	 *  if ancount == 0.) 	 */
if|if
condition|(
name|ancount
operator|==
literal|1
operator|||
operator|(
name|ancount
operator|==
literal|0
operator|&&
name|aucount
operator|>
literal|0
operator|)
condition|)
block|{
name|c
operator|=
name|aucount
expr_stmt|;
do|do
block|{
if|if
condition|(
name|tp
operator|-
name|msg
operator|>=
name|msglen
condition|)
block|{
name|formerrmsg
operator|=
name|outofDataAnswer
expr_stmt|;
goto|goto
name|formerr
goto|;
block|}
name|n
operator|=
name|dn_skipname
argument_list|(
name|tp
argument_list|,
name|msg
operator|+
name|msglen
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<=
literal|0
condition|)
block|{
name|formerrmsg
operator|=
name|skipnameFailedAnswer
expr_stmt|;
goto|goto
name|formerr
goto|;
block|}
name|tp
operator|+=
name|n
expr_stmt|;
comment|/* name */
name|GETSHORT
argument_list|(
name|i
argument_list|,
name|tp
argument_list|)
expr_stmt|;
comment|/* type */
name|tp
operator|+=
sizeof|sizeof
argument_list|(
name|u_int16_t
argument_list|)
expr_stmt|;
comment|/* class */
name|tp
operator|+=
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
expr_stmt|;
comment|/* ttl */
name|GETSHORT
argument_list|(
name|count
argument_list|,
name|tp
argument_list|)
expr_stmt|;
comment|/* dlen */
if|if
condition|(
name|tp
operator|-
name|msg
operator|>
name|msglen
operator|-
name|count
condition|)
block|{
name|formerrmsg
operator|=
name|dlenOverrunAnswer
expr_stmt|;
goto|goto
name|formerr
goto|;
block|}
name|tp
operator|+=
name|count
expr_stmt|;
if|if
condition|(
name|ancount
operator|&&
name|i
operator|==
name|T_CNAME
condition|)
block|{
name|cname
operator|++
expr_stmt|;
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"CNAME - needs more processing\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|qp
operator|->
name|q_cmsglen
condition|)
block|{
name|qp
operator|->
name|q_cmsg
operator|=
name|qp
operator|->
name|q_msg
expr_stmt|;
name|qp
operator|->
name|q_cmsglen
operator|=
name|qp
operator|->
name|q_msglen
expr_stmt|;
name|qp
operator|->
name|q_msg
operator|=
name|NULL
expr_stmt|;
name|qp
operator|->
name|q_msglen
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* 			 * See if authority record is a nameserver. 			 */
if|if
condition|(
name|ancount
operator|==
literal|0
operator|&&
name|i
operator|==
name|T_NS
condition|)
name|nscount
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|c
operator|>
literal|0
condition|)
do|;
name|tp
operator|=
name|cp
expr_stmt|;
block|}
if|if
condition|(
name|qp
operator|->
name|q_flags
operator|&
name|Q_ZSERIAL
condition|)
block|{
if|if
condition|(
operator|(
name|hp
operator|->
name|aa
operator|)
operator|&&
operator|(
name|ancount
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|hp
operator|->
name|rcode
operator|==
name|NOERROR
operator|)
operator|&&
operator|(
name|type
operator|==
name|T_SOA
operator|)
operator|&&
operator|(
operator|(
name|class
operator|==
name|C_IN
operator|)
operator|||
operator|(
name|class
operator|==
name|C_HS
operator|)
operator|)
condition|)
block|{
comment|/* XXX - should check name, too */
name|int
name|n
decl_stmt|;
name|u_int16_t
name|dlen
decl_stmt|;
name|u_int32_t
name|serial
decl_stmt|;
name|u_char
modifier|*
name|tp
init|=
name|cp
decl_stmt|;
if|if
condition|(
literal|0
operator|>=
operator|(
name|n
operator|=
name|dn_skipname
argument_list|(
name|tp
argument_list|,
name|msg
operator|+
name|msglen
argument_list|)
operator|)
condition|)
block|{
name|formerrmsg
operator|=
name|skipnameFailedAnswer
expr_stmt|;
goto|goto
name|formerr
goto|;
block|}
name|tp
operator|+=
name|n
comment|/* name */
operator|+
sizeof|sizeof
argument_list|(
name|u_int16_t
argument_list|)
comment|/* type */
operator|+
sizeof|sizeof
argument_list|(
name|u_int16_t
argument_list|)
comment|/* class */
operator|+
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
expr_stmt|;
comment|/* ttl */
name|GETSHORT
argument_list|(
name|dlen
argument_list|,
name|tp
argument_list|)
expr_stmt|;
comment|/* dlen */
if|if
condition|(
name|dlen
operator|<
operator|(
literal|5
operator|*
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
operator|)
condition|)
block|{
name|formerrmsg
operator|=
name|dlenUnderrunAnswer
expr_stmt|;
goto|goto
name|formerr
goto|;
block|}
if|if
condition|(
literal|0
operator|>=
operator|(
name|n
operator|=
name|dn_skipname
argument_list|(
name|tp
argument_list|,
name|msg
operator|+
name|msglen
argument_list|)
operator|)
condition|)
block|{
name|formerrmsg
operator|=
name|skipnameFailedAnswer
expr_stmt|;
goto|goto
name|formerr
goto|;
block|}
name|tp
operator|+=
name|n
expr_stmt|;
comment|/* mname */
if|if
condition|(
literal|0
operator|>=
operator|(
name|n
operator|=
name|dn_skipname
argument_list|(
name|tp
argument_list|,
name|msg
operator|+
name|msglen
argument_list|)
operator|)
condition|)
block|{
name|formerrmsg
operator|=
name|skipnameFailedAnswer
expr_stmt|;
goto|goto
name|formerr
goto|;
block|}
name|tp
operator|+=
name|n
expr_stmt|;
comment|/* rname */
name|GETLONG
argument_list|(
name|serial
argument_list|,
name|tp
argument_list|)
expr_stmt|;
name|qserial_answer
argument_list|(
name|qp
argument_list|,
name|serial
argument_list|)
expr_stmt|;
block|}
name|qremove
argument_list|(
name|qp
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Add the info received in the response to the Data Base 	 */
name|c
operator|=
name|ancount
operator|+
name|aucount
operator|+
name|arcount
expr_stmt|;
ifdef|#
directive|ifdef
name|NCACHE
comment|/* -ve $ing non-existence of record, must handle non-authoritative 	 * NOERRORs with c == 0. 	 */
if|if
condition|(
operator|!
name|hp
operator|->
name|aa
operator|&&
name|hp
operator|->
name|rcode
operator|==
name|NOERROR
operator|&&
name|c
operator|==
literal|0
condition|)
block|{
goto|goto
name|return_msg
goto|;
block|}
comment|/*should ideally validate message before returning it*/
endif|#
directive|endif
comment|/*NCACHE*/
ifdef|#
directive|ifdef
name|notdef
comment|/* 	 * If the request was for a CNAME that doesn't exist, 	 * but the name is valid, fetch any other data for the name. 	 * DON'T do this now, as it will requery if data are already 	 * in the cache (maybe later with negative caching). 	 */
if|if
condition|(
name|hp
operator|->
name|qdcount
operator|&&
name|type
operator|==
name|T_CNAME
operator|&&
name|c
operator|==
literal|0
operator|&&
name|hp
operator|->
name|rcode
operator|==
name|NOERROR
operator|&&
operator|!
operator|(
name|qp
operator|->
name|q_flags
operator|&
name|Q_SYSTEM
operator|)
condition|)
block|{
name|dprintf
argument_list|(
literal|4
argument_list|,
operator|(
name|ddt
operator|,
literal|"resp: leaving, no CNAME\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* Cause us to put it in the cache later */
name|prime
argument_list|(
name|class
argument_list|,
name|T_ANY
argument_list|,
name|qp
argument_list|)
expr_stmt|;
comment|/* Nothing to store, just give user the answer */
goto|goto
name|return_msg
goto|;
block|}
endif|#
directive|endif
comment|/* notdef */
name|nspp
operator|=
name|nsp
expr_stmt|;
if|if
condition|(
name|qp
operator|->
name|q_flags
operator|&
name|Q_SYSTEM
condition|)
name|dbflags
operator|=
name|DB_NOTAUTH
operator||
name|DB_NODATA
expr_stmt|;
else|else
name|dbflags
operator|=
name|DB_NOTAUTH
operator||
name|DB_NODATA
operator||
name|DB_NOHINTS
expr_stmt|;
name|count
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|tc
condition|)
block|{
name|count
operator|-=
name|arcount
expr_stmt|;
comment|/* truncation had to affect this */
if|if
condition|(
operator|!
name|arcount
condition|)
block|{
name|count
operator|-=
name|aucount
expr_stmt|;
comment|/* guess it got this too */
block|}
if|if
condition|(
operator|!
operator|(
name|arcount
operator|||
name|aucount
operator|)
condition|)
block|{
name|count
operator|-=
name|ancount
expr_stmt|;
comment|/* things are pretty grim */
block|}
comment|/* XXX - should retry this query with TCP */
block|}
ifdef|#
directive|ifdef
name|VALIDATE
name|tempcp
operator|=
name|cp
expr_stmt|;
name|validatelist
operator|=
operator|(
name|int
operator|*
operator|)
name|malloc
argument_list|(
name|count
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|lesscount
operator|=
literal|0
expr_stmt|;
comment|/*initialize*/
name|old_ancount
operator|=
name|ancount
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|int
name|VCode
decl_stmt|;
if|if
condition|(
name|tempcp
operator|>=
name|msg
operator|+
name|msglen
condition|)
block|{
name|formerrmsg
operator|=
name|outofDataFinal
expr_stmt|;
goto|goto
name|formerr
goto|;
block|}
if|if
condition|(
operator|(
name|n
operator|=
name|dovalidate
argument_list|(
operator|(
name|caddr_t
operator|)
name|msg
argument_list|,
name|msglen
argument_list|,
name|tempcp
argument_list|,
literal|0
argument_list|,
name|dbflags
argument_list|,
name|server
argument_list|,
operator|&
name|VCode
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"resp: leaving, dovalidate failed\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* return code filled in by dovalidate */
goto|goto
name|return_msg
goto|;
block|}
name|validatelist
index|[
name|i
index|]
operator|=
name|VCode
expr_stmt|;
if|if
condition|(
name|VCode
operator|==
name|INVALID
condition|)
name|lesscount
operator|++
expr_stmt|;
name|tempcp
operator|+=
name|n
expr_stmt|;
block|}
comment|/* need to delete INVALID records from the message 	 * and change fields appropriately 	 */
name|n
operator|=
name|update_msg
argument_list|(
name|msg
argument_list|,
operator|&
name|msglen
argument_list|,
name|validatelist
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|validatelist
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
goto|goto
name|formerr
goto|;
name|count
operator|-=
name|lesscount
expr_stmt|;
if|if
condition|(
name|old_ancount
operator|&&
operator|!
name|hp
operator|->
name|ancount
condition|)
block|{
comment|/* We lost all the answers */
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"validate count -> 0"
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|ancount
operator|<
operator|-
name|ntohs
argument_list|(
name|hp
operator|->
name|ancount
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|databuf
modifier|*
name|ns3
decl_stmt|;
ifdef|#
directive|ifdef
name|CRED
name|u_char
name|cred
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|cp
operator|>=
name|msg
operator|+
name|msglen
condition|)
block|{
name|formerrmsg
operator|=
name|outofDataFinal
expr_stmt|;
goto|goto
name|formerr
goto|;
block|}
ifdef|#
directive|ifdef
name|CRED
if|if
condition|(
name|i
operator|<
name|ancount
condition|)
block|{
name|cred
operator|=
name|hp
operator|->
name|aa
condition|?
name|DB_C_AUTH
else|:
name|DB_C_ANSWER
expr_stmt|;
block|}
else|else
block|{
name|cred
operator|=
name|DB_C_ADDITIONAL
expr_stmt|;
block|}
endif|#
directive|endif
name|ns3
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
name|doupdate
argument_list|(
operator|(
name|caddr_t
operator|)
name|msg
argument_list|,
name|msglen
argument_list|,
name|cp
argument_list|,
literal|0
argument_list|,
operator|&
name|ns3
argument_list|,
name|dbflags
ifdef|#
directive|ifdef
name|CRED
argument_list|,
name|cred
endif|#
directive|endif
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"resp: leaving, doupdate failed\n"
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DATUMREFCNT
name|free_nsp
argument_list|(
name|nsp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* return code filled in by doupdate */
goto|goto
name|return_msg
goto|;
block|}
comment|/* 		 * Remember nameservers from the authority section 		 * for referrals. 		 * (This is usually overwritten by findns below(?). XXX 		 */
if|if
condition|(
name|ns3
operator|&&
name|i
operator|>=
name|ancount
operator|&&
name|i
operator|<
name|ancount
operator|+
name|aucount
operator|&&
name|nspp
operator|<
operator|&
name|nsp
index|[
name|NSMAX
operator|-
literal|1
index|]
condition|)
block|{
operator|*
name|nspp
operator|++
operator|=
name|ns3
expr_stmt|;
ifdef|#
directive|ifdef
name|DATUMREFCNT
name|ns3
operator|->
name|d_rcnt
operator|++
expr_stmt|;
operator|*
name|nspp
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
block|}
name|cp
operator|+=
name|n
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|qp
operator|->
name|q_flags
operator|&
name|Q_SYSTEM
operator|)
operator|&&
name|ancount
condition|)
block|{
if|if
condition|(
name|qp
operator|->
name|q_flags
operator|&
name|Q_PRIMING
condition|)
name|check_root
argument_list|()
expr_stmt|;
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"resp: leaving, SYSQUERY ancount %d\n"
operator|,
name|ancount
operator|)
argument_list|)
expr_stmt|;
name|qremove
argument_list|(
name|qp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DATUMREFCNT
name|free_nsp
argument_list|(
name|nsp
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
if|if
condition|(
name|cp
operator|>
name|msg
operator|+
name|msglen
condition|)
block|{
name|formerrmsg
operator|=
name|outofDataAFinal
expr_stmt|;
goto|goto
name|formerr
goto|;
block|}
comment|/* 	 *  If there are addresses and this is a local query, 	 *  sort them appropriately for the local context. 	 */
if|if
condition|(
name|ancount
operator|>
literal|1
operator|&&
operator|(
name|lp
operator|=
name|local
argument_list|(
operator|&
name|qp
operator|->
name|q_from
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|sort_response
argument_list|(
operator|(
name|caddr_t
operator|)
name|tp
argument_list|,
name|ancount
argument_list|,
name|lp
argument_list|,
name|msg
operator|+
name|msglen
argument_list|)
expr_stmt|;
comment|/* 	 * An answer to a T_ANY query or a successful answer to a 	 * regular query with no indirection, then just return answer. 	 */
if|if
condition|(
operator|(
name|hp
operator|->
name|qdcount
operator|&&
name|type
operator|==
name|T_ANY
operator|&&
name|ancount
operator|)
operator|||
operator|(
operator|!
name|cname
operator|&&
operator|!
name|qp
operator|->
name|q_cmsglen
operator|&&
name|ancount
operator|)
condition|)
block|{
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"resp: got as much answer as there is\n"
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|return_msg
goto|;
block|}
comment|/* 	 * Eventually we will want to cache this negative answer. 	 */
if|if
condition|(
name|ancount
operator|==
literal|0
operator|&&
name|nscount
operator|==
literal|0
operator|&&
operator|(
name|hp
operator|->
name|aa
operator|||
name|fwd
operator|||
name|class
operator|==
name|C_ANY
operator|)
condition|)
block|{
comment|/* We have an authoritative NO */
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"resp: leaving auth NO\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|qp
operator|->
name|q_cmsglen
condition|)
block|{
name|msg
operator|=
operator|(
name|u_char
operator|*
operator|)
name|qp
operator|->
name|q_cmsg
expr_stmt|;
name|msglen
operator|=
name|qp
operator|->
name|q_cmsglen
expr_stmt|;
name|hp
operator|=
operator|(
name|HEADER
operator|*
operator|)
name|msg
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|NCACHE
comment|/*answer was an authoritative NO,*/
if|if
condition|(
operator|(
name|ancount
operator|==
literal|0
operator|)
operator|&&
operator|(
name|hp
operator|->
name|aa
operator|)
operator|&&
operator|(
operator|(
name|hp
operator|->
name|rcode
operator|==
name|NXDOMAIN
operator|)
operator|||
operator|(
name|hp
operator|->
name|rcode
operator|==
name|NOERROR
operator|)
operator|)
condition|)
block|{
name|cache_n_resp
argument_list|(
name|msg
argument_list|,
name|msglen
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/*NCACHE*/
goto|goto
name|return_msg
goto|;
block|}
comment|/* 	 * All messages in here need further processing.  i.e. they 	 * are either CNAMEs or we got referred again. 	 */
name|count
operator|=
literal|0
expr_stmt|;
name|founddata
operator|=
literal|0
expr_stmt|;
name|foundname
operator|=
literal|0
expr_stmt|;
name|dname
operator|=
name|name
expr_stmt|;
if|if
condition|(
operator|!
name|cname
operator|&&
name|qp
operator|->
name|q_cmsglen
operator|&&
name|ancount
condition|)
block|{
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"Cname second pass\n"
operator|)
argument_list|)
expr_stmt|;
name|newmsglen
operator|=
name|qp
operator|->
name|q_cmsglen
expr_stmt|;
name|bcopy
argument_list|(
name|qp
operator|->
name|q_cmsg
argument_list|,
name|newmsg
argument_list|,
name|newmsglen
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|newmsglen
operator|=
name|msglen
expr_stmt|;
name|bcopy
argument_list|(
name|msg
argument_list|,
name|newmsg
argument_list|,
name|newmsglen
argument_list|)
expr_stmt|;
block|}
name|hp
operator|=
operator|(
name|HEADER
operator|*
operator|)
name|newmsg
expr_stmt|;
name|hp
operator|->
name|ancount
operator|=
literal|0
expr_stmt|;
name|hp
operator|->
name|nscount
operator|=
literal|0
expr_stmt|;
name|hp
operator|->
name|arcount
operator|=
literal|0
expr_stmt|;
name|dnptrs
index|[
literal|0
index|]
operator|=
name|newmsg
expr_stmt|;
name|dnptrs
index|[
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
name|cp
operator|=
name|newmsg
operator|+
sizeof|sizeof
argument_list|(
name|HEADER
argument_list|)
expr_stmt|;
if|if
condition|(
name|cname
condition|)
name|cp
operator|+=
name|dn_skipname
argument_list|(
name|cp
argument_list|,
name|newmsg
operator|+
name|newmsglen
argument_list|)
operator|+
name|QFIXEDSZ
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
name|dn_expand
argument_list|(
name|newmsg
argument_list|,
name|newmsg
operator|+
name|newmsglen
argument_list|,
name|cp
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|dname
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"dn_expand failed\n"
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|servfail
goto|;
block|}
if|if
condition|(
operator|!
name|cname
condition|)
name|cp
operator|+=
name|n
operator|+
name|QFIXEDSZ
expr_stmt|;
name|buflen
operator|=
sizeof|sizeof
argument_list|(
name|newmsg
argument_list|)
operator|-
operator|(
name|cp
operator|-
name|newmsg
operator|)
expr_stmt|;
name|try_again
label|:
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"resp: nlookup(%s) type=%d\n"
operator|,
name|dname
operator|,
name|type
operator|)
argument_list|)
expr_stmt|;
name|fname
operator|=
literal|""
expr_stmt|;
name|htp
operator|=
name|hashtab
expr_stmt|;
comment|/* lookup relative to root */
name|np
operator|=
name|nlookup
argument_list|(
name|dname
argument_list|,
operator|&
name|htp
argument_list|,
operator|&
name|fname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"resp: %s '%s' as '%s' (cname=%d)\n"
operator|,
name|np
operator|==
name|NULL
condition|?
literal|"missed"
else|:
literal|"found"
operator|,
name|dname
operator|,
name|fname
operator|,
name|cname
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|==
name|NULL
operator|||
name|fname
operator|!=
name|dname
condition|)
goto|goto
name|fetch_ns
goto|;
name|foundname
operator|++
expr_stmt|;
name|count
operator|=
name|cp
operator|-
name|newmsg
expr_stmt|;
name|n
operator|=
name|finddata
argument_list|(
name|np
argument_list|,
name|class
argument_list|,
name|type
argument_list|,
name|hp
argument_list|,
operator|&
name|dname
argument_list|,
operator|&
name|buflen
argument_list|,
operator|&
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
goto|goto
name|fetch_ns
goto|;
comment|/* NO data available */
name|cp
operator|+=
name|n
expr_stmt|;
name|buflen
operator|-=
name|n
expr_stmt|;
name|hp
operator|->
name|ancount
operator|+=
name|count
expr_stmt|;
if|if
condition|(
name|fname
operator|!=
name|dname
operator|&&
name|type
operator|!=
name|T_CNAME
operator|&&
name|type
operator|!=
name|T_ANY
condition|)
block|{
name|cname
operator|++
expr_stmt|;
goto|goto
name|try_again
goto|;
block|}
name|founddata
operator|=
literal|1
expr_stmt|;
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"resp: foundname=%d, count=%d, founddata=%d, cname=%d\n"
operator|,
name|foundname
operator|,
name|count
operator|,
name|founddata
operator|,
name|cname
operator|)
argument_list|)
expr_stmt|;
name|fetch_ns
label|:
name|hp
operator|->
name|ancount
operator|=
name|htons
argument_list|(
name|hp
operator|->
name|ancount
argument_list|)
expr_stmt|;
comment|/*  	 * Look for name servers to refer to and fill in the authority  	 * section or record the address for forwarding the query  	 * (recursion desired).  	 */
ifdef|#
directive|ifdef
name|DATUMREFCNT
name|free_nsp
argument_list|(
name|nsp
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|findns
argument_list|(
operator|&
name|np
argument_list|,
name|class
argument_list|,
name|nsp
argument_list|,
operator|&
name|count
argument_list|,
literal|0
argument_list|)
condition|)
block|{
case|case
name|NXDOMAIN
case|:
comment|/* shouldn't happen */
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"req: leaving (%s, rcode %d)\n"
operator|,
name|dname
operator|,
name|hp
operator|->
name|rcode
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|foundname
condition|)
name|hp
operator|->
name|rcode
operator|=
name|NXDOMAIN
expr_stmt|;
if|if
condition|(
name|class
operator|!=
name|C_ANY
condition|)
block|{
name|hp
operator|->
name|aa
operator|=
literal|1
expr_stmt|;
comment|/* 			 * should return SOA if founddata == 0, 			 * but old named's are confused by an SOA 			 * in the auth. section if there's no error. 			 */
if|if
condition|(
name|foundname
operator|==
literal|0
operator|&&
name|np
condition|)
block|{
name|n
operator|=
name|doaddauth
argument_list|(
name|hp
argument_list|,
name|cp
argument_list|,
name|buflen
argument_list|,
name|np
argument_list|,
name|nsp
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
name|buflen
operator|-=
name|n
expr_stmt|;
block|}
block|}
goto|goto
name|return_newmsg
goto|;
case|case
name|SERVFAIL
case|:
goto|goto
name|servfail
goto|;
block|}
if|if
condition|(
name|founddata
condition|)
block|{
name|hp
operator|=
operator|(
name|HEADER
operator|*
operator|)
name|newmsg
expr_stmt|;
name|n
operator|=
name|add_data
argument_list|(
name|np
argument_list|,
name|nsp
argument_list|,
name|cp
argument_list|,
name|buflen
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|hp
operator|->
name|tc
operator|=
literal|1
expr_stmt|;
name|n
operator|=
operator|(
operator|-
name|n
operator|)
expr_stmt|;
block|}
name|cp
operator|+=
name|n
expr_stmt|;
name|buflen
operator|-=
name|n
expr_stmt|;
name|hp
operator|->
name|nscount
operator|=
name|htons
argument_list|(
operator|(
name|u_int16_t
operator|)
name|count
argument_list|)
expr_stmt|;
goto|goto
name|return_newmsg
goto|;
block|}
comment|/* 	 *  If we get here, we don't have the answer yet and are about 	 *  to iterate to try and get it.  First, infinite loop avoidance. 	 */
if|if
condition|(
name|qp
operator|->
name|q_nqueries
operator|++
operator|>
name|MAXQUERIES
condition|)
block|{
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"resp: MAXQUERIES exceeded (%s, class %d, type %d)\n"
operator|,
name|dname
operator|,
name|class
operator|,
name|type
operator|)
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"MAXQUERIES exceeded, possible data loop in resolving (%s)"
argument_list|,
name|dname
argument_list|)
expr_stmt|;
goto|goto
name|servfail
goto|;
block|}
comment|/* Reset the query control structure */
ifdef|#
directive|ifdef
name|DATUMREFCNT
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|qp
operator|->
name|q_naddr
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|--
operator|(
name|qp
operator|->
name|q_addr
index|[
name|i
index|]
operator|.
name|ns
operator|->
name|d_rcnt
operator|)
operator|)
condition|)
block|{
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"ns_resp: ns %s rcnt %d\n"
operator|,
name|qp
operator|->
name|q_addr
index|[
name|i
index|]
operator|.
name|ns
operator|->
name|d_data
operator|,
name|qp
operator|->
name|q_addr
index|[
name|i
index|]
operator|.
name|ns
operator|->
name|d_rcnt
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"ns_resp: ns %s rcnt %d delayed\n"
operator|,
name|qp
operator|->
name|q_addr
index|[
name|i
index|]
operator|.
name|ns
operator|->
name|d_data
operator|,
name|qp
operator|->
name|q_addr
index|[
name|i
index|]
operator|.
name|ns
operator|->
name|d_rcnt
operator|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|qp
operator|->
name|q_addr
index|[
name|i
index|]
operator|.
name|ns
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|--
operator|(
name|qp
operator|->
name|q_addr
index|[
name|i
index|]
operator|.
name|nsdata
operator|->
name|d_rcnt
operator|)
operator|)
condition|)
block|{
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"ns_resp: nsdata %08.8X rcnt %d\n"
operator|,
operator|*
operator|(
name|int32_t
operator|*
operator|)
operator|(
name|qp
operator|->
name|q_addr
index|[
name|i
index|]
operator|.
name|nsdata
operator|->
name|d_data
operator|)
operator|,
name|qp
operator|->
name|q_addr
index|[
name|i
index|]
operator|.
name|nsdata
operator|->
name|d_rcnt
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"ns_resp: nsdata %08.8X rcnt %d delayed\n"
operator|,
operator|*
operator|(
name|int32_t
operator|*
operator|)
operator|(
name|qp
operator|->
name|q_addr
index|[
name|i
index|]
operator|.
name|nsdata
operator|->
name|d_data
operator|)
operator|,
name|qp
operator|->
name|q_addr
index|[
name|i
index|]
operator|.
name|nsdata
operator|->
name|d_rcnt
operator|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|qp
operator|->
name|q_addr
index|[
name|i
index|]
operator|.
name|nsdata
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|qp
operator|->
name|q_naddr
operator|=
literal|0
expr_stmt|;
name|qp
operator|->
name|q_curaddr
operator|=
literal|0
expr_stmt|;
name|qp
operator|->
name|q_fwd
operator|=
name|fwdtab
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
name|nslookup
argument_list|(
name|nsp
argument_list|,
name|qp
argument_list|,
name|dname
argument_list|,
literal|"ns_resp"
argument_list|)
operator|)
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"resp: nslookup reports danger\n"
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"resp: no addrs found for NS's\n"
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cname
condition|)
comment|/* a remote CNAME that does not have data */
goto|goto
name|return_newmsg
goto|;
goto|goto
name|servfail
goto|;
block|}
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|qp
operator|->
name|q_naddr
condition|;
name|n
operator|++
control|)
name|qp
operator|->
name|q_addr
index|[
name|n
index|]
operator|.
name|stime
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|qp
operator|->
name|q_fwd
condition|)
name|qp
operator|->
name|q_addr
index|[
literal|0
index|]
operator|.
name|stime
operator|=
name|tt
expr_stmt|;
if|if
condition|(
name|cname
condition|)
block|{
if|if
condition|(
name|qp
operator|->
name|q_cname
operator|++
operator|==
name|MAXCNAMES
condition|)
block|{
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"resp: leaving, MAXCNAMES exceeded\n"
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|servfail
goto|;
block|}
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"q_cname = %d\n"
operator|,
name|qp
operator|->
name|q_cname
operator|)
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"resp: building recursive query; nslookup\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|qp
operator|->
name|q_msg
condition|)
operator|(
name|void
operator|)
name|free
argument_list|(
name|qp
operator|->
name|q_msg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|qp
operator|->
name|q_msg
operator|=
name|malloc
argument_list|(
name|BUFSIZ
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"resp: malloc error\n"
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|servfail
goto|;
block|}
name|qp
operator|->
name|q_msglen
operator|=
name|res_mkquery
argument_list|(
name|QUERY
argument_list|,
name|dname
argument_list|,
name|class
argument_list|,
name|type
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|qp
operator|->
name|q_msg
argument_list|,
name|BUFSIZ
argument_list|)
expr_stmt|;
name|hp
operator|=
operator|(
name|HEADER
operator|*
operator|)
name|qp
operator|->
name|q_msg
expr_stmt|;
name|hp
operator|->
name|rd
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|hp
operator|=
operator|(
name|HEADER
operator|*
operator|)
name|qp
operator|->
name|q_msg
expr_stmt|;
name|hp
operator|->
name|id
operator|=
name|qp
operator|->
name|q_nsid
operator|=
name|htons
argument_list|(
operator|(
name|u_int16_t
operator|)
operator|++
name|nsid
argument_list|)
expr_stmt|;
if|if
condition|(
name|qp
operator|->
name|q_fwd
condition|)
name|hp
operator|->
name|rd
operator|=
literal|1
expr_stmt|;
name|unsched
argument_list|(
name|qp
argument_list|)
expr_stmt|;
name|schedretry
argument_list|(
name|qp
argument_list|,
name|retrytime
argument_list|(
name|qp
argument_list|)
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"resp: forw -> [%s].%d ds=%d nsid=%d id=%d %dms\n"
operator|,
name|inet_ntoa
argument_list|(
name|Q_NEXTADDR
argument_list|(
name|qp
argument_list|,
literal|0
argument_list|)
operator|->
name|sin_addr
argument_list|)
operator|,
name|ntohs
argument_list|(
name|Q_NEXTADDR
argument_list|(
name|qp
argument_list|,
literal|0
argument_list|)
operator|->
name|sin_port
argument_list|)
operator|,
name|ds
operator|,
name|ntohs
argument_list|(
name|qp
operator|->
name|q_nsid
argument_list|)
operator|,
name|ntohs
argument_list|(
name|qp
operator|->
name|q_id
argument_list|)
operator|,
operator|(
name|qp
operator|->
name|q_addr
index|[
literal|0
index|]
operator|.
name|nsdata
operator|!=
name|NULL
operator|)
condition|?
name|qp
operator|->
name|q_addr
index|[
literal|0
index|]
operator|.
name|nsdata
operator|->
name|d_nstime
else|:
operator|(
operator|-
literal|1
operator|)
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>=
literal|10
condition|)
name|fp_query
argument_list|(
operator|(
name|char
operator|*
operator|)
name|msg
argument_list|,
name|ddt
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|sendto
argument_list|(
name|ds
argument_list|,
name|qp
operator|->
name|q_msg
argument_list|,
name|qp
operator|->
name|q_msglen
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|Q_NEXTADDR
argument_list|(
name|qp
argument_list|,
literal|0
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|dprintf
argument_list|(
literal|5
argument_list|,
operator|(
name|ddt
operator|,
literal|"sendto error = %d\n"
operator|,
name|errno
operator|)
argument_list|)
expr_stmt|;
block|}
name|hp
operator|->
name|rd
operator|=
literal|0
expr_stmt|;
comment|/* leave set to 0 for dup detection */
name|stats
index|[
name|S_OUTPKTS
index|]
operator|.
name|cnt
operator|++
expr_stmt|;
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"resp: Query sent.\n"
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DATUMREFCNT
name|free_nsp
argument_list|(
name|nsp
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
name|formerr
label|:
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"FORMERR resp() from [%s].%d size err %d, msglen %d\n"
operator|,
name|inet_ntoa
argument_list|(
name|from_addr
operator|.
name|sin_addr
argument_list|)
operator|,
name|ntohs
argument_list|(
name|from_addr
operator|.
name|sin_port
argument_list|)
operator|,
name|cp
operator|-
name|msg
operator|,
name|msglen
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|haveComplained
argument_list|(
operator|(
name|char
operator|*
operator|)
name|from_addr
operator|.
name|sin_addr
operator|.
name|s_addr
argument_list|,
operator|(
name|char
operator|*
operator|)
name|dhash
argument_list|(
operator|(
name|u_char
operator|*
operator|)
name|formerrmsg
argument_list|,
name|strlen
argument_list|(
name|formerrmsg
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"Malformed response from [%s].%d (%s)\n"
argument_list|,
name|inet_ntoa
argument_list|(
name|from_addr
operator|.
name|sin_addr
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|from_addr
operator|.
name|sin_port
argument_list|)
argument_list|,
name|formerrmsg
argument_list|)
expr_stmt|;
block|}
name|stats
index|[
name|S_RESPFORMERR
index|]
operator|.
name|cnt
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|DATUMREFCNT
name|free_nsp
argument_list|(
name|nsp
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
name|return_msg
label|:
name|stats
index|[
name|S_RESPOK
index|]
operator|.
name|cnt
operator|++
expr_stmt|;
comment|/* The "standard" return code */
name|hp
operator|->
name|qr
operator|=
literal|1
expr_stmt|;
name|hp
operator|->
name|id
operator|=
name|qp
operator|->
name|q_id
expr_stmt|;
name|hp
operator|->
name|rd
operator|=
literal|1
expr_stmt|;
name|hp
operator|->
name|ra
operator|=
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|send_msg
argument_list|(
operator|(
name|caddr_t
operator|)
name|msg
argument_list|,
name|msglen
argument_list|,
name|qp
argument_list|)
expr_stmt|;
name|qremove
argument_list|(
name|qp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DATUMREFCNT
name|free_nsp
argument_list|(
name|nsp
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
name|return_newmsg
label|:
name|stats
index|[
name|S_RESPOK
index|]
operator|.
name|cnt
operator|++
expr_stmt|;
if|if
condition|(
name|addcount
condition|)
block|{
name|n
operator|=
name|doaddinfo
argument_list|(
name|hp
argument_list|,
name|cp
argument_list|,
name|buflen
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
name|buflen
operator|-=
name|n
expr_stmt|;
block|}
name|hp
operator|->
name|id
operator|=
name|qp
operator|->
name|q_id
expr_stmt|;
name|hp
operator|->
name|rd
operator|=
literal|1
expr_stmt|;
name|hp
operator|->
name|ra
operator|=
literal|1
expr_stmt|;
name|hp
operator|->
name|qr
operator|=
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|send_msg
argument_list|(
operator|(
name|caddr_t
operator|)
name|newmsg
argument_list|,
name|cp
operator|-
name|newmsg
argument_list|,
name|qp
argument_list|)
expr_stmt|;
name|qremove
argument_list|(
name|qp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DATUMREFCNT
name|free_nsp
argument_list|(
name|nsp
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
name|servfail
label|:
name|stats
index|[
name|S_RESPFAIL
index|]
operator|.
name|cnt
operator|++
expr_stmt|;
name|hp
operator|=
operator|(
name|HEADER
operator|*
operator|)
operator|(
name|cname
condition|?
name|qp
operator|->
name|q_cmsg
else|:
name|qp
operator|->
name|q_msg
operator|)
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|SERVFAIL
expr_stmt|;
name|hp
operator|->
name|id
operator|=
name|qp
operator|->
name|q_id
expr_stmt|;
name|hp
operator|->
name|rd
operator|=
literal|1
expr_stmt|;
name|hp
operator|->
name|ra
operator|=
literal|1
expr_stmt|;
name|hp
operator|->
name|qr
operator|=
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|send_msg
argument_list|(
operator|(
name|char
operator|*
operator|)
name|hp
argument_list|,
operator|(
name|cname
condition|?
name|qp
operator|->
name|q_cmsglen
else|:
name|qp
operator|->
name|q_msglen
operator|)
argument_list|,
name|qp
argument_list|)
expr_stmt|;
name|qremove
argument_list|(
name|qp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DATUMREFCNT
name|free_nsp
argument_list|(
name|nsp
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
end_function

begin_comment
comment|/*  * Decode the resource record 'rrp' and update the database.  * If savens is non-nil, record pointer for forwarding queries a second time.  */
end_comment

begin_function
name|int
name|doupdate
parameter_list|(
name|msg
parameter_list|,
name|msglen
parameter_list|,
name|rrp
parameter_list|,
name|zone
parameter_list|,
name|savens
parameter_list|,
name|flags
ifdef|#
directive|ifdef
name|CRED
parameter_list|,
name|cred
endif|#
directive|endif
parameter_list|)
name|char
modifier|*
name|msg
decl_stmt|;
name|u_char
modifier|*
name|rrp
decl_stmt|;
name|struct
name|databuf
modifier|*
modifier|*
name|savens
decl_stmt|;
name|int
name|msglen
decl_stmt|,
name|zone
decl_stmt|,
name|flags
decl_stmt|;
ifdef|#
directive|ifdef
name|CRED
name|u_int
name|cred
decl_stmt|;
endif|#
directive|endif
block|{
specifier|register
name|u_char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
name|int
name|class
decl_stmt|,
name|type
decl_stmt|,
name|dlen
decl_stmt|,
name|n1
decl_stmt|;
name|u_int32_t
name|ttl
decl_stmt|;
name|struct
name|databuf
modifier|*
name|dp
decl_stmt|;
name|char
name|dname
index|[
name|MAXDNAME
index|]
decl_stmt|;
name|u_char
modifier|*
name|cp1
decl_stmt|;
name|u_char
name|data
index|[
name|BUFSIZ
index|]
decl_stmt|;
specifier|register
name|HEADER
modifier|*
name|hp
init|=
operator|(
name|HEADER
operator|*
operator|)
name|msg
decl_stmt|;
ifdef|#
directive|ifdef
name|ALLOW_UPDATES
name|int
name|zonenum
decl_stmt|;
endif|#
directive|endif
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"doupdate(zone %d, savens %x, flags %x)\n"
operator|,
name|zone
operator|,
name|savens
operator|,
name|flags
operator|)
argument_list|)
expr_stmt|;
name|cp
operator|=
name|rrp
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
name|dn_expand
argument_list|(
operator|(
name|u_char
operator|*
operator|)
name|msg
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|msg
operator|+
name|msglen
argument_list|,
name|cp
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|dname
argument_list|,
sizeof|sizeof
argument_list|(
name|dname
argument_list|)
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|cp
operator|+=
name|n
expr_stmt|;
name|GETSHORT
argument_list|(
name|type
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|GETSHORT
argument_list|(
name|class
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|GETLONG
argument_list|(
name|ttl
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|GETSHORT
argument_list|(
name|dlen
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"doupdate: dname %s type %d class %d ttl %d\n"
operator|,
name|dname
operator|,
name|type
operator|,
name|class
operator|,
name|ttl
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Convert the resource record data into the internal 	 * database format. 	 */
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|T_A
case|:
case|case
name|T_WKS
case|:
case|case
name|T_HINFO
case|:
case|case
name|T_UINFO
case|:
case|case
name|T_UID
case|:
case|case
name|T_GID
case|:
case|case
name|T_TXT
case|:
ifdef|#
directive|ifdef
name|ALLOW_T_UNSPEC
case|case
name|T_UNSPEC
case|:
endif|#
directive|endif
name|cp1
operator|=
name|cp
expr_stmt|;
name|n
operator|=
name|dlen
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
break|break;
case|case
name|T_CNAME
case|:
case|case
name|T_MB
case|:
case|case
name|T_MG
case|:
case|case
name|T_MR
case|:
case|case
name|T_NS
case|:
case|case
name|T_PTR
case|:
if|if
condition|(
operator|(
name|n
operator|=
name|dn_expand
argument_list|(
operator|(
name|u_char
operator|*
operator|)
name|msg
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|msg
operator|+
name|msglen
argument_list|,
name|cp
argument_list|,
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|data
argument_list|)
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|cp
operator|+=
name|n
expr_stmt|;
name|cp1
operator|=
name|data
expr_stmt|;
name|n
operator|=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|data
argument_list|)
operator|+
literal|1
expr_stmt|;
break|break;
case|case
name|T_MINFO
case|:
case|case
name|T_SOA
case|:
case|case
name|T_RP
case|:
if|if
condition|(
operator|(
name|n
operator|=
name|dn_expand
argument_list|(
operator|(
name|u_char
operator|*
operator|)
name|msg
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|msg
operator|+
name|msglen
argument_list|,
name|cp
argument_list|,
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|data
argument_list|)
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|cp
operator|+=
name|n
expr_stmt|;
name|cp1
operator|=
name|data
operator|+
operator|(
name|n
operator|=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|data
argument_list|)
operator|+
literal|1
operator|)
expr_stmt|;
name|n1
operator|=
sizeof|sizeof
argument_list|(
name|data
argument_list|)
operator|-
name|n
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|T_SOA
condition|)
name|n1
operator|-=
literal|5
operator|*
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
name|dn_expand
argument_list|(
operator|(
name|u_char
operator|*
operator|)
name|msg
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|msg
operator|+
name|msglen
argument_list|,
name|cp
argument_list|,
name|cp1
argument_list|,
name|n1
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|cp
operator|+=
name|n
expr_stmt|;
name|cp1
operator|+=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp1
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|T_SOA
condition|)
block|{
name|bcopy
argument_list|(
name|cp
argument_list|,
name|cp1
argument_list|,
name|n
operator|=
literal|5
operator|*
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
name|cp1
operator|+=
name|n
expr_stmt|;
block|}
name|n
operator|=
name|cp1
operator|-
name|data
expr_stmt|;
name|cp1
operator|=
name|data
expr_stmt|;
break|break;
case|case
name|T_MX
case|:
case|case
name|T_AFSDB
case|:
comment|/* grab preference */
name|bcopy
argument_list|(
name|cp
argument_list|,
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|u_int16_t
argument_list|)
argument_list|)
expr_stmt|;
name|cp1
operator|=
name|data
operator|+
sizeof|sizeof
argument_list|(
name|u_int16_t
argument_list|)
expr_stmt|;
name|cp
operator|+=
sizeof|sizeof
argument_list|(
name|u_int16_t
argument_list|)
expr_stmt|;
comment|/* get name */
if|if
condition|(
operator|(
name|n
operator|=
name|dn_expand
argument_list|(
operator|(
name|u_char
operator|*
operator|)
name|msg
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|msg
operator|+
name|msglen
argument_list|,
name|cp
argument_list|,
name|cp1
argument_list|,
sizeof|sizeof
argument_list|(
name|data
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|u_int16_t
argument_list|)
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|cp
operator|+=
name|n
expr_stmt|;
comment|/* compute end of data */
name|cp1
operator|+=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp1
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* compute size of data */
name|n
operator|=
name|cp1
operator|-
name|data
expr_stmt|;
name|cp1
operator|=
name|data
expr_stmt|;
break|break;
default|default:
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"unknown type %d\n"
operator|,
name|type
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|cp
operator|-
name|rrp
operator|)
operator|+
name|dlen
operator|)
return|;
block|}
if|if
condition|(
name|n
operator|>
name|MAXDATA
condition|)
block|{
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"update type %d: %d bytes is too much data\n"
operator|,
name|type
operator|,
name|n
operator|)
argument_list|)
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|NOCHANGE
expr_stmt|;
comment|/* XXX - FORMERR ??? */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|ALLOW_UPDATES
comment|/* 	 * If this is a dynamic update request, process it specially; else, 	 * execute normal update code. 	 */
switch|switch
condition|(
name|hp
operator|->
name|opcode
condition|)
block|{
comment|/* For UPDATEM and UPDATEMA, do UPDATED/UPDATEDA followed by UPDATEA */
case|case
name|UPDATEM
case|:
case|case
name|UPDATEMA
case|:
comment|/* 	 * The named code for UPDATED and UPDATEDA is the same except that for 	 * UPDATEDA we we ignore any data that was passed: we just delete all 	 * RRs whose name, type, and class matches 	 */
case|case
name|UPDATED
case|:
case|case
name|UPDATEDA
case|:
if|if
condition|(
name|type
operator|==
name|T_SOA
condition|)
block|{
comment|/* Not allowed */
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"UDPATE: REFUSED - SOA delete\n"
operator|)
argument_list|)
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|REFUSED
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 		 * Don't check message length if doing UPDATEM/UPDATEMA, 		 * since the whole message wont have been demarshalled until 		 * we reach the code for UPDATEA 		 */
if|if
condition|(
operator|(
name|hp
operator|->
name|opcode
operator|==
name|UPDATED
operator|)
operator|||
operator|(
name|hp
operator|->
name|opcode
operator|==
name|UPDATEDA
operator|)
condition|)
block|{
if|if
condition|(
name|cp
operator|!=
operator|(
name|u_char
operator|*
operator|)
operator|(
name|msg
operator|+
name|msglen
operator|)
condition|)
block|{
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"FORMERR UPDATE message length off\n"
operator|)
argument_list|)
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
if|if
condition|(
operator|(
name|zonenum
operator|=
name|findzone
argument_list|(
name|dname
argument_list|,
name|class
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|hp
operator|->
name|rcode
operator|=
name|NXDOMAIN
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|zones
index|[
name|zonenum
index|]
operator|.
name|z_state
operator|&
name|Z_DYNADDONLY
condition|)
block|{
name|hp
operator|->
name|rcode
operator|=
name|NXDOMAIN
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|hp
operator|->
name|opcode
operator|==
name|UPDATED
operator|)
operator|||
operator|(
name|hp
operator|->
name|opcode
operator|==
name|UPDATEM
operator|)
condition|)
block|{
comment|/* Make a dp for use in db_update, as old dp */
name|dp
operator|=
name|savedata
argument_list|(
name|class
argument_list|,
name|type
argument_list|,
literal|0
argument_list|,
name|cp1
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|dp
operator|->
name|d_zone
operator|=
name|zonenum
expr_stmt|;
ifdef|#
directive|ifdef
name|CRED
name|dp
operator|->
name|d_cred
operator|=
name|cred
expr_stmt|;
name|dp
operator|->
name|d_clev
operator|=
name|db_getclev
argument_list|(
name|zones
index|[
name|zonenum
index|]
operator|.
name|z_origin
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|n
operator|=
name|db_update
argument_list|(
name|dname
argument_list|,
name|dp
argument_list|,
name|NULL
argument_list|,
name|DB_MEXIST
operator||
name|DB_DELETE
argument_list|,
name|hashtab
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|!=
name|OK
condition|)
block|{
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"UPDATE: db_update failed\n"
operator|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dp
argument_list|)
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|NOCHANGE
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
else|else
block|{
comment|/* UPDATEDA or UPDATEMA */
name|int
name|DeletedOne
init|=
literal|0
decl_stmt|;
comment|/* Make a dp for use in db_update, as old dp */
name|dp
operator|=
name|savedata
argument_list|(
name|class
argument_list|,
name|type
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dp
operator|->
name|d_zone
operator|=
name|zonenum
expr_stmt|;
ifdef|#
directive|ifdef
name|CRED
name|dp
operator|->
name|d_cred
operator|=
name|cred
expr_stmt|;
name|dp
operator|->
name|d_clev
operator|=
name|db_getclev
argument_list|(
name|zones
index|[
name|zonenum
index|]
operator|.
name|z_origin
argument_list|)
expr_stmt|;
endif|#
directive|endif
do|do
block|{
comment|/* Loop and delete all matching RR(s) */
name|n
operator|=
name|db_update
argument_list|(
name|dname
argument_list|,
name|dp
argument_list|,
name|NULL
argument_list|,
name|DB_DELETE
argument_list|,
name|hashtab
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|!=
name|OK
condition|)
break|break;
name|DeletedOne
operator|++
expr_stmt|;
block|}
do|while
condition|(
literal|1
condition|)
do|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dp
argument_list|)
expr_stmt|;
comment|/* Ok for UPDATEMA not to have deleted any RRs */
if|if
condition|(
operator|!
name|DeletedOne
operator|&&
name|hp
operator|->
name|opcode
operator|==
name|UPDATEDA
condition|)
block|{
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"UPDATE: db_update failed\n"
operator|)
argument_list|)
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|NOCHANGE
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
if|if
condition|(
operator|(
name|hp
operator|->
name|opcode
operator|==
name|UPDATED
operator|)
operator|||
operator|(
name|hp
operator|->
name|opcode
operator|==
name|UPDATEDA
operator|)
condition|)
return|return
operator|(
name|cp
operator|-
name|rrp
operator|)
return|;
empty_stmt|;
comment|/* 		 * Else unmarshal the RR to be added and continue on to 		 * UPDATEA code for UPDATEM/UPDATEMA 		 */
if|if
condition|(
operator|(
name|n
operator|=
name|dn_expand
argument_list|(
name|msg
argument_list|,
name|msg
operator|+
name|msglen
argument_list|,
name|cp
argument_list|,
name|dname
argument_list|,
sizeof|sizeof
argument_list|(
name|dname
argument_list|)
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"FORMERR UPDATE expand name failed\n"
operator|)
argument_list|)
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|cp
operator|+=
name|n
expr_stmt|;
name|GETSHORT
argument_list|(
name|type
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|GETSHORT
argument_list|(
name|class
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|GETLONG
argument_list|(
name|ttl
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|GETSHORT
argument_list|(
name|n
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|cp1
operator|=
name|cp
expr_stmt|;
comment|/**** XXX - need bounds checking here ****/
name|cp
operator|+=
name|n
expr_stmt|;
case|case
name|UPDATEA
case|:
if|if
condition|(
name|n
operator|>
name|MAXDATA
condition|)
block|{
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"UPDATE: too much data\n"
operator|)
argument_list|)
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|NOCHANGE
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|cp
operator|!=
operator|(
name|u_char
operator|*
operator|)
operator|(
name|msg
operator|+
name|msglen
operator|)
condition|)
block|{
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"FORMERR UPDATE message length off\n"
operator|)
argument_list|)
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|zonenum
operator|=
name|findzone
argument_list|(
name|dname
argument_list|,
name|class
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|hp
operator|->
name|rcode
operator|=
name|NXDOMAIN
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|zones
index|[
name|zonenum
index|]
operator|.
name|z_state
operator|&
name|Z_DYNADDONLY
condition|)
block|{
name|struct
name|hashbuf
modifier|*
name|htp
init|=
name|hashtab
decl_stmt|;
name|char
modifier|*
name|fname
decl_stmt|;
if|if
condition|(
name|nlookup
argument_list|(
name|dname
argument_list|,
operator|&
name|htp
argument_list|,
operator|&
name|fname
argument_list|,
literal|0
argument_list|)
operator|&&
operator|!
name|strcmp
argument_list|(
name|dname
argument_list|,
name|fname
argument_list|)
condition|)
block|{
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"refusing add of existing name\n"
operator|)
argument_list|)
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|REFUSED
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
name|dp
operator|=
name|savedata
argument_list|(
name|class
argument_list|,
name|type
argument_list|,
name|ttl
argument_list|,
name|cp1
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|dp
operator|->
name|d_zone
operator|=
name|zonenum
expr_stmt|;
ifdef|#
directive|ifdef
name|CRED
name|dp
operator|->
name|d_cred
operator|=
name|cred
expr_stmt|;
name|dp
operator|->
name|d_clev
operator|=
name|db_getclev
argument_list|(
name|zones
index|[
name|zonenum
index|]
operator|.
name|z_origin
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|n
operator|=
name|db_update
argument_list|(
name|dname
argument_list|,
name|NULL
argument_list|,
name|dp
argument_list|,
name|DB_NODATA
argument_list|,
name|hashtab
argument_list|)
operator|)
operator|!=
name|OK
condition|)
block|{
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"UPDATE: db_update failed\n"
operator|)
argument_list|)
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|NOCHANGE
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dp
argument_list|)
expr_stmt|;
comment|/* vix@dec mar92 */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
else|else
return|return
operator|(
name|cp
operator|-
name|rrp
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* ALLOW_UPDATES */
if|if
condition|(
name|zone
operator|==
literal|0
condition|)
name|ttl
operator|+=
name|tt
operator|.
name|tv_sec
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|TRACEROOT
argument_list|)
operator|||
name|defined
argument_list|(
name|BOGUSNS
argument_list|)
comment|/* 	 *  This is a variation on a theme which was posted by 	 *  pma@cnd.hp.com.  It not only records who is giving out 	 *  bogus root NS records, it also prevents them from  	 *  polluting our cache. 	 */
if|if
condition|(
operator|(
name|type
operator|==
name|T_NS
operator|)
operator|&&
operator|(
name|savens
operator|!=
name|NULL
operator|)
condition|)
block|{
name|char
name|qname
index|[
name|MAXDNAME
index|]
decl_stmt|,
modifier|*
name|temp
decl_stmt|;
name|int
name|bogus
init|=
literal|0
decl_stmt|,
name|qn
decl_stmt|;
ifdef|#
directive|ifdef
name|BOGUSNS
if|if
condition|(
name|net_on_netlist
argument_list|(
name|from_addr
operator|.
name|sin_addr
argument_list|,
name|boglist
argument_list|)
condition|)
name|bogus
operator|++
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|bogus
operator|&&
operator|(
operator|(
name|temp
operator|=
name|strrchr
argument_list|(
operator|(
name|char
operator|*
operator|)
name|data
argument_list|,
literal|'.'
argument_list|)
operator|)
operator|!=
name|NULL
operator|)
operator|&&
operator|!
name|strcasecmp
argument_list|(
name|temp
argument_list|,
literal|".arpa"
argument_list|)
condition|)
name|bogus
operator|++
expr_stmt|;
name|qname
index|[
literal|0
index|]
operator|=
name|qname
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|qn
operator|=
name|dn_expand
argument_list|(
operator|(
name|u_char
operator|*
operator|)
name|msg
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|msg
operator|+
name|msglen
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|msg
operator|+
sizeof|sizeof
argument_list|(
name|HEADER
argument_list|)
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|qname
argument_list|,
sizeof|sizeof
argument_list|(
name|qname
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|qn
operator|<
literal|0
condition|)
name|qname
index|[
literal|0
index|]
operator|=
literal|'?'
expr_stmt|;
elseif|else
if|if
condition|(
name|qname
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|qname
index|[
literal|0
index|]
operator|=
literal|'.'
expr_stmt|;
if|if
condition|(
name|bogus
operator|&&
operator|(
operator|(
name|dname
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|)
operator|&&
operator|(
name|zone
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
comment|/* We want the filtering but not (normally) the syslogging, since we are    occasionally plagued with multi-megabyte floods of syslog messages.    syslog call therefore replaced with dprintf call. */
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"Bogus root NS %s received from %s on query on name [%s] -- rejected\n"
operator|,
name|data
operator|,
name|inet_ntoa
argument_list|(
name|from_addr
operator|.
name|sin_addr
argument_list|)
operator|,
name|qname
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|cp
operator|-
name|rrp
operator|)
return|;
block|}
block|}
endif|#
directive|endif
comment|/*TRACEROOT || BOGUSNS*/
name|dp
operator|=
name|savedata
argument_list|(
name|class
argument_list|,
name|type
argument_list|,
name|ttl
argument_list|,
name|cp1
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|dp
operator|->
name|d_zone
operator|=
name|zone
expr_stmt|;
ifdef|#
directive|ifdef
name|CRED
name|dp
operator|->
name|d_cred
operator|=
name|cred
expr_stmt|;
name|dp
operator|->
name|d_clev
operator|=
literal|0
expr_stmt|;
comment|/* We trust what is on disk more, except root servers */
endif|#
directive|endif
if|if
condition|(
operator|(
name|n
operator|=
name|db_update
argument_list|(
name|dname
argument_list|,
name|dp
argument_list|,
name|dp
argument_list|,
name|flags
argument_list|,
name|hashtab
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|&&
operator|(
name|n
operator|!=
name|DATAEXISTS
operator|)
condition|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"update failed (%d)\n"
argument_list|,
name|n
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|debug
operator|>=
literal|3
condition|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"update failed (DATAEXISTS)\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|T_NS
operator|&&
name|savens
operator|!=
name|NULL
condition|)
operator|*
name|savens
operator|=
name|dp
expr_stmt|;
return|return
operator|(
name|cp
operator|-
name|rrp
operator|)
return|;
block|}
end_function

begin_function
name|int
name|send_msg
parameter_list|(
name|msg
parameter_list|,
name|msglen
parameter_list|,
name|qp
parameter_list|)
name|char
modifier|*
name|msg
decl_stmt|;
name|int
name|msglen
decl_stmt|;
name|struct
name|qinfo
modifier|*
name|qp
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|struct
name|qinfo
modifier|*
name|tqp
decl_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
if|if
condition|(
name|qp
operator|->
name|q_flags
operator|&
name|Q_SYSTEM
condition|)
return|return
operator|(
literal|1
operator|)
return|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
block|{
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"send_msg -> [%s] (%s %d %d) id=%d\n"
argument_list|,
name|inet_ntoa
argument_list|(
name|qp
operator|->
name|q_from
operator|.
name|sin_addr
argument_list|)
argument_list|,
name|qp
operator|->
name|q_stream
operator|==
name|QSTREAM_NULL
condition|?
literal|"UDP"
else|:
literal|"TCP"
argument_list|,
name|qp
operator|->
name|q_stream
operator|==
name|QSTREAM_NULL
condition|?
name|qp
operator|->
name|q_dfd
else|:
name|qp
operator|->
name|q_stream
operator|->
name|s_rfd
argument_list|,
name|ntohs
argument_list|(
name|qp
operator|->
name|q_from
operator|.
name|sin_port
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|qp
operator|->
name|q_id
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|debug
operator|>
literal|4
condition|)
for|for
control|(
name|tqp
operator|=
name|qhead
init|;
name|tqp
operator|!=
name|QINFO_NULL
condition|;
name|tqp
operator|=
name|tqp
operator|->
name|q_link
control|)
block|{
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"qp %x q_id: %d  q_nsid: %d q_msglen: %d "
argument_list|,
name|tqp
argument_list|,
name|tqp
operator|->
name|q_id
argument_list|,
name|tqp
operator|->
name|q_nsid
argument_list|,
name|tqp
operator|->
name|q_msglen
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"q_naddr: %d q_curaddr: %d\n"
argument_list|,
name|tqp
operator|->
name|q_naddr
argument_list|,
name|tqp
operator|->
name|q_curaddr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"q_next: %x q_link: %x\n"
argument_list|,
name|qp
operator|->
name|q_next
argument_list|,
name|qp
operator|->
name|q_link
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|debug
operator|>=
literal|10
condition|)
name|fp_query
argument_list|(
name|msg
argument_list|,
name|ddt
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
if|if
condition|(
name|qp
operator|->
name|q_stream
operator|==
name|QSTREAM_NULL
condition|)
block|{
if|if
condition|(
name|sendto
argument_list|(
name|qp
operator|->
name|q_dfd
argument_list|,
name|msg
argument_list|,
name|msglen
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|qp
operator|->
name|q_from
argument_list|,
sizeof|sizeof
argument_list|(
name|qp
operator|->
name|q_from
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"sendto error errno= %d\n"
operator|,
name|errno
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|stats
index|[
name|S_OUTPKTS
index|]
operator|.
name|cnt
operator|++
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|writemsg
argument_list|(
name|qp
operator|->
name|q_stream
operator|->
name|s_rfd
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|msg
argument_list|,
name|msglen
argument_list|)
expr_stmt|;
name|sq_done
argument_list|(
name|qp
operator|->
name|q_stream
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|notdef
end_ifdef

begin_comment
comment|/* i don't quite understand this but the only ref to it is notdef'd --vix */
end_comment

begin_macro
name|prime
argument_list|(
argument|class
argument_list|,
argument|type
argument_list|,
argument|oqp
argument_list|)
end_macro

begin_decl_stmt
name|int
name|class
decl_stmt|,
name|type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|qinfo
modifier|*
name|oqp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|dname
index|[
name|BUFSIZ
index|]
decl_stmt|;
if|if
condition|(
name|oqp
operator|->
name|q_msg
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|dn_expand
argument_list|(
operator|(
name|u_char
operator|*
operator|)
name|oqp
operator|->
name|q_msg
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|oqp
operator|->
name|q_msg
operator|+
name|oqp
operator|->
name|q_msglen
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|oqp
operator|->
name|q_msg
operator|+
sizeof|sizeof
argument_list|(
name|HEADER
argument_list|)
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|dname
argument_list|,
sizeof|sizeof
argument_list|(
name|dname
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
return|return;
name|dprintf
argument_list|(
literal|2
argument_list|,
operator|(
name|ddt
operator|,
literal|"prime: %s\n"
operator|,
name|dname
operator|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sysquery
argument_list|(
name|dname
argument_list|,
name|class
argument_list|,
name|type
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|prime_cache
parameter_list|()
block|{
specifier|register
name|struct
name|qinfo
modifier|*
name|qp
decl_stmt|;
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"prime_cache: priming = %d\n"
operator|,
name|priming
operator|)
argument_list|)
expr_stmt|;
name|stats
index|[
name|S_PRIMECACHE
index|]
operator|.
name|cnt
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|priming
operator|&&
name|fcachetab
operator|->
name|h_tab
index|[
literal|0
index|]
operator|!=
name|NULL
operator|&&
operator|!
name|forward_only
condition|)
block|{
name|priming
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|qp
operator|=
name|sysquery
argument_list|(
literal|""
argument_list|,
name|C_IN
argument_list|,
name|T_NS
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|priming
operator|=
literal|0
expr_stmt|;
else|else
name|qp
operator|->
name|q_flags
operator||=
operator|(
name|Q_SYSTEM
operator||
name|Q_PRIMING
operator|)
expr_stmt|;
block|}
name|needs_prime_cache
operator|=
literal|0
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|struct
name|qinfo
modifier|*
name|sysquery
parameter_list|(
name|dname
parameter_list|,
name|class
parameter_list|,
name|type
parameter_list|,
name|nss
parameter_list|,
name|nsc
parameter_list|)
name|char
modifier|*
name|dname
decl_stmt|;
name|int
name|class
decl_stmt|,
name|type
decl_stmt|;
name|struct
name|in_addr
modifier|*
name|nss
decl_stmt|;
name|int
name|nsc
decl_stmt|;
block|{
specifier|register
name|struct
name|qinfo
modifier|*
name|qp
decl_stmt|,
modifier|*
name|oqp
decl_stmt|;
specifier|register
name|HEADER
modifier|*
name|hp
decl_stmt|;
name|struct
name|namebuf
modifier|*
name|np
decl_stmt|;
name|struct
name|databuf
modifier|*
name|nsp
index|[
name|NSMAX
index|]
decl_stmt|;
name|struct
name|hashbuf
modifier|*
name|htp
decl_stmt|;
name|char
modifier|*
name|fname
decl_stmt|;
name|int
name|count
decl_stmt|;
ifdef|#
directive|ifdef
name|DATUMREFCNT
name|nsp
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"sysquery(%s, %d, %d, 0x%x, %d)\n"
operator|,
name|dname
operator|,
name|class
operator|,
name|type
operator|,
name|nss
operator|,
name|nsc
operator|)
argument_list|)
expr_stmt|;
name|stats
index|[
name|S_SYSQUERIES
index|]
operator|.
name|cnt
operator|++
expr_stmt|;
name|qp
operator|=
name|qnew
argument_list|()
expr_stmt|;
if|if
condition|(
name|nss
operator|&&
name|nsc
condition|)
block|{ 	}
else|else
block|{
name|htp
operator|=
name|hashtab
expr_stmt|;
if|if
condition|(
name|priming
operator|&&
name|dname
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
name|np
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|np
operator|=
name|nlookup
argument_list|(
name|dname
argument_list|,
operator|&
name|htp
argument_list|,
operator|&
name|fname
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"sysquery: nlookup error on %s?\n"
operator|,
name|dname
operator|)
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|qp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
switch|switch
condition|(
name|findns
argument_list|(
operator|&
name|np
argument_list|,
name|class
argument_list|,
name|nsp
argument_list|,
operator|&
name|count
argument_list|,
literal|0
argument_list|)
condition|)
block|{
case|case
name|NXDOMAIN
case|:
case|case
name|SERVFAIL
case|:
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"sysquery: findns error on %s?\n"
operator|,
name|dname
operator|)
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|qp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DATUMREFCNT
name|free_nsp
argument_list|(
name|nsp
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
comment|/* build new qinfo struct */
name|qp
operator|->
name|q_cmsg
operator|=
name|qp
operator|->
name|q_msg
operator|=
name|NULL
expr_stmt|;
name|qp
operator|->
name|q_dfd
operator|=
name|ds
expr_stmt|;
if|if
condition|(
name|nss
operator|&&
name|nsc
condition|)
name|qp
operator|->
name|q_fwd
operator|=
name|NULL
expr_stmt|;
else|else
name|qp
operator|->
name|q_fwd
operator|=
name|fwdtab
expr_stmt|;
name|qp
operator|->
name|q_expire
operator|=
name|tt
operator|.
name|tv_sec
operator|+
name|RETRY_TIMEOUT
operator|*
literal|2
expr_stmt|;
name|qp
operator|->
name|q_flags
operator||=
name|Q_SYSTEM
expr_stmt|;
if|if
condition|(
operator|(
name|qp
operator|->
name|q_msg
operator|=
name|malloc
argument_list|(
name|BUFSIZ
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|qfree
argument_list|(
name|qp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DATUMREFCNT
name|free_nsp
argument_list|(
name|nsp
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|qp
operator|->
name|q_msglen
operator|=
name|res_mkquery
argument_list|(
name|QUERY
argument_list|,
name|dname
argument_list|,
name|class
argument_list|,
name|type
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|qp
operator|->
name|q_msg
argument_list|,
name|BUFSIZ
argument_list|)
expr_stmt|;
name|hp
operator|=
operator|(
name|HEADER
operator|*
operator|)
name|qp
operator|->
name|q_msg
expr_stmt|;
name|hp
operator|->
name|id
operator|=
name|qp
operator|->
name|q_nsid
operator|=
name|htons
argument_list|(
operator|(
name|u_int16_t
operator|)
operator|++
name|nsid
argument_list|)
expr_stmt|;
name|hp
operator|->
name|rd
operator|=
operator|(
name|qp
operator|->
name|q_fwd
condition|?
literal|1
else|:
literal|0
operator|)
expr_stmt|;
comment|/* First check for an already pending query for this data */
for|for
control|(
name|oqp
operator|=
name|qhead
init|;
name|oqp
operator|!=
name|QINFO_NULL
condition|;
name|oqp
operator|=
name|oqp
operator|->
name|q_link
control|)
block|{
if|if
condition|(
operator|(
name|oqp
operator|!=
name|qp
operator|)
operator|&&
operator|(
name|oqp
operator|->
name|q_msglen
operator|==
name|qp
operator|->
name|q_msglen
operator|)
operator|&&
name|bcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|oqp
operator|->
name|q_msg
operator|+
literal|2
argument_list|,
name|qp
operator|->
name|q_msg
operator|+
literal|2
argument_list|,
name|qp
operator|->
name|q_msglen
operator|-
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"sysquery: duplicate\n"
operator|)
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|qp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DATUMREFCNT
name|free_nsp
argument_list|(
name|nsp
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
if|if
condition|(
name|nss
operator|&&
name|nsc
condition|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|qserv
modifier|*
name|qs
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|qs
operator|=
name|qp
operator|->
name|q_addr
init|;
name|i
operator|<
name|nsc
condition|;
name|i
operator|++
operator|,
name|qs
operator|++
control|)
block|{
name|qs
operator|->
name|ns_addr
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|qs
operator|->
name|ns_addr
operator|.
name|sin_addr
operator|=
name|nss
index|[
name|i
index|]
expr_stmt|;
name|qs
operator|->
name|ns_addr
operator|.
name|sin_port
operator|=
name|ns_port
expr_stmt|;
name|qs
operator|->
name|ns
operator|=
name|NULL
expr_stmt|;
name|qs
operator|->
name|nsdata
operator|=
name|NULL
expr_stmt|;
name|qs
operator|->
name|stime
operator|=
name|tt
expr_stmt|;
name|qs
operator|->
name|nretry
operator|=
literal|0
expr_stmt|;
block|}
name|qp
operator|->
name|q_naddr
operator|=
name|nsc
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|count
operator|=
name|nslookup
argument_list|(
name|nsp
argument_list|,
name|qp
argument_list|,
name|dname
argument_list|,
literal|"sysquery"
argument_list|)
operator|)
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|count
operator|<
literal|0
condition|)
block|{
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"sysquery: nslookup reports danger\n"
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"sysquery: no addrs found for NS's\n"
operator|)
argument_list|)
expr_stmt|;
block|}
name|qfree
argument_list|(
name|qp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DATUMREFCNT
name|free_nsp
argument_list|(
name|nsp
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
name|schedretry
argument_list|(
name|qp
argument_list|,
name|retrytime
argument_list|(
name|qp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|qp
operator|->
name|q_fwd
operator|==
name|NULL
condition|)
name|qp
operator|->
name|q_addr
index|[
literal|0
index|]
operator|.
name|stime
operator|=
name|tt
expr_stmt|;
comment|/* XXX - why not every? */
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"sysquery: send -> [%s].%d dfd=%d, nsid=%d id=%d %dms\n"
operator|,
name|inet_ntoa
argument_list|(
name|Q_NEXTADDR
argument_list|(
name|qp
argument_list|,
literal|0
argument_list|)
operator|->
name|sin_addr
argument_list|)
operator|,
name|ntohs
argument_list|(
name|Q_NEXTADDR
argument_list|(
name|qp
argument_list|,
literal|0
argument_list|)
operator|->
name|sin_port
argument_list|)
operator|,
name|qp
operator|->
name|q_dfd
operator|,
name|ntohs
argument_list|(
name|qp
operator|->
name|q_nsid
argument_list|)
operator|,
name|ntohs
argument_list|(
name|qp
operator|->
name|q_id
argument_list|)
operator|,
operator|(
name|qp
operator|->
name|q_addr
index|[
literal|0
index|]
operator|.
name|nsdata
operator|!=
name|NULL
operator|)
condition|?
name|qp
operator|->
name|q_addr
index|[
literal|0
index|]
operator|.
name|nsdata
operator|->
name|d_nstime
else|:
operator|(
operator|-
literal|1
operator|)
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>=
literal|10
condition|)
name|fp_query
argument_list|(
name|qp
operator|->
name|q_msg
argument_list|,
name|ddt
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|sendto
argument_list|(
name|qp
operator|->
name|q_dfd
argument_list|,
name|qp
operator|->
name|q_msg
argument_list|,
name|qp
operator|->
name|q_msglen
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|Q_NEXTADDR
argument_list|(
name|qp
argument_list|,
literal|0
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* XXX - syslog or put in stats or something */
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"sendto error (%s)\n"
operator|,
name|strerror
argument_list|(
name|errno
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
name|stats
index|[
name|S_OUTPKTS
index|]
operator|.
name|cnt
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|DATUMREFCNT
name|free_nsp
argument_list|(
name|nsp
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|qp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check the list of root servers after receiving a response  * to a query for the root servers.  */
end_comment

begin_function
specifier|static
name|void
name|check_root
parameter_list|()
block|{
specifier|register
name|struct
name|databuf
modifier|*
name|dp
decl_stmt|,
modifier|*
name|pdp
decl_stmt|;
specifier|register
name|struct
name|namebuf
modifier|*
name|np
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
name|priming
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|np
operator|=
name|hashtab
operator|->
name|h_tab
index|[
literal|0
index|]
init|;
name|np
operator|!=
name|NULL
condition|;
name|np
operator|=
name|np
operator|->
name|n_next
control|)
if|if
condition|(
name|np
operator|->
name|n_dname
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
break|break;
if|if
condition|(
name|np
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"check_root: Can't find root!\n"
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|dp
operator|=
name|np
operator|->
name|n_data
init|;
name|dp
operator|!=
name|NULL
condition|;
name|dp
operator|=
name|dp
operator|->
name|d_next
control|)
if|if
condition|(
name|dp
operator|->
name|d_type
operator|==
name|T_NS
condition|)
name|count
operator|++
expr_stmt|;
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"%d root servers\n"
operator|,
name|count
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|<
name|MINROOTS
condition|)
block|{
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"check_root: %d root servers after query to root server< min"
argument_list|,
name|count
argument_list|)
expr_stmt|;
return|return;
block|}
name|pdp
operator|=
name|NULL
expr_stmt|;
name|dp
operator|=
name|np
operator|->
name|n_data
expr_stmt|;
while|while
condition|(
name|dp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|dp
operator|->
name|d_type
operator|==
name|T_NS
operator|&&
name|dp
operator|->
name|d_zone
operator|==
literal|0
operator|&&
name|dp
operator|->
name|d_ttl
operator|<
name|tt
operator|.
name|tv_sec
condition|)
block|{
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"deleting old root server '%s'\n"
operator|,
name|dp
operator|->
name|d_data
operator|)
argument_list|)
expr_stmt|;
name|dp
operator|=
name|rm_datum
argument_list|(
name|dp
argument_list|,
name|np
argument_list|,
name|pdp
argument_list|)
expr_stmt|;
comment|/* SHOULD DELETE FROM HINTS ALSO */
continue|continue;
block|}
name|pdp
operator|=
name|dp
expr_stmt|;
name|dp
operator|=
name|dp
operator|->
name|d_next
expr_stmt|;
block|}
name|check_ns
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*   * Check the root to make sure that for each NS record we have a A RR  */
end_comment

begin_function
specifier|static
name|void
name|check_ns
parameter_list|()
block|{
specifier|register
name|struct
name|databuf
modifier|*
name|dp
decl_stmt|,
modifier|*
name|tdp
decl_stmt|;
specifier|register
name|struct
name|namebuf
modifier|*
name|np
decl_stmt|,
modifier|*
name|tnp
decl_stmt|;
name|struct
name|hashbuf
modifier|*
name|htp
decl_stmt|;
name|char
modifier|*
name|dname
decl_stmt|;
name|int
name|found_arr
decl_stmt|;
name|char
modifier|*
name|fname
decl_stmt|;
name|time_t
name|curtime
decl_stmt|;
name|dprintf
argument_list|(
literal|2
argument_list|,
operator|(
name|ddt
operator|,
literal|"check_ns()\n"
operator|)
argument_list|)
expr_stmt|;
name|stats
index|[
name|S_CHECKNS
index|]
operator|.
name|cnt
operator|++
expr_stmt|;
name|curtime
operator|=
operator|(
name|u_int32_t
operator|)
name|tt
operator|.
name|tv_sec
expr_stmt|;
for|for
control|(
name|np
operator|=
name|hashtab
operator|->
name|h_tab
index|[
literal|0
index|]
init|;
name|np
operator|!=
name|NULL
condition|;
name|np
operator|=
name|np
operator|->
name|n_next
control|)
block|{
if|if
condition|(
name|np
operator|->
name|n_dname
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
continue|continue;
for|for
control|(
name|dp
operator|=
name|np
operator|->
name|n_data
init|;
name|dp
operator|!=
name|NULL
condition|;
name|dp
operator|=
name|dp
operator|->
name|d_next
control|)
block|{
if|if
condition|(
name|dp
operator|->
name|d_type
operator|!=
name|T_NS
condition|)
continue|continue;
comment|/* look for A records */
name|dname
operator|=
operator|(
name|caddr_t
operator|)
name|dp
operator|->
name|d_data
expr_stmt|;
name|htp
operator|=
name|hashtab
expr_stmt|;
name|tnp
operator|=
name|nlookup
argument_list|(
name|dname
argument_list|,
operator|&
name|htp
argument_list|,
operator|&
name|fname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|tnp
operator|==
name|NULL
operator|||
name|fname
operator|!=
name|dname
condition|)
block|{
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"check_ns: %s: not found %s %x\n"
operator|,
name|dname
operator|,
name|fname
operator|,
name|tnp
operator|)
argument_list|)
expr_stmt|;
name|sysquery
argument_list|(
name|dname
argument_list|,
name|dp
operator|->
name|d_class
argument_list|,
name|T_A
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* look for name server addresses */
name|found_arr
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|tdp
operator|=
name|tnp
operator|->
name|n_data
init|;
name|tdp
operator|!=
name|NULL
condition|;
name|tdp
operator|=
name|tdp
operator|->
name|d_next
control|)
block|{
if|if
condition|(
name|tdp
operator|->
name|d_type
operator|!=
name|T_A
operator|||
name|tdp
operator|->
name|d_class
operator|!=
name|dp
operator|->
name|d_class
condition|)
continue|continue;
if|if
condition|(
operator|(
name|tdp
operator|->
name|d_zone
operator|==
literal|0
operator|)
operator|&&
operator|(
name|tdp
operator|->
name|d_ttl
operator|<
name|curtime
operator|)
condition|)
block|{
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"check_ns: stale entry '%s'\n"
operator|,
name|tnp
operator|->
name|n_dname
operator|)
argument_list|)
expr_stmt|;
comment|/* Cache invalidate the address RR's */
name|delete_all
argument_list|(
name|tnp
argument_list|,
name|dp
operator|->
name|d_class
argument_list|,
name|T_A
argument_list|)
expr_stmt|;
name|found_arr
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|found_arr
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|found_arr
condition|)
operator|(
name|void
operator|)
name|sysquery
argument_list|(
name|dname
argument_list|,
name|dp
operator|->
name|d_class
argument_list|,
name|T_A
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  *  Find NS's or an SOA for the given dname (np) and fill in the  *  nsp array.  Returns OK on success, and SERVFAIL on error.  *  We return NXDOMAIN to indicate we are authoritative.  */
end_comment

begin_function
name|int
name|findns
parameter_list|(
name|npp
parameter_list|,
name|class
parameter_list|,
name|nsp
parameter_list|,
name|countp
parameter_list|,
name|flag
parameter_list|)
specifier|register
name|struct
name|namebuf
modifier|*
modifier|*
name|npp
decl_stmt|;
name|int
name|class
decl_stmt|;
name|struct
name|databuf
modifier|*
modifier|*
name|nsp
decl_stmt|;
name|int
modifier|*
name|countp
decl_stmt|;
name|int
name|flag
decl_stmt|;
block|{
specifier|register
name|struct
name|namebuf
modifier|*
name|np
init|=
operator|*
name|npp
decl_stmt|;
specifier|register
name|struct
name|databuf
modifier|*
name|dp
decl_stmt|;
specifier|register
name|struct
name|databuf
modifier|*
modifier|*
name|nspp
decl_stmt|;
name|struct
name|hashbuf
modifier|*
name|htp
decl_stmt|;
if|if
condition|(
name|priming
operator|&&
operator|(
name|np
operator|==
name|NULL
operator|||
name|np
operator|->
name|n_dname
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|)
condition|)
name|htp
operator|=
name|fcachetab
expr_stmt|;
else|else
name|htp
operator|=
name|hashtab
expr_stmt|;
name|try_again
label|:
if|if
condition|(
name|htp
operator|==
name|fcachetab
condition|)
name|needs_prime_cache
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|np
operator|==
name|NULL
operator|&&
name|htp
operator|!=
name|NULL
condition|)
block|{
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"findns: using %s\n"
operator|,
name|htp
operator|==
name|hashtab
condition|?
literal|"cache"
else|:
literal|"hints"
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|np
operator|=
name|htp
operator|->
name|h_tab
index|[
literal|0
index|]
init|;
name|np
operator|!=
name|NULL
condition|;
name|np
operator|=
name|np
operator|->
name|n_next
control|)
if|if
condition|(
name|np
operator|->
name|n_dname
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
break|break;
name|htp
operator|=
operator|(
name|htp
operator|==
name|hashtab
condition|?
name|fcachetab
else|:
name|NULL
operator|)
expr_stmt|;
comment|/* Fallback */
block|}
while|while
condition|(
name|np
operator|!=
name|NULL
condition|)
block|{
name|dprintf
argument_list|(
literal|5
argument_list|,
operator|(
name|ddt
operator|,
literal|"findns: np 0x%x '%s'\n"
operator|,
name|np
operator|,
name|np
operator|->
name|n_dname
operator|)
argument_list|)
expr_stmt|;
comment|/* Look first for SOA records. */
ifdef|#
directive|ifdef
name|ADDAUTH
if|if
condition|(
operator|!
name|flag
condition|)
endif|#
directive|endif
for|for
control|(
name|dp
operator|=
name|np
operator|->
name|n_data
init|;
name|dp
operator|!=
name|NULL
condition|;
name|dp
operator|=
name|dp
operator|->
name|d_next
control|)
block|{
if|if
condition|(
name|dp
operator|->
name|d_zone
operator|!=
literal|0
operator|&&
name|match
argument_list|(
name|dp
argument_list|,
name|class
argument_list|,
name|T_SOA
argument_list|)
condition|)
block|{
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"findns: SOA found\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|zones
index|[
name|dp
operator|->
name|d_zone
index|]
operator|.
name|z_state
operator|&
name|Z_AUTH
condition|)
block|{
operator|*
name|npp
operator|=
name|np
expr_stmt|;
name|nsp
index|[
literal|0
index|]
operator|=
name|dp
expr_stmt|;
ifdef|#
directive|ifdef
name|DATUMREFCNT
name|nsp
index|[
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
name|dp
operator|->
name|d_rcnt
operator|++
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|NXDOMAIN
operator|)
return|;
block|}
else|else
return|return
operator|(
name|SERVFAIL
operator|)
return|;
block|}
block|}
comment|/* If no SOA records, look for NS records. */
name|nspp
operator|=
operator|&
name|nsp
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|nspp
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|dp
operator|=
name|np
operator|->
name|n_data
init|;
name|dp
operator|!=
name|NULL
condition|;
name|dp
operator|=
name|dp
operator|->
name|d_next
control|)
block|{
if|if
condition|(
name|dp
operator|->
name|d_type
operator|!=
name|T_NS
operator|||
operator|(
name|dp
operator|->
name|d_class
operator|!=
name|class
operator|&&
name|class
operator|!=
name|C_ANY
operator|)
condition|)
continue|continue;
comment|/* 			 * Don't use records that may become invalid to 			 * reference later when we do the rtt computation. 			 * Never delete our safety-belt information! 			 */
if|if
condition|(
operator|(
name|dp
operator|->
name|d_zone
operator|==
literal|0
operator|)
operator|&&
operator|(
name|dp
operator|->
name|d_ttl
operator|<
operator|(
name|tt
operator|.
name|tv_sec
operator|+
literal|900
operator|)
operator|)
operator|&&
operator|!
operator|(
name|dp
operator|->
name|d_flags
operator|&
name|DB_F_HINT
operator|)
condition|)
block|{
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"findns: stale entry '%s'\n"
operator|,
name|np
operator|->
name|n_dname
operator|)
argument_list|)
expr_stmt|;
comment|/* Cache invalidate the NS RR's */
if|if
condition|(
name|dp
operator|->
name|d_ttl
operator|<
name|tt
operator|.
name|tv_sec
condition|)
name|delete_all
argument_list|(
name|np
argument_list|,
name|class
argument_list|,
name|T_NS
argument_list|)
expr_stmt|;
goto|goto
name|try_parent
goto|;
block|}
if|if
condition|(
name|nspp
operator|<
operator|&
name|nsp
index|[
name|NSMAX
operator|-
literal|1
index|]
condition|)
block|{
operator|*
name|nspp
operator|++
operator|=
name|dp
expr_stmt|;
ifdef|#
directive|ifdef
name|DATUMREFCNT
name|dp
operator|->
name|d_rcnt
operator|++
expr_stmt|;
endif|#
directive|endif
block|}
block|}
operator|*
name|countp
operator|=
name|nspp
operator|-
name|nsp
expr_stmt|;
if|if
condition|(
operator|*
name|countp
operator|>
literal|0
condition|)
block|{
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"findns: %d NS's added for '%s'\n"
operator|,
operator|*
name|countp
operator|,
name|np
operator|->
name|n_dname
operator|)
argument_list|)
expr_stmt|;
operator|*
name|nspp
operator|=
name|NULL
expr_stmt|;
operator|*
name|npp
operator|=
name|np
expr_stmt|;
return|return
name|OK
return|;
comment|/* Success, got some NS's */
block|}
name|try_parent
label|:
name|np
operator|=
name|np
operator|->
name|n_parent
expr_stmt|;
block|}
if|if
condition|(
name|htp
condition|)
goto|goto
name|try_again
goto|;
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"findns: No root nameservers for class %d?\n"
operator|,
name|class
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|unsigned
operator|)
name|class
operator|<
name|MAXCLASS
operator|&&
name|norootlogged
index|[
name|class
index|]
operator|==
literal|0
condition|)
block|{
name|norootlogged
index|[
name|class
index|]
operator|=
literal|1
expr_stmt|;
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"No root nameservers for class %d\n"
argument_list|,
name|class
argument_list|)
expr_stmt|;
block|}
return|return
name|SERVFAIL
return|;
block|}
end_function

begin_comment
comment|/*  *  Extract RR's from the given node that match class and type.  *  Return number of bytes added to response.  *  If no matching data is found, then 0 is returned.  */
end_comment

begin_function
name|int
name|finddata
parameter_list|(
name|np
parameter_list|,
name|class
parameter_list|,
name|type
parameter_list|,
name|hp
parameter_list|,
name|dnamep
parameter_list|,
name|lenp
parameter_list|,
name|countp
parameter_list|)
name|struct
name|namebuf
modifier|*
name|np
decl_stmt|;
name|int
name|class
decl_stmt|,
name|type
decl_stmt|;
specifier|register
name|HEADER
modifier|*
name|hp
decl_stmt|;
name|char
modifier|*
modifier|*
name|dnamep
decl_stmt|;
name|int
modifier|*
name|lenp
decl_stmt|,
decl|*
name|countp
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|struct
name|databuf
modifier|*
name|dp
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|buflen
decl_stmt|,
name|n
decl_stmt|,
name|count
init|=
literal|0
decl_stmt|,
name|foundstale
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|ROUND_ROBIN
if|if
condition|(
name|type
operator|!=
name|T_ANY
condition|)
block|{
comment|/* cycle order of RRs, for a load balancing effect... */
specifier|register
name|struct
name|databuf
modifier|*
modifier|*
name|dpp
decl_stmt|;
for|for
control|(
name|dpp
operator|=
operator|&
name|np
operator|->
name|n_data
init|;
operator|*
name|dpp
condition|;
name|dpp
operator|=
operator|&
name|dp
operator|->
name|d_next
control|)
block|{
name|dp
operator|=
operator|*
name|dpp
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|d_next
operator|&&
name|wanted
argument_list|(
name|dp
argument_list|,
name|class
argument_list|,
name|type
argument_list|)
condition|)
block|{
specifier|register
name|struct
name|databuf
modifier|*
name|lp
decl_stmt|;
operator|*
name|dpp
operator|=
name|lp
operator|=
name|dp
operator|->
name|d_next
expr_stmt|;
name|dp
operator|->
name|d_next
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|dpp
operator|=
operator|&
name|lp
operator|->
name|d_next
init|;
operator|*
name|dpp
condition|;
name|dpp
operator|=
operator|&
name|lp
operator|->
name|d_next
control|)
block|{
name|lp
operator|=
operator|*
name|dpp
expr_stmt|;
block|}
operator|*
name|dpp
operator|=
name|dp
expr_stmt|;
break|break;
block|}
block|}
block|}
endif|#
directive|endif
comment|/*ROUND_ROBIN*/
name|buflen
operator|=
operator|*
name|lenp
expr_stmt|;
name|cp
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
name|hp
operator|)
operator|+
operator|*
name|countp
expr_stmt|;
for|for
control|(
name|dp
operator|=
name|np
operator|->
name|n_data
init|;
name|dp
operator|!=
name|NULL
condition|;
name|dp
operator|=
name|dp
operator|->
name|d_next
control|)
block|{
if|if
condition|(
operator|!
name|wanted
argument_list|(
name|dp
argument_list|,
name|class
argument_list|,
name|type
argument_list|)
condition|)
block|{
ifndef|#
directive|ifndef
name|NCACHE
comment|/*if no negative caching then cname => nothing else*/
if|if
condition|(
name|type
operator|==
name|T_CNAME
operator|&&
name|class
operator|==
name|dp
operator|->
name|d_class
condition|)
block|{
comment|/* any data means no CNAME exists */
operator|*
name|countp
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
endif|#
directive|endif
comment|/*NCACHE*/
continue|continue;
block|}
if|if
condition|(
name|stale
argument_list|(
name|dp
argument_list|)
condition|)
block|{
comment|/* 			 * Don't use stale data. 			 * Would like to call delete_all here 			 * and continue, but the data chain would get 			 * munged; can't restart, as make_rr has side 			 * effects (leaving pointers in dnptr). 			 * Just skip this entry for now 			 * and call delete_all at the end. 			 */
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"finddata: stale entry '%s'\n"
operator|,
name|np
operator|->
name|n_dname
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|d_zone
operator|==
literal|0
condition|)
name|foundstale
operator|++
expr_stmt|;
continue|continue;
block|}
ifdef|#
directive|ifdef
name|CRED
if|if
condition|(
name|dp
operator|->
name|d_cred
operator|==
name|DB_C_ADDITIONAL
condition|)
block|{
comment|/* we want to expire additional data very 			 * quickly.  current strategy is to cut 5% 			 * off each time it is accessed.  this makes 			 * stale(dp) true faster when this datum is 			 * used often. 			 */
name|dp
operator|->
name|d_ttl
operator|=
name|tt
operator|.
name|tv_sec
operator|+
literal|0.95
operator|*
operator|(
name|dp
operator|->
name|d_ttl
operator|-
name|tt
operator|.
name|tv_sec
operator|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/*CRED*/
ifdef|#
directive|ifdef
name|NCACHE
comment|/* -ve $ing stuff, anant@isi.edu 		 * if we have a -ve $ed record, change the rcode on the 		 * header to reflect that 		 */
if|if
condition|(
name|dp
operator|->
name|d_rcode
operator|==
name|NOERROR_NODATA
condition|)
block|{
if|if
condition|(
name|count
operator|!=
literal|0
condition|)
block|{
comment|/* 				 * This should not happen, yet it does... 				 */
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"NODATA& data for \"%s\" type %d class %d"
argument_list|,
operator|*
name|dnamep
argument_list|,
name|type
argument_list|,
name|class
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|type
operator|!=
name|T_ANY
condition|)
block|{
name|hp
operator|->
name|rcode
operator|=
name|NOERROR_NODATA
expr_stmt|;
operator|*
name|countp
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
comment|/* XXX - we have to report success */
block|}
comment|/* don't satisfy T_ANY queries from -$ info */
continue|continue;
block|}
if|if
condition|(
name|dp
operator|->
name|d_rcode
operator|==
name|NXDOMAIN
condition|)
block|{
if|if
condition|(
name|count
operator|!=
literal|0
condition|)
block|{
comment|/* 				 * This should not happen, yet it might... 				 */
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"NXDOMAIN& data for \"%s\" type %d class %d"
argument_list|,
operator|*
name|dnamep
argument_list|,
name|type
argument_list|,
name|class
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|type
operator|!=
name|T_ANY
condition|)
block|{
name|hp
operator|->
name|rcode
operator|=
name|NXDOMAIN
expr_stmt|;
operator|*
name|countp
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
comment|/* XXX - we have to report success */
block|}
comment|/* don't satisfy T_ANY queries from -$ info */
continue|continue;
block|}
endif|#
directive|endif
comment|/*NCACHE*/
if|if
condition|(
operator|(
name|n
operator|=
name|make_rr
argument_list|(
operator|*
name|dnamep
argument_list|,
name|dp
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|cp
argument_list|,
name|buflen
argument_list|,
literal|1
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|hp
operator|->
name|tc
operator|=
literal|1
expr_stmt|;
operator|*
name|countp
operator|=
name|count
expr_stmt|;
return|return
operator|(
operator|*
name|lenp
operator|-
name|buflen
operator|)
return|;
block|}
name|cp
operator|+=
name|n
expr_stmt|;
name|buflen
operator|-=
name|n
expr_stmt|;
name|count
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|notdef
comment|/* this isn't right for glue records, aa is set in ns_req */
if|if
condition|(
name|dp
operator|->
name|d_zone
operator|&&
operator|(
name|zones
index|[
name|dp
operator|->
name|d_zone
index|]
operator|.
name|z_state
operator|&
name|Z_AUTH
operator|)
operator|&&
name|class
operator|!=
name|C_ANY
condition|)
name|hp
operator|->
name|aa
operator|=
literal|1
expr_stmt|;
comment|/* XXX */
endif|#
directive|endif
if|if
condition|(
name|dp
operator|->
name|d_type
operator|==
name|T_CNAME
condition|)
block|{
if|if
condition|(
name|type
operator|!=
name|T_ANY
condition|)
block|{
comment|/* or T_NS? */
operator|*
name|dnamep
operator|=
operator|(
name|caddr_t
operator|)
name|dp
operator|->
name|d_data
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|d_zone
operator|&&
operator|(
name|zones
index|[
name|dp
operator|->
name|d_zone
index|]
operator|.
name|z_state
operator|&
name|Z_AUTH
operator|)
operator|&&
name|class
operator|!=
name|C_ANY
condition|)
comment|/* XXX */
name|hp
operator|->
name|aa
operator|=
literal|1
expr_stmt|;
comment|/* XXX */
block|}
break|break;
block|}
block|}
comment|/* 	 * Cache invalidate the other RR's of same type 	 * if some have timed out 	 */
if|if
condition|(
name|foundstale
condition|)
block|{
name|delete_all
argument_list|(
name|np
argument_list|,
name|class
argument_list|,
name|type
argument_list|)
expr_stmt|;
comment|/* XXX this isn't right if 'type' is something special 		 * such as T_AXFR or T_MAILB, since the matching done 		 * by match() in delete_all() is different from that 		 * done by wanted() above. 		 */
block|}
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"finddata: added %d class %d type %d RRs\n"
operator|,
name|count
operator|,
name|class
operator|,
name|type
operator|)
argument_list|)
expr_stmt|;
operator|*
name|countp
operator|=
name|count
expr_stmt|;
return|return
operator|(
operator|*
name|lenp
operator|-
name|buflen
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Do we want this data record based on the class and type?  */
end_comment

begin_function
name|int
name|wanted
parameter_list|(
name|dp
parameter_list|,
name|class
parameter_list|,
name|type
parameter_list|)
name|struct
name|databuf
modifier|*
name|dp
decl_stmt|;
name|int
name|class
decl_stmt|,
name|type
decl_stmt|;
block|{
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"wanted(%x, %d, %d) %d, %d\n"
operator|,
name|dp
operator|,
name|class
operator|,
name|type
operator|,
name|dp
operator|->
name|d_class
operator|,
name|dp
operator|->
name|d_type
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|d_class
operator|!=
name|class
operator|&&
name|class
operator|!=
name|C_ANY
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|type
operator|==
name|dp
operator|->
name|d_type
condition|)
return|return
operator|(
literal|1
operator|)
return|;
ifdef|#
directive|ifdef
name|NCACHE
comment|/*-ve $ing stuff, for a T_ANY query, we do not want to return 	 * -ve $ed RRs. 	 */
if|if
condition|(
name|type
operator|==
name|T_ANY
operator|&&
name|dp
operator|->
name|d_rcode
operator|==
name|NOERROR_NODATA
condition|)
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
switch|switch
condition|(
name|dp
operator|->
name|d_type
condition|)
block|{
case|case
name|T_ANY
case|:
return|return
operator|(
literal|1
operator|)
return|;
case|case
name|T_CNAME
case|:
ifdef|#
directive|ifdef
name|NCACHE
if|if
condition|(
name|dp
operator|->
name|d_rcode
operator|!=
name|NOERROR_NODATA
condition|)
endif|#
directive|endif
return|return
operator|(
literal|1
operator|)
return|;
ifdef|#
directive|ifdef
name|NCACHE
else|else
break|break;
endif|#
directive|endif
block|}
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|T_ANY
case|:
return|return
operator|(
literal|1
operator|)
return|;
case|case
name|T_MAILB
case|:
switch|switch
condition|(
name|dp
operator|->
name|d_type
condition|)
block|{
case|case
name|T_MR
case|:
case|case
name|T_MB
case|:
case|case
name|T_MG
case|:
case|case
name|T_MINFO
case|:
return|return
operator|(
literal|1
operator|)
return|;
block|}
break|break;
case|case
name|T_AXFR
case|:
comment|/* T_AXFR needs an authoritative SOA */
if|if
condition|(
name|dp
operator|->
name|d_type
operator|==
name|T_SOA
operator|&&
name|dp
operator|->
name|d_zone
operator|!=
literal|0
operator|&&
operator|(
name|zones
index|[
name|dp
operator|->
name|d_zone
index|]
operator|.
name|z_state
operator|&
name|Z_AUTH
operator|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  Add RR entries from dpp array to a query/response.  *  Return the number of bytes added or negative the amount  *  added if truncation was required.  Typically you are  *  adding NS records to a response.  */
end_comment

begin_function
name|int
name|add_data
parameter_list|(
name|np
parameter_list|,
name|dpp
parameter_list|,
name|cp
parameter_list|,
name|buflen
parameter_list|)
name|struct
name|namebuf
modifier|*
name|np
decl_stmt|;
name|struct
name|databuf
modifier|*
modifier|*
name|dpp
decl_stmt|;
specifier|register
name|u_char
modifier|*
name|cp
decl_stmt|;
name|int
name|buflen
decl_stmt|;
block|{
specifier|register
name|struct
name|databuf
modifier|*
name|dp
decl_stmt|;
name|char
name|dname
index|[
name|MAXDNAME
index|]
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|,
name|count
init|=
literal|0
decl_stmt|;
name|getname
argument_list|(
name|np
argument_list|,
name|dname
argument_list|,
sizeof|sizeof
argument_list|(
name|dname
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|dp
operator|=
operator|*
name|dpp
operator|++
init|;
name|dp
operator|!=
name|NULL
condition|;
name|dp
operator|=
operator|*
name|dpp
operator|++
control|)
block|{
if|if
condition|(
name|stale
argument_list|(
name|dp
argument_list|)
condition|)
continue|continue;
comment|/* ignore old cache entry */
ifdef|#
directive|ifdef
name|NCACHE
if|if
condition|(
name|dp
operator|->
name|d_rcode
condition|)
continue|continue;
endif|#
directive|endif
if|if
condition|(
operator|(
name|n
operator|=
name|make_rr
argument_list|(
name|dname
argument_list|,
name|dp
argument_list|,
name|cp
argument_list|,
name|buflen
argument_list|,
literal|1
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
name|count
operator|)
return|;
comment|/* Truncation */
name|cp
operator|+=
name|n
expr_stmt|;
name|buflen
operator|-=
name|n
expr_stmt|;
name|count
operator|+=
name|n
expr_stmt|;
block|}
return|return
operator|(
name|count
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  This is best thought of as a "cache invalidate" function.  *  It is called whenever a piece of data is determined to have  *  timed out.  It is better to have no information, than to  *  have partial information you pass off as complete.  */
end_comment

begin_function
name|void
name|delete_all
parameter_list|(
name|np
parameter_list|,
name|class
parameter_list|,
name|type
parameter_list|)
specifier|register
name|struct
name|namebuf
modifier|*
name|np
decl_stmt|;
name|int
name|class
decl_stmt|,
name|type
decl_stmt|;
block|{
specifier|register
name|struct
name|databuf
modifier|*
name|dp
decl_stmt|,
modifier|*
name|pdp
decl_stmt|;
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"delete_all: '%s' 0x%x class %d type %d\n"
operator|,
name|np
operator|->
name|n_dname
operator|,
name|np
operator|,
name|class
operator|,
name|type
operator|)
argument_list|)
expr_stmt|;
name|pdp
operator|=
name|NULL
expr_stmt|;
name|dp
operator|=
name|np
operator|->
name|n_data
expr_stmt|;
while|while
condition|(
name|dp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|dp
operator|->
name|d_zone
operator|==
literal|0
operator|)
operator|&&
operator|!
operator|(
name|dp
operator|->
name|d_flags
operator|&
name|DB_F_HINT
operator|)
operator|&&
name|match
argument_list|(
name|dp
argument_list|,
name|class
argument_list|,
name|type
argument_list|)
condition|)
block|{
name|dp
operator|=
name|rm_datum
argument_list|(
name|dp
argument_list|,
name|np
argument_list|,
name|pdp
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|pdp
operator|=
name|dp
expr_stmt|;
name|dp
operator|=
name|dp
operator|->
name|d_next
expr_stmt|;
block|}
block|}
end_function

end_unit

