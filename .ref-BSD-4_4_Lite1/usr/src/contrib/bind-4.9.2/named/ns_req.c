begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|lint
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|SABER
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)ns_req.c	4.47 (Berkeley) 7/1/91"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$Id: ns_req.c,v 4.9.1.7 1993/12/06 00:43:02 vixie Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/*  * ++Copyright++ 1986, 1988, 1990  * -  * Copyright (c) 1986, 1988, 1990  *    The Regents of the University of California.  All rights reserved.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  * 	This product includes software developed by the University of  * 	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  * -  * Portions Copyright (c) 1993 by Digital Equipment Corporation.  *   * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies, and that  * the name of Digital Equipment Corporation not be used in advertising or  * publicity pertaining to distribution of the document or software without  * specific, written prior permission.  *   * THE SOFTWARE IS PROVIDED "AS IS" AND DIGITAL EQUIPMENT CORP. DISCLAIMS ALL  * WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS.   IN NO EVENT SHALL DIGITAL EQUIPMENT  * CORPORATION BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL  * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR  * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS  * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS  * SOFTWARE.  * -  * --Copyright--  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<arpa/nameser.h>
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<resolv.h>
end_include

begin_include
include|#
directive|include
file|"named.h"
end_include

begin_struct
struct|struct
name|addinfo
block|{
name|char
modifier|*
name|a_dname
decl_stmt|;
comment|/* domain name */
name|u_int
name|a_class
decl_stmt|;
comment|/* class for address */
block|}
struct|;
end_struct

begin_enum
enum|enum
name|req_action
block|{
name|Finish
block|,
name|Refuse
block|,
name|Return
block|}
enum|;
end_enum

begin_decl_stmt
specifier|static
name|enum
name|req_action
name|req_query
name|__P
argument_list|(
operator|(
name|HEADER
operator|*
name|hp
operator|,
name|u_char
operator|*
operator|*
name|cpp
operator|,
name|u_char
operator|*
name|eom
operator|,
expr|struct
name|qstream
operator|*
name|qsp
operator|,
name|int
operator|*
name|buflenp
operator|,
name|int
operator|*
name|msglenp
operator|,
name|u_char
operator|*
name|msg
operator|,
name|int
name|dfd
operator|,
expr|struct
name|sockaddr_in
operator|*
name|from
operator|)
argument_list|)
decl_stmt|,
name|req_iquery
name|__P
argument_list|(
operator|(
name|HEADER
operator|*
name|hp
operator|,
name|u_char
operator|*
operator|*
name|cpp
operator|,
name|u_char
operator|*
name|eom
operator|,
name|int
operator|*
name|buflenp
operator|,
name|u_char
operator|*
name|msg
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|fwritemsg
name|__P
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|,
name|doaxfr
name|__P
argument_list|(
operator|(
expr|struct
name|namebuf
operator|*
operator|,
name|FILE
operator|*
operator|,
expr|struct
name|namebuf
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|,
name|startxfr
name|__P
argument_list|(
operator|(
expr|struct
name|qstream
operator|*
operator|,
expr|struct
name|namebuf
operator|*
operator|,
name|char
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|,
name|printSOAdata
name|__P
argument_list|(
operator|(
expr|struct
name|databuf
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|ALLOW_UPDATES
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|InitDynUpdate
name|__P
argument_list|(
operator|(
specifier|register
name|HEADER
operator|*
name|hp
operator|,
name|char
operator|*
name|msg
operator|,
name|int
name|msglen
operator|,
name|u_char
operator|*
name|startcp
operator|,
expr|struct
name|sockaddr_in
operator|*
name|from
operator|,
expr|struct
name|qstream
operator|*
name|qsp
operator|,
name|int
name|dfd
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|SECURE_ZONES
end_ifdef

begin_function_decl
specifier|extern
name|struct
name|netinfo
modifier|*
name|net_on_netlist
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|struct
name|addinfo
name|addinfo
index|[
name|NADDRECS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|addname
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|u_int16_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Process request using database; assemble and send response.  */
end_comment

begin_function
name|void
name|ns_req
parameter_list|(
name|msg
parameter_list|,
name|msglen
parameter_list|,
name|buflen
parameter_list|,
name|qsp
parameter_list|,
name|from
parameter_list|,
name|dfd
parameter_list|)
name|u_char
modifier|*
name|msg
decl_stmt|;
name|int
name|msglen
decl_stmt|,
name|buflen
decl_stmt|;
name|struct
name|qstream
modifier|*
name|qsp
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|from
decl_stmt|;
name|int
name|dfd
decl_stmt|;
block|{
specifier|register
name|HEADER
modifier|*
name|hp
init|=
operator|(
name|HEADER
operator|*
operator|)
name|msg
decl_stmt|;
name|u_char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|eom
decl_stmt|;
name|enum
name|req_action
name|action
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|3
condition|)
block|{
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"ns_req(from=[%s].%d)\n"
argument_list|,
name|inet_ntoa
argument_list|(
name|from
operator|->
name|sin_addr
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|from
operator|->
name|sin_port
argument_list|)
argument_list|)
expr_stmt|;
name|fp_query
argument_list|(
operator|(
name|char
operator|*
operator|)
name|msg
argument_list|,
name|ddt
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 	 * XXX - this decision should be made by our caller, not by us. 	 */
if|if
condition|(
name|hp
operator|->
name|qr
condition|)
block|{
name|ns_resp
argument_list|(
name|msg
argument_list|,
name|msglen
argument_list|)
expr_stmt|;
comment|/* Now is a safe time for housekeeping */
if|if
condition|(
name|needs_prime_cache
condition|)
name|prime_cache
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* its a query and these bits have no business 	 * being set. will later simplify work if we can 	 * safely assume these are always 0 when a query 	 * comes in 	 */
name|hp
operator|->
name|aa
operator|=
name|hp
operator|->
name|ra
operator|=
literal|0
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|NOERROR
expr_stmt|;
name|cp
operator|=
name|msg
operator|+
sizeof|sizeof
argument_list|(
name|HEADER
argument_list|)
expr_stmt|;
name|eom
operator|=
name|msg
operator|+
name|msglen
expr_stmt|;
name|dnptrs
index|[
literal|0
index|]
operator|=
name|msg
expr_stmt|;
name|dnptrs
index|[
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
name|free_addinfo
argument_list|()
expr_stmt|;
comment|/* sets addcount to zero */
name|dnptrs
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
switch|switch
condition|(
name|hp
operator|->
name|opcode
condition|)
block|{
case|case
name|QUERY
case|:
name|action
operator|=
name|req_query
argument_list|(
name|hp
argument_list|,
operator|&
name|cp
argument_list|,
name|eom
argument_list|,
name|qsp
argument_list|,
operator|&
name|buflen
argument_list|,
operator|&
name|msglen
argument_list|,
name|msg
argument_list|,
name|dfd
argument_list|,
name|from
argument_list|)
expr_stmt|;
break|break;
if|#
directive|if
name|INVQ
case|case
name|IQUERY
case|:
name|action
operator|=
name|req_iquery
argument_list|(
name|hp
argument_list|,
operator|&
name|cp
argument_list|,
name|eom
argument_list|,
operator|&
name|buflen
argument_list|,
name|msg
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ALLOW_UPDATES
define|#
directive|define
name|FORWARDED
value|1000
comment|/*  * In a sense the following constant should be defined in<arpa/nameser.h>,  * since it is returned here in place of a response code if the update was  * forwarded, and the response codes are defined in nameser.h.  On the other  * hand, though, this constant is only seen in this file.  The assumption  * here is that none of the other return codes equals this one (a good  * assumption, since they only occupy 4 bits over-the-wire)  */
comment|/* Call InitDynUpdate for all dynamic update requests */
case|case
name|UPDATEM
case|:
case|case
name|UPDATEMA
case|:
case|case
name|UPDATED
case|:
case|case
name|UPDATEDA
case|:
case|case
name|UPDATEA
case|:
name|n
operator|=
name|InitDynUpdate
argument_list|(
name|hp
argument_list|,
name|msg
argument_list|,
name|msglen
argument_list|,
name|cp
argument_list|,
name|from
argument_list|,
name|qsp
argument_list|,
name|dfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|FORWARDED
condition|)
block|{
comment|/* Return directly because InitDynUpdate 			 * forwarded the query to the primary, so we 			 * will send response later 			 */
name|action
operator|=
name|Return
expr_stmt|;
block|}
else|else
block|{
comment|/* Either sucessful primary update or failure; 			 * return response code to client 			 */
name|action
operator|=
name|Finish
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* ALLOW_UPDATES */
case|case
name|ZONEREF
case|:
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"Refresh Zone\n"
operator|)
argument_list|)
expr_stmt|;
comment|/*FALLTHROUGH*/
default|default:
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"ns_req: Opcode %d not implemented\n"
operator|,
name|hp
operator|->
name|opcode
operator|)
argument_list|)
expr_stmt|;
comment|/* XXX - should syslog, limited by haveComplained */
name|hp
operator|->
name|qdcount
operator|=
literal|0
expr_stmt|;
name|hp
operator|->
name|ancount
operator|=
literal|0
expr_stmt|;
name|hp
operator|->
name|nscount
operator|=
literal|0
expr_stmt|;
name|hp
operator|->
name|arcount
operator|=
literal|0
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|NOTIMP
expr_stmt|;
name|action
operator|=
name|Finish
expr_stmt|;
block|}
comment|/* 	 * vector via internal opcode.  (yes, it was even uglier before.) 	 */
switch|switch
condition|(
name|action
condition|)
block|{
case|case
name|Return
case|:
return|return;
case|case
name|Refuse
case|:
name|hp
operator|->
name|rcode
operator|=
name|REFUSED
expr_stmt|;
comment|/*FALLTHROUGH*/
case|case
name|Finish
case|:
comment|/* rest of the function handles this case */
break|break;
default|default:
name|syslog
argument_list|(
name|LOG_CRIT
argument_list|,
literal|"bad action variable in ns_req() -- %d"
argument_list|,
operator|(
name|int
operator|)
name|action
argument_list|)
expr_stmt|;
return|return;
comment|/* XXX - should really exit here */
block|}
comment|/* 	 * update statistics 	 */
switch|switch
condition|(
name|hp
operator|->
name|rcode
condition|)
block|{
case|case
name|NOERROR
case|:
name|stats
index|[
name|S_RESPOK
index|]
operator|.
name|cnt
operator|++
expr_stmt|;
break|break;
case|case
name|FORMERR
case|:
name|stats
index|[
name|S_RESPFORMERR
index|]
operator|.
name|cnt
operator|++
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|NCACHE
case|case
name|NXDOMAIN
case|:
name|stats
index|[
name|S_RESPNXDOMAIN
index|]
operator|.
name|cnt
operator|++
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|stats
index|[
name|S_RESPFAIL
index|]
operator|.
name|cnt
operator|++
expr_stmt|;
break|break;
block|}
comment|/* 	 * apply final polish 	 */
name|hp
operator|->
name|qr
operator|=
literal|1
expr_stmt|;
comment|/* set Response flag */
if|if
condition|(
name|NoRecurse
condition|)
name|hp
operator|->
name|ra
operator|=
literal|0
expr_stmt|;
comment|/* No recursion; maybe we're a root server */
else|else
name|hp
operator|->
name|ra
operator|=
literal|1
expr_stmt|;
comment|/* Recursion is Available */
name|hp
operator|->
name|ancount
operator|=
name|htons
argument_list|(
name|hp
operator|->
name|ancount
argument_list|)
expr_stmt|;
if|if
condition|(
name|addcount
condition|)
block|{
name|int
name|n
init|=
name|doaddinfo
argument_list|(
name|hp
argument_list|,
name|cp
argument_list|,
name|buflen
argument_list|)
decl_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
name|buflen
operator|-=
name|n
expr_stmt|;
block|}
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"ns_req: answer -> [%s].%d fd=%d id=%d %s\n"
operator|,
name|inet_ntoa
argument_list|(
name|from
operator|->
name|sin_addr
argument_list|)
operator|,
name|ntohs
argument_list|(
name|from
operator|->
name|sin_port
argument_list|)
operator|,
operator|(
name|qsp
operator|==
name|QSTREAM_NULL
operator|)
condition|?
name|dfd
else|:
name|qsp
operator|->
name|s_rfd
operator|,
name|ntohs
argument_list|(
name|hp
operator|->
name|id
argument_list|)
operator|,
name|local
argument_list|(
name|from
argument_list|)
operator|==
name|NULL
condition|?
literal|"Remote"
else|:
literal|"Local"
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>=
literal|10
condition|)
name|fp_query
argument_list|(
operator|(
name|char
operator|*
operator|)
name|msg
argument_list|,
name|ddt
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|qsp
operator|==
name|QSTREAM_NULL
condition|)
block|{
if|if
condition|(
name|sendto
argument_list|(
name|dfd
argument_list|,
name|msg
argument_list|,
name|cp
operator|-
name|msg
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|from
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|from
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"error returning msg errno=%d\n"
operator|,
name|errno
operator|)
argument_list|)
expr_stmt|;
block|}
name|stats
index|[
name|S_OUTPKTS
index|]
operator|.
name|cnt
operator|++
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|writemsg
argument_list|(
name|qsp
operator|->
name|s_rfd
argument_list|,
name|msg
argument_list|,
name|cp
operator|-
name|msg
argument_list|)
expr_stmt|;
name|sq_done
argument_list|(
name|qsp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|needs_prime_cache
condition|)
block|{
name|prime_cache
argument_list|()
expr_stmt|;
comment|/* Now is a safe time */
block|}
block|}
end_function

begin_function
specifier|static
name|enum
name|req_action
name|req_query
parameter_list|(
name|hp
parameter_list|,
name|cpp
parameter_list|,
name|eom
parameter_list|,
name|qsp
parameter_list|,
name|buflenp
parameter_list|,
name|msglenp
parameter_list|,
name|msg
parameter_list|,
name|dfd
parameter_list|,
name|from
parameter_list|)
name|HEADER
modifier|*
name|hp
decl_stmt|;
name|u_char
modifier|*
modifier|*
name|cpp
decl_stmt|;
name|u_char
modifier|*
name|eom
decl_stmt|;
name|struct
name|qstream
modifier|*
name|qsp
decl_stmt|;
name|u_char
modifier|*
name|msg
decl_stmt|;
name|int
modifier|*
name|buflenp
decl_stmt|,
decl|*
name|msglenp
decl_stmt|,
name|dfd
decl_stmt|;
end_function

begin_decl_stmt
name|struct
name|sockaddr_in
modifier|*
name|from
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|n
decl_stmt|,
name|class
decl_stmt|,
name|type
decl_stmt|,
name|count
decl_stmt|,
name|foundname
decl_stmt|,
name|founddata
decl_stmt|,
name|omsglen
decl_stmt|,
name|cname
decl_stmt|;
name|u_int16_t
name|id
decl_stmt|;
name|u_char
modifier|*
modifier|*
name|dpp
decl_stmt|,
modifier|*
name|omsg
decl_stmt|;
name|char
name|dnbuf
index|[
name|MAXDNAME
index|]
decl_stmt|,
modifier|*
name|dname
decl_stmt|,
modifier|*
name|fname
decl_stmt|,
modifier|*
name|answers
decl_stmt|;
name|struct
name|hashbuf
modifier|*
name|htp
decl_stmt|;
name|struct
name|databuf
modifier|*
name|nsp
index|[
name|NSMAX
index|]
decl_stmt|;
name|struct
name|namebuf
modifier|*
name|np
decl_stmt|;
name|struct
name|qinfo
modifier|*
name|qp
decl_stmt|;
name|struct
name|netinfo
modifier|*
name|lp
decl_stmt|;
name|stats
index|[
name|S_QUERIES
index|]
operator|.
name|cnt
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|DATUMREFCNT
name|nsp
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
name|dpp
operator|=
name|dnptrs
expr_stmt|;
operator|*
name|dpp
operator|++
operator|=
name|msg
expr_stmt|;
operator|*
name|dpp
operator|=
name|NULL
expr_stmt|;
comment|/* for early returns (thanks, kre) */
comment|/* valid queries have one question and zero answers */
if|if
condition|(
operator|(
name|ntohs
argument_list|(
name|hp
operator|->
name|qdcount
argument_list|)
operator|!=
literal|1
operator|)
operator|||
name|hp
operator|->
name|ancount
operator|||
name|hp
operator|->
name|nscount
operator|||
name|hp
operator|->
name|arcount
condition|)
block|{
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"FORMERR Query header counts wrong\n"
operator|)
argument_list|)
expr_stmt|;
name|hp
operator|->
name|qdcount
operator|=
literal|0
expr_stmt|;
name|hp
operator|->
name|ancount
operator|=
literal|0
expr_stmt|;
name|hp
operator|->
name|nscount
operator|=
literal|0
expr_stmt|;
name|hp
operator|->
name|arcount
operator|=
literal|0
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
return|return
name|Finish
return|;
block|}
comment|/* 	 * Get domain name, class, and type. 	 */
if|if
condition|(
operator|(
operator|*
operator|*
name|cpp
operator|&
name|INDIR_MASK
operator|)
operator|==
literal|0
condition|)
block|{
operator|*
name|dpp
operator|++
operator|=
operator|*
name|cpp
expr_stmt|;
comment|/* remember name for compression */
block|}
operator|*
name|dpp
operator|=
name|NULL
expr_stmt|;
name|n
operator|=
name|dn_expand
argument_list|(
name|msg
argument_list|,
name|eom
argument_list|,
operator|*
name|cpp
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|dnbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|dnbuf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"FORMERR Query expand name failed\n"
operator|)
argument_list|)
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
return|return
name|Finish
return|;
block|}
operator|*
name|cpp
operator|+=
name|n
expr_stmt|;
name|GETSHORT
argument_list|(
name|type
argument_list|,
operator|*
name|cpp
argument_list|)
expr_stmt|;
name|GETSHORT
argument_list|(
name|class
argument_list|,
operator|*
name|cpp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|cpp
operator|>
name|eom
condition|)
block|{
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"FORMERR Query message length short\n"
operator|)
argument_list|)
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
return|return
name|Finish
return|;
block|}
if|if
condition|(
operator|*
name|cpp
operator|<
name|eom
condition|)
block|{
name|dprintf
argument_list|(
literal|6
argument_list|,
operator|(
name|ddt
operator|,
literal|"message length> received message\n"
operator|)
argument_list|)
expr_stmt|;
operator|*
name|msglenp
operator|=
operator|*
name|cpp
operator|-
name|msg
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|type
operator|>
name|T_ANY
operator|)
operator|||
operator|(
name|type
operator|<
literal|0
operator|)
condition|)
block|{
name|typestats
index|[
literal|0
index|]
operator|++
expr_stmt|;
comment|/* Bad type */
block|}
else|else
block|{
name|typestats
index|[
name|type
index|]
operator|++
expr_stmt|;
block|}
comment|/* 	 * Process query. 	 */
if|if
condition|(
name|type
operator|==
name|T_AXFR
condition|)
block|{
comment|/* refuse request if not a TCP connection */
if|if
condition|(
name|qsp
operator|==
name|QSTREAM_NULL
condition|)
block|{
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"T_AXFR via UDP refused\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|Refuse
return|;
block|}
ifdef|#
directive|ifdef
name|XFRNETS
if|if
condition|(
name|xfrnets
condition|)
block|{
comment|/* if xfrnets was specified, peer address 			 * must be on it.  should probably allow 			 * for negation some day. 			 */
if|if
condition|(
operator|!
name|net_on_netlist
argument_list|(
name|from
operator|->
name|sin_addr
argument_list|,
name|xfrnets
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"dangerous AXFR addr: [%s].%u"
argument_list|,
name|inet_ntoa
argument_list|(
name|from
operator|->
name|sin_addr
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|from
operator|->
name|sin_port
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|Refuse
return|;
block|}
block|}
endif|#
directive|endif
comment|/*XFRNETS*/
name|dnptrs
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
comment|/* don't compress names */
name|hp
operator|->
name|rd
operator|=
literal|0
expr_stmt|;
comment|/* recursion not possible */
block|}
operator|*
name|buflenp
operator|-=
operator|*
name|msglenp
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
name|foundname
operator|=
literal|0
expr_stmt|;
name|founddata
operator|=
literal|0
expr_stmt|;
name|dname
operator|=
name|dnbuf
expr_stmt|;
name|cname
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|QRYLOG
if|if
condition|(
name|qrylog
condition|)
block|{
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"XX /%s/%s/%s"
argument_list|,
name|inet_ntoa
argument_list|(
name|from
operator|->
name|sin_addr
argument_list|)
argument_list|,
operator|(
name|dname
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|)
condition|?
literal|"."
else|:
name|dname
argument_list|,
name|p_type
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/*QRYLOG*/
name|try_again
label|:
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"req: nlookup(%s) id %d type=%d\n"
operator|,
name|dname
operator|,
name|hp
operator|->
name|id
operator|,
name|type
operator|)
argument_list|)
expr_stmt|;
name|htp
operator|=
name|hashtab
expr_stmt|;
comment|/* lookup relative to root */
if|if
condition|(
operator|(
name|np
operator|=
name|nlookup
argument_list|(
name|dname
argument_list|,
operator|&
name|htp
argument_list|,
operator|&
name|fname
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|fname
operator|=
literal|""
expr_stmt|;
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"req: %s '%s' as '%s' (cname=%d)\n"
operator|,
name|np
operator|==
name|NULL
condition|?
literal|"missed"
else|:
literal|"found"
operator|,
name|dname
operator|,
name|fname
operator|,
name|cname
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LOCALDOM
comment|/* 	 * if nlookup failed to find the name then 	 * see if there are any '.''s in the name 	 * if not then add local domain name to the 	 * name and try again. 	 */
if|if
condition|(
operator|!
name|np
operator|&&
name|localdomain
operator|&&
operator|!
name|strchr
argument_list|(
name|dname
argument_list|,
literal|'.'
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|dname
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|dname
argument_list|,
name|localdomain
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"req: nlookup(%s) type=%d\n"
operator|,
name|dname
operator|,
name|type
operator|)
argument_list|)
expr_stmt|;
name|htp
operator|=
name|hashtab
expr_stmt|;
name|np
operator|=
name|nlookup
argument_list|(
name|dname
argument_list|,
operator|&
name|htp
argument_list|,
operator|&
name|fname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/*LOCALDOM*/
ifdef|#
directive|ifdef
name|YPKLUDGE
comment|/* Some braindamaged resolver software will not  	   recognize internet addresses in dot notation and  	   send out address  queries for "names" such as  	   128.93.8.1.  This kludge will prevent those  	   from flooding higher level servers. 	   We simply claim to be authoritative and that 	   the domain doesn't exist. 	   Note that we could return the address but we 	   don't do that in order to encourage that broken 	   software is fixed. 	*/
if|if
condition|(
operator|!
name|np
operator|&&
name|type
operator|==
name|T_A
operator|&&
name|class
operator|==
name|C_IN
operator|&&
name|dname
condition|)
block|{
name|struct
name|sockaddr_in
name|ina
decl_stmt|;
if|if
condition|(
name|inet_aton
argument_list|(
name|dname
argument_list|,
operator|&
name|ina
argument_list|)
condition|)
block|{
name|hp
operator|->
name|rcode
operator|=
name|NXDOMAIN
expr_stmt|;
name|hp
operator|->
name|aa
operator|=
literal|1
expr_stmt|;
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"ypkludge: hit as '%s'\n"
operator|,
name|dname
operator|)
argument_list|)
expr_stmt|;
return|return
name|Finish
return|;
block|}
block|}
endif|#
directive|endif
comment|/*YPKLUDGE*/
if|if
condition|(
operator|(
operator|!
name|np
operator|)
operator|||
operator|(
name|fname
operator|!=
name|dname
operator|)
condition|)
goto|goto
name|fetchns
goto|;
ifdef|#
directive|ifdef
name|SECURE_ZONES
if|if
condition|(
name|np
operator|->
name|n_data
condition|)
block|{
name|struct
name|zoneinfo
modifier|*
name|zp
decl_stmt|;
name|zp
operator|=
operator|&
name|zones
index|[
name|np
operator|->
name|n_data
operator|->
name|d_zone
index|]
expr_stmt|;
if|if
condition|(
name|zp
operator|->
name|secure_nets
operator|&&
operator|!
name|net_on_netlist
argument_list|(
name|from
operator|->
name|sin_addr
argument_list|,
name|zp
operator|->
name|secure_nets
argument_list|)
condition|)
block|{
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"REFUSED Unauthorized request from %s\n"
operator|,
name|inet_ntoa
argument_list|(
name|from
operator|->
name|sin_addr
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"Unauthorized request %s from %s"
argument_list|,
name|dname
argument_list|,
name|inet_ntoa
argument_list|(
name|from
operator|->
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|Refuse
return|;
block|}
block|}
endif|#
directive|endif
name|foundname
operator|++
expr_stmt|;
name|answers
operator|=
operator|(
name|char
operator|*
operator|)
operator|*
name|cpp
expr_stmt|;
name|count
operator|=
operator|*
name|cpp
operator|-
name|msg
expr_stmt|;
ifdef|#
directive|ifdef
name|NCACHE
comment|/* if this is a NXDOMAIN, will have only one databuf 	 * whose d_rcode field will be NXDOMAIN. So we can go home 	 * right here. -ve $ing: anant@isi.edu 	 */
if|if
condition|(
name|np
operator|->
name|n_data
operator|!=
name|NULL
operator|&&
operator|!
name|stale
argument_list|(
name|np
operator|->
name|n_data
argument_list|)
condition|)
block|{
if|if
condition|(
name|np
operator|->
name|n_data
operator|->
name|d_rcode
operator|==
name|NXDOMAIN
condition|)
block|{
name|hp
operator|->
name|rcode
operator|=
name|NXDOMAIN
expr_stmt|;
name|founddata
operator|=
literal|1
expr_stmt|;
goto|goto
name|fetchns
goto|;
block|}
block|}
comment|/* if not NXDOMAIN, the NOERROR_NODATA record might be 	 * anywhere in the chain. have to go through the grind. 	 * (anant@isi.edu) 	 */
endif|#
directive|endif
comment|/*NCACHE*/
name|n
operator|=
name|finddata
argument_list|(
name|np
argument_list|,
name|class
argument_list|,
name|type
argument_list|,
name|hp
argument_list|,
operator|&
name|dname
argument_list|,
name|buflenp
argument_list|,
operator|&
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
comment|/* NO data available.  Refuse AXFR requests, or 		 * look for better servers for other requests. 		 */
if|if
condition|(
name|type
operator|==
name|T_AXFR
condition|)
block|{
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"T_AXFR refused: no data\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|Refuse
return|;
block|}
else|else
block|{
goto|goto
name|fetchns
goto|;
block|}
block|}
ifdef|#
directive|ifdef
name|NCACHE
if|if
condition|(
name|hp
operator|->
name|rcode
operator|==
name|NOERROR_NODATA
condition|)
block|{
name|hp
operator|->
name|rcode
operator|=
name|NOERROR
expr_stmt|;
name|founddata
operator|=
literal|1
expr_stmt|;
return|return
name|Finish
return|;
block|}
endif|#
directive|endif
operator|*
name|cpp
operator|+=
name|n
expr_stmt|;
operator|*
name|buflenp
operator|-=
name|n
expr_stmt|;
operator|*
name|msglenp
operator|+=
name|n
expr_stmt|;
name|hp
operator|->
name|ancount
operator|+=
name|count
expr_stmt|;
if|if
condition|(
name|fname
operator|!=
name|dname
operator|&&
name|type
operator|!=
name|T_CNAME
operator|&&
name|type
operator|!=
name|T_ANY
condition|)
block|{
if|if
condition|(
name|cname
operator|++
operator|>=
name|MAXCNAMES
condition|)
block|{
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"resp: leaving, MAXCNAMES exceeded\n"
operator|)
argument_list|)
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|SERVFAIL
expr_stmt|;
return|return
name|Finish
return|;
block|}
goto|goto
name|try_again
goto|;
block|}
name|founddata
operator|=
literal|1
expr_stmt|;
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"req: foundname=%d, count=%d, founddata=%d, cname=%d\n"
operator|,
name|foundname
operator|,
name|count
operator|,
name|founddata
operator|,
name|cname
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|lp
operator|=
name|local
argument_list|(
name|from
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|sort_response
argument_list|(
name|answers
argument_list|,
name|count
argument_list|,
name|lp
argument_list|,
operator|*
name|cpp
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|T_AXFR
condition|)
block|{
name|hp
operator|->
name|ancount
operator|=
name|htons
argument_list|(
name|hp
operator|->
name|ancount
argument_list|)
expr_stmt|;
name|startxfr
argument_list|(
name|qsp
argument_list|,
name|np
argument_list|,
operator|(
name|char
operator|*
operator|)
name|msg
argument_list|,
operator|*
name|cpp
operator|-
name|msg
argument_list|,
name|class
argument_list|)
expr_stmt|;
name|sqrm
argument_list|(
name|qsp
argument_list|)
expr_stmt|;
return|return
name|Return
return|;
block|}
ifdef|#
directive|ifdef
name|notdef
comment|/* 	 * If we found an authoritative answer, 	 * we're done. 	 */
if|if
condition|(
name|hp
operator|->
name|aa
condition|)
block|{
return|return
name|Finish
return|;
block|}
endif|#
directive|endif
name|fetchns
label|:
comment|/*  	 * Look for name servers to refer to and fill in the authority  	 * section or record the address for forwarding the query  	 * (recursion desired).  	 */
ifdef|#
directive|ifdef
name|DATUMREFCNT
name|free_nsp
argument_list|(
name|nsp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|nsp
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|findns
argument_list|(
operator|&
name|np
argument_list|,
name|class
argument_list|,
name|nsp
argument_list|,
operator|&
name|count
argument_list|,
literal|0
argument_list|)
condition|)
block|{
case|case
name|NXDOMAIN
case|:
if|if
condition|(
operator|!
name|foundname
condition|)
block|{
name|hp
operator|->
name|rcode
operator|=
name|NXDOMAIN
expr_stmt|;
block|}
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"req: leaving (%s, rcode %d)\n"
operator|,
name|dname
operator|,
name|hp
operator|->
name|rcode
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|class
operator|!=
name|C_ANY
condition|)
block|{
name|hp
operator|->
name|aa
operator|=
literal|1
expr_stmt|;
comment|/* XXX 			 * should return SOA if founddata == 0, 			 * but old named's are confused by an SOA 			 * in the auth. section if there's no error. 			 */
if|if
condition|(
name|foundname
operator|==
literal|0
operator|&&
name|np
condition|)
block|{
name|n
operator|=
name|doaddauth
argument_list|(
name|hp
argument_list|,
operator|*
name|cpp
argument_list|,
operator|*
name|buflenp
argument_list|,
name|np
argument_list|,
name|nsp
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
operator|*
name|cpp
operator|+=
name|n
expr_stmt|;
operator|*
name|buflenp
operator|-=
name|n
expr_stmt|;
ifdef|#
directive|ifdef
name|ADDAUTH
block|}
elseif|else
if|if
condition|(
name|hp
operator|->
name|ancount
condition|)
block|{
comment|/* don't add NS records for NOERROR NODATA 				   as some severs can get confused */
ifdef|#
directive|ifdef
name|DATUMREFCNT
name|free_nsp
argument_list|(
name|nsp
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|findns
argument_list|(
operator|&
name|np
argument_list|,
name|class
argument_list|,
name|nsp
argument_list|,
operator|&
name|count
argument_list|,
literal|1
argument_list|)
condition|)
block|{
case|case
name|NXDOMAIN
case|:
case|case
name|SERVFAIL
case|:
break|break;
default|default:
if|if
condition|(
name|np
condition|)
block|{
name|n
operator|=
name|add_data
argument_list|(
name|np
argument_list|,
name|nsp
argument_list|,
operator|*
name|cpp
argument_list|,
operator|*
name|buflenp
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|hp
operator|->
name|tc
operator|=
literal|1
expr_stmt|;
name|n
operator|=
operator|(
operator|-
name|n
operator|)
expr_stmt|;
block|}
operator|*
name|cpp
operator|+=
name|n
expr_stmt|;
operator|*
name|buflenp
operator|-=
name|n
expr_stmt|;
name|hp
operator|->
name|nscount
operator|=
name|htons
argument_list|(
operator|(
name|u_int16_t
operator|)
name|count
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/*ADDAUTH*/
block|}
block|}
ifdef|#
directive|ifdef
name|DATUMREFCNT
name|free_nsp
argument_list|(
name|nsp
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|Finish
return|;
case|case
name|SERVFAIL
case|:
if|if
condition|(
operator|!
name|founddata
operator|&&
operator|!
operator|(
name|forward_only
operator|&&
name|fwdtab
operator|)
condition|)
block|{
name|hp
operator|->
name|rcode
operator|=
name|SERVFAIL
expr_stmt|;
ifdef|#
directive|ifdef
name|DATUMREFCNT
name|free_nsp
argument_list|(
name|nsp
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|Finish
return|;
block|}
block|}
comment|/* 	 *  If we successfully found the answer in the cache, 	 *  or this is not a recursive query, or we are purposely 	 *  never recursing, then add the nameserver references 	 *  ("authority section") here and we're done. 	 */
if|if
condition|(
name|founddata
operator|||
operator|(
operator|!
name|hp
operator|->
name|rd
operator|)
operator|||
name|NoRecurse
condition|)
block|{
name|n
operator|=
name|add_data
argument_list|(
name|np
argument_list|,
name|nsp
argument_list|,
operator|*
name|cpp
argument_list|,
operator|*
name|buflenp
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|hp
operator|->
name|tc
operator|=
literal|1
expr_stmt|;
name|n
operator|=
operator|(
operator|-
name|n
operator|)
expr_stmt|;
block|}
operator|*
name|cpp
operator|+=
name|n
expr_stmt|;
operator|*
name|buflenp
operator|-=
name|n
expr_stmt|;
name|hp
operator|->
name|nscount
operator|=
name|htons
argument_list|(
operator|(
name|u_int16_t
operator|)
name|count
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DATUMREFCNT
name|free_nsp
argument_list|(
name|nsp
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|Finish
return|;
block|}
comment|/* 	 *  At this point, we don't have the answer, but we do 	 *  have some NS's to try.  If the user would like us 	 *  to recurse, create the initial query.  If a cname 	 *  is involved, we need to build a new query and save 	 *  the old one in cmsg/cmsglen. 	 */
if|if
condition|(
name|cname
condition|)
block|{
name|omsg
operator|=
operator|(
name|u_char
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
operator|*
name|msglenp
argument_list|)
expr_stmt|;
if|if
condition|(
name|omsg
operator|==
operator|(
name|u_char
operator|*
operator|)
name|NULL
condition|)
block|{
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"ns_req: malloc fail\n"
operator|)
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ns_req: Out Of Memory"
argument_list|)
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|SERVFAIL
expr_stmt|;
return|return
name|Finish
return|;
block|}
name|id
operator|=
name|hp
operator|->
name|id
expr_stmt|;
name|hp
operator|->
name|ancount
operator|=
name|htons
argument_list|(
name|hp
operator|->
name|ancount
argument_list|)
expr_stmt|;
name|omsglen
operator|=
operator|*
name|msglenp
expr_stmt|;
name|bcopy
argument_list|(
name|msg
argument_list|,
name|omsg
argument_list|,
name|omsglen
argument_list|)
expr_stmt|;
operator|*
name|msglenp
operator|=
name|res_mkquery
argument_list|(
name|QUERY
argument_list|,
name|dname
argument_list|,
name|class
argument_list|,
name|type
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
operator|(
name|char
operator|*
operator|)
name|msg
argument_list|,
operator|*
name|msglenp
operator|+
operator|*
name|buflenp
argument_list|)
expr_stmt|;
block|}
name|n
operator|=
name|ns_forw
argument_list|(
name|nsp
argument_list|,
name|msg
argument_list|,
operator|*
name|msglenp
argument_list|,
name|from
argument_list|,
name|qsp
argument_list|,
name|dfd
argument_list|,
operator|&
name|qp
argument_list|,
name|dname
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|!=
name|FW_OK
operator|&&
name|cname
condition|)
name|free
argument_list|(
name|omsg
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|n
condition|)
block|{
case|case
name|FW_OK
case|:
if|if
condition|(
name|cname
condition|)
block|{
name|qp
operator|->
name|q_cname
operator|=
name|cname
expr_stmt|;
name|qp
operator|->
name|q_cmsg
operator|=
operator|(
name|char
operator|*
operator|)
name|omsg
expr_stmt|;
name|qp
operator|->
name|q_cmsglen
operator|=
name|omsglen
expr_stmt|;
name|qp
operator|->
name|q_id
operator|=
name|id
expr_stmt|;
block|}
break|break;
case|case
name|FW_DUP
case|:
break|break;
comment|/* Duplicate request dropped */
case|case
name|FW_NOSERVER
case|:
comment|/*  		** Don't go into an infinite loop if  		** the admin gave root NS records in the cache 		** file without giving address records 		** for the root servers. 		*/
if|if
condition|(
name|np
condition|)
block|{
if|if
condition|(
name|np
operator|->
name|n_dname
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"ns_req: no address for root NS\n"
operator|)
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ns_req: no address for root server"
argument_list|)
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|SERVFAIL
expr_stmt|;
return|return
name|Finish
return|;
block|}
ifdef|#
directive|ifdef
name|VALIDATE
comment|/* 			 * we need to kill all the NS records here as 			 * validate will fail as we are talking to the parent 			 * server 			 */
name|delete_all
argument_list|(
name|np
argument_list|,
name|class
argument_list|,
name|T_NS
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|np
operator|=
name|np
operator|->
name|n_parent
expr_stmt|;
block|}
goto|goto
name|fetchns
goto|;
comment|/* Try again. */
case|case
name|FW_SERVFAIL
case|:
name|hp
operator|->
name|rcode
operator|=
name|SERVFAIL
expr_stmt|;
ifdef|#
directive|ifdef
name|DATUMREFCNT
name|free_nsp
argument_list|(
name|nsp
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|Finish
return|;
block|}
ifdef|#
directive|ifdef
name|DATUMREFCNT
name|free_nsp
argument_list|(
name|nsp
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|Return
return|;
block|}
end_block

begin_if
if|#
directive|if
name|INVQ
end_if

begin_function
specifier|static
name|enum
name|req_action
name|req_iquery
parameter_list|(
name|hp
parameter_list|,
name|cpp
parameter_list|,
name|eom
parameter_list|,
name|buflenp
parameter_list|,
name|msg
parameter_list|)
name|HEADER
modifier|*
name|hp
decl_stmt|;
name|u_char
modifier|*
modifier|*
name|cpp
decl_stmt|,
decl|*
name|eom
decl_stmt|;
end_function

begin_decl_stmt
name|int
modifier|*
name|buflenp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_char
modifier|*
name|msg
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|invbuf
modifier|*
name|ip
decl_stmt|;
name|int
name|dlen
decl_stmt|,
name|alen
decl_stmt|,
name|i
decl_stmt|,
name|n
decl_stmt|,
name|type
decl_stmt|,
name|class
decl_stmt|,
name|count
decl_stmt|;
name|char
name|dnbuf
index|[
name|MAXDNAME
index|]
decl_stmt|,
name|anbuf
index|[
name|PACKETSZ
index|]
decl_stmt|,
modifier|*
name|data
decl_stmt|,
modifier|*
name|fname
decl_stmt|;
name|struct
name|namebuf
modifier|*
name|np
decl_stmt|;
name|struct
name|qinfo
modifier|*
name|qp
decl_stmt|;
name|struct
name|databuf
modifier|*
name|dp
decl_stmt|;
name|stats
index|[
name|S_IQUERIES
index|]
operator|.
name|cnt
operator|++
expr_stmt|;
name|hp
operator|->
name|ancount
operator|=
name|htons
argument_list|(
name|hp
operator|->
name|ancount
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|hp
operator|->
name|ancount
operator|!=
literal|1
operator|)
operator|||
name|hp
operator|->
name|qdcount
operator|||
name|hp
operator|->
name|nscount
operator|||
name|hp
operator|->
name|arcount
condition|)
block|{
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"FORMERR IQuery header counts wrong\n"
operator|)
argument_list|)
expr_stmt|;
name|hp
operator|->
name|qdcount
operator|=
literal|0
expr_stmt|;
name|hp
operator|->
name|ancount
operator|=
literal|0
expr_stmt|;
name|hp
operator|->
name|nscount
operator|=
literal|0
expr_stmt|;
name|hp
operator|->
name|arcount
operator|=
literal|0
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
return|return
name|Finish
return|;
block|}
comment|/* 	 * Skip domain name, get class, and type. 	 */
if|if
condition|(
operator|(
name|n
operator|=
name|dn_skipname
argument_list|(
operator|*
name|cpp
argument_list|,
name|eom
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"FORMERR IQuery packet name problem\n"
operator|)
argument_list|)
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
return|return
name|Finish
return|;
block|}
operator|*
name|cpp
operator|+=
name|n
expr_stmt|;
name|GETSHORT
argument_list|(
name|type
argument_list|,
operator|*
name|cpp
argument_list|)
expr_stmt|;
name|GETSHORT
argument_list|(
name|class
argument_list|,
operator|*
name|cpp
argument_list|)
expr_stmt|;
operator|*
name|cpp
operator|+=
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
expr_stmt|;
comment|/* ttl */
name|GETSHORT
argument_list|(
name|dlen
argument_list|,
operator|*
name|cpp
argument_list|)
expr_stmt|;
operator|*
name|cpp
operator|+=
name|dlen
expr_stmt|;
if|if
condition|(
operator|*
name|cpp
operator|!=
name|eom
condition|)
block|{
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"FORMERR IQuery message length off\n"
operator|)
argument_list|)
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
return|return
name|Finish
return|;
block|}
comment|/* 	 * not all inverse queries are handled. 	 */
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|T_A
case|:
case|case
name|T_UID
case|:
case|case
name|T_GID
case|:
break|break;
default|default:
return|return
name|Refuse
return|;
block|}
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"req: IQuery class %d type %d\n"
operator|,
name|class
operator|,
name|type
operator|)
argument_list|)
expr_stmt|;
name|fname
operator|=
operator|(
name|char
operator|*
operator|)
name|msg
operator|+
sizeof|sizeof
argument_list|(
name|HEADER
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|fname
argument_list|,
name|anbuf
argument_list|,
name|alen
operator|=
operator|(
name|char
operator|*
operator|)
operator|*
name|cpp
operator|-
name|fname
argument_list|)
expr_stmt|;
name|data
operator|=
name|anbuf
operator|+
name|alen
operator|-
name|dlen
expr_stmt|;
operator|*
name|cpp
operator|=
operator|(
name|u_char
operator|*
operator|)
name|fname
expr_stmt|;
operator|*
name|buflenp
operator|-=
sizeof|sizeof
argument_list|(
name|HEADER
argument_list|)
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|ip
operator|=
name|invtab
index|[
name|dhash
argument_list|(
operator|(
name|u_char
operator|*
operator|)
name|data
argument_list|,
name|dlen
argument_list|)
index|]
init|;
name|ip
operator|!=
name|NULL
condition|;
name|ip
operator|=
name|ip
operator|->
name|i_next
control|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|INVBLKSZ
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|np
operator|=
name|ip
operator|->
name|i_dname
index|[
name|i
index|]
operator|)
operator|==
name|NULL
condition|)
break|break;
name|dprintf
argument_list|(
literal|5
argument_list|,
operator|(
name|ddt
operator|,
literal|"dname = %d\n"
operator|,
name|np
operator|->
name|n_dname
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|dp
operator|=
name|np
operator|->
name|n_data
init|;
name|dp
operator|!=
name|NULL
condition|;
name|dp
operator|=
name|dp
operator|->
name|d_next
control|)
block|{
if|if
condition|(
operator|!
name|match
argument_list|(
name|dp
argument_list|,
name|class
argument_list|,
name|type
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|dp
operator|->
name|d_size
operator|!=
name|dlen
operator|||
name|bcmp
argument_list|(
name|dp
operator|->
name|d_data
argument_list|,
name|data
argument_list|,
name|dlen
argument_list|)
condition|)
continue|continue;
name|getname
argument_list|(
name|np
argument_list|,
name|dnbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|dnbuf
argument_list|)
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
literal|2
argument_list|,
operator|(
name|ddt
operator|,
literal|"req: IQuery found %s\n"
operator|,
name|dnbuf
operator|)
argument_list|)
expr_stmt|;
operator|*
name|buflenp
operator|-=
name|QFIXEDSZ
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
name|dn_comp
argument_list|(
operator|(
name|u_char
operator|*
operator|)
name|dnbuf
argument_list|,
operator|*
name|cpp
argument_list|,
operator|*
name|buflenp
argument_list|,
operator|(
name|u_char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|u_char
operator|*
operator|*
operator|)
name|NULL
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|hp
operator|->
name|tc
operator|=
literal|1
expr_stmt|;
return|return
name|Finish
return|;
block|}
operator|*
name|cpp
operator|+=
name|n
expr_stmt|;
name|PUTSHORT
argument_list|(
operator|(
name|u_int16_t
operator|)
name|dp
operator|->
name|d_type
argument_list|,
operator|*
name|cpp
argument_list|)
expr_stmt|;
name|PUTSHORT
argument_list|(
operator|(
name|u_int16_t
operator|)
name|dp
operator|->
name|d_class
argument_list|,
operator|*
name|cpp
argument_list|)
expr_stmt|;
operator|*
name|buflenp
operator|-=
name|n
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
block|}
block|}
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"req: IQuery %d records\n"
operator|,
name|count
operator|)
argument_list|)
expr_stmt|;
name|hp
operator|->
name|qdcount
operator|=
name|htons
argument_list|(
operator|(
name|u_int16_t
operator|)
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|alen
operator|>
operator|*
name|buflenp
condition|)
block|{
name|hp
operator|->
name|tc
operator|=
literal|1
expr_stmt|;
return|return
name|Finish
return|;
block|}
name|bcopy
argument_list|(
name|anbuf
argument_list|,
operator|*
name|cpp
argument_list|,
name|alen
argument_list|)
expr_stmt|;
operator|*
name|cpp
operator|+=
name|alen
expr_stmt|;
return|return
name|Finish
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|fwritemsg
parameter_list|(
name|rfp
parameter_list|,
name|msg
parameter_list|,
name|msglen
parameter_list|)
name|FILE
modifier|*
name|rfp
decl_stmt|;
name|char
modifier|*
name|msg
decl_stmt|;
name|int
name|msglen
decl_stmt|;
block|{
name|u_int16_t
name|len
init|=
name|htons
argument_list|(
operator|(
name|u_int16_t
operator|)
name|msglen
argument_list|)
decl_stmt|;
if|if
condition|(
name|fwrite
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|len
argument_list|,
sizeof|sizeof
argument_list|(
name|len
argument_list|)
argument_list|,
literal|1
argument_list|,
name|rfp
argument_list|)
operator|!=
literal|1
operator|||
name|fwrite
argument_list|(
name|msg
argument_list|,
name|msglen
argument_list|,
literal|1
argument_list|,
name|rfp
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"fwrite failed %d\n"
operator|,
name|errno
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  *  Test a datum for validity and return non-zero if it is out of date.  */
end_comment

begin_function
name|int
name|stale
parameter_list|(
name|dp
parameter_list|)
specifier|register
name|struct
name|databuf
modifier|*
name|dp
decl_stmt|;
block|{
specifier|register
name|struct
name|zoneinfo
modifier|*
name|zp
init|=
operator|&
name|zones
index|[
name|dp
operator|->
name|d_zone
index|]
decl_stmt|;
switch|switch
condition|(
name|zp
operator|->
name|z_type
condition|)
block|{
case|case
name|Z_PRIMARY
case|:
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|Z_SECONDARY
case|:
ifdef|#
directive|ifdef
name|STUBS
case|case
name|Z_STUB
case|:
endif|#
directive|endif
comment|/* 		 * Check to see whether a secondary zone 		 * has expired; if so clear authority flag 		 * for zone and return true.  If lastupdate 		 * is in the future, assume zone is up-to-date. 		 */
if|if
condition|(
call|(
name|int32_t
call|)
argument_list|(
name|tt
operator|.
name|tv_sec
operator|-
name|zp
operator|->
name|z_lastupdate
argument_list|)
operator|>
operator|(
name|int32_t
operator|)
name|zp
operator|->
name|z_expire
condition|)
block|{
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"stale: secondary zone %s expired\n"
operator|,
name|zp
operator|->
name|z_origin
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|haveComplained
argument_list|(
name|zp
operator|->
name|z_origin
argument_list|,
operator|(
name|char
operator|*
operator|)
name|stale
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"secondary zone \"%s\" expired"
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|)
expr_stmt|;
block|}
name|zp
operator|->
name|z_state
operator|&=
operator|~
name|Z_AUTH
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|Z_CACHE
case|:
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"stale: ttl %d %d (x%x)\n"
operator|,
name|dp
operator|->
name|d_ttl
operator|,
name|dp
operator|->
name|d_ttl
operator|-
name|tt
operator|.
name|tv_sec
operator|,
name|dp
operator|->
name|d_flags
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|d_flags
operator|&
name|DB_F_HINT
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|dp
operator|->
name|d_ttl
operator|<
name|tt
operator|.
name|tv_sec
operator|)
return|;
block|}
name|abort
argument_list|()
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_function

begin_comment
comment|/*  * Copy databuf into a resource record for replies.  * Return size of RR if OK, -1 if buffer is full.  */
end_comment

begin_function
name|int
name|make_rr
parameter_list|(
name|name
parameter_list|,
name|dp
parameter_list|,
name|buf
parameter_list|,
name|buflen
parameter_list|,
name|doadd
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
specifier|register
name|struct
name|databuf
modifier|*
name|dp
decl_stmt|;
name|u_char
modifier|*
name|buf
decl_stmt|;
name|int
name|buflen
decl_stmt|,
name|doadd
decl_stmt|;
block|{
specifier|register
name|u_char
modifier|*
name|cp
decl_stmt|;
name|u_char
modifier|*
name|cp1
decl_stmt|,
modifier|*
name|sp
decl_stmt|;
name|struct
name|zoneinfo
modifier|*
name|zp
decl_stmt|;
specifier|register
name|int32_t
name|n
decl_stmt|;
specifier|register
name|int32_t
name|ttl
decl_stmt|;
name|u_char
modifier|*
modifier|*
name|edp
init|=
name|dnptrs
operator|+
sizeof|sizeof
argument_list|(
name|dnptrs
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|dnptrs
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|dprintf
argument_list|(
literal|5
argument_list|,
operator|(
name|ddt
operator|,
literal|"make_rr(%s, %x, %x, %d, %d) %d zone %d ttl %d\n"
operator|,
name|name
operator|,
name|dp
operator|,
name|buf
operator|,
name|buflen
operator|,
name|doadd
operator|,
name|dp
operator|->
name|d_size
operator|,
name|dp
operator|->
name|d_zone
operator|,
name|dp
operator|->
name|d_ttl
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NCACHE
if|if
condition|(
name|dp
operator|->
name|d_rcode
condition|)
block|{
name|syslog
argument_list|(
name|LOG_CRIT
argument_list|,
literal|"make_rr d_rcode %d"
argument_list|,
name|dp
operator|->
name|d_rcode
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
operator|-
literal|1
return|;
comment|/* XXX We should exit here */
block|}
endif|#
directive|endif
name|zp
operator|=
operator|&
name|zones
index|[
name|dp
operator|->
name|d_zone
index|]
expr_stmt|;
comment|/* check for outdated RR before updating dnptrs by dn_comp() (???) */
if|if
condition|(
name|zp
operator|->
name|z_type
operator|==
name|Z_CACHE
condition|)
block|{
name|ttl
operator|=
name|dp
operator|->
name|d_ttl
operator|-
operator|(
name|u_int32_t
operator|)
name|tt
operator|.
name|tv_sec
expr_stmt|;
if|if
condition|(
operator|(
name|dp
operator|->
name|d_flags
operator|&
name|DB_F_HINT
operator|)
operator|||
operator|(
name|ttl
operator|<
literal|0
operator|)
condition|)
block|{
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"make_rr: %d=>0, x%x\n"
operator|,
name|ttl
operator|,
name|dp
operator|->
name|d_flags
operator|)
argument_list|)
expr_stmt|;
comment|/* XXX */
name|ttl
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|dp
operator|->
name|d_ttl
condition|)
name|ttl
operator|=
name|dp
operator|->
name|d_ttl
expr_stmt|;
else|else
name|ttl
operator|=
name|zp
operator|->
name|z_minimum
expr_stmt|;
comment|/* really default */
ifdef|#
directive|ifdef
name|notdef
comment|/* don't decrease ttl based on time since verification */
if|if
condition|(
name|zp
operator|->
name|z_type
operator|==
name|Z_SECONDARY
condition|)
block|{
comment|/* 			 * Set ttl to value received from primary, 			 * less time since we verified it (but never 			 * less than a small positive value). 			 */
name|ttl
operator|-=
name|tt
operator|.
name|tv_sec
operator|-
name|zp
operator|->
name|z_lastupdate
expr_stmt|;
if|if
condition|(
name|ttl
operator|<=
literal|0
condition|)
name|ttl
operator|=
literal|120
expr_stmt|;
block|}
endif|#
directive|endif
block|}
name|buflen
operator|-=
name|RRFIXEDSZ
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
name|dn_comp
argument_list|(
operator|(
name|u_char
operator|*
operator|)
name|name
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|buf
argument_list|,
name|buflen
argument_list|,
operator|(
name|u_char
operator|*
operator|*
operator|)
name|dnptrs
argument_list|,
operator|(
name|u_char
operator|*
operator|*
operator|)
name|edp
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|cp
operator|=
name|buf
operator|+
name|n
expr_stmt|;
name|buflen
operator|-=
name|n
expr_stmt|;
name|PUTSHORT
argument_list|(
operator|(
name|u_int16_t
operator|)
name|dp
operator|->
name|d_type
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|PUTSHORT
argument_list|(
operator|(
name|u_int16_t
operator|)
name|dp
operator|->
name|d_class
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|PUTLONG
argument_list|(
name|ttl
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|sp
operator|=
name|cp
expr_stmt|;
name|cp
operator|+=
sizeof|sizeof
argument_list|(
name|u_int16_t
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|dp
operator|->
name|d_type
condition|)
block|{
case|case
name|T_CNAME
case|:
case|case
name|T_MG
case|:
case|case
name|T_MR
case|:
case|case
name|T_PTR
case|:
if|if
condition|(
operator|(
name|n
operator|=
name|dn_comp
argument_list|(
operator|(
name|u_char
operator|*
operator|)
name|dp
operator|->
name|d_data
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|cp
argument_list|,
name|buflen
argument_list|,
operator|(
name|u_char
operator|*
operator|*
operator|)
name|dnptrs
argument_list|,
operator|(
name|u_char
operator|*
operator|*
operator|)
name|edp
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|PUTSHORT
argument_list|(
operator|(
name|u_int16_t
operator|)
name|n
argument_list|,
name|sp
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
break|break;
case|case
name|T_MB
case|:
case|case
name|T_NS
case|:
comment|/* Store domain name in answer */
if|if
condition|(
operator|(
name|n
operator|=
name|dn_comp
argument_list|(
operator|(
name|u_char
operator|*
operator|)
name|dp
operator|->
name|d_data
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|cp
argument_list|,
name|buflen
argument_list|,
operator|(
name|u_char
operator|*
operator|*
operator|)
name|dnptrs
argument_list|,
operator|(
name|u_char
operator|*
operator|*
operator|)
name|edp
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|PUTSHORT
argument_list|(
operator|(
name|u_int16_t
operator|)
name|n
argument_list|,
name|sp
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
if|if
condition|(
name|doadd
condition|)
name|addname
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dp
operator|->
name|d_data
argument_list|,
name|dp
operator|->
name|d_class
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_SOA
case|:
case|case
name|T_MINFO
case|:
case|case
name|T_RP
case|:
name|cp1
operator|=
name|dp
operator|->
name|d_data
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
name|dn_comp
argument_list|(
operator|(
name|u_char
operator|*
operator|)
name|cp1
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|cp
argument_list|,
name|buflen
argument_list|,
operator|(
name|u_char
operator|*
operator|*
operator|)
name|dnptrs
argument_list|,
operator|(
name|u_char
operator|*
operator|*
operator|)
name|edp
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|cp
operator|+=
name|n
expr_stmt|;
name|buflen
operator|-=
name|dp
operator|->
name|d_type
operator|==
name|T_SOA
condition|?
name|n
operator|+
literal|5
operator|*
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
else|:
name|n
expr_stmt|;
name|cp1
operator|+=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp1
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
name|dn_comp
argument_list|(
operator|(
name|u_char
operator|*
operator|)
name|cp1
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|cp
argument_list|,
name|buflen
argument_list|,
operator|(
name|u_char
operator|*
operator|*
operator|)
name|dnptrs
argument_list|,
operator|(
name|u_char
operator|*
operator|*
operator|)
name|edp
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|cp
operator|+=
name|n
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|d_type
operator|==
name|T_SOA
condition|)
block|{
name|cp1
operator|+=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp1
argument_list|)
operator|+
literal|1
expr_stmt|;
name|bcopy
argument_list|(
name|cp1
argument_list|,
name|cp
argument_list|,
call|(
name|int
call|)
argument_list|(
name|n
operator|=
name|dp
operator|->
name|d_size
operator|-
operator|(
name|cp1
operator|-
name|dp
operator|->
name|d_data
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
block|}
name|n
operator|=
call|(
name|u_int16_t
call|)
argument_list|(
operator|(
name|cp
operator|-
name|sp
operator|)
operator|-
sizeof|sizeof
argument_list|(
name|u_int16_t
argument_list|)
argument_list|)
expr_stmt|;
name|PUTSHORT
argument_list|(
operator|(
name|u_int16_t
operator|)
name|n
argument_list|,
name|sp
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_MX
case|:
case|case
name|T_AFSDB
case|:
comment|/* cp1 == our data/ cp == data of RR */
name|cp1
operator|=
name|dp
operator|->
name|d_data
expr_stmt|;
comment|/* copy preference */
name|bcopy
argument_list|(
name|cp1
argument_list|,
name|cp
argument_list|,
sizeof|sizeof
argument_list|(
name|u_int16_t
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|+=
sizeof|sizeof
argument_list|(
name|u_int16_t
argument_list|)
expr_stmt|;
name|cp1
operator|+=
sizeof|sizeof
argument_list|(
name|u_int16_t
argument_list|)
expr_stmt|;
name|buflen
operator|-=
sizeof|sizeof
argument_list|(
name|u_int16_t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
name|dn_comp
argument_list|(
operator|(
name|u_char
operator|*
operator|)
name|cp1
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|cp
argument_list|,
name|buflen
argument_list|,
operator|(
name|u_char
operator|*
operator|*
operator|)
name|dnptrs
argument_list|,
operator|(
name|u_char
operator|*
operator|*
operator|)
name|edp
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|cp
operator|+=
name|n
expr_stmt|;
comment|/* save data length */
name|n
operator|=
call|(
name|u_int16_t
call|)
argument_list|(
operator|(
name|cp
operator|-
name|sp
operator|)
operator|-
sizeof|sizeof
argument_list|(
name|u_int16_t
argument_list|)
argument_list|)
expr_stmt|;
name|PUTSHORT
argument_list|(
operator|(
name|u_int16_t
operator|)
name|n
argument_list|,
name|sp
argument_list|)
expr_stmt|;
if|if
condition|(
name|doadd
condition|)
name|addname
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp1
argument_list|,
name|dp
operator|->
name|d_class
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|dp
operator|->
name|d_size
operator|>
name|buflen
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|bcopy
argument_list|(
name|dp
operator|->
name|d_data
argument_list|,
name|cp
argument_list|,
name|dp
operator|->
name|d_size
argument_list|)
expr_stmt|;
name|PUTSHORT
argument_list|(
operator|(
name|u_int16_t
operator|)
name|dp
operator|->
name|d_size
argument_list|,
name|sp
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|dp
operator|->
name|d_size
expr_stmt|;
block|}
return|return
operator|(
name|cp
operator|-
name|buf
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__STDC__
argument_list|)
operator|||
name|defined
argument_list|(
name|__GNUC__
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|void
name|addname
argument_list|(
specifier|register
name|char
operator|*
name|name
argument_list|,
name|u_int16_t
name|class
argument_list|)
else|#
directive|else
decl|static
name|void
name|addname
argument_list|(
name|name
argument_list|,
name|class
argument_list|)
decl|register
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int16_t
name|class
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
specifier|register
name|struct
name|addinfo
modifier|*
name|ap
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
for|for
control|(
name|ap
operator|=
name|addinfo
operator|,
name|n
operator|=
name|addcount
init|;
operator|--
name|n
operator|>=
literal|0
condition|;
name|ap
operator|++
control|)
if|if
condition|(
name|strcasecmp
argument_list|(
name|ap
operator|->
name|a_dname
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return;
comment|/* add domain name to additional section */
if|if
condition|(
name|addcount
operator|<
name|NADDRECS
condition|)
block|{
name|addcount
operator|++
expr_stmt|;
name|ap
operator|->
name|a_dname
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|ap
operator|->
name|a_dname
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|ap
operator|->
name|a_class
operator|=
name|class
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Lookup addresses for names in addinfo and put into the message's  * additional section.  */
end_comment

begin_function
name|int
name|doaddinfo
parameter_list|(
name|hp
parameter_list|,
name|msg
parameter_list|,
name|msglen
parameter_list|)
name|HEADER
modifier|*
name|hp
decl_stmt|;
name|u_char
modifier|*
name|msg
decl_stmt|;
name|int
name|msglen
decl_stmt|;
block|{
specifier|register
name|struct
name|namebuf
modifier|*
name|np
decl_stmt|;
specifier|register
name|struct
name|databuf
modifier|*
name|dp
decl_stmt|;
specifier|register
name|struct
name|addinfo
modifier|*
name|ap
decl_stmt|;
specifier|register
name|u_char
modifier|*
name|cp
decl_stmt|;
name|struct
name|hashbuf
modifier|*
name|htp
decl_stmt|;
name|char
modifier|*
name|fname
decl_stmt|;
name|int
name|n
decl_stmt|,
name|count
decl_stmt|;
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"doaddinfo() addcount = %d\n"
operator|,
name|addcount
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|tc
condition|)
block|{
name|dprintf
argument_list|(
literal|4
argument_list|,
operator|(
name|ddt
operator|,
literal|"doaddinfo(): tc already set, bailing\n"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|count
operator|=
literal|0
expr_stmt|;
name|cp
operator|=
name|msg
expr_stmt|;
for|for
control|(
name|ap
operator|=
name|addinfo
init|;
operator|--
name|addcount
operator|>=
literal|0
condition|;
name|ap
operator|++
control|)
block|{
name|int
name|foundstale
init|=
literal|0
decl_stmt|,
name|foundany
init|=
literal|0
decl_stmt|,
name|save_count
init|=
name|count
decl_stmt|,
name|save_msglen
init|=
name|msglen
decl_stmt|;
name|u_char
modifier|*
name|save_cp
init|=
name|cp
decl_stmt|;
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"do additional '%s'\n"
operator|,
name|ap
operator|->
name|a_dname
operator|)
argument_list|)
expr_stmt|;
name|htp
operator|=
name|hashtab
expr_stmt|;
comment|/* because "nlookup" stomps on arg. */
name|np
operator|=
name|nlookup
argument_list|(
name|ap
operator|->
name|a_dname
argument_list|,
operator|&
name|htp
argument_list|,
operator|&
name|fname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|==
name|NULL
operator|||
name|fname
operator|!=
name|ap
operator|->
name|a_dname
condition|)
goto|goto
name|next_rr
goto|;
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"found it\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* look for the data */
for|for
control|(
name|dp
operator|=
name|np
operator|->
name|n_data
init|;
name|dp
operator|!=
name|NULL
condition|;
name|dp
operator|=
name|dp
operator|->
name|d_next
control|)
block|{
if|if
condition|(
operator|(
operator|!
name|match
argument_list|(
name|dp
argument_list|,
operator|(
name|int
operator|)
name|ap
operator|->
name|a_class
argument_list|,
name|T_A
argument_list|)
operator|)
operator|&&
operator|(
operator|!
name|match
argument_list|(
name|dp
argument_list|,
name|C_IN
argument_list|,
name|T_A
argument_list|)
operator|)
condition|)
block|{
continue|continue;
block|}
name|foundany
operator|++
expr_stmt|;
if|if
condition|(
name|stale
argument_list|(
name|dp
argument_list|)
condition|)
block|{
name|foundstale
operator|++
expr_stmt|;
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"doaddinfo: stale entry '%s'%s\n"
operator|,
name|np
operator|->
name|n_dname
operator|,
operator|(
name|dp
operator|->
name|d_flags
operator|&
name|DB_F_HINT
operator|)
condition|?
literal|" hint"
else|:
literal|""
operator|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
ifdef|#
directive|ifdef
name|NCACHE
if|if
condition|(
name|dp
operator|->
name|d_rcode
condition|)
continue|continue;
endif|#
directive|endif
comment|/* 			 *  Should be smart and eliminate duplicate 			 *  data here.	XXX 			 */
if|if
condition|(
operator|(
name|n
operator|=
name|make_rr
argument_list|(
name|ap
operator|->
name|a_dname
argument_list|,
name|dp
argument_list|,
name|cp
argument_list|,
name|msglen
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
comment|/* truncation in the additional-data section 				 * is not all that serious.  we do not set TC, 				 * since the answer and authority sections are 				 * OK; however, since we're not setting TC we 				 * have to make sure that none of the RR's for 				 * this name go out (!TC implies that all 				 * {name,type} appearances are complete -- and 				 * since we only do A RR's here, the name is 				 * the key).	vixie, 23apr93 				 */
name|cp
operator|=
name|save_cp
expr_stmt|;
name|msglen
operator|=
name|save_msglen
expr_stmt|;
name|count
operator|=
name|save_count
expr_stmt|;
break|break;
block|}
name|dprintf
argument_list|(
literal|5
argument_list|,
operator|(
name|ddt
operator|,
literal|"addinfo: adding address data n = %d\n"
operator|,
name|n
operator|)
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
name|msglen
operator|-=
name|n
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
name|next_rr
label|:
if|if
condition|(
name|foundstale
condition|)
block|{
comment|/* Cache invalidate the address RR's */
name|delete_all
argument_list|(
name|np
argument_list|,
operator|(
name|int
operator|)
name|ap
operator|->
name|a_class
argument_list|,
name|T_A
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|foundstale
operator|||
operator|!
name|foundany
condition|)
block|{
comment|/* ask a real server for this info */
operator|(
name|void
operator|)
name|sysquery
argument_list|(
name|ap
operator|->
name|a_dname
argument_list|,
operator|(
name|int
operator|)
name|ap
operator|->
name|a_class
argument_list|,
name|T_A
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|ap
operator|->
name|a_dname
argument_list|)
expr_stmt|;
block|}
name|hp
operator|->
name|arcount
operator|=
name|htons
argument_list|(
operator|(
name|u_int16_t
operator|)
name|count
argument_list|)
expr_stmt|;
return|return
operator|(
name|cp
operator|-
name|msg
operator|)
return|;
block|}
end_function

begin_function
name|int
name|doaddauth
parameter_list|(
name|hp
parameter_list|,
name|cp
parameter_list|,
name|buflen
parameter_list|,
name|np
parameter_list|,
name|dp
parameter_list|)
specifier|register
name|HEADER
modifier|*
name|hp
decl_stmt|;
name|u_char
modifier|*
name|cp
decl_stmt|;
name|int
name|buflen
decl_stmt|;
name|struct
name|namebuf
modifier|*
name|np
decl_stmt|;
name|struct
name|databuf
modifier|*
name|dp
decl_stmt|;
block|{
name|char
name|dnbuf
index|[
name|MAXDNAME
index|]
decl_stmt|;
name|int
name|n
decl_stmt|;
name|getname
argument_list|(
name|np
argument_list|,
name|dnbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|dnbuf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|stale
argument_list|(
name|dp
argument_list|)
condition|)
block|{
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"doaddauth: can't add stale '%s' (%d) (n=%d)\n"
operator|,
name|dnbuf
operator|,
name|buflen
operator|,
name|n
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|n
operator|=
name|make_rr
argument_list|(
name|dnbuf
argument_list|,
name|dp
argument_list|,
name|cp
argument_list|,
name|buflen
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<=
literal|0
condition|)
block|{
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"doaddauth: can't add oversize '%s' (%d) (n=%d)\n"
operator|,
name|dnbuf
operator|,
name|buflen
operator|,
name|n
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|hp
operator|->
name|tc
operator|=
literal|1
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
name|hp
operator|->
name|nscount
operator|=
name|htons
argument_list|(
operator|(
name|u_int16_t
operator|)
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|n
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Do a zone transfer (or a recursive part of a zone transfer).  * SOA record already sent.  *  * top always refers to the domain at the top of the zone being transferred.  * np refers to a domain inside the zone being transferred,  *	which will be equal to top if this is the first call,  *	or will be a subdomain below top if this is a recursive call,  * rfp is a stdio file to which output is sent.  */
end_comment

begin_function
specifier|static
name|void
name|doaxfr
parameter_list|(
name|np
parameter_list|,
name|rfp
parameter_list|,
name|top
parameter_list|,
name|class
parameter_list|)
specifier|register
name|struct
name|namebuf
modifier|*
name|np
decl_stmt|;
name|FILE
modifier|*
name|rfp
decl_stmt|;
name|struct
name|namebuf
modifier|*
name|top
decl_stmt|;
name|int
name|class
decl_stmt|;
comment|/* Class to transfer */
block|{
specifier|register
name|struct
name|databuf
modifier|*
name|dp
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
name|struct
name|hashbuf
modifier|*
name|htp
decl_stmt|;
name|struct
name|databuf
modifier|*
name|gdp
decl_stmt|;
comment|/* glue databuf */
name|struct
name|namebuf
modifier|*
name|gnp
decl_stmt|;
comment|/* glue namebuf */
name|struct
name|namebuf
modifier|*
name|tnp
decl_stmt|;
comment|/* top namebuf */
name|struct
name|databuf
modifier|*
name|tdp
decl_stmt|;
comment|/* top databuf */
name|struct
name|namebuf
modifier|*
modifier|*
name|npp
decl_stmt|,
modifier|*
modifier|*
name|nppend
decl_stmt|;
name|char
name|msg
index|[
name|PACKETSZ
index|]
decl_stmt|;
name|u_char
modifier|*
name|cp
decl_stmt|;
name|char
modifier|*
name|fname
decl_stmt|;
name|char
name|dname
index|[
name|MAXDNAME
index|]
decl_stmt|;
name|HEADER
modifier|*
name|hp
init|=
operator|(
name|HEADER
operator|*
operator|)
name|msg
decl_stmt|;
name|int
name|fndns
decl_stmt|;
if|if
condition|(
name|np
operator|==
name|top
condition|)
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"doaxfr()\n"
operator|)
argument_list|)
expr_stmt|;
name|fndns
operator|=
literal|0
expr_stmt|;
name|hp
operator|->
name|id
operator|=
literal|0
expr_stmt|;
name|hp
operator|->
name|opcode
operator|=
name|QUERY
expr_stmt|;
name|hp
operator|->
name|aa
operator|=
name|hp
operator|->
name|tc
operator|=
name|hp
operator|->
name|ra
operator|=
name|hp
operator|->
name|pr
operator|=
name|hp
operator|->
name|rd
operator|=
literal|0
expr_stmt|;
name|hp
operator|->
name|qr
operator|=
literal|1
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|NOERROR
expr_stmt|;
name|hp
operator|->
name|qdcount
operator|=
literal|0
expr_stmt|;
name|hp
operator|->
name|ancount
operator|=
name|htons
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|hp
operator|->
name|nscount
operator|=
literal|0
expr_stmt|;
name|hp
operator|->
name|arcount
operator|=
literal|0
expr_stmt|;
name|cp
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|(
name|msg
operator|+
sizeof|sizeof
argument_list|(
name|HEADER
argument_list|)
operator|)
expr_stmt|;
name|getname
argument_list|(
name|np
argument_list|,
name|dname
argument_list|,
sizeof|sizeof
argument_list|(
name|dname
argument_list|)
argument_list|)
expr_stmt|;
comment|/* first do the NS records (del@harris) */
for|for
control|(
name|dp
operator|=
name|np
operator|->
name|n_data
init|;
name|dp
operator|!=
name|NULL
condition|;
name|dp
operator|=
name|dp
operator|->
name|d_next
control|)
block|{
ifdef|#
directive|ifdef
name|GEN_AXFR
if|if
condition|(
name|dp
operator|->
name|d_class
operator|!=
name|class
operator|&&
name|class
operator|!=
name|C_ANY
condition|)
continue|continue;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|NCACHE
if|if
condition|(
name|dp
operator|->
name|d_rcode
condition|)
continue|continue;
endif|#
directive|endif
if|if
condition|(
name|dp
operator|->
name|d_type
operator|==
name|T_NS
condition|)
block|{
name|fndns
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
name|make_rr
argument_list|(
name|dname
argument_list|,
name|dp
argument_list|,
name|cp
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|HEADER
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
continue|continue;
name|fwritemsg
argument_list|(
name|rfp
argument_list|,
name|msg
argument_list|,
name|n
operator|+
sizeof|sizeof
argument_list|(
name|HEADER
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|!=
name|top
condition|)
block|{
comment|/*  Glue the sub domains together by sending  		     *  the address records for the sub domain 		     *  name servers along if necessary. 		     *  Glue is necessary if the server is in any zone 		     *  delegated from the current (top) zone.  Such 		     *  a delegated zone might or might not be that 		     *  referred to by the NS record now being handled. 		     */
name|htp
operator|=
name|hashtab
expr_stmt|;
name|cp
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|(
name|msg
operator|+
sizeof|sizeof
argument_list|(
name|HEADER
argument_list|)
operator|)
expr_stmt|;
name|gnp
operator|=
name|nlookup
argument_list|(
operator|(
name|caddr_t
operator|)
name|dp
operator|->
name|d_data
argument_list|,
operator|&
name|htp
argument_list|,
operator|&
name|fname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|gnp
operator|==
name|NULL
operator|||
name|fname
operator|!=
operator|(
name|caddr_t
operator|)
name|dp
operator|->
name|d_data
condition|)
continue|continue;
for|for
control|(
name|tnp
operator|=
name|gnp
init|;
name|tnp
operator|!=
name|NULL
condition|;
name|tnp
operator|=
name|tnp
operator|->
name|n_parent
control|)
if|if
condition|(
name|tnp
operator|==
name|top
condition|)
break|break;
if|if
condition|(
name|tnp
operator|==
name|NULL
condition|)
continue|continue;
comment|/* name server is not below top domain */
for|for
control|(
name|tnp
operator|=
name|gnp
init|;
name|tnp
operator|!=
name|top
condition|;
name|tnp
operator|=
name|tnp
operator|->
name|n_parent
control|)
block|{
for|for
control|(
name|tdp
operator|=
name|tnp
operator|->
name|n_data
init|;
name|tdp
operator|!=
name|NULL
condition|;
name|tdp
operator|=
name|tdp
operator|->
name|d_next
control|)
block|{
ifdef|#
directive|ifdef
name|GEN_AXFR
if|if
condition|(
name|tdp
operator|->
name|d_class
operator|!=
name|class
operator|&&
name|class
operator|!=
name|C_ANY
condition|)
continue|continue;
endif|#
directive|endif
if|if
condition|(
name|tdp
operator|->
name|d_type
operator|==
name|T_NS
condition|)
break|break;
block|}
if|if
condition|(
name|tdp
operator|!=
name|NULL
condition|)
break|break;
comment|/* found a zone cut */
block|}
if|if
condition|(
name|tnp
operator|==
name|top
condition|)
continue|continue;
comment|/* name server is not in a delegated zone */
comment|/* now we know glue records are needed.  send them. */
for|for
control|(
name|gdp
operator|=
name|gnp
operator|->
name|n_data
init|;
name|gdp
operator|!=
name|NULL
condition|;
name|gdp
operator|=
name|gdp
operator|->
name|d_next
control|)
block|{
ifdef|#
directive|ifdef
name|GEN_AXFR
if|if
condition|(
name|gdp
operator|->
name|d_class
operator|!=
name|class
operator|&&
name|class
operator|!=
name|C_ANY
condition|)
continue|continue;
endif|#
directive|endif
if|if
condition|(
name|gdp
operator|->
name|d_type
operator|!=
name|T_A
operator|||
name|stale
argument_list|(
name|gdp
argument_list|)
condition|)
continue|continue;
ifdef|#
directive|ifdef
name|NCACHE
if|if
condition|(
name|gdp
operator|->
name|d_rcode
condition|)
continue|continue;
endif|#
directive|endif
if|if
condition|(
operator|(
name|n
operator|=
name|make_rr
argument_list|(
name|fname
argument_list|,
name|gdp
argument_list|,
name|cp
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|HEADER
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
continue|continue;
name|fwritemsg
argument_list|(
name|rfp
argument_list|,
name|msg
argument_list|,
name|n
operator|+
sizeof|sizeof
argument_list|(
name|HEADER
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* no need to send anything else because of delegation */
if|if
condition|(
operator|(
name|np
operator|!=
name|top
operator|)
operator|&&
name|fndns
condition|)
return|return;
comment|/* do the rest of the data records */
for|for
control|(
name|dp
operator|=
name|np
operator|->
name|n_data
init|;
name|dp
operator|!=
name|NULL
condition|;
name|dp
operator|=
name|dp
operator|->
name|d_next
control|)
block|{
ifdef|#
directive|ifdef
name|GEN_AXFR
if|if
condition|(
name|dp
operator|->
name|d_class
operator|!=
name|class
operator|&&
name|class
operator|!=
name|C_ANY
condition|)
continue|continue;
endif|#
directive|endif
comment|/* 		 * Skip the top SOA record (marks end of data); 		 * don't send SOA for subdomains, as we're not sending them; 		 * skip the NS records because we did them first. 		 */
if|if
condition|(
name|dp
operator|->
name|d_type
operator|==
name|T_SOA
operator|||
name|dp
operator|->
name|d_type
operator|==
name|T_NS
condition|)
continue|continue;
if|if
condition|(
name|dp
operator|->
name|d_zone
operator|==
literal|0
operator|||
name|stale
argument_list|(
name|dp
argument_list|)
condition|)
continue|continue;
ifdef|#
directive|ifdef
name|NCACHE
if|if
condition|(
name|dp
operator|->
name|d_rcode
condition|)
continue|continue;
endif|#
directive|endif
if|if
condition|(
operator|(
name|n
operator|=
name|make_rr
argument_list|(
name|dname
argument_list|,
name|dp
argument_list|,
name|cp
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|HEADER
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
continue|continue;
name|fwritemsg
argument_list|(
name|rfp
argument_list|,
name|msg
argument_list|,
name|n
operator|+
sizeof|sizeof
argument_list|(
name|HEADER
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Finally do non-delegated subdomains.  Delegated subdomains 	 * have already been handled. 	 */
comment|/* 	 * We find the subdomains by looking in the hash table for this 	 * domain, but the root domain needs special treatment, because 	 * of the following wart in the database design: 	 * 	 * The top level hash table (pointed to by the global `hashtab' 	 * variable) contains pointers to the namebuf's for the root as 	 * well as for the top-level domains below the root, in contrast 	 * to the usual situation where a hash table contains entries 	 * for domains at the same level.  The n_hash member of the 	 * namebuf for the root domain is NULL instead of pointing to a 	 * hashbuf for the top-level domains.  The n_parent members of 	 * the namebufs for the top-level domains are NULL instead of 	 * pointing to the namebuf for the root. 	 * 	 * We work around the wart as follows: 	 * 	 * If we are not dealing with the root zone then we just set 	 * htp = np->n_hash, pointing to the hash table for the current 	 * domain, and we walk through the hash table as usual, 	 * processing the namebufs for all the subdomains. 	 * 	 * If we are dealing with the root zone, then we set 	 * htp = hashtab, pointing to the global hash table (because 	 * there is no hash table associated with the root domain's 	 * namebuf.  While we walk this hash table, we take care not to 	 * recursively process the entry for the root namebuf. 	 * 	 * (apb@und nov1990) 	 */
name|htp
operator|=
operator|(
operator|(
name|dname
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|)
condition|?
name|hashtab
else|:
name|np
operator|->
name|n_hash
operator|)
expr_stmt|;
if|if
condition|(
name|htp
operator|==
name|NULL
condition|)
block|{
return|return;
comment|/* no subdomains */
block|}
name|npp
operator|=
name|htp
operator|->
name|h_tab
expr_stmt|;
name|nppend
operator|=
name|npp
operator|+
name|htp
operator|->
name|h_size
expr_stmt|;
while|while
condition|(
name|npp
operator|<
name|nppend
condition|)
block|{
for|for
control|(
name|np
operator|=
operator|*
name|npp
operator|++
init|;
name|np
operator|!=
name|NULL
condition|;
name|np
operator|=
name|np
operator|->
name|n_next
control|)
block|{
if|if
condition|(
name|np
operator|->
name|n_dname
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
comment|/* don't redo root domain */
name|doaxfr
argument_list|(
name|np
argument_list|,
name|rfp
argument_list|,
name|top
argument_list|,
name|class
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|np
operator|==
name|top
condition|)
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"exit doaxfr()\n"
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|ALLOW_UPDATES
end_ifdef

begin_comment
comment|/*  * Called by UPDATE{A,D,DA,M,MA} to initiate a dynamic update.  If this is the  * primary server for the zone being updated, we update the zone's serial  * number and then call doupdate directly. If this is a secondary, we just  * forward the update; this way, if the primary update fails (e.g., if the  * primary is unavailable), we don't update the secondary; if the primary  * update suceeds, ns_resp will get called with the response (when it comes  * in), and then update the secondary's copy.  */
end_comment

begin_function
specifier|static
name|int
name|InitDynUpdate
parameter_list|(
name|hp
parameter_list|,
name|msg
parameter_list|,
name|msglen
parameter_list|,
name|startcp
parameter_list|,
name|from
parameter_list|,
name|qsp
parameter_list|,
name|dfd
parameter_list|)
specifier|register
name|HEADER
modifier|*
name|hp
decl_stmt|;
name|char
modifier|*
name|msg
decl_stmt|;
name|int
name|msglen
decl_stmt|;
name|u_char
modifier|*
name|startcp
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|from
decl_stmt|;
name|struct
name|qstream
modifier|*
name|qsp
decl_stmt|;
name|int
name|dfd
decl_stmt|;
block|{
name|struct
name|databuf
modifier|*
name|nsp
index|[
name|NSMAX
index|]
decl_stmt|;
name|struct
name|zoneinfo
modifier|*
name|zp
decl_stmt|;
name|char
name|dnbuf
index|[
name|MAXDNAME
index|]
decl_stmt|;
name|struct
name|hashbuf
modifier|*
name|htp
init|=
name|hashtab
decl_stmt|;
comment|/* lookup relative to root */
name|struct
name|namebuf
modifier|*
name|np
decl_stmt|;
name|struct
name|databuf
modifier|*
name|olddp
decl_stmt|,
modifier|*
name|newdp
decl_stmt|,
modifier|*
name|dp
decl_stmt|;
name|struct
name|databuf
modifier|*
modifier|*
name|nspp
decl_stmt|;
name|char
modifier|*
name|fname
decl_stmt|;
specifier|register
name|u_char
modifier|*
name|cp
init|=
name|startcp
decl_stmt|;
name|u_int16_t
name|class
decl_stmt|,
name|type
decl_stmt|;
name|int
name|n
decl_stmt|,
name|size
decl_stmt|,
name|zonenum
decl_stmt|;
name|char
name|ZoneName
index|[
name|MAXDNAME
index|]
decl_stmt|,
modifier|*
name|znp
decl_stmt|;
ifdef|#
directive|ifdef
name|DATUMREFCNT
name|nsp
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|n
operator|=
name|dn_expand
argument_list|(
name|msg
argument_list|,
name|msg
operator|+
name|msglen
argument_list|,
name|cp
argument_list|,
name|dnbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|dnbuf
argument_list|)
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"FORMERR InitDynUpdate expand name failed\n"
operator|)
argument_list|)
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
return|return
operator|(
name|FORMERR
operator|)
return|;
block|}
name|cp
operator|+=
name|n
expr_stmt|;
name|GETSHORT
argument_list|(
name|type
argument_list|,
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|T_SOA
condition|)
block|{
comment|/* T_SOA updates not allowed */
name|hp
operator|->
name|rcode
operator|=
name|REFUSED
expr_stmt|;
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"InitDynUpdate: REFUSED - SOA update\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|REFUSED
operator|)
return|;
block|}
name|GETSHORT
argument_list|(
name|class
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|+=
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
expr_stmt|;
name|GETSHORT
argument_list|(
name|size
argument_list|,
name|cp
argument_list|)
expr_stmt|;
comment|/****XXX - need bounds checking here ****/
name|cp
operator|+=
name|size
expr_stmt|;
if|if
condition|(
operator|(
name|zonenum
operator|=
name|findzone
argument_list|(
name|dnbuf
argument_list|,
name|class
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* zone not found */
name|hp
operator|->
name|rcode
operator|=
name|NXDOMAIN
expr_stmt|;
return|return
operator|(
name|NXDOMAIN
operator|)
return|;
block|}
name|zp
operator|=
operator|&
name|zones
index|[
name|zonenum
index|]
expr_stmt|;
comment|/* Disallow updates for which we aren't authoratative.  Note: the 	   following test doesn't work right:  If it's for a non-local zone, 	   we will think it's a primary but be unable to lookup the namebuf, 	   thus returning 'NXDOMAIN' */
if|if
condition|(
name|zp
operator|->
name|z_type
operator|!=
name|Z_PRIMARY
operator|&&
name|zp
operator|->
name|z_type
operator|!=
name|Z_SECONDARY
condition|)
block|{
name|hp
operator|->
name|rcode
operator|=
name|REFUSED
expr_stmt|;
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"InitDynUpdate: REFUSED - non-{primary,secondary} update\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|REFUSED
operator|)
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|zp
operator|->
name|z_state
operator|&
name|Z_DYNAMIC
operator|)
condition|)
block|{
name|hp
operator|->
name|rcode
operator|=
name|REFUSED
expr_stmt|;
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"InitDynUpdate: REFUSED - dynamic flag not set for zone\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|REFUSED
operator|)
return|;
block|}
comment|/* 	 * Lookup the zone namebuf.  Lookup "xyz" not "xyz.", since 	 * otherwise the lookup fails, because '.' may have a nil n_hash 	 * associated with it. 	 */
name|strcpy
argument_list|(
name|ZoneName
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|)
expr_stmt|;
name|znp
operator|=
operator|&
name|ZoneName
index|[
name|strlen
argument_list|(
name|ZoneName
argument_list|)
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
operator|*
name|znp
operator|==
literal|'.'
condition|)
operator|*
name|znp
operator|=
name|NULL
expr_stmt|;
name|np
operator|=
name|nlookup
argument_list|(
name|ZoneName
argument_list|,
operator|&
name|htp
argument_list|,
operator|&
name|fname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|np
operator|==
name|NULL
operator|)
operator|||
operator|(
name|fname
operator|!=
name|ZoneName
operator|)
condition|)
block|{
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"InitDynUpdate: lookup failed on zone (%s)\n"
operator|,
name|ZoneName
operator|)
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"InitDynUpdate: lookup failed on zone (%s)\n"
argument_list|,
name|ZoneName
argument_list|)
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|NXDOMAIN
expr_stmt|;
return|return
operator|(
name|NXDOMAIN
operator|)
return|;
block|}
comment|/* 	 * If this is the primary copy increment the serial number.  Don't 	 * increment the serial number if this is a secondary; this way, if 2 	 * different secondaries both update the primary, they will both have 	 * lower serial numbers than the primary has, and hence eventually 	 * refresh and get all updates and become consistent. 	 * 	 * Note that the serial number must be incremented in both the zone 	 * data structure and the zone's namebuf. 	 */
switch|switch
condition|(
name|zp
operator|->
name|z_type
condition|)
block|{
case|case
name|Z_SECONDARY
case|:
comment|/* forward update to primary */
name|nspp
operator|=
name|nsp
expr_stmt|;
name|dp
operator|=
name|np
operator|->
name|n_data
expr_stmt|;
while|while
condition|(
name|dp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|match
argument_list|(
name|dp
argument_list|,
name|class
argument_list|,
name|T_NS
argument_list|)
condition|)
block|{
if|if
condition|(
name|nspp
operator|<
operator|&
name|nsp
index|[
name|NSMAX
operator|-
literal|1
index|]
condition|)
block|{
operator|*
name|nspp
operator|++
operator|=
name|dp
expr_stmt|;
ifdef|#
directive|ifdef
name|DATUMREFCNT
name|dp
operator|->
name|d_rcnt
operator|++
expr_stmt|;
endif|#
directive|endif
block|}
else|else
break|break;
block|}
name|dp
operator|=
name|dp
operator|->
name|d_next
expr_stmt|;
block|}
operator|*
name|nspp
operator|=
name|NULL
expr_stmt|;
comment|/* Delimiter */
if|if
condition|(
name|ns_forw
argument_list|(
name|nsp
argument_list|,
name|msg
argument_list|,
name|msglen
argument_list|,
name|from
argument_list|,
name|qsp
argument_list|,
name|dfd
argument_list|,
name|NULL
argument_list|,
name|dnbuf
argument_list|)
operator|<
literal|0
condition|)
block|{
name|hp
operator|->
name|rcode
operator|=
name|SERVFAIL
expr_stmt|;
ifdef|#
directive|ifdef
name|DATUMREFCNT
name|free_nsp
argument_list|(
name|nsp
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|SERVFAIL
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|DATUMREFCNT
name|free_nsp
argument_list|(
name|nsp
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|FORWARDED
operator|)
return|;
case|case
name|Z_PRIMARY
case|:
name|zp
operator|->
name|z_serial
operator|++
expr_stmt|;
name|olddp
operator|=
name|np
operator|->
name|n_data
expr_stmt|;
comment|/* old databuf */
comment|/* Find the SOA record */
for|for
control|(
name|olddp
operator|=
name|np
operator|->
name|n_data
init|;
name|olddp
operator|!=
name|NULL
condition|;
name|olddp
operator|=
name|olddp
operator|->
name|d_next
control|)
if|if
condition|(
name|match
argument_list|(
name|olddp
argument_list|,
name|class
argument_list|,
name|T_SOA
argument_list|)
condition|)
break|break;
if|if
condition|(
name|olddp
operator|==
name|NULL
condition|)
block|{
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"InitDynUpdate: Couldn't find SOA record for '%s'\n"
operator|,
name|ZoneName
operator|)
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"InitDynUpdate: Couldn't find SOA record for '%s'\n"
argument_list|,
name|ZoneName
argument_list|)
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|NXDOMAIN
expr_stmt|;
ifdef|#
directive|ifdef
name|DATUMREFCNT
name|free_nsp
argument_list|(
name|nsp
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|NXDOMAIN
operator|)
return|;
block|}
name|newdp
operator|=
name|savedata
argument_list|(
name|olddp
operator|->
name|d_class
argument_list|,
name|olddp
operator|->
name|d_type
argument_list|,
name|olddp
operator|->
name|d_ttl
argument_list|,
name|olddp
operator|->
name|d_data
argument_list|,
name|olddp
operator|->
name|d_size
argument_list|)
expr_stmt|;
name|newdp
operator|->
name|d_zone
operator|=
name|olddp
operator|->
name|d_zone
expr_stmt|;
ifdef|#
directive|ifdef
name|CRED
name|newdp
operator|->
name|d_cred
operator|=
name|DB_C_AUTH
expr_stmt|;
name|newdp
operator|->
name|d_clev
operator|=
name|db_getclev
argument_list|(
name|zp
operator|->
name|z_origin
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|cp
operator|=
operator|(
name|u_char
operator|*
operator|)
name|newdp
operator|->
name|d_data
expr_stmt|;
name|cp
operator|+=
name|strlen
argument_list|(
name|cp
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* skip origin string */
name|cp
operator|+=
name|strlen
argument_list|(
name|cp
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* skip in-charge string */
name|putlong
argument_list|(
call|(
name|u_int32_t
call|)
argument_list|(
name|zp
operator|->
name|z_serial
argument_list|)
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
literal|4
argument_list|,
operator|(
name|ddt
operator|,
literal|"after stuffing data into newdp:\n"
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>=
literal|4
condition|)
name|printSOAdata
argument_list|(
name|newdp
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|n
operator|=
name|db_update
argument_list|(
name|ZoneName
argument_list|,
name|olddp
argument_list|,
name|newdp
argument_list|,
name|DB_DELETE
argument_list|,
name|hashtab
argument_list|)
operator|)
operator|!=
name|NOERROR
condition|)
block|{
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"InitDynUpdate: SOA update failed\n"
operator|)
argument_list|)
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|NOCHANGE
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dp
argument_list|)
expr_stmt|;
comment|/* vix@dec mar92 */
ifdef|#
directive|ifdef
name|DATUMREFCNT
name|free_nsp
argument_list|(
name|nsp
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|NOCHANGE
operator|)
return|;
block|}
comment|/* Now update the RR itself */
if|if
condition|(
name|doupdate
argument_list|(
name|msg
argument_list|,
name|msglen
argument_list|,
name|msg
operator|+
sizeof|sizeof
argument_list|(
name|HEADER
argument_list|)
argument_list|,
name|zonenum
argument_list|,
operator|(
expr|struct
name|databuf
operator|*
operator|)
literal|0
argument_list|,
name|DB_NODATA
ifdef|#
directive|ifdef
name|CRED
argument_list|,
name|DB_C_AUTH
endif|#
directive|endif
argument_list|)
operator|<
literal|0
condition|)
block|{
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"InitDynUpdate: doupdate failed\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* doupdate fills in rcode */
ifdef|#
directive|ifdef
name|DATUMREFCNT
name|free_nsp
argument_list|(
name|nsp
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|hp
operator|->
name|rcode
operator|)
return|;
block|}
name|zp
operator|->
name|z_state
operator||=
name|Z_CHANGED
expr_stmt|;
ifdef|#
directive|ifdef
name|DATUMREFCNT
name|free_nsp
argument_list|(
name|nsp
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|NOERROR
operator|)
return|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_comment
comment|/*  * Print the contents of the data in databuf pointed to by dp for an SOA record  */
end_comment

begin_function
specifier|static
name|void
name|printSOAdata
parameter_list|(
name|dp
parameter_list|)
name|struct
name|databuf
modifier|*
name|dp
decl_stmt|;
block|{
specifier|register
name|u_char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
operator|!
name|debug
condition|)
return|return;
comment|/* Otherwise fprintf to ddt will bomb */
name|cp
operator|=
operator|(
name|u_char
operator|*
operator|)
name|dp
operator|->
name|d_data
expr_stmt|;
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"printSOAdata(%x): origin(%x)='%s'\n"
argument_list|,
name|dp
argument_list|,
name|cp
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|strlen
argument_list|(
name|cp
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* skip origin string */
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"printSOAdata: in-charge(%x)='%s'\n"
argument_list|,
name|cp
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|strlen
argument_list|(
name|cp
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* skip in-charge string */
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"printSOAdata: serial(%x)=%d\n"
argument_list|,
name|cp
argument_list|,
name|_getlong
argument_list|(
name|cp
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|startxfr
parameter_list|(
name|qsp
parameter_list|,
name|np
parameter_list|,
name|msg
parameter_list|,
name|msglen
parameter_list|,
name|class
parameter_list|)
name|struct
name|qstream
modifier|*
name|qsp
decl_stmt|;
name|struct
name|namebuf
modifier|*
name|np
decl_stmt|;
name|char
modifier|*
name|msg
decl_stmt|;
name|int
name|msglen
decl_stmt|;
name|int
name|class
decl_stmt|;
block|{
specifier|register
name|FILE
modifier|*
name|rfp
decl_stmt|;
name|int
name|fdstat
decl_stmt|;
name|dprintf
argument_list|(
literal|5
argument_list|,
operator|(
name|ddt
operator|,
literal|"startxfr()\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * child does the work while 	 * the parent continues 	 * 	 * XXX this should be a vfork/exec since on non-copy-on-write 	 * systems with huge nameserver images, this is very expensive. 	 */
if|if
condition|(
name|fork
argument_list|()
operator|==
literal|0
condition|)
block|{
name|dprintf
argument_list|(
literal|5
argument_list|,
operator|(
name|ddt
operator|,
literal|"startxfr: child pid %d\n"
operator|,
name|getpid
argument_list|()
operator|)
argument_list|)
expr_stmt|;
name|rfp
operator|=
name|fdopen
argument_list|(
name|qsp
operator|->
name|s_rfd
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
name|setproctitle
argument_list|(
literal|"zone XFR to"
argument_list|,
name|qsp
operator|->
name|s_rfd
argument_list|)
expr_stmt|;
name|fdstat
operator|=
name|fcntl
argument_list|(
name|qsp
operator|->
name|s_rfd
argument_list|,
name|F_GETFL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fdstat
operator|!=
operator|-
literal|1
condition|)
operator|(
name|void
operator|)
name|fcntl
argument_list|(
name|qsp
operator|->
name|s_rfd
argument_list|,
name|F_SETFL
argument_list|,
name|fdstat
operator|&
operator|~
name|PORT_NONBLOCK
argument_list|)
expr_stmt|;
name|fwritemsg
argument_list|(
name|rfp
argument_list|,
name|msg
argument_list|,
name|msglen
argument_list|)
expr_stmt|;
name|doaxfr
argument_list|(
name|np
argument_list|,
name|rfp
argument_list|,
name|np
argument_list|,
name|class
argument_list|)
expr_stmt|;
name|fwritemsg
argument_list|(
name|rfp
argument_list|,
name|msg
argument_list|,
name|msglen
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|rfp
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_macro
name|free_addinfo
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|addinfo
modifier|*
name|ap
decl_stmt|;
for|for
control|(
name|ap
operator|=
name|addinfo
init|;
operator|--
name|addcount
operator|>=
literal|0
condition|;
name|ap
operator|++
control|)
block|{
name|free
argument_list|(
name|ap
operator|->
name|a_dname
argument_list|)
expr_stmt|;
block|}
name|addcount
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|DATUMREFCNT
end_ifdef

begin_macro
name|free_nsp
argument_list|(
argument|nsp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|databuf
modifier|*
modifier|*
name|nsp
decl_stmt|;
end_decl_stmt

begin_block
block|{
while|while
condition|(
operator|*
name|nsp
condition|)
block|{
if|if
condition|(
operator|--
operator|(
operator|(
operator|*
name|nsp
operator|)
operator|->
name|d_rcnt
operator|)
condition|)
block|{
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"free_nsp: %s rcnt %d\n"
operator|,
operator|(
operator|*
name|nsp
operator|)
operator|->
name|d_data
operator|,
operator|(
operator|*
name|nsp
operator|)
operator|->
name|d_rcnt
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"free_nsp: %s rcnt %d delayed\n"
operator|,
operator|(
operator|*
name|nsp
operator|)
operator|->
name|d_data
operator|,
operator|(
operator|*
name|nsp
operator|)
operator|->
name|d_rcnt
operator|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|*
name|nsp
argument_list|)
expr_stmt|;
comment|/* delayed free */
block|}
name|nsp
operator|++
expr_stmt|;
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

end_unit

