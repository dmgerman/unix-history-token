begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * This source code is a product of Sun Microsystems, Inc. and is provided  * for unrestricted use provided that this legend is included on all tape  * media and as a part of the software program in whole or part.  Users  * may copy or modify this source code without charge, but are not authorized  * to license or distribute it to anyone else except as part of a product or  * program developed by the user.  *  * THIS PROGRAM CONTAINS SOURCE CODE COPYRIGHTED BY SUN MICROSYSTEMS, INC.  * SUN MICROSYSTEMS, INC., MAKES NO REPRESENTATIONS ABOUT THE SUITABLITY  * OF SUCH SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT  * EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  SUN MICROSYSTEMS, INC. DISCLAIMS  * ALL WARRANTIES WITH REGARD TO SUCH SOURCE CODE, INCLUDING ALL IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN  * NO EVENT SHALL SUN MICROSYSTEMS, INC. BE LIABLE FOR ANY SPECIAL, INDIRECT,  * INCIDENTAL, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING  * FROM USE OF SUCH SOURCE CODE, REGARDLESS OF THE THEORY OF LIABILITY.  *   * This source code is provided with no support and without any obligation on  * the part of Sun Microsystems, Inc. to assist in its use, correction,   * modification or enhancement.  *  * SUN MICROSYSTEMS, INC. SHALL HAVE NO LIABILITY WITH RESPECT TO THE  * INFRINGEMENT OF COPYRIGHTS, TRADE SECRETS OR ANY PATENTS BY THIS  * SOURCE CODE OR ANY PART THEREOF.  *  * Sun Microsystems, Inc.  * 2550 Garcia Avenue  * Mountain View, California 94043  */
end_comment

begin_comment
comment|/* @(#)cache_common.c 1.10 69/12/31 SMI */
end_comment

begin_comment
comment|/*  * ld.so directory caching: common code  */
end_comment

begin_comment
comment|/*  * Copyright (c) 1989, 1991 by Sun Microsystems, Inc.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/dirent.h>
end_include

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/exec.h>
end_include

begin_include
include|#
directive|include
file|"link.h"
end_include

begin_include
include|#
directive|include
file|"cache.h"
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_function_decl
specifier|extern
name|char
modifier|*
name|getenv
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|stol
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|rest_ok
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|link_object
modifier|*
name|get_lo
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|dbd
modifier|*
name|new_dbd
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|db
modifier|*
name|find_so
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fix_lo
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|get_cache_file
parameter_list|()
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|LIB
value|"lib"
end_define

begin_comment
comment|/* library name prefix string */
end_comment

begin_define
define|#
directive|define
name|SO
value|".so."
end_define

begin_comment
comment|/* extension for shared object */
end_comment

begin_define
define|#
directive|define
name|LIBLEN
value|(sizeof (LIB) - 1)
end_define

begin_comment
comment|/* lengths of same */
end_comment

begin_define
define|#
directive|define
name|SOLEN
value|(sizeof (SO) - 1)
end_define

begin_decl_stmt
name|caddr_t
name|db_base
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* base address from mmap() */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|dbd
modifier|*
name|dbd_head
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* head of data bases */
end_comment

begin_comment
comment|/*   * Given a directory name - give back a data base. The data base may have  * orginated from the mmapped file or temporarily created  */
end_comment

begin_function
name|struct
name|db
modifier|*
name|lo_cache
parameter_list|(
name|ds
parameter_list|)
name|char
modifier|*
name|ds
decl_stmt|;
comment|/* directory to get cache for */
block|{
name|struct
name|db
modifier|*
name|dbp
decl_stmt|;
comment|/* database pointer */
name|struct
name|dbd
modifier|*
name|dbdp
decl_stmt|;
comment|/* working database descriptor */
name|struct
name|dbd
modifier|*
modifier|*
name|dbdpp
decl_stmt|;
comment|/* insertion pointer */
specifier|static
name|int
name|once
init|=
literal|1
decl_stmt|;
comment|/* once-only flag */
if|if
condition|(
name|once
condition|)
block|{
name|get_cache_file
argument_list|()
expr_stmt|;
name|once
operator|=
literal|0
expr_stmt|;
block|}
name|dbdpp
operator|=
operator|&
name|dbd_head
expr_stmt|;
for|for
control|(
name|dbdp
operator|=
name|dbd_head
init|;
name|dbdp
condition|;
name|dbdp
operator|=
name|dbdp
operator|->
name|dbd_next
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ds
argument_list|,
operator|&
name|AP
argument_list|(
name|dbdp
operator|->
name|dbd_db
argument_list|)
index|[
name|dbdp
operator|->
name|dbd_db
operator|->
name|db_name
index|]
argument_list|)
condition|)
return|return
operator|(
name|dbdp
operator|->
name|dbd_db
operator|)
return|;
name|dbdpp
operator|=
operator|&
name|dbdp
operator|->
name|dbd_next
expr_stmt|;
block|}
if|if
condition|(
name|dbp
operator|=
name|find_so
argument_list|(
name|ds
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|new_dbd
argument_list|(
name|dbdpp
argument_list|,
name|dbp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|dbp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*   * Delete from the db list those dbs that came from the mmapped file  */
end_comment

begin_function
name|void
name|dbd_flush
parameter_list|()
block|{
name|struct
name|dbd
modifier|*
name|dbdp
decl_stmt|;
comment|/* working dbd ptr. */
for|for
control|(
name|dbdp
operator|=
name|dbd_head
init|;
name|dbdp
condition|;
name|dbdp
operator|=
name|dbdp
operator|->
name|dbd_next
control|)
block|{
if|if
condition|(
name|dbdp
operator|->
name|dbd_db
operator|>=
operator|(
expr|struct
name|db
operator|*
operator|)
name|db_base
condition|)
block|{
if|if
condition|(
name|dbdp
operator|==
name|dbd_head
condition|)
name|dbd_head
operator|=
name|dbdp
operator|->
name|dbd_next
expr_stmt|;
elseif|else
if|if
condition|(
name|dbdp
operator|->
name|dbd_db
operator|>=
operator|(
expr|struct
name|db
operator|*
operator|)
name|db_base
condition|)
name|dbdp
operator|=
name|dbdp
operator|->
name|dbd_next
expr_stmt|;
block|}
if|if
condition|(
name|dbdp
operator|->
name|dbd_next
operator|==
name|NULL
condition|)
break|break;
block|}
block|}
end_function

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/*  * Get the cache file, if appropriate.  */
end_comment

begin_function
specifier|static
name|void
name|get_cache_file
parameter_list|()
block|{
name|int
name|fd
decl_stmt|;
comment|/* descriptor on cache file */
name|struct
name|stat
name|sb
decl_stmt|;
comment|/* used to find size */
name|struct
name|dbf
modifier|*
name|dbf_base
decl_stmt|;
comment|/* working cache file pointer */
name|struct
name|db
modifier|*
name|dbp
decl_stmt|;
comment|/* working data base pointer */
name|struct
name|dbd
modifier|*
name|dbdp
decl_stmt|;
comment|/* working dbd */
name|struct
name|dbd
modifier|*
modifier|*
name|dbdpp
decl_stmt|;
comment|/* insertion point for dbd list */
comment|/* 	 * If cache use is suppressed, simply skip all this. 	 */
if|if
condition|(
operator|!
name|use_cache
condition|)
return|return;
comment|/* 	 * Open, map in the file.  Failures occur silently. (XXX) 	 */
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|CACHE_FILE
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
return|return;
if|if
condition|(
name|fstat
argument_list|(
name|fd
argument_list|,
operator|&
name|sb
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return;
block|}
name|dbf_base
operator|=
operator|(
expr|struct
name|dbf
operator|*
operator|)
name|mmap
argument_list|(
literal|0
argument_list|,
name|sb
operator|.
name|st_size
argument_list|,
name|PROT_READ
argument_list|,
name|MAP_SHARED
argument_list|,
name|fd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dbf_base
operator|==
operator|(
expr|struct
name|dbf
operator|*
operator|)
operator|-
literal|1
operator|)
operator|||
operator|(
name|dbf_base
operator|->
name|dbf_magic
operator|!=
name|LD_CACHE_MAGIC
operator|)
condition|)
return|return;
if|if
condition|(
operator|(
name|dbf_base
operator|->
name|dbf_version
operator|!=
name|LD_CACHE_VERSION
operator|)
operator|||
if|#
directive|if
name|TARGET
operator|==
name|SUN2
operator|(
name|dbf_base
operator|->
name|dbf_machtype
operator|!=
name|M_68010
operator|)
condition|)
endif|#
directive|endif
if|#
directive|if
name|TARGET
operator|==
name|SUN3
operator|(
name|dbf_base
operator|->
name|dbf_machtype
operator|!=
name|M_68010
operator|)
operator|&&
operator|(
name|dbf_base
operator|->
name|dbf_machtype
operator|!=
name|M_68020
operator|)
block|)
endif|#
directive|endif
if|#
directive|if
name|TARGET
operator|==
name|SUN4
parameter_list|(
function|dbf_base->dbf_machtype != M_SPARC
end_function

begin_endif
unit|))
endif|#
directive|endif
end_endif

begin_return
return|return;
end_return

begin_expr_stmt
name|db_base
operator|=
operator|&
name|AP
argument_list|(
name|dbf_base
argument_list|)
index|[
operator|(
name|int
operator|)
name|dbf_base
operator|->
name|dbf_db
index|]
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* 	 * For each data base in the file, build a dbd and link it 	 * on to the master list. 	 */
end_comment

begin_for
for|for
control|(
name|dbdpp
operator|=
operator|&
name|dbd_head
operator|,
name|dbp
operator|=
operator|(
expr|struct
name|db
operator|*
operator|)
name|db_base
init|;
operator|(
name|dbp
operator|<
operator|(
expr|struct
name|db
operator|*
operator|)
operator|(
name|db_base
operator|+
name|sb
operator|.
name|st_size
operator|)
operator|)
operator|&&
operator|(
name|dbp
operator|->
name|db_chain
operator|!=
literal|0
operator|)
condition|;
operator|(
name|char
operator|*
operator|)
name|dbp
operator|+=
operator|(
name|int
operator|)
name|dbp
operator|->
name|db_chain
control|)
block|{
name|dbdp
operator|=
name|new_dbd
argument_list|(
name|dbdpp
argument_list|,
name|dbp
argument_list|)
expr_stmt|;
name|dbdpp
operator|=
operator|&
name|dbdp
operator|->
name|dbd_next
expr_stmt|;
block|}
end_for

begin_comment
unit|}
comment|/*  * Build a database for the directory "ds".  */
end_comment

begin_function
unit|static
name|struct
name|db
modifier|*
name|find_so
parameter_list|(
name|ds
parameter_list|)
name|char
modifier|*
name|ds
decl_stmt|;
comment|/* directory to search */
block|{
name|int
name|fd
decl_stmt|;
comment|/* descriptor on directory */
name|int
name|n
decl_stmt|;
comment|/* bytes from getdents */
name|char
modifier|*
name|cp
decl_stmt|;
comment|/* working char * */
name|struct
name|stat
name|sb
decl_stmt|;
comment|/* buffer for stat'ing directory */
name|struct
name|db
modifier|*
name|dbp
decl_stmt|;
comment|/* database */
specifier|static
name|caddr_t
name|buf
init|=
name|NULL
decl_stmt|;
comment|/* buffer for doing getdents */
specifier|static
name|long
name|bs
decl_stmt|;
comment|/* cached blocksize for getdents */
name|struct
name|link_object
modifier|*
name|tlop
decl_stmt|;
comment|/* working link object ptr. */
name|struct
name|dirent
modifier|*
name|dp
decl_stmt|;
comment|/* directory entry ptr. */
name|struct
name|dbe
modifier|*
name|ep
decl_stmt|;
comment|/* working db_entry ptr. */
name|char
modifier|*
name|mnp
decl_stmt|;
comment|/* where minor version begins */
name|char
modifier|*
name|mjp
decl_stmt|;
comment|/* where major version begins */
name|int
name|m
decl_stmt|;
comment|/* the major number */
name|int
name|to_min
decl_stmt|;
comment|/* index into string of minor */
name|int
name|cplen
decl_stmt|;
comment|/* length of X */
name|int
name|index
decl_stmt|;
comment|/* the hash value */
comment|/* 	 * Try to open directory.  Failing that, just return silently. 	 */
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|ds
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|(
expr|struct
name|db
operator|*
operator|)
name|NULL
operator|)
return|;
comment|/* 	 * If we have not yet gotten a buffer for reading directories, 	 * allocate it now.  Size it according to the most efficient size 	 * for the first directory we open successfully. 	 */
if|if
condition|(
operator|!
name|buf
condition|)
block|{
if|if
condition|(
name|fstat
argument_list|(
name|fd
argument_list|,
operator|&
name|sb
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
expr|struct
name|db
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
name|buf
operator|=
call|(
modifier|*
name|heap_malloc
call|)
argument_list|(
name|bs
operator|=
name|sb
operator|.
name|st_blksize
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Have a directory, have a buffer.  Allocate up a database 	 * and initialize it. 	 */
name|dbp
operator|=
operator|(
expr|struct
name|db
operator|*
operator|)
call|(
modifier|*
name|db_malloc
call|)
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|db
argument_list|)
argument_list|)
expr_stmt|;
name|dbp
operator|->
name|db_name
operator|=
name|RELPTR
argument_list|(
name|dbp
argument_list|,
call|(
modifier|*
name|db_malloc
call|)
argument_list|(
name|strlen
argument_list|(
name|ds
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|AP
argument_list|(
name|dbp
argument_list|)
index|[
name|dbp
operator|->
name|db_name
index|]
argument_list|,
name|ds
argument_list|)
expr_stmt|;
comment|/* 	 * Scan the directory looking for shared libraries.  getdents() 	 * failures are silently ignored and terminate the scan. 	 */
while|while
condition|(
operator|(
name|n
operator|=
name|getdents
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
name|bs
argument_list|)
operator|)
operator|>
literal|0
condition|)
for|for
control|(
name|dp
operator|=
operator|(
expr|struct
name|dirent
operator|*
operator|)
name|buf
init|;
name|dp
operator|&&
operator|(
name|dp
operator|<
operator|(
expr|struct
name|dirent
operator|*
operator|)
operator|(
name|buf
operator|+
name|n
operator|)
operator|)
condition|;
name|dp
operator|=
operator|(
expr|struct
name|dirent
operator|*
operator|)
operator|(
operator|(
name|dp
operator|->
name|d_reclen
operator|==
literal|0
operator|)
condition|?
name|NULL
else|:
operator|(
name|char
operator|*
operator|)
name|dp
operator|+
name|dp
operator|->
name|d_reclen
operator|)
control|)
block|{
comment|/* 			 * If file starts with a "lib", then extract the X 			 * from libX. 			 */
name|cp
operator|=
name|dp
operator|->
name|d_name
expr_stmt|;
if|if
condition|(
operator|(
name|cplen
operator|=
name|extract_name
argument_list|(
operator|&
name|cp
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
continue|continue;
comment|/*  			 * Is the next component ".so."? 			 */
if|if
condition|(
name|strncmp
argument_list|(
name|SO
argument_list|,
name|cp
operator|+
name|cplen
argument_list|,
name|SOLEN
argument_list|)
condition|)
continue|continue;
comment|/* 			 * Check if next component is the major number and 			 * whether following components are legal. 			 */
name|mnp
operator|=
name|mjp
operator|=
operator|(
name|dp
operator|->
name|d_name
operator|+
name|LIBLEN
operator|+
name|cplen
operator|+
name|SOLEN
operator|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|stol
argument_list|(
name|mjp
argument_list|,
literal|'.'
argument_list|,
operator|&
name|mnp
argument_list|,
operator|&
name|m
argument_list|)
operator|&&
name|rest_ok
argument_list|(
name|mnp
operator|+
literal|1
argument_list|)
operator|)
condition|)
continue|continue;
name|to_min
operator|=
name|mnp
operator|-
name|dp
operator|->
name|d_name
operator|+
literal|1
expr_stmt|;
comment|/* 			 * Have libX.so.major.minor - attempt to add it to the 			 * cache. If there is another with the same major 			 * number then the chose the object with the highest 			 * minor number 			 */
name|index
operator|=
name|hash
argument_list|(
name|cp
argument_list|,
name|cplen
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|ep
operator|=
operator|&
operator|(
name|dbp
operator|->
name|db_hash
index|[
name|index
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|dbe_lop
operator|==
name|NULL
condition|)
block|{
name|ep
operator|->
name|dbe_lop
operator|=
operator|(
name|long
operator|)
name|get_lo
argument_list|(
name|dbp
argument_list|,
name|cp
argument_list|,
name|cplen
argument_list|,
name|m
argument_list|,
name|to_min
argument_list|)
expr_stmt|;
name|tlop
operator|=
operator|(
expr|struct
name|link_object
operator|*
operator|)
operator|&
name|AP
argument_list|(
name|dbp
argument_list|)
index|[
name|ep
operator|->
name|dbe_lop
index|]
expr_stmt|;
name|strcpy
argument_list|(
operator|&
name|AP
argument_list|(
name|dbp
argument_list|)
index|[
name|tlop
operator|->
name|lo_next
index|]
argument_list|,
name|dp
operator|->
name|d_name
argument_list|)
expr_stmt|;
continue|continue;
block|}
for|for
control|(
name|ep
operator|=
operator|&
operator|(
name|dbp
operator|->
name|db_hash
index|[
name|index
index|]
operator|)
init|;
name|ep
condition|;
name|ep
operator|=
operator|(
expr|struct
name|dbe
operator|*
operator|)
operator|&
name|AP
argument_list|(
name|dbp
argument_list|)
index|[
name|ep
operator|->
name|dbe_next
index|]
control|)
block|{
name|tlop
operator|=
operator|(
expr|struct
name|link_object
operator|*
operator|)
operator|&
name|AP
argument_list|(
name|dbp
argument_list|)
index|[
name|ep
operator|->
name|dbe_lop
index|]
expr_stmt|;
comment|/*  				 * Choose the highest minor version 				 */
if|if
condition|(
operator|(
name|tlop
operator|->
name|lo_major
operator|==
name|m
operator|)
operator|&&
operator|(
operator|!
name|strncmp
argument_list|(
operator|&
name|AP
argument_list|(
name|dbp
argument_list|)
index|[
name|tlop
operator|->
name|lo_name
index|]
argument_list|,
name|cp
argument_list|,
name|cplen
argument_list|)
operator|)
operator|&&
operator|(
operator|*
operator|(
operator|&
name|AP
argument_list|(
name|dbp
argument_list|)
index|[
name|tlop
operator|->
name|lo_name
operator|+
name|cplen
operator|+
literal|1
index|]
operator|)
operator|==
literal|'\0'
operator|)
condition|)
block|{
if|if
condition|(
name|verscmp
argument_list|(
name|dp
operator|->
name|d_name
operator|+
name|to_min
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
operator|&
name|AP
argument_list|(
name|dbp
argument_list|)
index|[
name|tlop
operator|->
name|lo_next
index|]
operator|+
name|to_min
operator|)
argument_list|)
operator|>
literal|0
condition|)
name|strcpy
argument_list|(
operator|&
name|AP
argument_list|(
name|dbp
argument_list|)
index|[
name|tlop
operator|->
name|lo_next
index|]
argument_list|,
name|dp
operator|->
name|d_name
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ep
operator|->
name|dbe_next
operator|==
name|NULL
condition|)
block|{
name|ep
operator|->
name|dbe_next
operator|=
name|RELPTR
argument_list|(
name|dbp
argument_list|,
call|(
modifier|*
name|db_malloc
call|)
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|dbe
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ep
operator|=
operator|(
expr|struct
name|dbe
operator|*
operator|)
operator|&
name|AP
argument_list|(
name|dbp
argument_list|)
index|[
name|ep
operator|->
name|dbe_next
index|]
expr_stmt|;
name|ep
operator|->
name|dbe_lop
operator|=
operator|(
name|long
operator|)
name|get_lo
argument_list|(
name|dbp
argument_list|,
name|cp
argument_list|,
name|cplen
argument_list|,
name|m
argument_list|,
name|to_min
argument_list|)
expr_stmt|;
name|tlop
operator|=
operator|(
expr|struct
name|link_object
operator|*
operator|)
operator|&
name|AP
argument_list|(
name|dbp
argument_list|)
index|[
name|ep
operator|->
name|dbe_lop
index|]
expr_stmt|;
name|strcpy
argument_list|(
operator|&
name|AP
argument_list|(
name|dbp
argument_list|)
index|[
name|tlop
operator|->
name|lo_next
index|]
argument_list|,
name|dp
operator|->
name|d_name
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
name|fix_lo
argument_list|(
name|dbp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
name|dbp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Allocate and fill in the fields for a link_object  */
end_comment

begin_function
specifier|static
name|struct
name|link_object
modifier|*
name|get_lo
parameter_list|(
name|dbp
parameter_list|,
name|cp
parameter_list|,
name|cplen
parameter_list|,
name|m
parameter_list|,
name|n
parameter_list|)
name|struct
name|db
modifier|*
name|dbp
decl_stmt|;
comment|/* data base */
name|char
modifier|*
name|cp
decl_stmt|;
comment|/* ptr. to X of libX */
name|int
name|cplen
decl_stmt|;
comment|/* length of X */
name|int
name|m
decl_stmt|;
comment|/* major version */
name|int
name|n
decl_stmt|;
comment|/* index to minor version */
block|{
name|struct
name|link_object
modifier|*
name|lop
decl_stmt|;
comment|/* link_object to be returned */
name|struct
name|link_object
modifier|*
name|tlop
decl_stmt|;
comment|/* working copy of the above */
comment|/* 	 * Allocate a link object prototype in the database heap. 	 * Store the numeric major (interface) number, but the minor 	 * number is stored in the database as an index to the string 	 * representing the minor version.  By keeping the minor version 	 * as a string, "subfields" (i.e., major.minor[.other.fields. etc.]) 	 * are permitted.  Although not meaningful to the link editor, this 	 * permits run-time substitution of arbitrary customer revisions, 	 * although introducing the confusion of overloading the lo_minor 	 * field in the database (!) 	 */
name|lop
operator|=
operator|(
expr|struct
name|link_object
operator|*
operator|)
name|RELPTR
argument_list|(
name|dbp
argument_list|,
call|(
modifier|*
name|db_malloc
call|)
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|link_object
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|tlop
operator|=
operator|(
expr|struct
name|link_object
operator|*
operator|)
operator|&
name|AP
argument_list|(
name|dbp
argument_list|)
index|[
operator|(
name|long
operator|)
name|lop
index|]
expr_stmt|;
name|tlop
operator|->
name|lo_major
operator|=
name|m
expr_stmt|;
name|tlop
operator|->
name|lo_minor
operator|=
name|n
expr_stmt|;
comment|/* 	 * Allocate space for the complete path name on the host program's 	 * heap -- as we have to save it from the directory buffer which 	 * might otherwise get re-used on us.  Note that this space 	 * is wasted -- we can not assume that it can be reclaimed. 	 */
name|tlop
operator|->
name|lo_next
operator|=
operator|(
name|long
operator|)
name|RELPTR
argument_list|(
name|dbp
argument_list|,
call|(
modifier|*
name|heap_malloc
call|)
argument_list|(
name|MAXNAMLEN
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Store the prototype name in the link object in the database. 	 */
name|tlop
operator|->
name|lo_name
operator|=
operator|(
name|long
operator|)
name|RELPTR
argument_list|(
name|dbp
argument_list|,
call|(
modifier|*
name|db_malloc
call|)
argument_list|(
name|cplen
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|AP
argument_list|(
name|dbp
argument_list|)
index|[
name|tlop
operator|->
name|lo_name
index|]
argument_list|,
name|cp
argument_list|,
name|cplen
argument_list|)
expr_stmt|;
return|return
operator|(
name|lop
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Pull the "X" from libX, set name to X and return the  * length of X  */
end_comment

begin_function
specifier|static
name|int
name|extract_name
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
modifier|*
name|name
decl_stmt|;
block|{
name|char
modifier|*
name|ls
decl_stmt|;
comment|/* string after LIB root */
name|char
modifier|*
name|dp
decl_stmt|;
comment|/* string before first delimiter */
if|if
condition|(
name|strncmp
argument_list|(
operator|*
name|name
argument_list|,
name|LIB
argument_list|,
name|LIBLEN
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ls
operator|=
operator|*
name|name
operator|+
name|LIBLEN
expr_stmt|;
if|if
condition|(
operator|(
name|dp
operator|=
operator|(
name|char
operator|*
operator|)
name|index
argument_list|(
name|ls
argument_list|,
literal|'.'
argument_list|)
operator|)
operator|!=
operator|(
name|char
operator|*
operator|)
literal|0
condition|)
block|{
operator|*
name|name
operator|=
name|ls
expr_stmt|;
return|return
operator|(
name|dp
operator|-
name|ls
operator|)
return|;
block|}
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*   * Make a pass through the data base to set the dbe_name of a dbe.  This  * is necessary because there may be several revisions of a library  * but only one will be chosen.   */
end_comment

begin_function
specifier|static
name|void
name|fix_lo
parameter_list|(
name|dbp
parameter_list|)
name|struct
name|db
modifier|*
name|dbp
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
comment|/* loop temporary */
name|int
name|dirlen
init|=
name|strlen
argument_list|(
operator|&
name|AP
argument_list|(
name|dbp
argument_list|)
index|[
name|dbp
operator|->
name|db_name
index|]
argument_list|)
decl_stmt|;
comment|/* length of directory pathname */
name|char
modifier|*
name|cp
decl_stmt|;
comment|/* working temporary */
name|char
modifier|*
name|tp
decl_stmt|;
comment|/* working temporary */
name|struct
name|dbe
modifier|*
name|ep
decl_stmt|;
comment|/* working copy of dbe */
name|struct
name|link_object
modifier|*
name|lop
decl_stmt|;
comment|/* working copy of link_object */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DB_HASH
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|ep
operator|=
operator|&
operator|(
name|dbp
operator|->
name|db_hash
index|[
name|i
index|]
operator|)
init|;
name|ep
operator|&&
name|ep
operator|->
name|dbe_lop
condition|;
operator|(
name|ep
operator|=
name|ep
operator|->
name|dbe_next
operator|==
literal|0
condition|?
name|NULL
else|:
operator|(
expr|struct
name|dbe
operator|*
operator|)
operator|&
name|AP
argument_list|(
name|dbp
argument_list|)
index|[
name|ep
operator|->
name|dbe_next
index|]
operator|)
control|)
block|{
name|lop
operator|=
operator|(
expr|struct
name|link_object
operator|*
operator|)
operator|&
name|AP
argument_list|(
name|dbp
argument_list|)
index|[
name|ep
operator|->
name|dbe_lop
index|]
expr_stmt|;
name|tp
operator|=
operator|&
name|AP
argument_list|(
name|dbp
argument_list|)
index|[
name|lop
operator|->
name|lo_next
index|]
expr_stmt|;
name|ep
operator|->
name|dbe_name
operator|=
name|RELPTR
argument_list|(
name|dbp
argument_list|,
call|(
modifier|*
name|db_malloc
call|)
argument_list|(
name|dirlen
operator|+
name|strlen
argument_list|(
name|tp
argument_list|)
operator|+
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|lop
operator|->
name|lo_minor
operator|+=
name|dirlen
operator|+
literal|1
expr_stmt|;
name|cp
operator|=
name|strncpy
argument_list|(
operator|&
name|AP
argument_list|(
name|dbp
argument_list|)
index|[
name|ep
operator|->
name|dbe_name
index|]
argument_list|,
operator|&
name|AP
argument_list|(
name|dbp
argument_list|)
index|[
name|dbp
operator|->
name|db_name
index|]
argument_list|,
name|dirlen
argument_list|)
expr_stmt|;
name|cp
operator|=
name|strncpy
argument_list|(
name|cp
operator|+
name|dirlen
argument_list|,
literal|"/"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|cp
operator|+
literal|1
argument_list|,
name|tp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Allocate a new dbd, append it after dbdpp and set the dbd_dbp to dbp.  */
end_comment

begin_function
specifier|static
name|struct
name|dbd
modifier|*
name|new_dbd
parameter_list|(
name|dbdpp
parameter_list|,
name|dbp
parameter_list|)
name|struct
name|dbd
modifier|*
modifier|*
name|dbdpp
decl_stmt|;
comment|/* insertion point */
name|struct
name|db
modifier|*
name|dbp
decl_stmt|;
comment|/* db associated with this dbd */
block|{
name|struct
name|dbd
modifier|*
name|dbdp
decl_stmt|;
comment|/* working dbd ptr. */
name|dbdp
operator|=
operator|(
expr|struct
name|dbd
operator|*
operator|)
call|(
modifier|*
name|heap_malloc
call|)
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|dbd
argument_list|)
argument_list|)
expr_stmt|;
name|dbdp
operator|->
name|dbd_db
operator|=
name|dbp
expr_stmt|;
name|dbdp
operator|->
name|dbd_next
operator|=
name|NULL
expr_stmt|;
operator|*
name|dbdpp
operator|=
name|dbdp
expr_stmt|;
return|return
operator|(
name|dbdp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Calculate hash index for link object.  * This is based on X.major from libX.so.major.minor.  */
end_comment

begin_macro
name|hash
argument_list|(
argument|np
argument_list|,
argument|nchrs
argument_list|,
argument|m
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|np
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* X of libX */
end_comment

begin_decl_stmt
name|int
name|nchrs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* no of chrs. to hash on */
end_comment

begin_decl_stmt
name|int
name|m
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the major version */
end_comment

begin_block
block|{
name|int
name|h
decl_stmt|;
comment|/* for loop counter */
name|char
modifier|*
name|cp
decl_stmt|;
comment|/* working (char *) ptr */
for|for
control|(
name|h
operator|=
literal|0
operator|,
name|cp
operator|=
name|np
init|;
name|h
operator|<
name|nchrs
condition|;
name|h
operator|++
operator|,
operator|*
name|cp
operator|++
control|)
name|h
operator|=
operator|(
name|h
operator|<<
literal|1
operator|)
operator|+
operator|*
name|cp
expr_stmt|;
name|h
operator|+=
operator|(
name|h
operator|<<
literal|1
operator|)
operator|+
name|m
expr_stmt|;
name|h
operator|=
operator|(
operator|(
name|h
operator|&
literal|0x7fffffff
operator|)
operator|%
name|DB_HASH
operator|)
expr_stmt|;
return|return
operator|(
name|h
operator|)
return|;
block|}
end_block

end_unit

