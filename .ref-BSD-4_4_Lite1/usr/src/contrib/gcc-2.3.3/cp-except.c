begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Handle exceptional things in C++.    Copyright (C) 1989, 1992 Free Software Foundation, Inc.    Contributed by Michael Tiemann (tiemann@cygnus.com)  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* High-level class interface. */
end_comment

begin_define
define|#
directive|define
name|NULL
value|0
end_define

begin_comment
comment|/* This should be part of `ansi_opname', or at least be defined by the std.  */
end_comment

begin_define
define|#
directive|define
name|EXCEPTION_NAME_PREFIX
value|"__ex"
end_define

begin_define
define|#
directive|define
name|EXCEPTION_NAME_LENGTH
value|4
end_define

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"cp-tree.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_comment
comment|/* On Suns this can get you to the right definition if you    set the right value for TARGET.  */
end_comment

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|sequent
end_ifdef

begin_comment
comment|/* Can you believe they forgot this?  */
end_comment

begin_define
define|#
directive|define
name|_JBLEN
value|11
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|_JBLEN
end_ifndef

begin_define
define|#
directive|define
name|_JBLEN
value|(sizeof(jmp_buf)/sizeof(int))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
name|void
name|init_exception_processing
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|init_exception_processing_1
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* If non-zero, a VAR_DECL whose cleanup will cause a throw to the    next exception handler.  Its value says whether to throw or not.    In the case of functions which do not issue a RAISE, it should be    possible to optimize away this VAR_DECL (and overhead associated    with it).  */
end_comment

begin_decl_stmt
name|tree
name|exception_throw_decl
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Use this to know that we did not set `exception_throw_decl',    until GCC optimizer is smart enough to figure it out for itself.  */
end_comment

begin_decl_stmt
name|int
name|sets_exception_throw_decl
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The exception `type' currently in scope, or NULL_TREE if none.  */
end_comment

begin_decl_stmt
name|tree
name|current_exception_type
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The exception handler object for the given scope.  */
end_comment

begin_decl_stmt
name|tree
name|current_exception_decl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rtx
name|current_exception_name_as_rtx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rtx
name|current_exception_parms_as_rtx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The ``object'' view of the current exception parameters.    We cast up from the `parms' field to `current_exception_type'.  */
end_comment

begin_decl_stmt
name|tree
name|current_exception_object
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Cache `setjmp', `longjmp', `raise_exception', and `unhandled_exception'    after default conversion.  Maybe later they will get built-in.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|BISJ
decl_stmt|,
name|BILJ
decl_stmt|,
name|BIR
decl_stmt|,
name|BIUE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Local variables which give the appearance that exception    handling is part of the language and the execution model.  */
end_comment

begin_comment
comment|/* The type of the exception handler stack.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|EHS_type
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The global handler stack.  */
end_comment

begin_decl_stmt
name|tree
name|EHS_decl
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Cached component refs to fields of `EHS_decl'.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|EHS_prev
decl_stmt|,
name|EHS_handler
decl_stmt|,
name|EHS_parms
decl_stmt|,
name|EHS_name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|EHS_parms_as_rtx
decl_stmt|,
name|EHS_name_as_rtx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The parameter names of this exception type.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|last_exception_fields
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|last_exception_field_types
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* When ID is VOID_TYPE_NODE, it means ``raise all''.    Cannot be inline, since it uses `alloca', and that    breaks code which pushes the result of this function    on the stack.  */
end_comment

begin_function
specifier|static
name|tree
name|exception_object_name
parameter_list|(
name|prefix
parameter_list|,
name|id
parameter_list|)
name|tree
name|prefix
decl_stmt|;
name|tree
name|id
decl_stmt|;
block|{
comment|/* First, cons up the `name' of this exception.  */
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|length
init|=
operator|(
name|id
operator|==
name|void_type_node
condition|?
literal|3
else|:
name|IDENTIFIER_LENGTH
argument_list|(
name|id
argument_list|)
operator|)
operator|+
name|EXCEPTION_NAME_LENGTH
decl_stmt|;
if|if
condition|(
name|prefix
condition|)
name|length
operator|+=
name|IDENTIFIER_LENGTH
argument_list|(
name|prefix
argument_list|)
operator|+
literal|2
expr_stmt|;
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|length
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|name
argument_list|,
name|EXCEPTION_NAME_PREFIX
argument_list|)
expr_stmt|;
name|length
operator|=
name|EXCEPTION_NAME_LENGTH
expr_stmt|;
if|if
condition|(
name|prefix
condition|)
block|{
name|strcpy
argument_list|(
name|name
operator|+
name|length
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|prefix
argument_list|)
argument_list|)
expr_stmt|;
name|name
index|[
name|length
operator|+
name|IDENTIFIER_LENGTH
argument_list|(
name|prefix
argument_list|)
index|]
operator|=
name|JOINER
expr_stmt|;
name|length
operator|+=
name|IDENTIFIER_LENGTH
argument_list|(
name|prefix
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|id
operator|==
name|void_type_node
condition|)
name|strcpy
argument_list|(
name|name
operator|+
name|length
argument_list|,
literal|"all"
argument_list|)
expr_stmt|;
else|else
name|strcpy
argument_list|(
name|name
operator|+
name|length
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|get_identifier
argument_list|(
name|name
argument_list|)
return|;
block|}
end_function

begin_function
name|tree
name|lookup_exception_cname
parameter_list|(
name|ctype
parameter_list|,
name|cname
parameter_list|,
name|raise_id
parameter_list|)
name|tree
name|ctype
decl_stmt|,
name|cname
decl_stmt|;
name|tree
name|raise_id
decl_stmt|;
block|{
name|tree
name|this_cname
init|=
name|TREE_PURPOSE
argument_list|(
name|raise_id
argument_list|)
decl_stmt|;
if|if
condition|(
name|this_cname
operator|==
name|NULL_TREE
condition|)
block|{
if|if
condition|(
name|cname
condition|)
block|{
name|tree
name|name
init|=
name|TREE_VALUE
argument_list|(
name|raise_id
argument_list|)
decl_stmt|;
if|if
condition|(
name|purpose_member
argument_list|(
name|name
argument_list|,
name|CLASSTYPE_TAGS
argument_list|(
name|ctype
argument_list|)
argument_list|)
condition|)
name|this_cname
operator|=
name|cname
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|this_cname
operator|==
name|void_type_node
condition|)
name|this_cname
operator|=
name|NULL_TREE
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|this_cname
argument_list|)
operator|!=
name|IDENTIFIER_NODE
condition|)
block|{
name|sorry
argument_list|(
literal|"multiple scope refs in `cplus_expand_raise_stmt'"
argument_list|)
expr_stmt|;
name|this_cname
operator|=
name|error_mark_node
expr_stmt|;
block|}
return|return
name|this_cname
return|;
block|}
end_function

begin_function
name|tree
name|lookup_exception_tname
parameter_list|(
name|oname
parameter_list|)
name|tree
name|oname
decl_stmt|;
block|{
return|return
name|get_identifier
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|oname
argument_list|)
operator|+
name|EXCEPTION_NAME_LENGTH
argument_list|)
return|;
block|}
end_function

begin_function
name|tree
name|lookup_exception_object
parameter_list|(
name|cname
parameter_list|,
name|name
parameter_list|,
name|complain
parameter_list|)
name|tree
name|cname
decl_stmt|,
name|name
decl_stmt|;
name|int
name|complain
decl_stmt|;
block|{
name|tree
name|oname
decl_stmt|;
name|tree
name|decl
decl_stmt|;
if|if
condition|(
name|cname
operator|==
name|void_type_node
condition|)
name|cname
operator|=
name|NULL_TREE
expr_stmt|;
elseif|else
if|if
condition|(
name|cname
operator|&&
name|TREE_CODE
argument_list|(
name|cname
argument_list|)
operator|!=
name|IDENTIFIER_NODE
condition|)
block|{
name|sorry
argument_list|(
literal|"multiple scope refs in `lookup_exception_object'"
argument_list|)
expr_stmt|;
name|cname
operator|=
name|NULL_TREE
expr_stmt|;
block|}
name|oname
operator|=
name|exception_object_name
argument_list|(
name|cname
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|decl
operator|=
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|oname
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl
operator|==
name|NULL_TREE
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|VAR_DECL
condition|)
block|{
if|if
condition|(
name|complain
condition|)
block|{
name|push_obstacks_nochange
argument_list|()
expr_stmt|;
if|if
condition|(
name|cname
condition|)
name|error
argument_list|(
literal|"no exception name object for name `%s::%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|cname
argument_list|)
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"no exception name object for name `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|end_temporary_allocation
argument_list|()
expr_stmt|;
comment|/* Avoid further error messages.  */
name|pushdecl_top_level
argument_list|(
name|build_lang_field_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|exception_object_name
argument_list|(
name|cname
argument_list|,
name|name
argument_list|)
argument_list|,
name|error_mark_node
argument_list|)
argument_list|)
expr_stmt|;
name|pop_obstacks
argument_list|()
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
return|return
name|decl
return|;
block|}
end_function

begin_function
name|tree
name|lookup_exception_type
parameter_list|(
name|ctype
parameter_list|,
name|cname
parameter_list|,
name|raise_id
parameter_list|)
name|tree
name|ctype
decl_stmt|,
name|cname
decl_stmt|;
name|tree
name|raise_id
decl_stmt|;
block|{
name|tree
name|name
init|=
name|TREE_VALUE
argument_list|(
name|raise_id
argument_list|)
decl_stmt|;
name|tree
name|purpose
init|=
name|TREE_PURPOSE
argument_list|(
name|raise_id
argument_list|)
decl_stmt|;
if|if
condition|(
name|cname
operator|&&
name|purpose
operator|==
name|NULL_TREE
condition|)
name|purpose
operator|=
name|cname
expr_stmt|;
if|if
condition|(
name|purpose
operator|&&
name|purpose
operator|!=
name|void_type_node
condition|)
block|{
name|tree
name|link
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|purpose
argument_list|)
operator|!=
name|IDENTIFIER_NODE
condition|)
block|{
name|sorry
argument_list|(
literal|"multiple scope refs in `lookup_exception_type'"
argument_list|)
expr_stmt|;
name|TREE_PURPOSE
argument_list|(
name|raise_id
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
if|if
condition|(
operator|!
name|is_aggr_typedef
argument_list|(
name|purpose
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
name|ctype
operator|=
name|IDENTIFIER_TYPE_VALUE
argument_list|(
name|purpose
argument_list|)
expr_stmt|;
name|link
operator|=
name|purpose_member
argument_list|(
name|name
argument_list|,
name|CLASSTYPE_TAGS
argument_list|(
name|ctype
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|link
condition|)
return|return
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
return|;
block|}
name|ctype
operator|=
name|lookup_name
argument_list|(
name|name
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctype
operator|&&
name|TREE_CODE
argument_list|(
name|ctype
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|ctype
operator|=
name|TREE_TYPE
argument_list|(
name|ctype
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctype
operator|&&
name|TREE_CODE
argument_list|(
name|ctype
argument_list|)
operator|==
name|RECORD_TYPE
operator|&&
name|CLASSTYPE_DECLARED_EXCEPTION
argument_list|(
name|ctype
argument_list|)
condition|)
return|return
name|ctype
return|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_function
name|tree
name|finish_exception
parameter_list|(
name|e
parameter_list|,
name|list_of_fieldlists
parameter_list|)
name|tree
name|e
decl_stmt|;
name|tree
name|list_of_fieldlists
decl_stmt|;
block|{
name|tree
name|parmtypes
init|=
name|NULL_TREE
decl_stmt|,
name|name_field
decl_stmt|;
name|tree
name|cname
init|=
name|TYPE_NAME
argument_list|(
name|e
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|cname
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|cname
operator|=
name|DECL_NAME
argument_list|(
name|cname
argument_list|)
expr_stmt|;
if|if
condition|(
name|last_exception_fields
condition|)
name|error
argument_list|(
literal|"cannot declare exceptions within exceptions"
argument_list|)
expr_stmt|;
if|if
condition|(
name|list_of_fieldlists
operator|&&
operator|!
name|ANON_AGGRNAME_P
argument_list|(
name|cname
argument_list|)
condition|)
name|error_with_aggr_type
argument_list|(
name|e
argument_list|,
literal|"exception name `%s' must follow body declaration"
argument_list|)
expr_stmt|;
if|if
condition|(
name|list_of_fieldlists
condition|)
block|{
name|tree
name|prev
decl_stmt|,
name|field
decl_stmt|;
comment|/* Note: no public, private, or protected allowed.  */
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|list_of_fieldlists
argument_list|)
condition|)
name|error
argument_list|(
literal|"visibility declarations invalid in exception declaration"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|list_of_fieldlists
argument_list|)
operator|!=
operator|(
name|tree
operator|)
name|visibility_default
condition|)
name|error
argument_list|(
literal|"visibility declarations invalid in exception declaration"
argument_list|)
expr_stmt|;
name|TREE_PURPOSE
argument_list|(
name|list_of_fieldlists
argument_list|)
operator|=
operator|(
name|tree
operator|)
name|visibility_default
expr_stmt|;
comment|/* Note also: no member function declarations allowed.  */
for|for
control|(
name|prev
operator|=
literal|0
operator|,
name|field
operator|=
name|TREE_VALUE
argument_list|(
name|list_of_fieldlists
argument_list|)
init|;
name|field
condition|;
name|prev
operator|=
name|field
operator|,
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
control|)
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
condition|)
block|{
case|case
name|FIELD_DECL
case|:
comment|/* ok.  */
name|parmtypes
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|,
name|parmtypes
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|FUNCTION_DECL
case|:
name|error_with_decl
argument_list|(
name|field
argument_list|,
literal|"declaration of function `%s' in exception invalid"
argument_list|)
expr_stmt|;
break|break;
case|case
name|VAR_DECL
case|:
if|if
condition|(
name|TREE_STATIC
argument_list|(
name|field
argument_list|)
condition|)
name|error_with_decl
argument_list|(
name|field
argument_list|,
literal|"declaration of static variable `%s' in exception invalid"
argument_list|)
expr_stmt|;
else|else
name|error_with_decl
argument_list|(
name|field
argument_list|,
literal|"declaration of constant field `%s' in exception invalid"
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONST_DECL
case|:
name|error_with_decl
argument_list|(
name|field
argument_list|,
literal|"declaration of enum value `%s' in exception invalid"
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCOPE_REF
case|:
name|error
argument_list|(
literal|"use of `::' in exception context invalid"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|prev
condition|)
name|TREE_CHAIN
argument_list|(
name|prev
argument_list|)
operator|=
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
expr_stmt|;
else|else
name|TREE_VALUE
argument_list|(
name|list_of_fieldlists
argument_list|)
operator|=
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Now that we've cleaned up the fields, add a name identifier at front.  */
name|name_field
operator|=
name|build_lang_field_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"__name"
argument_list|)
argument_list|,
name|ptr_type_node
argument_list|)
expr_stmt|;
if|if
condition|(
name|list_of_fieldlists
condition|)
block|{
name|TREE_CHAIN
argument_list|(
name|name_field
argument_list|)
operator|=
name|TREE_VALUE
argument_list|(
name|list_of_fieldlists
argument_list|)
expr_stmt|;
name|TREE_VALUE
argument_list|(
name|list_of_fieldlists
argument_list|)
operator|=
name|name_field
expr_stmt|;
block|}
else|else
name|list_of_fieldlists
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|name_field
argument_list|)
expr_stmt|;
name|last_exception_fields
operator|=
name|TREE_VALUE
argument_list|(
name|list_of_fieldlists
argument_list|)
expr_stmt|;
if|if
condition|(
name|parmtypes
condition|)
block|{
name|last_exception_field_types
operator|=
name|nreverse
argument_list|(
name|parmtypes
argument_list|)
expr_stmt|;
comment|/* Set the TREE_CHAIN of what is now at the end of the 	 list to `void_list_node'.  */
name|TREE_CHAIN
argument_list|(
name|parmtypes
argument_list|)
operator|=
name|void_list_node
expr_stmt|;
block|}
else|else
name|last_exception_field_types
operator|=
name|void_list_node
expr_stmt|;
name|popclass
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* Remove aggregate types from the list of tags,      since these appear at global scope.  */
block|while (x&& IS_AGGR_TYPE (TREE_VALUE (x)))     x = TREE_CHAIN (x);   CLASSTYPE_TAGS (t) = x;   y = x;   while (x)     {       if (IS_AGGR_TYPE (TREE_VALUE (x))) 	TREE_CHAIN (y) = TREE_CHAIN (x);       x = TREE_CHAIN (x);     }
endif|#
directive|endif
if|if
condition|(
name|flag_cadillac
condition|)
name|cadillac_finish_exception
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return
name|e
return|;
block|}
end_function

begin_function
name|void
name|finish_exception_decl
parameter_list|(
name|cname
parameter_list|,
name|decl
parameter_list|)
name|tree
name|cname
decl_stmt|,
name|decl
decl_stmt|;
block|{
comment|/* In cp-decl.h.  */
specifier|extern
name|tree
name|last_function_parms
decl_stmt|;
comment|/* An exception declaration.  */
name|tree
name|t
decl_stmt|,
name|ctor
decl_stmt|;
name|tree
name|parmdecls
init|=
name|NULL_TREE
decl_stmt|,
name|fields
decl_stmt|;
name|tree
name|list_of_fieldlists
init|=
name|temp_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|copy_list
argument_list|(
name|last_exception_fields
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|edecl
init|=
name|build_lang_field_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|exception_object_name
argument_list|(
name|cname
argument_list|,
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|,
name|ptr_type_node
argument_list|)
decl_stmt|;
name|DECL_LANGUAGE
argument_list|(
name|edecl
argument_list|)
operator|=
name|lang_c
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|edecl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|edecl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|finish_decl
argument_list|(
name|pushdecl
argument_list|(
name|edecl
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Now instantiate the exception decl.  */
name|t
operator|=
name|xref_tag
argument_list|(
name|exception_type_node
argument_list|,
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* finish_struct will pop this.  */
name|pushclass
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Now add a constructor which takes as parameters all the types we      just defined.  */
name|ctor
operator|=
name|build_lang_decl
argument_list|(
name|FUNCTION_DECL
argument_list|,
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|,
name|build_cplus_method_type
argument_list|(
name|t
argument_list|,
name|TYPE_POINTER_TO
argument_list|(
name|t
argument_list|)
argument_list|,
name|last_exception_field_types
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Don't take `name'.  The constructor handles that.  */
name|fields
operator|=
name|TREE_CHAIN
argument_list|(
name|TREE_VALUE
argument_list|(
name|list_of_fieldlists
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|fields
condition|)
block|{
name|tree
name|parm
init|=
name|build_decl
argument_list|(
name|PARM_DECL
argument_list|,
name|DECL_NAME
argument_list|(
name|fields
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|fields
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Since there is a prototype, args are passed in their own types.  */
name|DECL_ARG_TYPE
argument_list|(
name|parm
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PROMOTE_PROTOTYPES
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fields
argument_list|)
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|fields
argument_list|)
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
condition|)
name|DECL_ARG_TYPE
argument_list|(
name|parm
argument_list|)
operator|=
name|integer_type_node
expr_stmt|;
endif|#
directive|endif
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
operator|=
name|parmdecls
expr_stmt|;
name|parmdecls
operator|=
name|parm
expr_stmt|;
name|fields
operator|=
name|TREE_CHAIN
argument_list|(
name|fields
argument_list|)
expr_stmt|;
block|}
name|fields
operator|=
name|TREE_VALUE
argument_list|(
name|list_of_fieldlists
argument_list|)
expr_stmt|;
name|last_function_parms
operator|=
name|nreverse
argument_list|(
name|parmdecls
argument_list|)
expr_stmt|;
name|DECL_CONSTRUCTOR_P
argument_list|(
name|ctor
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|grokclassfn
argument_list|(
name|t
argument_list|,
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|,
name|ctor
argument_list|,
name|NO_SPECIAL
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|ctor
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|ctor
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|ctor
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_INLINE
argument_list|(
name|ctor
argument_list|)
operator|=
literal|1
expr_stmt|;
name|make_decl_rtl
argument_list|(
name|ctor
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|finish_decl
argument_list|(
name|ctor
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|ctor
argument_list|)
operator|=
name|TREE_VALUE
argument_list|(
name|list_of_fieldlists
argument_list|)
expr_stmt|;
name|TREE_VALUE
argument_list|(
name|list_of_fieldlists
argument_list|)
operator|=
name|ctor
expr_stmt|;
name|finish_struct
argument_list|(
name|t
argument_list|,
name|list_of_fieldlists
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_function_decl
condition|)
name|error
argument_list|(
literal|"cannot define exception inside function scope"
argument_list|)
expr_stmt|;
else|else
block|{
name|enum
name|debug_info_type
name|old_write_symbols
init|=
name|write_symbols
decl_stmt|;
name|write_symbols
operator|=
name|NO_DEBUG
expr_stmt|;
comment|/* Now build the constructor for this exception.  */
name|parmdecls
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|ctor
argument_list|)
expr_stmt|;
name|start_function
argument_list|(
name|NULL_TREE
argument_list|,
name|ctor
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|store_parm_decls
argument_list|()
expr_stmt|;
name|pushlevel
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|clear_last_expr
argument_list|()
expr_stmt|;
name|push_momentary
argument_list|()
expr_stmt|;
name|expand_start_bindings
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Move all the parameters to the fields, skipping `this'.  */
name|parmdecls
operator|=
name|TREE_CHAIN
argument_list|(
name|parmdecls
argument_list|)
expr_stmt|;
comment|/* Install `name' of this exception handler.  */
name|DECL_INITIAL
argument_list|(
name|fields
argument_list|)
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|edecl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fields
operator|=
name|TREE_CHAIN
argument_list|(
name|fields
argument_list|)
expr_stmt|;
comment|/* Install all the values.  */
while|while
condition|(
name|fields
condition|)
block|{
comment|/* Set up the initialization for this field.  */
name|DECL_INITIAL
argument_list|(
name|fields
argument_list|)
operator|=
name|parmdecls
expr_stmt|;
name|fields
operator|=
name|TREE_CHAIN
argument_list|(
name|fields
argument_list|)
expr_stmt|;
name|parmdecls
operator|=
name|TREE_CHAIN
argument_list|(
name|parmdecls
argument_list|)
expr_stmt|;
block|}
name|emit_base_init
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|finish_function
argument_list|(
name|DECL_SOURCE_LINE
argument_list|(
name|ctor
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|write_symbols
operator|=
name|old_write_symbols
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|end_exception_decls
parameter_list|()
block|{
name|last_exception_field_types
operator|=
name|NULL_TREE
expr_stmt|;
name|last_exception_fields
operator|=
name|NULL_TREE
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Statement-level exception semantics.  */
end_comment

begin_function
name|void
name|cplus_expand_start_try
parameter_list|(
name|implicit
parameter_list|)
name|int
name|implicit
decl_stmt|;
block|{
name|tree
name|call_to_setjmp
decl_stmt|;
name|tree
name|handler
decl_stmt|,
name|ref
decl_stmt|;
comment|/* Start a new block enclosing the whole handler.  */
if|if
condition|(
name|implicit
condition|)
block|{
name|pushlevel_temporary
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pushlevel
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|clear_last_expr
argument_list|()
expr_stmt|;
name|push_momentary
argument_list|()
expr_stmt|;
comment|/* Encompass whole exception handler in one big binding contour. 	 If RAISE should throw out of the whole TRY/EXCEPT block, call 	 `expand_start_bindings' with argument of 1.  */
name|expand_start_bindings
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Allocate handler in that block.  It's real name will come later.      Note that it will be the first name in this binding contour.  */
name|handler
operator|=
name|get_temp_name
argument_list|(
name|EHS_type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|handler
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
name|finish_decl
argument_list|(
name|handler
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Must come after call to `finish_decl', else the cleanup for the temp      for the handler will cause the contour we just created to be popped.  */
if|if
condition|(
name|implicit
condition|)
name|declare_implicit_exception
argument_list|()
expr_stmt|;
comment|/* Catch via `setjmp'.  */
name|ref
operator|=
name|build_component_ref
argument_list|(
name|handler
argument_list|,
name|get_identifier
argument_list|(
literal|"handler"
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|call_to_setjmp
operator|=
name|build_function_call
argument_list|(
name|BISJ
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|ref
argument_list|)
argument_list|)
expr_stmt|;
comment|/* RAISE throws to EXCEPT part.  */
name|expand_start_try
argument_list|(
name|build_binary_op
argument_list|(
name|EQ_EXPR
argument_list|,
name|call_to_setjmp
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If KEEP is 1, then declarations in the TRY statement are worth keeping.    If KEEP is 2, then the TRY statement was generated by the compiler.    If KEEP is 0, the declarations in the TRY statement contain errors.  */
end_comment

begin_function
name|tree
name|cplus_expand_end_try
parameter_list|(
name|keep
parameter_list|)
name|int
name|keep
decl_stmt|;
block|{
name|tree
name|decls
decl_stmt|,
name|decl
decl_stmt|,
name|block
decl_stmt|;
if|if
condition|(
name|keep
operator|<
literal|2
condition|)
name|pop_implicit_try_blocks
argument_list|(
name|NULL_TREE
argument_list|)
expr_stmt|;
name|decls
operator|=
name|getdecls
argument_list|()
expr_stmt|;
comment|/* Emit code to avoid falling through into a default      handler that might come later.  */
name|expand_end_try
argument_list|()
expr_stmt|;
comment|/* Pops binding contour local to TRY, and get the exception handler      object built by `...start_try'.  */
switch|switch
condition|(
name|keep
condition|)
block|{
case|case
literal|0
case|:
name|expand_end_bindings
argument_list|(
name|decls
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|block
operator|=
name|poplevel
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pop_momentary
argument_list|()
expr_stmt|;
name|decl
operator|=
name|getdecls
argument_list|()
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|expand_end_bindings
argument_list|(
name|decls
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|block
operator|=
name|poplevel
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pop_momentary
argument_list|()
expr_stmt|;
name|decl
operator|=
name|getdecls
argument_list|()
expr_stmt|;
break|break;
default|default:
name|decl
operator|=
name|tree_last
argument_list|(
name|decls
argument_list|)
expr_stmt|;
name|block
operator|=
name|NULL_TREE
expr_stmt|;
break|break;
block|}
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|==
name|EHS_type
argument_list|,
literal|203
argument_list|)
expr_stmt|;
if|if
condition|(
name|block
condition|)
block|{
name|BLOCK_HANDLER_BLOCK
argument_list|(
name|block
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_USED
argument_list|(
name|block
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Pass it back so that its rtl can be bound to its name      (or vice versa).  */
return|return
name|decl
return|;
block|}
end_function

begin_function
name|void
name|cplus_expand_start_except
parameter_list|(
name|name
parameter_list|,
name|decl
parameter_list|)
name|tree
name|name
decl_stmt|,
name|decl
decl_stmt|;
block|{
name|int
name|yes
decl_stmt|;
name|tree
name|tmp
decl_stmt|,
name|init
decl_stmt|;
name|expand_start_except
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* This is internal `eh'.  */
name|current_exception_decl
operator|=
name|decl
expr_stmt|;
name|current_exception_name_as_rtx
operator|=
name|expand_expr
argument_list|(
name|build
argument_list|(
name|COMPONENT_REF
argument_list|,
name|ptr_type_node
argument_list|,
name|current_exception_decl
argument_list|,
name|TREE_OPERAND
argument_list|(
name|EHS_name
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|init
operator|=
name|build
argument_list|(
name|COMPONENT_REF
argument_list|,
name|ptr_type_node
argument_list|,
name|decl
argument_list|,
name|TREE_OPERAND
argument_list|(
name|EHS_parms
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|current_exception_parms_as_rtx
operator|=
name|expand_expr
argument_list|(
name|init
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
condition|)
block|{
comment|/* Get the exception object into scope (user declared `ex').  */
name|tmp
operator|=
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|name
argument_list|,
name|ptr_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|tmp
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
name|finish_decl
argument_list|(
name|tmp
argument_list|,
name|init
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|current_exception_type
operator|=
name|NULL_TREE
expr_stmt|;
name|yes
operator|=
name|suspend_momentary
argument_list|()
expr_stmt|;
if|if
condition|(
name|name
condition|)
block|{
comment|/* From now on, send the user to our faked-up object.  */
name|current_exception_object
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|void_type_node
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|IDENTIFIER_LOCAL_VALUE
argument_list|(
name|name
argument_list|)
operator|=
name|current_exception_object
expr_stmt|;
block|}
name|resume_momentary
argument_list|(
name|yes
argument_list|)
expr_stmt|;
comment|/* Pop exception handler stack.  */
name|expand_assignment
argument_list|(
name|EHS_decl
argument_list|,
name|EHS_prev
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate the call to `unhandled_exception' that is appropriate    for this particular unhandled exception.  */
end_comment

begin_function
specifier|static
name|tree
name|call_to_unhandled_exception
parameter_list|()
block|{
specifier|extern
name|int
name|lineno
decl_stmt|;
name|tree
name|parms
init|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|combine_strings
argument_list|(
name|build_string
argument_list|(
name|strlen
argument_list|(
name|input_filename
operator|+
literal|1
argument_list|)
argument_list|,
name|input_filename
argument_list|)
argument_list|)
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|build_int_2
argument_list|(
name|lineno
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|build_function_call
argument_list|(
name|BIUE
argument_list|,
name|parms
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Note that this must be mirror image of `...start_try'.    DFAULT is the default clause, if there was one.    DFAULT is ERROR_MARK_NODE when this ends an implicit handler.  */
end_comment

begin_function
name|void
name|cplus_expand_end_except
parameter_list|(
name|dfault
parameter_list|)
name|tree
name|dfault
decl_stmt|;
block|{
specifier|extern
name|tree
name|expand_end_except
parameter_list|()
function_decl|;
comment|/* stmt.c.  */
name|tree
name|decls
decl_stmt|,
name|raised
decl_stmt|;
if|if
condition|(
name|dfault
operator|==
name|NULL_TREE
condition|)
block|{
comment|/* Uncaught exception at outermost level.  If raised locally, 	 reraise the exception.  Otherwise, generate code to call `abort'.  */
if|if
condition|(
name|in_try_block
argument_list|(
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
name|expand_start_cond
argument_list|(
name|build
argument_list|(
name|EQ_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|exception_throw_decl
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|expand_expr
argument_list|(
name|call_to_unhandled_exception
argument_list|()
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|expand_end_cond
argument_list|()
expr_stmt|;
block|}
comment|/* Try the next handler.  */
if|if
condition|(
operator|!
name|expand_escape_except
argument_list|()
condition|)
name|compiler_error
argument_list|(
literal|"except nesting botch"
argument_list|)
expr_stmt|;
block|}
name|raised
operator|=
name|expand_end_except
argument_list|()
expr_stmt|;
name|decls
operator|=
name|getdecls
argument_list|()
expr_stmt|;
name|expand_end_bindings
argument_list|(
name|decls
argument_list|,
name|decls
operator|!=
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|poplevel
argument_list|(
name|decls
operator|!=
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Implicit handlers do not use the momentary obstack.  */
if|if
condition|(
name|dfault
operator|!=
name|error_mark_node
condition|)
name|pop_momentary
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|in_try_block
argument_list|(
literal|1
argument_list|)
condition|)
block|{
comment|/* Check that this function is not raising exceptions 	 it is not supposed to.  */
while|while
condition|(
name|raised
condition|)
block|{
name|error_with_decl
argument_list|(
name|TREE_VALUE
argument_list|(
name|raised
argument_list|)
argument_list|,
literal|"exception `%s' raised but not declared raisable"
argument_list|)
expr_stmt|;
name|raised
operator|=
name|TREE_CHAIN
argument_list|(
name|raised
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|dfault
operator|==
name|NULL_TREE
operator|||
name|dfault
operator|==
name|error_mark_node
condition|)
block|{
name|expand_start_cond
argument_list|(
name|build
argument_list|(
name|NE_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|exception_throw_decl
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* We fell off the end of this try block.  Try going to the next. 	 The escape_label will be the beginning of the next try block.  */
if|if
condition|(
operator|!
name|expand_escape_except
argument_list|()
condition|)
name|compiler_error
argument_list|(
literal|"except nesting botch"
argument_list|)
expr_stmt|;
name|expand_end_cond
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Generate code to raise exception RAISE_ID.    If EXP is NULL_TREE, then PARMS is the list of parameters to use    for constructing this exception.    If EXP is non-NULL, then it is an already constructed object    of the kind that we want.     FOR_RERAISE is non-zero if this raise is called by reraise.  In    this case we do not need to emit extra gotos to avoid warning messages;    the caller will do that once after all the exceptions it reraises    are handled and raised.  */
end_comment

begin_function
name|void
name|cplus_expand_raise
parameter_list|(
name|raise_id
parameter_list|,
name|parms
parameter_list|,
name|exp
parameter_list|,
name|for_reraise
parameter_list|)
name|tree
name|raise_id
decl_stmt|;
name|tree
name|parms
decl_stmt|;
name|tree
name|exp
decl_stmt|;
name|int
name|for_reraise
decl_stmt|;
block|{
comment|/* Allocate new exception of appropriate type, passing      PARMS to its constructor.  */
name|tree
name|cname
decl_stmt|,
name|name
decl_stmt|;
name|tree
name|decl
decl_stmt|;
name|tree
name|xexp
init|=
name|exp
decl_stmt|;
name|cname
operator|=
name|lookup_exception_cname
argument_list|(
name|current_class_type
argument_list|,
name|current_class_name
argument_list|,
name|raise_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|cname
operator|==
name|error_mark_node
condition|)
return|return;
name|name
operator|=
name|TREE_VALUE
argument_list|(
name|raise_id
argument_list|)
expr_stmt|;
name|decl
operator|=
name|lookup_exception_object
argument_list|(
name|cname
argument_list|,
name|name
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl
operator|==
name|NULL_TREE
condition|)
return|return;
if|if
condition|(
name|exp
operator|==
name|NULL_TREE
condition|)
block|{
name|exp
operator|=
name|build_method_call
argument_list|(
name|NULL_TREE
argument_list|,
name|name
argument_list|,
name|parms
argument_list|,
name|NULL_TREE
argument_list|,
name|LOOKUP_COMPLAIN
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
operator|==
name|error_mark_node
condition|)
return|return;
block|}
if|if
condition|(
name|in_try_block
argument_list|(
literal|1
argument_list|)
condition|)
block|{
name|expand_raise
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|current_function_decl
condition|)
block|{
if|if
condition|(
name|xexp
operator|==
name|NULL_TREE
condition|)
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"invalid raise of `%s' outside of functions"
argument_list|)
expr_stmt|;
else|else
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"invalid reraise of `%s' outside of functions"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Test this raise against what this function permits.  */
name|tree
name|names
init|=
name|TYPE_RAISES_EXCEPTIONS
argument_list|(
name|TREE_TYPE
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
decl_stmt|;
while|while
condition|(
name|names
condition|)
block|{
if|if
condition|(
name|decl
operator|==
name|TREE_TYPE
argument_list|(
name|names
argument_list|)
condition|)
break|break;
name|names
operator|=
name|TREE_CHAIN
argument_list|(
name|names
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|names
operator|==
name|NULL_TREE
condition|)
block|{
name|error
argument_list|(
literal|"current function not declared to raise exception `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|store_expr
argument_list|(
name|exp
argument_list|,
name|EHS_parms_as_rtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Set the global exception handler stack's NAME field      to the `name' of this exception.  The global exception      handler stack is the container for the exception object      we just built.       We go through a function call to make life easier when debugging.  */
if|#
directive|if
literal|0
block|expand_assignment (EHS_name, build_unary_op (ADDR_EXPR, decl, 0), 0, 0);
else|#
directive|else
name|parms
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|EHS_name
argument_list|,
literal|0
argument_list|)
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|decl
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expand_expr
argument_list|(
name|build_function_call
argument_list|(
name|BIR
argument_list|,
name|parms
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Activate thrower.  If we are inside a TRY statement,      we can cheat and not do this, saving a longjmp.  */
if|if
condition|(
name|in_try_block
argument_list|(
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sets_exception_throw_decl
operator|=
literal|1
expr_stmt|;
name|emit_move_insn
argument_list|(
name|DECL_RTL
argument_list|(
name|exception_throw_decl
argument_list|)
argument_list|,
name|const1_rtx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|xexp
operator|==
name|NULL_TREE
condition|)
block|{
comment|/* Invoke destructors for current procedure or handler.  */
if|if
condition|(
operator|!
name|expand_escape_except
argument_list|()
condition|)
name|compiler_error
argument_list|(
literal|"except nesting botch"
argument_list|)
expr_stmt|;
comment|/* Throw via `longjmp'... Done as side-effect of goto.  */
block|}
comment|/* To avoid spurious warning messages, we add a goto to the end      of the function.  This code is dead, and the compiler should      know how to delete it, but for now, we are stuck with it.  */
if|if
condition|(
operator|!
name|for_reraise
operator|&&
name|TREE_TYPE
argument_list|(
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
operator|!=
name|void_type_node
condition|)
name|expand_null_return
argument_list|()
expr_stmt|;
block|}
end_function

begin_function_decl
specifier|extern
name|tree
name|cplus_exception_name
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|tree
name|ansi_exception_object_lookup
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|raise_id
init|=
name|cplus_exception_name
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|decl
decl_stmt|;
name|decl
operator|=
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|raise_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl
operator|==
name|NULL_TREE
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|VAR_DECL
condition|)
block|{
name|push_obstacks_nochange
argument_list|()
expr_stmt|;
name|end_temporary_allocation
argument_list|()
expr_stmt|;
name|decl
operator|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|raise_id
argument_list|,
name|ptr_type_node
argument_list|)
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|pushdecl_top_level
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|make_decl_rtl
argument_list|(
name|decl
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pop_obstacks
argument_list|()
expr_stmt|;
block|}
return|return
name|decl
return|;
block|}
end_function

begin_comment
comment|/* Generate code to throw an exception using EXP.    Usng ANSI syntax and semantics.    If EXP is NULL_TREE< re-raise instead. */
end_comment

begin_function
name|void
name|cplus_expand_throw
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
name|tree
name|parms
decl_stmt|;
name|int
name|for_reraise
decl_stmt|;
comment|/* Allocate new exception of appropriate type, passing      PARMS to its constructor.  */
name|tree
name|decl
init|=
name|ansi_exception_object_lookup
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|xexp
init|=
name|exp
decl_stmt|;
if|if
condition|(
name|in_try_block
argument_list|(
literal|1
argument_list|)
condition|)
block|{
if|#
directive|if
literal|1
name|my_friendly_abort
argument_list|(
literal|35
argument_list|)
expr_stmt|;
else|#
directive|else
name|expand_raise
argument_list|(
name|decl
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
operator|!
name|current_function_decl
condition|)
name|error
argument_list|(
literal|"invalid throw outside of functions"
argument_list|)
expr_stmt|;
else|else
block|{
if|#
directive|if
literal|0
comment|/* Test this raise against what this function permits.  */
block|tree names = TYPE_RAISES_EXCEPTIONS (TREE_TYPE (current_function_decl));       while (names) 	{ 	  if (decl == TREE_TYPE (names)) 	    break; 	  names = TREE_CHAIN (names); 	}       if (names == NULL_TREE) 	{ 	  error ("current function not declared to raise exception `%s'", 		 IDENTIFIER_POINTER (name)); 	  return; 	}
endif|#
directive|endif
block|}
name|store_expr
argument_list|(
name|exp
argument_list|,
name|EHS_parms_as_rtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Set the global exception handler stack's NAME field      to the `name' of this exception.  The global exception      handler stack is the container for the exception object      we just built.       We go through a function call to make life easier when debugging.  */
if|#
directive|if
literal|0
block|expand_assignment (EHS_name, build_unary_op (ADDR_EXPR, decl, 0), 0, 0);
else|#
directive|else
name|parms
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|EHS_name
argument_list|,
literal|0
argument_list|)
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|decl
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expand_expr
argument_list|(
name|build_function_call
argument_list|(
name|BIR
argument_list|,
name|parms
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Activate thrower.  If we are inside a TRY statement,      we can cheat and not do this, saving a longjmp.  */
if|if
condition|(
name|in_try_block
argument_list|(
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sets_exception_throw_decl
operator|=
literal|1
expr_stmt|;
name|emit_move_insn
argument_list|(
name|DECL_RTL
argument_list|(
name|exception_throw_decl
argument_list|)
argument_list|,
name|const1_rtx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|xexp
operator|==
name|NULL_TREE
condition|)
block|{
comment|/* Invoke destructors for current procedure or handler.  */
if|if
condition|(
operator|!
name|expand_escape_except
argument_list|()
condition|)
name|compiler_error
argument_list|(
literal|"except nesting botch"
argument_list|)
expr_stmt|;
comment|/* Throw via `longjmp'... Done as side-effect of goto.  */
block|}
comment|/* To avoid spurious warning messages, we add a goto to the end      of the function.  This code is dead, and the compiler should      know how to delete it, but for now, we are stuck with it.  */
if|if
condition|(
operator|!
name|for_reraise
operator|&&
name|TREE_TYPE
argument_list|(
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
operator|!=
name|void_type_node
condition|)
name|expand_null_return
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|tree
name|cplus_expand_start_catch
parameter_list|(
name|raise_id
parameter_list|)
name|tree
name|raise_id
decl_stmt|;
block|{
name|tree
name|cname
init|=
name|lookup_exception_cname
argument_list|(
name|current_class_type
argument_list|,
name|current_class_name
argument_list|,
name|raise_id
argument_list|)
decl_stmt|;
name|tree
name|decl
decl_stmt|;
name|tree
name|cond
decl_stmt|;
if|if
condition|(
name|cname
operator|==
name|error_mark_node
condition|)
block|{
name|decl
operator|=
name|error_mark_node
expr_stmt|;
name|cond
operator|=
name|error_mark_node
expr_stmt|;
block|}
else|else
block|{
name|decl
operator|=
name|lookup_exception_object
argument_list|(
name|cname
argument_list|,
name|TREE_VALUE
argument_list|(
name|raise_id
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl
operator|==
name|NULL_TREE
condition|)
name|cond
operator|=
name|error_mark_node
expr_stmt|;
else|else
name|cond
operator|=
name|build_binary_op
argument_list|(
name|EQ_EXPR
argument_list|,
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|decl
argument_list|,
literal|0
argument_list|)
argument_list|,
name|build
argument_list|(
name|COMPONENT_REF
argument_list|,
name|ptr_type_node
argument_list|,
name|current_exception_decl
argument_list|,
name|TREE_OPERAND
argument_list|(
name|EHS_name
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|expand_start_cond
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Does nothing right now.  */
name|expand_catch
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_exception_type
operator|&&
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|current_exception_type
argument_list|)
condition|)
block|{
comment|/* Make a cleanup for the name-specific exception object now in scope.  */
name|tree
name|cleanup
init|=
name|maybe_build_cleanup
argument_list|(
name|current_exception_object
argument_list|)
decl_stmt|;
name|expand_start_bindings
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|expand_decl_cleanup
argument_list|(
name|NULL_TREE
argument_list|,
name|cleanup
argument_list|)
expr_stmt|;
block|}
return|return
name|decl
return|;
block|}
end_function

begin_function
name|tree
name|ansi_expand_start_catch
parameter_list|(
name|raise_type
parameter_list|)
name|tree
name|raise_type
decl_stmt|;
block|{
name|tree
name|decl
init|=
name|ansi_exception_object_lookup
argument_list|(
name|raise_type
argument_list|)
decl_stmt|;
name|tree
name|cond
decl_stmt|;
if|if
condition|(
name|decl
operator|==
name|NULL_TREE
condition|)
name|cond
operator|=
name|error_mark_node
expr_stmt|;
else|else
name|cond
operator|=
name|build_binary_op
argument_list|(
name|EQ_EXPR
argument_list|,
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|decl
argument_list|,
literal|0
argument_list|)
argument_list|,
name|build
argument_list|(
name|COMPONENT_REF
argument_list|,
name|ptr_type_node
argument_list|,
name|current_exception_decl
argument_list|,
name|TREE_OPERAND
argument_list|(
name|EHS_name
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expand_start_cond
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Does nothing right now.  */
name|expand_catch
argument_list|(
name|decl
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
end_function

begin_function
name|void
name|cplus_expand_end_catch
parameter_list|(
name|for_reraise
parameter_list|)
name|int
name|for_reraise
decl_stmt|;
block|{
if|if
condition|(
name|current_exception_type
operator|&&
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|current_exception_type
argument_list|)
condition|)
block|{
comment|/* Destroy the specific exception object now in scope.  */
name|expand_end_bindings
argument_list|(
name|getdecls
argument_list|()
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|for_reraise
condition|)
block|{
if|if
condition|(
operator|!
name|expand_escape_except
argument_list|()
condition|)
name|my_friendly_abort
argument_list|(
literal|36
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|expand_end_catch
argument_list|()
condition|)
name|my_friendly_abort
argument_list|(
literal|37
argument_list|)
expr_stmt|;
block|}
name|expand_end_cond
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Reraise an exception.    If EXCEPTIONS is NULL_TREE, it means reraise whatever exception was caught.    If EXCEPTIONS is an IDENTIFIER_NODE, it means reraise the exception    object named by EXCEPTIONS.  This must be a variable declared in    an `except' clause.    If EXCEPTIONS is a TREE_LIST, it is the list of exceptions we are    willing to reraise.  */
end_comment

begin_function
name|void
name|cplus_expand_reraise
parameter_list|(
name|exceptions
parameter_list|)
name|tree
name|exceptions
decl_stmt|;
block|{
name|tree
name|ex_ptr
decl_stmt|;
name|tree
name|ex_object
init|=
name|current_exception_object
decl_stmt|;
name|rtx
name|ex_ptr_as_rtx
decl_stmt|;
if|if
condition|(
name|exceptions
operator|&&
name|TREE_CODE
argument_list|(
name|exceptions
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
block|{
comment|/* Don't get tripped up if its TREE_TYPE is `error_mark_node'.  */
name|ex_object
operator|=
name|IDENTIFIER_LOCAL_VALUE
argument_list|(
name|exceptions
argument_list|)
expr_stmt|;
if|if
condition|(
name|ex_object
operator|==
name|NULL_TREE
operator|||
name|TREE_CODE
argument_list|(
name|ex_object
argument_list|)
operator|!=
name|INDIRECT_REF
condition|)
block|{
name|error
argument_list|(
literal|"`%s' is not an exception decl"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|exceptions
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|ex_object
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|VAR_DECL
argument_list|,
literal|204
argument_list|)
expr_stmt|;
name|exceptions
operator|=
name|NULL_TREE
expr_stmt|;
block|}
name|ex_ptr
operator|=
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|ptr_type_node
argument_list|,
name|TREE_OPERAND
argument_list|(
name|ex_object
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|ex_ptr_as_rtx
operator|=
name|expand_expr
argument_list|(
name|ex_ptr
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* reraise ALL, used by compiler.  */
if|if
condition|(
name|exceptions
operator|==
name|NULL_TREE
condition|)
block|{
comment|/* Now treat reraise like catch/raise.  */
name|expand_catch
argument_list|(
name|error_mark_node
argument_list|)
expr_stmt|;
name|expand_raise
argument_list|(
name|error_mark_node
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|EHS_name_as_rtx
argument_list|,
name|current_exception_name_as_rtx
argument_list|)
expr_stmt|;
name|store_expr
argument_list|(
name|EHS_parms_as_rtx
argument_list|,
name|current_exception_parms_as_rtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|in_try_block
argument_list|(
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sets_exception_throw_decl
operator|=
literal|1
expr_stmt|;
name|emit_move_insn
argument_list|(
name|DECL_RTL
argument_list|(
name|exception_throw_decl
argument_list|)
argument_list|,
name|const1_rtx
argument_list|)
expr_stmt|;
block|}
comment|/* Set to zero so that destructor will not be called.  */
name|emit_move_insn
argument_list|(
name|ex_ptr_as_rtx
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|expand_escape_except
argument_list|()
condition|)
name|my_friendly_abort
argument_list|(
literal|38
argument_list|)
expr_stmt|;
comment|/* To avoid spurious warning messages, we add a goto to the end 	 of the function.  This code is dead, and the compiler should 	 know how to delete it, but for now, we are stuck with it.  */
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
operator|!=
name|void_type_node
condition|)
name|expand_null_return
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* reraise from a list of exceptions.  */
while|while
condition|(
name|exceptions
condition|)
block|{
name|tree
name|type
init|=
name|lookup_exception_type
argument_list|(
name|current_class_type
argument_list|,
name|current_class_name
argument_list|,
name|exceptions
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|NULL_TREE
condition|)
block|{
name|error
argument_list|(
literal|"`%s' is not an exception type"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|TREE_VALUE
argument_list|(
name|exceptions
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|current_exception_type
operator|=
name|NULL_TREE
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|ex_object
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|ex_ptr
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
block|}
else|else
block|{
name|current_exception_type
operator|=
name|type
expr_stmt|;
comment|/* In-place union.  */
name|TREE_TYPE
argument_list|(
name|ex_object
argument_list|)
operator|=
name|type
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|ex_ptr
argument_list|)
operator|=
name|TYPE_POINTER_TO
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
comment|/* Now treat reraise like catch/raise.  */
name|cplus_expand_start_catch
argument_list|(
name|exceptions
argument_list|)
expr_stmt|;
name|cplus_expand_raise
argument_list|(
name|exceptions
argument_list|,
name|NULL_TREE
argument_list|,
name|ex_ptr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Set to zero so that destructor will not be called.  */
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|ex_ptr
argument_list|)
operator|!=
name|error_mark_node
condition|)
name|emit_move_insn
argument_list|(
name|ex_ptr_as_rtx
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|cplus_expand_end_catch
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|exceptions
operator|=
name|TREE_CHAIN
argument_list|(
name|exceptions
argument_list|)
expr_stmt|;
block|}
comment|/* Don't propagate any unhandled exceptions.  */
name|expand_expr
argument_list|(
name|call_to_unhandled_exception
argument_list|()
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* To avoid spurious warning messages, we add a goto to the end      of the function.  This code is dead, and the compiler should      know how to delete it, but for now, we are stuck with it.  */
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
operator|!=
name|void_type_node
condition|)
name|expand_null_return
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|setup_exception_throw_decl
parameter_list|()
block|{
name|tree
name|call_to_longjmp
decl_stmt|,
name|parms
decl_stmt|;
name|int
name|old
init|=
name|suspend_momentary
argument_list|()
decl_stmt|;
name|exception_throw_decl
operator|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|get_identifier
argument_list|(
name|THROW_NAME
argument_list|)
argument_list|,
name|integer_type_node
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|exception_throw_decl
argument_list|)
expr_stmt|;
name|parms
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|EHS_handler
argument_list|,
name|build_tree_list
argument_list|(
literal|0
argument_list|,
name|integer_one_node
argument_list|)
argument_list|)
expr_stmt|;
name|call_to_longjmp
operator|=
name|build_function_call
argument_list|(
name|BILJ
argument_list|,
name|parms
argument_list|)
expr_stmt|;
name|expand_decl
argument_list|(
name|exception_throw_decl
argument_list|)
expr_stmt|;
name|expand_decl_cleanup
argument_list|(
name|exception_throw_decl
argument_list|,
name|build
argument_list|(
name|COND_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|exception_throw_decl
argument_list|,
name|call_to_longjmp
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|exception_throw_decl
argument_list|)
operator|=
name|integer_zero_node
expr_stmt|;
name|sets_exception_throw_decl
operator|=
literal|0
expr_stmt|;
name|resume_momentary
argument_list|(
name|old
argument_list|)
expr_stmt|;
comment|/* Cache these, since they won't change throughout the function.  */
name|EHS_parms_as_rtx
operator|=
name|expand_expr
argument_list|(
name|EHS_parms
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|EHS_name_as_rtx
operator|=
name|expand_expr
argument_list|(
name|EHS_name
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|init_exception_processing
parameter_list|()
block|{
specifier|extern
name|tree
name|unhandled_exception_fndecl
decl_stmt|;
name|tree
name|cname
init|=
name|get_identifier
argument_list|(
literal|"ExceptionHandler"
argument_list|)
decl_stmt|;
name|tree
name|field
decl_stmt|,
name|chain
decl_stmt|;
name|tree
name|ctor
decl_stmt|,
name|dtor
decl_stmt|;
name|tree
name|jmp_buf_type
init|=
name|build_array_type
argument_list|(
name|integer_type_node
argument_list|,
name|build_index_type
argument_list|(
name|build_int_2
argument_list|(
name|_JBLEN
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|jmp_buf_arg_type
init|=
name|build_pointer_type
argument_list|(
name|integer_type_node
argument_list|)
decl_stmt|;
name|tree
name|parmtypes
init|=
name|hash_tree_chain
argument_list|(
name|jmp_buf_arg_type
argument_list|,
name|void_list_node
argument_list|)
decl_stmt|;
name|tree
name|setjmp_fndecl
decl_stmt|,
name|longjmp_fndecl
decl_stmt|,
name|raise_fndecl
decl_stmt|;
name|int
name|old_interface_only
init|=
name|interface_only
decl_stmt|;
name|int
name|old_interface_unknown
init|=
name|interface_unknown
decl_stmt|;
name|interface_only
operator|=
literal|1
expr_stmt|;
name|interface_unknown
operator|=
literal|0
expr_stmt|;
name|EHS_type
operator|=
name|xref_tag
argument_list|(
name|record_type_node
argument_list|,
name|cname
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|push_lang_context
argument_list|(
name|lang_name_c
argument_list|)
expr_stmt|;
name|setjmp_fndecl
operator|=
name|define_function
argument_list|(
literal|"setjmp"
argument_list|,
name|build_function_type
argument_list|(
name|integer_type_node
argument_list|,
name|parmtypes
argument_list|)
argument_list|,
name|NOT_BUILT_IN
argument_list|,
name|pushdecl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|BISJ
operator|=
name|default_conversion
argument_list|(
name|setjmp_fndecl
argument_list|)
expr_stmt|;
name|parmtypes
operator|=
name|hash_tree_chain
argument_list|(
name|jmp_buf_arg_type
argument_list|,
name|hash_tree_chain
argument_list|(
name|integer_type_node
argument_list|,
name|void_list_node
argument_list|)
argument_list|)
expr_stmt|;
name|longjmp_fndecl
operator|=
name|define_function
argument_list|(
literal|"longjmp"
argument_list|,
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|parmtypes
argument_list|)
argument_list|,
name|NOT_BUILT_IN
argument_list|,
name|pushdecl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|raise_fndecl
operator|=
name|define_function
argument_list|(
literal|"__raise_exception"
argument_list|,
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|hash_tree_chain
argument_list|(
name|ptr_type_node
argument_list|,
name|hash_tree_chain
argument_list|(
name|build_pointer_type
argument_list|(
name|ptr_type_node
argument_list|)
argument_list|,
name|void_list_node
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|NOT_BUILT_IN
argument_list|,
name|pushdecl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|BILJ
operator|=
name|default_conversion
argument_list|(
name|longjmp_fndecl
argument_list|)
expr_stmt|;
name|BIR
operator|=
name|default_conversion
argument_list|(
name|raise_fndecl
argument_list|)
expr_stmt|;
name|BIUE
operator|=
name|default_conversion
argument_list|(
name|unhandled_exception_fndecl
argument_list|)
expr_stmt|;
name|pop_lang_context
argument_list|()
expr_stmt|;
comment|/* finish_struct will pop this.  */
name|pushclass
argument_list|(
name|EHS_type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|field
operator|=
name|build_lang_field_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"parms"
argument_list|)
argument_list|,
name|ptr_type_node
argument_list|)
expr_stmt|;
name|chain
operator|=
name|field
expr_stmt|;
name|field
operator|=
name|build_lang_field_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"name"
argument_list|)
argument_list|,
name|build_pointer_type
argument_list|(
name|default_function_type
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
operator|=
name|chain
expr_stmt|;
name|chain
operator|=
name|field
expr_stmt|;
name|field
operator|=
name|build_lang_field_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"handler"
argument_list|)
argument_list|,
name|jmp_buf_type
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
operator|=
name|chain
expr_stmt|;
name|chain
operator|=
name|field
expr_stmt|;
name|field
operator|=
name|build_lang_field_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"prev"
argument_list|)
argument_list|,
name|TYPE_POINTER_TO
argument_list|(
name|EHS_type
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
operator|=
name|chain
expr_stmt|;
name|chain
operator|=
name|field
expr_stmt|;
name|ctor
operator|=
name|build_lang_decl
argument_list|(
name|FUNCTION_DECL
argument_list|,
name|cname
argument_list|,
name|build_cplus_method_type
argument_list|(
name|EHS_type
argument_list|,
name|TYPE_POINTER_TO
argument_list|(
name|EHS_type
argument_list|)
argument_list|,
name|void_list_node
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_CONSTRUCTOR_P
argument_list|(
name|ctor
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|ctor
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|ctor
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|ctor
argument_list|)
operator|=
literal|1
expr_stmt|;
name|grokclassfn
argument_list|(
name|EHS_type
argument_list|,
name|cname
argument_list|,
name|ctor
argument_list|,
name|NO_SPECIAL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|grok_ctor_properties
argument_list|(
name|EHS_type
argument_list|,
name|ctor
argument_list|)
expr_stmt|;
name|finish_decl
argument_list|(
name|pushdecl
argument_list|(
name|ctor
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Must copy the node here because the FUNCTION_DECL      used inside the struct ain't the same as the      FUNCTION_DECL we stick into the global binding      contour.  */
name|ctor
operator|=
name|copy_node
argument_list|(
name|ctor
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|ctor
argument_list|)
operator|=
name|chain
expr_stmt|;
name|chain
operator|=
name|ctor
expr_stmt|;
name|dtor
operator|=
name|build_lang_decl
argument_list|(
name|FUNCTION_DECL
argument_list|,
name|cname
argument_list|,
name|build_cplus_method_type
argument_list|(
name|EHS_type
argument_list|,
name|TYPE_POINTER_TO
argument_list|(
name|EHS_type
argument_list|)
argument_list|,
name|void_list_node
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|dtor
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|dtor
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|dtor
argument_list|)
operator|=
literal|1
expr_stmt|;
name|grokclassfn
argument_list|(
name|EHS_type
argument_list|,
name|cname
argument_list|,
name|dtor
argument_list|,
name|DTOR_FLAG
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|finish_decl
argument_list|(
name|pushdecl
argument_list|(
name|dtor
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Copy for the same reason as copying ctor.  */
name|dtor
operator|=
name|copy_node
argument_list|(
name|dtor
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|dtor
argument_list|)
operator|=
name|chain
expr_stmt|;
name|chain
operator|=
name|dtor
expr_stmt|;
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|EHS_type
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TYPE_HAS_DESTRUCTOR
argument_list|(
name|EHS_type
argument_list|)
operator|=
literal|1
expr_stmt|;
name|finish_struct
argument_list|(
name|EHS_type
argument_list|,
name|temp_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|chain
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|interface_only
operator|=
name|old_interface_only
expr_stmt|;
name|interface_unknown
operator|=
name|old_interface_unknown
expr_stmt|;
block|}
end_function

begin_function
name|void
name|init_exception_processing_1
parameter_list|()
block|{
specifier|register
name|tree
name|EHS_id
init|=
name|get_identifier
argument_list|(
literal|"exceptionHandlerStack"
argument_list|)
decl_stmt|;
name|EHS_decl
operator|=
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|EHS_id
argument_list|)
expr_stmt|;
comment|/* If we have no other definition, default to library implementation.  */
if|if
condition|(
name|EHS_decl
operator|==
name|NULL_TREE
condition|)
block|{
name|EHS_decl
operator|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|EHS_id
argument_list|,
name|TYPE_POINTER_TO
argument_list|(
name|EHS_type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we don't push this, its definition, should it be encountered, 	 will not be seen.  */
name|EHS_decl
operator|=
name|pushdecl
argument_list|(
name|EHS_decl
argument_list|)
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|EHS_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|EHS_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|EHS_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|finish_decl
argument_list|(
name|EHS_decl
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|EHS_decl
argument_list|)
operator|!=
name|VAR_DECL
operator|||
name|TREE_TYPE
argument_list|(
name|EHS_decl
argument_list|)
operator|!=
name|TYPE_POINTER_TO
argument_list|(
name|EHS_type
argument_list|)
condition|)
name|fatal
argument_list|(
literal|"exception handling declarations conflict with compiler's internal model"
argument_list|)
expr_stmt|;
if|if
condition|(
name|EHS_prev
operator|==
name|NULL_TREE
condition|)
block|{
specifier|register
name|tree
name|EHS_DECL
init|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|EHS_type
argument_list|,
name|EHS_decl
argument_list|)
decl_stmt|;
name|EHS_prev
operator|=
name|build_component_ref
argument_list|(
name|EHS_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"prev"
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|EHS_handler
operator|=
name|build_component_ref
argument_list|(
name|EHS_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"handler"
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|EHS_parms
operator|=
name|build_component_ref
argument_list|(
name|EHS_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"parms"
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|EHS_name
operator|=
name|build_component_ref
argument_list|(
name|EHS_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"name"
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

