begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Language-level data type conversion for GNU C++.    Copyright (C) 1987, 1988, 1992 Free Software Foundation, Inc.    Hacked by Michael Tiemann (tiemann@cygnus.com)  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* This file contains the functions for converting C expressions    to different data types.  The only entry point is `convert'.    Every language front end must have a `convert' function    but what kind of conversions it does will depend on the language.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"cp-tree.h"
end_include

begin_include
include|#
directive|include
file|"cp-class.h"
end_include

begin_define
define|#
directive|define
name|NULL
value|0
end_define

begin_function_decl
specifier|extern
name|void
name|warn_for_assignment
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Change of width--truncation and extension of integers or reals--    is represented with NOP_EXPR.  Proper functioning of many things    assumes that no other conversions can be NOP_EXPRs.     Conversion between integer and pointer is represented with CONVERT_EXPR.    Converting integer to real uses FLOAT_EXPR    and real to integer uses FIX_TRUNC_EXPR.     Here is a list of all the functions that assume that widening and    narrowing is always done with a NOP_EXPR:      In c-convert.c, convert_to_integer.      In c-typeck.c, build_binary_op_nodefault (boolean ops),         and truthvalue_conversion.      In expr.c: expand_expr, for operands of a MULT_EXPR.      In fold-const.c: fold.      In tree.c: get_narrower and get_unwidened.     C++: in multiple-inheritance, converting between pointers may involve    adjusting them by a delta stored within the class definition.  */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Subroutines of `convert'.  */
end_comment

begin_function
specifier|static
name|tree
name|convert_to_pointer
parameter_list|(
name|type
parameter_list|,
name|expr
parameter_list|)
name|tree
name|type
decl_stmt|,
name|expr
decl_stmt|;
block|{
specifier|register
name|tree
name|intype
init|=
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
decl_stmt|;
specifier|register
name|enum
name|tree_code
name|form
init|=
name|TREE_CODE
argument_list|(
name|intype
argument_list|)
decl_stmt|;
if|if
condition|(
name|integer_zerop
argument_list|(
name|expr
argument_list|)
condition|)
block|{
if|if
condition|(
name|type
operator|==
name|TREE_TYPE
argument_list|(
name|null_pointer_node
argument_list|)
condition|)
return|return
name|null_pointer_node
return|;
name|expr
operator|=
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
operator|=
name|type
expr_stmt|;
return|return
name|expr
return|;
block|}
if|if
condition|(
name|form
operator|==
name|POINTER_TYPE
condition|)
block|{
name|intype
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|intype
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
operator|!=
name|intype
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|RECORD_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|intype
argument_list|)
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
block|{
name|enum
name|tree_code
name|code
init|=
name|PLUS_EXPR
decl_stmt|;
name|tree
name|binfo
init|=
name|get_binfo
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|intype
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|binfo
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|binfo
operator|==
name|NULL_TREE
condition|)
block|{
name|binfo
operator|=
name|get_binfo
argument_list|(
name|TREE_TYPE
argument_list|(
name|intype
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|binfo
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|code
operator|=
name|MINUS_EXPR
expr_stmt|;
block|}
if|if
condition|(
name|binfo
condition|)
block|{
if|if
condition|(
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|||
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|TREE_TYPE
argument_list|(
name|intype
argument_list|)
argument_list|)
operator|||
operator|!
name|BINFO_OFFSET_ZEROP
argument_list|(
name|binfo
argument_list|)
condition|)
block|{
comment|/* Need to get the path we took.  */
name|tree
name|path
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|PLUS_EXPR
condition|)
name|get_base_distance
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|intype
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|&
name|path
argument_list|)
expr_stmt|;
else|else
name|get_base_distance
argument_list|(
name|TREE_TYPE
argument_list|(
name|intype
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|&
name|path
argument_list|)
expr_stmt|;
return|return
name|build_vbase_path
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|expr
argument_list|,
name|path
argument_list|,
literal|0
argument_list|)
return|;
block|}
block|}
block|}
return|return
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|type
argument_list|,
name|expr
argument_list|)
return|;
block|}
if|if
condition|(
name|form
operator|==
name|INTEGER_TYPE
operator|||
name|form
operator|==
name|ENUMERAL_TYPE
condition|)
block|{
if|if
condition|(
name|type_precision
argument_list|(
name|intype
argument_list|)
operator|==
name|POINTER_SIZE
condition|)
return|return
name|build1
argument_list|(
name|CONVERT_EXPR
argument_list|,
name|type
argument_list|,
name|expr
argument_list|)
return|;
return|return
name|convert_to_pointer
argument_list|(
name|type
argument_list|,
name|convert
argument_list|(
name|type_for_size
argument_list|(
name|POINTER_SIZE
argument_list|,
literal|0
argument_list|)
argument_list|,
name|expr
argument_list|)
argument_list|)
return|;
block|}
name|my_friendly_assert
argument_list|(
name|form
operator|!=
name|OFFSET_TYPE
argument_list|,
literal|186
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|intype
argument_list|)
condition|)
block|{
comment|/* If we cannot convert to the specific pointer type, 	 try to convert to the type `void *'.  */
name|tree
name|rval
decl_stmt|;
name|rval
operator|=
name|build_type_conversion
argument_list|(
name|CONVERT_EXPR
argument_list|,
name|type
argument_list|,
name|expr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
condition|)
block|{
if|if
condition|(
name|rval
operator|==
name|error_mark_node
condition|)
name|error
argument_list|(
literal|"ambiguous pointer conversion"
argument_list|)
expr_stmt|;
return|return
name|rval
return|;
block|}
block|}
name|error
argument_list|(
literal|"cannot convert to a pointer type"
argument_list|)
expr_stmt|;
return|return
name|null_pointer_node
return|;
block|}
end_function

begin_comment
comment|/* Like convert, except permit conversions to take place which    are not normally allowed due to visibility restrictions    (such as conversion from sub-type to private super-type).  */
end_comment

begin_function
specifier|static
name|tree
name|convert_to_pointer_force
parameter_list|(
name|type
parameter_list|,
name|expr
parameter_list|)
name|tree
name|type
decl_stmt|,
name|expr
decl_stmt|;
block|{
specifier|register
name|tree
name|intype
init|=
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
decl_stmt|;
specifier|register
name|enum
name|tree_code
name|form
init|=
name|TREE_CODE
argument_list|(
name|intype
argument_list|)
decl_stmt|;
if|if
condition|(
name|integer_zerop
argument_list|(
name|expr
argument_list|)
condition|)
block|{
if|if
condition|(
name|type
operator|==
name|TREE_TYPE
argument_list|(
name|null_pointer_node
argument_list|)
condition|)
return|return
name|null_pointer_node
return|;
name|expr
operator|=
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
operator|=
name|type
expr_stmt|;
return|return
name|expr
return|;
block|}
if|if
condition|(
name|form
operator|==
name|POINTER_TYPE
condition|)
block|{
name|intype
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|intype
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
operator|!=
name|intype
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|RECORD_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|intype
argument_list|)
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
block|{
name|enum
name|tree_code
name|code
init|=
name|PLUS_EXPR
decl_stmt|;
name|tree
name|path
decl_stmt|;
name|int
name|distance
init|=
name|get_base_distance
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|intype
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|&
name|path
argument_list|)
decl_stmt|;
if|if
condition|(
name|distance
operator|==
operator|-
literal|2
condition|)
block|{
name|ambig
label|:
name|error_with_aggr_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|"type `%s' is ambiguous baseclass of `%s'"
argument_list|,
name|TYPE_NAME_STRING
argument_list|(
name|TREE_TYPE
argument_list|(
name|intype
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|distance
operator|==
operator|-
literal|1
condition|)
block|{
name|distance
operator|=
name|get_base_distance
argument_list|(
name|TREE_TYPE
argument_list|(
name|intype
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|&
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|distance
operator|==
operator|-
literal|2
condition|)
goto|goto
name|ambig
goto|;
if|if
condition|(
name|distance
operator|<
literal|0
condition|)
comment|/* Doesn't need any special help from us.  */
return|return
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|type
argument_list|,
name|expr
argument_list|)
return|;
name|code
operator|=
name|MINUS_EXPR
expr_stmt|;
block|}
return|return
name|build_vbase_path
argument_list|(
name|code
argument_list|,
name|type
argument_list|,
name|expr
argument_list|,
name|path
argument_list|,
literal|0
argument_list|)
return|;
block|}
return|return
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|type
argument_list|,
name|expr
argument_list|)
return|;
block|}
return|return
name|convert_to_pointer
argument_list|(
name|type
argument_list|,
name|expr
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* We are passing something to a function which requires a reference.    The type we are interested in is in TYPE. The initial    value we have to begin with is in ARG.     FLAGS controls how we manage visibility checking.    CHECKCONST controls if we report error messages on const subversion.  */
end_comment

begin_function
specifier|static
name|tree
name|build_up_reference
parameter_list|(
name|type
parameter_list|,
name|arg
parameter_list|,
name|flags
parameter_list|,
name|checkconst
parameter_list|)
name|tree
name|type
decl_stmt|,
name|arg
decl_stmt|;
name|int
name|flags
decl_stmt|,
name|checkconst
decl_stmt|;
block|{
name|tree
name|rval
decl_stmt|,
name|targ
decl_stmt|;
name|int
name|literal_flag
init|=
literal|0
decl_stmt|;
name|tree
name|argtype
init|=
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
decl_stmt|,
name|basetype
init|=
name|argtype
decl_stmt|;
name|tree
name|target_type
init|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|binfo
init|=
name|NULL_TREE
decl_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REFERENCE_TYPE
argument_list|,
literal|187
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|!=
literal|0
operator|&&
name|TYPE_MAIN_VARIANT
argument_list|(
name|argtype
argument_list|)
operator|!=
name|TYPE_MAIN_VARIANT
argument_list|(
name|target_type
argument_list|)
operator|&&
name|IS_AGGR_TYPE
argument_list|(
name|argtype
argument_list|)
operator|&&
name|IS_AGGR_TYPE
argument_list|(
name|target_type
argument_list|)
condition|)
block|{
name|binfo
operator|=
name|get_binfo
argument_list|(
name|target_type
argument_list|,
name|argtype
argument_list|,
operator|(
name|flags
operator|&
name|LOOKUP_PROTECTED_OK
operator|)
condition|?
literal|3
else|:
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|LOOKUP_PROTECT
operator|)
operator|&&
name|binfo
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|basetype
operator|==
name|NULL_TREE
condition|)
return|return
name|error_not_base_type
argument_list|(
name|target_type
argument_list|,
name|argtype
argument_list|)
return|;
name|basetype
operator|=
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
block|}
comment|/* Pass along const and volatile down into the type. */
if|if
condition|(
name|TYPE_READONLY
argument_list|(
name|type
argument_list|)
operator|||
name|TYPE_VOLATILE
argument_list|(
name|type
argument_list|)
condition|)
name|target_type
operator|=
name|build_type_variant
argument_list|(
name|target_type
argument_list|,
name|TYPE_READONLY
argument_list|(
name|type
argument_list|)
argument_list|,
name|TYPE_VOLATILE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|targ
operator|=
name|arg
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|targ
argument_list|)
operator|==
name|SAVE_EXPR
condition|)
name|targ
operator|=
name|TREE_OPERAND
argument_list|(
name|targ
argument_list|,
literal|0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|targ
argument_list|)
condition|)
block|{
case|case
name|INDIRECT_REF
case|:
comment|/* This is a call to a constructor which did not know what it was 	 initializing until now: it needs to initialize a temporary.  */
if|if
condition|(
name|TREE_HAS_CONSTRUCTOR
argument_list|(
name|targ
argument_list|)
condition|)
block|{
name|tree
name|temp
init|=
name|build_cplus_new
argument_list|(
name|argtype
argument_list|,
name|TREE_OPERAND
argument_list|(
name|targ
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|TREE_HAS_CONSTRUCTOR
argument_list|(
name|targ
argument_list|)
operator|=
literal|0
expr_stmt|;
return|return
name|build_up_reference
argument_list|(
name|type
argument_list|,
name|temp
argument_list|,
name|flags
argument_list|,
literal|1
argument_list|)
return|;
block|}
comment|/* Let&* cancel out to simplify resulting code.          Also, throw away intervening NOP_EXPRs.  */
name|arg
operator|=
name|TREE_OPERAND
argument_list|(
name|targ
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|NOP_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|NON_LVALUE_EXPR
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|CONVERT_EXPR
operator|&&
name|TREE_REFERENCE_EXPR
argument_list|(
name|arg
argument_list|)
operator|)
condition|)
name|arg
operator|=
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* in doing a&*, we have to get rid of the const'ness on the pointer 	 value.  Haven't thought about volatile here.  Pointers come to mind 	 here.  */
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|arg
argument_list|)
condition|)
block|{
name|arg
operator|=
name|copy_node
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|TREE_READONLY
argument_list|(
name|arg
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
name|rval
operator|=
name|build1
argument_list|(
name|CONVERT_EXPR
argument_list|,
name|type
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|TREE_REFERENCE_EXPR
argument_list|(
name|rval
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* propagate the const flag on something like:  	 class Base { 	 public: 	   int foo; 	 };        class Derived : public Base {       public: 	int bar;       };        void func(Base&);        void func2(const Derived& d) { 	func(d);       }          on the d parameter.  The below could have been avoided, if the flags         were down in the tree, not sure why they are not.  (mrs) */
comment|/* The below code may have to be propagated to other parts of this 	 switch.  */
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|targ
argument_list|)
operator|&&
operator|!
name|TREE_READONLY
argument_list|(
name|arg
argument_list|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|PARM_DECL
operator|||
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|VAR_DECL
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
operator|&&
operator|(
name|TYPE_READONLY
argument_list|(
name|target_type
argument_list|)
operator|&&
name|checkconst
operator|)
condition|)
block|{
name|arg
operator|=
name|copy_node
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|TREE_READONLY
argument_list|(
name|arg
argument_list|)
operator|=
name|TREE_READONLY
argument_list|(
name|targ
argument_list|)
expr_stmt|;
block|}
name|literal_flag
operator|=
name|TREE_CONSTANT
argument_list|(
name|arg
argument_list|)
expr_stmt|;
goto|goto
name|done_but_maybe_warn
goto|;
comment|/* Get this out of a register if we happened to be in one by accident. 	 Also, build up references to non-lvalues it we must.  */
comment|/* For&x[y], return (&) x+y */
case|case
name|ARRAY_REF
case|:
if|if
condition|(
name|mark_addressable
argument_list|(
name|TREE_OPERAND
argument_list|(
name|targ
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
return|return
name|error_mark_node
return|;
name|rval
operator|=
name|build_binary_op
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_OPERAND
argument_list|(
name|targ
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|targ
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|rval
argument_list|)
operator|=
name|type
expr_stmt|;
if|if
condition|(
name|TREE_CONSTANT
argument_list|(
name|TREE_OPERAND
argument_list|(
name|targ
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
name|staticp
argument_list|(
name|TREE_OPERAND
argument_list|(
name|targ
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|TREE_CONSTANT
argument_list|(
name|rval
argument_list|)
operator|=
literal|1
expr_stmt|;
goto|goto
name|done
goto|;
case|case
name|SCOPE_REF
case|:
comment|/* Could be a reference to a static member.  */
block|{
name|tree
name|field
init|=
name|TREE_OPERAND
argument_list|(
name|targ
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_STATIC
argument_list|(
name|field
argument_list|)
condition|)
block|{
name|rval
operator|=
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|type
argument_list|,
name|field
argument_list|)
expr_stmt|;
name|literal_flag
operator|=
literal|1
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
comment|/* we should have farmed out member pointers above.  */
name|my_friendly_assert
argument_list|(
literal|0
argument_list|,
literal|188
argument_list|)
expr_stmt|;
case|case
name|COMPONENT_REF
case|:
name|rval
operator|=
name|build_component_addr
argument_list|(
name|targ
argument_list|,
name|build_pointer_type
argument_list|(
name|argtype
argument_list|)
argument_list|,
literal|"attempt to make a reference to bit-field structure member `%s'"
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|rval
argument_list|)
operator|=
name|type
expr_stmt|;
name|literal_flag
operator|=
name|staticp
argument_list|(
name|TREE_OPERAND
argument_list|(
name|targ
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|done_but_maybe_warn
goto|;
comment|/* Anything not already handled and not a true memory reference 	 needs to have a reference built up.  Do so silently for 	 things like integers and return values from function, 	 but complain if we need a reference to something declared 	 as `register'.  */
case|case
name|RESULT_DECL
case|:
if|if
condition|(
name|staticp
argument_list|(
name|targ
argument_list|)
condition|)
name|literal_flag
operator|=
literal|1
expr_stmt|;
name|TREE_ADDRESSABLE
argument_list|(
name|targ
argument_list|)
operator|=
literal|1
expr_stmt|;
name|put_var_into_stack
argument_list|(
name|targ
argument_list|)
expr_stmt|;
break|break;
case|case
name|PARM_DECL
case|:
if|if
condition|(
name|targ
operator|==
name|current_class_decl
condition|)
block|{
name|error
argument_list|(
literal|"address of `this' not available"
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* This code makes the following core dump the compiler on a sun4, 	     if the code below is used.  	     class e_decl; 	     class a_decl; 	     typedef a_decl* a_ref;  	     class a_s { 	     public: 	       a_s(); 	       void* append(a_ref& item); 	     }; 	     class a_decl { 	     public: 	       a_decl (e_decl *parent); 	       a_s  generic_s; 	       a_s  decls; 	       e_decl* parent; 	     };  	     class e_decl { 	     public: 	       e_decl(); 	       a_s implementations; 	     };  	     void foobar(void *);  	     a_decl::a_decl(e_decl *parent) { 	       parent->implementations.append(this); 	     } 	   */
block|TREE_ADDRESSABLE (targ) = 1;
comment|/* so compiler doesn't die later */
block|put_var_into_stack (targ);
else|#
directive|else
return|return
name|error_mark_node
return|;
endif|#
directive|endif
break|break;
block|}
comment|/* Fall through.  */
case|case
name|VAR_DECL
case|:
case|case
name|CONST_DECL
case|:
if|if
condition|(
name|DECL_REGISTER
argument_list|(
name|targ
argument_list|)
operator|&&
operator|!
name|TREE_ADDRESSABLE
argument_list|(
name|targ
argument_list|)
condition|)
name|warning
argument_list|(
literal|"address needed to build reference for `%s', which is declared `register'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|targ
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|staticp
argument_list|(
name|targ
argument_list|)
condition|)
name|literal_flag
operator|=
literal|1
expr_stmt|;
name|TREE_ADDRESSABLE
argument_list|(
name|targ
argument_list|)
operator|=
literal|1
expr_stmt|;
name|put_var_into_stack
argument_list|(
name|targ
argument_list|)
expr_stmt|;
break|break;
case|case
name|COMPOUND_EXPR
case|:
block|{
name|tree
name|real_reference
init|=
name|build_up_reference
argument_list|(
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|targ
argument_list|,
literal|1
argument_list|)
argument_list|,
name|LOOKUP_PROTECT
argument_list|,
name|checkconst
argument_list|)
decl_stmt|;
name|rval
operator|=
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|targ
argument_list|,
literal|0
argument_list|)
argument_list|,
name|real_reference
argument_list|)
expr_stmt|;
name|TREE_CONSTANT
argument_list|(
name|rval
argument_list|)
operator|=
name|staticp
argument_list|(
name|TREE_OPERAND
argument_list|(
name|targ
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|rval
return|;
block|}
case|case
name|MODIFY_EXPR
case|:
case|case
name|INIT_EXPR
case|:
block|{
name|tree
name|real_reference
init|=
name|build_up_reference
argument_list|(
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|targ
argument_list|,
literal|0
argument_list|)
argument_list|,
name|LOOKUP_PROTECT
argument_list|,
name|checkconst
argument_list|)
decl_stmt|;
name|rval
operator|=
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|type
argument_list|,
name|arg
argument_list|,
name|real_reference
argument_list|)
expr_stmt|;
name|TREE_CONSTANT
argument_list|(
name|rval
argument_list|)
operator|=
name|staticp
argument_list|(
name|TREE_OPERAND
argument_list|(
name|targ
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|rval
return|;
block|}
case|case
name|COND_EXPR
case|:
return|return
name|build
argument_list|(
name|COND_EXPR
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|targ
argument_list|,
literal|0
argument_list|)
argument_list|,
name|build_up_reference
argument_list|(
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|targ
argument_list|,
literal|1
argument_list|)
argument_list|,
name|LOOKUP_PROTECT
argument_list|,
name|checkconst
argument_list|)
argument_list|,
name|build_up_reference
argument_list|(
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|targ
argument_list|,
literal|2
argument_list|)
argument_list|,
name|LOOKUP_PROTECT
argument_list|,
name|checkconst
argument_list|)
argument_list|)
return|;
case|case
name|WITH_CLEANUP_EXPR
case|:
return|return
name|build
argument_list|(
name|WITH_CLEANUP_EXPR
argument_list|,
name|type
argument_list|,
name|build_up_reference
argument_list|(
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|targ
argument_list|,
literal|0
argument_list|)
argument_list|,
name|LOOKUP_PROTECT
argument_list|,
name|checkconst
argument_list|)
argument_list|,
literal|0
argument_list|,
name|TREE_OPERAND
argument_list|(
name|targ
argument_list|,
literal|2
argument_list|)
argument_list|)
return|;
case|case
name|BIND_EXPR
case|:
name|arg
operator|=
name|TREE_OPERAND
argument_list|(
name|targ
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
operator|==
name|NULL_TREE
condition|)
block|{
name|compiler_error
argument_list|(
literal|"({ ... }) expression not expanded when needed for reference"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|rval
operator|=
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|type
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|TREE_REFERENCE_EXPR
argument_list|(
name|rval
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|rval
return|;
default|default:
break|break;
block|}
if|if
condition|(
name|TREE_ADDRESSABLE
argument_list|(
name|targ
argument_list|)
operator|==
literal|0
condition|)
block|{
name|tree
name|temp
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|targ
argument_list|)
operator|==
name|CALL_EXPR
operator|&&
name|IS_AGGR_TYPE
argument_list|(
name|argtype
argument_list|)
condition|)
block|{
name|temp
operator|=
name|build_cplus_new
argument_list|(
name|argtype
argument_list|,
name|targ
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|rval
operator|=
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|type
argument_list|,
name|temp
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
else|else
block|{
name|temp
operator|=
name|get_temp_name
argument_list|(
name|argtype
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|global_bindings_p
argument_list|()
condition|)
block|{
comment|/* Give this new temp some rtl and initialize it.  */
name|DECL_INITIAL
argument_list|(
name|temp
argument_list|)
operator|=
name|targ
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|temp
argument_list|)
operator|=
literal|1
expr_stmt|;
name|finish_decl
argument_list|(
name|temp
argument_list|,
name|targ
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Do this after declaring it static.  */
name|rval
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|temp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|literal_flag
operator|=
name|TREE_CONSTANT
argument_list|(
name|rval
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
else|else
block|{
name|rval
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|temp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Put a value into the rtl.  */
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|argtype
argument_list|)
condition|)
block|{
comment|/* This may produce surprising results, 		     since we commit to initializing the temp 		     when the temp may not actually get used.  */
name|expand_aggr_init
argument_list|(
name|temp
argument_list|,
name|targ
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|rval
argument_list|)
operator|=
name|type
expr_stmt|;
name|literal_flag
operator|=
name|TREE_CONSTANT
argument_list|(
name|rval
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
else|else
block|{
if|if
condition|(
name|binfo
operator|&&
operator|!
name|BINFO_OFFSET_ZEROP
argument_list|(
name|binfo
argument_list|)
condition|)
name|rval
operator|=
name|convert_pointer_to
argument_list|(
name|target_type
argument_list|,
name|rval
argument_list|)
expr_stmt|;
else|else
name|TREE_TYPE
argument_list|(
name|rval
argument_list|)
operator|=
name|type
expr_stmt|;
return|return
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|type
argument_list|,
name|build
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|argtype
argument_list|,
name|temp
argument_list|,
name|arg
argument_list|)
argument_list|,
name|rval
argument_list|)
return|;
block|}
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|SAVE_EXPR
condition|)
name|my_friendly_abort
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|rval
operator|=
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|type
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
name|done_but_maybe_warn
label|:
if|if
condition|(
name|checkconst
operator|&&
name|TREE_READONLY
argument_list|(
name|arg
argument_list|)
operator|&&
operator|!
name|TYPE_READONLY
argument_list|(
name|target_type
argument_list|)
condition|)
name|readonly_warning_or_error
argument_list|(
name|arg
argument_list|,
literal|"conversion to reference"
argument_list|)
expr_stmt|;
name|done
label|:
if|if
condition|(
name|TYPE_USES_COMPLEX_INHERITANCE
argument_list|(
name|argtype
argument_list|)
condition|)
block|{
name|TREE_TYPE
argument_list|(
name|rval
argument_list|)
operator|=
name|TYPE_POINTER_TO
argument_list|(
name|argtype
argument_list|)
expr_stmt|;
name|rval
operator|=
name|convert_pointer_to
argument_list|(
name|target_type
argument_list|,
name|rval
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|rval
argument_list|)
operator|=
name|type
expr_stmt|;
block|}
name|TREE_CONSTANT
argument_list|(
name|rval
argument_list|)
operator|=
name|literal_flag
expr_stmt|;
return|return
name|rval
return|;
block|}
end_function

begin_comment
comment|/* For C++: Only need to do one-level references, but cannot    get tripped up on signed/unsigned differences.     If DECL is NULL_TREE it means convert as though casting (by force).    If it is ERROR_MARK_NODE, it means the conversion is implicit,    and that temporaries may be created.    Make sure the use of user-defined conversion operators is un-ambiguous.    Otherwise, DECL is a _DECL node which can be used in error reporting.     FNDECL, PARMNUM, and ERRTYPE are only used when checking for use of    volatile or const references where they aren't desired.  */
end_comment

begin_function
name|tree
name|convert_to_reference
parameter_list|(
name|decl
parameter_list|,
name|reftype
parameter_list|,
name|expr
parameter_list|,
name|fndecl
parameter_list|,
name|parmnum
parameter_list|,
name|errtype
parameter_list|,
name|strict
parameter_list|,
name|flags
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|tree
name|reftype
decl_stmt|,
name|expr
decl_stmt|;
name|tree
name|fndecl
decl_stmt|;
name|int
name|parmnum
decl_stmt|;
name|char
modifier|*
name|errtype
decl_stmt|;
name|int
name|strict
decl_stmt|,
name|flags
decl_stmt|;
block|{
specifier|register
name|tree
name|type
init|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|reftype
argument_list|)
argument_list|)
decl_stmt|;
specifier|register
name|tree
name|intype
init|=
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
decl_stmt|;
specifier|register
name|enum
name|tree_code
name|form
init|=
name|TREE_CODE
argument_list|(
name|intype
argument_list|)
decl_stmt|;
name|tree
name|rval
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|form
operator|==
name|REFERENCE_TYPE
condition|)
name|intype
operator|=
name|TREE_TYPE
argument_list|(
name|intype
argument_list|)
expr_stmt|;
name|intype
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|intype
argument_list|)
expr_stmt|;
comment|/* @@ Probably need to have a check for X(X&) here.  */
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|intype
argument_list|)
condition|)
block|{
name|rval
operator|=
name|build_type_conversion
argument_list|(
name|CONVERT_EXPR
argument_list|,
name|reftype
argument_list|,
name|expr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
condition|)
block|{
if|if
condition|(
name|rval
operator|==
name|error_mark_node
condition|)
name|error
argument_list|(
literal|"ambiguous pointer conversion"
argument_list|)
expr_stmt|;
return|return
name|rval
return|;
block|}
elseif|else
if|if
condition|(
name|type
operator|!=
name|intype
operator|&&
operator|(
name|rval
operator|=
name|build_type_conversion
argument_list|(
name|CONVERT_EXPR
argument_list|,
name|type
argument_list|,
name|expr
argument_list|,
literal|1
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|rval
operator|==
name|error_mark_node
condition|)
return|return
name|rval
return|;
if|if
condition|(
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|rval
operator|=
name|convert_to_reference
argument_list|(
name|NULL_TREE
argument_list|,
name|reftype
argument_list|,
name|rval
argument_list|,
name|NULL_TREE
argument_list|,
operator|-
literal|1
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|strict
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|decl
operator|=
name|get_temp_name
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rval
operator|=
name|build
argument_list|(
name|INIT_EXPR
argument_list|,
name|type
argument_list|,
name|decl
argument_list|,
name|rval
argument_list|)
expr_stmt|;
name|rval
operator|=
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|reftype
argument_list|,
name|rval
argument_list|,
name|convert_to_reference
argument_list|(
name|NULL_TREE
argument_list|,
name|reftype
argument_list|,
name|decl
argument_list|,
name|NULL_TREE
argument_list|,
operator|-
literal|1
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|strict
argument_list|,
name|flags
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|form
operator|==
name|REFERENCE_TYPE
operator|&&
name|type
operator|!=
name|intype
operator|&&
name|TYPE_USES_COMPLEX_INHERITANCE
argument_list|(
name|intype
argument_list|)
condition|)
block|{
comment|/* If it may move around, build a fresh reference.  */
name|expr
operator|=
name|convert_from_reference
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|form
operator|=
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* @@ Perhaps this should try to go through a constructor first      @@ for proper initialization, but I am not sure when that      @@ is needed or desirable.       @@ The second disjunct is provided to make references behave      @@ as some people think they should, i.e., an interconvertability      @@ between references to builtin types (such as short and      @@ unsigned short).  There should be no conversion between      @@ types whose codes are different, or whose sizes are different.  */
if|if
condition|(
operator|(
operator|(
name|IS_AGGR_TYPE
argument_list|(
name|type
argument_list|)
operator|||
name|IS_AGGR_TYPE
argument_list|(
name|intype
argument_list|)
operator|)
operator|&&
name|comptypes
argument_list|(
name|type
argument_list|,
name|intype
argument_list|,
name|strict
argument_list|)
operator|)
operator|||
operator|(
operator|!
name|IS_AGGR_TYPE
argument_list|(
name|type
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TREE_CODE
argument_list|(
name|intype
argument_list|)
operator|&&
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
operator|==
name|int_size_in_bytes
argument_list|(
name|intype
argument_list|)
operator|)
condition|)
block|{
comment|/* Section 13.  */
comment|/* Since convert_for_initialization didn't call convert_for_assignment, 	 we have to do this checking here.  XXX We should have a common 	 routine between here and convert_for_assignment.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
block|{
specifier|register
name|tree
name|ttl
init|=
name|TREE_TYPE
argument_list|(
name|reftype
argument_list|)
decl_stmt|;
specifier|register
name|tree
name|ttr
init|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|TYPE_READONLY
argument_list|(
name|ttl
argument_list|)
operator|&&
name|TYPE_READONLY
argument_list|(
name|ttr
argument_list|)
condition|)
name|warn_for_assignment
argument_list|(
literal|"%s of non-`const&' reference from `const&'"
argument_list|,
literal|"reference to const given for argument %d of `%s'"
argument_list|,
name|errtype
argument_list|,
name|fndecl
argument_list|,
name|parmnum
argument_list|,
name|pedantic
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TYPE_VOLATILE
argument_list|(
name|ttl
argument_list|)
operator|&&
name|TYPE_VOLATILE
argument_list|(
name|ttr
argument_list|)
condition|)
name|warn_for_assignment
argument_list|(
literal|"%s of non-`volatile&' reference from `volatile&'"
argument_list|,
literal|"reference to volatile given for argument %d of `%s'"
argument_list|,
name|errtype
argument_list|,
name|fndecl
argument_list|,
name|parmnum
argument_list|,
name|pedantic
argument_list|)
expr_stmt|;
block|}
comment|/* If EXPR is of aggregate type, and is really a CALL_EXPR, 	 then we don't need to convert it to reference type if 	 it is only being used to initialize DECL which is also 	 of the same aggregate type.  */
if|if
condition|(
name|form
operator|==
name|REFERENCE_TYPE
operator|||
operator|(
name|decl
operator|!=
name|NULL_TREE
operator|&&
name|decl
operator|!=
name|error_mark_node
operator|&&
name|IS_AGGR_TYPE
argument_list|(
name|type
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|CALL_EXPR
operator|&&
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
operator|==
name|intype
operator|)
condition|)
block|{
if|if
condition|(
name|decl
operator|&&
name|decl
operator|!=
name|error_mark_node
condition|)
block|{
name|tree
name|e1
init|=
name|build
argument_list|(
name|INIT_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|decl
argument_list|,
name|expr
argument_list|)
decl_stmt|;
name|tree
name|e2
decl_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|e1
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|form
operator|==
name|REFERENCE_TYPE
condition|)
name|e2
operator|=
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|reftype
argument_list|,
name|decl
argument_list|)
expr_stmt|;
else|else
block|{
name|e2
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|e2
argument_list|)
operator|=
name|reftype
expr_stmt|;
name|TREE_REFERENCE_EXPR
argument_list|(
name|e2
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|build_compound_expr
argument_list|(
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|e1
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|e2
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
name|expr
operator|=
name|copy_node
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
operator|=
name|reftype
expr_stmt|;
return|return
name|expr
return|;
block|}
if|if
condition|(
name|decl
operator|==
name|error_mark_node
condition|)
name|flags
operator||=
name|LOOKUP_PROTECTED_OK
expr_stmt|;
return|return
name|build_up_reference
argument_list|(
name|reftype
argument_list|,
name|expr
argument_list|,
name|flags
argument_list|,
name|decl
operator|!=
name|NULL_TREE
argument_list|)
return|;
block|}
comment|/* Definitely need to go through a constructor here.  */
if|if
condition|(
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|tree
name|init
init|=
name|build_method_call
argument_list|(
name|NULL_TREE
argument_list|,
name|constructor_name
argument_list|(
name|type
argument_list|)
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|expr
argument_list|)
argument_list|,
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
argument_list|,
name|LOOKUP_NO_CONVERSION
argument_list|)
decl_stmt|;
name|tree
name|rval1
decl_stmt|;
if|if
condition|(
name|init
operator|!=
name|error_mark_node
condition|)
if|if
condition|(
name|rval
condition|)
block|{
name|error
argument_list|(
literal|"both constructor and type conversion operator apply"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|init
operator|=
name|build_method_call
argument_list|(
name|NULL_TREE
argument_list|,
name|constructor_name
argument_list|(
name|type
argument_list|)
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|expr
argument_list|)
argument_list|,
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
argument_list|,
name|LOOKUP_NORMAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|init
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|rval
operator|=
name|build_cplus_new
argument_list|(
name|type
argument_list|,
name|init
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl
operator|==
name|error_mark_node
condition|)
name|flags
operator||=
name|LOOKUP_PROTECTED_OK
expr_stmt|;
return|return
name|build_up_reference
argument_list|(
name|reftype
argument_list|,
name|rval
argument_list|,
name|flags
argument_list|,
name|decl
operator|!=
name|NULL_TREE
argument_list|)
return|;
block|}
if|if
condition|(
name|rval
condition|)
block|{
comment|/* If we found a way to convert earlier, then use it. */
return|return
name|rval
return|;
block|}
name|my_friendly_assert
argument_list|(
name|form
operator|!=
name|OFFSET_TYPE
argument_list|,
literal|189
argument_list|)
expr_stmt|;
comment|/* This is in two pieces for now, because pointer to first becomes      invalid once type_as_string is called again. */
name|error
argument_list|(
literal|"cannot convert type `%s'"
argument_list|,
name|type_as_string
argument_list|(
name|intype
argument_list|)
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"       to type `%s'"
argument_list|,
name|type_as_string
argument_list|(
name|reftype
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
end_function

begin_comment
comment|/* We are using a reference VAL for its value. Bash that reference all the    way down to its lowest form. */
end_comment

begin_function
name|tree
name|convert_from_reference
parameter_list|(
name|val
parameter_list|)
name|tree
name|val
decl_stmt|;
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|OFFSET_TYPE
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
block|{
name|tree
name|target_type
init|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
decl_stmt|;
comment|/* This can happen if we cast to a reference type.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|val
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
block|{
name|val
operator|=
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|target_type
argument_list|)
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|val
operator|=
name|build_indirect_ref
argument_list|(
name|val
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
name|val
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|TYPE_MAIN_VARIANT
argument_list|(
name|target_type
argument_list|)
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|TREE_THIS_VOLATILE
argument_list|(
name|val
argument_list|)
operator|=
name|TYPE_VOLATILE
argument_list|(
name|target_type
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|val
argument_list|)
operator|=
name|TYPE_VOLATILE
argument_list|(
name|target_type
argument_list|)
expr_stmt|;
name|TREE_READONLY
argument_list|(
name|val
argument_list|)
operator|=
name|TYPE_READONLY
argument_list|(
name|target_type
argument_list|)
expr_stmt|;
block|}
return|return
name|val
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|convert_to_real
parameter_list|(
name|type
parameter_list|,
name|expr
parameter_list|)
name|tree
name|type
decl_stmt|,
name|expr
decl_stmt|;
block|{
specifier|register
name|enum
name|tree_code
name|form
init|=
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|form
operator|==
name|REAL_TYPE
condition|)
return|return
name|build1
argument_list|(
name|flag_float_store
condition|?
name|CONVERT_EXPR
else|:
name|NOP_EXPR
argument_list|,
name|type
argument_list|,
name|expr
argument_list|)
return|;
if|if
condition|(
name|form
operator|==
name|INTEGER_TYPE
operator|||
name|form
operator|==
name|ENUMERAL_TYPE
condition|)
return|return
name|build1
argument_list|(
name|FLOAT_EXPR
argument_list|,
name|type
argument_list|,
name|expr
argument_list|)
return|;
name|my_friendly_assert
argument_list|(
name|form
operator|!=
name|OFFSET_TYPE
argument_list|,
literal|190
argument_list|)
expr_stmt|;
if|if
condition|(
name|form
operator|==
name|POINTER_TYPE
condition|)
name|error
argument_list|(
literal|"pointer value used where a floating point value was expected"
argument_list|)
expr_stmt|;
comment|/* C++: check to see if we can convert this aggregate type      into the required scalar type.  */
elseif|else
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|rval
decl_stmt|;
name|rval
operator|=
name|build_type_conversion
argument_list|(
name|CONVERT_EXPR
argument_list|,
name|type
argument_list|,
name|expr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
condition|)
return|return
name|rval
return|;
else|else
name|error
argument_list|(
literal|"aggregate value used where a floating point value was expected"
argument_list|)
expr_stmt|;
block|}
block|{
specifier|register
name|tree
name|tem
init|=
name|make_node
argument_list|(
name|REAL_CST
argument_list|)
decl_stmt|;
name|TREE_TYPE
argument_list|(
name|tem
argument_list|)
operator|=
name|type
expr_stmt|;
name|TREE_REAL_CST
argument_list|(
name|tem
argument_list|)
operator|=
name|REAL_VALUE_ATOF
argument_list|(
literal|"0.0"
argument_list|)
expr_stmt|;
return|return
name|tem
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The result of this is always supposed to be a newly created tree node    not in use in any existing structure.  */
end_comment

begin_function
specifier|static
name|tree
name|convert_to_integer
parameter_list|(
name|type
parameter_list|,
name|expr
parameter_list|)
name|tree
name|type
decl_stmt|,
name|expr
decl_stmt|;
block|{
specifier|register
name|tree
name|intype
init|=
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
decl_stmt|;
specifier|register
name|enum
name|tree_code
name|form
init|=
name|TREE_CODE
argument_list|(
name|intype
argument_list|)
decl_stmt|;
specifier|extern
name|tree
name|build_binary_op_nodefault
parameter_list|()
function_decl|;
specifier|extern
name|tree
name|build_unary_op
parameter_list|()
function_decl|;
if|if
condition|(
name|form
operator|==
name|POINTER_TYPE
condition|)
block|{
if|if
condition|(
name|integer_zerop
argument_list|(
name|expr
argument_list|)
condition|)
name|expr
operator|=
name|integer_zero_node
expr_stmt|;
else|else
name|expr
operator|=
name|fold
argument_list|(
name|build1
argument_list|(
name|CONVERT_EXPR
argument_list|,
name|type_for_size
argument_list|(
name|POINTER_SIZE
argument_list|,
literal|0
argument_list|)
argument_list|,
name|expr
argument_list|)
argument_list|)
expr_stmt|;
name|intype
operator|=
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|form
operator|=
name|TREE_CODE
argument_list|(
name|intype
argument_list|)
expr_stmt|;
if|if
condition|(
name|intype
operator|==
name|type
condition|)
return|return
name|expr
return|;
block|}
if|if
condition|(
name|form
operator|==
name|INTEGER_TYPE
operator|||
name|form
operator|==
name|ENUMERAL_TYPE
condition|)
block|{
specifier|register
name|unsigned
name|outprec
init|=
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
decl_stmt|;
specifier|register
name|unsigned
name|inprec
init|=
name|TYPE_PRECISION
argument_list|(
name|intype
argument_list|)
decl_stmt|;
specifier|register
name|enum
name|tree_code
name|ex_form
init|=
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
decl_stmt|;
if|if
condition|(
name|flag_int_enum_equivalence
operator|==
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ENUMERAL_TYPE
operator|&&
name|form
operator|==
name|INTEGER_TYPE
condition|)
block|{
if|if
condition|(
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"anachronistic conversion from integer type to enumeral type `%s'"
argument_list|,
name|TYPE_NAME_STRING
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_pedantic_errors
condition|)
return|return
name|error_mark_node
return|;
block|}
comment|/* If we are widening the type, put in an explicit conversion. 	 Similarly if we are not changing the width.  However, if this is 	 a logical operation that just returns 0 or 1, we can change the 	 type of the expression (see below).  */
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|ex_form
argument_list|)
operator|==
literal|'<'
operator|||
name|ex_form
operator|==
name|TRUTH_AND_EXPR
operator|||
name|ex_form
operator|==
name|TRUTH_ANDIF_EXPR
operator|||
name|ex_form
operator|==
name|TRUTH_OR_EXPR
operator|||
name|ex_form
operator|==
name|TRUTH_ORIF_EXPR
operator|||
name|ex_form
operator|==
name|TRUTH_NOT_EXPR
condition|)
block|{
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
operator|=
name|type
expr_stmt|;
return|return
name|expr
return|;
block|}
elseif|else
if|if
condition|(
name|outprec
operator|>=
name|inprec
condition|)
return|return
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|type
argument_list|,
name|expr
argument_list|)
return|;
comment|/* Here detect when we can distribute the truncation down past some arithmetic.    For example, if adding two longs and converting to an int,    we can equally well convert both to ints and then add.    For the operations handled here, such truncation distribution    is always safe.    It is desirable in these cases:    1) when truncating down to full-word from a larger size    2) when truncating takes no work.    3) when at least one operand of the arithmetic has been extended    (as by C's default conversions).  In this case we need two conversions    if we do the arithmetic as already requested, so we might as well    truncate both and then combine.  Perhaps that way we need only one.     Note that in general we cannot do the arithmetic in a type    shorter than the desired result of conversion, even if the operands    are both extended from a shorter type, because they might overflow    if combined in that type.  The exceptions to this--the times when    two narrow values can be combined in their narrow type even to    make a wider result--are handled by "shorten" in build_binary_op.  */
switch|switch
condition|(
name|ex_form
condition|)
block|{
case|case
name|RSHIFT_EXPR
case|:
comment|/* We can pass truncation down through right shifting 	     when the shift count is a nonpositive constant.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|tree_int_cst_lt
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|,
name|integer_one_node
argument_list|)
condition|)
goto|goto
name|trunc1
goto|;
break|break;
case|case
name|LSHIFT_EXPR
case|:
comment|/* We can pass truncation down through left shifting 	     when the shift count is a nonnegative constant.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
operator|!
name|tree_int_cst_lt
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|,
name|integer_zero_node
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
comment|/* If shift count is less than the width of the truncated type, 		 really shift.  */
if|if
condition|(
name|tree_int_cst_lt
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|,
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
comment|/* In this case, shifting is like multiplication.  */
goto|goto
name|trunc1
goto|;
else|else
comment|/* If it is>= that width, result is zero. 		   Handling this with trunc1 would give the wrong result: 		   (int) ((long long) a<< 32) is well defined (as 0) 		   but (int) a<< 32 is undefined and would get a warning.  */
return|return
name|convert_to_integer
argument_list|(
name|type
argument_list|,
name|integer_zero_node
argument_list|)
return|;
block|}
break|break;
case|case
name|MAX_EXPR
case|:
case|case
name|MIN_EXPR
case|:
case|case
name|MULT_EXPR
case|:
block|{
name|tree
name|arg0
init|=
name|get_unwidened
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|,
name|type
argument_list|)
decl_stmt|;
name|tree
name|arg1
init|=
name|get_unwidened
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|,
name|type
argument_list|)
decl_stmt|;
comment|/* Don't distribute unless the output precision is at least as big 	       as the actual inputs.  Otherwise, the comparison of the 	       truncated values will be wrong.  */
if|if
condition|(
name|outprec
operator|>=
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|&&
name|outprec
operator|>=
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
comment|/* If signedness of arg0 and arg1 don't match, 		   we can't necessarily find a type to compare them in.  */
operator|&&
operator|(
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|==
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|)
condition|)
goto|goto
name|trunc1
goto|;
break|break;
block|}
case|case
name|PLUS_EXPR
case|:
case|case
name|MINUS_EXPR
case|:
case|case
name|BIT_AND_EXPR
case|:
case|case
name|BIT_IOR_EXPR
case|:
case|case
name|BIT_XOR_EXPR
case|:
case|case
name|BIT_ANDTC_EXPR
case|:
name|trunc1
label|:
block|{
name|tree
name|arg0
init|=
name|get_unwidened
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|,
name|type
argument_list|)
decl_stmt|;
name|tree
name|arg1
init|=
name|get_unwidened
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|,
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|outprec
operator|>=
name|BITS_PER_WORD
operator|||
name|TRULY_NOOP_TRUNCATION
argument_list|(
name|outprec
argument_list|,
name|inprec
argument_list|)
operator|||
name|inprec
operator|>
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|||
name|inprec
operator|>
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Do the arithmetic in type TYPEX, 		   then convert result to TYPE.  */
specifier|register
name|tree
name|typex
init|=
name|type
decl_stmt|;
comment|/* Can't do arithmetic in enumeral types 		   so use an integer type that will hold the values.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|typex
argument_list|)
operator|==
name|ENUMERAL_TYPE
condition|)
name|typex
operator|=
name|type_for_size
argument_list|(
name|TYPE_PRECISION
argument_list|(
name|typex
argument_list|)
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|typex
argument_list|)
argument_list|)
expr_stmt|;
comment|/* But now perhaps TYPEX is as wide as INPREC. 		   In that case, do nothing special here. 		   (Otherwise would recurse infinitely in convert.  */
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|typex
argument_list|)
operator|!=
name|inprec
condition|)
block|{
comment|/* Don't do unsigned arithmetic where signed was wanted, 		       or vice versa. 		       Exception 1: if we will eventually truncate 		       the result, then do the work as unsigned; 		       this can prevent unnecessary sign-extension. 		       Exception 2: if either of the original operands were 		       unsigned then can safely do the work as unsigned. 		       And we may need to do it as unsigned 		       if we truncate to the original size.  */
name|typex
operator|=
operator|(
operator|(
operator|(
name|outprec
operator|<=
name|TYPE_PRECISION
argument_list|(
name|typex
argument_list|)
operator|&&
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
operator|)
operator|||
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|||
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
operator|||
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|)
condition|?
name|unsigned_type
argument_list|(
name|typex
argument_list|)
else|:
name|signed_type
argument_list|(
name|typex
argument_list|)
operator|)
expr_stmt|;
return|return
name|convert
argument_list|(
name|type
argument_list|,
name|build_binary_op_nodefault
argument_list|(
name|ex_form
argument_list|,
name|convert
argument_list|(
name|typex
argument_list|,
name|arg0
argument_list|)
argument_list|,
name|convert
argument_list|(
name|typex
argument_list|,
name|arg1
argument_list|)
argument_list|,
name|ex_form
argument_list|)
argument_list|)
return|;
block|}
block|}
block|}
break|break;
case|case
name|NEGATE_EXPR
case|:
case|case
name|BIT_NOT_EXPR
case|:
case|case
name|ABS_EXPR
case|:
block|{
specifier|register
name|tree
name|typex
init|=
name|type
decl_stmt|;
comment|/* Can't do arithmetic in enumeral types 	       so use an integer type that will hold the values.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|typex
argument_list|)
operator|==
name|ENUMERAL_TYPE
condition|)
name|typex
operator|=
name|type_for_size
argument_list|(
name|TYPE_PRECISION
argument_list|(
name|typex
argument_list|)
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|typex
argument_list|)
argument_list|)
expr_stmt|;
comment|/* But now perhaps TYPEX is as wide as INPREC. 	       In that case, do nothing special here. 	       (Otherwise would recurse infinitely in convert.  */
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|typex
argument_list|)
operator|!=
name|inprec
condition|)
block|{
comment|/* Don't do unsigned arithmetic where signed was wanted, 		   or vice versa.  */
name|typex
operator|=
operator|(
operator|(
operator|(
name|outprec
operator|<=
name|TYPE_PRECISION
argument_list|(
name|typex
argument_list|)
operator|&&
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
operator|)
operator|||
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|)
condition|?
name|unsigned_type
argument_list|(
name|typex
argument_list|)
else|:
name|signed_type
argument_list|(
name|typex
argument_list|)
operator|)
expr_stmt|;
return|return
name|convert
argument_list|(
name|type
argument_list|,
name|build_unary_op
argument_list|(
name|ex_form
argument_list|,
name|convert
argument_list|(
name|typex
argument_list|,
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
block|}
block|}
case|case
name|NOP_EXPR
case|:
comment|/* If truncating after truncating, might as well do all at once. 	     If truncating after extending, we may get rid of wasted work.  */
return|return
name|convert
argument_list|(
name|type
argument_list|,
name|get_unwidened
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|,
name|type
argument_list|)
argument_list|)
return|;
case|case
name|COND_EXPR
case|:
comment|/* Can treat the two alternative values like the operands 	     of an arithmetic expression.  */
block|{
name|tree
name|arg1
init|=
name|get_unwidened
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|,
name|type
argument_list|)
decl_stmt|;
name|tree
name|arg2
init|=
name|get_unwidened
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|2
argument_list|)
argument_list|,
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|outprec
operator|>=
name|BITS_PER_WORD
operator|||
name|TRULY_NOOP_TRUNCATION
argument_list|(
name|outprec
argument_list|,
name|inprec
argument_list|)
operator|||
name|inprec
operator|>
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|||
name|inprec
operator|>
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg2
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Do the arithmetic in type TYPEX, 		   then convert result to TYPE.  */
specifier|register
name|tree
name|typex
init|=
name|type
decl_stmt|;
comment|/* Can't do arithmetic in enumeral types 		   so use an integer type that will hold the values.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|typex
argument_list|)
operator|==
name|ENUMERAL_TYPE
condition|)
name|typex
operator|=
name|type_for_size
argument_list|(
name|TYPE_PRECISION
argument_list|(
name|typex
argument_list|)
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|typex
argument_list|)
argument_list|)
expr_stmt|;
comment|/* But now perhaps TYPEX is as wide as INPREC. 		   In that case, do nothing special here. 		   (Otherwise would recurse infinitely in convert.  */
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|typex
argument_list|)
operator|!=
name|inprec
condition|)
block|{
comment|/* Don't do unsigned arithmetic where signed was wanted, 		       or vice versa.  */
name|typex
operator|=
operator|(
operator|(
operator|(
name|outprec
operator|<=
name|TYPE_PRECISION
argument_list|(
name|typex
argument_list|)
operator|&&
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
operator|)
operator|||
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|)
condition|?
name|unsigned_type
argument_list|(
name|typex
argument_list|)
else|:
name|signed_type
argument_list|(
name|typex
argument_list|)
operator|)
expr_stmt|;
return|return
name|convert
argument_list|(
name|type
argument_list|,
name|fold
argument_list|(
name|build
argument_list|(
name|COND_EXPR
argument_list|,
name|typex
argument_list|,
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|,
name|convert
argument_list|(
name|typex
argument_list|,
name|arg1
argument_list|)
argument_list|,
name|convert
argument_list|(
name|typex
argument_list|,
name|arg2
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
else|else
comment|/* It is sometimes worthwhile 		     to push the narrowing down through the conditional.  */
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|COND_EXPR
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|,
name|convert
argument_list|(
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|convert
argument_list|(
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|2
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
block|}
block|}
return|return
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|type
argument_list|,
name|expr
argument_list|)
return|;
block|}
if|if
condition|(
name|form
operator|==
name|REAL_TYPE
condition|)
return|return
name|build1
argument_list|(
name|FIX_TRUNC_EXPR
argument_list|,
name|type
argument_list|,
name|expr
argument_list|)
return|;
if|if
condition|(
name|form
operator|==
name|OFFSET_TYPE
condition|)
name|error_with_decl
argument_list|(
name|TYPE_NAME
argument_list|(
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|intype
argument_list|)
argument_list|)
argument_list|,
literal|"pointer-to-member expression object not composed with type `%s' object"
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|intype
argument_list|)
condition|)
block|{
name|tree
name|rval
decl_stmt|;
name|rval
operator|=
name|build_type_conversion
argument_list|(
name|CONVERT_EXPR
argument_list|,
name|type
argument_list|,
name|expr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
condition|)
return|return
name|rval
return|;
block|}
name|error
argument_list|(
literal|"aggregate value used where an integer was expected"
argument_list|)
expr_stmt|;
block|}
block|{
specifier|register
name|tree
name|tem
init|=
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|TREE_TYPE
argument_list|(
name|tem
argument_list|)
operator|=
name|type
expr_stmt|;
return|return
name|tem
return|;
block|}
block|}
end_function

begin_comment
comment|/* See if there is a constructor of type TYPE which will convert    EXPR.  The reference manual seems to suggest (8.5.6) that we need    not worry about finding constructors for base classes, then converting    to the derived class.     MSGP is a pointer to a message that would be an appropriate error    string.  If MSGP is NULL, then we are not interested in reporting    errors.  */
end_comment

begin_function
name|tree
name|convert_to_aggr
parameter_list|(
name|type
parameter_list|,
name|expr
parameter_list|,
name|msgp
parameter_list|,
name|protect
parameter_list|)
name|tree
name|type
decl_stmt|,
name|expr
decl_stmt|;
name|char
modifier|*
modifier|*
name|msgp
decl_stmt|;
name|int
name|protect
decl_stmt|;
block|{
name|tree
name|basetype
init|=
name|type
decl_stmt|;
name|tree
name|name
init|=
name|TYPE_IDENTIFIER
argument_list|(
name|basetype
argument_list|)
decl_stmt|;
name|tree
name|function
decl_stmt|,
name|fndecl
decl_stmt|,
name|fntype
decl_stmt|,
name|parmtypes
decl_stmt|,
name|parmlist
decl_stmt|,
name|result
decl_stmt|;
name|tree
name|method_name
decl_stmt|;
name|enum
name|visibility_type
name|visibility
decl_stmt|;
name|int
name|can_be_private
decl_stmt|,
name|can_be_protected
decl_stmt|;
if|if
condition|(
operator|!
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|basetype
argument_list|)
condition|)
block|{
if|if
condition|(
name|msgp
condition|)
operator|*
name|msgp
operator|=
literal|"type `%s' does not have a constructor"
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|visibility
operator|=
name|visibility_public
expr_stmt|;
name|can_be_private
operator|=
literal|0
expr_stmt|;
name|can_be_protected
operator|=
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|name
argument_list|)
operator|||
name|name
operator|==
name|current_class_name
expr_stmt|;
name|parmlist
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|expr
argument_list|)
expr_stmt|;
name|parmtypes
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|,
name|void_list_node
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|basetype
argument_list|)
condition|)
block|{
name|parmtypes
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_type_node
argument_list|,
name|parmtypes
argument_list|)
expr_stmt|;
name|parmlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_one_node
argument_list|,
name|parmlist
argument_list|)
expr_stmt|;
block|}
comment|/* The type of the first argument will be filled in inside the loop.  */
name|parmlist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_zero_node
argument_list|,
name|parmlist
argument_list|)
expr_stmt|;
name|parmtypes
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|TYPE_POINTER_TO
argument_list|(
name|basetype
argument_list|)
argument_list|,
name|parmtypes
argument_list|)
expr_stmt|;
name|method_name
operator|=
name|build_decl_overload
argument_list|(
name|name
argument_list|,
name|parmtypes
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* constructors are up front.  */
name|fndecl
operator|=
name|TREE_VEC_ELT
argument_list|(
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|basetype
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_HAS_DESTRUCTOR
argument_list|(
name|basetype
argument_list|)
condition|)
name|fndecl
operator|=
name|DECL_CHAIN
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
while|while
condition|(
name|fndecl
condition|)
block|{
if|if
condition|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|fndecl
argument_list|)
operator|==
name|method_name
condition|)
block|{
name|function
operator|=
name|fndecl
expr_stmt|;
if|if
condition|(
name|protect
condition|)
block|{
if|if
condition|(
name|TREE_PRIVATE
argument_list|(
name|fndecl
argument_list|)
condition|)
block|{
name|can_be_private
operator|=
operator|(
name|basetype
operator|==
name|current_class_type
operator|||
name|is_friend
argument_list|(
name|basetype
argument_list|,
name|current_function_decl
argument_list|)
operator|||
name|purpose_member
argument_list|(
name|basetype
argument_list|,
name|DECL_VISIBILITY
argument_list|(
name|fndecl
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|can_be_private
condition|)
goto|goto
name|found
goto|;
block|}
elseif|else
if|if
condition|(
name|TREE_PROTECTED
argument_list|(
name|fndecl
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|can_be_protected
condition|)
goto|goto
name|found
goto|;
block|}
block|}
goto|goto
name|found_and_ok
goto|;
block|}
name|fndecl
operator|=
name|DECL_CHAIN
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
block|}
comment|/* No exact conversion was found.  See if an approximate      one will do.  */
name|fndecl
operator|=
name|TREE_VEC_ELT
argument_list|(
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|basetype
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_HAS_DESTRUCTOR
argument_list|(
name|basetype
argument_list|)
condition|)
name|fndecl
operator|=
name|DECL_CHAIN
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
block|{
name|int
name|saw_private
init|=
literal|0
decl_stmt|;
name|int
name|saw_protected
init|=
literal|0
decl_stmt|;
name|struct
name|candidate
modifier|*
name|candidates
init|=
operator|(
expr|struct
name|candidate
operator|*
operator|)
name|alloca
argument_list|(
operator|(
name|decl_list_length
argument_list|(
name|fndecl
argument_list|)
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|candidate
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|candidate
modifier|*
name|cp
init|=
name|candidates
decl_stmt|;
while|while
condition|(
name|fndecl
condition|)
block|{
name|function
operator|=
name|fndecl
expr_stmt|;
name|cp
operator|->
name|harshness
operator|=
operator|(
name|unsigned
name|short
operator|*
operator|)
name|alloca
argument_list|(
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
name|compute_conversion_costs
argument_list|(
name|fndecl
argument_list|,
name|parmlist
argument_list|,
name|cp
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|evil
operator|==
literal|0
condition|)
block|{
name|cp
operator|->
name|u
operator|.
name|field
operator|=
name|fndecl
expr_stmt|;
if|if
condition|(
name|protect
condition|)
block|{
if|if
condition|(
name|TREE_PRIVATE
argument_list|(
name|fndecl
argument_list|)
condition|)
name|visibility
operator|=
name|visibility_private
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_PROTECTED
argument_list|(
name|fndecl
argument_list|)
condition|)
name|visibility
operator|=
name|visibility_protected
expr_stmt|;
else|else
name|visibility
operator|=
name|visibility_public
expr_stmt|;
block|}
else|else
name|visibility
operator|=
name|visibility_public
expr_stmt|;
if|if
condition|(
name|visibility
operator|==
name|visibility_private
condition|?
operator|(
name|basetype
operator|==
name|current_class_type
operator|||
name|is_friend
argument_list|(
name|basetype
argument_list|,
name|cp
operator|->
name|function
argument_list|)
operator|||
name|purpose_member
argument_list|(
name|basetype
argument_list|,
name|DECL_VISIBILITY
argument_list|(
name|fndecl
argument_list|)
argument_list|)
operator|)
else|:
name|visibility
operator|==
name|visibility_protected
condition|?
operator|(
name|can_be_protected
operator|||
name|purpose_member
argument_list|(
name|basetype
argument_list|,
name|DECL_VISIBILITY
argument_list|(
name|fndecl
argument_list|)
argument_list|)
operator|)
else|:
literal|1
condition|)
block|{
if|if
condition|(
name|cp
operator|->
name|user
operator|==
literal|0
operator|&&
name|cp
operator|->
name|b_or_d
operator|==
literal|0
operator|&&
name|cp
operator|->
name|easy
operator|<=
literal|1
condition|)
block|{
goto|goto
name|found_and_ok
goto|;
block|}
name|cp
operator|++
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|visibility
operator|==
name|visibility_private
condition|)
name|saw_private
operator|=
literal|1
expr_stmt|;
else|else
name|saw_protected
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|fndecl
operator|=
name|DECL_CHAIN
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cp
operator|-
name|candidates
condition|)
block|{
comment|/* Rank from worst to best.  Then cp will point to best one. 	   Private fields have their bits flipped.  For unsigned 	   numbers, this should make them look very large. 	   If the best alternate has a (signed) negative value, 	   then all we ever saw were private members.  */
if|if
condition|(
name|cp
operator|-
name|candidates
operator|>
literal|1
condition|)
name|qsort
argument_list|(
name|candidates
argument_list|,
comment|/* char *base */
name|cp
operator|-
name|candidates
argument_list|,
comment|/* int nel */
sizeof|sizeof
argument_list|(
expr|struct
name|candidate
argument_list|)
argument_list|,
comment|/* int width */
name|rank_for_overload
argument_list|)
expr_stmt|;
comment|/* int (*compar)() */
operator|--
name|cp
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|evil
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|msgp
condition|)
operator|*
name|msgp
operator|=
literal|"ambiguous type conversion possible for `%s'"
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|function
operator|=
name|cp
operator|->
name|function
expr_stmt|;
name|fndecl
operator|=
name|cp
operator|->
name|u
operator|.
name|field
expr_stmt|;
goto|goto
name|found_and_ok
goto|;
block|}
elseif|else
if|if
condition|(
name|msgp
condition|)
block|{
if|if
condition|(
name|saw_private
condition|)
if|if
condition|(
name|saw_protected
condition|)
operator|*
name|msgp
operator|=
literal|"only private and protected conversions apply"
expr_stmt|;
else|else
operator|*
name|msgp
operator|=
literal|"only private conversions apply"
expr_stmt|;
elseif|else
if|if
condition|(
name|saw_protected
condition|)
operator|*
name|msgp
operator|=
literal|"only protected conversions apply"
expr_stmt|;
block|}
return|return
name|error_mark_node
return|;
block|}
comment|/* NOTREACHED */
name|not_found
label|:
if|if
condition|(
name|msgp
condition|)
operator|*
name|msgp
operator|=
literal|"no appropriate conversion to type `%s'"
expr_stmt|;
return|return
name|error_mark_node
return|;
name|found
label|:
if|if
condition|(
name|visibility
operator|==
name|visibility_private
condition|)
if|if
condition|(
operator|!
name|can_be_private
condition|)
block|{
if|if
condition|(
name|msgp
condition|)
operator|*
name|msgp
operator|=
name|TREE_PRIVATE
argument_list|(
name|fndecl
argument_list|)
condition|?
literal|"conversion to type `%s' is private"
else|:
literal|"conversion to type `%s' is from private base class"
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|visibility
operator|==
name|visibility_protected
condition|)
if|if
condition|(
operator|!
name|can_be_protected
condition|)
block|{
if|if
condition|(
name|msgp
condition|)
operator|*
name|msgp
operator|=
name|TREE_PRIVATE
argument_list|(
name|fndecl
argument_list|)
condition|?
literal|"conversion to type `%s' is protected"
else|:
literal|"conversion to type `%s' is from protected base class"
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|function
operator|=
name|fndecl
expr_stmt|;
name|found_and_ok
label|:
comment|/* It will convert, but we don't do anything about it yet.  */
if|if
condition|(
name|msgp
operator|==
literal|0
condition|)
return|return
name|NULL_TREE
return|;
name|fntype
operator|=
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_INLINE
argument_list|(
name|function
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|function
operator|=
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|fntype
argument_list|)
argument_list|,
name|function
argument_list|)
expr_stmt|;
else|else
name|function
operator|=
name|default_conversion
argument_list|(
name|function
argument_list|)
expr_stmt|;
name|result
operator|=
name|build_nt
argument_list|(
name|CALL_EXPR
argument_list|,
name|function
argument_list|,
name|convert_arguments
argument_list|(
name|NULL_TREE
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|fntype
argument_list|)
argument_list|,
name|parmlist
argument_list|,
name|NULL_TREE
argument_list|,
name|LOOKUP_NORMAL
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|result
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|result
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_RAISES
argument_list|(
name|result
argument_list|)
operator|=
operator|!
operator|!
name|TYPE_RAISES_EXCEPTIONS
argument_list|(
name|fntype
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Call this when we know (for any reason) that expr is    not, in fact, zero.  */
end_comment

begin_function
name|tree
name|convert_pointer_to
parameter_list|(
name|binfo
parameter_list|,
name|expr
parameter_list|)
name|tree
name|binfo
decl_stmt|,
name|expr
decl_stmt|;
block|{
specifier|register
name|tree
name|intype
init|=
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
decl_stmt|;
name|tree
name|ptr_type
decl_stmt|;
name|tree
name|type
decl_stmt|,
name|rval
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|binfo
argument_list|)
operator|==
name|TREE_VEC
condition|)
name|type
operator|=
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|binfo
argument_list|)
condition|)
block|{
name|type
operator|=
name|binfo
expr_stmt|;
name|binfo
operator|=
name|TYPE_BINFO
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|type
operator|=
name|binfo
expr_stmt|;
name|binfo
operator|=
name|NULL_TREE
expr_stmt|;
block|}
name|ptr_type
operator|=
name|build_pointer_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr_type
operator|==
name|TYPE_MAIN_VARIANT
argument_list|(
name|intype
argument_list|)
condition|)
return|return
name|expr
return|;
if|if
condition|(
name|intype
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|my_friendly_assert
argument_list|(
operator|!
name|integer_zerop
argument_list|(
name|expr
argument_list|)
argument_list|,
literal|191
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|type
argument_list|)
operator|&&
name|IS_AGGR_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|intype
argument_list|)
argument_list|)
operator|&&
name|type
operator|!=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|intype
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|path
decl_stmt|;
name|int
name|distance
init|=
name|get_base_distance
argument_list|(
name|type
argument_list|,
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|intype
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|&
name|path
argument_list|)
decl_stmt|;
comment|/* This function shouldn't be called with unqualified arguments 	 but if it is, give them an error message that they can read. 	 */
if|if
condition|(
name|distance
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"cannot convert a pointer of type `%s'"
argument_list|,
name|TYPE_NAME_STRING
argument_list|(
name|TREE_TYPE
argument_list|(
name|intype
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|error_with_aggr_type
argument_list|(
name|type
argument_list|,
literal|"to a pointer of type `%s'"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
return|return
name|build_vbase_path
argument_list|(
name|PLUS_EXPR
argument_list|,
name|ptr_type
argument_list|,
name|expr
argument_list|,
name|path
argument_list|,
literal|1
argument_list|)
return|;
block|}
name|rval
operator|=
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|ptr_type
argument_list|,
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|NOP_EXPR
condition|?
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
else|:
name|expr
argument_list|)
expr_stmt|;
name|TREE_CONSTANT
argument_list|(
name|rval
argument_list|)
operator|=
name|TREE_CONSTANT
argument_list|(
name|expr
argument_list|)
expr_stmt|;
return|return
name|rval
return|;
block|}
end_function

begin_comment
comment|/* Same as above, but don't abort if we get an "ambiguous" baseclass.    There's only one virtual baseclass we are looking for, and once    we find one such virtual baseclass, we have found them all.  */
end_comment

begin_function
name|tree
name|convert_pointer_to_vbase
parameter_list|(
name|binfo
parameter_list|,
name|expr
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|tree
name|expr
decl_stmt|;
block|{
name|tree
name|intype
init|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|binfos
init|=
name|TYPE_BINFO_BASETYPES
argument_list|(
name|intype
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|TREE_VEC_LENGTH
argument_list|(
name|binfos
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|tree
name|basetype
init|=
name|BINFO_TYPE
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|binfos
argument_list|,
name|i
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
operator|==
name|basetype
condition|)
return|return
name|convert_pointer_to
argument_list|(
name|binfo
argument_list|,
name|expr
argument_list|)
return|;
if|if
condition|(
name|binfo_member
argument_list|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|,
name|CLASSTYPE_VBASECLASSES
argument_list|(
name|basetype
argument_list|)
argument_list|)
condition|)
return|return
name|convert_pointer_to_vbase
argument_list|(
name|binfo
argument_list|,
name|convert_pointer_to
argument_list|(
name|basetype
argument_list|,
name|expr
argument_list|)
argument_list|)
return|;
block|}
name|my_friendly_abort
argument_list|(
literal|6
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Create an expression whose value is that of EXPR,    converted to type TYPE.  The TREE_TYPE of the value    is always TYPE.  This function implements all reasonable    conversions; callers should filter out those that are    not permitted by the language being compiled.  */
end_comment

begin_function
name|tree
name|convert
parameter_list|(
name|type
parameter_list|,
name|expr
parameter_list|)
name|tree
name|type
decl_stmt|,
name|expr
decl_stmt|;
block|{
specifier|register
name|tree
name|e
init|=
name|expr
decl_stmt|;
specifier|register
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return
name|expr
return|;
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
condition|)
return|return
name|fold
argument_list|(
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|type
argument_list|,
name|expr
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return
name|error_mark_node
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|==
name|VOID_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"void value not ignored as it ought to be"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|code
operator|==
name|VOID_TYPE
condition|)
block|{
name|tree
name|rval
init|=
name|build_type_conversion
argument_list|(
name|NOP_EXPR
argument_list|,
name|type
argument_list|,
name|e
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/* If we can convert to void type via a type conversion, do so.  */
if|if
condition|(
name|rval
condition|)
return|return
name|rval
return|;
return|return
name|build1
argument_list|(
name|CONVERT_EXPR
argument_list|,
name|type
argument_list|,
name|e
argument_list|)
return|;
block|}
if|#
directive|if
literal|0
comment|/* This is incorrect.  A truncation can't be stripped this way.      Extensions will be stripped by the use of get_unwidened.  */
block|if (TREE_CODE (expr) == NOP_EXPR)     return convert (type, TREE_OPERAND (expr, 0));
endif|#
directive|endif
comment|/* Just convert to the type of the member.  */
if|if
condition|(
name|code
operator|==
name|OFFSET_TYPE
condition|)
block|{
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|code
operator|=
name|TREE_CODE
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
comment|/* C++ */
if|if
condition|(
name|code
operator|==
name|REFERENCE_TYPE
condition|)
return|return
name|fold
argument_list|(
name|convert_to_reference
argument_list|(
name|error_mark_node
argument_list|,
name|type
argument_list|,
name|e
argument_list|,
name|NULL_TREE
argument_list|,
operator|-
literal|1
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|-
literal|1
argument_list|,
name|LOOKUP_NORMAL
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|e
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|e
operator|=
name|convert_from_reference
argument_list|(
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|INTEGER_TYPE
operator|||
name|code
operator|==
name|ENUMERAL_TYPE
condition|)
return|return
name|fold
argument_list|(
name|convert_to_integer
argument_list|(
name|type
argument_list|,
name|e
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|code
operator|==
name|POINTER_TYPE
condition|)
return|return
name|fold
argument_list|(
name|convert_to_pointer
argument_list|(
name|type
argument_list|,
name|e
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|code
operator|==
name|REAL_TYPE
condition|)
return|return
name|fold
argument_list|(
name|convert_to_real
argument_list|(
name|type
argument_list|,
name|e
argument_list|)
argument_list|)
return|;
comment|/* New C++ semantics:  since assignment is now based on      memberwise copying,  if the rhs type is derived from the      lhs type, then we may still do a conversion.  */
if|if
condition|(
name|IS_AGGR_TYPE_CODE
argument_list|(
name|code
argument_list|)
condition|)
block|{
name|tree
name|dtype
init|=
name|TREE_TYPE
argument_list|(
name|e
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|dtype
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
block|{
name|e
operator|=
name|convert_from_reference
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|dtype
operator|=
name|TREE_TYPE
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
name|dtype
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|dtype
argument_list|)
expr_stmt|;
comment|/* Conversion between aggregate types.  New C++ semantics allow 	 objects of derived type to be cast to objects of base type. 	 Old semantics only allowed this between pointers.  	 There may be some ambiguity between using a constructor 	 vs. using a type conversion operator when both apply.  */
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|dtype
argument_list|)
condition|)
block|{
name|tree
name|binfo
decl_stmt|;
name|tree
name|conversion
init|=
name|TYPE_HAS_CONVERSION
argument_list|(
name|dtype
argument_list|)
condition|?
name|build_type_conversion
argument_list|(
name|CONVERT_EXPR
argument_list|,
name|type
argument_list|,
name|e
argument_list|,
literal|1
argument_list|)
else|:
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|tree
name|rval
init|=
name|build_method_call
argument_list|(
name|NULL_TREE
argument_list|,
name|constructor_name
argument_list|(
name|type
argument_list|)
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|e
argument_list|)
argument_list|,
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
argument_list|,
name|conversion
condition|?
name|LOOKUP_NO_CONVERSION
else|:
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|rval
operator|!=
name|error_mark_node
condition|)
block|{
if|if
condition|(
name|conversion
condition|)
block|{
name|error
argument_list|(
literal|"both constructor and type conversion operator apply"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* call to constructor successful.  */
name|rval
operator|=
name|build_cplus_new
argument_list|(
name|type
argument_list|,
name|rval
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|rval
return|;
block|}
block|}
comment|/* Type conversion successful/applies.  */
if|if
condition|(
name|conversion
condition|)
block|{
if|if
condition|(
name|conversion
operator|==
name|error_mark_node
condition|)
name|error
argument_list|(
literal|"ambiguous pointer conversion"
argument_list|)
expr_stmt|;
return|return
name|conversion
return|;
block|}
comment|/* now try normal C++ assignment semantics.  */
name|binfo
operator|=
name|TYPE_BINFO
argument_list|(
name|dtype
argument_list|)
expr_stmt|;
if|if
condition|(
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
operator|==
name|type
operator|||
operator|(
name|binfo
operator|=
name|get_binfo
argument_list|(
name|type
argument_list|,
name|dtype
argument_list|,
literal|1
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|binfo
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|binfo
operator|!=
name|NULL_TREE
condition|)
block|{
if|if
condition|(
name|lvalue_p
argument_list|(
name|e
argument_list|)
condition|)
block|{
name|e
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|e
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|BINFO_OFFSET_ZEROP
argument_list|(
name|binfo
argument_list|)
condition|)
name|e
operator|=
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TYPE_POINTER_TO
argument_list|(
name|type
argument_list|)
argument_list|,
name|e
argument_list|,
name|BINFO_OFFSET
argument_list|(
name|binfo
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|type
argument_list|,
name|e
argument_list|)
return|;
block|}
name|sorry
argument_list|(
literal|"addressable aggregates"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|error
argument_list|(
literal|"conversion between incompatible aggregate types requested"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* conversion from non-aggregate to aggregate type requires constructor.  */
elseif|else
if|if
condition|(
name|TYPE_HAS_CONSTRUCTOR
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|tree
name|rval
decl_stmt|;
name|tree
name|init
init|=
name|build_method_call
argument_list|(
name|NULL_TREE
argument_list|,
name|constructor_name
argument_list|(
name|type
argument_list|)
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|e
argument_list|)
argument_list|,
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
argument_list|,
name|LOOKUP_NORMAL
argument_list|)
decl_stmt|;
if|if
condition|(
name|init
operator|==
name|error_mark_node
condition|)
block|{
name|error_with_aggr_type
argument_list|(
name|type
argument_list|,
literal|"in conversion to type `%s'"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|rval
operator|=
name|build_cplus_new
argument_list|(
name|type
argument_list|,
name|init
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|rval
return|;
block|}
block|}
comment|/* If TYPE or TREE_TYPE (EXPR) is not on the permanent_obstack,      then the it won't be hashed and hence compare as not equal,      even when it is.  */
if|if
condition|(
name|code
operator|==
name|ARRAY_TYPE
operator|&&
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
operator|&&
name|index_type_equal
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|,
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
return|return
name|expr
return|;
name|error
argument_list|(
literal|"conversion to non-scalar type requested"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
end_function

begin_comment
comment|/* Like convert, except permit conversions to take place which    are not normally allowed due to visibility restrictions    (such as conversion from sub-type to private super-type).  */
end_comment

begin_function
name|tree
name|convert_force
parameter_list|(
name|type
parameter_list|,
name|expr
parameter_list|)
name|tree
name|type
decl_stmt|;
name|tree
name|expr
decl_stmt|;
block|{
specifier|register
name|tree
name|e
init|=
name|expr
decl_stmt|;
specifier|register
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|REFERENCE_TYPE
condition|)
return|return
name|fold
argument_list|(
name|convert_to_reference
argument_list|(
literal|0
argument_list|,
name|type
argument_list|,
name|e
argument_list|,
name|NULL_TREE
argument_list|,
operator|-
literal|1
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|e
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|e
operator|=
name|convert_from_reference
argument_list|(
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|POINTER_TYPE
condition|)
return|return
name|fold
argument_list|(
name|convert_to_pointer_force
argument_list|(
name|type
argument_list|,
name|e
argument_list|)
argument_list|)
return|;
block|{
name|int
name|old_equiv
init|=
name|flag_int_enum_equivalence
decl_stmt|;
name|flag_int_enum_equivalence
operator|=
literal|1
expr_stmt|;
name|e
operator|=
name|convert
argument_list|(
name|type
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|flag_int_enum_equivalence
operator|=
name|old_equiv
expr_stmt|;
block|}
return|return
name|e
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of build_type_conversion.  */
end_comment

begin_function
specifier|static
name|tree
name|build_type_conversion_1
parameter_list|(
name|xtype
parameter_list|,
name|basetype
parameter_list|,
name|expr
parameter_list|,
name|typename
parameter_list|,
name|for_sure
parameter_list|)
name|tree
name|xtype
decl_stmt|,
name|basetype
decl_stmt|;
name|tree
name|expr
decl_stmt|;
name|tree
name|typename
decl_stmt|;
name|int
name|for_sure
decl_stmt|;
block|{
name|tree
name|first_arg
init|=
name|expr
decl_stmt|;
name|tree
name|rval
decl_stmt|;
name|int
name|flags
decl_stmt|;
if|if
condition|(
name|for_sure
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|lvalue_p
argument_list|(
name|expr
argument_list|)
condition|)
name|first_arg
operator|=
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|TYPE_POINTER_TO
argument_list|(
name|basetype
argument_list|)
argument_list|,
name|integer_zero_node
argument_list|)
expr_stmt|;
name|flags
operator|=
name|LOOKUP_PROTECT
expr_stmt|;
block|}
else|else
name|flags
operator|=
name|LOOKUP_NORMAL
expr_stmt|;
name|rval
operator|=
name|build_method_call
argument_list|(
name|first_arg
argument_list|,
name|constructor_name
argument_list|(
name|typename
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
operator|==
name|error_mark_node
condition|)
block|{
if|if
condition|(
name|for_sure
operator|==
literal|0
condition|)
return|return
name|NULL_TREE
return|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
name|first_arg
operator|!=
name|expr
condition|)
block|{
name|expr
operator|=
name|build_up_reference
argument_list|(
name|build_reference_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|,
name|expr
argument_list|,
name|LOOKUP_COMPLAIN
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|TREE_VALUE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|rval
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|expr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|rval
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|xtype
argument_list|)
operator|!=
name|REFERENCE_TYPE
condition|)
name|rval
operator|=
name|default_conversion
argument_list|(
name|rval
argument_list|)
expr_stmt|;
if|if
condition|(
name|pedantic
operator|&&
name|TREE_TYPE
argument_list|(
name|xtype
argument_list|)
operator|&&
operator|(
name|TREE_READONLY
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|rval
argument_list|)
argument_list|)
argument_list|)
operator|>
name|TREE_READONLY
argument_list|(
name|TREE_TYPE
argument_list|(
name|xtype
argument_list|)
argument_list|)
operator|)
condition|)
name|pedwarn
argument_list|(
literal|"user-defined conversion casting away `const'"
argument_list|)
expr_stmt|;
return|return
name|convert
argument_list|(
name|xtype
argument_list|,
name|rval
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Convert an aggregate EXPR to type XTYPE.  If a conversion    exists, return the attempted conversion.  This may    return ERROR_MARK_NODE if the conversion is not    allowed (references private members, etc).    If no conversion exists, NULL_TREE is returned.     If (FOR_SURE& 1) is non-zero, then we allow this type conversion    to take place immediately.  Otherwise, we build a SAVE_EXPR    which can be evaluated if the results are ever needed.     If FOR_SURE>= 2, then we only look for exact conversions.     TYPE may be a reference type, in which case we first look    for something that will convert to a reference type.  If    that fails, we will try to look for something of the    reference's target type, and then return a reference to that.  */
end_comment

begin_function
name|tree
name|build_type_conversion
parameter_list|(
name|code
parameter_list|,
name|xtype
parameter_list|,
name|expr
parameter_list|,
name|for_sure
parameter_list|)
name|enum
name|tree_code
name|code
decl_stmt|;
name|tree
name|xtype
decl_stmt|,
name|expr
decl_stmt|;
name|int
name|for_sure
decl_stmt|;
block|{
comment|/* C++: check to see if we can convert this aggregate type      into the required scalar type.  */
name|tree
name|type
decl_stmt|,
name|type_default
decl_stmt|;
name|tree
name|typename
init|=
name|build_typename_overload
argument_list|(
name|xtype
argument_list|)
decl_stmt|,
modifier|*
name|typenames
decl_stmt|;
name|int
name|n_variants
init|=
literal|0
decl_stmt|;
name|tree
name|basetype
decl_stmt|,
name|save_basetype
decl_stmt|;
name|tree
name|rval
decl_stmt|;
name|int
name|exact_conversion
init|=
name|for_sure
operator|>=
literal|2
decl_stmt|;
name|for_sure
operator|&=
literal|1
expr_stmt|;
if|if
condition|(
name|expr
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|basetype
operator|=
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|basetype
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|basetype
operator|=
name|TREE_TYPE
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|basetype
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TYPE_LANG_SPECIFIC
argument_list|(
name|basetype
argument_list|)
operator|||
operator|!
name|TYPE_HAS_CONVERSION
argument_list|(
name|basetype
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|xtype
argument_list|)
operator|==
name|POINTER_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|xtype
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
block|{
comment|/* Prepare to match a variant of this type.  */
name|type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|xtype
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|n_variants
operator|=
literal|0
init|;
name|type
condition|;
name|type
operator|=
name|TYPE_NEXT_VARIANT
argument_list|(
name|type
argument_list|)
control|)
name|n_variants
operator|++
expr_stmt|;
name|typenames
operator|=
operator|(
name|tree
operator|*
operator|)
name|alloca
argument_list|(
name|n_variants
operator|*
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|n_variants
operator|=
literal|0
operator|,
name|type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|xtype
argument_list|)
argument_list|)
init|;
name|type
condition|;
name|n_variants
operator|++
operator|,
name|type
operator|=
name|TYPE_NEXT_VARIANT
argument_list|(
name|type
argument_list|)
control|)
block|{
if|if
condition|(
name|type
operator|==
name|TREE_TYPE
argument_list|(
name|xtype
argument_list|)
condition|)
name|typenames
index|[
name|n_variants
index|]
operator|=
name|typename
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|xtype
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
name|typenames
index|[
name|n_variants
index|]
operator|=
name|build_typename_overload
argument_list|(
name|build_pointer_type
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|typenames
index|[
name|n_variants
index|]
operator|=
name|build_typename_overload
argument_list|(
name|build_reference_type
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|save_basetype
operator|=
name|basetype
expr_stmt|;
name|type
operator|=
name|xtype
expr_stmt|;
while|while
condition|(
name|TYPE_HAS_CONVERSION
argument_list|(
name|basetype
argument_list|)
condition|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|lookup_fnfields
argument_list|(
name|TYPE_BINFO
argument_list|(
name|basetype
argument_list|)
argument_list|,
name|typename
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|build_type_conversion_1
argument_list|(
name|xtype
argument_list|,
name|basetype
argument_list|,
name|expr
argument_list|,
name|typename
argument_list|,
name|for_sure
argument_list|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_variants
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|typenames
index|[
name|i
index|]
operator|!=
name|typename
operator|&&
name|lookup_fnfields
argument_list|(
name|TYPE_BINFO
argument_list|(
name|basetype
argument_list|)
argument_list|,
name|typenames
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|build_type_conversion_1
argument_list|(
name|xtype
argument_list|,
name|basetype
argument_list|,
name|expr
argument_list|,
name|typenames
index|[
name|i
index|]
argument_list|,
name|for_sure
argument_list|)
return|;
if|if
condition|(
name|TYPE_BINFO_BASETYPES
argument_list|(
name|basetype
argument_list|)
condition|)
name|basetype
operator|=
name|TYPE_BINFO_BASETYPE
argument_list|(
name|basetype
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
break|break;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
block|{
name|tree
name|first_arg
init|=
name|expr
decl_stmt|;
name|type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|basetype
operator|=
name|save_basetype
expr_stmt|;
comment|/* May need to build a temporary for this.  */
while|while
condition|(
name|TYPE_HAS_CONVERSION
argument_list|(
name|basetype
argument_list|)
condition|)
block|{
if|if
condition|(
name|lookup_fnfields
argument_list|(
name|TYPE_BINFO
argument_list|(
name|basetype
argument_list|)
argument_list|,
name|typename
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|int
name|flags
decl_stmt|;
if|if
condition|(
name|for_sure
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|lvalue_p
argument_list|(
name|expr
argument_list|)
condition|)
name|first_arg
operator|=
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|TYPE_POINTER_TO
argument_list|(
name|basetype
argument_list|)
argument_list|,
name|integer_zero_node
argument_list|)
expr_stmt|;
name|flags
operator|=
name|LOOKUP_PROTECT
expr_stmt|;
block|}
else|else
name|flags
operator|=
name|LOOKUP_NORMAL
expr_stmt|;
name|rval
operator|=
name|build_method_call
argument_list|(
name|first_arg
argument_list|,
name|constructor_name
argument_list|(
name|typename
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
operator|==
name|error_mark_node
condition|)
block|{
if|if
condition|(
name|for_sure
operator|==
literal|0
condition|)
return|return
name|NULL_TREE
return|;
return|return
name|error_mark_node
return|;
block|}
name|TREE_VALUE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|rval
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|=
name|expr
expr_stmt|;
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|tree
name|init
init|=
name|build_method_call
argument_list|(
name|NULL_TREE
argument_list|,
name|constructor_name
argument_list|(
name|type
argument_list|)
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|rval
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
name|LOOKUP_NORMAL
argument_list|)
decl_stmt|;
name|tree
name|temp
init|=
name|build_cplus_new
argument_list|(
name|type
argument_list|,
name|init
argument_list|,
literal|1
argument_list|)
decl_stmt|;
return|return
name|build_up_reference
argument_list|(
name|TYPE_REFERENCE_TO
argument_list|(
name|type
argument_list|)
argument_list|,
name|temp
argument_list|,
name|LOOKUP_COMPLAIN
argument_list|,
literal|1
argument_list|)
return|;
block|}
return|return
name|convert
argument_list|(
name|xtype
argument_list|,
name|rval
argument_list|)
return|;
block|}
if|if
condition|(
name|TYPE_BINFO_BASETYPES
argument_list|(
name|basetype
argument_list|)
condition|)
name|basetype
operator|=
name|TYPE_BINFO_BASETYPE
argument_list|(
name|basetype
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
break|break;
block|}
comment|/* No free conversions for reference types, right?.  */
return|return
name|NULL_TREE
return|;
block|}
if|if
condition|(
name|exact_conversion
condition|)
return|return
name|NULL_TREE
return|;
comment|/* No perfect match found, try default.  */
if|if
condition|(
name|code
operator|==
name|CONVERT_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
name|type_default
operator|=
name|ptr_type_node
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
name|void_type_node
condition|)
return|return
name|NULL_TREE
return|;
else|else
block|{
specifier|extern
name|tree
name|default_conversion
parameter_list|()
function_decl|;
name|tree
name|tmp
init|=
name|default_conversion
argument_list|(
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|type
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|tmp
operator|==
name|error_mark_node
condition|)
return|return
name|NULL_TREE
return|;
name|type_default
operator|=
name|TREE_TYPE
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
name|basetype
operator|=
name|save_basetype
expr_stmt|;
if|if
condition|(
name|type_default
operator|!=
name|type
condition|)
block|{
name|type
operator|=
name|type_default
expr_stmt|;
name|typename
operator|=
name|build_typename_overload
argument_list|(
name|type
argument_list|)
expr_stmt|;
while|while
condition|(
name|TYPE_HAS_CONVERSION
argument_list|(
name|basetype
argument_list|)
condition|)
block|{
if|if
condition|(
name|lookup_fnfields
argument_list|(
name|TYPE_BINFO
argument_list|(
name|basetype
argument_list|)
argument_list|,
name|typename
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|build_type_conversion_1
argument_list|(
name|xtype
argument_list|,
name|basetype
argument_list|,
name|expr
argument_list|,
name|typename
argument_list|,
name|for_sure
argument_list|)
return|;
if|if
condition|(
name|TYPE_BINFO_BASETYPES
argument_list|(
name|basetype
argument_list|)
condition|)
name|basetype
operator|=
name|TYPE_BINFO_BASETYPE
argument_list|(
name|basetype
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
break|break;
block|}
block|}
name|try_pointer
label|:
if|if
condition|(
name|type
operator|==
name|ptr_type_node
condition|)
block|{
comment|/* Try converting to some other pointer type 	 with which void* is compatible, or in situations 	 in which void* is appropriate (such as&&,||, and !).  */
while|while
condition|(
name|TYPE_HAS_CONVERSION
argument_list|(
name|basetype
argument_list|)
condition|)
block|{
if|if
condition|(
name|CLASSTYPE_CONVERSION
argument_list|(
name|basetype
argument_list|,
name|ptr_conv
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|CLASSTYPE_CONVERSION
argument_list|(
name|basetype
argument_list|,
name|ptr_conv
argument_list|)
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|typename
operator|=
name|DECL_NAME
argument_list|(
name|CLASSTYPE_CONVERSION
argument_list|(
name|basetype
argument_list|,
name|ptr_conv
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|build_type_conversion_1
argument_list|(
name|xtype
argument_list|,
name|basetype
argument_list|,
name|expr
argument_list|,
name|typename
argument_list|,
name|for_sure
argument_list|)
return|;
block|}
if|if
condition|(
name|TYPE_BINFO_BASETYPES
argument_list|(
name|basetype
argument_list|)
condition|)
name|basetype
operator|=
name|TYPE_BINFO_BASETYPE
argument_list|(
name|basetype
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
break|break;
block|}
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|TYPE_READONLY
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|&&
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|void_type_node
condition|)
block|{
comment|/* Try converting to some other pointer type 	 with which const void* is compatible.  */
while|while
condition|(
name|TYPE_HAS_CONVERSION
argument_list|(
name|basetype
argument_list|)
condition|)
block|{
if|if
condition|(
name|CLASSTYPE_CONVERSION
argument_list|(
name|basetype
argument_list|,
name|constptr_conv
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|CLASSTYPE_CONVERSION
argument_list|(
name|basetype
argument_list|,
name|constptr_conv
argument_list|)
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|typename
operator|=
name|DECL_NAME
argument_list|(
name|CLASSTYPE_CONVERSION
argument_list|(
name|basetype
argument_list|,
name|constptr_conv
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|build_type_conversion_1
argument_list|(
name|xtype
argument_list|,
name|basetype
argument_list|,
name|expr
argument_list|,
name|typename
argument_list|,
name|for_sure
argument_list|)
return|;
block|}
if|if
condition|(
name|TYPE_BINFO_BASETYPES
argument_list|(
name|basetype
argument_list|)
condition|)
name|basetype
operator|=
name|TYPE_BINFO_BASETYPE
argument_list|(
name|basetype
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
break|break;
block|}
block|}
comment|/* Use the longer or shorter conversion that is appropriate.  Have      to check against 0 because the conversion may come from a baseclass.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|TYPE_HAS_INT_CONVERSION
argument_list|(
name|basetype
argument_list|)
operator|&&
name|CLASSTYPE_CONVERSION
argument_list|(
name|basetype
argument_list|,
name|int_conv
argument_list|)
operator|!=
literal|0
operator|&&
name|CLASSTYPE_CONVERSION
argument_list|(
name|basetype
argument_list|,
name|int_conv
argument_list|)
operator|!=
name|error_mark_node
condition|)
block|{
name|typename
operator|=
name|DECL_NAME
argument_list|(
name|CLASSTYPE_CONVERSION
argument_list|(
name|basetype
argument_list|,
name|int_conv
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|build_type_conversion_1
argument_list|(
name|xtype
argument_list|,
name|basetype
argument_list|,
name|expr
argument_list|,
name|typename
argument_list|,
name|for_sure
argument_list|)
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REAL_TYPE
operator|&&
name|TYPE_HAS_REAL_CONVERSION
argument_list|(
name|basetype
argument_list|)
operator|&&
name|CLASSTYPE_CONVERSION
argument_list|(
name|basetype
argument_list|,
name|real_conv
argument_list|)
operator|!=
literal|0
operator|&&
name|CLASSTYPE_CONVERSION
argument_list|(
name|basetype
argument_list|,
name|real_conv
argument_list|)
operator|!=
name|error_mark_node
condition|)
block|{
name|typename
operator|=
name|DECL_NAME
argument_list|(
name|CLASSTYPE_CONVERSION
argument_list|(
name|basetype
argument_list|,
name|real_conv
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|build_type_conversion_1
argument_list|(
name|xtype
argument_list|,
name|basetype
argument_list|,
name|expr
argument_list|,
name|typename
argument_list|,
name|for_sure
argument_list|)
return|;
block|}
comment|/* THIS IS A KLUDGE.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|POINTER_TYPE
operator|&&
operator|(
name|code
operator|==
name|TRUTH_ANDIF_EXPR
operator|||
name|code
operator|==
name|TRUTH_ORIF_EXPR
operator|||
name|code
operator|==
name|TRUTH_NOT_EXPR
operator|)
condition|)
block|{
comment|/* Here's when we can convert to a pointer.  */
name|type
operator|=
name|ptr_type_node
expr_stmt|;
goto|goto
name|try_pointer
goto|;
block|}
comment|/* THESE ARE TOTAL KLUDGES.  */
comment|/* Default promotion yields no new alternatives, try      conversions which are anti-default, such as       double -> float or int -> unsigned or unsigned -> long       */
if|if
condition|(
name|type_default
operator|==
name|type
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|INTEGER_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REAL_TYPE
operator|)
condition|)
block|{
name|int
name|not_again
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|double_type_node
condition|)
name|typename
operator|=
name|build_typename_overload
argument_list|(
name|float_type_node
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
name|integer_type_node
condition|)
name|typename
operator|=
name|build_typename_overload
argument_list|(
name|unsigned_type_node
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
name|unsigned_type_node
condition|)
name|typename
operator|=
name|build_typename_overload
argument_list|(
name|long_integer_type_node
argument_list|)
expr_stmt|;
name|again
label|:
name|basetype
operator|=
name|save_basetype
expr_stmt|;
while|while
condition|(
name|TYPE_HAS_CONVERSION
argument_list|(
name|basetype
argument_list|)
condition|)
block|{
if|if
condition|(
name|lookup_fnfields
argument_list|(
name|TYPE_BINFO
argument_list|(
name|basetype
argument_list|)
argument_list|,
name|typename
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|build_type_conversion_1
argument_list|(
name|xtype
argument_list|,
name|basetype
argument_list|,
name|expr
argument_list|,
name|typename
argument_list|,
name|for_sure
argument_list|)
return|;
if|if
condition|(
name|TYPE_BINFO_BASETYPES
argument_list|(
name|basetype
argument_list|)
condition|)
name|basetype
operator|=
name|TYPE_BINFO_BASETYPE
argument_list|(
name|basetype
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
break|break;
block|}
if|if
condition|(
operator|!
name|not_again
condition|)
block|{
if|if
condition|(
name|type
operator|==
name|integer_type_node
condition|)
block|{
name|typename
operator|=
name|build_typename_overload
argument_list|(
name|long_integer_type_node
argument_list|)
expr_stmt|;
name|not_again
operator|=
literal|1
expr_stmt|;
goto|goto
name|again
goto|;
block|}
else|else
block|{
name|typename
operator|=
name|build_typename_overload
argument_list|(
name|integer_type_node
argument_list|)
expr_stmt|;
name|not_again
operator|=
literal|1
expr_stmt|;
goto|goto
name|again
goto|;
block|}
block|}
block|}
comment|/* Now, try C promotions...       float -> int      int -> float, void *      void * -> int       Truthvalue conversions let us try to convert      to pointer if we were going for int, and to int      if we were looking for pointer.  */
name|basetype
operator|=
name|save_basetype
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REAL_TYPE
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
operator|(
name|code
operator|==
name|TRUTH_ANDIF_EXPR
operator|||
name|code
operator|==
name|TRUTH_ORIF_EXPR
operator|||
name|code
operator|==
name|TRUTH_NOT_EXPR
operator|)
operator|)
condition|)
name|type
operator|=
name|integer_type_node
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|INTEGER_TYPE
condition|)
if|if
condition|(
name|TYPE_HAS_REAL_CONVERSION
argument_list|(
name|basetype
argument_list|)
condition|)
name|type
operator|=
name|double_type_node
expr_stmt|;
else|else
return|return
name|NULL_TREE
return|;
else|else
return|return
name|NULL_TREE
return|;
name|typename
operator|=
name|build_typename_overload
argument_list|(
name|type
argument_list|)
expr_stmt|;
while|while
condition|(
name|TYPE_HAS_CONVERSION
argument_list|(
name|basetype
argument_list|)
condition|)
block|{
if|if
condition|(
name|lookup_fnfields
argument_list|(
name|TYPE_BINFO
argument_list|(
name|basetype
argument_list|)
argument_list|,
name|typename
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|rval
operator|=
name|build_type_conversion_1
argument_list|(
name|xtype
argument_list|,
name|basetype
argument_list|,
name|expr
argument_list|,
name|typename
argument_list|,
name|for_sure
argument_list|)
expr_stmt|;
return|return
name|rval
return|;
block|}
if|if
condition|(
name|TYPE_BINFO_BASETYPES
argument_list|(
name|basetype
argument_list|)
condition|)
name|basetype
operator|=
name|TYPE_BINFO_BASETYPE
argument_list|(
name|basetype
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
break|break;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Must convert two aggregate types to non-aggregate type.    Attempts to find a non-ambiguous, "best" type conversion.     Return 1 on success, 0 on failure.     @@ What are the real semantics of this supposed to be??? */
end_comment

begin_function
name|int
name|build_default_binary_type_conversion
parameter_list|(
name|code
parameter_list|,
name|arg1
parameter_list|,
name|arg2
parameter_list|)
name|enum
name|tree_code
name|code
decl_stmt|;
name|tree
modifier|*
name|arg1
decl_stmt|,
decl|*
name|arg2
decl_stmt|;
end_function

begin_block
block|{
name|tree
name|type1
init|=
name|TREE_TYPE
argument_list|(
operator|*
name|arg1
argument_list|)
decl_stmt|;
name|tree
name|type2
init|=
name|TREE_TYPE
argument_list|(
operator|*
name|arg2
argument_list|)
decl_stmt|;
name|char
modifier|*
name|name1
decl_stmt|,
modifier|*
name|name2
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type1
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|type1
operator|=
name|TREE_TYPE
argument_list|(
name|type1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type2
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
name|type2
operator|=
name|TREE_TYPE
argument_list|(
name|type2
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|type1
argument_list|)
argument_list|)
operator|!=
name|TYPE_DECL
condition|)
block|{
name|tree
name|decl
init|=
name|typedecl_for_tag
argument_list|(
name|type1
argument_list|)
decl_stmt|;
if|if
condition|(
name|decl
condition|)
name|error
argument_list|(
literal|"type conversion nonexistent for type `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"type conversion nonexistent for non-C++ type"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|type2
argument_list|)
argument_list|)
operator|!=
name|TYPE_DECL
condition|)
block|{
name|tree
name|decl
init|=
name|typedecl_for_tag
argument_list|(
name|type2
argument_list|)
decl_stmt|;
if|if
condition|(
name|decl
condition|)
name|error
argument_list|(
literal|"type conversion nonexistent for type `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"type conversion nonexistent for non-C++ type"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|name1
operator|=
name|TYPE_NAME_STRING
argument_list|(
name|type1
argument_list|)
expr_stmt|;
name|name2
operator|=
name|TYPE_NAME_STRING
argument_list|(
name|type2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|IS_AGGR_TYPE
argument_list|(
name|type1
argument_list|)
operator|||
operator|!
name|TYPE_HAS_CONVERSION
argument_list|(
name|type1
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|IS_AGGR_TYPE
argument_list|(
name|type2
argument_list|)
operator|||
operator|!
name|TYPE_HAS_CONVERSION
argument_list|(
name|type2
argument_list|)
condition|)
name|error
argument_list|(
literal|"type conversion required for binary operation on types `%s' and `%s'"
argument_list|,
name|name1
argument_list|,
name|name2
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"type conversion required for type `%s'"
argument_list|,
name|name1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|IS_AGGR_TYPE
argument_list|(
name|type2
argument_list|)
operator|||
operator|!
name|TYPE_HAS_CONVERSION
argument_list|(
name|type2
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"type conversion required for type `%s'"
argument_list|,
name|name2
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|TYPE_HAS_INT_CONVERSION
argument_list|(
name|type1
argument_list|)
operator|&&
name|TYPE_HAS_REAL_CONVERSION
argument_list|(
name|type1
argument_list|)
condition|)
name|warning
argument_list|(
literal|"ambiguous type conversion for type `%s', defaulting to int"
argument_list|,
name|name1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_HAS_INT_CONVERSION
argument_list|(
name|type1
argument_list|)
condition|)
block|{
operator|*
name|arg1
operator|=
name|build_type_conversion
argument_list|(
name|code
argument_list|,
name|integer_type_node
argument_list|,
operator|*
name|arg1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|*
name|arg2
operator|=
name|build_type_conversion
argument_list|(
name|code
argument_list|,
name|integer_type_node
argument_list|,
operator|*
name|arg2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TYPE_HAS_REAL_CONVERSION
argument_list|(
name|type1
argument_list|)
condition|)
block|{
operator|*
name|arg1
operator|=
name|build_type_conversion
argument_list|(
name|code
argument_list|,
name|double_type_node
argument_list|,
operator|*
name|arg1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|*
name|arg2
operator|=
name|build_type_conversion
argument_list|(
name|code
argument_list|,
name|double_type_node
argument_list|,
operator|*
name|arg2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|arg1
operator|=
name|build_type_conversion
argument_list|(
name|code
argument_list|,
name|ptr_type_node
argument_list|,
operator|*
name|arg1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|arg1
operator|==
name|error_mark_node
condition|)
name|error
argument_list|(
literal|"ambiguous pointer conversion"
argument_list|)
expr_stmt|;
operator|*
name|arg2
operator|=
name|build_type_conversion
argument_list|(
name|code
argument_list|,
name|ptr_type_node
argument_list|,
operator|*
name|arg2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|arg1
operator|!=
name|error_mark_node
operator|&&
operator|*
name|arg2
operator|==
name|error_mark_node
condition|)
name|error
argument_list|(
literal|"ambiguous pointer conversion"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|arg1
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|*
name|arg2
operator|==
literal|0
operator|&&
name|type1
operator|!=
name|type2
condition|)
name|error
argument_list|(
literal|"default type conversion for types `%s' and `%s' failed"
argument_list|,
name|name1
argument_list|,
name|name2
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"default type conversion for type `%s' failed"
argument_list|,
name|name1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
operator|*
name|arg2
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"default type conversion for type `%s' failed"
argument_list|,
name|name2
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_block

begin_comment
comment|/* Must convert two aggregate types to non-aggregate type.    Attempts to find a non-ambiguous, "best" type conversion.     Return 1 on success, 0 on failure.     The type of the argument is expected to be of aggregate type here.     @@ What are the real semantics of this supposed to be??? */
end_comment

begin_function
name|int
name|build_default_unary_type_conversion
parameter_list|(
name|code
parameter_list|,
name|arg
parameter_list|)
name|enum
name|tree_code
name|code
decl_stmt|;
name|tree
modifier|*
name|arg
decl_stmt|;
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
operator|*
name|arg
argument_list|)
decl_stmt|;
name|tree
name|id
init|=
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
condition|?
name|TYPE_IDENTIFIER
argument_list|(
name|type
argument_list|)
else|:
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|char
modifier|*
name|name
init|=
name|IDENTIFIER_POINTER
argument_list|(
name|id
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|TYPE_HAS_CONVERSION
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"type conversion required for type `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|TYPE_HAS_INT_CONVERSION
argument_list|(
name|type
argument_list|)
operator|&&
name|TYPE_HAS_REAL_CONVERSION
argument_list|(
name|type
argument_list|)
condition|)
name|warning
argument_list|(
literal|"ambiguous type conversion for type `%s', defaulting to int"
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_HAS_INT_CONVERSION
argument_list|(
name|type
argument_list|)
condition|)
operator|*
name|arg
operator|=
name|build_type_conversion
argument_list|(
name|code
argument_list|,
name|integer_type_node
argument_list|,
operator|*
name|arg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TYPE_HAS_REAL_CONVERSION
argument_list|(
name|type
argument_list|)
condition|)
operator|*
name|arg
operator|=
name|build_type_conversion
argument_list|(
name|code
argument_list|,
name|double_type_node
argument_list|,
operator|*
name|arg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
block|{
operator|*
name|arg
operator|=
name|build_type_conversion
argument_list|(
name|code
argument_list|,
name|ptr_type_node
argument_list|,
operator|*
name|arg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|arg
operator|==
name|error_mark_node
condition|)
name|error
argument_list|(
literal|"ambiguous pointer conversion"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|arg
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"default type conversion for type `%s' failed"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

end_unit

