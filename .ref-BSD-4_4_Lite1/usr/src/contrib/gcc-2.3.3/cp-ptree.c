begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Prints out tree in human readable form - GNU C++ compiler    Copyright (C) 1992 Free Software Foundation, Inc.    Hacked by Michael Tiemann (tiemann@cygnus.com)  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"cp-tree.h"
end_include

begin_function
name|void
name|print_lang_decl
parameter_list|(
name|file
parameter_list|,
name|node
parameter_list|,
name|indent
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|tree
name|node
decl_stmt|;
name|int
name|indent
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|DECL_LANG_SPECIFIC
argument_list|(
name|node
argument_list|)
condition|)
return|return;
comment|/* A FIELD_DECL only has the flags structure, which we aren't displaying      anyways.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|node
argument_list|)
operator|==
name|FIELD_DECL
condition|)
return|return;
name|indent_to
argument_list|(
name|file
argument_list|,
name|indent
operator|+
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_MAIN_VARIANT
argument_list|(
name|node
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" decl-main-variant "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_PTR_PRINTF
argument_list|,
name|DECL_MAIN_VARIANT
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|DECL_PENDING_INLINE_INFO
argument_list|(
name|node
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" pending-inline-info "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_PTR_PRINTF
argument_list|,
name|DECL_PENDING_INLINE_INFO
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|DECL_TEMPLATE_INFO
argument_list|(
name|node
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" template-info "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_PTR_PRINTF
argument_list|,
name|DECL_TEMPLATE_INFO
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|print_lang_type
parameter_list|(
name|file
parameter_list|,
name|node
parameter_list|,
name|indent
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
specifier|register
name|tree
name|node
decl_stmt|;
name|int
name|indent
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|node
argument_list|)
operator|==
name|TEMPLATE_TYPE_PARM
condition|)
block|{
name|print_node
argument_list|(
name|file
argument_list|,
literal|"tinfo"
argument_list|,
name|TYPE_VALUES
argument_list|(
name|node
argument_list|)
argument_list|,
name|indent
operator|+
literal|4
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|node
argument_list|)
operator|==
name|UNINSTANTIATED_P_TYPE
condition|)
block|{
name|print_node
argument_list|(
name|file
argument_list|,
literal|"template"
argument_list|,
name|UPT_TEMPLATE
argument_list|(
name|node
argument_list|)
argument_list|,
name|indent
operator|+
literal|4
argument_list|)
expr_stmt|;
name|print_node
argument_list|(
name|file
argument_list|,
literal|"parameters"
argument_list|,
name|UPT_PARMS
argument_list|(
name|node
argument_list|)
argument_list|,
name|indent
operator|+
literal|4
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|node
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|node
argument_list|)
operator|==
name|UNION_TYPE
operator|)
condition|)
return|return;
if|if
condition|(
operator|!
name|TYPE_LANG_SPECIFIC
argument_list|(
name|node
argument_list|)
condition|)
return|return;
name|indent_to
argument_list|(
name|file
argument_list|,
name|indent
operator|+
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_NEEDS_CONSTRUCTOR
argument_list|(
name|node
argument_list|)
condition|)
name|fputs
argument_list|(
literal|"needs-constructor"
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|node
argument_list|)
condition|)
name|fputs
argument_list|(
literal|" needs-destructor"
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_HAS_CONVERSION
argument_list|(
name|node
argument_list|)
condition|)
name|fputs
argument_list|(
literal|" has-type-conversion"
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_HAS_INT_CONVERSION
argument_list|(
name|node
argument_list|)
condition|)
name|fputs
argument_list|(
literal|" has-int-conversion"
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_HAS_REAL_CONVERSION
argument_list|(
name|node
argument_list|)
condition|)
name|fputs
argument_list|(
literal|" has-float-conversion"
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_HAS_INIT_REF
argument_list|(
name|node
argument_list|)
condition|)
name|fputs
argument_list|(
literal|" X(X&)"
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_GETS_NEW
argument_list|(
name|node
argument_list|)
condition|)
name|fputs
argument_list|(
literal|" gets-new"
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_GETS_DELETE
argument_list|(
name|node
argument_list|)
condition|)
name|fputs
argument_list|(
literal|" gets-delete"
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_HAS_ASSIGNMENT
argument_list|(
name|node
argument_list|)
condition|)
name|fputs
argument_list|(
literal|" has="
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_GETS_ASSIGNMENT
argument_list|(
name|node
argument_list|)
condition|)
name|fputs
argument_list|(
literal|" gets="
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_HAS_ASSIGN_REF
argument_list|(
name|node
argument_list|)
condition|)
name|fputs
argument_list|(
literal|" this=(X&)"
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_GETS_ASSIGN_REF
argument_list|(
name|node
argument_list|)
condition|)
name|fputs
argument_list|(
literal|" gets=(X&)"
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_OVERLOADS_METHOD_CALL_EXPR
argument_list|(
name|node
argument_list|)
condition|)
name|fputs
argument_list|(
literal|" op->()"
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_GETS_INIT_AGGR
argument_list|(
name|node
argument_list|)
condition|)
name|fputs
argument_list|(
literal|" gets X(X, ...)"
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_OVERLOADS_CALL_EXPR
argument_list|(
name|node
argument_list|)
condition|)
name|fputs
argument_list|(
literal|" op()"
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_OVERLOADS_ARRAY_REF
argument_list|(
name|node
argument_list|)
condition|)
name|fputs
argument_list|(
literal|" op[]"
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_OVERLOADS_ARROW
argument_list|(
name|node
argument_list|)
condition|)
name|fputs
argument_list|(
literal|" op->"
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_USES_MULTIPLE_INHERITANCE
argument_list|(
name|node
argument_list|)
condition|)
name|fputs
argument_list|(
literal|" uses-multiple-inheritance"
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|node
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" n_parents %d n_ancestors %d"
argument_list|,
name|CLASSTYPE_N_BASECLASSES
argument_list|(
name|node
argument_list|)
argument_list|,
name|CLASSTYPE_N_SUPERCLASSES
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" use_template=%d"
argument_list|,
name|CLASSTYPE_USE_TEMPLATE
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|CLASSTYPE_INTERFACE_ONLY
argument_list|(
name|node
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" interface-only"
argument_list|)
expr_stmt|;
if|if
condition|(
name|CLASSTYPE_INTERFACE_UNKNOWN
argument_list|(
name|node
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" interface-unknown"
argument_list|)
expr_stmt|;
name|print_node
argument_list|(
name|file
argument_list|,
literal|"member-functions"
argument_list|,
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|node
argument_list|)
argument_list|,
name|indent
operator|+
literal|4
argument_list|)
expr_stmt|;
name|print_node
argument_list|(
name|file
argument_list|,
literal|"baselinks"
argument_list|,
name|TYPE_BINFO_BASETYPES
argument_list|(
name|node
argument_list|)
condition|?
name|CLASSTYPE_BASELINK_VEC
argument_list|(
name|node
argument_list|)
else|:
name|NULL_TREE
argument_list|,
name|indent
operator|+
literal|4
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|print_lang_identifier
parameter_list|(
name|file
parameter_list|,
name|node
parameter_list|,
name|indent
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|tree
name|node
decl_stmt|;
name|int
name|indent
decl_stmt|;
block|{
name|print_node
argument_list|(
name|file
argument_list|,
literal|"global"
argument_list|,
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|node
argument_list|)
argument_list|,
name|indent
operator|+
literal|4
argument_list|)
expr_stmt|;
name|print_node
argument_list|(
name|file
argument_list|,
literal|"class"
argument_list|,
name|IDENTIFIER_CLASS_VALUE
argument_list|(
name|node
argument_list|)
argument_list|,
name|indent
operator|+
literal|4
argument_list|)
expr_stmt|;
name|print_node
argument_list|(
name|file
argument_list|,
literal|"local"
argument_list|,
name|IDENTIFIER_LOCAL_VALUE
argument_list|(
name|node
argument_list|)
argument_list|,
name|indent
operator|+
literal|4
argument_list|)
expr_stmt|;
name|print_node
argument_list|(
name|file
argument_list|,
literal|"label"
argument_list|,
name|IDENTIFIER_LABEL_VALUE
argument_list|(
name|node
argument_list|)
argument_list|,
name|indent
operator|+
literal|4
argument_list|)
expr_stmt|;
name|print_node
argument_list|(
name|file
argument_list|,
literal|"template"
argument_list|,
name|IDENTIFIER_TEMPLATE
argument_list|(
name|node
argument_list|)
argument_list|,
name|indent
operator|+
literal|4
argument_list|)
expr_stmt|;
name|print_node
argument_list|(
name|file
argument_list|,
literal|"implicit"
argument_list|,
name|IDENTIFIER_IMPLICIT_DECL
argument_list|(
name|node
argument_list|)
argument_list|,
name|indent
operator|+
literal|4
argument_list|)
expr_stmt|;
name|print_node
argument_list|(
name|file
argument_list|,
literal|"error locus"
argument_list|,
name|IDENTIFIER_ERROR_LOCUS
argument_list|(
name|node
argument_list|)
argument_list|,
name|indent
operator|+
literal|4
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

