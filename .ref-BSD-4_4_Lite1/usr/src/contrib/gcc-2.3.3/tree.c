begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Language-independent node constructors for parse phase of GNU compiler.    Copyright (C) 1987, 1988, 1992 Free Software Foundation, Inc.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* This file contains the low level primitives for operating on tree nodes,    including allocation, list operations, interning of identifiers,    construction of data type nodes and statement nodes,    and construction of type conversion nodes.  It also contains    tables index by tree code that describe how to take apart    nodes of that code.     It is intended to be language-independent, but occasionally    calls language-dependent routines defined (for C) in typecheck.c.     The low-level allocation routines oballoc and permalloc    are used also for allocating many other kinds of objects    by all passes of the compiler.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"gvarargs.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_define
define|#
directive|define
name|obstack_chunk_alloc
value|xmalloc
end_define

begin_define
define|#
directive|define
name|obstack_chunk_free
value|free
end_define

begin_comment
comment|/* Tree nodes of permanent duration are allocated in this obstack.    They are the identifier nodes, and everything outside of    the bodies and parameters of function definitions.  */
end_comment

begin_decl_stmt
name|struct
name|obstack
name|permanent_obstack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The initial RTL, and all ..._TYPE nodes, in a function    are allocated in this obstack.  Usually they are freed at the    end of the function, but if the function is inline they are saved.    For top-level functions, this is maybepermanent_obstack.    Separate obstacks are made for nested functions.  */
end_comment

begin_decl_stmt
name|struct
name|obstack
modifier|*
name|function_maybepermanent_obstack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is the function_maybepermanent_obstack for top-level functions.  */
end_comment

begin_decl_stmt
name|struct
name|obstack
name|maybepermanent_obstack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The contents of the current function definition are allocated    in this obstack, and all are freed at the end of the function.    For top-level functions, this is temporary_obstack.    Separate obstacks are made for nested functions.  */
end_comment

begin_decl_stmt
name|struct
name|obstack
modifier|*
name|function_obstack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is used for reading initializers of global variables.  */
end_comment

begin_decl_stmt
name|struct
name|obstack
name|temporary_obstack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The tree nodes of an expression are allocated    in this obstack, and all are freed at the end of the expression.  */
end_comment

begin_decl_stmt
name|struct
name|obstack
name|momentary_obstack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The tree nodes of a declarator are allocated    in this obstack, and all are freed when the declarator    has been parsed.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|obstack
name|temp_decl_obstack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This points at either permanent_obstack    or the current function_maybepermanent_obstack.  */
end_comment

begin_decl_stmt
name|struct
name|obstack
modifier|*
name|saveable_obstack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is same as saveable_obstack during parse and expansion phase;    it points to the current function's obstack during optimization.    This is the obstack to be used for creating rtl objects.  */
end_comment

begin_decl_stmt
name|struct
name|obstack
modifier|*
name|rtl_obstack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This points at either permanent_obstack or the current function_obstack.  */
end_comment

begin_decl_stmt
name|struct
name|obstack
modifier|*
name|current_obstack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This points at either permanent_obstack or the current function_obstack    or momentary_obstack.  */
end_comment

begin_decl_stmt
name|struct
name|obstack
modifier|*
name|expression_obstack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Stack of obstack selections for push_obstacks and pop_obstacks.  */
end_comment

begin_struct
struct|struct
name|obstack_stack
block|{
name|struct
name|obstack_stack
modifier|*
name|next
decl_stmt|;
name|struct
name|obstack
modifier|*
name|current
decl_stmt|;
name|struct
name|obstack
modifier|*
name|saveable
decl_stmt|;
name|struct
name|obstack
modifier|*
name|expression
decl_stmt|;
name|struct
name|obstack
modifier|*
name|rtl
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|obstack_stack
modifier|*
name|obstack_stack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Obstack for allocating struct obstack_stack entries.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|obstack
name|obstack_stack_obstack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Addresses of first objects in some obstacks.    This is for freeing their entire contents.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|maybepermanent_firstobj
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|temporary_firstobj
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|momentary_firstobj
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|temp_decl_firstobj
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means all ..._TYPE nodes should be allocated permanently.  */
end_comment

begin_decl_stmt
name|int
name|all_types_permanent
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Stack of places to restore the momentary obstack back to.  */
end_comment

begin_struct
struct|struct
name|momentary_level
block|{
comment|/* Pointer back to previous such level.  */
name|struct
name|momentary_level
modifier|*
name|prev
decl_stmt|;
comment|/* First object allocated within this level.  */
name|char
modifier|*
name|base
decl_stmt|;
comment|/* Value of expression_obstack saved at entry to this level.  */
name|struct
name|obstack
modifier|*
name|obstack
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|momentary_level
modifier|*
name|momentary_stack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Table indexed by tree code giving a string containing a character    classifying the tree code.  Possibilities are    t, d, s, c, r,<, 1, 2 and e.  See tree.def for details.  */
end_comment

begin_define
define|#
directive|define
name|DEFTREECODE
parameter_list|(
name|SYM
parameter_list|,
name|NAME
parameter_list|,
name|TYPE
parameter_list|,
name|LENGTH
parameter_list|)
value|TYPE,
end_define

begin_decl_stmt
name|char
modifier|*
name|standard_tree_code_type
index|[]
init|=
block|{
include|#
directive|include
file|"tree.def"
block|}
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|DEFTREECODE
end_undef

begin_comment
comment|/* Table indexed by tree code giving number of expression    operands beyond the fixed part of the node structure.    Not used for types or decls.  */
end_comment

begin_define
define|#
directive|define
name|DEFTREECODE
parameter_list|(
name|SYM
parameter_list|,
name|NAME
parameter_list|,
name|TYPE
parameter_list|,
name|LENGTH
parameter_list|)
value|LENGTH,
end_define

begin_decl_stmt
name|int
name|standard_tree_code_length
index|[]
init|=
block|{
include|#
directive|include
file|"tree.def"
block|}
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|DEFTREECODE
end_undef

begin_comment
comment|/* Names of tree components.    Used for printing out the tree and error messages.  */
end_comment

begin_define
define|#
directive|define
name|DEFTREECODE
parameter_list|(
name|SYM
parameter_list|,
name|NAME
parameter_list|,
name|TYPE
parameter_list|,
name|LEN
parameter_list|)
value|NAME,
end_define

begin_decl_stmt
name|char
modifier|*
name|standard_tree_code_name
index|[]
init|=
block|{
include|#
directive|include
file|"tree.def"
block|}
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|DEFTREECODE
end_undef

begin_comment
comment|/* Table indexed by tree code giving a string containing a character    classifying the tree code.  Possibilities are    t, d, s, c, r, e,<, 1 and 2.  See tree.def for details.  */
end_comment

begin_decl_stmt
name|char
modifier|*
modifier|*
name|tree_code_type
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Table indexed by tree code giving number of expression    operands beyond the fixed part of the node structure.    Not used for types or decls.  */
end_comment

begin_decl_stmt
name|int
modifier|*
name|tree_code_length
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Table indexed by tree code giving name of tree code, as a string.  */
end_comment

begin_decl_stmt
name|char
modifier|*
modifier|*
name|tree_code_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Statistics-gathering stuff.  */
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|d_kind
block|,
name|t_kind
block|,
name|b_kind
block|,
name|s_kind
block|,
name|r_kind
block|,
name|e_kind
block|,
name|c_kind
block|,
name|id_kind
block|,
name|op_id_kind
block|,
name|perm_list_kind
block|,
name|temp_list_kind
block|,
name|vec_kind
block|,
name|x_kind
block|,
name|lang_decl
block|,
name|lang_type
block|,
name|all_kinds
block|}
name|tree_node_kind
typedef|;
end_typedef

begin_decl_stmt
name|int
name|tree_node_counts
index|[
operator|(
name|int
operator|)
name|all_kinds
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|tree_node_sizes
index|[
operator|(
name|int
operator|)
name|all_kinds
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|id_string_size
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|tree_node_kind_names
index|[]
init|=
block|{
literal|"decls"
block|,
literal|"types"
block|,
literal|"blocks"
block|,
literal|"stmts"
block|,
literal|"refs"
block|,
literal|"exprs"
block|,
literal|"constants"
block|,
literal|"identifiers"
block|,
literal|"op_identifiers"
block|,
literal|"perm_tree_lists"
block|,
literal|"temp_tree_lists"
block|,
literal|"vecs"
block|,
literal|"random kinds"
block|,
literal|"lang_decl kinds"
block|,
literal|"lang_type kinds"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Hash table for uniquizing IDENTIFIER_NODEs by name.  */
end_comment

begin_define
define|#
directive|define
name|MAX_HASH_TABLE
value|1009
end_define

begin_decl_stmt
specifier|static
name|tree
name|hash_table
index|[
name|MAX_HASH_TABLE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* id hash buckets */
end_comment

begin_comment
comment|/* 0 while creating built-in identifiers.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|do_identifier_warnings
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Unique id for next decl created.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|next_decl_uid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|mode_name
index|[]
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
name|gcc_obstack_init
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|stabilize_reference_1
parameter_list|()
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* Init the principal obstacks.  */
end_comment

begin_function
name|void
name|init_obstacks
parameter_list|()
block|{
name|gcc_obstack_init
argument_list|(
operator|&
name|obstack_stack_obstack
argument_list|)
expr_stmt|;
name|gcc_obstack_init
argument_list|(
operator|&
name|permanent_obstack
argument_list|)
expr_stmt|;
name|gcc_obstack_init
argument_list|(
operator|&
name|temporary_obstack
argument_list|)
expr_stmt|;
name|temporary_firstobj
operator|=
operator|(
name|char
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|temporary_obstack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gcc_obstack_init
argument_list|(
operator|&
name|momentary_obstack
argument_list|)
expr_stmt|;
name|momentary_firstobj
operator|=
operator|(
name|char
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|momentary_obstack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gcc_obstack_init
argument_list|(
operator|&
name|maybepermanent_obstack
argument_list|)
expr_stmt|;
name|maybepermanent_firstobj
operator|=
operator|(
name|char
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|maybepermanent_obstack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gcc_obstack_init
argument_list|(
operator|&
name|temp_decl_obstack
argument_list|)
expr_stmt|;
name|temp_decl_firstobj
operator|=
operator|(
name|char
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|temp_decl_obstack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|function_obstack
operator|=
operator|&
name|temporary_obstack
expr_stmt|;
name|function_maybepermanent_obstack
operator|=
operator|&
name|maybepermanent_obstack
expr_stmt|;
name|current_obstack
operator|=
operator|&
name|permanent_obstack
expr_stmt|;
name|expression_obstack
operator|=
operator|&
name|permanent_obstack
expr_stmt|;
name|rtl_obstack
operator|=
name|saveable_obstack
operator|=
operator|&
name|permanent_obstack
expr_stmt|;
comment|/* Init the hash table of identifiers.  */
name|bzero
argument_list|(
name|hash_table
argument_list|,
sizeof|sizeof
name|hash_table
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|gcc_obstack_init
parameter_list|(
name|obstack
parameter_list|)
name|struct
name|obstack
modifier|*
name|obstack
decl_stmt|;
block|{
comment|/* Let particular systems override the size of a chunk.  */
ifndef|#
directive|ifndef
name|OBSTACK_CHUNK_SIZE
define|#
directive|define
name|OBSTACK_CHUNK_SIZE
value|0
endif|#
directive|endif
comment|/* Let them override the alloc and free routines too.  */
ifndef|#
directive|ifndef
name|OBSTACK_CHUNK_ALLOC
define|#
directive|define
name|OBSTACK_CHUNK_ALLOC
value|xmalloc
endif|#
directive|endif
ifndef|#
directive|ifndef
name|OBSTACK_CHUNK_FREE
define|#
directive|define
name|OBSTACK_CHUNK_FREE
value|free
endif|#
directive|endif
name|_obstack_begin
argument_list|(
name|obstack
argument_list|,
name|OBSTACK_CHUNK_SIZE
argument_list|,
literal|0
argument_list|,
operator|(
name|void
operator|*
call|(
modifier|*
call|)
argument_list|()
operator|)
name|OBSTACK_CHUNK_ALLOC
argument_list|,
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
name|OBSTACK_CHUNK_FREE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Save all variables describing the current status into the structure *P.    This is used before starting a nested function.  */
end_comment

begin_function
name|void
name|save_tree_status
parameter_list|(
name|p
parameter_list|)
name|struct
name|function
modifier|*
name|p
decl_stmt|;
block|{
name|p
operator|->
name|all_types_permanent
operator|=
name|all_types_permanent
expr_stmt|;
name|p
operator|->
name|momentary_stack
operator|=
name|momentary_stack
expr_stmt|;
name|p
operator|->
name|maybepermanent_firstobj
operator|=
name|maybepermanent_firstobj
expr_stmt|;
name|p
operator|->
name|momentary_firstobj
operator|=
name|momentary_firstobj
expr_stmt|;
name|p
operator|->
name|function_obstack
operator|=
name|function_obstack
expr_stmt|;
name|p
operator|->
name|function_maybepermanent_obstack
operator|=
name|function_maybepermanent_obstack
expr_stmt|;
name|p
operator|->
name|current_obstack
operator|=
name|current_obstack
expr_stmt|;
name|p
operator|->
name|expression_obstack
operator|=
name|expression_obstack
expr_stmt|;
name|p
operator|->
name|saveable_obstack
operator|=
name|saveable_obstack
expr_stmt|;
name|p
operator|->
name|rtl_obstack
operator|=
name|rtl_obstack
expr_stmt|;
name|function_obstack
operator|=
operator|(
expr|struct
name|obstack
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|obstack
argument_list|)
argument_list|)
expr_stmt|;
name|gcc_obstack_init
argument_list|(
name|function_obstack
argument_list|)
expr_stmt|;
name|function_maybepermanent_obstack
operator|=
operator|(
expr|struct
name|obstack
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|obstack
argument_list|)
argument_list|)
expr_stmt|;
name|gcc_obstack_init
argument_list|(
name|function_maybepermanent_obstack
argument_list|)
expr_stmt|;
name|current_obstack
operator|=
operator|&
name|permanent_obstack
expr_stmt|;
name|expression_obstack
operator|=
operator|&
name|permanent_obstack
expr_stmt|;
name|rtl_obstack
operator|=
name|saveable_obstack
operator|=
operator|&
name|permanent_obstack
expr_stmt|;
name|momentary_firstobj
operator|=
operator|(
name|char
operator|*
operator|)
name|obstack_finish
argument_list|(
operator|&
name|momentary_obstack
argument_list|)
expr_stmt|;
name|maybepermanent_firstobj
operator|=
operator|(
name|char
operator|*
operator|)
name|obstack_finish
argument_list|(
name|function_maybepermanent_obstack
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Restore all variables describing the current status from the structure *P.    This is used after a nested function.  */
end_comment

begin_function
name|void
name|restore_tree_status
parameter_list|(
name|p
parameter_list|)
name|struct
name|function
modifier|*
name|p
decl_stmt|;
block|{
name|all_types_permanent
operator|=
name|p
operator|->
name|all_types_permanent
expr_stmt|;
name|momentary_stack
operator|=
name|p
operator|->
name|momentary_stack
expr_stmt|;
name|obstack_free
argument_list|(
operator|&
name|momentary_obstack
argument_list|,
name|momentary_firstobj
argument_list|)
expr_stmt|;
name|obstack_free
argument_list|(
name|function_obstack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|obstack_free
argument_list|(
name|function_maybepermanent_obstack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|function_obstack
argument_list|)
expr_stmt|;
name|momentary_firstobj
operator|=
name|p
operator|->
name|momentary_firstobj
expr_stmt|;
name|maybepermanent_firstobj
operator|=
name|p
operator|->
name|maybepermanent_firstobj
expr_stmt|;
name|function_obstack
operator|=
name|p
operator|->
name|function_obstack
expr_stmt|;
name|function_maybepermanent_obstack
operator|=
name|p
operator|->
name|function_maybepermanent_obstack
expr_stmt|;
name|current_obstack
operator|=
name|p
operator|->
name|current_obstack
expr_stmt|;
name|expression_obstack
operator|=
name|p
operator|->
name|expression_obstack
expr_stmt|;
name|saveable_obstack
operator|=
name|p
operator|->
name|saveable_obstack
expr_stmt|;
name|rtl_obstack
operator|=
name|p
operator|->
name|rtl_obstack
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Start allocating on the temporary (per function) obstack.    This is done in start_function before parsing the function body,    and before each initialization at top level, and to go back    to temporary allocation after doing end_temporary_allocation.  */
end_comment

begin_function
name|void
name|temporary_allocation
parameter_list|()
block|{
comment|/* Note that function_obstack at top level points to temporary_obstack.      But within a nested function context, it is a separate obstack.  */
name|current_obstack
operator|=
name|function_obstack
expr_stmt|;
name|expression_obstack
operator|=
name|function_obstack
expr_stmt|;
name|rtl_obstack
operator|=
name|saveable_obstack
operator|=
name|function_maybepermanent_obstack
expr_stmt|;
name|momentary_stack
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Start allocating on the permanent obstack but don't    free the temporary data.  After calling this, call    `permanent_allocation' to fully resume permanent allocation status.  */
end_comment

begin_function
name|void
name|end_temporary_allocation
parameter_list|()
block|{
name|current_obstack
operator|=
operator|&
name|permanent_obstack
expr_stmt|;
name|expression_obstack
operator|=
operator|&
name|permanent_obstack
expr_stmt|;
name|rtl_obstack
operator|=
name|saveable_obstack
operator|=
operator|&
name|permanent_obstack
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Resume allocating on the temporary obstack, undoing    effects of `end_temporary_allocation'.  */
end_comment

begin_function
name|void
name|resume_temporary_allocation
parameter_list|()
block|{
name|current_obstack
operator|=
name|function_obstack
expr_stmt|;
name|expression_obstack
operator|=
name|function_obstack
expr_stmt|;
name|rtl_obstack
operator|=
name|saveable_obstack
operator|=
name|function_maybepermanent_obstack
expr_stmt|;
block|}
end_function

begin_comment
comment|/* While doing temporary allocation, switch to allocating in such a    way as to save all nodes if the function is inlined.  Call    resume_temporary_allocation to go back to ordinary temporary    allocation.  */
end_comment

begin_function
name|void
name|saveable_allocation
parameter_list|()
block|{
comment|/* Note that function_obstack at top level points to temporary_obstack.      But within a nested function context, it is a separate obstack.  */
name|expression_obstack
operator|=
name|current_obstack
operator|=
name|saveable_obstack
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Switch to current obstack CURRENT and maybepermanent obstack SAVEABLE,    recording the previously current obstacks on a stack.    This does not free any storage in any obstack.  */
end_comment

begin_function
name|void
name|push_obstacks
parameter_list|(
name|current
parameter_list|,
name|saveable
parameter_list|)
name|struct
name|obstack
modifier|*
name|current
decl_stmt|,
decl|*
name|saveable
decl_stmt|;
end_function

begin_block
block|{
name|struct
name|obstack_stack
modifier|*
name|p
init|=
operator|(
expr|struct
name|obstack_stack
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|obstack_stack_obstack
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|obstack_stack
argument_list|)
operator|)
argument_list|)
decl_stmt|;
name|p
operator|->
name|current
operator|=
name|current_obstack
expr_stmt|;
name|p
operator|->
name|saveable
operator|=
name|saveable_obstack
expr_stmt|;
name|p
operator|->
name|expression
operator|=
name|expression_obstack
expr_stmt|;
name|p
operator|->
name|rtl
operator|=
name|rtl_obstack
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|obstack_stack
expr_stmt|;
name|obstack_stack
operator|=
name|p
expr_stmt|;
name|current_obstack
operator|=
name|current
expr_stmt|;
name|expression_obstack
operator|=
name|current
expr_stmt|;
name|rtl_obstack
operator|=
name|saveable_obstack
operator|=
name|saveable
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Save the current set of obstacks, but don't change them.  */
end_comment

begin_function
name|void
name|push_obstacks_nochange
parameter_list|()
block|{
name|struct
name|obstack_stack
modifier|*
name|p
init|=
operator|(
expr|struct
name|obstack_stack
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|obstack_stack_obstack
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|obstack_stack
argument_list|)
operator|)
argument_list|)
decl_stmt|;
name|p
operator|->
name|current
operator|=
name|current_obstack
expr_stmt|;
name|p
operator|->
name|saveable
operator|=
name|saveable_obstack
expr_stmt|;
name|p
operator|->
name|expression
operator|=
name|expression_obstack
expr_stmt|;
name|p
operator|->
name|rtl
operator|=
name|rtl_obstack
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|obstack_stack
expr_stmt|;
name|obstack_stack
operator|=
name|p
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Pop the obstack selection stack.  */
end_comment

begin_function
name|void
name|pop_obstacks
parameter_list|()
block|{
name|struct
name|obstack_stack
modifier|*
name|p
init|=
name|obstack_stack
decl_stmt|;
name|obstack_stack
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|current_obstack
operator|=
name|p
operator|->
name|current
expr_stmt|;
name|saveable_obstack
operator|=
name|p
operator|->
name|saveable
expr_stmt|;
name|expression_obstack
operator|=
name|p
operator|->
name|expression
expr_stmt|;
name|rtl_obstack
operator|=
name|p
operator|->
name|rtl
expr_stmt|;
name|obstack_free
argument_list|(
operator|&
name|obstack_stack_obstack
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Nonzero if temporary allocation is currently in effect.    Zero if currently doing permanent allocation.  */
end_comment

begin_function
name|int
name|allocation_temporary_p
parameter_list|()
block|{
return|return
name|current_obstack
operator|!=
operator|&
name|permanent_obstack
return|;
block|}
end_function

begin_comment
comment|/* Go back to allocating on the permanent obstack    and free everything in the temporary obstack.    This is done in finish_function after fully compiling a function.  */
end_comment

begin_function
name|void
name|permanent_allocation
parameter_list|()
block|{
comment|/* Free up previous temporary obstack data */
name|obstack_free
argument_list|(
operator|&
name|temporary_obstack
argument_list|,
name|temporary_firstobj
argument_list|)
expr_stmt|;
name|obstack_free
argument_list|(
operator|&
name|momentary_obstack
argument_list|,
name|momentary_firstobj
argument_list|)
expr_stmt|;
name|obstack_free
argument_list|(
operator|&
name|maybepermanent_obstack
argument_list|,
name|maybepermanent_firstobj
argument_list|)
expr_stmt|;
name|obstack_free
argument_list|(
operator|&
name|temp_decl_obstack
argument_list|,
name|temp_decl_firstobj
argument_list|)
expr_stmt|;
name|current_obstack
operator|=
operator|&
name|permanent_obstack
expr_stmt|;
name|expression_obstack
operator|=
operator|&
name|permanent_obstack
expr_stmt|;
name|rtl_obstack
operator|=
name|saveable_obstack
operator|=
operator|&
name|permanent_obstack
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Save permanently everything on the maybepermanent_obstack.  */
end_comment

begin_function
name|void
name|preserve_data
parameter_list|()
block|{
name|maybepermanent_firstobj
operator|=
operator|(
name|char
operator|*
operator|)
name|obstack_alloc
argument_list|(
name|function_maybepermanent_obstack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|preserve_initializer
parameter_list|()
block|{
name|temporary_firstobj
operator|=
operator|(
name|char
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|temporary_obstack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|momentary_firstobj
operator|=
operator|(
name|char
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|momentary_obstack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|maybepermanent_firstobj
operator|=
operator|(
name|char
operator|*
operator|)
name|obstack_alloc
argument_list|(
name|function_maybepermanent_obstack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Start allocating new rtl in current_obstack.    Use resume_temporary_allocation    to go back to allocating rtl in saveable_obstack.  */
end_comment

begin_function
name|void
name|rtl_in_current_obstack
parameter_list|()
block|{
name|rtl_obstack
operator|=
name|current_obstack
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Temporarily allocate rtl from saveable_obstack.  Return 1 if we were    previously allocating it from current_obstack.  */
end_comment

begin_function
name|int
name|rtl_in_saveable_obstack
parameter_list|()
block|{
if|if
condition|(
name|rtl_obstack
operator|==
name|current_obstack
condition|)
block|{
name|rtl_obstack
operator|=
name|saveable_obstack
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Allocate SIZE bytes in the current obstack    and return a pointer to them.    In practice the current obstack is always the temporary one.  */
end_comment

begin_function
name|char
modifier|*
name|oballoc
parameter_list|(
name|size
parameter_list|)
name|int
name|size
decl_stmt|;
block|{
return|return
operator|(
name|char
operator|*
operator|)
name|obstack_alloc
argument_list|(
name|current_obstack
argument_list|,
name|size
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Free the object PTR in the current obstack    as well as everything allocated since PTR.    In practice the current obstack is always the temporary one.  */
end_comment

begin_function
name|void
name|obfree
parameter_list|(
name|ptr
parameter_list|)
name|char
modifier|*
name|ptr
decl_stmt|;
block|{
name|obstack_free
argument_list|(
name|current_obstack
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Allocate SIZE bytes in the permanent obstack    and return a pointer to them.  */
end_comment

begin_function
name|char
modifier|*
name|permalloc
parameter_list|(
name|size
parameter_list|)
name|int
name|size
decl_stmt|;
block|{
return|return
operator|(
name|char
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|permanent_obstack
argument_list|,
name|size
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Allocate NELEM items of SIZE bytes in the permanent obstack    and return a pointer to them.  The storage is cleared before    returning the value.  */
end_comment

begin_function
name|char
modifier|*
name|perm_calloc
parameter_list|(
name|nelem
parameter_list|,
name|size
parameter_list|)
name|int
name|nelem
decl_stmt|;
name|long
name|size
decl_stmt|;
block|{
name|char
modifier|*
name|rval
init|=
operator|(
name|char
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|permanent_obstack
argument_list|,
name|nelem
operator|*
name|size
argument_list|)
decl_stmt|;
name|bzero
argument_list|(
name|rval
argument_list|,
name|nelem
operator|*
name|size
argument_list|)
expr_stmt|;
return|return
name|rval
return|;
block|}
end_function

begin_comment
comment|/* Allocate SIZE bytes in the saveable obstack    and return a pointer to them.  */
end_comment

begin_function
name|char
modifier|*
name|savealloc
parameter_list|(
name|size
parameter_list|)
name|int
name|size
decl_stmt|;
block|{
return|return
operator|(
name|char
operator|*
operator|)
name|obstack_alloc
argument_list|(
name|saveable_obstack
argument_list|,
name|size
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print out which obstack an object is in.  */
end_comment

begin_function
name|void
name|debug_obstack
parameter_list|(
name|object
parameter_list|)
name|char
modifier|*
name|object
decl_stmt|;
block|{
name|struct
name|obstack
modifier|*
name|obstack
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|obstack_name
init|=
name|NULL
decl_stmt|;
name|struct
name|function
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|outer_function_chain
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
name|_obstack_allocated_p
argument_list|(
name|p
operator|->
name|function_obstack
argument_list|,
name|object
argument_list|)
condition|)
block|{
name|obstack
operator|=
name|p
operator|->
name|function_obstack
expr_stmt|;
name|obstack_name
operator|=
literal|"containing function obstack"
expr_stmt|;
block|}
if|if
condition|(
name|_obstack_allocated_p
argument_list|(
name|p
operator|->
name|function_maybepermanent_obstack
argument_list|,
name|object
argument_list|)
condition|)
block|{
name|obstack
operator|=
name|p
operator|->
name|function_maybepermanent_obstack
expr_stmt|;
name|obstack_name
operator|=
literal|"containing function maybepermanent obstack"
expr_stmt|;
block|}
block|}
if|if
condition|(
name|_obstack_allocated_p
argument_list|(
operator|&
name|obstack_stack_obstack
argument_list|,
name|object
argument_list|)
condition|)
block|{
name|obstack
operator|=
operator|&
name|obstack_stack_obstack
expr_stmt|;
name|obstack_name
operator|=
literal|"obstack_stack_obstack"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|_obstack_allocated_p
argument_list|(
name|function_obstack
argument_list|,
name|object
argument_list|)
condition|)
block|{
name|obstack
operator|=
name|function_obstack
expr_stmt|;
name|obstack_name
operator|=
literal|"function obstack"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|_obstack_allocated_p
argument_list|(
operator|&
name|permanent_obstack
argument_list|,
name|object
argument_list|)
condition|)
block|{
name|obstack
operator|=
operator|&
name|permanent_obstack
expr_stmt|;
name|obstack_name
operator|=
literal|"permanent_obstack"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|_obstack_allocated_p
argument_list|(
operator|&
name|momentary_obstack
argument_list|,
name|object
argument_list|)
condition|)
block|{
name|obstack
operator|=
operator|&
name|momentary_obstack
expr_stmt|;
name|obstack_name
operator|=
literal|"momentary_obstack"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|_obstack_allocated_p
argument_list|(
name|function_maybepermanent_obstack
argument_list|,
name|object
argument_list|)
condition|)
block|{
name|obstack
operator|=
name|function_maybepermanent_obstack
expr_stmt|;
name|obstack_name
operator|=
literal|"function maybepermanent obstack"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|_obstack_allocated_p
argument_list|(
operator|&
name|temp_decl_obstack
argument_list|,
name|object
argument_list|)
condition|)
block|{
name|obstack
operator|=
operator|&
name|temp_decl_obstack
expr_stmt|;
name|obstack_name
operator|=
literal|"temp_decl_obstack"
expr_stmt|;
block|}
comment|/* Check to see if the object is in the free area of the obstack. */
if|if
condition|(
name|obstack
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|object
operator|>=
name|obstack
operator|->
name|next_free
operator|&&
name|object
operator|<
name|obstack
operator|->
name|chunk_limit
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"object in free portion of obstack %s.\n"
argument_list|,
name|obstack_name
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"object allocated from %s.\n"
argument_list|,
name|obstack_name
argument_list|)
expr_stmt|;
block|}
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"object not allocated from any obstack.\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return 1 if OBJ is in the permanent obstack.    This is slow, and should be used only for debugging.    Use TREE_PERMANENT for other purposes.  */
end_comment

begin_function
name|int
name|object_permanent_p
parameter_list|(
name|obj
parameter_list|)
name|tree
name|obj
decl_stmt|;
block|{
return|return
name|_obstack_allocated_p
argument_list|(
operator|&
name|permanent_obstack
argument_list|,
name|obj
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Start a level of momentary allocation.    In C, each compound statement has its own level    and that level is freed at the end of each statement.    All expression nodes are allocated in the momentary allocation level.  */
end_comment

begin_function
name|void
name|push_momentary
parameter_list|()
block|{
name|struct
name|momentary_level
modifier|*
name|tem
init|=
operator|(
expr|struct
name|momentary_level
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|momentary_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|momentary_level
argument_list|)
argument_list|)
decl_stmt|;
name|tem
operator|->
name|prev
operator|=
name|momentary_stack
expr_stmt|;
name|tem
operator|->
name|base
operator|=
operator|(
name|char
operator|*
operator|)
name|obstack_base
argument_list|(
operator|&
name|momentary_obstack
argument_list|)
expr_stmt|;
name|tem
operator|->
name|obstack
operator|=
name|expression_obstack
expr_stmt|;
name|momentary_stack
operator|=
name|tem
expr_stmt|;
name|expression_obstack
operator|=
operator|&
name|momentary_obstack
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Free all the storage in the current momentary-allocation level.    In C, this happens at the end of each statement.  */
end_comment

begin_function
name|void
name|clear_momentary
parameter_list|()
block|{
name|obstack_free
argument_list|(
operator|&
name|momentary_obstack
argument_list|,
name|momentary_stack
operator|->
name|base
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Discard a level of momentary allocation.    In C, this happens at the end of each compound statement.    Restore the status of expression node allocation    that was in effect before this level was created.  */
end_comment

begin_function
name|void
name|pop_momentary
parameter_list|()
block|{
name|struct
name|momentary_level
modifier|*
name|tem
init|=
name|momentary_stack
decl_stmt|;
name|momentary_stack
operator|=
name|tem
operator|->
name|prev
expr_stmt|;
name|expression_obstack
operator|=
name|tem
operator|->
name|obstack
expr_stmt|;
name|obstack_free
argument_list|(
operator|&
name|momentary_obstack
argument_list|,
name|tem
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Call when starting to parse a declaration:    make expressions in the declaration last the length of the function.    Returns an argument that should be passed to resume_momentary later.  */
end_comment

begin_function
name|int
name|suspend_momentary
parameter_list|()
block|{
specifier|register
name|int
name|tem
init|=
name|expression_obstack
operator|==
operator|&
name|momentary_obstack
decl_stmt|;
name|expression_obstack
operator|=
name|saveable_obstack
expr_stmt|;
return|return
name|tem
return|;
block|}
end_function

begin_comment
comment|/* Call when finished parsing a declaration:    restore the treatment of node-allocation that was    in effect before the suspension.    YES should be the value previously returned by suspend_momentary.  */
end_comment

begin_function
name|void
name|resume_momentary
parameter_list|(
name|yes
parameter_list|)
name|int
name|yes
decl_stmt|;
block|{
if|if
condition|(
name|yes
condition|)
name|expression_obstack
operator|=
operator|&
name|momentary_obstack
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Init the tables indexed by tree code.    Note that languages can add to these tables to define their own codes.  */
end_comment

begin_function
name|void
name|init_tree_codes
parameter_list|()
block|{
name|tree_code_type
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|standard_tree_code_type
argument_list|)
argument_list|)
expr_stmt|;
name|tree_code_length
operator|=
operator|(
name|int
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|standard_tree_code_length
argument_list|)
argument_list|)
expr_stmt|;
name|tree_code_name
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|standard_tree_code_name
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|standard_tree_code_type
argument_list|,
name|tree_code_type
argument_list|,
sizeof|sizeof
argument_list|(
name|standard_tree_code_type
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|standard_tree_code_length
argument_list|,
name|tree_code_length
argument_list|,
sizeof|sizeof
argument_list|(
name|standard_tree_code_length
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|standard_tree_code_name
argument_list|,
name|tree_code_name
argument_list|,
sizeof|sizeof
argument_list|(
name|standard_tree_code_name
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return a newly allocated node of code CODE.    Initialize the node's unique id and its TREE_PERMANENT flag.    For decl and type nodes, some other fields are initialized.    The rest of the node is initialized to zero.     Achoo!  I got a code in the node.  */
end_comment

begin_function
name|tree
name|make_node
parameter_list|(
name|code
parameter_list|)
name|enum
name|tree_code
name|code
decl_stmt|;
block|{
specifier|register
name|tree
name|t
decl_stmt|;
specifier|register
name|int
name|type
init|=
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
decl_stmt|;
specifier|register
name|int
name|length
decl_stmt|;
specifier|register
name|struct
name|obstack
modifier|*
name|obstack
init|=
name|current_obstack
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|tree_node_kind
name|kind
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
literal|'d'
case|:
comment|/* A decl node */
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|kind
operator|=
name|d_kind
expr_stmt|;
endif|#
directive|endif
name|length
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|tree_decl
argument_list|)
expr_stmt|;
comment|/* All decls in an inline function need to be saved.  */
if|if
condition|(
name|obstack
operator|!=
operator|&
name|permanent_obstack
condition|)
name|obstack
operator|=
name|saveable_obstack
expr_stmt|;
comment|/* PARM_DECLs always go on saveable_obstack, not permanent, 	 even though we may make them before the function turns 	 on temporary allocation.  */
elseif|else
if|if
condition|(
name|code
operator|==
name|PARM_DECL
condition|)
name|obstack
operator|=
name|function_maybepermanent_obstack
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
comment|/* a type node */
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|kind
operator|=
name|t_kind
expr_stmt|;
endif|#
directive|endif
name|length
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|tree_type
argument_list|)
expr_stmt|;
comment|/* All data types are put where we can preserve them if nec.  */
if|if
condition|(
name|obstack
operator|!=
operator|&
name|permanent_obstack
condition|)
name|obstack
operator|=
name|all_types_permanent
condition|?
operator|&
name|permanent_obstack
else|:
name|saveable_obstack
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
comment|/* a lexical block */
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|kind
operator|=
name|b_kind
expr_stmt|;
endif|#
directive|endif
name|length
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|tree_block
argument_list|)
expr_stmt|;
comment|/* All BLOCK nodes are put where we can preserve them if nec.  */
if|if
condition|(
name|obstack
operator|!=
operator|&
name|permanent_obstack
condition|)
name|obstack
operator|=
name|saveable_obstack
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
comment|/* an expression with side effects */
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|kind
operator|=
name|s_kind
expr_stmt|;
goto|goto
name|usual_kind
goto|;
endif|#
directive|endif
case|case
literal|'r'
case|:
comment|/* a reference */
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|kind
operator|=
name|r_kind
expr_stmt|;
goto|goto
name|usual_kind
goto|;
endif|#
directive|endif
case|case
literal|'e'
case|:
comment|/* an expression */
case|case
literal|'<'
case|:
comment|/* a comparison expression */
case|case
literal|'1'
case|:
comment|/* a unary arithmetic expression */
case|case
literal|'2'
case|:
comment|/* a binary arithmetic expression */
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|kind
operator|=
name|e_kind
expr_stmt|;
name|usual_kind
label|:
endif|#
directive|endif
name|obstack
operator|=
name|expression_obstack
expr_stmt|;
comment|/* All BIND_EXPR nodes are put where we can preserve them if nec.  */
if|if
condition|(
name|code
operator|==
name|BIND_EXPR
operator|&&
name|obstack
operator|!=
operator|&
name|permanent_obstack
condition|)
name|obstack
operator|=
name|saveable_obstack
expr_stmt|;
name|length
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|tree_exp
argument_list|)
operator|+
operator|(
name|tree_code_length
index|[
operator|(
name|int
operator|)
name|code
index|]
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
comment|/* a constant */
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|kind
operator|=
name|c_kind
expr_stmt|;
endif|#
directive|endif
name|obstack
operator|=
name|expression_obstack
expr_stmt|;
comment|/* We can't use tree_code_length for this, since the number of words 	 is machine-dependent due to varying alignment of `double'.  */
if|if
condition|(
name|code
operator|==
name|REAL_CST
condition|)
block|{
name|length
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|tree_real_cst
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
literal|'x'
case|:
comment|/* something random, like an identifier.  */
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
if|if
condition|(
name|code
operator|==
name|IDENTIFIER_NODE
condition|)
name|kind
operator|=
name|id_kind
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|OP_IDENTIFIER
condition|)
name|kind
operator|=
name|op_id_kind
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|TREE_VEC
condition|)
name|kind
operator|=
name|vec_kind
expr_stmt|;
else|else
name|kind
operator|=
name|x_kind
expr_stmt|;
endif|#
directive|endif
name|length
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|tree_common
argument_list|)
operator|+
name|tree_code_length
index|[
operator|(
name|int
operator|)
name|code
index|]
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
expr_stmt|;
comment|/* Identifier nodes are always permanent since they are 	 unique in a compiler run.  */
if|if
condition|(
name|code
operator|==
name|IDENTIFIER_NODE
condition|)
name|obstack
operator|=
operator|&
name|permanent_obstack
expr_stmt|;
block|}
name|t
operator|=
operator|(
name|tree
operator|)
name|obstack_alloc
argument_list|(
name|obstack
argument_list|,
name|length
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|tree_node_counts
index|[
operator|(
name|int
operator|)
name|kind
index|]
operator|++
expr_stmt|;
name|tree_node_sizes
index|[
operator|(
name|int
operator|)
name|kind
index|]
operator|+=
name|length
expr_stmt|;
endif|#
directive|endif
comment|/* Clear a word at a time.  */
for|for
control|(
name|i
operator|=
operator|(
name|length
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
operator|(
operator|(
name|int
operator|*
operator|)
name|t
operator|)
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Clear any extra bytes.  */
for|for
control|(
name|i
operator|=
name|length
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
operator|(
operator|(
name|char
operator|*
operator|)
name|t
operator|)
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|TREE_SET_CODE
argument_list|(
name|t
argument_list|,
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
name|obstack
operator|==
operator|&
name|permanent_obstack
condition|)
name|TREE_PERMANENT
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
literal|'s'
case|:
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|void_type_node
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
if|if
condition|(
name|code
operator|!=
name|FUNCTION_DECL
condition|)
name|DECL_ALIGN
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_IN_SYSTEM_HEADER
argument_list|(
name|t
argument_list|)
operator|=
name|in_system_header
operator|&&
operator|(
name|obstack
operator|==
operator|&
name|permanent_obstack
operator|)
expr_stmt|;
name|DECL_SOURCE_LINE
argument_list|(
name|t
argument_list|)
operator|=
name|lineno
expr_stmt|;
name|DECL_SOURCE_FILE
argument_list|(
name|t
argument_list|)
operator|=
operator|(
name|input_filename
operator|)
condition|?
name|input_filename
else|:
literal|"<built-in>"
expr_stmt|;
name|DECL_UID
argument_list|(
name|t
argument_list|)
operator|=
name|next_decl_uid
operator|++
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
block|{
specifier|static
name|unsigned
name|next_type_uid
init|=
literal|1
decl_stmt|;
name|TYPE_UID
argument_list|(
name|t
argument_list|)
operator|=
name|next_type_uid
operator|++
expr_stmt|;
block|}
name|TYPE_ALIGN
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TYPE_MAIN_VARIANT
argument_list|(
name|t
argument_list|)
operator|=
name|t
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|TREE_CONSTANT
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
break|break;
block|}
return|return
name|t
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return a new node with the same contents as NODE    except that its TREE_CHAIN is zero and it has a fresh uid.  */
end_comment

begin_function
name|tree
name|copy_node
parameter_list|(
name|node
parameter_list|)
name|tree
name|node
decl_stmt|;
block|{
specifier|register
name|tree
name|t
decl_stmt|;
specifier|register
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|node
argument_list|)
decl_stmt|;
specifier|register
name|int
name|length
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
switch|switch
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
condition|)
block|{
case|case
literal|'d'
case|:
comment|/* A decl node */
name|length
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|tree_decl
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
comment|/* a type node */
name|length
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|tree_type
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
comment|/* a lexical block node */
name|length
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|tree_block
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
comment|/* a reference */
case|case
literal|'e'
case|:
comment|/* an expression */
case|case
literal|'s'
case|:
comment|/* an expression with side effects */
case|case
literal|'<'
case|:
comment|/* a comparison expression */
case|case
literal|'1'
case|:
comment|/* a unary arithmetic expression */
case|case
literal|'2'
case|:
comment|/* a binary arithmetic expression */
name|length
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|tree_exp
argument_list|)
operator|+
operator|(
name|tree_code_length
index|[
operator|(
name|int
operator|)
name|code
index|]
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
comment|/* a constant */
comment|/* We can't use tree_code_length for this, since the number of words 	 is machine-dependent due to varying alignment of `double'.  */
if|if
condition|(
name|code
operator|==
name|REAL_CST
condition|)
block|{
name|length
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|tree_real_cst
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
literal|'x'
case|:
comment|/* something random, like an identifier.  */
name|length
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|tree_common
argument_list|)
operator|+
name|tree_code_length
index|[
operator|(
name|int
operator|)
name|code
index|]
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|TREE_VEC
condition|)
name|length
operator|+=
operator|(
name|TREE_VEC_LENGTH
argument_list|(
name|node
argument_list|)
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
expr_stmt|;
block|}
name|t
operator|=
operator|(
name|tree
operator|)
name|obstack_alloc
argument_list|(
name|current_obstack
argument_list|,
name|length
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
operator|(
name|length
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
operator|(
operator|(
name|int
operator|*
operator|)
name|t
operator|)
index|[
name|i
index|]
operator|=
operator|(
operator|(
name|int
operator|*
operator|)
name|node
operator|)
index|[
name|i
index|]
expr_stmt|;
comment|/* Clear any extra bytes.  */
for|for
control|(
name|i
operator|=
name|length
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
operator|(
operator|(
name|char
operator|*
operator|)
name|t
operator|)
index|[
name|i
index|]
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
name|node
operator|)
index|[
name|i
index|]
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TREE_PERMANENT
argument_list|(
name|t
argument_list|)
operator|=
operator|(
name|current_obstack
operator|==
operator|&
name|permanent_obstack
operator|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Return a copy of a chain of nodes, chained through the TREE_CHAIN field.    For example, this can copy a list made of TREE_LIST nodes.  */
end_comment

begin_function
name|tree
name|copy_list
parameter_list|(
name|list
parameter_list|)
name|tree
name|list
decl_stmt|;
block|{
name|tree
name|head
decl_stmt|;
specifier|register
name|tree
name|prev
decl_stmt|,
name|next
decl_stmt|;
if|if
condition|(
name|list
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|head
operator|=
name|prev
operator|=
name|copy_node
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|next
operator|=
name|TREE_CHAIN
argument_list|(
name|list
argument_list|)
expr_stmt|;
while|while
condition|(
name|next
condition|)
block|{
name|TREE_CHAIN
argument_list|(
name|prev
argument_list|)
operator|=
name|copy_node
argument_list|(
name|next
argument_list|)
expr_stmt|;
name|prev
operator|=
name|TREE_CHAIN
argument_list|(
name|prev
argument_list|)
expr_stmt|;
name|next
operator|=
name|TREE_CHAIN
argument_list|(
name|next
argument_list|)
expr_stmt|;
block|}
return|return
name|head
return|;
block|}
end_function

begin_escape
end_escape

begin_define
define|#
directive|define
name|HASHBITS
value|30
end_define

begin_comment
comment|/* Return an IDENTIFIER_NODE whose name is TEXT (a null-terminated string).    If an identifier with that name has previously been referred to,    the same node is returned this time.  */
end_comment

begin_function
name|tree
name|get_identifier
parameter_list|(
name|text
parameter_list|)
specifier|register
name|char
modifier|*
name|text
decl_stmt|;
block|{
specifier|register
name|int
name|hi
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|tree
name|idp
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|,
name|hash_len
decl_stmt|;
comment|/* Compute length of text in len.  */
for|for
control|(
name|len
operator|=
literal|0
init|;
name|text
index|[
name|len
index|]
condition|;
name|len
operator|++
control|)
empty_stmt|;
comment|/* Decide how much of that length to hash on */
name|hash_len
operator|=
name|len
expr_stmt|;
if|if
condition|(
name|warn_id_clash
operator|&&
name|len
operator|>
name|id_clash_len
condition|)
name|hash_len
operator|=
name|id_clash_len
expr_stmt|;
comment|/* Compute hash code */
name|hi
operator|=
name|hash_len
operator|*
literal|613
operator|+
operator|(
name|unsigned
operator|)
name|text
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|hash_len
condition|;
name|i
operator|+=
literal|2
control|)
name|hi
operator|=
operator|(
operator|(
name|hi
operator|*
literal|613
operator|)
operator|+
call|(
name|unsigned
call|)
argument_list|(
name|text
index|[
name|i
index|]
argument_list|)
operator|)
expr_stmt|;
name|hi
operator|&=
operator|(
literal|1
operator|<<
name|HASHBITS
operator|)
operator|-
literal|1
expr_stmt|;
name|hi
operator|%=
name|MAX_HASH_TABLE
expr_stmt|;
comment|/* Search table for identifier */
for|for
control|(
name|idp
operator|=
name|hash_table
index|[
name|hi
index|]
init|;
name|idp
condition|;
name|idp
operator|=
name|TREE_CHAIN
argument_list|(
name|idp
argument_list|)
control|)
if|if
condition|(
name|IDENTIFIER_LENGTH
argument_list|(
name|idp
argument_list|)
operator|==
name|len
operator|&&
name|IDENTIFIER_POINTER
argument_list|(
name|idp
argument_list|)
index|[
literal|0
index|]
operator|==
name|text
index|[
literal|0
index|]
operator|&&
operator|!
name|bcmp
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|idp
argument_list|)
argument_list|,
name|text
argument_list|,
name|len
argument_list|)
condition|)
return|return
name|idp
return|;
comment|/*<-- return if found */
comment|/* Not found; optionally warn about a similar identifier */
if|if
condition|(
name|warn_id_clash
operator|&&
name|do_identifier_warnings
operator|&&
name|len
operator|>=
name|id_clash_len
condition|)
for|for
control|(
name|idp
operator|=
name|hash_table
index|[
name|hi
index|]
init|;
name|idp
condition|;
name|idp
operator|=
name|TREE_CHAIN
argument_list|(
name|idp
argument_list|)
control|)
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|idp
argument_list|)
argument_list|,
name|text
argument_list|,
name|id_clash_len
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|"`%s' and `%s' identical in first %d characters"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|idp
argument_list|)
argument_list|,
name|text
argument_list|,
name|id_clash_len
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|tree_code_length
index|[
operator|(
name|int
operator|)
name|IDENTIFIER_NODE
index|]
operator|<
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* set_identifier_size hasn't been called.  */
comment|/* Not found, create one, add to chain */
name|idp
operator|=
name|make_node
argument_list|(
name|IDENTIFIER_NODE
argument_list|)
expr_stmt|;
name|IDENTIFIER_LENGTH
argument_list|(
name|idp
argument_list|)
operator|=
name|len
expr_stmt|;
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|id_string_size
operator|+=
name|len
expr_stmt|;
endif|#
directive|endif
name|IDENTIFIER_POINTER
argument_list|(
name|idp
argument_list|)
operator|=
name|obstack_copy0
argument_list|(
operator|&
name|permanent_obstack
argument_list|,
name|text
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|idp
argument_list|)
operator|=
name|hash_table
index|[
name|hi
index|]
expr_stmt|;
name|hash_table
index|[
name|hi
index|]
operator|=
name|idp
expr_stmt|;
return|return
name|idp
return|;
comment|/*<-- return if created */
block|}
end_function

begin_comment
comment|/* Enable warnings on similar identifiers (if requested).    Done after the built-in identifiers are created.  */
end_comment

begin_function
name|void
name|start_identifier_warnings
parameter_list|()
block|{
name|do_identifier_warnings
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Record the size of an identifier node for the language in use.    SIZE is the total size in bytes.    This is called by the language-specific files.  This must be    called before allocating any identifiers.  */
end_comment

begin_function
name|void
name|set_identifier_size
parameter_list|(
name|size
parameter_list|)
name|int
name|size
decl_stmt|;
block|{
name|tree_code_length
index|[
operator|(
name|int
operator|)
name|IDENTIFIER_NODE
index|]
operator|=
operator|(
name|size
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|tree_common
argument_list|)
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return a newly constructed INTEGER_CST node whose constant value    is specified by the two ints LOW and HI.    The TREE_TYPE is set to `int'.      This function should be used via the `build_int_2' macro.  */
end_comment

begin_function
name|tree
name|build_int_2_wide
parameter_list|(
name|low
parameter_list|,
name|hi
parameter_list|)
name|HOST_WIDE_INT
name|low
decl_stmt|,
name|hi
decl_stmt|;
block|{
specifier|register
name|tree
name|t
init|=
name|make_node
argument_list|(
name|INTEGER_CST
argument_list|)
decl_stmt|;
name|TREE_INT_CST_LOW
argument_list|(
name|t
argument_list|)
operator|=
name|low
expr_stmt|;
name|TREE_INT_CST_HIGH
argument_list|(
name|t
argument_list|)
operator|=
name|hi
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|integer_type_node
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Return a new REAL_CST node whose type is TYPE and value is D.  */
end_comment

begin_function
name|tree
name|build_real
parameter_list|(
name|type
parameter_list|,
name|d
parameter_list|)
name|tree
name|type
decl_stmt|;
name|REAL_VALUE_TYPE
name|d
decl_stmt|;
block|{
name|tree
name|v
decl_stmt|;
comment|/* Check for valid float value for this type on this target machine;      if not, can print error message and store a valid value in D.  */
ifdef|#
directive|ifdef
name|CHECK_FLOAT_VALUE
name|CHECK_FLOAT_VALUE
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|,
name|d
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|v
operator|=
name|make_node
argument_list|(
name|REAL_CST
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|v
argument_list|)
operator|=
name|type
expr_stmt|;
name|TREE_REAL_CST
argument_list|(
name|v
argument_list|)
operator|=
name|d
expr_stmt|;
return|return
name|v
return|;
block|}
end_function

begin_comment
comment|/* Return a new REAL_CST node whose type is TYPE    and whose value is the integer value of the INTEGER_CST node I.  */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|REAL_IS_NOT_DOUBLE
argument_list|)
operator|||
name|defined
argument_list|(
name|REAL_ARITHMETIC
argument_list|)
end_if

begin_function
name|REAL_VALUE_TYPE
name|real_value_from_int_cst
parameter_list|(
name|i
parameter_list|)
name|tree
name|i
decl_stmt|;
block|{
name|REAL_VALUE_TYPE
name|d
decl_stmt|;
ifdef|#
directive|ifdef
name|REAL_ARITHMETIC
name|REAL_VALUE_FROM_INT
argument_list|(
name|d
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
name|i
argument_list|)
argument_list|,
name|TREE_INT_CST_HIGH
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* not REAL_ARITHMETIC */
if|if
condition|(
name|TREE_INT_CST_HIGH
argument_list|(
name|i
argument_list|)
operator|<
literal|0
operator|&&
operator|!
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|i
argument_list|)
argument_list|)
condition|)
block|{
name|d
operator|=
call|(
name|double
call|)
argument_list|(
operator|~
name|TREE_INT_CST_HIGH
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|d
operator|*=
operator|(
call|(
name|double
call|)
argument_list|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|HOST_BITS_PER_WIDE_INT
operator|/
literal|2
operator|)
argument_list|)
operator|*
call|(
name|double
call|)
argument_list|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|HOST_BITS_PER_WIDE_INT
operator|/
literal|2
operator|)
argument_list|)
operator|)
expr_stmt|;
name|d
operator|+=
operator|(
name|double
operator|)
call|(
name|unsigned
name|HOST_WIDE_INT
call|)
argument_list|(
operator|~
name|TREE_INT_CST_LOW
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|d
operator|=
operator|(
operator|-
name|d
operator|-
literal|1.0
operator|)
expr_stmt|;
block|}
else|else
block|{
name|d
operator|=
operator|(
name|double
operator|)
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|TREE_INT_CST_HIGH
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|d
operator|*=
operator|(
call|(
name|double
call|)
argument_list|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|HOST_BITS_PER_WIDE_INT
operator|/
literal|2
operator|)
argument_list|)
operator|*
call|(
name|double
call|)
argument_list|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|HOST_BITS_PER_WIDE_INT
operator|/
literal|2
operator|)
argument_list|)
operator|)
expr_stmt|;
name|d
operator|+=
operator|(
name|double
operator|)
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|TREE_INT_CST_LOW
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* not REAL_ARITHMETIC */
return|return
name|d
return|;
block|}
end_function

begin_comment
comment|/* This function can't be implemented if we can't do arithmetic    on the float representation.  */
end_comment

begin_function
name|tree
name|build_real_from_int_cst
parameter_list|(
name|type
parameter_list|,
name|i
parameter_list|)
name|tree
name|type
decl_stmt|;
name|tree
name|i
decl_stmt|;
block|{
name|tree
name|v
decl_stmt|;
name|REAL_VALUE_TYPE
name|d
decl_stmt|;
name|v
operator|=
name|make_node
argument_list|(
name|REAL_CST
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|v
argument_list|)
operator|=
name|type
expr_stmt|;
name|d
operator|=
name|REAL_VALUE_TRUNCATE
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|,
name|real_value_from_int_cst
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Check for valid float value for this type on this target machine;      if not, can print error message and store a valid value in D.  */
ifdef|#
directive|ifdef
name|CHECK_FLOAT_VALUE
name|CHECK_FLOAT_VALUE
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|,
name|d
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|TREE_REAL_CST
argument_list|(
name|v
argument_list|)
operator|=
name|d
expr_stmt|;
return|return
name|v
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not REAL_IS_NOT_DOUBLE, or REAL_ARITHMETIC */
end_comment

begin_comment
comment|/* Return a newly constructed STRING_CST node whose value is    the LEN characters at STR.    The TREE_TYPE is not initialized.  */
end_comment

begin_function
name|tree
name|build_string
parameter_list|(
name|len
parameter_list|,
name|str
parameter_list|)
name|int
name|len
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
block|{
specifier|register
name|tree
name|s
init|=
name|make_node
argument_list|(
name|STRING_CST
argument_list|)
decl_stmt|;
name|TREE_STRING_LENGTH
argument_list|(
name|s
argument_list|)
operator|=
name|len
expr_stmt|;
name|TREE_STRING_POINTER
argument_list|(
name|s
argument_list|)
operator|=
name|obstack_copy0
argument_list|(
name|saveable_obstack
argument_list|,
name|str
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_comment
comment|/* Return a newly constructed COMPLEX_CST node whose value is    specified by the real and imaginary parts REAL and IMAG.    Both REAL and IMAG should be constant nodes.    The TREE_TYPE is not initialized.  */
end_comment

begin_function
name|tree
name|build_complex
parameter_list|(
name|real
parameter_list|,
name|imag
parameter_list|)
name|tree
name|real
decl_stmt|,
name|imag
decl_stmt|;
block|{
specifier|register
name|tree
name|t
init|=
name|make_node
argument_list|(
name|COMPLEX_CST
argument_list|)
decl_stmt|;
name|TREE_REALPART
argument_list|(
name|t
argument_list|)
operator|=
name|real
expr_stmt|;
name|TREE_IMAGPART
argument_list|(
name|t
argument_list|)
operator|=
name|imag
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Build a newly constructed TREE_VEC node of length LEN.  */
end_comment

begin_function
name|tree
name|make_tree_vec
parameter_list|(
name|len
parameter_list|)
name|int
name|len
decl_stmt|;
block|{
specifier|register
name|tree
name|t
decl_stmt|;
specifier|register
name|int
name|length
init|=
operator|(
name|len
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|tree_vec
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|obstack
modifier|*
name|obstack
init|=
name|current_obstack
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|tree_node_counts
index|[
operator|(
name|int
operator|)
name|vec_kind
index|]
operator|++
expr_stmt|;
name|tree_node_sizes
index|[
operator|(
name|int
operator|)
name|vec_kind
index|]
operator|+=
name|length
expr_stmt|;
endif|#
directive|endif
name|t
operator|=
operator|(
name|tree
operator|)
name|obstack_alloc
argument_list|(
name|obstack
argument_list|,
name|length
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
operator|(
name|length
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
operator|(
operator|(
name|int
operator|*
operator|)
name|t
operator|)
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|TREE_SET_CODE
argument_list|(
name|t
argument_list|,
name|TREE_VEC
argument_list|)
expr_stmt|;
name|TREE_VEC_LENGTH
argument_list|(
name|t
argument_list|)
operator|=
name|len
expr_stmt|;
if|if
condition|(
name|obstack
operator|==
operator|&
name|permanent_obstack
condition|)
name|TREE_PERMANENT
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return 1 if EXPR is the integer constant zero.  */
end_comment

begin_function
name|int
name|integer_zerop
parameter_list|(
name|expr
parameter_list|)
name|tree
name|expr
decl_stmt|;
block|{
name|STRIP_NOPS
argument_list|(
name|expr
argument_list|)
expr_stmt|;
return|return
operator|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_INT_CST_LOW
argument_list|(
name|expr
argument_list|)
operator|==
literal|0
operator|&&
name|TREE_INT_CST_HIGH
argument_list|(
name|expr
argument_list|)
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if EXPR is the integer constant one.  */
end_comment

begin_function
name|int
name|integer_onep
parameter_list|(
name|expr
parameter_list|)
name|tree
name|expr
decl_stmt|;
block|{
name|STRIP_NOPS
argument_list|(
name|expr
argument_list|)
expr_stmt|;
return|return
operator|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_INT_CST_LOW
argument_list|(
name|expr
argument_list|)
operator|==
literal|1
operator|&&
name|TREE_INT_CST_HIGH
argument_list|(
name|expr
argument_list|)
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if EXPR is an integer containing all 1's    in as much precision as it contains.  */
end_comment

begin_function
name|int
name|integer_all_onesp
parameter_list|(
name|expr
parameter_list|)
name|tree
name|expr
decl_stmt|;
block|{
specifier|register
name|int
name|prec
decl_stmt|;
specifier|register
name|int
name|uns
decl_stmt|;
name|STRIP_NOPS
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
return|return
literal|0
return|;
name|uns
operator|=
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|uns
condition|)
return|return
name|TREE_INT_CST_LOW
argument_list|(
name|expr
argument_list|)
operator|==
operator|-
literal|1
operator|&&
name|TREE_INT_CST_HIGH
argument_list|(
name|expr
argument_list|)
operator|==
operator|-
literal|1
return|;
name|prec
operator|=
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|prec
operator|>=
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
name|int
name|high_value
decl_stmt|,
name|shift_amount
decl_stmt|;
name|shift_amount
operator|=
name|prec
operator|-
name|HOST_BITS_PER_WIDE_INT
expr_stmt|;
if|if
condition|(
name|shift_amount
operator|>
name|HOST_BITS_PER_WIDE_INT
condition|)
comment|/* Can not handle precisions greater than twice the host int size.  */
name|abort
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|shift_amount
operator|==
name|HOST_BITS_PER_WIDE_INT
condition|)
comment|/* Shifting by the host word size is undefined according to the ANSI 	   standard, so we must handle this as a special case.  */
name|high_value
operator|=
operator|-
literal|1
expr_stmt|;
else|else
name|high_value
operator|=
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|shift_amount
operator|)
operator|-
literal|1
expr_stmt|;
return|return
name|TREE_INT_CST_LOW
argument_list|(
name|expr
argument_list|)
operator|==
operator|-
literal|1
operator|&&
name|TREE_INT_CST_HIGH
argument_list|(
name|expr
argument_list|)
operator|==
name|high_value
return|;
block|}
else|else
return|return
name|TREE_INT_CST_LOW
argument_list|(
name|expr
argument_list|)
operator|==
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|prec
operator|)
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if EXPR is an integer constant that is a power of 2 (i.e., has only    one bit on).  */
end_comment

begin_function
name|int
name|integer_pow2p
parameter_list|(
name|expr
parameter_list|)
name|tree
name|expr
decl_stmt|;
block|{
name|HOST_WIDE_INT
name|high
decl_stmt|,
name|low
decl_stmt|;
name|STRIP_NOPS
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
return|return
literal|0
return|;
name|high
operator|=
name|TREE_INT_CST_HIGH
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|low
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|high
operator|==
literal|0
operator|&&
name|low
operator|==
literal|0
condition|)
return|return
literal|0
return|;
return|return
operator|(
operator|(
name|high
operator|==
literal|0
operator|&&
operator|(
name|low
operator|&
operator|(
name|low
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|low
operator|==
literal|0
operator|&&
operator|(
name|high
operator|&
operator|(
name|high
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if EXPR is the real constant zero.  */
end_comment

begin_function
name|int
name|real_zerop
parameter_list|(
name|expr
parameter_list|)
name|tree
name|expr
decl_stmt|;
block|{
name|STRIP_NOPS
argument_list|(
name|expr
argument_list|)
expr_stmt|;
return|return
operator|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|REAL_CST
operator|&&
name|REAL_VALUES_EQUAL
argument_list|(
name|TREE_REAL_CST
argument_list|(
name|expr
argument_list|)
argument_list|,
name|dconst0
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if EXPR is the real constant one.  */
end_comment

begin_function
name|int
name|real_onep
parameter_list|(
name|expr
parameter_list|)
name|tree
name|expr
decl_stmt|;
block|{
name|STRIP_NOPS
argument_list|(
name|expr
argument_list|)
expr_stmt|;
return|return
operator|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|REAL_CST
operator|&&
name|REAL_VALUES_EQUAL
argument_list|(
name|TREE_REAL_CST
argument_list|(
name|expr
argument_list|)
argument_list|,
name|dconst1
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if EXPR is the real constant two.  */
end_comment

begin_function
name|int
name|real_twop
parameter_list|(
name|expr
parameter_list|)
name|tree
name|expr
decl_stmt|;
block|{
name|STRIP_NOPS
argument_list|(
name|expr
argument_list|)
expr_stmt|;
return|return
operator|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|REAL_CST
operator|&&
name|REAL_VALUES_EQUAL
argument_list|(
name|TREE_REAL_CST
argument_list|(
name|expr
argument_list|)
argument_list|,
name|dconst2
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Nonzero if EXP is a constant or a cast of a constant.  */
end_comment

begin_function
name|int
name|really_constant_p
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
comment|/* This is not quite the same as STRIP_NOPS.  It does more.  */
while|while
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|NOP_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|CONVERT_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|NON_LVALUE_EXPR
condition|)
name|exp
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|TREE_CONSTANT
argument_list|(
name|exp
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return first list element whose TREE_VALUE is ELEM.    Return 0 if ELEM is not it LIST.  */
end_comment

begin_function
name|tree
name|value_member
parameter_list|(
name|elem
parameter_list|,
name|list
parameter_list|)
name|tree
name|elem
decl_stmt|,
name|list
decl_stmt|;
block|{
while|while
condition|(
name|list
condition|)
block|{
if|if
condition|(
name|elem
operator|==
name|TREE_VALUE
argument_list|(
name|list
argument_list|)
condition|)
return|return
name|list
return|;
name|list
operator|=
name|TREE_CHAIN
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Return first list element whose TREE_PURPOSE is ELEM.    Return 0 if ELEM is not it LIST.  */
end_comment

begin_function
name|tree
name|purpose_member
parameter_list|(
name|elem
parameter_list|,
name|list
parameter_list|)
name|tree
name|elem
decl_stmt|,
name|list
decl_stmt|;
block|{
while|while
condition|(
name|list
condition|)
block|{
if|if
condition|(
name|elem
operator|==
name|TREE_PURPOSE
argument_list|(
name|list
argument_list|)
condition|)
return|return
name|list
return|;
name|list
operator|=
name|TREE_CHAIN
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Return first list element whose BINFO_TYPE is ELEM.    Return 0 if ELEM is not it LIST.  */
end_comment

begin_function
name|tree
name|binfo_member
parameter_list|(
name|elem
parameter_list|,
name|list
parameter_list|)
name|tree
name|elem
decl_stmt|,
name|list
decl_stmt|;
block|{
while|while
condition|(
name|list
condition|)
block|{
if|if
condition|(
name|elem
operator|==
name|BINFO_TYPE
argument_list|(
name|list
argument_list|)
condition|)
return|return
name|list
return|;
name|list
operator|=
name|TREE_CHAIN
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if ELEM is part of the chain CHAIN.  */
end_comment

begin_function
name|int
name|chain_member
parameter_list|(
name|elem
parameter_list|,
name|chain
parameter_list|)
name|tree
name|elem
decl_stmt|,
name|chain
decl_stmt|;
block|{
while|while
condition|(
name|chain
condition|)
block|{
if|if
condition|(
name|elem
operator|==
name|chain
condition|)
return|return
literal|1
return|;
name|chain
operator|=
name|TREE_CHAIN
argument_list|(
name|chain
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return the length of a chain of nodes chained through TREE_CHAIN.    We expect a null pointer to mark the end of the chain.    This is the Lisp primitive `length'.  */
end_comment

begin_function
name|int
name|list_length
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
specifier|register
name|tree
name|tail
decl_stmt|;
specifier|register
name|int
name|len
init|=
literal|0
decl_stmt|;
for|for
control|(
name|tail
operator|=
name|t
init|;
name|tail
condition|;
name|tail
operator|=
name|TREE_CHAIN
argument_list|(
name|tail
argument_list|)
control|)
name|len
operator|++
expr_stmt|;
return|return
name|len
return|;
block|}
end_function

begin_comment
comment|/* Concatenate two chains of nodes (chained through TREE_CHAIN)    by modifying the last node in chain 1 to point to chain 2.    This is the Lisp primitive `nconc'.  */
end_comment

begin_function
name|tree
name|chainon
parameter_list|(
name|op1
parameter_list|,
name|op2
parameter_list|)
name|tree
name|op1
decl_stmt|,
name|op2
decl_stmt|;
block|{
name|tree
name|t
decl_stmt|;
if|if
condition|(
name|op1
condition|)
block|{
for|for
control|(
name|t
operator|=
name|op1
init|;
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
if|if
condition|(
name|t
operator|==
name|op2
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Circularity being created */
if|if
condition|(
name|t
operator|==
name|op2
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Circularity being created */
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
operator|=
name|op2
expr_stmt|;
return|return
name|op1
return|;
block|}
else|else
return|return
name|op2
return|;
block|}
end_function

begin_comment
comment|/* Return the last node in a chain of nodes (chained through TREE_CHAIN).  */
end_comment

begin_function
name|tree
name|tree_last
parameter_list|(
name|chain
parameter_list|)
specifier|register
name|tree
name|chain
decl_stmt|;
block|{
specifier|register
name|tree
name|next
decl_stmt|;
if|if
condition|(
name|chain
condition|)
while|while
condition|(
name|next
operator|=
name|TREE_CHAIN
argument_list|(
name|chain
argument_list|)
condition|)
name|chain
operator|=
name|next
expr_stmt|;
return|return
name|chain
return|;
block|}
end_function

begin_comment
comment|/* Reverse the order of elements in the chain T,    and return the new head of the chain (old last element).  */
end_comment

begin_function
name|tree
name|nreverse
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
specifier|register
name|tree
name|prev
init|=
literal|0
decl_stmt|,
name|decl
decl_stmt|,
name|next
decl_stmt|;
for|for
control|(
name|decl
operator|=
name|t
init|;
name|decl
condition|;
name|decl
operator|=
name|next
control|)
block|{
name|next
operator|=
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
operator|=
name|prev
expr_stmt|;
name|prev
operator|=
name|decl
expr_stmt|;
block|}
return|return
name|prev
return|;
block|}
end_function

begin_comment
comment|/* Given a chain CHAIN of tree nodes,    construct and return a list of those nodes.  */
end_comment

begin_function
name|tree
name|listify
parameter_list|(
name|chain
parameter_list|)
name|tree
name|chain
decl_stmt|;
block|{
name|tree
name|result
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|in_tail
init|=
name|chain
decl_stmt|;
name|tree
name|out_tail
init|=
name|NULL_TREE
decl_stmt|;
while|while
condition|(
name|in_tail
condition|)
block|{
name|tree
name|next
init|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|in_tail
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
if|if
condition|(
name|out_tail
condition|)
name|TREE_CHAIN
argument_list|(
name|out_tail
argument_list|)
operator|=
name|next
expr_stmt|;
else|else
name|result
operator|=
name|next
expr_stmt|;
name|out_tail
operator|=
name|next
expr_stmt|;
name|in_tail
operator|=
name|TREE_CHAIN
argument_list|(
name|in_tail
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return a newly created TREE_LIST node whose    purpose and value fields are PARM and VALUE.  */
end_comment

begin_function
name|tree
name|build_tree_list
parameter_list|(
name|parm
parameter_list|,
name|value
parameter_list|)
name|tree
name|parm
decl_stmt|,
name|value
decl_stmt|;
block|{
specifier|register
name|tree
name|t
init|=
name|make_node
argument_list|(
name|TREE_LIST
argument_list|)
decl_stmt|;
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
operator|=
name|parm
expr_stmt|;
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
operator|=
name|value
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Similar, but build on the temp_decl_obstack.  */
end_comment

begin_function
name|tree
name|build_decl_list
parameter_list|(
name|parm
parameter_list|,
name|value
parameter_list|)
name|tree
name|parm
decl_stmt|,
name|value
decl_stmt|;
block|{
specifier|register
name|tree
name|node
decl_stmt|;
specifier|register
name|struct
name|obstack
modifier|*
name|ambient_obstack
init|=
name|current_obstack
decl_stmt|;
name|current_obstack
operator|=
operator|&
name|temp_decl_obstack
expr_stmt|;
name|node
operator|=
name|build_tree_list
argument_list|(
name|parm
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|current_obstack
operator|=
name|ambient_obstack
expr_stmt|;
return|return
name|node
return|;
block|}
end_function

begin_comment
comment|/* Return a newly created TREE_LIST node whose    purpose and value fields are PARM and VALUE    and whose TREE_CHAIN is CHAIN.  */
end_comment

begin_function
name|tree
name|tree_cons
parameter_list|(
name|purpose
parameter_list|,
name|value
parameter_list|,
name|chain
parameter_list|)
name|tree
name|purpose
decl_stmt|,
name|value
decl_stmt|,
name|chain
decl_stmt|;
block|{
if|#
directive|if
literal|0
block|register tree node = make_node (TREE_LIST);
else|#
directive|else
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|tree
name|node
init|=
operator|(
name|tree
operator|)
name|obstack_alloc
argument_list|(
name|current_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tree_list
argument_list|)
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|tree_node_counts
index|[
operator|(
name|int
operator|)
name|x_kind
index|]
operator|++
expr_stmt|;
name|tree_node_sizes
index|[
operator|(
name|int
operator|)
name|x_kind
index|]
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|tree_list
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|tree_common
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
operator|(
operator|(
name|int
operator|*
operator|)
name|node
operator|)
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|TREE_SET_CODE
argument_list|(
name|node
argument_list|,
name|TREE_LIST
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_obstack
operator|==
operator|&
name|permanent_obstack
condition|)
name|TREE_PERMANENT
argument_list|(
name|node
argument_list|)
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
name|TREE_CHAIN
argument_list|(
name|node
argument_list|)
operator|=
name|chain
expr_stmt|;
name|TREE_PURPOSE
argument_list|(
name|node
argument_list|)
operator|=
name|purpose
expr_stmt|;
name|TREE_VALUE
argument_list|(
name|node
argument_list|)
operator|=
name|value
expr_stmt|;
return|return
name|node
return|;
block|}
end_function

begin_comment
comment|/* Similar, but build on the temp_decl_obstack.  */
end_comment

begin_function
name|tree
name|decl_tree_cons
parameter_list|(
name|purpose
parameter_list|,
name|value
parameter_list|,
name|chain
parameter_list|)
name|tree
name|purpose
decl_stmt|,
name|value
decl_stmt|,
name|chain
decl_stmt|;
block|{
specifier|register
name|tree
name|node
decl_stmt|;
specifier|register
name|struct
name|obstack
modifier|*
name|ambient_obstack
init|=
name|current_obstack
decl_stmt|;
name|current_obstack
operator|=
operator|&
name|temp_decl_obstack
expr_stmt|;
name|node
operator|=
name|tree_cons
argument_list|(
name|purpose
argument_list|,
name|value
argument_list|,
name|chain
argument_list|)
expr_stmt|;
name|current_obstack
operator|=
name|ambient_obstack
expr_stmt|;
return|return
name|node
return|;
block|}
end_function

begin_comment
comment|/* Same as `tree_cons' but make a permanent object.  */
end_comment

begin_function
name|tree
name|perm_tree_cons
parameter_list|(
name|purpose
parameter_list|,
name|value
parameter_list|,
name|chain
parameter_list|)
name|tree
name|purpose
decl_stmt|,
name|value
decl_stmt|,
name|chain
decl_stmt|;
block|{
specifier|register
name|tree
name|node
decl_stmt|;
specifier|register
name|struct
name|obstack
modifier|*
name|ambient_obstack
init|=
name|current_obstack
decl_stmt|;
name|current_obstack
operator|=
operator|&
name|permanent_obstack
expr_stmt|;
name|node
operator|=
name|tree_cons
argument_list|(
name|purpose
argument_list|,
name|value
argument_list|,
name|chain
argument_list|)
expr_stmt|;
name|current_obstack
operator|=
name|ambient_obstack
expr_stmt|;
return|return
name|node
return|;
block|}
end_function

begin_comment
comment|/* Same as `tree_cons', but make this node temporary, regardless.  */
end_comment

begin_function
name|tree
name|temp_tree_cons
parameter_list|(
name|purpose
parameter_list|,
name|value
parameter_list|,
name|chain
parameter_list|)
name|tree
name|purpose
decl_stmt|,
name|value
decl_stmt|,
name|chain
decl_stmt|;
block|{
specifier|register
name|tree
name|node
decl_stmt|;
specifier|register
name|struct
name|obstack
modifier|*
name|ambient_obstack
init|=
name|current_obstack
decl_stmt|;
name|current_obstack
operator|=
operator|&
name|temporary_obstack
expr_stmt|;
name|node
operator|=
name|tree_cons
argument_list|(
name|purpose
argument_list|,
name|value
argument_list|,
name|chain
argument_list|)
expr_stmt|;
name|current_obstack
operator|=
name|ambient_obstack
expr_stmt|;
return|return
name|node
return|;
block|}
end_function

begin_comment
comment|/* Same as `tree_cons', but save this node if the function's RTL is saved.  */
end_comment

begin_function
name|tree
name|saveable_tree_cons
parameter_list|(
name|purpose
parameter_list|,
name|value
parameter_list|,
name|chain
parameter_list|)
name|tree
name|purpose
decl_stmt|,
name|value
decl_stmt|,
name|chain
decl_stmt|;
block|{
specifier|register
name|tree
name|node
decl_stmt|;
specifier|register
name|struct
name|obstack
modifier|*
name|ambient_obstack
init|=
name|current_obstack
decl_stmt|;
name|current_obstack
operator|=
name|saveable_obstack
expr_stmt|;
name|node
operator|=
name|tree_cons
argument_list|(
name|purpose
argument_list|,
name|value
argument_list|,
name|chain
argument_list|)
expr_stmt|;
name|current_obstack
operator|=
name|ambient_obstack
expr_stmt|;
return|return
name|node
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the size nominally occupied by an object of type TYPE    when it resides in memory.  The value is measured in units of bytes,    and its data type is that normally used for type sizes    (which is the first type created by make_signed_type or    make_unsigned_type).  */
end_comment

begin_function
name|tree
name|size_in_bytes
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
return|return
name|integer_zero_node
return|;
name|type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|==
literal|0
condition|)
block|{
name|incomplete_type_error
argument_list|(
name|NULL_TREE
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|integer_zero_node
return|;
block|}
return|return
name|size_binop
argument_list|(
name|CEIL_DIV_EXPR
argument_list|,
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|,
name|size_int
argument_list|(
name|BITS_PER_UNIT
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return the size of TYPE (in bytes) as an integer,    or return -1 if the size can vary.  */
end_comment

begin_function
name|int
name|int_size_in_bytes
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|int
name|size
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
return|return
literal|0
return|;
name|type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
return|return
operator|-
literal|1
return|;
name|size
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|size
operator|+
name|BITS_PER_UNIT
operator|-
literal|1
operator|)
operator|/
name|BITS_PER_UNIT
return|;
block|}
end_function

begin_comment
comment|/* Return, as an INTEGER_CST node, the number of elements for    TYPE (which is an ARRAY_TYPE) minus one.     This counts only elements of the top array.  */
end_comment

begin_function
name|tree
name|array_type_nelts
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|index_type
init|=
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
decl_stmt|;
return|return
operator|(
name|tree_int_cst_equal
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|index_type
argument_list|)
argument_list|,
name|integer_zero_node
argument_list|)
condition|?
name|TYPE_MAX_VALUE
argument_list|(
name|index_type
argument_list|)
else|:
name|fold
argument_list|(
name|build
argument_list|(
name|MINUS_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|TYPE_MAX_VALUE
argument_list|(
name|index_type
argument_list|)
argument_list|,
name|TYPE_MIN_VALUE
argument_list|(
name|index_type
argument_list|)
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return nonzero if arg is static -- a reference to an object in    static storage.  This is not the same as the C meaning of `static'.  */
end_comment

begin_function
name|int
name|staticp
parameter_list|(
name|arg
parameter_list|)
name|tree
name|arg
decl_stmt|;
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
condition|)
block|{
case|case
name|VAR_DECL
case|:
case|case
name|FUNCTION_DECL
case|:
case|case
name|CONSTRUCTOR
case|:
return|return
name|TREE_STATIC
argument_list|(
name|arg
argument_list|)
operator|||
name|DECL_EXTERNAL
argument_list|(
name|arg
argument_list|)
return|;
case|case
name|STRING_CST
case|:
return|return
literal|1
return|;
case|case
name|COMPONENT_REF
case|:
case|case
name|BIT_FIELD_REF
case|:
return|return
name|staticp
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
case|case
name|INDIRECT_REF
case|:
return|return
name|TREE_CONSTANT
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
case|case
name|ARRAY_REF
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
condition|)
return|return
name|staticp
argument_list|(
name|TREE_OPERAND
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This should be applied to any node which may be used in more than one place,    but must be evaluated only once.  Normally, the code generator would    reevaluate the node each time; this forces it to compute it once and save    the result.  This is done by encapsulating the node in a SAVE_EXPR.  */
end_comment

begin_function
name|tree
name|save_expr
parameter_list|(
name|expr
parameter_list|)
name|tree
name|expr
decl_stmt|;
block|{
specifier|register
name|tree
name|t
init|=
name|fold
argument_list|(
name|expr
argument_list|)
decl_stmt|;
comment|/* We don't care about whether this can be used as an lvalue in this      context.  */
while|while
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|NON_LVALUE_EXPR
condition|)
name|t
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If the tree evaluates to a constant, then we don't want to hide that      fact (i.e. this allows further folding, and direct checks for constants).      However, a read-only object that has side effects cannot be bypassed.      Since it is no problem to reevaluate literals, we just return the       literal node. */
if|if
condition|(
name|TREE_CONSTANT
argument_list|(
name|t
argument_list|)
operator|||
operator|(
name|TREE_READONLY
argument_list|(
name|t
argument_list|)
operator|&&
operator|!
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
operator|)
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|SAVE_EXPR
condition|)
return|return
name|t
return|;
name|t
operator|=
name|build
argument_list|(
name|SAVE_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|,
name|t
argument_list|,
name|current_function_decl
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* This expression might be placed ahead of a jump to ensure that the      value was computed on both sides of the jump.  So make sure it isn't      eliminated as dead.  */
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Stabilize a reference so that we can use it any number of times    without causing its operands to be evaluated more than once.    Returns the stabilized reference.     Also allows conversion expressions whose operands are references.    Any other kind of expression is returned unchanged.  */
end_comment

begin_function
name|tree
name|stabilize_reference
parameter_list|(
name|ref
parameter_list|)
name|tree
name|ref
decl_stmt|;
block|{
specifier|register
name|tree
name|result
decl_stmt|;
specifier|register
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|ref
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|VAR_DECL
case|:
case|case
name|PARM_DECL
case|:
case|case
name|RESULT_DECL
case|:
comment|/* No action is needed in this case.  */
return|return
name|ref
return|;
case|case
name|NOP_EXPR
case|:
case|case
name|CONVERT_EXPR
case|:
case|case
name|FLOAT_EXPR
case|:
case|case
name|FIX_TRUNC_EXPR
case|:
case|case
name|FIX_FLOOR_EXPR
case|:
case|case
name|FIX_ROUND_EXPR
case|:
case|case
name|FIX_CEIL_EXPR
case|:
name|result
operator|=
name|build_nt
argument_list|(
name|code
argument_list|,
name|stabilize_reference
argument_list|(
name|TREE_OPERAND
argument_list|(
name|ref
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|INDIRECT_REF
case|:
name|result
operator|=
name|build_nt
argument_list|(
name|INDIRECT_REF
argument_list|,
name|stabilize_reference_1
argument_list|(
name|TREE_OPERAND
argument_list|(
name|ref
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|COMPONENT_REF
case|:
name|result
operator|=
name|build_nt
argument_list|(
name|COMPONENT_REF
argument_list|,
name|stabilize_reference
argument_list|(
name|TREE_OPERAND
argument_list|(
name|ref
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|ref
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|BIT_FIELD_REF
case|:
name|result
operator|=
name|build_nt
argument_list|(
name|BIT_FIELD_REF
argument_list|,
name|stabilize_reference
argument_list|(
name|TREE_OPERAND
argument_list|(
name|ref
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|stabilize_reference_1
argument_list|(
name|TREE_OPERAND
argument_list|(
name|ref
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|stabilize_reference_1
argument_list|(
name|TREE_OPERAND
argument_list|(
name|ref
argument_list|,
literal|2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ARRAY_REF
case|:
name|result
operator|=
name|build_nt
argument_list|(
name|ARRAY_REF
argument_list|,
name|stabilize_reference
argument_list|(
name|TREE_OPERAND
argument_list|(
name|ref
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|stabilize_reference_1
argument_list|(
name|TREE_OPERAND
argument_list|(
name|ref
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
comment|/* If arg isn't a kind of lvalue we recognize, make no change. 	 Caller should recognize the error for an invalid lvalue.  */
default|default:
return|return
name|ref
return|;
case|case
name|ERROR_MARK
case|:
return|return
name|error_mark_node
return|;
block|}
name|TREE_TYPE
argument_list|(
name|result
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|ref
argument_list|)
expr_stmt|;
name|TREE_READONLY
argument_list|(
name|result
argument_list|)
operator|=
name|TREE_READONLY
argument_list|(
name|ref
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|result
argument_list|)
operator|=
name|TREE_SIDE_EFFECTS
argument_list|(
name|ref
argument_list|)
expr_stmt|;
name|TREE_THIS_VOLATILE
argument_list|(
name|result
argument_list|)
operator|=
name|TREE_THIS_VOLATILE
argument_list|(
name|ref
argument_list|)
expr_stmt|;
name|TREE_RAISES
argument_list|(
name|result
argument_list|)
operator|=
name|TREE_RAISES
argument_list|(
name|ref
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of stabilize_reference; this is called for subtrees of    references.  Any expression with side-effects must be put in a SAVE_EXPR    to ensure that it is only evaluated once.     We don't put SAVE_EXPR nodes around everything, because assigning very    simple expressions to temporaries causes us to miss good opportunities    for optimizations.  Among other things, the opportunity to fold in the    addition of a constant into an addressing mode often gets lost, e.g.    "y[i+1] += x;".  In general, we take the approach that we should not make    an assignment unless we are forced into it - i.e., that any non-side effect    operator should be allowed, and that cse should take care of coalescing    multiple utterances of the same expression should that prove fruitful.  */
end_comment

begin_function
specifier|static
name|tree
name|stabilize_reference_1
parameter_list|(
name|e
parameter_list|)
name|tree
name|e
decl_stmt|;
block|{
specifier|register
name|tree
name|result
decl_stmt|;
specifier|register
name|int
name|length
decl_stmt|;
specifier|register
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|e
argument_list|)
decl_stmt|;
comment|/* We cannot ignore const expressions because it might be a reference      to a const array but whose index contains side-effects.  But we can      ignore things that are actual constant or that already have been      handled by this function.  */
if|if
condition|(
name|TREE_CONSTANT
argument_list|(
name|e
argument_list|)
operator|||
name|code
operator|==
name|SAVE_EXPR
condition|)
return|return
name|e
return|;
switch|switch
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
condition|)
block|{
case|case
literal|'x'
case|:
case|case
literal|'t'
case|:
case|case
literal|'d'
case|:
case|case
literal|'b'
case|:
case|case
literal|'<'
case|:
case|case
literal|'s'
case|:
case|case
literal|'e'
case|:
case|case
literal|'r'
case|:
comment|/* If the expression has side-effects, then encase it in a SAVE_EXPR 	 so that it will only be evaluated once.  */
comment|/* The reference (r) and comparison (<) classes could be handled as 	 below, but it is generally faster to only evaluate them once.  */
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|e
argument_list|)
condition|)
return|return
name|save_expr
argument_list|(
name|e
argument_list|)
return|;
return|return
name|e
return|;
case|case
literal|'c'
case|:
comment|/* Constants need no processing.  In fact, we should never reach 	 here.  */
return|return
name|e
return|;
case|case
literal|'2'
case|:
comment|/* Recursively stabilize each operand.  */
name|result
operator|=
name|build_nt
argument_list|(
name|code
argument_list|,
name|stabilize_reference_1
argument_list|(
name|TREE_OPERAND
argument_list|(
name|e
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|stabilize_reference_1
argument_list|(
name|TREE_OPERAND
argument_list|(
name|e
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'1'
case|:
comment|/* Recursively stabilize each operand.  */
name|result
operator|=
name|build_nt
argument_list|(
name|code
argument_list|,
name|stabilize_reference_1
argument_list|(
name|TREE_OPERAND
argument_list|(
name|e
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|TREE_TYPE
argument_list|(
name|result
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|TREE_READONLY
argument_list|(
name|result
argument_list|)
operator|=
name|TREE_READONLY
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|result
argument_list|)
operator|=
name|TREE_SIDE_EFFECTS
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|TREE_THIS_VOLATILE
argument_list|(
name|result
argument_list|)
operator|=
name|TREE_THIS_VOLATILE
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|TREE_RAISES
argument_list|(
name|result
argument_list|)
operator|=
name|TREE_RAISES
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Low-level constructors for expressions.  */
end_comment

begin_comment
comment|/* Build an expression of code CODE, data type TYPE,    and operands as specified by the arguments ARG1 and following arguments.    Expressions and reference nodes can be created this way.    Constants, decls, types and misc nodes cannot be.  */
end_comment

begin_function
name|tree
name|build
parameter_list|(
name|va_alist
parameter_list|)
function|va_dcl
block|{
name|va_list
name|p
decl_stmt|;
name|enum
name|tree_code
name|code
decl_stmt|;
specifier|register
name|tree
name|t
decl_stmt|;
specifier|register
name|int
name|length
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|va_start
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|code
operator|=
name|va_arg
argument_list|(
name|p
argument_list|,
expr|enum
name|tree_code
argument_list|)
expr_stmt|;
name|t
operator|=
name|make_node
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|length
operator|=
name|tree_code_length
index|[
operator|(
name|int
operator|)
name|code
index|]
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|va_arg
argument_list|(
name|p
argument_list|,
name|tree
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|==
literal|2
condition|)
block|{
comment|/* This is equivalent to the loop below, but faster.  */
specifier|register
name|tree
name|arg0
init|=
name|va_arg
argument_list|(
name|p
argument_list|,
name|tree
argument_list|)
decl_stmt|;
specifier|register
name|tree
name|arg1
init|=
name|va_arg
argument_list|(
name|p
argument_list|,
name|tree
argument_list|)
decl_stmt|;
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
operator|=
name|arg0
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
operator|=
name|arg1
expr_stmt|;
if|if
condition|(
operator|(
name|arg0
operator|&&
name|TREE_SIDE_EFFECTS
argument_list|(
name|arg0
argument_list|)
operator|)
operator|||
operator|(
name|arg1
operator|&&
name|TREE_SIDE_EFFECTS
argument_list|(
name|arg1
argument_list|)
operator|)
condition|)
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_RAISES
argument_list|(
name|t
argument_list|)
operator|=
operator|(
name|arg0
operator|&&
name|TREE_RAISES
argument_list|(
name|arg0
argument_list|)
operator|)
operator|||
operator|(
name|arg1
operator|&&
name|TREE_RAISES
argument_list|(
name|arg1
argument_list|)
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|length
operator|==
literal|1
condition|)
block|{
specifier|register
name|tree
name|arg0
init|=
name|va_arg
argument_list|(
name|p
argument_list|,
name|tree
argument_list|)
decl_stmt|;
comment|/* Call build1 for this!  */
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|!=
literal|'s'
condition|)
name|abort
argument_list|()
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
operator|=
name|arg0
expr_stmt|;
if|if
condition|(
name|arg0
operator|&&
name|TREE_SIDE_EFFECTS
argument_list|(
name|arg0
argument_list|)
condition|)
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_RAISES
argument_list|(
name|t
argument_list|)
operator|=
operator|(
name|arg0
operator|&&
name|TREE_RAISES
argument_list|(
name|arg0
argument_list|)
operator|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
block|{
specifier|register
name|tree
name|operand
init|=
name|va_arg
argument_list|(
name|p
argument_list|,
name|tree
argument_list|)
decl_stmt|;
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
operator|=
name|operand
expr_stmt|;
if|if
condition|(
name|operand
condition|)
block|{
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|operand
argument_list|)
condition|)
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TREE_RAISES
argument_list|(
name|operand
argument_list|)
condition|)
name|TREE_RAISES
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
name|va_end
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Same as above, but only builds for unary operators.    Saves lions share of calls to `build'; cuts down use    of varargs, which is expensive for RISC machines.  */
end_comment

begin_function
name|tree
name|build1
parameter_list|(
name|code
parameter_list|,
name|type
parameter_list|,
name|node
parameter_list|)
name|enum
name|tree_code
name|code
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|tree
name|node
decl_stmt|;
block|{
specifier|register
name|struct
name|obstack
modifier|*
name|obstack
init|=
name|current_obstack
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|length
decl_stmt|;
specifier|register
name|tree_node_kind
name|kind
decl_stmt|;
specifier|register
name|tree
name|t
decl_stmt|;
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'r'
condition|)
name|kind
operator|=
name|r_kind
expr_stmt|;
else|else
name|kind
operator|=
name|e_kind
expr_stmt|;
endif|#
directive|endif
name|obstack
operator|=
name|expression_obstack
expr_stmt|;
name|length
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|tree_exp
argument_list|)
expr_stmt|;
name|t
operator|=
operator|(
name|tree
operator|)
name|obstack_alloc
argument_list|(
name|obstack
argument_list|,
name|length
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|tree_node_counts
index|[
operator|(
name|int
operator|)
name|kind
index|]
operator|++
expr_stmt|;
name|tree_node_sizes
index|[
operator|(
name|int
operator|)
name|kind
index|]
operator|+=
name|length
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
operator|(
name|length
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
operator|(
operator|(
name|int
operator|*
operator|)
name|t
operator|)
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|type
expr_stmt|;
name|TREE_SET_CODE
argument_list|(
name|t
argument_list|,
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
name|obstack
operator|==
operator|&
name|permanent_obstack
condition|)
name|TREE_PERMANENT
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
operator|=
name|node
expr_stmt|;
if|if
condition|(
name|node
condition|)
block|{
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|node
argument_list|)
condition|)
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TREE_RAISES
argument_list|(
name|node
argument_list|)
condition|)
name|TREE_RAISES
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Similar except don't specify the TREE_TYPE    and leave the TREE_SIDE_EFFECTS as 0.    It is permissible for arguments to be null,    or even garbage if their values do not matter.  */
end_comment

begin_function
name|tree
name|build_nt
parameter_list|(
name|va_alist
parameter_list|)
function|va_dcl
block|{
name|va_list
name|p
decl_stmt|;
specifier|register
name|enum
name|tree_code
name|code
decl_stmt|;
specifier|register
name|tree
name|t
decl_stmt|;
specifier|register
name|int
name|length
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|va_start
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|code
operator|=
name|va_arg
argument_list|(
name|p
argument_list|,
expr|enum
name|tree_code
argument_list|)
expr_stmt|;
name|t
operator|=
name|make_node
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|length
operator|=
name|tree_code_length
index|[
operator|(
name|int
operator|)
name|code
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
operator|=
name|va_arg
argument_list|(
name|p
argument_list|,
name|tree
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Similar to `build_nt', except we build    on the temp_decl_obstack, regardless.  */
end_comment

begin_function
name|tree
name|build_parse_node
parameter_list|(
name|va_alist
parameter_list|)
function|va_dcl
block|{
specifier|register
name|struct
name|obstack
modifier|*
name|ambient_obstack
init|=
name|expression_obstack
decl_stmt|;
name|va_list
name|p
decl_stmt|;
specifier|register
name|enum
name|tree_code
name|code
decl_stmt|;
specifier|register
name|tree
name|t
decl_stmt|;
specifier|register
name|int
name|length
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|expression_obstack
operator|=
operator|&
name|temp_decl_obstack
expr_stmt|;
name|va_start
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|code
operator|=
name|va_arg
argument_list|(
name|p
argument_list|,
expr|enum
name|tree_code
argument_list|)
expr_stmt|;
name|t
operator|=
name|make_node
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|length
operator|=
name|tree_code_length
index|[
operator|(
name|int
operator|)
name|code
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
operator|=
name|va_arg
argument_list|(
name|p
argument_list|,
name|tree
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|expression_obstack
operator|=
name|ambient_obstack
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Commented out because this wants to be done very    differently.  See cp-lex.c.  */
end_comment

begin_endif
unit|tree build_op_identifier (op1, op2)      tree op1, op2; {   register tree t = make_node (OP_IDENTIFIER);   TREE_PURPOSE (t) = op1;   TREE_VALUE (t) = op2;   return t; }
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Create a DECL_... node of code CODE, name NAME and data type TYPE.    We do NOT enter this node in any sort of symbol table.     layout_decl is used to set up the decl's storage layout.    Other slots are initialized to 0 or null pointers.  */
end_comment

begin_function
name|tree
name|build_decl
parameter_list|(
name|code
parameter_list|,
name|name
parameter_list|,
name|type
parameter_list|)
name|enum
name|tree_code
name|code
decl_stmt|;
name|tree
name|name
decl_stmt|,
name|type
decl_stmt|;
block|{
specifier|register
name|tree
name|t
decl_stmt|;
name|t
operator|=
name|make_node
argument_list|(
name|code
argument_list|)
expr_stmt|;
comment|/*  if (type == error_mark_node)     type = integer_type_node; */
comment|/* That is not done, deliberately, so that having error_mark_node    as the type can suppress useless errors in the use of this variable.  */
name|DECL_NAME
argument_list|(
name|t
argument_list|)
operator|=
name|name
expr_stmt|;
name|DECL_ASSEMBLER_NAME
argument_list|(
name|t
argument_list|)
operator|=
name|name
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|type
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|VAR_DECL
operator|||
name|code
operator|==
name|PARM_DECL
operator|||
name|code
operator|==
name|RESULT_DECL
condition|)
name|layout_decl
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|FUNCTION_DECL
condition|)
name|DECL_MODE
argument_list|(
name|t
argument_list|)
operator|=
name|FUNCTION_MODE
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* BLOCK nodes are used to represent the structure of binding contours    and declarations, once those contours have been exited and their contents    compiled.  This information is used for outputting debugging info.  */
end_comment

begin_function
name|tree
name|build_block
parameter_list|(
name|vars
parameter_list|,
name|tags
parameter_list|,
name|subblocks
parameter_list|,
name|supercontext
parameter_list|,
name|chain
parameter_list|)
name|tree
name|vars
decl_stmt|,
name|tags
decl_stmt|,
name|subblocks
decl_stmt|,
name|supercontext
decl_stmt|,
name|chain
decl_stmt|;
block|{
specifier|register
name|tree
name|block
init|=
name|make_node
argument_list|(
name|BLOCK
argument_list|)
decl_stmt|;
name|BLOCK_VARS
argument_list|(
name|block
argument_list|)
operator|=
name|vars
expr_stmt|;
name|BLOCK_TYPE_TAGS
argument_list|(
name|block
argument_list|)
operator|=
name|tags
expr_stmt|;
name|BLOCK_SUBBLOCKS
argument_list|(
name|block
argument_list|)
operator|=
name|subblocks
expr_stmt|;
name|BLOCK_SUPERCONTEXT
argument_list|(
name|block
argument_list|)
operator|=
name|supercontext
expr_stmt|;
name|BLOCK_CHAIN
argument_list|(
name|block
argument_list|)
operator|=
name|chain
expr_stmt|;
return|return
name|block
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return a type like TYPE except that its TYPE_READONLY is CONSTP    and its TYPE_VOLATILE is VOLATILEP.     Such variant types already made are recorded so that duplicates    are not made.     A variant types should never be used as the type of an expression.    Always copy the variant information into the TREE_READONLY    and TREE_THIS_VOLATILE of the expression, and then give the expression    as its type the "main variant", the variant whose TYPE_READONLY    and TYPE_VOLATILE are zero.  Use TYPE_MAIN_VARIANT to find the    main variant.  */
end_comment

begin_function
name|tree
name|build_type_variant
parameter_list|(
name|type
parameter_list|,
name|constp
parameter_list|,
name|volatilep
parameter_list|)
name|tree
name|type
decl_stmt|;
name|int
name|constp
decl_stmt|,
name|volatilep
decl_stmt|;
block|{
specifier|register
name|tree
name|t
decl_stmt|,
name|m
init|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|obstack
modifier|*
name|ambient_obstack
init|=
name|current_obstack
decl_stmt|;
comment|/* Treat any nonzero argument as 1.  */
name|constp
operator|=
operator|!
operator|!
name|constp
expr_stmt|;
name|volatilep
operator|=
operator|!
operator|!
name|volatilep
expr_stmt|;
comment|/* If not generating auxiliary info, search the chain of variants to see      if there is already one there just like the one we need to have.  If so,      use that existing one.       We don't do this in the case where we are generating aux info because      in that case we want each typedef names to get it's own distinct type      node, even if the type of this new typedef is the same as some other      (existing) type.  */
if|if
condition|(
operator|!
name|flag_gen_aux_info
condition|)
for|for
control|(
name|t
operator|=
name|m
init|;
name|t
condition|;
name|t
operator|=
name|TYPE_NEXT_VARIANT
argument_list|(
name|t
argument_list|)
control|)
if|if
condition|(
name|constp
operator|==
name|TYPE_READONLY
argument_list|(
name|t
argument_list|)
operator|&&
name|volatilep
operator|==
name|TYPE_VOLATILE
argument_list|(
name|t
argument_list|)
condition|)
return|return
name|t
return|;
comment|/* We need a new one.  */
name|current_obstack
operator|=
name|TREE_PERMANENT
argument_list|(
name|type
argument_list|)
condition|?
operator|&
name|permanent_obstack
else|:
name|saveable_obstack
expr_stmt|;
name|t
operator|=
name|copy_node
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|TYPE_READONLY
argument_list|(
name|t
argument_list|)
operator|=
name|constp
expr_stmt|;
name|TYPE_VOLATILE
argument_list|(
name|t
argument_list|)
operator|=
name|volatilep
expr_stmt|;
name|TYPE_POINTER_TO
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TYPE_REFERENCE_TO
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Add this type to the chain of variants of TYPE.  */
name|TYPE_NEXT_VARIANT
argument_list|(
name|t
argument_list|)
operator|=
name|TYPE_NEXT_VARIANT
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|TYPE_NEXT_VARIANT
argument_list|(
name|m
argument_list|)
operator|=
name|t
expr_stmt|;
name|current_obstack
operator|=
name|ambient_obstack
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Create a new variant of TYPE, equivalent but distinct.    This is so the caller can modify it.  */
end_comment

begin_function
name|tree
name|build_type_copy
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
specifier|register
name|tree
name|t
decl_stmt|,
name|m
init|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|obstack
modifier|*
name|ambient_obstack
init|=
name|current_obstack
decl_stmt|;
name|current_obstack
operator|=
name|TREE_PERMANENT
argument_list|(
name|type
argument_list|)
condition|?
operator|&
name|permanent_obstack
else|:
name|saveable_obstack
expr_stmt|;
name|t
operator|=
name|copy_node
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|TYPE_POINTER_TO
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TYPE_REFERENCE_TO
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Add this type to the chain of variants of TYPE.  */
name|TYPE_NEXT_VARIANT
argument_list|(
name|t
argument_list|)
operator|=
name|TYPE_NEXT_VARIANT
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|TYPE_NEXT_VARIANT
argument_list|(
name|m
argument_list|)
operator|=
name|t
expr_stmt|;
name|current_obstack
operator|=
name|ambient_obstack
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Hashing of types so that we don't make duplicates.    The entry point is `type_hash_canon'.  */
end_comment

begin_comment
comment|/* Each hash table slot is a bucket containing a chain    of these structures.  */
end_comment

begin_struct
struct|struct
name|type_hash
block|{
name|struct
name|type_hash
modifier|*
name|next
decl_stmt|;
comment|/* Next structure in the bucket.  */
name|int
name|hashcode
decl_stmt|;
comment|/* Hash code of this type.  */
name|tree
name|type
decl_stmt|;
comment|/* The type recorded here.  */
block|}
struct|;
end_struct

begin_comment
comment|/* Now here is the hash table.  When recording a type, it is added    to the slot whose index is the hash code mod the table size.    Note that the hash table is used for several kinds of types    (function types, array types and array index range types, for now).    While all these live in the same table, they are completely independent,    and the hash code is computed differently for each of these.  */
end_comment

begin_define
define|#
directive|define
name|TYPE_HASH_SIZE
value|59
end_define

begin_decl_stmt
name|struct
name|type_hash
modifier|*
name|type_hash_table
index|[
name|TYPE_HASH_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Here is how primitive or already-canonicalized types' hash    codes are made.  */
end_comment

begin_define
define|#
directive|define
name|TYPE_HASH
parameter_list|(
name|TYPE
parameter_list|)
value|((HOST_WIDE_INT) (TYPE)& 0777777)
end_define

begin_comment
comment|/* Compute a hash code for a list of types (chain of TREE_LIST nodes    with types in the TREE_VALUE slots), by adding the hash codes    of the individual types.  */
end_comment

begin_function
name|int
name|type_hash_list
parameter_list|(
name|list
parameter_list|)
name|tree
name|list
decl_stmt|;
block|{
specifier|register
name|int
name|hashcode
decl_stmt|;
specifier|register
name|tree
name|tail
decl_stmt|;
for|for
control|(
name|hashcode
operator|=
literal|0
operator|,
name|tail
operator|=
name|list
init|;
name|tail
condition|;
name|tail
operator|=
name|TREE_CHAIN
argument_list|(
name|tail
argument_list|)
control|)
name|hashcode
operator|+=
name|TYPE_HASH
argument_list|(
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|hashcode
return|;
block|}
end_function

begin_comment
comment|/* Look in the type hash table for a type isomorphic to TYPE.    If one is found, return it.  Otherwise return 0.  */
end_comment

begin_function
name|tree
name|type_hash_lookup
parameter_list|(
name|hashcode
parameter_list|,
name|type
parameter_list|)
name|int
name|hashcode
decl_stmt|;
name|tree
name|type
decl_stmt|;
block|{
specifier|register
name|struct
name|type_hash
modifier|*
name|h
decl_stmt|;
for|for
control|(
name|h
operator|=
name|type_hash_table
index|[
name|hashcode
operator|%
name|TYPE_HASH_SIZE
index|]
init|;
name|h
condition|;
name|h
operator|=
name|h
operator|->
name|next
control|)
if|if
condition|(
name|h
operator|->
name|hashcode
operator|==
name|hashcode
operator|&&
name|TREE_CODE
argument_list|(
name|h
operator|->
name|type
argument_list|)
operator|==
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|&&
name|TREE_TYPE
argument_list|(
name|h
operator|->
name|type
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
operator|&&
operator|(
name|TYPE_MAX_VALUE
argument_list|(
name|h
operator|->
name|type
argument_list|)
operator|==
name|TYPE_MAX_VALUE
argument_list|(
name|type
argument_list|)
operator|||
name|tree_int_cst_equal
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|h
operator|->
name|type
argument_list|)
argument_list|,
name|TYPE_MAX_VALUE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
name|TYPE_MIN_VALUE
argument_list|(
name|h
operator|->
name|type
argument_list|)
operator|==
name|TYPE_MIN_VALUE
argument_list|(
name|type
argument_list|)
operator|||
name|tree_int_cst_equal
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|h
operator|->
name|type
argument_list|)
argument_list|,
name|TYPE_MIN_VALUE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
name|TYPE_DOMAIN
argument_list|(
name|h
operator|->
name|type
argument_list|)
operator|==
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
operator|||
operator|(
name|TYPE_DOMAIN
argument_list|(
name|h
operator|->
name|type
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|h
operator|->
name|type
argument_list|)
argument_list|)
operator|==
name|TREE_LIST
operator|&&
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|TREE_LIST
operator|&&
name|type_list_equal
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|h
operator|->
name|type
argument_list|)
argument_list|,
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
return|return
name|h
operator|->
name|type
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Add an entry to the type-hash-table    for a type TYPE whose hash code is HASHCODE.  */
end_comment

begin_function
name|void
name|type_hash_add
parameter_list|(
name|hashcode
parameter_list|,
name|type
parameter_list|)
name|int
name|hashcode
decl_stmt|;
name|tree
name|type
decl_stmt|;
block|{
specifier|register
name|struct
name|type_hash
modifier|*
name|h
decl_stmt|;
name|h
operator|=
operator|(
expr|struct
name|type_hash
operator|*
operator|)
name|oballoc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|type_hash
argument_list|)
argument_list|)
expr_stmt|;
name|h
operator|->
name|hashcode
operator|=
name|hashcode
expr_stmt|;
name|h
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|h
operator|->
name|next
operator|=
name|type_hash_table
index|[
name|hashcode
operator|%
name|TYPE_HASH_SIZE
index|]
expr_stmt|;
name|type_hash_table
index|[
name|hashcode
operator|%
name|TYPE_HASH_SIZE
index|]
operator|=
name|h
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given TYPE, and HASHCODE its hash code, return the canonical    object for an identical type if one already exists.    Otherwise, return TYPE, and record it as the canonical object    if it is a permanent object.     To use this function, first create a type of the sort you want.    Then compute its hash code from the fields of the type that    make it different from other similar types.    Then call this function and use the value.    This function frees the type you pass in if it is a duplicate.  */
end_comment

begin_comment
comment|/* Set to 1 to debug without canonicalization.  Never set by program.  */
end_comment

begin_decl_stmt
name|int
name|debug_no_type_hash
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|tree
name|type_hash_canon
parameter_list|(
name|hashcode
parameter_list|,
name|type
parameter_list|)
name|int
name|hashcode
decl_stmt|;
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|t1
decl_stmt|;
if|if
condition|(
name|debug_no_type_hash
condition|)
return|return
name|type
return|;
name|t1
operator|=
name|type_hash_lookup
argument_list|(
name|hashcode
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|t1
operator|!=
literal|0
condition|)
block|{
name|struct
name|obstack
modifier|*
name|o
init|=
name|TREE_PERMANENT
argument_list|(
name|type
argument_list|)
condition|?
operator|&
name|permanent_obstack
else|:
name|saveable_obstack
decl_stmt|;
name|obstack_free
argument_list|(
name|o
argument_list|,
name|type
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|tree_node_counts
index|[
operator|(
name|int
operator|)
name|t_kind
index|]
operator|--
expr_stmt|;
name|tree_node_sizes
index|[
operator|(
name|int
operator|)
name|t_kind
index|]
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|tree_type
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|t1
return|;
block|}
comment|/* If this is a new type, record it for later reuse.  */
if|if
condition|(
name|current_obstack
operator|==
operator|&
name|permanent_obstack
condition|)
name|type_hash_add
argument_list|(
name|hashcode
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* Given two lists of types    (chains of TREE_LIST nodes with types in the TREE_VALUE slots)    return 1 if the lists contain the same types in the same order.    Also, the TREE_PURPOSEs must match.  */
end_comment

begin_function
name|int
name|type_list_equal
parameter_list|(
name|l1
parameter_list|,
name|l2
parameter_list|)
name|tree
name|l1
decl_stmt|,
name|l2
decl_stmt|;
block|{
specifier|register
name|tree
name|t1
decl_stmt|,
name|t2
decl_stmt|;
for|for
control|(
name|t1
operator|=
name|l1
operator|,
name|t2
operator|=
name|l2
init|;
name|t1
operator|&&
name|t2
condition|;
name|t1
operator|=
name|TREE_CHAIN
argument_list|(
name|t1
argument_list|)
operator|,
name|t2
operator|=
name|TREE_CHAIN
argument_list|(
name|t2
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|t1
argument_list|)
operator|!=
name|TREE_VALUE
argument_list|(
name|t2
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|t1
argument_list|)
operator|!=
name|TREE_PURPOSE
argument_list|(
name|t2
argument_list|)
condition|)
block|{
name|int
name|cmp
init|=
name|simple_cst_equal
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|t2
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|cmp
operator|<
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|cmp
operator|==
literal|0
condition|)
return|return
literal|0
return|;
block|}
block|}
return|return
name|t1
operator|==
name|t2
return|;
block|}
end_function

begin_comment
comment|/* Nonzero if integer constants T1 and T2    represent the same constant value.  */
end_comment

begin_function
name|int
name|tree_int_cst_equal
parameter_list|(
name|t1
parameter_list|,
name|t2
parameter_list|)
name|tree
name|t1
decl_stmt|,
name|t2
decl_stmt|;
block|{
if|if
condition|(
name|t1
operator|==
name|t2
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|t1
operator|==
literal|0
operator|||
name|t2
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|t2
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_INT_CST_LOW
argument_list|(
name|t1
argument_list|)
operator|==
name|TREE_INT_CST_LOW
argument_list|(
name|t2
argument_list|)
operator|&&
name|TREE_INT_CST_HIGH
argument_list|(
name|t1
argument_list|)
operator|==
name|TREE_INT_CST_HIGH
argument_list|(
name|t2
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Nonzero if integer constants T1 and T2 represent values that satisfy<.    The precise way of comparison depends on their data type.  */
end_comment

begin_function
name|int
name|tree_int_cst_lt
parameter_list|(
name|t1
parameter_list|,
name|t2
parameter_list|)
name|tree
name|t1
decl_stmt|,
name|t2
decl_stmt|;
block|{
if|if
condition|(
name|t1
operator|==
name|t2
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
argument_list|)
condition|)
return|return
name|INT_CST_LT
argument_list|(
name|t1
argument_list|,
name|t2
argument_list|)
return|;
return|return
name|INT_CST_LT_UNSIGNED
argument_list|(
name|t1
argument_list|,
name|t2
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Compare two constructor-element-type constants.  */
end_comment

begin_function
name|int
name|simple_cst_list_equal
parameter_list|(
name|l1
parameter_list|,
name|l2
parameter_list|)
name|tree
name|l1
decl_stmt|,
name|l2
decl_stmt|;
block|{
while|while
condition|(
name|l1
operator|!=
name|NULL_TREE
operator|&&
name|l2
operator|!=
name|NULL_TREE
condition|)
block|{
name|int
name|cmp
init|=
name|simple_cst_equal
argument_list|(
name|TREE_VALUE
argument_list|(
name|l1
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|l2
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|cmp
operator|<
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|cmp
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|l1
operator|=
name|TREE_CHAIN
argument_list|(
name|l1
argument_list|)
expr_stmt|;
name|l2
operator|=
name|TREE_CHAIN
argument_list|(
name|l2
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|l1
operator|==
name|l2
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return truthvalue of whether T1 is the same tree structure as T2.    Return 1 if they are the same.    Return 0 if they are understandably different.    Return -1 if either contains tree structure not understood by    this function.  */
end_comment

begin_function
name|int
name|simple_cst_equal
parameter_list|(
name|t1
parameter_list|,
name|t2
parameter_list|)
name|tree
name|t1
decl_stmt|,
name|t2
decl_stmt|;
block|{
specifier|register
name|enum
name|tree_code
name|code1
decl_stmt|,
name|code2
decl_stmt|;
name|int
name|cmp
decl_stmt|;
if|if
condition|(
name|t1
operator|==
name|t2
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|t1
operator|==
literal|0
operator|||
name|t2
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|code1
operator|=
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
expr_stmt|;
name|code2
operator|=
name|TREE_CODE
argument_list|(
name|t2
argument_list|)
expr_stmt|;
if|if
condition|(
name|code1
operator|==
name|NOP_EXPR
operator|||
name|code1
operator|==
name|CONVERT_EXPR
operator|||
name|code1
operator|==
name|NON_LVALUE_EXPR
condition|)
if|if
condition|(
name|code2
operator|==
name|NOP_EXPR
operator|||
name|code2
operator|==
name|CONVERT_EXPR
operator|||
name|code2
operator|==
name|NON_LVALUE_EXPR
condition|)
return|return
name|simple_cst_equal
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t2
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
else|else
return|return
name|simple_cst_equal
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|t2
argument_list|)
return|;
elseif|else
if|if
condition|(
name|code2
operator|==
name|NOP_EXPR
operator|||
name|code2
operator|==
name|CONVERT_EXPR
operator|||
name|code2
operator|==
name|NON_LVALUE_EXPR
condition|)
return|return
name|simple_cst_equal
argument_list|(
name|t1
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t2
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|code1
operator|!=
name|code2
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|code1
condition|)
block|{
case|case
name|INTEGER_CST
case|:
return|return
name|TREE_INT_CST_LOW
argument_list|(
name|t1
argument_list|)
operator|==
name|TREE_INT_CST_LOW
argument_list|(
name|t2
argument_list|)
operator|&&
name|TREE_INT_CST_HIGH
argument_list|(
name|t1
argument_list|)
operator|==
name|TREE_INT_CST_HIGH
argument_list|(
name|t2
argument_list|)
return|;
case|case
name|REAL_CST
case|:
return|return
name|REAL_VALUES_EQUAL
argument_list|(
name|TREE_REAL_CST
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TREE_REAL_CST
argument_list|(
name|t2
argument_list|)
argument_list|)
return|;
case|case
name|STRING_CST
case|:
return|return
name|TREE_STRING_LENGTH
argument_list|(
name|t1
argument_list|)
operator|==
name|TREE_STRING_LENGTH
argument_list|(
name|t2
argument_list|)
operator|&&
operator|!
name|bcmp
argument_list|(
name|TREE_STRING_POINTER
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TREE_STRING_POINTER
argument_list|(
name|t2
argument_list|)
argument_list|,
name|TREE_STRING_LENGTH
argument_list|(
name|t1
argument_list|)
argument_list|)
return|;
case|case
name|CONSTRUCTOR
case|:
name|abort
argument_list|()
expr_stmt|;
case|case
name|SAVE_EXPR
case|:
return|return
name|simple_cst_equal
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t2
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
case|case
name|CALL_EXPR
case|:
name|cmp
operator|=
name|simple_cst_equal
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t2
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmp
operator|<=
literal|0
condition|)
return|return
name|cmp
return|;
return|return
name|simple_cst_list_equal
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t1
argument_list|,
literal|1
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t2
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
case|case
name|TARGET_EXPR
case|:
comment|/* Special case: if either target is an unallocated VAR_DECL, 	 it means that it's going to be unified with whatever the 	 TARGET_EXPR is really supposed to initialize, so treat it 	 as being equivalent to anything.  */
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t1
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_NAME
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t1
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|DECL_RTL
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t1
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t2
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_NAME
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t2
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|DECL_RTL
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t2
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
literal|0
operator|)
condition|)
name|cmp
operator|=
literal|1
expr_stmt|;
else|else
name|cmp
operator|=
name|simple_cst_equal
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t2
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmp
operator|<=
literal|0
condition|)
return|return
name|cmp
return|;
return|return
name|simple_cst_equal
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t1
argument_list|,
literal|1
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t2
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
case|case
name|WITH_CLEANUP_EXPR
case|:
name|cmp
operator|=
name|simple_cst_equal
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t2
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmp
operator|<=
literal|0
condition|)
return|return
name|cmp
return|;
return|return
name|simple_cst_equal
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t1
argument_list|,
literal|2
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t1
argument_list|,
literal|2
argument_list|)
argument_list|)
return|;
case|case
name|COMPONENT_REF
case|:
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|t1
argument_list|,
literal|1
argument_list|)
operator|==
name|TREE_OPERAND
argument_list|(
name|t2
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|simple_cst_equal
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t2
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
return|return
literal|0
return|;
case|case
name|BIT_FIELD_REF
case|:
return|return
operator|(
name|simple_cst_equal
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t2
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|simple_cst_equal
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t1
argument_list|,
literal|1
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t2
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
name|simple_cst_equal
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t1
argument_list|,
literal|2
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t2
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|)
return|;
case|case
name|VAR_DECL
case|:
case|case
name|PARM_DECL
case|:
case|case
name|CONST_DECL
case|:
case|case
name|FUNCTION_DECL
case|:
return|return
literal|0
return|;
case|case
name|PLUS_EXPR
case|:
case|case
name|MINUS_EXPR
case|:
case|case
name|MULT_EXPR
case|:
case|case
name|TRUNC_DIV_EXPR
case|:
case|case
name|TRUNC_MOD_EXPR
case|:
case|case
name|LSHIFT_EXPR
case|:
case|case
name|RSHIFT_EXPR
case|:
name|cmp
operator|=
name|simple_cst_equal
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t2
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmp
operator|<=
literal|0
condition|)
return|return
name|cmp
return|;
return|return
name|simple_cst_equal
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t1
argument_list|,
literal|1
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t2
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
case|case
name|NEGATE_EXPR
case|:
case|case
name|ADDR_EXPR
case|:
case|case
name|REFERENCE_EXPR
case|:
case|case
name|INDIRECT_REF
case|:
return|return
name|simple_cst_equal
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|t2
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
default|default:
if|#
directive|if
literal|0
block|return lang_simple_cst_equal (t1, t2);
else|#
directive|else
return|return
operator|-
literal|1
return|;
endif|#
directive|endif
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Constructors for pointer, array and function types.    (RECORD_TYPE, UNION_TYPE and ENUMERAL_TYPE nodes are    constructed by language-dependent code, not here.)  */
end_comment

begin_comment
comment|/* Construct, lay out and return the type of pointers to TO_TYPE.    If such a type has already been constructed, reuse it.  */
end_comment

begin_function
name|tree
name|build_pointer_type
parameter_list|(
name|to_type
parameter_list|)
name|tree
name|to_type
decl_stmt|;
block|{
specifier|register
name|tree
name|t
init|=
name|TYPE_POINTER_TO
argument_list|(
name|to_type
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|obstack
modifier|*
name|ambient_obstack
init|=
name|current_obstack
decl_stmt|;
specifier|register
name|struct
name|obstack
modifier|*
name|ambient_saveable_obstack
init|=
name|saveable_obstack
decl_stmt|;
comment|/* First, if we already have a type for pointers to TO_TYPE, use it.  */
if|if
condition|(
name|t
condition|)
return|return
name|t
return|;
comment|/* We need a new one.  If TO_TYPE is permanent, make this permanent too.  */
if|if
condition|(
name|TREE_PERMANENT
argument_list|(
name|to_type
argument_list|)
condition|)
block|{
name|current_obstack
operator|=
operator|&
name|permanent_obstack
expr_stmt|;
name|saveable_obstack
operator|=
operator|&
name|permanent_obstack
expr_stmt|;
block|}
name|t
operator|=
name|make_node
argument_list|(
name|POINTER_TYPE
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|to_type
expr_stmt|;
comment|/* Record this type as the pointer to TO_TYPE.  */
name|TYPE_POINTER_TO
argument_list|(
name|to_type
argument_list|)
operator|=
name|t
expr_stmt|;
comment|/* Lay out the type.  This function has many callers that are concerned      with expression-construction, and this simplifies them all.      Also, it guarantees the TYPE_SIZE is permanent if the type is.  */
name|layout_type
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|current_obstack
operator|=
name|ambient_obstack
expr_stmt|;
name|saveable_obstack
operator|=
name|ambient_saveable_obstack
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Create a type of integers to be the TYPE_DOMAIN of an ARRAY_TYPE.    MAXVAL should be the maximum value in the domain    (one less than the length of the array).  */
end_comment

begin_function
name|tree
name|build_index_type
parameter_list|(
name|maxval
parameter_list|)
name|tree
name|maxval
decl_stmt|;
block|{
specifier|register
name|tree
name|itype
init|=
name|make_node
argument_list|(
name|INTEGER_TYPE
argument_list|)
decl_stmt|;
name|TYPE_PRECISION
argument_list|(
name|itype
argument_list|)
operator|=
name|TYPE_PRECISION
argument_list|(
name|sizetype
argument_list|)
expr_stmt|;
name|TYPE_MIN_VALUE
argument_list|(
name|itype
argument_list|)
operator|=
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|itype
argument_list|)
argument_list|)
operator|=
name|sizetype
expr_stmt|;
name|TYPE_MAX_VALUE
argument_list|(
name|itype
argument_list|)
operator|=
name|convert
argument_list|(
name|sizetype
argument_list|,
name|maxval
argument_list|)
expr_stmt|;
name|TYPE_MODE
argument_list|(
name|itype
argument_list|)
operator|=
name|TYPE_MODE
argument_list|(
name|sizetype
argument_list|)
expr_stmt|;
name|TYPE_SIZE
argument_list|(
name|itype
argument_list|)
operator|=
name|TYPE_SIZE
argument_list|(
name|sizetype
argument_list|)
expr_stmt|;
name|TYPE_ALIGN
argument_list|(
name|itype
argument_list|)
operator|=
name|TYPE_ALIGN
argument_list|(
name|sizetype
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|maxval
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
name|int
name|maxint
init|=
operator|(
name|int
operator|)
name|TREE_INT_CST_LOW
argument_list|(
name|maxval
argument_list|)
decl_stmt|;
return|return
name|type_hash_canon
argument_list|(
name|maxint
operator|<
literal|0
condition|?
operator|~
name|maxint
else|:
name|maxint
argument_list|,
name|itype
argument_list|)
return|;
block|}
else|else
return|return
name|itype
return|;
block|}
end_function

begin_comment
comment|/* Just like build_index_type, but takes lowval and highval instead    of just highval (maxval). */
end_comment

begin_function
name|tree
name|build_index_2_type
parameter_list|(
name|lowval
parameter_list|,
name|highval
parameter_list|)
name|tree
name|lowval
decl_stmt|,
name|highval
decl_stmt|;
block|{
specifier|register
name|tree
name|itype
init|=
name|make_node
argument_list|(
name|INTEGER_TYPE
argument_list|)
decl_stmt|;
name|TYPE_PRECISION
argument_list|(
name|itype
argument_list|)
operator|=
name|TYPE_PRECISION
argument_list|(
name|sizetype
argument_list|)
expr_stmt|;
name|TYPE_MIN_VALUE
argument_list|(
name|itype
argument_list|)
operator|=
name|convert
argument_list|(
name|sizetype
argument_list|,
name|lowval
argument_list|)
expr_stmt|;
name|TYPE_MAX_VALUE
argument_list|(
name|itype
argument_list|)
operator|=
name|convert
argument_list|(
name|sizetype
argument_list|,
name|highval
argument_list|)
expr_stmt|;
name|TYPE_MODE
argument_list|(
name|itype
argument_list|)
operator|=
name|TYPE_MODE
argument_list|(
name|sizetype
argument_list|)
expr_stmt|;
name|TYPE_SIZE
argument_list|(
name|itype
argument_list|)
operator|=
name|TYPE_SIZE
argument_list|(
name|sizetype
argument_list|)
expr_stmt|;
name|TYPE_ALIGN
argument_list|(
name|itype
argument_list|)
operator|=
name|TYPE_ALIGN
argument_list|(
name|sizetype
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|lowval
argument_list|)
operator|==
name|INTEGER_CST
operator|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|highval
argument_list|)
operator|==
name|INTEGER_CST
operator|)
condition|)
block|{
name|HOST_WIDE_INT
name|highint
init|=
name|TREE_INT_CST_LOW
argument_list|(
name|highval
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|lowint
init|=
name|TREE_INT_CST_LOW
argument_list|(
name|lowval
argument_list|)
decl_stmt|;
name|int
name|maxint
init|=
call|(
name|int
call|)
argument_list|(
name|highint
operator|-
name|lowint
argument_list|)
decl_stmt|;
return|return
name|type_hash_canon
argument_list|(
name|maxint
operator|<
literal|0
condition|?
operator|~
name|maxint
else|:
name|maxint
argument_list|,
name|itype
argument_list|)
return|;
block|}
else|else
return|return
name|itype
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero iff ITYPE1 and ITYPE2 are equal (in the LISP sense).    Needed because when index types are not hashed, equal index types    built at different times appear distinct, even though structurally,    they are not.  */
end_comment

begin_function
name|int
name|index_type_equal
parameter_list|(
name|itype1
parameter_list|,
name|itype2
parameter_list|)
name|tree
name|itype1
decl_stmt|,
name|itype2
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|itype1
argument_list|)
operator|!=
name|TREE_CODE
argument_list|(
name|itype2
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|itype1
argument_list|)
operator|==
name|INTEGER_TYPE
condition|)
block|{
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|itype1
argument_list|)
operator|!=
name|TYPE_PRECISION
argument_list|(
name|itype2
argument_list|)
operator|||
name|TYPE_MODE
argument_list|(
name|itype1
argument_list|)
operator|!=
name|TYPE_MODE
argument_list|(
name|itype2
argument_list|)
operator|||
operator|!
name|simple_cst_equal
argument_list|(
name|TYPE_SIZE
argument_list|(
name|itype1
argument_list|)
argument_list|,
name|TYPE_SIZE
argument_list|(
name|itype2
argument_list|)
argument_list|)
operator|||
name|TYPE_ALIGN
argument_list|(
name|itype1
argument_list|)
operator|!=
name|TYPE_ALIGN
argument_list|(
name|itype2
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|simple_cst_equal
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|itype1
argument_list|)
argument_list|,
name|TYPE_MIN_VALUE
argument_list|(
name|itype2
argument_list|)
argument_list|)
operator|&&
name|simple_cst_equal
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|itype1
argument_list|)
argument_list|,
name|TYPE_MAX_VALUE
argument_list|(
name|itype2
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Construct, lay out and return the type of arrays of elements with ELT_TYPE    and number of elements specified by the range of values of INDEX_TYPE.    If such a type has already been constructed, reuse it.  */
end_comment

begin_function
name|tree
name|build_array_type
parameter_list|(
name|elt_type
parameter_list|,
name|index_type
parameter_list|)
name|tree
name|elt_type
decl_stmt|,
name|index_type
decl_stmt|;
block|{
specifier|register
name|tree
name|t
decl_stmt|;
name|int
name|hashcode
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|elt_type
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"arrays of functions are not meaningful"
argument_list|)
expr_stmt|;
name|elt_type
operator|=
name|integer_type_node
expr_stmt|;
block|}
comment|/* Make sure TYPE_POINTER_TO (elt_type) is filled in.  */
name|build_pointer_type
argument_list|(
name|elt_type
argument_list|)
expr_stmt|;
comment|/* Allocate the array after the pointer type,      in case we free it in type_hash_canon.  */
name|t
operator|=
name|make_node
argument_list|(
name|ARRAY_TYPE
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|elt_type
expr_stmt|;
name|TYPE_DOMAIN
argument_list|(
name|t
argument_list|)
operator|=
name|index_type
expr_stmt|;
if|if
condition|(
name|index_type
operator|==
literal|0
condition|)
return|return
name|t
return|;
name|hashcode
operator|=
name|TYPE_HASH
argument_list|(
name|elt_type
argument_list|)
operator|+
name|TYPE_HASH
argument_list|(
name|index_type
argument_list|)
expr_stmt|;
name|t
operator|=
name|type_hash_canon
argument_list|(
name|hashcode
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|t
argument_list|)
operator|==
literal|0
condition|)
name|layout_type
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Construct, lay out and return    the type of functions returning type VALUE_TYPE    given arguments of types ARG_TYPES.    ARG_TYPES is a chain of TREE_LIST nodes whose TREE_VALUEs    are data type nodes for the arguments of the function.    If such a type has already been constructed, reuse it.  */
end_comment

begin_function
name|tree
name|build_function_type
parameter_list|(
name|value_type
parameter_list|,
name|arg_types
parameter_list|)
name|tree
name|value_type
decl_stmt|,
name|arg_types
decl_stmt|;
block|{
specifier|register
name|tree
name|t
decl_stmt|;
name|int
name|hashcode
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value_type
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|value_type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"function return type cannot be function or array"
argument_list|)
expr_stmt|;
name|value_type
operator|=
name|integer_type_node
expr_stmt|;
block|}
comment|/* Make a node of the sort we want.  */
name|t
operator|=
name|make_node
argument_list|(
name|FUNCTION_TYPE
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|value_type
expr_stmt|;
name|TYPE_ARG_TYPES
argument_list|(
name|t
argument_list|)
operator|=
name|arg_types
expr_stmt|;
comment|/* If we already have such a type, use the old one and free this one.  */
name|hashcode
operator|=
name|TYPE_HASH
argument_list|(
name|value_type
argument_list|)
operator|+
name|type_hash_list
argument_list|(
name|arg_types
argument_list|)
expr_stmt|;
name|t
operator|=
name|type_hash_canon
argument_list|(
name|hashcode
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|t
argument_list|)
operator|==
literal|0
condition|)
name|layout_type
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Build the node for the type of references-to-TO_TYPE.  */
end_comment

begin_function
name|tree
name|build_reference_type
parameter_list|(
name|to_type
parameter_list|)
name|tree
name|to_type
decl_stmt|;
block|{
specifier|register
name|tree
name|t
init|=
name|TYPE_REFERENCE_TO
argument_list|(
name|to_type
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|obstack
modifier|*
name|ambient_obstack
init|=
name|current_obstack
decl_stmt|;
specifier|register
name|struct
name|obstack
modifier|*
name|ambient_saveable_obstack
init|=
name|saveable_obstack
decl_stmt|;
comment|/* First, if we already have a type for pointers to TO_TYPE, use it.  */
if|if
condition|(
name|t
condition|)
return|return
name|t
return|;
comment|/* We need a new one.  If TO_TYPE is permanent, make this permanent too.  */
if|if
condition|(
name|TREE_PERMANENT
argument_list|(
name|to_type
argument_list|)
condition|)
block|{
name|current_obstack
operator|=
operator|&
name|permanent_obstack
expr_stmt|;
name|saveable_obstack
operator|=
operator|&
name|permanent_obstack
expr_stmt|;
block|}
name|t
operator|=
name|make_node
argument_list|(
name|REFERENCE_TYPE
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|to_type
expr_stmt|;
comment|/* Record this type as the pointer to TO_TYPE.  */
name|TYPE_REFERENCE_TO
argument_list|(
name|to_type
argument_list|)
operator|=
name|t
expr_stmt|;
name|layout_type
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|current_obstack
operator|=
name|ambient_obstack
expr_stmt|;
name|saveable_obstack
operator|=
name|ambient_saveable_obstack
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Construct, lay out and return the type of methods belonging to class    BASETYPE and whose arguments and values are described by TYPE.    If that type exists already, reuse it.    TYPE must be a FUNCTION_TYPE node.  */
end_comment

begin_function
name|tree
name|build_method_type
parameter_list|(
name|basetype
parameter_list|,
name|type
parameter_list|)
name|tree
name|basetype
decl_stmt|,
name|type
decl_stmt|;
block|{
specifier|register
name|tree
name|t
decl_stmt|;
name|int
name|hashcode
decl_stmt|;
comment|/* Make a node of the sort we want.  */
name|t
operator|=
name|make_node
argument_list|(
name|METHOD_TYPE
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|FUNCTION_TYPE
condition|)
name|abort
argument_list|()
expr_stmt|;
name|TYPE_METHOD_BASETYPE
argument_list|(
name|t
argument_list|)
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* The actual arglist for this function includes a "hidden" argument      which is "this".  Put it into the list of argument types.  */
name|TYPE_ARG_TYPES
argument_list|(
name|t
argument_list|)
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_pointer_type
argument_list|(
name|basetype
argument_list|)
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we already have such a type, use the old one and free this one.  */
name|hashcode
operator|=
name|TYPE_HASH
argument_list|(
name|basetype
argument_list|)
operator|+
name|TYPE_HASH
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|t
operator|=
name|type_hash_canon
argument_list|(
name|hashcode
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|t
argument_list|)
operator|==
literal|0
condition|)
name|layout_type
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Construct, lay out and return the type of methods belonging to class    BASETYPE and whose arguments and values are described by TYPE.    If that type exists already, reuse it.    TYPE must be a FUNCTION_TYPE node.  */
end_comment

begin_function
name|tree
name|build_offset_type
parameter_list|(
name|basetype
parameter_list|,
name|type
parameter_list|)
name|tree
name|basetype
decl_stmt|,
name|type
decl_stmt|;
block|{
specifier|register
name|tree
name|t
decl_stmt|;
name|int
name|hashcode
decl_stmt|;
comment|/* Make a node of the sort we want.  */
name|t
operator|=
name|make_node
argument_list|(
name|OFFSET_TYPE
argument_list|)
expr_stmt|;
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|t
argument_list|)
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|type
expr_stmt|;
comment|/* If we already have such a type, use the old one and free this one.  */
name|hashcode
operator|=
name|TYPE_HASH
argument_list|(
name|basetype
argument_list|)
operator|+
name|TYPE_HASH
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|t
operator|=
name|type_hash_canon
argument_list|(
name|hashcode
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|t
argument_list|)
operator|==
literal|0
condition|)
name|layout_type
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Create a complex type whose components are COMPONENT_TYPE.  */
end_comment

begin_function
name|tree
name|build_complex_type
parameter_list|(
name|component_type
parameter_list|)
name|tree
name|component_type
decl_stmt|;
block|{
specifier|register
name|tree
name|t
decl_stmt|;
name|int
name|hashcode
decl_stmt|;
comment|/* Make a node of the sort we want.  */
name|t
operator|=
name|make_node
argument_list|(
name|COMPLEX_TYPE
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|component_type
argument_list|)
expr_stmt|;
name|TYPE_VOLATILE
argument_list|(
name|t
argument_list|)
operator|=
name|TYPE_VOLATILE
argument_list|(
name|component_type
argument_list|)
expr_stmt|;
name|TYPE_READONLY
argument_list|(
name|t
argument_list|)
operator|=
name|TYPE_READONLY
argument_list|(
name|component_type
argument_list|)
expr_stmt|;
comment|/* If we already have such a type, use the old one and free this one.  */
name|hashcode
operator|=
name|TYPE_HASH
argument_list|(
name|component_type
argument_list|)
expr_stmt|;
name|t
operator|=
name|type_hash_canon
argument_list|(
name|hashcode
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|t
argument_list|)
operator|==
literal|0
condition|)
name|layout_type
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return OP, stripped of any conversions to wider types as much as is safe.    Converting the value back to OP's type makes a value equivalent to OP.     If FOR_TYPE is nonzero, we return a value which, if converted to    type FOR_TYPE, would be equivalent to converting OP to type FOR_TYPE.     If FOR_TYPE is nonzero, unaligned bit-field references may be changed to the    narrowest type that can hold the value, even if they don't exactly fit.    Otherwise, bit-field references are changed to a narrower type    only if they can be fetched directly from memory in that type.     OP must have integer, real or enumeral type.  Pointers are not allowed!     There are some cases where the obvious value we could return    would regenerate to OP if converted to OP's type,     but would not extend like OP to wider types.    If FOR_TYPE indicates such extension is contemplated, we eschew such values.    For example, if OP is (unsigned short)(signed char)-1,    we avoid returning (signed char)-1 if FOR_TYPE is int,    even though extending that to an unsigned short would regenerate OP,    since the result of extending (signed char)-1 to (int)    is different from (int) OP.  */
end_comment

begin_function
name|tree
name|get_unwidened
parameter_list|(
name|op
parameter_list|,
name|for_type
parameter_list|)
specifier|register
name|tree
name|op
decl_stmt|;
name|tree
name|for_type
decl_stmt|;
block|{
comment|/* Set UNS initially if converting OP to FOR_TYPE is a zero-extension.  */
comment|/* TYPE_PRECISION is safe in place of type_precision since      pointer types are not allowed.  */
specifier|register
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|op
argument_list|)
decl_stmt|;
specifier|register
name|unsigned
name|final_prec
init|=
name|TYPE_PRECISION
argument_list|(
name|for_type
operator|!=
literal|0
condition|?
name|for_type
else|:
name|type
argument_list|)
decl_stmt|;
specifier|register
name|int
name|uns
init|=
operator|(
name|for_type
operator|!=
literal|0
operator|&&
name|for_type
operator|!=
name|type
operator|&&
name|final_prec
operator|>
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|&&
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
operator|)
decl_stmt|;
specifier|register
name|tree
name|win
init|=
name|op
decl_stmt|;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|NOP_EXPR
condition|)
block|{
specifier|register
name|int
name|bitschange
init|=
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|op
argument_list|)
argument_list|)
operator|-
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Truncations are many-one so cannot be removed. 	 Unless we are later going to truncate down even farther.  */
if|if
condition|(
name|bitschange
operator|<
literal|0
operator|&&
name|final_prec
operator|>
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|op
argument_list|)
argument_list|)
condition|)
break|break;
comment|/* See what's inside this conversion.  If we decide to strip it, 	 we will set WIN.  */
name|op
operator|=
name|TREE_OPERAND
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If we have not stripped any zero-extensions (uns is 0), 	 we can strip any kind of extension. 	 If we have previously stripped a zero-extension, 	 only zero-extensions can safely be stripped. 	 Any extension can be stripped if the bits it would produce 	 are all going to be discarded later by truncating to FOR_TYPE.  */
if|if
condition|(
name|bitschange
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|uns
operator|||
name|final_prec
operator|<=
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|op
argument_list|)
argument_list|)
condition|)
name|win
operator|=
name|op
expr_stmt|;
comment|/* TREE_UNSIGNED says whether this is a zero-extension. 	     Let's avoid computing it if it does not affect WIN 	     and if UNS will not be needed again.  */
if|if
condition|(
operator|(
name|uns
operator|||
name|TREE_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|NOP_EXPR
operator|)
operator|&&
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|op
argument_list|)
argument_list|)
condition|)
block|{
name|uns
operator|=
literal|1
expr_stmt|;
name|win
operator|=
name|op
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|COMPONENT_REF
comment|/* Since type_for_size always gives an integer type.  */
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|REAL_TYPE
condition|)
block|{
name|unsigned
name|innerprec
init|=
name|TREE_INT_CST_LOW
argument_list|(
name|DECL_SIZE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|type
operator|=
name|type_for_size
argument_list|(
name|innerprec
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|TREE_OPERAND
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We can get this structure field in the narrowest type it fits in. 	 If FOR_TYPE is 0, do this only for a field that matches the 	 narrower type exactly and is aligned for it 	 The resulting extension to its nominal type (a fullword type) 	 must fit the same conditions as for other extensions.  */
if|if
condition|(
name|innerprec
operator|<
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|op
argument_list|)
argument_list|)
operator|&&
operator|(
name|for_type
operator|||
operator|!
name|DECL_BIT_FIELD
argument_list|(
name|TREE_OPERAND
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
operator|!
name|uns
operator|||
name|final_prec
operator|<=
name|innerprec
operator|||
name|TREE_UNSIGNED
argument_list|(
name|TREE_OPERAND
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
operator|&&
name|type
operator|!=
literal|0
condition|)
block|{
name|win
operator|=
name|build
argument_list|(
name|COMPONENT_REF
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|win
argument_list|)
operator|=
name|TREE_SIDE_EFFECTS
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|TREE_THIS_VOLATILE
argument_list|(
name|win
argument_list|)
operator|=
name|TREE_THIS_VOLATILE
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|TREE_RAISES
argument_list|(
name|win
argument_list|)
operator|=
name|TREE_RAISES
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|win
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return OP or a simpler expression for a narrower value    which can be sign-extended or zero-extended to give back OP.    Store in *UNSIGNEDP_PTR either 1 if the value should be zero-extended    or 0 if the value should be sign-extended.  */
end_comment

begin_function
name|tree
name|get_narrower
parameter_list|(
name|op
parameter_list|,
name|unsignedp_ptr
parameter_list|)
specifier|register
name|tree
name|op
decl_stmt|;
name|int
modifier|*
name|unsignedp_ptr
decl_stmt|;
block|{
specifier|register
name|int
name|uns
init|=
literal|0
decl_stmt|;
name|int
name|first
init|=
literal|1
decl_stmt|;
specifier|register
name|tree
name|win
init|=
name|op
decl_stmt|;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|NOP_EXPR
condition|)
block|{
specifier|register
name|int
name|bitschange
init|=
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|op
argument_list|)
argument_list|)
operator|-
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Truncations are many-one so cannot be removed.  */
if|if
condition|(
name|bitschange
operator|<
literal|0
condition|)
break|break;
comment|/* See what's inside this conversion.  If we decide to strip it, 	 we will set WIN.  */
name|op
operator|=
name|TREE_OPERAND
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitschange
operator|>
literal|0
condition|)
block|{
comment|/* An extension: the outermost one can be stripped, 	     but remember whether it is zero or sign extension.  */
if|if
condition|(
name|first
condition|)
name|uns
operator|=
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|op
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Otherwise, if a sign extension has been stripped, 	     only sign extensions can now be stripped; 	     if a zero extension has been stripped, only zero-extensions.  */
elseif|else
if|if
condition|(
name|uns
operator|!=
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|op
argument_list|)
argument_list|)
condition|)
break|break;
name|first
operator|=
literal|0
expr_stmt|;
block|}
comment|/* A change in nominal type can always be stripped.  */
name|win
operator|=
name|op
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|COMPONENT_REF
comment|/* Since type_for_size always gives an integer type.  */
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|op
argument_list|)
argument_list|)
operator|!=
name|REAL_TYPE
condition|)
block|{
name|unsigned
name|innerprec
init|=
name|TREE_INT_CST_LOW
argument_list|(
name|DECL_SIZE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|type
init|=
name|type_for_size
argument_list|(
name|innerprec
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|op
argument_list|)
argument_list|)
decl_stmt|;
comment|/* We can get this structure field in a narrower type that fits it, 	 but the resulting extension to its nominal type (a fullword type) 	 must satisfy the same conditions as for other extensions.  	 Do this only for fields that are aligned (not bit-fields), 	 because when bit-field insns will be used there is no 	 advantage in doing this.  */
if|if
condition|(
name|innerprec
operator|<
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|op
argument_list|)
argument_list|)
operator|&&
operator|!
name|DECL_BIT_FIELD
argument_list|(
name|TREE_OPERAND
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
operator|(
name|first
operator|||
name|uns
operator|==
name|TREE_UNSIGNED
argument_list|(
name|TREE_OPERAND
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
operator|&&
name|type
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|first
condition|)
name|uns
operator|=
name|TREE_UNSIGNED
argument_list|(
name|TREE_OPERAND
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|win
operator|=
name|build
argument_list|(
name|COMPONENT_REF
argument_list|,
name|type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|win
argument_list|)
operator|=
name|TREE_SIDE_EFFECTS
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|TREE_THIS_VOLATILE
argument_list|(
name|win
argument_list|)
operator|=
name|TREE_THIS_VOLATILE
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|TREE_RAISES
argument_list|(
name|win
argument_list|)
operator|=
name|TREE_RAISES
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
block|}
operator|*
name|unsignedp_ptr
operator|=
name|uns
expr_stmt|;
return|return
name|win
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the precision of a type, for arithmetic purposes.    Supports all types on which arithmetic is possible    (including pointer types).    It's not clear yet what will be right for complex types.  */
end_comment

begin_function
name|int
name|type_precision
parameter_list|(
name|type
parameter_list|)
specifier|register
name|tree
name|type
decl_stmt|;
block|{
return|return
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|INTEGER_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ENUMERAL_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REAL_TYPE
operator|)
condition|?
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
else|:
name|POINTER_SIZE
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Nonzero if integer constant C has a value that is permissible    for type TYPE (an INTEGER_TYPE).  */
end_comment

begin_function
name|int
name|int_fits_type_p
parameter_list|(
name|c
parameter_list|,
name|type
parameter_list|)
name|tree
name|c
decl_stmt|,
name|type
decl_stmt|;
block|{
if|if
condition|(
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|)
return|return
operator|(
operator|!
name|INT_CST_LT_UNSIGNED
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|type
argument_list|)
argument_list|,
name|c
argument_list|)
operator|&&
operator|!
name|INT_CST_LT_UNSIGNED
argument_list|(
name|c
argument_list|,
name|TYPE_MIN_VALUE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|&&
operator|(
name|TREE_INT_CST_HIGH
argument_list|(
name|c
argument_list|)
operator|>=
literal|0
operator|||
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|c
argument_list|)
argument_list|)
operator|)
operator|)
return|;
else|else
return|return
operator|(
operator|!
name|INT_CST_LT
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|type
argument_list|)
argument_list|,
name|c
argument_list|)
operator|&&
operator|!
name|INT_CST_LT
argument_list|(
name|c
argument_list|,
name|TYPE_MIN_VALUE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|&&
operator|(
name|TREE_INT_CST_HIGH
argument_list|(
name|c
argument_list|)
operator|>=
literal|0
operator|||
operator|!
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|c
argument_list|)
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return the innermost context enclosing DECL that is    a FUNCTION_DECL, or zero if none.  */
end_comment

begin_function
name|tree
name|decl_function_context
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
name|tree
name|context
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|SAVE_EXPR
condition|)
name|context
operator|=
name|SAVE_EXPR_CONTEXT
argument_list|(
name|decl
argument_list|)
expr_stmt|;
else|else
name|context
operator|=
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
expr_stmt|;
while|while
condition|(
name|context
operator|&&
name|TREE_CODE
argument_list|(
name|context
argument_list|)
operator|!=
name|FUNCTION_DECL
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|context
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|context
argument_list|)
operator|==
name|UNION_TYPE
condition|)
name|context
operator|=
name|TYPE_CONTEXT
argument_list|(
name|context
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|context
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|context
operator|=
name|DECL_CONTEXT
argument_list|(
name|context
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|context
argument_list|)
operator|==
name|BLOCK
condition|)
name|context
operator|=
name|BLOCK_SUPERCONTEXT
argument_list|(
name|context
argument_list|)
expr_stmt|;
else|else
comment|/* Unhandled CONTEXT !?  */
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
name|context
return|;
block|}
end_function

begin_comment
comment|/* Return the innermost context enclosing DECL that is    a RECORD_TYPE or UNION_TYPE, or zero if none.    TYPE_DECLs and FUNCTION_DECLs are transparent to this function.  */
end_comment

begin_function
name|tree
name|decl_type_context
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
name|tree
name|context
init|=
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
decl_stmt|;
while|while
condition|(
name|context
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|context
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|context
argument_list|)
operator|==
name|UNION_TYPE
condition|)
return|return
name|context
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|context
argument_list|)
operator|==
name|TYPE_DECL
operator|||
name|TREE_CODE
argument_list|(
name|context
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|context
operator|=
name|DECL_CONTEXT
argument_list|(
name|context
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|context
argument_list|)
operator|==
name|BLOCK
condition|)
name|context
operator|=
name|BLOCK_SUPERCONTEXT
argument_list|(
name|context
argument_list|)
expr_stmt|;
else|else
comment|/* Unhandled CONTEXT!?  */
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_function
name|void
name|print_obstack_statistics
parameter_list|(
name|str
parameter_list|,
name|o
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
name|struct
name|obstack
modifier|*
name|o
decl_stmt|;
block|{
name|struct
name|_obstack_chunk
modifier|*
name|chunk
init|=
name|o
operator|->
name|chunk
decl_stmt|;
name|int
name|n_chunks
init|=
literal|0
decl_stmt|;
name|int
name|n_alloc
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|chunk
condition|)
block|{
name|n_chunks
operator|+=
literal|1
expr_stmt|;
name|n_alloc
operator|+=
name|chunk
operator|->
name|limit
operator|-
operator|&
name|chunk
operator|->
name|contents
index|[
literal|0
index|]
expr_stmt|;
name|chunk
operator|=
name|chunk
operator|->
name|prev
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"obstack %s: %d bytes, %d chunks\n"
argument_list|,
name|str
argument_list|,
name|n_alloc
argument_list|,
name|n_chunks
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dump_tree_statistics
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
name|int
name|total_nodes
decl_stmt|,
name|total_bytes
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n??? tree nodes created\n\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Kind                  Nodes     Bytes\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"-------------------------------------\n"
argument_list|)
expr_stmt|;
name|total_nodes
operator|=
name|total_bytes
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|all_kinds
condition|;
name|i
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%-20s %6d %9d\n"
argument_list|,
name|tree_node_kind_names
index|[
name|i
index|]
argument_list|,
name|tree_node_counts
index|[
name|i
index|]
argument_list|,
name|tree_node_sizes
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|total_nodes
operator|+=
name|tree_node_counts
index|[
name|i
index|]
expr_stmt|;
name|total_bytes
operator|+=
name|tree_node_sizes
index|[
name|i
index|]
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%-20s        %9d\n"
argument_list|,
literal|"identifier names"
argument_list|,
name|id_string_size
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"-------------------------------------\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%-20s %6d %9d\n"
argument_list|,
literal|"Total"
argument_list|,
name|total_nodes
argument_list|,
name|total_bytes
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"-------------------------------------\n"
argument_list|)
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"(No per-node statistics)\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|print_lang_statistics
argument_list|()
expr_stmt|;
block|}
end_function

end_unit

