begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Subroutines for insn-output.c for HPPA.    Copyright (C) 1992 Free Software Foundation, Inc.    Contributed by Tim Moore (moore@cs.utah.edu), based on sparc.c  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"conditions.h"
end_include

begin_include
include|#
directive|include
file|"insn-flags.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"insn-attr.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"c-tree.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_comment
comment|/* Save the operands last given to a compare for use when we    generate a scc or bcc insn.  */
end_comment

begin_decl_stmt
name|rtx
name|hppa_compare_op0
decl_stmt|,
name|hppa_compare_op1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|enum
name|cmp_type
name|hppa_branch_type
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set by the FUNCTION_PROFILER macro. */
end_comment

begin_decl_stmt
name|int
name|hp_profile_labelno
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Name of where we pretend to think the frame pointer points.    Normally, this is "4", but if we are in a leaf procedure,    this is "something(30)".  Will this work? */
end_comment

begin_decl_stmt
name|char
modifier|*
name|frame_base_name
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|rtx
name|find_addr_reg
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Return non-zero only if OP is a register of mode MODE,    or const0_rtx.  */
end_comment

begin_function
name|int
name|reg_or_0_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|op
operator|==
name|const0_rtx
operator|||
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|call_operand_address
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|REG_P
argument_list|(
name|op
argument_list|)
operator|||
operator|(
name|CONSTANT_P
argument_list|(
name|op
argument_list|)
operator|&&
operator|!
name|TARGET_LONG_CALLS
operator|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|symbolic_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
condition|)
block|{
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
return|return
literal|1
return|;
case|case
name|CONST
case|:
name|op
operator|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|)
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return truth value of statement that OP is a symbolic memory    operand of mode MODE.  */
end_comment

begin_function
name|int
name|symbolic_memory_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
condition|)
name|op
operator|=
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|MEM
condition|)
return|return
literal|0
return|;
name|op
operator|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SYMBOL_REF
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|HIGH
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|LABEL_REF
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if the operand is either a register or a memory operand that is    not symbolic.  */
end_comment

begin_function
name|int
name|reg_or_nonsymb_mem_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|memory_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|&&
operator|!
name|symbolic_memory_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|move_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|op
operator|==
name|CONST0_RTX
argument_list|(
name|mode
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|mode
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
condition|)
name|op
operator|=
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|MEM
condition|)
return|return
literal|0
return|;
name|op
operator|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|LO_SUM
condition|)
return|return
operator|(
name|register_operand
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Pmode
argument_list|)
operator|&&
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
return|;
return|return
name|memory_address_p
argument_list|(
name|mode
argument_list|,
name|op
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|pic_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
name|flag_pic
operator|&&
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|LABEL_REF
return|;
block|}
end_function

begin_function
name|int
name|short_memory_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|MEM
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
condition|)
block|{
name|rtx
name|op1
init|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|op2
init|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|REG
condition|)
return|return
operator|(
name|GET_CODE
argument_list|(
name|op2
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INT_5_BITS
argument_list|(
name|op2
argument_list|)
operator|)
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|op2
argument_list|)
operator|==
name|REG
condition|)
return|return
operator|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INT_5_BITS
argument_list|(
name|op1
argument_list|)
operator|)
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|register_or_short_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
condition|)
name|op
operator|=
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
expr_stmt|;
return|return
name|short_memory_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|fp_reg_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
name|reg_renumber
operator|&&
name|FP_REG_P
argument_list|(
name|op
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|check_fp_mov
parameter_list|(
name|operands
parameter_list|)
name|rtx
modifier|*
name|operands
decl_stmt|;
block|{
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|fp_reg_operand
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|mode
argument_list|)
condition|)
return|return
operator|(
name|register_operand
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
name|mode
argument_list|)
operator|||
name|short_memory_operand
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
name|mode
argument_list|)
operator|)
return|;
elseif|else
if|if
condition|(
name|fp_reg_operand
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
name|mode
argument_list|)
condition|)
return|return
operator|(
name|register_operand
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|mode
argument_list|)
operator|||
name|short_memory_operand
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|mode
argument_list|)
operator|)
return|;
else|else
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_decl_stmt
specifier|extern
name|int
name|current_function_uses_pic_offset_table
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|rtx
name|force_reg
argument_list|()
decl_stmt|,
name|validize_mem
argument_list|()
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The rtx for the global offset table which is a special form    that *is* a position independent symbolic constant.  */
end_comment

begin_decl_stmt
name|rtx
name|pic_pc_rtx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Ensure that we are not using patterns that are not OK with PIC.  */
end_comment

begin_function
name|int
name|check_pic
parameter_list|(
name|i
parameter_list|)
name|int
name|i
decl_stmt|;
block|{
specifier|extern
name|rtx
name|recog_operand
index|[]
decl_stmt|;
switch|switch
condition|(
name|flag_pic
condition|)
block|{
case|case
literal|1
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|recog_operand
index|[
name|i
index|]
argument_list|)
operator|==
name|SYMBOL_REF
operator|||
operator|(
name|GET_CODE
argument_list|(
name|recog_operand
index|[
name|i
index|]
argument_list|)
operator|==
name|CONST
operator|&&
operator|!
name|rtx_equal_p
argument_list|(
name|pic_pc_rtx
argument_list|,
name|recog_operand
index|[
name|i
index|]
argument_list|)
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
case|case
literal|2
case|:
default|default:
return|return
literal|1
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return truth value of whether OP is EQ or NE.  */
end_comment

begin_function
name|int
name|eq_or_neq
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|EQ
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|NE
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return truth value of whether OP can be used as an operand in a    three operand arithmetic insn that accepts registers of mode MODE    or 14-bit signed integers.  */
end_comment

begin_function
name|int
name|arith_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INT_14_BITS
argument_list|(
name|op
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return truth value of whether OP can be used as an operand in a    three operand arithmetic insn that accepts registers of mode MODE    or 11-bit signed integers.  */
end_comment

begin_function
name|int
name|arith11_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INT_11_BITS
argument_list|(
name|op
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|arith_double_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|mode
operator|&&
name|VAL_14_BITS_P
argument_list|(
name|CONST_DOUBLE_LOW
argument_list|(
name|op
argument_list|)
argument_list|)
operator|&&
operator|(
name|CONST_DOUBLE_HIGH
argument_list|(
name|op
argument_list|)
operator|>=
literal|0
operator|==
operator|(
operator|(
name|CONST_DOUBLE_LOW
argument_list|(
name|op
argument_list|)
operator|&
literal|0x1000
operator|)
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return truth value of whether OP is a integer which fits the    range constraining immediate operands in three-address insns.  */
end_comment

begin_function
name|int
name|int5_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INT_5_BITS
argument_list|(
name|op
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|uint5_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INT_U5_BITS
argument_list|(
name|op
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|int11_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INT_11_BITS
argument_list|(
name|op
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|arith5_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|||
name|int5_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* True iff zdepi can be used to generate this CONST_INT.  */
end_comment

begin_function
name|int
name|depi_cint_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|unsigned
name|x
decl_stmt|;
name|unsigned
name|lbmask
decl_stmt|,
name|t
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|CONST_INT
condition|)
return|return
literal|0
return|;
comment|/* This might not be obvious, but it's at least fast.      This function is critcal; we don't have the time loops would take.  */
name|x
operator|=
name|INTVAL
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|lbmask
operator|=
name|x
operator|&
operator|-
name|x
expr_stmt|;
name|t
operator|=
operator|(
operator|(
name|x
operator|>>
literal|4
operator|)
operator|+
name|lbmask
operator|)
operator|&
operator|~
operator|(
name|lbmask
operator|-
literal|1
operator|)
expr_stmt|;
return|return
operator|(
operator|(
name|t
operator|&
operator|(
name|t
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* True iff depi or extru can be used to compute (reg& mask).  */
end_comment

begin_function
name|int
name|consec_zeros_p
parameter_list|(
name|mask
parameter_list|)
name|unsigned
name|mask
decl_stmt|;
block|{
name|mask
operator|=
operator|~
name|mask
expr_stmt|;
name|mask
operator|+=
name|mask
operator|&
operator|-
name|mask
expr_stmt|;
return|return
operator|(
name|mask
operator|&
operator|(
name|mask
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
return|;
block|}
end_function

begin_comment
comment|/* True iff depi or extru can be used to compute (reg& OP).  */
end_comment

begin_function
name|int
name|and_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|consec_zeros_p
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* True iff depi can be used to compute (reg | MASK).  */
end_comment

begin_function
name|int
name|ior_mask_p
parameter_list|(
name|mask
parameter_list|)
name|unsigned
name|mask
decl_stmt|;
block|{
name|mask
operator|+=
name|mask
operator|&
operator|-
name|mask
expr_stmt|;
return|return
operator|(
name|mask
operator|&
operator|(
name|mask
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
return|;
block|}
end_function

begin_comment
comment|/* True iff depi can be used to compute (reg | OP).  */
end_comment

begin_function
name|int
name|ior_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|ior_mask_p
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|arith32_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
return|;
block|}
end_function

begin_comment
comment|/* True iff OP can be the source of a move to a general register.  */
end_comment

begin_function
name|int
name|srcsi_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
comment|/* Not intended for other modes than SImode.  */
if|if
condition|(
name|mode
operator|!=
name|SImode
condition|)
return|return
literal|0
return|;
comment|/* Accept any register or memory reference.  */
if|if
condition|(
name|nonimmediate_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|depi_cint_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* OK if ldo or ldil can be used.  */
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|INT_14_BITS
argument_list|(
name|op
argument_list|)
operator|||
operator|(
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|&
literal|0x7ff
operator|)
operator|==
literal|0
operator|)
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Legitimize PIC addresses.  If the address is already    position-independent, we return ORIG.  Newly generated    position-independent addresses go to REG.  If we need more    than one register, we lose.  */
end_comment

begin_function
name|rtx
name|legitimize_pic_address
parameter_list|(
name|orig
parameter_list|,
name|mode
parameter_list|,
name|reg
parameter_list|)
name|rtx
name|orig
decl_stmt|,
name|reg
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|rtx
name|pic_ref
init|=
name|orig
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|orig
argument_list|)
operator|==
name|SYMBOL_REF
condition|)
block|{
if|if
condition|(
name|reg
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|flag_pic
operator|==
literal|2
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_rtx
argument_list|(
name|SET
argument_list|,
name|VOIDmode
argument_list|,
name|reg
argument_list|,
name|gen_rtx
argument_list|(
name|HIGH
argument_list|,
name|Pmode
argument_list|,
name|orig
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx
argument_list|(
name|SET
argument_list|,
name|VOIDmode
argument_list|,
name|reg
argument_list|,
name|gen_rtx
argument_list|(
name|LO_SUM
argument_list|,
name|Pmode
argument_list|,
name|reg
argument_list|,
name|orig
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|orig
operator|=
name|reg
expr_stmt|;
block|}
name|pic_ref
operator|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|Pmode
argument_list|,
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|Pmode
argument_list|,
name|pic_offset_table_rtx
argument_list|,
name|orig
argument_list|)
argument_list|)
expr_stmt|;
name|current_function_uses_pic_offset_table
operator|=
literal|1
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|pic_ref
argument_list|)
operator|=
literal|1
expr_stmt|;
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|pic_ref
argument_list|)
expr_stmt|;
return|return
name|reg
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|orig
argument_list|)
operator|==
name|CONST
condition|)
block|{
name|rtx
name|base
decl_stmt|,
name|offset
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|pic_offset_table_rtx
condition|)
return|return
name|orig
return|;
if|if
condition|(
name|reg
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
condition|)
block|{
name|base
operator|=
name|legitimize_pic_address
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Pmode
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|orig
operator|=
name|legitimize_pic_address
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
name|Pmode
argument_list|,
name|base
operator|==
name|reg
condition|?
literal|0
else|:
name|reg
argument_list|)
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|orig
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
if|if
condition|(
name|SMALL_INT
argument_list|(
name|orig
argument_list|)
condition|)
return|return
name|plus_constant_for_output
argument_list|(
name|base
argument_list|,
name|INTVAL
argument_list|(
name|orig
argument_list|)
argument_list|)
return|;
name|orig
operator|=
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|orig
argument_list|)
expr_stmt|;
block|}
name|pic_ref
operator|=
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|Pmode
argument_list|,
name|base
argument_list|,
name|orig
argument_list|)
expr_stmt|;
comment|/* Likewise, should we set special REG_NOTEs here?  */
block|}
return|return
name|pic_ref
return|;
block|}
end_function

begin_comment
comment|/* Set up PIC-specific rtl.  This should not cause any insns    to be emitted.  */
end_comment

begin_function
name|void
name|initialize_pic
parameter_list|()
block|{ }
end_function

begin_comment
comment|/* Emit special PIC prologues and epilogues.  */
end_comment

begin_function
name|void
name|finalize_pic
parameter_list|()
block|{
comment|/* Need to emit this whether or not we obey regdecls,      since setjmp/longjmp can cause life info to screw up.  */
name|emit_insn
argument_list|(
name|gen_rtx
argument_list|(
name|USE
argument_list|,
name|VOIDmode
argument_list|,
name|pic_offset_table_rtx
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* For the HPPA, REG and REG+CONST is cost 0    and addresses involving symbolic constants are cost 2.     PIC addresses are very expensive.     It is no coincidence that this has the same structure    as GO_IF_LEGITIMATE_ADDRESS.  */
end_comment

begin_function
name|int
name|hppa_address_cost
parameter_list|(
name|X
parameter_list|)
name|rtx
name|X
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|X
argument_list|)
operator|==
name|PLUS
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|X
argument_list|)
operator|==
name|LO_SUM
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|X
argument_list|)
operator|==
name|HIGH
condition|)
return|return
literal|2
return|;
return|return
literal|4
return|;
block|}
end_function

begin_comment
comment|/* Emit insns to move operands[1] into operands[0].     Return 1 if we have written out everything that needs to be done to    do the move.  Otherwise, return 0 and the caller will emit the move    normally.  */
end_comment

begin_function
name|int
name|emit_move_sequence
parameter_list|(
name|operands
parameter_list|,
name|mode
parameter_list|,
name|scratch_reg
parameter_list|)
name|rtx
modifier|*
name|operands
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|scratch_reg
decl_stmt|;
block|{
specifier|register
name|rtx
name|operand0
init|=
name|operands
index|[
literal|0
index|]
decl_stmt|;
specifier|register
name|rtx
name|operand1
init|=
name|operands
index|[
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|fp_reg_operand
argument_list|(
name|operand0
argument_list|,
name|mode
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|operand1
argument_list|)
operator|==
name|MEM
operator|&&
operator|!
name|short_memory_operand
argument_list|(
name|operand1
argument_list|,
name|mode
argument_list|)
operator|&&
name|scratch_reg
condition|)
block|{
name|emit_move_insn
argument_list|(
name|scratch_reg
argument_list|,
name|XEXP
argument_list|(
name|operand1
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx
argument_list|(
name|SET
argument_list|,
name|VOIDmode
argument_list|,
name|operand0
argument_list|,
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|mode
argument_list|,
name|scratch_reg
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|fp_reg_operand
argument_list|(
name|operand1
argument_list|,
name|mode
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|operand0
argument_list|)
operator|==
name|MEM
operator|&&
operator|!
name|short_memory_operand
argument_list|(
name|operand0
argument_list|,
name|mode
argument_list|)
operator|&&
name|scratch_reg
condition|)
block|{
name|emit_move_insn
argument_list|(
name|scratch_reg
argument_list|,
name|XEXP
argument_list|(
name|operand0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx
argument_list|(
name|SET
argument_list|,
name|VOIDmode
argument_list|,
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|mode
argument_list|,
name|scratch_reg
argument_list|)
argument_list|,
name|operand1
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* Handle most common case: storing into a register.  */
elseif|else
if|if
condition|(
name|register_operand
argument_list|(
name|operand0
argument_list|,
name|mode
argument_list|)
condition|)
block|{
if|if
condition|(
name|register_operand
argument_list|(
name|operand1
argument_list|,
name|mode
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|operand1
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|SMALL_INT
argument_list|(
name|operand1
argument_list|)
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|operand1
argument_list|)
operator|==
name|HIGH
operator|&&
operator|!
name|symbolic_operand
argument_list|(
name|XEXP
argument_list|(
name|operand1
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
comment|/* Only `general_operands' can come here, so MEM is ok.  */
operator|||
name|GET_CODE
argument_list|(
name|operand1
argument_list|)
operator|==
name|MEM
condition|)
block|{
comment|/* Run this case quickly.  */
name|emit_insn
argument_list|(
name|gen_rtx
argument_list|(
name|SET
argument_list|,
name|VOIDmode
argument_list|,
name|operand0
argument_list|,
name|operand1
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|operand0
argument_list|)
operator|==
name|MEM
condition|)
block|{
if|if
condition|(
name|register_operand
argument_list|(
name|operand1
argument_list|,
name|mode
argument_list|)
operator|||
name|operand1
operator|==
name|const0_rtx
condition|)
block|{
comment|/* Run this case quickly.  */
name|emit_insn
argument_list|(
name|gen_rtx
argument_list|(
name|SET
argument_list|,
name|VOIDmode
argument_list|,
name|operand0
argument_list|,
name|operand1
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
operator|!
name|reload_in_progress
condition|)
block|{
name|operands
index|[
literal|0
index|]
operator|=
name|validize_mem
argument_list|(
name|operand0
argument_list|)
expr_stmt|;
name|operands
index|[
literal|1
index|]
operator|=
name|operand1
operator|=
name|force_reg
argument_list|(
name|mode
argument_list|,
name|operand1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Simplify the source if we need to.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|operand1
argument_list|)
operator|!=
name|HIGH
operator|&&
name|immediate_operand
argument_list|(
name|operand1
argument_list|,
name|mode
argument_list|)
condition|)
block|{
if|if
condition|(
name|symbolic_operand
argument_list|(
name|operand1
argument_list|,
name|mode
argument_list|)
condition|)
block|{
if|if
condition|(
name|flag_pic
condition|)
block|{
name|rtx
name|temp
init|=
name|reload_in_progress
condition|?
name|operand0
else|:
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
decl_stmt|;
name|operands
index|[
literal|1
index|]
operator|=
name|legitimize_pic_address
argument_list|(
name|operand1
argument_list|,
name|mode
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
comment|/* On the HPPA, references to data space are supposed to */
comment|/* use dp, register 27. */
elseif|else
if|if
condition|(
name|read_only_operand
argument_list|(
name|operand1
argument_list|)
condition|)
block|{
name|rtx
name|set
init|=
name|gen_rtx
argument_list|(
name|SET
argument_list|,
name|VOIDmode
argument_list|,
name|operand0
argument_list|,
name|gen_rtx
argument_list|(
name|LO_SUM
argument_list|,
name|mode
argument_list|,
name|operand0
argument_list|,
name|operand1
argument_list|)
argument_list|)
decl_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx
argument_list|(
name|SET
argument_list|,
name|VOIDmode
argument_list|,
name|operand0
argument_list|,
name|gen_rtx
argument_list|(
name|HIGH
argument_list|,
name|mode
argument_list|,
name|operand1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_SHARED_LIBS
operator|&&
name|function_label_operand
argument_list|(
name|operand1
argument_list|,
name|mode
argument_list|)
condition|)
block|{
name|rtx
name|temp
init|=
name|reload_in_progress
condition|?
name|scratch_reg
else|:
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|temp
condition|)
name|abort
argument_list|()
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx
argument_list|(
name|PARALLEL
argument_list|,
name|VOIDmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|2
argument_list|,
name|set
argument_list|,
name|gen_rtx
argument_list|(
name|CLOBBER
argument_list|,
name|VOIDmode
argument_list|,
name|temp
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|emit_insn
argument_list|(
name|set
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
block|{
comment|/* If reload_in_progress, we can't use addil and r1; we */
comment|/* have to use the more expensive ldil sequence. */
if|if
condition|(
name|reload_in_progress
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_rtx
argument_list|(
name|SET
argument_list|,
name|VOIDmode
argument_list|,
name|operand0
argument_list|,
name|gen_rtx
argument_list|(
name|HIGH
argument_list|,
name|mode
argument_list|,
name|operand1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx
argument_list|(
name|SET
argument_list|,
name|VOIDmode
argument_list|,
name|operand0
argument_list|,
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|mode
argument_list|,
name|operand0
argument_list|,
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|mode
argument_list|,
literal|27
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx
argument_list|(
name|SET
argument_list|,
name|VOIDmode
argument_list|,
name|operand0
argument_list|,
name|gen_rtx
argument_list|(
name|LO_SUM
argument_list|,
name|mode
argument_list|,
name|operand0
argument_list|,
name|operand1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rtx
name|temp1
decl_stmt|,
name|temp2
init|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
decl_stmt|;
comment|/* For 2.4 we could set RTX_UNCHANGING and add a  		     REG_EQUAL note for the first insn.  This would  		     allow the first insn to be moved out of loops.  */
name|temp1
operator|=
name|gen_rtx
argument_list|(
name|HIGH
argument_list|,
name|mode
argument_list|,
name|operand1
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx
argument_list|(
name|SET
argument_list|,
name|VOIDmode
argument_list|,
name|temp2
argument_list|,
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|mode
argument_list|,
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|mode
argument_list|,
literal|27
argument_list|)
argument_list|,
name|temp1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx
argument_list|(
name|SET
argument_list|,
name|VOIDmode
argument_list|,
name|operand0
argument_list|,
name|gen_rtx
argument_list|(
name|LO_SUM
argument_list|,
name|mode
argument_list|,
name|temp2
argument_list|,
name|operand1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|depi_cint_operand
argument_list|(
name|operand1
argument_list|,
name|VOIDmode
argument_list|)
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|operand1
argument_list|)
operator|==
name|CONST_INT
condition|?
operator|(
operator|!
name|SMALL_INT
argument_list|(
name|operand1
argument_list|)
operator|&&
operator|(
name|INTVAL
argument_list|(
name|operand1
argument_list|)
operator|&
literal|0x7ff
operator|)
operator|!=
literal|0
operator|)
else|:
literal|1
condition|)
block|{
name|rtx
name|temp
init|=
name|reload_in_progress
condition|?
name|operand0
else|:
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
decl_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx
argument_list|(
name|SET
argument_list|,
name|VOIDmode
argument_list|,
name|temp
argument_list|,
name|gen_rtx
argument_list|(
name|HIGH
argument_list|,
name|mode
argument_list|,
name|operand1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|operands
index|[
literal|1
index|]
operator|=
name|gen_rtx
argument_list|(
name|LO_SUM
argument_list|,
name|mode
argument_list|,
name|temp
argument_list|,
name|operand1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Now have insn-emit do whatever it normally does.  */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Does operand (which is a symbolic_operand) live in text space? If    so SYMBOL_REF_FLAG, which is set by ENCODE_SECTION_INFO, will be true.*/
end_comment

begin_function
name|int
name|read_only_operand
parameter_list|(
name|operand
parameter_list|)
name|rtx
name|operand
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|operand
argument_list|)
operator|==
name|CONST
condition|)
name|operand
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|operand
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|operand
argument_list|)
operator|==
name|SYMBOL_REF
condition|)
return|return
name|SYMBOL_REF_FLAG
argument_list|(
name|operand
argument_list|)
operator|||
name|CONSTANT_POOL_ADDRESS_P
argument_list|(
name|operand
argument_list|)
return|;
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the best assembler insn template    for moving operands[1] into operands[0] as a fullword.  */
end_comment

begin_function
name|char
modifier|*
name|singlemove_string
parameter_list|(
name|operands
parameter_list|)
name|rtx
modifier|*
name|operands
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|MEM
condition|)
return|return
literal|"stw %r1,%0"
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|MEM
condition|)
return|return
literal|"ldw %1,%0"
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|CONST_INT
condition|)
if|if
condition|(
name|INT_14_BITS
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
return|return
operator|(
name|INTVAL
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
literal|0
condition|?
literal|"copy 0,%0"
else|:
literal|"ldi %1,%0"
operator|)
return|;
else|else
return|return
literal|"ldil L'%1,%0\n\tldo R'%1(%0),%0"
return|;
return|return
literal|"copy %1,%0"
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Compute position (in OPERANDS[2]) and width (in OPERANDS[3])    useful for copying or or'ing IMM to a register using bit field    instructions.  Store the immediate value to insert in OPERANDS[1].  */
end_comment

begin_function
name|void
name|compute_xdepi_operands_from_integer
parameter_list|(
name|imm
parameter_list|,
name|operands
parameter_list|)
name|unsigned
name|imm
decl_stmt|;
name|rtx
modifier|*
name|operands
decl_stmt|;
block|{
name|int
name|lsb
decl_stmt|,
name|len
decl_stmt|;
comment|/* Find the least significant set bit in IMM.  */
for|for
control|(
name|lsb
operator|=
literal|0
init|;
name|lsb
operator|<
literal|32
condition|;
name|lsb
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|imm
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
break|break;
name|imm
operator|>>=
literal|1
expr_stmt|;
block|}
comment|/* Choose variants based on *sign* of the 5-bit field.  */
if|if
condition|(
operator|(
name|imm
operator|&
literal|0x10
operator|)
operator|==
literal|0
condition|)
name|len
operator|=
operator|(
name|lsb
operator|<=
literal|28
operator|)
condition|?
literal|4
else|:
literal|32
operator|-
name|lsb
expr_stmt|;
else|else
block|{
comment|/* Find the width of the bitstring in IMM.  */
for|for
control|(
name|len
operator|=
literal|5
init|;
name|len
operator|<
literal|32
condition|;
name|len
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|imm
operator|&
operator|(
literal|1
operator|<<
name|len
operator|)
operator|)
operator|==
literal|0
condition|)
break|break;
block|}
comment|/* Sign extend IMM as a 5-bit value.  */
name|imm
operator|=
operator|(
name|imm
operator|&
literal|0xf
operator|)
operator|-
literal|0x10
expr_stmt|;
block|}
name|operands
index|[
literal|1
index|]
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|imm
argument_list|)
expr_stmt|;
name|operands
index|[
literal|2
index|]
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
literal|31
operator|-
name|lsb
argument_list|)
expr_stmt|;
name|operands
index|[
literal|3
index|]
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output assembler code to perform a doubleword move insn    with operands OPERANDS.  */
end_comment

begin_function
name|char
modifier|*
name|output_move_double
parameter_list|(
name|operands
parameter_list|)
name|rtx
modifier|*
name|operands
decl_stmt|;
block|{
enum|enum
block|{
name|REGOP
block|,
name|OFFSOP
block|,
name|MEMOP
block|,
name|CNSTOP
block|,
name|RNDOP
block|}
name|optype0
enum|,
name|optype1
expr_stmt|;
name|rtx
name|latehalf
index|[
literal|2
index|]
decl_stmt|;
name|rtx
name|addreg0
init|=
literal|0
decl_stmt|,
name|addreg1
init|=
literal|0
decl_stmt|;
comment|/* First classify both operands.  */
if|if
condition|(
name|REG_P
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
condition|)
name|optype0
operator|=
name|REGOP
expr_stmt|;
elseif|else
if|if
condition|(
name|offsettable_memref_p
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
condition|)
name|optype0
operator|=
name|OFFSOP
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|MEM
condition|)
name|optype0
operator|=
name|MEMOP
expr_stmt|;
else|else
name|optype0
operator|=
name|RNDOP
expr_stmt|;
if|if
condition|(
name|REG_P
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
name|optype1
operator|=
name|REGOP
expr_stmt|;
elseif|else
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
name|optype1
operator|=
name|CNSTOP
expr_stmt|;
elseif|else
if|if
condition|(
name|offsettable_memref_p
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
name|optype1
operator|=
name|OFFSOP
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|MEM
condition|)
name|optype1
operator|=
name|MEMOP
expr_stmt|;
else|else
name|optype1
operator|=
name|RNDOP
expr_stmt|;
comment|/* Check for the cases that the operand constraints are not      supposed to allow to happen.  Abort if we get one,      because generating code for these cases is painful.  */
if|if
condition|(
name|optype0
operator|!=
name|REGOP
operator|&&
name|optype1
operator|!=
name|REGOP
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Handle auto decrementing and incrementing loads and stores      specifically, since the structure of the function doesn't work      for them without major modification.  Do it better when we learn      this port about the general inc/dec addressing of PA.      (This was written by tege.  Chide him if it doesn't work.)  */
if|if
condition|(
name|optype0
operator|==
name|MEMOP
condition|)
block|{
comment|/* We have to output the address syntax ourselves, since print_operand 	 doesn't deal with the addresses we want to use.  Fix this later.  */
name|rtx
name|addr
init|=
name|XEXP
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|POST_INC
operator|||
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|POST_DEC
condition|)
block|{
name|rtx
name|high_reg
init|=
name|gen_rtx
argument_list|(
name|SUBREG
argument_list|,
name|SImode
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|operands
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|!=
name|REG
operator|||
name|GET_CODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|!=
name|REG
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|reg_overlap_mentioned_p
argument_list|(
name|high_reg
argument_list|,
name|addr
argument_list|)
condition|)
block|{
comment|/* No overlap between high target register and address 		 register.  (We do this in a non-obvious way to 		 save a register file writeback)  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|POST_INC
condition|)
return|return
literal|"stws,ma %1,8(0,%0)\n\tstw %R1,-4(0,%0)"
return|;
return|return
literal|"stws,ma %1,-8(0,%0)\n\tstw %R1,12(0,%0)"
return|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|PRE_INC
operator|||
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|PRE_DEC
condition|)
block|{
name|rtx
name|high_reg
init|=
name|gen_rtx
argument_list|(
name|SUBREG
argument_list|,
name|SImode
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|operands
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|!=
name|REG
operator|||
name|GET_CODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|!=
name|REG
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|reg_overlap_mentioned_p
argument_list|(
name|high_reg
argument_list|,
name|addr
argument_list|)
condition|)
block|{
comment|/* No overlap between high target register and address 		 register.  (We do this in a non-obvious way to 		 save a register file writeback)  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|PRE_INC
condition|)
return|return
literal|"stws,mb %1,8(0,%0)\n\tstw %R1,4(0,%0)"
return|;
return|return
literal|"stws,mb %1,-8(0,%0)\n\tstw %R1,4(0,%0)"
return|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|optype1
operator|==
name|MEMOP
condition|)
block|{
comment|/* We have to output the address syntax ourselves, since print_operand 	 doesn't deal with the addresses we want to use.  Fix this later.  */
name|rtx
name|addr
init|=
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|POST_INC
operator|||
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|POST_DEC
condition|)
block|{
name|rtx
name|high_reg
init|=
name|gen_rtx
argument_list|(
name|SUBREG
argument_list|,
name|SImode
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|operands
index|[
literal|1
index|]
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|!=
name|REG
operator|||
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|!=
name|REG
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|reg_overlap_mentioned_p
argument_list|(
name|high_reg
argument_list|,
name|addr
argument_list|)
condition|)
block|{
comment|/* No overlap between high target register and address 		 register.  (We do this in a non-obvious way to 		 save a register file writeback)  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|POST_INC
condition|)
return|return
literal|"ldws,ma 8(0,%1),%0\n\tldw -4(0,%1),%R0"
return|;
return|return
literal|"ldws,ma -8(0,%1),%0\n\tldw 12(0,%1),%R0"
return|;
block|}
else|else
block|{
comment|/* This is an undefined situation.  We should load into the 		 address register *and* update that register.  Probably 		 we don't need to handle this at all.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|POST_INC
condition|)
return|return
literal|"ldw 4(0,%1),%R0\n\tldws,ma 8(0,%1),%0"
return|;
return|return
literal|"ldw 4(0,%1),%R0\n\tldws,ma -8(0,%1),%0"
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|PRE_INC
operator|||
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|PRE_DEC
condition|)
block|{
name|rtx
name|high_reg
init|=
name|gen_rtx
argument_list|(
name|SUBREG
argument_list|,
name|SImode
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|operands
index|[
literal|1
index|]
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|!=
name|REG
operator|||
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|!=
name|REG
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|reg_overlap_mentioned_p
argument_list|(
name|high_reg
argument_list|,
name|addr
argument_list|)
condition|)
block|{
comment|/* No overlap between high target register and address 		 register.  (We do this in a non-obvious way to 		 save a register file writeback)  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|PRE_INC
condition|)
return|return
literal|"ldws,mb 8(0,%1),%0\n\tldw 4(0,%1),%R0"
return|;
return|return
literal|"ldws,mb -8(0,%1),%0\n\tldw 4(0,%1),%R0"
return|;
block|}
else|else
block|{
comment|/* This is an undefined situation.  We should load into the 		 address register *and* update that register.  Probably 		 we don't need to handle this at all.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|PRE_INC
condition|)
return|return
literal|"ldw 12(0,%1),%R0\n\tldws,mb 8(0,%1),%0"
return|;
return|return
literal|"ldw -4(0,%1),%R0\n\tldws,mb -8(0,%1),%0"
return|;
block|}
block|}
block|}
comment|/* If an operand is an unoffsettable memory ref, find a register      we can increment temporarily to make it refer to the second word.  */
if|if
condition|(
name|optype0
operator|==
name|MEMOP
condition|)
name|addreg0
operator|=
name|find_addr_reg
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|optype1
operator|==
name|MEMOP
condition|)
name|addreg1
operator|=
name|find_addr_reg
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Ok, we can do one word at a time.      Normally we do the low-numbered word first.       In either case, set up in LATEHALF the operands to use      for the high-numbered word and in some cases alter the      operands in OPERANDS to be suitable for the low-numbered word.  */
if|if
condition|(
name|optype0
operator|==
name|REGOP
condition|)
name|latehalf
index|[
literal|0
index|]
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|SImode
argument_list|,
name|REGNO
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|optype0
operator|==
name|OFFSOP
condition|)
name|latehalf
index|[
literal|0
index|]
operator|=
name|adj_offsettable_operand
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|4
argument_list|)
expr_stmt|;
else|else
name|latehalf
index|[
literal|0
index|]
operator|=
name|operands
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|optype1
operator|==
name|REGOP
condition|)
name|latehalf
index|[
literal|1
index|]
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|SImode
argument_list|,
name|REGNO
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|optype1
operator|==
name|OFFSOP
condition|)
name|latehalf
index|[
literal|1
index|]
operator|=
name|adj_offsettable_operand
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|4
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|optype1
operator|==
name|CNSTOP
condition|)
name|split_double
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
operator|&
name|operands
index|[
literal|1
index|]
argument_list|,
operator|&
name|latehalf
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
else|else
name|latehalf
index|[
literal|1
index|]
operator|=
name|operands
index|[
literal|1
index|]
expr_stmt|;
comment|/* If the first move would clobber the source of the second one,      do them in the other order.       RMS says "This happens only for registers;      such overlap can't happen in memory unless the user explicitly      sets it up, and that is an undefined circumstance."       but it happens on the HP-PA when loading parameter registers,      so I am going to define that circumstance, and make it work      as expected.  */
if|if
condition|(
name|optype0
operator|==
name|REGOP
operator|&&
operator|(
name|optype1
operator|==
name|MEMOP
operator|||
name|optype1
operator|==
name|OFFSOP
operator|)
operator|&&
name|reg_overlap_mentioned_p
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
comment|/* XXX THIS PROBABLY DOESN'T WORK.  */
comment|/* Do the late half first.  */
if|if
condition|(
name|addreg1
condition|)
name|output_asm_insn
argument_list|(
literal|"ldo 4(%0),%0"
argument_list|,
operator|&
name|addreg1
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
name|singlemove_string
argument_list|(
name|latehalf
argument_list|)
argument_list|,
name|latehalf
argument_list|)
expr_stmt|;
if|if
condition|(
name|addreg1
condition|)
name|output_asm_insn
argument_list|(
literal|"ldo -4(%0),%0"
argument_list|,
operator|&
name|addreg1
argument_list|)
expr_stmt|;
comment|/* Then clobber.  */
return|return
name|singlemove_string
argument_list|(
name|operands
argument_list|)
return|;
block|}
if|if
condition|(
name|optype0
operator|==
name|REGOP
operator|&&
name|optype1
operator|==
name|REGOP
operator|&&
name|REGNO
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|REGNO
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|+
literal|1
condition|)
block|{
name|output_asm_insn
argument_list|(
name|singlemove_string
argument_list|(
name|latehalf
argument_list|)
argument_list|,
name|latehalf
argument_list|)
expr_stmt|;
return|return
name|singlemove_string
argument_list|(
name|operands
argument_list|)
return|;
block|}
comment|/* Normal case: do the two words, low-numbered first.  */
name|output_asm_insn
argument_list|(
name|singlemove_string
argument_list|(
name|operands
argument_list|)
argument_list|,
name|operands
argument_list|)
expr_stmt|;
comment|/* Make any unoffsettable addresses point at high-numbered word.  */
if|if
condition|(
name|addreg0
condition|)
name|output_asm_insn
argument_list|(
literal|"ldo 4(%0),%0"
argument_list|,
operator|&
name|addreg0
argument_list|)
expr_stmt|;
if|if
condition|(
name|addreg1
condition|)
name|output_asm_insn
argument_list|(
literal|"ldo 4(%0),%0"
argument_list|,
operator|&
name|addreg1
argument_list|)
expr_stmt|;
comment|/* Do that word.  */
name|output_asm_insn
argument_list|(
name|singlemove_string
argument_list|(
name|latehalf
argument_list|)
argument_list|,
name|latehalf
argument_list|)
expr_stmt|;
comment|/* Undo the adds we just did.  */
if|if
condition|(
name|addreg0
condition|)
name|output_asm_insn
argument_list|(
literal|"ldo -4(%0),%0"
argument_list|,
operator|&
name|addreg0
argument_list|)
expr_stmt|;
if|if
condition|(
name|addreg1
condition|)
name|output_asm_insn
argument_list|(
literal|"ldo -4(%0),%0"
argument_list|,
operator|&
name|addreg1
argument_list|)
expr_stmt|;
return|return
literal|""
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|char
modifier|*
name|output_fp_move_double
parameter_list|(
name|operands
parameter_list|)
name|rtx
modifier|*
name|operands
decl_stmt|;
block|{
if|if
condition|(
name|FP_REG_P
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|FP_REG_P
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
name|output_asm_insn
argument_list|(
literal|"fcpy,dbl %1,%0"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|REG
condition|)
block|{
name|rtx
name|xoperands
index|[
literal|3
index|]
decl_stmt|;
name|xoperands
index|[
literal|0
index|]
operator|=
name|operands
index|[
literal|0
index|]
expr_stmt|;
name|xoperands
index|[
literal|1
index|]
operator|=
name|operands
index|[
literal|1
index|]
expr_stmt|;
name|xoperands
index|[
literal|2
index|]
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|SImode
argument_list|,
name|REGNO
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"stw %1,-16(0,30)\n\tstw %2,-12(0,30)\n\tfldds -16(0,30),%0"
argument_list|,
name|xoperands
argument_list|)
expr_stmt|;
block|}
else|else
name|output_asm_insn
argument_list|(
literal|"fldds%F1 %1,%0"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|FP_REG_P
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|REG
condition|)
block|{
name|rtx
name|xoperands
index|[
literal|3
index|]
decl_stmt|;
name|xoperands
index|[
literal|2
index|]
operator|=
name|operands
index|[
literal|1
index|]
expr_stmt|;
name|xoperands
index|[
literal|1
index|]
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|SImode
argument_list|,
name|REGNO
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|xoperands
index|[
literal|0
index|]
operator|=
name|operands
index|[
literal|0
index|]
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"fstds %2,-16(0,30)\n\tldw -12(0,30),%1\n\tldw -16(0,30),%0"
argument_list|,
name|xoperands
argument_list|)
expr_stmt|;
block|}
else|else
name|output_asm_insn
argument_list|(
literal|"fstds%F0 %1,%0"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
return|return
literal|""
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return a REG that occurs in ADDR with coefficient 1.    ADDR can be effectively incremented by incrementing REG.  */
end_comment

begin_function
specifier|static
name|rtx
name|find_addr_reg
parameter_list|(
name|addr
parameter_list|)
name|rtx
name|addr
decl_stmt|;
block|{
while|while
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|PLUS
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|REG
condition|)
return|return
name|addr
return|;
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Emit code to perform a block move.     Restriction: If the length argument is non-constant, alignment    must be 4.     OPERANDS[0] is the destination pointer as a REG, clobbered.    OPERANDS[1] is the source pointer as a REG, clobbered.    if SIZE_IS_CONSTANT      OPERANDS[2] is a register for temporary storage.      OPERANDS[4] is the size as a CONST_INT    else      OPERANDS[2] is a REG which will contain the size, clobbered.    OPERANDS[3] is a register for temporary storage.    OPERANDS[5] is the alignment safe to use, as a CONST_INT.  */
end_comment

begin_function
name|char
modifier|*
name|output_block_move
parameter_list|(
name|operands
parameter_list|,
name|size_is_constant
parameter_list|)
name|rtx
modifier|*
name|operands
decl_stmt|;
name|int
name|size_is_constant
decl_stmt|;
block|{
name|int
name|align
init|=
name|INTVAL
argument_list|(
name|operands
index|[
literal|5
index|]
argument_list|)
decl_stmt|;
name|unsigned
name|long
name|n_bytes
decl_stmt|;
comment|/* We can't move more than four bytes at a time because the PA      has no longer integer move insns.  (Could use fp mem ops?)  */
if|if
condition|(
name|align
operator|>
literal|4
condition|)
name|align
operator|=
literal|4
expr_stmt|;
if|if
condition|(
name|size_is_constant
condition|)
block|{
name|unsigned
name|long
name|n_items
decl_stmt|;
name|unsigned
name|long
name|offset
decl_stmt|;
name|rtx
name|temp
decl_stmt|;
name|n_bytes
operator|=
name|INTVAL
argument_list|(
name|operands
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|n_bytes
operator|==
literal|0
condition|)
return|return
literal|""
return|;
if|if
condition|(
name|align
operator|>=
literal|4
condition|)
block|{
comment|/* Don't unroll too large blocks.  */
if|if
condition|(
name|n_bytes
operator|>
literal|64
condition|)
goto|goto
name|copy_with_loop
goto|;
comment|/* Read and store using two registers, and hide latency 	     by deferring the stores until three instructions after 	     the corresponding load.  The last load insn will read 	     the entire word were the last bytes are, possibly past 	     the end of the source block, but since loads are aligned, 	     this is harmless.  */
name|output_asm_insn
argument_list|(
literal|"ldws,ma 4(0,%1),%2"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
for|for
control|(
name|offset
operator|=
literal|4
init|;
name|offset
operator|<
name|n_bytes
condition|;
name|offset
operator|+=
literal|4
control|)
block|{
name|output_asm_insn
argument_list|(
literal|"ldws,ma 4(0,%1),%3"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"stws,ma %2,4(0,%0)"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
name|temp
operator|=
name|operands
index|[
literal|2
index|]
expr_stmt|;
name|operands
index|[
literal|2
index|]
operator|=
name|operands
index|[
literal|3
index|]
expr_stmt|;
name|operands
index|[
literal|3
index|]
operator|=
name|temp
expr_stmt|;
block|}
if|if
condition|(
name|n_bytes
operator|%
literal|4
operator|==
literal|0
condition|)
comment|/* Store the last word.  */
name|output_asm_insn
argument_list|(
literal|"stw %2,0(0,%0)"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Store the last, partial word.  */
name|operands
index|[
literal|4
index|]
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|n_bytes
operator|%
literal|4
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"stbys,e %2,%4(0,%0)"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
block|}
return|return
literal|""
return|;
block|}
if|if
condition|(
name|align
operator|>=
literal|2
operator|&&
name|n_bytes
operator|>=
literal|2
condition|)
block|{
name|output_asm_insn
argument_list|(
literal|"ldhs,ma 2(0,%1),%2"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
for|for
control|(
name|offset
operator|=
literal|2
init|;
name|offset
operator|+
literal|2
operator|<=
name|n_bytes
condition|;
name|offset
operator|+=
literal|2
control|)
block|{
name|output_asm_insn
argument_list|(
literal|"ldhs,ma 2(0,%1),%3"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"sths,ma %2,2(0,%0)"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
name|temp
operator|=
name|operands
index|[
literal|2
index|]
expr_stmt|;
name|operands
index|[
literal|2
index|]
operator|=
name|operands
index|[
literal|3
index|]
expr_stmt|;
name|operands
index|[
literal|3
index|]
operator|=
name|temp
expr_stmt|;
block|}
if|if
condition|(
name|n_bytes
operator|%
literal|2
operator|!=
literal|0
condition|)
name|output_asm_insn
argument_list|(
literal|"ldb 0(0,%1),%3"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"sths,ma %2,2(0,%0)"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
if|if
condition|(
name|n_bytes
operator|%
literal|2
operator|!=
literal|0
condition|)
name|output_asm_insn
argument_list|(
literal|"stb %3,0(0,%0)"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
return|return
literal|""
return|;
block|}
name|output_asm_insn
argument_list|(
literal|"ldbs,ma 1(0,%1),%2"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
for|for
control|(
name|offset
operator|=
literal|1
init|;
name|offset
operator|+
literal|1
operator|<=
name|n_bytes
condition|;
name|offset
operator|+=
literal|1
control|)
block|{
name|output_asm_insn
argument_list|(
literal|"ldbs,ma 1(0,%1),%3"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"stbs,ma %2,1(0,%0)"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
name|temp
operator|=
name|operands
index|[
literal|2
index|]
expr_stmt|;
name|operands
index|[
literal|2
index|]
operator|=
name|operands
index|[
literal|3
index|]
expr_stmt|;
name|operands
index|[
literal|3
index|]
operator|=
name|temp
expr_stmt|;
block|}
name|output_asm_insn
argument_list|(
literal|"stb %2,0(0,%0)"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
return|return
literal|""
return|;
block|}
if|if
condition|(
name|align
operator|!=
literal|4
condition|)
name|abort
argument_list|()
expr_stmt|;
name|copy_with_loop
label|:
if|if
condition|(
name|size_is_constant
condition|)
block|{
comment|/* Size is compile-time determined, and also not 	 very small (such small cases are handled above).  */
name|operands
index|[
literal|4
index|]
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|n_bytes
operator|-
literal|4
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"ldo %4(0),%2"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Decrement counter by 4, and if it becomes negative, jump past the 	 word copying loop.  */
name|output_asm_insn
argument_list|(
literal|"addib,<,n -4,%2,.+16"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
block|}
comment|/* Copying loop.  Note that the first load is in the annulled delay slot      of addib.  Is it OK on PA to have a load in a delay slot, i.e. is a      possible page fault stopped in time?  */
name|output_asm_insn
argument_list|(
literal|"ldws,ma 4(0,%1),%3"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"addib,>= -4,%2,.-4"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"stws,ma %3,4(0,%0)"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
comment|/* The counter is negative,>= -4.  The remaining number of bytes are      determined by the two least significant bits.  */
if|if
condition|(
name|size_is_constant
condition|)
block|{
if|if
condition|(
name|n_bytes
operator|%
literal|4
operator|!=
literal|0
condition|)
block|{
comment|/* Read the entire word of the source block tail.  */
name|output_asm_insn
argument_list|(
literal|"ldw 0(0,%1),%3"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
name|operands
index|[
literal|4
index|]
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|n_bytes
operator|%
literal|4
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"stbys,e %3,%4(0,%0)"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Add 4 to counter.  If it becomes zero, we're done.  */
name|output_asm_insn
argument_list|(
literal|"addib,=,n 4,%2,.+16"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
comment|/* Read the entire word of the source block tail.  (Also this 	 load is in an annulled delay slot.)  */
name|output_asm_insn
argument_list|(
literal|"ldw 0(0,%1),%3"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
comment|/* Make %0 point at the first byte after the destination block.  */
name|output_asm_insn
argument_list|(
literal|"add %2,%0,%0"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
comment|/* Store the leftmost bytes, up to, but not including, the address 	 in %0.  */
name|output_asm_insn
argument_list|(
literal|"stbys,e %3,0(0,%0)"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
block|}
return|return
literal|""
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|char
modifier|*
name|output_and
parameter_list|(
name|operands
parameter_list|)
name|rtx
modifier|*
name|operands
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|unsigned
name|mask
init|=
name|INTVAL
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
decl_stmt|;
name|int
name|ls0
decl_stmt|,
name|ls1
decl_stmt|,
name|ms0
decl_stmt|,
name|p
decl_stmt|,
name|len
decl_stmt|;
for|for
control|(
name|ls0
operator|=
literal|0
init|;
name|ls0
operator|<
literal|32
condition|;
name|ls0
operator|++
control|)
if|if
condition|(
operator|(
name|mask
operator|&
operator|(
literal|1
operator|<<
name|ls0
operator|)
operator|)
operator|==
literal|0
condition|)
break|break;
for|for
control|(
name|ls1
operator|=
name|ls0
init|;
name|ls1
operator|<
literal|32
condition|;
name|ls1
operator|++
control|)
if|if
condition|(
operator|(
name|mask
operator|&
operator|(
literal|1
operator|<<
name|ls1
operator|)
operator|)
operator|!=
literal|0
condition|)
break|break;
for|for
control|(
name|ms0
operator|=
name|ls1
init|;
name|ms0
operator|<
literal|32
condition|;
name|ms0
operator|++
control|)
if|if
condition|(
operator|(
name|mask
operator|&
operator|(
literal|1
operator|<<
name|ms0
operator|)
operator|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|ms0
operator|!=
literal|32
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|ls1
operator|==
literal|32
condition|)
block|{
name|len
operator|=
name|ls0
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|operands
index|[
literal|2
index|]
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
literal|"extru %1,31,%2,%0"
return|;
block|}
else|else
block|{
comment|/* We could use this `depi' for the case above as well, but `depi' 	     requires one more register file access than an `extru'.  */
name|p
operator|=
literal|31
operator|-
name|ls0
expr_stmt|;
name|len
operator|=
name|ls1
operator|-
name|ls0
expr_stmt|;
name|operands
index|[
literal|2
index|]
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|operands
index|[
literal|3
index|]
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
literal|"depi 0,%2,%3,%0"
return|;
block|}
block|}
else|else
return|return
literal|"and %1,%2,%0"
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|output_ior
parameter_list|(
name|operands
parameter_list|)
name|rtx
modifier|*
name|operands
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|unsigned
name|mask
init|=
name|INTVAL
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
decl_stmt|;
name|int
name|bs0
decl_stmt|,
name|bs1
decl_stmt|,
name|bs2
decl_stmt|,
name|p
decl_stmt|,
name|len
decl_stmt|;
if|if
condition|(
name|INTVAL
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|"copy %1,%0"
return|;
for|for
control|(
name|bs0
operator|=
literal|0
init|;
name|bs0
operator|<
literal|32
condition|;
name|bs0
operator|++
control|)
if|if
condition|(
operator|(
name|mask
operator|&
operator|(
literal|1
operator|<<
name|bs0
operator|)
operator|)
operator|!=
literal|0
condition|)
break|break;
for|for
control|(
name|bs1
operator|=
name|bs0
init|;
name|bs1
operator|<
literal|32
condition|;
name|bs1
operator|++
control|)
if|if
condition|(
operator|(
name|mask
operator|&
operator|(
literal|1
operator|<<
name|bs1
operator|)
operator|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|bs1
operator|!=
literal|32
operator|&&
operator|(
operator|(
name|unsigned
operator|)
literal|1
operator|<<
name|bs1
operator|)
operator|<=
name|mask
condition|)
name|abort
argument_list|()
expr_stmt|;
name|p
operator|=
literal|31
operator|-
name|bs0
expr_stmt|;
name|len
operator|=
name|bs1
operator|-
name|bs0
expr_stmt|;
name|operands
index|[
literal|2
index|]
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|operands
index|[
literal|3
index|]
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
literal|"depi -1,%2,%3,%0"
return|;
block|}
else|else
return|return
literal|"or %1,%2,%0"
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output an ascii string.  */
end_comment

begin_macro
name|output_ascii
argument_list|(
argument|file
argument_list|,
argument|p
argument_list|,
argument|size
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|size
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
name|int
name|chars_output
decl_stmt|;
name|unsigned
name|char
name|partial_output
index|[
literal|16
index|]
decl_stmt|;
comment|/* Max space 4 chars can occupy.   */
comment|/* The HP assembler can only take strings of 256 characters at one      time.  This is a limitation on input line length, *not* the      length of the string.  Sigh.  Even worse, it seems that the      restriction is in number of input characters (see \xnn&      \whatever).  So we have to do this very carefully.  */
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.STRING \""
argument_list|)
expr_stmt|;
name|chars_output
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|+=
literal|4
control|)
block|{
name|int
name|co
init|=
literal|0
decl_stmt|;
name|int
name|io
init|=
literal|0
decl_stmt|;
for|for
control|(
name|io
operator|=
literal|0
operator|,
name|co
operator|=
literal|0
init|;
name|io
operator|<
name|MIN
argument_list|(
literal|4
argument_list|,
name|size
operator|-
name|i
argument_list|)
condition|;
name|io
operator|++
control|)
block|{
specifier|register
name|unsigned
name|int
name|c
init|=
name|p
index|[
name|i
operator|+
name|io
index|]
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\"'
operator|||
name|c
operator|==
literal|'\\'
condition|)
name|partial_output
index|[
name|co
operator|++
index|]
operator|=
literal|'\\'
expr_stmt|;
if|if
condition|(
name|c
operator|>=
literal|' '
operator|&&
name|c
operator|<
literal|0177
condition|)
name|partial_output
index|[
name|co
operator|++
index|]
operator|=
name|c
expr_stmt|;
else|else
block|{
name|unsigned
name|int
name|hexd
decl_stmt|;
name|partial_output
index|[
name|co
operator|++
index|]
operator|=
literal|'\\'
expr_stmt|;
name|partial_output
index|[
name|co
operator|++
index|]
operator|=
literal|'x'
expr_stmt|;
name|hexd
operator|=
name|c
operator|/
literal|16
operator|-
literal|0
operator|+
literal|'0'
expr_stmt|;
if|if
condition|(
name|hexd
operator|>
literal|'9'
condition|)
name|hexd
operator|-=
literal|'9'
operator|-
literal|'a'
operator|+
literal|1
expr_stmt|;
name|partial_output
index|[
name|co
operator|++
index|]
operator|=
name|hexd
expr_stmt|;
name|hexd
operator|=
name|c
operator|%
literal|16
operator|-
literal|0
operator|+
literal|'0'
expr_stmt|;
if|if
condition|(
name|hexd
operator|>
literal|'9'
condition|)
name|hexd
operator|-=
literal|'9'
operator|-
literal|'a'
operator|+
literal|1
expr_stmt|;
name|partial_output
index|[
name|co
operator|++
index|]
operator|=
name|hexd
expr_stmt|;
block|}
block|}
if|if
condition|(
name|chars_output
operator|+
name|co
operator|>
literal|243
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\"\n\t.STRING \""
argument_list|)
expr_stmt|;
name|chars_output
operator|=
literal|0
expr_stmt|;
block|}
name|fwrite
argument_list|(
name|partial_output
argument_list|,
literal|1
argument_list|,
name|co
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|chars_output
operator|+=
name|co
expr_stmt|;
name|co
operator|=
literal|0
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\"\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* You may have trouble believing this, but this is the HP825 stack    layout.  Wow.     Offset		Contents     Variable arguments	(optional; any number may be allocated)     SP-(4*(N+9))		arg word N    	:		    :       SP-56		arg word 5       SP-52		arg word 4     Fixed arguments	(must be allocated; may remain unused)        SP-48		arg word 3       SP-44		arg word 2       SP-40		arg word 1       SP-36		arg word 0     Frame Marker        SP-32		External Data Pointer (DP)       SP-28		External sr4       SP-24		External/stub RP (RP')       SP-20		Current RP       SP-16		Static Link       SP-12		Clean up       SP-8		Calling Stub RP (RP'')       SP-4		Previous SP     Top of Frame        SP-0		Stack Pointer (points to next available address)  */
end_comment

begin_comment
comment|/* This function saves registers as follows.  Registers marked with ' are    this function's registers (as opposed to the previous function's).    If a frame_pointer isn't needed, r4 is saved as a general register;    the space for the frame pointer is still allocated, though, to keep    things simple.      Top of Frame         SP (FP')		Previous FP        SP + 4		Alignment filler (sigh)        SP + 8		Space for locals reserved here.        .        .        .        SP + n		All call saved register used.        .        .        .        SP + o		All call saved fp registers used.        .        .        .        SP + p (SP')	points to next available address.         */
end_comment

begin_comment
comment|/* Helper functions */
end_comment

begin_function
name|void
name|print_stw
parameter_list|(
name|file
parameter_list|,
name|r
parameter_list|,
name|disp
parameter_list|,
name|base
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|int
name|r
decl_stmt|,
name|disp
decl_stmt|,
name|base
decl_stmt|;
block|{
if|if
condition|(
name|VAL_14_BITS_P
argument_list|(
name|disp
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tstw %d,%d(0,%d)\n"
argument_list|,
name|r
argument_list|,
name|disp
argument_list|,
name|base
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\taddil L'%d,%d\n\tstw %d,R'%d(0,1)\n"
argument_list|,
name|disp
argument_list|,
name|base
argument_list|,
name|r
argument_list|,
name|disp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|print_ldw
parameter_list|(
name|file
parameter_list|,
name|r
parameter_list|,
name|disp
parameter_list|,
name|base
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|int
name|r
decl_stmt|,
name|disp
decl_stmt|,
name|base
decl_stmt|;
block|{
if|if
condition|(
name|VAL_14_BITS_P
argument_list|(
name|disp
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tldw %d(0,%d),%d\n"
argument_list|,
name|disp
argument_list|,
name|base
argument_list|,
name|r
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\taddil L'%d,%d\n\tldw R'%d(0,1),%d\n"
argument_list|,
name|disp
argument_list|,
name|base
argument_list|,
name|disp
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Global variables set by FUNCTION_PROLOGUE.  */
end_comment

begin_comment
comment|/* Size of frame.  Need to know this to emit return insns from    leaf procedures.  */
end_comment

begin_decl_stmt
name|int
name|apparent_fsize
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|actual_fsize
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|local_fsize
decl_stmt|,
name|save_fregs
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|compute_frame_size
parameter_list|(
name|size
parameter_list|,
name|leaf_function
parameter_list|,
name|fregs_live
parameter_list|)
name|int
name|size
decl_stmt|;
name|int
name|leaf_function
decl_stmt|;
name|int
modifier|*
name|fregs_live
decl_stmt|;
block|{
specifier|extern
name|int
name|current_function_outgoing_args_size
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 8 is space for frame pointer + filler */
name|local_fsize
operator|=
name|actual_fsize
operator|=
name|size
operator|+
literal|8
expr_stmt|;
comment|/* fp is stored in a special place. */
for|for
control|(
name|i
operator|=
literal|18
init|;
name|i
operator|>=
literal|5
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|i
index|]
condition|)
name|actual_fsize
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|regs_ever_live
index|[
literal|3
index|]
condition|)
name|actual_fsize
operator|+=
literal|4
expr_stmt|;
name|actual_fsize
operator|=
operator|(
name|actual_fsize
operator|+
literal|7
operator|)
operator|&
operator|~
literal|7
expr_stmt|;
if|if
condition|(
operator|!
name|TARGET_SNAKE
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|47
init|;
name|i
operator|>=
literal|44
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|i
index|]
condition|)
block|{
name|actual_fsize
operator|+=
literal|8
expr_stmt|;
if|if
condition|(
name|fregs_live
condition|)
operator|*
name|fregs_live
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|90
init|;
name|i
operator|>=
literal|72
condition|;
name|i
operator|-=
literal|2
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|i
index|]
operator|||
name|regs_ever_live
index|[
name|i
operator|+
literal|1
index|]
condition|)
block|{
name|actual_fsize
operator|+=
literal|8
expr_stmt|;
if|if
condition|(
name|fregs_live
condition|)
operator|*
name|fregs_live
operator|=
literal|1
expr_stmt|;
block|}
block|}
return|return
name|actual_fsize
operator|+
name|current_function_outgoing_args_size
return|;
block|}
end_function

begin_function
name|void
name|output_function_prologue
parameter_list|(
name|file
parameter_list|,
name|size
parameter_list|,
name|leaf_function
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|int
name|size
decl_stmt|;
name|int
name|leaf_function
decl_stmt|;
block|{
specifier|extern
name|char
name|call_used_regs
index|[]
decl_stmt|;
specifier|extern
name|int
name|frame_pointer_needed
decl_stmt|;
specifier|extern
name|int
name|current_function_returns_struct
decl_stmt|;
name|int
name|i
decl_stmt|,
name|offset
decl_stmt|;
name|save_fregs
operator|=
literal|0
expr_stmt|;
name|actual_fsize
operator|=
name|compute_frame_size
argument_list|(
name|size
argument_list|,
name|leaf_function
argument_list|,
operator|&
name|save_fregs
argument_list|)
operator|+
literal|32
expr_stmt|;
if|if
condition|(
name|TARGET_SNAKE
condition|)
name|actual_fsize
operator|=
operator|(
name|actual_fsize
operator|+
literal|63
operator|)
operator|&
operator|~
literal|63
expr_stmt|;
comment|/* Let's not try to bullshit more than we need to here. */
comment|/* This might be right a lot of the time */
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.PROC\n\t.CALLINFO FRAME=%d"
argument_list|,
name|actual_fsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|regs_ever_live
index|[
literal|2
index|]
operator|||
name|profile_flag
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|",CALLS,SAVE_RP\n"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|",NO_CALLS\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.ENTRY\n"
argument_list|)
expr_stmt|;
comment|/* Some registers have places to go in the current stack      structure.  */
if|if
condition|(
name|regs_ever_live
index|[
literal|2
index|]
operator|||
name|profile_flag
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tstw 2,-20(0,30)\n"
argument_list|)
expr_stmt|;
comment|/* Reserve space for local variables.  */
if|if
condition|(
name|frame_pointer_needed
condition|)
block|{
if|if
condition|(
name|VAL_14_BITS_P
argument_list|(
name|actual_fsize
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tcopy 4,1\n\tcopy 30,4\n\tstwm 1,%d(0,30)\n"
argument_list|,
name|actual_fsize
argument_list|)
expr_stmt|;
else|else
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tcopy 4,1\n\tcopy 30,4\n\tstw 1,0(0,4)\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\taddil L'%d,30\n\tldo R'%d(1),30\n"
argument_list|,
name|actual_fsize
argument_list|,
name|actual_fsize
argument_list|)
expr_stmt|;
block|}
block|}
else|else
comment|/* Used to be abort ();  */
block|{
if|if
condition|(
name|VAL_14_BITS_P
argument_list|(
name|actual_fsize
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tldo %d(30),30\n"
argument_list|,
name|actual_fsize
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\taddil L'%d,30\n\tldo R'%d(1),30\n"
argument_list|,
name|actual_fsize
argument_list|,
name|actual_fsize
argument_list|)
expr_stmt|;
block|}
comment|/* The hppa calling conventions say that that %r19, the pic offset       register, is saved at sp - 32 (in this function's frame) */
if|if
condition|(
name|flag_pic
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tstw %%r19,-32(%%r30)\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Instead of taking one argument, the counter label, as most normal      mcounts do, _mcount appears to behave differently on the HPPA. It      takes the return address of the caller, the address of this      routine, and the address of the label. Also, it isn't magic, so      argument registers have to be preserved. */
if|if
condition|(
name|profile_flag
condition|)
block|{
name|unsigned
name|int
name|pc_offset
init|=
operator|(
literal|4
operator|+
operator|(
name|frame_pointer_needed
condition|?
operator|(
name|VAL_14_BITS_P
argument_list|(
name|actual_fsize
argument_list|)
condition|?
literal|12
else|:
literal|20
operator|)
else|:
operator|(
name|VAL_14_BITS_P
argument_list|(
name|actual_fsize
argument_list|)
condition|?
literal|4
else|:
literal|8
operator|)
operator|)
operator|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|arg_offset
decl_stmt|;
name|int
name|basereg
decl_stmt|,
name|offsetadj
decl_stmt|;
comment|/* When the function has a frame pointer, use that as the base  	 register for saving/restoring registers.  Else use the stack 	 pointer.  Adjust the offset according to the frame size if this 	 function does not have a frame pointer.  */
name|basereg
operator|=
name|frame_pointer_needed
condition|?
name|FRAME_POINTER_REGNUM
else|:
name|STACK_POINTER_REGNUM
expr_stmt|;
name|offsetadj
operator|=
name|frame_pointer_needed
condition|?
literal|0
else|:
name|actual_fsize
expr_stmt|;
if|if
condition|(
name|current_function_returns_struct
condition|)
name|print_stw
argument_list|(
name|file
argument_list|,
name|STRUCT_VALUE_REGNUM
argument_list|,
operator|-
literal|12
operator|-
name|offsetadj
argument_list|,
name|basereg
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|26
operator|,
name|arg_offset
operator|=
operator|-
literal|36
operator|-
name|offsetadj
init|;
name|i
operator|>=
literal|23
condition|;
name|i
operator|--
operator|,
name|arg_offset
operator|-=
literal|4
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|i
index|]
condition|)
block|{
name|print_stw
argument_list|(
name|file
argument_list|,
name|i
argument_list|,
name|arg_offset
argument_list|,
name|basereg
argument_list|)
expr_stmt|;
comment|/* It is possible for the arg_offset not to fit in 14 bits                 when profiling a function without a frame pointer.  Deal 	       with such cases.  */
name|pc_offset
operator|+=
name|VAL_14_BITS_P
argument_list|(
name|arg_offset
argument_list|)
condition|?
literal|4
else|:
literal|8
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tcopy %%r2,%%r26\n\taddil L'LP$%04d-$global$,%%r27\n\ \tldo R'LP$%04d-$global$(%%r1),%%r24\n\tbl _mcount,%%r2\n\ \tldo %d(%%r2),%%r25\n"
argument_list|,
name|hp_profile_labelno
argument_list|,
name|hp_profile_labelno
argument_list|,
operator|-
name|pc_offset
operator|-
literal|12
operator|-
literal|8
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|26
operator|,
name|arg_offset
operator|=
operator|-
literal|36
operator|-
name|offsetadj
init|;
name|i
operator|>=
literal|23
condition|;
name|i
operator|--
operator|,
name|arg_offset
operator|-=
literal|4
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|i
index|]
condition|)
name|print_ldw
argument_list|(
name|file
argument_list|,
name|i
argument_list|,
name|arg_offset
argument_list|,
name|basereg
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_function_returns_struct
condition|)
name|print_ldw
argument_list|(
name|file
argument_list|,
name|STRUCT_VALUE_REGNUM
argument_list|,
operator|-
literal|12
operator|-
name|offsetadj
argument_list|,
name|basereg
argument_list|)
expr_stmt|;
block|}
comment|/* Normal register save. */
if|if
condition|(
name|frame_pointer_needed
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|18
operator|,
name|offset
operator|=
name|local_fsize
init|;
name|i
operator|>=
literal|5
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|i
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|i
index|]
condition|)
block|{
name|print_stw
argument_list|(
name|file
argument_list|,
name|i
argument_list|,
name|offset
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|4
expr_stmt|;
block|}
if|if
condition|(
name|regs_ever_live
index|[
literal|3
index|]
operator|&&
operator|!
name|call_used_regs
index|[
literal|3
index|]
condition|)
block|{
name|print_stw
argument_list|(
name|file
argument_list|,
literal|3
argument_list|,
name|offset
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|4
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|18
operator|,
name|offset
operator|=
name|local_fsize
operator|-
name|actual_fsize
init|;
name|i
operator|>=
literal|5
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|i
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|i
index|]
condition|)
block|{
name|print_stw
argument_list|(
name|file
argument_list|,
name|i
argument_list|,
name|offset
argument_list|,
literal|30
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|4
expr_stmt|;
block|}
if|if
condition|(
name|regs_ever_live
index|[
literal|3
index|]
operator|&&
operator|!
name|call_used_regs
index|[
literal|3
index|]
condition|)
block|{
name|print_stw
argument_list|(
name|file
argument_list|,
literal|3
argument_list|,
name|offset
argument_list|,
literal|30
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|4
expr_stmt|;
block|}
block|}
comment|/* Align pointer properly (doubleword boundary).  */
name|offset
operator|=
operator|(
name|offset
operator|+
literal|7
operator|)
operator|&
operator|~
literal|7
expr_stmt|;
comment|/* Floating point register store.  */
if|if
condition|(
name|save_fregs
condition|)
if|if
condition|(
name|frame_pointer_needed
condition|)
block|{
if|if
condition|(
name|VAL_14_BITS_P
argument_list|(
name|offset
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tldo %d(4),1\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\taddil L'%d,4\n\tldo R'%d(1),1\n"
argument_list|,
name|offset
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|VAL_14_BITS_P
argument_list|(
name|offset
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tldo %d(30),1\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\taddil L'%d,30\n\tldo R'%d(1),1\n"
argument_list|,
name|offset
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|TARGET_SNAKE
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|47
init|;
name|i
operator|>=
literal|44
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|regs_ever_live
index|[
name|i
index|]
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tfstds,ma %s,8(0,1)\n"
argument_list|,
name|reg_names
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|90
init|;
name|i
operator|>=
literal|72
condition|;
name|i
operator|-=
literal|2
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|i
index|]
operator|||
name|regs_ever_live
index|[
name|i
operator|+
literal|1
index|]
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tfstds,ma %s,8(0,1)\n"
argument_list|,
name|reg_names
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|output_function_epilogue
parameter_list|(
name|file
parameter_list|,
name|size
parameter_list|,
name|leaf_function
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|int
name|size
decl_stmt|;
name|int
name|leaf_function
decl_stmt|;
block|{
specifier|extern
name|char
name|call_used_regs
index|[]
decl_stmt|;
specifier|extern
name|int
name|frame_pointer_needed
decl_stmt|;
name|int
name|i
decl_stmt|,
name|offset
decl_stmt|;
if|if
condition|(
name|frame_pointer_needed
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|18
operator|,
name|offset
operator|=
name|local_fsize
init|;
name|i
operator|>=
literal|5
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|i
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|i
index|]
condition|)
block|{
name|print_ldw
argument_list|(
name|file
argument_list|,
name|i
argument_list|,
name|offset
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|4
expr_stmt|;
block|}
if|if
condition|(
name|regs_ever_live
index|[
literal|3
index|]
operator|&&
operator|!
name|call_used_regs
index|[
literal|3
index|]
condition|)
block|{
name|print_ldw
argument_list|(
name|file
argument_list|,
literal|3
argument_list|,
name|offset
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|4
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|18
operator|,
name|offset
operator|=
name|local_fsize
operator|-
name|actual_fsize
init|;
name|i
operator|>=
literal|5
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|i
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|i
index|]
condition|)
block|{
name|print_ldw
argument_list|(
name|file
argument_list|,
name|i
argument_list|,
name|offset
argument_list|,
literal|30
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|4
expr_stmt|;
block|}
if|if
condition|(
name|regs_ever_live
index|[
literal|3
index|]
operator|&&
operator|!
name|call_used_regs
index|[
literal|3
index|]
condition|)
block|{
name|print_ldw
argument_list|(
name|file
argument_list|,
literal|3
argument_list|,
name|offset
argument_list|,
literal|30
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|4
expr_stmt|;
block|}
block|}
comment|/* Align pointer properly (doubleword boundary).  */
name|offset
operator|=
operator|(
name|offset
operator|+
literal|7
operator|)
operator|&
operator|~
literal|7
expr_stmt|;
comment|/* Floating point register restore.  */
if|if
condition|(
name|save_fregs
condition|)
if|if
condition|(
name|frame_pointer_needed
condition|)
block|{
if|if
condition|(
name|VAL_14_BITS_P
argument_list|(
name|offset
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tldo %d(4),1\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\taddil L'%d,4\n\tldo R'%d(1),1\n"
argument_list|,
name|offset
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|VAL_14_BITS_P
argument_list|(
name|offset
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tldo %d(30),1\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\taddil L'%d,30\n\tldo R'%d(1),1\n"
argument_list|,
name|offset
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|TARGET_SNAKE
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|47
init|;
name|i
operator|>=
literal|44
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|regs_ever_live
index|[
name|i
index|]
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tfldds,ma 8(0,1),%s\n"
argument_list|,
name|reg_names
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|90
init|;
name|i
operator|>=
literal|72
condition|;
name|i
operator|-=
literal|2
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|i
index|]
operator|||
name|regs_ever_live
index|[
name|i
operator|+
literal|1
index|]
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tfldds,ma 8(0,1),%s\n"
argument_list|,
name|reg_names
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Reset stack pointer (and possibly frame pointer).  The stack */
comment|/* pointer is initially set to fp + 8 to avoid a race condition. */
if|if
condition|(
name|frame_pointer_needed
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tldo 8(4),30\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|regs_ever_live
index|[
literal|2
index|]
operator|||
name|profile_flag
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tldw -28(0,30),2\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tbv 0(2)\n\tldwm -8(30),4\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|actual_fsize
condition|)
block|{
if|if
condition|(
operator|(
name|regs_ever_live
index|[
literal|2
index|]
operator|||
name|profile_flag
operator|)
operator|&&
name|VAL_14_BITS_P
argument_list|(
name|actual_fsize
operator|+
literal|20
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tldw %d(30),2\n\tbv 0(2)\n\tldo %d(30),30\n"
argument_list|,
operator|-
operator|(
name|actual_fsize
operator|+
literal|20
operator|)
argument_list|,
operator|-
name|actual_fsize
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|regs_ever_live
index|[
literal|2
index|]
operator|||
name|profile_flag
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\taddil L'%d,30\n\tldw %d(1),2\n\tbv 0(2)\n\tldo R'%d(1),30\n"
argument_list|,
operator|-
name|actual_fsize
argument_list|,
operator|-
operator|(
name|actual_fsize
operator|+
literal|20
operator|+
operator|(
operator|(
operator|-
name|actual_fsize
operator|)
operator|&
operator|~
literal|0x7ff
operator|)
operator|)
argument_list|,
comment|/* - ((actual_fsize + 20) - (actual_fsize& ~0x7ff)), */
operator|-
name|actual_fsize
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|VAL_14_BITS_P
argument_list|(
name|actual_fsize
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tbv 0(2)\n\tldo %d(30),30\n"
argument_list|,
operator|-
name|actual_fsize
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\taddil L'%d,30\n\tbv 0(2)\n\tldo R'%d(1),30\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|current_function_epilogue_delay_list
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tbv 0(2)\n"
argument_list|)
expr_stmt|;
name|final_scan_insn
argument_list|(
name|XEXP
argument_list|(
name|current_function_epilogue_delay_list
argument_list|,
literal|0
argument_list|)
argument_list|,
name|file
argument_list|,
name|write_symbols
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tbv,n 0(2)\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.EXIT\n\t.PROCEND\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|rtx
name|gen_compare_reg
parameter_list|(
name|code
parameter_list|,
name|x
parameter_list|,
name|y
parameter_list|)
name|enum
name|rtx_code
name|code
decl_stmt|;
name|rtx
name|x
decl_stmt|,
name|y
decl_stmt|;
block|{
name|enum
name|machine_mode
name|mode
init|=
name|SELECT_CC_MODE
argument_list|(
name|code
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
decl_stmt|;
name|rtx
name|cc_reg
init|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|mode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx
argument_list|(
name|SET
argument_list|,
name|VOIDmode
argument_list|,
name|cc_reg
argument_list|,
name|gen_rtx
argument_list|(
name|COMPARE
argument_list|,
name|mode
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|cc_reg
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if TRIAL can go into the function epilogue's    delay slot.  SLOT is the slot we are trying to fill.  */
end_comment

begin_function
name|int
name|eligible_for_epilogue_delay
parameter_list|(
name|trial
parameter_list|,
name|slot
parameter_list|)
name|rtx
name|trial
decl_stmt|;
name|int
name|slot
decl_stmt|;
block|{
if|if
condition|(
name|slot
operator|>=
literal|1
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|trial
argument_list|)
operator|!=
name|INSN
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|trial
argument_list|)
argument_list|)
operator|!=
name|SET
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|get_attr_length
argument_list|(
name|trial
argument_list|)
operator|!=
literal|1
condition|)
return|return
literal|0
return|;
return|return
operator|(
name|leaf_function
operator|&&
name|get_attr_in_branch_delay
argument_list|(
name|trial
argument_list|)
operator|==
name|IN_BRANCH_DELAY_TRUE
operator|)
return|;
block|}
end_function

begin_function
name|rtx
name|gen_scond_fp
parameter_list|(
name|code
parameter_list|,
name|operand0
parameter_list|)
name|enum
name|rtx_code
name|code
decl_stmt|;
name|rtx
name|operand0
decl_stmt|;
block|{
return|return
name|gen_rtx
argument_list|(
name|SET
argument_list|,
name|VOIDmode
argument_list|,
name|operand0
argument_list|,
name|gen_rtx
argument_list|(
name|code
argument_list|,
name|CCFPmode
argument_list|,
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|CCFPmode
argument_list|,
literal|0
argument_list|)
argument_list|,
name|const0_rtx
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|emit_bcond_fp
parameter_list|(
name|code
parameter_list|,
name|operand0
parameter_list|)
name|enum
name|rtx_code
name|code
decl_stmt|;
name|rtx
name|operand0
decl_stmt|;
block|{
name|emit_jump_insn
argument_list|(
name|gen_rtx
argument_list|(
name|SET
argument_list|,
name|VOIDmode
argument_list|,
name|pc_rtx
argument_list|,
name|gen_rtx
argument_list|(
name|IF_THEN_ELSE
argument_list|,
name|VOIDmode
argument_list|,
name|gen_rtx
argument_list|(
name|code
argument_list|,
name|VOIDmode
argument_list|,
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|CCFPmode
argument_list|,
literal|0
argument_list|)
argument_list|,
name|const0_rtx
argument_list|)
argument_list|,
name|gen_rtx
argument_list|(
name|LABEL_REF
argument_list|,
name|VOIDmode
argument_list|,
name|operand0
argument_list|)
argument_list|,
name|pc_rtx
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|rtx
name|gen_cmp_fp
parameter_list|(
name|code
parameter_list|,
name|operand0
parameter_list|,
name|operand1
parameter_list|)
name|enum
name|rtx_code
name|code
decl_stmt|;
name|rtx
name|operand0
decl_stmt|,
name|operand1
decl_stmt|;
block|{
return|return
name|gen_rtx
argument_list|(
name|SET
argument_list|,
name|VOIDmode
argument_list|,
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|CCFPmode
argument_list|,
literal|0
argument_list|)
argument_list|,
name|gen_rtx
argument_list|(
name|code
argument_list|,
name|CCFPmode
argument_list|,
name|operand0
argument_list|,
name|operand1
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Print operand X (an rtx) in assembler syntax to file FILE.    CODE is a letter or dot (`z' in `%z0') or 0 if no letter was specified.    For `%' followed by punctuation, CODE is the punctuation and X is null.  */
end_comment

begin_function
name|void
name|print_operand
parameter_list|(
name|file
parameter_list|,
name|x
parameter_list|,
name|code
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|int
name|code
decl_stmt|;
block|{
switch|switch
condition|(
name|code
condition|)
block|{
case|case
literal|'#'
case|:
comment|/* Output a 'nop' if there's nothing for the delay slot.  */
if|if
condition|(
name|dbr_sequence_length
argument_list|()
operator|==
literal|0
condition|)
name|fputs
argument_list|(
literal|"\n\tnop"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'*'
case|:
comment|/* Output an nullification completer if there's nothing for the */
comment|/* delay slot or nullification is requested.  */
if|if
condition|(
name|dbr_sequence_length
argument_list|()
operator|==
literal|0
operator|||
operator|(
name|final_sequence
operator|&&
name|INSN_ANNULLED_BRANCH_P
argument_list|(
name|XVECEXP
argument_list|(
name|final_sequence
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
condition|)
name|fputs
argument_list|(
literal|",n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'R'
case|:
comment|/* Print out the second register name of a register pair. 	 I.e., R (6) => 7.  */
name|fputs
argument_list|(
name|reg_names
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
operator|+
literal|1
index|]
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'r'
case|:
comment|/* A register or zero. */
if|if
condition|(
name|x
operator|==
name|const0_rtx
condition|)
block|{
name|fputs
argument_list|(
literal|"0"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
break|break;
case|case
literal|'O'
case|:
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|PLUS
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"add%s"
argument_list|,
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|?
literal|"i"
else|:
literal|""
argument_list|)
expr_stmt|;
break|break;
case|case
name|MINUS
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"sub%s"
argument_list|,
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|?
literal|"i"
else|:
literal|""
argument_list|)
expr_stmt|;
break|break;
case|case
name|AND
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"and%s"
argument_list|,
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|NOT
condition|?
literal|"cm"
else|:
literal|""
argument_list|)
expr_stmt|;
break|break;
case|case
name|IOR
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"or"
argument_list|)
expr_stmt|;
break|break;
case|case
name|XOR
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"xor"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ASHIFT
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"sh%dadd"
argument_list|,
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
comment|/* Too lazy to handle bitfield conditions yet.  */
default|default:
name|printf
argument_list|(
literal|"Can't grok '%c' operator:\n"
argument_list|,
name|code
argument_list|)
expr_stmt|;
name|debug_rtx
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
return|return;
case|case
literal|'C'
case|:
case|case
literal|'X'
case|:
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|EQ
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"="
argument_list|)
expr_stmt|;
break|break;
case|case
name|NE
case|:
if|if
condition|(
name|code
operator|==
literal|'C'
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"<>"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"!="
argument_list|)
expr_stmt|;
break|break;
case|case
name|GT
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|">"
argument_list|)
expr_stmt|;
break|break;
case|case
name|GE
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|">="
argument_list|)
expr_stmt|;
break|break;
case|case
name|GEU
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|">>="
argument_list|)
expr_stmt|;
break|break;
case|case
name|GTU
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|">>"
argument_list|)
expr_stmt|;
break|break;
case|case
name|LT
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"<"
argument_list|)
expr_stmt|;
break|break;
case|case
name|LE
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"<="
argument_list|)
expr_stmt|;
break|break;
case|case
name|LEU
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"<<="
argument_list|)
expr_stmt|;
break|break;
case|case
name|LTU
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"<<"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"Can't grok '%c' operator:\n"
argument_list|,
name|code
argument_list|)
expr_stmt|;
name|debug_rtx
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
return|return;
case|case
literal|'N'
case|:
case|case
literal|'Y'
case|:
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|EQ
case|:
if|if
condition|(
name|code
operator|==
literal|'N'
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"<>"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"!="
argument_list|)
expr_stmt|;
break|break;
case|case
name|NE
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"="
argument_list|)
expr_stmt|;
break|break;
case|case
name|GT
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"<="
argument_list|)
expr_stmt|;
break|break;
case|case
name|GE
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"<"
argument_list|)
expr_stmt|;
break|break;
case|case
name|GEU
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"<<"
argument_list|)
expr_stmt|;
break|break;
case|case
name|GTU
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"<<="
argument_list|)
expr_stmt|;
break|break;
case|case
name|LT
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|">="
argument_list|)
expr_stmt|;
break|break;
case|case
name|LE
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|">"
argument_list|)
expr_stmt|;
break|break;
case|case
name|LEU
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|">>"
argument_list|)
expr_stmt|;
break|break;
case|case
name|LTU
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|">>="
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"Can't grok '%c' operator:\n"
argument_list|,
name|code
argument_list|)
expr_stmt|;
name|debug_rtx
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
return|return;
case|case
literal|'M'
case|:
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|PRE_DEC
case|:
case|case
name|PRE_INC
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"s,mb"
argument_list|)
expr_stmt|;
break|break;
case|case
name|POST_DEC
case|:
case|case
name|POST_INC
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"s,ma"
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return;
case|case
literal|'F'
case|:
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|PRE_DEC
case|:
case|case
name|PRE_INC
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|",mb"
argument_list|)
expr_stmt|;
break|break;
case|case
name|POST_DEC
case|:
case|case
name|POST_INC
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|",ma"
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return;
case|case
literal|'G'
case|:
name|output_global_address
argument_list|(
name|file
argument_list|,
name|x
argument_list|)
expr_stmt|;
return|return;
case|case
literal|0
case|:
comment|/* Don't do anything special */
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
condition|)
block|{
name|int
name|size
init|=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|base
init|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|PRE_DEC
case|:
case|case
name|POST_DEC
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"-%d(0,%s)"
argument_list|,
name|size
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|base
argument_list|)
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|PRE_INC
case|:
case|case
name|POST_INC
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d(0,%s)"
argument_list|,
name|size
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|base
argument_list|)
index|]
argument_list|)
expr_stmt|;
break|break;
default|default:
name|output_address
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|SFmode
condition|)
block|{
union|union
block|{
name|double
name|d
decl_stmt|;
name|int
name|i
index|[
literal|2
index|]
decl_stmt|;
block|}
name|u
union|;
union|union
block|{
name|float
name|f
decl_stmt|;
name|int
name|i
decl_stmt|;
block|}
name|u1
union|;
name|u
operator|.
name|i
index|[
literal|0
index|]
operator|=
name|XINT
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|u
operator|.
name|i
index|[
literal|1
index|]
operator|=
name|XINT
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|u1
operator|.
name|f
operator|=
name|u
operator|.
name|d
expr_stmt|;
if|if
condition|(
name|code
operator|==
literal|'f'
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"0r%.9g"
argument_list|,
name|u1
operator|.
name|f
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"0x%x"
argument_list|,
name|u1
operator|.
name|i
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|!=
name|DImode
condition|)
block|{
union|union
block|{
name|double
name|d
decl_stmt|;
name|int
name|i
index|[
literal|2
index|]
decl_stmt|;
block|}
name|u
union|;
name|u
operator|.
name|i
index|[
literal|0
index|]
operator|=
name|XINT
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|u
operator|.
name|i
index|[
literal|1
index|]
operator|=
name|XINT
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"0r%.20g"
argument_list|,
name|u
operator|.
name|d
argument_list|)
expr_stmt|;
block|}
else|else
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* output a SYMBOL_REF or a CONST expression involving a SYMBOL_REF. */
end_comment

begin_function
name|void
name|output_global_address
parameter_list|(
name|file
parameter_list|,
name|x
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|rtx
name|x
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|read_only_operand
argument_list|(
name|x
argument_list|)
condition|)
name|assemble_name
argument_list|(
name|file
argument_list|,
name|XSTR
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SYMBOL_REF
condition|)
block|{
name|assemble_name
argument_list|(
name|file
argument_list|,
name|XSTR
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"-$global$"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST
condition|)
block|{
name|char
modifier|*
name|sep
init|=
literal|""
decl_stmt|;
name|int
name|offset
init|=
literal|0
decl_stmt|;
comment|/* assembler wants -$global$ at end */
name|rtx
name|base
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
condition|)
block|{
name|base
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|base
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
name|offset
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
condition|)
block|{
name|base
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|base
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
name|offset
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
condition|)
block|{
if|if
condition|(
name|offset
operator|<
literal|0
condition|)
block|{
name|offset
operator|=
operator|-
name|offset
expr_stmt|;
name|sep
operator|=
literal|"-"
expr_stmt|;
block|}
else|else
name|sep
operator|=
literal|"+"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MINUS
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
operator|)
condition|)
name|sep
operator|=
literal|"-"
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|read_only_operand
argument_list|(
name|base
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"-$global$"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|sep
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
else|else
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* MEM rtls here are never SYMBOL_REFs (I think), so fldws is safe. */
end_comment

begin_function
name|char
modifier|*
name|output_floatsisf2
parameter_list|(
name|operands
parameter_list|)
name|rtx
modifier|*
name|operands
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|MEM
condition|)
return|return
literal|"fldws %1,%0\n\tfcnvxf,sgl,sgl %0,%0"
return|;
elseif|else
if|if
condition|(
name|FP_REG_P
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
return|return
literal|"fcnvxf,sgl,sgl %1,%0"
return|;
return|return
literal|"stwm %r1,4(0,30)\n\tfldws,mb -4(0,30),%0\n\tfcnvxf,sgl,sgl %0,%0"
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|output_floatsidf2
parameter_list|(
name|operands
parameter_list|)
name|rtx
modifier|*
name|operands
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|MEM
condition|)
return|return
literal|"fldws %1,%0\n\tfcnvxf,sgl,dbl %0,%0"
return|;
elseif|else
if|if
condition|(
name|FP_REG_P
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
return|return
literal|"fcnvxf,sgl,dbl %1,%0"
return|;
return|return
literal|"stwm %r1,4(0,30)\n\tfldws,mb -4(0,30),%0\n\tfcnvxf,sgl,dbl %0,%0"
return|;
block|}
end_function

begin_function
name|enum
name|rtx_code
name|reverse_relop
parameter_list|(
name|code
parameter_list|)
name|enum
name|rtx_code
name|code
decl_stmt|;
block|{
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|GT
case|:
return|return
name|LT
return|;
case|case
name|LT
case|:
return|return
name|GT
return|;
case|case
name|GE
case|:
return|return
name|LE
return|;
case|case
name|LE
case|:
return|return
name|GE
return|;
case|case
name|LTU
case|:
return|return
name|GTU
return|;
case|case
name|GTU
case|:
return|return
name|LTU
return|;
case|case
name|GEU
case|:
return|return
name|LEU
return|;
case|case
name|LEU
case|:
return|return
name|GEU
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* HP's millicode routines mean something special to the assembler.    Keep track of which ones we have used.  */
end_comment

begin_enum
enum|enum
name|millicodes
block|{
name|remI
block|,
name|remU
block|,
name|divI
block|,
name|divU
block|,
name|mulI
block|,
name|mulU
block|,
name|end1000
block|}
enum|;
end_enum

begin_decl_stmt
specifier|static
name|char
name|imported
index|[
operator|(
name|int
operator|)
name|end1000
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|milli_names
index|[]
init|=
block|{
literal|"remI"
block|,
literal|"remU"
block|,
literal|"divI"
block|,
literal|"divU"
block|,
literal|"mulI"
block|,
literal|"mulU"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|import_string
index|[]
init|=
literal|".IMPORT $$....,MILLICODE"
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|MILLI_START
value|10
end_define

begin_function
specifier|static
name|int
name|import_milli
parameter_list|(
name|code
parameter_list|)
name|enum
name|millicodes
name|code
decl_stmt|;
block|{
name|char
name|str
index|[
sizeof|sizeof
argument_list|(
name|import_string
argument_list|)
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|imported
index|[
operator|(
name|int
operator|)
name|code
index|]
condition|)
block|{
name|imported
index|[
operator|(
name|int
operator|)
name|code
index|]
operator|=
literal|1
expr_stmt|;
name|strcpy
argument_list|(
name|str
argument_list|,
name|import_string
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|str
operator|+
name|MILLI_START
argument_list|,
name|milli_names
index|[
operator|(
name|int
operator|)
name|code
index|]
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
name|str
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* The register constraints have put the operands and return value in     the proper registers. */
end_comment

begin_function
name|char
modifier|*
name|output_mul_insn
parameter_list|(
name|unsignedp
parameter_list|)
name|int
name|unsignedp
decl_stmt|;
block|{
if|if
condition|(
name|unsignedp
condition|)
block|{
name|import_milli
argument_list|(
name|mulU
argument_list|)
expr_stmt|;
return|return
literal|"bl $$mulU,31%#"
return|;
block|}
else|else
block|{
name|import_milli
argument_list|(
name|mulI
argument_list|)
expr_stmt|;
return|return
literal|"bl $$mulI,31%#"
return|;
block|}
block|}
end_function

begin_comment
comment|/* If operands isn't NULL, then it's a CONST_INT with which we can do    something */
end_comment

begin_comment
comment|/* Emit the rtl for doing a division by a constant. */
end_comment

begin_comment
comment|/* Do magic division millicodes exist for this value? */
end_comment

begin_decl_stmt
specifier|static
name|int
name|magic_milli
index|[]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* We'll use an array to keep track of the magic millicodes and     whether or not we've used them already. [n][0] is signed, [n][1] is    unsigned. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|div_milli
index|[
literal|16
index|]
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|div_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|mode
operator|==
name|SImode
operator|&&
operator|(
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|op
argument_list|)
operator|==
literal|25
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|>
literal|0
operator|&&
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|<
literal|16
operator|&&
name|magic_milli
index|[
name|INTVAL
argument_list|(
name|op
argument_list|)
index|]
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|emit_hpdiv_const
parameter_list|(
name|operands
parameter_list|,
name|unsignedp
parameter_list|)
name|rtx
modifier|*
name|operands
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
operator|>
literal|0
operator|&&
name|INTVAL
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
operator|<
literal|16
operator|&&
name|magic_milli
index|[
name|INTVAL
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
index|]
condition|)
block|{
name|emit_move_insn
argument_list|(
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|SImode
argument_list|,
literal|26
argument_list|)
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|emit
argument_list|(
name|gen_rtx
argument_list|(
name|PARALLEL
argument_list|,
name|VOIDmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|5
argument_list|,
name|gen_rtx
argument_list|(
name|SET
argument_list|,
name|VOIDmode
argument_list|,
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|SImode
argument_list|,
literal|29
argument_list|)
argument_list|,
name|gen_rtx
argument_list|(
name|unsignedp
condition|?
name|UDIV
else|:
name|DIV
argument_list|,
name|SImode
argument_list|,
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|SImode
argument_list|,
literal|26
argument_list|)
argument_list|,
name|operands
index|[
literal|2
index|]
argument_list|)
argument_list|)
argument_list|,
name|gen_rtx
argument_list|(
name|CLOBBER
argument_list|,
name|VOIDmode
argument_list|,
name|gen_rtx
argument_list|(
name|SCRATCH
argument_list|,
name|SImode
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|gen_rtx
argument_list|(
name|CLOBBER
argument_list|,
name|VOIDmode
argument_list|,
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|SImode
argument_list|,
literal|26
argument_list|)
argument_list|)
argument_list|,
name|gen_rtx
argument_list|(
name|CLOBBER
argument_list|,
name|VOIDmode
argument_list|,
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|SImode
argument_list|,
literal|25
argument_list|)
argument_list|)
argument_list|,
name|gen_rtx
argument_list|(
name|CLOBBER
argument_list|,
name|VOIDmode
argument_list|,
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|SImode
argument_list|,
literal|31
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|SImode
argument_list|,
literal|29
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|output_div_insn
parameter_list|(
name|operands
parameter_list|,
name|unsignedp
parameter_list|)
name|rtx
modifier|*
name|operands
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
block|{
name|int
name|divisor
decl_stmt|;
comment|/* If the divisor is a constant, try to use one of the special       opcodes .*/
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|divisor
operator|=
name|INTVAL
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|div_milli
index|[
name|divisor
index|]
index|[
name|unsignedp
index|]
condition|)
block|{
if|if
condition|(
name|unsignedp
condition|)
name|output_asm_insn
argument_list|(
literal|".IMPORT $$divU_%0,MILLICODE"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
else|else
name|output_asm_insn
argument_list|(
literal|".IMPORT $$divI_%0,MILLICODE"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
name|div_milli
index|[
name|divisor
index|]
index|[
name|unsignedp
index|]
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|unsignedp
condition|)
return|return
literal|"bl $$divU_%0,31%#"
return|;
return|return
literal|"bl $$divI_%0,31%#"
return|;
block|}
comment|/* Divisor isn't a special constant. */
else|else
block|{
if|if
condition|(
name|unsignedp
condition|)
block|{
name|import_milli
argument_list|(
name|divU
argument_list|)
expr_stmt|;
return|return
literal|"bl $$divU,31%#"
return|;
block|}
else|else
block|{
name|import_milli
argument_list|(
name|divI
argument_list|)
expr_stmt|;
return|return
literal|"bl $$divI,31%#"
return|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Output a $$rem millicode to do mod. */
end_comment

begin_function
name|char
modifier|*
name|output_mod_insn
parameter_list|(
name|unsignedp
parameter_list|)
name|int
name|unsignedp
decl_stmt|;
block|{
if|if
condition|(
name|unsignedp
condition|)
block|{
name|import_milli
argument_list|(
name|remU
argument_list|)
expr_stmt|;
return|return
literal|"bl $$remU,31%#"
return|;
block|}
else|else
block|{
name|import_milli
argument_list|(
name|remI
argument_list|)
expr_stmt|;
return|return
literal|"bl $$remI,31%#"
return|;
block|}
block|}
end_function

begin_function
name|void
name|output_arg_descriptor
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
name|char
modifier|*
name|arg_regs
index|[
literal|4
index|]
decl_stmt|;
name|enum
name|machine_mode
name|arg_mode
decl_stmt|;
name|rtx
name|prev_insn
decl_stmt|;
name|int
name|i
decl_stmt|,
name|output_flag
init|=
literal|0
decl_stmt|;
name|int
name|regno
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
name|arg_regs
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|prev_insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
init|;
name|GET_CODE
argument_list|(
name|prev_insn
argument_list|)
operator|==
name|INSN
condition|;
name|prev_insn
operator|=
name|PREV_INSN
argument_list|(
name|prev_insn
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|prev_insn
argument_list|)
argument_list|)
operator|==
name|USE
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|PATTERN
argument_list|(
name|prev_insn
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|FUNCTION_ARG_REGNO_P
argument_list|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|PATTERN
argument_list|(
name|prev_insn
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
condition|)
break|break;
name|arg_mode
operator|=
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|PATTERN
argument_list|(
name|prev_insn
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|regno
operator|=
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|PATTERN
argument_list|(
name|prev_insn
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|>=
literal|23
operator|&&
name|regno
operator|<=
literal|26
condition|)
block|{
name|arg_regs
index|[
literal|26
operator|-
name|regno
index|]
operator|=
literal|"GR"
expr_stmt|;
if|if
condition|(
name|arg_mode
operator|==
name|DImode
condition|)
name|arg_regs
index|[
literal|25
operator|-
name|regno
index|]
operator|=
literal|"GR"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|TARGET_SNAKE
condition|)
comment|/* fp args */
block|{
if|if
condition|(
name|arg_mode
operator|==
name|SFmode
condition|)
name|arg_regs
index|[
name|regno
operator|-
literal|36
index|]
operator|=
literal|"FR"
expr_stmt|;
else|else
block|{
ifdef|#
directive|ifdef
name|HP_FP_ARG_DESCRIPTOR_REVERSED
name|arg_regs
index|[
name|regno
operator|-
literal|37
index|]
operator|=
literal|"FR"
expr_stmt|;
name|arg_regs
index|[
name|regno
operator|-
literal|36
index|]
operator|=
literal|"FU"
expr_stmt|;
else|#
directive|else
name|arg_regs
index|[
name|regno
operator|-
literal|37
index|]
operator|=
literal|"FU"
expr_stmt|;
name|arg_regs
index|[
name|regno
operator|-
literal|36
index|]
operator|=
literal|"FR"
expr_stmt|;
endif|#
directive|endif
block|}
block|}
else|else
block|{
if|if
condition|(
name|arg_mode
operator|==
name|SFmode
condition|)
name|arg_regs
index|[
operator|(
name|regno
operator|-
literal|56
operator|)
operator|/
literal|2
index|]
operator|=
literal|"FR"
expr_stmt|;
else|else
block|{
ifdef|#
directive|ifdef
name|HP_FP_ARG_DESCRIPTOR_REVERSED
name|arg_regs
index|[
operator|(
name|regno
operator|-
literal|58
operator|)
operator|/
literal|2
index|]
operator|=
literal|"FR"
expr_stmt|;
name|arg_regs
index|[
operator|(
name|regno
operator|-
literal|58
operator|)
operator|/
literal|2
operator|+
literal|1
index|]
operator|=
literal|"FU"
expr_stmt|;
else|#
directive|else
name|arg_regs
index|[
operator|(
name|regno
operator|-
literal|58
operator|)
operator|/
literal|2
index|]
operator|=
literal|"FU"
expr_stmt|;
name|arg_regs
index|[
operator|(
name|regno
operator|-
literal|58
operator|)
operator|/
literal|2
operator|+
literal|1
index|]
operator|=
literal|"FR"
expr_stmt|;
endif|#
directive|endif
block|}
block|}
block|}
name|fputs
argument_list|(
literal|"\t.CALL "
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|arg_regs
index|[
name|i
index|]
condition|)
block|{
if|if
condition|(
name|output_flag
operator|++
condition|)
name|fputc
argument_list|(
literal|','
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"ARGW%d=%s"
argument_list|,
name|i
argument_list|,
name|arg_regs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Memory loads/stores to/from the shift need to go through    the general registers.  */
end_comment

begin_function
name|enum
name|reg_class
name|secondary_reload_class
parameter_list|(
name|class
parameter_list|,
name|mode
parameter_list|,
name|in
parameter_list|)
name|enum
name|reg_class
name|class
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|in
decl_stmt|;
block|{
name|int
name|regno
init|=
name|true_regnum
argument_list|(
name|in
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|TARGET_SHARED_LIBS
operator|&&
name|function_label_operand
argument_list|(
name|in
argument_list|,
name|mode
argument_list|)
operator|)
operator|||
operator|(
operator|(
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|||
name|regno
operator|==
operator|-
literal|1
operator|)
operator|&&
operator|(
operator|(
name|mode
operator|==
name|QImode
operator|||
name|mode
operator|==
name|HImode
operator|||
name|mode
operator|==
name|SImode
operator|||
name|mode
operator|==
name|DImode
operator|)
operator|&&
operator|(
name|class
operator|==
name|FP_REGS
operator|||
name|class
operator|==
name|SNAKE_FP_REGS
operator|||
name|class
operator|==
name|HI_SNAKE_FP_REGS
operator|)
operator|)
operator|)
operator|||
operator|(
name|class
operator|==
name|SHIFT_REGS
operator|&&
operator|(
name|regno
operator|<=
literal|0
operator|||
name|regno
operator|>=
literal|32
operator|)
operator|)
condition|)
return|return
name|GENERAL_REGS
return|;
return|return
name|NO_REGS
return|;
block|}
end_function

begin_function
name|enum
name|direction
name|function_arg_padding
parameter_list|(
name|mode
parameter_list|,
name|type
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|tree
name|type
decl_stmt|;
block|{
name|int
name|size
decl_stmt|;
if|if
condition|(
name|mode
operator|==
name|BLKmode
condition|)
block|{
if|if
condition|(
name|type
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
condition|)
name|size
operator|=
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
operator|*
name|BITS_PER_UNIT
expr_stmt|;
else|else
return|return
name|upward
return|;
comment|/* Don't know if this is right, but */
comment|/* same as old definition. */
block|}
else|else
name|size
operator|=
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|<
name|PARM_BOUNDARY
condition|)
return|return
name|downward
return|;
elseif|else
if|if
condition|(
name|size
operator|%
name|PARM_BOUNDARY
condition|)
return|return
name|upward
return|;
else|else
return|return
name|none
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Do what is necessary for `va_start'.  The argument is ignored;    We look at the current function to determine if stdargs or varargs    is used and fill in an initial va_list.  A pointer to this constructor    is returned.  */
end_comment

begin_function
name|struct
name|rtx_def
modifier|*
name|hppa_builtin_saveregs
parameter_list|(
name|arglist
parameter_list|)
name|tree
name|arglist
decl_stmt|;
block|{
name|rtx
name|block
decl_stmt|,
name|float_addr
decl_stmt|,
name|offset
decl_stmt|,
name|float_mem
decl_stmt|;
name|tree
name|fntype
init|=
name|TREE_TYPE
argument_list|(
name|current_function_decl
argument_list|)
decl_stmt|;
name|int
name|argadj
init|=
operator|(
operator|(
operator|!
operator|(
name|TYPE_ARG_TYPES
argument_list|(
name|fntype
argument_list|)
operator|!=
literal|0
operator|&&
operator|(
name|TREE_VALUE
argument_list|(
name|tree_last
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|fntype
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|void_type_node
operator|)
operator|)
operator|)
condition|?
name|UNITS_PER_WORD
else|:
literal|0
operator|)
decl_stmt|;
if|if
condition|(
name|argadj
condition|)
name|offset
operator|=
name|plus_constant
argument_list|(
name|current_function_arg_offset_rtx
argument_list|,
name|argadj
argument_list|)
expr_stmt|;
else|else
name|offset
operator|=
name|current_function_arg_offset_rtx
expr_stmt|;
comment|/* Store general registers on the stack. */
name|move_block_from_reg
argument_list|(
literal|23
argument_list|,
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|BLKmode
argument_list|,
name|plus_constant
argument_list|(
name|current_function_internal_arg_pointer
argument_list|,
operator|-
literal|16
argument_list|)
argument_list|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
return|return
name|copy_to_reg
argument_list|(
name|expand_binop
argument_list|(
name|Pmode
argument_list|,
name|add_optab
argument_list|,
name|current_function_internal_arg_pointer
argument_list|,
name|offset
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
specifier|extern
name|struct
name|obstack
modifier|*
name|saveable_obstack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* In HPUX 8.0's shared library scheme, special relocations are needed    for function labels if they might be passed to a function     in a shared library (because shared libraries don't live in code    space), and special magic is needed to construct their address. */
end_comment

begin_function
name|void
name|hppa_encode_label
parameter_list|(
name|sym
parameter_list|)
name|rtx
name|sym
decl_stmt|;
block|{
name|char
modifier|*
name|str
init|=
name|XSTR
argument_list|(
name|sym
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|int
name|len
init|=
name|strlen
argument_list|(
name|str
argument_list|)
decl_stmt|;
name|char
modifier|*
name|newstr
init|=
name|obstack_alloc
argument_list|(
name|saveable_obstack
argument_list|,
name|len
operator|+
literal|2
argument_list|)
decl_stmt|;
if|if
condition|(
name|str
index|[
literal|0
index|]
operator|==
literal|'*'
condition|)
operator|*
name|newstr
operator|++
operator|=
operator|*
name|str
operator|++
expr_stmt|;
name|strcpy
argument_list|(
name|newstr
operator|+
literal|1
argument_list|,
name|str
argument_list|)
expr_stmt|;
operator|*
name|newstr
operator|=
literal|'@'
expr_stmt|;
name|XSTR
argument_list|(
name|sym
argument_list|,
literal|0
argument_list|)
operator|=
name|newstr
expr_stmt|;
block|}
end_function

begin_function
name|int
name|function_label_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|FUNCTION_NAME_P
argument_list|(
name|XSTR
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is suitable for the second add operand (the unshifed     operand) in an shadd instruction.   Allow CONST_INT to work around    a reload bug.  */
end_comment

begin_function
name|int
name|shadd_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|REG
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

end_unit

