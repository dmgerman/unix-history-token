begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Subroutines for insn-output.c for Alliant FX computers.    Copyright (C) 1989,1991 Free Software Foundation, Inc.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* Some output-actions in alliant.md need these.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"conditions.h"
end_include

begin_include
include|#
directive|include
file|"insn-flags.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"insn-attr.h"
end_include

begin_comment
comment|/* Index into this array by (register number>> 3) to find the    smallest class which contains that register.  */
end_comment

begin_decl_stmt
name|enum
name|reg_class
name|regno_reg_class
index|[]
init|=
block|{
name|DATA_REGS
block|,
name|ADDR_REGS
block|,
name|FP_REGS
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|rtx
name|find_addr_reg
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|char
modifier|*
name|output_btst
parameter_list|(
name|operands
parameter_list|,
name|countop
parameter_list|,
name|dataop
parameter_list|,
name|insn
parameter_list|,
name|signpos
parameter_list|)
name|rtx
modifier|*
name|operands
decl_stmt|;
name|rtx
name|countop
decl_stmt|,
name|dataop
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|int
name|signpos
decl_stmt|;
block|{
name|operands
index|[
literal|0
index|]
operator|=
name|countop
expr_stmt|;
name|operands
index|[
literal|1
index|]
operator|=
name|dataop
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|countop
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
specifier|register
name|int
name|count
init|=
name|INTVAL
argument_list|(
name|countop
argument_list|)
decl_stmt|;
comment|/* If COUNT is bigger than size of storage unit in use, 	 advance to the containing unit of same size.  */
if|if
condition|(
name|count
operator|>
name|signpos
condition|)
block|{
name|int
name|offset
init|=
operator|(
name|count
operator|&
operator|~
name|signpos
operator|)
operator|/
literal|8
decl_stmt|;
name|count
operator|=
name|count
operator|&
name|signpos
expr_stmt|;
name|operands
index|[
literal|1
index|]
operator|=
name|dataop
operator|=
name|adj_offsettable_operand
argument_list|(
name|dataop
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|==
name|signpos
condition|)
name|cc_status
operator|.
name|flags
operator|=
name|CC_NOT_POSITIVE
operator||
name|CC_Z_IN_NOT_N
expr_stmt|;
else|else
name|cc_status
operator|.
name|flags
operator|=
name|CC_NOT_NEGATIVE
operator||
name|CC_Z_IN_NOT_N
expr_stmt|;
comment|/* These three statements used to use next_insns_test_no... 	 but it appears that this should do the same job.  */
if|if
condition|(
name|count
operator|==
literal|31
operator|&&
name|next_insn_tests_no_inequality
argument_list|(
name|insn
argument_list|)
condition|)
return|return
literal|"tst%.l %1"
return|;
if|if
condition|(
name|count
operator|==
literal|15
operator|&&
name|next_insn_tests_no_inequality
argument_list|(
name|insn
argument_list|)
condition|)
return|return
literal|"tst%.w %1"
return|;
if|if
condition|(
name|count
operator|==
literal|7
operator|&&
name|next_insn_tests_no_inequality
argument_list|(
name|insn
argument_list|)
condition|)
return|return
literal|"tst%.b %1"
return|;
name|cc_status
operator|.
name|flags
operator|=
name|CC_NOT_NEGATIVE
expr_stmt|;
block|}
return|return
literal|"btst %0,%1"
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the best assembler insn template    for moving operands[1] into operands[0] as a fullword.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|singlemove_string
parameter_list|(
name|operands
parameter_list|)
name|rtx
modifier|*
name|operands
decl_stmt|;
block|{
if|if
condition|(
name|operands
index|[
literal|1
index|]
operator|!=
name|const0_rtx
condition|)
return|return
literal|"mov%.l %1,%0"
return|;
if|if
condition|(
operator|!
name|ADDRESS_REG_P
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
condition|)
return|return
literal|"clr%.l %0"
return|;
return|return
literal|"sub%.l %0,%0"
return|;
block|}
end_function

begin_comment
comment|/* Output assembler code to perform a doubleword move insn    with operands OPERANDS.  */
end_comment

begin_function
name|char
modifier|*
name|output_move_double
parameter_list|(
name|operands
parameter_list|)
name|rtx
modifier|*
name|operands
decl_stmt|;
block|{
enum|enum
block|{
name|REGOP
block|,
name|OFFSOP
block|,
name|MEMOP
block|,
name|PUSHOP
block|,
name|POPOP
block|,
name|CNSTOP
block|,
name|RNDOP
block|}
name|optype0
enum|,
name|optype1
expr_stmt|;
name|rtx
name|latehalf
index|[
literal|2
index|]
decl_stmt|;
name|rtx
name|addreg0
init|=
literal|0
decl_stmt|,
name|addreg1
init|=
literal|0
decl_stmt|;
comment|/* First classify both operands.  */
if|if
condition|(
name|REG_P
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
condition|)
name|optype0
operator|=
name|REGOP
expr_stmt|;
elseif|else
if|if
condition|(
name|offsettable_memref_p
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
condition|)
name|optype0
operator|=
name|OFFSOP
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|POST_INC
condition|)
name|optype0
operator|=
name|POPOP
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PRE_DEC
condition|)
name|optype0
operator|=
name|PUSHOP
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|MEM
condition|)
name|optype0
operator|=
name|MEMOP
expr_stmt|;
else|else
name|optype0
operator|=
name|RNDOP
expr_stmt|;
if|if
condition|(
name|REG_P
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
name|optype1
operator|=
name|REGOP
expr_stmt|;
elseif|else
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
name|optype1
operator|=
name|CNSTOP
expr_stmt|;
elseif|else
if|if
condition|(
name|offsettable_memref_p
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
name|optype1
operator|=
name|OFFSOP
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|POST_INC
condition|)
name|optype1
operator|=
name|POPOP
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PRE_DEC
condition|)
name|optype1
operator|=
name|PUSHOP
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|MEM
condition|)
name|optype1
operator|=
name|MEMOP
expr_stmt|;
else|else
name|optype1
operator|=
name|RNDOP
expr_stmt|;
comment|/* Check for the cases that the operand constraints are not      supposed to allow to happen.  Abort if we get one,      because generating code for these cases is painful.  */
if|if
condition|(
name|optype0
operator|==
name|RNDOP
operator|||
name|optype1
operator|==
name|RNDOP
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* If one operand is decrementing and one is incrementing      decrement the former register explicitly      and change that operand into ordinary indexing.  */
if|if
condition|(
name|optype0
operator|==
name|PUSHOP
operator|&&
name|optype1
operator|==
name|POPOP
condition|)
block|{
name|operands
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"subq%.l %#8,%0"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
name|operands
index|[
literal|0
index|]
operator|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|DImode
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|optype0
operator|=
name|OFFSOP
expr_stmt|;
block|}
if|if
condition|(
name|optype0
operator|==
name|POPOP
operator|&&
name|optype1
operator|==
name|PUSHOP
condition|)
block|{
name|operands
index|[
literal|1
index|]
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"subq%.l %#8,%1"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
name|operands
index|[
literal|1
index|]
operator|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|DImode
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|optype1
operator|=
name|OFFSOP
expr_stmt|;
block|}
comment|/* If an operand is an unoffsettable memory ref, find a register      we can increment temporarily to make it refer to the second word.  */
if|if
condition|(
name|optype0
operator|==
name|MEMOP
condition|)
name|addreg0
operator|=
name|find_addr_reg
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|optype1
operator|==
name|MEMOP
condition|)
name|addreg1
operator|=
name|find_addr_reg
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Ok, we can do one word at a time.      Normally we do the low-numbered word first,      but if either operand is autodecrementing then we      do the high-numbered word first.       In either case, set up in LATEHALF the operands to use      for the high-numbered word and in some cases alter the      operands in OPERANDS to be suitable for the low-numbered word.  */
if|if
condition|(
name|optype0
operator|==
name|REGOP
condition|)
name|latehalf
index|[
literal|0
index|]
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|SImode
argument_list|,
name|REGNO
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|optype0
operator|==
name|OFFSOP
condition|)
name|latehalf
index|[
literal|0
index|]
operator|=
name|adj_offsettable_operand
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|4
argument_list|)
expr_stmt|;
else|else
name|latehalf
index|[
literal|0
index|]
operator|=
name|operands
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|optype1
operator|==
name|REGOP
condition|)
name|latehalf
index|[
literal|1
index|]
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|SImode
argument_list|,
name|REGNO
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|optype1
operator|==
name|OFFSOP
condition|)
name|latehalf
index|[
literal|1
index|]
operator|=
name|adj_offsettable_operand
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|4
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|optype1
operator|==
name|CNSTOP
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
name|split_double
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
operator|&
name|operands
index|[
literal|1
index|]
argument_list|,
operator|&
name|latehalf
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|latehalf
index|[
literal|1
index|]
operator|=
name|operands
index|[
literal|1
index|]
expr_stmt|;
name|operands
index|[
literal|1
index|]
operator|=
name|const0_rtx
expr_stmt|;
block|}
block|}
else|else
name|latehalf
index|[
literal|1
index|]
operator|=
name|operands
index|[
literal|1
index|]
expr_stmt|;
comment|/* If insn is effectively movd N(sp),-(sp) then we will do the      high word first.  We should use the adjusted operand 1 (which is N+4(sp))      for the low word as well, to compensate for the first decrement of sp.  */
if|if
condition|(
name|optype0
operator|==
name|PUSHOP
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|STACK_POINTER_REGNUM
operator|&&
name|reg_overlap_mentioned_p
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
name|operands
index|[
literal|1
index|]
operator|=
name|latehalf
index|[
literal|1
index|]
expr_stmt|;
comment|/* If one or both operands autodecrementing,      do the two words, high-numbered first.  */
comment|/* Likewise,  the first move would clobber the source of the second one,      do them in the other order.  This happens only for registers;      such overlap can't happen in memory unless the user explicitly      sets it up, and that is an undefined circumstance.  */
if|if
condition|(
name|optype0
operator|==
name|PUSHOP
operator|||
name|optype1
operator|==
name|PUSHOP
operator|||
operator|(
name|optype0
operator|==
name|REGOP
operator|&&
name|optype1
operator|==
name|REGOP
operator|&&
name|REGNO
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|REGNO
argument_list|(
name|latehalf
index|[
literal|1
index|]
argument_list|)
operator|)
condition|)
block|{
comment|/* Make any unoffsettable addresses point at high-numbered word.  */
if|if
condition|(
name|addreg0
condition|)
name|output_asm_insn
argument_list|(
literal|"addql %#4,%0"
argument_list|,
operator|&
name|addreg0
argument_list|)
expr_stmt|;
if|if
condition|(
name|addreg1
condition|)
name|output_asm_insn
argument_list|(
literal|"addql %#4,%0"
argument_list|,
operator|&
name|addreg1
argument_list|)
expr_stmt|;
comment|/* Do that word.  */
name|output_asm_insn
argument_list|(
name|singlemove_string
argument_list|(
name|latehalf
argument_list|)
argument_list|,
name|latehalf
argument_list|)
expr_stmt|;
comment|/* Undo the adds we just did.  */
if|if
condition|(
name|addreg0
condition|)
name|output_asm_insn
argument_list|(
literal|"subql %#4,%0"
argument_list|,
operator|&
name|addreg0
argument_list|)
expr_stmt|;
if|if
condition|(
name|addreg1
condition|)
name|output_asm_insn
argument_list|(
literal|"subql %#4,%0"
argument_list|,
operator|&
name|addreg1
argument_list|)
expr_stmt|;
comment|/* Do low-numbered word.  */
return|return
name|singlemove_string
argument_list|(
name|operands
argument_list|)
return|;
block|}
comment|/* Normal case: do the two words, low-numbered first.  */
name|output_asm_insn
argument_list|(
name|singlemove_string
argument_list|(
name|operands
argument_list|)
argument_list|,
name|operands
argument_list|)
expr_stmt|;
comment|/* Make any unoffsettable addresses point at high-numbered word.  */
if|if
condition|(
name|addreg0
condition|)
name|output_asm_insn
argument_list|(
literal|"addql %#4,%0"
argument_list|,
operator|&
name|addreg0
argument_list|)
expr_stmt|;
if|if
condition|(
name|addreg1
condition|)
name|output_asm_insn
argument_list|(
literal|"addql %#4,%0"
argument_list|,
operator|&
name|addreg1
argument_list|)
expr_stmt|;
comment|/* Do that word.  */
name|output_asm_insn
argument_list|(
name|singlemove_string
argument_list|(
name|latehalf
argument_list|)
argument_list|,
name|latehalf
argument_list|)
expr_stmt|;
comment|/* Undo the adds we just did.  */
if|if
condition|(
name|addreg0
condition|)
name|output_asm_insn
argument_list|(
literal|"subql %#4,%0"
argument_list|,
operator|&
name|addreg0
argument_list|)
expr_stmt|;
if|if
condition|(
name|addreg1
condition|)
name|output_asm_insn
argument_list|(
literal|"subql %#4,%0"
argument_list|,
operator|&
name|addreg1
argument_list|)
expr_stmt|;
return|return
literal|""
return|;
block|}
end_function

begin_comment
comment|/* Return a REG that occurs in ADDR with coefficient 1.    ADDR can be effectively incremented by incrementing REG.  */
end_comment

begin_function
specifier|static
name|rtx
name|find_addr_reg
parameter_list|(
name|addr
parameter_list|)
name|rtx
name|addr
decl_stmt|;
block|{
while|while
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|PLUS
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|REG
condition|)
return|return
name|addr
return|;
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|int
name|standard_SunFPA_constant_p
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

