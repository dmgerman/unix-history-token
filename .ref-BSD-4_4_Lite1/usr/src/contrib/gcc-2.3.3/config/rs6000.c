begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Subroutines used for code generation on IBM RS/6000.    Copyright (C) 1991 Free Software Foundation, Inc.    Contributed by Richard Kenner (kenner@nyu.edu)  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"conditions.h"
end_include

begin_include
include|#
directive|include
file|"insn-flags.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"insn-attr.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|language_string
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|min
parameter_list|(
name|A
parameter_list|,
name|B
parameter_list|)
value|((A)< (B) ? (A) : (B))
end_define

begin_define
define|#
directive|define
name|max
parameter_list|(
name|A
parameter_list|,
name|B
parameter_list|)
value|((A)> (B) ? (A) : (B))
end_define

begin_comment
comment|/* Set to non-zero by "fix" operation to indicate that itrunc and    uitrunc must be defined.  */
end_comment

begin_decl_stmt
name|int
name|rs6000_trunc_used
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set to non-zero once they have been defined.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|trunc_defined
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Save information from a "cmpxx" operation until the branch or scc is    emitted.  */
end_comment

begin_decl_stmt
name|rtx
name|rs6000_compare_op0
decl_stmt|,
name|rs6000_compare_op1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|rs6000_compare_fp_p
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Return non-zero if this function is known to have a null epilogue.  */
end_comment

begin_function
name|int
name|direct_return
parameter_list|()
block|{
return|return
operator|(
name|reload_completed
operator|&&
name|first_reg_to_save
argument_list|()
operator|==
literal|32
operator|&&
name|first_fp_reg_to_save
argument_list|()
operator|==
literal|64
operator|&&
operator|!
name|regs_ever_live
index|[
literal|65
index|]
operator|&&
operator|!
name|rs6000_pushes_stack
argument_list|()
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Returns 1 always.  */
end_comment

begin_function
name|int
name|any_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a constant that can fit in a D field.  */
end_comment

begin_function
name|int
name|short_cint_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
call|(
name|unsigned
call|)
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|+
literal|0x8000
argument_list|)
operator|<
literal|0x10000
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Similar for a unsigned D field.  */
end_comment

begin_function
name|int
name|u_short_cint_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|&
literal|0xffff0000
operator|)
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a CONST_INT that cannot fit in a signed D field.  */
end_comment

begin_function
name|int
name|non_short_cint_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
call|(
name|unsigned
call|)
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|+
literal|0x8000
argument_list|)
operator|>=
literal|0x10000
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Returns 1 if OP is a register that is not special (i.e., not MQ,    ctr, or lr).  */
end_comment

begin_function
name|int
name|gpc_reg_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|REG
operator|||
name|REGNO
argument_list|(
name|op
argument_list|)
operator|>=
literal|67
operator|||
name|REGNO
argument_list|(
name|op
argument_list|)
operator|<
literal|64
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Returns 1 if OP is either a pseudo-register or a register denoting a    CR field.  */
end_comment

begin_function
name|int
name|cc_reg_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|REG
operator|||
name|REGNO
argument_list|(
name|op
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|||
name|CR_REGNO_P
argument_list|(
name|REGNO
argument_list|(
name|op
argument_list|)
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Returns 1 if OP is either a constant integer valid for a D-field or a    non-special register.  If a register, it must be in the proper mode unless    MODE is VOIDmode.  */
end_comment

begin_function
name|int
name|reg_or_short_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
name|short_cint_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
return|return
name|gpc_reg_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Similar, except check if the negation of the constant would be valid for    a D-field.  */
end_comment

begin_function
name|int
name|reg_or_neg_short_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
name|CONST_OK_FOR_LETTER_P
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|,
literal|'P'
argument_list|)
return|;
return|return
name|gpc_reg_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if the operand is either a register or an integer whose high-order    16 bits are zero.  */
end_comment

begin_function
name|int
name|reg_or_u_short_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|&
literal|0xffff0000
operator|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
return|return
name|gpc_reg_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 is the operand is either a non-special register or ANY    constant integer.  */
end_comment

begin_function
name|int
name|reg_or_cint_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|||
name|gpc_reg_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if the operand is a CONST_DOUBLE and it can be put into a    register with one instruction per word.  For SFmode, this means  that    the low 16-bits are zero.  For DFmode, it means the low 16-bits of    the first word are zero and the high 16 bits of the second word    are zero (usually all bits in the low-order word will be zero).     We only do this if we can safely read CONST_DOUBLE_{LOW,HIGH}.  */
end_comment

begin_function
name|int
name|easy_fp_constant
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
specifier|register
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|rtx
name|low
decl_stmt|,
name|high
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|CONST_DOUBLE
operator|||
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|mode
operator|||
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|!=
name|MODE_FLOAT
condition|)
return|return
literal|0
return|;
name|high
operator|=
name|operand_subword
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|low
operator|=
name|operand_subword
argument_list|(
name|op
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|high
operator|==
literal|0
operator|||
name|GET_CODE
argument_list|(
name|high
argument_list|)
operator|!=
name|CONST_INT
operator|||
operator|(
name|INTVAL
argument_list|(
name|high
argument_list|)
operator|&
literal|0xffff
operator|)
condition|)
return|return
literal|0
return|;
return|return
operator|(
name|mode
operator|==
name|SFmode
operator|||
operator|(
name|low
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|low
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|INTVAL
argument_list|(
name|low
argument_list|)
operator|&
literal|0xffff0000
operator|)
operator|==
literal|0
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if the operand is either a floating-point register, a pseudo    register, or memory.  */
end_comment

begin_function
name|int
name|fp_reg_or_mem_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|memory_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|||
operator|(
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|REG
operator|||
name|REGNO
argument_list|(
name|op
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|||
name|FP_REGNO_P
argument_list|(
name|REGNO
argument_list|(
name|op
argument_list|)
argument_list|)
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if the operand is either an easy FP constant (see above) or    memory.  */
end_comment

begin_function
name|int
name|mem_or_easy_const_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
name|memory_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|||
name|easy_fp_constant
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if the operand is either a non-special register or an item    that can be used as the operand of an SI add insn.  */
end_comment

begin_function
name|int
name|add_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|reg_or_short_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|&
literal|0xffff
operator|)
operator|==
literal|0
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a constant but not a valid add_operand.  */
end_comment

begin_function
name|int
name|non_add_cint_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
call|(
name|unsigned
call|)
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|+
literal|0x8000
argument_list|)
operator|>=
literal|0x10000
operator|&&
operator|(
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|&
literal|0xffff
operator|)
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if the operand is a non-special register or a constant that    can be used as the operand of an OR or XOR insn on the RS/6000.  */
end_comment

begin_function
name|int
name|logical_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|gpc_reg_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
operator|(
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|&
literal|0xffff0000
operator|)
operator|==
literal|0
operator|||
operator|(
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|&
literal|0xffff
operator|)
operator|==
literal|0
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if C is a constant that is not a logical operand (as    above).  */
end_comment

begin_function
name|int
name|non_logical_cint_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|&
literal|0xffff0000
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|&
literal|0xffff
operator|)
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if C is a constant that can be encoded in a mask on the    RS/6000.  It is if there are no more than two 1->0 or 0->1 transitions.    Reject all ones and all zeros, since these should have been optimized    away and confuse the making of MB and ME.  */
end_comment

begin_function
name|int
name|mask_constant
parameter_list|(
name|c
parameter_list|)
specifier|register
name|int
name|c
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|last_bit_value
decl_stmt|;
name|int
name|transitions
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
operator|||
name|c
operator|==
operator|~
literal|0
condition|)
return|return
literal|0
return|;
name|last_bit_value
operator|=
name|c
operator|&
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
operator|(
name|c
operator|>>=
literal|1
operator|)
operator|&
literal|1
operator|)
operator|!=
name|last_bit_value
condition|)
name|last_bit_value
operator|^=
literal|1
operator|,
name|transitions
operator|++
expr_stmt|;
return|return
name|transitions
operator|<=
literal|2
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if the operand is a constant that is a mask on the RS/6000. */
end_comment

begin_function
name|int
name|mask_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|mask_constant
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if the operand is either a non-special register or a    constant that can be used as the operand of an RS/6000 logical AND insn.  */
end_comment

begin_function
name|int
name|and_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|reg_or_short_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|||
name|logical_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|||
name|mask_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if the operand is a constant but not a valid operand for an AND    insn.  */
end_comment

begin_function
name|int
name|non_and_cint_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|!
name|and_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if the operand is a general register or memory operand.  */
end_comment

begin_function
name|int
name|reg_or_mem_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
specifier|register
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
name|gpc_reg_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|||
name|memory_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if the operand, used inside a MEM, is a valid first argument    to CALL.  This is a SYMBOL_REF or a pseudo-register, which will be    forced to lr.  */
end_comment

begin_function
name|int
name|call_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|mode
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|mode
condition|)
return|return
literal|0
return|;
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SYMBOL_REF
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|op
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if this operand is a valid input for a move insn.  */
end_comment

begin_function
name|int
name|input_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|memory_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* For floating-point or multi-word mode, only register or memory      is valid.  */
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_FLOAT
operator|||
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|>
name|UNITS_PER_WORD
condition|)
return|return
name|gpc_reg_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
comment|/* The only cases left are integral modes one word or smaller (we      do not get called for MODE_CC values).  These can be in any      register.  */
if|if
condition|(
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
condition|)
return|return;
comment|/* For HImode and QImode, any constant is valid. */
if|if
condition|(
operator|(
name|mode
operator|==
name|HImode
operator|||
name|mode
operator|==
name|QImode
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
literal|1
return|;
comment|/* Otherwise, we will be doing this SET with an add, so anything valid      for an add will be valid.  */
return|return
name|add_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return 1 if OP is a load multiple operation.  It is known to be a    PARALLEL and the first section will be tested.  */
end_comment

begin_function
name|int
name|load_multiple_operation
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|int
name|count
init|=
name|XVECLEN
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|int
name|dest_regno
decl_stmt|;
name|rtx
name|src_addr
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Perform a quick check so we don't blow up below.  */
if|if
condition|(
name|count
operator|<=
literal|1
operator|||
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|SET
operator|||
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|REG
operator|||
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|MEM
condition|)
return|return
literal|0
return|;
name|dest_regno
operator|=
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|src_addr
operator|=
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|elt
init|=
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|elt
argument_list|)
operator|!=
name|SET
operator|||
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|!=
name|REG
operator|||
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|!=
name|SImode
operator|||
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|!=
name|dest_regno
operator|+
name|i
operator|||
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|!=
name|MEM
operator|||
name|GET_MODE
argument_list|(
name|SET_SRC
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|!=
name|SImode
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|elt
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|PLUS
operator|||
operator|!
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|elt
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|src_addr
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|elt
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
operator|||
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|elt
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|i
operator|*
literal|4
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Similar, but tests for store multiple.  Here, the second vector element    is a CLOBBER.  It will be tested later.  */
end_comment

begin_function
name|int
name|store_multiple_operation
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|int
name|count
init|=
name|XVECLEN
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
decl_stmt|;
name|int
name|src_regno
decl_stmt|;
name|rtx
name|dest_addr
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Perform a quick check so we don't blow up below.  */
if|if
condition|(
name|count
operator|<=
literal|1
operator|||
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|SET
operator|||
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|MEM
operator|||
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|REG
condition|)
return|return
literal|0
return|;
name|src_regno
operator|=
name|REGNO
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|dest_addr
operator|=
name|XEXP
argument_list|(
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|elt
init|=
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
name|i
operator|+
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|elt
argument_list|)
operator|!=
name|SET
operator|||
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|!=
name|REG
operator|||
name|GET_MODE
argument_list|(
name|SET_SRC
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|!=
name|SImode
operator|||
name|REGNO
argument_list|(
name|SET_SRC
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|!=
name|src_regno
operator|+
name|i
operator|||
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|!=
name|MEM
operator|||
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|!=
name|SImode
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_DEST
argument_list|(
name|elt
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|PLUS
operator|||
operator|!
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|SET_DEST
argument_list|(
name|elt
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|dest_addr
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|SET_DEST
argument_list|(
name|elt
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
operator|||
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|SET_DEST
argument_list|(
name|elt
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|i
operator|*
literal|4
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return 1 if OP is a comparison operation that is valid for a branch insn.    We only check the opcode against the mode of the CC value here.  */
end_comment

begin_function
name|int
name|branch_comparison_operator
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|op
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|cc_mode
decl_stmt|;
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|!=
literal|'<'
condition|)
return|return
literal|0
return|;
name|cc_mode
operator|=
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|cc_mode
argument_list|)
operator|!=
name|MODE_CC
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|(
name|code
operator|==
name|GT
operator|||
name|code
operator|==
name|LT
operator|||
name|code
operator|==
name|GE
operator|||
name|code
operator|==
name|LE
operator|)
operator|&&
name|cc_mode
operator|==
name|CCUNSmode
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|(
name|code
operator|==
name|GTU
operator|||
name|code
operator|==
name|LTU
operator|||
name|code
operator|==
name|GEU
operator|||
name|code
operator|==
name|LEU
operator|)
operator|&&
operator|(
name|cc_mode
operator|!=
name|CCUNSmode
operator|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a comparison operation that is valid for an scc insn.    We check the opcode against the mode of the CC value and disallow EQ or    NE comparisons for integers.  */
end_comment

begin_function
name|int
name|scc_comparison_operator
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|op
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|cc_mode
decl_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|mode
operator|&&
name|mode
operator|!=
name|VOIDmode
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|!=
literal|'<'
condition|)
return|return
literal|0
return|;
name|cc_mode
operator|=
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|cc_mode
argument_list|)
operator|!=
name|MODE_CC
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|code
operator|==
name|NE
operator|&&
name|cc_mode
operator|!=
name|CCFPmode
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|(
name|code
operator|==
name|GT
operator|||
name|code
operator|==
name|LT
operator|||
name|code
operator|==
name|GE
operator|||
name|code
operator|==
name|LE
operator|)
operator|&&
name|cc_mode
operator|==
name|CCUNSmode
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|(
name|code
operator|==
name|GTU
operator|||
name|code
operator|==
name|LTU
operator|||
name|code
operator|==
name|GEU
operator|||
name|code
operator|==
name|LEU
operator|)
operator|&&
operator|(
name|cc_mode
operator|!=
name|CCUNSmode
operator|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|cc_mode
operator|==
name|CCEQmode
operator|&&
name|code
operator|!=
name|EQ
operator|&&
name|code
operator|!=
name|NE
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return 1 if ANDOP is a mask that has no bits on that are not in the    mask required to convert the result of a rotate insn into a shift    left insn of SHIFTOP bits.  Both are known to be CONST_INT.  */
end_comment

begin_function
name|int
name|includes_lshift_p
parameter_list|(
name|shiftop
parameter_list|,
name|andop
parameter_list|)
specifier|register
name|rtx
name|shiftop
decl_stmt|;
specifier|register
name|rtx
name|andop
decl_stmt|;
block|{
name|int
name|shift_mask
init|=
operator|(
operator|~
literal|0
operator|<<
name|INTVAL
argument_list|(
name|shiftop
argument_list|)
operator|)
decl_stmt|;
return|return
operator|(
name|INTVAL
argument_list|(
name|andop
argument_list|)
operator|&
operator|~
name|shift_mask
operator|)
operator|==
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Similar, but for right shift.  */
end_comment

begin_function
name|int
name|includes_rshift_p
parameter_list|(
name|shiftop
parameter_list|,
name|andop
parameter_list|)
specifier|register
name|rtx
name|shiftop
decl_stmt|;
specifier|register
name|rtx
name|andop
decl_stmt|;
block|{
name|unsigned
name|shift_mask
init|=
operator|~
literal|0
decl_stmt|;
name|shift_mask
operator|>>=
name|INTVAL
argument_list|(
name|shiftop
argument_list|)
expr_stmt|;
return|return
operator|(
name|INTVAL
argument_list|(
name|andop
argument_list|)
operator|&
operator|~
name|shift_mask
operator|)
operator|==
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the register class of a scratch register needed to copy IN into    or out of a register in CLASS in MODE.  If it can be done directly,    NO_REGS is returned.  */
end_comment

begin_function
name|enum
name|reg_class
name|secondary_reload_class
parameter_list|(
name|class
parameter_list|,
name|mode
parameter_list|,
name|in
parameter_list|)
name|enum
name|reg_class
name|class
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|in
decl_stmt|;
block|{
name|int
name|regno
init|=
name|true_regnum
argument_list|(
name|in
argument_list|)
decl_stmt|;
if|if
condition|(
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
name|regno
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* We can place anything into GENERAL_REGS and can put GENERAL_REGS      into anything.  */
if|if
condition|(
name|class
operator|==
name|GENERAL_REGS
operator|||
name|class
operator|==
name|BASE_REGS
operator|||
operator|(
name|regno
operator|>=
literal|0
operator|&&
name|INT_REGNO_P
argument_list|(
name|regno
argument_list|)
operator|)
condition|)
return|return
name|NO_REGS
return|;
comment|/* Constants, memory, and FP registers can go into FP registers.  */
if|if
condition|(
operator|(
name|regno
operator|==
operator|-
literal|1
operator|||
name|FP_REGNO_P
argument_list|(
name|regno
argument_list|)
operator|)
operator|&&
operator|(
name|class
operator|==
name|FLOAT_REGS
operator|||
name|class
operator|==
name|NON_SPECIAL_REGS
operator|)
condition|)
return|return
name|NO_REGS
return|;
comment|/* We can copy among the CR registers.  */
if|if
condition|(
operator|(
name|class
operator|==
name|CR_REGS
operator|||
name|class
operator|==
name|CR0_REGS
operator|)
operator|&&
name|regno
operator|>=
literal|0
operator|&&
name|CR_REGNO_P
argument_list|(
name|regno
argument_list|)
condition|)
return|return
name|NO_REGS
return|;
comment|/* Otherwise, we need GENERAL_REGS.  */
return|return
name|GENERAL_REGS
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given a comparison operation, return the bit number in CCR to test.  We    know this is a valid comparison.       SCC_P is 1 if this is for an scc.  That means that %D will have been    used instead of %C, so the bits will be in different places.     Return -1 if OP isn't a valid comparison for some reason.  */
end_comment

begin_function
name|int
name|ccr_bit
parameter_list|(
name|op
parameter_list|,
name|scc_p
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|int
name|scc_p
decl_stmt|;
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|op
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|cc_mode
decl_stmt|;
name|int
name|cc_regnum
decl_stmt|;
name|int
name|base_bit
decl_stmt|;
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|!=
literal|'<'
condition|)
return|return
operator|-
literal|1
return|;
name|cc_mode
operator|=
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|cc_regnum
operator|=
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|base_bit
operator|=
literal|4
operator|*
operator|(
name|cc_regnum
operator|-
literal|68
operator|)
expr_stmt|;
comment|/* In CCEQmode cases we have made sure that the result is always in the      third bit of the CR field.  */
if|if
condition|(
name|cc_mode
operator|==
name|CCEQmode
condition|)
return|return
name|base_bit
operator|+
literal|3
return|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|NE
case|:
return|return
name|scc_p
condition|?
name|base_bit
operator|+
literal|3
else|:
name|base_bit
operator|+
literal|2
return|;
case|case
name|EQ
case|:
return|return
name|base_bit
operator|+
literal|2
return|;
case|case
name|GT
case|:
case|case
name|GTU
case|:
return|return
name|base_bit
operator|+
literal|1
return|;
case|case
name|LT
case|:
case|case
name|LTU
case|:
return|return
name|base_bit
return|;
case|case
name|GE
case|:
case|case
name|GEU
case|:
comment|/* If floating-point, we will have done a cror to put the bit in the 	 unordered position.  So test that bit.  For integer, this is ! LT 	 unless this is an scc insn.  */
return|return
name|cc_mode
operator|==
name|CCFPmode
operator|||
name|scc_p
condition|?
name|base_bit
operator|+
literal|3
else|:
name|base_bit
return|;
case|case
name|LE
case|:
case|case
name|LEU
case|:
return|return
name|cc_mode
operator|==
name|CCFPmode
operator|||
name|scc_p
condition|?
name|base_bit
operator|+
literal|3
else|:
name|base_bit
operator|+
literal|1
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print an operand.  Recognize special options, documented below.  */
end_comment

begin_function
name|void
name|print_operand
parameter_list|(
name|file
parameter_list|,
name|x
parameter_list|,
name|code
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|char
name|code
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|val
decl_stmt|;
comment|/* These macros test for integers and extract the low-order bits.  */
define|#
directive|define
name|INT_P
parameter_list|(
name|X
parameter_list|)
define|\
value|((GET_CODE (X) == CONST_INT || GET_CODE (X) == CONST_DOUBLE)	\&& GET_MODE (X) == VOIDmode)
define|#
directive|define
name|INT_LOWPART
parameter_list|(
name|X
parameter_list|)
define|\
value|(GET_CODE (X) == CONST_INT ? INTVAL (X) : CONST_DOUBLE_LOW (X))
switch|switch
condition|(
name|code
condition|)
block|{
case|case
literal|'h'
case|:
comment|/* If constant, output low-order five bits.  Otherwise, 	 write normally. */
if|if
condition|(
name|INT_P
argument_list|(
name|x
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d"
argument_list|,
name|INT_LOWPART
argument_list|(
name|x
argument_list|)
operator|&
literal|31
argument_list|)
expr_stmt|;
else|else
name|print_operand
argument_list|(
name|file
argument_list|,
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'H'
case|:
comment|/* X must be a constant.  Output the low order 5 bits plus 24.  */
if|if
condition|(
operator|!
name|INT_P
argument_list|(
name|x
argument_list|)
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%H value"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d"
argument_list|,
operator|(
name|INT_LOWPART
argument_list|(
name|x
argument_list|)
operator|+
literal|24
operator|)
operator|&
literal|31
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'b'
case|:
comment|/* Low-order 16 bits of constant, unsigned.  */
if|if
condition|(
operator|!
name|INT_P
argument_list|(
name|x
argument_list|)
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%b value"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d"
argument_list|,
name|INT_LOWPART
argument_list|(
name|x
argument_list|)
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'w'
case|:
comment|/* If constant, low-order 16 bits of constant, signed.  Otherwise, write 	 normally.  */
if|if
condition|(
name|INT_P
argument_list|(
name|x
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d"
argument_list|,
operator|(
name|INT_LOWPART
argument_list|(
name|x
argument_list|)
operator|&
literal|0xffff
operator|)
operator|-
literal|2
operator|*
operator|(
name|INT_LOWPART
argument_list|(
name|x
argument_list|)
operator|&
literal|0x8000
operator|)
argument_list|)
expr_stmt|;
else|else
name|print_operand
argument_list|(
name|file
argument_list|,
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'W'
case|:
comment|/* If constant, low-order 16 bits of constant, unsigned. 	 Otherwise, write normally.  */
if|if
condition|(
name|INT_P
argument_list|(
name|x
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d"
argument_list|,
name|INT_LOWPART
argument_list|(
name|x
argument_list|)
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
else|else
name|print_operand
argument_list|(
name|file
argument_list|,
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'u'
case|:
comment|/* High-order 16 bits of constant.  */
if|if
condition|(
operator|!
name|INT_P
argument_list|(
name|x
argument_list|)
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%u value"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d"
argument_list|,
operator|(
name|INT_LOWPART
argument_list|(
name|x
argument_list|)
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'s'
case|:
comment|/* Low 5 bits of 32 - value */
if|if
condition|(
operator|!
name|INT_P
argument_list|(
name|x
argument_list|)
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%s value"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d"
argument_list|,
operator|(
literal|32
operator|-
name|INT_LOWPART
argument_list|(
name|x
argument_list|)
operator|)
operator|&
literal|31
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'S'
case|:
comment|/* Low 5 bits of 31 - value */
if|if
condition|(
operator|!
name|INT_P
argument_list|(
name|x
argument_list|)
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%S value"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d"
argument_list|,
operator|(
literal|31
operator|-
name|INT_LOWPART
argument_list|(
name|x
argument_list|)
operator|)
operator|&
literal|31
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'p'
case|:
comment|/* X is a CONST_INT that is a power of two.  Output the logarithm.  */
if|if
condition|(
operator|!
name|INT_P
argument_list|(
name|x
argument_list|)
operator|||
operator|(
name|i
operator|=
name|exact_log2
argument_list|(
name|INT_LOWPART
argument_list|(
name|x
argument_list|)
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%p value"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'m'
case|:
comment|/* MB value for a mask operand.  */
if|if
condition|(
operator|!
name|mask_operand
argument_list|(
name|x
argument_list|,
name|VOIDmode
argument_list|)
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%m value"
argument_list|)
expr_stmt|;
name|val
operator|=
name|INT_LOWPART
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|/* If the high bit is set and the low bit is not, the value is zero. 	 If the high bit is zero, the value is the first 1 bit we find from 	 the left.  */
if|if
condition|(
name|val
operator|<
literal|0
operator|&&
operator|(
name|val
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"0"
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|val
operator|>=
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|val
operator|<<=
literal|1
operator|)
operator|<
literal|0
condition|)
break|break;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Otherwise, look for the first 0 bit from the right.  The result is its 	 number plus 1. We know the low-order bit is one.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
operator|(
name|val
operator|>>=
literal|1
operator|)
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
break|break;
comment|/* If we ended in ...01, I would be 0.  The correct value is 31, so 	 we want 31 - i.  */
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d"
argument_list|,
literal|31
operator|-
name|i
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'M'
case|:
comment|/* ME value for a mask operand.  */
if|if
condition|(
operator|!
name|mask_operand
argument_list|(
name|x
argument_list|,
name|VOIDmode
argument_list|)
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%m value"
argument_list|)
expr_stmt|;
name|val
operator|=
name|INT_LOWPART
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|/* If the low bit is set and the high bit is not, the value is 31. 	 If the low bit is zero, the value is the first 1 bit we find from 	 the right.  */
if|if
condition|(
operator|(
name|val
operator|&
literal|1
operator|)
operator|&&
name|val
operator|>=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"31"
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
operator|(
name|val
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|val
operator|>>=
literal|1
operator|)
operator|&
literal|1
condition|)
break|break;
comment|/* If we had ....10, I would be 0.  The result should be 	     30, so we need 30 - i.  */
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d"
argument_list|,
literal|30
operator|-
name|i
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Otherwise, look for the first 0 bit from the left.  The result is its 	 number minus 1. We know the high-order bit is one.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|val
operator|<<=
literal|1
operator|)
operator|>=
literal|0
condition|)
break|break;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'f'
case|:
comment|/* X is a CR register.  Print the shift count needed to move it 	 to the high-order four bits.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|REG
operator|||
operator|!
name|CR_REGNO_P
argument_list|(
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%f value"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d"
argument_list|,
literal|4
operator|*
operator|(
name|REGNO
argument_list|(
name|x
argument_list|)
operator|-
literal|68
operator|)
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'F'
case|:
comment|/* Similar, but print the count for the rotate in the opposite 	 direction.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|REG
operator|||
operator|!
name|CR_REGNO_P
argument_list|(
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%F value"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d"
argument_list|,
literal|32
operator|-
literal|4
operator|*
operator|(
name|REGNO
argument_list|(
name|x
argument_list|)
operator|-
literal|68
operator|)
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'E'
case|:
comment|/* X is a CR register.  Print the number of the third bit of the CR */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|REG
operator|||
operator|!
name|CR_REGNO_P
argument_list|(
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%E value"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d"
argument_list|,
literal|4
operator|*
operator|(
name|REGNO
argument_list|(
name|x
argument_list|)
operator|-
literal|68
operator|)
operator|+
literal|3
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
comment|/* X is a CR register.  Print the mask for `mtcrf'.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|REG
operator|||
operator|!
name|CR_REGNO_P
argument_list|(
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%R value"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d"
argument_list|,
literal|128
operator|>>
operator|(
name|REGNO
argument_list|(
name|x
argument_list|)
operator|-
literal|68
operator|)
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'X'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
operator|&&
name|LEGITIMATE_INDEXED_ADDRESS_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"x"
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'U'
case|:
comment|/* Print `u' is this has an auto-increment or auto-decrement.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PRE_INC
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PRE_DEC
operator|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"u"
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'I'
case|:
comment|/* Print `i' is this is a constant, else nothing.  */
if|if
condition|(
name|INT_P
argument_list|(
name|x
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"i"
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'N'
case|:
comment|/* Write the number of elements in the vector times 4.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|PARALLEL
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%N value"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d"
argument_list|,
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|*
literal|4
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'O'
case|:
comment|/* Similar, but subtract 1 first.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|PARALLEL
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%N value"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d"
argument_list|,
operator|(
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
operator|)
operator|*
literal|4
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'P'
case|:
comment|/* The operand must be an indirect memory reference.  The result 	 is the register number. */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|MEM
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|REG
operator|||
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|>=
literal|32
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%P value"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d"
argument_list|,
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'L'
case|:
comment|/* Write second word of DImode or DFmode reference.  Works on register 	 or non-indexed memory only.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d"
argument_list|,
name|REGNO
argument_list|(
name|x
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
condition|)
block|{
comment|/* Handle possible auto-increment.  Since it is pre-increment and 	     we have already done it, we can just use an offset of four.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PRE_INC
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PRE_DEC
condition|)
name|output_address
argument_list|(
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|output_address
argument_list|(
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
literal|'Y'
case|:
comment|/* Similar, for third word of TImode  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d"
argument_list|,
name|REGNO
argument_list|(
name|x
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PRE_INC
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PRE_DEC
condition|)
name|output_address
argument_list|(
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|8
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|output_address
argument_list|(
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|8
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
literal|'Z'
case|:
comment|/* Similar, for last word of TImode.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d"
argument_list|,
name|REGNO
argument_list|(
name|x
argument_list|)
operator|+
literal|3
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PRE_INC
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PRE_DEC
condition|)
name|output_address
argument_list|(
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|12
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|output_address
argument_list|(
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|12
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
literal|'t'
case|:
comment|/* Write 12 if this jump operation will branch if true, 4 otherwise.  	 All floating-point operations except NE branch true and integer 	 EQ, LT, GT, LTU and GTU also branch true.  */
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
literal|'<'
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%t value"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CCFPmode
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|NE
operator|)
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|EQ
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|LT
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|GT
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|LTU
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|GTU
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"12"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"4"
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'T'
case|:
comment|/* Opposite of 't': write 4 if this jump operation will branch if true, 	 12 otherwise.   */
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
literal|'<'
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%t value"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CCFPmode
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|NE
operator|)
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|EQ
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|LT
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|GT
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|LTU
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|GTU
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"4"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"12"
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'j'
case|:
comment|/* Write the bit number in CCR for jump.  */
name|i
operator|=
name|ccr_bit
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
operator|-
literal|1
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%j code"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'J'
case|:
comment|/* Similar, but add one for shift count in rlinm for scc and pass 	 scc flag to `ccr_bit'.  */
name|i
operator|=
name|ccr_bit
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
operator|-
literal|1
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%J code"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d"
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'C'
case|:
comment|/* This is an optional cror needed for LE or GE floating-point 	 comparisons.  Otherwise write nothing.  */
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|LE
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|GE
operator|)
operator|&&
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CCFPmode
condition|)
block|{
name|int
name|base_bit
init|=
literal|4
operator|*
operator|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|-
literal|68
operator|)
decl_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"cror %d,%d,%d\n\t"
argument_list|,
name|base_bit
operator|+
literal|3
argument_list|,
name|base_bit
operator|+
literal|2
argument_list|,
name|base_bit
operator|+
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|GE
operator|)
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
literal|'D'
case|:
comment|/* Similar, except that this is for an scc, so we must be able to 	 encode the test in a single bit that is one.  We do the above 	 for any LE, GE, GEU, or LEU and invert the bit for NE.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|LE
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|GE
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|LEU
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|GEU
condition|)
block|{
name|int
name|base_bit
init|=
literal|4
operator|*
operator|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|-
literal|68
operator|)
decl_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"cror %d,%d,%d\n\t"
argument_list|,
name|base_bit
operator|+
literal|3
argument_list|,
name|base_bit
operator|+
literal|2
argument_list|,
name|base_bit
operator|+
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|GE
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|GEU
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|NE
condition|)
block|{
name|int
name|base_bit
init|=
literal|4
operator|*
operator|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|-
literal|68
operator|)
decl_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"crnor %d,%d,%d\n\t"
argument_list|,
name|base_bit
operator|+
literal|3
argument_list|,
name|base_bit
operator|+
literal|2
argument_list|,
name|base_bit
operator|+
literal|2
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
literal|'z'
case|:
comment|/* X is a SYMBOL_REF.  Write out the name preceded by a 	 period and without any trailing data in brackets.  Used for function 	 names.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|SYMBOL_REF
condition|)
name|abort
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
name|RS6000_OUTPUT_BASENAME
argument_list|(
name|file
argument_list|,
name|XSTR
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'A'
case|:
comment|/* If X is a constant integer whose low-order 5 bits are zero, 	 write 'l'.  Otherwise, write 'r'.  This is a kludge to fix a bug 	 in the RS/6000 assembler where "sri" with a zero shift count 	 write a trash instruction.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|&
literal|31
operator|)
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"l"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
return|return;
case|case
literal|0
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
condition|)
block|{
comment|/* We need to handle PRE_INC and PRE_DEC here, since we need to 	     know the width from the mode.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PRE_INC
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d(%d)"
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|,
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PRE_DEC
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d(%d)"
argument_list|,
operator|-
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|,
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|output_address
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|x
argument_list|)
expr_stmt|;
break|break;
default|default:
name|output_operand_lossage
argument_list|(
literal|"invalid %%xn code"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print the address of an operand.  */
end_comment

begin_function
name|void
name|print_operand_address
parameter_list|(
name|file
parameter_list|,
name|x
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
specifier|register
name|rtx
name|x
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"0(%d)"
argument_list|,
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SYMBOL_REF
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST
condition|)
block|{
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"(2)"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
if|if
condition|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d,%d"
argument_list|,
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d,%d"
argument_list|,
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d(%d)"
argument_list|,
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This page contains routines that are used to determine what the function    prologue and epilogue code will do and write them out.  */
end_comment

begin_comment
comment|/*  Return the first fixed-point register that is required to be saved. 32 if     none.  */
end_comment

begin_function
name|int
name|first_reg_to_save
parameter_list|()
block|{
name|int
name|first_reg
decl_stmt|;
comment|/* Find lowest numbered live register.  */
for|for
control|(
name|first_reg
operator|=
literal|13
init|;
name|first_reg
operator|<=
literal|31
condition|;
name|first_reg
operator|++
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|first_reg
index|]
condition|)
break|break;
comment|/* If profiling, then we must save/restore every register that contains      a parameter before/after the .mcount call.  Use registers from 30 down      to 23 to do this.  Don't use the frame pointer in reg 31.       For now, save enough room for all of the parameter registers.  */
if|if
condition|(
name|profile_flag
condition|)
if|if
condition|(
name|first_reg
operator|>
literal|23
condition|)
name|first_reg
operator|=
literal|23
expr_stmt|;
return|return
name|first_reg
return|;
block|}
end_function

begin_comment
comment|/* Similar, for FP regs.  */
end_comment

begin_function
name|int
name|first_fp_reg_to_save
parameter_list|()
block|{
name|int
name|first_reg
decl_stmt|;
comment|/* Find lowest numbered live register.  */
for|for
control|(
name|first_reg
operator|=
literal|14
operator|+
literal|32
init|;
name|first_reg
operator|<=
literal|63
condition|;
name|first_reg
operator|++
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|first_reg
index|]
condition|)
break|break;
return|return
name|first_reg
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if we need to save CR.  */
end_comment

begin_function
name|int
name|must_save_cr
parameter_list|()
block|{
return|return
name|regs_ever_live
index|[
literal|70
index|]
operator|||
name|regs_ever_live
index|[
literal|71
index|]
operator|||
name|regs_ever_live
index|[
literal|72
index|]
return|;
block|}
end_function

begin_comment
comment|/* Compute the size of the save area in the stack, including the space for    the fixed area.  */
end_comment

begin_function
name|int
name|rs6000_sa_size
parameter_list|()
block|{
name|int
name|size
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* We have the six fixed words, plus the size of the register save       areas, rounded to a double-word.  */
name|size
operator|=
literal|6
operator|+
operator|(
literal|32
operator|-
name|first_reg_to_save
argument_list|()
operator|)
operator|+
operator|(
literal|64
operator|-
name|first_fp_reg_to_save
argument_list|()
operator|)
operator|*
literal|2
expr_stmt|;
if|if
condition|(
name|size
operator|&
literal|1
condition|)
name|size
operator|++
expr_stmt|;
return|return
name|size
operator|*
literal|4
return|;
block|}
end_function

begin_comment
comment|/* Return non-zero if this function makes calls.  */
end_comment

begin_function
name|int
name|rs6000_makes_calls
parameter_list|()
block|{
name|rtx
name|insn
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|next_insn
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return non-zero if this function needs to push space on the stack.  */
end_comment

begin_function
name|int
name|rs6000_pushes_stack
parameter_list|()
block|{
name|int
name|total_size
init|=
operator|(
name|rs6000_sa_size
argument_list|()
operator|+
name|get_frame_size
argument_list|()
operator|+
name|current_function_outgoing_args_size
operator|)
decl_stmt|;
comment|/* We need to push the stack if a frame pointer is needed (because the      stack might be dynamically adjusted), if we are debugging, if the      total stack size is more than 220 bytes, or if we make calls.  */
return|return
operator|(
name|frame_pointer_needed
operator|||
name|write_symbols
operator|!=
name|NO_DEBUG
operator|||
name|total_size
operator|>
literal|220
operator|||
name|rs6000_makes_calls
argument_list|()
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Write function prologue.  */
end_comment

begin_function
name|void
name|output_prolog
parameter_list|(
name|file
parameter_list|,
name|size
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
name|int
name|first_reg
init|=
name|first_reg_to_save
argument_list|()
decl_stmt|;
name|int
name|must_push
init|=
name|rs6000_pushes_stack
argument_list|()
decl_stmt|;
name|int
name|first_fp_reg
init|=
name|first_fp_reg_to_save
argument_list|()
decl_stmt|;
name|int
name|basic_size
init|=
name|rs6000_sa_size
argument_list|()
decl_stmt|;
name|int
name|total_size
init|=
operator|(
name|basic_size
operator|+
name|size
operator|+
name|current_function_outgoing_args_size
operator|)
decl_stmt|;
comment|/* Round size to multiple of 8 bytes.  */
name|total_size
operator|=
operator|(
name|total_size
operator|+
literal|7
operator|)
operator|&
operator|~
literal|7
expr_stmt|;
comment|/* Write .extern for any function we will call to save and restore fp      values.  */
if|if
condition|(
name|first_fp_reg
operator|<
literal|62
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.extern ._savef%d\n\t.extern ._restf%d\n"
argument_list|,
name|first_fp_reg
operator|-
literal|32
argument_list|,
name|first_fp_reg
operator|-
literal|32
argument_list|)
expr_stmt|;
comment|/* Write .extern for truncation routines, if needed.  */
if|if
condition|(
name|rs6000_trunc_used
operator|&&
operator|!
name|trunc_defined
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.extern .itrunc\n\t.extern .uitrunc\n"
argument_list|)
expr_stmt|;
name|trunc_defined
operator|=
literal|1
expr_stmt|;
block|}
comment|/* If we have to call a function to save fpr's, or if we are doing profiling,      then we will be using LR.  */
if|if
condition|(
name|first_fp_reg
operator|<
literal|62
operator|||
name|profile_flag
condition|)
name|regs_ever_live
index|[
literal|65
index|]
operator|=
literal|1
expr_stmt|;
comment|/* If we use the link register, get it into r0.  */
if|if
condition|(
name|regs_ever_live
index|[
literal|65
index|]
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tmflr 0\n"
argument_list|)
expr_stmt|;
comment|/* If we need to save CR, put it into r12.  */
if|if
condition|(
name|must_save_cr
argument_list|()
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tmfcr 12\n"
argument_list|)
expr_stmt|;
comment|/* Do any required saving of fpr's.  If only one or two to save, do it      ourself.  Otherwise, call function.  */
if|if
condition|(
name|first_fp_reg
operator|==
literal|62
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tstfd 30,-16(1)\n\tstfd 31,-8(1)\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|first_fp_reg
operator|==
literal|63
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tstfd 31,-8(1)\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|first_fp_reg
operator|!=
literal|64
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tbl ._savef%d\n\tcror 15,15,15\n"
argument_list|,
name|first_fp_reg
operator|-
literal|32
argument_list|)
expr_stmt|;
comment|/* Now save gpr's.  */
if|if
condition|(
name|first_reg
operator|==
literal|31
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tst 31,%d(1)\n"
argument_list|,
operator|-
literal|4
operator|-
operator|(
literal|64
operator|-
name|first_fp_reg
operator|)
operator|*
literal|8
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|first_reg
operator|!=
literal|32
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tstm %d,%d(1)\n"
argument_list|,
name|first_reg
argument_list|,
operator|-
operator|(
literal|32
operator|-
name|first_reg
operator|)
operator|*
literal|4
operator|-
operator|(
literal|64
operator|-
name|first_fp_reg
operator|)
operator|*
literal|8
argument_list|)
expr_stmt|;
comment|/* Save lr if we used it.  */
if|if
condition|(
name|regs_ever_live
index|[
literal|65
index|]
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tst 0,8(1)\n"
argument_list|)
expr_stmt|;
comment|/* Save CR if we use any that must be preserved.  */
if|if
condition|(
name|must_save_cr
argument_list|()
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tst 12,4(1)\n"
argument_list|)
expr_stmt|;
comment|/* Update stack and set back pointer.  */
if|if
condition|(
name|must_push
condition|)
block|{
if|if
condition|(
name|total_size
operator|<
literal|32767
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tstu 1,%d(1)\n"
argument_list|,
operator|-
name|total_size
argument_list|)
expr_stmt|;
else|else
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tcau 0,0,%d\n\toril 0,0,%d\n"
argument_list|,
operator|(
name|total_size
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
argument_list|,
name|total_size
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tsf 12,0,1\n\tst 1,0(12)\n\toril 1,12,0\n"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Set frame pointer, if needed.  */
if|if
condition|(
name|frame_pointer_needed
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\toril 31,1,0\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Write function epilogue.  */
end_comment

begin_function
name|void
name|output_epilog
parameter_list|(
name|file
parameter_list|,
name|size
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
name|int
name|first_reg
init|=
name|first_reg_to_save
argument_list|()
decl_stmt|;
name|int
name|must_push
init|=
name|rs6000_pushes_stack
argument_list|()
decl_stmt|;
name|int
name|first_fp_reg
init|=
name|first_fp_reg_to_save
argument_list|()
decl_stmt|;
name|int
name|basic_size
init|=
name|rs6000_sa_size
argument_list|()
decl_stmt|;
name|int
name|total_size
init|=
operator|(
name|basic_size
operator|+
name|size
operator|+
name|current_function_outgoing_args_size
operator|)
decl_stmt|;
name|rtx
name|insn
init|=
name|get_last_insn
argument_list|()
decl_stmt|;
comment|/* Round size to multiple of 8 bytes.  */
name|total_size
operator|=
operator|(
name|total_size
operator|+
literal|7
operator|)
operator|&
operator|~
literal|7
expr_stmt|;
comment|/* If the last insn was a BARRIER, we don't have to write anything except      the trace table.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
condition|)
name|insn
operator|=
name|prev_nonnote_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
operator|==
literal|0
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|BARRIER
condition|)
block|{
comment|/* If we have a frame pointer, a call to alloca,  or a large stack 	 frame, restore the old stack pointer using the backchain.  Otherwise, 	 we know what size to update it with.  */
if|if
condition|(
name|frame_pointer_needed
operator|||
name|current_function_calls_alloca
operator|||
name|total_size
operator|>
literal|32767
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tl 1,0(1)\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|must_push
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tai 1,1,%d\n"
argument_list|,
name|total_size
argument_list|)
expr_stmt|;
comment|/* Get the old lr if we saved it.  */
if|if
condition|(
name|regs_ever_live
index|[
literal|65
index|]
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tl 0,8(1)\n"
argument_list|)
expr_stmt|;
comment|/* Get the old cr if we saved it.  */
if|if
condition|(
name|must_save_cr
argument_list|()
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tl 12,4(1)\n"
argument_list|)
expr_stmt|;
comment|/* Set LR here to try to overlap restores below.  */
if|if
condition|(
name|regs_ever_live
index|[
literal|65
index|]
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tmtlr 0\n"
argument_list|)
expr_stmt|;
comment|/* Restore gpr's.  */
if|if
condition|(
name|first_reg
operator|==
literal|31
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tl 31,%d(1)\n"
argument_list|,
operator|-
literal|4
operator|-
operator|(
literal|64
operator|-
name|first_fp_reg
operator|)
operator|*
literal|8
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|first_reg
operator|!=
literal|32
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tlm %d,%d(1)\n"
argument_list|,
name|first_reg
argument_list|,
operator|-
operator|(
literal|32
operator|-
name|first_reg
operator|)
operator|*
literal|4
operator|-
operator|(
literal|64
operator|-
name|first_fp_reg
operator|)
operator|*
literal|8
argument_list|)
expr_stmt|;
comment|/* Restore fpr's if we can do it without calling a function.  */
if|if
condition|(
name|first_fp_reg
operator|==
literal|62
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tlfd 30,-16(1)\n\tlfd 31,-8(1)\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|first_fp_reg
operator|==
literal|63
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tlfd 31,-8(1)\n"
argument_list|)
expr_stmt|;
comment|/* If we saved cr, restore it here.  Just set cr2, cr3, and cr4.  */
if|if
condition|(
name|must_save_cr
argument_list|()
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tmtcrf 0x38,12\n"
argument_list|)
expr_stmt|;
comment|/* If we have to restore more than two FP registers, branch to the 	 restore function.  It will return to our caller.  */
if|if
condition|(
name|first_fp_reg
operator|<
literal|62
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tb ._restf%d\n\tcror 15,15,15\n"
argument_list|,
name|first_fp_reg
operator|-
literal|32
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tbr\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Output a traceback table here.  See /usr/include/sys/debug.h for info      on its format.  */
block|{
name|char
modifier|*
name|fname
init|=
name|XSTR
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|current_function_decl
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|int
name|fixed_parms
decl_stmt|,
name|float_parms
decl_stmt|,
name|parm_info
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Need label immediately before tbtab, so we can compute its offset        from the function start.  */
if|if
condition|(
operator|*
name|fname
operator|==
literal|'*'
condition|)
operator|++
name|fname
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"LT.."
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|file
argument_list|,
name|fname
argument_list|)
expr_stmt|;
comment|/* The .tbtab pseudo-op can only be used for the first eight        expressions, since it can't handle the possibly variable length        fields that follow.  However, if you omit the optional fields,        the assembler outputs zeros for all optional fields anyways, giving each        variable length field is minimum length (as defined in sys/debug.h).        Thus we can not use the .tbtab pseudo-op at all.  */
comment|/* An all-zero word flags the start of the tbtab, for debuggers that have        to find it by searching forward from the entry point or from the        current pc.  */
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.long 0\n"
argument_list|)
expr_stmt|;
comment|/* Tbtab format type.  Use format type 0.  */
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.byte 0,"
argument_list|)
expr_stmt|;
comment|/* Language type.  Unfortunately, there doesn't seem to be any official way        to get this info, so we use language_string.  C is 0.  C++ is 9.        No number defined for Obj-C, but it doesn't have its own        language_string, so we can't detect it anyways.  */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|language_string
argument_list|,
literal|"GNU C"
argument_list|)
condition|)
name|i
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|language_string
argument_list|,
literal|"GNU F77"
argument_list|)
condition|)
name|i
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|language_string
argument_list|,
literal|"GNU Ada"
argument_list|)
condition|)
name|i
operator|=
literal|3
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|language_string
argument_list|,
literal|"GNU PASCAL"
argument_list|)
condition|)
name|i
operator|=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|language_string
argument_list|,
literal|"GNU C++"
argument_list|)
condition|)
name|i
operator|=
literal|9
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d,"
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* 8 single bit fields: global linkage (not set for C extern linkage,        apparently a PL/I convention?), out-of-line epilogue/prologue, offset        from start of procedure stored in tbtab, internal function, function        has controlled storage, function has no toc, function uses fp,        function logs/aborts fp operations.  */
comment|/* Assume that fp operations are used if any fp reg must be saved.  */
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d,"
argument_list|,
operator|(
literal|1
operator|<<
literal|5
operator|)
operator||
operator|(
operator|(
name|first_fp_reg
operator|!=
literal|64
operator|)
operator|<<
literal|1
operator|)
argument_list|)
expr_stmt|;
comment|/* 6 bitfields: function is interrupt handler, name present in proc table,        function calls alloca, on condition directives (controls stack walks,        3 bits), saves condition reg, saves link reg.  */
comment|/* The `function calls alloca' bit seems to be set whenever reg 31 is        set up as a frame pointer, even when there is no alloca call.  */
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d,"
argument_list|,
operator|(
operator|(
literal|1
operator|<<
literal|6
operator|)
operator||
operator|(
name|frame_pointer_needed
operator|<<
literal|5
operator|)
operator||
operator|(
name|must_save_cr
argument_list|()
operator|<<
literal|1
operator|)
operator||
operator|(
name|regs_ever_live
index|[
literal|65
index|]
operator|)
operator|)
argument_list|)
expr_stmt|;
comment|/* 3 bitfields: saves backchain, spare bit, number of fpr saved        (6 bits).  */
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d,"
argument_list|,
operator|(
name|must_push
operator|<<
literal|7
operator|)
operator||
operator|(
literal|64
operator|-
name|first_fp_reg_to_save
argument_list|()
operator|)
argument_list|)
expr_stmt|;
comment|/* 2 bitfields: spare bits (2 bits), number of gpr saved (6 bits).  */
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d,"
argument_list|,
operator|(
literal|32
operator|-
name|first_reg_to_save
argument_list|()
operator|)
argument_list|)
expr_stmt|;
block|{
comment|/* Compute the parameter info from the function decl argument list.  */
name|tree
name|decl
decl_stmt|;
name|int
name|next_parm_info_bit
decl_stmt|;
name|next_parm_info_bit
operator|=
literal|31
expr_stmt|;
name|parm_info
operator|=
literal|0
expr_stmt|;
name|fixed_parms
operator|=
literal|0
expr_stmt|;
name|float_parms
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|decl
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|current_function_decl
argument_list|)
init|;
name|decl
condition|;
name|decl
operator|=
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
control|)
block|{
name|rtx
name|parameter
init|=
name|DECL_INCOMING_RTL
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|parameter
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|parameter
argument_list|)
operator|==
name|REG
condition|)
block|{
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_FLOAT
condition|)
block|{
name|int
name|bits
decl_stmt|;
name|float_parms
operator|++
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|SFmode
condition|)
name|bits
operator|=
literal|0x2
expr_stmt|;
elseif|else
if|if
condition|(
name|mode
operator|==
name|DFmode
condition|)
name|bits
operator|=
literal|0x3
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
comment|/* If only one bit will fit, don't or in this entry.  */
if|if
condition|(
name|next_parm_info_bit
operator|>
literal|0
condition|)
name|parm_info
operator||=
operator|(
name|bits
operator|<<
operator|(
name|next_parm_info_bit
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
name|next_parm_info_bit
operator|-=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|fixed_parms
operator|+=
operator|(
operator|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|+
operator|(
name|UNITS_PER_WORD
operator|-
literal|1
operator|)
operator|)
operator|/
name|UNITS_PER_WORD
operator|)
expr_stmt|;
name|next_parm_info_bit
operator|-=
literal|1
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* Number of fixed point parameters.  */
comment|/* This is actually the number of words of fixed point parameters; thus        an 8 byte struct counts as 2; and thus the maximum value is 8.  */
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d,"
argument_list|,
name|fixed_parms
argument_list|)
expr_stmt|;
comment|/* 2 bitfields: number of floating point parameters (7 bits), parameters        all on stack.  */
comment|/* This is actually the number of fp registers that hold parameters;        and thus the maximum value is 13.  */
comment|/* Set parameters on stack bit if parameters are not in their original        registers, regardless of whether they are on the stack?  Xlc        seems to set the bit when not optimizing.  */
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d\n"
argument_list|,
operator|(
operator|(
name|float_parms
operator|<<
literal|1
operator|)
operator||
operator|(
operator|!
name|optimize
operator|)
operator|)
argument_list|)
expr_stmt|;
comment|/* Optional fields follow.  Some are variable length.  */
comment|/* Parameter types, left adjusted bit fields: 0 fixed, 10 single float,        11 double float.  */
comment|/* There is an entry for each parameter in a register, in the order that        they occur in the parameter list.  Any intervening arguments on the        stack are ignored.  If the list overflows a long (max possible length        34 bits) then completely leave off all elements that don't fit.  */
comment|/* Only emit this long if there was at least one parameter.  */
if|if
condition|(
name|fixed_parms
operator|||
name|float_parms
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.long %d\n"
argument_list|,
name|parm_info
argument_list|)
expr_stmt|;
comment|/* Offset from start of code to tb table.  */
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.long LT.."
argument_list|)
expr_stmt|;
name|RS6000_OUTPUT_BASENAME
argument_list|(
name|file
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"-."
argument_list|)
expr_stmt|;
name|RS6000_OUTPUT_BASENAME
argument_list|(
name|file
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* Interrupt handler mask.  */
comment|/* Omit this long, since we never set the interrupt handler bit above.  */
comment|/* Number of CTL (controlled storage) anchors.  */
comment|/* Omit this long, since the has_ctl bit is never set above.  */
comment|/* Displacement into stack of each CTL anchor.  */
comment|/* Omit this list of longs, because there are no CTL anchors.  */
comment|/* Length of function name.  */
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.short %d\n"
argument_list|,
name|strlen
argument_list|(
name|fname
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Function name.  */
name|assemble_string
argument_list|(
name|fname
argument_list|,
name|strlen
argument_list|(
name|fname
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Register for alloca automatic storage; this is always reg 31.        Only emit this if the alloca bit was set above.  */
if|if
condition|(
name|frame_pointer_needed
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.byte 31\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output a TOC entry.  We derive the entry name from what is    being written.  */
end_comment

begin_function
name|void
name|output_toc
parameter_list|(
name|file
parameter_list|,
name|x
parameter_list|,
name|labelno
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|int
name|labelno
decl_stmt|;
block|{
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
name|char
modifier|*
name|name
init|=
name|buf
decl_stmt|;
name|rtx
name|base
init|=
name|x
decl_stmt|;
name|int
name|offset
init|=
literal|0
decl_stmt|;
name|ASM_OUTPUT_INTERNAL_LABEL
argument_list|(
name|file
argument_list|,
literal|"LC"
argument_list|,
name|labelno
argument_list|)
expr_stmt|;
comment|/* Handle FP constants specially.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|DFmode
operator|&&
name|TARGET_FLOAT_FORMAT
operator|==
name|HOST_FLOAT_FORMAT
operator|&&
name|BITS_PER_WORD
operator|==
name|HOST_BITS_PER_INT
operator|&&
name|TARGET_FP_IN_TOC
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.tc FD_%x_%x[TC],%d,%d\n"
argument_list|,
name|CONST_DOUBLE_LOW
argument_list|(
name|x
argument_list|)
argument_list|,
name|CONST_DOUBLE_HIGH
argument_list|(
name|x
argument_list|)
argument_list|,
name|CONST_DOUBLE_LOW
argument_list|(
name|x
argument_list|)
argument_list|,
name|CONST_DOUBLE_HIGH
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|SFmode
operator|&&
name|TARGET_FP_IN_TOC
condition|)
block|{
name|rtx
name|val
init|=
name|operand_subword
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|SFmode
argument_list|)
decl_stmt|;
if|if
condition|(
name|val
operator|==
literal|0
operator|||
name|GET_CODE
argument_list|(
name|val
argument_list|)
operator|!=
name|CONST_INT
condition|)
name|abort
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.tc FS_%x[TC],%d\n"
argument_list|,
name|INTVAL
argument_list|(
name|val
argument_list|)
argument_list|,
name|INTVAL
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST
condition|)
block|{
name|base
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|offset
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|base
argument_list|)
operator|==
name|SYMBOL_REF
condition|)
name|name
operator|=
name|XSTR
argument_list|(
name|base
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|base
argument_list|)
operator|==
name|LABEL_REF
condition|)
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|buf
argument_list|,
literal|"L"
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|XEXP
argument_list|(
name|base
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|base
argument_list|)
operator|==
name|CODE_LABEL
condition|)
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|buf
argument_list|,
literal|"L"
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|base
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.tc "
argument_list|)
expr_stmt|;
name|RS6000_OUTPUT_BASENAME
argument_list|(
name|file
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|<
literal|0
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|".N%d"
argument_list|,
operator|-
name|offset
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|offset
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|".P%d"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"[TC],"
argument_list|)
expr_stmt|;
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output an assembler pseudo-op to write an ASCII string of N characters    starting at P to FILE.     On the RS/6000, we have to do this using the .byte operation and    write out special characters outside the quoted string.    Also, the assembler is broken; very long strings are truncated,    so we must artificially break them up early. */
end_comment

begin_function
name|void
name|output_ascii
parameter_list|(
name|file
parameter_list|,
name|p
parameter_list|,
name|n
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|n
decl_stmt|;
block|{
name|char
name|c
decl_stmt|;
name|int
name|i
decl_stmt|,
name|count_string
decl_stmt|;
name|char
modifier|*
name|for_string
init|=
literal|"\t.byte \""
decl_stmt|;
name|char
modifier|*
name|for_decimal
init|=
literal|"\t.byte "
decl_stmt|;
name|char
modifier|*
name|to_close
init|=
name|NULL
decl_stmt|;
name|count_string
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|c
operator|=
operator|*
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|>=
literal|' '
operator|&&
name|c
operator|<
literal|0177
condition|)
block|{
if|if
condition|(
name|for_string
condition|)
name|fputs
argument_list|(
name|for_string
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|putc
argument_list|(
name|c
argument_list|,
name|file
argument_list|)
expr_stmt|;
comment|/* Write two quotes to get one.  */
if|if
condition|(
name|c
operator|==
literal|'"'
condition|)
block|{
name|putc
argument_list|(
name|c
argument_list|,
name|file
argument_list|)
expr_stmt|;
operator|++
name|count_string
expr_stmt|;
block|}
name|for_string
operator|=
name|NULL
expr_stmt|;
name|for_decimal
operator|=
literal|"\"\n\t.byte "
expr_stmt|;
name|to_close
operator|=
literal|"\"\n"
expr_stmt|;
operator|++
name|count_string
expr_stmt|;
if|if
condition|(
name|count_string
operator|>=
literal|512
condition|)
block|{
name|fputs
argument_list|(
name|to_close
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|for_string
operator|=
literal|"\t.byte \""
expr_stmt|;
name|for_decimal
operator|=
literal|"\t.byte "
expr_stmt|;
name|to_close
operator|=
name|NULL
expr_stmt|;
name|count_string
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|for_decimal
condition|)
name|fputs
argument_list|(
name|for_decimal
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d"
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|for_string
operator|=
literal|"\n\t.byte \""
expr_stmt|;
name|for_decimal
operator|=
literal|", "
expr_stmt|;
name|to_close
operator|=
literal|"\n"
expr_stmt|;
name|count_string
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* Now close the string if we have written one.  Then end the line.  */
if|if
condition|(
name|to_close
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|to_close
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generate a unique section name for FILENAME for a section type    represented by SECTION_DESC.  Output goes into BUF.     SECTION_DESC can be any string, as long as it is different for each    possible section type.     We name the section in the same manner as xlc.  The name begins with an    underscore followed by the filename (after stripping any leading directory    names) with the period replaced by the string SECTION_DESC.  If FILENAME    does not contain a period, SECTION_DESC is appended at the end of the    name.  */
end_comment

begin_function
name|void
name|rs6000_gen_section_name
parameter_list|(
name|buf
parameter_list|,
name|filename
parameter_list|,
name|section_desc
parameter_list|)
name|char
modifier|*
modifier|*
name|buf
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
name|char
modifier|*
name|section_desc
decl_stmt|;
block|{
name|char
modifier|*
name|q
decl_stmt|,
modifier|*
name|after_last_slash
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|used_desc
init|=
literal|0
decl_stmt|;
name|after_last_slash
operator|=
name|filename
expr_stmt|;
for|for
control|(
name|q
operator|=
name|filename
init|;
operator|*
name|q
condition|;
name|q
operator|++
control|)
if|if
condition|(
operator|*
name|q
operator|==
literal|'/'
condition|)
name|after_last_slash
operator|=
name|q
operator|+
literal|1
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|filename
argument_list|)
operator|+
name|strlen
argument_list|(
name|section_desc
argument_list|)
operator|+
literal|2
expr_stmt|;
operator|*
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|permalloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|p
operator|=
operator|*
name|buf
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'_'
expr_stmt|;
for|for
control|(
name|q
operator|=
name|after_last_slash
init|;
operator|*
name|q
condition|;
name|q
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|q
operator|==
literal|'.'
condition|)
block|{
name|strcpy
argument_list|(
name|p
argument_list|,
name|section_desc
argument_list|)
expr_stmt|;
name|p
operator|+=
name|strlen
argument_list|(
name|section_desc
argument_list|)
expr_stmt|;
name|used_desc
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isalnum
argument_list|(
operator|*
name|q
argument_list|)
condition|)
operator|*
name|p
operator|++
operator|=
operator|*
name|q
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|used_desc
condition|)
name|strcpy
argument_list|(
name|p
argument_list|,
name|section_desc
argument_list|)
expr_stmt|;
else|else
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Write function profiler code. */
end_comment

begin_function
name|void
name|output_function_profiler
parameter_list|(
name|file
parameter_list|,
name|labelno
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|int
name|labelno
decl_stmt|;
block|{
comment|/* The last used parameter register.  */
name|int
name|last_parm_reg
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
comment|/* Set up a TOC entry for the profiler label.  */
name|toc_section
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"LPC..%d:\n\t.tc\tLP..%d[TC],LP..%d\n"
argument_list|,
name|labelno
argument_list|,
name|labelno
argument_list|,
name|labelno
argument_list|)
expr_stmt|;
name|text_section
argument_list|()
expr_stmt|;
comment|/* Figure out last used parameter register.  The proper thing to do is      to walk incoming args of the function.  A function might have live      parameter registers even if it has no incoming args.  */
for|for
control|(
name|last_parm_reg
operator|=
literal|10
init|;
name|last_parm_reg
operator|>
literal|2
operator|&&
operator|!
name|regs_ever_live
index|[
name|last_parm_reg
index|]
condition|;
name|last_parm_reg
operator|--
control|)
empty_stmt|;
comment|/* Save parameter registers in regs 23-30.  Don't overwrite reg 31, since      it might be set up as the frame pointer.  */
for|for
control|(
name|i
operator|=
literal|3
operator|,
name|j
operator|=
literal|30
init|;
name|i
operator|<=
name|last_parm_reg
condition|;
name|i
operator|++
operator|,
name|j
operator|--
control|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tai %d,%d,0\n"
argument_list|,
name|j
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* Load location address into r3, and call mcount.  */
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tl 3,LPC..%d(2)\n\tbl .mcount\n"
argument_list|,
name|labelno
argument_list|)
expr_stmt|;
comment|/* Restore parameter registers.  */
for|for
control|(
name|i
operator|=
literal|3
operator|,
name|j
operator|=
literal|30
init|;
name|i
operator|<=
name|last_parm_reg
condition|;
name|i
operator|++
operator|,
name|j
operator|--
control|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tai %d,%d,0\n"
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

