begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Subroutines used for code generation on intel 80960.    Copyright (C) 1992 Free Software Foundation, Inc.    Contributed by Steven McGeady, Intel Corp.    Additional Work by Glenn Colon-Bonet, Jonathan Shapiro, Andy Wilson    Converted to GCC 2.0 by Jim Wilson and Michael Tiemann, Cygnus Support.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"conditions.h"
end_include

begin_include
include|#
directive|include
file|"insn-flags.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"insn-attr.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"insn-codes.h"
end_include

begin_include
include|#
directive|include
file|"assert.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|<math.h>
end_include

begin_comment
comment|/* Save the operands last given to a compare for use when we    generate a scc or bcc insn.  */
end_comment

begin_decl_stmt
name|rtx
name|i960_compare_op0
decl_stmt|,
name|i960_compare_op1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Used to implement #pragma align/noalign.  Initialized by OVERRIDE_OPTIONS    macro in i960.h.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|i960_maxbitalignment
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|i960_last_maxbitalignment
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Used to implement switching between MEM and ALU insn types, for better    C series performance.  */
end_comment

begin_decl_stmt
name|enum
name|insn_types
name|i960_last_insn_type
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The leaf-procedure return register.  Set only if this is a leaf routine.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|i960_leaf_ret_reg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* True if replacing tail calls with jumps is OK.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|tail_call_ok
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A string containing a list of insns to emit in the epilogue so as to    restore all registers saved by the prologue.  Created by the prologue    code as it saves registers away.  */
end_comment

begin_decl_stmt
name|char
name|epilogue_string
index|[
literal|1000
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A unique number (per function) for return labels.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ret_label
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Handle pragmas for compatibility with Intel's compilers.  */
end_comment

begin_comment
comment|/* ??? This is incomplete, since it does not handle all pragmas that the    intel compilers understand.  Also, it needs to be rewritten to accept    a stream instead of a string for GCC 2.  */
end_comment

begin_comment
unit|void process_pragma(str)      char  *str; {   int align;   int i;    if ((i = sscanf (str, " align %d",&align)) == 1)     switch (align)       {       case 0:
comment|/* Return to last alignment.  */
end_comment

begin_comment
unit|align = i960_last_maxbitalignment / 8;        case 16:
comment|/* Byte alignments. */
end_comment

begin_comment
unit|case 8:       case 4:       case 2:       case 1:         i960_last_maxbitalignment = i960_maxbitalignment;         i960_maxbitalignment = align * 8;         break;        default:
comment|/* Unknown, silently ignore.  */
end_comment

begin_comment
unit|break;       }
comment|/* NOTE: ic960 R3.0 pragma align definition:       #pragma align [(size)] | (identifier=size[,...])      #pragma noalign [(identifier)[,...]]       (all parens are optional)       - size is [1,2,4,8,16]      - noalign means size==1      - applies only to component elements of a struct (and union?)      - identifier applies to structure tag (only)      - missing identifier means next struct       - alignment rules for bitfields need more investigation  */
end_comment

begin_comment
comment|/* Should be pragma 'far' or equivalent for callx/balx here.  */
end_comment

begin_endif
unit|}
endif|#
directive|endif
end_endif

begin_comment
comment|/* Initialize variables before compiling any files.  */
end_comment

begin_function
name|void
name|i960_initialize
parameter_list|()
block|{
if|if
condition|(
name|TARGET_IC_COMPAT2_0
condition|)
block|{
name|i960_maxbitalignment
operator|=
literal|8
expr_stmt|;
name|i960_last_maxbitalignment
operator|=
literal|128
expr_stmt|;
block|}
else|else
block|{
name|i960_maxbitalignment
operator|=
literal|128
expr_stmt|;
name|i960_last_maxbitalignment
operator|=
literal|8
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return true if OP can be used as the source of an fp move insn.  */
end_comment

begin_function
name|int
name|fpmove_src_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
operator|||
name|general_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Return true if OP is a register or zero.  */
end_comment

begin_endif
unit|int reg_or_zero_operand (op, mode)      rtx op;      enum machine_mode mode; {   return register_operand (op, mode) || op == const0_rtx; }
endif|#
directive|endif
end_endif

begin_comment
comment|/* Return truth value of whether OP can be used as an operands in a three    address arithmetic insn (such as add %o1,7,%l2) of mode MODE.  */
end_comment

begin_function
name|int
name|arith_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|||
name|literal
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if OP is a register or a valid floating point literal.  */
end_comment

begin_function
name|int
name|fp_arith_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|||
name|fp_literal
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return true is OP is a register or a valid signed integer literal.  */
end_comment

begin_function
name|int
name|signed_arith_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|||
name|signed_literal
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return truth value of whether OP is a integer which fits the    range constraining immediate operands in three-address insns.  */
end_comment

begin_function
name|int
name|literal
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|)
operator|&&
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|>=
literal|0
operator|&&
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|<
literal|32
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if OP is a float constant of 1.  */
end_comment

begin_function
name|int
name|fp_literal_one
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|TARGET_NUMERICS
operator|&&
operator|(
name|mode
operator|==
name|VOIDmode
operator|||
name|mode
operator|==
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|)
operator|&&
operator|(
name|op
operator|==
name|CONST1_RTX
argument_list|(
name|mode
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if OP is a float constant of 0.  */
end_comment

begin_function
name|int
name|fp_literal_zero
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|TARGET_NUMERICS
operator|&&
operator|(
name|mode
operator|==
name|VOIDmode
operator|||
name|mode
operator|==
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|)
operator|&&
operator|(
name|op
operator|==
name|CONST0_RTX
argument_list|(
name|mode
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if OP is a valid floating point literal.  */
end_comment

begin_function
name|int
name|fp_literal
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
name|fp_literal_zero
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|||
name|fp_literal_one
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if OP is a valid signed immediate constant.  */
end_comment

begin_function
name|int
name|signed_literal
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|)
operator|&&
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|>
operator|-
literal|32
operator|&&
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|<
literal|32
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return truth value of statement that OP is a symbolic memory    operand of mode MODE.  */
end_comment

begin_function
name|int
name|symbolic_memory_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
condition|)
name|op
operator|=
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|MEM
condition|)
return|return
literal|0
return|;
name|op
operator|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SYMBOL_REF
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|HIGH
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|LABEL_REF
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return truth value of whether OP is EQ or NE.  */
end_comment

begin_function
name|int
name|eq_or_neq
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|EQ
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|NE
operator|)
return|;
block|}
end_function

begin_comment
comment|/* OP is an integer register or a constant.  */
end_comment

begin_function
name|int
name|arith32_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
operator|(
name|CONSTANT_P
argument_list|(
name|op
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if OP is an integer constant which is a power of 2.  */
end_comment

begin_function
name|int
name|power2_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|CONST_INT
condition|)
return|return
literal|0
return|;
return|return
name|exact_log2
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|)
operator|>=
literal|0
return|;
block|}
end_function

begin_comment
comment|/* If VAL has only one bit set, return the index of that bit.  Otherwise    return -1.  */
end_comment

begin_function
name|int
name|bitpos
parameter_list|(
name|val
parameter_list|)
name|unsigned
name|int
name|val
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|val
operator|!=
literal|0
condition|;
name|i
operator|++
operator|,
name|val
operator|>>=
literal|1
control|)
block|{
if|if
condition|(
name|val
operator|&
literal|1
condition|)
block|{
if|if
condition|(
name|val
operator|!=
literal|1
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|i
return|;
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return non-zero if OP is a mask, i.e. all one bits are consecutive.    The return value indicates how many consecutive non-zero bits exist    if this is a mask.  This is the same as the next function, except that    it does not indicate what the start and stop bit positions are.  */
end_comment

begin_function
name|int
name|is_mask
parameter_list|(
name|val
parameter_list|)
name|unsigned
name|int
name|val
decl_stmt|;
block|{
specifier|register
name|int
name|start
decl_stmt|,
name|end
decl_stmt|,
name|i
decl_stmt|;
name|start
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|val
operator|!=
literal|0
condition|;
name|val
operator|>>=
literal|1
operator|,
name|i
operator|++
control|)
block|{
if|if
condition|(
name|val
operator|&
literal|1
condition|)
block|{
if|if
condition|(
name|start
operator|<
literal|0
condition|)
name|start
operator|=
name|i
expr_stmt|;
name|end
operator|=
name|i
expr_stmt|;
continue|continue;
block|}
comment|/* Still looking for the first bit.  */
if|if
condition|(
name|start
operator|<
literal|0
condition|)
continue|continue;
comment|/* We've seen the start of a bit sequence, and now a zero.  There 	 must be more one bits, otherwise we would have exited the loop. 	 Therefore, it is not a mask.  */
if|if
condition|(
name|val
condition|)
return|return
literal|0
return|;
block|}
comment|/* The bit string has ones from START to END bit positions only.  */
return|return
name|end
operator|-
name|start
operator|+
literal|1
return|;
block|}
end_function

begin_comment
comment|/* If VAL is a mask, then return nonzero, with S set to the starting bit    position and E set to the ending bit position of the mask.  The return    value indicates how many consecutive bits exist in the mask.  This is    the same as the previous function, except that it also indicates the    start and end bit positions of the mask.  */
end_comment

begin_function
name|int
name|bitstr
parameter_list|(
name|val
parameter_list|,
name|s
parameter_list|,
name|e
parameter_list|)
name|unsigned
name|int
name|val
decl_stmt|;
name|int
modifier|*
name|s
decl_stmt|,
decl|*
name|e
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|int
name|start
decl_stmt|,
name|end
decl_stmt|,
name|i
decl_stmt|;
name|start
operator|=
operator|-
literal|1
expr_stmt|;
name|end
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|val
operator|!=
literal|0
condition|;
name|val
operator|>>=
literal|1
operator|,
name|i
operator|++
control|)
block|{
if|if
condition|(
name|val
operator|&
literal|1
condition|)
block|{
if|if
condition|(
name|start
operator|<
literal|0
condition|)
name|start
operator|=
name|i
expr_stmt|;
name|end
operator|=
name|i
expr_stmt|;
continue|continue;
block|}
comment|/* Still looking for the first bit.  */
if|if
condition|(
name|start
operator|<
literal|0
condition|)
continue|continue;
comment|/* We've seen the start of a bit sequence, and now a zero.  There 	 must be more one bits, otherwise we would have exited the loop. 	 Therefor, it is not a mask.  */
if|if
condition|(
name|val
condition|)
block|{
name|start
operator|=
operator|-
literal|1
expr_stmt|;
name|end
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
block|}
comment|/* The bit string has ones from START to END bit positions only.  */
operator|*
name|s
operator|=
name|start
expr_stmt|;
operator|*
name|e
operator|=
name|end
expr_stmt|;
return|return
operator|(
operator|(
name|start
operator|<
literal|0
operator|)
condition|?
literal|0
else|:
name|end
operator|-
name|start
operator|+
literal|1
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Return the machine mode to use for a comparison.  */
end_comment

begin_function
name|enum
name|machine_mode
name|select_cc_mode
parameter_list|(
name|op
parameter_list|,
name|x
parameter_list|)
name|RTX_CODE
name|op
decl_stmt|;
name|rtx
name|x
decl_stmt|;
block|{
if|if
condition|(
name|op
operator|==
name|GTU
operator|||
name|op
operator|==
name|LTU
operator|||
name|op
operator|==
name|GEU
operator|||
name|op
operator|==
name|LEU
condition|)
return|return
name|CC_UNSmode
return|;
return|return
name|CCmode
return|;
block|}
end_function

begin_comment
comment|/* X and Y are two things to compare using CODE.  Emit the compare insn and    return the rtx for register 36 in the proper mode.  */
end_comment

begin_function
name|rtx
name|gen_compare_reg
parameter_list|(
name|code
parameter_list|,
name|x
parameter_list|,
name|y
parameter_list|)
name|enum
name|rtx_code
name|code
decl_stmt|;
name|rtx
name|x
decl_stmt|,
name|y
decl_stmt|;
block|{
name|rtx
name|cc_reg
decl_stmt|;
name|enum
name|machine_mode
name|ccmode
init|=
name|SELECT_CC_MODE
argument_list|(
name|code
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|VOIDmode
condition|?
name|GET_MODE
argument_list|(
name|y
argument_list|)
else|:
name|GET_MODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|mode
operator|==
name|SImode
condition|)
block|{
if|if
condition|(
operator|!
name|arith_operand
argument_list|(
name|x
argument_list|,
name|mode
argument_list|)
condition|)
name|x
operator|=
name|force_reg
argument_list|(
name|SImode
argument_list|,
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|arith_operand
argument_list|(
name|y
argument_list|,
name|mode
argument_list|)
condition|)
name|y
operator|=
name|force_reg
argument_list|(
name|SImode
argument_list|,
name|y
argument_list|)
expr_stmt|;
block|}
name|cc_reg
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|ccmode
argument_list|,
literal|36
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx
argument_list|(
name|SET
argument_list|,
name|VOIDmode
argument_list|,
name|cc_reg
argument_list|,
name|gen_rtx
argument_list|(
name|COMPARE
argument_list|,
name|ccmode
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|cc_reg
return|;
block|}
end_function

begin_comment
comment|/* For the i960, REG is cost 1, REG+immed CONST is cost 2, REG+REG is cost 2,    REG+nonimmed CONST is cost 4.  REG+SYMBOL_REF, SYMBOL_REF, and similar    are 4.  Indexed addresses are cost 6.  */
end_comment

begin_comment
comment|/* ??? Try using just RTX_COST, i.e. not defining ADDRESS_COST.  */
end_comment

begin_function
name|int
name|i960_address_cost
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
if|#
directive|if
literal|0
comment|/* Handled before calling here.  */
block|if (GET_CODE (x) == REG)     return 1;
endif|#
directive|endif
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
condition|)
block|{
name|rtx
name|base
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|offset
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|base
argument_list|)
operator|==
name|SUBREG
condition|)
name|base
operator|=
name|SUBREG_REG
argument_list|(
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|offset
argument_list|)
operator|==
name|SUBREG
condition|)
name|offset
operator|=
name|SUBREG_REG
argument_list|(
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|base
argument_list|)
operator|==
name|REG
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|offset
argument_list|)
operator|==
name|REG
condition|)
return|return
literal|2
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|offset
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
if|if
condition|(
operator|(
name|unsigned
operator|)
name|INTVAL
argument_list|(
name|offset
argument_list|)
operator|<
literal|2047
condition|)
return|return
literal|2
return|;
return|return
literal|4
return|;
block|}
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|offset
argument_list|)
condition|)
return|return
literal|4
return|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|base
argument_list|)
operator|==
name|PLUS
operator|||
name|GET_CODE
argument_list|(
name|base
argument_list|)
operator|==
name|MULT
condition|)
return|return
literal|6
return|;
comment|/* This is an invalid address.  The return value doesn't matter, but 	 for convenience we make this more expensive than anything else.  */
return|return
literal|12
return|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MULT
condition|)
return|return
literal|6
return|;
comment|/* Symbol_refs and other unrecognized addresses are cost 4.  */
return|return
literal|4
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Emit insns to move operands[1] into operands[0].     Return 1 if we have written out everything that needs to be done to    do the move.  Otherwise, return 0 and the caller will emit the move    normally.  */
end_comment

begin_function
name|int
name|emit_move_sequence
parameter_list|(
name|operands
parameter_list|,
name|mode
parameter_list|)
name|rtx
modifier|*
name|operands
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
specifier|register
name|rtx
name|operand0
init|=
name|operands
index|[
literal|0
index|]
decl_stmt|;
specifier|register
name|rtx
name|operand1
init|=
name|operands
index|[
literal|1
index|]
decl_stmt|;
comment|/* We can only store registers to memory.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|operand0
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|operand1
argument_list|)
operator|!=
name|REG
condition|)
name|operands
index|[
literal|1
index|]
operator|=
name|force_reg
argument_list|(
name|mode
argument_list|,
name|operand1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Emit insns to load a constant.  Uses several strategies to try to use    as few insns as possible.  */
end_comment

begin_function
name|char
modifier|*
name|i960_output_ldconst
parameter_list|(
name|dst
parameter_list|,
name|src
parameter_list|)
specifier|register
name|rtx
name|dst
decl_stmt|,
name|src
decl_stmt|;
block|{
specifier|register
name|int
name|rsrc1
decl_stmt|;
specifier|register
name|unsigned
name|rsrc2
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|dst
argument_list|)
decl_stmt|;
name|rtx
name|operands
index|[
literal|4
index|]
decl_stmt|;
union|union
block|{
name|long
name|l
index|[
literal|2
index|]
decl_stmt|;
name|double
name|d
decl_stmt|;
block|}
name|x
union|;
name|operands
index|[
literal|0
index|]
operator|=
name|operands
index|[
literal|2
index|]
operator|=
name|dst
expr_stmt|;
name|operands
index|[
literal|1
index|]
operator|=
name|operands
index|[
literal|3
index|]
operator|=
name|src
expr_stmt|;
comment|/* Anything that isn't a compile time constant, such as a SYMBOL_REF,      must be a ldconst insn.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|!=
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|!=
name|CONST_DOUBLE
condition|)
block|{
name|output_asm_insn
argument_list|(
literal|"ldconst	%1,%0"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
return|return
literal|""
return|;
block|}
elseif|else
if|if
condition|(
name|mode
operator|==
name|DFmode
condition|)
block|{
name|rtx
name|first
decl_stmt|,
name|second
decl_stmt|;
if|if
condition|(
name|fp_literal_zero
argument_list|(
name|src
argument_list|,
name|VOIDmode
argument_list|)
condition|)
block|{
if|if
condition|(
name|FP_REG_P
argument_list|(
name|dst
argument_list|)
condition|)
return|return
literal|"movrl	%1,%0"
return|;
else|else
return|return
literal|"movl	0,%0"
return|;
block|}
if|#
directive|if
name|HOST_FLOAT_FORMAT
operator|==
name|TARGET_FLOAT_FORMAT
name|split_double
argument_list|(
name|src
argument_list|,
operator|&
name|first
argument_list|,
operator|&
name|second
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"# ldconst	%1,%0"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
name|operands
index|[
literal|0
index|]
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|SImode
argument_list|,
name|REGNO
argument_list|(
name|dst
argument_list|)
argument_list|)
expr_stmt|;
name|operands
index|[
literal|1
index|]
operator|=
name|first
expr_stmt|;
name|output_asm_insn
argument_list|(
name|i960_output_ldconst
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|operands
argument_list|)
expr_stmt|;
name|operands
index|[
literal|0
index|]
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|SImode
argument_list|,
name|REGNO
argument_list|(
name|dst
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|operands
index|[
literal|1
index|]
operator|=
name|second
expr_stmt|;
name|output_asm_insn
argument_list|(
name|i960_output_ldconst
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|operands
argument_list|)
expr_stmt|;
return|return
literal|""
return|;
else|#
directive|else
if|if
condition|(
name|fp_literal_one
argument_list|(
name|src
argument_list|,
name|VOIDmode
argument_list|)
condition|)
return|return
literal|"movrl	0f1.0,%0"
return|;
name|fatal
argument_list|(
literal|"inline double constants not supported on this host"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|mode
operator|==
name|TImode
condition|)
block|{
comment|/* ??? This is currently not handled at all.  */
name|abort
argument_list|()
expr_stmt|;
comment|/* Note: lowest order word goes in lowest numbered reg.  */
name|rsrc1
operator|=
name|INTVAL
argument_list|(
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
name|rsrc1
operator|>=
literal|0
operator|&&
name|rsrc1
operator|<
literal|32
condition|)
return|return
literal|"movq	%1,%0"
return|;
else|else
name|output_asm_insn
argument_list|(
literal|"movq\t0,%0\t# ldconstq %1,%0"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
comment|/* Go pick up the low-order word.  */
block|}
elseif|else
if|if
condition|(
name|mode
operator|==
name|DImode
condition|)
block|{
name|rtx
name|upperhalf
decl_stmt|,
name|lowerhalf
decl_stmt|,
name|xoperands
index|[
literal|2
index|]
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
block|{
name|upperhalf
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|CONST_DOUBLE_HIGH
argument_list|(
name|src
argument_list|)
argument_list|)
expr_stmt|;
name|lowerhalf
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|CONST_DOUBLE_LOW
argument_list|(
name|src
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|lowerhalf
operator|=
name|src
expr_stmt|;
name|upperhalf
operator|=
name|INTVAL
argument_list|(
name|src
argument_list|)
operator|<
literal|0
condition|?
name|constm1_rtx
else|:
name|const0_rtx
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
comment|/* Note: lowest order word goes in lowest numbered reg.  */
comment|/* Numbers from 0 to 31 can be handled with a single insn.  */
name|rsrc1
operator|=
name|INTVAL
argument_list|(
name|lowerhalf
argument_list|)
expr_stmt|;
if|if
condition|(
name|upperhalf
operator|==
name|const0_rtx
operator|&&
name|rsrc1
operator|>=
literal|0
operator|&&
name|rsrc1
operator|<
literal|32
condition|)
return|return
literal|"movl	%1,%0"
return|;
comment|/* Output the upper half with a recursive call.  */
name|xoperands
index|[
literal|0
index|]
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|SImode
argument_list|,
name|REGNO
argument_list|(
name|dst
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|xoperands
index|[
literal|1
index|]
operator|=
name|upperhalf
expr_stmt|;
name|output_asm_insn
argument_list|(
name|i960_output_ldconst
argument_list|(
name|xoperands
index|[
literal|0
index|]
argument_list|,
name|xoperands
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|xoperands
argument_list|)
expr_stmt|;
comment|/* The lower word is emitted as normally.  */
block|}
elseif|else
if|if
condition|(
name|mode
operator|==
name|SFmode
condition|)
block|{
if|#
directive|if
name|HOST_FLOAT_FORMAT
operator|==
name|TARGET_FLOAT_FORMAT
name|REAL_VALUE_TYPE
name|d
decl_stmt|;
name|long
name|value
decl_stmt|;
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|d
argument_list|,
name|src
argument_list|)
expr_stmt|;
name|REAL_VALUE_TO_TARGET_SINGLE
argument_list|(
name|d
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"# ldconst	%1,%0"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
name|operands
index|[
literal|0
index|]
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|SImode
argument_list|,
name|REGNO
argument_list|(
name|dst
argument_list|)
argument_list|)
expr_stmt|;
name|operands
index|[
literal|1
index|]
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
name|i960_output_ldconst
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|operands
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|fp_literal_zero
argument_list|(
name|src
argument_list|,
name|VOIDmode
argument_list|)
condition|)
return|return
literal|"movr	0f0.0,%0"
return|;
if|if
condition|(
name|fp_literal_one
argument_list|(
name|src
argument_list|,
name|VOIDmode
argument_list|)
condition|)
return|return
literal|"movr	0f1.0,%0"
return|;
name|fatal
argument_list|(
literal|"inline float constants not supported on this host"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|""
return|;
block|}
else|else
block|{
name|rsrc1
operator|=
name|INTVAL
argument_list|(
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|QImode
condition|)
block|{
if|if
condition|(
name|rsrc1
operator|>
literal|0xff
condition|)
name|rsrc1
operator|&=
literal|0xff
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mode
operator|==
name|HImode
condition|)
block|{
if|if
condition|(
name|rsrc1
operator|>
literal|0xffff
condition|)
name|rsrc1
operator|&=
literal|0xffff
expr_stmt|;
block|}
block|}
if|if
condition|(
name|rsrc1
operator|>=
literal|0
condition|)
block|{
comment|/* ldconst	0..31,X		-> 	mov	0..31,X  */
if|if
condition|(
name|rsrc1
operator|<
literal|32
condition|)
block|{
if|if
condition|(
name|i960_last_insn_type
operator|==
name|I_TYPE_REG
operator|&&
name|TARGET_C_SERIES
condition|)
return|return
literal|"lda	%1,%0"
return|;
return|return
literal|"mov	%1,%0"
return|;
block|}
comment|/* ldconst	32..63,X	->	add	31,nn,X  */
if|if
condition|(
name|rsrc1
operator|<
literal|63
condition|)
block|{
if|if
condition|(
name|i960_last_insn_type
operator|==
name|I_TYPE_REG
operator|&&
name|TARGET_C_SERIES
condition|)
return|return
literal|"lda	%1,%0"
return|;
name|operands
index|[
literal|1
index|]
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|rsrc1
operator|-
literal|31
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"addo\t31,%1,%0\t# ldconst %3,%0"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
return|return
literal|""
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|rsrc1
operator|<
literal|0
condition|)
block|{
comment|/* ldconst	-1..-31		->	sub	0,0..31,X  */
if|if
condition|(
name|rsrc1
operator|>=
operator|-
literal|31
condition|)
block|{
comment|/* return 'sub -(%1),0,%0' */
name|operands
index|[
literal|1
index|]
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
operator|-
name|rsrc1
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"subo\t%1,0,%0\t# ldconst %3,%0"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
return|return
literal|""
return|;
block|}
comment|/* ldconst	-32		->	not	31,X  */
if|if
condition|(
name|rsrc1
operator|==
operator|-
literal|32
condition|)
block|{
name|operands
index|[
literal|1
index|]
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
operator|~
name|rsrc1
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"not\t%1,%0	# ldconst %3,%0"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
return|return
literal|""
return|;
block|}
block|}
comment|/* If const is a single bit.  */
if|if
condition|(
name|bitpos
argument_list|(
name|rsrc1
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|operands
index|[
literal|1
index|]
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|bitpos
argument_list|(
name|rsrc1
argument_list|)
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"setbit\t%1,0,%0\t# ldconst %3,%0"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
return|return
literal|""
return|;
block|}
comment|/* If const is a bit string of less than 6 bits (1..31 shifted).  */
if|if
condition|(
name|is_mask
argument_list|(
name|rsrc1
argument_list|)
condition|)
block|{
name|int
name|s
decl_stmt|,
name|e
decl_stmt|;
if|if
condition|(
name|bitstr
argument_list|(
name|rsrc1
argument_list|,
operator|&
name|s
argument_list|,
operator|&
name|e
argument_list|)
operator|<
literal|6
condition|)
block|{
name|rsrc2
operator|=
operator|(
operator|(
name|unsigned
name|int
operator|)
name|rsrc1
operator|)
operator|>>
name|s
expr_stmt|;
name|operands
index|[
literal|1
index|]
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|rsrc2
argument_list|)
expr_stmt|;
name|operands
index|[
literal|2
index|]
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"shlo\t%2,%1,%0\t# ldconst %3,%0"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
return|return
literal|""
return|;
block|}
block|}
comment|/* Unimplemented cases:      const is in range 0..31 but rotated around end of word:      ror	31,3,g0	-> ldconst 0xe0000003,g0          and any 2 instruction cases that might be worthwhile  */
name|output_asm_insn
argument_list|(
literal|"ldconst	%1,%0"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
return|return
literal|""
return|;
block|}
end_function

begin_comment
comment|/* Determine if there is an opportunity for a bypass optimization.    Bypass succeeds on the 960K* if the destination of the previous    instruction is the second operand of the current instruction.    Bypass always succeeds on the C*.      Return 1 if the pattern should interchange the operands.     CMPBR_FLAG is true if this is for a compare-and-branch insn.    OP1 and OP2 are the two source operands of a 3 operand insn.  */
end_comment

begin_function
name|int
name|i960_bypass
parameter_list|(
name|insn
parameter_list|,
name|op1
parameter_list|,
name|op2
parameter_list|,
name|cmpbr_flag
parameter_list|)
specifier|register
name|rtx
name|insn
decl_stmt|,
name|op1
decl_stmt|,
name|op2
decl_stmt|;
name|int
name|cmpbr_flag
decl_stmt|;
block|{
specifier|register
name|rtx
name|prev_insn
decl_stmt|,
name|prev_dest
decl_stmt|;
if|if
condition|(
name|TARGET_C_SERIES
condition|)
return|return
literal|0
return|;
comment|/* Can't do this if op1 isn't a register.  */
if|if
condition|(
operator|!
name|REG_P
argument_list|(
name|op1
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Can't do this for a compare-and-branch if both ops aren't regs.  */
if|if
condition|(
name|cmpbr_flag
operator|&&
operator|!
name|REG_P
argument_list|(
name|op2
argument_list|)
condition|)
return|return
literal|0
return|;
name|prev_insn
operator|=
name|prev_real_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev_insn
operator|&&
name|GET_CODE
argument_list|(
name|prev_insn
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|prev_insn
argument_list|)
argument_list|)
operator|==
name|SET
condition|)
block|{
name|prev_dest
operator|=
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|prev_insn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|prev_dest
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|prev_dest
argument_list|)
operator|==
name|REGNO
argument_list|(
name|op1
argument_list|)
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|prev_dest
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|prev_dest
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|prev_dest
argument_list|)
argument_list|)
operator|==
name|REGNO
argument_list|(
name|op1
argument_list|)
operator|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output the code which declares the function name.  This also handles    leaf routines, which have special requirements, and initializes some    global variables.  */
end_comment

begin_function
name|void
name|i960_function_name_declare
parameter_list|(
name|file
parameter_list|,
name|name
parameter_list|,
name|fndecl
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|tree
name|fndecl
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|leaf_proc_ok
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
comment|/* Increment global return label.  */
name|ret_label
operator|++
expr_stmt|;
comment|/* Compute whether tail calls and leaf routine optimizations can be performed      for this function.  */
if|if
condition|(
name|TARGET_TAILCALL
condition|)
name|tail_call_ok
operator|=
literal|1
expr_stmt|;
else|else
name|tail_call_ok
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|TARGET_LEAFPROC
condition|)
name|leaf_proc_ok
operator|=
literal|1
expr_stmt|;
else|else
name|leaf_proc_ok
operator|=
literal|0
expr_stmt|;
comment|/* Even if nobody uses extra parms, can't have leafroc or tail calls if      argblock, because argblock uses g14 implicitly.  */
if|if
condition|(
name|current_function_args_size
operator|!=
literal|0
condition|)
block|{
name|tail_call_ok
operator|=
literal|0
expr_stmt|;
name|leaf_proc_ok
operator|=
literal|0
expr_stmt|;
block|}
comment|/* See if caller passes in an address to return value. */
if|if
condition|(
name|aggregate_value_p
argument_list|(
name|DECL_RESULT
argument_list|(
name|fndecl
argument_list|)
argument_list|)
condition|)
block|{
name|tail_call_ok
operator|=
literal|0
expr_stmt|;
name|leaf_proc_ok
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Can not use tail calls or make this a leaf routine if there is a non      zero frame size.  */
if|if
condition|(
name|get_frame_size
argument_list|()
operator|!=
literal|0
condition|)
name|leaf_proc_ok
operator|=
literal|0
expr_stmt|;
comment|/* I don't understand this condition, and do not think that it is correct.      Apparently this is just checking whether the frame pointer is used, and      we can't trust regs_ever_live[fp] since it is (almost?) always set.  */
if|if
condition|(
name|tail_call_ok
condition|)
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|&&
name|reg_mentioned_p
argument_list|(
name|frame_pointer_rtx
argument_list|,
name|insn
argument_list|)
condition|)
block|{
name|tail_call_ok
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/* Check for CALL insns.  Can not be a leaf routine if there are any.  */
if|if
condition|(
name|leaf_proc_ok
condition|)
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
name|leaf_proc_ok
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/* Can not be a leaf routine if any non-call clobbered registers are      used in this function.  */
if|if
condition|(
name|leaf_proc_ok
condition|)
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|i
index|]
operator|&&
operator|(
operator|(
operator|!
name|call_used_regs
index|[
name|i
index|]
operator|)
operator|||
operator|(
name|i
operator|>
literal|7
operator|&&
name|i
operator|<
literal|12
operator|)
operator|)
condition|)
block|{
comment|/* Global registers.  */
if|if
condition|(
name|i
operator|<
literal|16
operator|&&
name|i
operator|>
literal|7
operator|&&
name|i
operator|!=
literal|13
condition|)
name|leaf_proc_ok
operator|=
literal|0
expr_stmt|;
comment|/* Local registers.  */
elseif|else
if|if
condition|(
name|i
operator|<
literal|32
condition|)
name|leaf_proc_ok
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Now choose a leaf return register, if we can find one, and if it is      OK for this to be a leaf routine.  */
name|i960_leaf_ret_reg
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|optimize
operator|&&
name|leaf_proc_ok
condition|)
block|{
for|for
control|(
name|i960_leaf_ret_reg
operator|=
operator|-
literal|1
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|i
index|]
operator|==
literal|0
condition|)
block|{
name|i960_leaf_ret_reg
operator|=
name|i
expr_stmt|;
name|regs_ever_live
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
comment|/* Do this after choosing the leaf return register, so it will be listed      if one was chosen.  */
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t#  Function '%s'\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t#  Registers used: "
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|regs_ever_live
index|[
name|i
index|]
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s%s "
argument_list|,
name|reg_names
index|[
name|i
index|]
argument_list|,
name|call_used_regs
index|[
name|i
index|]
condition|?
literal|""
else|:
literal|"*"
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|15
operator|&&
name|j
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n\t#\t\t   "
argument_list|)
expr_stmt|;
name|j
operator|++
expr_stmt|;
block|}
block|}
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|i960_leaf_ret_reg
operator|>=
literal|0
condition|)
block|{
comment|/* Make it a leaf procedure.  */
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|fndecl
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.globl    %s.lf\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.leafproc\t_%s,%s.lf\n"
argument_list|,
name|name
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"_%s:\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tlda    LR%d,g14\n"
argument_list|,
name|ret_label
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s.lf:\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tmov    g14,g%d\n"
argument_list|,
name|i960_leaf_ret_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_C_SERIES
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tlda    0,g14\n"
argument_list|)
expr_stmt|;
name|i960_last_insn_type
operator|=
name|I_TYPE_MEM
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tmov    0,g14\n"
argument_list|)
expr_stmt|;
name|i960_last_insn_type
operator|=
name|I_TYPE_REG
expr_stmt|;
block|}
block|}
else|else
block|{
name|ASM_OUTPUT_LABEL
argument_list|(
name|file
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|i960_last_insn_type
operator|=
name|I_TYPE_CTRL
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Compute and return the frame size.  */
end_comment

begin_function
name|int
name|compute_frame_size
parameter_list|(
name|size
parameter_list|)
name|int
name|size
decl_stmt|;
block|{
name|int
name|actual_fsize
decl_stmt|;
name|int
name|outgoing_args_size
init|=
name|current_function_outgoing_args_size
operator|+
name|current_function_pretend_args_size
decl_stmt|;
comment|/* The STARTING_FRAME_OFFSET is totally hidden to us as far      as size is concerned.  */
name|actual_fsize
operator|=
operator|(
name|size
operator|+
literal|15
operator|)
operator|&
operator|-
literal|16
expr_stmt|;
name|actual_fsize
operator|+=
operator|(
name|outgoing_args_size
operator|+
literal|15
operator|)
operator|&
operator|-
literal|16
expr_stmt|;
return|return
name|actual_fsize
return|;
block|}
end_function

begin_comment
comment|/* Output code for the function prologue.  */
end_comment

begin_function
name|void
name|i960_function_prologue
parameter_list|(
name|file
parameter_list|,
name|size
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|unsigned
name|int
name|size
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|nr
decl_stmt|;
name|int
name|n_iregs
init|=
literal|0
decl_stmt|;
name|int
name|rsize
init|=
literal|0
decl_stmt|;
name|int
name|actual_fsize
decl_stmt|,
name|offset
decl_stmt|;
name|char
name|tmpstr
index|[
literal|1000
index|]
decl_stmt|;
comment|/* -1 if reg must be saved on proc entry, 0 if available, 1 if saved      somewhere.  */
name|int
name|regs
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|i
index|]
operator|&&
operator|(
operator|(
operator|!
name|call_used_regs
index|[
name|i
index|]
operator|)
operator|||
operator|(
name|i
operator|>
literal|7
operator|&&
name|i
operator|<
literal|12
operator|)
operator|)
condition|)
block|{
name|regs
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Count global registers that need saving.  */
if|if
condition|(
name|i
operator|<
literal|16
condition|)
name|n_iregs
operator|++
expr_stmt|;
block|}
else|else
name|regs
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|epilogue_string
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* First look for local registers to save globals in.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|regs
index|[
name|i
index|]
operator|==
literal|0
condition|)
continue|continue;
comment|/* Start at r4, not r3.  */
for|for
control|(
name|j
operator|=
literal|20
init|;
name|j
operator|<
literal|32
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|regs
index|[
name|j
index|]
operator|!=
literal|0
condition|)
continue|continue;
name|regs
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
name|regs
index|[
name|j
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|regs_ever_live
index|[
name|j
index|]
operator|=
literal|1
expr_stmt|;
name|nr
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|i
operator|<=
literal|14
operator|&&
name|i
operator|%
literal|2
operator|==
literal|0
operator|&&
name|j
operator|<=
literal|30
operator|&&
name|j
operator|%
literal|2
operator|==
literal|0
operator|&&
name|regs
index|[
name|i
operator|+
literal|1
index|]
operator|!=
literal|0
operator|&&
name|regs
index|[
name|j
operator|+
literal|1
index|]
operator|==
literal|0
condition|)
block|{
name|nr
operator|=
literal|2
expr_stmt|;
name|regs
index|[
name|i
operator|+
literal|1
index|]
operator|=
literal|1
expr_stmt|;
name|regs
index|[
name|j
operator|+
literal|1
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|regs_ever_live
index|[
name|j
operator|+
literal|1
index|]
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|nr
operator|==
literal|2
operator|&&
name|i
operator|<=
literal|12
operator|&&
name|i
operator|%
literal|4
operator|==
literal|0
operator|&&
name|j
operator|<=
literal|28
operator|&&
name|j
operator|%
literal|4
operator|==
literal|0
operator|&&
name|regs
index|[
name|i
operator|+
literal|2
index|]
operator|!=
literal|0
operator|&&
name|regs
index|[
name|j
operator|+
literal|2
index|]
operator|==
literal|0
condition|)
block|{
name|nr
operator|=
literal|3
expr_stmt|;
name|regs
index|[
name|i
operator|+
literal|2
index|]
operator|=
literal|1
expr_stmt|;
name|regs
index|[
name|j
operator|+
literal|2
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|regs_ever_live
index|[
name|j
operator|+
literal|2
index|]
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|nr
operator|==
literal|3
operator|&&
name|regs
index|[
name|i
operator|+
literal|3
index|]
operator|!=
literal|0
operator|&&
name|regs
index|[
name|j
operator|+
literal|3
index|]
operator|==
literal|0
condition|)
block|{
name|nr
operator|=
literal|4
expr_stmt|;
name|regs
index|[
name|i
operator|+
literal|3
index|]
operator|=
literal|1
expr_stmt|;
name|regs
index|[
name|j
operator|+
literal|3
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|regs_ever_live
index|[
name|j
operator|+
literal|3
index|]
operator|=
literal|1
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tmov%s	%s,%s\n"
argument_list|,
operator|(
operator|(
name|nr
operator|==
literal|4
operator|)
condition|?
literal|"q"
else|:
operator|(
name|nr
operator|==
literal|3
operator|)
condition|?
literal|"t"
else|:
operator|(
name|nr
operator|==
literal|2
operator|)
condition|?
literal|"l"
else|:
literal|""
operator|)
argument_list|,
name|reg_names
index|[
name|i
index|]
argument_list|,
name|reg_names
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|tmpstr
argument_list|,
literal|"\tmov%s	%s,%s\n"
argument_list|,
operator|(
operator|(
name|nr
operator|==
literal|4
operator|)
condition|?
literal|"q"
else|:
operator|(
name|nr
operator|==
literal|3
operator|)
condition|?
literal|"t"
else|:
operator|(
name|nr
operator|==
literal|2
operator|)
condition|?
literal|"l"
else|:
literal|""
operator|)
argument_list|,
name|reg_names
index|[
name|j
index|]
argument_list|,
name|reg_names
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|epilogue_string
argument_list|,
name|tmpstr
argument_list|)
expr_stmt|;
name|n_iregs
operator|-=
name|nr
expr_stmt|;
name|i
operator|+=
name|nr
operator|-
literal|1
expr_stmt|;
break|break;
block|}
block|}
comment|/* N_iregs is now the number of global registers that haven't been saved      yet.  */
name|rsize
operator|=
operator|(
name|n_iregs
operator|*
literal|4
operator|)
expr_stmt|;
name|actual_fsize
operator|=
name|compute_frame_size
argument_list|(
name|size
argument_list|)
operator|+
name|rsize
expr_stmt|;
if|#
directive|if
literal|0
comment|/* ??? The 1.2.1 compiler does this also.  This is meant to round the frame      size up to the nearest multiple of 16.  I don't know whether this is      necessary, or even desirable.       The frame pointer must be aligned, but the call instruction takes care of      that.  If we leave the stack pointer unaligned, we may save a little on      dynamic stack allocation.  And we don't lose, at least according to the      i960CA manual.  */
block|actual_fsize = (actual_fsize + 15)& ~0xF;
endif|#
directive|endif
comment|/* Allocate space for register save and locals.  */
if|if
condition|(
name|actual_fsize
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|actual_fsize
operator|<
literal|32
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\taddo	%d,sp,sp\n"
argument_list|,
name|actual_fsize
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tlda\t%d(sp),sp\n"
argument_list|,
name|actual_fsize
argument_list|)
expr_stmt|;
block|}
comment|/* Take hardware register save area created by the call instruction      into account.  */
name|offset
operator|=
name|compute_frame_size
argument_list|(
name|size
argument_list|)
operator|+
literal|64
expr_stmt|;
comment|/* Save registers on stack if needed.  */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
name|n_iregs
init|;
name|j
operator|>
literal|0
operator|&&
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|regs
index|[
name|i
index|]
operator|!=
operator|-
literal|1
condition|)
continue|continue;
name|nr
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|i
operator|<=
literal|14
operator|&&
name|i
operator|%
literal|2
operator|==
literal|0
operator|&&
name|regs
index|[
name|i
operator|+
literal|1
index|]
operator|==
operator|-
literal|1
operator|&&
name|offset
operator|%
literal|2
operator|==
literal|0
condition|)
name|nr
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|nr
operator|==
literal|2
operator|&&
name|i
operator|<=
literal|12
operator|&&
name|i
operator|%
literal|4
operator|==
literal|0
operator|&&
name|regs
index|[
name|i
operator|+
literal|2
index|]
operator|==
operator|-
literal|1
operator|&&
name|offset
operator|%
literal|4
operator|==
literal|0
condition|)
name|nr
operator|=
literal|3
expr_stmt|;
if|if
condition|(
name|nr
operator|==
literal|3
operator|&&
name|regs
index|[
name|i
operator|+
literal|3
index|]
operator|==
operator|-
literal|1
condition|)
name|nr
operator|=
literal|4
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tst%s	%s,%d(fp)\n"
argument_list|,
operator|(
operator|(
name|nr
operator|==
literal|4
operator|)
condition|?
literal|"q"
else|:
operator|(
name|nr
operator|==
literal|3
operator|)
condition|?
literal|"t"
else|:
operator|(
name|nr
operator|==
literal|2
operator|)
condition|?
literal|"l"
else|:
literal|""
operator|)
argument_list|,
name|reg_names
index|[
name|i
index|]
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|tmpstr
argument_list|,
literal|"\tld%s	%d(fp),%s\n"
argument_list|,
operator|(
operator|(
name|nr
operator|==
literal|4
operator|)
condition|?
literal|"q"
else|:
operator|(
name|nr
operator|==
literal|3
operator|)
condition|?
literal|"t"
else|:
operator|(
name|nr
operator|==
literal|2
operator|)
condition|?
literal|"l"
else|:
literal|""
operator|)
argument_list|,
name|offset
argument_list|,
name|reg_names
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|epilogue_string
argument_list|,
name|tmpstr
argument_list|)
expr_stmt|;
name|i
operator|+=
name|nr
operator|-
literal|1
expr_stmt|;
name|j
operator|-=
name|nr
expr_stmt|;
name|offset
operator|+=
name|nr
operator|*
literal|4
expr_stmt|;
block|}
if|if
condition|(
name|actual_fsize
operator|==
literal|0
operator|&&
name|size
operator|==
literal|0
operator|&&
name|rsize
operator|==
literal|0
condition|)
return|return;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t#Prologue stats:\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t#  Total Frame Size: %d bytes\n"
argument_list|,
name|actual_fsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t#  Local Variable Size: %d bytes\n"
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|rsize
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t#  Register Save Size: %d regs, %d bytes\n"
argument_list|,
name|n_iregs
argument_list|,
name|rsize
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t#End Prologue#\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output code for the function epilogue.  */
end_comment

begin_function
name|void
name|i960_function_epilogue
parameter_list|(
name|file
parameter_list|,
name|size
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|unsigned
name|int
name|size
decl_stmt|;
block|{
if|if
condition|(
name|i960_leaf_ret_reg
operator|>=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"LR%d:	ret\n"
argument_list|,
name|ret_label
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|*
name|epilogue_string
operator|==
literal|0
condition|)
block|{
specifier|register
name|rtx
name|tmp
decl_stmt|;
comment|/* Emit a return insn, but only if control can fall through to here.  */
name|tmp
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
while|while
condition|(
name|tmp
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|BARRIER
condition|)
return|return;
if|if
condition|(
name|GET_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|CODE_LABEL
condition|)
break|break;
if|if
condition|(
name|GET_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|JUMP_INSN
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|tmp
argument_list|)
argument_list|)
operator|==
name|RETURN
condition|)
return|return;
break|break;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|NOTE
condition|)
block|{
name|tmp
operator|=
name|PREV_INSN
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
continue|continue;
block|}
break|break;
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"LR%d:	ret\n"
argument_list|,
name|ret_label
argument_list|)
expr_stmt|;
return|return;
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"LR%d:\n"
argument_list|,
name|ret_label
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t#EPILOGUE#\n"
argument_list|)
expr_stmt|;
comment|/* Output the string created by the prologue which will restore all      registers saved by the prologue.  */
if|if
condition|(
name|epilogue_string
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|epilogue_string
argument_list|)
expr_stmt|;
comment|/* Must clear g14 on return.  */
if|if
condition|(
name|current_function_args_size
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tmov	0,g14\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tret\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t#End Epilogue#\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output code for a call insn.  */
end_comment

begin_function
name|char
modifier|*
name|i960_output_call_insn
parameter_list|(
name|target
parameter_list|,
name|argsize_rtx
parameter_list|,
name|arg_pointer
parameter_list|,
name|scratch_reg
parameter_list|,
name|insn
parameter_list|)
specifier|register
name|rtx
name|target
decl_stmt|,
name|argsize_rtx
decl_stmt|,
name|arg_pointer
decl_stmt|,
name|scratch_reg
decl_stmt|,
name|insn
decl_stmt|;
block|{
name|int
name|argsize
init|=
name|INTVAL
argument_list|(
name|argsize_rtx
argument_list|)
decl_stmt|;
name|rtx
name|nexti
init|=
name|next_real_insn
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|operands
index|[
literal|3
index|]
decl_stmt|;
name|operands
index|[
literal|0
index|]
operator|=
name|target
expr_stmt|;
name|operands
index|[
literal|1
index|]
operator|=
name|arg_pointer
expr_stmt|;
name|operands
index|[
literal|2
index|]
operator|=
name|scratch_reg
expr_stmt|;
if|if
condition|(
name|current_function_args_size
operator|!=
literal|0
condition|)
name|output_asm_insn
argument_list|(
literal|"mov	g14,%2"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
if|if
condition|(
name|argsize
operator|>
literal|48
condition|)
name|output_asm_insn
argument_list|(
literal|"lda	%a1,g14"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|current_function_args_size
operator|!=
literal|0
condition|)
name|output_asm_insn
argument_list|(
literal|"mov	0,g14"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
comment|/* The code used to assume that calls to SYMBOL_REFs could not be more      than 24 bits away (b vs bx, callj vs callx).  This is not true.  This      feature is now implemented by relaxing in the GNU linker.  It can convert      bx to b if in range, and callx to calls/call/balx/bal as appropriate.  */
comment|/* Nexti could be zero if the called routine is volatile.  */
if|if
condition|(
name|optimize
operator|&&
operator|(
operator|*
name|epilogue_string
operator|==
literal|0
operator|)
operator|&&
name|argsize
operator|==
literal|0
operator|&&
name|tail_call_ok
operator|&&
operator|(
name|nexti
operator|==
literal|0
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|nexti
argument_list|)
argument_list|)
operator|==
name|RETURN
operator|)
condition|)
block|{
comment|/* Delete following return insn.  */
if|if
condition|(
name|nexti
operator|&&
name|no_labels_between_p
argument_list|(
name|insn
argument_list|,
name|nexti
argument_list|)
condition|)
name|delete_insn
argument_list|(
name|nexti
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"bx	%0"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
return|return
literal|"# notreached"
return|;
block|}
name|output_asm_insn
argument_list|(
literal|"callx	%0"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_function_args_size
operator|!=
literal|0
condition|)
name|output_asm_insn
argument_list|(
literal|"mov	%2,g14"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
return|return
literal|""
return|;
block|}
end_function

begin_comment
comment|/* Output code for a return insn.  */
end_comment

begin_function
name|char
modifier|*
name|i960_output_ret_insn
parameter_list|(
name|insn
parameter_list|)
specifier|register
name|rtx
name|insn
decl_stmt|;
block|{
specifier|static
name|char
name|lbuf
index|[
literal|20
index|]
decl_stmt|;
if|if
condition|(
operator|*
name|epilogue_string
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|TARGET_CODE_ALIGN
operator|&&
name|next_real_insn
argument_list|(
name|insn
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|""
return|;
name|sprintf
argument_list|(
name|lbuf
argument_list|,
literal|"b	LR%d"
argument_list|,
name|ret_label
argument_list|)
expr_stmt|;
return|return
name|lbuf
return|;
block|}
if|if
condition|(
name|current_function_args_size
operator|!=
literal|0
condition|)
name|output_asm_insn
argument_list|(
literal|"mov	0,g14"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|i960_leaf_ret_reg
operator|>=
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|lbuf
argument_list|,
literal|"bx	(%s)"
argument_list|,
name|reg_names
index|[
name|i960_leaf_ret_reg
index|]
argument_list|)
expr_stmt|;
return|return
name|lbuf
return|;
block|}
return|return
literal|"ret"
return|;
block|}
end_function

begin_escape
end_escape

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Return a character string representing the branch prediction    opcode to be tacked on an instruction.  This must at least    return a null string.  */
end_comment

begin_comment
unit|char * i960_br_predict_opcode (lab_ref, insn)      rtx lab_ref, insn; {   if (TARGET_BRANCH_PREDICT)     {       unsigned long label_uid;              if (GET_CODE (lab_ref) == CODE_LABEL) 	label_uid = INSN_UID (lab_ref);       else if (GET_CODE (lab_ref) == LABEL_REF) 	label_uid = INSN_UID (XEXP (lab_ref, 0));       else 	return ".f";
comment|/* If not optimizing, then the insn_addresses array will not be 	 valid.  In this case, always return ".t" since most branches 	 are taken.  If optimizing, return .t for backward branches 	 and .f for forward branches.  */
end_comment

begin_endif
unit|if (! optimize 	  || insn_addresses[label_uid]< insn_addresses[INSN_UID (insn)]) 	return ".t";       return ".f";     }        return ""; }
endif|#
directive|endif
end_endif

begin_comment
comment|/* Print the operand represented by rtx X formatted by code CODE.  */
end_comment

begin_function
name|void
name|i960_print_operand
parameter_list|(
name|file
parameter_list|,
name|x
parameter_list|,
name|code
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|char
name|code
decl_stmt|;
block|{
name|enum
name|rtx_code
name|rtxcode
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|rtxcode
operator|==
name|REG
condition|)
block|{
switch|switch
condition|(
name|code
condition|)
block|{
case|case
literal|'D'
case|:
comment|/* Second reg of a double.  */
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
return|return;
block|}
elseif|else
if|if
condition|(
name|rtxcode
operator|==
name|MEM
condition|)
block|{
name|output_address
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|rtxcode
operator|==
name|CONST_INT
condition|)
block|{
if|if
condition|(
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|>
literal|9999
operator|||
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|<
operator|-
literal|999
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"0x%x"
argument_list|,
name|INTVAL
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d"
argument_list|,
name|INTVAL
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|rtxcode
operator|==
name|CONST_DOUBLE
condition|)
block|{
name|double
name|d
decl_stmt|;
if|if
condition|(
name|x
operator|==
name|CONST0_RTX
argument_list|(
name|DFmode
argument_list|)
operator|||
name|x
operator|==
name|CONST0_RTX
argument_list|(
name|SFmode
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"0f0.0"
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|x
operator|==
name|CONST1_RTX
argument_list|(
name|DFmode
argument_list|)
operator|||
name|x
operator|==
name|CONST1_RTX
argument_list|(
name|SFmode
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"0f1.0"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* This better be a comment.  */
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|d
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%#g"
argument_list|,
name|d
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|code
condition|)
block|{
case|case
literal|'B'
case|:
comment|/* Branch or jump, depending on assembler.  */
if|if
condition|(
name|TARGET_ASM_COMPAT
condition|)
name|fputs
argument_list|(
literal|"j"
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
name|fputs
argument_list|(
literal|"b"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
comment|/* Sign of condition.  */
if|if
condition|(
operator|(
name|rtxcode
operator|==
name|EQ
operator|)
operator|||
operator|(
name|rtxcode
operator|==
name|NE
operator|)
operator|||
operator|(
name|rtxcode
operator|==
name|GTU
operator|)
operator|||
operator|(
name|rtxcode
operator|==
name|LTU
operator|)
operator|||
operator|(
name|rtxcode
operator|==
name|GEU
operator|)
operator|||
operator|(
name|rtxcode
operator|==
name|LEU
operator|)
condition|)
name|fputs
argument_list|(
literal|"o"
argument_list|,
name|file
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|rtxcode
operator|==
name|GT
operator|)
operator|||
operator|(
name|rtxcode
operator|==
name|LT
operator|)
operator|||
operator|(
name|rtxcode
operator|==
name|GE
operator|)
operator|||
operator|(
name|rtxcode
operator|==
name|LE
operator|)
condition|)
name|fputs
argument_list|(
literal|"i"
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
comment|/* Inverted condition.  */
name|rtxcode
operator|=
name|reverse_condition
argument_list|(
name|rtxcode
argument_list|)
expr_stmt|;
goto|goto
name|normal
goto|;
case|case
literal|'X'
case|:
comment|/* Inverted condition w/ reversed operands.  */
name|rtxcode
operator|=
name|reverse_condition
argument_list|(
name|rtxcode
argument_list|)
expr_stmt|;
comment|/* Fallthrough.  */
case|case
literal|'R'
case|:
comment|/* Reversed operand condition.  */
name|rtxcode
operator|=
name|swap_condition
argument_list|(
name|rtxcode
argument_list|)
expr_stmt|;
comment|/* Fallthrough.  */
case|case
literal|'C'
case|:
comment|/* Normal condition.  */
name|normal
label|:
if|if
condition|(
name|rtxcode
operator|==
name|EQ
condition|)
block|{
name|fputs
argument_list|(
literal|"e"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|rtxcode
operator|==
name|NE
condition|)
block|{
name|fputs
argument_list|(
literal|"ne"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|rtxcode
operator|==
name|GT
condition|)
block|{
name|fputs
argument_list|(
literal|"g"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|rtxcode
operator|==
name|GTU
condition|)
block|{
name|fputs
argument_list|(
literal|"g"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|rtxcode
operator|==
name|LT
condition|)
block|{
name|fputs
argument_list|(
literal|"l"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|rtxcode
operator|==
name|LTU
condition|)
block|{
name|fputs
argument_list|(
literal|"l"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|rtxcode
operator|==
name|GE
condition|)
block|{
name|fputs
argument_list|(
literal|"ge"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|rtxcode
operator|==
name|GEU
condition|)
block|{
name|fputs
argument_list|(
literal|"ge"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|rtxcode
operator|==
name|LE
condition|)
block|{
name|fputs
argument_list|(
literal|"le"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|rtxcode
operator|==
name|LEU
condition|)
block|{
name|fputs
argument_list|(
literal|"le"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
break|break;
case|case
literal|0
case|:
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|x
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print a memory address as an operand to reference that memory location.     This is exactly the same as legitimate_address_p, except that it the prints    addresses instead of recognizing them.  */
end_comment

begin_function
name|void
name|i960_print_operand_addr
parameter_list|(
name|file
parameter_list|,
name|addr
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
specifier|register
name|rtx
name|addr
decl_stmt|;
block|{
name|rtx
name|breg
decl_stmt|,
name|ireg
decl_stmt|;
name|rtx
name|scale
decl_stmt|,
name|offset
decl_stmt|;
name|ireg
operator|=
literal|0
expr_stmt|;
name|breg
operator|=
literal|0
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
name|scale
operator|=
name|const1_rtx
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|REG
condition|)
name|breg
operator|=
name|addr
expr_stmt|;
elseif|else
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|addr
argument_list|)
condition|)
name|offset
operator|=
name|addr
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|PLUS
condition|)
block|{
name|rtx
name|op0
decl_stmt|,
name|op1
decl_stmt|;
name|op0
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|REG
condition|)
block|{
name|breg
operator|=
name|op0
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|REG
condition|)
name|ireg
operator|=
name|op1
expr_stmt|;
elseif|else
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|op1
argument_list|)
condition|)
name|offset
operator|=
name|op1
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|PLUS
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MULT
condition|)
block|{
name|ireg
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|scale
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
name|breg
operator|=
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|offset
operator|=
name|op1
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
name|breg
operator|=
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
name|ireg
operator|=
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|offset
operator|=
name|op1
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|MULT
condition|)
block|{
name|ireg
operator|=
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|scale
operator|=
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|REG
condition|)
name|breg
operator|=
name|op1
expr_stmt|;
elseif|else
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|op1
argument_list|)
condition|)
name|offset
operator|=
name|op1
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|MULT
condition|)
block|{
name|breg
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|scale
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|offset
condition|)
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|breg
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"(%s)"
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|breg
argument_list|)
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ireg
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"[%s*%d]"
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|ireg
argument_list|)
index|]
argument_list|,
name|INTVAL
argument_list|(
name|scale
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* GO_IF_LEGITIMATE_ADDRESS recognizes an RTL expression    that is a valid memory address for an instruction.    The MODE argument is the machine mode for the MEM expression    that wants to use this address.  	On 80960, legitimate addresses are: 		base				ld	(g0),r0 		disp	(12 or 32 bit)		ld	foo,r0 		base + index			ld	(g0)[g1*1],r0 		base + displ			ld	0xf00(g0),r0 		base + index*scale + displ	ld	0xf00(g0)[g1*4],r0 		index*scale + base		ld	(g0)[g1*4],r0 		index*scale + displ		ld	0xf00[g1*4],r0 		index*scale			ld	[g1*4],r0 		index + base + displ		ld	0xf00(g0)[g1*1],r0  	In each case, scale can be 1, 2, 4, 8, or 16.  */
end_comment

begin_comment
comment|/* This is exactly the same as i960_print_operand_addr, except that    it recognizes addresses instead of printing them.     It only recognizes address in canonical form.  LEGITIMIZE_ADDRESS should    convert common non-canonical forms to canonical form so that they will    be recognized.  */
end_comment

begin_function
name|int
name|legitimate_address_p
parameter_list|(
name|mode
parameter_list|,
name|addr
parameter_list|,
name|strict
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
specifier|register
name|rtx
name|addr
decl_stmt|;
name|int
name|strict
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|REG
condition|)
return|return
operator|(
name|strict
condition|?
name|REG_OK_FOR_BASE_P_STRICT
argument_list|(
name|addr
argument_list|)
else|:
name|REG_OK_FOR_BASE_P
argument_list|(
name|addr
argument_list|)
operator|)
return|;
elseif|else
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|addr
argument_list|)
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|PLUS
condition|)
block|{
name|rtx
name|op0
decl_stmt|,
name|op1
decl_stmt|;
if|if
condition|(
operator|!
name|TARGET_COMPLEX_ADDR
operator|&&
operator|!
name|reload_completed
condition|)
return|return
literal|0
return|;
name|op0
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|REG
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|strict
condition|?
name|REG_OK_FOR_BASE_P_STRICT
argument_list|(
name|op0
argument_list|)
else|:
name|REG_OK_FOR_BASE_P
argument_list|(
name|op0
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|REG
condition|)
return|return
operator|(
name|strict
condition|?
name|REG_OK_FOR_INDEX_P_STRICT
argument_list|(
name|op1
argument_list|)
else|:
name|REG_OK_FOR_INDEX_P
argument_list|(
name|op1
argument_list|)
operator|)
return|;
elseif|else
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|op1
argument_list|)
condition|)
return|return
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|PLUS
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MULT
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|strict
condition|?
name|REG_OK_FOR_INDEX_P_STRICT
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
else|:
name|REG_OK_FOR_INDEX_P
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
operator|&&
name|SCALE_TERM_P
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
return|return
operator|(
operator|(
name|strict
condition|?
name|REG_OK_FOR_BASE_P_STRICT
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
else|:
name|REG_OK_FOR_BASE_P
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
operator|&&
name|CONSTANT_P
argument_list|(
name|op1
argument_list|)
operator|)
return|;
else|else
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|strict
condition|?
name|REG_OK_FOR_BASE_P_STRICT
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
else|:
name|REG_OK_FOR_BASE_P
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
return|return
operator|(
operator|(
name|strict
condition|?
name|REG_OK_FOR_INDEX_P_STRICT
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
else|:
name|REG_OK_FOR_INDEX_P
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
operator|&&
name|CONSTANT_P
argument_list|(
name|op1
argument_list|)
operator|)
return|;
else|else
return|return
literal|0
return|;
block|}
else|else
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|MULT
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|strict
condition|?
name|REG_OK_FOR_INDEX_P_STRICT
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
else|:
name|REG_OK_FOR_INDEX_P
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
operator|&&
name|SCALE_TERM_P
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|REG
condition|)
return|return
operator|(
name|strict
condition|?
name|REG_OK_FOR_BASE_P_STRICT
argument_list|(
name|op1
argument_list|)
else|:
name|REG_OK_FOR_BASE_P
argument_list|(
name|op1
argument_list|)
operator|)
return|;
elseif|else
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|op1
argument_list|)
condition|)
return|return
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
else|else
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|MULT
condition|)
block|{
if|if
condition|(
operator|!
name|TARGET_COMPLEX_ADDR
operator|&&
operator|!
name|reload_completed
condition|)
return|return
literal|0
return|;
return|return
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|strict
condition|?
name|REG_OK_FOR_INDEX_P_STRICT
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
else|:
name|REG_OK_FOR_INDEX_P
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
operator|&&
name|SCALE_TERM_P
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
return|;
block|}
else|else
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Try machine-dependent ways of modifying an illegitimate address    to be legitimate.  If we find one, return the new, valid address.    This macro is used in only one place: `memory_address' in explow.c.     This converts some non-canonical addresses to canonical form so they    can be recognized.  */
end_comment

begin_function
name|rtx
name|legitimize_address
parameter_list|(
name|x
parameter_list|,
name|oldx
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|x
decl_stmt|;
specifier|register
name|rtx
name|oldx
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SYMBOL_REF
condition|)
block|{
name|abort
argument_list|()
expr_stmt|;
name|x
operator|=
name|copy_to_reg
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|TARGET_COMPLEX_ADDR
operator|&&
operator|!
name|reload_completed
condition|)
return|return
name|x
return|;
comment|/* Canonicalize (plus (mult (reg) (const)) (plus (reg) (const)))      into (plus (plus (mult (reg) (const)) (reg)) (const)).  This can be      created by virtual register instantiation, register elimination, and      similar optimizations.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MULT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|PLUS
condition|)
name|x
operator|=
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|Pmode
argument_list|,
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|Pmode
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Canonicalize (plus (plus (mult (reg) (const)) (plus (reg) (const))) const)      into (plus (plus (mult (reg) (const)) (reg)) (const)).  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MULT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|rtx
name|constant
decl_stmt|,
name|other
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|constant
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|other
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|constant
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|other
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|constant
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|constant
condition|)
name|x
operator|=
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|Pmode
argument_list|,
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|Pmode
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|plus_constant
argument_list|(
name|other
argument_list|,
name|INTVAL
argument_list|(
name|constant
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|x
return|;
block|}
end_function

begin_escape
end_escape

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Return the most stringent alignment that we are willing to consider    objects of size SIZE and known alignment ALIGN as having. */
end_comment

begin_endif
unit|int i960_alignment (size, align)      int size;      int align; {   int i;    if (! TARGET_STRICT_ALIGN)     if (TARGET_IC_COMPAT2_0 || align>= 4)       { 	i = i960_object_bytes_bitalign (size) / BITS_PER_UNIT; 	if (i> align) 	  align = i;       }    return align; }
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Modes for condition codes.  */
end_comment

begin_define
define|#
directive|define
name|C_MODES
define|\
value|((1<< (int) CCmode) | (1<< (int) CC_UNSmode) | (1<< (int) CC_CHKmode))
end_define

begin_comment
comment|/* Modes for single-word (and smaller) quantities.  */
end_comment

begin_define
define|#
directive|define
name|S_MODES
define|\
value|(~C_MODES						\& ~ ((1<< (int) DImode) | (1<< (int) TImode)	\        | (1<< (int) DFmode) | (1<< (int) TFmode)))
end_define

begin_comment
comment|/* Modes for double-word (and smaller) quantities.  */
end_comment

begin_define
define|#
directive|define
name|D_MODES
define|\
value|(~C_MODES					\& ~ ((1<< (int) TImode) | (1<< (int) TFmode)))
end_define

begin_comment
comment|/* Modes for quad-word quantities.  */
end_comment

begin_define
define|#
directive|define
name|T_MODES
value|(~C_MODES)
end_define

begin_comment
comment|/* Modes for single-float quantities.  */
end_comment

begin_define
define|#
directive|define
name|SF_MODES
value|((1<< (int) SFmode))
end_define

begin_comment
comment|/* Modes for double-float quantities.  */
end_comment

begin_define
define|#
directive|define
name|DF_MODES
value|(SF_MODES | (1<< (int) DFmode) | (1<< (int) SCmode))
end_define

begin_comment
comment|/* Modes for quad-float quantities.  */
end_comment

begin_define
define|#
directive|define
name|TF_MODES
value|(DF_MODES | (1<< (int) TFmode) | (1<< (int) DCmode))
end_define

begin_decl_stmt
name|unsigned
name|int
name|hard_regno_mode_ok
index|[
name|FIRST_PSEUDO_REGISTER
index|]
init|=
block|{
name|T_MODES
block|,
name|S_MODES
block|,
name|D_MODES
block|,
name|S_MODES
block|,
name|T_MODES
block|,
name|S_MODES
block|,
name|D_MODES
block|,
name|S_MODES
block|,
name|T_MODES
block|,
name|S_MODES
block|,
name|D_MODES
block|,
name|S_MODES
block|,
name|T_MODES
block|,
name|S_MODES
block|,
name|D_MODES
block|,
name|S_MODES
block|,
name|T_MODES
block|,
name|S_MODES
block|,
name|D_MODES
block|,
name|S_MODES
block|,
name|T_MODES
block|,
name|S_MODES
block|,
name|D_MODES
block|,
name|S_MODES
block|,
name|T_MODES
block|,
name|S_MODES
block|,
name|D_MODES
block|,
name|S_MODES
block|,
name|T_MODES
block|,
name|S_MODES
block|,
name|D_MODES
block|,
name|S_MODES
block|,
name|TF_MODES
block|,
name|TF_MODES
block|,
name|TF_MODES
block|,
name|TF_MODES
block|,
name|C_MODES
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Return the minimum alignment of an expression rtx X in bytes.  This takes    advantage of machine specific facts, such as knowing that the frame pointer    is always 16 byte aligned.  */
end_comment

begin_function
name|int
name|i960_expr_alignment
parameter_list|(
name|x
parameter_list|,
name|size
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
name|int
name|align
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return
literal|1
return|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|CONST_INT
case|:
name|align
operator|=
name|INTVAL
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|align
operator|&
literal|0xf
operator|)
operator|==
literal|0
condition|)
name|align
operator|=
literal|16
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|align
operator|&
literal|0x7
operator|)
operator|==
literal|0
condition|)
name|align
operator|=
literal|8
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|align
operator|&
literal|0x3
operator|)
operator|==
literal|0
condition|)
name|align
operator|=
literal|4
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|align
operator|&
literal|0x1
operator|)
operator|==
literal|0
condition|)
name|align
operator|=
literal|2
expr_stmt|;
else|else
name|align
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|PLUS
case|:
name|align
operator|=
name|MIN
argument_list|(
name|i960_expr_alignment
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|size
argument_list|)
argument_list|,
name|i960_expr_alignment
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|size
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SYMBOL_REF
case|:
comment|/* If this is a valid program, objects are guaranteed to be 	 correctly aligned for whatever size the reference actually is. */
name|align
operator|=
name|i960_object_bytes_bitalign
argument_list|(
name|size
argument_list|)
operator|/
name|BITS_PER_UNIT
expr_stmt|;
break|break;
case|case
name|REG
case|:
if|if
condition|(
name|REGNO
argument_list|(
name|x
argument_list|)
operator|==
name|FRAME_POINTER_REGNUM
condition|)
name|align
operator|=
literal|16
expr_stmt|;
break|break;
case|case
name|ASHIFT
case|:
case|case
name|LSHIFT
case|:
name|align
operator|=
name|i960_expr_alignment
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|align
operator|=
name|align
operator|<<
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|align
operator|=
name|MIN
argument_list|(
name|align
argument_list|,
literal|16
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|MULT
case|:
name|align
operator|=
operator|(
name|i960_expr_alignment
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|size
argument_list|)
operator|*
name|i960_expr_alignment
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|size
argument_list|)
operator|)
expr_stmt|;
name|align
operator|=
name|MIN
argument_list|(
name|align
argument_list|,
literal|16
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|align
return|;
block|}
end_function

begin_comment
comment|/* Return true if it is possible to reference both BASE and OFFSET, which    have alignment at least as great as 4 byte, as if they had alignment valid    for an object of size SIZE.  */
end_comment

begin_function
name|int
name|i960_improve_align
parameter_list|(
name|base
parameter_list|,
name|offset
parameter_list|,
name|size
parameter_list|)
name|rtx
name|base
decl_stmt|;
name|rtx
name|offset
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
comment|/* We have at least a word reference to the object, so we know it has to      be aligned at least to 4 bytes.  */
name|i
operator|=
name|MIN
argument_list|(
name|i960_expr_alignment
argument_list|(
name|base
argument_list|,
literal|4
argument_list|)
argument_list|,
name|i960_expr_alignment
argument_list|(
name|offset
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|=
name|MAX
argument_list|(
name|i
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* We know the size of the request.  If strict align is not enabled, we      can guess that the alignment is OK for the requested size.  */
if|if
condition|(
operator|!
name|TARGET_STRICT_ALIGN
condition|)
if|if
condition|(
operator|(
name|j
operator|=
operator|(
name|i960_object_bytes_bitalign
argument_list|(
name|size
argument_list|)
operator|/
name|BITS_PER_UNIT
operator|)
operator|)
operator|>
name|i
condition|)
name|i
operator|=
name|j
expr_stmt|;
return|return
operator|(
name|i
operator|>=
name|size
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if it is possible to access BASE and OFFSET, which have 4 byte    (SImode) alignment as if they had 16 byte (TImode) alignment.  */
end_comment

begin_function
name|int
name|i960_si_ti
parameter_list|(
name|base
parameter_list|,
name|offset
parameter_list|)
name|rtx
name|base
decl_stmt|;
name|rtx
name|offset
decl_stmt|;
block|{
return|return
name|i960_improve_align
argument_list|(
name|base
argument_list|,
name|offset
argument_list|,
literal|16
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if it is possible to access BASE and OFFSET, which have 4 byte    (SImode) alignment as if they had 8 byte (DImode) alignment.  */
end_comment

begin_function
name|int
name|i960_si_di
parameter_list|(
name|base
parameter_list|,
name|offset
parameter_list|)
name|rtx
name|base
decl_stmt|;
name|rtx
name|offset
decl_stmt|;
block|{
return|return
name|i960_improve_align
argument_list|(
name|base
argument_list|,
name|offset
argument_list|,
literal|8
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return raw values of size and alignment (in words) for the data    type being accessed.  These values will be rounded by the caller.  */
end_comment

begin_function
specifier|static
name|void
name|i960_arg_size_and_align
parameter_list|(
name|mode
parameter_list|,
name|type
parameter_list|,
name|size_out
parameter_list|,
name|align_out
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|int
modifier|*
name|size_out
decl_stmt|;
name|int
modifier|*
name|align_out
decl_stmt|;
block|{
name|int
name|size
decl_stmt|,
name|align
decl_stmt|;
comment|/* Use formal alignment requirements of type being passed, except make      it at least a word.  If we don't have a type, this is a library call,      and the parm has to be of scalar type.  In this case, consider its      formal alignment requirement to be its size in words.  */
if|if
condition|(
name|mode
operator|==
name|BLKmode
condition|)
name|size
operator|=
operator|(
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
operator|+
name|UNITS_PER_WORD
operator|-
literal|1
operator|)
operator|/
name|UNITS_PER_WORD
expr_stmt|;
elseif|else
if|if
condition|(
name|mode
operator|==
name|VOIDmode
condition|)
block|{
comment|/* End of parm list.  */
name|assert
argument_list|(
name|type
operator|!=
literal|0
operator|&&
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|==
name|VOIDmode
argument_list|)
expr_stmt|;
name|size
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|size
operator|=
operator|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|+
name|UNITS_PER_WORD
operator|-
literal|1
operator|)
operator|/
name|UNITS_PER_WORD
expr_stmt|;
if|if
condition|(
name|type
operator|==
literal|0
condition|)
name|align
operator|=
name|size
expr_stmt|;
elseif|else
if|if
condition|(
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
operator|>=
name|BITS_PER_WORD
condition|)
name|align
operator|=
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
operator|/
name|BITS_PER_WORD
expr_stmt|;
else|else
name|align
operator|=
literal|1
expr_stmt|;
operator|*
name|size_out
operator|=
name|size
expr_stmt|;
operator|*
name|align_out
operator|=
name|align
expr_stmt|;
block|}
end_function

begin_comment
comment|/* On the 80960 the first 12 args are in registers and the rest are pushed.    Any arg that is bigger than 4 words is placed on the stack and all    subsequent arguments are placed on the stack.     Additionally, parameters with an alignment requirement stronger than    a word must be be aligned appropriately.  */
end_comment

begin_comment
comment|/* Update CUM to advance past an argument described by MODE and TYPE.  */
end_comment

begin_function
name|void
name|i960_function_arg_advance
parameter_list|(
name|cum
parameter_list|,
name|mode
parameter_list|,
name|type
parameter_list|,
name|named
parameter_list|)
name|CUMULATIVE_ARGS
modifier|*
name|cum
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|int
name|named
decl_stmt|;
block|{
name|int
name|size
decl_stmt|,
name|align
decl_stmt|;
name|i960_arg_size_and_align
argument_list|(
name|mode
argument_list|,
name|type
argument_list|,
operator|&
name|size
argument_list|,
operator|&
name|align
argument_list|)
expr_stmt|;
if|if
condition|(
name|named
operator|==
literal|0
operator|||
name|size
operator|>
literal|4
operator|||
name|cum
operator|->
name|ca_nstackparms
operator|!=
literal|0
operator|||
operator|(
name|size
operator|+
name|ROUND
argument_list|(
name|cum
operator|->
name|ca_nregparms
argument_list|,
name|align
argument_list|)
operator|)
operator|>
name|NPARM_REGS
operator|||
name|MUST_PASS_IN_STACK
argument_list|(
name|mode
argument_list|,
name|type
argument_list|)
condition|)
name|cum
operator|->
name|ca_nstackparms
operator|=
name|ROUND
argument_list|(
name|cum
operator|->
name|ca_nstackparms
argument_list|,
name|align
argument_list|)
operator|+
name|size
expr_stmt|;
else|else
name|cum
operator|->
name|ca_nregparms
operator|=
name|ROUND
argument_list|(
name|cum
operator|->
name|ca_nregparms
argument_list|,
name|align
argument_list|)
operator|+
name|size
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the register that the argument described by MODE and TYPE is    passed in, or else return 0 if it is passed on the stack.  */
end_comment

begin_function
name|rtx
name|i960_function_arg
parameter_list|(
name|cum
parameter_list|,
name|mode
parameter_list|,
name|type
parameter_list|,
name|named
parameter_list|)
name|CUMULATIVE_ARGS
modifier|*
name|cum
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|int
name|named
decl_stmt|;
block|{
name|rtx
name|ret
decl_stmt|;
name|int
name|size
decl_stmt|,
name|align
decl_stmt|;
name|i960_arg_size_and_align
argument_list|(
name|mode
argument_list|,
name|type
argument_list|,
operator|&
name|size
argument_list|,
operator|&
name|align
argument_list|)
expr_stmt|;
if|if
condition|(
name|named
operator|==
literal|0
operator|||
name|size
operator|>
literal|4
operator|||
name|cum
operator|->
name|ca_nstackparms
operator|!=
literal|0
operator|||
operator|(
name|size
operator|+
name|ROUND
argument_list|(
name|cum
operator|->
name|ca_nregparms
argument_list|,
name|align
argument_list|)
operator|)
operator|>
name|NPARM_REGS
operator|||
name|MUST_PASS_IN_STACK
argument_list|(
name|mode
argument_list|,
name|type
argument_list|)
condition|)
block|{
name|cum
operator|->
name|ca_nstackparms
operator|=
name|ROUND
argument_list|(
name|cum
operator|->
name|ca_nstackparms
argument_list|,
name|align
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|cum
operator|->
name|ca_nregparms
operator|=
name|ROUND
argument_list|(
name|cum
operator|->
name|ca_nregparms
argument_list|,
name|align
argument_list|)
expr_stmt|;
name|ret
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|mode
argument_list|,
name|cum
operator|->
name|ca_nregparms
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Floating-point support.  */
end_comment

begin_function
name|void
name|i960_output_double
parameter_list|(
name|file
parameter_list|,
name|value
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|double
name|value
decl_stmt|;
block|{
if|if
condition|(
name|REAL_VALUE_ISINF
argument_list|(
name|value
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.word	0\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.word	0x7ff00000	# Infinity\n"
argument_list|)
expr_stmt|;
block|}
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.double 0d%.17e\n"
argument_list|,
operator|(
name|value
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|i960_output_float
parameter_list|(
name|file
parameter_list|,
name|value
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|double
name|value
decl_stmt|;
block|{
if|if
condition|(
name|REAL_VALUE_ISINF
argument_list|(
name|value
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.word	0x7f800000	# Infinity\n"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.float 0f%.12e\n"
argument_list|,
operator|(
name|value
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the number of bits that an object of size N bytes is aligned to.  */
end_comment

begin_function
name|int
name|i960_object_bytes_bitalign
parameter_list|(
name|n
parameter_list|)
name|int
name|n
decl_stmt|;
block|{
if|if
condition|(
name|n
operator|>
literal|8
condition|)
name|n
operator|=
literal|128
expr_stmt|;
elseif|else
if|if
condition|(
name|n
operator|>
literal|4
condition|)
name|n
operator|=
literal|64
expr_stmt|;
elseif|else
if|if
condition|(
name|n
operator|>
literal|2
condition|)
name|n
operator|=
literal|32
expr_stmt|;
elseif|else
if|if
condition|(
name|n
operator|>
literal|1
condition|)
name|n
operator|=
literal|16
expr_stmt|;
else|else
name|n
operator|=
literal|8
expr_stmt|;
return|return
name|n
return|;
block|}
end_function

begin_comment
comment|/* Compute the size of an aggregate type TSIZE.  */
end_comment

begin_function
name|tree
name|i960_round_size
parameter_list|(
name|tsize
parameter_list|)
name|tree
name|tsize
decl_stmt|;
block|{
name|int
name|size
decl_stmt|,
name|byte_size
decl_stmt|,
name|align
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|tsize
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
return|return
name|tsize
return|;
name|size
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|tsize
argument_list|)
expr_stmt|;
name|byte_size
operator|=
operator|(
name|size
operator|+
name|BITS_PER_UNIT
operator|-
literal|1
operator|)
operator|/
name|BITS_PER_UNIT
expr_stmt|;
name|align
operator|=
name|i960_object_bytes_bitalign
argument_list|(
name|byte_size
argument_list|)
expr_stmt|;
comment|/* Handle #pragma align.  */
if|if
condition|(
name|align
operator|>
name|i960_maxbitalignment
condition|)
name|align
operator|=
name|i960_maxbitalignment
expr_stmt|;
if|if
condition|(
name|size
operator|%
name|align
condition|)
name|size
operator|=
operator|(
operator|(
name|size
operator|/
name|align
operator|)
operator|+
literal|1
operator|)
operator|*
name|align
expr_stmt|;
return|return
name|size_int
argument_list|(
name|size
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Compute the alignment for an aggregate type TSIZE.  */
end_comment

begin_function
name|int
name|i960_round_align
parameter_list|(
name|align
parameter_list|,
name|tsize
parameter_list|)
name|int
name|align
decl_stmt|;
name|tree
name|tsize
decl_stmt|;
block|{
name|int
name|byte_size
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|tsize
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
return|return
name|align
return|;
name|byte_size
operator|=
operator|(
name|TREE_INT_CST_LOW
argument_list|(
name|tsize
argument_list|)
operator|+
name|BITS_PER_UNIT
operator|-
literal|1
operator|)
operator|/
name|BITS_PER_UNIT
expr_stmt|;
name|align
operator|=
name|i960_object_bytes_bitalign
argument_list|(
name|byte_size
argument_list|)
expr_stmt|;
return|return
name|align
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Do any needed setup for a varargs function.  For the i960, we must    create a register parameter block if one doesn't exist, and then copy    all register parameters to memory.  */
end_comment

begin_function
name|void
name|i960_setup_incoming_varargs
parameter_list|(
name|cum
parameter_list|,
name|mode
parameter_list|,
name|type
parameter_list|,
name|pretend_size
parameter_list|,
name|no_rtl
parameter_list|)
name|CUMULATIVE_ARGS
modifier|*
name|cum
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|int
modifier|*
name|pretend_size
decl_stmt|;
name|int
name|no_rtl
decl_stmt|;
block|{
if|if
condition|(
name|cum
operator|->
name|ca_nregparms
operator|<
name|NPARM_REGS
condition|)
block|{
name|int
name|first_reg_offset
init|=
name|cum
operator|->
name|ca_nregparms
decl_stmt|;
if|if
condition|(
name|first_reg_offset
operator|>
name|NPARM_REGS
condition|)
name|first_reg_offset
operator|=
name|NPARM_REGS
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|no_rtl
operator|)
operator|&&
name|first_reg_offset
operator|!=
name|NPARM_REGS
condition|)
block|{
name|rtx
name|label
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
name|emit_insn
argument_list|(
name|gen_cmpsi
argument_list|(
name|arg_pointer_rtx
argument_list|,
name|const0_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|emit_jump_insn
argument_list|(
name|gen_bne
argument_list|(
name|label
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx
argument_list|(
name|SET
argument_list|,
name|VOIDmode
argument_list|,
name|arg_pointer_rtx
argument_list|,
name|stack_pointer_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx
argument_list|(
name|SET
argument_list|,
name|VOIDmode
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|memory_address
argument_list|(
name|SImode
argument_list|,
name|plus_constant
argument_list|(
name|stack_pointer_rtx
argument_list|,
literal|48
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|move_block_from_reg
argument_list|(
name|first_reg_offset
argument_list|,
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|BLKmode
argument_list|,
name|virtual_incoming_args_rtx
argument_list|)
argument_list|,
name|NPARM_REGS
operator|-
name|first_reg_offset
argument_list|)
expr_stmt|;
block|}
operator|*
name|pretend_size
operator|=
operator|(
name|NPARM_REGS
operator|-
name|first_reg_offset
operator|)
operator|*
name|UNITS_PER_WORD
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Calculate the final size of the reg parm stack space for the current    function, based on how many bytes would be allocated on the stack.  */
end_comment

begin_function
name|int
name|i960_final_reg_parm_stack_space
parameter_list|(
name|const_size
parameter_list|,
name|var_size
parameter_list|)
name|int
name|const_size
decl_stmt|;
name|tree
name|var_size
decl_stmt|;
block|{
if|if
condition|(
name|var_size
operator|||
name|const_size
operator|>
literal|48
condition|)
return|return
literal|48
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Calculate the size of the reg parm stack space.  This is a bit complicated    on the i960.  */
end_comment

begin_function
name|int
name|i960_reg_parm_stack_space
parameter_list|(
name|fndecl
parameter_list|)
name|tree
name|fndecl
decl_stmt|;
block|{
comment|/* In this case, we are called from emit_library_call, and we don't need      to pretend we have more space for parameters than what's apparent.  */
if|if
condition|(
name|fndecl
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* In this case, we are called from locate_and_pad_parms when we're      not IN_REGS, so we have an arg block.  */
if|if
condition|(
name|fndecl
operator|!=
name|current_function_decl
condition|)
return|return
literal|48
return|;
comment|/* Otherwise, we have an arg block if the current function has more than      48 bytes of parameters.  */
if|if
condition|(
name|current_function_args_size
operator|!=
literal|0
condition|)
return|return
literal|48
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the register class of a scratch register needed to copy IN into    or out of a register in CLASS in MODE.  If it can be done directly,    NO_REGS is returned.  */
end_comment

begin_function
name|enum
name|reg_class
name|secondary_reload_class
parameter_list|(
name|class
parameter_list|,
name|mode
parameter_list|,
name|in
parameter_list|)
name|enum
name|reg_class
name|class
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|in
decl_stmt|;
block|{
name|int
name|regno
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|in
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|in
argument_list|)
operator|==
name|SUBREG
condition|)
name|regno
operator|=
name|true_regnum
argument_list|(
name|in
argument_list|)
expr_stmt|;
comment|/* We can place anything into LOCAL_OR_GLOBAL_REGS and can put      LOCAL_OR_GLOBAL_REGS into anything.  */
if|if
condition|(
name|class
operator|==
name|LOCAL_OR_GLOBAL_REGS
operator|||
name|class
operator|==
name|LOCAL_REGS
operator|||
name|class
operator|==
name|GLOBAL_REGS
operator|||
operator|(
name|regno
operator|>=
literal|0
operator|&&
name|regno
operator|<
literal|32
operator|)
condition|)
return|return
name|NO_REGS
return|;
comment|/* We can place any hard register, 0.0, and 1.0 into FP_REGS.  */
if|if
condition|(
name|class
operator|==
name|FP_REGS
operator|&&
operator|(
operator|(
name|regno
operator|>=
literal|0
operator|&&
name|regno
operator|<=
name|FIRST_PSEUDO_REGISTER
operator|)
operator|||
name|in
operator|==
name|CONST0_RTX
argument_list|(
name|mode
argument_list|)
operator|||
name|in
operator|==
name|CONST1_RTX
argument_list|(
name|mode
argument_list|)
operator|)
condition|)
return|return
name|NO_REGS
return|;
return|return
name|LOCAL_OR_GLOBAL_REGS
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Look at the opcode P, and set i96_last_insn_type to indicate which    function unit it executed on.  */
end_comment

begin_comment
comment|/* ??? This would make more sense as an attribute.  */
end_comment

begin_function
name|void
name|i960_scan_opcode
parameter_list|(
name|p
parameter_list|)
name|char
modifier|*
name|p
decl_stmt|;
block|{
switch|switch
condition|(
operator|*
name|p
condition|)
block|{
case|case
literal|'a'
case|:
case|case
literal|'d'
case|:
case|case
literal|'e'
case|:
case|case
literal|'m'
case|:
case|case
literal|'n'
case|:
case|case
literal|'o'
case|:
case|case
literal|'r'
case|:
comment|/* Ret is not actually of type REG, but it won't matter, because no 	 insn will ever follow it.  */
case|case
literal|'u'
case|:
case|case
literal|'x'
case|:
name|i960_last_insn_type
operator|=
name|I_TYPE_REG
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|'x'
operator|||
name|p
index|[
literal|3
index|]
operator|==
literal|'x'
condition|)
name|i960_last_insn_type
operator|=
name|I_TYPE_MEM
expr_stmt|;
name|i960_last_insn_type
operator|=
name|I_TYPE_CTRL
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
case|case
literal|'t'
case|:
name|i960_last_insn_type
operator|=
name|I_TYPE_CTRL
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|'a'
condition|)
block|{
if|if
condition|(
name|p
index|[
literal|4
index|]
operator|==
literal|'x'
condition|)
name|i960_last_insn_type
operator|=
name|I_TYPE_MEM
expr_stmt|;
else|else
name|i960_last_insn_type
operator|=
name|I_TYPE_CTRL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|'m'
condition|)
block|{
if|if
condition|(
name|p
index|[
literal|3
index|]
operator|==
literal|'d'
condition|)
name|i960_last_insn_type
operator|=
name|I_TYPE_REG
expr_stmt|;
elseif|else
if|if
condition|(
name|p
index|[
literal|4
index|]
operator|==
literal|'b'
operator|||
name|p
index|[
literal|4
index|]
operator|==
literal|'j'
condition|)
name|i960_last_insn_type
operator|=
name|I_TYPE_CTRL
expr_stmt|;
else|else
name|i960_last_insn_type
operator|=
name|I_TYPE_REG
expr_stmt|;
block|}
else|else
name|i960_last_insn_type
operator|=
name|I_TYPE_REG
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|i960_last_insn_type
operator|=
name|I_TYPE_MEM
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|'t'
condition|)
name|i960_last_insn_type
operator|=
name|I_TYPE_MEM
expr_stmt|;
else|else
name|i960_last_insn_type
operator|=
name|I_TYPE_REG
expr_stmt|;
break|break;
block|}
block|}
end_function

end_unit

