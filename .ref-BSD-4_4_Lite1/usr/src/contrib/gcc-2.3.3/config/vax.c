begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Subroutines for insn-output.c for Vax.    Copyright (C) 1987 Free Software Foundation, Inc.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"conditions.h"
end_include

begin_include
include|#
directive|include
file|"insn-flags.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"insn-attr.h"
end_include

begin_comment
comment|/* This is like nonimmediate_operand with a restriction on the type of MEM.  */
end_comment

begin_function
name|void
name|split_quadword_operands
parameter_list|(
name|operands
parameter_list|,
name|low
parameter_list|,
name|n
parameter_list|)
name|rtx
modifier|*
name|operands
decl_stmt|,
decl|*
name|low
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
comment|/* Split operands.  */
name|low
index|[
literal|0
index|]
operator|=
name|low
index|[
literal|1
index|]
operator|=
name|low
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|low
index|[
name|i
index|]
condition|)
comment|/* it's already been figured out */
empty_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
name|i
index|]
argument_list|)
operator|==
name|MEM
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|POST_INC
operator|)
condition|)
block|{
name|rtx
name|addr
init|=
name|XEXP
argument_list|(
name|operands
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|operands
index|[
name|i
index|]
operator|=
name|low
index|[
name|i
index|]
operator|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|SImode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|which_alternative
operator|==
literal|0
operator|&&
name|i
operator|==
literal|0
condition|)
block|{
name|addr
operator|=
name|XEXP
argument_list|(
name|operands
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|operands
index|[
name|i
operator|+
literal|1
index|]
operator|=
name|low
index|[
name|i
operator|+
literal|1
index|]
operator|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|SImode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|low
index|[
name|i
index|]
operator|=
name|operand_subword
argument_list|(
name|operands
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|DImode
argument_list|)
expr_stmt|;
name|operands
index|[
name|i
index|]
operator|=
name|operand_subword
argument_list|(
name|operands
index|[
name|i
index|]
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|DImode
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_escape
end_escape

begin_macro
name|print_operand_address
argument_list|(
argument|file
argument_list|,
argument|addr
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|rtx
name|addr
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|rtx
name|reg1
decl_stmt|,
name|reg2
decl_stmt|,
name|breg
decl_stmt|,
name|ireg
decl_stmt|;
name|rtx
name|offset
decl_stmt|;
name|retry
label|:
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
condition|)
block|{
case|case
name|MEM
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"*"
argument_list|)
expr_stmt|;
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|retry
goto|;
case|case
name|REG
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"(%s)"
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|addr
argument_list|)
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|PRE_DEC
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"-(%s)"
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|POST_INC
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"(%s)+"
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|PLUS
case|:
comment|/* There can be either two or three things added here.  One must be a 	 REG.  One can be either a REG or a MULT of a REG and an appropriate 	 constant, and the third can only be a constant or a MEM.  	 We get these two or three things and put the constant or MEM in 	 OFFSET, the MULT or REG in IREG, and the REG in BREG.  If we have 	 a register and can't tell yet if it is a base or index register, 	 put it into REG1.  */
name|reg1
operator|=
literal|0
expr_stmt|;
name|ireg
operator|=
literal|0
expr_stmt|;
name|breg
operator|=
literal|0
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|CONSTANT_ADDRESS_P
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MEM
condition|)
block|{
name|offset
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CONSTANT_ADDRESS_P
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|MEM
condition|)
block|{
name|offset
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|MULT
condition|)
block|{
name|ireg
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MULT
condition|)
block|{
name|ireg
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
name|reg1
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
name|reg1
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|REG
condition|)
block|{
if|if
condition|(
name|reg1
condition|)
name|ireg
operator|=
name|addr
expr_stmt|;
else|else
name|reg1
operator|=
name|addr
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|MULT
condition|)
name|ireg
operator|=
name|addr
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|PLUS
condition|)
block|{
if|if
condition|(
name|CONSTANT_ADDRESS_P
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MEM
condition|)
block|{
if|if
condition|(
name|offset
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|offset
argument_list|)
operator|==
name|CONST_INT
condition|)
name|offset
operator|=
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|,
name|INTVAL
argument_list|(
name|offset
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
name|offset
operator|=
name|plus_constant
argument_list|(
name|offset
argument_list|,
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
name|offset
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
if|if
condition|(
name|reg1
condition|)
name|ireg
operator|=
name|reg1
operator|,
name|breg
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
operator|,
name|reg1
operator|=
literal|0
expr_stmt|;
else|else
name|reg1
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MULT
condition|)
block|{
if|if
condition|(
name|ireg
condition|)
name|abort
argument_list|()
expr_stmt|;
name|ireg
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|CONSTANT_ADDRESS_P
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|MEM
condition|)
block|{
if|if
condition|(
name|offset
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|offset
argument_list|)
operator|==
name|CONST_INT
condition|)
name|offset
operator|=
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|,
name|INTVAL
argument_list|(
name|offset
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
name|offset
operator|=
name|plus_constant
argument_list|(
name|offset
argument_list|,
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
name|offset
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
if|if
condition|(
name|reg1
condition|)
name|ireg
operator|=
name|reg1
operator|,
name|breg
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
operator|,
name|reg1
operator|=
literal|0
expr_stmt|;
else|else
name|reg1
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|MULT
condition|)
block|{
if|if
condition|(
name|ireg
condition|)
name|abort
argument_list|()
expr_stmt|;
name|ireg
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
comment|/* If REG1 is non-zero, figure out if it is a base or index register.  */
if|if
condition|(
name|reg1
condition|)
block|{
if|if
condition|(
name|breg
operator|!=
literal|0
operator|||
operator|(
name|offset
operator|&&
name|GET_CODE
argument_list|(
name|offset
argument_list|)
operator|==
name|MEM
operator|)
condition|)
block|{
if|if
condition|(
name|ireg
condition|)
name|abort
argument_list|()
expr_stmt|;
name|ireg
operator|=
name|reg1
expr_stmt|;
block|}
else|else
name|breg
operator|=
name|reg1
expr_stmt|;
block|}
if|if
condition|(
name|offset
operator|!=
literal|0
condition|)
name|output_address
argument_list|(
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|breg
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"(%s)"
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|breg
argument_list|)
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ireg
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|ireg
argument_list|)
operator|==
name|MULT
condition|)
name|ireg
operator|=
name|XEXP
argument_list|(
name|ireg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|ireg
argument_list|)
operator|!=
name|REG
condition|)
name|abort
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"[%s]"
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|ireg
argument_list|)
index|]
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_function
name|char
modifier|*
name|rev_cond_name
parameter_list|(
name|op
parameter_list|)
name|rtx
name|op
decl_stmt|;
block|{
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
condition|)
block|{
case|case
name|EQ
case|:
return|return
literal|"neq"
return|;
case|case
name|NE
case|:
return|return
literal|"eql"
return|;
case|case
name|LT
case|:
return|return
literal|"geq"
return|;
case|case
name|LE
case|:
return|return
literal|"gtr"
return|;
case|case
name|GT
case|:
return|return
literal|"leq"
return|;
case|case
name|GE
case|:
return|return
literal|"lss"
return|;
case|case
name|LTU
case|:
return|return
literal|"gequ"
return|;
case|case
name|LEU
case|:
return|return
literal|"gtru"
return|;
case|case
name|GTU
case|:
return|return
literal|"lequ"
return|;
case|case
name|GEU
case|:
return|return
literal|"lssu"
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|vax_float_literal
parameter_list|(
name|c
parameter_list|)
specifier|register
name|rtx
name|c
decl_stmt|;
block|{
specifier|register
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|i
decl_stmt|;
union|union
block|{
name|double
name|d
decl_stmt|;
name|int
name|i
index|[
literal|2
index|]
decl_stmt|;
block|}
name|val
union|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|c
argument_list|)
operator|!=
name|CONST_DOUBLE
condition|)
return|return
literal|0
return|;
name|mode
operator|=
name|GET_MODE
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|const_tiny_rtx
index|[
operator|(
name|int
operator|)
name|mode
index|]
index|[
literal|0
index|]
operator|||
name|c
operator|==
name|const_tiny_rtx
index|[
operator|(
name|int
operator|)
name|mode
index|]
index|[
literal|1
index|]
operator|||
name|c
operator|==
name|const_tiny_rtx
index|[
operator|(
name|int
operator|)
name|mode
index|]
index|[
literal|2
index|]
condition|)
return|return
literal|1
return|;
if|#
directive|if
name|HOST_FLOAT_FORMAT
operator|==
name|VAX_FLOAT_FORMAT
name|val
operator|.
name|i
index|[
literal|0
index|]
operator|=
name|CONST_DOUBLE_LOW
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|val
operator|.
name|i
index|[
literal|1
index|]
operator|=
name|CONST_DOUBLE_HIGH
argument_list|(
name|c
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|7
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|val
operator|.
name|d
operator|==
literal|1
operator|<<
name|i
operator|||
name|val
operator|.
name|d
operator|==
literal|1
operator|/
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
return|return
literal|1
return|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return the cost in cycles of a memory address, relative to register    indirect.     Each of the following adds the indicated number of cycles:     1 - symbolic address    1 - pre-decrement    1 - indexing and/or offset(register)    2 - indirect */
end_comment

begin_function
name|int
name|vax_address_cost
parameter_list|(
name|addr
parameter_list|)
specifier|register
name|rtx
name|addr
decl_stmt|;
block|{
name|int
name|reg
init|=
literal|0
decl_stmt|,
name|indexed
init|=
literal|0
decl_stmt|,
name|indir
init|=
literal|0
decl_stmt|,
name|offset
init|=
literal|0
decl_stmt|,
name|predec
init|=
literal|0
decl_stmt|;
name|rtx
name|plus_op0
init|=
literal|0
decl_stmt|,
name|plus_op1
init|=
literal|0
decl_stmt|;
name|restart
label|:
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
condition|)
block|{
case|case
name|PRE_DEC
case|:
name|predec
operator|=
literal|1
expr_stmt|;
case|case
name|REG
case|:
case|case
name|SUBREG
case|:
case|case
name|POST_INC
case|:
name|reg
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|MULT
case|:
name|indexed
operator|=
literal|1
expr_stmt|;
comment|/* 2 on VAX 2 */
break|break;
case|case
name|CONST_INT
case|:
comment|/* byte offsets cost nothing (on a VAX 2, they cost 1 cycle) */
if|if
condition|(
name|offset
operator|==
literal|0
condition|)
name|offset
operator|=
call|(
name|unsigned
call|)
argument_list|(
name|INTVAL
argument_list|(
name|addr
argument_list|)
operator|+
literal|128
argument_list|)
operator|>
literal|256
expr_stmt|;
break|break;
case|case
name|CONST
case|:
case|case
name|SYMBOL_REF
case|:
name|offset
operator|=
literal|1
expr_stmt|;
comment|/* 2 on VAX 2 */
break|break;
case|case
name|LABEL_REF
case|:
comment|/* this is probably a byte offset from the pc */
if|if
condition|(
name|offset
operator|==
literal|0
condition|)
name|offset
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|PLUS
case|:
if|if
condition|(
name|plus_op0
condition|)
name|plus_op1
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|plus_op0
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|restart
goto|;
case|case
name|MEM
case|:
name|indir
operator|=
literal|2
expr_stmt|;
comment|/* 3 on VAX 2 */
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|restart
goto|;
block|}
comment|/* Up to 3 things can be added in an address.  They are stored in      plus_op0, plus_op1, and addr.  */
if|if
condition|(
name|plus_op0
condition|)
block|{
name|addr
operator|=
name|plus_op0
expr_stmt|;
name|plus_op0
operator|=
literal|0
expr_stmt|;
goto|goto
name|restart
goto|;
block|}
if|if
condition|(
name|plus_op1
condition|)
block|{
name|addr
operator|=
name|plus_op1
expr_stmt|;
name|plus_op1
operator|=
literal|0
expr_stmt|;
goto|goto
name|restart
goto|;
block|}
comment|/* Indexing and register+offset can both be used (except on a VAX 2)      without increasing execution time over either one alone. */
if|if
condition|(
name|reg
operator|&&
name|indexed
operator|&&
name|offset
condition|)
return|return
name|reg
operator|+
name|indir
operator|+
name|offset
operator|+
name|predec
return|;
return|return
name|reg
operator|+
name|indexed
operator|+
name|indir
operator|+
name|offset
operator|+
name|predec
return|;
block|}
end_function

begin_comment
comment|/* Cost of an expression on a VAX.  This version has costs tuned for the    CVAX chip (found in the VAX 3 series) with comments for variations on    other models.  */
end_comment

begin_function
name|int
name|vax_rtx_cost
parameter_list|(
name|x
parameter_list|)
specifier|register
name|rtx
name|x
decl_stmt|;
block|{
specifier|register
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
comment|/* may be modified in switch */
name|char
modifier|*
name|fmt
init|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
decl_stmt|;
comment|/* may be modified in switch */
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|POST_INC
case|:
return|return
literal|2
return|;
case|case
name|PRE_DEC
case|:
return|return
literal|3
return|;
case|case
name|MULT
case|:
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|DFmode
case|:
name|c
operator|=
literal|16
expr_stmt|;
comment|/* 4 on VAX 9000 */
break|break;
case|case
name|SFmode
case|:
name|c
operator|=
literal|9
expr_stmt|;
comment|/* 4 on VAX 9000, 12 on VAX 2 */
break|break;
case|case
name|DImode
case|:
name|c
operator|=
literal|16
expr_stmt|;
comment|/* 6 on VAX 9000, 28 on VAX 2 */
break|break;
case|case
name|SImode
case|:
case|case
name|HImode
case|:
case|case
name|QImode
case|:
name|c
operator|=
literal|10
expr_stmt|;
comment|/* 3-4 on VAX 9000, 20-28 on VAX 2 */
break|break;
block|}
break|break;
case|case
name|UDIV
case|:
name|c
operator|=
literal|17
expr_stmt|;
break|break;
case|case
name|DIV
case|:
if|if
condition|(
name|mode
operator|==
name|DImode
condition|)
name|c
operator|=
literal|30
expr_stmt|;
comment|/* highly variable */
elseif|else
if|if
condition|(
name|mode
operator|==
name|DFmode
condition|)
comment|/* divide takes 28 cycles if the result is not zero, 13 otherwise */
name|c
operator|=
literal|24
expr_stmt|;
else|else
name|c
operator|=
literal|11
expr_stmt|;
comment|/* 25 on VAX 2 */
break|break;
case|case
name|MOD
case|:
name|c
operator|=
literal|23
expr_stmt|;
break|break;
case|case
name|UMOD
case|:
name|c
operator|=
literal|29
expr_stmt|;
break|break;
case|case
name|FLOAT
case|:
name|c
operator|=
literal|6
operator|+
operator|(
name|mode
operator|==
name|DFmode
operator|)
operator|+
operator|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|SImode
operator|)
expr_stmt|;
comment|/* 4 on VAX 9000 */
break|break;
case|case
name|FIX
case|:
name|c
operator|=
literal|7
expr_stmt|;
comment|/* 17 on VAX 2 */
break|break;
case|case
name|LSHIFT
case|:
case|case
name|ASHIFT
case|:
case|case
name|LSHIFTRT
case|:
case|case
name|ASHIFTRT
case|:
if|if
condition|(
name|mode
operator|==
name|DImode
condition|)
name|c
operator|=
literal|12
expr_stmt|;
else|else
name|c
operator|=
literal|10
expr_stmt|;
comment|/* 6 on VAX 9000 */
break|break;
case|case
name|ROTATE
case|:
case|case
name|ROTATERT
case|:
name|c
operator|=
literal|6
expr_stmt|;
comment|/* 5 on VAX 2, 4 on VAX 9000 */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
name|fmt
operator|=
literal|"e"
expr_stmt|;
comment|/* all constant rotate counts are short */
break|break;
case|case
name|PLUS
case|:
comment|/* Check for small negative integer operand: subl2 can be used with 	 a short positive constant instead.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
if|if
condition|(
call|(
name|unsigned
call|)
argument_list|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|+
literal|63
argument_list|)
operator|<
literal|127
condition|)
name|fmt
operator|=
literal|"e"
expr_stmt|;
case|case
name|MINUS
case|:
name|c
operator|=
operator|(
name|mode
operator|==
name|DFmode
operator|)
condition|?
literal|13
else|:
literal|8
expr_stmt|;
comment|/* 6/8 on VAX 9000, 16/15 on VAX 2 */
case|case
name|IOR
case|:
case|case
name|XOR
case|:
name|c
operator|=
literal|3
expr_stmt|;
break|break;
case|case
name|AND
case|:
comment|/* AND is special because the first operand is complemented. */
name|c
operator|=
literal|3
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
if|if
condition|(
operator|(
name|unsigned
operator|)
operator|~
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|>
literal|63
condition|)
name|c
operator|=
literal|4
expr_stmt|;
name|fmt
operator|=
literal|"e"
expr_stmt|;
name|i
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|NEG
case|:
if|if
condition|(
name|mode
operator|==
name|DFmode
condition|)
return|return
literal|9
return|;
elseif|else
if|if
condition|(
name|mode
operator|==
name|SFmode
condition|)
return|return
literal|6
return|;
elseif|else
if|if
condition|(
name|mode
operator|==
name|DImode
condition|)
return|return
literal|4
return|;
case|case
name|NOT
case|:
return|return
literal|2
return|;
case|case
name|ZERO_EXTRACT
case|:
case|case
name|SIGN_EXTRACT
case|:
name|c
operator|=
literal|15
expr_stmt|;
break|break;
case|case
name|MEM
case|:
if|if
condition|(
name|mode
operator|==
name|DImode
operator|||
name|mode
operator|==
name|DFmode
condition|)
name|c
operator|=
literal|5
expr_stmt|;
comment|/* 7 on VAX 2 */
else|else
name|c
operator|=
literal|3
expr_stmt|;
comment|/* 4 on VAX 2 */
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|POST_INC
condition|)
return|return
name|c
return|;
return|return
name|c
operator|+
name|vax_address_cost
argument_list|(
name|x
argument_list|)
return|;
default|default:
name|c
operator|=
literal|3
expr_stmt|;
break|break;
block|}
comment|/* Now look inside the expression.  Operands which are not registers or      short constants add to the cost.       FMT and I may have been adjusted in the switch above for instructions      which require special handling */
while|while
condition|(
operator|*
name|fmt
operator|++
operator|==
literal|'e'
condition|)
block|{
specifier|register
name|rtx
name|op
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
operator|++
argument_list|)
decl_stmt|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|op
argument_list|)
expr_stmt|;
comment|/* A NOT is likely to be found as the first operand of an AND 	 (in which case the relevant cost is of the operand inside 	 the not) and not likely to be found anywhere else.  */
if|if
condition|(
name|code
operator|==
name|NOT
condition|)
name|op
operator|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
operator|,
name|code
operator|=
name|GET_CODE
argument_list|(
name|op
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|CONST_INT
case|:
if|if
condition|(
operator|(
name|unsigned
operator|)
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|>
literal|63
operator|&&
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|!=
name|QImode
condition|)
name|c
operator|+=
literal|1
expr_stmt|;
comment|/* 2 on VAX 2 */
break|break;
case|case
name|CONST
case|:
case|case
name|LABEL_REF
case|:
case|case
name|SYMBOL_REF
case|:
name|c
operator|+=
literal|1
expr_stmt|;
comment|/* 2 on VAX 2 */
break|break;
case|case
name|CONST_DOUBLE
case|:
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
argument_list|)
operator|==
name|MODE_FLOAT
condition|)
block|{
comment|/* Registers are faster than floating point constants -- even 		 those constants which can be encoded in a single byte.  */
if|if
condition|(
name|vax_float_literal
argument_list|(
name|op
argument_list|)
condition|)
name|c
operator|++
expr_stmt|;
else|else
name|c
operator|+=
operator|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|DFmode
operator|)
condition|?
literal|3
else|:
literal|2
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|CONST_DOUBLE_HIGH
argument_list|(
name|op
argument_list|)
operator|!=
literal|0
operator|||
operator|(
name|unsigned
operator|)
name|CONST_DOUBLE_LOW
argument_list|(
name|op
argument_list|)
operator|>
literal|63
condition|)
name|c
operator|+=
literal|2
expr_stmt|;
block|}
break|break;
case|case
name|MEM
case|:
name|c
operator|+=
literal|1
expr_stmt|;
comment|/* 2 on VAX 2 */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|REG
condition|)
name|c
operator|+=
name|vax_address_cost
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|REG
case|:
case|case
name|SUBREG
case|:
break|break;
default|default:
name|c
operator|+=
literal|1
expr_stmt|;
break|break;
block|}
block|}
return|return
name|c
return|;
block|}
end_function

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|VMS
end_ifdef

begin_comment
comment|/* Additional support code for VMS. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|QSORT_WORKAROUND
end_ifdef

begin_comment
comment|/* 	Do not use VAXCRTL's qsort() due to a severe bug:  once you've 	sorted something which has a size that's an exact multiple of 4 	and is longword aligned, you cannot safely sort anything which 	is either not a multiple of 4 in size or not longword aligned. 	A static "move-by-longword" optimization flag inside qsort() is 	never reset.  This is known of affect VMS V4.6 through VMS V5.5-1.  	In this work-around an insertion sort is used for simplicity. 	The qsort code from glibc should probably be used instead.    */
end_comment

begin_decl_stmt
name|void
name|not_qsort
argument_list|(
name|array
argument_list|,
name|count
argument_list|,
name|size
argument_list|,
name|compare
argument_list|)
name|void
modifier|*
name|array
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|count
decl_stmt|,
name|size
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
function_decl|(
modifier|*
name|compare
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_block
block|{
if|if
condition|(
name|size
operator|==
sizeof|sizeof
argument_list|(
name|short
argument_list|)
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|short
modifier|*
name|next
decl_stmt|,
modifier|*
name|prev
decl_stmt|;
name|short
name|tmp
decl_stmt|,
modifier|*
name|base
init|=
name|array
decl_stmt|;
for|for
control|(
name|next
operator|=
name|base
operator|,
name|i
operator|=
name|count
operator|-
literal|1
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|prev
operator|=
name|next
operator|++
expr_stmt|;
if|if
condition|(
call|(
modifier|*
name|compare
call|)
argument_list|(
name|next
argument_list|,
name|prev
argument_list|)
operator|<
literal|0
condition|)
block|{
name|tmp
operator|=
operator|*
name|next
expr_stmt|;
do|do
operator|*
operator|(
name|prev
operator|+
literal|1
operator|)
operator|=
operator|*
name|prev
expr_stmt|;
do|while
condition|(
operator|--
name|prev
operator|>=
name|base
condition|?
call|(
modifier|*
name|compare
call|)
argument_list|(
operator|&
name|tmp
argument_list|,
name|prev
argument_list|)
operator|<
literal|0
else|:
literal|0
condition|)
do|;
operator|*
operator|(
name|prev
operator|+
literal|1
operator|)
operator|=
name|tmp
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|size
operator|==
sizeof|sizeof
argument_list|(
name|long
argument_list|)
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|long
modifier|*
name|next
decl_stmt|,
modifier|*
name|prev
decl_stmt|;
name|long
name|tmp
decl_stmt|,
modifier|*
name|base
init|=
name|array
decl_stmt|;
for|for
control|(
name|next
operator|=
name|base
operator|,
name|i
operator|=
name|count
operator|-
literal|1
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|prev
operator|=
name|next
operator|++
expr_stmt|;
if|if
condition|(
call|(
modifier|*
name|compare
call|)
argument_list|(
name|next
argument_list|,
name|prev
argument_list|)
operator|<
literal|0
condition|)
block|{
name|tmp
operator|=
operator|*
name|next
expr_stmt|;
do|do
operator|*
operator|(
name|prev
operator|+
literal|1
operator|)
operator|=
operator|*
name|prev
expr_stmt|;
do|while
condition|(
operator|--
name|prev
operator|>=
name|base
condition|?
call|(
modifier|*
name|compare
call|)
argument_list|(
operator|&
name|tmp
argument_list|,
name|prev
argument_list|)
operator|<
literal|0
else|:
literal|0
condition|)
do|;
operator|*
operator|(
name|prev
operator|+
literal|1
operator|)
operator|=
name|tmp
expr_stmt|;
block|}
block|}
block|}
else|else
comment|/* arbitrary size */
block|{
ifdef|#
directive|ifdef
name|USE_C_ALLOCA
specifier|extern
name|void
modifier|*
name|alloca
parameter_list|()
function_decl|;
endif|#
directive|endif
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|next
decl_stmt|,
modifier|*
name|prev
decl_stmt|,
modifier|*
name|tmp
init|=
name|alloca
argument_list|(
name|size
argument_list|)
decl_stmt|,
modifier|*
name|base
init|=
name|array
decl_stmt|;
for|for
control|(
name|next
operator|=
name|base
operator|,
name|i
operator|=
name|count
operator|-
literal|1
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
comment|/* count-1 forward iterations */
name|prev
operator|=
name|next
operator|,
name|next
operator|+=
name|size
expr_stmt|;
comment|/* increment front pointer */
if|if
condition|(
call|(
modifier|*
name|compare
call|)
argument_list|(
name|next
argument_list|,
name|prev
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* found element out of order; move others up then re-insert */
name|memcpy
argument_list|(
name|tmp
argument_list|,
name|next
argument_list|,
name|size
argument_list|)
expr_stmt|;
comment|/* save smaller element */
do|do
block|{
name|memcpy
argument_list|(
name|prev
operator|+
name|size
argument_list|,
name|prev
argument_list|,
name|size
argument_list|)
expr_stmt|;
comment|/* move larger elem. up */
name|prev
operator|-=
name|size
expr_stmt|;
comment|/* decrement back pointer */
block|}
do|while
condition|(
name|prev
operator|>=
name|base
condition|?
call|(
modifier|*
name|compare
call|)
argument_list|(
name|tmp
argument_list|,
name|prev
argument_list|)
operator|<
literal|0
else|:
literal|0
condition|)
do|;
name|memcpy
argument_list|(
name|prev
operator|+
name|size
argument_list|,
name|tmp
argument_list|,
name|size
argument_list|)
expr_stmt|;
comment|/* restore small element */
block|}
block|}
ifdef|#
directive|ifdef
name|USE_C_ALLOCA
name|alloca
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
return|return;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* QSORT_WORKAROUND */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* VMS */
end_comment

end_unit

