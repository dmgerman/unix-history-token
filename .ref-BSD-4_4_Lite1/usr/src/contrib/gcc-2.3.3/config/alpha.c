begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Subroutines used for code generation on the DEC Alpha.    Copyright (C) 1992 Free Software Foundation, Inc.    Contributed by Richard Kenner (kenner@nyu.edu)  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"conditions.h"
end_include

begin_include
include|#
directive|include
file|"insn-flags.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"insn-attr.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"reload.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_comment
comment|/* Save information from a "cmpxx" operation until the branch or scc is    emitted.  */
end_comment

begin_decl_stmt
name|rtx
name|alpha_compare_op0
decl_stmt|,
name|alpha_compare_op1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|alpha_compare_fp_p
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Save the name of the current function as used by the assembler.  This    is used by the epilogue.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|alpha_function_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if the current function needs gp.  */
end_comment

begin_decl_stmt
name|int
name|alpha_function_needs_gp
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Returns 1 if VALUE is a mask that contains full bytes of zero or ones.  */
end_comment

begin_function
name|int
name|zap_mask
parameter_list|(
name|value
parameter_list|)
name|HOST_WIDE_INT
name|value
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HOST_BITS_PER_WIDE_INT
operator|/
name|HOST_BITS_PER_CHAR
condition|;
name|i
operator|++
operator|,
name|value
operator|>>=
literal|8
control|)
if|if
condition|(
operator|(
name|value
operator|&
literal|0xff
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|value
operator|&
literal|0xff
operator|)
operator|!=
literal|0xff
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Returns 1 if OP is either the constant zero or a register.  If a    register, it must be in the proper mode unless MODE is VOIDmode.  */
end_comment

begin_function
name|int
name|reg_or_0_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
name|op
operator|==
name|const0_rtx
operator|||
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is an 8-bit constant or any register.  */
end_comment

begin_function
name|int
name|reg_or_8bit_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|<
literal|0x100
operator|)
operator|||
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if the operand is a valid second operand to an add insn.  */
end_comment

begin_function
name|int
name|add_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
operator|(
call|(
name|unsigned
name|HOST_WIDE_INT
call|)
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|+
literal|0x8000
argument_list|)
operator|<
literal|0x10000
operator|||
operator|(
operator|(
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|&
literal|0xffff
operator|)
operator|==
literal|0
operator|&&
operator|(
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|>>
literal|31
operator|==
operator|-
literal|1
operator|||
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|>>
literal|31
operator|==
literal|0
operator|)
operator|)
operator|)
return|;
return|return
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if the operand is a valid second operand to a sign-extending    add insn.  */
end_comment

begin_function
name|int
name|sext_add_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|<
literal|255
operator|||
call|(
name|unsigned
name|HOST_WIDE_INT
call|)
argument_list|(
operator|-
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|)
operator|<
literal|255
operator|)
return|;
return|return
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is the constant 4 or 8.  */
end_comment

begin_function
name|int
name|const48_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|==
literal|4
operator|||
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|==
literal|8
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a valid first operand to an AND insn.  */
end_comment

begin_function
name|int
name|and_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|VOIDmode
condition|)
return|return
operator|(
name|zap_mask
argument_list|(
name|CONST_DOUBLE_LOW
argument_list|(
name|op
argument_list|)
argument_list|)
operator|&&
name|zap_mask
argument_list|(
name|CONST_DOUBLE_HIGH
argument_list|(
name|op
argument_list|)
argument_list|)
operator|)
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|<
literal|0x100
operator|||
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
operator|~
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|<
literal|0x100
operator|||
name|zap_mask
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|)
operator|)
return|;
return|return
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a constant that is the width, in bits, of an integral    mode smaller than DImode.  */
end_comment

begin_function
name|int
name|mode_width_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|==
literal|8
operator|||
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|==
literal|16
operator|||
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|==
literal|32
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a constant that is the width of an integral machine mode    smaller than an integer.  */
end_comment

begin_function
name|int
name|mode_mask_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|==
literal|32
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
return|return
name|CONST_DOUBLE_HIGH
argument_list|(
name|op
argument_list|)
operator|==
literal|0
operator|&&
name|CONST_DOUBLE_LOW
argument_list|(
name|op
argument_list|)
operator|==
operator|-
literal|1
return|;
endif|#
directive|endif
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
operator|(
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|==
literal|0xff
operator|||
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|==
literal|0xffff
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|==
literal|64
operator|||
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|==
literal|0xffffffff
endif|#
directive|endif
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a multiple of 8 less than 64.  */
end_comment

begin_function
name|int
name|mul8_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|<
literal|64
operator|&&
operator|(
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|&
literal|7
operator|)
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is the constant zero in floating-point.  */
end_comment

begin_function
name|int
name|fp0_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|mode
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_FLOAT
operator|&&
name|op
operator|==
name|CONST0_RTX
argument_list|(
name|mode
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is the floating-point constant zero or a register.  */
end_comment

begin_function
name|int
name|reg_or_fp0_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
name|fp0_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|||
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a register or a constant integer.  */
end_comment

begin_function
name|int
name|reg_or_cint_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|||
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a valid operand for the source of a move insn.  */
end_comment

begin_function
name|int
name|input_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|mode
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|VOIDmode
operator|&&
name|mode
operator|!=
name|GET_MODE
argument_list|(
name|op
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_FLOAT
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|mode
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
condition|)
block|{
case|case
name|LABEL_REF
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|CONST
case|:
return|return
name|mode
operator|==
name|DImode
return|;
case|case
name|REG
case|:
return|return
literal|1
return|;
case|case
name|SUBREG
case|:
if|if
condition|(
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* ... fall through ... */
case|case
name|MEM
case|:
return|return
name|mode
operator|!=
name|HImode
operator|&&
name|mode
operator|!=
name|QImode
operator|&&
name|general_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
case|case
name|CONST_DOUBLE
case|:
return|return
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_FLOAT
operator|&&
name|op
operator|==
name|CONST0_RTX
argument_list|(
name|mode
argument_list|)
return|;
case|case
name|CONST_INT
case|:
return|return
name|mode
operator|==
name|QImode
operator|||
name|mode
operator|==
name|HImode
operator|||
name|add_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a SYMBOL_REF for the current function.  */
end_comment

begin_function
name|int
name|current_function_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
operator|!
name|strcmp
argument_list|(
name|XSTR
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
name|current_function_name
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a valid Alpha comparison operator.  Here we know which    comparisons are valid in which insn.  */
end_comment

begin_function
name|int
name|alpha_comparison_operator
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|op
argument_list|)
decl_stmt|;
if|if
condition|(
name|mode
operator|!=
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|||
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|!=
literal|'<'
condition|)
return|return
literal|0
return|;
return|return
operator|(
name|code
operator|==
name|EQ
operator|||
name|code
operator|==
name|LE
operator|||
name|code
operator|==
name|LT
operator|||
operator|(
name|mode
operator|==
name|DImode
operator|&&
operator|(
name|code
operator|==
name|LEU
operator|||
name|code
operator|==
name|LTU
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a signed comparison operation.  */
end_comment

begin_function
name|int
name|signed_comparison_operator
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
condition|)
block|{
case|case
name|EQ
case|:
case|case
name|NE
case|:
case|case
name|LE
case|:
case|case
name|LT
case|:
case|case
name|GE
case|:
case|case
name|GT
case|:
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if this is a divide or modulus operator.  */
end_comment

begin_function
name|int
name|divmod_operator
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
condition|)
block|{
case|case
name|DIV
case|:
case|case
name|MOD
case|:
case|case
name|UDIV
case|:
case|case
name|UMOD
case|:
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if this memory address is a known aligned register plus    a constant.  It must be a valid address.  This means that we can do    this as an aligned reference plus some offset.     Take into account what reload will do.     We could say that out-of-range stack slots are alignable, but that would    complicate get_aligned_mem and it isn't worth the trouble since few    functions have large stack space.  */
end_comment

begin_function
name|int
name|aligned_memory_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
if|if
condition|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|mode
condition|)
return|return
literal|0
return|;
name|op
operator|=
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|mode
operator|=
name|GET_MODE
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|reload_in_progress
operator|&&
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|op
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
name|op
operator|=
name|reg_equiv_mem
index|[
name|REGNO
argument_list|(
name|op
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|MEM
operator|||
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|mode
operator|||
operator|!
name|memory_address_p
argument_list|(
name|mode
argument_list|,
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
name|op
operator|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|PLUS
condition|)
name|op
operator|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|REGNO
argument_list|(
name|op
argument_list|)
operator|==
name|STACK_POINTER_REGNUM
operator|||
name|op
operator|==
name|frame_pointer_rtx
operator|||
operator|(
name|REGNO
argument_list|(
name|op
argument_list|)
operator|>=
name|FIRST_VIRTUAL_REGISTER
operator|&&
name|REGNO
argument_list|(
name|op
argument_list|)
operator|<=
name|LAST_VIRTUAL_REGISTER
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Similar, but return 1 if OP is a MEM which is not alignable.  */
end_comment

begin_function
name|int
name|unaligned_memory_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
if|if
condition|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|mode
condition|)
return|return
literal|0
return|;
name|op
operator|=
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|mode
operator|=
name|GET_MODE
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|reload_in_progress
operator|&&
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|op
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
name|op
operator|=
name|reg_equiv_mem
index|[
name|REGNO
argument_list|(
name|op
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|MEM
operator|||
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|mode
condition|)
return|return
literal|0
return|;
name|op
operator|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|memory_address_p
argument_list|(
name|mode
argument_list|,
name|op
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|PLUS
condition|)
name|op
operator|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|REG
operator|||
operator|(
name|REGNO
argument_list|(
name|op
argument_list|)
operator|!=
name|STACK_POINTER_REGNUM
operator|&&
name|op
operator|!=
name|frame_pointer_rtx
operator|&&
operator|(
name|REGNO
argument_list|(
name|op
argument_list|)
operator|<
name|FIRST_VIRTUAL_REGISTER
operator|||
name|REGNO
argument_list|(
name|op
argument_list|)
operator|>
name|LAST_VIRTUAL_REGISTER
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is any memory location.  During reload a pseudo matches.  */
end_comment

begin_function
name|int
name|any_memory_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|MEM
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|)
operator|==
name|REG
operator|)
operator|||
operator|(
name|reload_in_progress
operator|&&
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|op
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|)
operator|||
operator|(
name|reload_in_progress
operator|&&
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* REF is an alignable memory location.  Place an aligned SImode    reference into *PALIGNED_MEM and the number of bits to shift into    *PBITNUM.  */
end_comment

begin_function
name|void
name|get_aligned_mem
parameter_list|(
name|ref
parameter_list|,
name|paligned_mem
parameter_list|,
name|pbitnum
parameter_list|)
name|rtx
name|ref
decl_stmt|;
name|rtx
modifier|*
name|paligned_mem
decl_stmt|,
decl|*
name|pbitnum
decl_stmt|;
end_function

begin_block
block|{
name|rtx
name|base
decl_stmt|;
name|HOST_WIDE_INT
name|offset
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|ref
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
name|offset
operator|=
name|SUBREG_WORD
argument_list|(
name|ref
argument_list|)
operator|*
name|UNITS_PER_WORD
expr_stmt|;
if|if
condition|(
name|BYTES_BIG_ENDIAN
condition|)
name|offset
operator|-=
operator|(
name|MIN
argument_list|(
name|UNITS_PER_WORD
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|ref
argument_list|)
argument_list|)
argument_list|)
operator|-
name|MIN
argument_list|(
name|UNITS_PER_WORD
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|ref
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|ref
operator|=
name|SUBREG_REG
argument_list|(
name|ref
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|ref
argument_list|)
operator|==
name|REG
condition|)
name|ref
operator|=
name|reg_equiv_mem
index|[
name|REGNO
argument_list|(
name|ref
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|reload_in_progress
condition|)
name|base
operator|=
name|find_replacement
argument_list|(
operator|&
name|XEXP
argument_list|(
name|ref
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|base
operator|=
name|XEXP
argument_list|(
name|ref
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|base
argument_list|)
operator|==
name|PLUS
condition|)
name|offset
operator|+=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|base
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|,
name|base
operator|=
name|XEXP
argument_list|(
name|base
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|paligned_mem
operator|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|SImode
argument_list|,
name|plus_constant
argument_list|(
name|base
argument_list|,
name|offset
operator|&
operator|~
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|MEM_IN_STRUCT_P
argument_list|(
operator|*
name|paligned_mem
argument_list|)
operator|=
name|MEM_IN_STRUCT_P
argument_list|(
name|ref
argument_list|)
expr_stmt|;
name|MEM_VOLATILE_P
argument_list|(
operator|*
name|paligned_mem
argument_list|)
operator|=
name|MEM_VOLATILE_P
argument_list|(
name|ref
argument_list|)
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
operator|*
name|paligned_mem
argument_list|)
operator|=
name|RTX_UNCHANGING_P
argument_list|(
name|ref
argument_list|)
expr_stmt|;
operator|*
name|pbitnum
operator|=
name|GEN_INT
argument_list|(
operator|(
name|offset
operator|&
literal|3
operator|)
operator|*
literal|8
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Similar, but just get the address.  Handle the two reload cases.  */
end_comment

begin_function
name|rtx
name|get_unaligned_address
parameter_list|(
name|ref
parameter_list|)
name|rtx
name|ref
decl_stmt|;
block|{
name|rtx
name|base
decl_stmt|;
name|HOST_WIDE_INT
name|offset
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|ref
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
name|offset
operator|=
name|SUBREG_WORD
argument_list|(
name|ref
argument_list|)
operator|*
name|UNITS_PER_WORD
expr_stmt|;
if|if
condition|(
name|BYTES_BIG_ENDIAN
condition|)
name|offset
operator|-=
operator|(
name|MIN
argument_list|(
name|UNITS_PER_WORD
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|ref
argument_list|)
argument_list|)
argument_list|)
operator|-
name|MIN
argument_list|(
name|UNITS_PER_WORD
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|ref
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|ref
operator|=
name|SUBREG_REG
argument_list|(
name|ref
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|ref
argument_list|)
operator|==
name|REG
condition|)
name|ref
operator|=
name|reg_equiv_mem
index|[
name|REGNO
argument_list|(
name|ref
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|reload_in_progress
condition|)
name|base
operator|=
name|find_replacement
argument_list|(
operator|&
name|XEXP
argument_list|(
name|ref
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|base
operator|=
name|XEXP
argument_list|(
name|ref
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|base
argument_list|)
operator|==
name|PLUS
condition|)
name|offset
operator|+=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|base
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|,
name|base
operator|=
name|XEXP
argument_list|(
name|base
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|plus_constant
argument_list|(
name|base
argument_list|,
name|offset
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Subfunction of the following function.  Update the flags of any MEM    found in part of X.  */
end_comment

begin_function
specifier|static
name|void
name|alpha_set_memflags_1
parameter_list|(
name|x
parameter_list|,
name|in_struct_p
parameter_list|,
name|volatile_p
parameter_list|,
name|unchanging_p
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|int
name|in_struct_p
decl_stmt|,
name|volatile_p
decl_stmt|,
name|unchanging_p
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|SEQUENCE
case|:
case|case
name|PARALLEL
case|:
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
name|alpha_set_memflags_1
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
name|in_struct_p
argument_list|,
name|volatile_p
argument_list|,
name|unchanging_p
argument_list|)
expr_stmt|;
break|break;
case|case
name|INSN
case|:
name|alpha_set_memflags_1
argument_list|(
name|PATTERN
argument_list|(
name|x
argument_list|)
argument_list|,
name|in_struct_p
argument_list|,
name|volatile_p
argument_list|,
name|unchanging_p
argument_list|)
expr_stmt|;
break|break;
case|case
name|SET
case|:
name|alpha_set_memflags_1
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|,
name|in_struct_p
argument_list|,
name|volatile_p
argument_list|,
name|unchanging_p
argument_list|)
expr_stmt|;
name|alpha_set_memflags_1
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
name|in_struct_p
argument_list|,
name|volatile_p
argument_list|,
name|unchanging_p
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEM
case|:
name|MEM_IN_STRUCT_P
argument_list|(
name|x
argument_list|)
operator|=
name|in_struct_p
expr_stmt|;
name|MEM_VOLATILE_P
argument_list|(
name|x
argument_list|)
operator|=
name|volatile_p
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|x
argument_list|)
operator|=
name|unchanging_p
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Given INSN, which is either an INSN or a SEQUENCE generated to    perform a memory operation, look for any MEMs in either a SET_DEST or    a SET_SRC and copy the in-struct, unchanging, and volatile flags from    REF into each of the MEMs found.  If REF is not a MEM, don't do    anything.  */
end_comment

begin_function
name|void
name|alpha_set_memflags
parameter_list|(
name|insn
parameter_list|,
name|ref
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|rtx
name|ref
decl_stmt|;
block|{
comment|/* Note that it is always safe to get these flags, though they won't      be what we think if REF is not a MEM.  */
name|int
name|in_struct_p
init|=
name|MEM_IN_STRUCT_P
argument_list|(
name|ref
argument_list|)
decl_stmt|;
name|int
name|volatile_p
init|=
name|MEM_VOLATILE_P
argument_list|(
name|ref
argument_list|)
decl_stmt|;
name|int
name|unchanging_p
init|=
name|RTX_UNCHANGING_P
argument_list|(
name|ref
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|ref
argument_list|)
operator|!=
name|MEM
operator|||
operator|(
operator|!
name|in_struct_p
operator|&&
operator|!
name|volatile_p
operator|&&
operator|!
name|unchanging_p
operator|)
condition|)
return|return;
name|alpha_set_memflags_1
argument_list|(
name|insn
argument_list|,
name|in_struct_p
argument_list|,
name|volatile_p
argument_list|,
name|unchanging_p
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Try to output insns to set TARGET equal to the constant C if it can be    done in less than N insns.  Returns 1 if it can be done and the    insns have been emitted.  If it would take more than N insns, zero is    returned and no insns and emitted.  */
end_comment

begin_function
name|int
name|alpha_emit_set_const
parameter_list|(
name|target
parameter_list|,
name|c
parameter_list|,
name|n
parameter_list|)
name|rtx
name|target
decl_stmt|;
name|HOST_WIDE_INT
name|c
decl_stmt|;
name|int
name|n
decl_stmt|;
block|{
name|HOST_WIDE_INT
name|new
init|=
name|c
decl_stmt|;
name|int
name|i
decl_stmt|,
name|bits
decl_stmt|;
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|==
literal|64
comment|/* We are only called for SImode and DImode.  If this is SImode, ensure that      we are sign extended to a full word.  This does not make any sense when      cross-compiling on a narrow machine.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|==
name|SImode
condition|)
name|c
operator|=
operator|(
name|c
operator|&
literal|0xffffffff
operator|)
operator|-
literal|2
operator|*
operator|(
name|c
operator|&
literal|0x80000000
operator|)
expr_stmt|;
endif|#
directive|endif
comment|/* If this is a sign-extended 32-bit constant, we can do this in at most      three insns, so do it if we have enough insns left.  We always have      a sign-extended 32-bit constant when compiling on a narrow machine.  */
if|if
condition|(
name|HOST_BITS_PER_WIDE_INT
operator|!=
literal|64
operator|||
name|c
operator|>>
literal|31
operator|==
operator|-
literal|1
operator|||
name|c
operator|>>
literal|31
operator|==
literal|0
condition|)
block|{
name|HOST_WIDE_INT
name|low
init|=
operator|(
name|c
operator|&
literal|0xffff
operator|)
operator|-
literal|2
operator|*
operator|(
name|c
operator|&
literal|0x8000
operator|)
decl_stmt|;
name|HOST_WIDE_INT
name|tmp1
init|=
name|c
operator|-
name|low
decl_stmt|;
name|HOST_WIDE_INT
name|high
init|=
operator|(
operator|(
name|tmp1
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
operator|)
operator|-
literal|2
operator|*
operator|(
operator|(
name|tmp1
operator|>>
literal|16
operator|)
operator|&
literal|0x8000
operator|)
decl_stmt|;
name|HOST_WIDE_INT
name|tmp2
init|=
name|c
operator|-
operator|(
name|high
operator|<<
literal|16
operator|)
operator|-
name|low
decl_stmt|;
name|HOST_WIDE_INT
name|extra
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|tmp2
condition|)
block|{
name|extra
operator|=
literal|0x4000
expr_stmt|;
name|tmp1
operator|-=
literal|0x40000000
expr_stmt|;
name|high
operator|=
operator|(
operator|(
name|tmp1
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
operator|)
operator|-
literal|2
operator|*
operator|(
operator|(
name|tmp1
operator|>>
literal|16
operator|)
operator|&
literal|0x8000
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
name|low
operator|||
operator|(
name|low
operator|==
literal|0
operator|&&
name|extra
operator|==
literal|0
operator|)
condition|)
block|{
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|GEN_INT
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|n
operator|>=
literal|2
operator|+
operator|(
name|extra
operator|!=
literal|0
operator|)
condition|)
block|{
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|GEN_INT
argument_list|(
name|low
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|extra
operator|!=
literal|0
condition|)
name|emit_insn
argument_list|(
name|gen_add2_insn
argument_list|(
name|target
argument_list|,
name|GEN_INT
argument_list|(
name|extra
operator|<<
literal|16
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_add2_insn
argument_list|(
name|target
argument_list|,
name|GEN_INT
argument_list|(
name|high
operator|<<
literal|16
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
comment|/* If we couldn't do it that way, try some other methods (that depend on      being able to compute in the target's word size).  But if we have no      instructions left, don't bother.  Also, don't even try if this is       SImode (in which case we should have already done something, but      do a sanity check here).  */
if|if
condition|(
name|n
operator|==
literal|1
operator|||
name|HOST_BITS_PER_WIDE_INT
operator|<
literal|64
operator|||
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|!=
name|DImode
condition|)
return|return
literal|0
return|;
comment|/* First, see if can load a value into the target that is the same as the      constant except that all bytes that are 0 are changed to be 0xff.  If we      can, then we can do a ZAPNOT to obtain the desired constant.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|64
condition|;
name|i
operator|+=
literal|8
control|)
if|if
condition|(
operator|(
name|new
operator|&
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|0xff
operator|<<
name|i
operator|)
operator|)
operator|==
literal|0
condition|)
name|new
operator||=
operator|(
name|HOST_WIDE_INT
operator|)
literal|0xff
operator|<<
name|i
expr_stmt|;
if|if
condition|(
name|alpha_emit_set_const
argument_list|(
name|target
argument_list|,
name|new
argument_list|,
name|n
operator|-
literal|1
argument_list|)
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_anddi3
argument_list|(
name|target
argument_list|,
name|target
argument_list|,
name|GEN_INT
argument_list|(
name|c
operator||
operator|~
name|new
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* Find, see if we can load a related constant and then shift and possibly      negate it to get the constant we want.  Try this once each increasing      numbers of insns.  */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
comment|/* First try complementing.  */
if|if
condition|(
name|alpha_emit_set_const
argument_list|(
name|target
argument_list|,
operator|~
name|c
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_one_cmpldi2
argument_list|(
name|target
argument_list|,
name|target
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* First try to form a constant and do a left shift.  We can do this 	 if some low-order bits are zero; the exact_log2 call below tells 	 us that information.  The bits we are shifting out could be any 	 value, but here we'll just try the 0- and sign-extended forms of 	 the constant.  To try to increase the chance of having the same 	 constant in more than one insn, start at the highest number of 	 bits to shift, but try all possibilities in case a ZAPNOT will 	 be useful.  */
if|if
condition|(
operator|(
name|bits
operator|=
name|exact_log2
argument_list|(
name|c
operator|&
operator|-
name|c
argument_list|)
operator|)
operator|>
literal|0
condition|)
for|for
control|(
init|;
name|bits
operator|>
literal|0
condition|;
name|bits
operator|--
control|)
if|if
condition|(
name|alpha_emit_set_const
argument_list|(
name|target
argument_list|,
name|c
operator|>>
name|bits
argument_list|,
name|i
argument_list|)
operator|||
name|alpha_emit_set_const
argument_list|(
name|target
argument_list|,
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|c
operator|)
operator|>>
name|bits
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_ashldi3
argument_list|(
name|target
argument_list|,
name|target
argument_list|,
name|GEN_INT
argument_list|(
name|bits
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* Now try high-order zero bits.  Here we try the shifted-in bits as 	 all zero and all ones.  */
if|if
condition|(
operator|(
name|bits
operator|=
name|HOST_BITS_PER_WIDE_INT
operator|-
name|floor_log2
argument_list|(
name|c
argument_list|)
operator|-
literal|1
operator|)
operator|>
literal|0
condition|)
for|for
control|(
init|;
name|bits
operator|>
literal|0
condition|;
name|bits
operator|--
control|)
if|if
condition|(
name|alpha_emit_set_const
argument_list|(
name|target
argument_list|,
name|c
operator|<<
name|bits
argument_list|,
name|i
argument_list|)
operator|||
name|alpha_emit_set_const
argument_list|(
name|target
argument_list|,
operator|(
operator|(
name|c
operator|<<
name|bits
operator|)
operator||
operator|(
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|bits
operator|)
operator|-
literal|1
operator|)
operator|)
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_lshrdi3
argument_list|(
name|target
argument_list|,
name|target
argument_list|,
name|GEN_INT
argument_list|(
name|bits
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* Now try high-order 1 bits.  We get that with a sign-extension. 	 But one bit isn't enough here.  */
if|if
condition|(
operator|(
name|bits
operator|=
name|HOST_BITS_PER_WIDE_INT
operator|-
name|floor_log2
argument_list|(
operator|~
name|c
argument_list|)
operator|-
literal|2
operator|)
operator|>
literal|0
condition|)
for|for
control|(
init|;
name|bits
operator|>
literal|0
condition|;
name|bits
operator|--
control|)
if|if
condition|(
name|alpha_emit_set_const
argument_list|(
name|target
argument_list|,
name|c
operator|<<
name|bits
argument_list|,
name|i
argument_list|)
operator|||
name|alpha_emit_set_const
argument_list|(
name|target
argument_list|,
operator|(
operator|(
name|c
operator|<<
name|bits
operator|)
operator||
operator|(
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|bits
operator|)
operator|-
literal|1
operator|)
operator|)
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_ashrdi3
argument_list|(
name|target
argument_list|,
name|target
argument_list|,
name|GEN_INT
argument_list|(
name|bits
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Adjust the cost of a scheduling dependency.  Return the new cost of    a dependency LINK or INSN on DEP_INSN.  COST is the current cost.  */
end_comment

begin_function
name|int
name|alpha_adjust_cost
parameter_list|(
name|insn
parameter_list|,
name|link
parameter_list|,
name|dep_insn
parameter_list|,
name|cost
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|rtx
name|link
decl_stmt|;
name|rtx
name|dep_insn
decl_stmt|;
name|int
name|cost
decl_stmt|;
block|{
name|rtx
name|set
decl_stmt|;
comment|/* If the dependence is an anti-dependence, there is no cost.  For an      output dependence, there is sometimes a cost, but it doesn't seem      worth handling those few cases.  */
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
comment|/* If INSN is a store insn and DEP_INSN is setting the data being stored,      we can sometimes lower the cost.  */
if|if
condition|(
name|recog_memoized
argument_list|(
name|insn
argument_list|)
operator|>=
literal|0
operator|&&
name|get_attr_type
argument_list|(
name|insn
argument_list|)
operator|==
name|TYPE_ST
operator|&&
operator|(
name|set
operator|=
name|single_set
argument_list|(
name|dep_insn
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|rtx_equal_p
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|,
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
condition|)
switch|switch
condition|(
name|get_attr_type
argument_list|(
name|dep_insn
argument_list|)
condition|)
block|{
case|case
name|TYPE_LD
case|:
comment|/* No savings here.  */
return|return
name|cost
return|;
case|case
name|TYPE_IMULL
case|:
case|case
name|TYPE_IMULQ
case|:
comment|/* In these cases, we save one cycle.  */
return|return
name|cost
operator|-
literal|2
return|;
default|default:
comment|/* In all other cases, we save two cycles.  */
return|return
name|MAX
argument_list|(
literal|0
argument_list|,
name|cost
operator|-
literal|4
argument_list|)
return|;
block|}
comment|/* Another case that needs adjustment is an arithmetic or logical      operation.  It's cost is usually one cycle, but we default it to      two in the MD file.  The only case that it is actually two is      for the address in loads and stores.  */
if|if
condition|(
name|recog_memoized
argument_list|(
name|dep_insn
argument_list|)
operator|>=
literal|0
operator|&&
name|get_attr_type
argument_list|(
name|dep_insn
argument_list|)
operator|==
name|TYPE_IADDLOG
condition|)
switch|switch
condition|(
name|get_attr_type
argument_list|(
name|insn
argument_list|)
condition|)
block|{
case|case
name|TYPE_LD
case|:
case|case
name|TYPE_ST
case|:
return|return
name|cost
return|;
default|default:
return|return
literal|2
return|;
block|}
comment|/* The final case is when a compare feeds into an integer branch.  The cost      is only one cycle in that case.  */
if|if
condition|(
name|recog_memoized
argument_list|(
name|dep_insn
argument_list|)
operator|>=
literal|0
operator|&&
name|get_attr_type
argument_list|(
name|dep_insn
argument_list|)
operator|==
name|TYPE_ICMP
operator|&&
name|recog_memoized
argument_list|(
name|insn
argument_list|)
operator|>=
literal|0
operator|&&
name|get_attr_type
argument_list|(
name|insn
argument_list|)
operator|==
name|TYPE_IBR
condition|)
return|return
literal|2
return|;
comment|/* Otherwise, return the default cost. */
return|return
name|cost
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print an operand.  Recognize special options, documented below.  */
end_comment

begin_function
name|void
name|print_operand
parameter_list|(
name|file
parameter_list|,
name|x
parameter_list|,
name|code
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|char
name|code
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
literal|'r'
case|:
comment|/* If this operand is the constant zero, write it as "$31".  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|x
operator|==
name|CONST0_RTX
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"$31"
argument_list|)
expr_stmt|;
else|else
name|output_operand_lossage
argument_list|(
literal|"invalid %%r value"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
comment|/* Similar, but for floating-point.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|x
operator|==
name|CONST0_RTX
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"$f31"
argument_list|)
expr_stmt|;
else|else
name|output_operand_lossage
argument_list|(
literal|"invalid %%R value"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
comment|/* Write the 1's complement of a constant.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|CONST_INT
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%N value"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%ld"
argument_list|,
operator|~
name|INTVAL
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
comment|/* Write 1<< C, for a constant C.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|CONST_INT
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%P value"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%ld"
argument_list|,
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|INTVAL
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
comment|/* Write the high-order 16 bits of a constant, sign-extended.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|CONST_INT
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%h value"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%ld"
argument_list|,
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|>>
literal|16
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
comment|/* Write the low-order 16 bits of a constant, sign-extended.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|CONST_INT
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%L value"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%ld"
argument_list|,
operator|(
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|&
literal|0xffff
operator|)
operator|-
literal|2
operator|*
operator|(
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|&
literal|0x8000
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
comment|/* Write mask for ZAP insn.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
block|{
name|HOST_WIDE_INT
name|mask
init|=
literal|0
decl_stmt|;
name|HOST_WIDE_INT
name|value
decl_stmt|;
name|value
operator|=
name|CONST_DOUBLE_LOW
argument_list|(
name|x
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HOST_BITS_PER_WIDE_INT
operator|/
name|HOST_BITS_PER_CHAR
condition|;
name|i
operator|++
operator|,
name|value
operator|>>=
literal|8
control|)
if|if
condition|(
name|value
operator|&
literal|0xff
condition|)
name|mask
operator||=
operator|(
literal|1
operator|<<
name|i
operator|)
expr_stmt|;
name|value
operator|=
name|CONST_DOUBLE_HIGH
argument_list|(
name|x
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HOST_BITS_PER_WIDE_INT
operator|/
name|HOST_BITS_PER_CHAR
condition|;
name|i
operator|++
operator|,
name|value
operator|>>=
literal|8
control|)
if|if
condition|(
name|value
operator|&
literal|0xff
condition|)
name|mask
operator||=
operator|(
literal|1
operator|<<
operator|(
name|i
operator|+
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|)
operator|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%ld"
argument_list|,
name|mask
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|HOST_WIDE_INT
name|mask
init|=
literal|0
decl_stmt|,
name|value
init|=
name|INTVAL
argument_list|(
name|x
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
operator|,
name|value
operator|>>=
literal|8
control|)
if|if
condition|(
name|value
operator|&
literal|0xff
condition|)
name|mask
operator||=
operator|(
literal|1
operator|<<
name|i
operator|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%ld"
argument_list|,
name|mask
argument_list|)
expr_stmt|;
block|}
else|else
name|output_operand_lossage
argument_list|(
literal|"invalid %%m value"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
comment|/* 'b', 'w', or 'l' as the value of the constant.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|CONST_INT
operator|||
operator|(
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|!=
literal|8
operator|&&
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|!=
literal|16
operator|&&
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|!=
literal|32
operator|)
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%M value"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|==
literal|8
condition|?
literal|"b"
else|:
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|==
literal|16
condition|?
literal|"w"
else|:
literal|"l"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'U'
case|:
comment|/* Similar, except do it from the mask.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|==
literal|0xff
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"b"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|==
literal|0xffff
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|==
literal|32
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|CONST_DOUBLE_HIGH
argument_list|(
name|x
argument_list|)
operator|==
literal|0
operator|&&
name|CONST_DOUBLE_LOW
argument_list|(
name|x
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"l"
argument_list|)
expr_stmt|;
else|#
directive|else
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|==
literal|0xffffffff
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"l"
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|else
name|output_operand_lossage
argument_list|(
literal|"invalid %%U value"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
comment|/* Write the constant value divided by 8.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|CONST_INT
operator|&&
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|>=
literal|64
operator|&&
operator|(
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|&
literal|7
operator|)
operator|!=
literal|8
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%s value"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%ld"
argument_list|,
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|/
literal|8
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
comment|/* Same, except compute (64 - c) / 8 */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|CONST_INT
operator|&&
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|>=
literal|64
operator|&&
operator|(
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|&
literal|7
operator|)
operator|!=
literal|8
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%s value"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%ld"
argument_list|,
operator|(
literal|64
operator|-
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|)
operator|/
literal|8
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
comment|/* Write out comparison name.  */
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
literal|'<'
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%C value"
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|LEU
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"ule"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|LTU
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"ult"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|GET_RTX_NAME
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
comment|/* Similar, but write reversed code.  We can't get an unsigned code 	 here.  */
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
literal|'<'
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%D value"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|GET_RTX_NAME
argument_list|(
name|reverse_condition
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
comment|/* Write the divide or modulus operator.  */
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|DIV
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"div%s"
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|SImode
condition|?
literal|"l"
else|:
literal|"q"
argument_list|)
expr_stmt|;
break|break;
case|case
name|UDIV
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"div%su"
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|SImode
condition|?
literal|"l"
else|:
literal|"q"
argument_list|)
expr_stmt|;
break|break;
case|case
name|MOD
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"rem%s"
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|SImode
condition|?
literal|"l"
else|:
literal|"q"
argument_list|)
expr_stmt|;
break|break;
case|case
name|UMOD
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"rem%su"
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|SImode
condition|?
literal|"l"
else|:
literal|"q"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|output_operand_lossage
argument_list|(
literal|"invalid %%E value"
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|'F'
case|:
comment|/* Write the symbol; if the current function uses GP, write a 	 modified version.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|SYMBOL_REF
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid %%F value"
argument_list|)
expr_stmt|;
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|alpha_function_needs_gp
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"..ng"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'A'
case|:
comment|/* Write "_u" for unaligned access.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|AND
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"_u"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
condition|)
name|output_address
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|x
argument_list|)
expr_stmt|;
break|break;
default|default:
name|output_operand_lossage
argument_list|(
literal|"invalid %%xn code"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Do what is necessary for `va_start'.  The argument is ignored;    We look at the current function to determine if stdarg or varargs    is used and fill in an initial va_list.  A pointer to this constructor    is returned.  */
end_comment

begin_function
name|struct
name|rtx_def
modifier|*
name|alpha_builtin_saveregs
parameter_list|(
name|arglist
parameter_list|)
name|tree
name|arglist
decl_stmt|;
block|{
name|rtx
name|block
decl_stmt|,
name|addr
decl_stmt|,
name|argsize
decl_stmt|;
name|tree
name|fntype
init|=
name|TREE_TYPE
argument_list|(
name|current_function_decl
argument_list|)
decl_stmt|;
name|int
name|stdarg
init|=
operator|(
name|TYPE_ARG_TYPES
argument_list|(
name|fntype
argument_list|)
operator|!=
literal|0
operator|&&
operator|(
name|TREE_VALUE
argument_list|(
name|tree_last
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|fntype
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|void_type_node
operator|)
operator|)
decl_stmt|;
name|int
name|nregs
init|=
name|current_function_args_info
decl_stmt|;
comment|/* If we have a variable-sized argument already, we will have used all      the registers, so set up to indicate that.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|current_function_arg_offset_rtx
argument_list|)
operator|!=
name|CONST_INT
condition|)
block|{
name|argsize
operator|=
name|plus_constant
argument_list|(
name|current_function_arg_offset_rtx
argument_list|,
operator|(
literal|6
operator|*
name|UNITS_PER_WORD
operator|+
name|UNITS_PER_WORD
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|argsize
operator|=
name|expand_shift
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|Pmode
argument_list|,
name|argsize
argument_list|,
name|build_int_2
argument_list|(
literal|3
argument_list|,
literal|0
argument_list|)
argument_list|,
name|argsize
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Compute the number of args in memory and number of arguments already 	 processed.  Then adjust the number of registers if this is stdarg.  */
name|int
name|memargs
init|=
operator|(
operator|(
name|INTVAL
argument_list|(
name|current_function_arg_offset_rtx
argument_list|)
operator|+
name|UNITS_PER_WORD
operator|-
literal|1
operator|)
operator|/
name|UNITS_PER_WORD
operator|)
decl_stmt|;
name|argsize
operator|=
name|GEN_INT
argument_list|(
name|MIN
argument_list|(
name|nregs
argument_list|,
literal|6
argument_list|)
operator|+
name|memargs
argument_list|)
expr_stmt|;
if|if
condition|(
name|nregs
operator|<=
literal|6
condition|)
name|nregs
operator|-=
name|stdarg
expr_stmt|;
block|}
comment|/* Allocate the va_list constructor */
name|block
operator|=
name|assign_stack_local
argument_list|(
name|BLKmode
argument_list|,
literal|4
operator|*
name|UNITS_PER_WORD
argument_list|,
name|BITS_PER_WORD
argument_list|)
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|block
argument_list|)
operator|=
literal|1
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|XEXP
argument_list|(
name|block
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Store the argsize as the __va_arg member.  */
name|emit_move_insn
argument_list|(
name|change_address
argument_list|(
name|block
argument_list|,
name|DImode
argument_list|,
name|XEXP
argument_list|(
name|block
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|argsize
argument_list|)
expr_stmt|;
comment|/* Store the arg pointer in the __va_stack member.  */
name|emit_move_insn
argument_list|(
name|change_address
argument_list|(
name|block
argument_list|,
name|Pmode
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|block
argument_list|,
literal|0
argument_list|)
argument_list|,
name|UNITS_PER_WORD
argument_list|)
argument_list|)
argument_list|,
name|virtual_incoming_args_rtx
argument_list|)
expr_stmt|;
comment|/* Allocate the integer register space, and store it as the      __va_ireg member.  */
name|addr
operator|=
name|assign_stack_local
argument_list|(
name|BLKmode
argument_list|,
literal|6
operator|*
name|UNITS_PER_WORD
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|MEM_IN_STRUCT_P
argument_list|(
name|addr
argument_list|)
operator|=
literal|1
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|addr
argument_list|)
operator|=
literal|1
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
name|emit_move_insn
argument_list|(
name|change_address
argument_list|(
name|block
argument_list|,
name|Pmode
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|block
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|2
operator|*
name|UNITS_PER_WORD
argument_list|)
argument_list|)
argument_list|,
name|copy_to_reg
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now store the incoming integer registers.  */
if|if
condition|(
name|nregs
operator|<
literal|6
condition|)
name|move_block_from_reg
argument_list|(
literal|16
operator|+
name|nregs
argument_list|,
name|change_address
argument_list|(
name|addr
argument_list|,
name|Pmode
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|,
name|nregs
operator|*
name|UNITS_PER_WORD
argument_list|)
argument_list|)
argument_list|,
literal|6
operator|-
name|nregs
argument_list|)
expr_stmt|;
comment|/* Allocate the FP register space, and store it as the      __va_freg member.  */
name|addr
operator|=
name|assign_stack_local
argument_list|(
name|BLKmode
argument_list|,
literal|6
operator|*
name|UNITS_PER_WORD
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|MEM_IN_STRUCT_P
argument_list|(
name|addr
argument_list|)
operator|=
literal|1
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|addr
argument_list|)
operator|=
literal|1
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
name|emit_move_insn
argument_list|(
name|change_address
argument_list|(
name|block
argument_list|,
name|Pmode
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|block
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|3
operator|*
name|UNITS_PER_WORD
argument_list|)
argument_list|)
argument_list|,
name|copy_to_reg
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now store the incoming floating-point registers.   If we are not      to use the floating-point registers, store the integer registers      in those locations too.  */
if|if
condition|(
name|nregs
operator|<
literal|6
condition|)
name|move_block_from_reg
argument_list|(
literal|16
operator|+
literal|32
operator|*
operator|(
name|TARGET_FPREGS
operator|!=
literal|0
operator|)
operator|+
name|nregs
argument_list|,
name|change_address
argument_list|(
name|addr
argument_list|,
name|Pmode
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|,
name|nregs
operator|*
name|UNITS_PER_WORD
argument_list|)
argument_list|)
argument_list|,
literal|6
operator|-
name|nregs
argument_list|)
expr_stmt|;
comment|/* Return the address of the va_list constructor, but don't put it in a      register.  This fails when not optimizing and produces worse code when      optimizing.  */
return|return
name|XEXP
argument_list|(
name|block
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This page contains routines that are used to determine what the function    prologue and epilogue code will do and write them out.  */
end_comment

begin_comment
comment|/* Compute the size of the save area in the stack.  */
end_comment

begin_function
name|int
name|alpha_sa_size
parameter_list|()
block|{
name|int
name|size
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|fixed_regs
index|[
name|i
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|i
index|]
operator|&&
name|regs_ever_live
index|[
name|i
index|]
condition|)
name|size
operator|++
expr_stmt|;
return|return
name|size
operator|*
literal|8
return|;
block|}
end_function

begin_comment
comment|/* Return non-zero if this function needs gp.  It does if it has    an LDSYM insn.  */
end_comment

begin_function
name|int
name|alpha_need_gp
parameter_list|()
block|{
name|rtx
name|insn
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
literal|'i'
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|USE
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|CLOBBER
operator|&&
name|get_attr_type
argument_list|(
name|insn
argument_list|)
operator|==
name|TYPE_LDSYM
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if GP is dead at after INSN.  */
end_comment

begin_function
name|int
name|alpha_gp_dead_after
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
name|int
name|jump_count
init|=
literal|0
decl_stmt|;
name|int
name|found
init|=
literal|0
decl_stmt|;
name|rtx
name|p
decl_stmt|;
comment|/* If we aren't optimizing, don't do this optimization.  More importantly,      JUMP_LABEL isn't properly set when not optimizing.  */
if|if
condition|(
name|optimize
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* If we are followed by a BARRIER, we don't return.  */
if|if
condition|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|BARRIER
condition|)
return|return
literal|1
return|;
comment|/* Otherwise search for a use of GP before a return.  */
for|for
control|(
name|p
operator|=
name|next_active_insn
argument_list|(
name|insn
argument_list|)
init|;
name|p
condition|;
name|p
operator|=
name|next_active_insn
argument_list|(
name|p
argument_list|)
control|)
block|{
if|if
condition|(
name|get_attr_type
argument_list|(
name|p
argument_list|)
operator|==
name|TYPE_LDSYM
operator|||
name|get_attr_type
argument_list|(
name|p
argument_list|)
operator|==
name|TYPE_JSR
condition|)
block|{
name|found
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|JUMP_INSN
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|)
operator|==
name|RETURN
condition|)
break|break;
if|if
condition|(
operator|!
name|simplejump_p
argument_list|(
name|p
argument_list|)
operator|||
name|jump_count
operator|++
operator|>
literal|10
condition|)
block|{
name|found
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|p
operator|=
name|JUMP_LABEL
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Restore any operands destroyed by the attribute calls above.  */
name|insn_extract
argument_list|(
name|insn
argument_list|)
expr_stmt|;
return|return
operator|!
name|found
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if this function can directly return via $26.  */
end_comment

begin_function
name|int
name|direct_return
parameter_list|()
block|{
return|return
operator|(
name|reload_completed
operator|&&
name|alpha_sa_size
argument_list|()
operator|==
literal|0
operator|&&
name|get_frame_size
argument_list|()
operator|==
literal|0
operator|&&
name|current_function_pretend_args_size
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Write function prologue.  */
end_comment

begin_function
name|void
name|output_prolog
parameter_list|(
name|file
parameter_list|,
name|size
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
name|HOST_WIDE_INT
name|frame_size
init|=
operator|(
operator|(
name|size
operator|+
name|current_function_outgoing_args_size
operator|+
name|current_function_pretend_args_size
operator|+
name|alpha_sa_size
argument_list|()
operator|+
literal|15
operator|)
operator|&
operator|~
literal|15
operator|)
decl_stmt|;
name|int
name|reg_offset
init|=
name|current_function_outgoing_args_size
decl_stmt|;
name|int
name|start_reg_offset
init|=
name|reg_offset
decl_stmt|;
name|unsigned
name|reg_mask
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* If we need a GP, load it first.  */
name|alpha_function_needs_gp
operator|=
name|alpha_need_gp
argument_list|()
expr_stmt|;
if|if
condition|(
name|alpha_function_needs_gp
condition|)
block|{
name|rtx
name|insn
decl_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tldgp $29,0($27)\n"
argument_list|)
expr_stmt|;
comment|/* If we have a recursive call, put a special label here.  */
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
operator|&&
name|get_attr_type
argument_list|(
name|insn
argument_list|)
operator|!=
name|TYPE_JSR
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s..ng:\n"
argument_list|,
name|current_function_name
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* Adjust the stack by the frame size.  If the frame size is> 32768      bytes, we have to load it into a register first and then subtract      from sp.  Note that we are only allowed to adjust sp once in the      prologue.  */
if|if
condition|(
name|frame_size
operator|>
literal|32768
condition|)
block|{
name|HOST_WIDE_INT
name|low
init|=
operator|(
name|frame_size
operator|&
literal|0xffff
operator|)
operator|-
literal|2
operator|*
operator|(
name|frame_size
operator|&
literal|0x8000
operator|)
decl_stmt|;
name|HOST_WIDE_INT
name|tmp1
init|=
name|frame_size
operator|-
name|low
decl_stmt|;
name|HOST_WIDE_INT
name|high
init|=
operator|(
operator|(
name|tmp1
operator|>>
literal|16
operator|)
operator|&
literal|0xfff
operator|)
operator|-
literal|2
operator|*
operator|(
operator|(
name|tmp1
operator|>>
literal|16
operator|)
operator|&
literal|0x8000
operator|)
decl_stmt|;
name|HOST_WIDE_INT
name|tmp2
init|=
name|frame_size
operator|-
operator|(
name|high
operator|<<
literal|16
operator|)
operator|-
name|low
decl_stmt|;
name|HOST_WIDE_INT
name|extra
init|=
literal|0
decl_stmt|;
name|int
name|in_reg
init|=
literal|31
decl_stmt|;
comment|/* We haven't written code to handle frames> 4GB.  */
if|#
directive|if
name|HOST_BITS_PER_LONG_INT
operator|==
literal|64
if|if
condition|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|frame_size
operator|>>
literal|32
operator|!=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|tmp2
condition|)
block|{
name|extra
operator|=
literal|0x4000
expr_stmt|;
name|tmp1
operator|-=
literal|0x40000000
expr_stmt|;
name|high
operator|=
operator|(
operator|(
name|tmp1
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
operator|)
operator|-
literal|2
operator|*
operator|(
operator|(
name|tmp1
operator|>>
literal|16
operator|)
operator|&
literal|0x8000
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|low
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tlda $28,%d($%d)\n"
argument_list|,
name|low
argument_list|,
name|in_reg
argument_list|)
expr_stmt|;
name|in_reg
operator|=
literal|28
expr_stmt|;
block|}
if|if
condition|(
name|extra
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tldah $28,%d($%d)\n"
argument_list|,
name|extra
argument_list|,
name|in_reg
argument_list|)
expr_stmt|;
name|in_reg
operator|=
literal|28
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tldah $28,%d($%d)\n"
argument_list|,
name|high
argument_list|,
name|in_reg
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tsubq $30,$28,$30\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|frame_size
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tlda $30,-%d($30)\n"
argument_list|,
name|frame_size
argument_list|)
expr_stmt|;
comment|/* Write out the .frame line.  If we need a frame pointer, we use      an offset of zero.  */
if|if
condition|(
name|frame_pointer_needed
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.frame $15,0,$26\n"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.frame $30,%d,$26\n"
argument_list|,
name|frame_size
argument_list|)
expr_stmt|;
comment|/* Save register 26 if it is used.  */
if|if
condition|(
name|regs_ever_live
index|[
literal|26
index|]
condition|)
block|{
name|reg_mask
operator||=
literal|1
operator|<<
literal|26
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tstq $26,%d($30)\n"
argument_list|,
name|reg_offset
argument_list|)
expr_stmt|;
name|reg_offset
operator|+=
literal|8
expr_stmt|;
block|}
comment|/* Now save any other used register that are required to be saved.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|fixed_regs
index|[
name|i
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|i
index|]
operator|&&
name|regs_ever_live
index|[
name|i
index|]
operator|&&
name|i
operator|!=
literal|26
condition|)
block|{
name|reg_mask
operator||=
literal|1
operator|<<
name|i
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tstq $%d,%d($30)\n"
argument_list|,
name|i
argument_list|,
name|reg_offset
argument_list|)
expr_stmt|;
name|reg_offset
operator|+=
literal|8
expr_stmt|;
block|}
comment|/* Print the register mask and do floating-point saves.  */
if|if
condition|(
name|reg_mask
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.mask 0x%x,%d\n"
argument_list|,
name|reg_mask
argument_list|,
name|start_reg_offset
operator|-
name|frame_size
argument_list|)
expr_stmt|;
name|start_reg_offset
operator|=
name|reg_offset
expr_stmt|;
name|reg_mask
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|fixed_regs
index|[
name|i
operator|+
literal|32
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|i
operator|+
literal|32
index|]
operator|&&
name|regs_ever_live
index|[
name|i
operator|+
literal|32
index|]
condition|)
block|{
name|reg_mask
operator||=
literal|1
operator|<<
name|i
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tstt $f%d,%d($30)\n"
argument_list|,
name|i
argument_list|,
name|reg_offset
argument_list|)
expr_stmt|;
name|reg_offset
operator|+=
literal|8
expr_stmt|;
block|}
comment|/* Print the floating-point mask, if we've saved any fp register.  */
if|if
condition|(
name|reg_mask
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.fmask 0x%x,%d\n"
argument_list|,
name|reg_mask
argument_list|,
name|start_reg_offset
argument_list|)
expr_stmt|;
comment|/* If we need a frame pointer, set it to the value of incoming stack      which we compute by adding back the frame size pointer.  Because we      can subtract one more than we can add, we have to special-case      frame sizes of 32K.  Note that there is no restriction that the frame      pointer be updated in one instruction.  */
if|if
condition|(
name|frame_pointer_needed
condition|)
block|{
if|if
condition|(
name|frame_size
operator|==
literal|32768
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tlda $15,16384($30)\n\tlda $15,16384($15)\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|frame_size
operator|>
literal|32768
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\taddq $30,$28,$15\n"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tlda $15,%d($30)\n"
argument_list|,
name|frame_size
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Write function epilogue.  */
end_comment

begin_function
name|void
name|output_epilog
parameter_list|(
name|file
parameter_list|,
name|size
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
name|rtx
name|insn
init|=
name|get_last_insn
argument_list|()
decl_stmt|;
name|HOST_WIDE_INT
name|frame_size
init|=
operator|(
operator|(
name|size
operator|+
name|current_function_outgoing_args_size
operator|+
name|current_function_pretend_args_size
operator|+
name|alpha_sa_size
argument_list|()
operator|+
literal|15
operator|)
operator|&
operator|~
literal|15
operator|)
decl_stmt|;
name|int
name|reg_offset
init|=
name|current_function_outgoing_args_size
decl_stmt|;
name|int
name|reg_offset_from
init|=
name|STACK_POINTER_REGNUM
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* If the last insn was a BARRIER, we don't have to write anything except      the .end pseudo-op.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
condition|)
name|insn
operator|=
name|prev_nonnote_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
operator|==
literal|0
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|BARRIER
condition|)
block|{
comment|/* If we have a frame pointer, we restore the registers from an 	 offset from it, assuming that we can reach the offset.  If not, 	 we have to compute the address using a scratch register.  This is 	 messy, but should not be common.  We have to copy the frame 	 pointer elsewhere here since we will be restoring it before we can 	 use it to restore the stack pointer.  We use $25.  */
if|if
condition|(
name|frame_pointer_needed
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tbis $15,$15,$25\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|frame_size
operator|<
literal|32768
condition|)
name|reg_offset
operator|-=
name|frame_size
operator|,
name|reg_offset_from
operator|=
literal|25
expr_stmt|;
else|else
block|{
name|HOST_WIDE_INT
name|low
init|=
operator|(
name|frame_size
operator|&
literal|0xffff
operator|)
operator|-
literal|2
operator|*
operator|(
name|frame_size
operator|&
literal|0x8000
operator|)
decl_stmt|;
name|HOST_WIDE_INT
name|tmp1
init|=
name|frame_size
operator|-
name|low
decl_stmt|;
name|HOST_WIDE_INT
name|high
init|=
operator|(
operator|(
name|tmp1
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
operator|)
operator|-
literal|2
operator|*
operator|(
operator|(
name|tmp1
operator|>>
literal|16
operator|)
operator|&
literal|0x8000
operator|)
decl_stmt|;
name|HOST_WIDE_INT
name|tmp2
init|=
name|frame_size
operator|-
operator|(
name|high
operator|<<
literal|16
operator|)
operator|-
name|low
decl_stmt|;
name|int
name|extra
init|=
literal|0
decl_stmt|;
name|int
name|in_reg
init|=
literal|31
decl_stmt|;
if|if
condition|(
name|tmp2
condition|)
block|{
name|extra
operator|=
literal|0x4000
expr_stmt|;
name|tmp1
operator|-=
literal|0x40000000
expr_stmt|;
name|high
operator|=
operator|(
operator|(
name|tmp1
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
operator|)
operator|-
literal|2
operator|*
operator|(
operator|(
name|tmp1
operator|>>
literal|16
operator|)
operator|&
literal|0x8000
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|low
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tlda $28,%d($%d)\n"
argument_list|,
name|low
argument_list|,
name|in_reg
argument_list|)
expr_stmt|;
name|in_reg
operator|=
literal|28
expr_stmt|;
block|}
if|if
condition|(
name|extra
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tldah $28,%d($%d)\n"
argument_list|,
name|extra
argument_list|,
name|in_reg
argument_list|)
expr_stmt|;
name|in_reg
operator|=
literal|28
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tldah $28,%d($%d)\n"
argument_list|,
name|high
argument_list|,
name|in_reg
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tsubq $25,$28,$28\n"
argument_list|)
expr_stmt|;
name|reg_offset_from
operator|=
literal|28
expr_stmt|;
block|}
block|}
comment|/* Restore all the registers, starting with the return address 	 register.  */
if|if
condition|(
name|regs_ever_live
index|[
literal|26
index|]
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tldq $26,%d($%d)\n"
argument_list|,
name|reg_offset
argument_list|,
name|reg_offset_from
argument_list|)
expr_stmt|;
name|reg_offset
operator|+=
literal|8
expr_stmt|;
block|}
comment|/* Now restore any other used register that that we saved.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|fixed_regs
index|[
name|i
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|i
index|]
operator|&&
name|regs_ever_live
index|[
name|i
index|]
operator|&&
name|i
operator|!=
literal|26
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tldq $%d,%d($%d)\n"
argument_list|,
name|i
argument_list|,
name|reg_offset
argument_list|,
name|reg_offset_from
argument_list|)
expr_stmt|;
name|reg_offset
operator|+=
literal|8
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|fixed_regs
index|[
name|i
operator|+
literal|32
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|i
operator|+
literal|32
index|]
operator|&&
name|regs_ever_live
index|[
name|i
operator|+
literal|32
index|]
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tldt $f%d,%d($%d)\n"
argument_list|,
name|i
argument_list|,
name|reg_offset
argument_list|,
name|reg_offset_from
argument_list|)
expr_stmt|;
name|reg_offset
operator|+=
literal|8
expr_stmt|;
block|}
comment|/* Restore the stack.  If we have a frame pointer, use it.  Otherwise, 	 add the size back into the stack, handling the large frame size.  */
if|if
condition|(
name|frame_pointer_needed
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tbis $25,$25,$30\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|frame_size
operator|>
literal|32767
condition|)
block|{
name|HOST_WIDE_INT
name|low
init|=
operator|(
name|frame_size
operator|&
literal|0xffff
operator|)
operator|-
literal|2
operator|*
operator|(
name|frame_size
operator|&
literal|0x8000
operator|)
decl_stmt|;
name|HOST_WIDE_INT
name|tmp1
init|=
name|frame_size
operator|-
name|low
decl_stmt|;
name|HOST_WIDE_INT
name|high
init|=
operator|(
operator|(
name|tmp1
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
operator|)
operator|-
literal|2
operator|*
operator|(
operator|(
name|tmp1
operator|>>
literal|16
operator|)
operator|&
literal|0x8000
operator|)
decl_stmt|;
name|HOST_WIDE_INT
name|tmp2
init|=
name|frame_size
operator|-
operator|(
name|high
operator|<<
literal|16
operator|)
operator|-
name|low
decl_stmt|;
name|HOST_WIDE_INT
name|extra
init|=
literal|0
decl_stmt|;
name|int
name|in_reg
init|=
literal|31
decl_stmt|;
comment|/* We haven't written code to handle frames> 4GB.  */
if|#
directive|if
name|HOST_BITS_PER_LONG_INT
operator|==
literal|64
if|if
condition|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|frame_size
operator|>>
literal|32
operator|!=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|tmp2
condition|)
block|{
name|extra
operator|=
literal|0x4000
expr_stmt|;
name|tmp1
operator|-=
literal|0x40000000
expr_stmt|;
name|high
operator|=
operator|(
operator|(
name|tmp1
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
operator|)
operator|-
literal|2
operator|*
operator|(
operator|(
name|tmp1
operator|>>
literal|16
operator|)
operator|&
literal|0x8000
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|low
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tlda $28,%d($%d)\n"
argument_list|,
name|low
argument_list|,
name|in_reg
argument_list|)
expr_stmt|;
name|in_reg
operator|=
literal|28
expr_stmt|;
block|}
if|if
condition|(
name|extra
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tldah $28,%d($%d)\n"
argument_list|,
name|extra
argument_list|,
name|in_reg
argument_list|)
expr_stmt|;
name|in_reg
operator|=
literal|28
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tldah $28,%d($%d)\n"
argument_list|,
name|high
argument_list|,
name|in_reg
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\taddq $30,$28,$30\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|frame_size
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tlda $30,%d($30)\n"
argument_list|,
name|frame_size
argument_list|)
expr_stmt|;
comment|/* Now return to the caller.  */
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tret $31,($26),1\n"
argument_list|)
expr_stmt|;
block|}
comment|/* End the function.  */
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.end %s\n"
argument_list|,
name|alpha_function_name
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

