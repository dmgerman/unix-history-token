begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Subroutines for assembler code output on the NS32000.    Copyright (C) 1988 Free Software Foundation, Inc.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* Some output-actions in ns32k.md need these.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"conditions.h"
end_include

begin_include
include|#
directive|include
file|"insn-flags.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"insn-attr.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|OSF_OS
end_ifdef

begin_decl_stmt
name|int
name|ns32k_num_files
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|trace
parameter_list|(
name|s
parameter_list|,
name|s1
parameter_list|,
name|s2
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|,
decl|*
name|s1
decl_stmt|,
modifier|*
name|s2
decl_stmt|;
end_function

begin_block
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|s
argument_list|,
name|s1
argument_list|,
name|s2
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Value is 1 if hard register REGNO can hold a value of machine-mode MODE. */
end_comment

begin_function
name|int
name|hard_regno_mode_ok
parameter_list|(
name|regno
parameter_list|,
name|mode
parameter_list|)
name|int
name|regno
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|QImode
case|:
case|case
name|HImode
case|:
case|case
name|PSImode
case|:
case|case
name|SImode
case|:
case|case
name|PDImode
case|:
case|case
name|VOIDmode
case|:
case|case
name|BLKmode
case|:
if|if
condition|(
name|regno
operator|<
literal|8
operator|||
name|regno
operator|==
literal|16
operator|||
name|regno
operator|==
literal|17
condition|)
return|return
literal|1
return|;
else|else
return|return
literal|0
return|;
case|case
name|DImode
case|:
if|if
condition|(
name|regno
operator|<
literal|8
operator|&&
operator|(
name|regno
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
else|else
return|return
literal|0
return|;
case|case
name|SFmode
case|:
case|case
name|SCmode
case|:
if|if
condition|(
name|TARGET_32081
condition|)
block|{
if|if
condition|(
name|regno
operator|<
literal|16
condition|)
return|return
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
else|else
block|{
if|if
condition|(
name|regno
operator|<
literal|8
condition|)
return|return
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
case|case
name|DFmode
case|:
case|case
name|DCmode
case|:
if|if
condition|(
operator|(
name|regno
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|TARGET_32081
condition|)
block|{
if|if
condition|(
name|regno
operator|<
literal|16
condition|)
return|return
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
else|else
block|{
if|if
condition|(
name|regno
operator|<
literal|8
condition|)
return|return
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
block|}
else|else
return|return
literal|0
return|;
block|}
comment|/* Used to abort here, but simply saying "no" handles TImode      much better.  */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ADDRESS_COST calls this.  This function is not optimal    for the 32032& 32332, but it probably is better than    the default. */
end_comment

begin_function
name|int
name|calc_address_cost
parameter_list|(
name|operand
parameter_list|)
name|rtx
name|operand
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|cost
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|operand
argument_list|)
operator|==
name|MEM
condition|)
name|cost
operator|+=
literal|3
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|operand
argument_list|)
operator|==
name|MULT
condition|)
name|cost
operator|+=
literal|2
expr_stmt|;
if|#
directive|if
literal|0
block|if (GET_CODE (operand) == REG)     cost += 1;
comment|/* not really, but the documentation 				   says different amount of registers 				   shouldn't return the same costs */
endif|#
directive|endif
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|operand
argument_list|)
condition|)
block|{
case|case
name|REG
case|:
case|case
name|CONST
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
case|case
name|POST_DEC
case|:
case|case
name|PRE_DEC
case|:
break|break;
case|case
name|MULT
case|:
case|case
name|MEM
case|:
case|case
name|PLUS
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GET_RTX_LENGTH
argument_list|(
name|GET_CODE
argument_list|(
name|operand
argument_list|)
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|cost
operator|+=
name|calc_address_cost
argument_list|(
name|XEXP
argument_list|(
name|operand
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
default|default:
break|break;
block|}
return|return
name|cost
return|;
block|}
end_function

begin_comment
comment|/* Return the register class of a scratch register needed to copy IN into    or out of a register in CLASS in MODE.  If it can be done directly,    NO_REGS is returned.  */
end_comment

begin_function
name|enum
name|reg_class
name|secondary_reload_class
parameter_list|(
name|class
parameter_list|,
name|mode
parameter_list|,
name|in
parameter_list|)
name|enum
name|reg_class
name|class
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|in
decl_stmt|;
block|{
name|int
name|regno
init|=
name|true_regnum
argument_list|(
name|in
argument_list|)
decl_stmt|;
if|if
condition|(
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
name|regno
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* We can place anything into GENERAL_REGS and can put GENERAL_REGS      into anything.  */
if|if
condition|(
name|class
operator|==
name|GENERAL_REGS
operator|||
operator|(
name|regno
operator|>=
literal|0
operator|&&
name|regno
operator|<
literal|8
operator|)
condition|)
return|return
name|NO_REGS
return|;
comment|/* Constants, memory, and FP registers can go into FP registers.  */
if|if
condition|(
operator|(
name|regno
operator|==
operator|-
literal|1
operator|||
operator|(
name|regno
operator|>=
literal|8
operator|&&
name|regno
operator|<
literal|16
operator|)
operator|)
operator|&&
operator|(
name|class
operator|==
name|FLOAT_REGS
operator|)
condition|)
return|return
name|NO_REGS
return|;
if|#
directive|if
literal|0
comment|/* This isn't strictly true (can't move fp to sp or vice versa), 	 so it's cleaner to use PREFERRED_RELOAD_CLASS 	 to make the right things happen.  */
block|if (regno>= 16&& class == GEN_AND_MEM_REGS)     return NO_REGS;
endif|#
directive|endif
comment|/* Otherwise, we need GENERAL_REGS. */
return|return
name|GENERAL_REGS
return|;
block|}
end_function

begin_comment
comment|/* Generate the rtx that comes from an address expression in the md file */
end_comment

begin_comment
comment|/* The expression to be build is BASE[INDEX:SCALE].  To recognize this,    scale must be converted from an exponent (from ASHIFT) to a    multiplier (for MULT). */
end_comment

begin_function
name|rtx
name|gen_indexed_expr
parameter_list|(
name|base
parameter_list|,
name|index
parameter_list|,
name|scale
parameter_list|)
name|rtx
name|base
decl_stmt|,
name|index
decl_stmt|,
name|scale
decl_stmt|;
block|{
name|rtx
name|addr
decl_stmt|;
comment|/* This generates an illegal addressing mode, if BASE is      fp or sp.  This is handled by PRINT_OPERAND_ADDRESS.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|base
argument_list|)
operator|!=
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|base
argument_list|)
operator|!=
name|CONST_INT
condition|)
name|base
operator|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|SImode
argument_list|,
name|base
argument_list|)
expr_stmt|;
name|addr
operator|=
name|gen_rtx
argument_list|(
name|MULT
argument_list|,
name|SImode
argument_list|,
name|index
argument_list|,
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
literal|1
operator|<<
name|INTVAL
argument_list|(
name|scale
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|addr
operator|=
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|SImode
argument_list|,
name|base
argument_list|,
name|addr
argument_list|)
expr_stmt|;
return|return
name|addr
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a valid operand of mode MODE.  This    predicate rejects operands which do not have a mode    (such as CONST_INT which are VOIDmode).  */
end_comment

begin_function
name|int
name|reg_or_mem_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|mode
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|MEM
operator|)
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the best assembler insn template    for moving operands[1] into operands[0] as a fullword.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|singlemove_string
parameter_list|(
name|operands
parameter_list|)
name|rtx
modifier|*
name|operands
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|<=
literal|7
operator|&&
name|INTVAL
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|>=
operator|-
literal|8
condition|)
return|return
literal|"movqd %1,%0"
return|;
return|return
literal|"movd %1,%0"
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|output_move_double
parameter_list|(
name|operands
parameter_list|)
name|rtx
modifier|*
name|operands
decl_stmt|;
block|{
enum|enum
name|anon1
block|{
name|REGOP
block|,
name|OFFSOP
block|,
name|POPOP
block|,
name|CNSTOP
block|,
name|RNDOP
block|}
name|optype0
enum|,
name|optype1
expr_stmt|;
name|rtx
name|latehalf
index|[
literal|2
index|]
decl_stmt|;
comment|/* First classify both operands.  */
if|if
condition|(
name|REG_P
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
condition|)
name|optype0
operator|=
name|REGOP
expr_stmt|;
elseif|else
if|if
condition|(
name|offsettable_memref_p
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
condition|)
name|optype0
operator|=
name|OFFSOP
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PRE_DEC
condition|)
name|optype0
operator|=
name|POPOP
expr_stmt|;
else|else
name|optype0
operator|=
name|RNDOP
expr_stmt|;
if|if
condition|(
name|REG_P
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
name|optype1
operator|=
name|REGOP
expr_stmt|;
elseif|else
if|if
condition|(
name|CONSTANT_ADDRESS_P
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
name|optype1
operator|=
name|CNSTOP
expr_stmt|;
elseif|else
if|if
condition|(
name|offsettable_memref_p
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
name|optype1
operator|=
name|OFFSOP
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PRE_DEC
condition|)
name|optype1
operator|=
name|POPOP
expr_stmt|;
else|else
name|optype1
operator|=
name|RNDOP
expr_stmt|;
comment|/* Check for the cases that the operand constraints are not      supposed to allow to happen.  Abort if we get one,      because generating code for these cases is painful.  */
if|if
condition|(
name|optype0
operator|==
name|RNDOP
operator|||
name|optype1
operator|==
name|RNDOP
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Ok, we can do one word at a time.      Normally we do the low-numbered word first,      but if either operand is autodecrementing then we      do the high-numbered word first.       In either case, set up in LATEHALF the operands to use      for the high-numbered word and in some cases alter the      operands in OPERANDS to be suitable for the low-numbered word.  */
if|if
condition|(
name|optype0
operator|==
name|REGOP
condition|)
name|latehalf
index|[
literal|0
index|]
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|SImode
argument_list|,
name|REGNO
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|optype0
operator|==
name|OFFSOP
condition|)
name|latehalf
index|[
literal|0
index|]
operator|=
name|adj_offsettable_operand
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|4
argument_list|)
expr_stmt|;
else|else
name|latehalf
index|[
literal|0
index|]
operator|=
name|operands
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|optype1
operator|==
name|REGOP
condition|)
name|latehalf
index|[
literal|1
index|]
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|SImode
argument_list|,
name|REGNO
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|optype1
operator|==
name|OFFSOP
condition|)
name|latehalf
index|[
literal|1
index|]
operator|=
name|adj_offsettable_operand
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|4
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|optype1
operator|==
name|CNSTOP
condition|)
block|{
if|if
condition|(
name|CONSTANT_ADDRESS_P
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
name|latehalf
index|[
literal|1
index|]
operator|=
name|const0_rtx
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
name|split_double
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
operator|&
name|operands
index|[
literal|1
index|]
argument_list|,
operator|&
name|latehalf
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
else|else
name|latehalf
index|[
literal|1
index|]
operator|=
name|operands
index|[
literal|1
index|]
expr_stmt|;
comment|/* If one or both operands autodecrementing,      do the two words, high-numbered first.  */
if|if
condition|(
name|optype0
operator|==
name|POPOP
operator|||
name|optype1
operator|==
name|POPOP
condition|)
block|{
name|output_asm_insn
argument_list|(
name|singlemove_string
argument_list|(
name|latehalf
argument_list|)
argument_list|,
name|latehalf
argument_list|)
expr_stmt|;
return|return
name|singlemove_string
argument_list|(
name|operands
argument_list|)
return|;
block|}
comment|/* Not autodecrementing.  Do the two words, low-numbered first.  */
name|output_asm_insn
argument_list|(
name|singlemove_string
argument_list|(
name|operands
argument_list|)
argument_list|,
name|operands
argument_list|)
expr_stmt|;
name|operands
index|[
literal|0
index|]
operator|=
name|latehalf
index|[
literal|0
index|]
expr_stmt|;
name|operands
index|[
literal|1
index|]
operator|=
name|latehalf
index|[
literal|1
index|]
expr_stmt|;
return|return
name|singlemove_string
argument_list|(
name|operands
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|check_reg
parameter_list|(
name|oper
parameter_list|,
name|reg
parameter_list|)
name|rtx
name|oper
decl_stmt|;
name|int
name|reg
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|oper
operator|==
literal|0
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|oper
argument_list|)
condition|)
block|{
case|case
name|REG
case|:
return|return
operator|(
name|REGNO
argument_list|(
name|oper
argument_list|)
operator|==
name|reg
operator|)
condition|?
literal|1
else|:
literal|0
return|;
case|case
name|MEM
case|:
return|return
name|check_reg
argument_list|(
name|XEXP
argument_list|(
name|oper
argument_list|,
literal|0
argument_list|)
argument_list|,
name|reg
argument_list|)
return|;
case|case
name|PLUS
case|:
case|case
name|MULT
case|:
return|return
name|check_reg
argument_list|(
name|XEXP
argument_list|(
name|oper
argument_list|,
literal|0
argument_list|)
argument_list|,
name|reg
argument_list|)
operator|||
name|check_reg
argument_list|(
name|XEXP
argument_list|(
name|oper
argument_list|,
literal|1
argument_list|)
argument_list|,
name|reg
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* PRINT_OPERAND is defined to call this function,    which is easier to debug than putting all the code in    a macro definition in ns32k.h.  */
end_comment

begin_function
name|void
name|print_operand
parameter_list|(
name|file
parameter_list|,
name|x
parameter_list|,
name|code
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|char
name|code
decl_stmt|;
block|{
if|if
condition|(
name|code
operator|==
literal|'$'
condition|)
name|PUT_IMMEDIATE_PREFIX
argument_list|(
name|file
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
literal|'?'
condition|)
name|PUT_EXTERNAL_PREFIX
argument_list|(
name|file
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
condition|)
block|{
name|rtx
name|tmp
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|#
directive|if
operator|!
operator|(
name|defined
argument_list|(
name|PC_RELATIVE
argument_list|)
operator|||
name|defined
argument_list|(
name|NO_ABSOLUTE_PREFIX_IF_SYMBOLIC
argument_list|)
operator|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|tmp
argument_list|)
operator|!=
name|CONST_INT
condition|)
block|{
name|char
modifier|*
name|out
init|=
name|XSTR
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|out
index|[
literal|0
index|]
operator|==
literal|'*'
condition|)
block|{
name|PUT_ABSOLUTE_PREFIX
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
operator|&
name|out
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
else|else
name|ASM_OUTPUT_LABELREF
argument_list|(
name|file
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
name|output_address
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|!=
name|DImode
condition|)
block|{
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|DFmode
condition|)
block|{
union|union
block|{
name|double
name|d
decl_stmt|;
name|int
name|i
index|[
literal|2
index|]
decl_stmt|;
block|}
name|u
union|;
name|u
operator|.
name|i
index|[
literal|0
index|]
operator|=
name|CONST_DOUBLE_LOW
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|u
operator|.
name|i
index|[
literal|1
index|]
operator|=
name|CONST_DOUBLE_HIGH
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|PUT_IMMEDIATE_PREFIX
argument_list|(
name|file
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SEQUENT_ASM
comment|/* Sequent likes it's floating point constants as integers */
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"0Dx%08x%08x"
argument_list|,
name|u
operator|.
name|i
index|[
literal|1
index|]
argument_list|,
name|u
operator|.
name|i
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|ENCORE_ASM
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"0f%.20e"
argument_list|,
name|u
operator|.
name|d
argument_list|)
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"0d%.20e"
argument_list|,
name|u
operator|.
name|d
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
block|}
else|else
block|{
union|union
block|{
name|double
name|d
decl_stmt|;
name|int
name|i
index|[
literal|2
index|]
decl_stmt|;
block|}
name|u
union|;
name|u
operator|.
name|i
index|[
literal|0
index|]
operator|=
name|CONST_DOUBLE_LOW
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|u
operator|.
name|i
index|[
literal|1
index|]
operator|=
name|CONST_DOUBLE_HIGH
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|PUT_IMMEDIATE_PREFIX
argument_list|(
name|file
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SEQUENT_ASM
comment|/* We have no way of winning if we can't get the bits 	     for a sequent floating point number.  */
if|#
directive|if
name|HOST_FLOAT_FORMAT
operator|!=
name|TARGET_FLOAT_FORMAT
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|{
union|union
block|{
name|float
name|f
decl_stmt|;
name|long
name|l
decl_stmt|;
block|}
name|uu
union|;
name|uu
operator|.
name|f
operator|=
name|u
operator|.
name|d
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"0Fx%08x"
argument_list|,
name|uu
operator|.
name|l
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"0f%.20e"
argument_list|,
name|u
operator|.
name|d
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|NO_IMMEDIATE_PREFIX_IF_SYMBOLIC
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
condition|)
endif|#
directive|endif
name|PUT_IMMEDIATE_PREFIX
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* PRINT_OPERAND_ADDRESS is defined to call this function,    which is easier to debug than putting all the code in    a macro definition in ns32k.h .  */
end_comment

begin_comment
comment|/* Completely rewritten to get this to work with Gas for PC532 Mach.    This function didn't work and I just wasn't able (nor very willing) to    figure out how it worked.    90-11-25 Tatu Yl|nen<ylo@cs.hut.fi> */
end_comment

begin_expr_stmt
name|print_operand_address
argument_list|(
name|file
argument_list|,
name|addr
argument_list|)
specifier|register
name|FILE
operator|*
name|file
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|rtx
name|addr
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|static
name|char
name|scales
index|[]
init|=
block|{
literal|'b'
block|,
literal|'w'
block|,
literal|'d'
block|,
literal|0
block|,
literal|'q'
block|, }
decl_stmt|;
name|rtx
name|offset
decl_stmt|,
name|base
decl_stmt|,
name|indexexp
decl_stmt|,
name|tmp
decl_stmt|;
name|int
name|scale
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|PRE_DEC
operator|||
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|POST_DEC
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"tos"
argument_list|)
expr_stmt|;
return|return;
block|}
name|offset
operator|=
name|NULL
expr_stmt|;
name|base
operator|=
name|NULL
expr_stmt|;
name|indexexp
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|addr
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|PLUS
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
condition|)
block|{
name|tmp
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tmp
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|tmp
operator|=
name|addr
expr_stmt|;
name|addr
operator|=
name|NULL
expr_stmt|;
block|}
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|tmp
argument_list|)
condition|)
block|{
case|case
name|PLUS
case|:
name|abort
argument_list|()
expr_stmt|;
case|case
name|MEM
case|:
if|if
condition|(
name|base
condition|)
block|{
name|indexexp
operator|=
name|base
expr_stmt|;
name|base
operator|=
name|tmp
expr_stmt|;
block|}
else|else
name|base
operator|=
name|tmp
expr_stmt|;
break|break;
case|case
name|REG
case|:
if|if
condition|(
name|REGNO
argument_list|(
name|tmp
argument_list|)
operator|<
literal|8
condition|)
if|if
condition|(
name|base
condition|)
block|{
name|indexexp
operator|=
name|tmp
expr_stmt|;
block|}
else|else
name|base
operator|=
name|tmp
expr_stmt|;
elseif|else
if|if
condition|(
name|base
condition|)
block|{
name|indexexp
operator|=
name|base
expr_stmt|;
name|base
operator|=
name|tmp
expr_stmt|;
block|}
else|else
name|base
operator|=
name|tmp
expr_stmt|;
break|break;
case|case
name|MULT
case|:
name|indexexp
operator|=
name|tmp
expr_stmt|;
break|break;
case|case
name|CONST
case|:
case|case
name|CONST_INT
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
if|if
condition|(
name|offset
condition|)
name|offset
operator|=
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|SImode
argument_list|,
name|tmp
argument_list|,
name|offset
argument_list|)
expr_stmt|;
else|else
name|offset
operator|=
name|tmp
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|offset
condition|)
name|offset
operator|=
name|const0_rtx
expr_stmt|;
ifdef|#
directive|ifdef
name|INDEX_RATHER_THAN_BASE
comment|/* This is a re-implementation of the SEQUENT_ADDRESS_BUG fix.  */
if|if
condition|(
name|base
operator|&&
operator|!
name|indexexp
operator|&&
name|GET_CODE
argument_list|(
name|base
argument_list|)
operator|==
name|REG
operator|&&
name|REG_OK_FOR_INDEX_P
argument_list|(
name|base
argument_list|)
condition|)
block|{
name|indexexp
operator|=
name|base
expr_stmt|;
name|base
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* now, offset, base and indexexp are set */
if|if
condition|(
operator|!
name|base
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|PC_RELATIVE
argument_list|)
operator|||
name|defined
argument_list|(
name|NO_ABSOLUTE_PREFIX_IF_SYMBOLIC
argument_list|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|offset
argument_list|)
operator|==
name|CONST_INT
condition|)
comment|/*      if (! (GET_CODE (offset) == LABEL_REF 	     || GET_CODE (offset) == SYMBOL_REF)) */
endif|#
directive|endif
name|PUT_ABSOLUTE_PREFIX
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|base
condition|)
comment|/* base can be (REG ...) or (MEM ...) */
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|base
argument_list|)
condition|)
block|{
comment|/* now we must output base.  Possible alternatives are: 	   (rN)       (REG ...) 	   (sp)	      (REG ...) 	   (fp)       (REG ...) 	   (pc)       (REG ...)  used for SYMBOL_REF and LABEL_REF, output 	   (disp(fp)) (MEM ...)       just before possible [rX:y] 	   (disp(sp)) (MEM ...) 	   (disp(sb)) (MEM ...) 	   */
case|case
name|REG
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"(%s)"
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|base
argument_list|)
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEM
case|:
name|addr
operator|=
name|XEXP
argument_list|(
name|base
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|base
operator|=
name|NULL
expr_stmt|;
name|offset
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|addr
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|PLUS
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
condition|)
block|{
name|tmp
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tmp
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|tmp
operator|=
name|addr
expr_stmt|;
name|addr
operator|=
name|NULL
expr_stmt|;
block|}
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|tmp
argument_list|)
condition|)
block|{
case|case
name|REG
case|:
name|base
operator|=
name|tmp
expr_stmt|;
break|break;
case|case
name|CONST
case|:
case|case
name|CONST_INT
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
if|if
condition|(
name|offset
condition|)
name|offset
operator|=
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|SImode
argument_list|,
name|tmp
argument_list|,
name|offset
argument_list|)
expr_stmt|;
else|else
name|offset
operator|=
name|tmp
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|offset
condition|)
name|offset
operator|=
name|const0_rtx
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|base
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"(%s)"
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|base
argument_list|)
index|]
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BASE_REG_NEEDED
elseif|else
if|if
condition|(
name|TARGET_SB
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"(sb)"
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|fprintf
argument_list|(
name|file
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|PC_RELATIVE
elseif|else
comment|/* no base */
if|if
condition|(
name|GET_CODE
argument_list|(
name|offset
argument_list|)
operator|==
name|LABEL_REF
operator|||
name|GET_CODE
argument_list|(
name|offset
argument_list|)
operator|==
name|SYMBOL_REF
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"(pc)"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|BASE_REG_NEEDED
comment|/* this is defined if the assembler always 			   	   needs a base register */
elseif|else
if|if
condition|(
name|TARGET_SB
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"(sb)"
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* now print index if we have one */
if|if
condition|(
name|indexexp
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|indexexp
argument_list|)
operator|==
name|MULT
condition|)
block|{
name|scale
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|indexexp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|>>
literal|1
expr_stmt|;
name|indexexp
operator|=
name|XEXP
argument_list|(
name|indexexp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|scale
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|indexexp
argument_list|)
operator|!=
name|REG
operator|||
name|REGNO
argument_list|(
name|indexexp
argument_list|)
operator|>=
literal|8
condition|)
name|abort
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|UTEK_ASM
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"[%c`%s]"
argument_list|,
name|scales
index|[
name|scale
index|]
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|indexexp
argument_list|)
index|]
argument_list|)
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"[%s:%c]"
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|indexexp
argument_list|)
index|]
argument_list|,
name|scales
index|[
name|scale
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* National 32032 shifting is so bad that we can get    better performance in many common cases by using other    techniques.  */
end_comment

begin_function
name|char
modifier|*
name|output_shift_insn
parameter_list|(
name|operands
parameter_list|)
name|rtx
modifier|*
name|operands
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
operator|>
literal|0
operator|&&
name|INTVAL
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
operator|<=
literal|3
condition|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|REG
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|REG
condition|)
block|{
if|if
condition|(
name|REGNO
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|REGNO
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|operands
index|[
literal|2
index|]
operator|==
name|const1_rtx
condition|)
return|return
literal|"addd %0,%0"
return|;
elseif|else
if|if
condition|(
name|INTVAL
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
operator|==
literal|2
condition|)
return|return
literal|"addd %0,%0\n\taddd %0,%0"
return|;
block|}
if|if
condition|(
name|operands
index|[
literal|2
index|]
operator|==
name|const1_rtx
condition|)
return|return
literal|"movd %1,%0\n\taddd %0,%0"
return|;
name|operands
index|[
literal|1
index|]
operator|=
name|gen_indexed_expr
argument_list|(
name|const0_rtx
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|,
name|operands
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
return|return
literal|"addr %a1,%0"
return|;
block|}
if|if
condition|(
name|operands
index|[
literal|2
index|]
operator|==
name|const1_rtx
condition|)
return|return
literal|"movd %1,%0\n\taddd %0,%0"
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|REG
condition|)
block|{
name|operands
index|[
literal|1
index|]
operator|=
name|gen_indexed_expr
argument_list|(
name|const0_rtx
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|,
name|operands
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
return|return
literal|"addr %a1,%0"
return|;
block|}
elseif|else
if|if
condition|(
name|INTVAL
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
operator|==
literal|1
operator|&&
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|MEM
operator|&&
name|rtx_equal_p
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|rtx
name|temp
init|=
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|temp
argument_list|)
operator|==
name|REG
operator|||
operator|(
name|GET_CODE
argument_list|(
name|temp
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|)
condition|)
return|return
literal|"addd %0,%0"
return|;
block|}
else|else
return|return
literal|"ashd %2,%0"
return|;
return|return
literal|"ashd %2,%0"
return|;
block|}
end_function

end_unit

