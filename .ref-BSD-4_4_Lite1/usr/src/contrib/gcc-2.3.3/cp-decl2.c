begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Process declarations and variables for C compiler.    Copyright (C) 1988, 1992 Free Software Foundation, Inc.    Hacked by Michael Tiemann (tiemann@cygnus.com)  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* Process declarations and symbol lookup for C front end.    Also constructs types; the standard scalar types at initialization,    and structure, union, array and enum types when they are declared.  */
end_comment

begin_comment
comment|/* ??? not all decl nodes are given the most useful possible    line numbers.  For example, the CONST_DECLs for enum values.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"cp-tree.h"
end_include

begin_include
include|#
directive|include
file|"cp-lex.h"
end_include

begin_include
include|#
directive|include
file|"cp-decl.h"
end_include

begin_function_decl
specifier|extern
name|tree
name|grokdeclarator
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|grok_function_init
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* A list of virtual function tables we must make sure to write out.  */
end_comment

begin_decl_stmt
name|tree
name|pending_vtables
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A list of static class variables.  This is needed, because a    static class variable can be declared inside the class without    an initializer, and then initialized, staticly, outside the class.  */
end_comment

begin_decl_stmt
name|tree
name|pending_statics
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|tree
name|pending_addressable_inlines
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Used to help generate temporary names which are unique within    a function.  Reset to 0 by start_function.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|temp_name_counter
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Same, but not reset.  Local temp variables and global temp variables    can have the same name.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|global_temp_name_counter
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The (assembler) name of the first globally-visible object output.  */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|first_global_object_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Flag used when debugging cp-spew.c */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|spew_debug
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* C (and C++) language-specific option variables.  */
end_comment

begin_comment
comment|/* Nonzero means allow type mismatches in conditional expressions;    just make their values `void'.   */
end_comment

begin_decl_stmt
name|int
name|flag_cond_mismatch
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means give `double' the same size as `float'.  */
end_comment

begin_decl_stmt
name|int
name|flag_short_double
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means don't recognize the keyword `asm'.  */
end_comment

begin_decl_stmt
name|int
name|flag_no_asm
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means don't recognize the non-ANSI builtin functions.  */
end_comment

begin_decl_stmt
name|int
name|flag_no_builtin
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means do some things the same way PCC does.  */
end_comment

begin_decl_stmt
name|int
name|flag_traditional
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means to treat bitfields as unsigned unless they say `signed'.  */
end_comment

begin_decl_stmt
name|int
name|flag_signed_bitfields
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means handle `#ident' directives.  0 means ignore them.  */
end_comment

begin_decl_stmt
name|int
name|flag_no_ident
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means handle things in ANSI, instead of GNU fashion.  This    flag should be tested for language behavior that's different between    ANSI and GNU, but not so horrible as to merit a PEDANTIC label.  */
end_comment

begin_decl_stmt
name|int
name|flag_ansi
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means warn about implicit declarations.  */
end_comment

begin_decl_stmt
name|int
name|warn_implicit
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Like `warn_return_type', but this is set by users, whereas    `warn_return_type' is set by the compiler.  */
end_comment

begin_decl_stmt
name|int
name|explicit_warn_return_type
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means give string constants the type `const char *'    to get extra warnings from them.  These warnings will be too numerous    to be useful, except in thoroughly ANSIfied programs.  */
end_comment

begin_decl_stmt
name|int
name|warn_write_strings
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means warn about pointer casts that can drop a type qualifier    from the pointer target type.  */
end_comment

begin_decl_stmt
name|int
name|warn_cast_qual
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Warn about traditional constructs whose meanings changed in ANSI C.  */
end_comment

begin_decl_stmt
name|int
name|warn_traditional
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means warn about sizeof(function) or addition/subtraction    of function pointers.  */
end_comment

begin_decl_stmt
name|int
name|warn_pointer_arith
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means warn for non-prototype function decls    or non-prototyped defs without previous prototype.  */
end_comment

begin_decl_stmt
name|int
name|warn_strict_prototypes
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means warn for any function def without prototype decl.  */
end_comment

begin_decl_stmt
name|int
name|warn_missing_prototypes
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means warn about multiple (redundant) decls for the same single    variable or function.  */
end_comment

begin_decl_stmt
name|int
name|warn_redundant_decls
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Warn about *printf or *scanf format/argument anomalies. */
end_comment

begin_decl_stmt
name|int
name|warn_format
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Warn about a subscript that has type char.  */
end_comment

begin_decl_stmt
name|int
name|warn_char_subscripts
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Warn if a type conversion is done that might have confusing results.  */
end_comment

begin_decl_stmt
name|int
name|warn_conversion
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Warn if adding () is suggested.  */
end_comment

begin_decl_stmt
name|int
name|warn_parentheses
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero means warn in function declared in derived class has the    same name as a virtual in the base class, but fails to match the    type signature of any virtual function in the base class.  */
end_comment

begin_decl_stmt
name|int
name|warn_overloaded_virtual
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero means warn when converting between different enumeral types.  */
end_comment

begin_decl_stmt
name|int
name|warn_enum_clash
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero means warn when declaring a class that has a non virtual    destructor, when it really ought to have a virtual one. */
end_comment

begin_decl_stmt
name|int
name|warn_nonvdtor
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means `$' can be in an identifier.    See cccp.c for reasons why this breaks some obscure ANSI C programs.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|DOLLARS_IN_IDENTIFIERS
end_ifndef

begin_define
define|#
directive|define
name|DOLLARS_IN_IDENTIFIERS
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|dollars_in_ident
init|=
name|DOLLARS_IN_IDENTIFIERS
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero for -no-strict-prototype switch: do not consider empty    argument prototype to mean function takes no arguments.  */
end_comment

begin_decl_stmt
name|int
name|strict_prototype
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|strict_prototypes_lang_c
decl_stmt|,
name|strict_prototypes_lang_cplusplus
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means that labels can be used as first-class objects */
end_comment

begin_decl_stmt
name|int
name|flag_labels_ok
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero means to collect statistics which might be expensive    and to print them when we are done.  */
end_comment

begin_decl_stmt
name|int
name|flag_detailed_statistics
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* C++ specific flags.  */
end_comment

begin_comment
comment|/* Nonzero for -fall-virtual: make every member function (except    constructors) lay down in the virtual function table.  Calls    can then either go through the virtual function table or not,    depending.  */
end_comment

begin_decl_stmt
name|int
name|flag_all_virtual
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Zero means that `this' is a *const.  This gives nice behavior in the    2.0 world.  1 gives 1.2-compatible behavior.  2 gives Spring behavior.    -2 means we're constructing an object and it has fixed type.  */
end_comment

begin_decl_stmt
name|int
name|flag_this_is_variable
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means memoize our member lookups.  */
end_comment

begin_decl_stmt
name|int
name|flag_memoize_lookups
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flag_save_memoized_contexts
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 3 means write out only virtuals function tables `defined'    in this implementation file.    2 means write out only specific virtual function tables    and give them (C) public visibility.    1 means write out virtual function tables and give them    (C) public visibility.    0 means write out virtual function tables and give them    (C) static visibility (default).    -1 means declare virtual function tables extern.  */
end_comment

begin_decl_stmt
name|int
name|write_virtuals
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means we should attempt to elide constructors when possible.  */
end_comment

begin_decl_stmt
name|int
name|flag_elide_constructors
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Same, but for inline functions: nonzero means write out debug info    for inlines.  Zero means do not.  */
end_comment

begin_decl_stmt
name|int
name|flag_inline_debug
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means recognize and handle exception handling constructs.    2 means handle exceptions the way Spring wants them handled.  */
end_comment

begin_decl_stmt
name|int
name|flag_handle_exceptions
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means recognize and handle exception handling constructs.    Use ansi syntax and semantics.  WORK IN PROGRESS!    2 means handle exceptions the way Spring wants them handled.  */
end_comment

begin_decl_stmt
name|int
name|flag_ansi_exceptions
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means that member functions defined in class scope are    inline by default.  */
end_comment

begin_decl_stmt
name|int
name|flag_default_inline
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Controls whether enums and ints freely convert.    1 means with complete freedom.    0 means enums can convert to ints, but not vice-versa.  */
end_comment

begin_decl_stmt
name|int
name|flag_int_enum_equivalence
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Controls whether compiler is operating under LUCID's Cadillac    system.  1 means yes, 0 means no.  */
end_comment

begin_decl_stmt
name|int
name|flag_cadillac
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Controls whether compiler generates code to build objects    that can be collected when they become garbage.  */
end_comment

begin_decl_stmt
name|int
name|flag_gc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Controls whether compiler generates 'dossiers' that give    run-time type information.  */
end_comment

begin_decl_stmt
name|int
name|flag_dossier
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if we wish to output cross-referencing information    for the GNU class browser.  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|flag_gnu_xref
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if compiler can make `reasonable' assumptions about    references and objects.  For example, the compiler must be    conservative about the following and not assume that `a' is nonnull:     obj&a = g ();    a.f (2);     In general, it is `reasonable' to assume that for many programs,    and better code can be generated in that case.  */
end_comment

begin_decl_stmt
name|int
name|flag_assume_nonnull_objects
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Table of language-dependent -f options.    STRING is the option name.  VARIABLE is the address of the variable.    ON_VALUE is the value to store in VARIABLE     if `-fSTRING' is seen as an option.    (If `-fno-STRING' is seen as an option, the opposite value is stored.)  */
end_comment

begin_struct
specifier|static
struct|struct
block|{
name|char
modifier|*
name|string
decl_stmt|;
name|int
modifier|*
name|variable
decl_stmt|;
name|int
name|on_value
decl_stmt|;
block|}
name|lang_f_options
index|[]
init|=
block|{
block|{
literal|"signed-char"
block|,
operator|&
name|flag_signed_char
block|,
literal|1
block|}
block|,
block|{
literal|"unsigned-char"
block|,
operator|&
name|flag_signed_char
block|,
literal|0
block|}
block|,
block|{
literal|"signed-bitfields"
block|,
operator|&
name|flag_signed_bitfields
block|,
literal|1
block|}
block|,
block|{
literal|"unsigned-bitfields"
block|,
operator|&
name|flag_signed_bitfields
block|,
literal|0
block|}
block|,
block|{
literal|"short-enums"
block|,
operator|&
name|flag_short_enums
block|,
literal|1
block|}
block|,
block|{
literal|"short-double"
block|,
operator|&
name|flag_short_double
block|,
literal|1
block|}
block|,
block|{
literal|"cond-mismatch"
block|,
operator|&
name|flag_cond_mismatch
block|,
literal|1
block|}
block|,
block|{
literal|"asm"
block|,
operator|&
name|flag_no_asm
block|,
literal|0
block|}
block|,
block|{
literal|"builtin"
block|,
operator|&
name|flag_no_builtin
block|,
literal|0
block|}
block|,
block|{
literal|"ident"
block|,
operator|&
name|flag_no_ident
block|,
literal|0
block|}
block|,
block|{
literal|"labels-ok"
block|,
operator|&
name|flag_labels_ok
block|,
literal|1
block|}
block|,
block|{
literal|"stats"
block|,
operator|&
name|flag_detailed_statistics
block|,
literal|1
block|}
block|,
block|{
literal|"this-is-variable"
block|,
operator|&
name|flag_this_is_variable
block|,
literal|1
block|}
block|,
block|{
literal|"strict-prototype"
block|,
operator|&
name|strict_prototypes_lang_cplusplus
block|,
literal|1
block|}
block|,
block|{
literal|"all-virtual"
block|,
operator|&
name|flag_all_virtual
block|,
literal|1
block|}
block|,
block|{
literal|"memoize-lookups"
block|,
operator|&
name|flag_memoize_lookups
block|,
literal|1
block|}
block|,
block|{
literal|"elide-constructors"
block|,
operator|&
name|flag_elide_constructors
block|,
literal|1
block|}
block|,
block|{
literal|"inline-debug"
block|,
operator|&
name|flag_inline_debug
block|,
literal|0
block|}
block|,
block|{
literal|"handle-exceptions"
block|,
operator|&
name|flag_handle_exceptions
block|,
literal|1
block|}
block|,
block|{
literal|"ansi-exceptions"
block|,
operator|&
name|flag_ansi_exceptions
block|,
literal|1
block|}
block|,
block|{
literal|"spring-exceptions"
block|,
operator|&
name|flag_handle_exceptions
block|,
literal|2
block|}
block|,
block|{
literal|"default-inline"
block|,
operator|&
name|flag_default_inline
block|,
literal|1
block|}
block|,
block|{
literal|"dollars-in-identifiers"
block|,
operator|&
name|dollars_in_ident
block|,
literal|1
block|}
block|,
block|{
literal|"enum-int-equiv"
block|,
operator|&
name|flag_int_enum_equivalence
block|,
literal|1
block|}
block|,
block|{
literal|"gc"
block|,
operator|&
name|flag_gc
block|,
literal|1
block|}
block|,
block|{
literal|"dossier"
block|,
operator|&
name|flag_dossier
block|,
literal|1
block|}
block|,
block|{
literal|"xref"
block|,
operator|&
name|flag_gnu_xref
block|,
literal|1
block|}
block|,
block|{
literal|"nonnull-objects"
block|,
operator|&
name|flag_assume_nonnull_objects
block|,
literal|1
block|}
block|, }
struct|;
end_struct

begin_comment
comment|/* Decode the string P as a language-specific option.    Return 1 if it is recognized (and handle it);    return 0 if not recognized.  */
end_comment

begin_function
name|int
name|lang_decode_option
parameter_list|(
name|p
parameter_list|)
name|char
modifier|*
name|p
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"-ftraditional"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"-traditional"
argument_list|)
condition|)
name|flag_traditional
operator|=
literal|1
operator|,
name|dollars_in_ident
operator|=
literal|1
operator|,
name|flag_writable_strings
operator|=
literal|1
operator|,
name|flag_this_is_variable
operator|=
literal|1
expr_stmt|;
comment|/* The +e options are for cfront compatibility.  They come in as      `-+eN', to kludge around gcc.c's argument handling.  */
elseif|else
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'+'
operator|&&
name|p
index|[
literal|2
index|]
operator|==
literal|'e'
condition|)
block|{
name|int
name|old_write_virtuals
init|=
name|write_virtuals
decl_stmt|;
if|if
condition|(
name|p
index|[
literal|3
index|]
operator|==
literal|'1'
condition|)
name|write_virtuals
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|p
index|[
literal|3
index|]
operator|==
literal|'0'
condition|)
name|write_virtuals
operator|=
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|p
index|[
literal|3
index|]
operator|==
literal|'2'
condition|)
name|write_virtuals
operator|=
literal|2
expr_stmt|;
else|else
name|error
argument_list|(
literal|"invalid +e option"
argument_list|)
expr_stmt|;
if|if
condition|(
name|old_write_virtuals
operator|!=
literal|0
operator|&&
name|write_virtuals
operator|!=
name|old_write_virtuals
condition|)
name|error
argument_list|(
literal|"conflicting +e options given"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'f'
condition|)
block|{
comment|/* Some kind of -f option. 	 P's value is the option sans `-f'. 	 Search for it in the table of options.  */
name|int
name|found
init|=
literal|0
decl_stmt|,
name|j
decl_stmt|;
name|p
operator|+=
literal|2
expr_stmt|;
comment|/* Try special -f options.  */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"save-memoized"
argument_list|)
condition|)
block|{
name|flag_memoize_lookups
operator|=
literal|1
expr_stmt|;
name|flag_save_memoized_contexts
operator|=
literal|1
expr_stmt|;
name|found
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"no-save-memoized"
argument_list|)
condition|)
block|{
name|flag_memoize_lookups
operator|=
literal|0
expr_stmt|;
name|flag_save_memoized_contexts
operator|=
literal|0
expr_stmt|;
name|found
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"SOS"
argument_list|)
condition|)
block|{
name|flag_all_virtual
operator|=
literal|2
expr_stmt|;
name|found
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"no-SOS"
argument_list|)
condition|)
block|{
name|flag_all_virtual
operator|=
literal|0
expr_stmt|;
name|found
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"cadillac"
argument_list|,
literal|8
argument_list|)
condition|)
block|{
name|flag_cadillac
operator|=
name|atoi
argument_list|(
name|p
operator|+
literal|9
argument_list|)
expr_stmt|;
name|found
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"no-cadillac"
argument_list|,
literal|11
argument_list|)
condition|)
block|{
name|flag_cadillac
operator|=
literal|0
expr_stmt|;
name|found
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"gc"
argument_list|)
condition|)
block|{
name|flag_gc
operator|=
literal|1
expr_stmt|;
comment|/* This must come along for the ride.  */
name|flag_dossier
operator|=
literal|1
expr_stmt|;
name|found
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"no-gc"
argument_list|)
condition|)
block|{
name|flag_gc
operator|=
literal|0
expr_stmt|;
comment|/* This must come along for the ride.  */
name|flag_dossier
operator|=
literal|0
expr_stmt|;
name|found
operator|=
literal|1
expr_stmt|;
block|}
else|else
for|for
control|(
name|j
operator|=
literal|0
init|;
operator|!
name|found
operator|&&
name|j
operator|<
sizeof|sizeof
argument_list|(
name|lang_f_options
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|lang_f_options
index|[
literal|0
index|]
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
name|lang_f_options
index|[
name|j
index|]
operator|.
name|string
argument_list|)
condition|)
block|{
operator|*
name|lang_f_options
index|[
name|j
index|]
operator|.
name|variable
operator|=
name|lang_f_options
index|[
name|j
index|]
operator|.
name|on_value
expr_stmt|;
comment|/* A goto here would be cleaner, 		 but breaks the vax pcc.  */
name|found
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'n'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'o'
operator|&&
name|p
index|[
literal|2
index|]
operator|==
literal|'-'
operator|&&
operator|!
name|strcmp
argument_list|(
name|p
operator|+
literal|3
argument_list|,
name|lang_f_options
index|[
name|j
index|]
operator|.
name|string
argument_list|)
condition|)
block|{
operator|*
name|lang_f_options
index|[
name|j
index|]
operator|.
name|variable
operator|=
operator|!
name|lang_f_options
index|[
name|j
index|]
operator|.
name|on_value
expr_stmt|;
name|found
operator|=
literal|1
expr_stmt|;
block|}
block|}
return|return
name|found
return|;
block|}
elseif|else
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'W'
condition|)
block|{
name|int
name|setting
init|=
literal|1
decl_stmt|;
comment|/* The -W options control the warning behavior of the compiler.  */
name|p
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'n'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'o'
operator|&&
name|p
index|[
literal|2
index|]
operator|==
literal|'-'
condition|)
name|setting
operator|=
literal|0
operator|,
name|p
operator|+=
literal|3
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"implicit"
argument_list|)
condition|)
name|warn_implicit
operator|=
name|setting
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"return-type"
argument_list|)
condition|)
name|explicit_warn_return_type
operator|=
name|setting
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"write-strings"
argument_list|)
condition|)
name|warn_write_strings
operator|=
name|setting
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"cast-qual"
argument_list|)
condition|)
name|warn_cast_qual
operator|=
name|setting
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"traditional"
argument_list|)
condition|)
name|warn_traditional
operator|=
name|setting
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"char-subscripts"
argument_list|)
condition|)
name|warn_char_subscripts
operator|=
name|setting
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"pointer-arith"
argument_list|)
condition|)
name|warn_pointer_arith
operator|=
name|setting
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"strict-prototypes"
argument_list|)
condition|)
name|warn_strict_prototypes
operator|=
name|setting
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"missing-prototypes"
argument_list|)
condition|)
name|warn_missing_prototypes
operator|=
name|setting
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"redundant-decls"
argument_list|)
condition|)
name|warn_redundant_decls
operator|=
name|setting
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"format"
argument_list|)
condition|)
name|warn_format
operator|=
name|setting
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"conversion"
argument_list|)
condition|)
name|warn_conversion
operator|=
name|setting
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"parentheses"
argument_list|)
condition|)
name|warn_parentheses
operator|=
name|setting
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"comment"
argument_list|)
condition|)
empty_stmt|;
comment|/* cpp handles this one.  */
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"comments"
argument_list|)
condition|)
empty_stmt|;
comment|/* cpp handles this one.  */
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"trigraphs"
argument_list|)
condition|)
empty_stmt|;
comment|/* cpp handles this one.  */
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"import"
argument_list|)
condition|)
empty_stmt|;
comment|/* cpp handles this one.  */
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"all"
argument_list|)
condition|)
block|{
name|extra_warnings
operator|=
name|setting
expr_stmt|;
name|explicit_warn_return_type
operator|=
name|setting
expr_stmt|;
name|warn_unused
operator|=
name|setting
expr_stmt|;
name|warn_implicit
operator|=
name|setting
expr_stmt|;
name|warn_switch
operator|=
name|setting
expr_stmt|;
name|warn_uninitialized
operator|=
name|setting
expr_stmt|;
if|#
directive|if
literal|0
block|warn_enum_clash = setting;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"overloaded-virtual"
argument_list|)
condition|)
name|warn_overloaded_virtual
operator|=
name|setting
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"enum-clash"
argument_list|)
condition|)
name|warn_enum_clash
operator|=
name|setting
expr_stmt|;
else|else
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"-ansi"
argument_list|)
condition|)
name|flag_no_asm
operator|=
literal|1
operator|,
name|dollars_in_ident
operator|=
literal|0
operator|,
name|flag_ansi
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|SPEW_DEBUG
comment|/* Undocumented, only ever used when you're invoking cc1plus by hand, since      it's probably safe to assume no sane person would ever want to use this      under normal circumstances.  */
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"-spew-debug"
argument_list|)
condition|)
name|spew_debug
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
else|else
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Incorporate `const' and `volatile' qualifiers for member functions.    FUNCTION is a TYPE_DECL or a FUNCTION_DECL.    QUALS is a list of qualifiers.  */
end_comment

begin_function
name|tree
name|grok_method_quals
parameter_list|(
name|ctype
parameter_list|,
name|function
parameter_list|,
name|quals
parameter_list|)
name|tree
name|ctype
decl_stmt|,
name|function
decl_stmt|,
name|quals
decl_stmt|;
block|{
name|tree
name|fntype
init|=
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
decl_stmt|;
name|tree
name|raises
init|=
name|TYPE_RAISES_EXCEPTIONS
argument_list|(
name|fntype
argument_list|)
decl_stmt|;
do|do
block|{
specifier|extern
name|tree
name|ridpointers
index|[]
decl_stmt|;
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|quals
argument_list|)
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_CONST
index|]
condition|)
block|{
if|if
condition|(
name|TYPE_READONLY
argument_list|(
name|ctype
argument_list|)
condition|)
name|error
argument_list|(
literal|"duplicate `%s' %s"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|TREE_VALUE
argument_list|(
name|quals
argument_list|)
argument_list|)
argument_list|,
operator|(
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|==
name|FUNCTION_DECL
condition|?
literal|"for member function"
else|:
literal|"in type declaration"
operator|)
argument_list|)
expr_stmt|;
name|ctype
operator|=
name|build_type_variant
argument_list|(
name|ctype
argument_list|,
literal|1
argument_list|,
name|TYPE_VOLATILE
argument_list|(
name|ctype
argument_list|)
argument_list|)
expr_stmt|;
name|build_pointer_type
argument_list|(
name|ctype
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|quals
argument_list|)
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_VOLATILE
index|]
condition|)
block|{
if|if
condition|(
name|TYPE_VOLATILE
argument_list|(
name|ctype
argument_list|)
condition|)
name|error
argument_list|(
literal|"duplicate `%s' %s"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|TREE_VALUE
argument_list|(
name|quals
argument_list|)
argument_list|)
argument_list|,
operator|(
name|TREE_CODE
argument_list|(
name|function
argument_list|)
operator|==
name|FUNCTION_DECL
condition|?
literal|"for member function"
else|:
literal|"in type declaration"
operator|)
argument_list|)
expr_stmt|;
name|ctype
operator|=
name|build_type_variant
argument_list|(
name|ctype
argument_list|,
name|TYPE_READONLY
argument_list|(
name|ctype
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|build_pointer_type
argument_list|(
name|ctype
argument_list|)
expr_stmt|;
block|}
else|else
name|my_friendly_abort
argument_list|(
literal|20
argument_list|)
expr_stmt|;
name|quals
operator|=
name|TREE_CHAIN
argument_list|(
name|quals
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|quals
condition|)
do|;
name|fntype
operator|=
name|build_cplus_method_type
argument_list|(
name|ctype
argument_list|,
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
argument_list|,
operator|(
name|TREE_CODE
argument_list|(
name|fntype
argument_list|)
operator|==
name|METHOD_TYPE
condition|?
name|TREE_CHAIN
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|fntype
argument_list|)
argument_list|)
else|:
name|TYPE_ARG_TYPES
argument_list|(
name|fntype
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|raises
condition|)
name|fntype
operator|=
name|build_exception_variant
argument_list|(
name|ctype
argument_list|,
name|fntype
argument_list|,
name|raises
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
operator|=
name|fntype
expr_stmt|;
return|return
name|ctype
return|;
block|}
end_function

begin_comment
comment|/* This routine replaces cryptic DECL_NAMEs with readable DECL_NAMEs.    It leaves DECL_ASSEMBLER_NAMEs with the correct value.  */
end_comment

begin_comment
comment|/* This does not yet work with user defined conversion operators    It should.  */
end_comment

begin_function
specifier|static
name|void
name|substitute_nice_name
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
if|if
condition|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
block|{
specifier|extern
name|char
modifier|*
name|decl_as_string
parameter_list|()
function_decl|;
name|char
modifier|*
name|n
init|=
name|decl_as_string
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
index|[
name|strlen
argument_list|(
name|n
argument_list|)
operator|-
literal|1
index|]
operator|==
literal|' '
condition|)
name|n
index|[
name|strlen
argument_list|(
name|n
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
operator|=
name|get_identifier
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Classes overload their constituent function names automatically.    When a function name is declared in a record structure,    its name is changed to it overloaded name.  Since names for    constructors and destructors can conflict, we place a leading    '$' for destructors.     CNAME is the name of the class we are grokking for.     FUNCTION is a FUNCTION_DECL.  It was created by `grokdeclarator'.     FLAGS contains bits saying what's special about today's    arguments.  1 == DESTRUCTOR.  2 == OPERATOR.     If FUNCTION is a destructor, then we must add the `auto-delete' field    as a second parameter.  There is some hair associated with the fact    that we must "declare" this variable in the manner consistent with the    way the rest of the arguments were declared.     If FUNCTION is a constructor, and we are doing SOS hacks for dynamic    classes, then the second hidden argument is the virtual function table    pointer with which to initialize the object.     QUALS are the qualifiers for the this pointer.  */
end_comment

begin_function
name|void
name|grokclassfn
parameter_list|(
name|ctype
parameter_list|,
name|cname
parameter_list|,
name|function
parameter_list|,
name|flags
parameter_list|,
name|quals
parameter_list|)
name|tree
name|ctype
decl_stmt|,
name|cname
decl_stmt|,
name|function
decl_stmt|;
name|enum
name|overload_flags
name|flags
decl_stmt|;
name|tree
name|quals
decl_stmt|;
block|{
name|tree
name|fn_name
init|=
name|DECL_NAME
argument_list|(
name|function
argument_list|)
decl_stmt|;
name|tree
name|arg_types
decl_stmt|;
name|tree
name|parm
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
name|fn_name
operator|==
name|NULL_TREE
condition|)
block|{
name|error
argument_list|(
literal|"name missing for member function"
argument_list|)
expr_stmt|;
name|fn_name
operator|=
name|get_identifier
argument_list|(
literal|"<anonymous>"
argument_list|)
expr_stmt|;
name|DECL_NAME
argument_list|(
name|function
argument_list|)
operator|=
name|fn_name
expr_stmt|;
block|}
if|if
condition|(
name|quals
condition|)
name|ctype
operator|=
name|grok_method_quals
argument_list|(
name|ctype
argument_list|,
name|function
argument_list|,
name|quals
argument_list|)
expr_stmt|;
name|arg_types
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
block|{
comment|/* Must add the class instance variable up front.  */
comment|/* Right now we just make this a pointer.  But later 	 we may wish to make it special.  */
name|tree
name|type
init|=
name|TREE_VALUE
argument_list|(
name|arg_types
argument_list|)
decl_stmt|;
if|if
condition|(
name|flags
operator|==
name|DTOR_FLAG
condition|)
name|type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_CONSTRUCTOR_P
argument_list|(
name|function
argument_list|)
condition|)
block|{
if|if
condition|(
name|TYPE_DYNAMIC
argument_list|(
name|ctype
argument_list|)
condition|)
block|{
name|parm
operator|=
name|build_decl
argument_list|(
name|PARM_DECL
argument_list|,
name|get_identifier
argument_list|(
name|AUTO_VTABLE_NAME
argument_list|)
argument_list|,
name|TYPE_POINTER_TO
argument_list|(
name|ptr_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_USED
argument_list|(
name|parm
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_READONLY
argument_list|(
name|parm
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_ARG_TYPE
argument_list|(
name|parm
argument_list|)
operator|=
name|TYPE_POINTER_TO
argument_list|(
name|ptr_type_node
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
operator|=
name|last_function_parms
expr_stmt|;
name|last_function_parms
operator|=
name|parm
expr_stmt|;
block|}
if|if
condition|(
name|TYPE_USES_VIRTUAL_BASECLASSES
argument_list|(
name|ctype
argument_list|)
condition|)
block|{
name|DECL_CONSTRUCTOR_FOR_VBASE_P
argument_list|(
name|function
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* In this case we need "in-charge" flag saying whether 		 this constructor is responsible for initialization 		 of virtual baseclasses or not.  */
name|parm
operator|=
name|build_decl
argument_list|(
name|PARM_DECL
argument_list|,
name|in_charge_identifier
argument_list|,
name|integer_type_node
argument_list|)
expr_stmt|;
name|DECL_ARG_TYPE
argument_list|(
name|parm
argument_list|)
operator|=
name|integer_type_node
expr_stmt|;
name|DECL_REGISTER
argument_list|(
name|parm
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
operator|=
name|last_function_parms
expr_stmt|;
name|last_function_parms
operator|=
name|parm
expr_stmt|;
block|}
block|}
name|parm
operator|=
name|build_decl
argument_list|(
name|PARM_DECL
argument_list|,
name|this_identifier
argument_list|,
name|type
argument_list|)
expr_stmt|;
comment|/* Mark the artificial `this' parameter as "artificial".  */
name|DECL_SOURCE_LINE
argument_list|(
name|parm
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_ARG_TYPE
argument_list|(
name|parm
argument_list|)
operator|=
name|type
expr_stmt|;
comment|/* We can make this a register, so long as we don't 	 accidentally complain if someone tries to take its address.  */
name|DECL_REGISTER
argument_list|(
name|parm
argument_list|)
operator|=
literal|1
expr_stmt|;
if|#
directive|if
literal|0
comment|/* it is wrong to flag the object as readonly, when 	 flag_this_is_variable is 0. */
block|if (flags != DTOR_FLAG&& (flag_this_is_variable<= 0 || TYPE_READONLY (type)))
else|#
directive|else
if|if
condition|(
name|flags
operator|!=
name|DTOR_FLAG
operator|&&
name|TYPE_READONLY
argument_list|(
name|type
argument_list|)
condition|)
endif|#
directive|endif
name|TREE_READONLY
argument_list|(
name|parm
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
operator|=
name|last_function_parms
expr_stmt|;
name|last_function_parms
operator|=
name|parm
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|==
name|DTOR_FLAG
condition|)
block|{
name|char
modifier|*
name|buf
decl_stmt|,
modifier|*
name|dbuf
decl_stmt|;
name|tree
name|const_integer_type
init|=
name|build_type_variant
argument_list|(
name|integer_type_node
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|int
name|len
init|=
sizeof|sizeof
argument_list|(
name|DESTRUCTOR_DECL_PREFIX
argument_list|)
operator|-
literal|1
decl_stmt|;
name|arg_types
operator|=
name|hash_tree_chain
argument_list|(
name|const_integer_type
argument_list|,
name|void_list_node
argument_list|)
expr_stmt|;
comment|/* Build the overload name.  It will look like e.g. 7Example.  */
if|if
condition|(
name|IDENTIFIER_TYPE_VALUE
argument_list|(
name|cname
argument_list|)
condition|)
name|dbuf
operator|=
name|build_overload_name
argument_list|(
name|IDENTIFIER_TYPE_VALUE
argument_list|(
name|cname
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|IDENTIFIER_LOCAL_VALUE
argument_list|(
name|cname
argument_list|)
condition|)
name|dbuf
operator|=
name|build_overload_name
argument_list|(
name|TREE_TYPE
argument_list|(
name|IDENTIFIER_LOCAL_VALUE
argument_list|(
name|cname
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|my_friendly_abort
argument_list|(
literal|346
argument_list|)
expr_stmt|;
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|dbuf
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|DESTRUCTOR_DECL_PREFIX
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|DESTRUCTOR_DECL_PREFIX
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|buf
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|strcat
argument_list|(
name|buf
argument_list|,
name|dbuf
argument_list|)
expr_stmt|;
name|DECL_ASSEMBLER_NAME
argument_list|(
name|function
argument_list|)
operator|=
name|get_identifier
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|parm
operator|=
name|build_decl
argument_list|(
name|PARM_DECL
argument_list|,
name|in_charge_identifier
argument_list|,
name|const_integer_type
argument_list|)
expr_stmt|;
name|TREE_USED
argument_list|(
name|parm
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_READONLY
argument_list|(
name|parm
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_ARG_TYPE
argument_list|(
name|parm
argument_list|)
operator|=
name|const_integer_type
expr_stmt|;
comment|/* This is the same chain as DECL_ARGUMENTS (...).  */
name|TREE_CHAIN
argument_list|(
name|last_function_parms
argument_list|)
operator|=
name|parm
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
operator|=
name|build_cplus_method_type
argument_list|(
name|ctype
argument_list|,
name|void_type_node
argument_list|,
name|arg_types
argument_list|)
expr_stmt|;
name|TYPE_HAS_DESTRUCTOR
argument_list|(
name|ctype
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|tree
name|these_arg_types
decl_stmt|;
if|if
condition|(
name|TYPE_DYNAMIC
argument_list|(
name|ctype
argument_list|)
operator|&&
name|DECL_CONSTRUCTOR_P
argument_list|(
name|function
argument_list|)
condition|)
block|{
name|arg_types
operator|=
name|hash_tree_chain
argument_list|(
name|build_pointer_type
argument_list|(
name|ptr_type_node
argument_list|)
argument_list|,
name|TREE_CHAIN
argument_list|(
name|arg_types
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
operator|=
name|build_cplus_method_type
argument_list|(
name|ctype
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
argument_list|)
argument_list|,
name|arg_types
argument_list|)
expr_stmt|;
name|arg_types
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|DECL_CONSTRUCTOR_FOR_VBASE_P
argument_list|(
name|function
argument_list|)
condition|)
block|{
name|arg_types
operator|=
name|hash_tree_chain
argument_list|(
name|integer_type_node
argument_list|,
name|TREE_CHAIN
argument_list|(
name|arg_types
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
operator|=
name|build_cplus_method_type
argument_list|(
name|ctype
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
argument_list|)
argument_list|,
name|arg_types
argument_list|)
expr_stmt|;
name|arg_types
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|these_arg_types
operator|=
name|arg_types
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
comment|/* Only true for static member functions.  */
name|these_arg_types
operator|=
name|hash_tree_chain
argument_list|(
name|TYPE_POINTER_TO
argument_list|(
name|ctype
argument_list|)
argument_list|,
name|arg_types
argument_list|)
expr_stmt|;
name|DECL_ASSEMBLER_NAME
argument_list|(
name|function
argument_list|)
operator|=
name|build_decl_overload
argument_list|(
name|fn_name
argument_list|,
name|these_arg_types
argument_list|,
literal|1
operator|+
name|DECL_CONSTRUCTOR_P
argument_list|(
name|function
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* This code is going into the compiler, but currently, it makes 	 libg++/src/Interger.cc not compile.  The problem is that the nice name 	 winds up going into the symbol table, and conversion operations look 	 for the manged name.  */
block|substitute_nice_name (function);
endif|#
directive|endif
if|#
directive|if
literal|0
block|if (flags == TYPENAME_FLAG)
comment|/* Not exactly an IDENTIFIER_TYPE_VALUE.  */
block|TREE_TYPE (DECL_ASSEMBLER_NAME (function)) = TREE_TYPE (fn_name);
endif|#
directive|endif
block|}
name|DECL_ARGUMENTS
argument_list|(
name|function
argument_list|)
operator|=
name|last_function_parms
expr_stmt|;
comment|/* First approximations.  */
name|DECL_CONTEXT
argument_list|(
name|function
argument_list|)
operator|=
name|ctype
expr_stmt|;
name|DECL_CLASS_CONTEXT
argument_list|(
name|function
argument_list|)
operator|=
name|ctype
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Sanity check: report error if this function FUNCTION is not    really a member of the class (CTYPE) it is supposed to belong to.    CNAME and FLAGS are the same here as they are for grokclassfn above.  */
end_comment

begin_function
name|void
name|check_classfn
parameter_list|(
name|ctype
parameter_list|,
name|cname
parameter_list|,
name|function
parameter_list|,
name|flags
parameter_list|)
name|tree
name|ctype
decl_stmt|,
name|cname
decl_stmt|,
name|function
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|tree
name|fn_name
init|=
name|DECL_NAME
argument_list|(
name|function
argument_list|)
decl_stmt|;
name|tree
name|fndecl
decl_stmt|;
name|int
name|need_quotes
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|err_name
decl_stmt|;
name|tree
name|method_vec
init|=
name|CLASSTYPE_METHOD_VEC
argument_list|(
name|ctype
argument_list|)
decl_stmt|;
name|tree
modifier|*
name|methods
init|=
literal|0
decl_stmt|;
name|tree
modifier|*
name|end
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|method_vec
operator|!=
literal|0
condition|)
block|{
name|methods
operator|=
operator|&
name|TREE_VEC_ELT
argument_list|(
name|method_vec
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|end
operator|=
name|TREE_VEC_END
argument_list|(
name|method_vec
argument_list|)
expr_stmt|;
comment|/* First suss out ctors and dtors.  */
if|if
condition|(
operator|*
name|methods
operator|&&
name|fn_name
operator|==
name|cname
condition|)
goto|goto
name|got_it
goto|;
while|while
condition|(
operator|++
name|methods
operator|!=
name|end
condition|)
block|{
if|if
condition|(
name|fn_name
operator|==
name|DECL_NAME
argument_list|(
operator|*
name|methods
argument_list|)
condition|)
block|{
name|got_it
label|:
name|fndecl
operator|=
operator|*
name|methods
expr_stmt|;
while|while
condition|(
name|fndecl
condition|)
block|{
if|if
condition|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|function
argument_list|)
operator|==
name|DECL_ASSEMBLER_NAME
argument_list|(
name|fndecl
argument_list|)
condition|)
return|return;
name|fndecl
operator|=
name|DECL_CHAIN
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* loser */
block|}
block|}
block|}
if|if
condition|(
name|fn_name
operator|==
name|ansi_opname
index|[
operator|(
name|int
operator|)
name|TYPE_EXPR
index|]
condition|)
block|{
if|if
condition|(
name|TYPE_HAS_CONVERSION
argument_list|(
name|ctype
argument_list|)
condition|)
name|err_name
operator|=
literal|"such type conversion operator"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IDENTIFIER_OPNAME_P
argument_list|(
name|fn_name
argument_list|)
condition|)
block|{
name|err_name
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
literal|1024
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|err_name
argument_list|,
literal|"`operator %s'"
argument_list|,
name|operator_name_string
argument_list|(
name|fn_name
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|err_name
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|fn_name
argument_list|)
expr_stmt|;
name|need_quotes
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|methods
operator|!=
name|end
condition|)
if|if
condition|(
name|need_quotes
condition|)
name|error
argument_list|(
literal|"argument list for `%s' does not match any in class"
argument_list|,
name|err_name
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"argument list for %s does not match any in class"
argument_list|,
name|err_name
argument_list|)
expr_stmt|;
else|else
block|{
name|methods
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|need_quotes
condition|)
name|error
argument_list|(
literal|"no `%s' member function declared in class"
argument_list|,
name|err_name
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"no %s declared in class"
argument_list|,
name|err_name
argument_list|)
expr_stmt|;
block|}
comment|/* If we did not find the method in the class, add it to      avoid spurious errors.  */
name|add_method
argument_list|(
name|ctype
argument_list|,
name|methods
argument_list|,
name|function
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Process the specs, declarator (NULL if omitted) and width (NULL if omitted)    of a structure component, returning a FIELD_DECL node.    QUALS is a list of type qualifiers for this decl (such as for declaring    const member functions).     This is done during the parsing of the struct declaration.    The FIELD_DECL nodes are chained together and the lot of them    are ultimately passed to `build_struct' to make the RECORD_TYPE node.     C++:     If class A defines that certain functions in class B are friends, then    the way I have set things up, it is B who is interested in permission    granted by A.  However, it is in A's context that these declarations    are parsed.  By returning a void_type_node, class A does not attempt    to incorporate the declarations of the friends within its structure.     DO NOT MAKE ANY CHANGES TO THIS CODE WITHOUT MAKING CORRESPONDING    CHANGES TO CODE IN `start_method'.  */
end_comment

begin_function
name|tree
name|grokfield
parameter_list|(
name|declarator
parameter_list|,
name|declspecs
parameter_list|,
name|raises
parameter_list|,
name|init
parameter_list|,
name|asmspec_tree
parameter_list|)
name|tree
name|declarator
decl_stmt|,
name|declspecs
decl_stmt|,
name|raises
decl_stmt|,
name|init
decl_stmt|;
name|tree
name|asmspec_tree
decl_stmt|;
block|{
specifier|register
name|tree
name|value
decl_stmt|;
name|char
modifier|*
name|asmspec
init|=
literal|0
decl_stmt|;
comment|/* Convert () initializers to = initializers.  */
if|if
condition|(
name|init
operator|==
name|NULL_TREE
operator|&&
name|declarator
operator|!=
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|declarator
argument_list|)
operator|==
name|CALL_EXPR
operator|&&
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|0
argument_list|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|IDENTIFIER_NODE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SCOPE_REF
operator|)
operator|&&
name|parmlist_is_exprlist
argument_list|(
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|init
operator|=
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|declarator
operator|=
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|init
operator|&&
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|TREE_LIST
operator|&&
name|TREE_VALUE
argument_list|(
name|init
argument_list|)
operator|==
name|error_mark_node
operator|&&
name|TREE_CHAIN
argument_list|(
name|init
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|init
operator|=
name|NULL_TREE
expr_stmt|;
name|value
operator|=
name|grokdeclarator
argument_list|(
name|declarator
argument_list|,
name|declspecs
argument_list|,
name|FIELD
argument_list|,
name|init
operator|!=
literal|0
argument_list|,
name|raises
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|value
condition|)
return|return
name|NULL_TREE
return|;
comment|/* friends went bad.  */
comment|/* Pass friendly classes back.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|VOID_TYPE
condition|)
return|return
name|void_type_node
return|;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|value
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|value
argument_list|)
argument_list|)
index|[
literal|0
index|]
operator|==
literal|'_'
operator|&&
operator|!
name|strcmp
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|value
argument_list|)
argument_list|)
argument_list|,
literal|"_vptr"
argument_list|)
condition|)
name|error_with_decl
argument_list|(
name|value
argument_list|,
literal|"member `%s' conflicts with virtual function table field name"
argument_list|)
expr_stmt|;
comment|/* Stash away type declarations.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
name|DECL_NONLOCAL
argument_list|(
name|value
argument_list|)
operator|=
literal|1
expr_stmt|;
name|CLASSTYPE_LOCAL_TYPEDECLS
argument_list|(
name|current_class_type
argument_list|)
operator|=
literal|1
expr_stmt|;
name|pushdecl_class_level
argument_list|(
name|value
argument_list|)
expr_stmt|;
return|return
name|value
return|;
block|}
if|if
condition|(
name|DECL_IN_AGGR_P
argument_list|(
name|value
argument_list|)
condition|)
block|{
name|error_with_decl
argument_list|(
name|value
argument_list|,
literal|"`%s' is already defined in the class %s"
argument_list|,
name|TYPE_NAME_STRING
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|value
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|void_type_node
return|;
block|}
if|if
condition|(
name|flag_cadillac
condition|)
name|cadillac_start_decl
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|asmspec_tree
condition|)
name|asmspec
operator|=
name|TREE_STRING_POINTER
argument_list|(
name|asmspec_tree
argument_list|)
expr_stmt|;
if|if
condition|(
name|init
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
name|grok_function_init
argument_list|(
name|value
argument_list|,
name|init
argument_list|)
expr_stmt|;
name|init
operator|=
name|NULL_TREE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pedantic
condition|)
block|{
name|error
argument_list|(
literal|"fields cannot have initializers"
argument_list|)
expr_stmt|;
name|init
operator|=
name|NULL_TREE
expr_stmt|;
block|}
else|else
block|{
comment|/* We allow initializers to become parameters to base initializers.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|TREE_LIST
condition|)
block|{
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|init
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|init
operator|=
name|TREE_VALUE
argument_list|(
name|init
argument_list|)
expr_stmt|;
else|else
name|init
operator|=
name|digest_init
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|,
name|init
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"field declaration"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|CONST_DECL
condition|)
name|init
operator|=
name|DECL_INITIAL
argument_list|(
name|init
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_READONLY_DECL_P
argument_list|(
name|init
argument_list|)
condition|)
name|init
operator|=
name|decl_constant_value
argument_list|(
name|init
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|CONSTRUCTOR
condition|)
name|init
operator|=
name|digest_init
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|,
name|init
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_PERMANENT
argument_list|(
name|init
argument_list|)
argument_list|,
literal|192
argument_list|)
expr_stmt|;
if|if
condition|(
name|init
operator|==
name|error_mark_node
condition|)
comment|/* We must make this look different than `error_mark_node' 	       because `decl_const_value' would mis-interpret it 	       as only meaning that this VAR_DECL is defined.  */
name|init
operator|=
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|,
name|init
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|TREE_CONSTANT
argument_list|(
name|init
argument_list|)
condition|)
block|{
comment|/* We can allow references to things that are effectively 		 static, since references are initialized with the address.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|)
operator|!=
name|REFERENCE_TYPE
operator|||
operator|(
name|TREE_STATIC
argument_list|(
name|init
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|init
argument_list|)
argument_list|)
operator|!=
literal|'d'
operator|||
name|DECL_EXTERNAL
argument_list|(
name|init
argument_list|)
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"field initializer is not constant"
argument_list|)
expr_stmt|;
name|init
operator|=
name|error_mark_node
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* The corresponding pop_obstacks is in finish_decl.  */
name|push_obstacks_nochange
argument_list|()
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|VAR_DECL
condition|)
block|{
comment|/* We cannot call pushdecl here, because that would 	 fill in the value of our TREE_CHAIN.  Instead, we 	 modify finish_decl to do the right thing, namely, to 	 put this decl out straight away.  */
if|if
condition|(
name|TREE_STATIC
argument_list|(
name|value
argument_list|)
condition|)
block|{
comment|/* current_class_type can be NULL_TREE in case of error.  */
if|if
condition|(
name|asmspec
operator|==
literal|0
operator|&&
name|current_class_type
condition|)
block|{
name|tree
name|name
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|,
modifier|*
name|buf2
decl_stmt|;
name|buf2
operator|=
name|build_overload_name
argument_list|(
name|current_class_type
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|IDENTIFIER_LENGTH
argument_list|(
name|DECL_NAME
argument_list|(
name|value
argument_list|)
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|STATIC_NAME_FORMAT
argument_list|)
operator|+
name|strlen
argument_list|(
name|buf2
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
name|STATIC_NAME_FORMAT
argument_list|,
name|buf2
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|value
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|name
operator|=
name|get_identifier
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|value
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|value
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
name|DECL_ASSEMBLER_NAME
argument_list|(
name|value
argument_list|)
operator|=
name|name
expr_stmt|;
block|}
name|pending_statics
operator|=
name|perm_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|value
argument_list|,
name|pending_statics
argument_list|)
expr_stmt|;
comment|/* Static consts need not be initialized in the class definition.  */
if|if
condition|(
name|init
operator|!=
name|NULL_TREE
operator|&&
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|)
condition|)
block|{
specifier|static
name|int
name|explanation
init|=
literal|0
decl_stmt|;
name|error
argument_list|(
literal|"initializer invalid for static member with constructor"
argument_list|)
expr_stmt|;
if|if
condition|(
name|explanation
operator|++
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"(you really want to initialize it separately)"
argument_list|)
expr_stmt|;
name|init
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Force the compiler to know when an uninitialized static 	     const member is being used.  */
if|if
condition|(
name|TYPE_READONLY
argument_list|(
name|value
argument_list|)
operator|&&
name|init
operator|==
literal|0
condition|)
name|TREE_USED
argument_list|(
name|value
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
name|DECL_INITIAL
argument_list|(
name|value
argument_list|)
operator|=
name|init
expr_stmt|;
name|DECL_IN_AGGR_P
argument_list|(
name|value
argument_list|)
operator|=
literal|1
expr_stmt|;
name|finish_decl
argument_list|(
name|value
argument_list|,
name|init
argument_list|,
name|asmspec_tree
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pushdecl_class_level
argument_list|(
name|value
argument_list|)
expr_stmt|;
return|return
name|value
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|FIELD_DECL
condition|)
block|{
if|if
condition|(
name|asmspec
condition|)
name|DECL_ASSEMBLER_NAME
argument_list|(
name|value
argument_list|)
operator|=
name|get_identifier
argument_list|(
name|asmspec
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|value
argument_list|)
operator|==
name|error_mark_node
condition|)
name|init
operator|=
name|error_mark_node
expr_stmt|;
name|finish_decl
argument_list|(
name|value
argument_list|,
name|init
argument_list|,
name|asmspec_tree
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|value
argument_list|)
operator|=
name|init
expr_stmt|;
name|DECL_IN_AGGR_P
argument_list|(
name|value
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|value
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
comment|/* grokdeclarator defers setting this.  */
name|TREE_PUBLIC
argument_list|(
name|value
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|DECL_CHAIN
argument_list|(
name|value
argument_list|)
operator|!=
name|NULL_TREE
condition|)
block|{
comment|/* Need a fresh node here so that we don't get circularity 	     when we link these together.  */
name|value
operator|=
name|copy_node
argument_list|(
name|value
argument_list|)
expr_stmt|;
comment|/* When does this happen?  */
name|my_friendly_assert
argument_list|(
name|init
operator|==
name|NULL_TREE
argument_list|,
literal|193
argument_list|)
expr_stmt|;
block|}
name|finish_decl
argument_list|(
name|value
argument_list|,
name|init
argument_list|,
name|asmspec_tree
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Pass friends back this way.  */
if|if
condition|(
name|DECL_FRIEND_P
argument_list|(
name|value
argument_list|)
condition|)
return|return
name|void_type_node
return|;
name|DECL_IN_AGGR_P
argument_list|(
name|value
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|value
return|;
block|}
name|my_friendly_abort
argument_list|(
literal|21
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Like `grokfield', but for bitfields.    WIDTH is non-NULL for bit fields only, and is an INTEGER_CST node.  */
end_comment

begin_function
name|tree
name|grokbitfield
parameter_list|(
name|declarator
parameter_list|,
name|declspecs
parameter_list|,
name|width
parameter_list|)
name|tree
name|declarator
decl_stmt|,
name|declspecs
decl_stmt|,
name|width
decl_stmt|;
block|{
specifier|register
name|tree
name|value
init|=
name|grokdeclarator
argument_list|(
name|declarator
argument_list|,
name|declspecs
argument_list|,
name|BITFIELD
argument_list|,
literal|0
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|value
condition|)
return|return
name|NULL_TREE
return|;
comment|/* friends went bad.  */
comment|/* Pass friendly classes back.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|VOID_TYPE
condition|)
return|return
name|void_type_node
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
name|error_with_decl
argument_list|(
name|value
argument_list|,
literal|"cannot declare `%s' to be a bitfield type"
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
if|if
condition|(
name|DECL_IN_AGGR_P
argument_list|(
name|value
argument_list|)
condition|)
block|{
name|error_with_decl
argument_list|(
name|value
argument_list|,
literal|"`%s' is already defined in the class %s"
argument_list|,
name|TYPE_NAME_STRING
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|value
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|void_type_node
return|;
block|}
name|GNU_xref_member
argument_list|(
name|current_class_name
argument_list|,
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_STATIC
argument_list|(
name|value
argument_list|)
condition|)
block|{
name|error_with_decl
argument_list|(
name|value
argument_list|,
literal|"static member `%s' cannot be a bitfield"
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
name|finish_decl
argument_list|(
name|value
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|width
operator|!=
name|error_mark_node
condition|)
block|{
comment|/* detect invalid field size.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|width
argument_list|)
operator|==
name|CONST_DECL
condition|)
name|width
operator|=
name|DECL_INITIAL
argument_list|(
name|width
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_READONLY_DECL_P
argument_list|(
name|width
argument_list|)
condition|)
name|width
operator|=
name|decl_constant_value
argument_list|(
name|width
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|width
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
block|{
name|error_with_decl
argument_list|(
name|value
argument_list|,
literal|"structure field `%s' width not an integer constant"
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|value
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
else|else
block|{
name|DECL_INITIAL
argument_list|(
name|value
argument_list|)
operator|=
name|width
expr_stmt|;
name|DECL_BIT_FIELD
argument_list|(
name|value
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|DECL_IN_AGGR_P
argument_list|(
name|value
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|value
return|;
block|}
end_function

begin_comment
comment|/* Like GROKFIELD, except that the declarator has been    buried in DECLSPECS.  Find the declarator, and    return something that looks like it came from    GROKFIELD.  */
end_comment

begin_function
name|tree
name|groktypefield
parameter_list|(
name|declspecs
parameter_list|,
name|parmlist
parameter_list|)
name|tree
name|declspecs
decl_stmt|;
name|tree
name|parmlist
decl_stmt|;
block|{
name|tree
name|spec
init|=
name|declspecs
decl_stmt|;
name|tree
name|prev
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|type_id
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|quals
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|lengths
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|decl
init|=
name|NULL_TREE
decl_stmt|;
while|while
condition|(
name|spec
condition|)
block|{
specifier|register
name|tree
name|id
init|=
name|TREE_VALUE
argument_list|(
name|spec
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|spec
argument_list|)
operator|!=
name|TREE_LIST
condition|)
comment|/* Certain parse errors slip through.  For example, 	   `int class ();' is not caught by the parser. Try 	   weakly to recover here.  */
return|return
name|NULL_TREE
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|id
argument_list|)
operator|==
name|TYPE_DECL
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|id
argument_list|)
operator|==
name|IDENTIFIER_NODE
operator|&&
name|TREE_TYPE
argument_list|(
name|id
argument_list|)
operator|)
condition|)
block|{
comment|/* We have a constructor/destructor or 	     conversion operator.  Use it.  */
if|if
condition|(
name|prev
condition|)
name|TREE_CHAIN
argument_list|(
name|prev
argument_list|)
operator|=
name|TREE_CHAIN
argument_list|(
name|spec
argument_list|)
expr_stmt|;
else|else
name|declspecs
operator|=
name|TREE_CHAIN
argument_list|(
name|spec
argument_list|)
expr_stmt|;
name|type_id
operator|=
name|id
expr_stmt|;
goto|goto
name|found
goto|;
block|}
name|prev
operator|=
name|spec
expr_stmt|;
name|spec
operator|=
name|TREE_CHAIN
argument_list|(
name|spec
argument_list|)
expr_stmt|;
block|}
comment|/* Nope, we have a conversion operator to a scalar type or something      else, that includes things like constructor declarations for      templates.  */
name|spec
operator|=
name|declspecs
expr_stmt|;
while|while
condition|(
name|spec
condition|)
block|{
name|tree
name|id
init|=
name|TREE_VALUE
argument_list|(
name|spec
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|id
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
block|{
if|if
condition|(
name|id
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_INT
index|]
operator|||
name|id
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_DOUBLE
index|]
operator|||
name|id
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_FLOAT
index|]
operator|||
name|id
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_WCHAR
index|]
condition|)
block|{
if|if
condition|(
name|type_id
condition|)
name|error
argument_list|(
literal|"extra `%s' ignored"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|type_id
operator|=
name|id
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|id
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_LONG
index|]
operator|||
name|id
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_SHORT
index|]
operator|||
name|id
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_CHAR
index|]
condition|)
block|{
name|lengths
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|id
argument_list|,
name|lengths
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|id
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_VOID
index|]
condition|)
block|{
if|if
condition|(
name|type_id
condition|)
name|error
argument_list|(
literal|"spurious `void' type ignored"
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"conversion to `void' type invalid"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|id
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_AUTO
index|]
operator|||
name|id
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_REGISTER
index|]
operator|||
name|id
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_TYPEDEF
index|]
operator|||
name|id
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_CONST
index|]
operator|||
name|id
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_VOLATILE
index|]
condition|)
block|{
name|error
argument_list|(
literal|"type specifier `%s' used invalidly"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|id
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_FRIEND
index|]
operator|||
name|id
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_VIRTUAL
index|]
operator|||
name|id
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_INLINE
index|]
operator|||
name|id
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_UNSIGNED
index|]
operator|||
name|id
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_SIGNED
index|]
operator|||
name|id
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_STATIC
index|]
operator|||
name|id
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_EXTERN
index|]
condition|)
block|{
name|quals
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|id
argument_list|,
name|quals
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Happens when we have a global typedef 		 and a class-local member function with 		 the same name.  */
name|type_id
operator|=
name|id
expr_stmt|;
goto|goto
name|found
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|id
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
block|{
name|type_id
operator|=
name|TYPE_NAME
argument_list|(
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type_id
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|type_id
operator|=
name|DECL_NAME
argument_list|(
name|type_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|type_id
operator|==
name|NULL_TREE
condition|)
name|error
argument_list|(
literal|"identifier for aggregate type conversion omitted"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|id
argument_list|)
argument_list|)
operator|==
literal|'t'
condition|)
block|{
name|error
argument_list|(
literal|"`operator' missing on conversion operator or tag missing from type"
argument_list|)
expr_stmt|;
block|}
else|else
name|my_friendly_assert
argument_list|(
literal|0
argument_list|,
literal|194
argument_list|)
expr_stmt|;
name|spec
operator|=
name|TREE_CHAIN
argument_list|(
name|spec
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|type_id
condition|)
block|{
name|declspecs
operator|=
name|chainon
argument_list|(
name|lengths
argument_list|,
name|quals
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lengths
condition|)
block|{
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|lengths
argument_list|)
condition|)
name|error
argument_list|(
literal|"multiple length specifiers"
argument_list|)
expr_stmt|;
name|type_id
operator|=
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_INT
index|]
expr_stmt|;
name|declspecs
operator|=
name|chainon
argument_list|(
name|lengths
argument_list|,
name|quals
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|quals
condition|)
block|{
name|error
argument_list|(
literal|"no type given, defaulting to `operator int ...'"
argument_list|)
expr_stmt|;
name|type_id
operator|=
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_INT
index|]
expr_stmt|;
name|declspecs
operator|=
name|quals
expr_stmt|;
block|}
else|else
return|return
name|NULL_TREE
return|;
name|found
label|:
name|decl
operator|=
name|grokdeclarator
argument_list|(
name|build_parse_node
argument_list|(
name|CALL_EXPR
argument_list|,
name|type_id
argument_list|,
name|parmlist
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|,
name|declspecs
argument_list|,
name|FIELD
argument_list|,
literal|0
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl
operator|==
name|NULL_TREE
condition|)
return|return
name|NULL_TREE
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_CHAIN
argument_list|(
name|decl
argument_list|)
operator|!=
name|NULL_TREE
condition|)
block|{
comment|/* Need a fresh node here so that we don't get circularity 	 when we link these together.  */
name|decl
operator|=
name|copy_node
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|decl
operator|==
name|void_type_node
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|!=
name|METHOD_TYPE
operator|)
condition|)
comment|/* bunch of friends.  */
return|return
name|decl
return|;
if|if
condition|(
name|DECL_IN_AGGR_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"`%s' already defined in the class "
argument_list|)
expr_stmt|;
return|return
name|void_type_node
return|;
block|}
name|finish_decl
argument_list|(
name|decl
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If this declaration is common to another declaration      complain about such redundancy, and return NULL_TREE      so that we don't build a circular list.  */
if|if
condition|(
name|DECL_CHAIN
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"function `%s' declared twice in class %s"
argument_list|,
name|TYPE_NAME_STRING
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
name|DECL_IN_AGGR_P
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|decl
return|;
block|}
end_function

begin_comment
comment|/* The precedence rules of this grammar (or any other deterministic LALR    grammar, for that matter), place the CALL_EXPR somewhere where we    may not want it.  The solution is to grab the first CALL_EXPR we see,    pretend that that is the one that belongs to the parameter list of    the type conversion function, and leave everything else alone.    We pull it out in place.     CALL_REQUIRED is non-zero if we should complain if a CALL_EXPR    does not appear in DECL.  */
end_comment

begin_function
name|tree
name|grokoptypename
parameter_list|(
name|decl
parameter_list|,
name|call_required
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|int
name|call_required
decl_stmt|;
block|{
name|tree
name|tmp
decl_stmt|,
name|last
decl_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TYPE_EXPR
argument_list|,
literal|195
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|last
operator|=
name|NULL_TREE
expr_stmt|;
while|while
condition|(
name|tmp
condition|)
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|tmp
argument_list|)
condition|)
block|{
case|case
name|CALL_EXPR
case|:
block|{
name|tree
name|parms
init|=
name|TREE_OPERAND
argument_list|(
name|tmp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|last
condition|)
name|TREE_OPERAND
argument_list|(
name|last
argument_list|,
literal|0
argument_list|)
operator|=
name|TREE_OPERAND
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
operator|=
name|TREE_OPERAND
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|parms
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|parms
argument_list|)
argument_list|)
operator|==
name|TREE_LIST
condition|)
name|TREE_VALUE
argument_list|(
name|parms
argument_list|)
operator|=
name|grokdeclarator
argument_list|(
name|TREE_VALUE
argument_list|(
name|TREE_VALUE
argument_list|(
name|parms
argument_list|)
argument_list|)
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|TREE_VALUE
argument_list|(
name|parms
argument_list|)
argument_list|)
argument_list|,
name|TYPENAME
argument_list|,
literal|0
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|parms
condition|)
block|{
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|parms
argument_list|)
operator|!=
name|void_type_node
condition|)
name|error
argument_list|(
literal|"operator<typename> requires empty parameter list"
argument_list|)
expr_stmt|;
else|else
comment|/* Canonicalize parameter lists.  */
name|TREE_OPERAND
argument_list|(
name|tmp
argument_list|,
literal|1
argument_list|)
operator|=
name|void_list_node
expr_stmt|;
block|}
name|last
operator|=
name|grokdeclarator
argument_list|(
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|TYPENAME
argument_list|,
literal|0
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|)
operator|=
name|build_typename_overload
argument_list|(
name|last
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|=
name|last
expr_stmt|;
return|return
name|tmp
return|;
block|}
case|case
name|INDIRECT_REF
case|:
case|case
name|ADDR_EXPR
case|:
case|case
name|ARRAY_REF
case|:
break|break;
case|case
name|SCOPE_REF
case|:
comment|/* This is legal when declaring a conversion to 	     something of type pointer-to-member.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|tmp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|INDIRECT_REF
condition|)
block|{
name|tmp
operator|=
name|TREE_OPERAND
argument_list|(
name|tmp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|#
directive|if
literal|0
comment|/* We may need to do this if grokdeclarator cannot handle this.  */
block|error ("type `member of class %s' invalid return type", 		     TYPE_NAME_STRING (TREE_OPERAND (tmp, 0))); 	      TREE_OPERAND (tmp, 1) = build_parse_node (INDIRECT_REF, TREE_OPERAND (tmp, 1));
endif|#
directive|endif
name|tmp
operator|=
name|TREE_OPERAND
argument_list|(
name|tmp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|my_friendly_assert
argument_list|(
literal|0
argument_list|,
literal|196
argument_list|)
expr_stmt|;
block|}
name|last
operator|=
name|tmp
expr_stmt|;
name|tmp
operator|=
name|TREE_OPERAND
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|call_required
condition|)
name|error
argument_list|(
literal|"operator<typename> construct requires parameter list"
argument_list|)
expr_stmt|;
name|last
operator|=
name|grokdeclarator
argument_list|(
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|TYPENAME
argument_list|,
literal|0
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|build_parse_node
argument_list|(
name|CALL_EXPR
argument_list|,
name|build_typename_overload
argument_list|(
name|last
argument_list|)
argument_list|,
name|void_list_node
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|=
name|last
expr_stmt|;
return|return
name|tmp
return|;
block|}
end_function

begin_comment
comment|/* When a function is declared with an initializer,    do the right thing.  Currently, there are two possibilities:     class B    {     public:      // initialization possibility #1.      virtual void f () = 0;      int g ();    };        class D1 : B    {     public:      int d1;      // error, no f ();    };        class D2 : B    {     public:      int d2;      void f ();    };        class D3 : B    {     public:      int d3;      // initialization possibility #2      void f () = B::f;    };  */
end_comment

begin_function
specifier|static
name|void
name|grok_function_init
parameter_list|(
name|decl
parameter_list|,
name|init
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|tree
name|init
decl_stmt|;
block|{
comment|/* An initializer for a function tells how this function should      be inherited.  */
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
decl_stmt|;
specifier|extern
name|tree
name|abort_fndecl
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"initializer specified for non-member function `%s'"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_VINDEX
argument_list|(
name|decl
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"initializer specified for non-virtual method `%s'"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|integer_zerop
argument_list|(
name|init
argument_list|)
condition|)
block|{
comment|/* Mark this function as being "defined".  */
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
comment|/* Give this node rtl from `abort'.  */
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
operator|=
name|DECL_RTL
argument_list|(
name|abort_fndecl
argument_list|)
expr_stmt|;
name|DECL_ABSTRACT_VIRTUAL_P
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|OFFSET_REF
operator|&&
name|TREE_OPERAND
argument_list|(
name|init
argument_list|,
literal|0
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
block|{
name|tree
name|basetype
init|=
name|DECL_CLASS_CONTEXT
argument_list|(
name|init
argument_list|)
decl_stmt|;
name|tree
name|basefn
init|=
name|TREE_OPERAND
argument_list|(
name|init
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|basefn
argument_list|)
operator|!=
name|FUNCTION_DECL
condition|)
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"non-method initializer invalid for method `%s'"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|BINFO_OFFSET_ZEROP
argument_list|(
name|TYPE_BINFO
argument_list|(
name|DECL_CLASS_CONTEXT
argument_list|(
name|basefn
argument_list|)
argument_list|)
argument_list|)
condition|)
name|sorry
argument_list|(
literal|"base member function from other than first base class"
argument_list|)
expr_stmt|;
else|else
block|{
name|tree
name|binfo
init|=
name|get_binfo
argument_list|(
name|basetype
argument_list|,
name|TYPE_METHOD_BASETYPE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|binfo
operator|==
name|error_mark_node
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|binfo
operator|==
literal|0
condition|)
name|error_not_base_type
argument_list|(
name|TYPE_METHOD_BASETYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
argument_list|)
argument_list|,
name|TYPE_METHOD_BASETYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Mark this function as being defined, 		 and give it new rtl.  */
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
operator|=
name|DECL_RTL
argument_list|(
name|basefn
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"invalid initializer for virtual method `%s'"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* When we get a declaration of the form     type cname::fname ...     the node for `cname::fname' gets built here in a special way.    Namely, we push into `cname's scope.  When this declaration is    processed, we pop back out.  */
end_comment

begin_function
name|tree
name|build_push_scope
parameter_list|(
name|cname
parameter_list|,
name|name
parameter_list|)
name|tree
name|cname
decl_stmt|;
name|tree
name|name
decl_stmt|;
block|{
specifier|extern
name|int
name|current_class_depth
decl_stmt|;
name|tree
name|ctype
decl_stmt|,
name|rval
decl_stmt|;
if|if
condition|(
name|cname
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|ctype
operator|=
name|IDENTIFIER_TYPE_VALUE
argument_list|(
name|cname
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctype
operator|==
name|NULL_TREE
operator|||
operator|!
name|IS_AGGR_TYPE
argument_list|(
name|ctype
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"`%s' not defined as aggregate type"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|cname
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|name
return|;
block|}
name|rval
operator|=
name|build_parse_node
argument_list|(
name|SCOPE_REF
argument_list|,
name|cname
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* Don't need to push the scope here, but we do need to return      a SCOPE_REF for something like       class foo { typedef int bar (foo::*foo_fn)(void); };  */
if|if
condition|(
name|ctype
operator|==
name|current_class_type
condition|)
return|return
name|rval
return|;
name|pushclass
argument_list|(
name|ctype
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|TREE_COMPLEXITY
argument_list|(
name|rval
argument_list|)
operator|=
name|current_class_depth
expr_stmt|;
return|return
name|rval
return|;
block|}
end_function

begin_function
name|void
name|cplus_decl_attributes
parameter_list|(
name|decl
parameter_list|,
name|attributes
parameter_list|)
name|tree
name|decl
decl_stmt|,
name|attributes
decl_stmt|;
block|{
if|if
condition|(
name|decl
condition|)
name|decl_attributes
argument_list|(
name|decl
argument_list|,
name|attributes
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* CONSTRUCTOR_NAME:    Return the name for the constructor (or destructor) for the specified    class.  Argument can be RECORD_TYPE, TYPE_DECL, or IDENTIFIER_NODE.  */
end_comment

begin_function
name|tree
name|constructor_name
parameter_list|(
name|thing
parameter_list|)
name|tree
name|thing
decl_stmt|;
block|{
name|tree
name|t
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|thing
argument_list|)
operator|==
name|UNINSTANTIATED_P_TYPE
condition|)
return|return
name|DECL_NAME
argument_list|(
name|UPT_TEMPLATE
argument_list|(
name|thing
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|thing
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|thing
argument_list|)
operator|==
name|UNION_TYPE
condition|)
name|thing
operator|=
name|TYPE_NAME
argument_list|(
name|thing
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|thing
argument_list|)
operator|==
name|TYPE_DECL
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|thing
argument_list|)
operator|==
name|TEMPLATE_DECL
operator|&&
name|DECL_TEMPLATE_IS_CLASS
argument_list|(
name|thing
argument_list|)
operator|)
condition|)
name|thing
operator|=
name|DECL_NAME
argument_list|(
name|thing
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|thing
argument_list|)
operator|==
name|IDENTIFIER_NODE
argument_list|,
literal|197
argument_list|)
expr_stmt|;
name|t
operator|=
name|IDENTIFIER_TEMPLATE
argument_list|(
name|thing
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|t
condition|)
return|return
name|thing
return|;
name|t
operator|=
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
name|DECL_NAME
argument_list|(
name|t
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Cache the value of this class's main virtual function table pointer    in a register variable.  This will save one indirection if a    more than one virtual function call is made this function.  */
end_comment

begin_function
name|void
name|setup_vtbl_ptr
parameter_list|()
block|{
specifier|extern
name|rtx
name|base_init_insns
decl_stmt|;
if|if
condition|(
name|base_init_insns
operator|==
literal|0
operator|&&
name|DECL_CONSTRUCTOR_P
argument_list|(
name|current_function_decl
argument_list|)
condition|)
name|emit_base_init
argument_list|(
name|current_class_type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* This has something a little wrong with it.       On a sun4, code like:          be L6         ld [%i0],%o1       is generated, when the below is used when -O4 is given.  The delay      slot it filled with an instruction that is safe, when this isn't      used, like in:          be L6         sethi %hi(LC1),%o0         ld [%i0],%o1       on code like:          struct A {           virtual void print() { printf("xxx"); }           void f();         };          void A::f() {           if (this) {             print();           } else {             printf("0");           }         }       And that is why this is disabled for now. (mrs)   */
block|if ((flag_this_is_variable& 1) == 0&& optimize&& current_class_type&& CLASSTYPE_VSIZE (current_class_type)&& ! DECL_STATIC_FUNCTION_P (current_function_decl))     {       tree vfield = build_vfield_ref (C_C_D, current_class_type);       current_vtable_decl = CLASSTYPE_VTBL_PTR (current_class_type);       DECL_RTL (current_vtable_decl) = 0;       DECL_INITIAL (current_vtable_decl) = error_mark_node;
comment|/* Have to cast the initializer, since it may have come from a 	 more base class then we ascribe CURRENT_VTABLE_DECL to be.  */
block|finish_decl (current_vtable_decl, convert_force (TREE_TYPE (current_vtable_decl), vfield), 0, 0);       current_vtable_decl = build_indirect_ref (current_vtable_decl, 0);     }   else
endif|#
directive|endif
name|current_vtable_decl
operator|=
name|NULL_TREE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Record the existence of an addressable inline function.  */
end_comment

begin_function
name|void
name|mark_inline_for_output
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
if|if
condition|(
name|DECL_PENDING_INLINE_INFO
argument_list|(
name|decl
argument_list|)
operator|!=
literal|0
operator|&&
operator|!
name|DECL_PENDING_INLINE_INFO
argument_list|(
name|decl
argument_list|)
operator|->
name|deja_vu
condition|)
block|{
name|struct
name|pending_inline
modifier|*
name|t
init|=
name|pending_inlines
decl_stmt|;
name|my_friendly_assert
argument_list|(
name|DECL_SAVED_INSNS
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
argument_list|,
literal|198
argument_list|)
expr_stmt|;
while|while
condition|(
name|t
condition|)
block|{
if|if
condition|(
name|t
operator|==
name|DECL_PENDING_INLINE_INFO
argument_list|(
name|decl
argument_list|)
condition|)
break|break;
name|t
operator|=
name|t
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|t
operator|==
literal|0
condition|)
block|{
name|t
operator|=
name|DECL_PENDING_INLINE_INFO
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|t
operator|->
name|next
operator|=
name|pending_inlines
expr_stmt|;
name|pending_inlines
operator|=
name|t
expr_stmt|;
block|}
name|DECL_PENDING_INLINE_INFO
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
name|pending_addressable_inlines
operator|=
name|perm_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|decl
argument_list|,
name|pending_addressable_inlines
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|clear_temp_name
parameter_list|()
block|{
name|temp_name_counter
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Hand off a unique name which can be used for variable we don't really    want to know about anyway, for example, the anonymous variables which    are needed to make references work.  Declare this thing so we can use it.    The variable created will be of type TYPE.     STATICP is nonzero if this variable should be static.  */
end_comment

begin_function
name|tree
name|get_temp_name
parameter_list|(
name|type
parameter_list|,
name|staticp
parameter_list|)
name|tree
name|type
decl_stmt|;
name|int
name|staticp
decl_stmt|;
block|{
name|char
name|buf
index|[
sizeof|sizeof
argument_list|(
name|AUTO_TEMP_FORMAT
argument_list|)
operator|+
literal|20
index|]
decl_stmt|;
name|tree
name|decl
decl_stmt|;
name|int
name|toplev
init|=
name|global_bindings_p
argument_list|()
decl_stmt|;
name|push_obstacks_nochange
argument_list|()
expr_stmt|;
if|if
condition|(
name|toplev
operator|||
name|staticp
condition|)
block|{
name|end_temporary_allocation
argument_list|()
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
name|AUTO_TEMP_FORMAT
argument_list|,
name|global_temp_name_counter
operator|++
argument_list|)
expr_stmt|;
name|decl
operator|=
name|pushdecl_top_level
argument_list|(
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|get_identifier
argument_list|(
name|buf
argument_list|)
argument_list|,
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
name|AUTO_TEMP_FORMAT
argument_list|,
name|temp_name_counter
operator|++
argument_list|)
expr_stmt|;
name|decl
operator|=
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|get_identifier
argument_list|(
name|buf
argument_list|)
argument_list|,
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|TREE_USED
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|=
name|staticp
expr_stmt|;
comment|/* If this is a local variable, then lay out its rtl now.      Otherwise, callers of this function are responsible for dealing      with this variable's rtl.  */
if|if
condition|(
operator|!
name|toplev
condition|)
block|{
name|expand_decl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|expand_decl_init
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
name|pop_obstacks
argument_list|()
expr_stmt|;
return|return
name|decl
return|;
block|}
end_function

begin_comment
comment|/* Get a variable which we can use for multiple assignments.    It is not entered into current_binding_level, because    that breaks things when it comes time to do final cleanups    (which take place "outside" the binding contour of the function).  */
end_comment

begin_function
name|tree
name|get_temp_regvar
parameter_list|(
name|type
parameter_list|,
name|init
parameter_list|)
name|tree
name|type
decl_stmt|,
name|init
decl_stmt|;
block|{
specifier|static
name|char
name|buf
index|[
sizeof|sizeof
argument_list|(
name|AUTO_TEMP_FORMAT
argument_list|)
operator|+
literal|20
index|]
init|=
block|{
literal|'_'
block|}
decl_stmt|;
name|tree
name|decl
decl_stmt|;
name|sprintf
argument_list|(
name|buf
operator|+
literal|1
argument_list|,
name|AUTO_TEMP_FORMAT
argument_list|,
name|temp_name_counter
operator|++
argument_list|)
expr_stmt|;
name|decl
operator|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|get_identifier
argument_list|(
name|buf
argument_list|)
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|TREE_USED
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_REGISTER
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|init
condition|)
name|store_init_value
argument_list|(
name|decl
argument_list|,
name|init
argument_list|)
expr_stmt|;
comment|/* We can expand these without fear, since they cannot need      constructors or destructors.  */
name|expand_decl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|expand_decl_init
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|type_needs_gc_entry
argument_list|(
name|type
argument_list|)
condition|)
name|DECL_GC_OFFSET
argument_list|(
name|decl
argument_list|)
operator|=
name|size_int
argument_list|(
operator|++
name|current_function_obstack_index
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
end_function

begin_comment
comment|/* Make the macro TEMP_NAME_P available to units which do not    include c-tree.h.  */
end_comment

begin_function
name|int
name|temp_name_p
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
return|return
name|TEMP_NAME_P
argument_list|(
name|decl
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Finish off the processing of a UNION_TYPE structure.    If there are static members, then all members are    static, and must be laid out together.  If the    union is an anonymous union, we arrange for that    as well.  PUBLIC_P is nonzero if this union is    not declared static.  */
end_comment

begin_function
name|void
name|finish_anon_union
parameter_list|(
name|anon_union_decl
parameter_list|)
name|tree
name|anon_union_decl
decl_stmt|;
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|anon_union_decl
argument_list|)
decl_stmt|;
name|tree
name|field
decl_stmt|,
name|main_decl
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|elems
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|public_p
init|=
name|TREE_PUBLIC
argument_list|(
name|anon_union_decl
argument_list|)
decl_stmt|;
name|int
name|static_p
init|=
name|TREE_STATIC
argument_list|(
name|anon_union_decl
argument_list|)
decl_stmt|;
name|int
name|external_p
init|=
name|DECL_EXTERNAL
argument_list|(
name|anon_union_decl
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|field
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
operator|)
operator|==
name|NULL_TREE
condition|)
return|return;
if|if
condition|(
name|public_p
operator|&&
operator|(
name|static_p
operator|||
name|external_p
operator|)
condition|)
name|error
argument_list|(
literal|"optimizer cannot handle global anonymous unions"
argument_list|)
expr_stmt|;
while|while
condition|(
name|field
condition|)
block|{
name|tree
name|decl
init|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|DECL_NAME
argument_list|(
name|field
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
decl_stmt|;
comment|/* tell `pushdecl' that this is not tentative.  */
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|=
name|public_p
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|=
name|static_p
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
name|external_p
expr_stmt|;
name|decl
operator|=
name|pushdecl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* Only write out one anon union element--choose the one that 	 can hold them all.  */
if|if
condition|(
name|main_decl
operator|==
name|NULL_TREE
operator|&&
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
operator|==
name|DECL_SIZE
argument_list|(
name|anon_union_decl
argument_list|)
condition|)
block|{
name|main_decl
operator|=
name|decl
expr_stmt|;
block|}
else|else
block|{
comment|/* ??? This causes there to be no debug info written out 	     about this decl.  */
name|TREE_ASM_WRITTEN
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* If there's a cleanup to do, it belongs in the 	 TREE_PURPOSE of the following TREE_LIST.  */
name|elems
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|decl
argument_list|,
name|elems
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|elems
argument_list|)
operator|=
name|type
expr_stmt|;
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|static_p
condition|)
block|{
name|make_decl_rtl
argument_list|(
name|main_decl
argument_list|,
literal|0
argument_list|,
name|global_bindings_p
argument_list|()
argument_list|)
expr_stmt|;
name|DECL_RTL
argument_list|(
name|anon_union_decl
argument_list|)
operator|=
name|DECL_RTL
argument_list|(
name|main_decl
argument_list|)
expr_stmt|;
block|}
comment|/* The following call assumes that there are never any cleanups      for anonymous unions--a reasonable assumption.  */
name|expand_anon_union_decl
argument_list|(
name|anon_union_decl
argument_list|,
name|NULL_TREE
argument_list|,
name|elems
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_cadillac
condition|)
name|cadillac_finish_anon_union
argument_list|(
name|anon_union_decl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finish and output a table which is generated by the compiler.    NAME is the name to give the table.    TYPE is the type of the table entry.    INIT is all the elements in the table.    PUBLICP is non-zero if this table should be given external visibility.  */
end_comment

begin_function
name|tree
name|finish_table
parameter_list|(
name|name
parameter_list|,
name|type
parameter_list|,
name|init
parameter_list|,
name|publicp
parameter_list|)
name|tree
name|name
decl_stmt|,
name|type
decl_stmt|,
name|init
decl_stmt|;
name|int
name|publicp
decl_stmt|;
block|{
name|tree
name|itype
decl_stmt|,
name|atype
decl_stmt|,
name|decl
decl_stmt|;
specifier|static
name|tree
name|empty_table
decl_stmt|;
name|int
name|is_empty
init|=
literal|0
decl_stmt|;
name|tree
name|asmspec
decl_stmt|;
name|itype
operator|=
name|build_index_type
argument_list|(
name|size_int
argument_list|(
name|list_length
argument_list|(
name|init
argument_list|)
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|atype
operator|=
name|build_cplus_array_type
argument_list|(
name|type
argument_list|,
name|itype
argument_list|)
expr_stmt|;
name|layout_type
argument_list|(
name|atype
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|init
argument_list|)
operator|==
name|integer_zero_node
operator|&&
name|TREE_CHAIN
argument_list|(
name|init
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
if|if
condition|(
name|empty_table
operator|==
name|NULL_TREE
condition|)
block|{
name|empty_table
operator|=
name|get_temp_name
argument_list|(
name|atype
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|init
operator|=
name|build
argument_list|(
name|CONSTRUCTOR
argument_list|,
name|atype
argument_list|,
name|NULL_TREE
argument_list|,
name|init
argument_list|)
expr_stmt|;
name|TREE_CONSTANT
argument_list|(
name|init
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|init
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|empty_table
argument_list|)
operator|=
name|init
expr_stmt|;
name|asmspec
operator|=
name|build_string
argument_list|(
name|IDENTIFIER_LENGTH
argument_list|(
name|DECL_NAME
argument_list|(
name|empty_table
argument_list|)
argument_list|)
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|empty_table
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|finish_decl
argument_list|(
name|empty_table
argument_list|,
name|init
argument_list|,
name|asmspec
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|is_empty
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|name
operator|==
name|NULL_TREE
condition|)
block|{
if|if
condition|(
name|is_empty
condition|)
return|return
name|empty_table
return|;
name|decl
operator|=
name|get_temp_name
argument_list|(
name|atype
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|decl
operator|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|name
argument_list|,
name|atype
argument_list|)
expr_stmt|;
name|decl
operator|=
name|pushdecl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|is_empty
operator|==
literal|0
condition|)
block|{
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|=
name|publicp
expr_stmt|;
name|init
operator|=
name|build
argument_list|(
name|CONSTRUCTOR
argument_list|,
name|atype
argument_list|,
name|NULL_TREE
argument_list|,
name|init
argument_list|)
expr_stmt|;
name|TREE_CONSTANT
argument_list|(
name|init
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|init
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|init
expr_stmt|;
name|asmspec
operator|=
name|build_string
argument_list|(
name|IDENTIFIER_LENGTH
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* This will cause DECL to point to EMPTY_TABLE in rtl-land.  */
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|init
operator|=
literal|0
expr_stmt|;
name|asmspec
operator|=
name|build_string
argument_list|(
name|IDENTIFIER_LENGTH
argument_list|(
name|DECL_NAME
argument_list|(
name|empty_table
argument_list|)
argument_list|)
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|empty_table
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|finish_decl
argument_list|(
name|decl
argument_list|,
name|init
argument_list|,
name|asmspec
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
end_function

begin_comment
comment|/* Finish processing a builtin type TYPE.  It's name is NAME,    its fields are in the array FIELDS.  LEN is the number of elements    in FIELDS.     It is given the same alignment as ALIGN_TYPE.  */
end_comment

begin_function
name|void
name|finish_builtin_type
parameter_list|(
name|type
parameter_list|,
name|name
parameter_list|,
name|fields
parameter_list|,
name|len
parameter_list|,
name|align_type
parameter_list|)
name|tree
name|type
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|tree
name|fields
index|[]
decl_stmt|;
name|int
name|len
decl_stmt|;
name|tree
name|align_type
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
operator|=
name|fields
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|layout_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|fields
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_FIELD_CONTEXT
argument_list|(
name|fields
index|[
name|i
index|]
argument_list|)
operator|=
name|type
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|fields
index|[
name|i
index|]
argument_list|)
operator|=
name|fields
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
block|}
name|DECL_FIELD_CONTEXT
argument_list|(
name|fields
index|[
name|i
index|]
argument_list|)
operator|=
name|type
expr_stmt|;
name|DECL_CLASS_CONTEXT
argument_list|(
name|fields
index|[
name|i
index|]
argument_list|)
operator|=
name|type
expr_stmt|;
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_ALIGN
argument_list|(
name|align_type
argument_list|)
expr_stmt|;
name|layout_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* not yet, should get fixed properly later */
block|TYPE_NAME (type) = make_type_decl (get_identifier (name), type);
else|#
directive|else
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|=
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
name|name
argument_list|)
argument_list|,
name|type
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|layout_decl
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Auxiliary functions to make type signatures for    `operator new' and `operator delete' correspond to    what compiler will be expecting.  */
end_comment

begin_decl_stmt
specifier|extern
name|tree
name|sizetype
decl_stmt|;
end_decl_stmt

begin_function
name|tree
name|coerce_new_type
parameter_list|(
name|ctype
parameter_list|,
name|type
parameter_list|)
name|tree
name|ctype
decl_stmt|;
name|tree
name|type
decl_stmt|;
block|{
name|int
name|e1
init|=
literal|0
decl_stmt|,
name|e2
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
name|type
operator|=
name|build_function_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|TREE_CHAIN
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
operator|!=
name|ptr_type_node
condition|)
name|e1
operator|=
literal|1
operator|,
name|error
argument_list|(
literal|"`operator new' must return type `void *'"
argument_list|)
expr_stmt|;
comment|/* Technically the type must be `size_t', but we may not know      what that is.  */
if|if
condition|(
name|TYPE_ARG_TYPES
argument_list|(
name|type
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|e1
operator|=
literal|1
operator|,
name|error
argument_list|(
literal|"`operator new' takes type `size_t' parameter"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|INTEGER_TYPE
operator|||
name|TYPE_PRECISION
argument_list|(
name|TREE_VALUE
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|TYPE_PRECISION
argument_list|(
name|sizetype
argument_list|)
condition|)
name|e2
operator|=
literal|1
operator|,
name|error
argument_list|(
literal|"`operator new' takes type `size_t' as first parameter"
argument_list|)
expr_stmt|;
if|if
condition|(
name|e2
condition|)
name|type
operator|=
name|build_function_type
argument_list|(
name|ptr_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|sizetype
argument_list|,
name|TREE_CHAIN
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|e1
condition|)
name|type
operator|=
name|build_function_type
argument_list|(
name|ptr_type_node
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|type
return|;
block|}
end_function

begin_function
name|tree
name|coerce_delete_type
parameter_list|(
name|ctype
parameter_list|,
name|type
parameter_list|)
name|tree
name|ctype
decl_stmt|;
name|tree
name|type
decl_stmt|;
block|{
name|int
name|e1
init|=
literal|0
decl_stmt|,
name|e2
init|=
literal|0
decl_stmt|,
name|e3
init|=
literal|0
decl_stmt|;
name|tree
name|arg_types
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
block|{
name|type
operator|=
name|build_function_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|TREE_CHAIN
argument_list|(
name|arg_types
argument_list|)
argument_list|)
expr_stmt|;
name|arg_types
operator|=
name|TREE_CHAIN
argument_list|(
name|arg_types
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
operator|!=
name|void_type_node
condition|)
name|e1
operator|=
literal|1
operator|,
name|error
argument_list|(
literal|"`operator delete' must return type `void'"
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg_types
operator|==
name|NULL_TREE
operator|||
name|TREE_VALUE
argument_list|(
name|arg_types
argument_list|)
operator|!=
name|ptr_type_node
condition|)
name|e2
operator|=
literal|1
operator|,
name|error
argument_list|(
literal|"`operator delete' takes type `void *' as first parameter"
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg_types
operator|&&
name|TREE_CHAIN
argument_list|(
name|arg_types
argument_list|)
operator|&&
name|TREE_CHAIN
argument_list|(
name|arg_types
argument_list|)
operator|!=
name|void_list_node
condition|)
block|{
comment|/* Again, technically this argument must be `size_t', but again 	 we may not know what that is.  */
name|tree
name|t2
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arg_types
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t2
argument_list|)
operator|!=
name|INTEGER_TYPE
operator|||
name|TYPE_PRECISION
argument_list|(
name|t2
argument_list|)
operator|!=
name|TYPE_PRECISION
argument_list|(
name|sizetype
argument_list|)
condition|)
name|e3
operator|=
literal|1
operator|,
name|error
argument_list|(
literal|"second argument to `operator delete' must be of type `size_t'"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arg_types
argument_list|)
argument_list|)
operator|!=
name|void_list_node
condition|)
block|{
name|e3
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arg_types
argument_list|)
argument_list|)
condition|)
name|error
argument_list|(
literal|"too many arguments in declaration of `operator delete'"
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"`...' invalid in specification of `operator delete'"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|e3
condition|)
name|arg_types
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ptr_type_node
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|sizetype
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|e3
operator||=
name|e2
condition|)
block|{
if|if
condition|(
name|arg_types
operator|==
name|NULL_TREE
condition|)
name|arg_types
operator|=
name|void_list_node
expr_stmt|;
else|else
name|arg_types
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ptr_type_node
argument_list|,
name|TREE_CHAIN
argument_list|(
name|arg_types
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|e3
operator||=
name|e1
expr_stmt|;
if|if
condition|(
name|e3
condition|)
name|type
operator|=
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|arg_types
argument_list|)
expr_stmt|;
return|return
name|type
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|write_vtable_entries
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
name|tree
name|entries
init|=
name|TREE_CHAIN
argument_list|(
name|CONSTRUCTOR_ELTS
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|flag_dossier
condition|)
name|entries
operator|=
name|TREE_CHAIN
argument_list|(
name|entries
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|entries
condition|;
name|entries
operator|=
name|TREE_CHAIN
argument_list|(
name|entries
argument_list|)
control|)
block|{
name|tree
name|fnaddr
init|=
name|FNADDR_FROM_VTABLE_ENTRY
argument_list|(
name|TREE_VALUE
argument_list|(
name|entries
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|fn
init|=
name|TREE_OPERAND
argument_list|(
name|fnaddr
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|DECL_EXTERNAL
argument_list|(
name|fn
argument_list|)
operator|&&
operator|!
name|TREE_ASM_WRITTEN
argument_list|(
name|fn
argument_list|)
operator|&&
name|DECL_SAVED_INSNS
argument_list|(
name|fn
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|DECL_CLASS_CONTEXT
argument_list|(
name|fn
argument_list|)
argument_list|)
condition|)
name|TREE_PUBLIC
argument_list|(
name|fn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_ADDRESSABLE
argument_list|(
name|fn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|output_inline_function
argument_list|(
name|fn
argument_list|)
expr_stmt|;
block|}
else|else
name|assemble_external
argument_list|(
name|fn
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|finish_vtable_typedecl
parameter_list|(
name|prev
parameter_list|,
name|vars
parameter_list|)
name|tree
name|prev
decl_stmt|,
name|vars
decl_stmt|;
block|{
name|tree
name|decl
init|=
name|TYPE_BINFO_VTABLE
argument_list|(
name|TREE_TYPE
argument_list|(
name|vars
argument_list|)
argument_list|)
decl_stmt|;
comment|/* If we are controlled by `+e2', obey.  */
if|if
condition|(
name|write_virtuals
operator|==
literal|2
condition|)
block|{
name|tree
name|binfo
init|=
name|value_member
argument_list|(
name|DECL_NAME
argument_list|(
name|vars
argument_list|)
argument_list|,
name|pending_vtables
argument_list|)
decl_stmt|;
if|if
condition|(
name|binfo
condition|)
name|TREE_PURPOSE
argument_list|(
name|binfo
argument_list|)
operator|=
name|void_type_node
expr_stmt|;
else|else
name|decl
operator|=
name|NULL_TREE
expr_stmt|;
block|}
comment|/* If this type has inline virtual functions, then      write those functions out now.  */
if|if
condition|(
name|decl
operator|&&
name|write_virtuals
operator|>=
literal|0
operator|&&
operator|!
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|&&
operator|(
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|||
name|TREE_USED
argument_list|(
name|decl
argument_list|)
operator|)
condition|)
name|write_vtable_entries
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|finish_vtable_vardecl
parameter_list|(
name|prev
parameter_list|,
name|vars
parameter_list|)
name|tree
name|prev
decl_stmt|,
name|vars
decl_stmt|;
block|{
if|if
condition|(
name|write_virtuals
operator|>=
literal|0
operator|&&
operator|!
name|DECL_EXTERNAL
argument_list|(
name|vars
argument_list|)
operator|&&
operator|(
name|TREE_PUBLIC
argument_list|(
name|vars
argument_list|)
operator|||
name|TREE_USED
argument_list|(
name|vars
argument_list|)
operator|)
condition|)
block|{
specifier|extern
name|tree
name|the_null_vtable_entry
decl_stmt|;
comment|/* Stuff this virtual function table's size into 	 `pfn' slot of `the_null_vtable_entry'.  */
name|tree
name|nelts
init|=
name|array_type_nelts
argument_list|(
name|TREE_TYPE
argument_list|(
name|vars
argument_list|)
argument_list|)
decl_stmt|;
name|SET_FNADDR_FROM_VTABLE_ENTRY
argument_list|(
name|the_null_vtable_entry
argument_list|,
name|nelts
argument_list|)
expr_stmt|;
comment|/* Kick out the dossier before writing out the vtable.  */
if|if
condition|(
name|flag_dossier
condition|)
name|rest_of_decl_compilation
argument_list|(
name|TREE_OPERAND
argument_list|(
name|FNADDR_FROM_VTABLE_ENTRY
argument_list|(
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|CONSTRUCTOR_ELTS
argument_list|(
name|DECL_INITIAL
argument_list|(
name|vars
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Write it out.  */
name|write_vtable_entries
argument_list|(
name|vars
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|DECL_INITIAL
argument_list|(
name|vars
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|store_init_value
argument_list|(
name|vars
argument_list|,
name|DECL_INITIAL
argument_list|(
name|vars
argument_list|)
argument_list|)
expr_stmt|;
name|rest_of_decl_compilation
argument_list|(
name|vars
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* We know that PREV must be non-zero here.  */
name|TREE_CHAIN
argument_list|(
name|prev
argument_list|)
operator|=
name|TREE_CHAIN
argument_list|(
name|vars
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|void
name|walk_vtables
argument_list|(
name|typedecl_fn
argument_list|,
name|vardecl_fn
argument_list|)
decl|register
name|void
argument_list|(
operator|*
name|typedecl_fn
argument_list|)
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|register
name|void
function_decl|(
modifier|*
name|vardecl_fn
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_block
block|{
name|tree
name|prev
decl_stmt|,
name|vars
decl_stmt|;
for|for
control|(
name|prev
operator|=
literal|0
operator|,
name|vars
operator|=
name|getdecls
argument_list|()
init|;
name|vars
condition|;
name|vars
operator|=
name|TREE_CHAIN
argument_list|(
name|vars
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|vars
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|TYPE_LANG_SPECIFIC
argument_list|(
name|TREE_TYPE
argument_list|(
name|vars
argument_list|)
argument_list|)
operator|&&
name|CLASSTYPE_VSIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|vars
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|typedecl_fn
condition|)
call|(
modifier|*
name|typedecl_fn
call|)
argument_list|(
name|prev
argument_list|,
name|vars
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|vars
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_VIRTUAL_P
argument_list|(
name|vars
argument_list|)
condition|)
block|{
if|if
condition|(
name|vardecl_fn
condition|)
call|(
modifier|*
name|vardecl_fn
call|)
argument_list|(
name|prev
argument_list|,
name|vars
argument_list|)
expr_stmt|;
block|}
else|else
name|prev
operator|=
name|vars
expr_stmt|;
block|}
block|}
end_block

begin_decl_stmt
specifier|extern
name|int
name|parse_time
decl_stmt|,
name|varconst_time
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|TIMEVAR
parameter_list|(
name|VAR
parameter_list|,
name|BODY
parameter_list|)
define|\
value|do { int otime = get_run_time (); BODY; VAR += get_run_time () - otime; } while (0)
end_define

begin_comment
comment|/* This routine is called from the last rule in yyparse ().    Its job is to create all the code needed to initialize and    destroy the global aggregates.  We do the destruction    first, since that way we only need to reverse the decls once.  */
end_comment

begin_function
name|void
name|finish_file
parameter_list|()
block|{
specifier|extern
name|int
name|lineno
decl_stmt|;
name|int
name|start_time
decl_stmt|,
name|this_time
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|tree
name|fnname
decl_stmt|;
name|tree
name|vars
init|=
name|static_aggregates
decl_stmt|;
name|int
name|needs_cleaning
init|=
literal|0
decl_stmt|,
name|needs_messing_up
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|main_input_filename
operator|==
literal|0
condition|)
name|main_input_filename
operator|=
name|input_filename
expr_stmt|;
if|if
condition|(
operator|!
name|first_global_object_name
condition|)
name|first_global_object_name
operator|=
name|main_input_filename
expr_stmt|;
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
name|FILE_FUNCTION_FORMAT
argument_list|)
operator|+
name|strlen
argument_list|(
name|first_global_object_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_detailed_statistics
condition|)
name|dump_tree_statistics
argument_list|()
expr_stmt|;
comment|/* Bad parse errors.  Just forget about it.  */
if|if
condition|(
operator|!
name|global_bindings_p
argument_list|()
operator|||
name|current_class_type
condition|)
return|return;
name|start_time
operator|=
name|get_run_time
argument_list|()
expr_stmt|;
comment|/* Push into C language context, because that's all      we'll need here.  */
name|push_lang_context
argument_list|(
name|lang_name_c
argument_list|)
expr_stmt|;
comment|/* Set up the name of the file-level functions we may need.  */
comment|/* Use a global object (which is already required to be unique over      the program) rather than the file name (which imposes extra      constraints).  -- Raeburn@MIT.EDU, 10 Jan 1990.  */
name|sprintf
argument_list|(
name|buf
argument_list|,
name|FILE_FUNCTION_FORMAT
argument_list|,
name|first_global_object_name
argument_list|)
expr_stmt|;
comment|/* Don't need to pull wierd characters out of global names.  */
if|if
condition|(
name|first_global_object_name
operator|==
name|main_input_filename
condition|)
block|{
for|for
control|(
name|p
operator|=
name|buf
operator|+
literal|11
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|!
operator|(
operator|(
operator|*
name|p
operator|>=
literal|'0'
operator|&&
operator|*
name|p
operator|<=
literal|'9'
operator|)
if|#
directive|if
literal|0
comment|/* we always want labels, which are valid C++ identifiers (+ `$') */
ifndef|#
directive|ifndef
name|ASM_IDENTIFY_GCC
comment|/* this is required if `.' is invalid -- k. raeburn */
expr||| *p == '.'
endif|#
directive|endif
endif|#
directive|endif
ifndef|#
directive|ifndef
name|NO_DOLLAR_IN_LABEL
comment|/* this for `$'; unlikely, but... -- kr */
operator|||
operator|*
name|p
operator|==
literal|'$'
endif|#
directive|endif
operator|||
operator|(
operator|*
name|p
operator|>=
literal|'A'
operator|&&
operator|*
name|p
operator|<=
literal|'Z'
operator|)
operator|||
operator|(
operator|*
name|p
operator|>=
literal|'a'
operator|&&
operator|*
name|p
operator|<=
literal|'z'
operator|)
operator|)
condition|)
operator|*
name|p
operator|=
literal|'_'
expr_stmt|;
block|}
comment|/* See if we really need the hassle.  */
while|while
condition|(
name|vars
operator|&&
name|needs_cleaning
operator|==
literal|0
condition|)
block|{
name|tree
name|decl
init|=
name|TREE_VALUE
argument_list|(
name|vars
argument_list|)
decl_stmt|;
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|needs_cleaning
operator|=
literal|1
expr_stmt|;
name|needs_messing_up
operator|=
literal|1
expr_stmt|;
break|break;
block|}
else|else
name|needs_messing_up
operator||=
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|vars
operator|=
name|TREE_CHAIN
argument_list|(
name|vars
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|needs_cleaning
operator|==
literal|0
condition|)
goto|goto
name|mess_up
goto|;
comment|/* Otherwise, GDB can get confused, because in only knows      about source for LINENO-1 lines.  */
name|lineno
operator|-=
literal|1
expr_stmt|;
name|fnname
operator|=
name|get_identifier
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|start_function
argument_list|(
name|void_list_node
argument_list|,
name|build_parse_node
argument_list|(
name|CALL_EXPR
argument_list|,
name|fnname
argument_list|,
name|void_list_node
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fnname
operator|=
name|DECL_ASSEMBLER_NAME
argument_list|(
name|current_function_decl
argument_list|)
expr_stmt|;
name|store_parm_decls
argument_list|()
expr_stmt|;
name|pushlevel
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|clear_last_expr
argument_list|()
expr_stmt|;
name|push_momentary
argument_list|()
expr_stmt|;
name|expand_start_bindings
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* These must be done in backward order to destroy,      in which they happen to be!  */
while|while
condition|(
name|vars
condition|)
block|{
name|tree
name|decl
init|=
name|TREE_VALUE
argument_list|(
name|vars
argument_list|)
decl_stmt|;
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|tree
name|temp
init|=
name|TREE_PURPOSE
argument_list|(
name|vars
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_NEEDS_DESTRUCTOR
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_STATIC
argument_list|(
name|vars
argument_list|)
condition|)
name|expand_start_cond
argument_list|(
name|build_binary_op
argument_list|(
name|NE_EXPR
argument_list|,
name|temp
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
name|temp
operator|=
name|decl
expr_stmt|;
else|else
block|{
name|mark_addressable
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|temp
operator|=
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|TYPE_POINTER_TO
argument_list|(
name|type
argument_list|)
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
name|temp
operator|=
name|build_delete
argument_list|(
name|TREE_TYPE
argument_list|(
name|temp
argument_list|)
argument_list|,
name|temp
argument_list|,
name|integer_two_node
argument_list|,
name|LOOKUP_NORMAL
operator||
name|LOOKUP_NONVIRTUAL
operator||
name|LOOKUP_DESTRUCTOR
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|expand_expr_stmt
argument_list|(
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_STATIC
argument_list|(
name|vars
argument_list|)
condition|)
name|expand_end_cond
argument_list|()
expr_stmt|;
block|}
name|vars
operator|=
name|TREE_CHAIN
argument_list|(
name|vars
argument_list|)
expr_stmt|;
block|}
name|expand_end_bindings
argument_list|(
name|getdecls
argument_list|()
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|poplevel
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pop_momentary
argument_list|()
expr_stmt|;
name|finish_function
argument_list|(
name|lineno
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|assemble_destructor
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|fnname
argument_list|)
argument_list|)
expr_stmt|;
comment|/* if it needed cleaning, then it will need messing up: drop through  */
name|mess_up
label|:
comment|/* Must do this while we think we are at the top level.  */
name|vars
operator|=
name|nreverse
argument_list|(
name|static_aggregates
argument_list|)
expr_stmt|;
if|if
condition|(
name|vars
operator|!=
name|NULL_TREE
condition|)
block|{
name|buf
index|[
name|FILE_FUNCTION_PREFIX_LEN
index|]
operator|=
literal|'I'
expr_stmt|;
name|fnname
operator|=
name|get_identifier
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|start_function
argument_list|(
name|void_list_node
argument_list|,
name|build_parse_node
argument_list|(
name|CALL_EXPR
argument_list|,
name|fnname
argument_list|,
name|void_list_node
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fnname
operator|=
name|DECL_ASSEMBLER_NAME
argument_list|(
name|current_function_decl
argument_list|)
expr_stmt|;
name|store_parm_decls
argument_list|()
expr_stmt|;
name|pushlevel
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|clear_last_expr
argument_list|()
expr_stmt|;
name|push_momentary
argument_list|()
expr_stmt|;
name|expand_start_bindings
argument_list|(
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SOS
if|if
condition|(
name|flag_all_virtual
operator|==
literal|2
condition|)
block|{
name|tree
name|decl
decl_stmt|;
name|char
name|c
init|=
name|buf
index|[
name|FILE_FUNCTION_PREFIX_LEN
index|]
decl_stmt|;
name|buf
index|[
name|FILE_FUNCTION_PREFIX_LEN
index|]
operator|=
literal|'Z'
expr_stmt|;
name|decl
operator|=
name|pushdecl
argument_list|(
name|build_lang_decl
argument_list|(
name|FUNCTION_DECL
argument_list|,
name|get_identifier
argument_list|(
name|buf
argument_list|)
argument_list|,
name|default_function_type
argument_list|)
argument_list|)
expr_stmt|;
name|finish_decl
argument_list|(
name|decl
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|expand_expr_stmt
argument_list|(
name|build_function_call
argument_list|(
name|decl
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
expr_stmt|;
name|buf
index|[
name|FILE_FUNCTION_PREFIX_LEN
index|]
operator|=
name|c
expr_stmt|;
block|}
endif|#
directive|endif
while|while
condition|(
name|vars
condition|)
block|{
name|tree
name|decl
init|=
name|TREE_VALUE
argument_list|(
name|vars
argument_list|)
decl_stmt|;
name|tree
name|init
init|=
name|TREE_PURPOSE
argument_list|(
name|vars
argument_list|)
decl_stmt|;
comment|/* If this was a static attribute within some function's scope, 	     then don't initialize it here.  Also, don't bother 	     with initializers that contain errors.  */
if|if
condition|(
name|TREE_STATIC
argument_list|(
name|vars
argument_list|)
operator|||
operator|(
name|init
operator|&&
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|TREE_LIST
operator|&&
name|value_member
argument_list|(
name|error_mark_node
argument_list|,
name|init
argument_list|)
operator|)
condition|)
block|{
name|vars
operator|=
name|TREE_CHAIN
argument_list|(
name|vars
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
condition|)
block|{
comment|/* Set these global variables so that GDB at least puts 		 us near the declaration which required the initialization.  */
name|input_filename
operator|=
name|DECL_SOURCE_FILE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|lineno
operator|=
name|DECL_SOURCE_LINE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|emit_note
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
if|if
condition|(
name|init
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|VAR_DECL
condition|)
block|{
comment|/* This behavior results when there are 			 multiple declarations of an aggregate, 			 the last of which defines it.  */
if|if
condition|(
name|DECL_RTL
argument_list|(
name|init
argument_list|)
operator|==
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|my_friendly_assert
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
name|error_mark_node
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|CONSTRUCTOR
operator|&&
name|CONSTRUCTOR_ELTS
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|NULL_TREE
operator|)
argument_list|,
literal|199
argument_list|)
expr_stmt|;
name|init
operator|=
name|DECL_INITIAL
argument_list|(
name|init
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|CONSTRUCTOR
operator|&&
name|CONSTRUCTOR_ELTS
argument_list|(
name|init
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|init
operator|=
name|NULL_TREE
expr_stmt|;
block|}
if|#
directive|if
literal|0
block|else if (TREE_TYPE (decl) == TREE_TYPE (init)) 			{
if|#
directive|if
literal|1
block|my_friendly_assert (0, 200);
else|#
directive|else
comment|/* point to real decl's rtl anyway.  */
block|DECL_RTL (init) = DECL_RTL (decl); 			  my_friendly_assert (DECL_INITIAL (decl) == error_mark_node, 					      201); 			  init = DECL_INITIAL (init);
endif|#
directive|endif
comment|/* 1 */
block|}
endif|#
directive|endif
comment|/* 0 */
block|}
block|}
if|if
condition|(
name|IS_AGGR_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|||
name|init
operator|==
literal|0
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
comment|/* Set this up so is_friend() works properly on _GLOBAL_ fns.  */
name|tree
name|old_dcc
init|=
name|DECL_CLASS_CONTEXT
argument_list|(
name|current_function_decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|old_dcc
operator|==
name|NULL_TREE
condition|)
name|DECL_CLASS_CONTEXT
argument_list|(
name|current_function_decl
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|expand_aggr_init
argument_list|(
name|decl
argument_list|,
name|init
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DECL_CLASS_CONTEXT
argument_list|(
name|current_function_decl
argument_list|)
operator|=
name|old_dcc
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|TREE_VEC
condition|)
block|{
name|expand_expr
argument_list|(
name|expand_vec_init
argument_list|(
name|decl
argument_list|,
name|TREE_VEC_ELT
argument_list|(
name|init
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_VEC_ELT
argument_list|(
name|init
argument_list|,
literal|1
argument_list|)
argument_list|,
name|TREE_VEC_ELT
argument_list|(
name|init
argument_list|,
literal|2
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free_temp_slots
argument_list|()
expr_stmt|;
block|}
else|else
name|expand_assignment
argument_list|(
name|decl
argument_list|,
name|init
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|SAVE_EXPR
condition|)
block|{
if|if
condition|(
operator|!
name|PARM_DECL_EXPR
argument_list|(
name|decl
argument_list|)
condition|)
block|{
comment|/* a `new' expression at top level.  */
name|expand_expr
argument_list|(
name|decl
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free_temp_slots
argument_list|()
expr_stmt|;
name|expand_aggr_init
argument_list|(
name|build_indirect_ref
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
argument_list|,
name|init
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|decl
operator|==
name|error_mark_node
condition|)
empty_stmt|;
else|else
name|my_friendly_abort
argument_list|(
literal|22
argument_list|)
expr_stmt|;
name|vars
operator|=
name|TREE_CHAIN
argument_list|(
name|vars
argument_list|)
expr_stmt|;
block|}
name|expand_end_bindings
argument_list|(
name|getdecls
argument_list|()
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|poplevel
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pop_momentary
argument_list|()
expr_stmt|;
name|finish_function
argument_list|(
name|lineno
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|assemble_constructor
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|fnname
argument_list|)
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SOS
if|if
condition|(
name|flag_all_virtual
operator|==
literal|2
condition|)
block|{
name|tree
name|__sosDynError
init|=
name|default_conversion
argument_list|(
name|lookup_name
argument_list|(
name|get_identifier
argument_list|(
literal|"sosDynError"
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|null_string
init|=
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|string_type_node
argument_list|,
name|combine_strings
argument_list|(
name|build_string
argument_list|(
literal|0
argument_list|,
literal|""
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|tags
init|=
name|gettags
argument_list|()
decl_stmt|;
name|tree
name|decls
init|=
name|getdecls
argument_list|()
decl_stmt|;
name|tree
name|entry
decl_stmt|;
name|int
name|i
decl_stmt|;
name|entry
operator|=
name|NULL_TREE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
name|entry
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_zero_node
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|zlink
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|build
argument_list|(
name|CONSTRUCTOR
argument_list|,
name|zlink_type
argument_list|,
name|NULL_TREE
argument_list|,
name|entry
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_CONSTANT
argument_list|(
name|TREE_VALUE
argument_list|(
name|zlink
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|TREE_VALUE
argument_list|(
name|zlink
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
name|entry
operator|=
name|NULL_TREE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|5
condition|;
name|i
operator|++
control|)
name|entry
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_zero_node
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|zret
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|build
argument_list|(
name|CONSTRUCTOR
argument_list|,
name|zret_type
argument_list|,
name|NULL_TREE
argument_list|,
name|entry
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_CONSTANT
argument_list|(
name|TREE_VALUE
argument_list|(
name|zret
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|TREE_VALUE
argument_list|(
name|zret
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Symbols with external visibility (except globally visible 	 dynamic member functions) into the `zlink' table.  */
while|while
condition|(
name|decls
condition|)
block|{
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|decls
argument_list|)
operator|&&
operator|!
name|TREE_EXTERN
argument_list|(
name|decls
argument_list|)
operator|&&
name|TREE_ASM_WRITTEN
argument_list|(
name|decls
argument_list|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|decls
argument_list|)
operator|!=
name|FUNCTION_DECL
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decls
argument_list|)
argument_list|)
operator|!=
name|METHOD_TYPE
operator|||
name|TYPE_DYNAMIC
argument_list|(
name|DECL_CLASS_CONTEXT
argument_list|(
name|decls
argument_list|)
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|entry
operator|=
name|build
argument_list|(
name|CONSTRUCTOR
argument_list|,
name|zlink_type
argument_list|,
name|NULL_TREE
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|string_type_node
argument_list|,
name|combine_strings
argument_list|(
name|build_string
argument_list|(
name|IDENTIFIER_LENGTH
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decls
argument_list|)
argument_list|)
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decls
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_one_node
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|decls
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_CONSTANT
argument_list|(
name|entry
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|entry
argument_list|)
operator|=
literal|1
expr_stmt|;
name|zlink
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|entry
argument_list|,
name|zlink
argument_list|)
expr_stmt|;
block|}
name|decls
operator|=
name|TREE_CHAIN
argument_list|(
name|decls
argument_list|)
expr_stmt|;
block|}
name|buf
index|[
name|FILE_FUNCTION_PREFIX_LEN
index|]
operator|=
literal|'Z'
expr_stmt|;
name|fnname
operator|=
name|get_identifier
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|start_function
argument_list|(
name|void_list_node
argument_list|,
name|build_parse_node
argument_list|(
name|CALL_EXPR
argument_list|,
name|fnname
argument_list|,
name|void_list_node
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fnname
operator|=
name|DECL_ASSEMBLER_NAME
argument_list|(
name|current_function_decl
argument_list|)
expr_stmt|;
name|store_parm_decls
argument_list|()
expr_stmt|;
name|pushlevel
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|clear_last_expr
argument_list|()
expr_stmt|;
name|push_momentary
argument_list|()
expr_stmt|;
name|expand_start_bindings
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|{
name|tree
name|decl
decl_stmt|,
name|type
decl_stmt|;
comment|/* Lay out a table static to this function 	   with information about all text and data that 	   this file provides.  */
name|tree
name|zlink_table
init|=
name|finish_table
argument_list|(
name|get_identifier
argument_list|(
literal|"__ZLINK_tbl"
argument_list|)
argument_list|,
name|zlink_type
argument_list|,
name|zlink
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|decl
operator|=
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"_ZLINK_once"
argument_list|)
argument_list|,
name|integer_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|finish_decl
argument_list|(
name|decl
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|expand_start_cond
argument_list|(
name|truthvalue_conversion
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|expand_null_return
argument_list|()
expr_stmt|;
name|expand_end_cond
argument_list|()
expr_stmt|;
name|finish_stmt
argument_list|()
expr_stmt|;
name|expand_expr_stmt
argument_list|(
name|build_modify_expr
argument_list|(
name|decl
argument_list|,
name|NOP_EXPR
argument_list|,
name|integer_one_node
argument_list|)
argument_list|)
expr_stmt|;
name|type
operator|=
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|decl
operator|=
name|pushdecl
argument_list|(
name|build_lang_decl
argument_list|(
name|FUNCTION_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"_Ztable_from_cfront"
argument_list|)
argument_list|,
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|finish_decl
argument_list|(
name|decl
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|expand_expr_stmt
argument_list|(
name|build_function_call
argument_list|(
name|decl
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|zlink_table
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expand_null_return
argument_list|()
expr_stmt|;
block|}
name|expand_end_bindings
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|poplevel
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pop_momentary
argument_list|()
expr_stmt|;
name|finish_function
argument_list|(
name|lineno
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|buf
index|[
name|FILE_FUNCTION_PREFIX_LEN
index|]
operator|=
literal|'Y'
expr_stmt|;
name|fnname
operator|=
name|get_identifier
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|start_function
argument_list|(
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|get_identifier
argument_list|(
literal|"int"
argument_list|)
argument_list|)
argument_list|,
name|build_parse_node
argument_list|(
name|INDIRECT_REF
argument_list|,
name|build_parse_node
argument_list|(
name|CALL_EXPR
argument_list|,
name|fnname
argument_list|,
name|void_list_node
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fnname
operator|=
name|DECL_ASSEMBLER_NAME
argument_list|(
name|current_function_decl
argument_list|)
expr_stmt|;
name|store_parm_decls
argument_list|()
expr_stmt|;
name|pushlevel
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|clear_last_expr
argument_list|()
expr_stmt|;
name|push_momentary
argument_list|()
expr_stmt|;
name|expand_start_bindings
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|{
define|#
directive|define
name|SOS_VERSION
value|2
name|tree
name|sosVersionNumber
init|=
name|build_int_2
argument_list|(
name|SOS_VERSION
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|zret_table
decl_stmt|;
comment|/* For each type defined, if is a dynamic type, write out 	   an entry linking its member functions with their names.  */
while|while
condition|(
name|tags
condition|)
block|{
name|tree
name|type
init|=
name|TREE_VALUE
argument_list|(
name|tags
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_DYNAMIC
argument_list|(
name|type
argument_list|)
condition|)
block|{
comment|/* SOS currently only implements single inheritance, 		   so we just pick up one string, if this class 		   has a base class.  */
name|tree
name|base_name
init|=
name|TYPE_BINFO_BASETYPES
argument_list|(
name|type
argument_list|)
operator|&&
name|TYPE_DYNAMIC
argument_list|(
name|TYPE_BINFO_BASECLASS
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|?
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|string_type_node
argument_list|,
name|CLASSTYPE_TYPENAME_AS_STRING
argument_list|(
name|TYPE_BINFO_BASETYPE
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
else|:
name|null_string
decl_stmt|;
name|tree
name|dyn_table
decl_stmt|,
name|dyn_entry
init|=
name|NULL_TREE
decl_stmt|,
name|fns
init|=
name|TYPE_BINFO_VIRTUALS
argument_list|(
name|type
argument_list|)
decl_stmt|;
while|while
condition|(
name|fns
condition|)
block|{
if|if
condition|(
name|TREE_ASM_WRITTEN
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_VALUE
argument_list|(
name|fns
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|dyn_entry
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|TREE_VALUE
argument_list|(
name|fns
argument_list|)
argument_list|,
name|dyn_entry
argument_list|)
expr_stmt|;
else|else
name|dyn_entry
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|__sosDynError
argument_list|,
name|dyn_entry
argument_list|)
expr_stmt|;
name|fns
operator|=
name|TREE_CHAIN
argument_list|(
name|fns
argument_list|)
expr_stmt|;
block|}
name|dyn_entry
operator|=
name|nreverse
argument_list|(
name|dyn_entry
argument_list|)
expr_stmt|;
name|dyn_entry
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|TYPE_POINTER_TO
argument_list|(
name|default_function_type
argument_list|)
argument_list|,
name|sosVersionNumber
argument_list|)
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_zero_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_zero_node
argument_list|,
name|dyn_entry
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|dyn_table
operator|=
name|finish_table
argument_list|(
name|TYPE_IDENTIFIER
argument_list|(
name|type
argument_list|)
argument_list|,
name|TYPE_POINTER_TO
argument_list|(
name|default_function_type
argument_list|)
argument_list|,
name|dyn_entry
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|entry
operator|=
name|build
argument_list|(
name|CONSTRUCTOR
argument_list|,
name|zret_type
argument_list|,
name|NULL_TREE
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|string_type_node
argument_list|,
name|CLASSTYPE_TYPENAME_AS_STRING
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|default_conversion
argument_list|(
name|dyn_table
argument_list|)
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_int_2
argument_list|(
name|CLASSTYPE_VSIZE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|base_name
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_CONSTANT
argument_list|(
name|entry
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|entry
argument_list|)
operator|=
literal|1
expr_stmt|;
name|zret
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|entry
argument_list|,
name|zret
argument_list|)
expr_stmt|;
block|}
name|tags
operator|=
name|TREE_CHAIN
argument_list|(
name|tags
argument_list|)
expr_stmt|;
block|}
name|zret_table
operator|=
name|finish_table
argument_list|(
name|get_identifier
argument_list|(
literal|"__Zret"
argument_list|)
argument_list|,
name|zret_type
argument_list|,
name|zret
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|c_expand_return
argument_list|(
name|convert
argument_list|(
name|build_pointer_type
argument_list|(
name|integer_type_node
argument_list|)
argument_list|,
name|default_conversion
argument_list|(
name|zret_table
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|expand_end_bindings
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|poplevel
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pop_momentary
argument_list|()
expr_stmt|;
name|finish_function
argument_list|(
name|lineno
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|assemble_constructor
argument_list|(
name|fnname
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Done with C language context needs.  */
name|pop_lang_context
argument_list|()
expr_stmt|;
comment|/* Now write out any static class variables (which may have since      learned how to be initialized).  */
while|while
condition|(
name|pending_statics
condition|)
block|{
name|tree
name|decl
init|=
name|TREE_VALUE
argument_list|(
name|pending_statics
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_USED
argument_list|(
name|decl
argument_list|)
operator|==
literal|1
operator|||
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
operator|||
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
condition|)
name|rest_of_decl_compilation
argument_list|(
name|decl
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pending_statics
operator|=
name|TREE_CHAIN
argument_list|(
name|pending_statics
argument_list|)
expr_stmt|;
block|}
name|this_time
operator|=
name|get_run_time
argument_list|()
expr_stmt|;
name|parse_time
operator|-=
name|this_time
operator|-
name|start_time
expr_stmt|;
name|varconst_time
operator|+=
name|this_time
operator|-
name|start_time
expr_stmt|;
comment|/* Now write out inline functions which had their addresses taken      and which were not declared virtual and which were not declared      `extern inline'.  */
while|while
condition|(
name|pending_addressable_inlines
condition|)
block|{
name|tree
name|decl
init|=
name|TREE_VALUE
argument_list|(
name|pending_addressable_inlines
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|TREE_ASM_WRITTEN
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_SAVED_INSNS
argument_list|(
name|decl
argument_list|)
condition|)
name|output_inline_function
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|pending_addressable_inlines
operator|=
name|TREE_CHAIN
argument_list|(
name|pending_addressable_inlines
argument_list|)
expr_stmt|;
block|}
name|start_time
operator|=
name|get_run_time
argument_list|()
expr_stmt|;
comment|/* Now delete from the chain of variables all virtual function tables.      We output them all ourselves, because each will be treated specially.  */
if|#
directive|if
literal|1
comment|/* The reason for pushing garbage onto the global_binding_level is to      ensure that we can slice out _DECLs which pertain to virtual function      tables.  If the last thing pushed onto the global_binding_level was a      virtual function table, then slicing it out would slice away all the      decls (i.e., we lose the head of the chain).       There are several ways of getting the same effect, from changing the      way that iterators over the chain treat the elements that pertain to      virtual function tables, moving the implementation of this code to      cp-decl.c (where we can manipulate global_binding_level directly),      popping the garbage after pushing it and slicing away the vtable      stuff, or just leaving it alone. */
comment|/* Make last thing in global scope not be a virtual function table.  */
if|#
directive|if
literal|0
comment|/* not yet, should get fixed properly later */
block|vars = make_type_decl (get_identifier (" @%$#@!"), integer_type_node);
else|#
directive|else
name|vars
operator|=
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|" @%$#@!"
argument_list|)
argument_list|,
name|integer_type_node
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|DECL_IGNORED_P
argument_list|(
name|vars
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_SOURCE_LINE
argument_list|(
name|vars
argument_list|)
operator|=
literal|0
expr_stmt|;
name|pushdecl
argument_list|(
name|vars
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|walk_vtables
argument_list|(
name|finish_vtable_typedecl
argument_list|,
name|finish_vtable_vardecl
argument_list|)
expr_stmt|;
if|if
condition|(
name|write_virtuals
operator|==
literal|2
condition|)
block|{
comment|/* Now complain about an virtual function tables promised 	 but not delivered.  */
while|while
condition|(
name|pending_vtables
condition|)
block|{
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|pending_vtables
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|error
argument_list|(
literal|"virtual function table for `%s' not defined"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|TREE_VALUE
argument_list|(
name|pending_vtables
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|pending_vtables
operator|=
name|TREE_CHAIN
argument_list|(
name|pending_vtables
argument_list|)
expr_stmt|;
block|}
block|}
name|permanent_allocation
argument_list|()
expr_stmt|;
name|this_time
operator|=
name|get_run_time
argument_list|()
expr_stmt|;
name|parse_time
operator|-=
name|this_time
operator|-
name|start_time
expr_stmt|;
name|varconst_time
operator|+=
name|this_time
operator|-
name|start_time
expr_stmt|;
if|if
condition|(
name|flag_detailed_statistics
condition|)
name|dump_time_statistics
argument_list|()
expr_stmt|;
block|}
end_function

end_unit

