begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Generate code from machine description to compute values of attributes.    Copyright (C) 1991 Free Software Foundation, Inc.    Contributed by Richard Kenner (kenner@nyu.edu)  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* This program handles insn attributes and the DEFINE_DELAY and    DEFINE_FUNCTION_UNIT definitions.     It produces a series of functions named `get_attr_...', one for each insn    attribute.  Each of these is given the rtx for an insn and returns a member    of the enum for the attribute.     These subroutines have the form of a `switch' on the INSN_CODE (via    `recog_memoized').  Each case either returns a constant attribute value    or a value that depends on tests on other attributes, the form of    operands, or some random C expression (encoded with a SYMBOL_REF    expression).     If the attribute `alternative', or a random C expression is present,    `constrain_operands' is called.  If either of these cases of a reference to    an operand is found, `insn_extract' is called.     The special attribute `length' is also recognized.  For this operand,     expressions involving the address of an operand or the current insn,    (address (pc)), are valid.  In this case, an initial pass is made to    set all lengths that do not depend on address.  Those that do are set to    the maximum length.  Then each insn that depends on an address is checked    and possibly has its length changed.  The process repeats until no further    changed are made.  The resulting lengths are saved for use by    `get_attr_length'.     A special form of DEFINE_ATTR, where the expression for default value is a    CONST expression, indicates an attribute that is constant for a given run    of the compiler.  The subroutine generated for these attributes has no    parameters as it does not depend on any particular insn.  Constant    attributes are typically used to specify which variety of processor is    used.        Internal attributes are defined to handle DEFINE_DELAY and    DEFINE_FUNCTION_UNIT.  Special routines are output for these cases.     This program works by keeping a list of possible values for each attribute.    These include the basic attribute choices, default values for attribute, and    all derived quantities.     As the description file is read, the definition for each insn is saved in a    `struct insn_def'.   When the file reading is complete, a `struct insn_ent'    is created for each insn and chained to the corresponding attribute value,    either that specified, or the default.     An optimization phase is then run.  This simplifies expressions for each    insn.  EQ_ATTR tests are resolved, whenever possible, to a test that    indicates when the attribute has the specified value for the insn.  This    avoids recursive calls during compilation.     The strategy used when processing DEFINE_DELAY and DEFINE_FUNCTION_UNIT    definitions is to create arbitrarily complex expressions and have the    optimization simplify them.     Once optimization is complete, any required routines and definitions    will be written.     An optimization that is not yet implemented is to hoist the constant    expressions entirely out of the routines and definitions that are written.    A way to do this is to iterate over all possible combinations of values    for constant attributes and generate a set of functions for that given    combination.  An initialization function would be written that evaluates    the attributes and installs the corresponding set of routines and    definitions (each would be accessed through a pointer).     We use the flags in an RTX as follows:    `unchanging' (RTX_UNCHANGING_P): This rtx is fully simplified       independent of the insn code.    `in_struct' (MEM_IN_STRUCT_P): This rtx is fully simplified       for the insn code currently being processed (see optimize_attrs).    `integrated' (RTX_INTEGRATED_P): This rtx is permanent and unique       (see attr_rtx).    `volatil' (MEM_VOLATILE_P): During simplify_by_exploding the value of an       EQ_ATTR rtx is true if !volatil and false if volatil.  */
end_comment

begin_include
include|#
directive|include
file|"gvarargs.h"
end_include

begin_include
include|#
directive|include
file|"hconfig.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_comment
comment|/* For REGISTER_CONSTRAINTS */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|VMS
end_ifndef

begin_ifndef
ifndef|#
directive|ifndef
name|USG
end_ifndef

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* We must include obstack.h after<sys/time.h>, to avoid lossage with    /usr/include/sys/stdtypes.h on Sun OS 4.x.  */
end_comment

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_decl_stmt
specifier|static
name|struct
name|obstack
name|obstack
decl_stmt|,
name|obstack1
decl_stmt|,
name|obstack2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|obstack
modifier|*
name|rtl_obstack
init|=
operator|&
name|obstack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|obstack
modifier|*
name|hash_obstack
init|=
operator|&
name|obstack1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|obstack
modifier|*
name|temp_obstack
init|=
operator|&
name|obstack2
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|obstack_chunk_alloc
value|xmalloc
end_define

begin_define
define|#
directive|define
name|obstack_chunk_free
value|free
end_define

begin_comment
comment|/* Define this so we can link with print-rtl.o to get debug_rtx function.  */
end_comment

begin_decl_stmt
name|char
modifier|*
modifier|*
name|insn_name_ptr
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|void
name|free
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|rtx
name|read_rtx
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fatal
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|fancy_abort
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* enough space to reserve for printing out ints */
end_comment

begin_define
define|#
directive|define
name|MAX_DIGITS
value|(HOST_BITS_PER_INT * 3 / 10 + 3)
end_define

begin_comment
comment|/* Define structures used to record attributes and values.  */
end_comment

begin_comment
comment|/* As each DEFINE_INSN, DEFINE_PEEPHOLE, or DEFINE_ASM_ATTRIBUTES is    encountered, we store all the relevant information into a    `struct insn_def'.  This is done to allow attribute definitions to occur    anywhere in the file.  */
end_comment

begin_struct
struct|struct
name|insn_def
block|{
name|int
name|insn_code
decl_stmt|;
comment|/* Instruction number. */
name|int
name|insn_index
decl_stmt|;
comment|/* Expression numer in file, for errors. */
name|struct
name|insn_def
modifier|*
name|next
decl_stmt|;
comment|/* Next insn in chain. */
name|rtx
name|def
decl_stmt|;
comment|/* The DEFINE_... */
name|int
name|num_alternatives
decl_stmt|;
comment|/* Number of alternatives.  */
name|int
name|vec_idx
decl_stmt|;
comment|/* Index of attribute vector in `def'. */
block|}
struct|;
end_struct

begin_comment
comment|/* Once everything has been read in, we store in each attribute value a list    of insn codes that have that value.  Here is the structure used for the    list.  */
end_comment

begin_struct
struct|struct
name|insn_ent
block|{
name|int
name|insn_code
decl_stmt|;
comment|/* Instruction number.  */
name|int
name|insn_index
decl_stmt|;
comment|/* Index of definition in file */
name|struct
name|insn_ent
modifier|*
name|next
decl_stmt|;
comment|/* Next in chain.  */
block|}
struct|;
end_struct

begin_comment
comment|/* Each value of an attribute (either constant or computed) is assigned a    structure which is used as the listhead of the insns that have that    value.  */
end_comment

begin_struct
struct|struct
name|attr_value
block|{
name|rtx
name|value
decl_stmt|;
comment|/* Value of attribute.  */
name|struct
name|attr_value
modifier|*
name|next
decl_stmt|;
comment|/* Next attribute value in chain.  */
name|struct
name|insn_ent
modifier|*
name|first_insn
decl_stmt|;
comment|/* First insn with this value.  */
name|int
name|num_insns
decl_stmt|;
comment|/* Number of insns with this value.  */
name|int
name|has_asm_insn
decl_stmt|;
comment|/* True if this value used for `asm' insns */
block|}
struct|;
end_struct

begin_comment
comment|/* Structure for each attribute.  */
end_comment

begin_struct
struct|struct
name|attr_desc
block|{
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Name of attribute. */
name|struct
name|attr_desc
modifier|*
name|next
decl_stmt|;
comment|/* Next attribute. */
name|int
name|is_numeric
decl_stmt|;
comment|/* Values of this attribute are numeric. */
name|int
name|negative_ok
decl_stmt|;
comment|/* Allow negative numeric values.  */
name|int
name|unsigned_p
decl_stmt|;
comment|/* Make the output function unsigned int.  */
name|int
name|is_const
decl_stmt|;
comment|/* Attribute value constant for each run.  */
name|int
name|is_special
decl_stmt|;
comment|/* Don't call `write_attr_set'. */
name|struct
name|attr_value
modifier|*
name|first_value
decl_stmt|;
comment|/* First value of this attribute. */
name|struct
name|attr_value
modifier|*
name|default_val
decl_stmt|;
comment|/* Default value for this attribute. */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|NULL_ATTR
value|(struct attr_desc *) NULL
end_define

begin_comment
comment|/* A range of values.  */
end_comment

begin_struct
struct|struct
name|range
block|{
name|int
name|min
decl_stmt|;
name|int
name|max
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Structure for each DEFINE_DELAY.  */
end_comment

begin_struct
struct|struct
name|delay_desc
block|{
name|rtx
name|def
decl_stmt|;
comment|/* DEFINE_DELAY expression.  */
name|struct
name|delay_desc
modifier|*
name|next
decl_stmt|;
comment|/* Next DEFINE_DELAY. */
name|int
name|num
decl_stmt|;
comment|/* Number of DEFINE_DELAY, starting at 1.  */
block|}
struct|;
end_struct

begin_comment
comment|/* Record information about each DEFINE_FUNCTION_UNIT.  */
end_comment

begin_struct
struct|struct
name|function_unit_op
block|{
name|rtx
name|condexp
decl_stmt|;
comment|/* Expression TRUE for applicable insn.  */
name|struct
name|function_unit_op
modifier|*
name|next
decl_stmt|;
comment|/* Next operation for this function unit.  */
name|int
name|num
decl_stmt|;
comment|/* Ordinal for this operation type in unit.  */
name|int
name|ready
decl_stmt|;
comment|/* Cost until data is ready.  */
name|int
name|issue_delay
decl_stmt|;
comment|/* Cost until unit can accept another insn.  */
name|rtx
name|conflict_exp
decl_stmt|;
comment|/* Expression TRUE for insns incurring issue delay.  */
name|rtx
name|issue_exp
decl_stmt|;
comment|/* Expression computing issue delay.  */
block|}
struct|;
end_struct

begin_comment
comment|/* Record information about each function unit mentioned in a    DEFINE_FUNCTION_UNIT.  */
end_comment

begin_struct
struct|struct
name|function_unit
block|{
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Function unit name.  */
name|struct
name|function_unit
modifier|*
name|next
decl_stmt|;
comment|/* Next function unit.  */
name|int
name|num
decl_stmt|;
comment|/* Ordinal of this unit type.  */
name|int
name|multiplicity
decl_stmt|;
comment|/* Number of units of this type.  */
name|int
name|simultaneity
decl_stmt|;
comment|/* Maximum number of simultaneous insns 				   on this function unit or 0 if unlimited.  */
name|rtx
name|condexp
decl_stmt|;
comment|/* Expression TRUE for insn needing unit. */
name|int
name|num_opclasses
decl_stmt|;
comment|/* Number of different operation types.  */
name|struct
name|function_unit_op
modifier|*
name|ops
decl_stmt|;
comment|/* Pointer to first operation type.  */
name|int
name|needs_conflict_function
decl_stmt|;
comment|/* Nonzero if a conflict function required.  */
name|int
name|needs_blockage_function
decl_stmt|;
comment|/* Nonzero if a blockage function required.  */
name|int
name|needs_range_function
decl_stmt|;
comment|/* Nonzero if a blockage range function required.  */
name|rtx
name|default_cost
decl_stmt|;
comment|/* Conflict cost, if constant.  */
name|struct
name|range
name|issue_delay
decl_stmt|;
comment|/* Range of issue delay values.  */
name|int
name|max_blockage
decl_stmt|;
comment|/* Maximum time an insn blocks the unit.  */
block|}
struct|;
end_struct

begin_comment
comment|/* Listheads of above structures.  */
end_comment

begin_comment
comment|/* This one is indexed by the first character of the attribute name.  */
end_comment

begin_define
define|#
directive|define
name|MAX_ATTRS_INDEX
value|256
end_define

begin_decl_stmt
specifier|static
name|struct
name|attr_desc
modifier|*
name|attrs
index|[
name|MAX_ATTRS_INDEX
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|insn_def
modifier|*
name|defs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|delay_desc
modifier|*
name|delays
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|function_unit
modifier|*
name|units
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Other variables. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|insn_code_number
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|insn_index_number
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|got_define_asm_attributes
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|must_extract
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|must_constrain
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|address_used
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|length_used
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|num_delays
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|have_annul_true
decl_stmt|,
name|have_annul_false
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|num_units
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Used as operand to `operate_exp':  */
end_comment

begin_enum
enum|enum
name|operator
block|{
name|PLUS_OP
block|,
name|MINUS_OP
block|,
name|POS_MINUS_OP
block|,
name|EQ_OP
block|,
name|OR_OP
block|,
name|MAX_OP
block|,
name|MIN_OP
block|,
name|RANGE_OP
block|}
enum|;
end_enum

begin_comment
comment|/* Stores, for each insn code, the number of constraint alternatives.  */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|insn_n_alternatives
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Stores, for each insn code, a bitmap that has bits on for each possible    alternative.  */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|insn_alternatives
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If nonzero, assume that the `alternative' attr has this value.    This is the hashed, unique string for the numeral    whose value is chosen alternative.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|current_alternative_string
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Used to simplify expressions.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|true_rtx
decl_stmt|,
name|false_rtx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Used to reduce calls to `strcmp' */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|alternative_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Simplify an expression.  Only call the routine if there is something to    simplify.  */
end_comment

begin_define
define|#
directive|define
name|SIMPLIFY_TEST_EXP
parameter_list|(
name|EXP
parameter_list|,
name|INSN_CODE
parameter_list|,
name|INSN_INDEX
parameter_list|)
define|\
value|(RTX_UNCHANGING_P (EXP) || MEM_IN_STRUCT_P (EXP) ? (EXP)	\    : simplify_test_exp (EXP, INSN_CODE, INSN_INDEX))
end_define

begin_comment
comment|/* Simplify (eq_attr ("alternative") ...)    when we are working with a particular alternative.  */
end_comment

begin_define
define|#
directive|define
name|SIMPLIFY_ALTERNATIVE
parameter_list|(
name|EXP
parameter_list|)
define|\
value|if (current_alternative_string				\&& GET_CODE ((EXP)) == EQ_ATTR				\&& XSTR ((EXP), 0) == alternative_name)			\     (EXP) = (XSTR ((EXP), 1) == current_alternative_string	\ 	    ? true_rtx : false_rtx);
end_define

begin_comment
comment|/* These are referenced by rtlanal.c and hence need to be defined somewhere.    They won't actually be used.  */
end_comment

begin_decl_stmt
name|rtx
name|frame_pointer_rtx
decl_stmt|,
name|stack_pointer_rtx
decl_stmt|,
name|arg_pointer_rtx
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|rtx
name|attr_rtx
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|attr_printf
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|attr_string
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|check_attr_test
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|check_attr_value
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|convert_set_attr_alternative
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|convert_set_attr
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|check_defs
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|convert_const_symbol_ref
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|make_canonical
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|attr_value
modifier|*
name|get_attr_value
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|copy_rtx_unchanging
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|copy_boolean
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|expand_delays
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|operate_exp
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|expand_units
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|simplify_knowing
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|encode_units_mask
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fill_attr
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|substitute_address
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|make_length_attrs
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|identity_fn
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|zero_fn
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|one_fn
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|max_fn
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|simplify_cond
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|simplify_by_alternatives
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|simplify_by_exploding
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|find_and_mark_used_attributes
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|unmark_used_attributes
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|add_values_to_cover
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|increment_current_value
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|test_for_current_value
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|simplify_with_current_value
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|simplify_with_current_value_aux
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|remove_insn_ent
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|insert_insn_ent
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|insert_right_side
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|make_alternative_compare
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|compute_alternative_mask
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|evaluate_eq_attr
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|simplify_and_tree
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|simplify_or_tree
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|simplify_test_exp
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|optimize_attrs
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gen_attr
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|count_alternatives
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|compares_alternatives_p
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|contained_in_p
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gen_insn
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gen_delay
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gen_unit
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|write_test_expr
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|max_attr_value
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|walk_attr_value
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|write_attr_get
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|eliminate_known_true
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|write_attr_set
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|write_attr_case
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|write_attr_value
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|write_attr_valueq
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|write_upcase
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|write_indent
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|write_eligible_delay
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|write_function_unit_info
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|write_complex_function
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|n_comma_elts
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|next_comma_elt
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|attr_desc
modifier|*
name|find_attr
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|make_internal_attr
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|attr_value
modifier|*
name|find_most_used
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|find_single_value
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|make_numeric_value
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|extend_range
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|xrealloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|xmalloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fatal
parameter_list|()
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|oballoc
parameter_list|(
name|size
parameter_list|)
value|obstack_alloc (hash_obstack, size)
end_define

begin_escape
end_escape

begin_comment
comment|/* Hash table for sharing RTL and strings.  */
end_comment

begin_comment
comment|/* Each hash table slot is a bucket containing a chain of these structures.    Strings are given negative hash codes; RTL expressions are given positive    hash codes.  */
end_comment

begin_struct
struct|struct
name|attr_hash
block|{
name|struct
name|attr_hash
modifier|*
name|next
decl_stmt|;
comment|/* Next structure in the bucket.  */
name|int
name|hashcode
decl_stmt|;
comment|/* Hash code of this rtx or string.  */
union|union
block|{
name|char
modifier|*
name|str
decl_stmt|;
comment|/* The string (negative hash codes) */
name|rtx
name|rtl
decl_stmt|;
comment|/* or the RTL recorded here.  */
block|}
name|u
union|;
block|}
struct|;
end_struct

begin_comment
comment|/* Now here is the hash table.  When recording an RTL, it is added to    the slot whose index is the hash code mod the table size.  Note    that the hash table is used for several kinds of RTL (see attr_rtx)    and for strings.  While all these live in the same table, they are    completely independent, and the hash code is computed differently    for each.  */
end_comment

begin_define
define|#
directive|define
name|RTL_HASH_SIZE
value|4093
end_define

begin_decl_stmt
name|struct
name|attr_hash
modifier|*
name|attr_hash_table
index|[
name|RTL_HASH_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Here is how primitive or already-shared RTL's hash    codes are made.  */
end_comment

begin_define
define|#
directive|define
name|RTL_HASH
parameter_list|(
name|RTL
parameter_list|)
value|((HOST_WIDE_INT) (RTL)& 0777777)
end_define

begin_comment
comment|/* Add an entry to the hash table for RTL with hash code HASHCODE.  */
end_comment

begin_function
specifier|static
name|void
name|attr_hash_add_rtx
parameter_list|(
name|hashcode
parameter_list|,
name|rtl
parameter_list|)
name|int
name|hashcode
decl_stmt|;
name|rtx
name|rtl
decl_stmt|;
block|{
specifier|register
name|struct
name|attr_hash
modifier|*
name|h
decl_stmt|;
name|h
operator|=
operator|(
expr|struct
name|attr_hash
operator|*
operator|)
name|obstack_alloc
argument_list|(
name|hash_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|attr_hash
argument_list|)
argument_list|)
expr_stmt|;
name|h
operator|->
name|hashcode
operator|=
name|hashcode
expr_stmt|;
name|h
operator|->
name|u
operator|.
name|rtl
operator|=
name|rtl
expr_stmt|;
name|h
operator|->
name|next
operator|=
name|attr_hash_table
index|[
name|hashcode
operator|%
name|RTL_HASH_SIZE
index|]
expr_stmt|;
name|attr_hash_table
index|[
name|hashcode
operator|%
name|RTL_HASH_SIZE
index|]
operator|=
name|h
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add an entry to the hash table for STRING with hash code HASHCODE.  */
end_comment

begin_function
specifier|static
name|void
name|attr_hash_add_string
parameter_list|(
name|hashcode
parameter_list|,
name|str
parameter_list|)
name|int
name|hashcode
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
block|{
specifier|register
name|struct
name|attr_hash
modifier|*
name|h
decl_stmt|;
name|h
operator|=
operator|(
expr|struct
name|attr_hash
operator|*
operator|)
name|obstack_alloc
argument_list|(
name|hash_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|attr_hash
argument_list|)
argument_list|)
expr_stmt|;
name|h
operator|->
name|hashcode
operator|=
operator|-
name|hashcode
expr_stmt|;
name|h
operator|->
name|u
operator|.
name|str
operator|=
name|str
expr_stmt|;
name|h
operator|->
name|next
operator|=
name|attr_hash_table
index|[
name|hashcode
operator|%
name|RTL_HASH_SIZE
index|]
expr_stmt|;
name|attr_hash_table
index|[
name|hashcode
operator|%
name|RTL_HASH_SIZE
index|]
operator|=
name|h
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate an RTL expression, but avoid duplicates.    Set the RTX_INTEGRATED_P flag for these permanent objects.     In some cases we cannot uniquify; then we return an ordinary    impermanent rtx with RTX_INTEGRATED_P clear.     Args are like gen_rtx, but without the mode:     rtx attr_rtx (code, [element1, ..., elementn])  */
end_comment

begin_comment
comment|/*VARARGS1*/
end_comment

begin_function
specifier|static
name|rtx
name|attr_rtx
parameter_list|(
name|va_alist
parameter_list|)
function|va_dcl
block|{
name|va_list
name|p
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
comment|/* Array indices...			*/
specifier|register
name|char
modifier|*
name|fmt
decl_stmt|;
comment|/* Current rtx's format...		*/
specifier|register
name|rtx
name|rt_val
decl_stmt|;
comment|/* RTX to return to caller...		*/
name|int
name|hashcode
decl_stmt|;
specifier|register
name|struct
name|attr_hash
modifier|*
name|h
decl_stmt|;
name|struct
name|obstack
modifier|*
name|old_obstack
init|=
name|rtl_obstack
decl_stmt|;
name|va_start
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|code
operator|=
name|va_arg
argument_list|(
name|p
argument_list|,
expr|enum
name|rtx_code
argument_list|)
expr_stmt|;
comment|/* For each of several cases, search the hash table for an existing entry.      Use that entry if one is found; otherwise create a new RTL and add it      to the table.  */
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'1'
condition|)
block|{
name|rtx
name|arg0
init|=
name|va_arg
argument_list|(
name|p
argument_list|,
name|rtx
argument_list|)
decl_stmt|;
comment|/* A permanent object cannot point to impermanent ones.  */
if|if
condition|(
operator|!
name|RTX_INTEGRATED_P
argument_list|(
name|arg0
argument_list|)
condition|)
block|{
name|rt_val
operator|=
name|rtx_alloc
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|rt_val
argument_list|,
literal|0
argument_list|)
operator|=
name|arg0
expr_stmt|;
name|va_end
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
name|rt_val
return|;
block|}
name|hashcode
operator|=
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
name|code
operator|+
name|RTL_HASH
argument_list|(
name|arg0
argument_list|)
operator|)
expr_stmt|;
for|for
control|(
name|h
operator|=
name|attr_hash_table
index|[
name|hashcode
operator|%
name|RTL_HASH_SIZE
index|]
init|;
name|h
condition|;
name|h
operator|=
name|h
operator|->
name|next
control|)
if|if
condition|(
name|h
operator|->
name|hashcode
operator|==
name|hashcode
operator|&&
name|GET_CODE
argument_list|(
name|h
operator|->
name|u
operator|.
name|rtl
argument_list|)
operator|==
name|code
operator|&&
name|XEXP
argument_list|(
name|h
operator|->
name|u
operator|.
name|rtl
argument_list|,
literal|0
argument_list|)
operator|==
name|arg0
condition|)
goto|goto
name|found
goto|;
if|if
condition|(
name|h
operator|==
literal|0
condition|)
block|{
name|rtl_obstack
operator|=
name|hash_obstack
expr_stmt|;
name|rt_val
operator|=
name|rtx_alloc
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|rt_val
argument_list|,
literal|0
argument_list|)
operator|=
name|arg0
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'c'
operator|||
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'2'
operator|||
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'<'
condition|)
block|{
name|rtx
name|arg0
init|=
name|va_arg
argument_list|(
name|p
argument_list|,
name|rtx
argument_list|)
decl_stmt|;
name|rtx
name|arg1
init|=
name|va_arg
argument_list|(
name|p
argument_list|,
name|rtx
argument_list|)
decl_stmt|;
comment|/* A permanent object cannot point to impermanent ones.  */
if|if
condition|(
operator|!
name|RTX_INTEGRATED_P
argument_list|(
name|arg0
argument_list|)
operator|||
operator|!
name|RTX_INTEGRATED_P
argument_list|(
name|arg1
argument_list|)
condition|)
block|{
name|rt_val
operator|=
name|rtx_alloc
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|rt_val
argument_list|,
literal|0
argument_list|)
operator|=
name|arg0
expr_stmt|;
name|XEXP
argument_list|(
name|rt_val
argument_list|,
literal|1
argument_list|)
operator|=
name|arg1
expr_stmt|;
name|va_end
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
name|rt_val
return|;
block|}
name|hashcode
operator|=
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
name|code
operator|+
name|RTL_HASH
argument_list|(
name|arg0
argument_list|)
operator|+
name|RTL_HASH
argument_list|(
name|arg1
argument_list|)
operator|)
expr_stmt|;
for|for
control|(
name|h
operator|=
name|attr_hash_table
index|[
name|hashcode
operator|%
name|RTL_HASH_SIZE
index|]
init|;
name|h
condition|;
name|h
operator|=
name|h
operator|->
name|next
control|)
if|if
condition|(
name|h
operator|->
name|hashcode
operator|==
name|hashcode
operator|&&
name|GET_CODE
argument_list|(
name|h
operator|->
name|u
operator|.
name|rtl
argument_list|)
operator|==
name|code
operator|&&
name|XEXP
argument_list|(
name|h
operator|->
name|u
operator|.
name|rtl
argument_list|,
literal|0
argument_list|)
operator|==
name|arg0
operator|&&
name|XEXP
argument_list|(
name|h
operator|->
name|u
operator|.
name|rtl
argument_list|,
literal|1
argument_list|)
operator|==
name|arg1
condition|)
goto|goto
name|found
goto|;
if|if
condition|(
name|h
operator|==
literal|0
condition|)
block|{
name|rtl_obstack
operator|=
name|hash_obstack
expr_stmt|;
name|rt_val
operator|=
name|rtx_alloc
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|rt_val
argument_list|,
literal|0
argument_list|)
operator|=
name|arg0
expr_stmt|;
name|XEXP
argument_list|(
name|rt_val
argument_list|,
literal|1
argument_list|)
operator|=
name|arg1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|==
literal|1
operator|&&
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
index|[
literal|0
index|]
operator|==
literal|'s'
condition|)
block|{
name|char
modifier|*
name|arg0
init|=
name|va_arg
argument_list|(
name|p
argument_list|,
name|char
operator|*
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|SYMBOL_REF
condition|)
name|arg0
operator|=
name|attr_string
argument_list|(
name|arg0
argument_list|,
name|strlen
argument_list|(
name|arg0
argument_list|)
argument_list|)
expr_stmt|;
name|hashcode
operator|=
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
name|code
operator|+
name|RTL_HASH
argument_list|(
name|arg0
argument_list|)
operator|)
expr_stmt|;
for|for
control|(
name|h
operator|=
name|attr_hash_table
index|[
name|hashcode
operator|%
name|RTL_HASH_SIZE
index|]
init|;
name|h
condition|;
name|h
operator|=
name|h
operator|->
name|next
control|)
if|if
condition|(
name|h
operator|->
name|hashcode
operator|==
name|hashcode
operator|&&
name|GET_CODE
argument_list|(
name|h
operator|->
name|u
operator|.
name|rtl
argument_list|)
operator|==
name|code
operator|&&
name|XSTR
argument_list|(
name|h
operator|->
name|u
operator|.
name|rtl
argument_list|,
literal|0
argument_list|)
operator|==
name|arg0
condition|)
goto|goto
name|found
goto|;
if|if
condition|(
name|h
operator|==
literal|0
condition|)
block|{
name|rtl_obstack
operator|=
name|hash_obstack
expr_stmt|;
name|rt_val
operator|=
name|rtx_alloc
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|XSTR
argument_list|(
name|rt_val
argument_list|,
literal|0
argument_list|)
operator|=
name|arg0
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|==
literal|2
operator|&&
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
index|[
literal|0
index|]
operator|==
literal|'s'
operator|&&
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
index|[
literal|1
index|]
operator|==
literal|'s'
condition|)
block|{
name|char
modifier|*
name|arg0
init|=
name|va_arg
argument_list|(
name|p
argument_list|,
name|char
operator|*
argument_list|)
decl_stmt|;
name|char
modifier|*
name|arg1
init|=
name|va_arg
argument_list|(
name|p
argument_list|,
name|char
operator|*
argument_list|)
decl_stmt|;
name|hashcode
operator|=
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
name|code
operator|+
name|RTL_HASH
argument_list|(
name|arg0
argument_list|)
operator|+
name|RTL_HASH
argument_list|(
name|arg1
argument_list|)
operator|)
expr_stmt|;
for|for
control|(
name|h
operator|=
name|attr_hash_table
index|[
name|hashcode
operator|%
name|RTL_HASH_SIZE
index|]
init|;
name|h
condition|;
name|h
operator|=
name|h
operator|->
name|next
control|)
if|if
condition|(
name|h
operator|->
name|hashcode
operator|==
name|hashcode
operator|&&
name|GET_CODE
argument_list|(
name|h
operator|->
name|u
operator|.
name|rtl
argument_list|)
operator|==
name|code
operator|&&
name|XSTR
argument_list|(
name|h
operator|->
name|u
operator|.
name|rtl
argument_list|,
literal|0
argument_list|)
operator|==
name|arg0
operator|&&
name|XSTR
argument_list|(
name|h
operator|->
name|u
operator|.
name|rtl
argument_list|,
literal|1
argument_list|)
operator|==
name|arg1
condition|)
goto|goto
name|found
goto|;
if|if
condition|(
name|h
operator|==
literal|0
condition|)
block|{
name|rtl_obstack
operator|=
name|hash_obstack
expr_stmt|;
name|rt_val
operator|=
name|rtx_alloc
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|XSTR
argument_list|(
name|rt_val
argument_list|,
literal|0
argument_list|)
operator|=
name|arg0
expr_stmt|;
name|XSTR
argument_list|(
name|rt_val
argument_list|,
literal|1
argument_list|)
operator|=
name|arg1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|CONST_INT
condition|)
block|{
name|HOST_WIDE_INT
name|arg0
init|=
name|va_arg
argument_list|(
name|p
argument_list|,
name|HOST_WIDE_INT
argument_list|)
decl_stmt|;
if|if
condition|(
name|arg0
operator|==
literal|0
condition|)
return|return
name|false_rtx
return|;
if|if
condition|(
name|arg0
operator|==
literal|1
condition|)
return|return
name|true_rtx
return|;
goto|goto
name|nohash
goto|;
block|}
else|else
block|{
name|nohash
label|:
name|rt_val
operator|=
name|rtx_alloc
argument_list|(
name|code
argument_list|)
expr_stmt|;
comment|/* Allocate the storage space.  */
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
comment|/* Find the right format...  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
operator|*
name|fmt
operator|++
condition|)
block|{
case|case
literal|'0'
case|:
comment|/* Unused field.  */
break|break;
case|case
literal|'i'
case|:
comment|/* An integer?  */
name|XINT
argument_list|(
name|rt_val
argument_list|,
name|i
argument_list|)
operator|=
name|va_arg
argument_list|(
name|p
argument_list|,
name|int
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
comment|/* A wide integer? */
name|XWINT
argument_list|(
name|rt_val
argument_list|,
name|i
argument_list|)
operator|=
name|va_arg
argument_list|(
name|p
argument_list|,
name|HOST_WIDE_INT
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
comment|/* A string?  */
name|XSTR
argument_list|(
name|rt_val
argument_list|,
name|i
argument_list|)
operator|=
name|va_arg
argument_list|(
name|p
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
comment|/* An expression?  */
case|case
literal|'u'
case|:
comment|/* An insn?  Same except when printing.  */
name|XEXP
argument_list|(
name|rt_val
argument_list|,
name|i
argument_list|)
operator|=
name|va_arg
argument_list|(
name|p
argument_list|,
name|rtx
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
comment|/* An RTX vector?  */
name|XVEC
argument_list|(
name|rt_val
argument_list|,
name|i
argument_list|)
operator|=
name|va_arg
argument_list|(
name|p
argument_list|,
name|rtvec
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
name|va_end
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
name|rt_val
return|;
block|}
name|rtl_obstack
operator|=
name|old_obstack
expr_stmt|;
name|va_end
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|attr_hash_add_rtx
argument_list|(
name|hashcode
argument_list|,
name|rt_val
argument_list|)
expr_stmt|;
name|RTX_INTEGRATED_P
argument_list|(
name|rt_val
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|rt_val
return|;
name|found
label|:
name|va_end
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
name|h
operator|->
name|u
operator|.
name|rtl
return|;
block|}
end_function

begin_comment
comment|/* Create a new string printed with the printf line arguments into a space    of at most LEN bytes:     rtx attr_printf (len, format, [arg1, ..., argn])  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_VPRINTF
end_ifdef

begin_comment
comment|/*VARARGS2*/
end_comment

begin_function
specifier|static
name|char
modifier|*
name|attr_printf
parameter_list|(
name|va_alist
parameter_list|)
function|va_dcl
block|{
name|va_list
name|p
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
specifier|register
name|char
modifier|*
name|fmt
decl_stmt|;
specifier|register
name|char
modifier|*
name|str
decl_stmt|;
comment|/* Print the string into a temporary location.  */
name|va_start
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|len
operator|=
name|va_arg
argument_list|(
name|p
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|str
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|fmt
operator|=
name|va_arg
argument_list|(
name|p
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
name|vsprintf
argument_list|(
name|str
argument_list|,
name|fmt
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
name|attr_string
argument_list|(
name|str
argument_list|,
name|strlen
argument_list|(
name|str
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* not HAVE_VPRINTF */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|attr_printf
parameter_list|(
name|len
parameter_list|,
name|fmt
parameter_list|,
name|arg1
parameter_list|,
name|arg2
parameter_list|,
name|arg3
parameter_list|)
name|int
name|len
decl_stmt|;
name|char
modifier|*
name|fmt
decl_stmt|;
name|char
modifier|*
name|arg1
decl_stmt|,
decl|*
name|arg2
decl_stmt|,
modifier|*
name|arg3
decl_stmt|;
end_function

begin_comment
comment|/* also int */
end_comment

begin_block
block|{
specifier|register
name|char
modifier|*
name|str
decl_stmt|;
comment|/* Print the string into a temporary location.  */
name|str
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|str
argument_list|,
name|fmt
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|,
name|arg3
argument_list|)
expr_stmt|;
return|return
name|attr_string
argument_list|(
name|str
argument_list|,
name|strlen
argument_list|(
name|str
argument_list|)
argument_list|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not HAVE_VPRINTF */
end_comment

begin_function
name|rtx
name|attr_eq
parameter_list|(
name|name
parameter_list|,
name|value
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|,
decl|*
name|value
decl_stmt|;
end_function

begin_block
block|{
return|return
name|attr_rtx
argument_list|(
name|EQ_ATTR
argument_list|,
name|attr_string
argument_list|(
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|)
argument_list|,
name|attr_string
argument_list|(
name|value
argument_list|,
name|strlen
argument_list|(
name|value
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
end_block

begin_function
name|char
modifier|*
name|attr_numeral
parameter_list|(
name|n
parameter_list|)
name|int
name|n
decl_stmt|;
block|{
return|return
name|XSTR
argument_list|(
name|make_numeric_value
argument_list|(
name|n
argument_list|)
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return a permanent (possibly shared) copy of a string STR (not assumed    to be null terminated) with LEN bytes.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|attr_string
parameter_list|(
name|str
parameter_list|,
name|len
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
specifier|register
name|struct
name|attr_hash
modifier|*
name|h
decl_stmt|;
name|int
name|hashcode
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|new_str
decl_stmt|;
comment|/* Compute the hash code.  */
name|hashcode
operator|=
operator|(
name|len
operator|+
literal|1
operator|)
operator|*
literal|613
operator|+
operator|(
name|unsigned
operator|)
name|str
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|len
condition|;
name|i
operator|+=
literal|2
control|)
name|hashcode
operator|=
operator|(
operator|(
name|hashcode
operator|*
literal|613
operator|)
operator|+
operator|(
name|unsigned
operator|)
name|str
index|[
name|i
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|hashcode
operator|<
literal|0
condition|)
name|hashcode
operator|=
operator|-
name|hashcode
expr_stmt|;
comment|/* Search the table for the string.  */
for|for
control|(
name|h
operator|=
name|attr_hash_table
index|[
name|hashcode
operator|%
name|RTL_HASH_SIZE
index|]
init|;
name|h
condition|;
name|h
operator|=
name|h
operator|->
name|next
control|)
if|if
condition|(
name|h
operator|->
name|hashcode
operator|==
operator|-
name|hashcode
operator|&&
name|h
operator|->
name|u
operator|.
name|str
index|[
literal|0
index|]
operator|==
name|str
index|[
literal|0
index|]
operator|&&
operator|!
name|strncmp
argument_list|(
name|h
operator|->
name|u
operator|.
name|str
argument_list|,
name|str
argument_list|,
name|len
argument_list|)
condition|)
return|return
name|h
operator|->
name|u
operator|.
name|str
return|;
comment|/*<-- return if found.  */
comment|/* Not found; create a permanent copy and add it to the hash table.  */
name|new_str
operator|=
operator|(
name|char
operator|*
operator|)
name|obstack_alloc
argument_list|(
name|hash_obstack
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|str
argument_list|,
name|new_str
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|new_str
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|attr_hash_add_string
argument_list|(
name|hashcode
argument_list|,
name|new_str
argument_list|)
expr_stmt|;
return|return
name|new_str
return|;
comment|/* Return the new string.  */
block|}
end_function

begin_comment
comment|/* Check two rtx's for equality of contents,    taking advantage of the fact that if both are hashed    then they can't be equal unless they are the same object.  */
end_comment

begin_function
name|int
name|attr_equal_p
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
name|rtx
name|x
decl_stmt|,
name|y
decl_stmt|;
block|{
return|return
operator|(
name|x
operator|==
name|y
operator|||
operator|(
operator|!
operator|(
name|RTX_INTEGRATED_P
argument_list|(
name|x
argument_list|)
operator|&&
name|RTX_INTEGRATED_P
argument_list|(
name|y
argument_list|)
operator|)
operator|&&
name|rtx_equal_p
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Copy an attribute value expression,    descending to all depths, but not copying any    permanent hashed subexpressions.  */
end_comment

begin_function
name|rtx
name|attr_copy_rtx
parameter_list|(
name|orig
parameter_list|)
specifier|register
name|rtx
name|orig
decl_stmt|;
block|{
specifier|register
name|rtx
name|copy
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|register
name|RTX_CODE
name|code
decl_stmt|;
specifier|register
name|char
modifier|*
name|format_ptr
decl_stmt|;
comment|/* No need to copy a permanent object.  */
if|if
condition|(
name|RTX_INTEGRATED_P
argument_list|(
name|orig
argument_list|)
condition|)
return|return
name|orig
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|orig
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|REG
case|:
case|case
name|QUEUED
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|CODE_LABEL
case|:
case|case
name|PC
case|:
case|case
name|CC0
case|:
return|return
name|orig
return|;
block|}
name|copy
operator|=
name|rtx_alloc
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|PUT_MODE
argument_list|(
name|copy
argument_list|,
name|GET_MODE
argument_list|(
name|orig
argument_list|)
argument_list|)
expr_stmt|;
name|copy
operator|->
name|in_struct
operator|=
name|orig
operator|->
name|in_struct
expr_stmt|;
name|copy
operator|->
name|volatil
operator|=
name|orig
operator|->
name|volatil
expr_stmt|;
name|copy
operator|->
name|unchanging
operator|=
name|orig
operator|->
name|unchanging
expr_stmt|;
name|copy
operator|->
name|integrated
operator|=
name|orig
operator|->
name|integrated
expr_stmt|;
name|format_ptr
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|GET_CODE
argument_list|(
name|copy
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GET_RTX_LENGTH
argument_list|(
name|GET_CODE
argument_list|(
name|copy
argument_list|)
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
operator|*
name|format_ptr
operator|++
condition|)
block|{
case|case
literal|'e'
case|:
name|XEXP
argument_list|(
name|copy
argument_list|,
name|i
argument_list|)
operator|=
name|XEXP
argument_list|(
name|orig
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|XEXP
argument_list|(
name|orig
argument_list|,
name|i
argument_list|)
operator|!=
name|NULL
condition|)
name|XEXP
argument_list|(
name|copy
argument_list|,
name|i
argument_list|)
operator|=
name|attr_copy_rtx
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
case|case
literal|'V'
case|:
name|XVEC
argument_list|(
name|copy
argument_list|,
name|i
argument_list|)
operator|=
name|XVEC
argument_list|(
name|orig
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|XVEC
argument_list|(
name|orig
argument_list|,
name|i
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|XVEC
argument_list|(
name|copy
argument_list|,
name|i
argument_list|)
operator|=
name|rtvec_alloc
argument_list|(
name|XVECLEN
argument_list|(
name|orig
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|copy
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|XVECEXP
argument_list|(
name|copy
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
operator|=
name|attr_copy_rtx
argument_list|(
name|XVECEXP
argument_list|(
name|orig
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'n'
case|:
case|case
literal|'i'
case|:
name|XINT
argument_list|(
name|copy
argument_list|,
name|i
argument_list|)
operator|=
name|XINT
argument_list|(
name|orig
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|XWINT
argument_list|(
name|copy
argument_list|,
name|i
argument_list|)
operator|=
name|XWINT
argument_list|(
name|orig
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
case|case
literal|'S'
case|:
name|XSTR
argument_list|(
name|copy
argument_list|,
name|i
argument_list|)
operator|=
name|XSTR
argument_list|(
name|orig
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|copy
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given a test expression for an attribute, ensure it is validly formed.    IS_CONST indicates whether the expression is constant for each compiler    run (a constant expression may not test any particular insn).     Convert (eq_attr "att" "a1,a2") to (ior (eq_attr ... ) (eq_attrq ..))    and (eq_attr "att" "!a1") to (not (eq_attr "att" "a1")).  Do the latter    test first so that (eq_attr "att" "!a1,a2,a3") works as expected.     Update the string address in EQ_ATTR expression to be the same used    in the attribute (or `alternative_name') to speed up subsequent    `find_attr' calls and eliminate most `strcmp' calls.     Return the new expression, if any.   */
end_comment

begin_function
specifier|static
name|rtx
name|check_attr_test
parameter_list|(
name|exp
parameter_list|,
name|is_const
parameter_list|)
name|rtx
name|exp
decl_stmt|;
name|int
name|is_const
decl_stmt|;
block|{
name|struct
name|attr_desc
modifier|*
name|attr
decl_stmt|;
name|struct
name|attr_value
modifier|*
name|av
decl_stmt|;
name|char
modifier|*
name|name_ptr
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|rtx
name|orexp
decl_stmt|,
name|newexp
decl_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|exp
argument_list|)
condition|)
block|{
case|case
name|EQ_ATTR
case|:
comment|/* Handle negation test.  */
if|if
condition|(
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
index|[
literal|0
index|]
operator|==
literal|'!'
condition|)
return|return
name|check_attr_test
argument_list|(
name|attr_rtx
argument_list|(
name|NOT
argument_list|,
name|attr_eq
argument_list|(
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
index|[
literal|1
index|]
argument_list|)
argument_list|)
argument_list|,
name|is_const
argument_list|)
return|;
elseif|else
if|if
condition|(
name|n_comma_elts
argument_list|(
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
literal|1
condition|)
block|{
name|attr
operator|=
name|find_attr
argument_list|(
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|"alternative"
argument_list|)
condition|)
block|{
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
operator|=
name|alternative_name
expr_stmt|;
comment|/* This can't be simplified any further.  */
name|RTX_UNCHANGING_P
argument_list|(
name|exp
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|exp
return|;
block|}
else|else
name|fatal
argument_list|(
literal|"Unknown attribute `%s' in EQ_ATTR"
argument_list|,
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|is_const
operator|&&
operator|!
name|attr
operator|->
name|is_const
condition|)
name|fatal
argument_list|(
literal|"Constant expression uses insn attribute `%s' in EQ_ATTR"
argument_list|,
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Copy this just to make it permanent, 	     so expressions using it can be permanent too.  */
name|exp
operator|=
name|attr_eq
argument_list|(
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* It shouldn't be possible to simplify the value given to a 	     constant attribute, so don't expand this until it's time to 	     write the test expression.  */
if|if
condition|(
name|attr
operator|->
name|is_const
condition|)
name|RTX_UNCHANGING_P
argument_list|(
name|exp
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|attr
operator|->
name|is_numeric
condition|)
block|{
for|for
control|(
name|p
operator|=
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|*
name|p
operator|<
literal|'0'
operator|||
operator|*
name|p
operator|>
literal|'9'
condition|)
name|fatal
argument_list|(
literal|"Attribute `%s' takes only numeric values"
argument_list|,
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|av
operator|=
name|attr
operator|->
name|first_value
init|;
name|av
condition|;
name|av
operator|=
name|av
operator|->
name|next
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|av
operator|->
name|value
argument_list|)
operator|==
name|CONST_STRING
operator|&&
operator|!
name|strcmp
argument_list|(
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|XSTR
argument_list|(
name|av
operator|->
name|value
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
break|break;
if|if
condition|(
name|av
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"Unknown value `%s' for `%s' attribute"
argument_list|,
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Make an IOR tree of the possible values.  */
name|orexp
operator|=
name|false_rtx
expr_stmt|;
name|name_ptr
operator|=
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|p
operator|=
name|next_comma_elt
argument_list|(
operator|&
name|name_ptr
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|newexp
operator|=
name|attr_eq
argument_list|(
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|orexp
operator|=
name|insert_right_side
argument_list|(
name|IOR
argument_list|,
name|orexp
argument_list|,
name|newexp
argument_list|,
operator|-
literal|2
argument_list|)
expr_stmt|;
block|}
return|return
name|check_attr_test
argument_list|(
name|orexp
argument_list|,
name|is_const
argument_list|)
return|;
block|}
break|break;
case|case
name|CONST_INT
case|:
comment|/* Either TRUE or FALSE.  */
if|if
condition|(
name|XWINT
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|true_rtx
return|;
else|else
return|return
name|false_rtx
return|;
case|case
name|IOR
case|:
case|case
name|AND
case|:
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
operator|=
name|check_attr_test
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|is_const
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
operator|=
name|check_attr_test
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|is_const
argument_list|)
expr_stmt|;
break|break;
case|case
name|NOT
case|:
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
operator|=
name|check_attr_test
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|is_const
argument_list|)
expr_stmt|;
break|break;
case|case
name|MATCH_OPERAND
case|:
if|if
condition|(
name|is_const
condition|)
name|fatal
argument_list|(
literal|"RTL operator \"%s\" not valid in constant attribute test"
argument_list|,
name|GET_RTX_NAME
argument_list|(
name|MATCH_OPERAND
argument_list|)
argument_list|)
expr_stmt|;
comment|/* These cases can't be simplified.  */
name|RTX_UNCHANGING_P
argument_list|(
name|exp
argument_list|)
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|LE
case|:
case|case
name|LT
case|:
case|case
name|GT
case|:
case|case
name|GE
case|:
case|case
name|LEU
case|:
case|case
name|LTU
case|:
case|case
name|GTU
case|:
case|case
name|GEU
case|:
case|case
name|NE
case|:
case|case
name|EQ
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
condition|)
name|exp
operator|=
name|attr_rtx
argument_list|(
name|GET_CODE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|attr_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|XSTR
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|attr_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|XSTR
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* These cases can't be simplified.  */
name|RTX_UNCHANGING_P
argument_list|(
name|exp
argument_list|)
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|SYMBOL_REF
case|:
if|if
condition|(
name|is_const
condition|)
block|{
comment|/* These cases are valid for constant attributes, but can't be 	     simplified.  */
name|exp
operator|=
name|attr_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|exp
argument_list|)
operator|=
literal|1
expr_stmt|;
break|break;
block|}
default|default:
name|fatal
argument_list|(
literal|"RTL operator \"%s\" not valid in attribute test"
argument_list|,
name|GET_RTX_NAME
argument_list|(
name|GET_CODE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|exp
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given an expression, ensure that it is validly formed and that all named    attribute values are valid for the given attribute.  Issue a fatal error    if not.  If no attribute is specified, assume a numeric attribute.     Return a perhaps modified replacement expression for the value.  */
end_comment

begin_function
specifier|static
name|rtx
name|check_attr_value
parameter_list|(
name|exp
parameter_list|,
name|attr
parameter_list|)
name|rtx
name|exp
decl_stmt|;
name|struct
name|attr_desc
modifier|*
name|attr
decl_stmt|;
block|{
name|struct
name|attr_value
modifier|*
name|av
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|exp
argument_list|)
condition|)
block|{
case|case
name|CONST_INT
case|:
if|if
condition|(
name|attr
operator|&&
operator|!
name|attr
operator|->
name|is_numeric
condition|)
name|fatal
argument_list|(
literal|"CONST_INT not valid for non-numeric `%s' attribute"
argument_list|,
name|attr
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|INTVAL
argument_list|(
name|exp
argument_list|)
operator|<
literal|0
condition|)
name|fatal
argument_list|(
literal|"Negative numeric value specified for `%s' attribute"
argument_list|,
name|attr
operator|->
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONST_STRING
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|"*"
argument_list|)
condition|)
break|break;
if|if
condition|(
name|attr
operator|==
literal|0
operator|||
name|attr
operator|->
name|is_numeric
condition|)
block|{
name|p
operator|=
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr
operator|&&
name|attr
operator|->
name|negative_ok
operator|&&
operator|*
name|p
operator|==
literal|'-'
condition|)
name|p
operator|++
expr_stmt|;
for|for
control|(
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|*
name|p
operator|>
literal|'9'
operator|||
operator|*
name|p
operator|<
literal|'0'
condition|)
name|fatal
argument_list|(
literal|"Non-numeric value for numeric `%s' attribute"
argument_list|,
name|attr
condition|?
name|attr
operator|->
name|name
else|:
literal|"internal"
argument_list|)
expr_stmt|;
break|break;
block|}
for|for
control|(
name|av
operator|=
name|attr
operator|->
name|first_value
init|;
name|av
condition|;
name|av
operator|=
name|av
operator|->
name|next
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|av
operator|->
name|value
argument_list|)
operator|==
name|CONST_STRING
operator|&&
operator|!
name|strcmp
argument_list|(
name|XSTR
argument_list|(
name|av
operator|->
name|value
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
break|break;
if|if
condition|(
name|av
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"Unknown value `%s' for `%s' attribute"
argument_list|,
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|attr
condition|?
name|attr
operator|->
name|name
else|:
literal|"internal"
argument_list|)
expr_stmt|;
break|break;
case|case
name|IF_THEN_ELSE
case|:
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
operator|=
name|check_attr_test
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|attr
condition|?
name|attr
operator|->
name|is_const
else|:
literal|0
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
operator|=
name|check_attr_value
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|attr
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
operator|=
name|check_attr_value
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
argument_list|,
name|attr
argument_list|)
expr_stmt|;
break|break;
case|case
name|COND
case|:
if|if
condition|(
name|XVECLEN
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
operator|%
literal|2
operator|!=
literal|0
condition|)
name|fatal
argument_list|(
literal|"First operand of COND must have even length"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|+=
literal|2
control|)
block|{
name|XVECEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
operator|=
name|check_attr_test
argument_list|(
name|XVECEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
name|attr
condition|?
name|attr
operator|->
name|is_const
else|:
literal|0
argument_list|)
expr_stmt|;
name|XVECEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|,
name|i
operator|+
literal|1
argument_list|)
operator|=
name|check_attr_value
argument_list|(
name|XVECEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|,
name|i
operator|+
literal|1
argument_list|)
argument_list|,
name|attr
argument_list|)
expr_stmt|;
block|}
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
operator|=
name|check_attr_value
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|attr
argument_list|)
expr_stmt|;
break|break;
case|case
name|SYMBOL_REF
case|:
if|if
condition|(
name|attr
operator|&&
name|attr
operator|->
name|is_const
condition|)
comment|/* A constant SYMBOL_REF is valid as a constant attribute test and 	   is expanded later by make_canonical into a COND.  */
return|return
name|attr_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
comment|/* Otherwise, fall through... */
default|default:
name|fatal
argument_list|(
literal|"Illegal operation `%s' for attribute value"
argument_list|,
name|GET_RTX_NAME
argument_list|(
name|GET_CODE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|exp
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given an SET_ATTR_ALTERNATIVE expression, convert to the canonical SET.    It becomes a COND with each test being (eq_attr "alternative "n") */
end_comment

begin_function
specifier|static
name|rtx
name|convert_set_attr_alternative
parameter_list|(
name|exp
parameter_list|,
name|num_alt
parameter_list|,
name|insn_code
parameter_list|,
name|insn_index
parameter_list|)
name|rtx
name|exp
decl_stmt|;
name|int
name|num_alt
decl_stmt|;
name|int
name|insn_code
decl_stmt|,
name|insn_index
decl_stmt|;
block|{
name|rtx
name|condexp
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|XVECLEN
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
operator|!=
name|num_alt
condition|)
name|fatal
argument_list|(
literal|"Bad number of entries in SET_ATTR_ALTERNATIVE for insn %d"
argument_list|,
name|insn_index
argument_list|)
expr_stmt|;
comment|/* Make a COND with all tests but the last.  Select the last value via the      default.  */
name|condexp
operator|=
name|rtx_alloc
argument_list|(
name|COND
argument_list|)
expr_stmt|;
name|XVEC
argument_list|(
name|condexp
argument_list|,
literal|0
argument_list|)
operator|=
name|rtvec_alloc
argument_list|(
operator|(
name|num_alt
operator|-
literal|1
operator|)
operator|*
literal|2
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_alt
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|attr_numeral
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|XVECEXP
argument_list|(
name|condexp
argument_list|,
literal|0
argument_list|,
literal|2
operator|*
name|i
argument_list|)
operator|=
name|attr_eq
argument_list|(
name|alternative_name
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* Sharing this EQ_ATTR rtl causes trouble.  */
block|XVECEXP (condexp, 0, 2 * i) = rtx_alloc (EQ_ATTR);       XSTR (XVECEXP (condexp, 0, 2 * i), 0) = alternative_name;       XSTR (XVECEXP (condexp, 0, 2 * i), 1) = p;
endif|#
directive|endif
name|XVECEXP
argument_list|(
name|condexp
argument_list|,
literal|0
argument_list|,
literal|2
operator|*
name|i
operator|+
literal|1
argument_list|)
operator|=
name|XVECEXP
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|XEXP
argument_list|(
name|condexp
argument_list|,
literal|1
argument_list|)
operator|=
name|XVECEXP
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
name|attr_rtx
argument_list|(
name|SET
argument_list|,
name|attr_rtx
argument_list|(
name|ATTR
argument_list|,
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|condexp
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given a SET_ATTR, convert to the appropriate SET.  If a comma-separated    list of values is given, convert to SET_ATTR_ALTERNATIVE first.  */
end_comment

begin_function
specifier|static
name|rtx
name|convert_set_attr
parameter_list|(
name|exp
parameter_list|,
name|num_alt
parameter_list|,
name|insn_code
parameter_list|,
name|insn_index
parameter_list|)
name|rtx
name|exp
decl_stmt|;
name|int
name|num_alt
decl_stmt|;
name|int
name|insn_code
decl_stmt|,
name|insn_index
decl_stmt|;
block|{
name|rtx
name|newexp
decl_stmt|;
name|char
modifier|*
name|name_ptr
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|n
decl_stmt|;
comment|/* See how many alternative specified.  */
name|n
operator|=
name|n_comma_elts
argument_list|(
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|1
condition|)
return|return
name|attr_rtx
argument_list|(
name|SET
argument_list|,
name|attr_rtx
argument_list|(
name|ATTR
argument_list|,
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|attr_rtx
argument_list|(
name|CONST_STRING
argument_list|,
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
return|;
name|newexp
operator|=
name|rtx_alloc
argument_list|(
name|SET_ATTR_ALTERNATIVE
argument_list|)
expr_stmt|;
name|XSTR
argument_list|(
name|newexp
argument_list|,
literal|0
argument_list|)
operator|=
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|XVEC
argument_list|(
name|newexp
argument_list|,
literal|1
argument_list|)
operator|=
name|rtvec_alloc
argument_list|(
name|n
argument_list|)
expr_stmt|;
comment|/* Process each comma-separated name.  */
name|name_ptr
operator|=
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|p
operator|=
name|next_comma_elt
argument_list|(
operator|&
name|name_ptr
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|XVECEXP
argument_list|(
name|newexp
argument_list|,
literal|1
argument_list|,
name|n
operator|++
argument_list|)
operator|=
name|attr_rtx
argument_list|(
name|CONST_STRING
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
name|convert_set_attr_alternative
argument_list|(
name|newexp
argument_list|,
name|num_alt
argument_list|,
name|insn_code
argument_list|,
name|insn_index
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Scan all definitions, checking for validity.  Also, convert any SET_ATTR    and SET_ATTR_ALTERNATIVE expressions to the corresponding SET    expressions. */
end_comment

begin_function
specifier|static
name|void
name|check_defs
parameter_list|()
block|{
name|struct
name|insn_def
modifier|*
name|id
decl_stmt|;
name|struct
name|attr_desc
modifier|*
name|attr
decl_stmt|;
name|int
name|i
decl_stmt|;
name|rtx
name|value
decl_stmt|;
for|for
control|(
name|id
operator|=
name|defs
init|;
name|id
condition|;
name|id
operator|=
name|id
operator|->
name|next
control|)
block|{
if|if
condition|(
name|XVEC
argument_list|(
name|id
operator|->
name|def
argument_list|,
name|id
operator|->
name|vec_idx
argument_list|)
operator|==
name|NULL
condition|)
continue|continue;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|id
operator|->
name|def
argument_list|,
name|id
operator|->
name|vec_idx
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|value
operator|=
name|XVECEXP
argument_list|(
name|id
operator|->
name|def
argument_list|,
name|id
operator|->
name|vec_idx
argument_list|,
name|i
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|value
argument_list|)
condition|)
block|{
case|case
name|SET
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|ATTR
condition|)
name|fatal
argument_list|(
literal|"Bad attribute set in pattern %d"
argument_list|,
name|id
operator|->
name|insn_index
argument_list|)
expr_stmt|;
break|break;
case|case
name|SET_ATTR_ALTERNATIVE
case|:
name|value
operator|=
name|convert_set_attr_alternative
argument_list|(
name|value
argument_list|,
name|id
operator|->
name|num_alternatives
argument_list|,
name|id
operator|->
name|insn_code
argument_list|,
name|id
operator|->
name|insn_index
argument_list|)
expr_stmt|;
break|break;
case|case
name|SET_ATTR
case|:
name|value
operator|=
name|convert_set_attr
argument_list|(
name|value
argument_list|,
name|id
operator|->
name|num_alternatives
argument_list|,
name|id
operator|->
name|insn_code
argument_list|,
name|id
operator|->
name|insn_index
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fatal
argument_list|(
literal|"Invalid attribute code `%s' for pattern %d"
argument_list|,
name|GET_RTX_NAME
argument_list|(
name|GET_CODE
argument_list|(
name|value
argument_list|)
argument_list|)
argument_list|,
name|id
operator|->
name|insn_index
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|attr
operator|=
name|find_attr
argument_list|(
name|XSTR
argument_list|(
name|XEXP
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"Unknown attribute `%s' for pattern number %d"
argument_list|,
name|XSTR
argument_list|(
name|XEXP
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|id
operator|->
name|insn_index
argument_list|)
expr_stmt|;
name|XVECEXP
argument_list|(
name|id
operator|->
name|def
argument_list|,
name|id
operator|->
name|vec_idx
argument_list|,
name|i
argument_list|)
operator|=
name|value
expr_stmt|;
name|XEXP
argument_list|(
name|value
argument_list|,
literal|1
argument_list|)
operator|=
name|check_attr_value
argument_list|(
name|XEXP
argument_list|(
name|value
argument_list|,
literal|1
argument_list|)
argument_list|,
name|attr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given a constant SYMBOL_REF expression, convert to a COND that    explicitly tests each enumerated value.  */
end_comment

begin_function
specifier|static
name|rtx
name|convert_const_symbol_ref
parameter_list|(
name|exp
parameter_list|,
name|attr
parameter_list|)
name|rtx
name|exp
decl_stmt|;
name|struct
name|attr_desc
modifier|*
name|attr
decl_stmt|;
block|{
name|rtx
name|condexp
decl_stmt|;
name|struct
name|attr_value
modifier|*
name|av
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|num_alt
init|=
literal|0
decl_stmt|;
for|for
control|(
name|av
operator|=
name|attr
operator|->
name|first_value
init|;
name|av
condition|;
name|av
operator|=
name|av
operator|->
name|next
control|)
name|num_alt
operator|++
expr_stmt|;
comment|/* Make a COND with all tests but the last, and in the original order.      Select the last value via the default.  Note that the attr values      are constructed in reverse order.  */
name|condexp
operator|=
name|rtx_alloc
argument_list|(
name|COND
argument_list|)
expr_stmt|;
name|XVEC
argument_list|(
name|condexp
argument_list|,
literal|0
argument_list|)
operator|=
name|rtvec_alloc
argument_list|(
operator|(
name|num_alt
operator|-
literal|1
operator|)
operator|*
literal|2
argument_list|)
expr_stmt|;
name|av
operator|=
name|attr
operator|->
name|first_value
expr_stmt|;
name|XEXP
argument_list|(
name|condexp
argument_list|,
literal|1
argument_list|)
operator|=
name|av
operator|->
name|value
expr_stmt|;
for|for
control|(
name|i
operator|=
name|num_alt
operator|-
literal|2
init|;
name|av
operator|=
name|av
operator|->
name|next
operator|,
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|string
decl_stmt|;
name|rtx
name|value
decl_stmt|;
name|string
operator|=
name|p
operator|=
operator|(
name|char
operator|*
operator|)
name|oballoc
argument_list|(
literal|2
operator|+
name|strlen
argument_list|(
name|attr
operator|->
name|name
argument_list|)
operator|+
name|strlen
argument_list|(
name|XSTR
argument_list|(
name|av
operator|->
name|value
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|p
argument_list|,
name|attr
operator|->
name|name
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|p
argument_list|,
literal|"_"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|p
argument_list|,
name|XSTR
argument_list|(
name|av
operator|->
name|value
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|*
name|p
operator|>=
literal|'a'
operator|&&
operator|*
name|p
operator|<=
literal|'z'
condition|)
operator|*
name|p
operator|-=
literal|'a'
operator|-
literal|'A'
expr_stmt|;
name|value
operator|=
name|attr_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|string
argument_list|)
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|value
argument_list|)
operator|=
literal|1
expr_stmt|;
name|XVECEXP
argument_list|(
name|condexp
argument_list|,
literal|0
argument_list|,
literal|2
operator|*
name|i
argument_list|)
operator|=
name|attr_rtx
argument_list|(
name|EQ
argument_list|,
name|exp
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|XVECEXP
argument_list|(
name|condexp
argument_list|,
literal|0
argument_list|,
literal|2
operator|*
name|i
operator|+
literal|1
argument_list|)
operator|=
name|av
operator|->
name|value
expr_stmt|;
block|}
return|return
name|condexp
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given a valid expression for an attribute value, remove any IF_THEN_ELSE    expressions by converting them into a COND.  This removes cases from this    program.  Also, replace an attribute value of "*" with the default attribute    value.  */
end_comment

begin_function
specifier|static
name|rtx
name|make_canonical
parameter_list|(
name|attr
parameter_list|,
name|exp
parameter_list|)
name|struct
name|attr_desc
modifier|*
name|attr
decl_stmt|;
name|rtx
name|exp
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|rtx
name|newexp
decl_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|exp
argument_list|)
condition|)
block|{
case|case
name|CONST_INT
case|:
name|exp
operator|=
name|make_numeric_value
argument_list|(
name|INTVAL
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONST_STRING
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|"*"
argument_list|)
condition|)
block|{
if|if
condition|(
name|attr
operator|==
literal|0
operator|||
name|attr
operator|->
name|default_val
operator|==
literal|0
condition|)
name|fatal
argument_list|(
literal|"(attr_value \"*\") used in invalid context."
argument_list|)
expr_stmt|;
name|exp
operator|=
name|attr
operator|->
name|default_val
operator|->
name|value
expr_stmt|;
block|}
break|break;
case|case
name|SYMBOL_REF
case|:
if|if
condition|(
operator|!
name|attr
operator|->
name|is_const
operator|||
name|RTX_UNCHANGING_P
argument_list|(
name|exp
argument_list|)
condition|)
break|break;
comment|/* The SYMBOL_REF is constant for a given run, so mark it as unchanging. 	 This makes the COND something that won't be considered an arbitrary 	 expression by walk_attr_value.  */
name|RTX_UNCHANGING_P
argument_list|(
name|exp
argument_list|)
operator|=
literal|1
expr_stmt|;
name|exp
operator|=
name|convert_const_symbol_ref
argument_list|(
name|exp
argument_list|,
name|attr
argument_list|)
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|exp
argument_list|)
operator|=
literal|1
expr_stmt|;
name|exp
operator|=
name|check_attr_value
argument_list|(
name|exp
argument_list|,
name|attr
argument_list|)
expr_stmt|;
comment|/* Goto COND case since this is now a COND.  Note that while the          new expression is rescanned, all symbol_ref notes are mared as 	 unchanging.  */
goto|goto
name|cond
goto|;
case|case
name|IF_THEN_ELSE
case|:
name|newexp
operator|=
name|rtx_alloc
argument_list|(
name|COND
argument_list|)
expr_stmt|;
name|XVEC
argument_list|(
name|newexp
argument_list|,
literal|0
argument_list|)
operator|=
name|rtvec_alloc
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|XVECEXP
argument_list|(
name|newexp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|=
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|XVECEXP
argument_list|(
name|newexp
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
operator|=
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|newexp
argument_list|,
literal|1
argument_list|)
operator|=
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|exp
operator|=
name|newexp
expr_stmt|;
comment|/* Fall through to COND case since this is now a COND.  */
case|case
name|COND
case|:
name|cond
label|:
block|{
name|int
name|allsame
init|=
literal|1
decl_stmt|;
name|rtx
name|defval
decl_stmt|;
comment|/* First, check for degenerate COND. */
if|if
condition|(
name|XVECLEN
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
return|return
name|make_canonical
argument_list|(
name|attr
argument_list|,
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
name|defval
operator|=
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
operator|=
name|make_canonical
argument_list|(
name|attr
argument_list|,
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|+=
literal|2
control|)
block|{
name|XVECEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
operator|=
name|copy_boolean
argument_list|(
name|XVECEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|XVECEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|,
name|i
operator|+
literal|1
argument_list|)
operator|=
name|make_canonical
argument_list|(
name|attr
argument_list|,
name|XVECEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|,
name|i
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rtx_equal_p
argument_list|(
name|XVECEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|,
name|i
operator|+
literal|1
argument_list|)
argument_list|,
name|defval
argument_list|)
condition|)
name|allsame
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|allsame
condition|)
return|return
name|defval
return|;
break|break;
block|}
block|}
return|return
name|exp
return|;
block|}
end_function

begin_function
specifier|static
name|rtx
name|copy_boolean
parameter_list|(
name|exp
parameter_list|)
name|rtx
name|exp
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|AND
operator|||
name|GET_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|IOR
condition|)
return|return
name|attr_rtx
argument_list|(
name|GET_CODE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|copy_boolean
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|copy_boolean
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
return|;
return|return
name|exp
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given a value and an attribute description, return a `struct attr_value *'    that represents that value.  This is either an existing structure, if the    value has been previously encountered, or a newly-created structure.     `insn_code' is the code of an insn whose attribute has the specified    value (-2 if not processing an insn).  We ensure that all insns for    a given value have the same number of alternatives if the value checks    alternatives.  */
end_comment

begin_function
specifier|static
name|struct
name|attr_value
modifier|*
name|get_attr_value
parameter_list|(
name|value
parameter_list|,
name|attr
parameter_list|,
name|insn_code
parameter_list|)
name|rtx
name|value
decl_stmt|;
name|struct
name|attr_desc
modifier|*
name|attr
decl_stmt|;
name|int
name|insn_code
decl_stmt|;
block|{
name|struct
name|attr_value
modifier|*
name|av
decl_stmt|;
name|int
name|num_alt
init|=
literal|0
decl_stmt|;
name|value
operator|=
name|make_canonical
argument_list|(
name|attr
argument_list|,
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|compares_alternatives_p
argument_list|(
name|value
argument_list|)
condition|)
block|{
if|if
condition|(
name|insn_code
operator|<
literal|0
operator|||
name|insn_alternatives
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"(eq_attr \"alternatives\" ...) used in non-insn context"
argument_list|)
expr_stmt|;
else|else
name|num_alt
operator|=
name|insn_alternatives
index|[
name|insn_code
index|]
expr_stmt|;
block|}
for|for
control|(
name|av
operator|=
name|attr
operator|->
name|first_value
init|;
name|av
condition|;
name|av
operator|=
name|av
operator|->
name|next
control|)
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|value
argument_list|,
name|av
operator|->
name|value
argument_list|)
operator|&&
operator|(
name|num_alt
operator|==
literal|0
operator|||
name|av
operator|->
name|first_insn
operator|==
name|NULL
operator|||
name|insn_alternatives
index|[
name|av
operator|->
name|first_insn
operator|->
name|insn_code
index|]
operator|)
condition|)
return|return
name|av
return|;
name|av
operator|=
operator|(
expr|struct
name|attr_value
operator|*
operator|)
name|oballoc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|attr_value
argument_list|)
argument_list|)
expr_stmt|;
name|av
operator|->
name|value
operator|=
name|value
expr_stmt|;
name|av
operator|->
name|next
operator|=
name|attr
operator|->
name|first_value
expr_stmt|;
name|attr
operator|->
name|first_value
operator|=
name|av
expr_stmt|;
name|av
operator|->
name|first_insn
operator|=
name|NULL
expr_stmt|;
name|av
operator|->
name|num_insns
operator|=
literal|0
expr_stmt|;
name|av
operator|->
name|has_asm_insn
operator|=
literal|0
expr_stmt|;
return|return
name|av
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* After all DEFINE_DELAYs have been read in, create internal attributes    to generate the required routines.     First, we compute the number of delay slots for each insn (as a COND of    each of the test expressions in DEFINE_DELAYs).  Then, if more than one    delay type is specified, we compute a similar function giving the    DEFINE_DELAY ordinal for each insn.     Finally, for each [DEFINE_DELAY, slot #] pair, we compute an attribute that    tells whether a given insn can be in that delay slot.     Normal attribute filling and optimization expands these to contain the    information needed to handle delay slots.  */
end_comment

begin_function
specifier|static
name|void
name|expand_delays
parameter_list|()
block|{
name|struct
name|delay_desc
modifier|*
name|delay
decl_stmt|;
name|rtx
name|condexp
decl_stmt|;
name|rtx
name|newexp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
comment|/* First, generate data for `num_delay_slots' function.  */
name|condexp
operator|=
name|rtx_alloc
argument_list|(
name|COND
argument_list|)
expr_stmt|;
name|XVEC
argument_list|(
name|condexp
argument_list|,
literal|0
argument_list|)
operator|=
name|rtvec_alloc
argument_list|(
name|num_delays
operator|*
literal|2
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|condexp
argument_list|,
literal|1
argument_list|)
operator|=
name|make_numeric_value
argument_list|(
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|delay
operator|=
name|delays
init|;
name|delay
condition|;
name|i
operator|+=
literal|2
operator|,
name|delay
operator|=
name|delay
operator|->
name|next
control|)
block|{
name|XVECEXP
argument_list|(
name|condexp
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
operator|=
name|XEXP
argument_list|(
name|delay
operator|->
name|def
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|XVECEXP
argument_list|(
name|condexp
argument_list|,
literal|0
argument_list|,
name|i
operator|+
literal|1
argument_list|)
operator|=
name|make_numeric_value
argument_list|(
name|XVECLEN
argument_list|(
name|delay
operator|->
name|def
argument_list|,
literal|1
argument_list|)
operator|/
literal|3
argument_list|)
expr_stmt|;
block|}
name|make_internal_attr
argument_list|(
literal|"*num_delay_slots"
argument_list|,
name|condexp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If more than one delay type, do the same for computing the delay type.  */
if|if
condition|(
name|num_delays
operator|>
literal|1
condition|)
block|{
name|condexp
operator|=
name|rtx_alloc
argument_list|(
name|COND
argument_list|)
expr_stmt|;
name|XVEC
argument_list|(
name|condexp
argument_list|,
literal|0
argument_list|)
operator|=
name|rtvec_alloc
argument_list|(
name|num_delays
operator|*
literal|2
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|condexp
argument_list|,
literal|1
argument_list|)
operator|=
name|make_numeric_value
argument_list|(
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|delay
operator|=
name|delays
init|;
name|delay
condition|;
name|i
operator|+=
literal|2
operator|,
name|delay
operator|=
name|delay
operator|->
name|next
control|)
block|{
name|XVECEXP
argument_list|(
name|condexp
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
operator|=
name|XEXP
argument_list|(
name|delay
operator|->
name|def
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|XVECEXP
argument_list|(
name|condexp
argument_list|,
literal|0
argument_list|,
name|i
operator|+
literal|1
argument_list|)
operator|=
name|make_numeric_value
argument_list|(
name|delay
operator|->
name|num
argument_list|)
expr_stmt|;
block|}
name|make_internal_attr
argument_list|(
literal|"*delay_type"
argument_list|,
name|condexp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* For each delay possibility and delay slot, compute an eligibility      attribute for non-annulled insns and for each type of annulled (annul      if true and annul if false).  */
for|for
control|(
name|delay
operator|=
name|delays
init|;
name|delay
condition|;
name|delay
operator|=
name|delay
operator|->
name|next
control|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|delay
operator|->
name|def
argument_list|,
literal|1
argument_list|)
condition|;
name|i
operator|+=
literal|3
control|)
block|{
name|condexp
operator|=
name|XVECEXP
argument_list|(
name|delay
operator|->
name|def
argument_list|,
literal|1
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|condexp
operator|==
literal|0
condition|)
name|condexp
operator|=
name|false_rtx
expr_stmt|;
name|newexp
operator|=
name|attr_rtx
argument_list|(
name|IF_THEN_ELSE
argument_list|,
name|condexp
argument_list|,
name|make_numeric_value
argument_list|(
literal|1
argument_list|)
argument_list|,
name|make_numeric_value
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|=
name|attr_printf
argument_list|(
sizeof|sizeof
argument_list|(
literal|"*delay__"
argument_list|)
operator|+
name|MAX_DIGITS
operator|*
literal|2
argument_list|,
literal|"*delay_%d_%d"
argument_list|,
name|delay
operator|->
name|num
argument_list|,
name|i
operator|/
literal|3
argument_list|)
expr_stmt|;
name|make_internal_attr
argument_list|(
name|p
argument_list|,
name|newexp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|have_annul_true
condition|)
block|{
name|condexp
operator|=
name|XVECEXP
argument_list|(
name|delay
operator|->
name|def
argument_list|,
literal|1
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|condexp
operator|==
literal|0
condition|)
name|condexp
operator|=
name|false_rtx
expr_stmt|;
name|newexp
operator|=
name|attr_rtx
argument_list|(
name|IF_THEN_ELSE
argument_list|,
name|condexp
argument_list|,
name|make_numeric_value
argument_list|(
literal|1
argument_list|)
argument_list|,
name|make_numeric_value
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|=
name|attr_printf
argument_list|(
sizeof|sizeof
argument_list|(
literal|"*annul_true__"
argument_list|)
operator|+
name|MAX_DIGITS
operator|*
literal|2
argument_list|,
literal|"*annul_true_%d_%d"
argument_list|,
name|delay
operator|->
name|num
argument_list|,
name|i
operator|/
literal|3
argument_list|)
expr_stmt|;
name|make_internal_attr
argument_list|(
name|p
argument_list|,
name|newexp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|have_annul_false
condition|)
block|{
name|condexp
operator|=
name|XVECEXP
argument_list|(
name|delay
operator|->
name|def
argument_list|,
literal|1
argument_list|,
name|i
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|condexp
operator|==
literal|0
condition|)
name|condexp
operator|=
name|false_rtx
expr_stmt|;
name|newexp
operator|=
name|attr_rtx
argument_list|(
name|IF_THEN_ELSE
argument_list|,
name|condexp
argument_list|,
name|make_numeric_value
argument_list|(
literal|1
argument_list|)
argument_list|,
name|make_numeric_value
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|=
name|attr_printf
argument_list|(
sizeof|sizeof
argument_list|(
literal|"*annul_false__"
argument_list|)
operator|+
name|MAX_DIGITS
operator|*
literal|2
argument_list|,
literal|"*annul_false_%d_%d"
argument_list|,
name|delay
operator|->
name|num
argument_list|,
name|i
operator|/
literal|3
argument_list|)
expr_stmt|;
name|make_internal_attr
argument_list|(
name|p
argument_list|,
name|newexp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This function is given a left and right side expression and an operator.    Each side is a conditional expression, each alternative of which has a    numerical value.  The function returns another conditional expression    which, for every possible set of condition values, returns a value that is    the operator applied to the values of the two sides.     Since this is called early, it must also support IF_THEN_ELSE.  */
end_comment

begin_function
specifier|static
name|rtx
name|operate_exp
parameter_list|(
name|op
parameter_list|,
name|left
parameter_list|,
name|right
parameter_list|)
name|enum
name|operator
name|op
decl_stmt|;
name|rtx
name|left
decl_stmt|,
name|right
decl_stmt|;
block|{
name|int
name|left_value
decl_stmt|,
name|right_value
decl_stmt|;
name|rtx
name|newexp
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* If left is a string, apply operator to it and the right side.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|left
argument_list|)
operator|==
name|CONST_STRING
condition|)
block|{
comment|/* If right is also a string, just perform the operation.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|right
argument_list|)
operator|==
name|CONST_STRING
condition|)
block|{
name|left_value
operator|=
name|atoi
argument_list|(
name|XSTR
argument_list|(
name|left
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|right_value
operator|=
name|atoi
argument_list|(
name|XSTR
argument_list|(
name|right
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|PLUS_OP
case|:
name|i
operator|=
name|left_value
operator|+
name|right_value
expr_stmt|;
break|break;
case|case
name|MINUS_OP
case|:
name|i
operator|=
name|left_value
operator|-
name|right_value
expr_stmt|;
break|break;
case|case
name|POS_MINUS_OP
case|:
comment|/* The positive part of LEFT - RIGHT.  */
if|if
condition|(
name|left_value
operator|>
name|right_value
condition|)
name|i
operator|=
name|left_value
operator|-
name|right_value
expr_stmt|;
else|else
name|i
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|OR_OP
case|:
name|i
operator|=
name|left_value
operator||
name|right_value
expr_stmt|;
break|break;
case|case
name|EQ_OP
case|:
name|i
operator|=
name|left_value
operator|==
name|right_value
expr_stmt|;
break|break;
case|case
name|RANGE_OP
case|:
name|i
operator|=
operator|(
name|left_value
operator|<<
operator|(
name|HOST_BITS_PER_INT
operator|/
literal|2
operator|)
operator|)
operator||
name|right_value
expr_stmt|;
break|break;
case|case
name|MAX_OP
case|:
if|if
condition|(
name|left_value
operator|>
name|right_value
condition|)
name|i
operator|=
name|left_value
expr_stmt|;
else|else
name|i
operator|=
name|right_value
expr_stmt|;
break|break;
case|case
name|MIN_OP
case|:
if|if
condition|(
name|left_value
operator|<
name|right_value
condition|)
name|i
operator|=
name|left_value
expr_stmt|;
else|else
name|i
operator|=
name|right_value
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
name|make_numeric_value
argument_list|(
name|i
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|right
argument_list|)
operator|==
name|IF_THEN_ELSE
condition|)
block|{
comment|/* Apply recursively to all values within.  */
name|rtx
name|newleft
init|=
name|operate_exp
argument_list|(
name|op
argument_list|,
name|left
argument_list|,
name|XEXP
argument_list|(
name|right
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|newright
init|=
name|operate_exp
argument_list|(
name|op
argument_list|,
name|left
argument_list|,
name|XEXP
argument_list|(
name|right
argument_list|,
literal|2
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|newleft
argument_list|,
name|newright
argument_list|)
condition|)
return|return
name|newleft
return|;
return|return
name|attr_rtx
argument_list|(
name|IF_THEN_ELSE
argument_list|,
name|XEXP
argument_list|(
name|right
argument_list|,
literal|0
argument_list|)
argument_list|,
name|newleft
argument_list|,
name|newright
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|right
argument_list|)
operator|==
name|COND
condition|)
block|{
name|int
name|allsame
init|=
literal|1
decl_stmt|;
name|rtx
name|defval
decl_stmt|;
name|newexp
operator|=
name|rtx_alloc
argument_list|(
name|COND
argument_list|)
expr_stmt|;
name|XVEC
argument_list|(
name|newexp
argument_list|,
literal|0
argument_list|)
operator|=
name|rtvec_alloc
argument_list|(
name|XVECLEN
argument_list|(
name|right
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|defval
operator|=
name|XEXP
argument_list|(
name|newexp
argument_list|,
literal|1
argument_list|)
operator|=
name|operate_exp
argument_list|(
name|op
argument_list|,
name|left
argument_list|,
name|XEXP
argument_list|(
name|right
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|right
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|+=
literal|2
control|)
block|{
name|XVECEXP
argument_list|(
name|newexp
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
operator|=
name|XVECEXP
argument_list|(
name|right
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|XVECEXP
argument_list|(
name|newexp
argument_list|,
literal|0
argument_list|,
name|i
operator|+
literal|1
argument_list|)
operator|=
name|operate_exp
argument_list|(
name|op
argument_list|,
name|left
argument_list|,
name|XVECEXP
argument_list|(
name|right
argument_list|,
literal|0
argument_list|,
name|i
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rtx_equal_p
argument_list|(
name|XVECEXP
argument_list|(
name|newexp
argument_list|,
literal|0
argument_list|,
name|i
operator|+
literal|1
argument_list|)
argument_list|,
name|defval
argument_list|)
condition|)
name|allsame
operator|=
literal|0
expr_stmt|;
block|}
comment|/* If the resulting cond is trivial (all alternatives 	     give the same value), optimize it away.  */
if|if
condition|(
name|allsame
condition|)
block|{
name|obstack_free
argument_list|(
name|rtl_obstack
argument_list|,
name|newexp
argument_list|)
expr_stmt|;
return|return
name|operate_exp
argument_list|(
name|op
argument_list|,
name|left
argument_list|,
name|XEXP
argument_list|(
name|right
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
block|}
comment|/* If the result is the same as the RIGHT operand, 	     just use that.  */
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|newexp
argument_list|,
name|right
argument_list|)
condition|)
block|{
name|obstack_free
argument_list|(
name|rtl_obstack
argument_list|,
name|newexp
argument_list|)
expr_stmt|;
return|return
name|right
return|;
block|}
return|return
name|newexp
return|;
block|}
else|else
name|fatal
argument_list|(
literal|"Badly formed attribute value"
argument_list|)
expr_stmt|;
block|}
comment|/* Otherwise, do recursion the other way.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|left
argument_list|)
operator|==
name|IF_THEN_ELSE
condition|)
block|{
name|rtx
name|newleft
init|=
name|operate_exp
argument_list|(
name|op
argument_list|,
name|XEXP
argument_list|(
name|left
argument_list|,
literal|1
argument_list|)
argument_list|,
name|right
argument_list|)
decl_stmt|;
name|rtx
name|newright
init|=
name|operate_exp
argument_list|(
name|op
argument_list|,
name|XEXP
argument_list|(
name|left
argument_list|,
literal|2
argument_list|)
argument_list|,
name|right
argument_list|)
decl_stmt|;
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|newleft
argument_list|,
name|newright
argument_list|)
condition|)
return|return
name|newleft
return|;
return|return
name|attr_rtx
argument_list|(
name|IF_THEN_ELSE
argument_list|,
name|XEXP
argument_list|(
name|left
argument_list|,
literal|0
argument_list|)
argument_list|,
name|newleft
argument_list|,
name|newright
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|left
argument_list|)
operator|==
name|COND
condition|)
block|{
name|int
name|allsame
init|=
literal|1
decl_stmt|;
name|rtx
name|defval
decl_stmt|;
name|newexp
operator|=
name|rtx_alloc
argument_list|(
name|COND
argument_list|)
expr_stmt|;
name|XVEC
argument_list|(
name|newexp
argument_list|,
literal|0
argument_list|)
operator|=
name|rtvec_alloc
argument_list|(
name|XVECLEN
argument_list|(
name|left
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|defval
operator|=
name|XEXP
argument_list|(
name|newexp
argument_list|,
literal|1
argument_list|)
operator|=
name|operate_exp
argument_list|(
name|op
argument_list|,
name|XEXP
argument_list|(
name|left
argument_list|,
literal|1
argument_list|)
argument_list|,
name|right
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|left
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|+=
literal|2
control|)
block|{
name|XVECEXP
argument_list|(
name|newexp
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
operator|=
name|XVECEXP
argument_list|(
name|left
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|XVECEXP
argument_list|(
name|newexp
argument_list|,
literal|0
argument_list|,
name|i
operator|+
literal|1
argument_list|)
operator|=
name|operate_exp
argument_list|(
name|op
argument_list|,
name|XVECEXP
argument_list|(
name|left
argument_list|,
literal|0
argument_list|,
name|i
operator|+
literal|1
argument_list|)
argument_list|,
name|right
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rtx_equal_p
argument_list|(
name|XVECEXP
argument_list|(
name|newexp
argument_list|,
literal|0
argument_list|,
name|i
operator|+
literal|1
argument_list|)
argument_list|,
name|defval
argument_list|)
condition|)
name|allsame
operator|=
literal|0
expr_stmt|;
block|}
comment|/* If the cond is trivial (all alternatives give the same value), 	 optimize it away.  */
if|if
condition|(
name|allsame
condition|)
block|{
name|obstack_free
argument_list|(
name|rtl_obstack
argument_list|,
name|newexp
argument_list|)
expr_stmt|;
return|return
name|operate_exp
argument_list|(
name|op
argument_list|,
name|XEXP
argument_list|(
name|left
argument_list|,
literal|1
argument_list|)
argument_list|,
name|right
argument_list|)
return|;
block|}
comment|/* If the result is the same as the LEFT operand, 	 just use that.  */
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|newexp
argument_list|,
name|left
argument_list|)
condition|)
block|{
name|obstack_free
argument_list|(
name|rtl_obstack
argument_list|,
name|newexp
argument_list|)
expr_stmt|;
return|return
name|left
return|;
block|}
return|return
name|newexp
return|;
block|}
else|else
name|fatal
argument_list|(
literal|"Badly formed attribute value."
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
return|return
name|NULL
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Once all attributes and DEFINE_FUNCTION_UNITs have been read, we    construct a number of attributes.     The first produces a function `function_units_used' which is given an    insn and produces an encoding showing which function units are required    for the execution of that insn.  If the value is non-negative, the insn    uses that unit; otherwise, the value is a one's compliment mask of units    used.     The second produces a function `result_ready_cost' which is used to    determine the time that the result of an insn will be ready and hence    a worst-case schedule.     Both of these produce quite complex expressions which are then set as the    default value of internal attributes.  Normal attribute simplification    should produce reasonable expressions.     For each unit, a `<name>_unit_ready_cost' function will take an    insn and give the delay until that unit will be ready with the result    and a `<name>_unit_conflict_cost' function is given an insn already    executing on the unit and a candidate to execute and will give the    cost from the time the executing insn started until the candidate    can start (ignore limitations on the number of simultaneous insns).     For each unit, a `<name>_unit_blockage' function is given an insn    already executing on the unit and a candidate to execute and will    give the delay incurred due to function unit conflicts.  The range of    blockage cost values for a given executing insn is given by the    `<name>_unit_blockage_range' function.  These values are encoded in    an int where the upper half gives the minimum value and the lower    half gives the maximum value.  */
end_comment

begin_function
specifier|static
name|void
name|expand_units
parameter_list|()
block|{
name|struct
name|function_unit
modifier|*
name|unit
decl_stmt|,
modifier|*
modifier|*
name|unit_num
decl_stmt|;
name|struct
name|function_unit_op
modifier|*
name|op
decl_stmt|,
modifier|*
modifier|*
name|op_array
decl_stmt|,
modifier|*
modifier|*
modifier|*
name|unit_ops
decl_stmt|;
name|rtx
name|unitsmask
decl_stmt|;
name|rtx
name|readycost
decl_stmt|;
name|rtx
name|newexp
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|u
decl_stmt|,
name|num
decl_stmt|,
name|nvalues
decl_stmt|;
comment|/* Rebuild the condition for the unit to share the RTL expressions.      Sharing is required by simplify_by_exploding.  Build the issue delay      expressions.  Validate the expressions we were given for the conditions      and conflict vector.  Then make attributes for use in the conflict      function.  */
for|for
control|(
name|unit
operator|=
name|units
init|;
name|unit
condition|;
name|unit
operator|=
name|unit
operator|->
name|next
control|)
block|{
name|rtx
name|min_issue
init|=
name|make_numeric_value
argument_list|(
name|unit
operator|->
name|issue_delay
operator|.
name|min
argument_list|)
decl_stmt|;
name|unit
operator|->
name|condexp
operator|=
name|check_attr_test
argument_list|(
name|unit
operator|->
name|condexp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|op
operator|=
name|unit
operator|->
name|ops
init|;
name|op
condition|;
name|op
operator|=
name|op
operator|->
name|next
control|)
block|{
name|rtx
name|issue_delay
init|=
name|make_numeric_value
argument_list|(
name|op
operator|->
name|issue_delay
argument_list|)
decl_stmt|;
name|rtx
name|issue_exp
init|=
name|issue_delay
decl_stmt|;
comment|/* Build, validate, and simplify the issue delay expression.  */
if|if
condition|(
name|op
operator|->
name|conflict_exp
operator|!=
name|true_rtx
condition|)
name|issue_exp
operator|=
name|attr_rtx
argument_list|(
name|IF_THEN_ELSE
argument_list|,
name|op
operator|->
name|conflict_exp
argument_list|,
name|issue_exp
argument_list|,
name|make_numeric_value
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|issue_exp
operator|=
name|check_attr_value
argument_list|(
name|make_canonical
argument_list|(
name|NULL_ATTR
argument_list|,
name|issue_exp
argument_list|)
argument_list|,
name|NULL_ATTR
argument_list|)
expr_stmt|;
name|issue_exp
operator|=
name|simplify_knowing
argument_list|(
name|issue_exp
argument_list|,
name|unit
operator|->
name|condexp
argument_list|)
expr_stmt|;
name|op
operator|->
name|issue_exp
operator|=
name|issue_exp
expr_stmt|;
comment|/* Make an attribute for use in the conflict function if needed.  */
name|unit
operator|->
name|needs_conflict_function
operator|=
operator|(
name|unit
operator|->
name|issue_delay
operator|.
name|min
operator|!=
name|unit
operator|->
name|issue_delay
operator|.
name|max
operator|)
expr_stmt|;
if|if
condition|(
name|unit
operator|->
name|needs_conflict_function
condition|)
block|{
name|str
operator|=
name|attr_printf
argument_list|(
name|strlen
argument_list|(
name|unit
operator|->
name|name
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
literal|"*_cost_"
argument_list|)
operator|+
name|MAX_DIGITS
argument_list|,
literal|"*%s_cost_%d"
argument_list|,
name|unit
operator|->
name|name
argument_list|,
name|op
operator|->
name|num
argument_list|)
expr_stmt|;
name|make_internal_attr
argument_list|(
name|str
argument_list|,
name|issue_exp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Validate the condition.  */
name|op
operator|->
name|condexp
operator|=
name|check_attr_test
argument_list|(
name|op
operator|->
name|condexp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Compute the mask of function units used.  Initially, the unitsmask is      zero.   Set up a conditional to compute each unit's contribution.  */
name|unitsmask
operator|=
name|make_numeric_value
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|newexp
operator|=
name|rtx_alloc
argument_list|(
name|IF_THEN_ELSE
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|newexp
argument_list|,
literal|2
argument_list|)
operator|=
name|make_numeric_value
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Merge each function unit into the unit mask attributes.  */
for|for
control|(
name|unit
operator|=
name|units
init|;
name|unit
condition|;
name|unit
operator|=
name|unit
operator|->
name|next
control|)
block|{
name|XEXP
argument_list|(
name|newexp
argument_list|,
literal|0
argument_list|)
operator|=
name|unit
operator|->
name|condexp
expr_stmt|;
name|XEXP
argument_list|(
name|newexp
argument_list|,
literal|1
argument_list|)
operator|=
name|make_numeric_value
argument_list|(
literal|1
operator|<<
name|unit
operator|->
name|num
argument_list|)
expr_stmt|;
name|unitsmask
operator|=
name|operate_exp
argument_list|(
name|OR_OP
argument_list|,
name|unitsmask
argument_list|,
name|newexp
argument_list|)
expr_stmt|;
block|}
comment|/* Simplify the unit mask expression, encode it, and make an attribute      for the function_units_used function.  */
name|unitsmask
operator|=
name|simplify_by_exploding
argument_list|(
name|unitsmask
argument_list|)
expr_stmt|;
name|unitsmask
operator|=
name|encode_units_mask
argument_list|(
name|unitsmask
argument_list|)
expr_stmt|;
name|make_internal_attr
argument_list|(
literal|"*function_units_used"
argument_list|,
name|unitsmask
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* Create an array of ops for each unit.  Add an extra unit for the      result_ready_cost function that has the ops of all other units.  */
name|unit_ops
operator|=
operator|(
expr|struct
name|function_unit_op
operator|*
operator|*
operator|*
operator|)
name|alloca
argument_list|(
operator|(
name|num_units
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|function_unit_op
operator|*
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|unit_num
operator|=
operator|(
expr|struct
name|function_unit
operator|*
operator|*
operator|)
name|alloca
argument_list|(
operator|(
name|num_units
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|function_unit
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|unit_num
index|[
name|num_units
index|]
operator|=
name|unit
operator|=
operator|(
expr|struct
name|function_unit
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|function_unit
argument_list|)
argument_list|)
expr_stmt|;
name|unit
operator|->
name|num
operator|=
name|num_units
expr_stmt|;
name|unit
operator|->
name|num_opclasses
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|unit
operator|=
name|units
init|;
name|unit
condition|;
name|unit
operator|=
name|unit
operator|->
name|next
control|)
block|{
name|unit_num
index|[
name|num_units
index|]
operator|->
name|num_opclasses
operator|+=
name|unit
operator|->
name|num_opclasses
expr_stmt|;
name|unit_num
index|[
name|unit
operator|->
name|num
index|]
operator|=
name|unit
expr_stmt|;
name|unit_ops
index|[
name|unit
operator|->
name|num
index|]
operator|=
name|op_array
operator|=
operator|(
expr|struct
name|function_unit_op
operator|*
operator|*
operator|)
name|alloca
argument_list|(
name|unit
operator|->
name|num_opclasses
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|function_unit_op
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|op
operator|=
name|unit
operator|->
name|ops
init|;
name|op
condition|;
name|op
operator|=
name|op
operator|->
name|next
control|)
name|op_array
index|[
name|op
operator|->
name|num
index|]
operator|=
name|op
expr_stmt|;
block|}
comment|/* Compose the array of ops for the extra unit.  */
name|unit_ops
index|[
name|num_units
index|]
operator|=
name|op_array
operator|=
operator|(
expr|struct
name|function_unit_op
operator|*
operator|*
operator|)
name|alloca
argument_list|(
name|unit_num
index|[
name|num_units
index|]
operator|->
name|num_opclasses
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|function_unit_op
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|unit
operator|=
name|units
operator|,
name|i
operator|=
literal|0
init|;
name|unit
condition|;
name|i
operator|+=
name|unit
operator|->
name|num_opclasses
operator|,
name|unit
operator|=
name|unit
operator|->
name|next
control|)
name|bcopy
argument_list|(
name|unit_ops
index|[
name|unit
operator|->
name|num
index|]
argument_list|,
operator|&
name|op_array
index|[
name|i
index|]
argument_list|,
name|unit
operator|->
name|num_opclasses
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|function_unit_op
operator|*
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Compute the ready cost function for each unit by computing the      condition for each non-default value.  */
for|for
control|(
name|u
operator|=
literal|0
init|;
name|u
operator|<=
name|num_units
condition|;
name|u
operator|++
control|)
block|{
name|rtx
name|orexp
decl_stmt|;
name|int
name|value
decl_stmt|;
name|unit
operator|=
name|unit_num
index|[
name|u
index|]
expr_stmt|;
name|op_array
operator|=
name|unit_ops
index|[
name|unit
operator|->
name|num
index|]
expr_stmt|;
name|num
operator|=
name|unit
operator|->
name|num_opclasses
expr_stmt|;
comment|/* Sort the array of ops into increasing ready cost order.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
name|num
operator|-
literal|1
init|;
name|j
operator|>
name|i
condition|;
name|j
operator|--
control|)
if|if
condition|(
name|op_array
index|[
name|j
operator|-
literal|1
index|]
operator|->
name|ready
operator|<
name|op_array
index|[
name|j
index|]
operator|->
name|ready
condition|)
block|{
name|op
operator|=
name|op_array
index|[
name|j
index|]
expr_stmt|;
name|op_array
index|[
name|j
index|]
operator|=
name|op_array
index|[
name|j
operator|-
literal|1
index|]
expr_stmt|;
name|op_array
index|[
name|j
operator|-
literal|1
index|]
operator|=
name|op
expr_stmt|;
block|}
comment|/* Determine how many distinct non-default ready cost values there 	 are.  We use a default ready cost value of 1.  */
name|nvalues
operator|=
literal|0
expr_stmt|;
name|value
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
name|num
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|op_array
index|[
name|i
index|]
operator|->
name|ready
operator|>
name|value
condition|)
block|{
name|value
operator|=
name|op_array
index|[
name|i
index|]
operator|->
name|ready
expr_stmt|;
name|nvalues
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|nvalues
operator|==
literal|0
condition|)
name|readycost
operator|=
name|make_numeric_value
argument_list|(
literal|1
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Construct the ready cost expression as a COND of each value from 	     the largest to the smallest.  */
name|readycost
operator|=
name|rtx_alloc
argument_list|(
name|COND
argument_list|)
expr_stmt|;
name|XVEC
argument_list|(
name|readycost
argument_list|,
literal|0
argument_list|)
operator|=
name|rtvec_alloc
argument_list|(
name|nvalues
operator|*
literal|2
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|readycost
argument_list|,
literal|1
argument_list|)
operator|=
name|make_numeric_value
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|nvalues
operator|=
literal|0
expr_stmt|;
name|orexp
operator|=
name|false_rtx
expr_stmt|;
name|value
operator|=
name|op_array
index|[
literal|0
index|]
operator|->
name|ready
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
block|{
name|op
operator|=
name|op_array
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|op
operator|->
name|ready
operator|<=
literal|1
condition|)
break|break;
elseif|else
if|if
condition|(
name|op
operator|->
name|ready
operator|==
name|value
condition|)
name|orexp
operator|=
name|insert_right_side
argument_list|(
name|IOR
argument_list|,
name|orexp
argument_list|,
name|op
operator|->
name|condexp
argument_list|,
operator|-
literal|2
argument_list|)
expr_stmt|;
else|else
block|{
name|XVECEXP
argument_list|(
name|readycost
argument_list|,
literal|0
argument_list|,
name|nvalues
operator|*
literal|2
argument_list|)
operator|=
name|orexp
expr_stmt|;
name|XVECEXP
argument_list|(
name|readycost
argument_list|,
literal|0
argument_list|,
name|nvalues
operator|*
literal|2
operator|+
literal|1
argument_list|)
operator|=
name|make_numeric_value
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|nvalues
operator|++
expr_stmt|;
name|value
operator|=
name|op
operator|->
name|ready
expr_stmt|;
name|orexp
operator|=
name|op
operator|->
name|condexp
expr_stmt|;
block|}
block|}
name|XVECEXP
argument_list|(
name|readycost
argument_list|,
literal|0
argument_list|,
name|nvalues
operator|*
literal|2
argument_list|)
operator|=
name|orexp
expr_stmt|;
name|XVECEXP
argument_list|(
name|readycost
argument_list|,
literal|0
argument_list|,
name|nvalues
operator|*
literal|2
operator|+
literal|1
argument_list|)
operator|=
name|make_numeric_value
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|u
operator|<
name|num_units
condition|)
block|{
name|rtx
name|max_blockage
init|=
literal|0
decl_stmt|,
name|min_blockage
init|=
literal|0
decl_stmt|;
comment|/* Simplify the readycost expression by only considering insns 	     that use the unit.  */
name|readycost
operator|=
name|simplify_knowing
argument_list|(
name|readycost
argument_list|,
name|unit
operator|->
name|condexp
argument_list|)
expr_stmt|;
comment|/* Determine the blockage cost the executing insn (E) given 	     the candidate insn (C).  This is the maximum of the issue 	     delay, the pipeline delay, and the simultaneity constraint. 	     Each function_unit_op represents the characteristics of the 	     candidate insn, so in the expressions below, C is a known 	     term and E is an unknown term.  	     The issue delay function for C is op->issue_exp and is used to 	     write the `<name>_unit_conflict_cost' function.  Symbolicly 	     this is "ISSUE-DELAY (E,C)".  	     The pipeline delay results form the FIFO constraint on the 	     function unit and is "READY-COST (E) + 1 - READY-COST (C)".  	     The simultaneity constraint is based on how long it takes to 	     fill the unit given the minimum issue delay.  FILL-TIME is the 	     constant "MIN (ISSUE-DELAY (*,*)) * (SIMULTANEITY - 1)", and 	     the simultaneity constraint is "READY-COST (E) - FILL-TIME" 	     if SIMULTANEITY is non-zero and zero otherwise.  	     Thus, BLOCKAGE (E,C) when SIMULTANEITY is zero is  	         MAX (ISSUE-DELAY (E,C), 		      READY-COST (E) - (READY-COST (C) - 1))  	     and otherwise  	         MAX (ISSUE-DELAY (E,C), 		      READY-COST (E) - (READY-COST (C) - 1), 		      READY-COST (E) - FILL-TIME)  	     The `<name>_unit_blockage' function is computed by determining 	     this value for each candidate insn.  As these values are 	     computed, we also compute the upper and lower bounds for 	     BLOCKAGE (E,*).  These are combined to form the function 	     `<name>_unit_blockage_range'.  Finally, the maximum blockage 	     cost, MAX (BLOCKAGE (*,*)), is computed.  */
for|for
control|(
name|op
operator|=
name|unit
operator|->
name|ops
init|;
name|op
condition|;
name|op
operator|=
name|op
operator|->
name|next
control|)
block|{
name|rtx
name|blockage
init|=
name|readycost
decl_stmt|;
name|int
name|delay
init|=
name|op
operator|->
name|ready
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|unit
operator|->
name|simultaneity
operator|!=
literal|0
condition|)
name|delay
operator|=
name|MIN
argument_list|(
name|delay
argument_list|,
operator|(
operator|(
name|unit
operator|->
name|simultaneity
operator|-
literal|1
operator|)
operator|*
name|unit
operator|->
name|issue_delay
operator|.
name|min
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|delay
operator|>
literal|0
condition|)
name|blockage
operator|=
name|operate_exp
argument_list|(
name|POS_MINUS_OP
argument_list|,
name|blockage
argument_list|,
name|make_numeric_value
argument_list|(
name|delay
argument_list|)
argument_list|)
expr_stmt|;
name|blockage
operator|=
name|operate_exp
argument_list|(
name|MAX_OP
argument_list|,
name|blockage
argument_list|,
name|op
operator|->
name|issue_exp
argument_list|)
expr_stmt|;
name|blockage
operator|=
name|simplify_knowing
argument_list|(
name|blockage
argument_list|,
name|unit
operator|->
name|condexp
argument_list|)
expr_stmt|;
comment|/* Add this op's contribution to MAX (BLOCKAGE (E,*)) and 		 MIN (BLOCKAGE (E,*)).  */
if|if
condition|(
name|max_blockage
operator|==
literal|0
condition|)
name|max_blockage
operator|=
name|min_blockage
operator|=
name|blockage
expr_stmt|;
else|else
block|{
name|max_blockage
operator|=
name|simplify_knowing
argument_list|(
name|operate_exp
argument_list|(
name|MAX_OP
argument_list|,
name|max_blockage
argument_list|,
name|blockage
argument_list|)
argument_list|,
name|unit
operator|->
name|condexp
argument_list|)
expr_stmt|;
name|min_blockage
operator|=
name|simplify_knowing
argument_list|(
name|operate_exp
argument_list|(
name|MIN_OP
argument_list|,
name|min_blockage
argument_list|,
name|blockage
argument_list|)
argument_list|,
name|unit
operator|->
name|condexp
argument_list|)
expr_stmt|;
block|}
comment|/* Make an attribute for use in the blockage function.  */
name|str
operator|=
name|attr_printf
argument_list|(
name|strlen
argument_list|(
name|unit
operator|->
name|name
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
literal|"*_block_"
argument_list|)
operator|+
name|MAX_DIGITS
argument_list|,
literal|"*%s_block_%d"
argument_list|,
name|unit
operator|->
name|name
argument_list|,
name|op
operator|->
name|num
argument_list|)
expr_stmt|;
name|make_internal_attr
argument_list|(
name|str
argument_list|,
name|blockage
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Record MAX (BLOCKAGE (*,*)).  */
name|unit
operator|->
name|max_blockage
operator|=
name|max_attr_value
argument_list|(
name|max_blockage
argument_list|)
expr_stmt|;
comment|/* See if the upper and lower bounds of BLOCKAGE (E,*) are the 	     same.  If so, the blockage function carries no additional 	     information and is not written.  */
name|newexp
operator|=
name|operate_exp
argument_list|(
name|EQ_OP
argument_list|,
name|max_blockage
argument_list|,
name|min_blockage
argument_list|)
expr_stmt|;
name|newexp
operator|=
name|simplify_knowing
argument_list|(
name|newexp
argument_list|,
name|unit
operator|->
name|condexp
argument_list|)
expr_stmt|;
name|unit
operator|->
name|needs_blockage_function
operator|=
operator|(
name|GET_CODE
argument_list|(
name|newexp
argument_list|)
operator|!=
name|CONST_STRING
operator|||
name|atoi
argument_list|(
name|XSTR
argument_list|(
name|newexp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
literal|1
operator|)
expr_stmt|;
comment|/* If the all values of BLOCKAGE (E,C) have the same value, 	     neither blockage function is written.  */
name|unit
operator|->
name|needs_range_function
operator|=
operator|(
name|unit
operator|->
name|needs_blockage_function
operator|||
name|GET_CODE
argument_list|(
name|max_blockage
argument_list|)
operator|!=
name|CONST_STRING
operator|)
expr_stmt|;
if|if
condition|(
name|unit
operator|->
name|needs_range_function
condition|)
block|{
comment|/* Compute the blockage range function and make an attribute 		 for writing it's value.  */
name|newexp
operator|=
name|operate_exp
argument_list|(
name|RANGE_OP
argument_list|,
name|min_blockage
argument_list|,
name|max_blockage
argument_list|)
expr_stmt|;
name|newexp
operator|=
name|simplify_knowing
argument_list|(
name|newexp
argument_list|,
name|unit
operator|->
name|condexp
argument_list|)
expr_stmt|;
name|str
operator|=
name|attr_printf
argument_list|(
name|strlen
argument_list|(
name|unit
operator|->
name|name
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
literal|"*_unit_blockage_range"
argument_list|)
argument_list|,
literal|"*%s_unit_blockage_range"
argument_list|,
name|unit
operator|->
name|name
argument_list|)
expr_stmt|;
name|make_internal_attr
argument_list|(
name|str
argument_list|,
name|newexp
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
name|str
operator|=
name|attr_printf
argument_list|(
name|strlen
argument_list|(
name|unit
operator|->
name|name
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
literal|"*_unit_ready_cost"
argument_list|)
argument_list|,
literal|"*%s_unit_ready_cost"
argument_list|,
name|unit
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
else|else
name|str
operator|=
literal|"*result_ready_cost"
expr_stmt|;
comment|/* Make an attribute for the ready_cost function.  Simplifying 	 further with simplify_by_exploding doesn't win.  */
name|make_internal_attr
argument_list|(
name|str
argument_list|,
name|readycost
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* For each unit that requires a conflict cost function, make an attribute      that maps insns to the operation number.  */
for|for
control|(
name|unit
operator|=
name|units
init|;
name|unit
condition|;
name|unit
operator|=
name|unit
operator|->
name|next
control|)
block|{
name|rtx
name|caseexp
decl_stmt|;
if|if
condition|(
operator|!
name|unit
operator|->
name|needs_conflict_function
operator|&&
operator|!
name|unit
operator|->
name|needs_blockage_function
condition|)
continue|continue;
name|caseexp
operator|=
name|rtx_alloc
argument_list|(
name|COND
argument_list|)
expr_stmt|;
name|XVEC
argument_list|(
name|caseexp
argument_list|,
literal|0
argument_list|)
operator|=
name|rtvec_alloc
argument_list|(
operator|(
name|unit
operator|->
name|num_opclasses
operator|-
literal|1
operator|)
operator|*
literal|2
argument_list|)
expr_stmt|;
for|for
control|(
name|op
operator|=
name|unit
operator|->
name|ops
init|;
name|op
condition|;
name|op
operator|=
name|op
operator|->
name|next
control|)
block|{
comment|/* Make our adjustment to the COND being computed.  If we are the 	     last operation class, place our values into the default of the 	     COND.  */
if|if
condition|(
name|op
operator|->
name|num
operator|==
name|unit
operator|->
name|num_opclasses
operator|-
literal|1
condition|)
block|{
name|XEXP
argument_list|(
name|caseexp
argument_list|,
literal|1
argument_list|)
operator|=
name|make_numeric_value
argument_list|(
name|op
operator|->
name|num
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|XVECEXP
argument_list|(
name|caseexp
argument_list|,
literal|0
argument_list|,
name|op
operator|->
name|num
operator|*
literal|2
argument_list|)
operator|=
name|op
operator|->
name|condexp
expr_stmt|;
name|XVECEXP
argument_list|(
name|caseexp
argument_list|,
literal|0
argument_list|,
name|op
operator|->
name|num
operator|*
literal|2
operator|+
literal|1
argument_list|)
operator|=
name|make_numeric_value
argument_list|(
name|op
operator|->
name|num
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Simplifying caseexp with simplify_by_exploding doesn't win.  */
name|str
operator|=
name|attr_printf
argument_list|(
name|strlen
argument_list|(
name|unit
operator|->
name|name
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
literal|"*_cases"
argument_list|)
argument_list|,
literal|"*%s_cases"
argument_list|,
name|unit
operator|->
name|name
argument_list|)
expr_stmt|;
name|make_internal_attr
argument_list|(
name|str
argument_list|,
name|caseexp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Simplify EXP given KNOWN_TRUE.  */
end_comment

begin_function
specifier|static
name|rtx
name|simplify_knowing
parameter_list|(
name|exp
parameter_list|,
name|known_true
parameter_list|)
name|rtx
name|exp
decl_stmt|,
name|known_true
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|exp
argument_list|)
operator|!=
name|CONST_STRING
condition|)
block|{
name|exp
operator|=
name|attr_rtx
argument_list|(
name|IF_THEN_ELSE
argument_list|,
name|known_true
argument_list|,
name|exp
argument_list|,
name|make_numeric_value
argument_list|(
name|max_attr_value
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|exp
operator|=
name|simplify_by_exploding
argument_list|(
name|exp
argument_list|)
expr_stmt|;
block|}
return|return
name|exp
return|;
block|}
end_function

begin_comment
comment|/* Translate the CONST_STRING expressions in X to change the encoding of    value.  On input, the value is a bitmask with a one bit for each unit    used; on output, the value is the unit number (zero based) if one    and only one unit is used or the one's compliment of the bitmask.  */
end_comment

begin_function
specifier|static
name|rtx
name|encode_units_mask
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|;
specifier|register
name|enum
name|rtx_code
name|code
decl_stmt|;
specifier|register
name|char
modifier|*
name|fmt
decl_stmt|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|CONST_STRING
case|:
name|i
operator|=
name|atoi
argument_list|(
name|XSTR
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* The sign bit encodes a one's compliment mask.  */
elseif|else
if|if
condition|(
name|i
operator|!=
literal|0
operator|&&
name|i
operator|==
operator|(
name|i
operator|&
operator|-
name|i
operator|)
condition|)
comment|/* Only one bit is set, so yield that unit number.  */
for|for
control|(
name|j
operator|=
literal|0
init|;
operator|(
name|i
operator|>>=
literal|1
operator|)
operator|!=
literal|0
condition|;
name|j
operator|++
control|)
empty_stmt|;
else|else
name|j
operator|=
operator|~
name|i
expr_stmt|;
return|return
name|attr_rtx
argument_list|(
name|CONST_STRING
argument_list|,
name|attr_printf
argument_list|(
name|MAX_DIGITS
argument_list|,
literal|"%d"
argument_list|,
name|j
argument_list|)
argument_list|)
return|;
case|case
name|REG
case|:
case|case
name|QUEUED
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|CODE_LABEL
case|:
case|case
name|PC
case|:
case|case
name|CC0
case|:
case|case
name|EQ_ATTR
case|:
return|return
name|x
return|;
block|}
comment|/* Compare the elements.  If any pair of corresponding elements      fail to match, return 0 for the whole things.  */
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
switch|switch
condition|(
name|fmt
index|[
name|i
index|]
condition|)
block|{
case|case
literal|'V'
case|:
case|case
literal|'E'
case|:
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
operator|=
name|encode_units_mask
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|=
name|encode_units_mask
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
name|x
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Once all attributes and insns have been read and checked, we construct for    each attribute value a list of all the insns that have that value for    the attribute.  */
end_comment

begin_function
specifier|static
name|void
name|fill_attr
parameter_list|(
name|attr
parameter_list|)
name|struct
name|attr_desc
modifier|*
name|attr
decl_stmt|;
block|{
name|struct
name|attr_value
modifier|*
name|av
decl_stmt|;
name|struct
name|insn_ent
modifier|*
name|ie
decl_stmt|;
name|struct
name|insn_def
modifier|*
name|id
decl_stmt|;
name|int
name|i
decl_stmt|;
name|rtx
name|value
decl_stmt|;
comment|/* Don't fill constant attributes.  The value is independent of      any particular insn.  */
if|if
condition|(
name|attr
operator|->
name|is_const
condition|)
return|return;
for|for
control|(
name|id
operator|=
name|defs
init|;
name|id
condition|;
name|id
operator|=
name|id
operator|->
name|next
control|)
block|{
comment|/* If no value is specified for this insn for this attribute, use the 	 default.  */
name|value
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|XVEC
argument_list|(
name|id
operator|->
name|def
argument_list|,
name|id
operator|->
name|vec_idx
argument_list|)
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|id
operator|->
name|def
argument_list|,
name|id
operator|->
name|vec_idx
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|XSTR
argument_list|(
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|id
operator|->
name|def
argument_list|,
name|id
operator|->
name|vec_idx
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|attr
operator|->
name|name
argument_list|)
condition|)
name|value
operator|=
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|id
operator|->
name|def
argument_list|,
name|id
operator|->
name|vec_idx
argument_list|,
name|i
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|==
name|NULL
condition|)
name|av
operator|=
name|attr
operator|->
name|default_val
expr_stmt|;
else|else
name|av
operator|=
name|get_attr_value
argument_list|(
name|value
argument_list|,
name|attr
argument_list|,
name|id
operator|->
name|insn_code
argument_list|)
expr_stmt|;
name|ie
operator|=
operator|(
expr|struct
name|insn_ent
operator|*
operator|)
name|oballoc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|insn_ent
argument_list|)
argument_list|)
expr_stmt|;
name|ie
operator|->
name|insn_code
operator|=
name|id
operator|->
name|insn_code
expr_stmt|;
name|ie
operator|->
name|insn_index
operator|=
name|id
operator|->
name|insn_code
expr_stmt|;
name|insert_insn_ent
argument_list|(
name|av
argument_list|,
name|ie
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given an expression EXP, see if it is a COND or IF_THEN_ELSE that has a    test that checks relative positions of insns (uses MATCH_DUP or PC).    If so, replace it with what is obtained by passing the expression to    ADDRESS_FN.  If not but it is a COND or IF_THEN_ELSE, call this routine    recursively on each value (including the default value).  Otherwise,    return the value returned by NO_ADDRESS_FN applied to EXP.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|substitute_address
argument_list|(
name|exp
argument_list|,
name|no_address_fn
argument_list|,
name|address_fn
argument_list|)
name|rtx
name|exp
decl_stmt|;
end_decl_stmt

begin_function_decl
name|rtx
function_decl|(
modifier|*
name|no_address_fn
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|rtx
function_decl|(
modifier|*
name|address_fn
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_block
block|{
name|int
name|i
decl_stmt|;
name|rtx
name|newexp
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|COND
condition|)
block|{
comment|/* See if any tests use addresses.  */
name|address_used
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|+=
literal|2
control|)
name|walk_attr_value
argument_list|(
name|XVECEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|address_used
condition|)
return|return
call|(
modifier|*
name|address_fn
call|)
argument_list|(
name|exp
argument_list|)
return|;
comment|/* Make a new copy of this COND, replacing each element.  */
name|newexp
operator|=
name|rtx_alloc
argument_list|(
name|COND
argument_list|)
expr_stmt|;
name|XVEC
argument_list|(
name|newexp
argument_list|,
literal|0
argument_list|)
operator|=
name|rtvec_alloc
argument_list|(
name|XVECLEN
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|+=
literal|2
control|)
block|{
name|XVECEXP
argument_list|(
name|newexp
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
operator|=
name|XVECEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|XVECEXP
argument_list|(
name|newexp
argument_list|,
literal|0
argument_list|,
name|i
operator|+
literal|1
argument_list|)
operator|=
name|substitute_address
argument_list|(
name|XVECEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|,
name|i
operator|+
literal|1
argument_list|)
argument_list|,
name|no_address_fn
argument_list|,
name|address_fn
argument_list|)
expr_stmt|;
block|}
name|XEXP
argument_list|(
name|newexp
argument_list|,
literal|1
argument_list|)
operator|=
name|substitute_address
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|no_address_fn
argument_list|,
name|address_fn
argument_list|)
expr_stmt|;
return|return
name|newexp
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|IF_THEN_ELSE
condition|)
block|{
name|address_used
operator|=
literal|0
expr_stmt|;
name|walk_attr_value
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|address_used
condition|)
return|return
call|(
modifier|*
name|address_fn
call|)
argument_list|(
name|exp
argument_list|)
return|;
return|return
name|attr_rtx
argument_list|(
name|IF_THEN_ELSE
argument_list|,
name|substitute_address
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|no_address_fn
argument_list|,
name|address_fn
argument_list|)
argument_list|,
name|substitute_address
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|no_address_fn
argument_list|,
name|address_fn
argument_list|)
argument_list|,
name|substitute_address
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
argument_list|,
name|no_address_fn
argument_list|,
name|address_fn
argument_list|)
argument_list|)
return|;
block|}
return|return
call|(
modifier|*
name|no_address_fn
call|)
argument_list|(
name|exp
argument_list|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Make new attributes from the `length' attribute.  The following are made,    each corresponding to a function called from `shorten_branches' or    `get_attr_length':     *insn_default_length		This is the length of the insn to be returned 				by `get_attr_length' before `shorten_branches' 				has been called.  In each case where the length 				depends on relative addresses, the largest 				possible is used.  This routine is also used 				to compute the initial size of the insn.     *insn_variable_length_p	This returns 1 if the insn's length depends 				on relative addresses, zero otherwise.     *insn_current_length		This is only called when it is known that the 				insn has a variable length and returns the 				current length, based on relative addresses.   */
end_comment

begin_function
specifier|static
name|void
name|make_length_attrs
parameter_list|()
block|{
specifier|static
name|char
modifier|*
name|new_names
index|[]
init|=
block|{
literal|"*insn_default_length"
block|,
literal|"*insn_variable_length_p"
block|,
literal|"*insn_current_length"
block|}
decl_stmt|;
specifier|static
name|rtx
function_decl|(
modifier|*
name|no_address_fn
index|[]
function_decl|)
parameter_list|()
init|=
block|{
name|identity_fn
operator|,
function_decl|zero_fn
operator|,
function_decl|zero_fn
block|}
end_function

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_function_decl
specifier|static
name|rtx
function_decl|(
modifier|*
name|address_fn
index|[]
function_decl|)
parameter_list|()
init|=
block|{
name|max_fn
operator|,
function_decl|one_fn
operator|,
function_decl|identity_fn
end_function_decl

begin_decl_stmt
unit|};
name|int
name|i
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|attr_desc
modifier|*
name|length_attr
decl_stmt|,
modifier|*
name|new_attr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|attr_value
modifier|*
name|av
decl_stmt|,
modifier|*
name|new_av
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|insn_ent
modifier|*
name|ie
decl_stmt|,
modifier|*
name|new_ie
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* See if length attribute is defined.  If so, it must be numeric.  Make      it special so we don't output anything for it.  */
end_comment

begin_expr_stmt
name|length_attr
operator|=
name|find_attr
argument_list|(
literal|"length"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|length_attr
operator|==
literal|0
condition|)
return|return;
end_if

begin_if
if|if
condition|(
operator|!
name|length_attr
operator|->
name|is_numeric
condition|)
name|fatal
argument_list|(
literal|"length attribute must be numeric."
argument_list|)
expr_stmt|;
end_if

begin_expr_stmt
name|length_attr
operator|->
name|is_const
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|length_attr
operator|->
name|is_special
operator|=
literal|1
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Make each new attribute, in turn.  */
end_comment

begin_for
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
name|new_names
operator|/
sizeof|sizeof
name|new_names
index|[
literal|0
index|]
condition|;
name|i
operator|++
control|)
block|{
name|make_internal_attr
argument_list|(
name|new_names
index|[
name|i
index|]
argument_list|,
name|substitute_address
argument_list|(
name|length_attr
operator|->
name|default_val
operator|->
name|value
argument_list|,
name|no_address_fn
index|[
name|i
index|]
argument_list|,
name|address_fn
index|[
name|i
index|]
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|new_attr
operator|=
name|find_attr
argument_list|(
name|new_names
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|av
operator|=
name|length_attr
operator|->
name|first_value
init|;
name|av
condition|;
name|av
operator|=
name|av
operator|->
name|next
control|)
for|for
control|(
name|ie
operator|=
name|av
operator|->
name|first_insn
init|;
name|ie
condition|;
name|ie
operator|=
name|ie
operator|->
name|next
control|)
block|{
name|new_av
operator|=
name|get_attr_value
argument_list|(
name|substitute_address
argument_list|(
name|av
operator|->
name|value
argument_list|,
name|no_address_fn
index|[
name|i
index|]
argument_list|,
name|address_fn
index|[
name|i
index|]
argument_list|)
argument_list|,
name|new_attr
argument_list|,
name|ie
operator|->
name|insn_code
argument_list|)
expr_stmt|;
name|new_ie
operator|=
operator|(
expr|struct
name|insn_ent
operator|*
operator|)
name|oballoc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|insn_ent
argument_list|)
argument_list|)
expr_stmt|;
name|new_ie
operator|->
name|insn_code
operator|=
name|ie
operator|->
name|insn_code
expr_stmt|;
name|new_ie
operator|->
name|insn_index
operator|=
name|ie
operator|->
name|insn_index
expr_stmt|;
name|insert_insn_ent
argument_list|(
name|new_av
argument_list|,
name|new_ie
argument_list|)
expr_stmt|;
block|}
block|}
end_for

begin_comment
unit|}
comment|/* Utility functions called from above routine.  */
end_comment

begin_function
unit|static
name|rtx
name|identity_fn
parameter_list|(
name|exp
parameter_list|)
name|rtx
name|exp
decl_stmt|;
block|{
return|return
name|exp
return|;
block|}
end_function

begin_function
specifier|static
name|rtx
name|zero_fn
parameter_list|(
name|exp
parameter_list|)
name|rtx
name|exp
decl_stmt|;
block|{
return|return
name|make_numeric_value
argument_list|(
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|rtx
name|one_fn
parameter_list|(
name|exp
parameter_list|)
name|rtx
name|exp
decl_stmt|;
block|{
return|return
name|make_numeric_value
argument_list|(
literal|1
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|rtx
name|max_fn
parameter_list|(
name|exp
parameter_list|)
name|rtx
name|exp
decl_stmt|;
block|{
return|return
name|make_numeric_value
argument_list|(
name|max_attr_value
argument_list|(
name|exp
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Take a COND expression and see if any of the conditions in it can be    simplified.  If any are known true or known false for the particular insn    code, the COND can be further simplified.     Also call ourselves on any COND operations that are values of this COND.     We do not modify EXP; rather, we make and return a new rtx.  */
end_comment

begin_function
specifier|static
name|rtx
name|simplify_cond
parameter_list|(
name|exp
parameter_list|,
name|insn_code
parameter_list|,
name|insn_index
parameter_list|)
name|rtx
name|exp
decl_stmt|;
name|int
name|insn_code
decl_stmt|,
name|insn_index
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
comment|/* We store the desired contents here,      then build a new expression if they don't match EXP.  */
name|rtx
name|defval
init|=
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|rtx
name|new_defval
init|=
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|int
name|len
init|=
name|XVECLEN
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
modifier|*
name|tests
init|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
name|len
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|allsame
init|=
literal|1
decl_stmt|;
name|char
modifier|*
name|first_spacer
decl_stmt|;
comment|/* This lets us free all storage allocated below, if appropriate.  */
name|first_spacer
operator|=
operator|(
name|char
operator|*
operator|)
name|obstack_finish
argument_list|(
name|rtl_obstack
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|XVECEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|tests
argument_list|,
name|len
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
comment|/* See if default value needs simplification.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|defval
argument_list|)
operator|==
name|COND
condition|)
name|new_defval
operator|=
name|simplify_cond
argument_list|(
name|defval
argument_list|,
name|insn_code
argument_list|,
name|insn_index
argument_list|)
expr_stmt|;
comment|/* Simplify the subexpressions, and see what tests we can get rid of.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|+=
literal|2
control|)
block|{
name|rtx
name|newtest
decl_stmt|,
name|newval
decl_stmt|;
comment|/* Simplify this test.  */
name|newtest
operator|=
name|SIMPLIFY_TEST_EXP
argument_list|(
name|tests
index|[
name|i
index|]
argument_list|,
name|insn_code
argument_list|,
name|insn_index
argument_list|)
expr_stmt|;
name|tests
index|[
name|i
index|]
operator|=
name|newtest
expr_stmt|;
name|newval
operator|=
name|tests
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
comment|/* See if this value may need simplification.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|newval
argument_list|)
operator|==
name|COND
condition|)
name|newval
operator|=
name|simplify_cond
argument_list|(
name|newval
argument_list|,
name|insn_code
argument_list|,
name|insn_index
argument_list|)
expr_stmt|;
comment|/* Look for ways to delete or combine this test.  */
if|if
condition|(
name|newtest
operator|==
name|true_rtx
condition|)
block|{
comment|/* If test is true, make this value the default 	     and discard this + any following tests.  */
name|len
operator|=
name|i
expr_stmt|;
name|defval
operator|=
name|tests
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
name|new_defval
operator|=
name|newval
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|newtest
operator|==
name|false_rtx
condition|)
block|{
comment|/* If test is false, discard it and its value.  */
for|for
control|(
name|j
operator|=
name|i
init|;
name|j
operator|<
name|len
operator|-
literal|2
condition|;
name|j
operator|++
control|)
name|tests
index|[
name|j
index|]
operator|=
name|tests
index|[
name|j
operator|+
literal|2
index|]
expr_stmt|;
name|len
operator|-=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|>
literal|0
operator|&&
name|attr_equal_p
argument_list|(
name|newval
argument_list|,
name|tests
index|[
name|i
operator|-
literal|1
index|]
argument_list|)
condition|)
block|{
comment|/* If this value and the value for the prev test are the same, 	     merge the tests.  */
name|tests
index|[
name|i
operator|-
literal|2
index|]
operator|=
name|insert_right_side
argument_list|(
name|IOR
argument_list|,
name|tests
index|[
name|i
operator|-
literal|2
index|]
argument_list|,
name|newtest
argument_list|,
name|insn_code
argument_list|,
name|insn_index
argument_list|)
expr_stmt|;
comment|/* Delete this test/value.  */
for|for
control|(
name|j
operator|=
name|i
init|;
name|j
operator|<
name|len
operator|-
literal|2
condition|;
name|j
operator|++
control|)
name|tests
index|[
name|j
index|]
operator|=
name|tests
index|[
name|j
operator|+
literal|2
index|]
expr_stmt|;
name|len
operator|-=
literal|2
expr_stmt|;
block|}
else|else
name|tests
index|[
name|i
operator|+
literal|1
index|]
operator|=
name|newval
expr_stmt|;
block|}
comment|/* If the last test in a COND has the same value      as the default value, that test isn't needed.  */
while|while
condition|(
name|len
operator|>
literal|0
operator|&&
name|attr_equal_p
argument_list|(
name|tests
index|[
name|len
operator|-
literal|1
index|]
argument_list|,
name|new_defval
argument_list|)
condition|)
name|len
operator|-=
literal|2
expr_stmt|;
comment|/* See if we changed anything.  */
if|if
condition|(
name|len
operator|!=
name|XVECLEN
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
operator|||
name|new_defval
operator|!=
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
condition|)
name|allsame
operator|=
literal|0
expr_stmt|;
else|else
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|attr_equal_p
argument_list|(
name|tests
index|[
name|i
index|]
argument_list|,
name|XVECEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
block|{
name|allsame
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
name|obstack_free
argument_list|(
name|rtl_obstack
argument_list|,
name|first_spacer
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|defval
argument_list|)
operator|==
name|COND
condition|)
return|return
name|simplify_cond
argument_list|(
name|defval
argument_list|,
name|insn_code
argument_list|,
name|insn_index
argument_list|)
return|;
return|return
name|defval
return|;
block|}
elseif|else
if|if
condition|(
name|allsame
condition|)
block|{
name|obstack_free
argument_list|(
name|rtl_obstack
argument_list|,
name|first_spacer
argument_list|)
expr_stmt|;
return|return
name|exp
return|;
block|}
else|else
block|{
name|rtx
name|newexp
init|=
name|rtx_alloc
argument_list|(
name|COND
argument_list|)
decl_stmt|;
name|XVEC
argument_list|(
name|newexp
argument_list|,
literal|0
argument_list|)
operator|=
name|rtvec_alloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|tests
argument_list|,
operator|&
name|XVECEXP
argument_list|(
name|newexp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|len
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|newexp
argument_list|,
literal|1
argument_list|)
operator|=
name|new_defval
expr_stmt|;
return|return
name|newexp
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Remove an insn entry from an attribute value.  */
end_comment

begin_function
specifier|static
name|void
name|remove_insn_ent
parameter_list|(
name|av
parameter_list|,
name|ie
parameter_list|)
name|struct
name|attr_value
modifier|*
name|av
decl_stmt|;
name|struct
name|insn_ent
modifier|*
name|ie
decl_stmt|;
block|{
name|struct
name|insn_ent
modifier|*
name|previe
decl_stmt|;
if|if
condition|(
name|av
operator|->
name|first_insn
operator|==
name|ie
condition|)
name|av
operator|->
name|first_insn
operator|=
name|ie
operator|->
name|next
expr_stmt|;
else|else
block|{
for|for
control|(
name|previe
operator|=
name|av
operator|->
name|first_insn
init|;
name|previe
operator|->
name|next
operator|!=
name|ie
condition|;
name|previe
operator|=
name|previe
operator|->
name|next
control|)
empty_stmt|;
name|previe
operator|->
name|next
operator|=
name|ie
operator|->
name|next
expr_stmt|;
block|}
name|av
operator|->
name|num_insns
operator|--
expr_stmt|;
if|if
condition|(
name|ie
operator|->
name|insn_code
operator|==
operator|-
literal|1
condition|)
name|av
operator|->
name|has_asm_insn
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Insert an insn entry in an attribute value list.  */
end_comment

begin_function
specifier|static
name|void
name|insert_insn_ent
parameter_list|(
name|av
parameter_list|,
name|ie
parameter_list|)
name|struct
name|attr_value
modifier|*
name|av
decl_stmt|;
name|struct
name|insn_ent
modifier|*
name|ie
decl_stmt|;
block|{
name|ie
operator|->
name|next
operator|=
name|av
operator|->
name|first_insn
expr_stmt|;
name|av
operator|->
name|first_insn
operator|=
name|ie
expr_stmt|;
name|av
operator|->
name|num_insns
operator|++
expr_stmt|;
if|if
condition|(
name|ie
operator|->
name|insn_code
operator|==
operator|-
literal|1
condition|)
name|av
operator|->
name|has_asm_insn
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This is a utility routine to take an expression that is a tree of either    AND or IOR expressions and insert a new term.  The new term will be    inserted at the right side of the first node whose code does not match    the root.  A new node will be created with the root's code.  Its left    side will be the old right side and its right side will be the new    term.     If the `term' is itself a tree, all its leaves will be inserted.  */
end_comment

begin_function
specifier|static
name|rtx
name|insert_right_side
parameter_list|(
name|code
parameter_list|,
name|exp
parameter_list|,
name|term
parameter_list|,
name|insn_code
parameter_list|,
name|insn_index
parameter_list|)
name|RTX_CODE
name|code
decl_stmt|;
name|rtx
name|exp
decl_stmt|;
name|rtx
name|term
decl_stmt|;
name|int
name|insn_code
decl_stmt|,
name|insn_index
decl_stmt|;
block|{
name|rtx
name|newexp
decl_stmt|;
comment|/* Avoid consing in some special cases.  */
if|if
condition|(
name|code
operator|==
name|AND
operator|&&
name|term
operator|==
name|true_rtx
condition|)
return|return
name|exp
return|;
if|if
condition|(
name|code
operator|==
name|AND
operator|&&
name|term
operator|==
name|false_rtx
condition|)
return|return
name|false_rtx
return|;
if|if
condition|(
name|code
operator|==
name|AND
operator|&&
name|exp
operator|==
name|true_rtx
condition|)
return|return
name|term
return|;
if|if
condition|(
name|code
operator|==
name|AND
operator|&&
name|exp
operator|==
name|false_rtx
condition|)
return|return
name|false_rtx
return|;
if|if
condition|(
name|code
operator|==
name|IOR
operator|&&
name|term
operator|==
name|true_rtx
condition|)
return|return
name|true_rtx
return|;
if|if
condition|(
name|code
operator|==
name|IOR
operator|&&
name|term
operator|==
name|false_rtx
condition|)
return|return
name|exp
return|;
if|if
condition|(
name|code
operator|==
name|IOR
operator|&&
name|exp
operator|==
name|true_rtx
condition|)
return|return
name|true_rtx
return|;
if|if
condition|(
name|code
operator|==
name|IOR
operator|&&
name|exp
operator|==
name|false_rtx
condition|)
return|return
name|term
return|;
if|if
condition|(
name|attr_equal_p
argument_list|(
name|exp
argument_list|,
name|term
argument_list|)
condition|)
return|return
name|exp
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|term
argument_list|)
operator|==
name|code
condition|)
block|{
name|exp
operator|=
name|insert_right_side
argument_list|(
name|code
argument_list|,
name|exp
argument_list|,
name|XEXP
argument_list|(
name|term
argument_list|,
literal|0
argument_list|)
argument_list|,
name|insn_code
argument_list|,
name|insn_index
argument_list|)
expr_stmt|;
name|exp
operator|=
name|insert_right_side
argument_list|(
name|code
argument_list|,
name|exp
argument_list|,
name|XEXP
argument_list|(
name|term
argument_list|,
literal|1
argument_list|)
argument_list|,
name|insn_code
argument_list|,
name|insn_index
argument_list|)
expr_stmt|;
return|return
name|exp
return|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|code
condition|)
block|{
name|rtx
name|new
init|=
name|insert_right_side
argument_list|(
name|code
argument_list|,
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|term
argument_list|,
name|insn_code
argument_list|,
name|insn_index
argument_list|)
decl_stmt|;
if|if
condition|(
name|new
operator|!=
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
condition|)
comment|/* Make a copy of this expression and call recursively.  */
name|newexp
operator|=
name|attr_rtx
argument_list|(
name|code
argument_list|,
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|new
argument_list|)
expr_stmt|;
else|else
name|newexp
operator|=
name|exp
expr_stmt|;
block|}
else|else
block|{
comment|/* Insert the new term.  */
name|newexp
operator|=
name|attr_rtx
argument_list|(
name|code
argument_list|,
name|exp
argument_list|,
name|term
argument_list|)
expr_stmt|;
block|}
return|return
name|SIMPLIFY_TEST_EXP
argument_list|(
name|newexp
argument_list|,
name|insn_code
argument_list|,
name|insn_index
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* If we have an expression which AND's a bunch of 	(not (eq_attrq "alternative" "n"))    terms, we may have covered all or all but one of the possible alternatives.    If so, we can optimize.  Similarly for IOR's of EQ_ATTR.     This routine is passed an expression and either AND or IOR.  It returns a    bitmask indicating which alternatives are present.    ??? What does "present" mean?  */
end_comment

begin_function
specifier|static
name|int
name|compute_alternative_mask
parameter_list|(
name|exp
parameter_list|,
name|code
parameter_list|)
name|rtx
name|exp
decl_stmt|;
name|RTX_CODE
name|code
decl_stmt|;
block|{
name|char
modifier|*
name|string
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|code
condition|)
return|return
name|compute_alternative_mask
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|code
argument_list|)
operator||
name|compute_alternative_mask
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|code
argument_list|)
return|;
elseif|else
if|if
condition|(
name|code
operator|==
name|AND
operator|&&
name|GET_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|NOT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|EQ_ATTR
operator|&&
name|XSTR
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|alternative_name
condition|)
name|string
operator|=
name|XSTR
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|IOR
operator|&&
name|GET_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|EQ_ATTR
operator|&&
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
operator|==
name|alternative_name
condition|)
name|string
operator|=
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
return|return
literal|0
return|;
if|if
condition|(
name|string
index|[
literal|1
index|]
operator|==
literal|0
condition|)
return|return
literal|1
operator|<<
operator|(
name|string
index|[
literal|0
index|]
operator|-
literal|'0'
operator|)
return|;
return|return
literal|1
operator|<<
name|atoi
argument_list|(
name|string
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Given I, a single-bit mask, return RTX to compare the `alternative'    attribute with the value represented by that bit.  */
end_comment

begin_function
specifier|static
name|rtx
name|make_alternative_compare
parameter_list|(
name|mask
parameter_list|)
name|int
name|mask
decl_stmt|;
block|{
name|rtx
name|newexp
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Find the bit.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|mask
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
operator|)
operator|==
literal|0
condition|;
name|i
operator|++
control|)
empty_stmt|;
name|newexp
operator|=
name|attr_rtx
argument_list|(
name|EQ_ATTR
argument_list|,
name|alternative_name
argument_list|,
name|attr_numeral
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|newexp
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|newexp
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* If we are processing an (eq_attr "attr" "value") test, we find the value    of "attr" for this insn code.  From that value, we can compute a test    showing when the EQ_ATTR will be true.  This routine performs that    computation.  If a test condition involves an address, we leave the EQ_ATTR    intact because addresses are only valid for the `length' attribute.  */
end_comment

begin_comment
comment|/* ??? Kenner, document the meanings of the arguments!!!  */
end_comment

begin_function
specifier|static
name|rtx
name|evaluate_eq_attr
parameter_list|(
name|exp
parameter_list|,
name|value
parameter_list|,
name|insn_code
parameter_list|,
name|insn_index
parameter_list|)
name|rtx
name|exp
decl_stmt|;
name|rtx
name|value
decl_stmt|;
name|int
name|insn_code
decl_stmt|,
name|insn_index
decl_stmt|;
block|{
name|rtx
name|orexp
decl_stmt|,
name|andexp
decl_stmt|;
name|rtx
name|right
decl_stmt|;
name|rtx
name|newexp
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|CONST_STRING
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|XSTR
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
name|newexp
operator|=
name|true_rtx
expr_stmt|;
else|else
name|newexp
operator|=
name|false_rtx
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|COND
condition|)
block|{
comment|/* We construct an IOR of all the cases for which the requested attribute 	 value is present.  Since we start with FALSE, if it is not present, 	 FALSE will be returned.  	 Each case is the AND of the NOT's of the previous conditions with the 	 current condition; in the default case the current condition is TRUE.   	 For each possible COND value, call ourselves recursively.  	 The extra TRUE and FALSE expressions will be eliminated by another 	 call to the simplification routine. */
name|orexp
operator|=
name|false_rtx
expr_stmt|;
name|andexp
operator|=
name|true_rtx
expr_stmt|;
if|if
condition|(
name|current_alternative_string
condition|)
name|clear_struct_flag
argument_list|(
name|value
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|+=
literal|2
control|)
block|{
name|rtx
name|this
init|=
name|SIMPLIFY_TEST_EXP
argument_list|(
name|XVECEXP
argument_list|(
name|value
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
name|insn_code
argument_list|,
name|insn_index
argument_list|)
decl_stmt|;
name|SIMPLIFY_ALTERNATIVE
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|right
operator|=
name|insert_right_side
argument_list|(
name|AND
argument_list|,
name|andexp
argument_list|,
name|this
argument_list|,
name|insn_code
argument_list|,
name|insn_index
argument_list|)
expr_stmt|;
name|right
operator|=
name|insert_right_side
argument_list|(
name|AND
argument_list|,
name|right
argument_list|,
name|evaluate_eq_attr
argument_list|(
name|exp
argument_list|,
name|XVECEXP
argument_list|(
name|value
argument_list|,
literal|0
argument_list|,
name|i
operator|+
literal|1
argument_list|)
argument_list|,
name|insn_code
argument_list|,
name|insn_index
argument_list|)
argument_list|,
name|insn_code
argument_list|,
name|insn_index
argument_list|)
expr_stmt|;
name|orexp
operator|=
name|insert_right_side
argument_list|(
name|IOR
argument_list|,
name|orexp
argument_list|,
name|right
argument_list|,
name|insn_code
argument_list|,
name|insn_index
argument_list|)
expr_stmt|;
comment|/* Add this condition into the AND expression.  */
name|newexp
operator|=
name|attr_rtx
argument_list|(
name|NOT
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|andexp
operator|=
name|insert_right_side
argument_list|(
name|AND
argument_list|,
name|andexp
argument_list|,
name|newexp
argument_list|,
name|insn_code
argument_list|,
name|insn_index
argument_list|)
expr_stmt|;
block|}
comment|/* Handle the default case.  */
name|right
operator|=
name|insert_right_side
argument_list|(
name|AND
argument_list|,
name|andexp
argument_list|,
name|evaluate_eq_attr
argument_list|(
name|exp
argument_list|,
name|XEXP
argument_list|(
name|value
argument_list|,
literal|1
argument_list|)
argument_list|,
name|insn_code
argument_list|,
name|insn_index
argument_list|)
argument_list|,
name|insn_code
argument_list|,
name|insn_index
argument_list|)
expr_stmt|;
name|newexp
operator|=
name|insert_right_side
argument_list|(
name|IOR
argument_list|,
name|orexp
argument_list|,
name|right
argument_list|,
name|insn_code
argument_list|,
name|insn_index
argument_list|)
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
comment|/* If uses an address, must return original expression.  But set the      RTX_UNCHANGING_P bit so we don't try to simplify it again.  */
name|address_used
operator|=
literal|0
expr_stmt|;
name|walk_attr_value
argument_list|(
name|newexp
argument_list|)
expr_stmt|;
if|if
condition|(
name|address_used
condition|)
block|{
comment|/* This had `&& current_alternative_string', which seems to be wrong.  */
if|if
condition|(
operator|!
name|RTX_UNCHANGING_P
argument_list|(
name|exp
argument_list|)
condition|)
return|return
name|copy_rtx_unchanging
argument_list|(
name|exp
argument_list|)
return|;
return|return
name|exp
return|;
block|}
else|else
return|return
name|newexp
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This routine is called when an AND of a term with a tree of AND's is    encountered.  If the term or its complement is present in the tree, it    can be replaced with TRUE or FALSE, respectively.     Note that (eq_attr "att" "v1") and (eq_attr "att" "v2") cannot both    be true and hence are complementary.       There is one special case:  If we see 	(and (not (eq_attr "att" "v1")) 	     (eq_attr "att" "v2"))    this can be replaced by (eq_attr "att" "v2").  To do this we need to    replace the term, not anything in the AND tree.  So we pass a pointer to    the term.  */
end_comment

begin_function
specifier|static
name|rtx
name|simplify_and_tree
parameter_list|(
name|exp
parameter_list|,
name|pterm
parameter_list|,
name|insn_code
parameter_list|,
name|insn_index
parameter_list|)
name|rtx
name|exp
decl_stmt|;
name|rtx
modifier|*
name|pterm
decl_stmt|;
name|int
name|insn_code
decl_stmt|,
name|insn_index
decl_stmt|;
block|{
name|rtx
name|left
decl_stmt|,
name|right
decl_stmt|;
name|rtx
name|newexp
decl_stmt|;
name|rtx
name|temp
decl_stmt|;
name|int
name|left_eliminates_term
decl_stmt|,
name|right_eliminates_term
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|AND
condition|)
block|{
name|left
operator|=
name|simplify_and_tree
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|pterm
argument_list|,
name|insn_code
argument_list|,
name|insn_index
argument_list|)
expr_stmt|;
name|right
operator|=
name|simplify_and_tree
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|pterm
argument_list|,
name|insn_code
argument_list|,
name|insn_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|left
operator|!=
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
operator|||
name|right
operator|!=
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|newexp
operator|=
name|attr_rtx
argument_list|(
name|GET_CODE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
expr_stmt|;
name|exp
operator|=
name|SIMPLIFY_TEST_EXP
argument_list|(
name|newexp
argument_list|,
name|insn_code
argument_list|,
name|insn_index
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|IOR
condition|)
block|{
comment|/* For the IOR case, we do the same as above, except that we can          only eliminate `term' if both sides of the IOR would do so.  */
name|temp
operator|=
operator|*
name|pterm
expr_stmt|;
name|left
operator|=
name|simplify_and_tree
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|temp
argument_list|,
name|insn_code
argument_list|,
name|insn_index
argument_list|)
expr_stmt|;
name|left_eliminates_term
operator|=
operator|(
name|temp
operator|==
name|true_rtx
operator|)
expr_stmt|;
name|temp
operator|=
operator|*
name|pterm
expr_stmt|;
name|right
operator|=
name|simplify_and_tree
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
operator|&
name|temp
argument_list|,
name|insn_code
argument_list|,
name|insn_index
argument_list|)
expr_stmt|;
name|right_eliminates_term
operator|=
operator|(
name|temp
operator|==
name|true_rtx
operator|)
expr_stmt|;
if|if
condition|(
name|left_eliminates_term
operator|&&
name|right_eliminates_term
condition|)
operator|*
name|pterm
operator|=
name|true_rtx
expr_stmt|;
if|if
condition|(
name|left
operator|!=
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
operator|||
name|right
operator|!=
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|newexp
operator|=
name|attr_rtx
argument_list|(
name|GET_CODE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
expr_stmt|;
name|exp
operator|=
name|SIMPLIFY_TEST_EXP
argument_list|(
name|newexp
argument_list|,
name|insn_code
argument_list|,
name|insn_index
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Check for simplifications.  Do some extra checking here since this      routine is called so many times.  */
if|if
condition|(
name|exp
operator|==
operator|*
name|pterm
condition|)
return|return
name|true_rtx
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|NOT
operator|&&
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
operator|==
operator|*
name|pterm
condition|)
return|return
name|false_rtx
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
operator|*
name|pterm
argument_list|)
operator|==
name|NOT
operator|&&
name|exp
operator|==
name|XEXP
argument_list|(
operator|*
name|pterm
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|false_rtx
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|EQ_ATTR
operator|&&
name|GET_CODE
argument_list|(
operator|*
name|pterm
argument_list|)
operator|==
name|EQ_ATTR
condition|)
block|{
if|if
condition|(
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
operator|!=
name|XSTR
argument_list|(
operator|*
name|pterm
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|exp
return|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|XSTR
argument_list|(
operator|*
name|pterm
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
return|return
name|true_rtx
return|;
else|else
return|return
name|false_rtx
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
operator|*
name|pterm
argument_list|)
operator|==
name|EQ_ATTR
operator|&&
name|GET_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|NOT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|EQ_ATTR
condition|)
block|{
if|if
condition|(
name|XSTR
argument_list|(
operator|*
name|pterm
argument_list|,
literal|0
argument_list|)
operator|!=
name|XSTR
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|exp
return|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|XSTR
argument_list|(
operator|*
name|pterm
argument_list|,
literal|1
argument_list|)
argument_list|,
name|XSTR
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
return|return
name|false_rtx
return|;
else|else
return|return
name|true_rtx
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|EQ_ATTR
operator|&&
name|GET_CODE
argument_list|(
operator|*
name|pterm
argument_list|)
operator|==
name|NOT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
operator|*
name|pterm
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|EQ_ATTR
condition|)
block|{
if|if
condition|(
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
operator|!=
name|XSTR
argument_list|(
name|XEXP
argument_list|(
operator|*
name|pterm
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|exp
return|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|XSTR
argument_list|(
name|XEXP
argument_list|(
operator|*
name|pterm
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
return|return
name|false_rtx
return|;
else|else
operator|*
name|pterm
operator|=
name|true_rtx
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|NOT
operator|&&
name|GET_CODE
argument_list|(
operator|*
name|pterm
argument_list|)
operator|==
name|NOT
condition|)
block|{
if|if
condition|(
name|attr_equal_p
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
operator|*
name|pterm
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
name|true_rtx
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|NOT
condition|)
block|{
if|if
condition|(
name|attr_equal_p
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|*
name|pterm
argument_list|)
condition|)
return|return
name|false_rtx
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
operator|*
name|pterm
argument_list|)
operator|==
name|NOT
condition|)
block|{
if|if
condition|(
name|attr_equal_p
argument_list|(
name|XEXP
argument_list|(
operator|*
name|pterm
argument_list|,
literal|0
argument_list|)
argument_list|,
name|exp
argument_list|)
condition|)
return|return
name|false_rtx
return|;
block|}
elseif|else
if|if
condition|(
name|attr_equal_p
argument_list|(
name|exp
argument_list|,
operator|*
name|pterm
argument_list|)
condition|)
return|return
name|true_rtx
return|;
return|return
name|exp
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Similar to `simplify_and_tree', but for IOR trees.  */
end_comment

begin_function
specifier|static
name|rtx
name|simplify_or_tree
parameter_list|(
name|exp
parameter_list|,
name|pterm
parameter_list|,
name|insn_code
parameter_list|,
name|insn_index
parameter_list|)
name|rtx
name|exp
decl_stmt|;
name|rtx
modifier|*
name|pterm
decl_stmt|;
name|int
name|insn_code
decl_stmt|,
name|insn_index
decl_stmt|;
block|{
name|rtx
name|left
decl_stmt|,
name|right
decl_stmt|;
name|rtx
name|newexp
decl_stmt|;
name|rtx
name|temp
decl_stmt|;
name|int
name|left_eliminates_term
decl_stmt|,
name|right_eliminates_term
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|IOR
condition|)
block|{
name|left
operator|=
name|simplify_or_tree
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|pterm
argument_list|,
name|insn_code
argument_list|,
name|insn_index
argument_list|)
expr_stmt|;
name|right
operator|=
name|simplify_or_tree
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|pterm
argument_list|,
name|insn_code
argument_list|,
name|insn_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|left
operator|!=
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
operator|||
name|right
operator|!=
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|newexp
operator|=
name|attr_rtx
argument_list|(
name|GET_CODE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
expr_stmt|;
name|exp
operator|=
name|SIMPLIFY_TEST_EXP
argument_list|(
name|newexp
argument_list|,
name|insn_code
argument_list|,
name|insn_index
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|AND
condition|)
block|{
comment|/* For the AND case, we do the same as above, except that we can          only eliminate `term' if both sides of the AND would do so.  */
name|temp
operator|=
operator|*
name|pterm
expr_stmt|;
name|left
operator|=
name|simplify_or_tree
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|temp
argument_list|,
name|insn_code
argument_list|,
name|insn_index
argument_list|)
expr_stmt|;
name|left_eliminates_term
operator|=
operator|(
name|temp
operator|==
name|false_rtx
operator|)
expr_stmt|;
name|temp
operator|=
operator|*
name|pterm
expr_stmt|;
name|right
operator|=
name|simplify_or_tree
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
operator|&
name|temp
argument_list|,
name|insn_code
argument_list|,
name|insn_index
argument_list|)
expr_stmt|;
name|right_eliminates_term
operator|=
operator|(
name|temp
operator|==
name|false_rtx
operator|)
expr_stmt|;
if|if
condition|(
name|left_eliminates_term
operator|&&
name|right_eliminates_term
condition|)
operator|*
name|pterm
operator|=
name|false_rtx
expr_stmt|;
if|if
condition|(
name|left
operator|!=
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
operator|||
name|right
operator|!=
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|newexp
operator|=
name|attr_rtx
argument_list|(
name|GET_CODE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
expr_stmt|;
name|exp
operator|=
name|SIMPLIFY_TEST_EXP
argument_list|(
name|newexp
argument_list|,
name|insn_code
argument_list|,
name|insn_index
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|attr_equal_p
argument_list|(
name|exp
argument_list|,
operator|*
name|pterm
argument_list|)
condition|)
return|return
name|false_rtx
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|NOT
operator|&&
name|attr_equal_p
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|*
name|pterm
argument_list|)
condition|)
return|return
name|true_rtx
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
operator|*
name|pterm
argument_list|)
operator|==
name|NOT
operator|&&
name|attr_equal_p
argument_list|(
name|XEXP
argument_list|(
operator|*
name|pterm
argument_list|,
literal|0
argument_list|)
argument_list|,
name|exp
argument_list|)
condition|)
return|return
name|true_rtx
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
operator|*
name|pterm
argument_list|)
operator|==
name|EQ_ATTR
operator|&&
name|GET_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|NOT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|EQ_ATTR
operator|&&
name|XSTR
argument_list|(
operator|*
name|pterm
argument_list|,
literal|0
argument_list|)
operator|==
name|XSTR
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
operator|*
name|pterm
operator|=
name|false_rtx
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|EQ_ATTR
operator|&&
name|GET_CODE
argument_list|(
operator|*
name|pterm
argument_list|)
operator|==
name|NOT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
operator|*
name|pterm
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|EQ_ATTR
operator|&&
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
operator|==
name|XSTR
argument_list|(
name|XEXP
argument_list|(
operator|*
name|pterm
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|false_rtx
return|;
return|return
name|exp
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given an expression, see if it can be simplified for a particular insn    code based on the values of other attributes being tested.  This can    eliminate nested get_attr_... calls.     Note that if an endless recursion is specified in the patterns, the     optimization will loop.  However, it will do so in precisely the cases where    an infinite recursion loop could occur during compilation.  It's better that    it occurs here!  */
end_comment

begin_function
specifier|static
name|rtx
name|simplify_test_exp
parameter_list|(
name|exp
parameter_list|,
name|insn_code
parameter_list|,
name|insn_index
parameter_list|)
name|rtx
name|exp
decl_stmt|;
name|int
name|insn_code
decl_stmt|,
name|insn_index
decl_stmt|;
block|{
name|rtx
name|left
decl_stmt|,
name|right
decl_stmt|;
name|struct
name|attr_desc
modifier|*
name|attr
decl_stmt|;
name|struct
name|attr_value
modifier|*
name|av
decl_stmt|;
name|struct
name|insn_ent
modifier|*
name|ie
decl_stmt|;
name|int
name|i
decl_stmt|;
name|rtx
name|newexp
init|=
name|exp
decl_stmt|;
name|char
modifier|*
name|spacer
init|=
operator|(
name|char
operator|*
operator|)
name|obstack_finish
argument_list|(
name|rtl_obstack
argument_list|)
decl_stmt|;
specifier|static
name|rtx
name|loser
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|count
init|=
literal|0
decl_stmt|;
specifier|static
name|stopcount
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|exp
operator|==
name|loser
condition|)
name|do_nothing
argument_list|()
expr_stmt|;
name|count
operator|++
expr_stmt|;
if|if
condition|(
name|count
operator|==
name|stopcount
condition|)
name|do_nothing
argument_list|()
expr_stmt|;
comment|/* Don't re-simplify something we already simplified.  */
if|if
condition|(
name|RTX_UNCHANGING_P
argument_list|(
name|exp
argument_list|)
operator|||
name|MEM_IN_STRUCT_P
argument_list|(
name|exp
argument_list|)
condition|)
return|return
name|exp
return|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|exp
argument_list|)
condition|)
block|{
case|case
name|AND
case|:
name|left
operator|=
name|SIMPLIFY_TEST_EXP
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|insn_code
argument_list|,
name|insn_index
argument_list|)
expr_stmt|;
name|SIMPLIFY_ALTERNATIVE
argument_list|(
name|left
argument_list|)
expr_stmt|;
if|if
condition|(
name|left
operator|==
name|false_rtx
condition|)
block|{
name|obstack_free
argument_list|(
name|rtl_obstack
argument_list|,
name|spacer
argument_list|)
expr_stmt|;
return|return
name|false_rtx
return|;
block|}
name|right
operator|=
name|SIMPLIFY_TEST_EXP
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|insn_code
argument_list|,
name|insn_index
argument_list|)
expr_stmt|;
name|SIMPLIFY_ALTERNATIVE
argument_list|(
name|right
argument_list|)
expr_stmt|;
if|if
condition|(
name|left
operator|==
name|false_rtx
condition|)
block|{
name|obstack_free
argument_list|(
name|rtl_obstack
argument_list|,
name|spacer
argument_list|)
expr_stmt|;
return|return
name|false_rtx
return|;
block|}
comment|/* If either side is an IOR and we have (eq_attr "alternative" ..") 	 present on both sides, apply the distributive law since this will 	 yield simplifications.  */
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|left
argument_list|)
operator|==
name|IOR
operator|||
name|GET_CODE
argument_list|(
name|right
argument_list|)
operator|==
name|IOR
operator|)
operator|&&
name|compute_alternative_mask
argument_list|(
name|left
argument_list|,
name|IOR
argument_list|)
operator|&&
name|compute_alternative_mask
argument_list|(
name|right
argument_list|,
name|IOR
argument_list|)
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|left
argument_list|)
operator|==
name|IOR
condition|)
block|{
name|rtx
name|tem
init|=
name|left
decl_stmt|;
name|left
operator|=
name|right
expr_stmt|;
name|right
operator|=
name|tem
expr_stmt|;
block|}
name|newexp
operator|=
name|attr_rtx
argument_list|(
name|IOR
argument_list|,
name|attr_rtx
argument_list|(
name|AND
argument_list|,
name|left
argument_list|,
name|XEXP
argument_list|(
name|right
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|attr_rtx
argument_list|(
name|AND
argument_list|,
name|left
argument_list|,
name|XEXP
argument_list|(
name|right
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SIMPLIFY_TEST_EXP
argument_list|(
name|newexp
argument_list|,
name|insn_code
argument_list|,
name|insn_index
argument_list|)
return|;
block|}
comment|/* Try with the term on both sides.  */
name|right
operator|=
name|simplify_and_tree
argument_list|(
name|right
argument_list|,
operator|&
name|left
argument_list|,
name|insn_code
argument_list|,
name|insn_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|left
operator|==
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
operator|&&
name|right
operator|==
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
condition|)
name|left
operator|=
name|simplify_and_tree
argument_list|(
name|left
argument_list|,
operator|&
name|right
argument_list|,
name|insn_code
argument_list|,
name|insn_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|left
operator|==
name|false_rtx
operator|||
name|right
operator|==
name|false_rtx
condition|)
block|{
name|obstack_free
argument_list|(
name|rtl_obstack
argument_list|,
name|spacer
argument_list|)
expr_stmt|;
return|return
name|false_rtx
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|==
name|true_rtx
condition|)
block|{
return|return
name|right
return|;
block|}
elseif|else
if|if
condition|(
name|right
operator|==
name|true_rtx
condition|)
block|{
return|return
name|left
return|;
block|}
comment|/* See if all or all but one of the insn's alternatives are specified 	 in this tree.  Optimize if so.  */
elseif|else
if|if
condition|(
name|insn_code
operator|>=
literal|0
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|left
argument_list|)
operator|==
name|AND
operator|||
operator|(
name|GET_CODE
argument_list|(
name|left
argument_list|)
operator|==
name|NOT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|left
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|EQ_ATTR
operator|&&
name|XSTR
argument_list|(
name|XEXP
argument_list|(
name|left
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|alternative_name
operator|)
operator|||
name|GET_CODE
argument_list|(
name|right
argument_list|)
operator|==
name|AND
operator|||
operator|(
name|GET_CODE
argument_list|(
name|right
argument_list|)
operator|==
name|NOT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|right
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|EQ_ATTR
operator|&&
name|XSTR
argument_list|(
name|XEXP
argument_list|(
name|right
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|alternative_name
operator|)
operator|)
condition|)
block|{
name|i
operator|=
name|compute_alternative_mask
argument_list|(
name|exp
argument_list|,
name|AND
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|&
operator|~
name|insn_alternatives
index|[
name|insn_code
index|]
condition|)
name|fatal
argument_list|(
literal|"Illegal alternative specified for pattern number %d"
argument_list|,
name|insn_index
argument_list|)
expr_stmt|;
comment|/* If all alternatives are excluded, this is false. */
name|i
operator|^=
name|insn_alternatives
index|[
name|insn_code
index|]
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
return|return
name|false_rtx
return|;
elseif|else
if|if
condition|(
operator|(
name|i
operator|&
operator|(
name|i
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
operator|&&
name|insn_alternatives
index|[
name|insn_code
index|]
operator|>
literal|1
condition|)
block|{
comment|/* If just one excluded, AND a comparison with that one to the 		 front of the tree.  The others will be eliminated by 		 optimization.  We do not want to do this if the insn has one 		 alternative and we have tested none of them!  */
name|left
operator|=
name|make_alternative_compare
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|right
operator|=
name|simplify_and_tree
argument_list|(
name|exp
argument_list|,
operator|&
name|left
argument_list|,
name|insn_code
argument_list|,
name|insn_index
argument_list|)
expr_stmt|;
name|newexp
operator|=
name|attr_rtx
argument_list|(
name|AND
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
expr_stmt|;
return|return
name|SIMPLIFY_TEST_EXP
argument_list|(
name|newexp
argument_list|,
name|insn_code
argument_list|,
name|insn_index
argument_list|)
return|;
block|}
block|}
if|if
condition|(
name|left
operator|!=
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
operator|||
name|right
operator|!=
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|newexp
operator|=
name|attr_rtx
argument_list|(
name|AND
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
expr_stmt|;
return|return
name|SIMPLIFY_TEST_EXP
argument_list|(
name|newexp
argument_list|,
name|insn_code
argument_list|,
name|insn_index
argument_list|)
return|;
block|}
break|break;
case|case
name|IOR
case|:
name|left
operator|=
name|SIMPLIFY_TEST_EXP
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|insn_code
argument_list|,
name|insn_index
argument_list|)
expr_stmt|;
name|SIMPLIFY_ALTERNATIVE
argument_list|(
name|left
argument_list|)
expr_stmt|;
if|if
condition|(
name|left
operator|==
name|true_rtx
condition|)
block|{
name|obstack_free
argument_list|(
name|rtl_obstack
argument_list|,
name|spacer
argument_list|)
expr_stmt|;
return|return
name|true_rtx
return|;
block|}
name|right
operator|=
name|SIMPLIFY_TEST_EXP
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|insn_code
argument_list|,
name|insn_index
argument_list|)
expr_stmt|;
name|SIMPLIFY_ALTERNATIVE
argument_list|(
name|right
argument_list|)
expr_stmt|;
if|if
condition|(
name|right
operator|==
name|true_rtx
condition|)
block|{
name|obstack_free
argument_list|(
name|rtl_obstack
argument_list|,
name|spacer
argument_list|)
expr_stmt|;
return|return
name|true_rtx
return|;
block|}
name|right
operator|=
name|simplify_or_tree
argument_list|(
name|right
argument_list|,
operator|&
name|left
argument_list|,
name|insn_code
argument_list|,
name|insn_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|left
operator|==
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
operator|&&
name|right
operator|==
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
condition|)
name|left
operator|=
name|simplify_or_tree
argument_list|(
name|left
argument_list|,
operator|&
name|right
argument_list|,
name|insn_code
argument_list|,
name|insn_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|right
operator|==
name|true_rtx
operator|||
name|left
operator|==
name|true_rtx
condition|)
block|{
name|obstack_free
argument_list|(
name|rtl_obstack
argument_list|,
name|spacer
argument_list|)
expr_stmt|;
return|return
name|true_rtx
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|==
name|false_rtx
condition|)
block|{
return|return
name|right
return|;
block|}
elseif|else
if|if
condition|(
name|right
operator|==
name|false_rtx
condition|)
block|{
return|return
name|left
return|;
block|}
comment|/* Test for simple cases where the distributive law is useful.  I.e., 	    convert (ior (and (x) (y)) 			 (and (x) (z))) 	    to      (and (x) 			 (ior (y) (z)))        */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|left
argument_list|)
operator|==
name|AND
operator|&&
name|GET_CODE
argument_list|(
name|right
argument_list|)
operator|==
name|AND
operator|&&
name|attr_equal_p
argument_list|(
name|XEXP
argument_list|(
name|left
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|right
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|newexp
operator|=
name|attr_rtx
argument_list|(
name|IOR
argument_list|,
name|XEXP
argument_list|(
name|left
argument_list|,
literal|1
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|right
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|left
operator|=
name|XEXP
argument_list|(
name|left
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|right
operator|=
name|newexp
expr_stmt|;
name|newexp
operator|=
name|attr_rtx
argument_list|(
name|AND
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
expr_stmt|;
return|return
name|SIMPLIFY_TEST_EXP
argument_list|(
name|newexp
argument_list|,
name|insn_code
argument_list|,
name|insn_index
argument_list|)
return|;
block|}
comment|/* See if all or all but one of the insn's alternatives are specified 	 in this tree.  Optimize if so.  */
elseif|else
if|if
condition|(
name|insn_code
operator|>=
literal|0
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|left
argument_list|)
operator|==
name|IOR
operator|||
operator|(
name|GET_CODE
argument_list|(
name|left
argument_list|)
operator|==
name|EQ_ATTR
operator|&&
name|XSTR
argument_list|(
name|left
argument_list|,
literal|0
argument_list|)
operator|==
name|alternative_name
operator|)
operator|||
name|GET_CODE
argument_list|(
name|right
argument_list|)
operator|==
name|IOR
operator|||
operator|(
name|GET_CODE
argument_list|(
name|right
argument_list|)
operator|==
name|EQ_ATTR
operator|&&
name|XSTR
argument_list|(
name|right
argument_list|,
literal|0
argument_list|)
operator|==
name|alternative_name
operator|)
operator|)
condition|)
block|{
name|i
operator|=
name|compute_alternative_mask
argument_list|(
name|exp
argument_list|,
name|IOR
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|&
operator|~
name|insn_alternatives
index|[
name|insn_code
index|]
condition|)
name|fatal
argument_list|(
literal|"Illegal alternative specified for pattern number %d"
argument_list|,
name|insn_index
argument_list|)
expr_stmt|;
comment|/* If all alternatives are included, this is true. */
name|i
operator|^=
name|insn_alternatives
index|[
name|insn_code
index|]
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
return|return
name|true_rtx
return|;
elseif|else
if|if
condition|(
operator|(
name|i
operator|&
operator|(
name|i
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
operator|&&
name|insn_alternatives
index|[
name|insn_code
index|]
operator|>
literal|1
condition|)
block|{
comment|/* If just one excluded, IOR a comparison with that one to the 		 front of the tree.  The others will be eliminated by 		 optimization.  We do not want to do this if the insn has one 		 alternative and we have tested none of them!  */
name|left
operator|=
name|make_alternative_compare
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|right
operator|=
name|simplify_and_tree
argument_list|(
name|exp
argument_list|,
operator|&
name|left
argument_list|,
name|insn_code
argument_list|,
name|insn_index
argument_list|)
expr_stmt|;
name|newexp
operator|=
name|attr_rtx
argument_list|(
name|IOR
argument_list|,
name|attr_rtx
argument_list|(
name|NOT
argument_list|,
name|left
argument_list|)
argument_list|,
name|right
argument_list|)
expr_stmt|;
return|return
name|SIMPLIFY_TEST_EXP
argument_list|(
name|newexp
argument_list|,
name|insn_code
argument_list|,
name|insn_index
argument_list|)
return|;
block|}
block|}
if|if
condition|(
name|left
operator|!=
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
operator|||
name|right
operator|!=
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|newexp
operator|=
name|attr_rtx
argument_list|(
name|IOR
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
expr_stmt|;
return|return
name|SIMPLIFY_TEST_EXP
argument_list|(
name|newexp
argument_list|,
name|insn_code
argument_list|,
name|insn_index
argument_list|)
return|;
block|}
break|break;
case|case
name|NOT
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|NOT
condition|)
block|{
name|left
operator|=
name|SIMPLIFY_TEST_EXP
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|insn_code
argument_list|,
name|insn_index
argument_list|)
expr_stmt|;
name|SIMPLIFY_ALTERNATIVE
argument_list|(
name|left
argument_list|)
expr_stmt|;
return|return
name|left
return|;
block|}
name|left
operator|=
name|SIMPLIFY_TEST_EXP
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|insn_code
argument_list|,
name|insn_index
argument_list|)
expr_stmt|;
name|SIMPLIFY_ALTERNATIVE
argument_list|(
name|left
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|left
argument_list|)
operator|==
name|NOT
condition|)
return|return
name|XEXP
argument_list|(
name|left
argument_list|,
literal|0
argument_list|)
return|;
if|if
condition|(
name|left
operator|==
name|false_rtx
condition|)
block|{
name|obstack_free
argument_list|(
name|rtl_obstack
argument_list|,
name|spacer
argument_list|)
expr_stmt|;
return|return
name|true_rtx
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|==
name|true_rtx
condition|)
block|{
name|obstack_free
argument_list|(
name|rtl_obstack
argument_list|,
name|spacer
argument_list|)
expr_stmt|;
return|return
name|false_rtx
return|;
block|}
comment|/* Try to apply De`Morgan's laws.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|left
argument_list|)
operator|==
name|IOR
condition|)
block|{
name|newexp
operator|=
name|attr_rtx
argument_list|(
name|AND
argument_list|,
name|attr_rtx
argument_list|(
name|NOT
argument_list|,
name|XEXP
argument_list|(
name|left
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|attr_rtx
argument_list|(
name|NOT
argument_list|,
name|XEXP
argument_list|(
name|left
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|newexp
operator|=
name|SIMPLIFY_TEST_EXP
argument_list|(
name|newexp
argument_list|,
name|insn_code
argument_list|,
name|insn_index
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|left
argument_list|)
operator|==
name|AND
condition|)
block|{
name|newexp
operator|=
name|attr_rtx
argument_list|(
name|IOR
argument_list|,
name|attr_rtx
argument_list|(
name|NOT
argument_list|,
name|XEXP
argument_list|(
name|left
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|attr_rtx
argument_list|(
name|NOT
argument_list|,
name|XEXP
argument_list|(
name|left
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|newexp
operator|=
name|SIMPLIFY_TEST_EXP
argument_list|(
name|newexp
argument_list|,
name|insn_code
argument_list|,
name|insn_index
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|left
operator|!=
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|newexp
operator|=
name|attr_rtx
argument_list|(
name|NOT
argument_list|,
name|left
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|EQ_ATTR
case|:
if|if
condition|(
name|current_alternative_string
operator|&&
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
operator|==
name|alternative_name
condition|)
return|return
operator|(
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
operator|==
name|current_alternative_string
condition|?
name|true_rtx
else|:
name|false_rtx
operator|)
return|;
comment|/* Look at the value for this insn code in the specified attribute. 	 We normally can replace this comparison with the condition that 	 would give this insn the values being tested for.   */
if|if
condition|(
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
operator|!=
name|alternative_name
operator|&&
operator|(
name|attr
operator|=
name|find_attr
argument_list|(
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
for|for
control|(
name|av
operator|=
name|attr
operator|->
name|first_value
init|;
name|av
condition|;
name|av
operator|=
name|av
operator|->
name|next
control|)
for|for
control|(
name|ie
operator|=
name|av
operator|->
name|first_insn
init|;
name|ie
condition|;
name|ie
operator|=
name|ie
operator|->
name|next
control|)
if|if
condition|(
name|ie
operator|->
name|insn_code
operator|==
name|insn_code
condition|)
return|return
name|evaluate_eq_attr
argument_list|(
name|exp
argument_list|,
name|av
operator|->
name|value
argument_list|,
name|insn_code
argument_list|,
name|insn_index
argument_list|)
return|;
block|}
comment|/* We have already simplified this expression.  Simplifying it again      won't buy anything unless we weren't given a valid insn code      to process (i.e., we are canonicalizing something.).  */
if|if
condition|(
name|insn_code
operator|!=
operator|-
literal|2
comment|/* Seems wrong:&& current_alternative_string.  */
operator|&&
operator|!
name|RTX_UNCHANGING_P
argument_list|(
name|newexp
argument_list|)
condition|)
return|return
name|copy_rtx_unchanging
argument_list|(
name|newexp
argument_list|)
return|;
return|return
name|newexp
return|;
block|}
end_function

begin_macro
name|do_nothing
argument_list|()
end_macro

begin_block
block|{}
end_block

begin_escape
end_escape

begin_comment
comment|/* Optimize the attribute lists by seeing if we can determine conditional    values from the known values of other attributes.  This will save subroutine    calls during the compilation.  */
end_comment

begin_function
specifier|static
name|void
name|optimize_attrs
parameter_list|()
block|{
name|struct
name|attr_desc
modifier|*
name|attr
decl_stmt|;
name|struct
name|attr_value
modifier|*
name|av
decl_stmt|;
name|struct
name|insn_ent
modifier|*
name|ie
decl_stmt|;
name|rtx
name|newexp
decl_stmt|;
name|int
name|something_changed
init|=
literal|1
decl_stmt|;
name|int
name|i
decl_stmt|;
struct|struct
name|attr_value_list
block|{
name|struct
name|attr_value
modifier|*
name|av
decl_stmt|;
name|struct
name|insn_ent
modifier|*
name|ie
decl_stmt|;
name|struct
name|attr_desc
modifier|*
name|attr
decl_stmt|;
name|struct
name|attr_value_list
modifier|*
name|next
decl_stmt|;
block|}
struct|;
name|struct
name|attr_value_list
modifier|*
modifier|*
name|insn_code_values
decl_stmt|;
name|struct
name|attr_value_list
modifier|*
name|iv
decl_stmt|;
comment|/* For each insn code, make a list of all the insn_ent's for it,      for all values for all attributes.  */
comment|/* Make 2 extra elements, for "code" values -2 and -1.  */
name|insn_code_values
operator|=
operator|(
expr|struct
name|attr_value_list
operator|*
operator|*
operator|)
name|alloca
argument_list|(
operator|(
name|insn_code_number
operator|+
literal|2
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|attr_value_list
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|insn_code_values
argument_list|,
operator|(
name|insn_code_number
operator|+
literal|2
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|attr_value_list
operator|*
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Offset the table address so we can index by -2 or -1.  */
name|insn_code_values
operator|+=
literal|2
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_ATTRS_INDEX
condition|;
name|i
operator|++
control|)
for|for
control|(
name|attr
operator|=
name|attrs
index|[
name|i
index|]
init|;
name|attr
condition|;
name|attr
operator|=
name|attr
operator|->
name|next
control|)
for|for
control|(
name|av
operator|=
name|attr
operator|->
name|first_value
init|;
name|av
condition|;
name|av
operator|=
name|av
operator|->
name|next
control|)
for|for
control|(
name|ie
operator|=
name|av
operator|->
name|first_insn
init|;
name|ie
condition|;
name|ie
operator|=
name|ie
operator|->
name|next
control|)
block|{
name|iv
operator|=
operator|(
operator|(
expr|struct
name|attr_value_list
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|attr_value_list
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|iv
operator|->
name|attr
operator|=
name|attr
expr_stmt|;
name|iv
operator|->
name|av
operator|=
name|av
expr_stmt|;
name|iv
operator|->
name|ie
operator|=
name|ie
expr_stmt|;
name|iv
operator|->
name|next
operator|=
name|insn_code_values
index|[
name|ie
operator|->
name|insn_code
index|]
expr_stmt|;
name|insn_code_values
index|[
name|ie
operator|->
name|insn_code
index|]
operator|=
name|iv
expr_stmt|;
block|}
comment|/* Process one insn code at a time.  */
for|for
control|(
name|i
operator|=
operator|-
literal|2
init|;
name|i
operator|<
name|insn_code_number
condition|;
name|i
operator|++
control|)
block|{
comment|/* Clear the MEM_IN_STRUCT_P flag everywhere relevant. 	 We use it to mean "already simplified for this insn".  */
for|for
control|(
name|iv
operator|=
name|insn_code_values
index|[
name|i
index|]
init|;
name|iv
condition|;
name|iv
operator|=
name|iv
operator|->
name|next
control|)
name|clear_struct_flag
argument_list|(
name|iv
operator|->
name|av
operator|->
name|value
argument_list|)
expr_stmt|;
comment|/* Loop until nothing changes for one iteration.  */
name|something_changed
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|something_changed
condition|)
block|{
name|something_changed
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|iv
operator|=
name|insn_code_values
index|[
name|i
index|]
init|;
name|iv
condition|;
name|iv
operator|=
name|iv
operator|->
name|next
control|)
block|{
name|struct
name|obstack
modifier|*
name|old
init|=
name|rtl_obstack
decl_stmt|;
name|char
modifier|*
name|spacer
init|=
operator|(
name|char
operator|*
operator|)
name|obstack_finish
argument_list|(
name|temp_obstack
argument_list|)
decl_stmt|;
name|attr
operator|=
name|iv
operator|->
name|attr
expr_stmt|;
name|av
operator|=
name|iv
operator|->
name|av
expr_stmt|;
name|ie
operator|=
name|iv
operator|->
name|ie
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|av
operator|->
name|value
argument_list|)
operator|!=
name|COND
condition|)
continue|continue;
name|rtl_obstack
operator|=
name|temp_obstack
expr_stmt|;
if|#
directive|if
literal|0
comment|/* This was intended as a speed up, but it was slower.  */
block|if (insn_n_alternatives[ie->insn_code]> 6&& count_sub_rtxs (av->value, 200)>= 200) 		newexp = simplify_by_alternatives (av->value, ie->insn_code, 						   ie->insn_index); 	      else
endif|#
directive|endif
name|newexp
operator|=
name|simplify_cond
argument_list|(
name|av
operator|->
name|value
argument_list|,
name|ie
operator|->
name|insn_code
argument_list|,
name|ie
operator|->
name|insn_index
argument_list|)
expr_stmt|;
name|rtl_obstack
operator|=
name|old
expr_stmt|;
if|if
condition|(
name|newexp
operator|!=
name|av
operator|->
name|value
condition|)
block|{
name|newexp
operator|=
name|attr_copy_rtx
argument_list|(
name|newexp
argument_list|)
expr_stmt|;
name|remove_insn_ent
argument_list|(
name|av
argument_list|,
name|ie
argument_list|)
expr_stmt|;
name|av
operator|=
name|get_attr_value
argument_list|(
name|newexp
argument_list|,
name|attr
argument_list|,
name|ie
operator|->
name|insn_code
argument_list|)
expr_stmt|;
name|iv
operator|->
name|av
operator|=
name|av
expr_stmt|;
name|insert_insn_ent
argument_list|(
name|av
argument_list|,
name|ie
argument_list|)
expr_stmt|;
name|something_changed
operator|=
literal|1
expr_stmt|;
block|}
name|obstack_free
argument_list|(
name|temp_obstack
argument_list|,
name|spacer
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
unit|static rtx simplify_by_alternatives (exp, insn_code, insn_index)      rtx exp;      int insn_code, insn_index; {   int i;   int len = insn_n_alternatives[insn_code];   rtx newexp = rtx_alloc (COND);   rtx ultimate;     XVEC (newexp, 0) = rtvec_alloc (len * 2);
comment|/* It will not matter what value we use as the default value      of the new COND, since that default will never be used.      Choose something of the right type.  */
end_comment

begin_endif
unit|for (ultimate = exp; GET_CODE (ultimate) == COND;)     ultimate = XEXP (ultimate, 1);   XEXP (newexp, 1) = ultimate;    for (i = 0; i< insn_n_alternatives[insn_code]; i++)     {       current_alternative_string = attr_numeral (i);       XVECEXP (newexp, 0, i * 2) = make_alternative_compare (1<< i);       XVECEXP (newexp, 0, i * 2 + 1) 	= simplify_cond (exp, insn_code, insn_index);     }    current_alternative_string = 0;   return simplify_cond (newexp, insn_code, insn_index); }
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* An expression where all the unknown terms are EQ_ATTR tests can be    rearranged into a COND provided we can enumerate all possible    combinations of the unknown values.  The set of combinations become the    tests of the COND; the value of the expression given that combination is    computed and becomes the corresponding value.  To do this, we must be    able to enumerate all values for each attribute used in the expression    (currently, we give up if we find a numeric attribute).        If the set of EQ_ATTR tests used in an expression tests the value of N    different attributes, the list of all possible combinations can be made    by walking the N-dimensional attribute space defined by those    attributes.  We record each of these as a struct dimension.     The algorithm relies on sharing EQ_ATTR nodes: if two nodes in an    expression are the same, the will also have the same address.  We find    all the EQ_ATTR nodes by marking them MEM_VOLATILE_P.  This bit later    represents the value of an EQ_ATTR node, so once all nodes are marked,    they are also given an initial value of FALSE.     We then separate the set of EQ_ATTR nodes into dimensions for each    attribute and put them on the VALUES list.  Terms are added as needed by    `add_values_to_cover' so that all possible values of the attribute are    tested.     Each dimension also has a current value.  This is the node that is    currently considered to be TRUE.  If this is one of the nodes added by    `add_values_to_cover', all the EQ_ATTR tests in the original expression    will be FALSE.  Otherwise, only the CURRENT_VALUE will be true.     NUM_VALUES is simply the length of the VALUES list and is there for    convenience.     Once the dimensions are created, the algorithm enumerates all possible    values and computes the current value of the given expression.  */
end_comment

begin_struct
struct|struct
name|dimension
block|{
name|struct
name|attr_desc
modifier|*
name|attr
decl_stmt|;
comment|/* Attribute for this dimension.  */
name|rtx
name|values
decl_stmt|;
comment|/* List of attribute values used.  */
name|rtx
name|current_value
decl_stmt|;
comment|/* Position in the list for the TRUE value.  */
name|int
name|num_values
decl_stmt|;
comment|/* Length of the values list.  */
block|}
struct|;
end_struct

begin_comment
comment|/* If EXP is a suitable expression, reorganize it by constructing an    equivalent expression that is a COND with the tests being all combinations    of attribute values and the values being simple constants.  */
end_comment

begin_function
specifier|static
name|rtx
name|simplify_by_exploding
parameter_list|(
name|exp
parameter_list|)
name|rtx
name|exp
decl_stmt|;
block|{
name|rtx
name|list
init|=
literal|0
decl_stmt|,
name|link
decl_stmt|,
name|condexp
decl_stmt|,
name|defval
decl_stmt|;
name|struct
name|dimension
modifier|*
name|space
decl_stmt|;
name|rtx
modifier|*
name|condtest
decl_stmt|,
modifier|*
name|condval
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|total
decl_stmt|,
name|ndim
init|=
literal|0
decl_stmt|;
name|int
name|most_tests
decl_stmt|,
name|num_marks
decl_stmt|,
name|new_marks
decl_stmt|;
comment|/* Locate all the EQ_ATTR expressions.  */
if|if
condition|(
operator|!
name|find_and_mark_used_attributes
argument_list|(
name|exp
argument_list|,
operator|&
name|list
argument_list|,
operator|&
name|ndim
argument_list|)
operator|||
name|ndim
operator|==
literal|0
condition|)
block|{
name|unmark_used_attributes
argument_list|(
name|list
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|exp
return|;
block|}
comment|/* Create an attribute space from the list of used attributes.  For each      dimension in the attribute space, record the attribute, list of values      used, and number of values used.  Add members to the list of values to      cover the domain of the attribute.  This makes the expanded COND form      order independent.  */
name|space
operator|=
operator|(
expr|struct
name|dimension
operator|*
operator|)
name|alloca
argument_list|(
name|ndim
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|dimension
argument_list|)
argument_list|)
expr_stmt|;
name|total
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|ndim
operator|=
literal|0
init|;
name|list
condition|;
name|ndim
operator|++
control|)
block|{
comment|/* Pull the first attribute value from the list and record that 	 attribute as another dimension in the attribute space.  */
name|char
modifier|*
name|name
init|=
name|XSTR
argument_list|(
name|XEXP
argument_list|(
name|list
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
modifier|*
name|prev
decl_stmt|;
if|if
condition|(
operator|(
name|space
index|[
name|ndim
index|]
operator|.
name|attr
operator|=
name|find_attr
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
literal|0
operator|||
name|space
index|[
name|ndim
index|]
operator|.
name|attr
operator|->
name|is_numeric
condition|)
block|{
name|unmark_used_attributes
argument_list|(
name|list
argument_list|,
name|space
argument_list|,
name|ndim
argument_list|)
expr_stmt|;
return|return
name|exp
return|;
block|}
comment|/* Add all remaining attribute values that refer to this attribute.  */
name|space
index|[
name|ndim
index|]
operator|.
name|num_values
operator|=
literal|0
expr_stmt|;
name|space
index|[
name|ndim
index|]
operator|.
name|values
operator|=
literal|0
expr_stmt|;
name|prev
operator|=
operator|&
name|list
expr_stmt|;
for|for
control|(
name|link
operator|=
name|list
init|;
name|link
condition|;
name|link
operator|=
operator|*
name|prev
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|XSTR
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|name
argument_list|)
condition|)
block|{
name|space
index|[
name|ndim
index|]
operator|.
name|num_values
operator|++
expr_stmt|;
operator|*
name|prev
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
operator|=
name|space
index|[
name|ndim
index|]
operator|.
name|values
expr_stmt|;
name|space
index|[
name|ndim
index|]
operator|.
name|values
operator|=
name|link
expr_stmt|;
block|}
else|else
name|prev
operator|=
operator|&
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Add sufficient members to the list of values to make the list 	 mutually exclusive and record the total size of the attribute 	 space.  */
name|total
operator|*=
name|add_values_to_cover
argument_list|(
operator|&
name|space
index|[
name|ndim
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* Sort the attribute space so that the attributes go from non-constant      to constant and from most values to least values.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ndim
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
name|ndim
operator|-
literal|1
init|;
name|j
operator|>
name|i
condition|;
name|j
operator|--
control|)
if|if
condition|(
operator|(
name|space
index|[
name|j
operator|-
literal|1
index|]
operator|.
name|attr
operator|->
name|is_const
operator|&&
operator|!
name|space
index|[
name|j
index|]
operator|.
name|attr
operator|->
name|is_const
operator|)
operator|||
name|space
index|[
name|j
operator|-
literal|1
index|]
operator|.
name|num_values
operator|<
name|space
index|[
name|j
index|]
operator|.
name|num_values
condition|)
block|{
name|struct
name|dimension
name|tmp
decl_stmt|;
name|tmp
operator|=
name|space
index|[
name|j
index|]
expr_stmt|;
name|space
index|[
name|j
index|]
operator|=
name|space
index|[
name|j
operator|-
literal|1
index|]
expr_stmt|;
name|space
index|[
name|j
operator|-
literal|1
index|]
operator|=
name|tmp
expr_stmt|;
block|}
comment|/* Establish the initial current value.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ndim
condition|;
name|i
operator|++
control|)
name|space
index|[
name|i
index|]
operator|.
name|current_value
operator|=
name|space
index|[
name|i
index|]
operator|.
name|values
expr_stmt|;
name|condtest
operator|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
name|total
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|condval
operator|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
name|total
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Expand the tests and values by iterating over all values in the      attribute space.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
condition|;
name|i
operator|++
control|)
block|{
name|condtest
index|[
name|i
index|]
operator|=
name|test_for_current_value
argument_list|(
name|space
argument_list|,
name|ndim
argument_list|)
expr_stmt|;
name|condval
index|[
name|i
index|]
operator|=
name|simplify_with_current_value
argument_list|(
name|exp
argument_list|,
name|space
argument_list|,
name|ndim
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|increment_current_value
argument_list|(
name|space
argument_list|,
name|ndim
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|!=
name|total
operator|-
literal|1
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* We are now finished with the original expression.  */
name|unmark_used_attributes
argument_list|(
literal|0
argument_list|,
name|space
argument_list|,
name|ndim
argument_list|)
expr_stmt|;
comment|/* Find the most used constant value and make that the default.  */
name|most_tests
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
name|num_marks
operator|=
literal|0
init|;
name|i
operator|<
name|total
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|condval
index|[
name|i
index|]
argument_list|)
operator|==
name|CONST_STRING
operator|&&
operator|!
name|MEM_VOLATILE_P
argument_list|(
name|condval
index|[
name|i
index|]
argument_list|)
condition|)
block|{
comment|/* Mark the unmarked constant value and count how many are marked.  */
name|MEM_VOLATILE_P
argument_list|(
name|condval
index|[
name|i
index|]
argument_list|)
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|j
operator|=
name|new_marks
operator|=
literal|0
init|;
name|j
operator|<
name|total
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|condval
index|[
name|j
index|]
argument_list|)
operator|==
name|CONST_STRING
operator|&&
name|MEM_VOLATILE_P
argument_list|(
name|condval
index|[
name|j
index|]
argument_list|)
condition|)
name|new_marks
operator|++
expr_stmt|;
if|if
condition|(
name|new_marks
operator|-
name|num_marks
operator|>
name|most_tests
condition|)
block|{
name|most_tests
operator|=
name|new_marks
operator|-
name|num_marks
expr_stmt|;
name|defval
operator|=
name|condval
index|[
name|i
index|]
expr_stmt|;
block|}
name|num_marks
operator|=
name|new_marks
expr_stmt|;
block|}
comment|/* Clear all the marks.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|total
condition|;
name|i
operator|++
control|)
name|MEM_VOLATILE_P
argument_list|(
name|condval
index|[
name|i
index|]
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Give up if nothing is constant.  */
if|if
condition|(
name|num_marks
operator|==
literal|0
condition|)
return|return
name|exp
return|;
comment|/* If all values are the default, use that.  */
if|if
condition|(
name|total
operator|==
name|most_tests
condition|)
return|return
name|defval
return|;
comment|/* Make a COND with the most common constant value the default.  (A more      complex method where tests with the same value were combined didn't      seem to improve things.)  */
name|condexp
operator|=
name|rtx_alloc
argument_list|(
name|COND
argument_list|)
expr_stmt|;
name|XVEC
argument_list|(
name|condexp
argument_list|,
literal|0
argument_list|)
operator|=
name|rtvec_alloc
argument_list|(
operator|(
name|total
operator|-
name|most_tests
operator|)
operator|*
literal|2
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|condexp
argument_list|,
literal|1
argument_list|)
operator|=
name|defval
expr_stmt|;
for|for
control|(
name|i
operator|=
name|j
operator|=
literal|0
init|;
name|i
operator|<
name|total
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|condval
index|[
name|i
index|]
operator|!=
name|defval
condition|)
block|{
name|XVECEXP
argument_list|(
name|condexp
argument_list|,
literal|0
argument_list|,
literal|2
operator|*
name|j
argument_list|)
operator|=
name|condtest
index|[
name|i
index|]
expr_stmt|;
name|XVECEXP
argument_list|(
name|condexp
argument_list|,
literal|0
argument_list|,
literal|2
operator|*
name|j
operator|+
literal|1
argument_list|)
operator|=
name|condval
index|[
name|i
index|]
expr_stmt|;
name|j
operator|++
expr_stmt|;
block|}
return|return
name|condexp
return|;
block|}
end_function

begin_comment
comment|/* Set the MEM_VOLATILE_P flag for all EQ_ATTR expressions in EXP and    verify that EXP can be simplified to a constant term if all the EQ_ATTR    tests have known value.  */
end_comment

begin_function
specifier|static
name|int
name|find_and_mark_used_attributes
parameter_list|(
name|exp
parameter_list|,
name|terms
parameter_list|,
name|nterms
parameter_list|)
name|rtx
name|exp
decl_stmt|,
decl|*
name|terms
decl_stmt|;
end_function

begin_decl_stmt
name|int
modifier|*
name|nterms
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|exp
argument_list|)
condition|)
block|{
case|case
name|EQ_ATTR
case|:
if|if
condition|(
operator|!
name|MEM_VOLATILE_P
argument_list|(
name|exp
argument_list|)
condition|)
block|{
name|rtx
name|link
init|=
name|rtx_alloc
argument_list|(
name|EXPR_LIST
argument_list|)
decl_stmt|;
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
operator|=
name|exp
expr_stmt|;
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
operator|=
operator|*
name|terms
expr_stmt|;
operator|*
name|terms
operator|=
name|link
expr_stmt|;
operator|*
name|nterms
operator|+=
literal|1
expr_stmt|;
name|MEM_VOLATILE_P
argument_list|(
name|exp
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
case|case
name|CONST_STRING
case|:
return|return
literal|1
return|;
case|case
name|IF_THEN_ELSE
case|:
if|if
condition|(
operator|!
name|find_and_mark_used_attributes
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
argument_list|,
name|terms
argument_list|,
name|nterms
argument_list|)
condition|)
return|return
literal|0
return|;
case|case
name|IOR
case|:
case|case
name|AND
case|:
if|if
condition|(
operator|!
name|find_and_mark_used_attributes
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|terms
argument_list|,
name|nterms
argument_list|)
condition|)
return|return
literal|0
return|;
case|case
name|NOT
case|:
if|if
condition|(
operator|!
name|find_and_mark_used_attributes
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|terms
argument_list|,
name|nterms
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
case|case
name|COND
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|find_and_mark_used_attributes
argument_list|(
name|XVECEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
name|terms
argument_list|,
name|nterms
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|find_and_mark_used_attributes
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|terms
argument_list|,
name|nterms
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* Clear the MEM_VOLATILE_P flag in all EQ_ATTR expressions on LIST and    in the values of the NDIM-dimensional attribute space SPACE.  */
end_comment

begin_function
specifier|static
name|void
name|unmark_used_attributes
parameter_list|(
name|list
parameter_list|,
name|space
parameter_list|,
name|ndim
parameter_list|)
name|rtx
name|list
decl_stmt|;
name|struct
name|dimension
modifier|*
name|space
decl_stmt|;
name|int
name|ndim
decl_stmt|;
block|{
name|rtx
name|link
decl_stmt|,
name|exp
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ndim
condition|;
name|i
operator|++
control|)
name|unmark_used_attributes
argument_list|(
name|space
index|[
name|i
index|]
operator|.
name|values
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|link
operator|=
name|list
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
block|{
name|exp
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|EQ_ATTR
condition|)
name|MEM_VOLATILE_P
argument_list|(
name|exp
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Update the attribute dimension DIM so that all values of the attribute    are tested.  Return the updated number of values.  */
end_comment

begin_function
specifier|static
name|int
name|add_values_to_cover
parameter_list|(
name|dim
parameter_list|)
name|struct
name|dimension
modifier|*
name|dim
decl_stmt|;
block|{
name|struct
name|attr_value
modifier|*
name|av
decl_stmt|;
name|rtx
name|exp
decl_stmt|,
name|link
decl_stmt|,
modifier|*
name|prev
decl_stmt|;
name|int
name|nalt
init|=
literal|0
decl_stmt|;
for|for
control|(
name|av
operator|=
name|dim
operator|->
name|attr
operator|->
name|first_value
init|;
name|av
condition|;
name|av
operator|=
name|av
operator|->
name|next
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|av
operator|->
name|value
argument_list|)
operator|==
name|CONST_STRING
condition|)
name|nalt
operator|++
expr_stmt|;
if|if
condition|(
name|nalt
operator|<
name|dim
operator|->
name|num_values
condition|)
name|abort
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|nalt
operator|==
name|dim
operator|->
name|num_values
condition|)
empty_stmt|;
comment|/* Ok.  */
elseif|else
if|if
condition|(
name|nalt
operator|*
literal|2
operator|<
name|dim
operator|->
name|num_values
operator|*
literal|3
condition|)
block|{
comment|/* Most all the values of the attribute are used, so add all the unused 	 values.  */
name|prev
operator|=
operator|&
name|dim
operator|->
name|values
expr_stmt|;
for|for
control|(
name|link
operator|=
name|dim
operator|->
name|values
init|;
name|link
condition|;
name|link
operator|=
operator|*
name|prev
control|)
name|prev
operator|=
operator|&
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|av
operator|=
name|dim
operator|->
name|attr
operator|->
name|first_value
init|;
name|av
condition|;
name|av
operator|=
name|av
operator|->
name|next
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|av
operator|->
name|value
argument_list|)
operator|==
name|CONST_STRING
condition|)
block|{
name|exp
operator|=
name|attr_eq
argument_list|(
name|dim
operator|->
name|attr
operator|->
name|name
argument_list|,
name|XSTR
argument_list|(
name|av
operator|->
name|value
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|MEM_VOLATILE_P
argument_list|(
name|exp
argument_list|)
condition|)
continue|continue;
name|link
operator|=
name|rtx_alloc
argument_list|(
name|EXPR_LIST
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
operator|=
name|exp
expr_stmt|;
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
operator|=
literal|0
expr_stmt|;
operator|*
name|prev
operator|=
name|link
expr_stmt|;
name|prev
operator|=
operator|&
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|dim
operator|->
name|num_values
operator|=
name|nalt
expr_stmt|;
block|}
else|else
block|{
name|rtx
name|orexp
init|=
name|false_rtx
decl_stmt|;
comment|/* Very few values are used, so compute a mutually exclusive 	 expression.  (We could do this for numeric values if that becomes 	 important.)  */
name|prev
operator|=
operator|&
name|dim
operator|->
name|values
expr_stmt|;
for|for
control|(
name|link
operator|=
name|dim
operator|->
name|values
init|;
name|link
condition|;
name|link
operator|=
operator|*
name|prev
control|)
block|{
name|orexp
operator|=
name|insert_right_side
argument_list|(
name|IOR
argument_list|,
name|orexp
argument_list|,
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|-
literal|2
argument_list|)
expr_stmt|;
name|prev
operator|=
operator|&
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|link
operator|=
name|rtx_alloc
argument_list|(
name|EXPR_LIST
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
operator|=
name|attr_rtx
argument_list|(
name|NOT
argument_list|,
name|orexp
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
operator|=
literal|0
expr_stmt|;
operator|*
name|prev
operator|=
name|link
expr_stmt|;
name|dim
operator|->
name|num_values
operator|++
expr_stmt|;
block|}
return|return
name|dim
operator|->
name|num_values
return|;
block|}
end_function

begin_comment
comment|/* Increment the current value for the NDIM-dimensional attribute space SPACE    and return FALSE if the increment overflowed.  */
end_comment

begin_function
specifier|static
name|int
name|increment_current_value
parameter_list|(
name|space
parameter_list|,
name|ndim
parameter_list|)
name|struct
name|dimension
modifier|*
name|space
decl_stmt|;
name|int
name|ndim
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|ndim
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
operator|(
name|space
index|[
name|i
index|]
operator|.
name|current_value
operator|=
name|XEXP
argument_list|(
name|space
index|[
name|i
index|]
operator|.
name|current_value
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|space
index|[
name|i
index|]
operator|.
name|current_value
operator|=
name|space
index|[
name|i
index|]
operator|.
name|values
expr_stmt|;
else|else
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Construct an expression corresponding to the current value for the    NDIM-dimensional attribute space SPACE.  */
end_comment

begin_function
specifier|static
name|rtx
name|test_for_current_value
parameter_list|(
name|space
parameter_list|,
name|ndim
parameter_list|)
name|struct
name|dimension
modifier|*
name|space
decl_stmt|;
name|int
name|ndim
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|rtx
name|exp
init|=
name|true_rtx
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ndim
condition|;
name|i
operator|++
control|)
name|exp
operator|=
name|insert_right_side
argument_list|(
name|AND
argument_list|,
name|exp
argument_list|,
name|XEXP
argument_list|(
name|space
index|[
name|i
index|]
operator|.
name|current_value
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|-
literal|2
argument_list|)
expr_stmt|;
return|return
name|exp
return|;
block|}
end_function

begin_comment
comment|/* Given the current value of the NDIM-dimensional attribute space SPACE,    set the corresponding EQ_ATTR expressions to that value and reduce    the expression EXP as much as possible.  On input [and output], all    known EQ_ATTR expressions are set to FALSE.  */
end_comment

begin_function
specifier|static
name|rtx
name|simplify_with_current_value
parameter_list|(
name|exp
parameter_list|,
name|space
parameter_list|,
name|ndim
parameter_list|)
name|rtx
name|exp
decl_stmt|;
name|struct
name|dimension
modifier|*
name|space
decl_stmt|;
name|int
name|ndim
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|rtx
name|x
decl_stmt|;
comment|/* Mark each current value as TRUE.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ndim
condition|;
name|i
operator|++
control|)
block|{
name|x
operator|=
name|XEXP
argument_list|(
name|space
index|[
name|i
index|]
operator|.
name|current_value
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|EQ_ATTR
condition|)
name|MEM_VOLATILE_P
argument_list|(
name|x
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
name|exp
operator|=
name|simplify_with_current_value_aux
argument_list|(
name|exp
argument_list|)
expr_stmt|;
comment|/* Change each current value back to FALSE.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ndim
condition|;
name|i
operator|++
control|)
block|{
name|x
operator|=
name|XEXP
argument_list|(
name|space
index|[
name|i
index|]
operator|.
name|current_value
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|EQ_ATTR
condition|)
name|MEM_VOLATILE_P
argument_list|(
name|x
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|exp
return|;
block|}
end_function

begin_comment
comment|/* Reduce the expression EXP based on the MEM_VOLATILE_P settings of    all EQ_ATTR expressions.  */
end_comment

begin_function
specifier|static
name|rtx
name|simplify_with_current_value_aux
parameter_list|(
name|exp
parameter_list|)
name|rtx
name|exp
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|rtx
name|cond
decl_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|exp
argument_list|)
condition|)
block|{
case|case
name|EQ_ATTR
case|:
if|if
condition|(
name|MEM_VOLATILE_P
argument_list|(
name|exp
argument_list|)
condition|)
return|return
name|false_rtx
return|;
else|else
return|return
name|true_rtx
return|;
case|case
name|CONST_STRING
case|:
return|return
name|exp
return|;
case|case
name|IF_THEN_ELSE
case|:
name|cond
operator|=
name|simplify_with_current_value_aux
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cond
operator|==
name|true_rtx
condition|)
return|return
name|simplify_with_current_value_aux
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|cond
operator|==
name|false_rtx
condition|)
return|return
name|simplify_with_current_value_aux
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
argument_list|)
return|;
else|else
return|return
name|attr_rtx
argument_list|(
name|IF_THEN_ELSE
argument_list|,
name|cond
argument_list|,
name|simplify_with_current_value_aux
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|simplify_with_current_value_aux
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|IOR
case|:
name|cond
operator|=
name|simplify_with_current_value_aux
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cond
operator|==
name|true_rtx
condition|)
return|return
name|cond
return|;
elseif|else
if|if
condition|(
name|cond
operator|==
name|false_rtx
condition|)
return|return
name|simplify_with_current_value_aux
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
else|else
return|return
name|attr_rtx
argument_list|(
name|IOR
argument_list|,
name|cond
argument_list|,
name|simplify_with_current_value_aux
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|AND
case|:
name|cond
operator|=
name|simplify_with_current_value_aux
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cond
operator|==
name|true_rtx
condition|)
return|return
name|simplify_with_current_value_aux
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|cond
operator|==
name|false_rtx
condition|)
return|return
name|cond
return|;
else|else
return|return
name|attr_rtx
argument_list|(
name|AND
argument_list|,
name|cond
argument_list|,
name|simplify_with_current_value_aux
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|NOT
case|:
name|cond
operator|=
name|simplify_with_current_value_aux
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cond
operator|==
name|true_rtx
condition|)
return|return
name|false_rtx
return|;
elseif|else
if|if
condition|(
name|cond
operator|==
name|false_rtx
condition|)
return|return
name|true_rtx
return|;
else|else
return|return
name|attr_rtx
argument_list|(
name|NOT
argument_list|,
name|cond
argument_list|)
return|;
case|case
name|COND
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|+=
literal|2
control|)
block|{
name|cond
operator|=
name|simplify_with_current_value_aux
argument_list|(
name|XVECEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cond
operator|==
name|true_rtx
condition|)
return|return
name|simplify_with_current_value_aux
argument_list|(
name|XVECEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|,
name|i
operator|+
literal|1
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|cond
operator|==
name|false_rtx
condition|)
continue|continue;
else|else
name|abort
argument_list|()
expr_stmt|;
comment|/* With all EQ_ATTR's of known value, a case should 			 have been selected.  */
block|}
return|return
name|simplify_with_current_value_aux
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
block|}
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Clear the MEM_IN_STRUCT_P flag in EXP and its subexpressions.  */
end_comment

begin_macro
name|clear_struct_flag
argument_list|(
argument|x
argument_list|)
end_macro

begin_decl_stmt
name|rtx
name|x
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|;
specifier|register
name|enum
name|rtx_code
name|code
decl_stmt|;
specifier|register
name|char
modifier|*
name|fmt
decl_stmt|;
name|MEM_IN_STRUCT_P
argument_list|(
name|x
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|RTX_UNCHANGING_P
argument_list|(
name|x
argument_list|)
condition|)
return|return;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|REG
case|:
case|case
name|QUEUED
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|CODE_LABEL
case|:
case|case
name|PC
case|:
case|case
name|CC0
case|:
case|case
name|EQ_ATTR
case|:
return|return;
block|}
comment|/* Compare the elements.  If any pair of corresponding elements      fail to match, return 0 for the whole things.  */
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
switch|switch
condition|(
name|fmt
index|[
name|i
index|]
condition|)
block|{
case|case
literal|'V'
case|:
case|case
literal|'E'
case|:
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|clear_struct_flag
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|clear_struct_flag
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_block

begin_comment
comment|/* Return the number of RTX objects making up the expression X.    But if we count more more than MAX objects, stop counting.  */
end_comment

begin_macro
name|count_sub_rtxs
argument_list|(
argument|x
argument_list|,
argument|max
argument_list|)
end_macro

begin_decl_stmt
name|rtx
name|x
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|max
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|;
specifier|register
name|enum
name|rtx_code
name|code
decl_stmt|;
specifier|register
name|char
modifier|*
name|fmt
decl_stmt|;
name|int
name|total
init|=
literal|0
decl_stmt|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|REG
case|:
case|case
name|QUEUED
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|CODE_LABEL
case|:
case|case
name|PC
case|:
case|case
name|CC0
case|:
case|case
name|EQ_ATTR
case|:
return|return
literal|1
return|;
block|}
comment|/* Compare the elements.  If any pair of corresponding elements      fail to match, return 0 for the whole things.  */
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|total
operator|>=
name|max
condition|)
return|return
name|total
return|;
switch|switch
condition|(
name|fmt
index|[
name|i
index|]
condition|)
block|{
case|case
literal|'V'
case|:
case|case
literal|'E'
case|:
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|total
operator|+=
name|count_sub_rtxs
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|max
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|total
operator|+=
name|count_sub_rtxs
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|max
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
name|total
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Create table entries for DEFINE_ATTR.  */
end_comment

begin_function
specifier|static
name|void
name|gen_attr
parameter_list|(
name|exp
parameter_list|)
name|rtx
name|exp
decl_stmt|;
block|{
name|struct
name|attr_desc
modifier|*
name|attr
decl_stmt|;
name|struct
name|attr_value
modifier|*
name|av
decl_stmt|;
name|char
modifier|*
name|name_ptr
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
comment|/* Make a new attribute structure.  Check for duplicate by looking at      attr->default_val, since it is initialized by this routine.  */
name|attr
operator|=
name|find_attr
argument_list|(
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr
operator|->
name|default_val
condition|)
name|fatal
argument_list|(
literal|"Duplicate definition for `%s' attribute"
argument_list|,
name|attr
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
operator|==
literal|'\0'
condition|)
name|attr
operator|->
name|is_numeric
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|name_ptr
operator|=
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|p
operator|=
name|next_comma_elt
argument_list|(
operator|&
name|name_ptr
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|av
operator|=
operator|(
expr|struct
name|attr_value
operator|*
operator|)
name|oballoc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|attr_value
argument_list|)
argument_list|)
expr_stmt|;
name|av
operator|->
name|value
operator|=
name|attr_rtx
argument_list|(
name|CONST_STRING
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|av
operator|->
name|next
operator|=
name|attr
operator|->
name|first_value
expr_stmt|;
name|attr
operator|->
name|first_value
operator|=
name|av
expr_stmt|;
name|av
operator|->
name|first_insn
operator|=
name|NULL
expr_stmt|;
name|av
operator|->
name|num_insns
operator|=
literal|0
expr_stmt|;
name|av
operator|->
name|has_asm_insn
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|==
name|CONST
condition|)
block|{
name|attr
operator|->
name|is_const
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|attr
operator|->
name|is_numeric
condition|)
name|fatal
argument_list|(
literal|"Constant attributes may not take numeric values"
argument_list|)
expr_stmt|;
comment|/* Get rid of the CONST node.  It is allowed only at top-level.  */
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|attr
operator|->
name|name
argument_list|,
literal|"length"
argument_list|)
operator|&&
operator|!
name|attr
operator|->
name|is_numeric
condition|)
name|fatal
argument_list|(
literal|"`length' attribute must take numeric values"
argument_list|)
expr_stmt|;
comment|/* Set up the default value. */
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
operator|=
name|check_attr_value
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
argument_list|,
name|attr
argument_list|)
expr_stmt|;
name|attr
operator|->
name|default_val
operator|=
name|get_attr_value
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
argument_list|,
name|attr
argument_list|,
operator|-
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given a pattern for DEFINE_PEEPHOLE or DEFINE_INSN, return the number of    alternatives in the constraints.  Assume all MATCH_OPERANDs have the same    number of alternatives as this should be checked elsewhere.  */
end_comment

begin_function
specifier|static
name|int
name|count_alternatives
parameter_list|(
name|exp
parameter_list|)
name|rtx
name|exp
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|n
decl_stmt|;
name|char
modifier|*
name|fmt
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|MATCH_OPERAND
condition|)
return|return
name|n_comma_elts
argument_list|(
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
argument_list|)
return|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|GET_CODE
argument_list|(
name|exp
argument_list|)
argument_list|)
init|;
name|i
operator|<
name|GET_RTX_LENGTH
argument_list|(
name|GET_CODE
argument_list|(
name|exp
argument_list|)
argument_list|)
condition|;
name|i
operator|++
control|)
switch|switch
condition|(
operator|*
name|fmt
operator|++
condition|)
block|{
case|case
literal|'e'
case|:
case|case
literal|'u'
case|:
name|n
operator|=
name|count_alternatives
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
condition|)
return|return
name|n
return|;
break|break;
case|case
literal|'E'
case|:
case|case
literal|'V'
case|:
if|if
condition|(
name|XVEC
argument_list|(
name|exp
argument_list|,
name|i
argument_list|)
operator|!=
name|NULL
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|exp
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
name|n
operator|=
name|count_alternatives
argument_list|(
name|XVECEXP
argument_list|(
name|exp
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
condition|)
return|return
name|n
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Returns non-zero if the given expression contains an EQ_ATTR with the    `alternative' attribute.  */
end_comment

begin_function
specifier|static
name|int
name|compares_alternatives_p
parameter_list|(
name|exp
parameter_list|)
name|rtx
name|exp
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|char
modifier|*
name|fmt
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|EQ_ATTR
operator|&&
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
operator|==
name|alternative_name
condition|)
return|return
literal|1
return|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|GET_CODE
argument_list|(
name|exp
argument_list|)
argument_list|)
init|;
name|i
operator|<
name|GET_RTX_LENGTH
argument_list|(
name|GET_CODE
argument_list|(
name|exp
argument_list|)
argument_list|)
condition|;
name|i
operator|++
control|)
switch|switch
condition|(
operator|*
name|fmt
operator|++
condition|)
block|{
case|case
literal|'e'
case|:
case|case
literal|'u'
case|:
if|if
condition|(
name|compares_alternatives_p
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
break|break;
case|case
literal|'E'
case|:
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|exp
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|compares_alternatives_p
argument_list|(
name|XVECEXP
argument_list|(
name|exp
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Returns non-zero is INNER is contained in EXP.  */
end_comment

begin_function
specifier|static
name|int
name|contained_in_p
parameter_list|(
name|inner
parameter_list|,
name|exp
parameter_list|)
name|rtx
name|inner
decl_stmt|;
name|rtx
name|exp
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|char
modifier|*
name|fmt
decl_stmt|;
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|inner
argument_list|,
name|exp
argument_list|)
condition|)
return|return
literal|1
return|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|GET_CODE
argument_list|(
name|exp
argument_list|)
argument_list|)
init|;
name|i
operator|<
name|GET_RTX_LENGTH
argument_list|(
name|GET_CODE
argument_list|(
name|exp
argument_list|)
argument_list|)
condition|;
name|i
operator|++
control|)
switch|switch
condition|(
operator|*
name|fmt
operator|++
condition|)
block|{
case|case
literal|'e'
case|:
case|case
literal|'u'
case|:
if|if
condition|(
name|contained_in_p
argument_list|(
name|inner
argument_list|,
name|XEXP
argument_list|(
name|exp
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
break|break;
case|case
literal|'E'
case|:
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|exp
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|contained_in_p
argument_list|(
name|inner
argument_list|,
name|XVECEXP
argument_list|(
name|exp
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Process DEFINE_PEEPHOLE, DEFINE_INSN, and DEFINE_ASM_ATTRIBUTES.  */
end_comment

begin_function
specifier|static
name|void
name|gen_insn
parameter_list|(
name|exp
parameter_list|)
name|rtx
name|exp
decl_stmt|;
block|{
name|struct
name|insn_def
modifier|*
name|id
decl_stmt|;
name|id
operator|=
operator|(
expr|struct
name|insn_def
operator|*
operator|)
name|oballoc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|insn_def
argument_list|)
argument_list|)
expr_stmt|;
name|id
operator|->
name|next
operator|=
name|defs
expr_stmt|;
name|defs
operator|=
name|id
expr_stmt|;
name|id
operator|->
name|def
operator|=
name|exp
expr_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|exp
argument_list|)
condition|)
block|{
case|case
name|DEFINE_INSN
case|:
name|id
operator|->
name|insn_code
operator|=
name|insn_code_number
operator|++
expr_stmt|;
name|id
operator|->
name|insn_index
operator|=
name|insn_index_number
operator|++
expr_stmt|;
name|id
operator|->
name|num_alternatives
operator|=
name|count_alternatives
argument_list|(
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
operator|->
name|num_alternatives
operator|==
literal|0
condition|)
name|id
operator|->
name|num_alternatives
operator|=
literal|1
expr_stmt|;
name|id
operator|->
name|vec_idx
operator|=
literal|4
expr_stmt|;
break|break;
case|case
name|DEFINE_PEEPHOLE
case|:
name|id
operator|->
name|insn_code
operator|=
name|insn_code_number
operator|++
expr_stmt|;
name|id
operator|->
name|insn_index
operator|=
name|insn_index_number
operator|++
expr_stmt|;
name|id
operator|->
name|num_alternatives
operator|=
name|count_alternatives
argument_list|(
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
operator|->
name|num_alternatives
operator|==
literal|0
condition|)
name|id
operator|->
name|num_alternatives
operator|=
literal|1
expr_stmt|;
name|id
operator|->
name|vec_idx
operator|=
literal|3
expr_stmt|;
break|break;
case|case
name|DEFINE_ASM_ATTRIBUTES
case|:
name|id
operator|->
name|insn_code
operator|=
operator|-
literal|1
expr_stmt|;
name|id
operator|->
name|insn_index
operator|=
operator|-
literal|1
expr_stmt|;
name|id
operator|->
name|num_alternatives
operator|=
literal|1
expr_stmt|;
name|id
operator|->
name|vec_idx
operator|=
literal|0
expr_stmt|;
name|got_define_asm_attributes
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Process a DEFINE_DELAY.  Validate the vector length, check if annul    true or annul false is specified, and make a `struct delay_desc'.  */
end_comment

begin_function
specifier|static
name|void
name|gen_delay
parameter_list|(
name|def
parameter_list|)
name|rtx
name|def
decl_stmt|;
block|{
name|struct
name|delay_desc
modifier|*
name|delay
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|XVECLEN
argument_list|(
name|def
argument_list|,
literal|1
argument_list|)
operator|%
literal|3
operator|!=
literal|0
condition|)
name|fatal
argument_list|(
literal|"Number of elements in DEFINE_DELAY must be multiple of three."
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|def
argument_list|,
literal|1
argument_list|)
condition|;
name|i
operator|+=
literal|3
control|)
block|{
if|if
condition|(
name|XVECEXP
argument_list|(
name|def
argument_list|,
literal|1
argument_list|,
name|i
operator|+
literal|1
argument_list|)
condition|)
name|have_annul_true
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|XVECEXP
argument_list|(
name|def
argument_list|,
literal|1
argument_list|,
name|i
operator|+
literal|2
argument_list|)
condition|)
name|have_annul_false
operator|=
literal|1
expr_stmt|;
block|}
name|delay
operator|=
operator|(
expr|struct
name|delay_desc
operator|*
operator|)
name|oballoc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|delay_desc
argument_list|)
argument_list|)
expr_stmt|;
name|delay
operator|->
name|def
operator|=
name|def
expr_stmt|;
name|delay
operator|->
name|num
operator|=
operator|++
name|num_delays
expr_stmt|;
name|delay
operator|->
name|next
operator|=
name|delays
expr_stmt|;
name|delays
operator|=
name|delay
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Process a DEFINE_FUNCTION_UNIT.       This gives information about a function unit contained in the CPU.    We fill in a `struct function_unit_op' and a `struct function_unit'    with information used later by `expand_unit'.  */
end_comment

begin_function
specifier|static
name|void
name|gen_unit
parameter_list|(
name|def
parameter_list|)
name|rtx
name|def
decl_stmt|;
block|{
name|struct
name|function_unit
modifier|*
name|unit
decl_stmt|;
name|struct
name|function_unit_op
modifier|*
name|op
decl_stmt|;
name|char
modifier|*
name|name
init|=
name|XSTR
argument_list|(
name|def
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|int
name|multiplicity
init|=
name|XINT
argument_list|(
name|def
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|int
name|simultaneity
init|=
name|XINT
argument_list|(
name|def
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|rtx
name|condexp
init|=
name|XEXP
argument_list|(
name|def
argument_list|,
literal|3
argument_list|)
decl_stmt|;
name|int
name|ready_cost
init|=
name|MAX
argument_list|(
name|XINT
argument_list|(
name|def
argument_list|,
literal|4
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|int
name|issue_delay
init|=
name|MAX
argument_list|(
name|XINT
argument_list|(
name|def
argument_list|,
literal|5
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
comment|/* See if we have already seen this function unit.  If so, check that      the multiplicity and simultaneity values are the same.  If not, make      a structure for this function unit.  */
for|for
control|(
name|unit
operator|=
name|units
init|;
name|unit
condition|;
name|unit
operator|=
name|unit
operator|->
name|next
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|unit
operator|->
name|name
argument_list|,
name|name
argument_list|)
condition|)
block|{
if|if
condition|(
name|unit
operator|->
name|multiplicity
operator|!=
name|multiplicity
operator|||
name|unit
operator|->
name|simultaneity
operator|!=
name|simultaneity
condition|)
name|fatal
argument_list|(
literal|"Differing specifications given for `%s' function unit."
argument_list|,
name|unit
operator|->
name|name
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|unit
operator|==
literal|0
condition|)
block|{
name|unit
operator|=
operator|(
expr|struct
name|function_unit
operator|*
operator|)
name|oballoc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|function_unit
argument_list|)
argument_list|)
expr_stmt|;
name|unit
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|unit
operator|->
name|multiplicity
operator|=
name|multiplicity
expr_stmt|;
name|unit
operator|->
name|simultaneity
operator|=
name|simultaneity
expr_stmt|;
name|unit
operator|->
name|issue_delay
operator|.
name|min
operator|=
name|unit
operator|->
name|issue_delay
operator|.
name|max
operator|=
name|issue_delay
expr_stmt|;
name|unit
operator|->
name|num
operator|=
name|num_units
operator|++
expr_stmt|;
name|unit
operator|->
name|num_opclasses
operator|=
literal|0
expr_stmt|;
name|unit
operator|->
name|condexp
operator|=
name|false_rtx
expr_stmt|;
name|unit
operator|->
name|ops
operator|=
literal|0
expr_stmt|;
name|unit
operator|->
name|next
operator|=
name|units
expr_stmt|;
name|units
operator|=
name|unit
expr_stmt|;
block|}
comment|/* Make a new operation class structure entry and initialize it.  */
name|op
operator|=
operator|(
expr|struct
name|function_unit_op
operator|*
operator|)
name|oballoc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|function_unit_op
argument_list|)
argument_list|)
expr_stmt|;
name|op
operator|->
name|condexp
operator|=
name|condexp
expr_stmt|;
name|op
operator|->
name|num
operator|=
name|unit
operator|->
name|num_opclasses
operator|++
expr_stmt|;
name|op
operator|->
name|ready
operator|=
name|ready_cost
expr_stmt|;
name|op
operator|->
name|issue_delay
operator|=
name|issue_delay
expr_stmt|;
name|op
operator|->
name|next
operator|=
name|unit
operator|->
name|ops
expr_stmt|;
name|unit
operator|->
name|ops
operator|=
name|op
expr_stmt|;
comment|/* Set our issue expression based on whether or not an optional conflict      vector was specified.  */
if|if
condition|(
name|XVEC
argument_list|(
name|def
argument_list|,
literal|6
argument_list|)
condition|)
block|{
comment|/* Compute the IOR of all the specified expressions.  */
name|rtx
name|orexp
init|=
name|false_rtx
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|def
argument_list|,
literal|6
argument_list|)
condition|;
name|i
operator|++
control|)
name|orexp
operator|=
name|insert_right_side
argument_list|(
name|IOR
argument_list|,
name|orexp
argument_list|,
name|XVECEXP
argument_list|(
name|def
argument_list|,
literal|6
argument_list|,
name|i
argument_list|)
argument_list|,
operator|-
literal|2
argument_list|)
expr_stmt|;
name|op
operator|->
name|conflict_exp
operator|=
name|orexp
expr_stmt|;
name|extend_range
argument_list|(
operator|&
name|unit
operator|->
name|issue_delay
argument_list|,
literal|1
argument_list|,
name|issue_delay
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|op
operator|->
name|conflict_exp
operator|=
name|true_rtx
expr_stmt|;
name|extend_range
argument_list|(
operator|&
name|unit
operator|->
name|issue_delay
argument_list|,
name|issue_delay
argument_list|,
name|issue_delay
argument_list|)
expr_stmt|;
block|}
comment|/* Merge our conditional into that of the function unit so we can determine      which insns are used by the function unit.  */
name|unit
operator|->
name|condexp
operator|=
name|insert_right_side
argument_list|(
name|IOR
argument_list|,
name|unit
operator|->
name|condexp
argument_list|,
name|op
operator|->
name|condexp
argument_list|,
operator|-
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given a piece of RTX, print a C expression to test it's truth value.    We use AND and IOR both for logical and bit-wise operations, so     interpret them as logical unless they are inside a comparison expression.    The second operand of this function will be non-zero in that case.  */
end_comment

begin_function
specifier|static
name|void
name|write_test_expr
parameter_list|(
name|exp
parameter_list|,
name|in_comparison
parameter_list|)
name|rtx
name|exp
decl_stmt|;
name|int
name|in_comparison
decl_stmt|;
block|{
name|int
name|comparison_operator
init|=
literal|0
decl_stmt|;
name|RTX_CODE
name|code
decl_stmt|;
name|struct
name|attr_desc
modifier|*
name|attr
decl_stmt|;
comment|/* In order not to worry about operator precedence, surround our part of      the expression with parentheses.  */
name|printf
argument_list|(
literal|"("
argument_list|)
expr_stmt|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|exp
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
comment|/* Binary operators.  */
case|case
name|EQ
case|:
case|case
name|NE
case|:
case|case
name|GE
case|:
case|case
name|GT
case|:
case|case
name|GEU
case|:
case|case
name|GTU
case|:
case|case
name|LE
case|:
case|case
name|LT
case|:
case|case
name|LEU
case|:
case|case
name|LTU
case|:
name|comparison_operator
operator|=
literal|1
expr_stmt|;
case|case
name|PLUS
case|:
case|case
name|MINUS
case|:
case|case
name|MULT
case|:
case|case
name|DIV
case|:
case|case
name|MOD
case|:
case|case
name|AND
case|:
case|case
name|IOR
case|:
case|case
name|XOR
case|:
case|case
name|LSHIFT
case|:
case|case
name|ASHIFT
case|:
case|case
name|LSHIFTRT
case|:
case|case
name|ASHIFTRT
case|:
name|write_test_expr
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|in_comparison
operator|||
name|comparison_operator
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|EQ
case|:
name|printf
argument_list|(
literal|" == "
argument_list|)
expr_stmt|;
break|break;
case|case
name|NE
case|:
name|printf
argument_list|(
literal|" != "
argument_list|)
expr_stmt|;
break|break;
case|case
name|GE
case|:
name|printf
argument_list|(
literal|">= "
argument_list|)
expr_stmt|;
break|break;
case|case
name|GT
case|:
name|printf
argument_list|(
literal|"> "
argument_list|)
expr_stmt|;
break|break;
case|case
name|GEU
case|:
name|printf
argument_list|(
literal|">= (unsigned) "
argument_list|)
expr_stmt|;
break|break;
case|case
name|GTU
case|:
name|printf
argument_list|(
literal|"> (unsigned) "
argument_list|)
expr_stmt|;
break|break;
case|case
name|LE
case|:
name|printf
argument_list|(
literal|"<= "
argument_list|)
expr_stmt|;
break|break;
case|case
name|LT
case|:
name|printf
argument_list|(
literal|"< "
argument_list|)
expr_stmt|;
break|break;
case|case
name|LEU
case|:
name|printf
argument_list|(
literal|"<= (unsigned) "
argument_list|)
expr_stmt|;
break|break;
case|case
name|LTU
case|:
name|printf
argument_list|(
literal|"< (unsigned) "
argument_list|)
expr_stmt|;
break|break;
case|case
name|PLUS
case|:
name|printf
argument_list|(
literal|" + "
argument_list|)
expr_stmt|;
break|break;
case|case
name|MINUS
case|:
name|printf
argument_list|(
literal|" - "
argument_list|)
expr_stmt|;
break|break;
case|case
name|MULT
case|:
name|printf
argument_list|(
literal|" * "
argument_list|)
expr_stmt|;
break|break;
case|case
name|DIV
case|:
name|printf
argument_list|(
literal|" / "
argument_list|)
expr_stmt|;
break|break;
case|case
name|MOD
case|:
name|printf
argument_list|(
literal|" %% "
argument_list|)
expr_stmt|;
break|break;
case|case
name|AND
case|:
if|if
condition|(
name|in_comparison
condition|)
name|printf
argument_list|(
literal|"& "
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"&& "
argument_list|)
expr_stmt|;
break|break;
case|case
name|IOR
case|:
if|if
condition|(
name|in_comparison
condition|)
name|printf
argument_list|(
literal|" | "
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|" || "
argument_list|)
expr_stmt|;
break|break;
case|case
name|XOR
case|:
name|printf
argument_list|(
literal|" ^ "
argument_list|)
expr_stmt|;
break|break;
case|case
name|LSHIFT
case|:
case|case
name|ASHIFT
case|:
name|printf
argument_list|(
literal|"<< "
argument_list|)
expr_stmt|;
break|break;
case|case
name|LSHIFTRT
case|:
case|case
name|ASHIFTRT
case|:
name|printf
argument_list|(
literal|">> "
argument_list|)
expr_stmt|;
break|break;
block|}
name|write_test_expr
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|in_comparison
operator|||
name|comparison_operator
argument_list|)
expr_stmt|;
break|break;
case|case
name|NOT
case|:
comment|/* Special-case (not (eq_attrq "alternative" "x")) */
if|if
condition|(
operator|!
name|in_comparison
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|EQ_ATTR
operator|&&
name|XSTR
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|alternative_name
condition|)
block|{
name|printf
argument_list|(
literal|"which_alternative != %s"
argument_list|,
name|XSTR
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Otherwise, fall through to normal unary operator.  */
comment|/* Unary operators.  */
case|case
name|ABS
case|:
case|case
name|NEG
case|:
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|NOT
case|:
if|if
condition|(
name|in_comparison
condition|)
name|printf
argument_list|(
literal|"~ "
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"! "
argument_list|)
expr_stmt|;
break|break;
case|case
name|ABS
case|:
name|printf
argument_list|(
literal|"abs "
argument_list|)
expr_stmt|;
break|break;
case|case
name|NEG
case|:
name|printf
argument_list|(
literal|"-"
argument_list|)
expr_stmt|;
break|break;
block|}
name|write_test_expr
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|in_comparison
argument_list|)
expr_stmt|;
break|break;
comment|/* Comparison test of an attribute with a value.  Most of these will        have been removed by optimization.   Handle "alternative"        specially and give error if EQ_ATTR present inside a comparison.  */
case|case
name|EQ_ATTR
case|:
if|if
condition|(
name|in_comparison
condition|)
name|fatal
argument_list|(
literal|"EQ_ATTR not valid inside comparison"
argument_list|)
expr_stmt|;
if|if
condition|(
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
operator|==
name|alternative_name
condition|)
block|{
name|printf
argument_list|(
literal|"which_alternative == %s"
argument_list|,
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|attr
operator|=
name|find_attr
argument_list|(
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|attr
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Now is the time to expand the value of a constant attribute.  */
if|if
condition|(
name|attr
operator|->
name|is_const
condition|)
block|{
name|write_test_expr
argument_list|(
name|evaluate_eq_attr
argument_list|(
name|exp
argument_list|,
name|attr
operator|->
name|default_val
operator|->
name|value
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|in_comparison
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"get_attr_%s (insn) == "
argument_list|,
name|attr
operator|->
name|name
argument_list|)
expr_stmt|;
name|write_attr_valueq
argument_list|(
name|attr
argument_list|,
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* See if an operand matches a predicate.  */
case|case
name|MATCH_OPERAND
case|:
comment|/* If only a mode is given, just ensure the mode matches the operand. 	 If neither a mode nor predicate is given, error.  */
if|if
condition|(
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
operator|==
name|NULL
operator|||
operator|*
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
name|GET_MODE
argument_list|(
name|exp
argument_list|)
operator|==
name|VOIDmode
condition|)
name|fatal
argument_list|(
literal|"Null MATCH_OPERAND specified as test"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"GET_MODE (operands[%d]) == %smode"
argument_list|,
name|XINT
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GET_MODE_NAME
argument_list|(
name|GET_MODE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"%s (operands[%d], %smode)"
argument_list|,
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|XINT
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GET_MODE_NAME
argument_list|(
name|GET_MODE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
comment|/* Constant integer. */
case|case
name|CONST_INT
case|:
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|==
name|HOST_BITS_PER_INT
name|printf
argument_list|(
literal|"%d"
argument_list|,
name|XWINT
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
literal|"%ld"
argument_list|,
name|XWINT
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
comment|/* A random C expression. */
case|case
name|SYMBOL_REF
case|:
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
comment|/* The address of the branch target.  */
case|case
name|MATCH_DUP
case|:
name|printf
argument_list|(
literal|"insn_addresses[INSN_UID (JUMP_LABEL (insn))]"
argument_list|)
expr_stmt|;
break|break;
comment|/* The address of the current insn.  It would be more consistent with        other usage to make this the address of the NEXT insn, but this gets        too confusing because of the ambiguity regarding the length of the        current insn.  */
case|case
name|PC
case|:
name|printf
argument_list|(
literal|"insn_current_address"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fatal
argument_list|(
literal|"bad RTX code `%s' in attribute calculation\n"
argument_list|,
name|GET_RTX_NAME
argument_list|(
name|code
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given an attribute value, return the maximum CONST_STRING argument    encountered.  It is assumed that they are all numeric.  */
end_comment

begin_function
specifier|static
name|int
name|max_attr_value
parameter_list|(
name|exp
parameter_list|)
name|rtx
name|exp
decl_stmt|;
block|{
name|int
name|current_max
init|=
literal|0
decl_stmt|;
name|int
name|n
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|CONST_STRING
condition|)
return|return
name|atoi
argument_list|(
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|COND
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|+=
literal|2
control|)
block|{
name|n
operator|=
name|max_attr_value
argument_list|(
name|XVECEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|,
name|i
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>
name|current_max
condition|)
name|current_max
operator|=
name|n
expr_stmt|;
block|}
name|n
operator|=
name|max_attr_value
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>
name|current_max
condition|)
name|current_max
operator|=
name|n
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|IF_THEN_ELSE
condition|)
block|{
name|current_max
operator|=
name|max_attr_value
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|max_attr_value
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>
name|current_max
condition|)
name|current_max
operator|=
name|n
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
return|return
name|current_max
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Scan an attribute value, possibly a conditional, and record what actions    will be required to do any conditional tests in it.     Specifically, set 	`must_extract'	  if we need to extract the insn operands 	`must_constrain'  if we must compute `which_alternative' 	`address_used'	  if an address expression was used 	`length_used'	  if an (eq_attr "length" ...) was used  */
end_comment

begin_function
specifier|static
name|void
name|walk_attr_value
parameter_list|(
name|exp
parameter_list|)
name|rtx
name|exp
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|register
name|char
modifier|*
name|fmt
decl_stmt|;
name|RTX_CODE
name|code
decl_stmt|;
if|if
condition|(
name|exp
operator|==
name|NULL
condition|)
return|return;
name|code
operator|=
name|GET_CODE
argument_list|(
name|exp
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|SYMBOL_REF
case|:
if|if
condition|(
operator|!
name|RTX_UNCHANGING_P
argument_list|(
name|exp
argument_list|)
condition|)
comment|/* Since this is an arbitrary expression, it can look at anything. 	   However, constant expressions do not depend on any particular 	   insn.  */
name|must_extract
operator|=
name|must_constrain
operator|=
literal|1
expr_stmt|;
return|return;
case|case
name|MATCH_OPERAND
case|:
name|must_extract
operator|=
literal|1
expr_stmt|;
return|return;
case|case
name|EQ_ATTR
case|:
if|if
condition|(
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
operator|==
name|alternative_name
condition|)
name|must_extract
operator|=
name|must_constrain
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|XSTR
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|"length"
argument_list|)
operator|==
literal|0
condition|)
name|length_used
operator|=
literal|1
expr_stmt|;
return|return;
case|case
name|MATCH_DUP
case|:
case|case
name|PC
case|:
name|address_used
operator|=
literal|1
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
init|;
name|i
operator|<
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
condition|;
name|i
operator|++
control|)
switch|switch
condition|(
operator|*
name|fmt
operator|++
condition|)
block|{
case|case
literal|'e'
case|:
case|case
literal|'u'
case|:
name|walk_attr_value
argument_list|(
name|XEXP
argument_list|(
name|exp
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
if|if
condition|(
name|XVEC
argument_list|(
name|exp
argument_list|,
name|i
argument_list|)
operator|!=
name|NULL
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|exp
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|walk_attr_value
argument_list|(
name|XVECEXP
argument_list|(
name|exp
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Write out a function to obtain the attribute for a given INSN.  */
end_comment

begin_function
specifier|static
name|void
name|write_attr_get
parameter_list|(
name|attr
parameter_list|)
name|struct
name|attr_desc
modifier|*
name|attr
decl_stmt|;
block|{
name|struct
name|attr_value
modifier|*
name|av
decl_stmt|,
modifier|*
name|common_av
decl_stmt|;
comment|/* Find the most used attribute value.  Handle that as the `default' of the      switch we will generate. */
name|common_av
operator|=
name|find_most_used
argument_list|(
name|attr
argument_list|)
expr_stmt|;
comment|/* Write out start of function, then all values with explicit `case' lines,      then a `default', then the value with the most uses.  */
if|if
condition|(
operator|!
name|attr
operator|->
name|is_numeric
condition|)
name|printf
argument_list|(
literal|"enum attr_%s\n"
argument_list|,
name|attr
operator|->
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|attr
operator|->
name|unsigned_p
condition|)
name|printf
argument_list|(
literal|"unsigned int\n"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"int\n"
argument_list|)
expr_stmt|;
comment|/* If the attribute name starts with a star, the remainder is the name of      the subroutine to use, instead of `get_attr_...'.  */
if|if
condition|(
name|attr
operator|->
name|name
index|[
literal|0
index|]
operator|==
literal|'*'
condition|)
name|printf
argument_list|(
literal|"%s (insn)\n"
argument_list|,
operator|&
name|attr
operator|->
name|name
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|attr
operator|->
name|is_const
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"get_attr_%s (insn)\n"
argument_list|,
name|attr
operator|->
name|name
argument_list|)
expr_stmt|;
else|else
block|{
name|printf
argument_list|(
literal|"get_attr_%s ()\n"
argument_list|,
name|attr
operator|->
name|name
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"{\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|av
operator|=
name|attr
operator|->
name|first_value
init|;
name|av
condition|;
name|av
operator|=
name|av
operator|->
name|next
control|)
if|if
condition|(
name|av
operator|->
name|num_insns
operator|!=
literal|0
condition|)
name|write_attr_set
argument_list|(
name|attr
argument_list|,
literal|2
argument_list|,
name|av
operator|->
name|value
argument_list|,
literal|"return"
argument_list|,
literal|";"
argument_list|,
name|true_rtx
argument_list|,
name|av
operator|->
name|first_insn
operator|->
name|insn_code
argument_list|,
name|av
operator|->
name|first_insn
operator|->
name|insn_index
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"}\n\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|printf
argument_list|(
literal|"     rtx insn;\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"{\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  switch (recog_memoized (insn))\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    {\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|av
operator|=
name|attr
operator|->
name|first_value
init|;
name|av
condition|;
name|av
operator|=
name|av
operator|->
name|next
control|)
if|if
condition|(
name|av
operator|!=
name|common_av
condition|)
name|write_attr_case
argument_list|(
name|attr
argument_list|,
name|av
argument_list|,
literal|1
argument_list|,
literal|"return"
argument_list|,
literal|";"
argument_list|,
literal|4
argument_list|,
name|true_rtx
argument_list|)
expr_stmt|;
name|write_attr_case
argument_list|(
name|attr
argument_list|,
name|common_av
argument_list|,
literal|0
argument_list|,
literal|"return"
argument_list|,
literal|";"
argument_list|,
literal|4
argument_list|,
name|true_rtx
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    }\n}\n\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given an AND tree of known true terms (because we are inside an `if' with    that as the condition or are in an `else' clause) and an expression,    replace any known true terms with TRUE.  Use `simplify_and_tree' to do    the bulk of the work.  */
end_comment

begin_function
specifier|static
name|rtx
name|eliminate_known_true
parameter_list|(
name|known_true
parameter_list|,
name|exp
parameter_list|,
name|insn_code
parameter_list|,
name|insn_index
parameter_list|)
name|rtx
name|known_true
decl_stmt|;
name|rtx
name|exp
decl_stmt|;
name|int
name|insn_code
decl_stmt|,
name|insn_index
decl_stmt|;
block|{
name|rtx
name|term
decl_stmt|;
name|known_true
operator|=
name|SIMPLIFY_TEST_EXP
argument_list|(
name|known_true
argument_list|,
name|insn_code
argument_list|,
name|insn_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|known_true
argument_list|)
operator|==
name|AND
condition|)
block|{
name|exp
operator|=
name|eliminate_known_true
argument_list|(
name|XEXP
argument_list|(
name|known_true
argument_list|,
literal|0
argument_list|)
argument_list|,
name|exp
argument_list|,
name|insn_code
argument_list|,
name|insn_index
argument_list|)
expr_stmt|;
name|exp
operator|=
name|eliminate_known_true
argument_list|(
name|XEXP
argument_list|(
name|known_true
argument_list|,
literal|1
argument_list|)
argument_list|,
name|exp
argument_list|,
name|insn_code
argument_list|,
name|insn_index
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|term
operator|=
name|known_true
expr_stmt|;
name|exp
operator|=
name|simplify_and_tree
argument_list|(
name|exp
argument_list|,
operator|&
name|term
argument_list|,
name|insn_code
argument_list|,
name|insn_index
argument_list|)
expr_stmt|;
block|}
return|return
name|exp
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Write out a series of tests and assignment statements to perform tests and    sets of an attribute value.  We are passed an indentation amount and prefix    and suffix strings to write around each attribute value (e.g., "return"    and ";").  */
end_comment

begin_function
specifier|static
name|void
name|write_attr_set
parameter_list|(
name|attr
parameter_list|,
name|indent
parameter_list|,
name|value
parameter_list|,
name|prefix
parameter_list|,
name|suffix
parameter_list|,
name|known_true
parameter_list|,
name|insn_code
parameter_list|,
name|insn_index
parameter_list|)
name|struct
name|attr_desc
modifier|*
name|attr
decl_stmt|;
name|int
name|indent
decl_stmt|;
name|rtx
name|value
decl_stmt|;
name|char
modifier|*
name|prefix
decl_stmt|;
name|char
modifier|*
name|suffix
decl_stmt|;
name|rtx
name|known_true
decl_stmt|;
name|int
name|insn_code
decl_stmt|,
name|insn_index
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|CONST_STRING
condition|)
block|{
name|write_indent
argument_list|(
name|indent
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s "
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
name|write_attr_value
argument_list|(
name|attr
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|suffix
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|COND
condition|)
block|{
comment|/* Assume the default value will be the default of the COND unless we 	 find an always true expression.  */
name|rtx
name|default_val
init|=
name|XEXP
argument_list|(
name|value
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|rtx
name|our_known_true
init|=
name|known_true
decl_stmt|;
name|rtx
name|newexp
decl_stmt|;
name|int
name|first_if
init|=
literal|1
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|+=
literal|2
control|)
block|{
name|rtx
name|testexp
decl_stmt|;
name|rtx
name|inner_true
decl_stmt|;
name|testexp
operator|=
name|eliminate_known_true
argument_list|(
name|our_known_true
argument_list|,
name|XVECEXP
argument_list|(
name|value
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
name|insn_code
argument_list|,
name|insn_index
argument_list|)
expr_stmt|;
name|newexp
operator|=
name|attr_rtx
argument_list|(
name|NOT
argument_list|,
name|testexp
argument_list|)
expr_stmt|;
name|newexp
operator|=
name|insert_right_side
argument_list|(
name|AND
argument_list|,
name|our_known_true
argument_list|,
name|newexp
argument_list|,
name|insn_code
argument_list|,
name|insn_index
argument_list|)
expr_stmt|;
comment|/* If the test expression is always true or if the next `known_true' 	     expression is always false, this is the last case, so break 	     out and let this value be the `else' case.  */
if|if
condition|(
name|testexp
operator|==
name|true_rtx
operator|||
name|newexp
operator|==
name|false_rtx
condition|)
block|{
name|default_val
operator|=
name|XVECEXP
argument_list|(
name|value
argument_list|,
literal|0
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Compute the expression to pass to our recursive call as being 	     known true.  */
name|inner_true
operator|=
name|insert_right_side
argument_list|(
name|AND
argument_list|,
name|our_known_true
argument_list|,
name|testexp
argument_list|,
name|insn_code
argument_list|,
name|insn_index
argument_list|)
expr_stmt|;
comment|/* If this is always false, skip it.  */
if|if
condition|(
name|inner_true
operator|==
name|false_rtx
condition|)
continue|continue;
name|write_indent
argument_list|(
name|indent
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%sif "
argument_list|,
name|first_if
condition|?
literal|""
else|:
literal|"else "
argument_list|)
expr_stmt|;
name|first_if
operator|=
literal|0
expr_stmt|;
name|write_test_expr
argument_list|(
name|testexp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|write_indent
argument_list|(
name|indent
operator|+
literal|2
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"{\n"
argument_list|)
expr_stmt|;
name|write_attr_set
argument_list|(
name|attr
argument_list|,
name|indent
operator|+
literal|4
argument_list|,
name|XVECEXP
argument_list|(
name|value
argument_list|,
literal|0
argument_list|,
name|i
operator|+
literal|1
argument_list|)
argument_list|,
name|prefix
argument_list|,
name|suffix
argument_list|,
name|inner_true
argument_list|,
name|insn_code
argument_list|,
name|insn_index
argument_list|)
expr_stmt|;
name|write_indent
argument_list|(
name|indent
operator|+
literal|2
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"}\n"
argument_list|)
expr_stmt|;
name|our_known_true
operator|=
name|newexp
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|first_if
condition|)
block|{
name|write_indent
argument_list|(
name|indent
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"else\n"
argument_list|)
expr_stmt|;
name|write_indent
argument_list|(
name|indent
operator|+
literal|2
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"{\n"
argument_list|)
expr_stmt|;
block|}
name|write_attr_set
argument_list|(
name|attr
argument_list|,
name|first_if
condition|?
name|indent
else|:
name|indent
operator|+
literal|4
argument_list|,
name|default_val
argument_list|,
name|prefix
argument_list|,
name|suffix
argument_list|,
name|our_known_true
argument_list|,
name|insn_code
argument_list|,
name|insn_index
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|first_if
condition|)
block|{
name|write_indent
argument_list|(
name|indent
operator|+
literal|2
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"}\n"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Write out the computation for one attribute value.  */
end_comment

begin_function
specifier|static
name|void
name|write_attr_case
parameter_list|(
name|attr
parameter_list|,
name|av
parameter_list|,
name|write_case_lines
parameter_list|,
name|prefix
parameter_list|,
name|suffix
parameter_list|,
name|indent
parameter_list|,
name|known_true
parameter_list|)
name|struct
name|attr_desc
modifier|*
name|attr
decl_stmt|;
name|struct
name|attr_value
modifier|*
name|av
decl_stmt|;
name|int
name|write_case_lines
decl_stmt|;
name|char
modifier|*
name|prefix
decl_stmt|,
decl|*
name|suffix
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|indent
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rtx
name|known_true
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|insn_ent
modifier|*
name|ie
decl_stmt|;
if|if
condition|(
name|av
operator|->
name|num_insns
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|av
operator|->
name|has_asm_insn
condition|)
block|{
name|write_indent
argument_list|(
name|indent
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"case -1:\n"
argument_list|)
expr_stmt|;
name|write_indent
argument_list|(
name|indent
operator|+
literal|2
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"if (GET_CODE (PATTERN (insn)) != ASM_INPUT\n"
argument_list|)
expr_stmt|;
name|write_indent
argument_list|(
name|indent
operator|+
literal|2
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"&& asm_noperands (PATTERN (insn))< 0)\n"
argument_list|)
expr_stmt|;
name|write_indent
argument_list|(
name|indent
operator|+
literal|2
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  fatal_insn_not_found (insn);\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|write_case_lines
condition|)
block|{
for|for
control|(
name|ie
operator|=
name|av
operator|->
name|first_insn
init|;
name|ie
condition|;
name|ie
operator|=
name|ie
operator|->
name|next
control|)
if|if
condition|(
name|ie
operator|->
name|insn_code
operator|!=
operator|-
literal|1
condition|)
block|{
name|write_indent
argument_list|(
name|indent
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"case %d:\n"
argument_list|,
name|ie
operator|->
name|insn_code
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|write_indent
argument_list|(
name|indent
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"default:\n"
argument_list|)
expr_stmt|;
block|}
comment|/* See what we have to do to output this value.  */
name|must_extract
operator|=
name|must_constrain
operator|=
name|address_used
operator|=
literal|0
expr_stmt|;
name|walk_attr_value
argument_list|(
name|av
operator|->
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|must_extract
condition|)
block|{
name|write_indent
argument_list|(
name|indent
operator|+
literal|2
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"insn_extract (insn);\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|must_constrain
condition|)
block|{
ifdef|#
directive|ifdef
name|REGISTER_CONSTRAINTS
name|write_indent
argument_list|(
name|indent
operator|+
literal|2
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"if (! constrain_operands (INSN_CODE (insn), reload_completed))\n"
argument_list|)
expr_stmt|;
name|write_indent
argument_list|(
name|indent
operator|+
literal|2
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  fatal_insn_not_found (insn);\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|write_attr_set
argument_list|(
name|attr
argument_list|,
name|indent
operator|+
literal|2
argument_list|,
name|av
operator|->
name|value
argument_list|,
name|prefix
argument_list|,
name|suffix
argument_list|,
name|known_true
argument_list|,
name|av
operator|->
name|first_insn
operator|->
name|insn_code
argument_list|,
name|av
operator|->
name|first_insn
operator|->
name|insn_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|prefix
argument_list|,
literal|"return"
argument_list|,
literal|6
argument_list|)
condition|)
block|{
name|write_indent
argument_list|(
name|indent
operator|+
literal|2
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"break;\n"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Utilities to write names in various forms.  */
end_comment

begin_function
specifier|static
name|void
name|write_attr_valueq
parameter_list|(
name|attr
parameter_list|,
name|s
parameter_list|)
name|struct
name|attr_desc
modifier|*
name|attr
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
block|{
if|if
condition|(
name|attr
operator|->
name|is_numeric
condition|)
block|{
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|s
argument_list|)
expr_stmt|;
comment|/* Make the blockage range values easier to read.  */
if|if
condition|(
name|strlen
argument_list|(
name|s
argument_list|)
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|" /* 0x%x */"
argument_list|,
name|atoi
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|write_upcase
argument_list|(
name|attr
operator|->
name|name
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"_"
argument_list|)
expr_stmt|;
name|write_upcase
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|write_attr_value
parameter_list|(
name|attr
parameter_list|,
name|value
parameter_list|)
name|struct
name|attr_desc
modifier|*
name|attr
decl_stmt|;
name|rtx
name|value
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|!=
name|CONST_STRING
condition|)
name|abort
argument_list|()
expr_stmt|;
name|write_attr_valueq
argument_list|(
name|attr
argument_list|,
name|XSTR
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|write_upcase
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
while|while
condition|(
operator|*
name|str
condition|)
if|if
condition|(
operator|*
name|str
operator|<
literal|'a'
operator|||
operator|*
name|str
operator|>
literal|'z'
condition|)
name|printf
argument_list|(
literal|"%c"
argument_list|,
operator|*
name|str
operator|++
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%c"
argument_list|,
operator|*
name|str
operator|++
operator|-
literal|'a'
operator|+
literal|'A'
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|write_indent
parameter_list|(
name|indent
parameter_list|)
name|int
name|indent
decl_stmt|;
block|{
for|for
control|(
init|;
name|indent
operator|>
literal|8
condition|;
name|indent
operator|-=
literal|8
control|)
name|printf
argument_list|(
literal|"\t"
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|indent
condition|;
name|indent
operator|--
control|)
name|printf
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Write a subroutine that is given an insn that requires a delay slot, a    delay slot ordinal, and a candidate insn.  It returns non-zero if the    candidate can be placed in the specified delay slot of the insn.     We can write as many as three subroutines.  `eligible_for_delay'    handles normal delay slots, `eligible_for_annul_true' indicates that    the specified insn can be annulled if the branch is true, and likewise    for `eligible_for_annul_false'.     KIND is a string distinguishing these three cases ("delay", "annul_true",    or "annul_false").  */
end_comment

begin_function
specifier|static
name|void
name|write_eligible_delay
parameter_list|(
name|kind
parameter_list|)
name|char
modifier|*
name|kind
decl_stmt|;
block|{
name|struct
name|delay_desc
modifier|*
name|delay
decl_stmt|;
name|int
name|max_slots
decl_stmt|;
name|char
name|str
index|[
literal|50
index|]
decl_stmt|;
name|struct
name|attr_desc
modifier|*
name|attr
decl_stmt|;
name|struct
name|attr_value
modifier|*
name|av
decl_stmt|,
modifier|*
name|common_av
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Compute the maximum number of delay slots required.  We use the delay      ordinal times this number plus one, plus the slot number as an index into      the appropriate predicate to test.  */
for|for
control|(
name|delay
operator|=
name|delays
operator|,
name|max_slots
operator|=
literal|0
init|;
name|delay
condition|;
name|delay
operator|=
name|delay
operator|->
name|next
control|)
if|if
condition|(
name|XVECLEN
argument_list|(
name|delay
operator|->
name|def
argument_list|,
literal|1
argument_list|)
operator|/
literal|3
operator|>
name|max_slots
condition|)
name|max_slots
operator|=
name|XVECLEN
argument_list|(
name|delay
operator|->
name|def
argument_list|,
literal|1
argument_list|)
operator|/
literal|3
expr_stmt|;
comment|/* Write function prelude.  */
name|printf
argument_list|(
literal|"int\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"eligible_for_%s (delay_insn, slot, candidate_insn)\n"
argument_list|,
name|kind
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"     rtx delay_insn;\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"     int slot;\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"     rtx candidate_insn;\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"{\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  rtx insn;\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  if (slot>= %d)\n"
argument_list|,
name|max_slots
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    abort ();\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* If more than one delay type, find out which type the delay insn is.  */
if|if
condition|(
name|num_delays
operator|>
literal|1
condition|)
block|{
name|attr
operator|=
name|find_attr
argument_list|(
literal|"*delay_type"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|attr
condition|)
name|abort
argument_list|()
expr_stmt|;
name|common_av
operator|=
name|find_most_used
argument_list|(
name|attr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  insn = delay_insn;\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  switch (recog_memoized (insn))\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    {\n"
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|str
argument_list|,
literal|" * %d;\n      break;"
argument_list|,
name|max_slots
argument_list|)
expr_stmt|;
for|for
control|(
name|av
operator|=
name|attr
operator|->
name|first_value
init|;
name|av
condition|;
name|av
operator|=
name|av
operator|->
name|next
control|)
if|if
condition|(
name|av
operator|!=
name|common_av
condition|)
name|write_attr_case
argument_list|(
name|attr
argument_list|,
name|av
argument_list|,
literal|1
argument_list|,
literal|"slot +="
argument_list|,
name|str
argument_list|,
literal|4
argument_list|,
name|true_rtx
argument_list|)
expr_stmt|;
name|write_attr_case
argument_list|(
name|attr
argument_list|,
name|common_av
argument_list|,
literal|0
argument_list|,
literal|"slot +="
argument_list|,
name|str
argument_list|,
literal|4
argument_list|,
name|true_rtx
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    }\n\n"
argument_list|)
expr_stmt|;
comment|/* Ensure matched.  Otherwise, shouldn't have been called.  */
name|printf
argument_list|(
literal|"  if (slot< %d)\n"
argument_list|,
name|max_slots
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    abort ();\n\n"
argument_list|)
expr_stmt|;
block|}
comment|/* If just one type of delay slot, write simple switch.  */
if|if
condition|(
name|num_delays
operator|==
literal|1
operator|&&
name|max_slots
operator|==
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"  insn = candidate_insn;\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  switch (recog_memoized (insn))\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    {\n"
argument_list|)
expr_stmt|;
name|attr
operator|=
name|find_attr
argument_list|(
literal|"*delay_1_0"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|attr
condition|)
name|abort
argument_list|()
expr_stmt|;
name|common_av
operator|=
name|find_most_used
argument_list|(
name|attr
argument_list|)
expr_stmt|;
for|for
control|(
name|av
operator|=
name|attr
operator|->
name|first_value
init|;
name|av
condition|;
name|av
operator|=
name|av
operator|->
name|next
control|)
if|if
condition|(
name|av
operator|!=
name|common_av
condition|)
name|write_attr_case
argument_list|(
name|attr
argument_list|,
name|av
argument_list|,
literal|1
argument_list|,
literal|"return"
argument_list|,
literal|";"
argument_list|,
literal|4
argument_list|,
name|true_rtx
argument_list|)
expr_stmt|;
name|write_attr_case
argument_list|(
name|attr
argument_list|,
name|common_av
argument_list|,
literal|0
argument_list|,
literal|"return"
argument_list|,
literal|";"
argument_list|,
literal|4
argument_list|,
name|true_rtx
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    }\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Write a nested CASE.  The first indicates which condition we need to 	 test, and the inner CASE tests the condition.  */
name|printf
argument_list|(
literal|"  insn = candidate_insn;\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  switch (slot)\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    {\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|delay
operator|=
name|delays
init|;
name|delay
condition|;
name|delay
operator|=
name|delay
operator|->
name|next
control|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|delay
operator|->
name|def
argument_list|,
literal|1
argument_list|)
condition|;
name|i
operator|+=
literal|3
control|)
block|{
name|printf
argument_list|(
literal|"    case %d:\n"
argument_list|,
operator|(
name|i
operator|/
literal|3
operator|)
operator|+
operator|(
name|num_delays
operator|==
literal|1
condition|?
literal|0
else|:
name|delay
operator|->
name|num
operator|*
name|max_slots
operator|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"      switch (recog_memoized (insn))\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\t{\n"
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|str
argument_list|,
literal|"*%s_%d_%d"
argument_list|,
name|kind
argument_list|,
name|delay
operator|->
name|num
argument_list|,
name|i
operator|/
literal|3
argument_list|)
expr_stmt|;
name|attr
operator|=
name|find_attr
argument_list|(
name|str
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|attr
condition|)
name|abort
argument_list|()
expr_stmt|;
name|common_av
operator|=
name|find_most_used
argument_list|(
name|attr
argument_list|)
expr_stmt|;
for|for
control|(
name|av
operator|=
name|attr
operator|->
name|first_value
init|;
name|av
condition|;
name|av
operator|=
name|av
operator|->
name|next
control|)
if|if
condition|(
name|av
operator|!=
name|common_av
condition|)
name|write_attr_case
argument_list|(
name|attr
argument_list|,
name|av
argument_list|,
literal|1
argument_list|,
literal|"return"
argument_list|,
literal|";"
argument_list|,
literal|8
argument_list|,
name|true_rtx
argument_list|)
expr_stmt|;
name|write_attr_case
argument_list|(
name|attr
argument_list|,
name|common_av
argument_list|,
literal|0
argument_list|,
literal|"return"
argument_list|,
literal|";"
argument_list|,
literal|8
argument_list|,
name|true_rtx
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"      }\n"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"    default:\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"      abort ();\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    }\n"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"}\n\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Write routines to compute conflict cost for function units.  Then write a    table describing the available function units.  */
end_comment

begin_function
specifier|static
name|void
name|write_function_unit_info
parameter_list|()
block|{
name|struct
name|function_unit
modifier|*
name|unit
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Write out conflict routines for function units.  Don't bother writing      one if there is only one issue delay value.  */
for|for
control|(
name|unit
operator|=
name|units
init|;
name|unit
condition|;
name|unit
operator|=
name|unit
operator|->
name|next
control|)
block|{
if|if
condition|(
name|unit
operator|->
name|needs_blockage_function
condition|)
name|write_complex_function
argument_list|(
name|unit
argument_list|,
literal|"blockage"
argument_list|,
literal|"block"
argument_list|)
expr_stmt|;
comment|/* If the minimum and maximum conflict costs are the same, there 	 is only one value, so we don't need a function.  */
if|if
condition|(
operator|!
name|unit
operator|->
name|needs_conflict_function
condition|)
block|{
name|unit
operator|->
name|default_cost
operator|=
name|make_numeric_value
argument_list|(
name|unit
operator|->
name|issue_delay
operator|.
name|max
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* The function first computes the case from the candidate insn.  */
name|unit
operator|->
name|default_cost
operator|=
name|make_numeric_value
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|write_complex_function
argument_list|(
name|unit
argument_list|,
literal|"conflict_cost"
argument_list|,
literal|"cost"
argument_list|)
expr_stmt|;
block|}
comment|/* Now that all functions have been written, write the table describing      the function units.   The name is included for documentation purposes      only.  */
name|printf
argument_list|(
literal|"struct function_unit_desc function_units[] = {\n"
argument_list|)
expr_stmt|;
comment|/* Write out the descriptions in numeric order, but don't force that order      on the list.  Doing so increases the runtime of genattrtab.c.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_units
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|unit
operator|=
name|units
init|;
name|unit
condition|;
name|unit
operator|=
name|unit
operator|->
name|next
control|)
if|if
condition|(
name|unit
operator|->
name|num
operator|==
name|i
condition|)
break|break;
name|printf
argument_list|(
literal|"  {\"%s\", %d, %d, %d, %s, %d, %s_unit_ready_cost, "
argument_list|,
name|unit
operator|->
name|name
argument_list|,
literal|1
operator|<<
name|unit
operator|->
name|num
argument_list|,
name|unit
operator|->
name|multiplicity
argument_list|,
name|unit
operator|->
name|simultaneity
argument_list|,
name|XSTR
argument_list|(
name|unit
operator|->
name|default_cost
argument_list|,
literal|0
argument_list|)
argument_list|,
name|unit
operator|->
name|issue_delay
operator|.
name|max
argument_list|,
name|unit
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|unit
operator|->
name|needs_conflict_function
condition|)
name|printf
argument_list|(
literal|"%s_unit_conflict_cost, "
argument_list|,
name|unit
operator|->
name|name
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"0, "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%d, "
argument_list|,
name|unit
operator|->
name|max_blockage
argument_list|)
expr_stmt|;
if|if
condition|(
name|unit
operator|->
name|needs_range_function
condition|)
name|printf
argument_list|(
literal|"%s_unit_blockage_range, "
argument_list|,
name|unit
operator|->
name|name
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"0, "
argument_list|)
expr_stmt|;
if|if
condition|(
name|unit
operator|->
name|needs_blockage_function
condition|)
name|printf
argument_list|(
literal|"%s_unit_blockage"
argument_list|,
name|unit
operator|->
name|name
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"0"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"}, \n"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"};\n\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|write_complex_function
parameter_list|(
name|unit
parameter_list|,
name|name
parameter_list|,
name|connection
parameter_list|)
name|struct
name|function_unit
modifier|*
name|unit
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|,
decl|*
name|connection
decl_stmt|;
end_function

begin_block
block|{
name|struct
name|attr_desc
modifier|*
name|case_attr
decl_stmt|,
modifier|*
name|attr
decl_stmt|;
name|struct
name|attr_value
modifier|*
name|av
decl_stmt|,
modifier|*
name|common_av
decl_stmt|;
name|rtx
name|value
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
name|int
name|using_case
decl_stmt|;
name|int
name|i
decl_stmt|;
name|printf
argument_list|(
literal|"static int\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s_unit_%s (executing_insn, candidate_insn)\n"
argument_list|,
name|unit
operator|->
name|name
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"     rtx executing_insn;\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"     rtx candidate_insn;\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"{\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  rtx insn;\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  int casenum;\n\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  insn = candidate_insn;\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  switch (recog_memoized (insn))\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    {\n"
argument_list|)
expr_stmt|;
comment|/* Write the `switch' statement to get the case value.  */
name|str
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|unit
operator|->
name|name
argument_list|)
operator|+
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
name|strlen
argument_list|(
name|connection
argument_list|)
operator|+
literal|10
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|str
argument_list|,
literal|"*%s_cases"
argument_list|,
name|unit
operator|->
name|name
argument_list|)
expr_stmt|;
name|case_attr
operator|=
name|find_attr
argument_list|(
name|str
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|case_attr
condition|)
name|abort
argument_list|()
expr_stmt|;
name|common_av
operator|=
name|find_most_used
argument_list|(
name|case_attr
argument_list|)
expr_stmt|;
for|for
control|(
name|av
operator|=
name|case_attr
operator|->
name|first_value
init|;
name|av
condition|;
name|av
operator|=
name|av
operator|->
name|next
control|)
if|if
condition|(
name|av
operator|!=
name|common_av
condition|)
name|write_attr_case
argument_list|(
name|case_attr
argument_list|,
name|av
argument_list|,
literal|1
argument_list|,
literal|"casenum ="
argument_list|,
literal|";"
argument_list|,
literal|4
argument_list|,
name|unit
operator|->
name|condexp
argument_list|)
expr_stmt|;
name|write_attr_case
argument_list|(
name|case_attr
argument_list|,
name|common_av
argument_list|,
literal|0
argument_list|,
literal|"casenum ="
argument_list|,
literal|";"
argument_list|,
literal|4
argument_list|,
name|unit
operator|->
name|condexp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    }\n\n"
argument_list|)
expr_stmt|;
comment|/* Now write an outer switch statement on each case.  Then write      the tests on the executing function within each.  */
name|printf
argument_list|(
literal|"  insn = executing_insn;\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  switch (casenum)\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    {\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|unit
operator|->
name|num_opclasses
condition|;
name|i
operator|++
control|)
block|{
comment|/* Ensure using this case.  */
name|using_case
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|av
operator|=
name|case_attr
operator|->
name|first_value
init|;
name|av
condition|;
name|av
operator|=
name|av
operator|->
name|next
control|)
if|if
condition|(
name|av
operator|->
name|num_insns
operator|&&
name|contained_in_p
argument_list|(
name|make_numeric_value
argument_list|(
name|i
argument_list|)
argument_list|,
name|av
operator|->
name|value
argument_list|)
condition|)
name|using_case
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|using_case
condition|)
continue|continue;
name|printf
argument_list|(
literal|"    case %d:\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|str
argument_list|,
literal|"*%s_%s_%d"
argument_list|,
name|unit
operator|->
name|name
argument_list|,
name|connection
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|attr
operator|=
name|find_attr
argument_list|(
name|str
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|attr
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* If single value, just write it.  */
name|value
operator|=
name|find_single_value
argument_list|(
name|attr
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
condition|)
name|write_attr_set
argument_list|(
name|attr
argument_list|,
literal|6
argument_list|,
name|value
argument_list|,
literal|"return"
argument_list|,
literal|";\n"
argument_list|,
name|true_rtx
argument_list|,
operator|-
literal|2
argument_list|)
expr_stmt|;
else|else
block|{
name|common_av
operator|=
name|find_most_used
argument_list|(
name|attr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"      switch (recog_memoized (insn))\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\t{\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|av
operator|=
name|attr
operator|->
name|first_value
init|;
name|av
condition|;
name|av
operator|=
name|av
operator|->
name|next
control|)
if|if
condition|(
name|av
operator|!=
name|common_av
condition|)
name|write_attr_case
argument_list|(
name|attr
argument_list|,
name|av
argument_list|,
literal|1
argument_list|,
literal|"return"
argument_list|,
literal|";"
argument_list|,
literal|8
argument_list|,
name|unit
operator|->
name|condexp
argument_list|)
expr_stmt|;
name|write_attr_case
argument_list|(
name|attr
argument_list|,
name|common_av
argument_list|,
literal|0
argument_list|,
literal|"return"
argument_list|,
literal|";"
argument_list|,
literal|8
argument_list|,
name|unit
operator|->
name|condexp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"      }\n\n"
argument_list|)
expr_stmt|;
block|}
block|}
name|printf
argument_list|(
literal|"    }\n}\n\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* This page contains miscellaneous utility routines.  */
end_comment

begin_comment
comment|/* Given a string, return the number of comma-separated elements in it.    Return 0 for the null string.  */
end_comment

begin_function
specifier|static
name|int
name|n_comma_elts
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|int
name|n
decl_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'\0'
condition|)
return|return
literal|0
return|;
for|for
control|(
name|n
operator|=
literal|1
init|;
operator|*
name|s
condition|;
name|s
operator|++
control|)
if|if
condition|(
operator|*
name|s
operator|==
literal|','
condition|)
name|n
operator|++
expr_stmt|;
return|return
name|n
return|;
block|}
end_function

begin_comment
comment|/* Given a pointer to a (char *), return a malloc'ed string containing the    next comma-separated element.  Advance the pointer to after the string    scanned, or the end-of-string.  Return NULL if at end of string.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|next_comma_elt
parameter_list|(
name|pstr
parameter_list|)
name|char
modifier|*
modifier|*
name|pstr
decl_stmt|;
block|{
name|char
modifier|*
name|out_str
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|*
operator|*
name|pstr
operator|==
literal|'\0'
condition|)
return|return
name|NULL
return|;
comment|/* Find end of string to compute length.  */
for|for
control|(
name|p
operator|=
operator|*
name|pstr
init|;
operator|*
name|p
operator|!=
literal|','
operator|&&
operator|*
name|p
operator|!=
literal|'\0'
condition|;
name|p
operator|++
control|)
empty_stmt|;
name|out_str
operator|=
name|attr_string
argument_list|(
operator|*
name|pstr
argument_list|,
name|p
operator|-
operator|*
name|pstr
argument_list|)
expr_stmt|;
operator|*
name|pstr
operator|=
name|p
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|pstr
operator|==
literal|','
condition|)
operator|(
operator|*
name|pstr
operator|)
operator|++
expr_stmt|;
return|return
name|out_str
return|;
block|}
end_function

begin_comment
comment|/* Return a `struct attr_desc' pointer for a given named attribute.  If CREATE    is non-zero, build a new attribute, if one does not exist.  */
end_comment

begin_function
specifier|static
name|struct
name|attr_desc
modifier|*
name|find_attr
parameter_list|(
name|name
parameter_list|,
name|create
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|create
decl_stmt|;
block|{
name|struct
name|attr_desc
modifier|*
name|attr
decl_stmt|;
name|int
name|index
decl_stmt|;
comment|/* Before we resort to using `strcmp', see if the string address matches      anywhere.  In most cases, it should have been canonicalized to do so.  */
if|if
condition|(
name|name
operator|==
name|alternative_name
condition|)
return|return
name|NULL
return|;
name|index
operator|=
name|name
index|[
literal|0
index|]
operator|&
operator|(
name|MAX_ATTRS_INDEX
operator|-
literal|1
operator|)
expr_stmt|;
for|for
control|(
name|attr
operator|=
name|attrs
index|[
name|index
index|]
init|;
name|attr
condition|;
name|attr
operator|=
name|attr
operator|->
name|next
control|)
if|if
condition|(
name|name
operator|==
name|attr
operator|->
name|name
condition|)
return|return
name|attr
return|;
comment|/* Otherwise, do it the slow way.  */
for|for
control|(
name|attr
operator|=
name|attrs
index|[
name|index
index|]
init|;
name|attr
condition|;
name|attr
operator|=
name|attr
operator|->
name|next
control|)
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
name|attr
operator|->
name|name
index|[
literal|0
index|]
operator|&&
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
name|attr
operator|->
name|name
argument_list|)
condition|)
return|return
name|attr
return|;
if|if
condition|(
operator|!
name|create
condition|)
return|return
name|NULL
return|;
name|attr
operator|=
operator|(
expr|struct
name|attr_desc
operator|*
operator|)
name|oballoc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|attr_desc
argument_list|)
argument_list|)
expr_stmt|;
name|attr
operator|->
name|name
operator|=
name|attr_string
argument_list|(
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|attr
operator|->
name|first_value
operator|=
name|attr
operator|->
name|default_val
operator|=
name|NULL
expr_stmt|;
name|attr
operator|->
name|is_numeric
operator|=
name|attr
operator|->
name|negative_ok
operator|=
name|attr
operator|->
name|is_const
operator|=
name|attr
operator|->
name|is_special
operator|=
literal|0
expr_stmt|;
name|attr
operator|->
name|next
operator|=
name|attrs
index|[
name|index
index|]
expr_stmt|;
name|attrs
index|[
name|index
index|]
operator|=
name|attr
expr_stmt|;
return|return
name|attr
return|;
block|}
end_function

begin_comment
comment|/* Create internal attribute with the given default value.  */
end_comment

begin_function
specifier|static
name|void
name|make_internal_attr
parameter_list|(
name|name
parameter_list|,
name|value
parameter_list|,
name|special
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|rtx
name|value
decl_stmt|;
name|int
name|special
decl_stmt|;
block|{
name|struct
name|attr_desc
modifier|*
name|attr
decl_stmt|;
name|attr
operator|=
name|find_attr
argument_list|(
name|name
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr
operator|->
name|default_val
condition|)
name|abort
argument_list|()
expr_stmt|;
name|attr
operator|->
name|is_numeric
operator|=
literal|1
expr_stmt|;
name|attr
operator|->
name|is_const
operator|=
literal|0
expr_stmt|;
name|attr
operator|->
name|is_special
operator|=
operator|(
name|special
operator|&
literal|1
operator|)
operator|!=
literal|0
expr_stmt|;
name|attr
operator|->
name|negative_ok
operator|=
operator|(
name|special
operator|&
literal|2
operator|)
operator|!=
literal|0
expr_stmt|;
name|attr
operator|->
name|unsigned_p
operator|=
operator|(
name|special
operator|&
literal|4
operator|)
operator|!=
literal|0
expr_stmt|;
name|attr
operator|->
name|default_val
operator|=
name|get_attr_value
argument_list|(
name|value
argument_list|,
name|attr
argument_list|,
operator|-
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Find the most used value of an attribute.  */
end_comment

begin_function
specifier|static
name|struct
name|attr_value
modifier|*
name|find_most_used
parameter_list|(
name|attr
parameter_list|)
name|struct
name|attr_desc
modifier|*
name|attr
decl_stmt|;
block|{
name|struct
name|attr_value
modifier|*
name|av
decl_stmt|;
name|struct
name|attr_value
modifier|*
name|most_used
decl_stmt|;
name|int
name|nuses
decl_stmt|;
name|most_used
operator|=
name|NULL
expr_stmt|;
name|nuses
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|av
operator|=
name|attr
operator|->
name|first_value
init|;
name|av
condition|;
name|av
operator|=
name|av
operator|->
name|next
control|)
if|if
condition|(
name|av
operator|->
name|num_insns
operator|>
name|nuses
condition|)
name|nuses
operator|=
name|av
operator|->
name|num_insns
operator|,
name|most_used
operator|=
name|av
expr_stmt|;
return|return
name|most_used
return|;
block|}
end_function

begin_comment
comment|/* If an attribute only has a single value used, return it.  Otherwise    return NULL.  */
end_comment

begin_function
specifier|static
name|rtx
name|find_single_value
parameter_list|(
name|attr
parameter_list|)
name|struct
name|attr_desc
modifier|*
name|attr
decl_stmt|;
block|{
name|struct
name|attr_value
modifier|*
name|av
decl_stmt|;
name|rtx
name|unique_value
decl_stmt|;
name|unique_value
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|av
operator|=
name|attr
operator|->
name|first_value
init|;
name|av
condition|;
name|av
operator|=
name|av
operator|->
name|next
control|)
if|if
condition|(
name|av
operator|->
name|num_insns
condition|)
block|{
if|if
condition|(
name|unique_value
condition|)
return|return
name|NULL
return|;
else|else
name|unique_value
operator|=
name|av
operator|->
name|value
expr_stmt|;
block|}
return|return
name|unique_value
return|;
block|}
end_function

begin_comment
comment|/* Return (attr_value "n") */
end_comment

begin_function
specifier|static
name|rtx
name|make_numeric_value
parameter_list|(
name|n
parameter_list|)
name|int
name|n
decl_stmt|;
block|{
specifier|static
name|rtx
name|int_values
index|[
literal|20
index|]
decl_stmt|;
name|rtx
name|exp
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|20
operator|&&
name|int_values
index|[
name|n
index|]
condition|)
return|return
name|int_values
index|[
name|n
index|]
return|;
name|p
operator|=
name|attr_printf
argument_list|(
name|MAX_DIGITS
argument_list|,
literal|"%d"
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|exp
operator|=
name|attr_rtx
argument_list|(
name|CONST_STRING
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|20
condition|)
name|int_values
index|[
name|n
index|]
operator|=
name|exp
expr_stmt|;
return|return
name|exp
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|extend_range
parameter_list|(
name|range
parameter_list|,
name|min
parameter_list|,
name|max
parameter_list|)
name|struct
name|range
modifier|*
name|range
decl_stmt|;
name|int
name|min
decl_stmt|;
name|int
name|max
decl_stmt|;
block|{
if|if
condition|(
name|range
operator|->
name|min
operator|>
name|min
condition|)
name|range
operator|->
name|min
operator|=
name|min
expr_stmt|;
if|if
condition|(
name|range
operator|->
name|max
operator|<
name|max
condition|)
name|range
operator|->
name|max
operator|=
name|max
expr_stmt|;
block|}
end_function

begin_function
name|char
modifier|*
name|xrealloc
parameter_list|(
name|ptr
parameter_list|,
name|size
parameter_list|)
name|char
modifier|*
name|ptr
decl_stmt|;
name|unsigned
name|size
decl_stmt|;
block|{
name|char
modifier|*
name|result
init|=
operator|(
name|char
operator|*
operator|)
name|realloc
argument_list|(
name|ptr
argument_list|,
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|result
condition|)
name|fatal
argument_list|(
literal|"virtual memory exhausted"
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|xmalloc
parameter_list|(
name|size
parameter_list|)
name|unsigned
name|size
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|val
init|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
name|val
operator|==
literal|0
condition|)
name|fatal
argument_list|(
literal|"virtual memory exhausted"
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_function
specifier|static
name|rtx
name|copy_rtx_unchanging
parameter_list|(
name|orig
parameter_list|)
specifier|register
name|rtx
name|orig
decl_stmt|;
block|{
if|#
directive|if
literal|0
block|register rtx copy;   register RTX_CODE code;
endif|#
directive|endif
if|if
condition|(
name|RTX_UNCHANGING_P
argument_list|(
name|orig
argument_list|)
operator|||
name|MEM_IN_STRUCT_P
argument_list|(
name|orig
argument_list|)
condition|)
return|return
name|orig
return|;
name|MEM_IN_STRUCT_P
argument_list|(
name|orig
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|orig
return|;
if|#
directive|if
literal|0
block|code = GET_CODE (orig);   switch (code)     {     case CONST_INT:     case CONST_DOUBLE:     case SYMBOL_REF:     case CODE_LABEL:       return orig;     }    copy = rtx_alloc (code);   PUT_MODE (copy, GET_MODE (orig));   RTX_UNCHANGING_P (copy) = 1;      bcopy (&XEXP (orig, 0),&XEXP (copy, 0), 	 GET_RTX_LENGTH (GET_CODE (copy)) * sizeof (rtx));   return copy;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|fatal
parameter_list|(
name|s
parameter_list|,
name|a1
parameter_list|,
name|a2
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"genattrtab: "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|s
argument_list|,
name|a1
argument_list|,
name|a2
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|FATAL_EXIT_CODE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* More 'friendly' abort that prints the line and file.    config.h can #define abort fancy_abort if you like that sort of thing.  */
end_comment

begin_function
name|void
name|fancy_abort
parameter_list|()
block|{
name|fatal
argument_list|(
literal|"Internal gcc abort."
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Determine if an insn has a constant number of delay slots, i.e., the    number of delay slots is not a function of the length of the insn.  */
end_comment

begin_function
name|void
name|write_const_num_delay_slots
parameter_list|()
block|{
name|struct
name|attr_desc
modifier|*
name|attr
init|=
name|find_attr
argument_list|(
literal|"*num_delay_slots"
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|struct
name|attr_value
modifier|*
name|av
decl_stmt|;
name|struct
name|insn_ent
modifier|*
name|ie
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|attr
condition|)
block|{
name|printf
argument_list|(
literal|"int\nconst_num_delay_slots (insn)\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"     rtx *insn;\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"{\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  switch (recog_memoized (insn))\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    {\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|av
operator|=
name|attr
operator|->
name|first_value
init|;
name|av
condition|;
name|av
operator|=
name|av
operator|->
name|next
control|)
block|{
name|length_used
operator|=
literal|0
expr_stmt|;
name|walk_attr_value
argument_list|(
name|av
operator|->
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|length_used
condition|)
block|{
for|for
control|(
name|ie
operator|=
name|av
operator|->
name|first_insn
init|;
name|ie
condition|;
name|ie
operator|=
name|ie
operator|->
name|next
control|)
if|if
condition|(
name|ie
operator|->
name|insn_code
operator|!=
operator|-
literal|1
condition|)
name|printf
argument_list|(
literal|"    case %d:\n"
argument_list|,
name|ie
operator|->
name|insn_code
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"      return 0;\n"
argument_list|)
expr_stmt|;
block|}
block|}
name|printf
argument_list|(
literal|"    default:\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"      return 1;\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    }\n}\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|rtx
name|desc
decl_stmt|;
name|FILE
modifier|*
name|infile
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
name|struct
name|attr_desc
modifier|*
name|attr
decl_stmt|;
name|struct
name|insn_def
modifier|*
name|id
decl_stmt|;
name|rtx
name|tem
decl_stmt|;
name|int
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|RLIMIT_STACK
comment|/* Get rid of any avoidable limit on stack size.  */
block|{
name|struct
name|rlimit
name|rlim
decl_stmt|;
comment|/* Set the stack limit huge so that alloca does not fail. */
name|getrlimit
argument_list|(
name|RLIMIT_STACK
argument_list|,
operator|&
name|rlim
argument_list|)
expr_stmt|;
name|rlim
operator|.
name|rlim_cur
operator|=
name|rlim
operator|.
name|rlim_max
expr_stmt|;
name|setrlimit
argument_list|(
name|RLIMIT_STACK
argument_list|,
operator|&
name|rlim
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* RLIMIT_STACK defined */
name|obstack_init
argument_list|(
name|rtl_obstack
argument_list|)
expr_stmt|;
name|obstack_init
argument_list|(
name|hash_obstack
argument_list|)
expr_stmt|;
name|obstack_init
argument_list|(
name|temp_obstack
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|<=
literal|1
condition|)
name|fatal
argument_list|(
literal|"No input file name."
argument_list|)
expr_stmt|;
name|infile
operator|=
name|fopen
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|infile
operator|==
literal|0
condition|)
block|{
name|perror
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|FATAL_EXIT_CODE
argument_list|)
expr_stmt|;
block|}
name|init_rtl
argument_list|()
expr_stmt|;
comment|/* Set up true and false rtx's */
name|true_rtx
operator|=
name|rtx_alloc
argument_list|(
name|CONST_INT
argument_list|)
expr_stmt|;
name|XWINT
argument_list|(
name|true_rtx
argument_list|,
literal|0
argument_list|)
operator|=
literal|1
expr_stmt|;
name|false_rtx
operator|=
name|rtx_alloc
argument_list|(
name|CONST_INT
argument_list|)
expr_stmt|;
name|XWINT
argument_list|(
name|false_rtx
argument_list|,
literal|0
argument_list|)
operator|=
literal|0
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|true_rtx
argument_list|)
operator|=
name|RTX_UNCHANGING_P
argument_list|(
name|false_rtx
argument_list|)
operator|=
literal|1
expr_stmt|;
name|RTX_INTEGRATED_P
argument_list|(
name|true_rtx
argument_list|)
operator|=
name|RTX_INTEGRATED_P
argument_list|(
name|false_rtx
argument_list|)
operator|=
literal|1
expr_stmt|;
name|alternative_name
operator|=
name|attr_string
argument_list|(
literal|"alternative"
argument_list|,
name|strlen
argument_list|(
literal|"alternative"
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"/* Generated automatically by the program `genattrtab'\n\ from the machine description file `md'.  */\n\n"
argument_list|)
expr_stmt|;
comment|/* Read the machine description.  */
while|while
condition|(
literal|1
condition|)
block|{
name|c
operator|=
name|read_skip_spaces
argument_list|(
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
break|break;
name|ungetc
argument_list|(
name|c
argument_list|,
name|infile
argument_list|)
expr_stmt|;
name|desc
operator|=
name|read_rtx
argument_list|(
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|desc
argument_list|)
operator|==
name|DEFINE_INSN
operator|||
name|GET_CODE
argument_list|(
name|desc
argument_list|)
operator|==
name|DEFINE_PEEPHOLE
operator|||
name|GET_CODE
argument_list|(
name|desc
argument_list|)
operator|==
name|DEFINE_ASM_ATTRIBUTES
condition|)
name|gen_insn
argument_list|(
name|desc
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|desc
argument_list|)
operator|==
name|DEFINE_EXPAND
condition|)
name|insn_code_number
operator|++
operator|,
name|insn_index_number
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|desc
argument_list|)
operator|==
name|DEFINE_SPLIT
condition|)
name|insn_code_number
operator|++
operator|,
name|insn_index_number
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|desc
argument_list|)
operator|==
name|DEFINE_ATTR
condition|)
block|{
name|gen_attr
argument_list|(
name|desc
argument_list|)
expr_stmt|;
name|insn_index_number
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|desc
argument_list|)
operator|==
name|DEFINE_DELAY
condition|)
block|{
name|gen_delay
argument_list|(
name|desc
argument_list|)
expr_stmt|;
name|insn_index_number
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|desc
argument_list|)
operator|==
name|DEFINE_FUNCTION_UNIT
condition|)
block|{
name|gen_unit
argument_list|(
name|desc
argument_list|)
expr_stmt|;
name|insn_index_number
operator|++
expr_stmt|;
block|}
block|}
comment|/* If we didn't have a DEFINE_ASM_ATTRIBUTES, make a null one.  */
if|if
condition|(
operator|!
name|got_define_asm_attributes
condition|)
block|{
name|tem
operator|=
name|rtx_alloc
argument_list|(
name|DEFINE_ASM_ATTRIBUTES
argument_list|)
expr_stmt|;
name|XVEC
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
operator|=
name|rtvec_alloc
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|gen_insn
argument_list|(
name|tem
argument_list|)
expr_stmt|;
block|}
comment|/* Expand DEFINE_DELAY information into new attribute.  */
if|if
condition|(
name|num_delays
condition|)
name|expand_delays
argument_list|()
expr_stmt|;
comment|/* Expand DEFINE_FUNCTION_UNIT information into new attributes.  */
if|if
condition|(
name|num_units
condition|)
name|expand_units
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"config.h\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"rtl.h\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"insn-config.h\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"recog.h\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"regs.h\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"real.h\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"output.h\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#include \"insn-attr.h\"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#define operands recog_operand\n\n"
argument_list|)
expr_stmt|;
comment|/* Make `insn_alternatives'.  */
name|insn_alternatives
operator|=
operator|(
name|int
operator|*
operator|)
name|oballoc
argument_list|(
name|insn_code_number
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|id
operator|=
name|defs
init|;
name|id
condition|;
name|id
operator|=
name|id
operator|->
name|next
control|)
if|if
condition|(
name|id
operator|->
name|insn_code
operator|>=
literal|0
condition|)
name|insn_alternatives
index|[
name|id
operator|->
name|insn_code
index|]
operator|=
operator|(
literal|1
operator|<<
name|id
operator|->
name|num_alternatives
operator|)
operator|-
literal|1
expr_stmt|;
comment|/* Make `insn_n_alternatives'.  */
name|insn_n_alternatives
operator|=
operator|(
name|int
operator|*
operator|)
name|oballoc
argument_list|(
name|insn_code_number
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|id
operator|=
name|defs
init|;
name|id
condition|;
name|id
operator|=
name|id
operator|->
name|next
control|)
if|if
condition|(
name|id
operator|->
name|insn_code
operator|>=
literal|0
condition|)
name|insn_n_alternatives
index|[
name|id
operator|->
name|insn_code
index|]
operator|=
name|id
operator|->
name|num_alternatives
expr_stmt|;
comment|/* Prepare to write out attribute subroutines by checking everything stored      away and building the attribute cases.  */
name|check_defs
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_ATTRS_INDEX
condition|;
name|i
operator|++
control|)
for|for
control|(
name|attr
operator|=
name|attrs
index|[
name|i
index|]
init|;
name|attr
condition|;
name|attr
operator|=
name|attr
operator|->
name|next
control|)
block|{
name|attr
operator|->
name|default_val
operator|->
name|value
operator|=
name|check_attr_value
argument_list|(
name|attr
operator|->
name|default_val
operator|->
name|value
argument_list|,
name|attr
argument_list|)
expr_stmt|;
name|fill_attr
argument_list|(
name|attr
argument_list|)
expr_stmt|;
block|}
comment|/* Construct extra attributes for `length'.  */
name|make_length_attrs
argument_list|()
expr_stmt|;
comment|/* Perform any possible optimizations to speed up compilation. */
name|optimize_attrs
argument_list|()
expr_stmt|;
comment|/* Now write out all the `gen_attr_...' routines.  Do these before the      special routines (specifically before write_function_unit_info), so      that they get defined before they are used.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_ATTRS_INDEX
condition|;
name|i
operator|++
control|)
for|for
control|(
name|attr
operator|=
name|attrs
index|[
name|i
index|]
init|;
name|attr
condition|;
name|attr
operator|=
name|attr
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|attr
operator|->
name|is_special
condition|)
name|write_attr_get
argument_list|(
name|attr
argument_list|)
expr_stmt|;
block|}
comment|/* Write out delay eligibility information, if DEFINE_DELAY present.      (The function to compute the number of delay slots will be written      below.)  */
if|if
condition|(
name|num_delays
condition|)
block|{
name|write_eligible_delay
argument_list|(
literal|"delay"
argument_list|)
expr_stmt|;
if|if
condition|(
name|have_annul_true
condition|)
name|write_eligible_delay
argument_list|(
literal|"annul_true"
argument_list|)
expr_stmt|;
if|if
condition|(
name|have_annul_false
condition|)
name|write_eligible_delay
argument_list|(
literal|"annul_false"
argument_list|)
expr_stmt|;
block|}
comment|/* Write out information about function units.  */
if|if
condition|(
name|num_units
condition|)
name|write_function_unit_info
argument_list|()
expr_stmt|;
comment|/* Write out constant delay slot info */
name|write_const_num_delay_slots
argument_list|()
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|ferror
argument_list|(
name|stdout
argument_list|)
operator|!=
literal|0
condition|?
name|FATAL_EXIT_CODE
else|:
name|SUCCESS_EXIT_CODE
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
return|return
literal|0
return|;
block|}
end_function

end_unit

