begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Dummy data flow analysis for GNU compiler in nonoptimizing mode.    Copyright (C) 1987, 1991 Free Software Foundation, Inc.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* This file performs stupid register allocation, which is used    when cc1 gets the -noreg switch (which is when cc does not get -O).     Stupid register allocation goes in place of the the flow_analysis,    local_alloc and global_alloc passes.  combine_instructions cannot    be done with stupid allocation because the data flow info that it needs    is not computed here.     In stupid allocation, the only user-defined variables that can    go in registers are those declared "register".  They are assumed    to have a life span equal to their scope.  Other user variables    are given stack slots in the rtl-generation pass and are not    represented as pseudo regs.  A compiler-generated temporary    is assumed to live from its first mention to its last mention.     Since each pseudo-reg's life span is just an interval, it can be    represented as a pair of numbers, each of which identifies an insn by    its position in the function (number of insns before it).  The first    thing done for stupid allocation is to compute such a number for each    insn.  It is called the suid.  Then the life-interval of each    pseudo reg is computed.  Then the pseudo regs are ordered by priority    and assigned hard regs in priority order.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_escape
end_escape

begin_comment
comment|/* Vector mapping INSN_UIDs to suids.    The suids are like uids but increase monotonically always.    We use them to see whether a subroutine call came    between a variable's birth and its death.  */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|uid_suid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Get the suid of an insn.  */
end_comment

begin_define
define|#
directive|define
name|INSN_SUID
parameter_list|(
name|INSN
parameter_list|)
value|(uid_suid[INSN_UID (INSN)])
end_define

begin_comment
comment|/* Record the suid of the last CALL_INSN    so we can tell whether a pseudo reg crosses any calls.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|last_call_suid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Record the suid of the last JUMP_INSN    so we can tell whether a pseudo reg crosses any jumps.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|last_jump_suid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Record the suid of the last CODE_LABEL    so we can tell whether a pseudo reg crosses any labels.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|last_label_suid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Element N is suid of insn where life span of pseudo reg N ends.    Element is  0 if register N has not been seen yet on backward scan.  */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|reg_where_dead
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Element N is suid of insn where life span of pseudo reg N begins.  */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|reg_where_born
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Element N is 1 if pseudo reg N lives across labels or jumps.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|reg_crosses_blocks
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Numbers of pseudo-regs to be allocated, highest priority first.  */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|reg_order
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indexed by reg number (hard or pseudo), nonzero if register is live    at the current point in the instruction stream.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|regs_live
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indexed by insn's suid, the set of hard regs live after that insn.  */
end_comment

begin_decl_stmt
specifier|static
name|HARD_REG_SET
modifier|*
name|after_insn_hard_regs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Record that hard reg REGNO is live after insn INSN.  */
end_comment

begin_define
define|#
directive|define
name|MARK_LIVE_AFTER
parameter_list|(
name|INSN
parameter_list|,
name|REGNO
parameter_list|)
define|\
value|SET_HARD_REG_BIT (after_insn_hard_regs[INSN_SUID (INSN)], (REGNO))
end_define

begin_function_decl
specifier|static
name|void
name|stupid_mark_refs
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|stupid_reg_compare
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|stupid_find_reg
parameter_list|()
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* Stupid life analysis is for the case where only variables declared    `register' go in registers.  For this case, we mark all    pseudo-registers that belong to register variables as    dying in the last instruction of the function, and all other    pseudo registers as dying in the last place they are referenced.    Hard registers are marked as dying in the last reference before    the end or before each store into them.  */
end_comment

begin_function
name|void
name|stupid_life_analysis
parameter_list|(
name|f
parameter_list|,
name|nregs
parameter_list|,
name|file
parameter_list|)
name|rtx
name|f
decl_stmt|;
name|int
name|nregs
decl_stmt|;
name|FILE
modifier|*
name|file
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|rtx
name|last
decl_stmt|,
name|insn
decl_stmt|;
name|int
name|max_uid
decl_stmt|;
name|bzero
argument_list|(
name|regs_ever_live
argument_list|,
sizeof|sizeof
name|regs_ever_live
argument_list|)
expr_stmt|;
name|regs_live
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|nregs
argument_list|)
expr_stmt|;
comment|/* First find the last real insn, and count the number of insns,      and assign insns their suids.  */
for|for
control|(
name|insn
operator|=
name|f
operator|,
name|i
operator|=
literal|0
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|INSN_UID
argument_list|(
name|insn
argument_list|)
operator|>
name|i
condition|)
name|i
operator|=
name|INSN_UID
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|max_uid
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|uid_suid
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
operator|(
name|i
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Compute the mapping from uids to suids.      Suids are numbers assigned to insns, like uids,      except that suids increase monotonically through the code.  */
name|last
operator|=
literal|0
expr_stmt|;
comment|/* In case of empty function body */
for|for
control|(
name|insn
operator|=
name|f
operator|,
name|i
operator|=
literal|0
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
condition|)
name|last
operator|=
name|insn
expr_stmt|;
name|INSN_SUID
argument_list|(
name|insn
argument_list|)
operator|=
operator|++
name|i
expr_stmt|;
block|}
name|last_call_suid
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|last_jump_suid
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|last_label_suid
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|max_regno
operator|=
name|nregs
expr_stmt|;
comment|/* Allocate tables to record info about regs.  */
name|reg_where_dead
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|nregs
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|reg_where_dead
argument_list|,
name|nregs
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|reg_where_born
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|nregs
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|reg_where_born
argument_list|,
name|nregs
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|reg_crosses_blocks
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|nregs
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|reg_crosses_blocks
argument_list|,
name|nregs
argument_list|)
expr_stmt|;
name|reg_order
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|nregs
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|reg_order
argument_list|,
name|nregs
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|reg_renumber
operator|=
operator|(
name|short
operator|*
operator|)
name|oballoc
argument_list|(
name|nregs
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
name|reg_renumber
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
for|for
control|(
name|i
operator|=
name|FIRST_VIRTUAL_REGISTER
init|;
name|i
operator|<=
name|LAST_VIRTUAL_REGISTER
condition|;
name|i
operator|++
control|)
name|reg_renumber
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|after_insn_hard_regs
operator|=
operator|(
name|HARD_REG_SET
operator|*
operator|)
name|alloca
argument_list|(
name|max_uid
operator|*
sizeof|sizeof
argument_list|(
name|HARD_REG_SET
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|after_insn_hard_regs
argument_list|,
name|max_uid
operator|*
sizeof|sizeof
argument_list|(
name|HARD_REG_SET
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Allocate and zero out many data structures      that will record the data from lifetime analysis.  */
name|allocate_for_life_analysis
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max_regno
condition|;
name|i
operator|++
control|)
block|{
name|reg_n_deaths
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
block|}
name|bzero
argument_list|(
name|regs_live
argument_list|,
name|nregs
argument_list|)
expr_stmt|;
comment|/* Find where each pseudo register is born and dies,      by scanning all insns from the end to the start      and noting all mentions of the registers.       Also find where each hard register is live      and record that info in after_insn_hard_regs.      regs_live[I] is 1 if hard reg I is live      at the current point in the scan.  */
for|for
control|(
name|insn
operator|=
name|last
init|;
name|insn
condition|;
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
specifier|register
name|HARD_REG_SET
modifier|*
name|p
init|=
name|after_insn_hard_regs
operator|+
name|INSN_SUID
argument_list|(
name|insn
argument_list|)
decl_stmt|;
comment|/* Copy the info in regs_live 	 into the element of after_insn_hard_regs 	 for the current position in the rtl code.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|regs_live
index|[
name|i
index|]
condition|)
name|SET_HARD_REG_BIT
argument_list|(
operator|*
name|p
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* Mark all call-clobbered regs as live after each call insn 	 so that a pseudo whose life span includes this insn 	 will not go in one of them. 	 Then mark those regs as all dead for the continuing scan 	 of the insns before the call.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
name|last_call_suid
operator|=
name|INSN_SUID
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|IOR_HARD_REG_SET
argument_list|(
name|after_insn_hard_regs
index|[
name|last_call_suid
index|]
argument_list|,
name|call_used_reg_set
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|call_used_regs
index|[
name|i
index|]
condition|)
name|regs_live
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
condition|)
name|last_jump_suid
operator|=
name|INSN_SUID
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_LABEL
condition|)
name|last_label_suid
operator|=
name|INSN_SUID
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* Update which hard regs are currently live 	 and also the birth and death suids of pseudo regs 	 based on the pattern of this insn.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
condition|)
block|{
name|stupid_mark_refs
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Now decide the order in which to allocate the pseudo registers.  */
for|for
control|(
name|i
operator|=
name|LAST_VIRTUAL_REGISTER
operator|+
literal|1
init|;
name|i
operator|<
name|max_regno
condition|;
name|i
operator|++
control|)
name|reg_order
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
name|qsort
argument_list|(
operator|&
name|reg_order
index|[
name|LAST_VIRTUAL_REGISTER
operator|+
literal|1
index|]
argument_list|,
name|max_regno
operator|-
name|LAST_VIRTUAL_REGISTER
operator|-
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
name|stupid_reg_compare
argument_list|)
expr_stmt|;
comment|/* Now, in that order, try to find hard registers for those pseudo regs.  */
for|for
control|(
name|i
operator|=
name|LAST_VIRTUAL_REGISTER
operator|+
literal|1
init|;
name|i
operator|<
name|max_regno
condition|;
name|i
operator|++
control|)
block|{
specifier|register
name|int
name|r
init|=
name|reg_order
index|[
name|i
index|]
decl_stmt|;
name|enum
name|reg_class
name|class
decl_stmt|;
comment|/* Some regnos disappear from the rtl.  Ignore them to avoid crash.  */
if|if
condition|(
name|regno_reg_rtx
index|[
name|r
index|]
operator|==
literal|0
condition|)
continue|continue;
comment|/* Now find the best hard-register class for this pseudo register */
if|if
condition|(
name|N_REG_CLASSES
operator|>
literal|1
condition|)
block|{
name|class
operator|=
name|reg_preferred_class
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|reg_renumber
index|[
name|r
index|]
operator|=
name|stupid_find_reg
argument_list|(
name|reg_n_calls_crossed
index|[
name|r
index|]
argument_list|,
name|class
argument_list|,
name|PSEUDO_REGNO_MODE
argument_list|(
name|r
argument_list|)
argument_list|,
name|reg_where_born
index|[
name|r
index|]
argument_list|,
name|reg_where_dead
index|[
name|r
index|]
argument_list|,
name|reg_crosses_blocks
index|[
name|r
index|]
argument_list|)
expr_stmt|;
block|}
else|else
name|reg_renumber
index|[
name|r
index|]
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* If no reg available in that class, 	 try any reg.  */
if|if
condition|(
name|reg_renumber
index|[
name|r
index|]
operator|==
operator|-
literal|1
condition|)
name|reg_renumber
index|[
name|r
index|]
operator|=
name|stupid_find_reg
argument_list|(
name|reg_n_calls_crossed
index|[
name|r
index|]
argument_list|,
name|GENERAL_REGS
argument_list|,
name|PSEUDO_REGNO_MODE
argument_list|(
name|r
argument_list|)
argument_list|,
name|reg_where_born
index|[
name|r
index|]
argument_list|,
name|reg_where_dead
index|[
name|r
index|]
argument_list|,
name|reg_crosses_blocks
index|[
name|r
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|file
condition|)
name|dump_flow_info
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Comparison function for qsort.    Returns -1 (1) if register *R1P is higher priority than *R2P.  */
end_comment

begin_function
specifier|static
name|int
name|stupid_reg_compare
parameter_list|(
name|r1p
parameter_list|,
name|r2p
parameter_list|)
name|int
modifier|*
name|r1p
decl_stmt|,
decl|*
name|r2p
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|int
name|r1
init|=
operator|*
name|r1p
decl_stmt|,
name|r2
init|=
operator|*
name|r2p
decl_stmt|;
specifier|register
name|int
name|len1
init|=
name|reg_where_dead
index|[
name|r1
index|]
operator|-
name|reg_where_born
index|[
name|r1
index|]
decl_stmt|;
specifier|register
name|int
name|len2
init|=
name|reg_where_dead
index|[
name|r2
index|]
operator|-
name|reg_where_born
index|[
name|r2
index|]
decl_stmt|;
name|int
name|tem
decl_stmt|;
name|tem
operator|=
name|len2
operator|-
name|len1
expr_stmt|;
if|if
condition|(
name|tem
operator|!=
literal|0
condition|)
return|return
name|tem
return|;
name|tem
operator|=
name|reg_n_refs
index|[
name|r1
index|]
operator|-
name|reg_n_refs
index|[
name|r2
index|]
expr_stmt|;
if|if
condition|(
name|tem
operator|!=
literal|0
condition|)
return|return
name|tem
return|;
comment|/* If regs are equally good, sort by regno,      so that the results of qsort leave nothing to chance.  */
return|return
name|r1
operator|-
name|r2
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Find a block of SIZE words of hard registers in reg_class CLASS    that can hold a value of machine-mode MODE      (but actually we test only the first of the block for holding MODE)    currently free from after insn whose suid is BIRTH    through the insn whose suid is DEATH,    and return the number of the first of them.    Return -1 if such a block cannot be found.     If CALL_PRESERVED is nonzero, insist on registers preserved    over subroutine calls, and return -1 if cannot find such.    If CROSSES_BLOCKS is nonzero, reject registers for which    PRESERVE_DEATH_INFO_REGNO_P is true.  */
end_comment

begin_function
specifier|static
name|int
name|stupid_find_reg
parameter_list|(
name|call_preserved
parameter_list|,
name|class
parameter_list|,
name|mode
parameter_list|,
name|born_insn
parameter_list|,
name|dead_insn
parameter_list|,
name|crosses_blocks
parameter_list|)
name|int
name|call_preserved
decl_stmt|;
name|enum
name|reg_class
name|class
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|born_insn
decl_stmt|,
name|dead_insn
decl_stmt|;
name|int
name|crosses_blocks
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|ins
decl_stmt|;
ifdef|#
directive|ifdef
name|HARD_REG_SET
specifier|register
comment|/* Declare them register if they are scalars.  */
endif|#
directive|endif
name|HARD_REG_SET
name|used
decl_stmt|,
name|this_reg
decl_stmt|;
ifdef|#
directive|ifdef
name|ELIMINABLE_REGS
specifier|static
struct|struct
block|{
name|int
name|from
decl_stmt|,
name|to
decl_stmt|;
block|}
name|eliminables
index|[]
init|=
name|ELIMINABLE_REGS
struct|;
endif|#
directive|endif
name|COPY_HARD_REG_SET
argument_list|(
name|used
argument_list|,
name|call_preserved
condition|?
name|call_used_reg_set
else|:
name|fixed_reg_set
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ELIMINABLE_REGS
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
name|eliminables
operator|/
sizeof|sizeof
name|eliminables
index|[
literal|0
index|]
condition|;
name|i
operator|++
control|)
name|SET_HARD_REG_BIT
argument_list|(
name|used
argument_list|,
name|eliminables
index|[
name|i
index|]
operator|.
name|from
argument_list|)
expr_stmt|;
else|#
directive|else
name|SET_HARD_REG_BIT
argument_list|(
name|used
argument_list|,
name|FRAME_POINTER_REGNUM
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|ins
operator|=
name|born_insn
init|;
name|ins
operator|<
name|dead_insn
condition|;
name|ins
operator|++
control|)
name|IOR_HARD_REG_SET
argument_list|(
name|used
argument_list|,
name|after_insn_hard_regs
index|[
name|ins
index|]
argument_list|)
expr_stmt|;
name|IOR_COMPL_HARD_REG_SET
argument_list|(
name|used
argument_list|,
name|reg_class_contents
index|[
operator|(
name|int
operator|)
name|class
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
block|{
ifdef|#
directive|ifdef
name|REG_ALLOC_ORDER
name|int
name|regno
init|=
name|reg_alloc_order
index|[
name|i
index|]
decl_stmt|;
else|#
directive|else
name|int
name|regno
init|=
name|i
decl_stmt|;
endif|#
directive|endif
comment|/* If we need reasonable death info on this hard reg, 	 don't use it for anything whose life spans a label or a jump.  */
ifdef|#
directive|ifdef
name|PRESERVE_DEATH_INFO_REGNO_P
if|if
condition|(
name|PRESERVE_DEATH_INFO_REGNO_P
argument_list|(
name|regno
argument_list|)
operator|&&
name|crosses_blocks
condition|)
continue|continue;
endif|#
directive|endif
comment|/* If a register has screwy overlap problems, 	 don't use it at all if not optimizing. 	 Actually this is only for the 387 stack register, 	 and it's because subsequent code won't work.  */
ifdef|#
directive|ifdef
name|OVERLAPPING_REGNO_P
if|if
condition|(
name|OVERLAPPING_REGNO_P
argument_list|(
name|regno
argument_list|)
condition|)
continue|continue;
endif|#
directive|endif
if|if
condition|(
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|used
argument_list|,
name|regno
argument_list|)
operator|&&
name|HARD_REGNO_MODE_OK
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
condition|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
specifier|register
name|int
name|size1
init|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
name|size1
operator|&&
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|used
argument_list|,
name|regno
operator|+
name|j
argument_list|)
condition|;
name|j
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|j
operator|==
name|size1
condition|)
block|{
name|CLEAR_HARD_REG_SET
argument_list|(
name|this_reg
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|j
operator|>=
literal|0
condition|)
name|SET_HARD_REG_BIT
argument_list|(
name|this_reg
argument_list|,
name|regno
operator|+
name|j
argument_list|)
expr_stmt|;
for|for
control|(
name|ins
operator|=
name|born_insn
init|;
name|ins
operator|<
name|dead_insn
condition|;
name|ins
operator|++
control|)
block|{
name|IOR_HARD_REG_SET
argument_list|(
name|after_insn_hard_regs
index|[
name|ins
index|]
argument_list|,
name|this_reg
argument_list|)
expr_stmt|;
block|}
return|return
name|regno
return|;
block|}
ifndef|#
directive|ifndef
name|REG_ALLOC_ORDER
name|i
operator|+=
name|j
expr_stmt|;
comment|/* Skip starting points we know will lose */
endif|#
directive|endif
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Walk X, noting all assignments and references to registers    and recording what they imply about life spans.    INSN is the current insn, supplied so we can find its suid.  */
end_comment

begin_function
specifier|static
name|void
name|stupid_mark_refs
parameter_list|(
name|x
parameter_list|,
name|insn
parameter_list|)
name|rtx
name|x
decl_stmt|,
name|insn
decl_stmt|;
block|{
specifier|register
name|RTX_CODE
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
specifier|register
name|char
modifier|*
name|fmt
decl_stmt|;
specifier|register
name|int
name|regno
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|SET
operator|||
name|code
operator|==
name|CLOBBER
condition|)
block|{
if|if
condition|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
comment|/* Register is being assigned.  */
name|regno
operator|=
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
comment|/* For hard regs, update the where-live info.  */
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
specifier|register
name|int
name|j
init|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
while|while
condition|(
operator|--
name|j
operator|>=
literal|0
condition|)
block|{
name|regs_ever_live
index|[
name|regno
operator|+
name|j
index|]
operator|=
literal|1
expr_stmt|;
name|regs_live
index|[
name|regno
operator|+
name|j
index|]
operator|=
literal|0
expr_stmt|;
comment|/* The following line is for unused outputs; 		     they do get stored even though never used again.  */
name|MARK_LIVE_AFTER
argument_list|(
name|insn
argument_list|,
name|regno
argument_list|)
expr_stmt|;
comment|/* When a hard reg is clobbered, mark it in use 		     just before this insn, so it is live all through.  */
if|if
condition|(
name|code
operator|==
name|CLOBBER
operator|&&
name|INSN_SUID
argument_list|(
name|insn
argument_list|)
operator|>
literal|0
condition|)
name|SET_HARD_REG_BIT
argument_list|(
name|after_insn_hard_regs
index|[
name|INSN_SUID
argument_list|(
name|insn
argument_list|)
operator|-
literal|1
index|]
argument_list|,
name|regno
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* For pseudo regs, record where born, where dead, number of 	     times used, and whether live across a call.  */
else|else
block|{
comment|/* Update the life-interval bounds of this pseudo reg.  */
comment|/* When a pseudo-reg is CLOBBERed, it is born just before 		 the clobbering insn.  When setting, just after.  */
name|int
name|where_born
init|=
name|INSN_SUID
argument_list|(
name|insn
argument_list|)
operator|-
operator|(
name|code
operator|==
name|CLOBBER
operator|)
decl_stmt|;
name|reg_where_born
index|[
name|regno
index|]
operator|=
name|where_born
expr_stmt|;
comment|/* The reg must live at least one insn even 		 in it is never again used--because it has to go 		 in SOME hard reg.  Mark it as dying after the current 		 insn so that it will conflict with any other outputs of 		 this insn.  */
if|if
condition|(
name|reg_where_dead
index|[
name|regno
index|]
operator|<
name|where_born
operator|+
literal|2
condition|)
name|reg_where_dead
index|[
name|regno
index|]
operator|=
name|where_born
operator|+
literal|2
expr_stmt|;
comment|/* Count the refs of this reg.  */
name|reg_n_refs
index|[
name|regno
index|]
operator|++
expr_stmt|;
if|if
condition|(
name|last_call_suid
operator|<
name|reg_where_dead
index|[
name|regno
index|]
condition|)
name|reg_n_calls_crossed
index|[
name|regno
index|]
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|last_jump_suid
operator|<
name|reg_where_dead
index|[
name|regno
index|]
operator|||
name|last_label_suid
operator|<
name|reg_where_dead
index|[
name|regno
index|]
condition|)
name|reg_crosses_blocks
index|[
name|regno
index|]
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* Record references from the value being set, 	 or from addresses in the place being set if that's not a reg. 	 If setting a SUBREG, we treat the entire reg as *used*.  */
if|if
condition|(
name|code
operator|==
name|SET
condition|)
block|{
name|stupid_mark_refs
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|REG
condition|)
name|stupid_mark_refs
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
comment|/* Register value being used, not set.  */
if|if
condition|(
name|code
operator|==
name|REG
condition|)
block|{
name|regno
operator|=
name|REGNO
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
comment|/* Hard reg: mark it live for continuing scan of previous insns.  */
specifier|register
name|int
name|j
init|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
decl_stmt|;
while|while
condition|(
operator|--
name|j
operator|>=
literal|0
condition|)
block|{
name|regs_ever_live
index|[
name|regno
operator|+
name|j
index|]
operator|=
literal|1
expr_stmt|;
name|regs_live
index|[
name|regno
operator|+
name|j
index|]
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Pseudo reg: record first use, last use and number of uses.  */
name|reg_where_born
index|[
name|regno
index|]
operator|=
name|INSN_SUID
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|reg_n_refs
index|[
name|regno
index|]
operator|++
expr_stmt|;
if|if
condition|(
name|regs_live
index|[
name|regno
index|]
operator|==
literal|0
condition|)
block|{
name|regs_live
index|[
name|regno
index|]
operator|=
literal|1
expr_stmt|;
name|reg_where_dead
index|[
name|regno
index|]
operator|=
name|INSN_SUID
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
return|return;
block|}
comment|/* Recursive scan of all other rtx's.  */
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
name|stupid_mark_refs
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
name|stupid_mark_refs
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

end_unit

