begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Convert language-specific tree expression to rtl instructions,    for GNU compiler.    Copyright (C) 1988, 1992 Free Software Foundation, Inc.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"cp-tree.h"
end_include

begin_define
define|#
directive|define
name|NULL
value|0
end_define

begin_comment
comment|/* Hook used by expand_expr to expand language-specific tree codes.  */
end_comment

begin_function
name|rtx
name|cplus_expand_expr
parameter_list|(
name|exp
parameter_list|,
name|target
parameter_list|,
name|tmode
parameter_list|,
name|modifier
parameter_list|)
name|tree
name|exp
decl_stmt|;
name|rtx
name|target
decl_stmt|;
name|enum
name|machine_mode
name|tmode
decl_stmt|;
name|enum
name|expand_modifier
name|modifier
decl_stmt|;
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
decl_stmt|;
specifier|register
name|enum
name|machine_mode
name|mode
init|=
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
specifier|register
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
decl_stmt|;
name|rtx
name|original_target
init|=
name|target
decl_stmt|;
name|int
name|ignore
init|=
name|target
operator|==
name|const0_rtx
decl_stmt|;
if|if
condition|(
name|ignore
condition|)
name|target
operator|=
literal|0
operator|,
name|original_target
operator|=
literal|0
expr_stmt|;
comment|/* No sense saving up arithmetic to be done      if it's all in the wrong mode to form part of an address.      And force_operand won't know whether to sign-extend or zero-extend.  */
if|if
condition|(
name|mode
operator|!=
name|Pmode
operator|&&
name|modifier
operator|==
name|EXPAND_SUM
condition|)
name|modifier
operator|=
name|EXPAND_NORMAL
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|NEW_EXPR
case|:
block|{
comment|/* Something needs to be initialized, but we didn't know 	   where that thing was when building the tree.  For example, 	   it could be the return value of a function, or a parameter 	   to a function which lays down in the stack, or a temporary 	   variable which must be passed by reference.  	   Cleanups are handled in a language-specific way: they 	   might be run by the called function (true in GNU C++ 	   for parameters with cleanups), or they might be 	   run by the caller, after the call (true in GNU C++ 	   for other cleanup needs).  */
name|tree
name|func
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|args
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
decl_stmt|,
name|slot
decl_stmt|;
name|tree
name|fn_type
init|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|func
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|return_type
init|=
name|TREE_TYPE
argument_list|(
name|fn_type
argument_list|)
decl_stmt|;
name|rtx
name|call_target
decl_stmt|,
name|return_target
decl_stmt|;
comment|/* The expression `init' wants to initialize what 	   `target' represents.  SLOT holds the slot for TARGET.  */
name|slot
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|==
literal|0
condition|)
block|{
comment|/* Should always be called with a target in BLKmode case.  */
name|my_friendly_assert
argument_list|(
name|mode
operator|!=
name|BLKmode
argument_list|,
literal|205
argument_list|)
expr_stmt|;
name|my_friendly_assert
argument_list|(
name|DECL_RTL
argument_list|(
name|slot
argument_list|)
operator|!=
literal|0
argument_list|,
literal|206
argument_list|)
expr_stmt|;
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
block|}
comment|/* The target the initializer will initialize (CALL_TARGET) 	   must now be directed to initialize the target we are 	   supposed to initialize (TARGET).  The semantics for 	   choosing what CALL_TARGET is is language-specific, 	   as is building the call which will perform the 	   initialization.  It is left here to show the choices that 	   exist for C++.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|func
argument_list|)
operator|==
name|ADDR_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|func
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_CONSTRUCTOR_P
argument_list|(
name|TREE_OPERAND
argument_list|(
name|func
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|type
operator|=
name|TYPE_POINTER_TO
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* Don't clobber a value that might be part of a default 	       parameter value.  */
if|if
condition|(
name|TREE_PERMANENT
argument_list|(
name|args
argument_list|)
condition|)
name|args
operator|=
name|tree_cons
argument_list|(
literal|0
argument_list|,
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|type
argument_list|,
name|slot
argument_list|)
argument_list|,
name|TREE_CHAIN
argument_list|(
name|args
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|TREE_VALUE
argument_list|(
name|args
argument_list|)
operator|=
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|type
argument_list|,
name|slot
argument_list|)
expr_stmt|;
name|call_target
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|return_type
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
block|{
name|type
operator|=
name|return_type
expr_stmt|;
name|call_target
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|call_target
operator|=
name|target
expr_stmt|;
block|}
if|if
condition|(
name|call_target
condition|)
name|preserve_temp_slots
argument_list|(
name|call_target
argument_list|)
expr_stmt|;
name|preserve_temp_slots
argument_list|(
name|DECL_RTL
argument_list|(
name|slot
argument_list|)
argument_list|)
expr_stmt|;
name|return_target
operator|=
name|expand_expr
argument_list|(
name|build
argument_list|(
name|CALL_EXPR
argument_list|,
name|type
argument_list|,
name|func
argument_list|,
name|args
argument_list|,
literal|0
argument_list|)
argument_list|,
name|call_target
argument_list|,
name|mode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free_temp_slots
argument_list|()
expr_stmt|;
if|if
condition|(
name|call_target
operator|==
literal|0
condition|)
name|call_target
operator|=
name|return_target
expr_stmt|;
elseif|else
if|if
condition|(
name|call_target
operator|!=
name|return_target
condition|)
block|{
if|if
condition|(
name|GET_MODE
argument_list|(
name|return_target
argument_list|)
operator|==
name|BLKmode
condition|)
name|emit_block_move
argument_list|(
name|call_target
argument_list|,
name|return_target
argument_list|,
name|expr_size
argument_list|(
name|exp
argument_list|)
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
else|else
name|emit_move_insn
argument_list|(
name|call_target
argument_list|,
name|return_target
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|return_type
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
block|{
name|tree
name|init
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|call_target
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|call_target
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
name|my_friendly_abort
argument_list|(
literal|39
argument_list|)
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|init
operator|=
name|build
argument_list|(
name|RTL_EXPR
argument_list|,
name|return_type
argument_list|,
literal|0
argument_list|,
name|call_target
argument_list|)
expr_stmt|;
comment|/* We got back a reference to the type we want.  Now initialize 	       target with that.  */
name|expand_aggr_init
argument_list|(
name|slot
argument_list|,
name|init
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|DECL_RTL
argument_list|(
name|slot
argument_list|)
operator|!=
name|target
condition|)
name|emit_move_insn
argument_list|(
name|DECL_RTL
argument_list|(
name|slot
argument_list|)
argument_list|,
name|target
argument_list|)
expr_stmt|;
return|return
name|DECL_RTL
argument_list|(
name|slot
argument_list|)
return|;
block|}
case|case
name|OFFSET_REF
case|:
block|{
name|tree
name|base
init|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|offset
init|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
return|return
name|expand_expr
argument_list|(
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|base
argument_list|,
name|offset
argument_list|)
argument_list|,
name|target
argument_list|,
name|tmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
return|;
block|}
default|default:
break|break;
block|}
name|my_friendly_abort
argument_list|(
literal|40
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|void
name|init_cplus_expand
parameter_list|()
block|{
name|lang_expand_expr
operator|=
name|cplus_expand_expr
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If DECL had its rtl moved from where callers expect it    to be, fix it up.  RESULT is the nominal rtl for the RESULT_DECL,    which may be a pseudo instead of a hard register.  */
end_comment

begin_function
name|void
name|fixup_result_decl
parameter_list|(
name|decl
parameter_list|,
name|result
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|rtx
name|result
decl_stmt|;
block|{
if|if
condition|(
name|REG_P
argument_list|(
name|result
argument_list|)
condition|)
block|{
if|if
condition|(
name|REGNO
argument_list|(
name|result
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|rtx
name|real_decl_result
decl_stmt|;
ifdef|#
directive|ifdef
name|FUNCTION_OUTGOING_VALUE
name|real_decl_result
operator|=
name|FUNCTION_OUTGOING_VALUE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|current_function_decl
argument_list|)
expr_stmt|;
else|#
directive|else
name|real_decl_result
operator|=
name|FUNCTION_VALUE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|current_function_decl
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|REG_FUNCTION_VALUE_P
argument_list|(
name|real_decl_result
argument_list|)
operator|=
literal|1
expr_stmt|;
name|result
operator|=
name|real_decl_result
expr_stmt|;
block|}
name|emit_move_insn
argument_list|(
name|result
argument_list|,
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx
argument_list|(
name|USE
argument_list|,
name|VOIDmode
argument_list|,
name|result
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return nonzero iff DECL is memory-based.  The DECL_RTL of    certain const variables might be a CONST_INT, or a REG    in some cases.  We cannot use `memory_operand' as a test    here because on most RISC machines, a variable's address    is not, by itself, a legitimate address.  */
end_comment

begin_function
name|int
name|decl_in_memory_p
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
return|return
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|MEM
return|;
block|}
end_function

end_unit

