begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*********************************************************** Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts, and the Massachusetts Institute of Technology, Cambridge, Massachusetts.                          All Rights Reserved  Permission to use, copy, modify, and distribute this software and its  documentation for any purpose and without fee is hereby granted,  provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in  supporting documentation, and that the names of Digital or MIT not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.    DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  ******************************************************************/
end_comment

begin_comment
comment|/* $XConsortium: cfbgc.c,v 5.32.1.1 90/03/21 10:16:47 rws Exp $ */
end_comment

begin_include
include|#
directive|include
file|"X.h"
end_include

begin_include
include|#
directive|include
file|"Xmd.h"
end_include

begin_include
include|#
directive|include
file|"Xproto.h"
end_include

begin_include
include|#
directive|include
file|"../cfb/cfb.h"
end_include

begin_include
include|#
directive|include
file|"fontstruct.h"
end_include

begin_include
include|#
directive|include
file|"dixfontstr.h"
end_include

begin_include
include|#
directive|include
file|"gcstruct.h"
end_include

begin_include
include|#
directive|include
file|"windowstr.h"
end_include

begin_include
include|#
directive|include
file|"pixmapstr.h"
end_include

begin_include
include|#
directive|include
file|"scrnintstr.h"
end_include

begin_include
include|#
directive|include
file|"region.h"
end_include

begin_include
include|#
directive|include
file|"topcat.h"
end_include

begin_include
include|#
directive|include
file|"mistruct.h"
end_include

begin_include
include|#
directive|include
file|"mibstore.h"
end_include

begin_include
include|#
directive|include
file|"../cfb/cfbmskbits.h"
end_include

begin_include
include|#
directive|include
file|"../cfb/cfb8bit.h"
end_include

begin_function_decl
specifier|extern
name|RegionPtr
name|hpcCopyArea
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|void
name|topcatValidateGC
argument_list|()
decl_stmt|,
name|cfbChangeGC
argument_list|()
decl_stmt|,
name|cfbCopyGC
argument_list|()
decl_stmt|,
name|cfbDestroyGC
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|cfbChangeClip
argument_list|()
decl_stmt|,
name|cfbDestroyClip
argument_list|()
decl_stmt|,
name|cfbCopyClip
argument_list|()
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|cfbDestroyOps
argument_list|()
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|GCFuncs
name|cfbGCFuncs
init|=
block|{
name|topcatValidateGC
block|,
name|cfbChangeGC
block|,
name|cfbCopyGC
block|,
name|cfbDestroyGC
block|,
name|cfbChangeClip
block|,
name|cfbDestroyClip
block|,
name|cfbCopyClip
block|, }
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|tcImageGlyphBlt
value|cfbImageGlyphBlt8
end_define

begin_decl_stmt
specifier|static
name|GCOps
name|cfbTEOps1Rect
init|=
block|{
name|cfbSolidSpansCopy
block|,
name|cfbSetSpans
block|,
name|tcPutImage
block|,
name|hpcCopyArea
block|,
name|tcCopyPlane
block|,
name|cfbPolyPoint
block|,
if|#
directive|if
name|PPW
operator|==
literal|4
name|cfb8LineSS1Rect
block|,
name|cfb8SegmentSS1Rect
block|,
else|#
directive|else
name|cfbLineSS
block|,
name|cfbSegmentSS
block|,
endif|#
directive|endif
name|miPolyRectangle
block|,
if|#
directive|if
name|PPW
operator|==
literal|4
name|cfbZeroPolyArcSS8Copy
block|,
else|#
directive|else
name|miZeroPolyArc
block|,
endif|#
directive|endif
name|cfbFillPoly1RectCopy
block|,
name|tcPolyFillRect
block|,
name|cfbPolyFillArcSolidCopy
block|,
name|miPolyText8
block|,
name|miPolyText16
block|,
name|miImageText8
block|,
name|miImageText16
block|,
if|#
directive|if
name|PPW
operator|==
literal|4
name|cfbTEGlyphBlt8
block|,
name|cfbPolyGlyphBlt8
block|,
name|cfbPushPixels8
block|,
else|#
directive|else
name|cfbTEGlyphBlt
block|,
name|miPolyGlyphBlt
block|,
name|mfbPushPixels
block|,
endif|#
directive|endif
name|NULL
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|GCOps
name|cfbTEOps
init|=
block|{
name|cfbSolidSpansCopy
block|,
name|cfbSetSpans
block|,
name|tcPutImage
block|,
name|hpcCopyArea
block|,
name|tcCopyPlane
block|,
name|cfbPolyPoint
block|,
name|cfbLineSS
block|,
name|cfbSegmentSS
block|,
name|miPolyRectangle
block|,
if|#
directive|if
name|PPW
operator|==
literal|4
name|cfbZeroPolyArcSS8Copy
block|,
else|#
directive|else
name|miZeroPolyArc
block|,
endif|#
directive|endif
name|miFillPolygon
block|,
name|tcPolyFillRect
block|,
name|cfbPolyFillArcSolidCopy
block|,
name|miPolyText8
block|,
name|miPolyText16
block|,
name|miImageText8
block|,
name|miImageText16
block|,
if|#
directive|if
name|PPW
operator|==
literal|4
name|cfbTEGlyphBlt8
block|,
name|cfbPolyGlyphBlt8
block|,
name|cfbPushPixels8
block|,
else|#
directive|else
name|cfbTEGlyphBlt
block|,
name|miPolyGlyphBlt
block|,
name|mfbPushPixels
block|,
endif|#
directive|endif
name|NULL
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|GCOps
name|cfbNonTEOps1Rect
init|=
block|{
name|cfbSolidSpansCopy
block|,
name|cfbSetSpans
block|,
name|tcPutImage
block|,
name|hpcCopyArea
block|,
name|tcCopyPlane
block|,
name|cfbPolyPoint
block|,
if|#
directive|if
name|PPW
operator|==
literal|4
name|cfb8LineSS1Rect
block|,
name|cfb8SegmentSS1Rect
block|,
else|#
directive|else
name|cfbLineSS
block|,
name|cfbSegmentSS
block|,
endif|#
directive|endif
name|miPolyRectangle
block|,
if|#
directive|if
name|PPW
operator|==
literal|4
name|cfbZeroPolyArcSS8Copy
block|,
else|#
directive|else
name|miZeroPolyArc
block|,
endif|#
directive|endif
name|cfbFillPoly1RectCopy
block|,
name|tcPolyFillRect
block|,
name|cfbPolyFillArcSolidCopy
block|,
name|miPolyText8
block|,
name|miPolyText16
block|,
name|miImageText8
block|,
name|miImageText16
block|,
if|#
directive|if
name|PPW
operator|==
literal|4
name|cfbImageGlyphBlt8
block|,
name|cfbPolyGlyphBlt8
block|,
name|cfbPushPixels8
block|,
else|#
directive|else
name|miImageGlyphBlt
block|,
name|miPolyGlyphBlt
block|,
name|mfbPushPixels
block|,
endif|#
directive|endif
name|NULL
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|GCOps
name|cfbNonTEOps
init|=
block|{
name|cfbSolidSpansCopy
block|,
name|cfbSetSpans
block|,
name|tcPutImage
block|,
name|hpcCopyArea
block|,
name|tcCopyPlane
block|,
name|cfbPolyPoint
block|,
name|cfbLineSS
block|,
name|cfbSegmentSS
block|,
name|miPolyRectangle
block|,
if|#
directive|if
name|PPW
operator|==
literal|4
name|cfbZeroPolyArcSS8Copy
block|,
else|#
directive|else
name|miZeroPolyArc
block|,
endif|#
directive|endif
name|miFillPolygon
block|,
name|tcPolyFillRect
block|,
name|cfbPolyFillArcSolidCopy
block|,
name|miPolyText8
block|,
name|miPolyText16
block|,
name|miImageText8
block|,
name|miImageText16
block|,
if|#
directive|if
name|PPW
operator|==
literal|4
name|cfbImageGlyphBlt8
block|,
name|cfbPolyGlyphBlt8
block|,
name|cfbPushPixels8
block|,
else|#
directive|else
name|miImageGlyphBlt
block|,
name|miPolyGlyphBlt
block|,
name|mfbPushPixels
block|,
endif|#
directive|endif
name|NULL
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|GCOps
name|tcWinOps1Rect
init|=
block|{
name|tcSolidFS
block|,
name|cfbSetSpans
block|,
name|tcPutImage
block|,
name|hpcCopyArea
block|,
name|tcCopyPlane
block|,
name|cfbPolyPoint
block|,
if|#
directive|if
name|PPW
operator|==
literal|4
name|cfb8LineSS1Rect
block|,
name|cfb8SegmentSS1Rect
block|,
else|#
directive|else
name|cfbLineSS
block|,
name|cfbSegmentSS
block|,
endif|#
directive|endif
name|miPolyRectangle
block|,
name|cfbZeroPolyArcSS8Copy
block|,
name|cfbFillPoly1RectCopy
block|,
name|tcPolyFillRect
block|,
name|cfbPolyFillArcSolidCopy
block|,
name|miPolyText8
block|,
name|miPolyText16
block|,
name|miImageText8
block|,
name|miImageText16
block|,
name|tcImageGlyphBlt
block|,
name|cfbPolyGlyphBlt8
block|,
name|cfbPushPixels8
block|,
name|NULL
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|GCOps
name|tcWinOps
init|=
block|{
name|tcSolidFS
block|,
name|cfbSetSpans
block|,
name|tcPutImage
block|,
name|hpcCopyArea
block|,
name|tcCopyPlane
block|,
name|cfbPolyPoint
block|,
name|cfbLineSS
block|,
name|cfbSegmentSS
block|,
name|miPolyRectangle
block|,
name|cfbZeroPolyArcSS8Copy
block|,
name|miFillPolygon
block|,
name|tcPolyFillRect
block|,
name|cfbPolyFillArcSolidCopy
block|,
name|miPolyText8
block|,
name|miPolyText16
block|,
name|miImageText8
block|,
name|miImageText16
block|,
name|tcImageGlyphBlt
block|,
name|cfbPolyGlyphBlt8
block|,
name|cfbPushPixels8
block|,
name|NULL
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|GCOps
name|tcWinOTEOps1Rect
init|=
block|{
name|tcSolidFS
block|,
name|cfbSetSpans
block|,
name|tcPutImage
block|,
name|hpcCopyArea
block|,
name|tcCopyPlane
block|,
name|cfbPolyPoint
block|,
if|#
directive|if
name|PPW
operator|==
literal|4
name|cfb8LineSS1Rect
block|,
name|cfb8SegmentSS1Rect
block|,
else|#
directive|else
name|cfbLineSS
block|,
name|cfbSegmentSS
block|,
endif|#
directive|endif
name|miPolyRectangle
block|,
name|cfbZeroPolyArcSS8Copy
block|,
name|cfbFillPoly1RectCopy
block|,
name|tcPolyFillRect
block|,
name|cfbPolyFillArcSolidCopy
block|,
name|tcPolyOptText8
block|,
name|miPolyText16
block|,
name|tcImageOptTEText8
block|,
name|miImageText16
block|,
name|tcImageGlyphBlt
block|,
name|cfbPolyGlyphBlt8
block|,
name|cfbPushPixels8
block|,
name|NULL
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|GCOps
name|tcWinOTEOps
init|=
block|{
name|tcSolidFS
block|,
name|cfbSetSpans
block|,
name|tcPutImage
block|,
name|hpcCopyArea
block|,
name|tcCopyPlane
block|,
name|cfbPolyPoint
block|,
name|cfbLineSS
block|,
name|cfbSegmentSS
block|,
name|miPolyRectangle
block|,
name|cfbZeroPolyArcSS8Copy
block|,
name|miFillPolygon
block|,
name|tcPolyFillRect
block|,
name|cfbPolyFillArcSolidCopy
block|,
name|tcPolyOptText8
block|,
name|miPolyText16
block|,
name|tcImageOptTEText8
block|,
name|miImageText16
block|,
name|tcImageGlyphBlt
block|,
name|cfbPolyGlyphBlt8
block|,
name|cfbPushPixels8
block|,
name|NULL
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|GCOps
name|tcWinONonTEOps1Rect
init|=
block|{
name|tcSolidFS
block|,
name|cfbSetSpans
block|,
name|tcPutImage
block|,
name|hpcCopyArea
block|,
name|tcCopyPlane
block|,
name|cfbPolyPoint
block|,
if|#
directive|if
name|PPW
operator|==
literal|4
name|cfb8LineSS1Rect
block|,
name|cfb8SegmentSS1Rect
block|,
else|#
directive|else
name|cfbLineSS
block|,
name|cfbSegmentSS
block|,
endif|#
directive|endif
name|miPolyRectangle
block|,
name|cfbZeroPolyArcSS8Copy
block|,
name|cfbFillPoly1RectCopy
block|,
name|tcPolyFillRect
block|,
name|cfbPolyFillArcSolidCopy
block|,
name|tcPolyOptText8
block|,
name|miPolyText16
block|,
name|tcImageOptText8
block|,
name|miImageText16
block|,
name|tcImageGlyphBlt
block|,
name|cfbPolyGlyphBlt8
block|,
name|cfbPushPixels8
block|,
name|NULL
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|GCOps
name|tcWinONonTEOps
init|=
block|{
name|tcSolidFS
block|,
name|cfbSetSpans
block|,
name|tcPutImage
block|,
name|hpcCopyArea
block|,
name|tcCopyPlane
block|,
name|cfbPolyPoint
block|,
name|cfbLineSS
block|,
name|cfbSegmentSS
block|,
name|miPolyRectangle
block|,
name|cfbZeroPolyArcSS8Copy
block|,
name|miFillPolygon
block|,
name|tcPolyFillRect
block|,
name|cfbPolyFillArcSolidCopy
block|,
name|tcPolyOptText8
block|,
name|miPolyText16
block|,
name|tcImageOptText8
block|,
name|miImageText16
block|,
name|tcImageGlyphBlt
block|,
name|cfbPolyGlyphBlt8
block|,
name|cfbPushPixels8
block|,
name|NULL
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|GCOps
modifier|*
name|tcMatchCommon
parameter_list|(
name|pGC
parameter_list|,
name|devPriv
parameter_list|,
name|pWin
parameter_list|)
name|GCPtr
name|pGC
decl_stmt|;
name|cfbPrivGCPtr
name|devPriv
decl_stmt|;
name|WindowPtr
name|pWin
decl_stmt|;
block|{
if|if
condition|(
name|pGC
operator|->
name|lineWidth
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|pGC
operator|->
name|lineStyle
operator|!=
name|LineSolid
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|pGC
operator|->
name|fillStyle
operator|!=
name|FillSolid
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|devPriv
operator|->
name|rop
operator|!=
name|GXcopy
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|pWin
condition|)
block|{
if|if
condition|(
name|pGC
operator|->
name|font
operator|&&
name|FONTMAXBOUNDS
argument_list|(
name|pGC
operator|->
name|font
argument_list|,
name|rightSideBearing
argument_list|)
operator|-
name|FONTMINBOUNDS
argument_list|(
name|pGC
operator|->
name|font
argument_list|,
name|leftSideBearing
argument_list|)
operator|<=
literal|32
operator|&&
name|FONTMINBOUNDS
argument_list|(
name|pGC
operator|->
name|font
argument_list|,
name|characterWidth
argument_list|)
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|TERMINALFONT
argument_list|(
name|pGC
operator|->
name|font
argument_list|)
if|#
directive|if
name|PPW
operator|==
literal|4
operator|&&
name|FONTMAXBOUNDS
argument_list|(
name|pGC
operator|->
name|font
argument_list|,
name|characterWidth
argument_list|)
operator|>=
literal|4
endif|#
directive|endif
condition|)
if|if
condition|(
name|devPriv
operator|->
name|oneRect
condition|)
return|return
operator|&
name|cfbTEOps1Rect
return|;
else|else
return|return
operator|&
name|cfbTEOps
return|;
elseif|else
if|if
condition|(
name|devPriv
operator|->
name|oneRect
condition|)
return|return
operator|&
name|cfbNonTEOps1Rect
return|;
else|else
return|return
operator|&
name|cfbNonTEOps
return|;
block|}
block|}
else|else
block|{
if|#
directive|if
literal|0
comment|/* XXXX */
block|if (pGC->font&& pGC->font->devPriv[pGC->pScreen->myNum]) 	{ 	    if (TERMINALFONT(pGC->font)) 		if (devPriv->oneRect) 		    return&tcWinOTEOps1Rect; 		else 		    return&tcWinOTEOps; 	    else 		if (devPriv->oneRect) 		    return&tcWinONonTEOps1Rect; 		else 		    return&tcWinONonTEOps; 	}
endif|#
directive|endif
if|if
condition|(
name|devPriv
operator|->
name|oneRect
condition|)
return|return
operator|&
name|tcWinOps1Rect
return|;
else|else
return|return
operator|&
name|tcWinOps
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|Bool
name|topcatCreateGC
parameter_list|(
name|pGC
parameter_list|)
specifier|register
name|GCPtr
name|pGC
decl_stmt|;
block|{
name|cfbPrivGC
modifier|*
name|pPriv
decl_stmt|;
if|if
condition|(
name|pGC
operator|->
name|depth
operator|==
literal|1
condition|)
return|return
name|mfbCreateGC
argument_list|(
name|pGC
argument_list|)
return|;
name|pGC
operator|->
name|clientClip
operator|=
name|NULL
expr_stmt|;
name|pGC
operator|->
name|clientClipType
operator|=
name|CT_NONE
expr_stmt|;
comment|/*      * some of the output primitives aren't really necessary, since they      * will be filled in ValidateGC because of dix/CreateGC() setting all      * the change bits.  Others are necessary because although they depend      * on being a color frame buffer, they don't change       */
name|pGC
operator|->
name|ops
operator|=
operator|&
name|cfbNonTEOps
expr_stmt|;
name|pGC
operator|->
name|funcs
operator|=
operator|&
name|cfbGCFuncs
expr_stmt|;
comment|/* cfb wants to translate before scan conversion */
name|pGC
operator|->
name|miTranslate
operator|=
literal|1
expr_stmt|;
name|pPriv
operator|=
operator|(
name|cfbPrivGC
operator|*
operator|)
operator|(
name|pGC
operator|->
name|devPrivates
index|[
name|cfbGCPrivateIndex
index|]
operator|.
name|ptr
operator|)
expr_stmt|;
name|pPriv
operator|->
name|rop
operator|=
name|pGC
operator|->
name|alu
expr_stmt|;
name|pPriv
operator|->
name|oneRect
operator|=
name|FALSE
expr_stmt|;
name|pPriv
operator|->
name|fExpose
operator|=
name|TRUE
expr_stmt|;
name|pPriv
operator|->
name|freeCompClip
operator|=
name|FALSE
expr_stmt|;
name|pPriv
operator|->
name|pRotatedPixmap
operator|=
operator|(
name|PixmapPtr
operator|)
name|NULL
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|cfbChangeGC
parameter_list|(
name|pGC
parameter_list|,
name|mask
parameter_list|)
name|GC
modifier|*
name|pGC
decl_stmt|;
name|BITS32
name|mask
decl_stmt|;
block|{
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|cfbDestroyGC
parameter_list|(
name|pGC
parameter_list|)
name|GC
modifier|*
name|pGC
decl_stmt|;
block|{
name|cfbPrivGC
modifier|*
name|pPriv
decl_stmt|;
name|pPriv
operator|=
operator|(
name|cfbPrivGC
operator|*
operator|)
operator|(
name|pGC
operator|->
name|devPrivates
index|[
name|cfbGCPrivateIndex
index|]
operator|.
name|ptr
operator|)
expr_stmt|;
if|if
condition|(
name|pPriv
operator|->
name|pRotatedPixmap
condition|)
name|cfbDestroyPixmap
argument_list|(
name|pPriv
operator|->
name|pRotatedPixmap
argument_list|)
expr_stmt|;
if|if
condition|(
name|pPriv
operator|->
name|freeCompClip
condition|)
call|(
modifier|*
name|pGC
operator|->
name|pScreen
operator|->
name|RegionDestroy
call|)
argument_list|(
name|pPriv
operator|->
name|pCompositeClip
argument_list|)
expr_stmt|;
name|cfbDestroyOps
argument_list|(
name|pGC
operator|->
name|ops
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * create a private op array for a gc  */
end_comment

begin_function
specifier|static
name|GCOps
modifier|*
name|cfbCreateOps
parameter_list|(
name|prototype
parameter_list|)
name|GCOps
modifier|*
name|prototype
decl_stmt|;
block|{
name|GCOps
modifier|*
name|ret
decl_stmt|;
specifier|extern
name|Bool
name|Must_have_memory
decl_stmt|;
comment|/* XXX */
name|Must_have_memory
operator|=
name|TRUE
expr_stmt|;
name|ret
operator|=
operator|(
name|GCOps
operator|*
operator|)
name|xalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|GCOps
argument_list|)
argument_list|)
expr_stmt|;
comment|/* XXX */
name|Must_have_memory
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
return|return
literal|0
return|;
operator|*
name|ret
operator|=
operator|*
name|prototype
expr_stmt|;
name|ret
operator|->
name|devPrivate
operator|.
name|val
operator|=
literal|1
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_expr_stmt
specifier|static
name|cfbDestroyOps
argument_list|(
argument|ops
argument_list|)
name|GCOps
operator|*
name|ops
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|ops
operator|->
name|devPrivate
operator|.
name|val
condition|)
name|xfree
argument_list|(
name|ops
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Clipping conventions 	if the drawable is a window 	    CT_REGION ==> pCompositeClip really is the composite 	    CT_other ==> pCompositeClip is the window clip region 	if the drawable is a pixmap 	    CT_REGION ==> pCompositeClip is the translated client region 		clipped to the pixmap boundary 	    CT_other ==> pCompositeClip is the pixmap bounding box */
end_comment

begin_function
specifier|static
name|void
name|topcatValidateGC
parameter_list|(
name|pGC
parameter_list|,
name|changes
parameter_list|,
name|pDrawable
parameter_list|)
specifier|register
name|GCPtr
name|pGC
decl_stmt|;
name|Mask
name|changes
decl_stmt|;
name|DrawablePtr
name|pDrawable
decl_stmt|;
block|{
name|WindowPtr
name|pWin
decl_stmt|;
name|int
name|mask
decl_stmt|;
comment|/* stateChanges */
name|int
name|index
decl_stmt|;
comment|/* used for stepping through bitfields */
name|int
name|new_rrop
decl_stmt|;
name|int
name|new_line
decl_stmt|,
name|new_text
decl_stmt|,
name|new_fillspans
decl_stmt|,
name|new_fillarea
decl_stmt|;
name|int
name|new_rotate
decl_stmt|;
name|int
name|xrot
decl_stmt|,
name|yrot
decl_stmt|;
comment|/* flags for changing the proc vector */
name|cfbPrivGCPtr
name|devPriv
decl_stmt|;
name|int
name|oneRect
decl_stmt|;
name|new_rotate
operator|=
name|pGC
operator|->
name|lastWinOrg
operator|.
name|x
operator|!=
name|pDrawable
operator|->
name|x
operator|||
name|pGC
operator|->
name|lastWinOrg
operator|.
name|y
operator|!=
name|pDrawable
operator|->
name|y
expr_stmt|;
name|pGC
operator|->
name|lastWinOrg
operator|.
name|x
operator|=
name|pDrawable
operator|->
name|x
expr_stmt|;
name|pGC
operator|->
name|lastWinOrg
operator|.
name|y
operator|=
name|pDrawable
operator|->
name|y
expr_stmt|;
if|if
condition|(
name|pDrawable
operator|->
name|type
operator|==
name|DRAWABLE_WINDOW
condition|)
block|{
name|pWin
operator|=
operator|(
name|WindowPtr
operator|)
name|pDrawable
expr_stmt|;
block|}
else|else
block|{
name|pWin
operator|=
operator|(
name|WindowPtr
operator|)
name|NULL
expr_stmt|;
block|}
name|devPriv
operator|=
operator|(
call|(
name|cfbPrivGCPtr
call|)
argument_list|(
name|pGC
operator|->
name|devPrivates
index|[
name|cfbGCPrivateIndex
index|]
operator|.
name|ptr
argument_list|)
operator|)
expr_stmt|;
name|new_rrop
operator|=
name|FALSE
expr_stmt|;
name|new_line
operator|=
name|FALSE
expr_stmt|;
name|new_text
operator|=
name|FALSE
expr_stmt|;
name|new_fillspans
operator|=
name|FALSE
expr_stmt|;
name|new_fillarea
operator|=
name|FALSE
expr_stmt|;
comment|/*      * if the client clip is different or moved OR the subwindowMode has      * changed OR the window's clip has changed since the last validation      * we need to recompute the composite clip       */
if|if
condition|(
operator|(
name|changes
operator|&
operator|(
name|GCClipXOrigin
operator||
name|GCClipYOrigin
operator||
name|GCClipMask
operator||
name|GCSubwindowMode
operator|)
operator|)
operator|||
operator|(
name|pDrawable
operator|->
name|serialNumber
operator|!=
operator|(
name|pGC
operator|->
name|serialNumber
operator|&
name|DRAWABLE_SERIAL_BITS
operator|)
operator|)
condition|)
block|{
name|ScreenPtr
name|pScreen
init|=
name|pGC
operator|->
name|pScreen
decl_stmt|;
if|if
condition|(
name|pWin
condition|)
block|{
name|RegionPtr
name|pregWin
decl_stmt|;
name|Bool
name|freeTmpClip
decl_stmt|,
name|freeCompClip
decl_stmt|;
if|if
condition|(
name|pGC
operator|->
name|subWindowMode
operator|==
name|IncludeInferiors
condition|)
block|{
name|pregWin
operator|=
name|NotClippedByChildren
argument_list|(
name|pWin
argument_list|)
expr_stmt|;
name|freeTmpClip
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|pregWin
operator|=
operator|&
name|pWin
operator|->
name|clipList
expr_stmt|;
name|freeTmpClip
operator|=
name|FALSE
expr_stmt|;
block|}
name|freeCompClip
operator|=
name|devPriv
operator|->
name|freeCompClip
expr_stmt|;
comment|/* 	     * if there is no client clip, we can get by with just keeping 	     * the pointer we got, and remembering whether or not should 	     * destroy (or maybe re-use) it later.  this way, we avoid 	     * unnecessary copying of regions.  (this wins especially if 	     * many clients clip by children and have no client clip.)  	     */
if|if
condition|(
name|pGC
operator|->
name|clientClipType
operator|==
name|CT_NONE
condition|)
block|{
if|if
condition|(
name|freeCompClip
condition|)
call|(
modifier|*
name|pScreen
operator|->
name|RegionDestroy
call|)
argument_list|(
name|devPriv
operator|->
name|pCompositeClip
argument_list|)
expr_stmt|;
name|devPriv
operator|->
name|pCompositeClip
operator|=
name|pregWin
expr_stmt|;
name|devPriv
operator|->
name|freeCompClip
operator|=
name|freeTmpClip
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * we need one 'real' region to put into the composite 		 * clip. if pregWin the current composite clip are real, 		 * we can get rid of one. if pregWin is real and the 		 * current composite clip isn't, use pregWin for the 		 * composite clip. if the current composite clip is real 		 * and pregWin isn't, use the current composite clip. if 		 * neither is real, create a new region.  		 */
call|(
modifier|*
name|pScreen
operator|->
name|TranslateRegion
call|)
argument_list|(
name|pGC
operator|->
name|clientClip
argument_list|,
name|pDrawable
operator|->
name|x
operator|+
name|pGC
operator|->
name|clipOrg
operator|.
name|x
argument_list|,
name|pDrawable
operator|->
name|y
operator|+
name|pGC
operator|->
name|clipOrg
operator|.
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|freeCompClip
condition|)
block|{
call|(
modifier|*
name|pGC
operator|->
name|pScreen
operator|->
name|Intersect
call|)
argument_list|(
name|devPriv
operator|->
name|pCompositeClip
argument_list|,
name|pregWin
argument_list|,
name|pGC
operator|->
name|clientClip
argument_list|)
expr_stmt|;
if|if
condition|(
name|freeTmpClip
condition|)
call|(
modifier|*
name|pScreen
operator|->
name|RegionDestroy
call|)
argument_list|(
name|pregWin
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|freeTmpClip
condition|)
block|{
call|(
modifier|*
name|pScreen
operator|->
name|Intersect
call|)
argument_list|(
name|pregWin
argument_list|,
name|pregWin
argument_list|,
name|pGC
operator|->
name|clientClip
argument_list|)
expr_stmt|;
name|devPriv
operator|->
name|pCompositeClip
operator|=
name|pregWin
expr_stmt|;
block|}
else|else
block|{
name|devPriv
operator|->
name|pCompositeClip
operator|=
call|(
modifier|*
name|pScreen
operator|->
name|RegionCreate
call|)
argument_list|(
name|NullBox
argument_list|,
literal|0
argument_list|)
expr_stmt|;
call|(
modifier|*
name|pScreen
operator|->
name|Intersect
call|)
argument_list|(
name|devPriv
operator|->
name|pCompositeClip
argument_list|,
name|pregWin
argument_list|,
name|pGC
operator|->
name|clientClip
argument_list|)
expr_stmt|;
block|}
name|devPriv
operator|->
name|freeCompClip
operator|=
name|TRUE
expr_stmt|;
call|(
modifier|*
name|pScreen
operator|->
name|TranslateRegion
call|)
argument_list|(
name|pGC
operator|->
name|clientClip
argument_list|,
operator|-
operator|(
name|pDrawable
operator|->
name|x
operator|+
name|pGC
operator|->
name|clipOrg
operator|.
name|x
operator|)
argument_list|,
operator|-
operator|(
name|pDrawable
operator|->
name|y
operator|+
name|pGC
operator|->
name|clipOrg
operator|.
name|y
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* end of composite clip for a window */
else|else
block|{
name|BoxRec
name|pixbounds
decl_stmt|;
comment|/* XXX should we translate by drawable.x/y here ? */
name|pixbounds
operator|.
name|x1
operator|=
literal|0
expr_stmt|;
name|pixbounds
operator|.
name|y1
operator|=
literal|0
expr_stmt|;
name|pixbounds
operator|.
name|x2
operator|=
name|pDrawable
operator|->
name|width
expr_stmt|;
name|pixbounds
operator|.
name|y2
operator|=
name|pDrawable
operator|->
name|height
expr_stmt|;
if|if
condition|(
name|devPriv
operator|->
name|freeCompClip
condition|)
call|(
modifier|*
name|pScreen
operator|->
name|RegionReset
call|)
argument_list|(
name|devPriv
operator|->
name|pCompositeClip
argument_list|,
operator|&
name|pixbounds
argument_list|)
expr_stmt|;
else|else
block|{
name|devPriv
operator|->
name|freeCompClip
operator|=
name|TRUE
expr_stmt|;
name|devPriv
operator|->
name|pCompositeClip
operator|=
call|(
modifier|*
name|pScreen
operator|->
name|RegionCreate
call|)
argument_list|(
operator|&
name|pixbounds
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pGC
operator|->
name|clientClipType
operator|==
name|CT_REGION
condition|)
block|{
call|(
modifier|*
name|pScreen
operator|->
name|TranslateRegion
call|)
argument_list|(
name|devPriv
operator|->
name|pCompositeClip
argument_list|,
operator|-
name|pGC
operator|->
name|clipOrg
operator|.
name|x
argument_list|,
operator|-
name|pGC
operator|->
name|clipOrg
operator|.
name|y
argument_list|)
expr_stmt|;
call|(
modifier|*
name|pScreen
operator|->
name|Intersect
call|)
argument_list|(
name|devPriv
operator|->
name|pCompositeClip
argument_list|,
name|devPriv
operator|->
name|pCompositeClip
argument_list|,
name|pGC
operator|->
name|clientClip
argument_list|)
expr_stmt|;
call|(
modifier|*
name|pScreen
operator|->
name|TranslateRegion
call|)
argument_list|(
name|devPriv
operator|->
name|pCompositeClip
argument_list|,
name|pGC
operator|->
name|clipOrg
operator|.
name|x
argument_list|,
name|pGC
operator|->
name|clipOrg
operator|.
name|y
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* end of composute clip for pixmap */
name|oneRect
operator|=
name|REGION_NUM_RECTS
argument_list|(
name|devPriv
operator|->
name|pCompositeClip
argument_list|)
operator|==
literal|1
expr_stmt|;
if|if
condition|(
name|oneRect
operator|!=
name|devPriv
operator|->
name|oneRect
condition|)
name|new_line
operator|=
name|TRUE
expr_stmt|;
name|devPriv
operator|->
name|oneRect
operator|=
name|oneRect
expr_stmt|;
block|}
name|mask
operator|=
name|changes
expr_stmt|;
while|while
condition|(
name|mask
condition|)
block|{
name|index
operator|=
name|lowbit
argument_list|(
name|mask
argument_list|)
expr_stmt|;
name|mask
operator|&=
operator|~
name|index
expr_stmt|;
comment|/* 	 * this switch acculmulates a list of which procedures might have 	 * to change due to changes in the GC.  in some cases (e.g. 	 * changing one 16 bit tile for another) we might not really need 	 * a change, but the code is being paranoid. this sort of batching 	 * wins if, for example, the alu and the font have been changed, 	 * or any other pair of items that both change the same thing.  	 */
switch|switch
condition|(
name|index
condition|)
block|{
case|case
name|GCFunction
case|:
case|case
name|GCForeground
case|:
name|new_rrop
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|GCPlaneMask
case|:
name|new_rrop
operator|=
name|TRUE
expr_stmt|;
name|new_text
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|GCBackground
case|:
break|break;
case|case
name|GCLineStyle
case|:
case|case
name|GCLineWidth
case|:
name|new_line
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|GCJoinStyle
case|:
case|case
name|GCCapStyle
case|:
break|break;
case|case
name|GCFillStyle
case|:
name|new_text
operator|=
name|TRUE
expr_stmt|;
name|new_fillspans
operator|=
name|TRUE
expr_stmt|;
name|new_line
operator|=
name|TRUE
expr_stmt|;
name|new_fillarea
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|GCFillRule
case|:
break|break;
case|case
name|GCTile
case|:
name|new_fillspans
operator|=
name|TRUE
expr_stmt|;
name|new_fillarea
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|GCStipple
case|:
if|if
condition|(
name|pGC
operator|->
name|stipple
condition|)
block|{
name|int
name|width
init|=
name|pGC
operator|->
name|stipple
operator|->
name|drawable
operator|.
name|width
decl_stmt|;
name|PixmapPtr
name|nstipple
decl_stmt|;
if|if
condition|(
operator|(
name|width
operator|<=
literal|32
operator|)
operator|&&
operator|!
operator|(
name|width
operator|&
operator|(
name|width
operator|-
literal|1
operator|)
operator|)
operator|&&
operator|(
name|nstipple
operator|=
name|cfbCopyPixmap
argument_list|(
name|pGC
operator|->
name|stipple
argument_list|)
operator|)
condition|)
block|{
name|cfbPadPixmap
argument_list|(
name|nstipple
argument_list|)
expr_stmt|;
name|cfbDestroyPixmap
argument_list|(
name|pGC
operator|->
name|stipple
argument_list|)
expr_stmt|;
name|pGC
operator|->
name|stipple
operator|=
name|nstipple
expr_stmt|;
block|}
block|}
name|new_fillspans
operator|=
name|TRUE
expr_stmt|;
name|new_fillarea
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|GCTileStipXOrigin
case|:
name|new_rotate
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|GCTileStipYOrigin
case|:
name|new_rotate
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|GCFont
case|:
name|new_text
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|GCSubwindowMode
case|:
break|break;
case|case
name|GCGraphicsExposures
case|:
break|break;
case|case
name|GCClipXOrigin
case|:
break|break;
case|case
name|GCClipYOrigin
case|:
break|break;
case|case
name|GCClipMask
case|:
break|break;
case|case
name|GCDashOffset
case|:
break|break;
case|case
name|GCDashList
case|:
break|break;
case|case
name|GCArcMode
case|:
break|break;
default|default:
break|break;
block|}
block|}
comment|/*      * If the drawable has changed,  ensure suitable      * entries are in the proc vector.       */
if|if
condition|(
name|pDrawable
operator|->
name|serialNumber
operator|!=
operator|(
name|pGC
operator|->
name|serialNumber
operator|&
operator|(
name|DRAWABLE_SERIAL_BITS
operator|)
operator|)
condition|)
block|{
name|new_fillspans
operator|=
name|TRUE
expr_stmt|;
comment|/* deal with FillSpans later */
block|}
if|if
condition|(
name|new_rotate
operator|||
name|new_fillspans
condition|)
block|{
name|Bool
name|new_pix
init|=
name|FALSE
decl_stmt|;
name|xrot
operator|=
name|pGC
operator|->
name|patOrg
operator|.
name|x
operator|+
name|pDrawable
operator|->
name|x
expr_stmt|;
name|yrot
operator|=
name|pGC
operator|->
name|patOrg
operator|.
name|y
operator|+
name|pDrawable
operator|->
name|y
expr_stmt|;
switch|switch
condition|(
name|pGC
operator|->
name|fillStyle
condition|)
block|{
case|case
name|FillTiled
case|:
if|if
condition|(
operator|!
name|pGC
operator|->
name|tileIsPixel
condition|)
block|{
name|int
name|width
init|=
name|pGC
operator|->
name|tile
operator|.
name|pixmap
operator|->
name|drawable
operator|.
name|width
operator|*
name|PSZ
decl_stmt|;
if|if
condition|(
operator|(
name|width
operator|<=
literal|32
operator|)
operator|&&
operator|!
operator|(
name|width
operator|&
operator|(
name|width
operator|-
literal|1
operator|)
operator|)
condition|)
block|{
name|cfbCopyRotatePixmap
argument_list|(
name|pGC
operator|->
name|tile
operator|.
name|pixmap
argument_list|,
operator|&
name|devPriv
operator|->
name|pRotatedPixmap
argument_list|,
name|xrot
argument_list|,
name|yrot
argument_list|)
expr_stmt|;
name|new_pix
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
break|break;
if|#
directive|if
operator|(
name|PPW
operator|==
literal|4
operator|)
case|case
name|FillStippled
case|:
case|case
name|FillOpaqueStippled
case|:
block|{
name|int
name|width
init|=
name|pGC
operator|->
name|stipple
operator|->
name|drawable
operator|.
name|width
decl_stmt|;
if|if
condition|(
operator|(
name|width
operator|<=
literal|32
operator|)
operator|&&
operator|!
operator|(
name|width
operator|&
operator|(
name|width
operator|-
literal|1
operator|)
operator|)
condition|)
block|{
name|mfbCopyRotatePixmap
argument_list|(
name|pGC
operator|->
name|stipple
argument_list|,
operator|&
name|devPriv
operator|->
name|pRotatedPixmap
argument_list|,
name|xrot
argument_list|,
name|yrot
argument_list|)
expr_stmt|;
name|new_pix
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
break|break;
endif|#
directive|endif
block|}
if|if
condition|(
operator|!
name|new_pix
operator|&&
name|devPriv
operator|->
name|pRotatedPixmap
condition|)
block|{
name|cfbDestroyPixmap
argument_list|(
name|devPriv
operator|->
name|pRotatedPixmap
argument_list|)
expr_stmt|;
name|devPriv
operator|->
name|pRotatedPixmap
operator|=
operator|(
name|PixmapPtr
operator|)
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|new_rrop
condition|)
block|{
name|int
name|old_rrop
decl_stmt|;
name|old_rrop
operator|=
name|devPriv
operator|->
name|rop
expr_stmt|;
name|devPriv
operator|->
name|rop
operator|=
name|cfbReduceRasterOp
argument_list|(
name|pGC
operator|->
name|alu
argument_list|,
name|pGC
operator|->
name|fgPixel
argument_list|,
name|pGC
operator|->
name|planemask
argument_list|,
operator|&
name|devPriv
operator|->
name|and
argument_list|,
operator|&
name|devPriv
operator|->
name|xor
argument_list|)
expr_stmt|;
if|if
condition|(
name|old_rrop
operator|==
name|devPriv
operator|->
name|rop
condition|)
name|new_rrop
operator|=
name|FALSE
expr_stmt|;
else|else
block|{
if|#
directive|if
name|PPW
operator|==
literal|4
name|new_line
operator|=
name|TRUE
expr_stmt|;
name|new_text
operator|=
name|TRUE
expr_stmt|;
endif|#
directive|endif
name|new_fillspans
operator|=
name|TRUE
expr_stmt|;
name|new_fillarea
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|new_rrop
operator|||
name|new_fillspans
operator|||
name|new_text
operator|||
name|new_fillarea
operator|||
name|new_line
condition|)
block|{
name|GCOps
modifier|*
name|newops
decl_stmt|;
if|if
condition|(
name|newops
operator|=
name|tcMatchCommon
argument_list|(
name|pGC
argument_list|,
name|devPriv
argument_list|,
name|pWin
argument_list|)
condition|)
block|{
if|if
condition|(
name|pGC
operator|->
name|ops
operator|->
name|devPrivate
operator|.
name|val
condition|)
name|cfbDestroyOps
argument_list|(
name|pGC
operator|->
name|ops
argument_list|)
expr_stmt|;
name|pGC
operator|->
name|ops
operator|=
name|newops
expr_stmt|;
name|new_rrop
operator|=
name|new_line
operator|=
name|new_fillspans
operator|=
name|new_text
operator|=
name|new_fillarea
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|pGC
operator|->
name|ops
operator|->
name|devPrivate
operator|.
name|val
condition|)
block|{
name|pGC
operator|->
name|ops
operator|=
name|cfbCreateOps
argument_list|(
name|pGC
operator|->
name|ops
argument_list|)
expr_stmt|;
name|pGC
operator|->
name|ops
operator|->
name|devPrivate
operator|.
name|val
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
comment|/* deal with the changes we've collected */
if|if
condition|(
name|new_line
condition|)
block|{
name|pGC
operator|->
name|ops
operator|->
name|FillPolygon
operator|=
name|miFillPolygon
expr_stmt|;
if|if
condition|(
name|devPriv
operator|->
name|oneRect
operator|&&
name|pGC
operator|->
name|fillStyle
operator|==
name|FillSolid
condition|)
block|{
switch|switch
condition|(
name|devPriv
operator|->
name|rop
condition|)
block|{
case|case
name|GXcopy
case|:
name|pGC
operator|->
name|ops
operator|->
name|FillPolygon
operator|=
name|cfbFillPoly1RectCopy
expr_stmt|;
break|break;
default|default:
name|pGC
operator|->
name|ops
operator|->
name|FillPolygon
operator|=
name|cfbFillPoly1RectGeneral
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|pGC
operator|->
name|lineWidth
operator|==
literal|0
condition|)
block|{
if|#
directive|if
name|PPW
operator|==
literal|4
if|if
condition|(
operator|(
name|pGC
operator|->
name|lineStyle
operator|==
name|LineSolid
operator|)
operator|&&
operator|(
name|pGC
operator|->
name|fillStyle
operator|==
name|FillSolid
operator|)
condition|)
block|{
switch|switch
condition|(
name|devPriv
operator|->
name|rop
condition|)
block|{
case|case
name|GXxor
case|:
name|pGC
operator|->
name|ops
operator|->
name|PolyArc
operator|=
name|cfbZeroPolyArcSS8Xor
expr_stmt|;
break|break;
case|case
name|GXcopy
case|:
name|pGC
operator|->
name|ops
operator|->
name|PolyArc
operator|=
name|cfbZeroPolyArcSS8Copy
expr_stmt|;
break|break;
default|default:
name|pGC
operator|->
name|ops
operator|->
name|PolyArc
operator|=
name|cfbZeroPolyArcSS8General
expr_stmt|;
break|break;
block|}
block|}
else|else
endif|#
directive|endif
name|pGC
operator|->
name|ops
operator|->
name|PolyArc
operator|=
name|miZeroPolyArc
expr_stmt|;
block|}
else|else
name|pGC
operator|->
name|ops
operator|->
name|PolyArc
operator|=
name|miPolyArc
expr_stmt|;
name|pGC
operator|->
name|ops
operator|->
name|PolySegment
operator|=
name|miPolySegment
expr_stmt|;
switch|switch
condition|(
name|pGC
operator|->
name|lineStyle
condition|)
block|{
case|case
name|LineSolid
case|:
if|if
condition|(
name|pGC
operator|->
name|lineWidth
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|pGC
operator|->
name|fillStyle
operator|==
name|FillSolid
condition|)
block|{
if|#
directive|if
name|PPW
operator|==
literal|4
if|if
condition|(
name|devPriv
operator|->
name|oneRect
condition|)
block|{
name|pGC
operator|->
name|ops
operator|->
name|Polylines
operator|=
name|cfb8LineSS1Rect
expr_stmt|;
name|pGC
operator|->
name|ops
operator|->
name|PolySegment
operator|=
name|cfb8SegmentSS1Rect
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
name|pGC
operator|->
name|ops
operator|->
name|Polylines
operator|=
name|cfbLineSS
expr_stmt|;
name|pGC
operator|->
name|ops
operator|->
name|PolySegment
operator|=
name|cfbSegmentSS
expr_stmt|;
block|}
block|}
else|else
name|pGC
operator|->
name|ops
operator|->
name|Polylines
operator|=
name|miZeroLine
expr_stmt|;
block|}
else|else
name|pGC
operator|->
name|ops
operator|->
name|Polylines
operator|=
name|miWideLine
expr_stmt|;
break|break;
case|case
name|LineOnOffDash
case|:
case|case
name|LineDoubleDash
case|:
if|if
condition|(
name|pGC
operator|->
name|lineWidth
operator|==
literal|0
operator|&&
name|pGC
operator|->
name|fillStyle
operator|==
name|FillSolid
condition|)
block|{
name|pGC
operator|->
name|ops
operator|->
name|Polylines
operator|=
name|cfbLineSD
expr_stmt|;
name|pGC
operator|->
name|ops
operator|->
name|PolySegment
operator|=
name|cfbSegmentSD
expr_stmt|;
block|}
else|else
name|pGC
operator|->
name|ops
operator|->
name|Polylines
operator|=
name|miWideDash
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|new_text
operator|&&
operator|(
name|pGC
operator|->
name|font
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|pWin
condition|)
block|{
if|if
condition|(
name|FONTMAXBOUNDS
argument_list|(
name|pGC
operator|->
name|font
argument_list|,
name|rightSideBearing
argument_list|)
operator|-
name|FONTMINBOUNDS
argument_list|(
name|pGC
operator|->
name|font
argument_list|,
name|leftSideBearing
argument_list|)
operator|>
literal|32
operator|||
name|FONTMINBOUNDS
argument_list|(
name|pGC
operator|->
name|font
argument_list|,
name|characterWidth
argument_list|)
operator|<
literal|0
condition|)
block|{
name|pGC
operator|->
name|ops
operator|->
name|PolyGlyphBlt
operator|=
name|miPolyGlyphBlt
expr_stmt|;
name|pGC
operator|->
name|ops
operator|->
name|ImageGlyphBlt
operator|=
name|miImageGlyphBlt
expr_stmt|;
block|}
else|else
block|{
if|#
directive|if
name|PPW
operator|==
literal|4
if|if
condition|(
name|pGC
operator|->
name|fillStyle
operator|==
name|FillSolid
condition|)
block|{
if|if
condition|(
name|devPriv
operator|->
name|rop
operator|==
name|GXcopy
condition|)
name|pGC
operator|->
name|ops
operator|->
name|PolyGlyphBlt
operator|=
name|cfbPolyGlyphBlt8
expr_stmt|;
else|else
name|pGC
operator|->
name|ops
operator|->
name|PolyGlyphBlt
operator|=
name|cfbPolyGlyphRop8
expr_stmt|;
block|}
else|else
endif|#
directive|endif
name|pGC
operator|->
name|ops
operator|->
name|PolyGlyphBlt
operator|=
name|miPolyGlyphBlt
expr_stmt|;
comment|/* special case ImageGlyphBlt for terminal emulator fonts */
if|if
condition|(
name|TERMINALFONT
argument_list|(
name|pGC
operator|->
name|font
argument_list|)
operator|&&
operator|(
name|pGC
operator|->
name|planemask
operator|&
name|PMSK
operator|)
operator|==
name|PMSK
if|#
directive|if
name|PPW
operator|==
literal|4
operator|&&
name|FONTMAXBOUNDS
argument_list|(
name|pGC
operator|->
name|font
argument_list|,
name|characterWidth
argument_list|)
operator|>=
literal|4
endif|#
directive|endif
condition|)
block|{
if|#
directive|if
name|PPW
operator|==
literal|4
name|pGC
operator|->
name|ops
operator|->
name|ImageGlyphBlt
operator|=
name|cfbTEGlyphBlt8
expr_stmt|;
else|#
directive|else
name|pGC
operator|->
name|ops
operator|->
name|ImageGlyphBlt
operator|=
name|cfbTEGlyphBlt
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
if|#
directive|if
name|PPW
operator|==
literal|4
name|pGC
operator|->
name|ops
operator|->
name|ImageGlyphBlt
operator|=
name|cfbImageGlyphBlt8
expr_stmt|;
else|#
directive|else
name|pGC
operator|->
name|ops
operator|->
name|ImageGlyphBlt
operator|=
name|miImageGlyphBlt
expr_stmt|;
endif|#
directive|endif
block|}
block|}
block|}
else|else
block|{
name|pGC
operator|->
name|ops
operator|->
name|ImageGlyphBlt
operator|=
name|tcImageGlyphBlt
expr_stmt|;
if|if
condition|(
name|FONTMAXBOUNDS
argument_list|(
name|pGC
operator|->
name|font
argument_list|,
name|rightSideBearing
argument_list|)
operator|-
name|FONTMINBOUNDS
argument_list|(
name|pGC
operator|->
name|font
argument_list|,
name|leftSideBearing
argument_list|)
operator|>
literal|32
operator|||
name|FONTMINBOUNDS
argument_list|(
name|pGC
operator|->
name|font
argument_list|,
name|characterWidth
argument_list|)
operator|<
literal|0
condition|)
name|pGC
operator|->
name|ops
operator|->
name|PolyGlyphBlt
operator|=
name|miPolyGlyphBlt
expr_stmt|;
elseif|else
if|#
directive|if
name|PPW
operator|==
literal|4
if|if
condition|(
name|pGC
operator|->
name|fillStyle
operator|==
name|FillSolid
condition|)
block|{
if|if
condition|(
name|devPriv
operator|->
name|rop
operator|==
name|GXcopy
condition|)
name|pGC
operator|->
name|ops
operator|->
name|PolyGlyphBlt
operator|=
name|cfbPolyGlyphBlt8
expr_stmt|;
else|else
name|pGC
operator|->
name|ops
operator|->
name|PolyGlyphBlt
operator|=
name|cfbPolyGlyphRop8
expr_stmt|;
block|}
else|else
endif|#
directive|endif
name|pGC
operator|->
name|ops
operator|->
name|PolyGlyphBlt
operator|=
name|miPolyGlyphBlt
expr_stmt|;
if|#
directive|if
literal|0
block|if (pGC->font->devPriv[pGC->pScreen->myNum]) 	    { 		pGC->ops->PolyText8 = tcPolyOptText8; 		if (TERMINALFONT(pGC->font)) 		    pGC->ops->ImageText8 = tcImageOptTEText8; 		else 		    pGC->ops->ImageText8 = tcImageOptText8; 	    } 	    else
endif|#
directive|endif
block|{
name|pGC
operator|->
name|ops
operator|->
name|PolyText8
operator|=
name|miPolyText8
expr_stmt|;
name|pGC
operator|->
name|ops
operator|->
name|ImageText8
operator|=
name|miImageText8
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|new_fillspans
condition|)
block|{
switch|switch
condition|(
name|pGC
operator|->
name|fillStyle
condition|)
block|{
case|case
name|FillSolid
case|:
if|if
condition|(
name|pDrawable
operator|->
name|type
operator|==
name|DRAWABLE_WINDOW
condition|)
name|pGC
operator|->
name|ops
operator|->
name|FillSpans
operator|=
name|tcSolidFS
expr_stmt|;
else|else
switch|switch
condition|(
name|devPriv
operator|->
name|rop
condition|)
block|{
case|case
name|GXcopy
case|:
name|pGC
operator|->
name|ops
operator|->
name|FillSpans
operator|=
name|cfbSolidSpansCopy
expr_stmt|;
break|break;
case|case
name|GXxor
case|:
name|pGC
operator|->
name|ops
operator|->
name|FillSpans
operator|=
name|cfbSolidSpansXor
expr_stmt|;
break|break;
default|default:
name|pGC
operator|->
name|ops
operator|->
name|FillSpans
operator|=
name|cfbSolidSpansGeneral
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FillTiled
case|:
if|#
directive|if
literal|1
comment|/* XXX */
if|if
condition|(
name|devPriv
operator|->
name|pRotatedPixmap
condition|)
block|{
if|if
condition|(
name|pGC
operator|->
name|alu
operator|==
name|GXcopy
operator|&&
operator|(
name|pGC
operator|->
name|planemask
operator|&
name|PMSK
operator|)
operator|==
name|PMSK
condition|)
name|pGC
operator|->
name|ops
operator|->
name|FillSpans
operator|=
name|cfbTile32FSCopy
expr_stmt|;
else|else
name|pGC
operator|->
name|ops
operator|->
name|FillSpans
operator|=
name|cfbTile32FSGeneral
expr_stmt|;
block|}
else|else
endif|#
directive|endif
name|pGC
operator|->
name|ops
operator|->
name|FillSpans
operator|=
name|cfbUnnaturalTileFS
expr_stmt|;
break|break;
case|case
name|FillStippled
case|:
if|#
directive|if
name|PPW
operator|==
literal|4
if|if
condition|(
name|devPriv
operator|->
name|pRotatedPixmap
condition|)
name|pGC
operator|->
name|ops
operator|->
name|FillSpans
operator|=
name|cfb8Stipple32FS
expr_stmt|;
else|else
endif|#
directive|endif
name|pGC
operator|->
name|ops
operator|->
name|FillSpans
operator|=
name|cfbUnnaturalStippleFS
expr_stmt|;
break|break;
case|case
name|FillOpaqueStippled
case|:
if|#
directive|if
name|PPW
operator|==
literal|4
if|if
condition|(
name|devPriv
operator|->
name|pRotatedPixmap
condition|)
name|pGC
operator|->
name|ops
operator|->
name|FillSpans
operator|=
name|cfb8OpaqueStipple32FS
expr_stmt|;
else|else
endif|#
directive|endif
name|pGC
operator|->
name|ops
operator|->
name|FillSpans
operator|=
name|cfbUnnaturalStippleFS
expr_stmt|;
break|break;
default|default:
name|FatalError
argument_list|(
literal|"cfbValidateGC: illegal fillStyle\n"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* end of new_fillspans */
if|if
condition|(
name|new_fillarea
condition|)
block|{
if|#
directive|if
name|PPW
operator|!=
literal|4
name|pGC
operator|->
name|ops
operator|->
name|PolyFillRect
operator|=
name|miPolyFillRect
expr_stmt|;
if|if
condition|(
name|pGC
operator|->
name|fillStyle
operator|==
name|FillSolid
operator|||
name|pGC
operator|->
name|fillStyle
operator|==
name|FillTiled
condition|)
block|{
name|pGC
operator|->
name|ops
operator|->
name|PolyFillRect
operator|=
name|tcPolyFillRect
expr_stmt|;
block|}
endif|#
directive|endif
if|#
directive|if
name|PPW
operator|==
literal|4
name|pGC
operator|->
name|ops
operator|->
name|PushPixels
operator|=
name|mfbPushPixels
expr_stmt|;
if|if
condition|(
name|pGC
operator|->
name|fillStyle
operator|==
name|FillSolid
operator|&&
name|devPriv
operator|->
name|rop
operator|==
name|GXcopy
condition|)
name|pGC
operator|->
name|ops
operator|->
name|PushPixels
operator|=
name|cfbPushPixels8
expr_stmt|;
endif|#
directive|endif
name|pGC
operator|->
name|ops
operator|->
name|PolyFillArc
operator|=
name|miPolyFillArc
expr_stmt|;
switch|switch
condition|(
name|pGC
operator|->
name|fillStyle
condition|)
block|{
case|case
name|FillSolid
case|:
switch|switch
condition|(
name|devPriv
operator|->
name|rop
condition|)
block|{
case|case
name|GXcopy
case|:
name|pGC
operator|->
name|ops
operator|->
name|PolyFillArc
operator|=
name|cfbPolyFillArcSolidCopy
expr_stmt|;
break|break;
default|default:
name|pGC
operator|->
name|ops
operator|->
name|PolyFillArc
operator|=
name|cfbPolyFillArcSolidGeneral
expr_stmt|;
break|break;
block|}
break|break;
if|#
directive|if
operator|(
name|PPW
operator|==
literal|4
operator|)
case|case
name|FillStippled
case|:
case|case
name|FillOpaqueStippled
case|:
name|pGC
operator|->
name|ops
operator|->
name|PolyFillRect
operator|=
name|tcPolyFillStippledRect
expr_stmt|;
break|break;
endif|#
directive|endif
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|cfbDestroyClip
parameter_list|(
name|pGC
parameter_list|)
name|GCPtr
name|pGC
decl_stmt|;
block|{
if|if
condition|(
name|pGC
operator|->
name|clientClipType
operator|==
name|CT_NONE
condition|)
return|return;
elseif|else
if|if
condition|(
name|pGC
operator|->
name|clientClipType
operator|==
name|CT_PIXMAP
condition|)
block|{
name|cfbDestroyPixmap
argument_list|(
call|(
name|PixmapPtr
call|)
argument_list|(
name|pGC
operator|->
name|clientClip
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* we know we'll never have a list of rectangles, since 	   ChangeClip immediately turns them into a region  	*/
call|(
modifier|*
name|pGC
operator|->
name|pScreen
operator|->
name|RegionDestroy
call|)
argument_list|(
name|pGC
operator|->
name|clientClip
argument_list|)
expr_stmt|;
block|}
name|pGC
operator|->
name|clientClip
operator|=
name|NULL
expr_stmt|;
name|pGC
operator|->
name|clientClipType
operator|=
name|CT_NONE
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cfbChangeClip
parameter_list|(
name|pGC
parameter_list|,
name|type
parameter_list|,
name|pvalue
parameter_list|,
name|nrects
parameter_list|)
name|GCPtr
name|pGC
decl_stmt|;
name|int
name|type
decl_stmt|;
name|pointer
name|pvalue
decl_stmt|;
name|int
name|nrects
decl_stmt|;
block|{
name|cfbDestroyClip
argument_list|(
name|pGC
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|CT_PIXMAP
condition|)
block|{
name|pGC
operator|->
name|clientClip
operator|=
call|(
name|pointer
call|)
argument_list|(
operator|*
name|pGC
operator|->
name|pScreen
operator|->
name|BitmapToRegion
argument_list|)
argument_list|(
operator|(
name|PixmapPtr
operator|)
name|pvalue
argument_list|)
expr_stmt|;
call|(
modifier|*
name|pGC
operator|->
name|pScreen
operator|->
name|DestroyPixmap
call|)
argument_list|(
name|pvalue
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|CT_REGION
condition|)
block|{
comment|/* stuff the region in the GC */
name|pGC
operator|->
name|clientClip
operator|=
name|pvalue
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|!=
name|CT_NONE
condition|)
block|{
name|pGC
operator|->
name|clientClip
operator|=
call|(
name|pointer
call|)
argument_list|(
operator|*
name|pGC
operator|->
name|pScreen
operator|->
name|RectsToRegion
argument_list|)
argument_list|(
name|nrects
argument_list|,
operator|(
name|xRectangle
operator|*
operator|)
name|pvalue
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|pvalue
argument_list|)
expr_stmt|;
block|}
name|pGC
operator|->
name|clientClipType
operator|=
operator|(
name|type
operator|!=
name|CT_NONE
operator|&&
name|pGC
operator|->
name|clientClip
operator|)
condition|?
name|CT_REGION
else|:
name|CT_NONE
expr_stmt|;
name|pGC
operator|->
name|stateChanges
operator||=
name|GCClipMask
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cfbCopyClip
parameter_list|(
name|pgcDst
parameter_list|,
name|pgcSrc
parameter_list|)
name|GCPtr
name|pgcDst
decl_stmt|,
name|pgcSrc
decl_stmt|;
block|{
name|RegionPtr
name|prgnNew
decl_stmt|;
switch|switch
condition|(
name|pgcSrc
operator|->
name|clientClipType
condition|)
block|{
case|case
name|CT_PIXMAP
case|:
operator|(
operator|(
name|PixmapPtr
operator|)
name|pgcSrc
operator|->
name|clientClip
operator|)
operator|->
name|refcnt
operator|++
expr_stmt|;
comment|/* Fall through !! */
case|case
name|CT_NONE
case|:
name|cfbChangeClip
argument_list|(
name|pgcDst
argument_list|,
operator|(
name|int
operator|)
name|pgcSrc
operator|->
name|clientClipType
argument_list|,
name|pgcSrc
operator|->
name|clientClip
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|CT_REGION
case|:
name|prgnNew
operator|=
call|(
modifier|*
name|pgcSrc
operator|->
name|pScreen
operator|->
name|RegionCreate
call|)
argument_list|(
name|NULL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
call|(
modifier|*
name|pgcSrc
operator|->
name|pScreen
operator|->
name|RegionCopy
call|)
argument_list|(
name|prgnNew
argument_list|,
call|(
name|RegionPtr
call|)
argument_list|(
name|pgcSrc
operator|->
name|clientClip
argument_list|)
argument_list|)
expr_stmt|;
name|cfbChangeClip
argument_list|(
name|pgcDst
argument_list|,
name|CT_REGION
argument_list|,
operator|(
name|pointer
operator|)
name|prgnNew
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|cfbCopyGC
parameter_list|(
name|pGCSrc
parameter_list|,
name|changes
parameter_list|,
name|pGCDst
parameter_list|)
name|GCPtr
name|pGCSrc
decl_stmt|;
name|Mask
name|changes
decl_stmt|;
name|GCPtr
name|pGCDst
decl_stmt|;
block|{
return|return;
block|}
end_function

end_unit

