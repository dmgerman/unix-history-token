begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*********************************************************** Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts, and the Massachusetts Institute of Technology, Cambridge, Massachusetts.                          All Rights Reserved  Permission to use, copy, modify, and distribute this software and its  documentation for any purpose and without fee is hereby granted,  provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in  supporting documentation, and that the names of Digital or MIT not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.    DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  ******************************************************************/
end_comment

begin_comment
comment|/* $XConsortium: mfbpushpxl.c,v 5.2 89/09/14 16:26:57 rws Exp $ */
end_comment

begin_include
include|#
directive|include
file|"X.h"
end_include

begin_include
include|#
directive|include
file|"gcstruct.h"
end_include

begin_include
include|#
directive|include
file|"scrnintstr.h"
end_include

begin_include
include|#
directive|include
file|"pixmapstr.h"
end_include

begin_include
include|#
directive|include
file|"miscstruct.h"
end_include

begin_include
include|#
directive|include
file|"maskbits.h"
end_include

begin_include
include|#
directive|include
file|"regionstr.h"
end_include

begin_include
include|#
directive|include
file|"mfb.h"
end_include

begin_comment
comment|/*  mfbSolidPP is courtesy of xhacks@csri.toronto.edu      For fillStyle==FillSolid, a monochrome PushPixels can be reduced to     a ROP in the following way:  (Note that the ROP is the same as the     result of ROP(src=0x3,dst=0x5))  			src=0011 0000 0011 			dst=0101 0101 0101 			rop      fg=0 fg=1 	GXclear         0x0 0000 0100 0100 0 	GXand           0x1 0001 0100 0101  s&d 	GXandReverse    0x2 0010 0100 0110 s&~d 	GXcopy          0x3 0011 0100 0111 s 	GXandInverted   0x4 0100 0101 0100 ~s&d 	GXnoop          0x5 0101 0101 0101 d 	GXxor           0x6 0110 0101 0110 s^d 	GXor            0x7 0111 0101 0111 s|d 	GXnor           0x8 1000 0110 0100 ~s&~d 	GXequiv         0x9 1001 0110 0101 ~s^d 	GXinvert        0xa 1010 0110 0110 ~d 	GXorReverse     0xb 1011 0110 0111 s|~d 	GXcopyInverted  0xc 1100 0111 0100 ~s 	GXorInverted    0xd 1101 0111 0101 ~s|d 	GXnand          0xe 1110 0111 0110 ~s|~d 	GXset           0xf 1111 0111 0111 1  For src=0: newRop = 0x4|(rop>>2) For src=1: newRop = 0x4|(rop&3) */
end_comment

begin_comment
comment|/* mfbSolidPP -- squeegees the forground color of pGC through pBitMap  * into pDrawable.  pBitMap is a stencil (dx by dy of it is used, it may  * be bigger) which is placed on the drawable at xOrg, yOrg.  Where a 1 bit  * is set in the bitmap, the fill style is put onto the drawable using  * the GC's logical function. The drawable is not changed where the bitmap  * has a zero bit or outside the area covered by the stencil.  */
end_comment

begin_function
name|void
name|mfbSolidPP
parameter_list|(
name|pGC
parameter_list|,
name|pBitMap
parameter_list|,
name|pDrawable
parameter_list|,
name|dx
parameter_list|,
name|dy
parameter_list|,
name|xOrg
parameter_list|,
name|yOrg
parameter_list|)
name|GCPtr
name|pGC
decl_stmt|;
name|PixmapPtr
name|pBitMap
decl_stmt|;
name|DrawablePtr
name|pDrawable
decl_stmt|;
name|int
name|dx
decl_stmt|,
name|dy
decl_stmt|,
name|xOrg
decl_stmt|,
name|yOrg
decl_stmt|;
block|{
name|unsigned
name|char
name|alu
decl_stmt|;
name|RegionRec
name|rgnDst
decl_stmt|;
name|DDXPointPtr
name|pptSrc
decl_stmt|;
name|BoxRec
name|srcBox
decl_stmt|;
specifier|register
name|DDXPointPtr
name|ppt
decl_stmt|;
specifier|register
name|BoxPtr
name|pbox
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|pGC
operator|->
name|planemask
operator|&
literal|1
condition|)
return|return;
comment|/* compute the reduced rop function */
name|alu
operator|=
name|pGC
operator|->
name|alu
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|pGC
operator|->
name|fgPixel
operator|&
literal|1
operator|)
condition|)
name|alu
operator|>>=
literal|2
expr_stmt|;
name|alu
operator|=
operator|(
name|alu
operator|&
literal|0x3
operator|)
operator||
literal|0x4
expr_stmt|;
if|if
condition|(
name|alu
operator|==
name|GXnoop
condition|)
return|return;
name|srcBox
operator|.
name|x1
operator|=
name|xOrg
expr_stmt|;
name|srcBox
operator|.
name|y1
operator|=
name|yOrg
expr_stmt|;
name|srcBox
operator|.
name|x2
operator|=
name|xOrg
operator|+
name|dx
expr_stmt|;
name|srcBox
operator|.
name|y2
operator|=
name|yOrg
operator|+
name|dy
expr_stmt|;
call|(
modifier|*
name|pGC
operator|->
name|pScreen
operator|->
name|RegionInit
call|)
argument_list|(
operator|&
name|rgnDst
argument_list|,
operator|&
name|srcBox
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* clip the shape of the dst to the destination composite clip */
call|(
modifier|*
name|pGC
operator|->
name|pScreen
operator|->
name|Intersect
call|)
argument_list|(
operator|&
name|rgnDst
argument_list|,
operator|&
name|rgnDst
argument_list|,
operator|(
operator|(
name|mfbPrivGC
operator|*
operator|)
operator|(
name|pGC
operator|->
name|devPrivates
index|[
name|mfbGCPrivateIndex
index|]
operator|.
name|ptr
operator|)
operator|)
operator|->
name|pCompositeClip
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|REGION_NIL
argument_list|(
operator|&
name|rgnDst
argument_list|)
condition|)
block|{
name|i
operator|=
name|REGION_NUM_RECTS
argument_list|(
operator|&
name|rgnDst
argument_list|)
expr_stmt|;
name|pptSrc
operator|=
operator|(
name|DDXPointPtr
operator|)
name|ALLOCATE_LOCAL
argument_list|(
name|i
operator|*
sizeof|sizeof
argument_list|(
name|DDXPointRec
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pptSrc
condition|)
block|{
for|for
control|(
name|pbox
operator|=
name|REGION_RECTS
argument_list|(
operator|&
name|rgnDst
argument_list|)
operator|,
name|ppt
operator|=
name|pptSrc
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
name|pbox
operator|++
operator|,
name|ppt
operator|++
control|)
block|{
name|ppt
operator|->
name|x
operator|=
name|pbox
operator|->
name|x1
operator|-
name|xOrg
expr_stmt|;
name|ppt
operator|->
name|y
operator|=
name|pbox
operator|->
name|y1
operator|-
name|yOrg
expr_stmt|;
block|}
name|mfbDoBitblt
argument_list|(
operator|(
name|DrawablePtr
operator|)
name|pBitMap
argument_list|,
name|pDrawable
argument_list|,
name|alu
argument_list|,
operator|&
name|rgnDst
argument_list|,
name|pptSrc
argument_list|)
expr_stmt|;
name|DEALLOCATE_LOCAL
argument_list|(
name|pptSrc
argument_list|)
expr_stmt|;
block|}
block|}
call|(
modifier|*
name|pGC
operator|->
name|pScreen
operator|->
name|RegionUninit
call|)
argument_list|(
operator|&
name|rgnDst
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|NPT
value|128
end_define

begin_comment
comment|/* mfbPushPixels -- squeegees the forground color of pGC through pBitMap  * into pDrawable.  pBitMap is a stencil (dx by dy of it is used, it may  * be bigger) which is placed on the drawable at xOrg, yOrg.  Where a 1 bit  * is set in the bitmap, the fill style is put onto the drawable using  * the GC's logical function. The drawable is not changed where the bitmap  * has a zero bit or outside the area covered by the stencil.  */
end_comment

begin_function
name|void
name|mfbPushPixels
parameter_list|(
name|pGC
parameter_list|,
name|pBitMap
parameter_list|,
name|pDrawable
parameter_list|,
name|dx
parameter_list|,
name|dy
parameter_list|,
name|xOrg
parameter_list|,
name|yOrg
parameter_list|)
name|GCPtr
name|pGC
decl_stmt|;
name|PixmapPtr
name|pBitMap
decl_stmt|;
name|DrawablePtr
name|pDrawable
decl_stmt|;
name|int
name|dx
decl_stmt|,
name|dy
decl_stmt|,
name|xOrg
decl_stmt|,
name|yOrg
decl_stmt|;
block|{
name|int
name|h
decl_stmt|,
name|dxDiv32
decl_stmt|,
name|ibEnd
decl_stmt|;
name|unsigned
name|int
modifier|*
name|pwLineStart
decl_stmt|;
specifier|register
name|unsigned
name|int
modifier|*
name|pw
decl_stmt|,
modifier|*
name|pwEnd
decl_stmt|;
specifier|register
name|unsigned
name|int
name|mask
decl_stmt|;
specifier|register
name|int
name|ib
decl_stmt|,
name|w
decl_stmt|;
specifier|register
name|int
name|ipt
decl_stmt|;
comment|/* index into above arrays */
name|hpPrivPixmapPtr
name|pPrivBitMap
decl_stmt|;
name|Bool
name|fInBox
decl_stmt|;
name|DDXPointRec
name|pt
index|[
name|NPT
index|]
decl_stmt|;
name|int
name|width
index|[
name|NPT
index|]
decl_stmt|;
if|if
condition|(
name|pBitMap
operator|->
name|devKind
operator|==
name|PIXMAP_FRAME_BUFFER
condition|)
name|WAIT_READY_TO_RENDER
argument_list|(
name|pBitMap
operator|->
name|drawable
operator|.
name|pScreen
argument_list|)
expr_stmt|;
name|WAIT_READY_TO_RENDER
argument_list|(
name|pDrawable
operator|->
name|pScreen
argument_list|)
expr_stmt|;
name|pPrivBitMap
operator|=
call|(
name|hpPrivPixmapPtr
call|)
argument_list|(
name|pBitMap
operator|->
name|devPrivate
operator|.
name|ptr
argument_list|)
expr_stmt|;
comment|/* Now scan convert the pixmap and use the result to call fillspans in      * in the drawable with the original GC */
name|ipt
operator|=
literal|0
expr_stmt|;
name|dxDiv32
operator|=
name|dx
operator|/
literal|32
expr_stmt|;
for|for
control|(
name|h
operator|=
literal|0
init|;
name|h
operator|<
name|dy
condition|;
name|h
operator|++
control|)
block|{
name|pw
operator|=
operator|(
name|unsigned
name|int
operator|*
operator|)
operator|(
operator|(
operator|(
name|char
operator|*
operator|)
operator|(
name|pPrivBitMap
operator|->
name|bits
operator|)
operator|)
operator|+
operator|(
name|h
operator|*
name|pPrivBitMap
operator|->
name|stride
operator|)
operator|)
expr_stmt|;
name|pwLineStart
operator|=
name|pw
expr_stmt|;
comment|/* Process all words which are fully in the pixmap */
name|fInBox
operator|=
name|FALSE
expr_stmt|;
name|pwEnd
operator|=
name|pwLineStart
operator|+
name|dxDiv32
expr_stmt|;
while|while
condition|(
name|pw
operator|<
name|pwEnd
condition|)
block|{
name|w
operator|=
operator|*
name|pw
expr_stmt|;
name|mask
operator|=
name|endtab
index|[
literal|1
index|]
expr_stmt|;
for|for
control|(
name|ib
operator|=
literal|0
init|;
name|ib
operator|<
literal|32
condition|;
name|ib
operator|++
control|)
block|{
if|if
condition|(
name|w
operator|&
name|mask
condition|)
block|{
if|if
condition|(
operator|!
name|fInBox
condition|)
block|{
name|pt
index|[
name|ipt
index|]
operator|.
name|x
operator|=
operator|(
operator|(
name|pw
operator|-
name|pwLineStart
operator|)
operator|<<
literal|5
operator|)
operator|+
name|ib
operator|+
name|xOrg
expr_stmt|;
name|pt
index|[
name|ipt
index|]
operator|.
name|y
operator|=
name|h
operator|+
name|yOrg
expr_stmt|;
comment|/* start new box */
name|fInBox
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|fInBox
condition|)
block|{
name|width
index|[
name|ipt
index|]
operator|=
operator|(
operator|(
name|pw
operator|-
name|pwLineStart
operator|)
operator|<<
literal|5
operator|)
operator|+
name|ib
operator|+
name|xOrg
operator|-
name|pt
index|[
name|ipt
index|]
operator|.
name|x
expr_stmt|;
if|if
condition|(
operator|++
name|ipt
operator|>=
name|NPT
condition|)
block|{
call|(
modifier|*
name|pGC
operator|->
name|ops
operator|->
name|FillSpans
call|)
argument_list|(
name|pDrawable
argument_list|,
name|pGC
argument_list|,
name|NPT
argument_list|,
name|pt
argument_list|,
name|width
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|ipt
operator|=
literal|0
expr_stmt|;
block|}
comment|/* end box */
name|fInBox
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
name|mask
operator|=
name|SCRRIGHT
argument_list|(
name|mask
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|pw
operator|++
expr_stmt|;
block|}
name|ibEnd
operator|=
name|dx
operator|&
literal|0x1F
expr_stmt|;
if|if
condition|(
name|ibEnd
condition|)
block|{
comment|/* Process final partial word on line */
name|w
operator|=
operator|*
name|pw
expr_stmt|;
name|mask
operator|=
name|endtab
index|[
literal|1
index|]
expr_stmt|;
for|for
control|(
name|ib
operator|=
literal|0
init|;
name|ib
operator|<
name|ibEnd
condition|;
name|ib
operator|++
control|)
block|{
if|if
condition|(
name|w
operator|&
name|mask
condition|)
block|{
if|if
condition|(
operator|!
name|fInBox
condition|)
block|{
comment|/* start new box */
name|pt
index|[
name|ipt
index|]
operator|.
name|x
operator|=
operator|(
operator|(
name|pw
operator|-
name|pwLineStart
operator|)
operator|<<
literal|5
operator|)
operator|+
name|ib
operator|+
name|xOrg
expr_stmt|;
name|pt
index|[
name|ipt
index|]
operator|.
name|y
operator|=
name|h
operator|+
name|yOrg
expr_stmt|;
name|fInBox
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|fInBox
condition|)
block|{
comment|/* end box */
name|width
index|[
name|ipt
index|]
operator|=
operator|(
operator|(
name|pw
operator|-
name|pwLineStart
operator|)
operator|<<
literal|5
operator|)
operator|+
name|ib
operator|+
name|xOrg
operator|-
name|pt
index|[
name|ipt
index|]
operator|.
name|x
expr_stmt|;
if|if
condition|(
operator|++
name|ipt
operator|>=
name|NPT
condition|)
block|{
call|(
modifier|*
name|pGC
operator|->
name|ops
operator|->
name|FillSpans
call|)
argument_list|(
name|pDrawable
argument_list|,
name|pGC
argument_list|,
name|NPT
argument_list|,
name|pt
argument_list|,
name|width
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|ipt
operator|=
literal|0
expr_stmt|;
block|}
name|fInBox
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
name|mask
operator|=
name|SCRRIGHT
argument_list|(
name|mask
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If scanline ended with last bit set, end the box */
if|if
condition|(
name|fInBox
condition|)
block|{
name|width
index|[
name|ipt
index|]
operator|=
name|dx
operator|+
name|xOrg
operator|-
name|pt
index|[
name|ipt
index|]
operator|.
name|x
expr_stmt|;
if|if
condition|(
operator|++
name|ipt
operator|>=
name|NPT
condition|)
block|{
call|(
modifier|*
name|pGC
operator|->
name|ops
operator|->
name|FillSpans
call|)
argument_list|(
name|pDrawable
argument_list|,
name|pGC
argument_list|,
name|NPT
argument_list|,
name|pt
argument_list|,
name|width
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|ipt
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
comment|/* Flush any remaining spans */
if|if
condition|(
name|ipt
condition|)
block|{
call|(
modifier|*
name|pGC
operator|->
name|ops
operator|->
name|FillSpans
call|)
argument_list|(
name|pDrawable
argument_list|,
name|pGC
argument_list|,
name|ipt
argument_list|,
name|pt
argument_list|,
name|width
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

