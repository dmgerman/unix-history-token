begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * cfb copy area  */
end_comment

begin_comment
comment|/* Copyright 1989 by the Massachusetts Institute of Technology  Permission to use, copy, modify, and distribute this software and its documentation for any purpose and without fee is hereby granted, provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in supporting documentation, and that the name of M.I.T. not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.  M.I.T. makes no representations about the suitability of this software for any purpose.  It is provided "as is" without express or implied warranty.  Author: Keith Packard  */
end_comment

begin_comment
comment|/* $XConsortium: cfbblt.c,v 1.7 91/05/06 15:13:21 rws Exp $ */
end_comment

begin_include
include|#
directive|include
file|"X.h"
end_include

begin_include
include|#
directive|include
file|"Xmd.h"
end_include

begin_include
include|#
directive|include
file|"Xproto.h"
end_include

begin_include
include|#
directive|include
file|"gcstruct.h"
end_include

begin_include
include|#
directive|include
file|"windowstr.h"
end_include

begin_include
include|#
directive|include
file|"scrnintstr.h"
end_include

begin_include
include|#
directive|include
file|"pixmapstr.h"
end_include

begin_include
include|#
directive|include
file|"regionstr.h"
end_include

begin_include
include|#
directive|include
file|"cfb.h"
end_include

begin_include
include|#
directive|include
file|"cfbmskbits.h"
end_include

begin_include
include|#
directive|include
file|"cfb8bit.h"
end_include

begin_include
include|#
directive|include
file|"fastblt.h"
end_include

begin_include
include|#
directive|include
file|"mergerop.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|notdef
end_ifdef

begin_comment
comment|/* XXX fails right now, walks off end of pixmaps */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|FAST_UNALIGNED_READS
argument_list|)
operator|&&
operator|(
name|PPW
operator|==
literal|4
operator|)
end_if

begin_define
define|#
directive|define
name|DO_UNALIGNED_BITBLT
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|MROP_NAME
function|(
name|cfbDoBitblt
function|)
parameter_list|(
name|pSrc
parameter_list|,
name|pDst
parameter_list|,
name|alu
parameter_list|,
name|prgnDst
parameter_list|,
name|pptSrc
parameter_list|,
name|planemask
parameter_list|)
name|DrawablePtr
name|pSrc
decl_stmt|,
name|pDst
decl_stmt|;
name|int
name|alu
decl_stmt|;
name|RegionPtr
name|prgnDst
decl_stmt|;
name|DDXPointPtr
name|pptSrc
decl_stmt|;
name|unsigned
name|long
name|planemask
decl_stmt|;
block|{
name|unsigned
name|long
modifier|*
name|psrcBase
decl_stmt|,
modifier|*
name|pdstBase
decl_stmt|;
comment|/* start of src and dst bitmaps */
name|int
name|widthSrc
decl_stmt|,
name|widthDst
decl_stmt|;
comment|/* add to get to same position in next line */
name|BoxPtr
name|pbox
decl_stmt|;
name|int
name|nbox
decl_stmt|;
name|BoxPtr
name|pboxTmp
decl_stmt|,
name|pboxNext
decl_stmt|,
name|pboxBase
decl_stmt|,
name|pboxNew1
decl_stmt|,
name|pboxNew2
decl_stmt|;
comment|/* temporaries for shuffling rectangles */
name|DDXPointPtr
name|pptTmp
decl_stmt|,
name|pptNew1
decl_stmt|,
name|pptNew2
decl_stmt|;
comment|/* shuffling boxes entails shuffling the 				   source points too */
name|int
name|w
decl_stmt|,
name|h
decl_stmt|;
name|int
name|xdir
decl_stmt|;
comment|/* 1 = left right, -1 = right left/ */
name|int
name|ydir
decl_stmt|;
comment|/* 1 = top down, -1 = bottom up */
name|unsigned
name|long
modifier|*
name|psrcLine
decl_stmt|,
modifier|*
name|pdstLine
decl_stmt|;
comment|/* pointers to line with current src and dst */
specifier|register
name|unsigned
name|long
modifier|*
name|psrc
decl_stmt|;
comment|/* pointer to current src longword */
specifier|register
name|unsigned
name|long
modifier|*
name|pdst
decl_stmt|;
comment|/* pointer to current dst longword */
name|MROP_DECLARE_REG
argument_list|()
comment|/* following used for looping through a line */
name|unsigned
name|long
name|startmask
decl_stmt|,
name|endmask
decl_stmt|;
comment|/* masks for writing ends of dst */
name|int
name|nlMiddle
decl_stmt|;
comment|/* whole longwords in dst */
name|int
name|xoffSrc
decl_stmt|,
name|xoffDst
decl_stmt|;
specifier|register
name|int
name|leftShift
decl_stmt|,
name|rightShift
decl_stmt|;
specifier|register
name|unsigned
name|long
name|bits
decl_stmt|;
specifier|register
name|unsigned
name|long
name|bits1
decl_stmt|;
specifier|register
name|int
name|nl
decl_stmt|;
comment|/* temp copy of nlMiddle */
comment|/* place to store full source word */
name|int
name|nstart
decl_stmt|;
comment|/* number of ragged bits at start of dst */
name|int
name|nend
decl_stmt|;
comment|/* number of ragged bits at end of dst */
name|int
name|srcStartOver
decl_stmt|;
comment|/* pulling nstart bits from src 				   overflows into the next word? */
name|int
name|careful
decl_stmt|;
name|int
name|tmpSrc
decl_stmt|;
name|MROP_INITIALIZE
argument_list|(
name|alu
argument_list|,
name|planemask
argument_list|)
expr_stmt|;
name|cfbGetLongWidthAndPointer
argument_list|(
argument|pSrc
argument_list|,
argument|widthSrc
argument_list|,
argument|psrcBase
argument_list|)
name|cfbGetLongWidthAndPointer
argument_list|(
argument|pDst
argument_list|,
argument|widthDst
argument_list|,
argument|pdstBase
argument_list|)
comment|/* XXX we have to err on the side of safety when both are windows,      * because we don't know if IncludeInferiors is being used.      */
name|careful
operator|=
operator|(
operator|(
name|pSrc
operator|==
name|pDst
operator|)
operator|||
operator|(
operator|(
name|pSrc
operator|->
name|type
operator|==
name|DRAWABLE_WINDOW
operator|)
operator|&&
operator|(
name|pDst
operator|->
name|type
operator|==
name|DRAWABLE_WINDOW
operator|)
operator|)
operator|)
expr_stmt|;
name|pbox
operator|=
name|REGION_RECTS
argument_list|(
name|prgnDst
argument_list|)
expr_stmt|;
name|nbox
operator|=
name|REGION_NUM_RECTS
argument_list|(
name|prgnDst
argument_list|)
expr_stmt|;
name|pboxNew1
operator|=
name|NULL
expr_stmt|;
name|pptNew1
operator|=
name|NULL
expr_stmt|;
name|pboxNew2
operator|=
name|NULL
expr_stmt|;
name|pptNew2
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|careful
operator|&&
operator|(
name|pptSrc
operator|->
name|y
operator|<
name|pbox
operator|->
name|y1
operator|)
condition|)
block|{
comment|/* walk source botttom to top */
name|ydir
operator|=
operator|-
literal|1
expr_stmt|;
name|widthSrc
operator|=
operator|-
name|widthSrc
expr_stmt|;
name|widthDst
operator|=
operator|-
name|widthDst
expr_stmt|;
if|if
condition|(
name|nbox
operator|>
literal|1
condition|)
block|{
comment|/* keep ordering in each band, reverse order of bands */
name|pboxNew1
operator|=
operator|(
name|BoxPtr
operator|)
name|ALLOCATE_LOCAL
argument_list|(
sizeof|sizeof
argument_list|(
name|BoxRec
argument_list|)
operator|*
name|nbox
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pboxNew1
condition|)
return|return;
name|pptNew1
operator|=
operator|(
name|DDXPointPtr
operator|)
name|ALLOCATE_LOCAL
argument_list|(
sizeof|sizeof
argument_list|(
name|DDXPointRec
argument_list|)
operator|*
name|nbox
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pptNew1
condition|)
block|{
name|DEALLOCATE_LOCAL
argument_list|(
name|pboxNew1
argument_list|)
expr_stmt|;
return|return;
block|}
name|pboxBase
operator|=
name|pboxNext
operator|=
name|pbox
operator|+
name|nbox
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|pboxBase
operator|>=
name|pbox
condition|)
block|{
while|while
condition|(
operator|(
name|pboxNext
operator|>=
name|pbox
operator|)
operator|&&
operator|(
name|pboxBase
operator|->
name|y1
operator|==
name|pboxNext
operator|->
name|y1
operator|)
condition|)
name|pboxNext
operator|--
expr_stmt|;
name|pboxTmp
operator|=
name|pboxNext
operator|+
literal|1
expr_stmt|;
name|pptTmp
operator|=
name|pptSrc
operator|+
operator|(
name|pboxTmp
operator|-
name|pbox
operator|)
expr_stmt|;
while|while
condition|(
name|pboxTmp
operator|<=
name|pboxBase
condition|)
block|{
operator|*
name|pboxNew1
operator|++
operator|=
operator|*
name|pboxTmp
operator|++
expr_stmt|;
operator|*
name|pptNew1
operator|++
operator|=
operator|*
name|pptTmp
operator|++
expr_stmt|;
block|}
name|pboxBase
operator|=
name|pboxNext
expr_stmt|;
block|}
name|pboxNew1
operator|-=
name|nbox
expr_stmt|;
name|pbox
operator|=
name|pboxNew1
expr_stmt|;
name|pptNew1
operator|-=
name|nbox
expr_stmt|;
name|pptSrc
operator|=
name|pptNew1
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* walk source top to bottom */
name|ydir
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|careful
operator|&&
operator|(
name|pptSrc
operator|->
name|x
operator|<
name|pbox
operator|->
name|x1
operator|)
condition|)
block|{
comment|/* walk source right to left */
name|xdir
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|nbox
operator|>
literal|1
condition|)
block|{
comment|/* reverse order of rects in each band */
name|pboxNew2
operator|=
operator|(
name|BoxPtr
operator|)
name|ALLOCATE_LOCAL
argument_list|(
sizeof|sizeof
argument_list|(
name|BoxRec
argument_list|)
operator|*
name|nbox
argument_list|)
expr_stmt|;
name|pptNew2
operator|=
operator|(
name|DDXPointPtr
operator|)
name|ALLOCATE_LOCAL
argument_list|(
sizeof|sizeof
argument_list|(
name|DDXPointRec
argument_list|)
operator|*
name|nbox
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pboxNew2
operator|||
operator|!
name|pptNew2
condition|)
block|{
if|if
condition|(
name|pptNew2
condition|)
name|DEALLOCATE_LOCAL
argument_list|(
name|pptNew2
argument_list|)
expr_stmt|;
if|if
condition|(
name|pboxNew2
condition|)
name|DEALLOCATE_LOCAL
argument_list|(
name|pboxNew2
argument_list|)
expr_stmt|;
if|if
condition|(
name|pboxNew1
condition|)
block|{
name|DEALLOCATE_LOCAL
argument_list|(
name|pptNew1
argument_list|)
expr_stmt|;
name|DEALLOCATE_LOCAL
argument_list|(
name|pboxNew1
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
name|pboxBase
operator|=
name|pboxNext
operator|=
name|pbox
expr_stmt|;
while|while
condition|(
name|pboxBase
operator|<
name|pbox
operator|+
name|nbox
condition|)
block|{
while|while
condition|(
operator|(
name|pboxNext
operator|<
name|pbox
operator|+
name|nbox
operator|)
operator|&&
operator|(
name|pboxNext
operator|->
name|y1
operator|==
name|pboxBase
operator|->
name|y1
operator|)
condition|)
name|pboxNext
operator|++
expr_stmt|;
name|pboxTmp
operator|=
name|pboxNext
expr_stmt|;
name|pptTmp
operator|=
name|pptSrc
operator|+
operator|(
name|pboxTmp
operator|-
name|pbox
operator|)
expr_stmt|;
while|while
condition|(
name|pboxTmp
operator|!=
name|pboxBase
condition|)
block|{
operator|*
name|pboxNew2
operator|++
operator|=
operator|*
operator|--
name|pboxTmp
expr_stmt|;
operator|*
name|pptNew2
operator|++
operator|=
operator|*
operator|--
name|pptTmp
expr_stmt|;
block|}
name|pboxBase
operator|=
name|pboxNext
expr_stmt|;
block|}
name|pboxNew2
operator|-=
name|nbox
expr_stmt|;
name|pbox
operator|=
name|pboxNew2
expr_stmt|;
name|pptNew2
operator|-=
name|nbox
expr_stmt|;
name|pptSrc
operator|=
name|pptNew2
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* walk source left to right */
name|xdir
operator|=
literal|1
expr_stmt|;
block|}
name|WAIT_READY_TO_RENDER
argument_list|(
name|pSrc
operator|->
name|pScreen
argument_list|)
expr_stmt|;
name|SET_REGISTERS_FOR_WRITING
argument_list|(
name|pDst
operator|->
name|pScreen
argument_list|,
operator|~
literal|0
argument_list|,
name|GXcopy
argument_list|)
expr_stmt|;
while|while
condition|(
name|nbox
operator|--
condition|)
block|{
name|w
operator|=
name|pbox
operator|->
name|x2
operator|-
name|pbox
operator|->
name|x1
expr_stmt|;
name|h
operator|=
name|pbox
operator|->
name|y2
operator|-
name|pbox
operator|->
name|y1
expr_stmt|;
if|if
condition|(
name|ydir
operator|==
operator|-
literal|1
condition|)
comment|/* start at last scanline of rectangle */
block|{
name|psrcLine
operator|=
name|psrcBase
operator|+
operator|(
operator|(
name|pptSrc
operator|->
name|y
operator|+
name|h
operator|-
literal|1
operator|)
operator|*
operator|-
name|widthSrc
operator|)
expr_stmt|;
name|pdstLine
operator|=
name|pdstBase
operator|+
operator|(
operator|(
name|pbox
operator|->
name|y2
operator|-
literal|1
operator|)
operator|*
operator|-
name|widthDst
operator|)
expr_stmt|;
block|}
else|else
comment|/* start at first scanline */
block|{
name|psrcLine
operator|=
name|psrcBase
operator|+
operator|(
name|pptSrc
operator|->
name|y
operator|*
name|widthSrc
operator|)
expr_stmt|;
name|pdstLine
operator|=
name|pdstBase
operator|+
operator|(
name|pbox
operator|->
name|y1
operator|*
name|widthDst
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|pbox
operator|->
name|x1
operator|&
name|PIM
operator|)
operator|+
name|w
operator|<=
name|PPW
condition|)
block|{
name|maskpartialbits
argument_list|(
name|pbox
operator|->
name|x1
argument_list|,
name|w
argument_list|,
name|startmask
argument_list|)
expr_stmt|;
name|endmask
operator|=
literal|0
expr_stmt|;
name|nlMiddle
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|maskbits
argument_list|(
name|pbox
operator|->
name|x1
argument_list|,
name|w
argument_list|,
name|startmask
argument_list|,
name|endmask
argument_list|,
name|nlMiddle
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|xdir
operator|==
literal|1
condition|)
block|{
name|xoffSrc
operator|=
name|pptSrc
operator|->
name|x
operator|&
name|PIM
expr_stmt|;
name|xoffDst
operator|=
name|pbox
operator|->
name|x1
operator|&
name|PIM
expr_stmt|;
name|pdstLine
operator|+=
operator|(
name|pbox
operator|->
name|x1
operator|>>
name|PWSH
operator|)
expr_stmt|;
name|psrcLine
operator|+=
operator|(
name|pptSrc
operator|->
name|x
operator|>>
name|PWSH
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DO_UNALIGNED_BITBLT
name|nl
operator|=
name|xoffSrc
operator|-
name|xoffDst
expr_stmt|;
name|psrcLine
operator|=
operator|(
name|unsigned
name|long
operator|*
operator|)
operator|(
operator|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|psrcLine
operator|)
operator|+
name|nl
operator|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|xoffSrc
operator|==
name|xoffDst
condition|)
endif|#
directive|endif
block|{
while|while
condition|(
name|h
operator|--
condition|)
block|{
name|psrc
operator|=
name|psrcLine
expr_stmt|;
name|pdst
operator|=
name|pdstLine
expr_stmt|;
name|pdstLine
operator|+=
name|widthDst
expr_stmt|;
name|psrcLine
operator|+=
name|widthSrc
expr_stmt|;
if|if
condition|(
name|startmask
condition|)
block|{
operator|*
name|pdst
operator|=
name|MROP_MASK
argument_list|(
operator|*
name|psrc
argument_list|,
operator|*
name|pdst
argument_list|,
name|startmask
argument_list|)
expr_stmt|;
name|psrc
operator|++
expr_stmt|;
name|pdst
operator|++
expr_stmt|;
block|}
name|nl
operator|=
name|nlMiddle
expr_stmt|;
ifdef|#
directive|ifdef
name|LARGE_INSTRUCTION_CACHE
ifdef|#
directive|ifdef
name|FAST_CONSTANT_OFFSET_MODE
name|psrc
operator|+=
name|nl
operator|&
operator|(
name|UNROLL
operator|-
literal|1
operator|)
expr_stmt|;
name|pdst
operator|+=
name|nl
operator|&
operator|(
name|UNROLL
operator|-
literal|1
operator|)
expr_stmt|;
define|#
directive|define
name|BodyOdd
parameter_list|(
name|n
parameter_list|)
value|pdst[-n] = MROP_SOLID (psrc[-n], pdst[-n]);
define|#
directive|define
name|BodyEven
parameter_list|(
name|n
parameter_list|)
value|pdst[-n] = MROP_SOLID (psrc[-n], pdst[-n]);
define|#
directive|define
name|LoopReset
define|\
value|pdst += UNROLL; \ psrc += UNROLL;
else|#
directive|else
define|#
directive|define
name|BodyOdd
parameter_list|(
name|n
parameter_list|)
value|*pdst = MROP_SOLID (*psrc, *pdst); pdst++; psrc++;
define|#
directive|define
name|BodyEven
parameter_list|(
name|n
parameter_list|)
value|BodyOdd(n)
define|#
directive|define
name|LoopReset
value|;
endif|#
directive|endif
name|PackedLoop
undef|#
directive|undef
name|BodyOdd
undef|#
directive|undef
name|BodyEven
undef|#
directive|undef
name|LoopReset
else|#
directive|else
ifdef|#
directive|ifdef
name|NOTDEF
comment|/* you'd think this would be faster -- 		     * a single instruction instead of 6 		     * but measurements show it to be ~15% slower 		     */
while|while
condition|(
operator|(
name|nl
operator|-=
literal|6
operator|)
operator|>=
literal|0
condition|)
block|{
asm|asm ("moveml %1+,#0x0c0f;moveml#0x0c0f,%0" 			     : "=m" (*(char *)pdst) 			     : "m" (*(char *)psrc) 			     : "d0", "d1", "d2", "d3", 			       "a2", "a3");
name|pdst
operator|+=
literal|6
expr_stmt|;
block|}
name|nl
operator|+=
literal|6
expr_stmt|;
while|while
condition|(
name|nl
operator|--
condition|)
operator|*
name|pdst
operator|++
operator|=
operator|*
name|psrc
operator|++
expr_stmt|;
endif|#
directive|endif
name|DuffL
argument_list|(
argument|nl
argument_list|,
argument|label1
argument_list|,
argument|*pdst = MROP_SOLID (*psrc, *pdst); 			    pdst++; psrc++;
argument_list|)
endif|#
directive|endif
if|if
condition|(
name|endmask
condition|)
operator|*
name|pdst
operator|=
name|MROP_MASK
argument_list|(
operator|*
name|psrc
argument_list|,
operator|*
name|pdst
argument_list|,
name|endmask
argument_list|)
expr_stmt|;
block|}
block|}
ifndef|#
directive|ifndef
name|DO_UNALIGNED_BITBLT
else|else
block|{
if|if
condition|(
name|xoffSrc
operator|>
name|xoffDst
condition|)
block|{
name|leftShift
operator|=
operator|(
name|xoffSrc
operator|-
name|xoffDst
operator|)
operator|<<
operator|(
literal|5
operator|-
name|PWSH
operator|)
expr_stmt|;
name|rightShift
operator|=
literal|32
operator|-
name|leftShift
expr_stmt|;
block|}
else|else
block|{
name|rightShift
operator|=
operator|(
name|xoffDst
operator|-
name|xoffSrc
operator|)
operator|<<
operator|(
literal|5
operator|-
name|PWSH
operator|)
expr_stmt|;
name|leftShift
operator|=
literal|32
operator|-
name|rightShift
expr_stmt|;
block|}
while|while
condition|(
name|h
operator|--
condition|)
block|{
name|psrc
operator|=
name|psrcLine
expr_stmt|;
name|pdst
operator|=
name|pdstLine
expr_stmt|;
name|pdstLine
operator|+=
name|widthDst
expr_stmt|;
name|psrcLine
operator|+=
name|widthSrc
expr_stmt|;
name|bits
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|xoffSrc
operator|>
name|xoffDst
condition|)
name|bits
operator|=
operator|*
name|psrc
operator|++
expr_stmt|;
if|if
condition|(
name|startmask
condition|)
block|{
name|bits1
operator|=
name|BitLeft
argument_list|(
name|bits
argument_list|,
name|leftShift
argument_list|)
expr_stmt|;
name|bits
operator|=
operator|*
name|psrc
operator|++
expr_stmt|;
name|bits1
operator||=
name|BitRight
argument_list|(
name|bits
argument_list|,
name|rightShift
argument_list|)
expr_stmt|;
operator|*
name|pdst
operator|=
name|MROP_MASK
argument_list|(
name|bits1
argument_list|,
operator|*
name|pdst
argument_list|,
name|startmask
argument_list|)
expr_stmt|;
name|pdst
operator|++
expr_stmt|;
block|}
name|nl
operator|=
name|nlMiddle
expr_stmt|;
ifdef|#
directive|ifdef
name|LARGE_INSTRUCTION_CACHE
name|bits1
operator|=
name|bits
expr_stmt|;
ifdef|#
directive|ifdef
name|FAST_CONSTANT_OFFSET_MODE
name|psrc
operator|+=
name|nl
operator|&
operator|(
name|UNROLL
operator|-
literal|1
operator|)
expr_stmt|;
name|pdst
operator|+=
name|nl
operator|&
operator|(
name|UNROLL
operator|-
literal|1
operator|)
expr_stmt|;
define|#
directive|define
name|BodyOdd
parameter_list|(
name|n
parameter_list|)
define|\
value|bits = psrc[-n]; \ pdst[-n] = MROP_SOLID(BitLeft(bits1, leftShift) | BitRight(bits, rightShift), pdst[-n]);
define|#
directive|define
name|BodyEven
parameter_list|(
name|n
parameter_list|)
define|\
value|bits1 = psrc[-n]; \ pdst[-n] = MROP_SOLID(BitLeft(bits, leftShift) | BitRight(bits1, rightShift), pdst[-n]);
define|#
directive|define
name|LoopReset
define|\
value|pdst += UNROLL; \ psrc += UNROLL;
else|#
directive|else
define|#
directive|define
name|BodyOdd
parameter_list|(
name|n
parameter_list|)
define|\
value|bits = *psrc++; \ *pdst = MROP_SOLID(BitLeft(bits1, leftShift) | BitRight(bits, rightShift), *pdst); \ pdst++;
define|#
directive|define
name|BodyEven
parameter_list|(
name|n
parameter_list|)
define|\
value|bits1 = *psrc++; \ *pdst = MROP_SOLID(BitLeft(bits, leftShift) | BitRight(bits1, rightShift), *pdst); \ pdst++;
define|#
directive|define
name|LoopReset
value|;
endif|#
directive|endif
comment|/* !FAST_CONSTANT_OFFSET_MODE */
name|PackedLoop
undef|#
directive|undef
name|BodyOdd
undef|#
directive|undef
name|BodyEven
undef|#
directive|undef
name|LoopReset
else|#
directive|else
name|DuffL
argument_list|(
name|nl
argument_list|,
name|label2
argument_list|,
name|bits1
operator|=
name|BitLeft
argument_list|(
name|bits
argument_list|,
name|leftShift
argument_list|)
argument_list|;
name|bits
operator|=
operator|*
name|psrc
operator|++
expr_stmt|;
operator|*
name|pdst
operator|=
name|MROP_SOLID
argument_list|(
name|bits1
operator||
name|BitRight
argument_list|(
name|bits
argument_list|,
name|rightShift
argument_list|)
argument_list|,
operator|*
name|pdst
argument_list|)
expr_stmt|;
name|pdst
operator|++
expr_stmt|;
block|)
endif|#
directive|endif
if|if
condition|(
name|endmask
condition|)
block|{
name|bits1
operator|=
name|BitLeft
argument_list|(
name|bits
argument_list|,
name|leftShift
argument_list|)
expr_stmt|;
if|if
condition|(
name|BitLeft
argument_list|(
name|endmask
argument_list|,
name|rightShift
argument_list|)
condition|)
block|{
name|bits
operator|=
operator|*
name|psrc
expr_stmt|;
name|bits1
operator||=
name|BitRight
argument_list|(
name|bits
argument_list|,
name|rightShift
argument_list|)
expr_stmt|;
block|}
operator|*
name|pdst
operator|=
name|MROP_MASK
argument_list|(
name|bits1
argument_list|,
operator|*
name|pdst
argument_list|,
name|endmask
argument_list|)
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
comment|/* DO_UNALIGNED_BITBLT */
block|}
else|else
comment|/* xdir == -1 */
block|{
name|xoffSrc
operator|=
operator|(
name|pptSrc
operator|->
name|x
operator|+
name|w
operator|-
literal|1
operator|)
operator|&
name|PIM
expr_stmt|;
name|xoffDst
operator|=
operator|(
name|pbox
operator|->
name|x2
operator|-
literal|1
operator|)
operator|&
name|PIM
expr_stmt|;
name|pdstLine
operator|+=
operator|(
operator|(
name|pbox
operator|->
name|x2
operator|-
literal|1
operator|)
operator|>>
name|PWSH
operator|)
operator|+
literal|1
expr_stmt|;
name|psrcLine
operator|+=
operator|(
operator|(
name|pptSrc
operator|->
name|x
operator|+
name|w
operator|-
literal|1
operator|)
operator|>>
name|PWSH
operator|)
operator|+
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|DO_UNALIGNED_BITBLT
name|nl
operator|=
name|xoffSrc
operator|-
name|xoffDst
expr_stmt|;
name|psrcLine
operator|=
operator|(
name|unsigned
name|long
operator|*
operator|)
operator|(
operator|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|psrcLine
operator|)
operator|+
name|nl
operator|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|xoffSrc
operator|==
name|xoffDst
condition|)
endif|#
directive|endif
block|{
while|while
condition|(
name|h
operator|--
condition|)
block|{
name|psrc
operator|=
name|psrcLine
expr_stmt|;
name|pdst
operator|=
name|pdstLine
expr_stmt|;
name|pdstLine
operator|+=
name|widthDst
expr_stmt|;
name|psrcLine
operator|+=
name|widthSrc
expr_stmt|;
if|if
condition|(
name|endmask
condition|)
block|{
name|pdst
operator|--
expr_stmt|;
name|psrc
operator|--
expr_stmt|;
operator|*
name|pdst
operator|=
name|MROP_MASK
argument_list|(
operator|*
name|psrc
argument_list|,
operator|*
name|pdst
argument_list|,
name|endmask
argument_list|)
expr_stmt|;
block|}
name|nl
operator|=
name|nlMiddle
expr_stmt|;
ifdef|#
directive|ifdef
name|LARGE_INSTRUCTION_CACHE
ifdef|#
directive|ifdef
name|FAST_CONSTANT_OFFSET_MODE
name|psrc
operator|-=
name|nl
operator|&
operator|(
name|UNROLL
operator|-
literal|1
operator|)
expr_stmt|;
name|pdst
operator|-=
name|nl
operator|&
operator|(
name|UNROLL
operator|-
literal|1
operator|)
expr_stmt|;
define|#
directive|define
name|BodyOdd
parameter_list|(
name|n
parameter_list|)
value|pdst[n-1] = MROP_SOLID (psrc[n-1], pdst[n-1]);
define|#
directive|define
name|BodyEven
parameter_list|(
name|n
parameter_list|)
value|BodyOdd(n)
define|#
directive|define
name|LoopReset
define|\
value|pdst -= UNROLL;\ psrc -= UNROLL;
else|#
directive|else
define|#
directive|define
name|BodyOdd
parameter_list|(
name|n
parameter_list|)
value|--pdst; --psrc; *pdst = MROP_SOLID(*psrc, *pdst);
define|#
directive|define
name|BodyEven
parameter_list|(
name|n
parameter_list|)
value|BodyOdd(n)
define|#
directive|define
name|LoopReset
value|;
endif|#
directive|endif
name|PackedLoop
undef|#
directive|undef
name|BodyOdd
undef|#
directive|undef
name|BodyEven
undef|#
directive|undef
name|LoopReset
else|#
directive|else
name|DuffL
argument_list|(
name|nl
argument_list|,
name|label3
argument_list|,
operator|--
name|pdst
argument_list|;
operator|--
name|psrc
expr_stmt|;
operator|*
name|pdst
operator|=
name|MROP_SOLID
argument_list|(
operator|*
name|psrc
argument_list|,
operator|*
name|pdst
argument_list|)
expr_stmt|;
block|)
endif|#
directive|endif
if|if
condition|(
name|startmask
condition|)
block|{
operator|--
name|pdst
expr_stmt|;
operator|--
name|psrc
expr_stmt|;
operator|*
name|pdst
operator|=
name|MROP_MASK
argument_list|(
operator|*
name|psrc
argument_list|,
operator|*
name|pdst
argument_list|,
name|startmask
argument_list|)
expr_stmt|;
block|}
block|}
block|}
ifndef|#
directive|ifndef
name|DO_UNALIGNED_BITBLT
else|else
block|{
if|if
condition|(
name|xoffDst
operator|>
name|xoffSrc
condition|)
block|{
name|rightShift
operator|=
operator|(
name|xoffDst
operator|-
name|xoffSrc
operator|)
operator|<<
operator|(
literal|5
operator|-
name|PWSH
operator|)
expr_stmt|;
name|leftShift
operator|=
literal|32
operator|-
name|rightShift
expr_stmt|;
block|}
else|else
block|{
name|leftShift
operator|=
operator|(
name|xoffSrc
operator|-
name|xoffDst
operator|)
operator|<<
operator|(
literal|5
operator|-
name|PWSH
operator|)
expr_stmt|;
name|rightShift
operator|=
literal|32
operator|-
name|leftShift
expr_stmt|;
block|}
while|while
condition|(
name|h
operator|--
condition|)
block|{
name|psrc
operator|=
name|psrcLine
expr_stmt|;
name|pdst
operator|=
name|pdstLine
expr_stmt|;
name|pdstLine
operator|+=
name|widthDst
expr_stmt|;
name|psrcLine
operator|+=
name|widthSrc
expr_stmt|;
name|bits
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|xoffDst
operator|>
name|xoffSrc
condition|)
name|bits
operator|=
operator|*
operator|--
name|psrc
expr_stmt|;
if|if
condition|(
name|endmask
condition|)
block|{
name|bits1
operator|=
name|BitRight
argument_list|(
name|bits
argument_list|,
name|rightShift
argument_list|)
expr_stmt|;
name|bits
operator|=
operator|*
operator|--
name|psrc
expr_stmt|;
name|bits1
operator||=
name|BitLeft
argument_list|(
name|bits
argument_list|,
name|leftShift
argument_list|)
expr_stmt|;
name|pdst
operator|--
expr_stmt|;
operator|*
name|pdst
operator|=
name|MROP_MASK
argument_list|(
name|bits1
argument_list|,
operator|*
name|pdst
argument_list|,
name|endmask
argument_list|)
expr_stmt|;
block|}
name|nl
operator|=
name|nlMiddle
expr_stmt|;
ifdef|#
directive|ifdef
name|LARGE_INSTRUCTION_CACHE
name|bits1
operator|=
name|bits
expr_stmt|;
ifdef|#
directive|ifdef
name|FAST_CONSTANT_OFFSET_MODE
name|psrc
operator|-=
name|nl
operator|&
operator|(
name|UNROLL
operator|-
literal|1
operator|)
expr_stmt|;
name|pdst
operator|-=
name|nl
operator|&
operator|(
name|UNROLL
operator|-
literal|1
operator|)
expr_stmt|;
define|#
directive|define
name|BodyOdd
parameter_list|(
name|n
parameter_list|)
define|\
value|bits = psrc[n-1]; \ pdst[n-1] = MROP_SOLID(BitRight(bits1, rightShift) | BitLeft(bits, leftShift),pdst[n-1]);
define|#
directive|define
name|BodyEven
parameter_list|(
name|n
parameter_list|)
define|\
value|bits1 = psrc[n-1]; \ pdst[n-1] = MROP_SOLID(BitRight(bits, rightShift) | BitLeft(bits1, leftShift),pdst[n-1]);
define|#
directive|define
name|LoopReset
define|\
value|pdst -= UNROLL; \ psrc -= UNROLL;
else|#
directive|else
define|#
directive|define
name|BodyOdd
parameter_list|(
name|n
parameter_list|)
define|\
value|bits = *--psrc; --pdst; \ *pdst = MROP_SOLID(BitRight(bits1, rightShift) | BitLeft(bits, leftShift),*pdst);
define|#
directive|define
name|BodyEven
parameter_list|(
name|n
parameter_list|)
define|\
value|bits1 = *--psrc; --pdst; \ *pdst = MROP_SOLID(BitRight(bits, rightShift) | BitLeft(bits1, leftShift),*pdst);
define|#
directive|define
name|LoopReset
value|;
endif|#
directive|endif
name|PackedLoop
undef|#
directive|undef
name|BodyOdd
undef|#
directive|undef
name|BodyEven
undef|#
directive|undef
name|LoopReset
else|#
directive|else
name|DuffL
argument_list|(
name|nl
argument_list|,
name|label4
argument_list|,
name|bits1
operator|=
name|BitRight
argument_list|(
name|bits
argument_list|,
name|rightShift
argument_list|)
argument_list|;
name|bits
operator|=
operator|*
operator|--
name|psrc
argument_list|;
operator|--
name|pdst
argument_list|;
operator|*
name|pdst
operator|=
name|MROP_SOLID
argument_list|(
name|bits1
operator||
name|BitLeft
argument_list|(
name|bits
argument_list|,
name|leftShift
argument_list|)
argument_list|,
operator|*
name|pdst
argument_list|)
argument_list|; 		    )
endif|#
directive|endif
decl|if
argument_list|(
name|startmask
argument_list|)
block|{
name|bits1
operator|=
name|BitRight
argument_list|(
name|bits
argument_list|,
name|rightShift
argument_list|)
expr_stmt|;
if|if
condition|(
name|BitRight
argument_list|(
name|startmask
argument_list|,
name|leftShift
argument_list|)
condition|)
block|{
name|bits
operator|=
operator|*
operator|--
name|psrc
expr_stmt|;
name|bits1
operator||=
name|BitLeft
argument_list|(
name|bits
argument_list|,
name|leftShift
argument_list|)
expr_stmt|;
block|}
operator|--
name|pdst
expr_stmt|;
operator|*
name|pdst
operator|=
name|MROP_MASK
argument_list|(
name|bits1
argument_list|,
operator|*
name|pdst
argument_list|,
name|startmask
argument_list|)
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
block|}
end_function

begin_expr_stmt
name|pbox
operator|++
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|pptSrc
operator|++
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|}     if
operator|(
name|pboxNew2
operator|)
block|{
name|DEALLOCATE_LOCAL
argument_list|(
name|pptNew2
argument_list|)
block|;
name|DEALLOCATE_LOCAL
argument_list|(
name|pboxNew2
argument_list|)
block|;     }
end_expr_stmt

begin_if
if|if
condition|(
name|pboxNew1
condition|)
block|{
name|DEALLOCATE_LOCAL
argument_list|(
name|pptNew1
argument_list|)
expr_stmt|;
name|DEALLOCATE_LOCAL
argument_list|(
name|pboxNew1
argument_list|)
expr_stmt|;
block|}
end_if

unit|}
end_unit

