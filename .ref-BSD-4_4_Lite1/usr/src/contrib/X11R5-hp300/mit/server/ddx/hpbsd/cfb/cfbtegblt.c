begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $XConsortium: cfbtegblt.c,v 5.4 91/05/04 11:52:53 keith Exp $ */
end_comment

begin_comment
comment|/*********************************************************** Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts, and the Massachusetts Institute of Technology, Cambridge, Massachusetts.                          All Rights Reserved  Permission to use, copy, modify, and distribute this software and its  documentation for any purpose and without fee is hereby granted,  provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in  supporting documentation, and that the names of Digital or MIT not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.    DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  ******************************************************************/
end_comment

begin_include
include|#
directive|include
file|"X.h"
end_include

begin_include
include|#
directive|include
file|"Xmd.h"
end_include

begin_include
include|#
directive|include
file|"Xproto.h"
end_include

begin_include
include|#
directive|include
file|"cfb.h"
end_include

begin_include
include|#
directive|include
file|"fontstruct.h"
end_include

begin_include
include|#
directive|include
file|"dixfontstr.h"
end_include

begin_include
include|#
directive|include
file|"gcstruct.h"
end_include

begin_include
include|#
directive|include
file|"windowstr.h"
end_include

begin_include
include|#
directive|include
file|"scrnintstr.h"
end_include

begin_include
include|#
directive|include
file|"pixmapstr.h"
end_include

begin_include
include|#
directive|include
file|"regionstr.h"
end_include

begin_include
include|#
directive|include
file|"cfbmskbits.h"
end_include

begin_function_decl
specifier|extern
name|void
name|miImageGlyphBlt
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*     this works for fonts with glyphs<= 32 bits wide, on an     arbitrarily deep display.  Use cfbTEGlyphBlt8 for 8 bit displays.      This should be called only with a terminal-emulator font; this means that the FIXED_METRICS flag is set, and that glyphbounds == charbounds.      in theory, this goes faster; even if it doesn't, it reduces the flicker caused by writing a string over itself with image text (since the background gets repainted per character instead of per string.) this seems to be important for some converted X10 applications.      Image text looks at the bits in the glyph and the fg and bg in the GC.  it paints a rectangle, as defined in the protocol dcoument, and the paints the characters.  */
end_comment

begin_function
name|void
name|cfbTEGlyphBlt
parameter_list|(
name|pDrawable
parameter_list|,
name|pGC
parameter_list|,
name|x
parameter_list|,
name|y
parameter_list|,
name|nglyph
parameter_list|,
name|ppci
parameter_list|,
name|pglyphBase
parameter_list|)
name|DrawablePtr
name|pDrawable
decl_stmt|;
name|GC
modifier|*
name|pGC
decl_stmt|;
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
name|unsigned
name|int
name|nglyph
decl_stmt|;
name|CharInfoPtr
modifier|*
name|ppci
decl_stmt|;
comment|/* array of character info */
name|unsigned
name|char
modifier|*
name|pglyphBase
decl_stmt|;
comment|/* start of array of glyphs */
block|{
name|FontPtr
name|pfont
init|=
name|pGC
operator|->
name|font
decl_stmt|;
name|int
name|widthDst
decl_stmt|;
name|unsigned
name|long
modifier|*
name|pdstBase
decl_stmt|;
comment|/* pointer to longword with top row  				   of current glyph */
name|int
name|w
decl_stmt|;
comment|/* width of glyph and char */
name|int
name|h
decl_stmt|;
comment|/* height of glyph and char */
specifier|register
name|int
name|xpos
init|=
name|x
decl_stmt|;
comment|/* current x%32  */
name|int
name|ypos
init|=
name|y
decl_stmt|;
comment|/* current y%32 */
specifier|register
name|unsigned
name|char
modifier|*
name|pglyph
decl_stmt|;
name|int
name|widthGlyph
decl_stmt|;
specifier|register
name|unsigned
name|long
modifier|*
name|pdst
decl_stmt|;
comment|/* pointer to current longword in dst */
name|int
name|hTmp
decl_stmt|;
comment|/* counter for height */
name|BoxRec
name|bbox
decl_stmt|;
comment|/* for clipping */
specifier|register
name|int
name|wtmp
decl_stmt|,
name|xtemp
decl_stmt|,
name|width
decl_stmt|;
name|unsigned
name|long
name|bgfill
decl_stmt|,
name|fgfill
decl_stmt|,
modifier|*
name|ptemp
decl_stmt|,
name|tmpDst1
decl_stmt|,
name|tmpDst2
decl_stmt|,
modifier|*
name|pdtmp
decl_stmt|;
name|int
name|tmpx
decl_stmt|;
name|xpos
operator|+=
name|pDrawable
operator|->
name|x
expr_stmt|;
name|ypos
operator|+=
name|pDrawable
operator|->
name|y
expr_stmt|;
name|cfbGetLongWidthAndPointer
argument_list|(
argument|pDrawable
argument_list|,
argument|widthDst
argument_list|,
argument|pdstBase
argument_list|)
name|SET_REGISTERS_FOR_WRITING
argument_list|(
name|pDrawable
operator|->
name|pScreen
argument_list|,
operator|~
literal|0
argument_list|,
name|GXcopy
argument_list|)
expr_stmt|;
name|wtmp
operator|=
name|FONTMAXBOUNDS
argument_list|(
name|pfont
argument_list|,
name|characterWidth
argument_list|)
expr_stmt|;
name|h
operator|=
name|FONTASCENT
argument_list|(
name|pfont
argument_list|)
operator|+
name|FONTDESCENT
argument_list|(
name|pfont
argument_list|)
expr_stmt|;
name|widthGlyph
operator|=
name|GLYPHWIDTHBYTESPADDED
argument_list|(
operator|*
name|ppci
argument_list|)
expr_stmt|;
name|xpos
operator|+=
name|FONTMAXBOUNDS
argument_list|(
name|pfont
argument_list|,
name|leftSideBearing
argument_list|)
expr_stmt|;
name|ypos
operator|-=
name|FONTASCENT
argument_list|(
name|pfont
argument_list|)
expr_stmt|;
name|bbox
operator|.
name|x1
operator|=
name|xpos
expr_stmt|;
name|bbox
operator|.
name|x2
operator|=
name|xpos
operator|+
operator|(
name|wtmp
operator|*
name|nglyph
operator|)
expr_stmt|;
name|bbox
operator|.
name|y1
operator|=
name|ypos
expr_stmt|;
name|bbox
operator|.
name|y2
operator|=
name|ypos
operator|+
name|h
expr_stmt|;
name|fgfill
operator|=
name|PFILL
argument_list|(
name|pGC
operator|->
name|fgPixel
argument_list|)
expr_stmt|;
name|bgfill
operator|=
name|PFILL
argument_list|(
name|pGC
operator|->
name|bgPixel
argument_list|)
expr_stmt|;
switch|switch
condition|(
call|(
modifier|*
name|pGC
operator|->
name|pScreen
operator|->
name|RectIn
call|)
argument_list|(
operator|(
operator|(
name|cfbPrivGC
operator|*
operator|)
operator|(
name|pGC
operator|->
name|devPrivates
index|[
name|cfbGCPrivateIndex
index|]
operator|.
name|ptr
operator|)
operator|)
operator|->
name|pCompositeClip
argument_list|,
operator|&
name|bbox
argument_list|)
condition|)
block|{
case|case
name|rgnOUT
case|:
break|break;
case|case
name|rgnPART
case|:
comment|/* this is the WRONG thing to do, but it works. 	   calling the non-terminal text is easy, but slow, given 	   what we know about the font.  	   the right thing to do is something like: 	    for each clip rectangle 		compute at which row the glyph starts to be in it, 		   and at which row the glyph ceases to be in it 		compute which is the first glyph inside the left 		    edge, and the last one inside the right edge 		draw a fractional first glyph, using only 		    the rows we know are in 		draw all the whole glyphs, using the appropriate rows 		draw any pieces of the last glyph, using the right rows  	   this way, the code would take advantage of knowing that 	   all glyphs are the same height and don't overlap.  	   one day... 	*/
name|miImageGlyphBlt
argument_list|(
name|pDrawable
argument_list|,
name|pGC
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|nglyph
argument_list|,
name|ppci
argument_list|,
name|pglyphBase
argument_list|)
expr_stmt|;
break|break;
case|case
name|rgnIN
case|:
name|pdtmp
operator|=
name|pdstBase
operator|+
operator|(
name|widthDst
operator|*
name|ypos
operator|)
expr_stmt|;
while|while
condition|(
name|nglyph
operator|--
condition|)
block|{
name|pglyph
operator|=
name|FONTGLYPHBITS
argument_list|(
name|pglyphBase
argument_list|,
operator|*
name|ppci
operator|++
argument_list|)
expr_stmt|;
name|pdst
operator|=
name|pdtmp
expr_stmt|;
name|hTmp
operator|=
name|h
expr_stmt|;
while|while
condition|(
name|hTmp
operator|--
condition|)
block|{
name|x
operator|=
name|xpos
expr_stmt|;
name|width
operator|=
name|wtmp
expr_stmt|;
name|xtemp
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|width
operator|>
literal|0
condition|)
block|{
name|tmpx
operator|=
name|x
operator|&
name|PIM
expr_stmt|;
name|w
operator|=
name|min
argument_list|(
name|width
argument_list|,
name|PPW
operator|-
name|tmpx
argument_list|)
expr_stmt|;
name|w
operator|=
name|min
argument_list|(
name|w
argument_list|,
operator|(
literal|32
operator|-
name|xtemp
operator|)
argument_list|)
expr_stmt|;
name|ptemp
operator|=
operator|(
name|unsigned
name|long
operator|*
operator|)
operator|(
name|pglyph
operator|+
operator|(
name|xtemp
operator|>>
literal|5
operator|)
operator|)
expr_stmt|;
name|getstipplepixels
argument_list|(
name|ptemp
argument_list|,
name|xtemp
argument_list|,
name|w
argument_list|,
literal|0
argument_list|,
operator|&
name|bgfill
argument_list|,
operator|&
name|tmpDst1
argument_list|)
expr_stmt|;
name|getstipplepixels
argument_list|(
name|ptemp
argument_list|,
name|xtemp
argument_list|,
name|w
argument_list|,
literal|1
argument_list|,
operator|&
name|fgfill
argument_list|,
operator|&
name|tmpDst2
argument_list|)
expr_stmt|;
block|{
name|unsigned
name|long
name|tmpDst
init|=
name|tmpDst1
operator||
name|tmpDst2
decl_stmt|;
name|unsigned
name|long
modifier|*
name|pdsttmp
init|=
name|pdst
operator|+
operator|(
name|x
operator|>>
name|PWSH
operator|)
decl_stmt|;
name|putbits
argument_list|(
name|tmpDst
argument_list|,
name|tmpx
argument_list|,
name|w
argument_list|,
name|pdsttmp
argument_list|,
name|pGC
operator|->
name|planemask
argument_list|)
expr_stmt|;
block|}
name|x
operator|+=
name|w
expr_stmt|;
name|xtemp
operator|+=
name|w
expr_stmt|;
name|width
operator|-=
name|w
expr_stmt|;
block|}
name|pglyph
operator|+=
name|widthGlyph
expr_stmt|;
name|pdst
operator|+=
name|widthDst
expr_stmt|;
block|}
name|xpos
operator|+=
name|wtmp
expr_stmt|;
block|}
break|break;
block|}
block|}
end_function

end_unit

