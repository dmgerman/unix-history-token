begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Fill odd tiled rectangles and spans.  * no depth dependencies.  */
end_comment

begin_comment
comment|/* Copyright 1989 by the Massachusetts Institute of Technology  Permission to use, copy, modify, and distribute this software and its documentation for any purpose and without fee is hereby granted, provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in supporting documentation, and that the name of M.I.T. not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.  M.I.T. makes no representations about the suitability of this software for any purpose.  It is provided "as is" without express or implied warranty. */
end_comment

begin_comment
comment|/* $XConsortium: cfbtileodd.c,v 1.13 91/07/10 17:26:10 keith Exp $ */
end_comment

begin_include
include|#
directive|include
file|"X.h"
end_include

begin_include
include|#
directive|include
file|"Xmd.h"
end_include

begin_include
include|#
directive|include
file|"servermd.h"
end_include

begin_include
include|#
directive|include
file|"gcstruct.h"
end_include

begin_include
include|#
directive|include
file|"window.h"
end_include

begin_include
include|#
directive|include
file|"pixmapstr.h"
end_include

begin_include
include|#
directive|include
file|"scrnintstr.h"
end_include

begin_include
include|#
directive|include
file|"windowstr.h"
end_include

begin_include
include|#
directive|include
file|"cfb.h"
end_include

begin_include
include|#
directive|include
file|"cfbmskbits.h"
end_include

begin_include
include|#
directive|include
file|"cfb8bit.h"
end_include

begin_include
include|#
directive|include
file|"mergerop.h"
end_include

begin_define
define|#
directive|define
name|LastTileBits
value|{\     tmp = bits; \     if (tileEndPart) \ 	bits = (*pSrc& tileEndMask) | BitRight (*pSrcLine, tileEndLeftShift); \     else \ 	bits = *pSrc; \ }
end_define

begin_define
define|#
directive|define
name|ResetTileBits
value|{\     pSrc = pSrcLine; \     nlwSrc = widthSrc;\     if (tileEndPart) { \ 	if (PPW - xoff + tileEndPart<= PPW) {\ 	    bits = *pSrc++; \ 	    nlwSrc--; \ 	} else \ 	    bits = BitLeft(tmp, tileEndLeftShift) | \ 		   BitRight(bits, tileEndRightShift); \ 	xoff = (xoff + xoffStep)& PIM; \ 	leftShift = xoff<< (5-PWSH); \ 	rightShift = 32 - leftShift; \     }\ }
end_define

begin_define
define|#
directive|define
name|NextTileBits
value|{\     if (nlwSrc == 1) {\ 	LastTileBits\     } else { \     	if (nlwSrc == 0) {\ 	    ResetTileBits\     	} \ 	if (nlwSrc == 1) {\ 	    LastTileBits\ 	} else {\ 	    tmp = bits; \ 	    bits = *pSrc++; \ 	}\     }\     nlwSrc--; \ }
end_define

begin_function
name|void
name|MROP_NAME
function|(
name|cfbFillBoxTileOdd
function|)
parameter_list|(
name|pDrawable
parameter_list|,
name|nBox
parameter_list|,
name|pBox
parameter_list|,
name|tile
parameter_list|,
name|xrot
parameter_list|,
name|yrot
parameter_list|,
name|alu
parameter_list|,
name|planemask
parameter_list|)
name|DrawablePtr
name|pDrawable
decl_stmt|;
name|int
name|nBox
decl_stmt|;
comment|/* number of boxes to fill */
specifier|register
name|BoxPtr
name|pBox
decl_stmt|;
comment|/* pointer to list of boxes to fill */
name|PixmapPtr
name|tile
decl_stmt|;
comment|/* tile */
name|int
name|xrot
decl_stmt|,
name|yrot
decl_stmt|;
name|int
name|alu
decl_stmt|;
name|unsigned
name|long
name|planemask
decl_stmt|;
block|{
name|hpPrivPixmapPtr
name|tilePriv
decl_stmt|;
name|int
name|tileWidth
decl_stmt|;
comment|/* width of tile in pixels */
name|int
name|tileHeight
decl_stmt|;
comment|/* height of the tile */
name|int
name|widthSrc
decl_stmt|;
name|int
name|strideSrc
decl_stmt|;
name|int
name|widthDst
decl_stmt|;
comment|/* width in longwords of the dest pixmap */
name|int
name|w
decl_stmt|;
comment|/* width of current box */
name|int
name|h
decl_stmt|;
comment|/* height of current box */
name|unsigned
name|long
name|startmask
decl_stmt|;
name|unsigned
name|long
name|endmask
decl_stmt|;
comment|/* masks for reggedy bits at either end of line */
name|int
name|nlwMiddle
decl_stmt|;
comment|/* number of longwords between sides of boxes */
name|int
name|nlwSrc
decl_stmt|;
comment|/* number of whole longwords in source */
specifier|register
name|int
name|nlw
decl_stmt|;
comment|/* loop version of nlwMiddle */
name|int
name|srcy
decl_stmt|;
comment|/* current tile y position */
name|int
name|srcx
decl_stmt|;
comment|/* current tile x position */
name|int
name|xoffDst
decl_stmt|,
name|xoffSrc
decl_stmt|;
name|int
name|leftShift
decl_stmt|,
name|rightShift
decl_stmt|;
name|MROP_DECLARE_REG
argument_list|()
name|unsigned
name|long
modifier|*
name|pDstBase
decl_stmt|;
comment|/* pointer to start of dest */
name|unsigned
name|long
modifier|*
name|pDstLine
decl_stmt|;
comment|/* poitner to start of dest box */
name|unsigned
name|long
modifier|*
name|pSrcBase
decl_stmt|;
comment|/* pointer to start of source */
name|unsigned
name|long
modifier|*
name|pSrcLine
decl_stmt|;
comment|/* pointer to start of source line */
specifier|register
name|unsigned
name|long
modifier|*
name|pDst
decl_stmt|;
specifier|register
name|unsigned
name|long
modifier|*
name|pSrc
decl_stmt|;
specifier|register
name|unsigned
name|long
name|bits
decl_stmt|,
name|tmp
decl_stmt|;
specifier|register
name|int
name|nlwPart
decl_stmt|;
name|int
name|xoffStart
decl_stmt|,
name|xoff
decl_stmt|;
name|int
name|leftShiftStart
decl_stmt|,
name|rightShiftStart
decl_stmt|,
name|nlwSrcStart
decl_stmt|;
name|unsigned
name|long
name|tileEndMask
decl_stmt|;
name|int
name|tileEndLeftShift
decl_stmt|,
name|tileEndRightShift
decl_stmt|;
name|int
name|xoffStep
decl_stmt|;
name|int
name|tileEndPart
decl_stmt|;
name|int
name|needFirst
decl_stmt|;
name|unsigned
name|long
name|narrow
index|[
literal|2
index|]
decl_stmt|;
name|unsigned
name|long
name|narrowMask
decl_stmt|;
name|int
name|narrowShift
decl_stmt|;
name|Bool
name|narrowTile
decl_stmt|;
name|MROP_INITIALIZE
argument_list|(
argument|alu
argument_list|,
argument|planemask
argument_list|)
name|tileHeight
operator|=
name|tile
operator|->
name|drawable
operator|.
name|height
expr_stmt|;
name|tileWidth
operator|=
name|tile
operator|->
name|drawable
operator|.
name|width
expr_stmt|;
name|tilePriv
operator|=
operator|(
name|hpPrivPixmapPtr
operator|)
name|tile
operator|->
name|devPrivate
operator|.
name|ptr
expr_stmt|;
if|if
condition|(
name|tile
operator|->
name|devKind
operator|==
name|PIXMAP_FRAME_BUFFER
condition|)
name|widthSrc
operator|=
name|tilePriv
operator|->
name|pChunk
operator|->
name|w
operator|>>
literal|2
expr_stmt|;
else|else
name|widthSrc
operator|=
name|tilePriv
operator|->
name|stride
operator|>>
literal|2
expr_stmt|;
name|strideSrc
operator|=
name|tilePriv
operator|->
name|stride
operator|>>
literal|2
expr_stmt|;
name|narrowTile
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|widthSrc
operator|==
literal|1
condition|)
block|{
name|narrowShift
operator|=
name|tileWidth
expr_stmt|;
name|narrowMask
operator|=
name|cfbendpartial
index|[
name|tileWidth
index|]
expr_stmt|;
name|tileWidth
operator|*=
literal|2
expr_stmt|;
name|widthSrc
operator|=
literal|2
expr_stmt|;
name|narrowTile
operator|=
name|TRUE
expr_stmt|;
block|}
name|pSrcBase
operator|=
operator|(
name|unsigned
name|long
operator|*
operator|)
name|tilePriv
operator|->
name|bits
expr_stmt|;
name|cfbGetLongWidthAndPointer
argument_list|(
argument|pDrawable
argument_list|,
argument|widthDst
argument_list|,
argument|pDstBase
argument_list|)
name|SET_REGISTERS_FOR_WRITING
argument_list|(
name|pDrawable
operator|->
name|pScreen
argument_list|,
operator|~
literal|0
argument_list|,
name|GXcopy
argument_list|)
expr_stmt|;
if|if
condition|(
name|tile
operator|->
name|devKind
operator|==
name|PIXMAP_FRAME_BUFFER
condition|)
name|WAIT_READY_TO_RENDER
argument_list|(
name|tile
operator|->
name|drawable
operator|.
name|pScreen
argument_list|)
expr_stmt|;
name|tileEndPart
operator|=
name|tileWidth
operator|&
name|PIM
expr_stmt|;
name|tileEndMask
operator|=
name|cfbendpartial
index|[
name|tileEndPart
index|]
expr_stmt|;
name|tileEndLeftShift
operator|=
operator|(
name|tileEndPart
operator|)
operator|<<
operator|(
literal|5
operator|-
name|PWSH
operator|)
expr_stmt|;
name|tileEndRightShift
operator|=
literal|32
operator|-
name|tileEndLeftShift
expr_stmt|;
name|xoffStep
operator|=
name|PPW
operator|-
name|tileEndPart
expr_stmt|;
comment|/*      * current assumptions: tile> 32 bits wide.      */
while|while
condition|(
name|nBox
operator|--
condition|)
block|{
name|w
operator|=
name|pBox
operator|->
name|x2
operator|-
name|pBox
operator|->
name|x1
expr_stmt|;
name|h
operator|=
name|pBox
operator|->
name|y2
operator|-
name|pBox
operator|->
name|y1
expr_stmt|;
name|modulus
argument_list|(
name|pBox
operator|->
name|x1
operator|-
name|xrot
argument_list|,
name|tileWidth
argument_list|,
name|srcx
argument_list|)
expr_stmt|;
name|modulus
argument_list|(
name|pBox
operator|->
name|y1
operator|-
name|yrot
argument_list|,
name|tileHeight
argument_list|,
name|srcy
argument_list|)
expr_stmt|;
name|xoffDst
operator|=
name|pBox
operator|->
name|x1
operator|&
name|PIM
expr_stmt|;
if|if
condition|(
name|xoffDst
operator|+
name|w
operator|<
name|PPW
condition|)
block|{
name|maskpartialbits
argument_list|(
name|pBox
operator|->
name|x1
argument_list|,
name|w
argument_list|,
name|startmask
argument_list|)
expr_stmt|;
name|endmask
operator|=
literal|0
expr_stmt|;
name|nlwMiddle
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|maskbits
argument_list|(
argument|pBox->x1
argument_list|,
argument|w
argument_list|,
argument|startmask
argument_list|,
argument|endmask
argument_list|,
argument|nlwMiddle
argument_list|)
block|}
name|pDstLine
operator|=
name|pDstBase
operator|+
operator|(
name|pBox
operator|->
name|y1
operator|*
name|widthDst
operator|)
operator|+
operator|(
name|pBox
operator|->
name|x1
operator|>>
name|PWSH
operator|)
expr_stmt|;
name|pSrcLine
operator|=
name|pSrcBase
operator|+
operator|(
name|srcy
operator|*
name|strideSrc
operator|)
expr_stmt|;
name|xoffSrc
operator|=
name|srcx
operator|&
name|PIM
expr_stmt|;
if|if
condition|(
name|xoffSrc
operator|>=
name|xoffDst
condition|)
block|{
name|xoffStart
operator|=
name|xoffSrc
operator|-
name|xoffDst
expr_stmt|;
name|needFirst
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|xoffStart
operator|=
name|PPW
operator|-
operator|(
name|xoffDst
operator|-
name|xoffSrc
operator|)
expr_stmt|;
name|needFirst
operator|=
literal|0
expr_stmt|;
block|}
name|leftShiftStart
operator|=
operator|(
name|xoffStart
operator|)
operator|<<
operator|(
literal|5
operator|-
name|PWSH
operator|)
expr_stmt|;
name|rightShiftStart
operator|=
literal|32
operator|-
name|leftShiftStart
expr_stmt|;
name|nlwSrcStart
operator|=
name|widthSrc
operator|-
operator|(
name|srcx
operator|>>
name|PWSH
operator|)
expr_stmt|;
while|while
condition|(
name|h
operator|--
condition|)
block|{
comment|/* XXX only works when narrowShift>= PPW/2 */
if|if
condition|(
name|narrowTile
condition|)
block|{
name|tmp
operator|=
name|pSrcBase
index|[
name|srcy
index|]
operator|&
name|narrowMask
expr_stmt|;
comment|/* source width == 1 */
name|narrow
index|[
literal|0
index|]
operator|=
name|tmp
operator||
name|SCRRIGHT
argument_list|(
name|tmp
argument_list|,
name|narrowShift
argument_list|)
expr_stmt|;
name|narrow
index|[
literal|1
index|]
operator|=
name|SCRLEFT
argument_list|(
name|tmp
argument_list|,
name|PPW
operator|-
name|narrowShift
argument_list|)
operator||
name|SCRRIGHT
argument_list|(
name|tmp
argument_list|,
literal|2
operator|*
name|narrowShift
operator|-
name|PPW
argument_list|)
expr_stmt|;
name|pSrcLine
operator|=
name|narrow
expr_stmt|;
block|}
name|xoff
operator|=
name|xoffStart
expr_stmt|;
name|leftShift
operator|=
name|leftShiftStart
expr_stmt|;
name|rightShift
operator|=
name|rightShiftStart
expr_stmt|;
name|nlwSrc
operator|=
name|nlwSrcStart
expr_stmt|;
name|pSrc
operator|=
name|pSrcLine
operator|+
operator|(
name|srcx
operator|>>
name|PWSH
operator|)
expr_stmt|;
name|pDst
operator|=
name|pDstLine
expr_stmt|;
name|bits
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|needFirst
condition|)
block|{
name|NextTileBits
block|}
if|if
condition|(
name|startmask
condition|)
block|{
name|NextTileBits
name|tmp
init|=
name|BitLeft
argument_list|(
name|tmp
argument_list|,
name|leftShift
argument_list|)
decl_stmt|;
if|if
condition|(
name|rightShift
operator|!=
literal|32
condition|)
name|tmp
operator||=
name|BitRight
argument_list|(
name|bits
argument_list|,
name|rightShift
argument_list|)
expr_stmt|;
operator|*
name|pDst
operator|=
name|MROP_MASK
argument_list|(
name|tmp
argument_list|,
operator|*
name|pDst
argument_list|,
name|startmask
argument_list|)
expr_stmt|;
operator|++
name|pDst
expr_stmt|;
block|}
name|nlw
operator|=
name|nlwMiddle
expr_stmt|;
while|while
condition|(
name|nlw
condition|)
block|{
if|#
directive|if
name|MROP
operator|==
name|Mcopy
if|if
condition|(
name|nlwSrc
operator|>
literal|1
condition|)
block|{
name|nlwPart
operator|=
name|nlw
expr_stmt|;
if|if
condition|(
name|nlwPart
operator|>=
name|nlwSrc
condition|)
name|nlwPart
operator|=
name|nlwSrc
operator|-
literal|1
expr_stmt|;
name|nlw
operator|-=
name|nlwPart
expr_stmt|;
name|nlwSrc
operator|-=
name|nlwPart
expr_stmt|;
if|if
condition|(
name|rightShift
operator|!=
literal|32
condition|)
block|{
while|while
condition|(
name|nlwPart
operator|--
condition|)
block|{
name|tmp
operator|=
name|bits
expr_stmt|;
name|bits
operator|=
operator|*
name|pSrc
operator|++
expr_stmt|;
operator|*
name|pDst
operator|=
name|MROP_SOLID
argument_list|(
name|BitLeft
argument_list|(
name|tmp
argument_list|,
name|leftShift
argument_list|)
operator||
name|BitRight
argument_list|(
name|bits
argument_list|,
name|rightShift
argument_list|)
argument_list|,
operator|*
name|pDst
argument_list|)
expr_stmt|;
operator|++
name|pDst
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|nlwPart
condition|)
block|{
operator|*
name|pDst
operator|=
name|MROP_SOLID
argument_list|(
name|bits
argument_list|,
operator|*
name|pDst
argument_list|)
expr_stmt|;
operator|++
name|pDst
expr_stmt|;
name|nlwPart
operator|--
expr_stmt|;
while|while
condition|(
name|nlwPart
operator|--
condition|)
block|{
operator|*
name|pDst
operator|=
name|MROP_SOLID
argument_list|(
operator|*
name|pSrc
argument_list|,
operator|*
name|pDst
argument_list|)
expr_stmt|;
operator|++
name|pDst
expr_stmt|;
operator|++
name|pSrc
expr_stmt|;
block|}
name|bits
operator|=
operator|*
name|pSrc
operator|++
expr_stmt|;
block|}
block|}
block|}
else|else
endif|#
directive|endif
block|{
name|NextTileBits
if|if
condition|(
name|rightShift
operator|!=
literal|32
condition|)
block|{
operator|*
name|pDst
operator|=
name|MROP_SOLID
argument_list|(
name|BitLeft
argument_list|(
name|tmp
argument_list|,
name|leftShift
argument_list|)
operator||
name|BitRight
argument_list|(
name|bits
argument_list|,
name|rightShift
argument_list|)
argument_list|,
operator|*
name|pDst
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|pDst
operator|=
name|MROP_SOLID
argument_list|(
name|tmp
argument_list|,
operator|*
name|pDst
argument_list|)
expr_stmt|;
block|}
operator|++
name|pDst
expr_stmt|;
name|nlw
operator|--
expr_stmt|;
block|}
block|}
if|if
condition|(
name|endmask
condition|)
block|{
name|NextTileBits
if|if
condition|(
name|rightShift
operator|==
literal|32
condition|)
name|bits
operator|=
literal|0
expr_stmt|;
operator|*
name|pDst
operator|=
name|MROP_MASK
argument_list|(
name|BitLeft
argument_list|(
name|tmp
argument_list|,
name|leftShift
argument_list|)
operator||
name|BitRight
argument_list|(
name|bits
argument_list|,
name|rightShift
argument_list|)
argument_list|,
operator|*
name|pDst
argument_list|,
name|endmask
argument_list|)
expr_stmt|;
block|}
name|pDstLine
operator|+=
name|widthDst
expr_stmt|;
name|pSrcLine
operator|+=
name|strideSrc
expr_stmt|;
if|if
condition|(
operator|++
name|srcy
operator|==
name|tileHeight
condition|)
block|{
name|srcy
operator|=
literal|0
expr_stmt|;
name|pSrcLine
operator|=
name|pSrcBase
expr_stmt|;
block|}
block|}
name|pBox
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|MROP_NAME
function|(
name|cfbFillSpanTileOdd
function|)
parameter_list|(
name|pDrawable
parameter_list|,
name|n
parameter_list|,
name|ppt
parameter_list|,
name|pwidth
parameter_list|,
name|tile
parameter_list|,
name|xrot
parameter_list|,
name|yrot
parameter_list|,
name|alu
parameter_list|,
name|planemask
parameter_list|)
name|DrawablePtr
name|pDrawable
decl_stmt|;
name|int
name|n
decl_stmt|;
name|DDXPointPtr
name|ppt
decl_stmt|;
name|int
modifier|*
name|pwidth
decl_stmt|;
name|PixmapPtr
name|tile
decl_stmt|;
name|int
name|xrot
decl_stmt|,
name|yrot
decl_stmt|;
name|int
name|alu
decl_stmt|;
name|unsigned
name|long
name|planemask
decl_stmt|;
block|{
name|hpPrivPixmapPtr
name|tilePriv
decl_stmt|;
name|int
name|tileWidth
decl_stmt|;
comment|/* width of tile in pixels */
name|int
name|tileHeight
decl_stmt|;
comment|/* height of the tile */
name|int
name|widthSrc
decl_stmt|;
name|int
name|strideSrc
decl_stmt|;
name|int
name|widthDst
decl_stmt|;
comment|/* width in longwords of the dest pixmap */
name|int
name|w
decl_stmt|;
comment|/* width of current span */
name|unsigned
name|long
name|startmask
decl_stmt|;
name|unsigned
name|long
name|endmask
decl_stmt|;
comment|/* masks for reggedy bits at either end of line */
name|int
name|nlwSrc
decl_stmt|;
comment|/* number of whole longwords in source */
specifier|register
name|int
name|nlw
decl_stmt|;
comment|/* loop version of nlwMiddle */
name|int
name|srcy
decl_stmt|;
comment|/* current tile y position */
name|int
name|srcx
decl_stmt|;
comment|/* current tile x position */
name|int
name|xoffDst
decl_stmt|,
name|xoffSrc
decl_stmt|;
name|int
name|leftShift
decl_stmt|,
name|rightShift
decl_stmt|;
name|MROP_DECLARE_REG
argument_list|()
name|unsigned
name|long
modifier|*
name|pDstBase
decl_stmt|;
comment|/* pointer to start of dest */
name|unsigned
name|long
modifier|*
name|pDstLine
decl_stmt|;
comment|/* poitner to start of dest box */
name|unsigned
name|long
modifier|*
name|pSrcBase
decl_stmt|;
comment|/* pointer to start of source */
name|unsigned
name|long
modifier|*
name|pSrcLine
decl_stmt|;
comment|/* pointer to start of source line */
specifier|register
name|unsigned
name|long
modifier|*
name|pDst
decl_stmt|;
specifier|register
name|unsigned
name|long
modifier|*
name|pSrc
decl_stmt|;
specifier|register
name|unsigned
name|long
name|bits
decl_stmt|,
name|tmp
decl_stmt|;
specifier|register
name|int
name|nlwPart
decl_stmt|;
name|int
name|xoffStart
decl_stmt|,
name|xoff
decl_stmt|;
name|int
name|leftShiftStart
decl_stmt|,
name|rightShiftStart
decl_stmt|,
name|nlwSrcStart
decl_stmt|;
name|unsigned
name|long
name|tileEndMask
decl_stmt|;
name|int
name|tileEndLeftShift
decl_stmt|,
name|tileEndRightShift
decl_stmt|;
name|int
name|xoffStep
decl_stmt|;
name|int
name|tileEndPart
decl_stmt|;
name|int
name|needFirst
decl_stmt|;
name|unsigned
name|long
name|narrow
index|[
literal|2
index|]
decl_stmt|;
name|unsigned
name|long
name|narrowMask
decl_stmt|;
name|int
name|narrowShift
decl_stmt|;
name|Bool
name|narrowTile
decl_stmt|;
name|MROP_INITIALIZE
argument_list|(
argument|alu
argument_list|,
argument|planemask
argument_list|)
name|tileHeight
operator|=
name|tile
operator|->
name|drawable
operator|.
name|height
expr_stmt|;
name|tileWidth
operator|=
name|tile
operator|->
name|drawable
operator|.
name|width
expr_stmt|;
name|tilePriv
operator|=
operator|(
name|hpPrivPixmapPtr
operator|)
name|tile
operator|->
name|devPrivate
operator|.
name|ptr
expr_stmt|;
if|if
condition|(
name|tile
operator|->
name|devKind
operator|==
name|PIXMAP_FRAME_BUFFER
condition|)
name|widthSrc
operator|=
name|tilePriv
operator|->
name|pChunk
operator|->
name|w
operator|>>
literal|2
expr_stmt|;
else|else
name|widthSrc
operator|=
name|tilePriv
operator|->
name|stride
operator|>>
literal|2
expr_stmt|;
name|strideSrc
operator|=
name|tilePriv
operator|->
name|stride
operator|>>
literal|2
expr_stmt|;
name|narrowTile
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|widthSrc
operator|==
literal|1
condition|)
block|{
name|narrowShift
operator|=
name|tileWidth
expr_stmt|;
name|narrowMask
operator|=
name|cfbendpartial
index|[
name|tileWidth
index|]
expr_stmt|;
name|tileWidth
operator|*=
literal|2
expr_stmt|;
name|widthSrc
operator|=
literal|2
expr_stmt|;
name|narrowTile
operator|=
name|TRUE
expr_stmt|;
block|}
name|pSrcBase
operator|=
operator|(
name|unsigned
name|long
operator|*
operator|)
name|tilePriv
operator|->
name|bits
expr_stmt|;
name|cfbGetLongWidthAndPointer
argument_list|(
argument|pDrawable
argument_list|,
argument|widthDst
argument_list|,
argument|pDstBase
argument_list|)
name|SET_REGISTERS_FOR_WRITING
argument_list|(
name|pDrawable
operator|->
name|pScreen
argument_list|,
operator|~
literal|0
argument_list|,
name|GXcopy
argument_list|)
expr_stmt|;
if|if
condition|(
name|tile
operator|->
name|devKind
operator|==
name|PIXMAP_FRAME_BUFFER
condition|)
name|WAIT_READY_TO_RENDER
argument_list|(
name|tile
operator|->
name|drawable
operator|.
name|pScreen
argument_list|)
expr_stmt|;
name|tileEndPart
operator|=
name|tileWidth
operator|&
name|PIM
expr_stmt|;
name|tileEndMask
operator|=
name|cfbendpartial
index|[
name|tileEndPart
index|]
expr_stmt|;
name|tileEndLeftShift
operator|=
operator|(
name|tileEndPart
operator|)
operator|<<
operator|(
literal|5
operator|-
name|PWSH
operator|)
expr_stmt|;
name|tileEndRightShift
operator|=
literal|32
operator|-
name|tileEndLeftShift
expr_stmt|;
name|xoffStep
operator|=
name|PPW
operator|-
name|tileEndPart
expr_stmt|;
while|while
condition|(
name|n
operator|--
condition|)
block|{
name|w
operator|=
operator|*
name|pwidth
operator|++
expr_stmt|;
name|modulus
argument_list|(
name|ppt
operator|->
name|x
operator|-
name|xrot
argument_list|,
name|tileWidth
argument_list|,
name|srcx
argument_list|)
expr_stmt|;
name|modulus
argument_list|(
name|ppt
operator|->
name|y
operator|-
name|yrot
argument_list|,
name|tileHeight
argument_list|,
name|srcy
argument_list|)
expr_stmt|;
name|xoffDst
operator|=
name|ppt
operator|->
name|x
operator|&
name|PIM
expr_stmt|;
if|if
condition|(
name|xoffDst
operator|+
name|w
operator|<
name|PPW
condition|)
block|{
name|maskpartialbits
argument_list|(
name|ppt
operator|->
name|x
argument_list|,
name|w
argument_list|,
name|startmask
argument_list|)
expr_stmt|;
name|endmask
operator|=
literal|0
expr_stmt|;
name|nlw
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|maskbits
argument_list|(
argument|ppt->x
argument_list|,
argument|w
argument_list|,
argument|startmask
argument_list|,
argument|endmask
argument_list|,
argument|nlw
argument_list|)
block|}
name|pDstLine
operator|=
name|pDstBase
operator|+
operator|(
name|ppt
operator|->
name|y
operator|*
name|widthDst
operator|)
operator|+
operator|(
name|ppt
operator|->
name|x
operator|>>
name|PWSH
operator|)
expr_stmt|;
name|pSrcLine
operator|=
name|pSrcBase
operator|+
operator|(
name|srcy
operator|*
name|strideSrc
operator|)
expr_stmt|;
name|xoffSrc
operator|=
name|srcx
operator|&
name|PIM
expr_stmt|;
if|if
condition|(
name|xoffSrc
operator|>=
name|xoffDst
condition|)
block|{
name|xoffStart
operator|=
name|xoffSrc
operator|-
name|xoffDst
expr_stmt|;
name|needFirst
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|xoffStart
operator|=
name|PPW
operator|-
operator|(
name|xoffDst
operator|-
name|xoffSrc
operator|)
expr_stmt|;
name|needFirst
operator|=
literal|0
expr_stmt|;
block|}
name|leftShiftStart
operator|=
operator|(
name|xoffStart
operator|)
operator|<<
operator|(
literal|5
operator|-
name|PWSH
operator|)
expr_stmt|;
name|rightShiftStart
operator|=
literal|32
operator|-
name|leftShiftStart
expr_stmt|;
name|nlwSrcStart
operator|=
name|widthSrc
operator|-
operator|(
name|srcx
operator|>>
name|PWSH
operator|)
expr_stmt|;
comment|/* XXX only works when narrowShift>= PPW/2 */
if|if
condition|(
name|narrowTile
condition|)
block|{
name|tmp
operator|=
name|pSrcBase
index|[
name|srcy
index|]
operator|&
name|narrowMask
expr_stmt|;
comment|/* source width == 1 */
name|narrow
index|[
literal|0
index|]
operator|=
name|tmp
operator||
name|SCRRIGHT
argument_list|(
name|tmp
argument_list|,
name|narrowShift
argument_list|)
expr_stmt|;
name|narrow
index|[
literal|1
index|]
operator|=
name|SCRLEFT
argument_list|(
name|tmp
argument_list|,
name|PPW
operator|-
name|narrowShift
argument_list|)
operator||
name|SCRRIGHT
argument_list|(
name|tmp
argument_list|,
literal|2
operator|*
name|narrowShift
operator|-
name|PPW
argument_list|)
expr_stmt|;
name|pSrcLine
operator|=
name|narrow
expr_stmt|;
block|}
name|xoff
operator|=
name|xoffStart
expr_stmt|;
name|leftShift
operator|=
name|leftShiftStart
expr_stmt|;
name|rightShift
operator|=
name|rightShiftStart
expr_stmt|;
name|nlwSrc
operator|=
name|nlwSrcStart
expr_stmt|;
name|pSrc
operator|=
name|pSrcLine
operator|+
operator|(
name|srcx
operator|>>
name|PWSH
operator|)
expr_stmt|;
name|pDst
operator|=
name|pDstLine
expr_stmt|;
name|bits
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|needFirst
condition|)
block|{
name|NextTileBits
block|}
if|if
condition|(
name|startmask
condition|)
block|{
name|NextTileBits
name|tmp
init|=
name|BitLeft
argument_list|(
name|tmp
argument_list|,
name|leftShift
argument_list|)
decl_stmt|;
if|if
condition|(
name|rightShift
operator|!=
literal|32
condition|)
name|tmp
operator||=
name|BitRight
argument_list|(
name|bits
argument_list|,
name|rightShift
argument_list|)
expr_stmt|;
operator|*
name|pDst
operator|=
name|MROP_MASK
argument_list|(
name|tmp
argument_list|,
operator|*
name|pDst
argument_list|,
name|startmask
argument_list|)
expr_stmt|;
operator|++
name|pDst
expr_stmt|;
block|}
while|while
condition|(
name|nlw
condition|)
block|{
if|#
directive|if
name|MROP
operator|==
name|Mcopy
if|if
condition|(
name|nlwSrc
operator|>
literal|1
condition|)
block|{
name|nlwPart
operator|=
name|nlw
expr_stmt|;
if|if
condition|(
name|nlwPart
operator|>=
name|nlwSrc
condition|)
name|nlwPart
operator|=
name|nlwSrc
operator|-
literal|1
expr_stmt|;
name|nlw
operator|-=
name|nlwPart
expr_stmt|;
name|nlwSrc
operator|-=
name|nlwPart
expr_stmt|;
if|if
condition|(
name|rightShift
operator|!=
literal|32
condition|)
block|{
while|while
condition|(
name|nlwPart
operator|--
condition|)
block|{
name|tmp
operator|=
name|bits
expr_stmt|;
name|bits
operator|=
operator|*
name|pSrc
operator|++
expr_stmt|;
operator|*
name|pDst
operator|=
name|MROP_SOLID
argument_list|(
name|BitLeft
argument_list|(
name|tmp
argument_list|,
name|leftShift
argument_list|)
operator||
name|BitRight
argument_list|(
name|bits
argument_list|,
name|rightShift
argument_list|)
argument_list|,
operator|*
name|pDst
argument_list|)
expr_stmt|;
operator|++
name|pDst
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|nlwPart
condition|)
block|{
operator|*
name|pDst
operator|=
name|MROP_SOLID
argument_list|(
name|bits
argument_list|,
operator|*
name|pDst
argument_list|)
expr_stmt|;
operator|++
name|pDst
expr_stmt|;
name|nlwPart
operator|--
expr_stmt|;
while|while
condition|(
name|nlwPart
operator|--
condition|)
block|{
operator|*
name|pDst
operator|=
name|MROP_SOLID
argument_list|(
operator|*
name|pSrc
argument_list|,
operator|*
name|pDst
argument_list|)
expr_stmt|;
operator|++
name|pDst
expr_stmt|;
operator|++
name|pSrc
expr_stmt|;
block|}
name|bits
operator|=
operator|*
name|pSrc
operator|++
expr_stmt|;
block|}
block|}
block|}
else|else
endif|#
directive|endif
block|{
name|NextTileBits
if|if
condition|(
name|rightShift
operator|!=
literal|32
condition|)
block|{
operator|*
name|pDst
operator|=
name|MROP_SOLID
argument_list|(
name|BitLeft
argument_list|(
name|tmp
argument_list|,
name|leftShift
argument_list|)
operator||
name|BitRight
argument_list|(
name|bits
argument_list|,
name|rightShift
argument_list|)
argument_list|,
operator|*
name|pDst
argument_list|)
expr_stmt|;
operator|++
name|pDst
expr_stmt|;
block|}
else|else
block|{
operator|*
name|pDst
operator|=
name|MROP_SOLID
argument_list|(
name|tmp
argument_list|,
operator|*
name|pDst
argument_list|)
expr_stmt|;
operator|++
name|pDst
expr_stmt|;
block|}
name|nlw
operator|--
expr_stmt|;
block|}
block|}
if|if
condition|(
name|endmask
condition|)
block|{
name|NextTileBits
if|if
condition|(
name|rightShift
operator|==
literal|32
condition|)
name|bits
operator|=
literal|0
expr_stmt|;
operator|*
name|pDst
operator|=
name|MROP_MASK
argument_list|(
name|BitLeft
argument_list|(
name|tmp
argument_list|,
name|leftShift
argument_list|)
operator||
name|BitRight
argument_list|(
name|bits
argument_list|,
name|rightShift
argument_list|)
argument_list|,
operator|*
name|pDst
argument_list|,
name|endmask
argument_list|)
expr_stmt|;
block|}
name|ppt
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_include
include|#
directive|include
file|"fastblt.h"
end_include

begin_define
define|#
directive|define
name|IncSrcPtr
value|psrc++; if (!--srcRemaining) { srcRemaining = widthSrc; psrc = psrcStart; }
end_define

begin_function
name|MROP_NAME
function|(
name|cfbFillBoxTile32s
function|)
parameter_list|(
name|pDrawable
parameter_list|,
name|nBox
parameter_list|,
name|pBox
parameter_list|,
name|tile
parameter_list|,
name|xrot
parameter_list|,
name|yrot
parameter_list|,
name|alu
parameter_list|,
name|planemask
parameter_list|)
name|DrawablePtr
name|pDrawable
decl_stmt|;
name|int
name|nBox
decl_stmt|;
comment|/* number of boxes to fill */
specifier|register
name|BoxPtr
name|pBox
decl_stmt|;
comment|/* pointer to list of boxes to fill */
name|PixmapPtr
name|tile
decl_stmt|;
comment|/* tile */
name|int
name|xrot
decl_stmt|,
name|yrot
decl_stmt|;
name|int
name|alu
decl_stmt|;
name|unsigned
name|long
name|planemask
decl_stmt|;
block|{
name|hpPrivPixmapPtr
name|tilePriv
decl_stmt|;
name|int
name|tileWidth
decl_stmt|;
comment|/* width of tile */
name|int
name|tileHeight
decl_stmt|;
comment|/* height of the tile */
name|int
name|widthSrc
decl_stmt|;
comment|/* width in longwords of the source tile */
name|int
name|strideSrc
decl_stmt|;
name|int
name|widthDst
decl_stmt|;
comment|/* width in longwords of the dest pixmap */
name|int
name|w
decl_stmt|;
comment|/* width of current box */
name|int
name|h
decl_stmt|;
comment|/* height of current box */
name|unsigned
name|long
name|startmask
decl_stmt|;
name|unsigned
name|long
name|endmask
decl_stmt|;
comment|/* masks for reggedy bits at either end of line */
name|int
name|nlMiddle
decl_stmt|;
comment|/* number of longwords between sides of boxes */
specifier|register
name|int
name|nl
decl_stmt|;
comment|/* loop version of nlMiddle */
name|int
name|srcy
decl_stmt|;
comment|/* current tile y position */
name|int
name|srcx
decl_stmt|;
comment|/* current tile x position */
name|int
name|srcRemaining
decl_stmt|;
comment|/* number of longwords remaining in source */
name|int
name|xoffDst
decl_stmt|,
name|xoffSrc
decl_stmt|;
name|int
name|srcStart
decl_stmt|;
comment|/* number of longwords source offset at left of box */
name|int
name|leftShift
decl_stmt|,
name|rightShift
decl_stmt|;
name|MROP_DECLARE_REG
argument_list|()
name|unsigned
name|long
modifier|*
name|pdstBase
decl_stmt|;
comment|/* pointer to start of dest */
name|unsigned
name|long
modifier|*
name|pdstLine
decl_stmt|;
comment|/* poitner to start of dest box */
name|unsigned
name|long
modifier|*
name|psrcBase
decl_stmt|;
comment|/* pointer to start of source */
name|unsigned
name|long
modifier|*
name|psrcLine
decl_stmt|;
comment|/* pointer to fetch point of source */
name|unsigned
name|long
modifier|*
name|psrcStart
decl_stmt|;
comment|/* pointer to start of source line */
specifier|register
name|unsigned
name|long
modifier|*
name|pdst
decl_stmt|;
specifier|register
name|unsigned
name|long
modifier|*
name|psrc
decl_stmt|;
specifier|register
name|unsigned
name|long
name|bits
decl_stmt|,
name|bits1
decl_stmt|;
specifier|register
name|int
name|nlTemp
decl_stmt|;
name|MROP_INITIALIZE
argument_list|(
argument|alu
argument_list|,
argument|planemask
argument_list|)
name|tilePriv
operator|=
operator|(
name|hpPrivPixmapPtr
operator|)
name|tile
operator|->
name|devPrivate
operator|.
name|ptr
expr_stmt|;
name|psrcBase
operator|=
operator|(
name|unsigned
name|long
operator|*
operator|)
name|tilePriv
operator|->
name|bits
expr_stmt|;
name|tileHeight
operator|=
name|tile
operator|->
name|drawable
operator|.
name|height
expr_stmt|;
name|tileWidth
operator|=
name|tile
operator|->
name|drawable
operator|.
name|width
expr_stmt|;
name|widthSrc
operator|=
name|tileWidth
operator|>>
name|PWSH
expr_stmt|;
name|strideSrc
operator|=
name|tilePriv
operator|->
name|stride
operator|>>
name|PWSH
expr_stmt|;
name|cfbGetLongWidthAndPointer
argument_list|(
argument|pDrawable
argument_list|,
argument|widthDst
argument_list|,
argument|pdstBase
argument_list|)
name|SET_REGISTERS_FOR_WRITING
argument_list|(
name|pDrawable
operator|->
name|pScreen
argument_list|,
operator|~
literal|0
argument_list|,
name|GXcopy
argument_list|)
expr_stmt|;
if|if
condition|(
name|tile
operator|->
name|devKind
operator|==
name|PIXMAP_FRAME_BUFFER
condition|)
name|WAIT_READY_TO_RENDER
argument_list|(
name|tile
operator|->
name|drawable
operator|.
name|pScreen
argument_list|)
expr_stmt|;
while|while
condition|(
name|nBox
operator|--
condition|)
block|{
name|w
operator|=
name|pBox
operator|->
name|x2
operator|-
name|pBox
operator|->
name|x1
expr_stmt|;
name|h
operator|=
name|pBox
operator|->
name|y2
operator|-
name|pBox
operator|->
name|y1
expr_stmt|;
comment|/* set up source */
name|modulus
argument_list|(
name|pBox
operator|->
name|x1
operator|-
name|xrot
argument_list|,
name|tileWidth
argument_list|,
name|srcx
argument_list|)
expr_stmt|;
name|modulus
argument_list|(
name|pBox
operator|->
name|y1
operator|-
name|yrot
argument_list|,
name|tileHeight
argument_list|,
name|srcy
argument_list|)
expr_stmt|;
name|xoffSrc
operator|=
name|srcx
operator|&
name|PIM
expr_stmt|;
name|srcStart
operator|=
operator|(
name|srcx
operator|>>
name|PWSH
operator|)
expr_stmt|;
name|psrcStart
operator|=
name|psrcBase
operator|+
operator|(
name|srcy
operator|*
name|strideSrc
operator|)
expr_stmt|;
name|psrcLine
operator|=
name|psrcStart
operator|+
name|srcStart
expr_stmt|;
comment|/* set up dest */
name|xoffDst
operator|=
name|pBox
operator|->
name|x1
operator|&
name|PIM
expr_stmt|;
name|pdstLine
operator|=
name|pdstBase
operator|+
operator|(
name|pBox
operator|->
name|y1
operator|*
name|widthDst
operator|)
operator|+
operator|(
name|pBox
operator|->
name|x1
operator|>>
name|PWSH
operator|)
expr_stmt|;
comment|/* set up masks */
if|if
condition|(
name|xoffDst
operator|+
name|w
operator|<
name|PPW
condition|)
block|{
name|maskpartialbits
argument_list|(
name|pBox
operator|->
name|x1
argument_list|,
name|w
argument_list|,
name|startmask
argument_list|)
expr_stmt|;
name|endmask
operator|=
literal|0
expr_stmt|;
name|nlMiddle
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|maskbits
argument_list|(
argument|pBox->x1
argument_list|,
argument|w
argument_list|,
argument|startmask
argument_list|,
argument|endmask
argument_list|,
argument|nlMiddle
argument_list|)
block|}
if|if
condition|(
name|xoffSrc
operator|==
name|xoffDst
condition|)
block|{
while|while
condition|(
name|h
operator|--
condition|)
block|{
name|psrc
operator|=
name|psrcLine
expr_stmt|;
name|pdst
operator|=
name|pdstLine
expr_stmt|;
name|srcRemaining
operator|=
name|widthSrc
operator|-
name|srcStart
expr_stmt|;
if|if
condition|(
name|startmask
condition|)
block|{
operator|*
name|pdst
operator|=
name|MROP_MASK
argument_list|(
operator|*
name|psrc
argument_list|,
operator|*
name|pdst
argument_list|,
name|startmask
argument_list|)
expr_stmt|;
name|pdst
operator|++
expr_stmt|;
name|IncSrcPtr
block|}
name|nlTemp
operator|=
name|nlMiddle
expr_stmt|;
while|while
condition|(
name|nlTemp
condition|)
block|{
name|nl
operator|=
name|nlTemp
expr_stmt|;
if|if
condition|(
name|nl
operator|>
name|srcRemaining
condition|)
name|nl
operator|=
name|srcRemaining
expr_stmt|;
name|nlTemp
operator|-=
name|nl
expr_stmt|;
name|srcRemaining
operator|-=
name|nl
expr_stmt|;
if|#
directive|if
name|MROP
operator|==
name|Mcopy
ifdef|#
directive|ifdef
name|LARGE_INSTRUCTION_CACHE
ifdef|#
directive|ifdef
name|FAST_CONSTANT_OFFSET_MODE
name|psrc
operator|+=
name|nl
operator|&
operator|(
name|UNROLL
operator|-
literal|1
operator|)
expr_stmt|;
name|pdst
operator|+=
name|nl
operator|&
operator|(
name|UNROLL
operator|-
literal|1
operator|)
expr_stmt|;
define|#
directive|define
name|BodyOdd
parameter_list|(
name|n
parameter_list|)
value|pdst[-n] = MROP_SOLID (psrc[-n], pdst[-n]);
define|#
directive|define
name|BodyEven
parameter_list|(
name|n
parameter_list|)
value|pdst[-n] = MROP_SOLID (psrc[-n], pdst[-n]);
define|#
directive|define
name|LoopReset
define|\
value|pdst += UNROLL; \ psrc += UNROLL;
else|#
directive|else
define|#
directive|define
name|BodyOdd
parameter_list|(
name|n
parameter_list|)
value|*pdst = MROP_SOLID (*psrc, *pdst); pdst++; psrc++;
define|#
directive|define
name|BodyEven
parameter_list|(
name|n
parameter_list|)
value|BodyOdd(n)
define|#
directive|define
name|LoopReset
value|;
endif|#
directive|endif
name|PackedLoop
undef|#
directive|undef
name|BodyOdd
undef|#
directive|undef
name|BodyEven
undef|#
directive|undef
name|LoopReset
else|#
directive|else
name|DuffL
argument_list|(
name|nl
argument_list|,
name|label1
argument_list|,
operator|*
name|pdst
operator|=
name|MROP_SOLID
argument_list|(
operator|*
name|psrc
argument_list|,
operator|*
name|pdst
argument_list|)
argument_list|;
name|pdst
operator|++
expr_stmt|;
name|psrc
operator|++
expr_stmt|;
block|)
endif|#
directive|endif
else|#
directive|else
while|while
condition|(
name|nl
operator|--
condition|)
block|{
operator|*
name|pdst
operator|=
name|MROP_SOLID
argument_list|(
operator|*
name|psrc
argument_list|,
operator|*
name|pdst
argument_list|)
expr_stmt|;
name|pdst
operator|++
expr_stmt|;
name|psrc
operator|++
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|!
name|srcRemaining
condition|)
block|{
name|srcRemaining
operator|=
name|widthSrc
expr_stmt|;
name|psrc
operator|=
name|psrcStart
expr_stmt|;
block|}
block|}
if|if
condition|(
name|endmask
condition|)
block|{
operator|*
name|pdst
operator|=
name|MROP_MASK
argument_list|(
operator|*
name|psrc
argument_list|,
operator|*
name|pdst
argument_list|,
name|endmask
argument_list|)
expr_stmt|;
block|}
name|pdstLine
operator|+=
name|widthDst
expr_stmt|;
name|psrcLine
operator|+=
name|strideSrc
expr_stmt|;
name|psrcStart
operator|+=
name|strideSrc
expr_stmt|;
if|if
condition|(
operator|++
name|srcy
operator|==
name|tileHeight
condition|)
block|{
name|psrcStart
operator|=
name|psrcBase
expr_stmt|;
name|psrcLine
operator|=
name|psrcStart
operator|+
name|srcStart
expr_stmt|;
name|srcy
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|xoffSrc
operator|>
name|xoffDst
condition|)
block|{
name|leftShift
operator|=
operator|(
name|xoffSrc
operator|-
name|xoffDst
operator|)
operator|<<
operator|(
literal|5
operator|-
name|PWSH
operator|)
expr_stmt|;
name|rightShift
operator|=
literal|32
operator|-
name|leftShift
expr_stmt|;
block|}
else|else
block|{
name|rightShift
operator|=
operator|(
name|xoffDst
operator|-
name|xoffSrc
operator|)
operator|<<
operator|(
literal|5
operator|-
name|PWSH
operator|)
expr_stmt|;
name|leftShift
operator|=
literal|32
operator|-
name|rightShift
expr_stmt|;
block|}
while|while
condition|(
name|h
operator|--
condition|)
block|{
name|psrc
operator|=
name|psrcLine
expr_stmt|;
name|pdst
operator|=
name|pdstLine
expr_stmt|;
name|bits
operator|=
literal|0
expr_stmt|;
name|srcRemaining
operator|=
name|widthSrc
operator|-
name|srcStart
expr_stmt|;
if|if
condition|(
name|xoffSrc
operator|>
name|xoffDst
condition|)
block|{
name|bits
operator|=
operator|*
name|psrc
expr_stmt|;
name|IncSrcPtr
block|}
if|if
condition|(
name|startmask
condition|)
block|{
name|bits1
operator|=
name|BitLeft
argument_list|(
name|bits
argument_list|,
name|leftShift
argument_list|)
expr_stmt|;
name|bits
operator|=
operator|*
name|psrc
expr_stmt|;
name|IncSrcPtr
name|bits1
operator||=
name|BitRight
argument_list|(
name|bits
argument_list|,
name|rightShift
argument_list|)
expr_stmt|;
operator|*
name|pdst
operator|=
name|MROP_MASK
argument_list|(
name|bits1
argument_list|,
operator|*
name|pdst
argument_list|,
name|startmask
argument_list|)
expr_stmt|;
name|pdst
operator|++
expr_stmt|;
block|}
name|nlTemp
operator|=
name|nlMiddle
expr_stmt|;
while|while
condition|(
name|nlTemp
condition|)
block|{
name|nl
operator|=
name|nlTemp
expr_stmt|;
if|if
condition|(
name|nl
operator|>
name|srcRemaining
condition|)
name|nl
operator|=
name|srcRemaining
expr_stmt|;
name|nlTemp
operator|-=
name|nl
expr_stmt|;
name|srcRemaining
operator|-=
name|nl
expr_stmt|;
if|#
directive|if
name|MROP
operator|==
name|Mcopy
ifdef|#
directive|ifdef
name|LARGE_INSTRUCTION_CACHE
name|bits1
operator|=
name|bits
expr_stmt|;
ifdef|#
directive|ifdef
name|FAST_CONSTANT_OFFSET_MODE
name|psrc
operator|+=
name|nl
operator|&
operator|(
name|UNROLL
operator|-
literal|1
operator|)
expr_stmt|;
name|pdst
operator|+=
name|nl
operator|&
operator|(
name|UNROLL
operator|-
literal|1
operator|)
expr_stmt|;
define|#
directive|define
name|BodyOdd
parameter_list|(
name|n
parameter_list|)
define|\
value|bits = psrc[-n]; \     pdst[-n] = MROP_SOLID(BitLeft(bits1, leftShift) | BitRight(bits, rightShift), pdst[-n]);
define|#
directive|define
name|BodyEven
parameter_list|(
name|n
parameter_list|)
define|\
value|bits1 = psrc[-n]; \     pdst[-n] = MROP_SOLID(BitLeft(bits, leftShift) | BitRight(bits1, rightShift), pdst[-n]);
define|#
directive|define
name|LoopReset
define|\
value|pdst += UNROLL; \     psrc += UNROLL;
else|#
directive|else
define|#
directive|define
name|BodyOdd
parameter_list|(
name|n
parameter_list|)
define|\
value|bits = *psrc++; \     *pdst = MROP_SOLID(BitLeft(bits1, leftShift) | BitRight(bits, rightShift), *pdst); \     pdst++;
define|#
directive|define
name|BodyEven
parameter_list|(
name|n
parameter_list|)
define|\
value|bits1 = *psrc++; \     *pdst = MROP_SOLID(BitLeft(bits, leftShift) | BitRight(bits1, rightShift), *pdst); \     pdst++;
define|#
directive|define
name|LoopReset
value|;
endif|#
directive|endif
comment|/* !FAST_CONSTANT_OFFSET_MODE */
name|PackedLoop
undef|#
directive|undef
name|BodyOdd
undef|#
directive|undef
name|BodyEven
undef|#
directive|undef
name|LoopReset
else|#
directive|else
name|DuffL
argument_list|(
name|nl
argument_list|,
name|label2
argument_list|,
name|bits1
operator|=
name|BitLeft
argument_list|(
name|bits
argument_list|,
name|leftShift
argument_list|)
argument_list|;
name|bits
operator|=
operator|*
name|psrc
operator|++
argument_list|;
operator|*
name|pdst
operator|=
name|MROP_SOLID
argument_list|(
name|bits1
operator||
name|BitRight
argument_list|(
name|bits
argument_list|,
name|rightShift
argument_list|)
argument_list|,
operator|*
name|pdst
argument_list|)
argument_list|;
name|pdst
operator|++
argument_list|; 		    )
endif|#
directive|endif
else|#
directive|else
decl|while
argument_list|(
name|nl
operator|--
argument_list|)
block|{
name|bits1
operator|=
name|BitLeft
argument_list|(
name|bits
argument_list|,
name|leftShift
argument_list|)
expr_stmt|;
name|bits
operator|=
operator|*
name|psrc
operator|++
expr_stmt|;
operator|*
name|pdst
operator|=
name|MROP_SOLID
argument_list|(
name|bits1
operator||
name|BitRight
argument_list|(
name|bits
argument_list|,
name|rightShift
argument_list|)
argument_list|,
operator|*
name|pdst
argument_list|)
expr_stmt|;
name|pdst
operator|++
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|!
name|srcRemaining
condition|)
block|{
name|srcRemaining
operator|=
name|widthSrc
expr_stmt|;
name|psrc
operator|=
name|psrcStart
expr_stmt|;
block|}
block|}
if|if
condition|(
name|endmask
condition|)
block|{
name|bits1
operator|=
name|BitLeft
argument_list|(
name|bits
argument_list|,
name|leftShift
argument_list|)
expr_stmt|;
if|if
condition|(
name|BitLeft
argument_list|(
name|endmask
argument_list|,
name|rightShift
argument_list|)
condition|)
block|{
name|bits
operator|=
operator|*
name|psrc
expr_stmt|;
name|bits1
operator||=
name|BitRight
argument_list|(
name|bits
argument_list|,
name|rightShift
argument_list|)
expr_stmt|;
block|}
operator|*
name|pdst
operator|=
name|MROP_MASK
argument_list|(
name|bits1
argument_list|,
operator|*
name|pdst
argument_list|,
name|endmask
argument_list|)
expr_stmt|;
block|}
name|pdstLine
operator|+=
name|widthDst
expr_stmt|;
name|psrcLine
operator|+=
name|strideSrc
expr_stmt|;
name|psrcStart
operator|+=
name|strideSrc
expr_stmt|;
if|if
condition|(
operator|++
name|srcy
operator|==
name|tileHeight
condition|)
block|{
name|psrcStart
operator|=
name|psrcBase
expr_stmt|;
name|psrcLine
operator|=
name|psrcStart
operator|+
name|srcStart
expr_stmt|;
name|srcy
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
name|pBox
operator|++
expr_stmt|;
block|}
end_function

begin_expr_stmt
unit|}  MROP_NAME
operator|(
name|cfbFillSpanTile32s
operator|)
operator|(
name|pDrawable
operator|,
name|n
operator|,
name|ppt
operator|,
name|pwidth
operator|,
name|tile
operator|,
name|xrot
operator|,
name|yrot
operator|,
name|alu
operator|,
name|planemask
operator|)
name|DrawablePtr
name|pDrawable
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|DDXPointPtr
name|ppt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|pwidth
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|PixmapPtr
name|tile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|xrot
decl_stmt|,
name|yrot
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|alu
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|long
name|planemask
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|hpPrivPixmapPtr
name|tilePriv
decl_stmt|;
name|int
name|tileWidth
decl_stmt|;
comment|/* width of tile */
name|int
name|tileHeight
decl_stmt|;
comment|/* height of the tile */
name|int
name|widthSrc
decl_stmt|;
comment|/* width in longwords of the source tile */
name|int
name|strideSrc
decl_stmt|;
name|int
name|widthDst
decl_stmt|;
comment|/* width in longwords of the dest pixmap */
name|int
name|w
decl_stmt|;
comment|/* width of current box */
name|unsigned
name|long
name|startmask
decl_stmt|;
name|unsigned
name|long
name|endmask
decl_stmt|;
comment|/* masks for reggedy bits at either end of line */
name|int
name|nlMiddle
decl_stmt|;
comment|/* number of longwords between sides of boxes */
specifier|register
name|int
name|nl
decl_stmt|;
comment|/* loop version of nlMiddle */
name|int
name|srcy
decl_stmt|;
comment|/* current tile y position */
name|int
name|srcx
decl_stmt|;
comment|/* current tile x position */
name|int
name|srcRemaining
decl_stmt|;
comment|/* number of longwords remaining in source */
name|int
name|xoffDst
decl_stmt|,
name|xoffSrc
decl_stmt|;
name|int
name|srcStart
decl_stmt|;
comment|/* number of longwords source offset at left of box */
name|int
name|leftShift
decl_stmt|,
name|rightShift
decl_stmt|;
name|MROP_DECLARE_REG
argument_list|()
name|unsigned
name|long
modifier|*
name|pdstBase
decl_stmt|;
comment|/* pointer to start of dest */
name|unsigned
name|long
modifier|*
name|pdstLine
decl_stmt|;
comment|/* poitner to start of dest box */
name|unsigned
name|long
modifier|*
name|psrcBase
decl_stmt|;
comment|/* pointer to start of source */
name|unsigned
name|long
modifier|*
name|psrcLine
decl_stmt|;
comment|/* pointer to fetch point of source */
name|unsigned
name|long
modifier|*
name|psrcStart
decl_stmt|;
comment|/* pointer to start of source line */
specifier|register
name|unsigned
name|long
modifier|*
name|pdst
decl_stmt|;
specifier|register
name|unsigned
name|long
modifier|*
name|psrc
decl_stmt|;
specifier|register
name|unsigned
name|long
name|bits
decl_stmt|,
name|bits1
decl_stmt|;
specifier|register
name|int
name|nlTemp
decl_stmt|;
name|MROP_INITIALIZE
argument_list|(
argument|alu
argument_list|,
argument|planemask
argument_list|)
name|tilePriv
operator|=
operator|(
name|hpPrivPixmapPtr
operator|)
name|tile
operator|->
name|devPrivate
operator|.
name|ptr
expr_stmt|;
name|psrcBase
operator|=
operator|(
name|unsigned
name|long
operator|*
operator|)
name|tilePriv
operator|->
name|bits
expr_stmt|;
name|tileHeight
operator|=
name|tile
operator|->
name|drawable
operator|.
name|height
expr_stmt|;
name|tileWidth
operator|=
name|tile
operator|->
name|drawable
operator|.
name|width
expr_stmt|;
name|widthSrc
operator|=
name|tileWidth
operator|>>
name|PWSH
expr_stmt|;
name|strideSrc
operator|=
name|tilePriv
operator|->
name|stride
operator|>>
name|PWSH
expr_stmt|;
name|cfbGetLongWidthAndPointer
argument_list|(
argument|pDrawable
argument_list|,
argument|widthDst
argument_list|,
argument|pdstBase
argument_list|)
name|SET_REGISTERS_FOR_WRITING
argument_list|(
name|pDrawable
operator|->
name|pScreen
argument_list|,
operator|~
literal|0
argument_list|,
name|GXcopy
argument_list|)
expr_stmt|;
if|if
condition|(
name|tile
operator|->
name|devKind
operator|==
name|PIXMAP_FRAME_BUFFER
condition|)
name|WAIT_READY_TO_RENDER
argument_list|(
name|tile
operator|->
name|drawable
operator|.
name|pScreen
argument_list|)
expr_stmt|;
while|while
condition|(
name|n
operator|--
condition|)
block|{
name|w
operator|=
operator|*
name|pwidth
operator|++
expr_stmt|;
comment|/* set up source */
name|modulus
argument_list|(
name|ppt
operator|->
name|x
operator|-
name|xrot
argument_list|,
name|tileWidth
argument_list|,
name|srcx
argument_list|)
expr_stmt|;
name|modulus
argument_list|(
name|ppt
operator|->
name|y
operator|-
name|yrot
argument_list|,
name|tileHeight
argument_list|,
name|srcy
argument_list|)
expr_stmt|;
name|xoffSrc
operator|=
name|srcx
operator|&
name|PIM
expr_stmt|;
name|srcStart
operator|=
operator|(
name|srcx
operator|>>
name|PWSH
operator|)
expr_stmt|;
name|psrcStart
operator|=
name|psrcBase
operator|+
operator|(
name|srcy
operator|*
name|strideSrc
operator|)
expr_stmt|;
name|psrcLine
operator|=
name|psrcStart
operator|+
name|srcStart
expr_stmt|;
comment|/* set up dest */
name|xoffDst
operator|=
name|ppt
operator|->
name|x
operator|&
name|PIM
expr_stmt|;
name|pdstLine
operator|=
name|pdstBase
operator|+
operator|(
name|ppt
operator|->
name|y
operator|*
name|widthDst
operator|)
operator|+
operator|(
name|ppt
operator|->
name|x
operator|>>
name|PWSH
operator|)
expr_stmt|;
comment|/* set up masks */
if|if
condition|(
name|xoffDst
operator|+
name|w
operator|<
name|PPW
condition|)
block|{
name|maskpartialbits
argument_list|(
name|ppt
operator|->
name|x
argument_list|,
name|w
argument_list|,
name|startmask
argument_list|)
expr_stmt|;
name|endmask
operator|=
literal|0
expr_stmt|;
name|nlMiddle
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|maskbits
argument_list|(
argument|ppt->x
argument_list|,
argument|w
argument_list|,
argument|startmask
argument_list|,
argument|endmask
argument_list|,
argument|nlMiddle
argument_list|)
block|}
if|if
condition|(
name|xoffSrc
operator|==
name|xoffDst
condition|)
block|{
name|psrc
operator|=
name|psrcLine
expr_stmt|;
name|pdst
operator|=
name|pdstLine
expr_stmt|;
name|srcRemaining
operator|=
name|widthSrc
operator|-
name|srcStart
expr_stmt|;
if|if
condition|(
name|startmask
condition|)
block|{
operator|*
name|pdst
operator|=
name|MROP_MASK
argument_list|(
operator|*
name|psrc
argument_list|,
operator|*
name|pdst
argument_list|,
name|startmask
argument_list|)
expr_stmt|;
name|pdst
operator|++
expr_stmt|;
name|IncSrcPtr
block|}
name|nlTemp
operator|=
name|nlMiddle
expr_stmt|;
while|while
condition|(
name|nlTemp
condition|)
block|{
name|nl
operator|=
name|nlTemp
expr_stmt|;
if|if
condition|(
name|nl
operator|>
name|srcRemaining
condition|)
name|nl
operator|=
name|srcRemaining
expr_stmt|;
name|nlTemp
operator|-=
name|nl
expr_stmt|;
name|srcRemaining
operator|-=
name|nl
expr_stmt|;
if|#
directive|if
name|MROP
operator|==
name|Mcopy
ifdef|#
directive|ifdef
name|LARGE_INSTRUCTION_CACHE
ifdef|#
directive|ifdef
name|FAST_CONSTANT_OFFSET_MODE
name|psrc
operator|+=
name|nl
operator|&
operator|(
name|UNROLL
operator|-
literal|1
operator|)
expr_stmt|;
name|pdst
operator|+=
name|nl
operator|&
operator|(
name|UNROLL
operator|-
literal|1
operator|)
expr_stmt|;
define|#
directive|define
name|BodyOdd
parameter_list|(
name|n
parameter_list|)
value|pdst[-n] = MROP_SOLID (psrc[-n], pdst[-n]);
define|#
directive|define
name|BodyEven
parameter_list|(
name|n
parameter_list|)
value|pdst[-n] = MROP_SOLID (psrc[-n], pdst[-n]);
define|#
directive|define
name|LoopReset
define|\
value|pdst += UNROLL; \ psrc += UNROLL;
else|#
directive|else
define|#
directive|define
name|BodyOdd
parameter_list|(
name|n
parameter_list|)
value|*pdst = MROP_SOLID (*psrc, *pdst); pdst++; psrc++;
define|#
directive|define
name|BodyEven
parameter_list|(
name|n
parameter_list|)
value|BodyOdd(n)
define|#
directive|define
name|LoopReset
value|;
endif|#
directive|endif
name|PackedLoop
undef|#
directive|undef
name|BodyOdd
undef|#
directive|undef
name|BodyEven
undef|#
directive|undef
name|LoopReset
else|#
directive|else
name|DuffL
argument_list|(
name|nl
argument_list|,
name|label1
argument_list|,
operator|*
name|pdst
operator|=
name|MROP_SOLID
argument_list|(
operator|*
name|psrc
argument_list|,
operator|*
name|pdst
argument_list|)
argument_list|;
name|pdst
operator|++
expr_stmt|;
name|psrc
operator|++
expr_stmt|;
block|)
endif|#
directive|endif
else|#
directive|else
while|while
condition|(
name|nl
operator|--
condition|)
block|{
operator|*
name|pdst
operator|=
name|MROP_SOLID
argument_list|(
operator|*
name|psrc
argument_list|,
operator|*
name|pdst
argument_list|)
expr_stmt|;
name|pdst
operator|++
expr_stmt|;
name|psrc
operator|++
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|!
name|srcRemaining
condition|)
block|{
name|srcRemaining
operator|=
name|widthSrc
expr_stmt|;
name|psrc
operator|=
name|psrcStart
expr_stmt|;
block|}
block|}
if|if
condition|(
name|endmask
condition|)
block|{
operator|*
name|pdst
operator|=
name|MROP_MASK
argument_list|(
operator|*
name|psrc
argument_list|,
operator|*
name|pdst
argument_list|,
name|endmask
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|xoffSrc
operator|>
name|xoffDst
condition|)
block|{
name|leftShift
operator|=
operator|(
name|xoffSrc
operator|-
name|xoffDst
operator|)
operator|<<
operator|(
literal|5
operator|-
name|PWSH
operator|)
expr_stmt|;
name|rightShift
operator|=
literal|32
operator|-
name|leftShift
expr_stmt|;
block|}
else|else
block|{
name|rightShift
operator|=
operator|(
name|xoffDst
operator|-
name|xoffSrc
operator|)
operator|<<
operator|(
literal|5
operator|-
name|PWSH
operator|)
expr_stmt|;
name|leftShift
operator|=
literal|32
operator|-
name|rightShift
expr_stmt|;
block|}
name|psrc
operator|=
name|psrcLine
expr_stmt|;
name|pdst
operator|=
name|pdstLine
expr_stmt|;
name|bits
operator|=
literal|0
expr_stmt|;
name|srcRemaining
operator|=
name|widthSrc
operator|-
name|srcStart
expr_stmt|;
if|if
condition|(
name|xoffSrc
operator|>
name|xoffDst
condition|)
block|{
name|bits
operator|=
operator|*
name|psrc
expr_stmt|;
name|IncSrcPtr
block|}
if|if
condition|(
name|startmask
condition|)
block|{
name|bits1
operator|=
name|BitLeft
argument_list|(
name|bits
argument_list|,
name|leftShift
argument_list|)
expr_stmt|;
name|bits
operator|=
operator|*
name|psrc
expr_stmt|;
name|IncSrcPtr
name|bits1
operator||=
name|BitRight
argument_list|(
name|bits
argument_list|,
name|rightShift
argument_list|)
expr_stmt|;
operator|*
name|pdst
operator|=
name|MROP_MASK
argument_list|(
name|bits1
argument_list|,
operator|*
name|pdst
argument_list|,
name|startmask
argument_list|)
expr_stmt|;
name|pdst
operator|++
expr_stmt|;
block|}
name|nlTemp
operator|=
name|nlMiddle
expr_stmt|;
while|while
condition|(
name|nlTemp
condition|)
block|{
name|nl
operator|=
name|nlTemp
expr_stmt|;
if|if
condition|(
name|nl
operator|>
name|srcRemaining
condition|)
name|nl
operator|=
name|srcRemaining
expr_stmt|;
name|nlTemp
operator|-=
name|nl
expr_stmt|;
name|srcRemaining
operator|-=
name|nl
expr_stmt|;
if|#
directive|if
name|MROP
operator|==
name|Mcopy
ifdef|#
directive|ifdef
name|LARGE_INSTRUCTION_CACHE
name|bits1
operator|=
name|bits
expr_stmt|;
ifdef|#
directive|ifdef
name|FAST_CONSTANT_OFFSET_MODE
name|psrc
operator|+=
name|nl
operator|&
operator|(
name|UNROLL
operator|-
literal|1
operator|)
expr_stmt|;
name|pdst
operator|+=
name|nl
operator|&
operator|(
name|UNROLL
operator|-
literal|1
operator|)
expr_stmt|;
define|#
directive|define
name|BodyOdd
parameter_list|(
name|n
parameter_list|)
define|\
value|bits = psrc[-n]; \ pdst[-n] = MROP_SOLID(BitLeft(bits1, leftShift) | BitRight(bits, rightShift), pdst[-n]);
define|#
directive|define
name|BodyEven
parameter_list|(
name|n
parameter_list|)
define|\
value|bits1 = psrc[-n]; \ pdst[-n] = MROP_SOLID(BitLeft(bits, leftShift) | BitRight(bits1, rightShift), pdst[-n]);
define|#
directive|define
name|LoopReset
define|\
value|pdst += UNROLL; \ psrc += UNROLL;
else|#
directive|else
define|#
directive|define
name|BodyOdd
parameter_list|(
name|n
parameter_list|)
define|\
value|bits = *psrc++; \ *pdst = MROP_SOLID(BitLeft(bits1, leftShift) | BitRight(bits, rightShift), *pdst); \ pdst++;
define|#
directive|define
name|BodyEven
parameter_list|(
name|n
parameter_list|)
define|\
value|bits1 = *psrc++; \ *pdst = MROP_SOLID(BitLeft(bits, leftShift) | BitRight(bits1, rightShift), *pdst); \ pdst++;
define|#
directive|define
name|LoopReset
value|;
endif|#
directive|endif
comment|/* !FAST_CONSTANT_OFFSET_MODE */
name|PackedLoop
undef|#
directive|undef
name|BodyOdd
undef|#
directive|undef
name|BodyEven
undef|#
directive|undef
name|LoopReset
else|#
directive|else
name|DuffL
argument_list|(
name|nl
argument_list|,
name|label2
argument_list|,
name|bits1
operator|=
name|BitLeft
argument_list|(
name|bits
argument_list|,
name|leftShift
argument_list|)
argument_list|;
name|bits
operator|=
operator|*
name|psrc
operator|++
argument_list|;
operator|*
name|pdst
operator|=
name|MROP_SOLID
argument_list|(
name|bits1
operator||
name|BitRight
argument_list|(
name|bits
argument_list|,
name|rightShift
argument_list|)
argument_list|,
operator|*
name|pdst
argument_list|)
argument_list|;
name|pdst
operator|++
argument_list|; 		)
endif|#
directive|endif
else|#
directive|else
decl|while
argument_list|(
name|nl
operator|--
argument_list|)
block|{
name|bits1
operator|=
name|BitLeft
argument_list|(
name|bits
argument_list|,
name|leftShift
argument_list|)
expr_stmt|;
name|bits
operator|=
operator|*
name|psrc
operator|++
expr_stmt|;
operator|*
name|pdst
operator|=
name|MROP_SOLID
argument_list|(
name|bits1
operator||
name|BitRight
argument_list|(
name|bits
argument_list|,
name|rightShift
argument_list|)
argument_list|,
operator|*
name|pdst
argument_list|)
expr_stmt|;
name|pdst
operator|++
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|!
name|srcRemaining
condition|)
block|{
name|srcRemaining
operator|=
name|widthSrc
expr_stmt|;
name|psrc
operator|=
name|psrcStart
expr_stmt|;
block|}
block|}
if|if
condition|(
name|endmask
condition|)
block|{
name|bits1
operator|=
name|BitLeft
argument_list|(
name|bits
argument_list|,
name|leftShift
argument_list|)
expr_stmt|;
if|if
condition|(
name|BitLeft
argument_list|(
name|endmask
argument_list|,
name|rightShift
argument_list|)
condition|)
block|{
name|bits
operator|=
operator|*
name|psrc
expr_stmt|;
name|bits1
operator||=
name|BitRight
argument_list|(
name|bits
argument_list|,
name|rightShift
argument_list|)
expr_stmt|;
block|}
operator|*
name|pdst
operator|=
name|MROP_MASK
argument_list|(
name|bits1
argument_list|,
operator|*
name|pdst
argument_list|,
name|endmask
argument_list|)
expr_stmt|;
block|}
block|}
name|ppt
operator|++
expr_stmt|;
block|}
end_block

unit|}
end_unit

