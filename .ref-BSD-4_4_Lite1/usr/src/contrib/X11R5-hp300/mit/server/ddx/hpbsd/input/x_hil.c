begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $Header: /host/debretts/disk2/X11R5/R5-hp300/mit/server/ddx/hpbsd/input/RCS/x_hil.c,v 1.2 1993/04/21 21:41:28 root Exp $ */
end_comment

begin_comment
comment|/******************************************************************* ** **    ********************************************************* **    * **    *  File:          ddx/hp/hp/x_hil.c **    * **    *  Contents:      Input event procedures for the  **    *                 X/Starbase Merged Server **    * **    *  Created:       4/28/88 **    * **    *  Last Change:   12/05/88 **    * **    *  Last Release:  IC2 **    * **    *  Revision:      A.01.00 **    * **    *  Author:        --gms **    * **    *  Copyright:     (c) 1988 Hewlett-Packard Company **    * **    ********************************************************* **  ********************************************************************/
end_comment

begin_comment
comment|/********************************************************  Copyright (c) 1988 by Hewlett-Packard Company Copyright (c) 1988 by the Massachusetts Institute of Technology  Permission to use, copy, modify, and distribute this software  and its documentation for any purpose and without fee is hereby  granted, provided that the above copyright notice appear in all  copies and that both that copyright notice and this permission  notice appear in supporting documentation, and that the names of  Hewlett-Packard or  M.I.T.  not be used in advertising or publicity  pertaining to distribution of the software without specific, written  prior permission.  ********************************************************/
end_comment

begin_include
include|#
directive|include
file|"stdio.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|hp9000
end_ifndef

begin_ifndef
ifndef|#
directive|ifndef
name|__apollo
end_ifndef

begin_include
include|#
directive|include
file|"termio.h"
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|"/sys5/usr/include/sys/termio.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __apollo */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|NEED_EVENTS
end_define

begin_include
include|#
directive|include
file|"X.h"
end_include

begin_include
include|#
directive|include
file|"Xproto.h"
end_include

begin_include
include|#
directive|include
file|"hildef.h"
end_include

begin_include
include|#
directive|include
file|"hppriv.h"
end_include

begin_include
include|#
directive|include
file|"windowstr.h"
end_include

begin_include
include|#
directive|include
file|"XHPproto.h"
end_include

begin_include
include|#
directive|include
file|"x_hil.h"
end_include

begin_include
include|#
directive|include
file|"x_serialdrv.h"
end_include

begin_include
include|#
directive|include
file|"hpkeys.h"
end_include

begin_include
include|#
directive|include
file|"inputstr.h"
end_include

begin_include
include|#
directive|include
file|"../../../os/osdep.h"
end_include

begin_include
include|#
directive|include
file|<sys/times.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__apollo
end_ifdef

begin_include
include|#
directive|include
file|"../apollo/xshscreenpriv.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __apollo */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__hp_osf
end_ifdef

begin_include
include|#
directive|include
file|<hp/hilioctl.h>
end_include

begin_decl_stmt
specifier|extern
name|HILQ
modifier|*
name|hil_qp
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __hp_osf */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__hpux
end_ifdef

begin_include
include|#
directive|include
file|<sys/hilioctl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __hpux */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|hp9000
end_ifdef

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<hilioctl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_define
define|#
directive|define
name|FIRST_EXTENSION_EVENT
value|64
end_define

begin_define
define|#
directive|define
name|MIN_KEYCODE
value|8
end_define

begin_define
define|#
directive|define
name|REPEAT_ARROW
value|0x2
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|XTESTEXT1
end_ifdef

begin_comment
comment|/*  * defined in xtestext1di.c  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|on_steal_input
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|exclusive_steal
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* XTESTEXT1 */
end_comment

begin_comment
comment|/******************************************************************  *  * Externs and variables referenced from other files.  *  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|num_serial_devices
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|SerialProcs
name|serialprocs
index|[]
decl_stmt|;
end_decl_stmt

begin_function_decl
name|xEvent
modifier|*
name|format_ev
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|xHPEvent
name|xE
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|XINPUT
end_ifdef

begin_decl_stmt
specifier|extern
name|int
name|DeviceMotionNotify
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|DeviceKeyPress
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|DeviceKeyRelease
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|DeviceButtonPress
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|DeviceButtonRelease
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|DeviceValuator
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|ProximityIn
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|ProximityOut
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* XINPUT */
end_comment

begin_decl_stmt
name|int
modifier|*
name|dheadmotionBuf
index|[
name|MAX_LOGICAL_DEVS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|dpmotionBuf
index|[
name|MAX_LOGICAL_DEVS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|axes_changed
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|keyboard_click
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|screenIsSaved
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|lastEventTime
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|x_axis
decl_stmt|,
name|y_axis
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|inputs_selected
name|valid_inputs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|HPInputDevice
name|l_devs
index|[
name|MAX_LOGICAL_DEVS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|HPInputDevice
modifier|*
name|hpKeyboard
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|HPInputDevice
modifier|*
name|hpPointer
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|HPInputDevice
modifier|*
name|hptablet_extension
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|WindowPtr
modifier|*
name|WindowTable
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|InputInfo
name|inputInfo
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|DeviceIntPtr
name|screen_change_dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|DeviceIntPtr
name|tablet_extension_device
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|unsigned
name|tablet_xorg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|unsigned
name|tablet_yorg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|unsigned
name|tablet_xlimit
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|unsigned
name|tablet_ylimit
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|u_int
name|tablet_width
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Bool
name|in_tablet_extension
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_char
name|pointer_amt_bits
index|[
literal|3
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_char
name|ptr_mods
decl_stmt|,
name|mv_mods
decl_stmt|,
name|rs_mods
decl_stmt|,
name|bw_mods
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_char
name|buf
index|[
name|BUF_SIZ
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_char
modifier|*
name|pkt_ptr
init|=
name|buf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Bool
name|screen_was_changed
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Bool
name|reset_enabled
init|=
name|TRUE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|hpActiveScreen
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* active screen ndx (Zaphod) */
end_comment

begin_decl_stmt
name|int
name|queue_events_free
init|=
name|MAX_EVENTS
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|data_cnt
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|data_fd
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|pending_index
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|pending_bytes
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|acceleration
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|threshold
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|x11EventQueue
modifier|*
name|events_queue
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pointer to events queue.  */
end_comment

begin_function_decl
name|xHPEvent
modifier|*
name|allocate_event
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|dev_info
name|hil_info
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* holds hil_data */
end_comment

begin_decl_stmt
name|Bool
name|display_borrowed
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|XINPUT
end_ifdef

begin_function_decl
name|DeviceIntPtr
name|LookupDeviceIntRec
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* XINPUT */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__hp9000s800
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__hp9000s700
argument_list|)
end_if

begin_decl_stmt
name|unsigned
name|long
name|timediff
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Bool
name|time_set
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __hp9000s800 */
end_comment

begin_comment
comment|/******************************************************************  *  * Variables global to this file.  *  */
end_comment

begin_function_decl
specifier|static
name|DeviceIntPtr
name|find_deviceintrec
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|process_inputs
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|process_hil_data
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|process_serial_data
parameter_list|()
function_decl|;
end_function_decl

begin_expr_stmt
specifier|static
name|check_subset_and_scale
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|move_sprite
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|send_motion
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|send_button
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|move_mouse
argument_list|()
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|u_char
name|last_direction
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_char
name|last_key
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_char
name|last_arrow
init|=
name|REPEAT_ARROW
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*keycode of arrow key pressed last */
end_comment

begin_decl_stmt
specifier|static
name|int
name|k_down_flag
index|[
literal|4
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|k_down_incx
index|[
literal|4
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|k_down_incy
index|[
literal|4
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/****************************************************************************  *  * Process all available data from the input devices and put it on the server's  * internal events queue.  When this routine is invoked, that queue is empty   * since the server empties it each time through its main dispatch loop.  *   * The server's internal queue can hold 256 events.  If the server is busy for  * a long time, it is possible for the queue to fill up.  In that case we   * can return with unread data, or data that is left in a global buffer.  * This routine must be prepared to handle such leftover data.  *  * After handling leftovers, this routine finds a file descriptor with data  * ready to be read and calls process_inputs to handle it.  *  */
end_comment

begin_macro
name|store_inputs
argument_list|(
argument|ready_inputs
argument_list|)
end_macro

begin_decl_stmt
name|long
name|ready_inputs
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
name|int
name|checkfd
init|=
name|valid_inputs
operator|.
name|max_fd
decl_stmt|;
comment|/* max fd valid for input*/
name|int
name|checkword
init|=
name|MASKIDX
argument_list|(
name|checkfd
argument_list|)
decl_stmt|;
comment|/* max valid word of mask*/
name|long
name|mask
index|[
name|mskcnt
index|]
decl_stmt|;
name|long
name|checkmask
index|[
name|mskcnt
index|]
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__hp9000s800
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__hp9000s700
argument_list|)
comment|/* building for s800 */
name|struct
name|tms
name|buffer
decl_stmt|;
name|int
name|newtime
decl_stmt|;
name|struct
name|timeval
name|tv
decl_stmt|,
name|get_tv
argument_list|()
decl_stmt|;
comment|/**********************************************************************      *      * On s800 machines, the time reported in HIL events has its origin at      * the time of machine power-up.  The time reported by gettimeofday(),      * which will be called by UpdateCurrentTime when a grab is done, always      * has its origin at Jan. 1, 1970.  On s800s, we must compute a difference      * to be added to the HIL times to keep the two in sync.  We must also      * check each time via get_tv (PA-RISC fast gettimeofday) to see if the      * time reported by gettimeofday has been changed via the date() command.      * If so, our time difference is invalid and must be recalculated.      */
name|tv
operator|=
name|get_tv
argument_list|()
expr_stmt|;
name|newtime
operator|=
operator|(
name|tv
operator|.
name|tv_sec
operator|*
literal|1000
operator|)
operator|+
operator|(
name|tv
operator|.
name|tv_usec
operator|/
literal|1000
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|time_set
operator|||
name|newtime
operator|<
name|lastEventTime
condition|)
block|{
name|time_set
operator|=
literal|1
expr_stmt|;
name|lastEventTime
operator|=
name|GetTimeInMillis
argument_list|()
expr_stmt|;
name|timediff
operator|=
name|lastEventTime
operator|-
operator|(
name|times
argument_list|(
operator|&
name|buffer
argument_list|)
operator|*
literal|10
operator|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* __hp9000s800 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mskcnt
condition|;
name|i
operator|++
control|)
name|checkmask
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|data_cnt
operator|>
literal|0
condition|)
comment|/* we have leftover data*/
block|{
name|process_inputs
argument_list|(
name|data_fd
argument_list|)
expr_stmt|;
comment|/* go process it	*/
block|}
name|MASKANDSETBITS
argument_list|(
name|mask
argument_list|,
name|ready_inputs
argument_list|,
name|valid_inputs
operator|.
name|input_mask
argument_list|)
expr_stmt|;
name|BITSET
argument_list|(
name|checkmask
argument_list|,
name|checkfd
argument_list|)
expr_stmt|;
comment|/* corresponding mask	*/
for|for
control|(
name|i
operator|=
name|checkword
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
comment|/* for all mask words   */
block|{
while|while
condition|(
name|mask
index|[
name|i
index|]
condition|)
comment|/* while input available*/
block|{
if|if
condition|(
name|mask
index|[
name|i
index|]
operator|&
name|checkmask
index|[
name|i
index|]
condition|)
comment|/* if current fd valid  */
block|{
name|mask
index|[
name|i
index|]
operator|&=
operator|~
name|checkmask
index|[
name|i
index|]
expr_stmt|;
name|process_inputs
argument_list|(
name|checkfd
argument_list|)
expr_stmt|;
comment|/* process its input	*/
block|}
name|checkfd
operator|--
expr_stmt|;
name|checkmask
index|[
name|i
index|]
operator|=
name|checkmask
index|[
name|i
index|]
operator|>>
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|checkfd
operator|=
operator|(
name|i
operator|-
literal|1
operator|)
operator|*
literal|32
operator|+
literal|31
expr_stmt|;
name|BITSET
argument_list|(
name|checkmask
argument_list|,
name|checkfd
argument_list|)
expr_stmt|;
comment|/* corresponding mask	*/
block|}
block|}
block|}
end_block

begin_comment
comment|/****************************************************************************  *  * Find the device data structure that matches the file descriptor from which  * data will be read.  Read up to 2000 bytes (HIL driver buffer is only 512)  * from that file descriptor.  From the data read, get 1 HIL data packet.  * That packet may contain up to 8 keycodes and 1 motion event.  In the case  * of a barcode reader in ASCII mode, each keycode may generate up to 6  * X input events.  The worst case is therefore 49 X events from 1 HIL data  * packet.  *  */
end_comment

begin_define
define|#
directive|define
name|TIME_POLL_BYTES
value|5
end_define

begin_comment
comment|/* bytes indicating time and poll*/
end_comment

begin_function
specifier|static
name|int
name|process_inputs
parameter_list|(
name|file_ds
parameter_list|)
name|int
name|file_ds
decl_stmt|;
comment|/* file_ds to read from      	 */
block|{
name|int
name|i
decl_stmt|;
name|u_char
modifier|*
name|hil_ptr
decl_stmt|;
name|HPInputDevice
modifier|*
name|indevice
init|=
name|NULL
decl_stmt|;
name|DeviceIntPtr
name|dev
decl_stmt|;
name|xHPEvent
modifier|*
name|xHP
decl_stmt|;
name|Bool
name|done
init|=
name|FALSE
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_LOGICAL_DEVS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|file_ds
operator|==
name|l_devs
index|[
name|i
index|]
operator|.
name|file_ds
condition|)
block|{
name|indevice
operator|=
operator|&
operator|(
name|l_devs
index|[
name|i
index|]
operator|)
expr_stmt|;
break|break;
block|}
block|}
name|dev
operator|=
name|find_deviceintrec
argument_list|(
name|indevice
argument_list|)
expr_stmt|;
if|if
condition|(
name|data_cnt
operator|==
literal|0
operator|&&
comment|/* no leftover data	    */
operator|!
operator|(
name|indevice
operator|->
name|hpflags
operator|&
name|IS_SERIAL_DEVICE
operator|)
condition|)
block|{
name|pkt_ptr
operator|=
name|buf
expr_stmt|;
name|data_cnt
operator|=
name|read
argument_list|(
name|file_ds
argument_list|,
name|buf
argument_list|,
name|READ_SIZ
argument_list|)
expr_stmt|;
comment|/* We get here with nothing actually to read after a SIGHUP  	   so ignore it */
if|if
condition|(
name|data_cnt
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|==
name|EWOULDBLOCK
condition|)
block|{
name|data_cnt
operator|=
literal|0
expr_stmt|;
return|return;
block|}
block|}
while|while
condition|(
name|data_cnt
operator|>
literal|0
operator|||
comment|/* data yet to be processed */
operator|(
name|indevice
operator|->
name|hpflags
operator|&
name|IS_SERIAL_DEVICE
operator|&&
operator|!
name|done
operator|)
condition|)
block|{
if|if
condition|(
name|queue_events_free
operator|<=
name|MAXHILEVENTS
condition|)
comment|/* no room on server queue  */
block|{
if|if
condition|(
name|data_fd
operator|==
operator|-
literal|1
condition|)
name|data_fd
operator|=
name|file_ds
expr_stmt|;
comment|/* save the file descriptor */
return|return;
block|}
name|hil_ptr
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|hil_info
expr_stmt|;
comment|/* place to copy packet to*/
if|if
condition|(
name|indevice
operator|->
name|hpflags
operator|&
name|IS_SERIAL_DEVICE
condition|)
block|{
name|done
operator|=
name|get_serial_event
argument_list|(
name|hil_ptr
argument_list|)
expr_stmt|;
name|process_serial_data
argument_list|(
name|dev
argument_list|,
name|indevice
argument_list|,
operator|&
operator|(
name|hil_info
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|get_hil_event
argument_list|(
name|file_ds
argument_list|,
name|hil_ptr
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__hp9000s800
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__hp9000s700
argument_list|)
comment|/* building for s800 */
name|hil_info
operator|.
name|timestamp
operator|+=
name|timediff
expr_stmt|;
endif|#
directive|endif
comment|/* __hp9000s800 */
name|process_hil_data
argument_list|(
name|dev
argument_list|,
name|indevice
argument_list|,
operator|&
operator|(
name|hil_info
operator|)
argument_list|)
expr_stmt|;
block|}
name|lastEventTime
operator|=
name|hil_info
operator|.
name|timestamp
expr_stmt|;
comment|/* Used by ScreenSaver  */
block|}
name|data_fd
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|xE
operator|.
name|b
operator|.
name|u
operator|.
name|u
operator|.
name|type
operator|!=
literal|0
condition|)
comment|/* at least 1 motion event */
block|{
name|xHP
operator|=
name|allocate_event
argument_list|()
expr_stmt|;
comment|/* get current queue pointer*/
operator|*
name|xHP
operator|=
name|xE
expr_stmt|;
comment|/* copy from global struct  */
name|xE
operator|.
name|b
operator|.
name|u
operator|.
name|u
operator|.
name|type
operator|=
literal|0
expr_stmt|;
comment|/* mark it as processed	    */
block|}
block|}
end_function

begin_comment
comment|/***************************************************************************  *  * Given the HP device structure, find the DIX device structure that  * logically corresponds to it.  There is a one-to-one correspondence,  * expect when the keyboard is also the X pointer, a tablet is subsetted,  * or an input device is merged with the X pointer or X keyboard.  *  * Callers: process_inputs(), read_shmhil().  *  */
end_comment

begin_function
specifier|static
name|DeviceIntPtr
name|find_deviceintrec
parameter_list|(
name|indevice
parameter_list|)
name|HPInputDevice
modifier|*
name|indevice
decl_stmt|;
block|{
name|PtrFeedbackPtr
name|p
decl_stmt|;
name|DeviceIntPtr
name|dev
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|indevice
operator|!=
name|NULL
condition|)
block|{
name|hil_info
operator|.
name|hil_dev
operator|=
name|indevice
expr_stmt|;
comment|/* input device struct ptr  */
if|if
condition|(
name|hptablet_extension
operator|&&
name|indevice
operator|->
name|file_ds
operator|==
name|hptablet_extension
operator|->
name|file_ds
operator|&&
name|in_tablet_extension
condition|)
block|{
name|hil_info
operator|.
name|hil_dev
operator|=
name|hptablet_extension
expr_stmt|;
name|dev
operator|=
name|tablet_extension_device
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|indevice
operator|==
name|hpKeyboard
operator|||
operator|(
name|indevice
operator|->
name|x_type
operator|==
name|KEYBOARD
operator|&&
operator|(
name|indevice
operator|->
name|hpflags
operator|&
name|MERGED_DEVICE
operator|)
operator|)
condition|)
name|dev
operator|=
name|inputInfo
operator|.
name|keyboard
expr_stmt|;
elseif|else
if|if
condition|(
name|indevice
operator|==
name|hpPointer
operator|||
operator|(
name|indevice
operator|->
name|x_type
operator|==
name|MOUSE
operator|&&
operator|(
name|indevice
operator|->
name|hpflags
operator|&
name|MERGED_DEVICE
operator|)
operator|)
condition|)
name|dev
operator|=
name|inputInfo
operator|.
name|pointer
expr_stmt|;
ifdef|#
directive|ifdef
name|XINPUT
else|else
name|dev
operator|=
name|LookupDeviceIntRec
argument_list|(
name|indevice
operator|->
name|dev_id
argument_list|)
expr_stmt|;
name|p
operator|=
name|dev
operator|->
name|ptrfeed
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
name|threshold
operator|=
name|p
operator|->
name|ctrl
operator|.
name|threshold
expr_stmt|;
name|acceleration
operator|=
name|p
operator|->
name|ctrl
operator|.
name|num
operator|/
name|p
operator|->
name|ctrl
operator|.
name|den
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* XINPUT */
if|if
condition|(
name|acceleration
operator|==
literal|0
condition|)
name|acceleration
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|FatalError
argument_list|(
literal|"X server couldn't find current input device - Aborting.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|dev
operator|)
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************  *  * Get one HIL data packet from the data that was previously read.  * If the buffer only contains a partial packet, read the rest.  *  * This function may also be called from x_threebut.c.  *  */
end_comment

begin_macro
name|get_hil_event
argument_list|(
argument|fd
argument_list|,
argument|dest
argument_list|)
end_macro

begin_decl_stmt
name|int
name|fd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|dest
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|packet_size
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|dev_info
modifier|*
name|info
init|=
operator|(
expr|struct
name|dev_info
operator|*
operator|)
name|dest
decl_stmt|;
name|packet_size
operator|=
operator|*
name|pkt_ptr
operator|++
expr_stmt|;
comment|/* 1st byte is size	    */
if|if
condition|(
name|data_cnt
operator|<
name|packet_size
condition|)
comment|/* We got a partial packet  */
block|{
name|data_cnt
operator|+=
name|read
argument_list|(
name|fd
argument_list|,
comment|/* get rest of packet */
name|pkt_ptr
operator|+
name|data_cnt
argument_list|,
name|packet_size
operator|-
name|data_cnt
argument_list|)
expr_stmt|;
if|if
condition|(
name|data_cnt
operator|!=
name|packet_size
condition|)
name|FatalError
argument_list|(
literal|"Unable to read all of an HIL data packet.  Server exiting! \n"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|packet_size
condition|;
name|i
operator|++
control|)
comment|/* copy the current packet  */
operator|*
name|dest
operator|++
operator|=
operator|*
name|pkt_ptr
operator|++
expr_stmt|;
name|info
operator|->
name|timestamp
operator|=
operator|(
name|info
operator|->
name|timestamp
operator|-
literal|1
operator|)
operator|*
literal|10
expr_stmt|;
name|info
operator|->
name|poll_hdr
operator|&=
name|HIL_POLL_HDR_BITS
expr_stmt|;
comment|/* zero nonsignifcant bits  */
name|data_cnt
operator|-=
name|packet_size
expr_stmt|;
comment|/* fix unprocessed data cnt */
name|pending_index
operator|=
literal|0
expr_stmt|;
name|pending_bytes
operator|=
name|packet_size
operator|-
literal|1
operator|-
name|TIME_POLL_BYTES
expr_stmt|;
block|}
end_block

begin_comment
comment|/****************************************************************************  *  * process the HIL data packet and generate X input events as needed.  *  */
end_comment

begin_define
define|#
directive|define
name|UP_LEFT_ARROW
value|0xf8
end_define

begin_comment
comment|/* HIL key codes for arrow keys. */
end_comment

begin_define
define|#
directive|define
name|DOWN_LEFT_ARROW
value|0xf9
end_define

begin_define
define|#
directive|define
name|UP_DOWN_ARROW
value|0xfa
end_define

begin_define
define|#
directive|define
name|DOWN_DOWN_ARROW
value|0xfb
end_define

begin_define
define|#
directive|define
name|UP_UP_ARROW
value|0xfc
end_define

begin_define
define|#
directive|define
name|DOWN_UP_ARROW
value|0xfd
end_define

begin_define
define|#
directive|define
name|UP_RIGHT_ARROW
value|0xfe
end_define

begin_define
define|#
directive|define
name|DOWN_RIGHT_ARROW
value|0xff
end_define

begin_define
define|#
directive|define
name|HIL_PROXIMITY
value|0x4f
end_define

begin_decl_stmt
specifier|static
name|u_char
name|code
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|process_hil_data
parameter_list|(
name|dev
parameter_list|,
name|phys
parameter_list|,
name|info
parameter_list|)
name|DeviceIntPtr
name|dev
decl_stmt|;
name|HPInputDevice
modifier|*
name|phys
decl_stmt|;
name|struct
name|dev_info
modifier|*
name|info
decl_stmt|;
block|{
name|xEvent
modifier|*
name|ev
decl_stmt|;
name|int
name|count
decl_stmt|;
name|u_char
name|type
decl_stmt|,
name|keyset
decl_stmt|,
name|kcode
decl_stmt|,
name|bcode
decl_stmt|,
modifier|*
name|hil_code
decl_stmt|;
name|struct
name|hil_desc_record
modifier|*
name|h
init|=
operator|&
name|phys
operator|->
name|hil_header
decl_stmt|;
while|while
condition|(
name|pending_index
operator|<
name|pending_bytes
condition|)
block|{
if|if
condition|(
name|info
operator|->
name|poll_hdr
operator|&
name|MOTION_MASK
condition|)
block|{
name|handle_motion_event
argument_list|(
name|dev
argument_list|,
name|phys
argument_list|,
name|info
argument_list|)
expr_stmt|;
name|info
operator|->
name|poll_hdr
operator|&=
operator|~
name|MOTION_MASK
expr_stmt|;
block|}
if|if
condition|(
name|info
operator|->
name|poll_hdr
operator|&
name|KEY_DATA_MASK
condition|)
block|{
name|keyset
operator|=
name|info
operator|->
name|poll_hdr
operator|&
name|HILPRH_KEYSET
expr_stmt|;
name|hil_code
operator|=
name|code
expr_stmt|;
if|if
condition|(
name|phys
operator|->
name|hpflags
operator|&
name|DATA_IS_8_BITS
condition|)
operator|*
name|hil_code
operator|=
operator|(
name|info
operator|->
name|dev_data
operator|)
index|[
name|pending_index
operator|++
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|phys
operator|->
name|hpflags
operator|&
name|DATA_IS_16_BITS
condition|)
block|{
operator|*
name|hil_code
operator|=
operator|(
operator|(
name|info
operator|->
name|dev_data
operator|)
index|[
name|pending_index
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
name|info
operator|->
name|dev_data
operator|)
index|[
name|pending_index
operator|+
literal|1
index|]
expr_stmt|;
name|pending_index
operator|+=
literal|2
expr_stmt|;
block|}
comment|/* Check if cursor keys are repeating. */
switch|switch
condition|(
operator|*
name|hil_code
condition|)
block|{
case|case
name|DOWN_DOWN_ARROW
case|:
case|case
name|UP_DOWN_ARROW
case|:
case|case
name|UP_LEFT_ARROW
case|:
case|case
name|DOWN_LEFT_ARROW
case|:
case|case
name|UP_RIGHT_ARROW
case|:
case|case
name|DOWN_RIGHT_ARROW
case|:
case|case
name|UP_UP_ARROW
case|:
case|case
name|DOWN_UP_ARROW
case|:
name|last_arrow
operator|=
operator|*
name|hil_code
expr_stmt|;
break|break;
case|case
name|REPEAT_ARROW
case|:
if|if
condition|(
operator|(
name|keyset
operator|==
name|HILPRH_KEYSET1
operator|)
operator|&&
name|last_arrow
operator|!=
name|REPEAT_ARROW
condition|)
operator|*
name|hil_code
operator|=
name|last_arrow
expr_stmt|;
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|phys
operator|->
name|dev_type
operator|==
name|BARCODE
condition|)
name|hil_code
operator|=
name|ascii_to_code
index|[
operator|*
name|hil_code
index|]
expr_stmt|;
for|for
control|(
name|count
operator|=
literal|0
init|;
operator|(
name|count
operator|==
literal|0
operator|||
operator|*
name|hil_code
operator|!=
literal|0
operator|)
condition|;
name|count
operator|++
control|)
block|{
ifdef|#
directive|ifdef
name|XINPUT
comment|/* proximity HIL codes cause a different event type. 		   However, proximity is not reported for devices being 		   used as the X pointer, unless they have no buttons 		   (like a touchscreen), in which case the proximity is 		   treated as button 1. 		   */
name|kcode
operator|=
operator|(
operator|(
name|u_char
operator|)
operator|*
name|hil_code
operator|)
operator|>>
literal|1
expr_stmt|;
comment|/* same code up& down*/
name|kcode
operator|+=
name|MIN_KEYCODE
expr_stmt|;
comment|/* avoid mouse codes. */
comment|/* Check to see if this is a "down" keycode for a key that is 		   already down.  If so, and autorepeat has been disabled for 		   this key, ignore the key and return. 		   */
if|if
condition|(
operator|!
operator|(
operator|*
name|hil_code
operator|%
literal|2
operator|)
operator|&&
name|KeyIsDown
argument_list|(
name|dev
argument_list|,
name|kcode
argument_list|)
operator|&&
operator|!
name|KeyIsRepeating
argument_list|(
name|dev
argument_list|,
name|kcode
argument_list|)
condition|)
return|return;
name|bcode
operator|=
operator|*
operator|(
name|hil_code
operator|++
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|h
operator|->
name|iob
operator|&
name|HILIOB_PIO
operator|)
operator|&&
name|kcode
operator|==
name|HIL_PROXIMITY
condition|)
if|if
condition|(
name|dev
operator|!=
name|inputInfo
operator|.
name|pointer
condition|)
block|{
name|type
operator|=
operator|(
name|bcode
operator|&
name|UP_MASK
operator|)
condition|?
name|ProximityOut
else|:
name|ProximityIn
expr_stmt|;
name|ev
operator|=
name|format_ev
argument_list|(
name|type
argument_list|,
literal|0
argument_list|,
name|info
operator|->
name|timestamp
argument_list|,
name|phys
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|h
operator|->
name|p_button_count
operator|==
literal|0
condition|)
name|bcode
operator|-=
literal|0x0e
expr_stmt|;
comment|/* make it button 1 */
else|else
return|return;
comment|/* proximity not reported for X pointer */
endif|#
directive|endif
comment|/* XINPUT */
if|if
condition|(
name|bcode
operator|>=
name|BUTTON_BASE
operator|&&
name|bcode
operator|<
name|PROXIMITY_IN
condition|)
block|{
if|if
condition|(
name|phys
operator|==
name|hptablet_extension
operator|&&
name|phys
operator|->
name|open_cnt
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|dev
operator|==
name|inputInfo
operator|.
name|pointer
condition|)
if|if
condition|(
name|bcode
operator|&
name|UP_MASK
condition|)
name|type
operator|=
name|ButtonRelease
expr_stmt|;
else|else
name|type
operator|=
name|ButtonPress
expr_stmt|;
elseif|else
if|if
condition|(
name|bcode
operator|&
name|UP_MASK
condition|)
name|type
operator|=
name|DeviceButtonRelease
expr_stmt|;
else|else
name|type
operator|=
name|DeviceButtonPress
expr_stmt|;
name|ev
operator|=
name|format_ev
argument_list|(
name|type
argument_list|,
name|kcode
argument_list|,
name|info
operator|->
name|timestamp
argument_list|,
name|phys
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|process_button
argument_list|(
name|ev
argument_list|,
name|dev
argument_list|,
name|info
argument_list|,
name|bcode
argument_list|,
name|h
operator|->
name|p_button_count
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|dev
operator|==
name|inputInfo
operator|.
name|keyboard
condition|)
if|if
condition|(
name|bcode
operator|&
name|UP_MASK
condition|)
name|type
operator|=
name|KeyRelease
expr_stmt|;
else|else
name|type
operator|=
name|KeyPress
expr_stmt|;
elseif|else
if|if
condition|(
name|bcode
operator|&
name|UP_MASK
condition|)
name|type
operator|=
name|DeviceKeyRelease
expr_stmt|;
else|else
name|type
operator|=
name|DeviceKeyPress
expr_stmt|;
name|ev
operator|=
name|format_ev
argument_list|(
name|type
argument_list|,
name|kcode
argument_list|,
name|info
operator|->
name|timestamp
argument_list|,
name|phys
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|parse_keycode
argument_list|(
name|dev
argument_list|,
name|phys
argument_list|,
name|ev
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/****************************************************************************  *  * process the serial data packet and generate X input events as needed.  *  */
end_comment

begin_decl_stmt
specifier|static
name|u_int
name|s_code
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|process_serial_data
parameter_list|(
name|dev
parameter_list|,
name|phys
parameter_list|,
name|info
parameter_list|)
name|DeviceIntPtr
name|dev
decl_stmt|;
name|HPInputDevice
modifier|*
name|phys
decl_stmt|;
name|struct
name|dev_info
modifier|*
name|info
decl_stmt|;
block|{
name|xEvent
modifier|*
name|ev
decl_stmt|;
name|int
name|count
decl_stmt|;
name|u_int
modifier|*
name|hil_code
decl_stmt|;
name|u_char
name|type
decl_stmt|,
name|kcode
decl_stmt|;
name|int
name|button_count
init|=
name|phys
operator|->
name|hil_header
operator|.
name|p_button_count
decl_stmt|;
while|while
condition|(
name|pending_index
operator|<
name|pending_bytes
condition|)
block|{
if|if
condition|(
name|info
operator|->
name|poll_hdr
operator|&
name|MOTION_DATA
condition|)
block|{
name|handle_motion_event
argument_list|(
name|dev
argument_list|,
name|phys
argument_list|,
name|info
argument_list|)
expr_stmt|;
block|}
name|hil_code
operator|=
name|s_code
expr_stmt|;
if|if
condition|(
name|phys
operator|->
name|hpflags
operator|&
name|DATA_IS_8_BITS
condition|)
operator|*
name|hil_code
operator|=
operator|(
name|info
operator|->
name|dev_data
operator|)
index|[
name|pending_index
operator|++
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|phys
operator|->
name|hpflags
operator|&
name|DATA_IS_16_BITS
condition|)
block|{
operator|*
name|hil_code
operator|=
operator|(
operator|(
name|info
operator|->
name|dev_data
operator|)
index|[
name|pending_index
operator|+
literal|1
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
name|info
operator|->
name|dev_data
operator|)
index|[
name|pending_index
index|]
expr_stmt|;
name|pending_index
operator|+=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|phys
operator|->
name|hpflags
operator|&
name|DATA_IS_32_BITS
condition|)
block|{
operator|*
name|hil_code
operator|=
operator|(
operator|(
name|info
operator|->
name|dev_data
operator|)
index|[
name|pending_index
operator|+
literal|3
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
name|info
operator|->
name|dev_data
operator|)
index|[
name|pending_index
operator|+
literal|2
index|]
operator|<<
literal|16
operator||
operator|(
name|info
operator|->
name|dev_data
operator|)
index|[
name|pending_index
operator|+
literal|1
index|]
operator|<<
literal|8
operator||
operator|(
name|info
operator|->
name|dev_data
operator|)
index|[
name|pending_index
index|]
expr_stmt|;
name|pending_index
operator|+=
literal|4
expr_stmt|;
block|}
if|if
condition|(
name|info
operator|->
name|poll_hdr
operator|&
name|KEY_DATA
condition|)
block|{
comment|/* Check to see if this is a "down" keycode for a key that is 	       already down.  If so, and autorepeat has been disabled for 	       this key, ignore the key and return. 	       */
name|kcode
operator|=
call|(
name|u_char
call|)
argument_list|(
operator|*
name|hil_code
operator|>>
literal|1
argument_list|)
expr_stmt|;
comment|/* same code up& down */
if|if
condition|(
operator|*
name|hil_code
operator|&
name|UP_MASK
condition|)
if|if
condition|(
name|dev
operator|==
name|inputInfo
operator|.
name|keyboard
condition|)
name|type
operator|=
name|KeyRelease
expr_stmt|;
else|else
name|type
operator|=
name|DeviceKeyRelease
expr_stmt|;
else|else
block|{
if|if
condition|(
name|KeyIsDown
argument_list|(
name|dev
argument_list|,
name|kcode
argument_list|)
operator|&&
operator|!
name|KeyIsRepeating
argument_list|(
name|dev
argument_list|,
name|kcode
argument_list|)
condition|)
return|return;
if|if
condition|(
name|dev
operator|==
name|inputInfo
operator|.
name|keyboard
condition|)
name|type
operator|=
name|KeyPress
expr_stmt|;
else|else
name|type
operator|=
name|DeviceKeyPress
expr_stmt|;
block|}
name|ev
operator|=
name|format_ev
argument_list|(
name|type
argument_list|,
name|kcode
argument_list|,
name|info
operator|->
name|timestamp
argument_list|,
name|phys
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|parse_keycode
argument_list|(
name|dev
argument_list|,
name|phys
argument_list|,
name|ev
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|info
operator|->
name|poll_hdr
operator|&
name|BUTTON_DATA
condition|)
block|{
if|if
condition|(
operator|*
name|hil_code
operator|&
name|UP_MASK
condition|)
if|if
condition|(
name|dev
operator|==
name|inputInfo
operator|.
name|pointer
condition|)
name|type
operator|=
name|ButtonRelease
expr_stmt|;
else|else
name|type
operator|=
name|DeviceButtonRelease
expr_stmt|;
elseif|else
if|if
condition|(
name|dev
operator|==
name|inputInfo
operator|.
name|pointer
condition|)
name|type
operator|=
name|ButtonPress
expr_stmt|;
else|else
name|type
operator|=
name|DeviceButtonPress
expr_stmt|;
name|kcode
operator|=
operator|*
name|hil_code
operator|+
name|BUTTON_BASE
expr_stmt|;
if|if
condition|(
name|dev
operator|==
name|inputInfo
operator|.
name|pointer
operator|&&
name|kcode
operator|>
name|PROXIMITY_OUT
condition|)
return|return;
if|if
condition|(
name|phys
operator|==
name|hptablet_extension
operator|&&
name|phys
operator|->
name|open_cnt
operator|==
literal|0
condition|)
return|return;
name|ev
operator|=
name|format_ev
argument_list|(
name|type
argument_list|,
name|kcode
argument_list|,
name|info
operator|->
name|timestamp
argument_list|,
name|phys
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|process_button
argument_list|(
name|ev
argument_list|,
name|dev
argument_list|,
name|info
argument_list|,
name|kcode
argument_list|,
name|button_count
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|XINPUT
elseif|else
if|if
condition|(
name|info
operator|->
name|poll_hdr
operator|&
name|PROXIMITY_DATA
condition|)
block|{
comment|/* proximity HIL codes cause a different event type. 	       However, proximity is not reported for devices being 	       used as the X pointer, unless they have no buttons 	       (like a touchscreen), in which case the proximity is 	       treated as button 1. 	       */
if|if
condition|(
name|dev
operator|!=
name|inputInfo
operator|.
name|pointer
condition|)
block|{
name|type
operator|=
operator|(
operator|*
name|hil_code
operator|&
name|UP_MASK
operator|)
condition|?
name|ProximityOut
else|:
name|ProximityIn
expr_stmt|;
name|ev
operator|=
name|format_ev
argument_list|(
name|type
argument_list|,
literal|0
argument_list|,
name|info
operator|->
name|timestamp
argument_list|,
name|phys
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|button_count
operator|==
literal|0
condition|)
block|{
name|kcode
operator|=
literal|1
expr_stmt|;
comment|/* make it button 1 */
name|ev
operator|=
name|format_ev
argument_list|(
name|type
argument_list|,
name|kcode
argument_list|,
name|info
operator|->
name|timestamp
argument_list|,
name|phys
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|phys
operator|==
name|hptablet_extension
operator|&&
name|phys
operator|->
name|open_cnt
operator|==
literal|0
condition|)
return|return;
name|process_button
argument_list|(
name|ev
argument_list|,
name|dev
argument_list|,
name|info
argument_list|,
name|kcode
argument_list|,
name|button_count
argument_list|)
expr_stmt|;
block|}
else|else
return|return;
comment|/* proximity not reported for X pointer */
block|}
endif|#
directive|endif
comment|/* XINPUT */
block|}
block|}
end_function

begin_comment
comment|/*******************************************************************  *  * handle_motion_event()  *  */
end_comment

begin_macro
name|handle_motion_event
argument_list|(
argument|dev
argument_list|,
argument|phys
argument_list|,
argument|info
argument_list|)
end_macro

begin_decl_stmt
name|DeviceIntPtr
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|HPInputDevice
modifier|*
name|phys
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|dev_info
modifier|*
name|info
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|,
name|type
decl_stmt|,
name|bytes_coord
decl_stmt|;
name|int
name|tmp
decl_stmt|,
name|coords
index|[
name|MAX_AXES
index|]
decl_stmt|;
name|char
modifier|*
name|sdata
decl_stmt|;
name|u_char
modifier|*
name|udata
decl_stmt|;
name|HPInputDevice
modifier|*
name|log
decl_stmt|;
if|if
condition|(
name|dev
operator|==
name|inputInfo
operator|.
name|pointer
condition|)
block|{
name|type
operator|=
name|MotionNotify
expr_stmt|;
name|log
operator|=
name|hpPointer
expr_stmt|;
block|}
else|else
block|{
name|type
operator|=
name|DeviceMotionNotify
expr_stmt|;
name|log
operator|=
name|phys
expr_stmt|;
block|}
if|if
condition|(
name|phys
operator|->
name|hpflags
operator|&
name|DATA_IS_32_BITS
condition|)
name|bytes_coord
operator|=
literal|4
expr_stmt|;
elseif|else
if|if
condition|(
name|phys
operator|->
name|hpflags
operator|&
name|DATA_IS_16_BITS
condition|)
name|bytes_coord
operator|=
literal|2
expr_stmt|;
else|else
name|bytes_coord
operator|=
literal|1
expr_stmt|;
name|pending_index
operator|+=
name|phys
operator|->
name|hil_header
operator|.
name|ax_num
operator|*
name|bytes_coord
expr_stmt|;
if|if
condition|(
name|phys
operator|->
name|hil_header
operator|.
name|flags
operator|&
name|HIL_ABSOLUTE
condition|)
comment|/* absolute device */
block|{
name|udata
operator|=
name|info
operator|->
name|dev_data
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|u_char
operator|)
name|phys
operator|->
name|hil_header
operator|.
name|ax_num
condition|;
name|i
operator|++
operator|,
name|udata
operator|+=
name|bytes_coord
control|)
if|if
condition|(
name|bytes_coord
operator|==
literal|1
condition|)
name|coords
index|[
name|i
index|]
operator|=
operator|*
name|udata
expr_stmt|;
elseif|else
if|if
condition|(
name|bytes_coord
operator|==
literal|2
condition|)
name|coords
index|[
name|i
index|]
operator|=
operator|*
name|udata
operator||
operator|*
operator|(
name|udata
operator|+
literal|1
operator|)
operator|<<
literal|8
expr_stmt|;
elseif|else
if|if
condition|(
name|bytes_coord
operator|==
literal|4
condition|)
name|coords
index|[
name|i
index|]
operator|=
operator|*
name|udata
operator||
operator|(
operator|*
operator|(
name|udata
operator|+
literal|1
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
operator|*
operator|(
name|udata
operator|+
literal|2
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
operator|*
operator|(
name|udata
operator|+
literal|3
operator|)
operator|<<
literal|24
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|check_subset_and_scale
argument_list|(
operator|&
name|dev
argument_list|,
name|phys
argument_list|,
operator|&
name|log
argument_list|,
name|coords
argument_list|)
condition|)
return|return;
block|}
else|else
block|{
name|sdata
operator|=
operator|(
name|char
operator|*
operator|)
name|info
operator|->
name|dev_data
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|u_char
operator|)
name|phys
operator|->
name|hil_header
operator|.
name|ax_num
condition|;
name|i
operator|++
operator|,
name|sdata
operator|+=
name|bytes_coord
control|)
if|if
condition|(
name|bytes_coord
operator|==
literal|1
condition|)
name|coords
index|[
name|i
index|]
operator|=
operator|*
name|sdata
expr_stmt|;
elseif|else
if|if
condition|(
name|bytes_coord
operator|==
literal|2
condition|)
name|coords
index|[
name|i
index|]
operator|=
operator|*
operator|(
name|sdata
operator|+
literal|1
operator|)
operator|<<
literal|8
operator||
operator|(
operator|*
name|sdata
operator|&
literal|0x0ff
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|bytes_coord
operator|==
literal|2
condition|)
name|coords
index|[
name|i
index|]
operator|=
operator|(
operator|*
operator|(
name|sdata
operator|+
literal|3
operator|)
operator|<<
literal|24
operator|)
operator||
operator|(
operator|(
operator|*
operator|(
name|sdata
operator|+
literal|2
operator|)
operator|<<
literal|16
operator|)
operator|&
literal|0x0ff
operator|)
operator||
operator|(
operator|(
operator|*
operator|(
name|sdata
operator|+
literal|1
operator|)
operator|<<
literal|8
operator|)
operator|&
literal|0xff
operator|)
operator||
operator|(
operator|*
name|sdata
operator|&
literal|0x0ff
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|phys
operator|==
name|hpPointer
operator|&&
name|axes_changed
condition|)
block|{
name|tmp
operator|=
name|coords
index|[
literal|0
index|]
expr_stmt|;
name|coords
index|[
literal|0
index|]
operator|=
name|coords
index|[
name|x_axis
index|]
expr_stmt|;
if|if
condition|(
name|y_axis
operator|==
literal|0
condition|)
name|coords
index|[
literal|1
index|]
operator|=
name|tmp
expr_stmt|;
else|else
name|coords
index|[
literal|1
index|]
operator|=
name|coords
index|[
name|y_axis
index|]
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|phys
operator|->
name|hil_header
operator|.
name|flags
operator|&
name|HIL_ABSOLUTE
operator|)
operator|&&
name|phys
operator|->
name|dev_type
operator|!=
name|NINE_KNOB
condition|)
name|coords
index|[
literal|1
index|]
operator|=
operator|-
name|coords
index|[
literal|1
index|]
expr_stmt|;
name|process_motion
argument_list|(
name|dev
argument_list|,
name|phys
argument_list|,
name|log
argument_list|,
name|coords
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|format_ev
argument_list|(
name|type
argument_list|,
literal|0
argument_list|,
name|info
operator|->
name|timestamp
argument_list|,
name|log
argument_list|,
operator|&
name|xE
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*******************************************************************  *  * check_subset_and_scale()  * all we care about is the x and y coordinates.  *  */
end_comment

begin_expr_stmt
specifier|static
name|check_subset_and_scale
argument_list|(
argument|dev
argument_list|,
argument|phys
argument_list|,
argument|log
argument_list|,
argument|c
argument_list|)
name|DeviceIntPtr
operator|*
name|dev
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|HPInputDevice
modifier|*
name|phys
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|HPInputDevice
modifier|*
modifier|*
name|log
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|c
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|extern
name|u_char
name|screen_change_amt
decl_stmt|;
if|if
condition|(
name|tablet_width
condition|)
if|if
condition|(
name|c
index|[
literal|0
index|]
operator|<
name|tablet_xorg
operator|||
name|c
index|[
literal|0
index|]
operator|>
name|tablet_xlimit
operator|||
name|c
index|[
literal|1
index|]
operator|>
name|tablet_yorg
operator|||
name|c
index|[
literal|1
index|]
operator|<
name|tablet_ylimit
condition|)
block|{
name|in_tablet_extension
operator|=
name|TRUE
expr_stmt|;
operator|*
name|dev
operator|=
name|tablet_extension_device
expr_stmt|;
operator|*
name|log
operator|=
name|hptablet_extension
expr_stmt|;
block|}
else|else
block|{
name|in_tablet_extension
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|log
operator|==
name|hpPointer
condition|)
block|{
if|if
condition|(
operator|*
name|dev
operator|==
name|screen_change_dev
condition|)
name|c
index|[
literal|0
index|]
operator|=
call|(
name|float
call|)
argument_list|(
name|c
index|[
literal|0
index|]
operator|-
name|tablet_xorg
argument_list|)
operator|*
name|phys
operator|->
name|scaleX
operator|-
name|screen_change_amt
expr_stmt|;
else|else
name|c
index|[
literal|0
index|]
operator|=
call|(
name|float
call|)
argument_list|(
name|c
index|[
literal|0
index|]
operator|-
name|tablet_xorg
argument_list|)
operator|*
name|phys
operator|->
name|scaleX
expr_stmt|;
name|c
index|[
literal|1
index|]
operator|=
operator|(
operator|*
name|log
operator|)
operator|->
name|pScreen
operator|->
name|height
operator|-
operator|(
call|(
name|float
call|)
argument_list|(
name|c
index|[
literal|1
index|]
operator|-
name|tablet_ylimit
argument_list|)
operator|*
name|phys
operator|->
name|scaleY
operator|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|*
name|dev
operator|==
name|screen_change_dev
condition|)
name|c
index|[
literal|0
index|]
operator|-=
name|screen_change_amt
expr_stmt|;
name|c
index|[
literal|1
index|]
operator|=
name|phys
operator|->
name|hil_header
operator|.
name|size_y
operator|-
name|c
index|[
literal|1
index|]
expr_stmt|;
comment|/* Y-coord  reversed.*/
block|}
if|if
condition|(
name|c
index|[
literal|0
index|]
operator|==
operator|(
operator|*
name|log
operator|)
operator|->
name|coords
index|[
literal|0
index|]
operator|&&
name|c
index|[
literal|1
index|]
operator|==
operator|(
operator|*
name|log
operator|)
operator|->
name|coords
index|[
literal|1
index|]
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
name|c
index|[
literal|0
index|]
operator|-=
operator|(
operator|*
name|log
operator|)
operator|->
name|coords
index|[
literal|0
index|]
expr_stmt|;
name|c
index|[
literal|1
index|]
operator|-=
operator|(
operator|*
name|log
operator|)
operator|->
name|coords
index|[
literal|1
index|]
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_block

begin_decl_stmt
name|unsigned
name|char
name|lockcode
init|=
name|CAPSCODE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/****************************************************************************  *  * parse_keycode (dev, phys, ev, x_type)  *   Parse keycode information.  *   Buttons from a three-button mouse also end up here.  *  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__hpux
argument_list|)
operator|||
name|defined
argument_list|(
name|__hp_osf
argument_list|)
operator|||
name|defined
argument_list|(
name|hp9000
argument_list|)
end_if

begin_struct
struct|struct
name|_LedCmd
block|{
name|int
name|on
decl_stmt|;
name|int
name|off
decl_stmt|;
block|}
name|LedCmd
index|[]
init|=
block|{
block|{
name|HILP1
block|,
name|HILA1
block|}
block|,
block|{
name|HILP2
block|,
name|HILA2
block|}
block|,
block|{
name|HILP3
block|,
name|HILA3
block|}
block|,
block|{
name|HILP3
block|,
name|HILA3
block|}
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|parse_keycode
parameter_list|(
name|dev
parameter_list|,
name|phys
parameter_list|,
name|ev
parameter_list|)
name|DeviceIntPtr
name|dev
decl_stmt|;
name|HPInputDevice
modifier|*
name|phys
decl_stmt|;
name|xEvent
modifier|*
name|ev
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|XTESTEXT1
specifier|extern
name|u_char
name|xtest_command_key
decl_stmt|;
comment|/* defined in xtestext1dd.c */
endif|#
directive|endif
comment|/* XTESTEXT1 */
name|u_char
name|down_mods
decl_stmt|;
name|char
name|ioctl_data
index|[
literal|12
index|]
decl_stmt|;
if|if
condition|(
name|hpPointer
operator|->
name|x_type
operator|==
name|KEYBOARD
condition|)
if|if
condition|(
name|hpKeyboard
operator|->
name|hpflags
operator|&
name|SECOND_LOGICAL_DEVICE
operator|&&
operator|(
operator|(
name|ev
operator|->
name|u
operator|.
name|keyButtonPointer
operator|.
name|pad1
operator|==
name|hpKeyboard
operator|->
name|dev_id
operator|||
name|ev
operator|->
name|u
operator|.
name|keyButtonPointer
operator|.
name|pad1
operator|==
name|hpPointer
operator|->
name|dev_id
operator|)
operator|&&
name|move_sprite
argument_list|(
name|dev
argument_list|,
name|hpPointer
argument_list|,
name|ev
argument_list|)
operator|)
condition|)
return|return;
elseif|else
if|if
condition|(
name|ev
operator|->
name|u
operator|.
name|keyButtonPointer
operator|.
name|pad1
operator|==
name|hpPointer
operator|->
name|dev_id
operator|&&
operator|(
name|move_sprite
argument_list|(
name|dev
argument_list|,
name|hpPointer
argument_list|,
name|ev
argument_list|)
operator|)
condition|)
return|return;
comment|/* allow borrow-mode switching on Domain/OS machines */
ifdef|#
directive|ifdef
name|__apollo
if|if
condition|(
name|ev
operator|->
name|u
operator|.
name|u
operator|.
name|detail
operator|==
name|borrow_mode
condition|)
if|if
condition|(
operator|(
name|hpKeyboard
operator|->
name|hpflags
operator|&
name|SECOND_LOGICAL_DEVICE
operator|&&
operator|(
name|ev
operator|->
name|u
operator|.
name|keyButtonPointer
operator|.
name|pad1
operator|==
name|hpKeyboard
operator|->
name|dev_id
operator|||
name|ev
operator|->
name|u
operator|.
name|keyButtonPointer
operator|.
name|pad1
operator|==
name|hpPointer
operator|->
name|dev_id
operator|)
operator|)
operator|||
name|ev
operator|->
name|u
operator|.
name|keyButtonPointer
operator|.
name|pad1
operator|==
name|hpKeyboard
operator|->
name|dev_id
condition|)
block|{
name|get_down_modifiers
argument_list|(
name|inputInfo
operator|.
name|keyboard
operator|->
name|key
operator|->
name|down
argument_list|,
operator|&
name|down_mods
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|bw_mods
operator|&
name|down_mods
operator|)
operator|==
name|bw_mods
condition|)
block|{
specifier|extern
name|unsigned
name|char
name|last_code
decl_stmt|;
comment|/* in smd_input.c */
name|unsigned
name|long
name|timestamp
decl_stmt|;
name|timestamp
operator|=
name|ev
operator|->
name|u
operator|.
name|keyButtonPointer
operator|.
name|time
expr_stmt|;
name|deallocate_event
argument_list|(
name|ev
argument_list|)
expr_stmt|;
comment|/* eat the borrow mode key */
name|ev
operator|=
name|format_ev
argument_list|(
name|KeyRelease
argument_list|,
name|borrow_mode_mods
index|[
literal|0
index|]
operator|+
name|MIN_KEYCODE
argument_list|,
name|timestamp
argument_list|,
name|phys
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ev
operator|=
name|format_ev
argument_list|(
name|KeyRelease
argument_list|,
name|borrow_mode_mods
index|[
literal|1
index|]
operator|+
name|MIN_KEYCODE
argument_list|,
name|timestamp
argument_list|,
name|phys
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|last_code
operator|=
literal|0
expr_stmt|;
name|leave_X
argument_list|()
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* __apollo */
comment|/* allow reset only from the X system keyboard, 	   and only if reset is enabled.		*/
if|if
condition|(
name|ev
operator|->
name|u
operator|.
name|u
operator|.
name|detail
operator|==
name|reset
operator|&&
name|reset_enabled
condition|)
if|if
condition|(
operator|(
name|hpKeyboard
operator|->
name|hpflags
operator|&
name|SECOND_LOGICAL_DEVICE
operator|&&
operator|(
name|ev
operator|->
name|u
operator|.
name|keyButtonPointer
operator|.
name|pad1
operator|==
name|hpKeyboard
operator|->
name|dev_id
operator|||
name|ev
operator|->
name|u
operator|.
name|keyButtonPointer
operator|.
name|pad1
operator|==
name|hpPointer
operator|->
name|dev_id
operator|)
operator|)
operator|||
name|ev
operator|->
name|u
operator|.
name|keyButtonPointer
operator|.
name|pad1
operator|==
name|hpKeyboard
operator|->
name|dev_id
condition|)
block|{
name|get_down_modifiers
argument_list|(
name|inputInfo
operator|.
name|keyboard
operator|->
name|key
operator|->
name|down
argument_list|,
operator|&
name|down_mods
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NOT_DONE
comment|/* We don't have hp extensions, thus no ResetManager */
if|if
condition|(
operator|(
operator|(
name|rs_mods
operator|&
name|down_mods
operator|)
operator|==
name|rs_mods
operator|)
operator|&&
operator|!
name|SendEventToResetManager
argument_list|()
condition|)
name|GiveUp
argument_list|()
expr_stmt|;
block|}
else|#
directive|else
if|if
condition|(
operator|(
name|rs_mods
operator|&
name|down_mods
operator|)
operator|==
name|rs_mods
condition|)
name|GiveUp
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__hpux
argument_list|)
operator|||
name|defined
argument_list|(
name|__hp_osf
argument_list|)
operator|||
name|defined
argument_list|(
name|hp9000
argument_list|)
end_if

begin_comment
comment|/* Special case handling for the Caps Lock modifier and LED.        If a key is pressed that is bound to the Lock modifier,        turn on the Caps Lock LED and treat the key as latched.        However, do this only if a client has not overridden the        default use of the Caps Lock LED via the HPConfigureInput        protocol request.  */
end_comment

begin_if
if|if
condition|(
name|IsLockKey
argument_list|(
name|dev
argument_list|,
name|ev
operator|->
name|u
operator|.
name|u
operator|.
name|detail
argument_list|)
condition|)
comment|/* lock modifier pressed */
block|{
if|if
condition|(
name|ev
operator|->
name|u
operator|.
name|u
operator|.
name|detail
operator|!=
name|lockcode
condition|)
comment|/* was changed by xmodmap*/
block|{
name|UnlatchKey
argument_list|(
name|phys
argument_list|,
name|lockcode
argument_list|)
expr_stmt|;
name|LatchKey
argument_list|(
name|phys
argument_list|,
name|ev
operator|->
name|u
operator|.
name|u
operator|.
name|detail
argument_list|)
expr_stmt|;
name|lockcode
operator|=
name|ev
operator|->
name|u
operator|.
name|u
operator|.
name|detail
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|ev
operator|->
name|u
operator|.
name|u
operator|.
name|detail
operator|==
name|lockcode
condition|)
comment|/* is former lock modifier */
block|{
name|UnlatchKey
argument_list|(
name|phys
argument_list|,
name|lockcode
argument_list|)
expr_stmt|;
name|lockcode
operator|=
literal|0xff
expr_stmt|;
block|}
end_if

begin_if
if|if
condition|(
name|KeyIsLatched
argument_list|(
name|phys
argument_list|,
name|ev
operator|->
name|u
operator|.
name|u
operator|.
name|detail
argument_list|)
condition|)
if|if
condition|(
name|KeyIsIgnored
argument_list|(
name|phys
argument_list|,
name|ev
operator|->
name|u
operator|.
name|u
operator|.
name|detail
argument_list|)
condition|)
block|{
if|if
condition|(
name|KeyDownEvent
argument_list|(
name|ev
argument_list|)
condition|)
name|UnignoreKey
argument_list|(
name|phys
argument_list|,
name|ev
operator|->
name|u
operator|.
name|u
operator|.
name|detail
argument_list|)
expr_stmt|;
name|deallocate_event
argument_list|(
name|ev
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|KeyDownEvent
argument_list|(
name|ev
argument_list|)
condition|)
name|IgnoreKey
argument_list|(
name|phys
argument_list|,
name|ev
operator|->
name|u
operator|.
name|u
operator|.
name|detail
argument_list|)
expr_stmt|;
end_if

begin_if
if|if
condition|(
name|DeviceHasLeds
argument_list|(
name|phys
argument_list|)
operator|&&
name|KeyHasLed
argument_list|(
name|dev
argument_list|,
name|phys
argument_list|,
name|ev
operator|->
name|u
operator|.
name|u
operator|.
name|detail
argument_list|)
condition|)
if|if
condition|(
name|KeyUpEvent
argument_list|(
name|ev
argument_list|)
condition|)
name|LedOff
argument_list|(
name|dev
argument_list|,
name|phys
argument_list|,
name|ev
operator|->
name|u
operator|.
name|u
operator|.
name|detail
argument_list|,
name|ioctl_data
argument_list|)
expr_stmt|;
else|else
name|LedOn
argument_list|(
name|dev
argument_list|,
name|phys
argument_list|,
name|ev
operator|->
name|u
operator|.
name|u
operator|.
name|detail
argument_list|,
name|ioctl_data
argument_list|)
expr_stmt|;
end_if

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __hpux */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|XTESTEXT1
end_ifdef

begin_if
if|if
condition|(
name|on_steal_input
condition|)
block|{
name|XTestStealKeyData
argument_list|(
name|ev
operator|->
name|u
operator|.
name|u
operator|.
name|detail
argument_list|,
name|ev
operator|->
name|u
operator|.
name|u
operator|.
name|type
argument_list|,
name|phys
operator|->
name|x_type
argument_list|,
name|ev
operator|->
name|u
operator|.
name|keyButtonPointer
operator|.
name|rootX
argument_list|,
name|ev
operator|->
name|u
operator|.
name|keyButtonPointer
operator|.
name|rootY
argument_list|)
expr_stmt|;
if|if
condition|(
name|exclusive_steal
condition|)
block|{
if|if
condition|(
name|ev
operator|->
name|u
operator|.
name|u
operator|.
name|detail
operator|!=
name|xtest_command_key
condition|)
name|deallocate_event
argument_list|(
name|ev
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ev
operator|->
name|u
operator|.
name|u
operator|.
name|detail
operator|==
name|xtest_command_key
condition|)
name|deallocate_event
argument_list|(
name|ev
argument_list|)
expr_stmt|;
block|}
end_if

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* XTESTEXT1 */
end_comment

begin_comment
unit|}
comment|/************************************************************************  *  * This routine checks to see if the key should be interpreted as a   * sprite movement or a button.  *  */
end_comment

begin_macro
unit|static
name|move_sprite
argument_list|(
argument|dev
argument_list|,
argument|phys
argument_list|,
argument|ev
argument_list|)
end_macro

begin_decl_stmt
name|DeviceIntPtr
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|HPInputDevice
modifier|*
name|phys
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|xEvent
modifier|*
name|ev
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|u_char
name|down_mods
decl_stmt|;
name|u_char
name|key
init|=
name|ev
operator|->
name|u
operator|.
name|u
operator|.
name|detail
decl_stmt|;
name|u_char
name|type
init|=
name|ev
operator|->
name|u
operator|.
name|u
operator|.
name|type
decl_stmt|;
name|int
name|inc
decl_stmt|;
name|Bool
name|motion_mods
decl_stmt|;
name|get_down_modifiers
argument_list|(
name|dev
operator|->
name|key
operator|->
name|down
argument_list|,
operator|&
name|down_mods
argument_list|)
expr_stmt|;
if|if
condition|(
name|down_mods
operator|&
operator|(
operator|~
name|ptr_mods
operator|&
operator|~
name|mv_mods
operator|)
condition|)
name|motion_mods
operator|=
name|FALSE
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|down_mods
operator|&
name|ptr_mods
operator|)
operator|==
name|ptr_mods
condition|)
name|motion_mods
operator|=
name|TRUE
expr_stmt|;
else|else
name|motion_mods
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|down_mods
operator|&
name|mv_mods
operator|)
condition|)
name|inc
operator|=
name|pointer_move
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|down_mods
operator|&
name|mv_mods
operator|)
operator|==
name|pointer_amt_bits
index|[
literal|0
index|]
condition|)
name|inc
operator|=
name|pointer_mod1_amt
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|down_mods
operator|&
name|mv_mods
operator|)
operator|==
name|pointer_amt_bits
index|[
literal|1
index|]
condition|)
name|inc
operator|=
name|pointer_mod2_amt
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|down_mods
operator|&
name|mv_mods
operator|)
operator|==
name|pointer_amt_bits
index|[
literal|2
index|]
condition|)
name|inc
operator|=
name|pointer_mod3_amt
expr_stmt|;
else|else
name|motion_mods
operator|=
name|FALSE
expr_stmt|;
name|k_down_incy
index|[
name|DOWN
index|]
operator|=
name|inc
expr_stmt|;
name|k_down_incx
index|[
name|RIGHT
index|]
operator|=
name|inc
expr_stmt|;
name|k_down_incy
index|[
name|UP
index|]
operator|=
name|inc
operator|*
operator|-
literal|1
expr_stmt|;
name|k_down_incx
index|[
name|LEFT
index|]
operator|=
name|inc
operator|*
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|key
operator|==
name|cursor_down
operator|&&
name|type
operator|==
name|KeyPress
operator|&&
name|motion_mods
condition|)
return|return
operator|(
name|send_motion
argument_list|(
name|phys
argument_list|,
name|ev
argument_list|,
literal|0
argument_list|,
name|inc
argument_list|,
name|DOWN
argument_list|)
operator|)
return|;
elseif|else
if|if
condition|(
name|key
operator|==
name|cursor_down
operator|&&
name|type
operator|==
name|KeyRelease
condition|)
block|{
name|k_down_flag
index|[
name|DOWN
index|]
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|key
operator|==
name|cursor_left
operator|&&
name|type
operator|==
name|KeyPress
operator|&&
name|motion_mods
condition|)
return|return
operator|(
name|send_motion
argument_list|(
name|phys
argument_list|,
name|ev
argument_list|,
name|inc
operator|*
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
name|LEFT
argument_list|)
operator|)
return|;
elseif|else
if|if
condition|(
name|key
operator|==
name|cursor_left
operator|&&
name|type
operator|==
name|KeyRelease
condition|)
block|{
name|k_down_flag
index|[
name|LEFT
index|]
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|key
operator|==
name|cursor_right
operator|&&
name|type
operator|==
name|KeyPress
operator|&&
name|motion_mods
condition|)
return|return
operator|(
name|send_motion
argument_list|(
name|phys
argument_list|,
name|ev
argument_list|,
name|inc
argument_list|,
literal|0
argument_list|,
name|RIGHT
argument_list|)
operator|)
return|;
elseif|else
if|if
condition|(
name|key
operator|==
name|cursor_right
operator|&&
name|type
operator|==
name|KeyRelease
condition|)
block|{
name|k_down_flag
index|[
name|RIGHT
index|]
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|key
operator|==
name|cursor_up
operator|&&
name|type
operator|==
name|KeyPress
operator|&&
name|motion_mods
condition|)
return|return
operator|(
name|send_motion
argument_list|(
name|phys
argument_list|,
name|ev
argument_list|,
literal|0
argument_list|,
name|inc
operator|*
operator|-
literal|1
argument_list|,
name|UP
argument_list|)
operator|)
return|;
elseif|else
if|if
condition|(
name|key
operator|==
name|cursor_up
operator|&&
name|type
operator|==
name|KeyRelease
condition|)
block|{
name|k_down_flag
index|[
name|UP
index|]
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|type
operator|==
name|KeyPress
condition|)
name|type
operator|=
name|ButtonPress
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|KeyRelease
condition|)
name|type
operator|=
name|ButtonRelease
expr_stmt|;
if|if
condition|(
name|key
operator|==
name|button_1
condition|)
return|return
operator|(
name|send_button
argument_list|(
name|ev
argument_list|,
name|type
argument_list|,
literal|1
argument_list|)
operator|)
return|;
elseif|else
if|if
condition|(
name|key
operator|==
name|button_2
condition|)
return|return
operator|(
name|send_button
argument_list|(
name|ev
argument_list|,
name|type
argument_list|,
literal|2
argument_list|)
operator|)
return|;
elseif|else
if|if
condition|(
name|key
operator|==
name|button_3
condition|)
return|return
operator|(
name|send_button
argument_list|(
name|ev
argument_list|,
name|type
argument_list|,
literal|3
argument_list|)
operator|)
return|;
elseif|else
if|if
condition|(
name|key
operator|==
name|button_4
condition|)
return|return
operator|(
name|send_button
argument_list|(
name|ev
argument_list|,
name|type
argument_list|,
literal|4
argument_list|)
operator|)
return|;
elseif|else
if|if
condition|(
name|key
operator|==
name|button_5
condition|)
return|return
operator|(
name|send_button
argument_list|(
name|ev
argument_list|,
name|type
argument_list|,
literal|5
argument_list|)
operator|)
return|;
elseif|else
if|if
condition|(
name|key
operator|==
name|button_6
condition|)
return|return
operator|(
name|send_button
argument_list|(
name|ev
argument_list|,
name|type
argument_list|,
literal|6
argument_list|)
operator|)
return|;
elseif|else
if|if
condition|(
name|key
operator|==
name|button_7
condition|)
return|return
operator|(
name|send_button
argument_list|(
name|ev
argument_list|,
name|type
argument_list|,
literal|7
argument_list|)
operator|)
return|;
elseif|else
if|if
condition|(
name|key
operator|==
name|button_8
condition|)
return|return
operator|(
name|send_button
argument_list|(
name|ev
argument_list|,
name|type
argument_list|,
literal|8
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/****************************************************************************  *  * Send motion information from the keyboard, when it is the pointer device.  *  */
end_comment

begin_expr_stmt
specifier|static
name|send_motion
argument_list|(
argument|phys
argument_list|,
argument|ev
argument_list|,
argument|x
argument_list|,
argument|y
argument_list|,
argument|which
argument_list|)
name|HPInputDevice
operator|*
name|phys
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|xEvent
modifier|*
name|ev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|x
decl_stmt|,
name|y
decl_stmt|,
name|which
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|coords
index|[
name|MAX_AXES
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|i
operator|!=
name|which
operator|&&
name|k_down_flag
index|[
name|i
index|]
operator|!=
literal|0
condition|)
block|{
name|x
operator|+=
name|k_down_incx
index|[
name|i
index|]
expr_stmt|;
name|y
operator|+=
name|k_down_incy
index|[
name|i
index|]
expr_stmt|;
block|}
name|coords
index|[
literal|0
index|]
operator|=
name|x
expr_stmt|;
name|coords
index|[
literal|1
index|]
operator|=
name|y
expr_stmt|;
name|k_down_flag
index|[
name|which
index|]
operator|=
literal|1
expr_stmt|;
name|deallocate_event
argument_list|(
name|ev
argument_list|)
expr_stmt|;
name|process_motion
argument_list|(
name|inputInfo
operator|.
name|pointer
argument_list|,
name|phys
argument_list|,
name|hpPointer
argument_list|,
name|coords
argument_list|)
expr_stmt|;
name|ev
operator|=
name|format_ev
argument_list|(
name|MotionNotify
argument_list|,
literal|0
argument_list|,
name|ev
operator|->
name|u
operator|.
name|keyButtonPointer
operator|.
name|time
argument_list|,
name|hpPointer
argument_list|,
operator|&
name|xE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/****************************************************************************  *  * Send button information from the keyboard, when it is the pointer device.  *  */
end_comment

begin_expr_stmt
specifier|static
name|send_button
argument_list|(
argument|ev
argument_list|,
argument|direction
argument_list|,
argument|bcode
argument_list|)
name|xEvent
operator|*
name|ev
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|u_char
name|direction
decl_stmt|,
name|bcode
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|bcode
operator|==
name|last_key
operator|&&
name|direction
operator|==
name|last_direction
condition|)
name|deallocate_event
argument_list|(
name|ev
argument_list|)
expr_stmt|;
else|else
block|{
name|ev
operator|->
name|u
operator|.
name|u
operator|.
name|type
operator|=
name|direction
expr_stmt|;
name|ev
operator|->
name|u
operator|.
name|u
operator|.
name|detail
operator|=
name|bcode
expr_stmt|;
name|last_key
operator|=
name|bcode
expr_stmt|;
name|last_direction
operator|=
name|direction
expr_stmt|;
ifdef|#
directive|ifdef
name|XTESTEXT1
if|if
condition|(
name|on_steal_input
condition|)
name|XTestStealKeyData
argument_list|(
name|ev
operator|->
name|u
operator|.
name|u
operator|.
name|detail
argument_list|,
name|ev
operator|->
name|u
operator|.
name|u
operator|.
name|type
argument_list|,
name|MOUSE
argument_list|,
name|ev
operator|->
name|u
operator|.
name|keyButtonPointer
operator|.
name|rootX
argument_list|,
name|ev
operator|->
name|u
operator|.
name|keyButtonPointer
operator|.
name|rootY
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* XTESTEXT1 */
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/****************************************************************************  *  * process_motion (hil_info)  *  * This function may also be called from x_threebut.c and x_tablet.c.  * It requires the motion passed to be a relative amount.  * dev_hp and dev are the logical devices, phys is the actual device.  *  */
end_comment

begin_define
define|#
directive|define
name|DEF_ACCELERATION
value|1
end_define

begin_define
define|#
directive|define
name|EDGE_L
value|1<< 0
end_define

begin_define
define|#
directive|define
name|EDGE_R
value|1<< 1
end_define

begin_define
define|#
directive|define
name|EDGE_T
value|1<< 2
end_define

begin_define
define|#
directive|define
name|EDGE_B
value|1<< 3
end_define

begin_define
define|#
directive|define
name|OffRightEdge
parameter_list|(
name|log
parameter_list|)
value|(log->coords[0]> (log->change_xmax + \ 			    (int) log->change_amt) ? EDGE_R : 0)
end_define

begin_define
define|#
directive|define
name|OffLeftEdge
parameter_list|(
name|log
parameter_list|)
value|(log->coords[0]< (log->change_xmin - \ 			    (int) log->change_amt) ? EDGE_L : 0)
end_define

begin_define
define|#
directive|define
name|OffTopEdge
parameter_list|(
name|log
parameter_list|)
value|(log->coords[1]< (log->change_ymin - \ 			    (int) log->change_amt) ? EDGE_T : 0)
end_define

begin_define
define|#
directive|define
name|OffBottomEdge
parameter_list|(
name|log
parameter_list|)
value|(log->coords[1]> (log->change_ymax + \ 			    (int) log->change_amt) ? EDGE_B : 0)
end_define

begin_macro
name|process_motion
argument_list|(
argument|dev
argument_list|,
argument|phys
argument_list|,
argument|log
argument_list|,
argument|c
argument_list|)
end_macro

begin_decl_stmt
name|DeviceIntPtr
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|HPInputDevice
modifier|*
name|phys
decl_stmt|,
modifier|*
name|log
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|c
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|state
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|XTESTEXT1
specifier|extern
name|int
name|playback_on
decl_stmt|;
endif|#
directive|endif
comment|/* Compute x,y taking care of desired threshold and acceleration      * No acceleration if we're playing back a recorded test script.      * No acceleration for absolute pointing devices.      * No acceleration if we're using the default (1) acceleration.      */
ifdef|#
directive|ifdef
name|XTESTEXT1
if|if
condition|(
operator|!
name|playback_on
condition|)
endif|#
directive|endif
block|{
if|if
condition|(
operator|!
operator|(
name|phys
operator|->
name|hil_header
operator|.
name|flags
operator|&
name|HIL_ABSOLUTE
operator|)
operator|&&
operator|(
name|acceleration
operator|>
name|DEF_ACCELERATION
operator|)
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|u_char
operator|)
name|log
operator|->
name|hil_header
operator|.
name|ax_num
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|c
index|[
name|i
index|]
operator|-
name|threshold
operator|)
operator|>
literal|0
condition|)
name|c
index|[
name|i
index|]
operator|=
name|threshold
operator|+
operator|(
name|c
index|[
name|i
index|]
operator|-
name|threshold
operator|)
operator|*
name|acceleration
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|c
index|[
name|i
index|]
operator|+
name|threshold
operator|)
operator|<
literal|0
condition|)
name|c
index|[
name|i
index|]
operator|=
operator|(
name|c
index|[
name|i
index|]
operator|+
name|threshold
operator|)
operator|*
name|acceleration
operator|-
name|threshold
expr_stmt|;
block|}
block|}
comment|/*      * If this is the pointer or a device whose input is merged      * with the pointer, accumulate the motion and maintain a current position.      * If this is an relative device, save the current movement.      */
if|if
condition|(
name|log
operator|==
name|hpPointer
operator|||
operator|(
name|phys
operator|->
name|hil_header
operator|.
name|flags
operator|&
name|HIL_ABSOLUTE
operator|)
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|log
operator|->
name|hil_header
operator|.
name|ax_num
condition|;
name|i
operator|++
control|)
name|log
operator|->
name|coords
index|[
name|i
index|]
operator|=
name|log
operator|->
name|coords
index|[
name|i
index|]
operator|+
name|c
index|[
name|i
index|]
expr_stmt|;
else|else
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|u_char
operator|)
name|log
operator|->
name|hil_header
operator|.
name|ax_num
condition|;
name|i
operator|++
control|)
name|log
operator|->
name|coords
index|[
name|i
index|]
operator|=
name|c
index|[
name|i
index|]
expr_stmt|;
comment|/*      * Active Zaphod implementation:      *    Change the screen if we have more than one screen,      *	  and the screen change device has gone off one of the edges,      *    and the device is not grabbed and confined.      */
if|#
directive|if
name|defined
argument_list|(
name|__hpux
argument_list|)
operator|||
name|defined
argument_list|(
name|__hp_osf
argument_list|)
operator|||
name|defined
argument_list|(
name|hp9000
argument_list|)
if|if
condition|(
name|screenInfo
operator|.
name|numScreens
operator|>
literal|1
operator|&&
name|log
operator|->
name|dev_id
operator|==
name|screen_change_dev
operator|->
name|id
operator|&&
operator|(
operator|!
name|dev
operator|->
name|grab
operator|||
operator|!
name|dev
operator|->
name|grab
operator|->
name|confineTo
operator|)
condition|)
block|{
if|if
condition|(
name|state
operator|=
operator|(
name|OffRightEdge
argument_list|(
name|log
argument_list|)
operator||
name|OffLeftEdge
argument_list|(
name|log
argument_list|)
operator||
name|OffTopEdge
argument_list|(
name|log
argument_list|)
operator||
name|OffBottomEdge
argument_list|(
name|log
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|screen_was_changed
condition|)
name|change_the_screen
argument_list|(
name|dev
argument_list|,
name|phys
argument_list|,
name|log
argument_list|,
name|state
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* 	     * Needed for the case where a tablet is the X pointer device. 	     * Once we change screens, we want to avoid immediately changing 	     * back.  We change when we enter the screen change area and  	     * do not change again until after we have left it. 	     */
name|screen_was_changed
operator|=
name|FALSE
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* __hpux */
if|if
condition|(
name|phys
operator|==
name|hptablet_extension
operator|&&
name|log
operator|->
name|open_cnt
operator|==
literal|0
condition|)
return|return;
comment|/*      * Clip the cursor to stay within the bound of screen.      */
if|if
condition|(
name|log
operator|==
name|hpPointer
operator|&&
operator|(
operator|!
name|hpConstrainXY
argument_list|(
operator|&
name|log
operator|->
name|coords
index|[
literal|0
index|]
argument_list|,
operator|&
name|log
operator|->
name|coords
index|[
literal|1
index|]
argument_list|)
operator|)
condition|)
return|return;
name|move_mouse
argument_list|(
name|log
argument_list|,
name|lastEventTime
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/****************************************************************************  *  * change_the_screen()  * We have more than one screen, and the screen_change_device has been moved   * off one of the edges.  Change to another screen.  *  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__hpux
argument_list|)
operator|||
name|defined
argument_list|(
name|__hp_osf
argument_list|)
operator|||
name|defined
argument_list|(
name|hp9000
argument_list|)
end_if

begin_define
define|#
directive|define
name|INCREMENT_SCREEN_BY_ONE
parameter_list|(
name|p
parameter_list|,
name|l
parameter_list|)
value|(screenInfo.screens[(p->myNum+1) % \     screenInfo.numScreens])
end_define

begin_define
define|#
directive|define
name|DECREMENT_SCREEN_BY_ONE
parameter_list|(
name|p
parameter_list|,
name|l
parameter_list|)
value|(p->myNum != 0 ? \     screenInfo.screens[p->myNum-1] : \     screenInfo.screens[screenInfo.numScreens - 1])
end_define

begin_define
define|#
directive|define
name|INCREMENT_SCREEN_BY_TWO
parameter_list|(
name|p
parameter_list|,
name|l
parameter_list|)
value|(screenInfo.screens[(p->myNum+2) % \     screenInfo.numScreens])
end_define

begin_define
define|#
directive|define
name|DECREMENT_SCREEN_BY_TWO
parameter_list|(
name|p
parameter_list|,
name|l
parameter_list|)
value|(p->myNum> 1 ? \     screenInfo.screens[p->myNum-2] : \     screenInfo.screens[p->myNum + screenInfo.numScreens - 2])
end_define

begin_macro
name|change_the_screen
argument_list|(
argument|dev
argument_list|,
argument|phys
argument_list|,
argument|log
argument_list|,
argument|state
argument_list|)
end_macro

begin_decl_stmt
name|DeviceIntPtr
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|HPInputDevice
modifier|*
name|phys
decl_stmt|,
modifier|*
name|log
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* logical device */
end_comment

begin_decl_stmt
name|unsigned
name|int
name|state
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|ScreenPtr
name|pScreen
decl_stmt|;
name|WindowPtr
name|pRootWin
decl_stmt|;
name|int
name|tx
decl_stmt|,
name|ty
decl_stmt|;
if|if
condition|(
name|screen_col_wrap
operator|==
name|DEFAULT
condition|)
block|{
if|if
condition|(
name|screen_orientation
operator|==
name|VERTICAL
condition|)
name|screen_col_wrap
operator|=
name|WRAP
expr_stmt|;
else|else
name|screen_col_wrap
operator|=
name|NOWRAP
expr_stmt|;
block|}
if|if
condition|(
name|screen_row_wrap
operator|==
name|DEFAULT
condition|)
block|{
if|if
condition|(
name|screen_orientation
operator|==
name|HORIZONTAL
condition|)
name|screen_row_wrap
operator|=
name|WRAP
expr_stmt|;
else|else
name|screen_row_wrap
operator|=
name|NOWRAP
expr_stmt|;
block|}
name|pScreen
operator|=
name|log
operator|->
name|pScreen
expr_stmt|;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|EDGE_L
case|:
if|if
condition|(
name|screen_row_wrap
operator|==
name|NOWRAP
operator|&&
operator|(
name|screen_orientation
operator|==
name|VERTICAL
operator|||
operator|(
name|pScreen
operator|->
name|myNum
operator|==
literal|0
operator|||
operator|(
name|pScreen
operator|->
name|myNum
operator|==
literal|2
operator|&&
name|screen_orientation
operator|==
name|MATRIX
operator|)
operator|)
operator|)
condition|)
return|return;
if|if
condition|(
name|screen_orientation
operator|==
name|VERTICAL
condition|)
block|{
if|if
condition|(
name|screen_row_wrap
operator|==
name|CHANGE_BY_TWO
condition|)
block|{
name|log
operator|->
name|pScreen
operator|=
name|DECREMENT_SCREEN_BY_TWO
argument_list|(
name|pScreen
argument_list|,
name|log
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|screen_orientation
operator|==
name|HORIZONTAL
condition|)
block|{
name|log
operator|->
name|pScreen
operator|=
name|DECREMENT_SCREEN_BY_ONE
argument_list|(
name|pScreen
argument_list|,
name|log
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|screen_orientation
operator|==
name|MATRIX
condition|)
block|{
if|if
condition|(
name|pScreen
operator|->
name|myNum
operator|%
literal|2
condition|)
block|{
name|log
operator|->
name|pScreen
operator|=
name|DECREMENT_SCREEN_BY_ONE
argument_list|(
name|pScreen
argument_list|,
name|log
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|screen_row_wrap
operator|==
name|WRAP
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|screenInfo
operator|.
name|numScreens
operator|==
literal|3
operator|&&
name|pScreen
operator|->
name|myNum
operator|==
literal|2
operator|)
condition|)
block|{
name|log
operator|->
name|pScreen
operator|=
name|INCREMENT_SCREEN_BY_ONE
argument_list|(
name|pScreen
argument_list|,
name|log
argument_list|)
expr_stmt|;
block|}
block|}
else|else
break|break;
block|}
if|if
condition|(
operator|!
operator|(
name|log
operator|->
name|hil_header
operator|.
name|flags
operator|&
name|HIL_ABSOLUTE
operator|)
condition|)
name|log
operator|->
name|coords
index|[
literal|0
index|]
operator|+=
operator|(
name|log
operator|->
name|pScreen
operator|->
name|width
operator|-
name|log
operator|->
name|change_xmin
operator|)
expr_stmt|;
break|break;
case|case
name|EDGE_R
case|:
if|if
condition|(
name|screen_row_wrap
operator|==
name|NOWRAP
operator|&&
operator|(
name|screen_orientation
operator|==
name|VERTICAL
operator|||
operator|(
name|pScreen
operator|->
name|myNum
operator|==
literal|3
operator|||
operator|(
name|pScreen
operator|->
name|myNum
operator|==
literal|1
operator|&&
name|screen_orientation
operator|==
name|MATRIX
operator|)
operator|)
operator|)
condition|)
return|return;
if|if
condition|(
name|screen_orientation
operator|==
name|VERTICAL
condition|)
block|{
if|if
condition|(
name|screen_row_wrap
operator|==
name|CHANGE_BY_TWO
condition|)
block|{
name|log
operator|->
name|pScreen
operator|=
name|INCREMENT_SCREEN_BY_TWO
argument_list|(
name|pScreen
argument_list|,
name|log
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|screen_orientation
operator|==
name|HORIZONTAL
condition|)
block|{
name|log
operator|->
name|pScreen
operator|=
name|INCREMENT_SCREEN_BY_ONE
argument_list|(
name|pScreen
argument_list|,
name|log
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|screen_orientation
operator|==
name|MATRIX
condition|)
block|{
if|if
condition|(
name|pScreen
operator|->
name|myNum
operator|%
literal|2
condition|)
block|{
if|if
condition|(
name|screen_row_wrap
operator|==
name|WRAP
condition|)
block|{
name|log
operator|->
name|pScreen
operator|=
name|DECREMENT_SCREEN_BY_ONE
argument_list|(
name|pScreen
argument_list|,
name|log
argument_list|)
expr_stmt|;
block|}
else|else
break|break;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|screenInfo
operator|.
name|numScreens
operator|==
literal|3
operator|&&
name|pScreen
operator|->
name|myNum
operator|==
literal|2
operator|)
condition|)
block|{
name|log
operator|->
name|pScreen
operator|=
name|INCREMENT_SCREEN_BY_ONE
argument_list|(
name|pScreen
argument_list|,
name|log
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|screen_row_wrap
operator|!=
name|WRAP
condition|)
break|break;
block|}
if|if
condition|(
operator|!
operator|(
name|log
operator|->
name|hil_header
operator|.
name|flags
operator|&
name|HIL_ABSOLUTE
operator|)
condition|)
name|log
operator|->
name|coords
index|[
literal|0
index|]
operator|-=
operator|(
name|pScreen
operator|->
name|width
operator|)
expr_stmt|;
break|break;
case|case
name|EDGE_T
case|:
if|if
condition|(
name|screen_col_wrap
operator|==
name|NOWRAP
operator|&&
operator|(
name|screen_orientation
operator|==
name|HORIZONTAL
operator|||
operator|(
name|pScreen
operator|->
name|myNum
operator|==
literal|3
operator|||
operator|(
name|pScreen
operator|->
name|myNum
operator|==
literal|2
operator|&&
name|screen_orientation
operator|==
name|MATRIX
operator|)
operator|)
operator|)
condition|)
return|return;
if|if
condition|(
name|screen_orientation
operator|==
name|HORIZONTAL
condition|)
block|{
if|if
condition|(
name|screen_col_wrap
operator|==
name|CHANGE_BY_TWO
condition|)
block|{
name|log
operator|->
name|pScreen
operator|=
name|INCREMENT_SCREEN_BY_TWO
argument_list|(
name|pScreen
argument_list|,
name|log
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|screen_orientation
operator|==
name|VERTICAL
condition|)
block|{
name|log
operator|->
name|pScreen
operator|=
name|INCREMENT_SCREEN_BY_ONE
argument_list|(
name|pScreen
argument_list|,
name|log
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|screen_orientation
operator|==
name|MATRIX
condition|)
block|{
if|if
condition|(
name|pScreen
operator|->
name|myNum
operator|>=
literal|2
condition|)
block|{
if|if
condition|(
name|screen_col_wrap
operator|==
name|WRAP
condition|)
block|{
name|log
operator|->
name|pScreen
operator|=
name|DECREMENT_SCREEN_BY_TWO
argument_list|(
name|pScreen
argument_list|,
name|log
argument_list|)
expr_stmt|;
block|}
else|else
break|break;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|screenInfo
operator|.
name|numScreens
operator|==
literal|3
operator|&&
name|pScreen
operator|->
name|myNum
operator|==
literal|1
operator|)
condition|)
block|{
name|log
operator|->
name|pScreen
operator|=
name|INCREMENT_SCREEN_BY_TWO
argument_list|(
name|pScreen
argument_list|,
name|log
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|screen_col_wrap
operator|!=
name|WRAP
condition|)
break|break;
block|}
if|if
condition|(
operator|!
operator|(
name|log
operator|->
name|hil_header
operator|.
name|flags
operator|&
name|HIL_ABSOLUTE
operator|)
condition|)
name|log
operator|->
name|coords
index|[
literal|1
index|]
operator|+=
operator|(
name|pScreen
operator|->
name|height
operator|)
expr_stmt|;
break|break;
case|case
name|EDGE_B
case|:
if|if
condition|(
name|screen_col_wrap
operator|==
name|NOWRAP
operator|&&
operator|(
name|screen_orientation
operator|==
name|HORIZONTAL
operator|||
operator|(
name|pScreen
operator|->
name|myNum
operator|==
literal|0
operator|||
operator|(
name|pScreen
operator|->
name|myNum
operator|==
literal|1
operator|&&
name|screen_orientation
operator|==
name|MATRIX
operator|)
operator|)
operator|)
condition|)
return|return;
if|if
condition|(
name|screen_orientation
operator|==
name|HORIZONTAL
condition|)
block|{
if|if
condition|(
name|screen_col_wrap
operator|==
name|CHANGE_BY_TWO
condition|)
block|{
name|log
operator|->
name|pScreen
operator|=
name|DECREMENT_SCREEN_BY_TWO
argument_list|(
name|pScreen
argument_list|,
name|log
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|screen_orientation
operator|==
name|VERTICAL
condition|)
block|{
name|log
operator|->
name|pScreen
operator|=
name|DECREMENT_SCREEN_BY_ONE
argument_list|(
name|pScreen
argument_list|,
name|log
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|screen_orientation
operator|==
name|MATRIX
condition|)
block|{
if|if
condition|(
name|pScreen
operator|->
name|myNum
operator|>=
literal|2
condition|)
block|{
name|log
operator|->
name|pScreen
operator|=
name|DECREMENT_SCREEN_BY_TWO
argument_list|(
name|pScreen
argument_list|,
name|log
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|screen_col_wrap
operator|==
name|WRAP
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|screenInfo
operator|.
name|numScreens
operator|==
literal|3
operator|&&
name|pScreen
operator|->
name|myNum
operator|==
literal|1
operator|)
condition|)
block|{
name|log
operator|->
name|pScreen
operator|=
name|INCREMENT_SCREEN_BY_TWO
argument_list|(
name|pScreen
argument_list|,
name|log
argument_list|)
expr_stmt|;
block|}
block|}
else|else
break|break;
block|}
if|if
condition|(
operator|!
operator|(
name|log
operator|->
name|hil_header
operator|.
name|flags
operator|&
name|HIL_ABSOLUTE
operator|)
condition|)
name|log
operator|->
name|coords
index|[
literal|1
index|]
operator|-=
operator|(
name|pScreen
operator|->
name|height
operator|)
expr_stmt|;
break|break;
block|}
name|getPrivScreenPtr
argument_list|(
name|pScreen
argument_list|)
operator|->
name|CursorOff
argument_list|(
name|pScreen
argument_list|)
expr_stmt|;
name|pScreen
operator|=
name|log
operator|->
name|pScreen
expr_stmt|;
name|screen_was_changed
operator|=
name|TRUE
expr_stmt|;
name|set_scale_and_screen_change
argument_list|(
name|log
argument_list|)
expr_stmt|;
name|getPrivScreenPtr
argument_list|(
name|pScreen
argument_list|)
operator|->
name|ChangeScreen
argument_list|(
name|pScreen
argument_list|)
expr_stmt|;
if|if
condition|(
name|phys
operator|==
name|hptablet_extension
condition|)
block|{
name|tx
operator|=
name|phys
operator|->
name|coords
index|[
literal|0
index|]
operator|<
name|tablet_xorg
condition|?
literal|0
else|:
name|pScreen
operator|->
name|width
expr_stmt|;
name|ty
operator|=
operator|(
name|float
operator|)
name|phys
operator|->
name|coords
index|[
literal|1
index|]
operator|*
name|phys
operator|->
name|scaleY
expr_stmt|;
name|NewCurrentScreen
argument_list|(
name|pScreen
argument_list|,
name|tx
argument_list|,
name|ty
argument_list|)
expr_stmt|;
block|}
else|else
name|NewCurrentScreen
argument_list|(
name|pScreen
argument_list|,
name|log
operator|->
name|coords
index|[
literal|0
index|]
argument_list|,
name|log
operator|->
name|coords
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|hpActiveScreen
operator|=
name|pScreen
operator|->
name|myNum
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|grab
operator|&&
name|dev
operator|->
name|grab
operator|->
name|cursor
condition|)
name|pScreen
operator|->
name|DisplayCursor
argument_list|(
name|pScreen
argument_list|,
name|dev
operator|->
name|grab
operator|->
name|cursor
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
operator|(
name|pRootWin
operator|=
name|WindowTable
index|[
name|pScreen
operator|->
name|myNum
index|]
operator|)
condition|)
name|pScreen
operator|->
name|DisplayCursor
argument_list|(
name|pScreen
argument_list|,
operator|(
name|CursorPtr
operator|)
name|NULL
argument_list|)
expr_stmt|;
else|else
name|pScreen
operator|->
name|DisplayCursor
argument_list|(
name|pScreen
argument_list|,
name|pRootWin
operator|->
name|optional
operator|->
name|cursor
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __hpux || __hp_osf */
end_comment

begin_comment
comment|/****************************************************************************  *  * move_mouse ()  * move the sprite, if the device is the pointer.  * Also move it if some other device is sending MotionNotify events.  * In any case, send a motion event to dix.  *  * This routine may also be called from xtest1dd.c  *  */
end_comment

begin_expr_stmt
specifier|static
name|move_mouse
argument_list|(
argument|log
argument_list|,
argument|event_time
argument_list|)
name|HPInputDevice
operator|*
name|log
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* logical device  */
end_comment

begin_decl_stmt
name|int
name|event_time
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* event timestamp */
end_comment

begin_block
block|{
name|int
name|i
decl_stmt|;
name|int
name|id
init|=
name|log
operator|->
name|dev_id
decl_stmt|;
name|int
name|axes
init|=
name|log
operator|->
name|hil_header
operator|.
name|ax_num
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__hpux
argument_list|)
operator|||
name|defined
argument_list|(
name|__hp_osf
argument_list|)
operator|||
name|defined
argument_list|(
name|hp9000
argument_list|)
specifier|register
name|hpPrivScreenPtr
name|phpPriv
init|=
name|getPrivScreenPtr
argument_list|(
name|log
operator|->
name|pScreen
argument_list|)
decl_stmt|;
if|if
condition|(
name|log
operator|==
name|hpPointer
condition|)
ifdef|#
directive|ifdef
name|SPECIAL_68K_OSF
name|miPointerMoveCursor
argument_list|(
name|log
operator|->
name|pScreen
argument_list|,
name|log
operator|->
name|coords
index|[
literal|0
index|]
argument_list|,
name|log
operator|->
name|coords
index|[
literal|1
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|#
directive|else
call|(
modifier|*
name|phpPriv
operator|->
name|MoveMouse
call|)
argument_list|(
name|log
operator|->
name|pScreen
argument_list|,
name|log
operator|->
name|coords
index|[
literal|0
index|]
argument_list|,
name|log
operator|->
name|coords
index|[
literal|1
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* __hpux */
ifdef|#
directive|ifdef
name|__apollo
if|if
condition|(
name|log
operator|==
name|hpPointer
condition|)
block|{
name|xshScreenPrivPtr
name|pScreenPriv
decl_stmt|;
name|pScreenPriv
operator|=
name|XSH_SCREEN_PRIV
argument_list|(
name|log
operator|->
name|pScreen
argument_list|)
expr_stmt|;
call|(
modifier|*
name|pScreenPriv
operator|->
name|MoveCursor
call|)
argument_list|(
name|pScreenPriv
argument_list|,
name|log
operator|->
name|coords
index|[
literal|0
index|]
argument_list|,
name|log
operator|->
name|coords
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|XTESTEXT1
if|if
condition|(
name|on_steal_input
condition|)
name|check_for_motion_steal
argument_list|(
name|log
operator|->
name|coords
index|[
literal|0
index|]
argument_list|,
name|log
operator|->
name|coords
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* XTESTEXT1 */
block|}
endif|#
directive|endif
comment|/* __apollo */
operator|*
name|dpmotionBuf
index|[
name|id
index|]
operator|++
operator|=
name|event_time
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|axes
condition|;
name|i
operator|++
control|)
operator|*
name|dpmotionBuf
index|[
name|id
index|]
operator|++
operator|=
name|log
operator|->
name|coords
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|dheadmotionBuf
index|[
name|id
index|]
operator|+
literal|100
operator|*
operator|(
name|axes
operator|+
literal|1
operator|)
operator|)
operator|==
name|dpmotionBuf
index|[
name|id
index|]
condition|)
name|dpmotionBuf
index|[
name|id
index|]
operator|=
name|dheadmotionBuf
index|[
name|id
index|]
expr_stmt|;
block|}
end_block

begin_comment
comment|/**************************************************************************  *  * Called by: hpMouseProc during device initialization, process_motion  * 	whenever we change screens.  *  * This routine sets the scaling factor to be used for absolute pointing  * devices like graphics tablets.  Input from these devices is scaled to  * the screen size.  If we have a multi-screen environment, the scaling  * factor must be changed whenever the screen changes.  *  * This routine also sets the margin at the screen edge that will be used  * to change screens.  For tablets, this is initially 0, allowing the   * entire tablet surface to be used by the application.  If a tablet is   * the X pointer and a multi-screen environment is being used, the   * screen_change_amt variable should be initialized to some value (like 30)  * to define a area at the tablet edges that will cause the screen to change.  *  * Tablet subsetting adds more complications.  The user can define a subset  * area that used as the X pointer, while the remainder of the tablet surface  * is treated as a second logical device.  It is this second logical device  * that controls screen changes.  *  */
end_comment

begin_macro
name|set_scale_and_screen_change
argument_list|(
argument|d
argument_list|)
end_macro

begin_decl_stmt
name|HPInputDevice
modifier|*
name|d
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|tmp
decl_stmt|,
name|resx_mm
decl_stmt|,
name|resy_mm
decl_stmt|;
comment|/* Absolute device: graphics tablet or touchscreen */
if|if
condition|(
name|d
operator|->
name|hil_header
operator|.
name|flags
operator|&
name|HIL_ABSOLUTE
condition|)
block|{
name|resx_mm
operator|=
name|d
operator|->
name|hil_header
operator|.
name|resx
operator|/
literal|1000
expr_stmt|;
name|resy_mm
operator|=
name|d
operator|->
name|hil_header
operator|.
name|resy
operator|/
literal|1000
expr_stmt|;
comment|/* Tablet subsetting enabled and this is the pointer region.     	   This is called only during initialization, since when     	   we change screens, the device is the second logical device. */
if|if
condition|(
name|tablet_width
operator|&&
name|d
operator|->
name|dev_id
operator|==
name|inputInfo
operator|.
name|pointer
operator|->
name|id
condition|)
block|{
name|tablet_xorg
operator|=
name|tablet_xorigin
operator|*
name|resx_mm
expr_stmt|;
name|tablet_xlimit
operator|=
name|tablet_xorg
operator|+
name|tablet_width
operator|*
name|resx_mm
expr_stmt|;
name|tmp
operator|=
name|d
operator|->
name|hil_header
operator|.
name|size_y
operator|-
operator|(
name|tablet_yorigin
operator|*
name|resy_mm
operator|)
expr_stmt|;
name|tablet_yorg
operator|=
name|tmp
operator|>
literal|0
condition|?
name|tmp
else|:
literal|0
expr_stmt|;
name|tmp
operator|=
name|tablet_yorg
operator|-
operator|(
name|tablet_height
operator|*
name|resy_mm
operator|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|>
literal|0
condition|)
name|tablet_ylimit
operator|=
name|tmp
expr_stmt|;
else|else
block|{
name|tablet_ylimit
operator|=
literal|0
expr_stmt|;
name|tablet_height
operator|=
name|tablet_yorg
operator|/
name|resy_mm
expr_stmt|;
block|}
name|d
operator|->
name|scaleX
operator|=
operator|(
operator|(
name|float
operator|)
name|d
operator|->
name|pScreen
operator|->
name|width
operator|)
operator|/
operator|(
operator|(
name|float
operator|)
name|tablet_width
operator|*
name|resx_mm
operator|)
expr_stmt|;
name|d
operator|->
name|scaleY
operator|=
operator|(
operator|(
name|float
operator|)
name|d
operator|->
name|pScreen
operator|->
name|height
operator|)
operator|/
operator|(
operator|(
name|float
operator|)
name|tablet_height
operator|*
name|resy_mm
operator|)
expr_stmt|;
name|d
operator|->
name|change_xmin
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|change_xmax
operator|=
name|d
operator|->
name|pScreen
operator|->
name|width
expr_stmt|;
name|d
operator|->
name|change_amt
operator|=
literal|0
expr_stmt|;
block|}
else|else
comment|/* This code is called if we are initializing the second logical 	   device, or if tablet subsetting is not enabled.  It is also 	   called when we are changing screens with a tablet as the X 	   pointer device.  	 */
block|{
comment|/*  	      Set scale for the case where the tablet is the X pointer. 	      The scale is also returned to clients via XHPListInputDevices. 	     */
name|d
operator|->
name|scaleX
operator|=
operator|(
call|(
name|float
call|)
argument_list|(
name|d
operator|->
name|pScreen
operator|->
name|width
operator|+
literal|2
operator|*
name|screen_change_amt
argument_list|)
operator|)
operator|/
operator|(
operator|(
name|float
operator|)
name|d
operator|->
name|hil_header
operator|.
name|size_x
operator|)
expr_stmt|;
name|d
operator|->
name|scaleY
operator|=
operator|(
operator|(
name|float
operator|)
name|d
operator|->
name|pScreen
operator|->
name|height
operator|)
operator|/
operator|(
operator|(
name|float
operator|)
name|d
operator|->
name|hil_header
operator|.
name|size_y
operator|)
expr_stmt|;
if|if
condition|(
name|tablet_width
condition|)
block|{
comment|/* If this is the second logical device, we must also 		   change the scale of the X pointer.  Since input from 		   absolute extension devices is not scaled, the 		   screen change amounts units are tablet counts. 		 */
name|hpPointer
operator|->
name|scaleX
operator|=
operator|(
operator|(
name|float
operator|)
name|d
operator|->
name|pScreen
operator|->
name|width
operator|)
operator|/
operator|(
operator|(
name|float
operator|)
name|tablet_width
operator|*
name|resx_mm
operator|)
expr_stmt|;
name|hpPointer
operator|->
name|scaleY
operator|=
operator|(
operator|(
name|float
operator|)
name|d
operator|->
name|pScreen
operator|->
name|height
operator|)
operator|/
operator|(
operator|(
name|float
operator|)
name|tablet_height
operator|*
name|resy_mm
operator|)
expr_stmt|;
name|d
operator|->
name|change_xmin
operator|=
name|resx_mm
operator|*
name|screen_change_amt
expr_stmt|;
name|d
operator|->
name|change_xmax
operator|=
name|d
operator|->
name|hil_header
operator|.
name|size_x
operator|-
name|d
operator|->
name|change_xmin
expr_stmt|;
name|d
operator|->
name|change_ymin
operator|=
name|resy_mm
operator|*
name|screen_change_amt
expr_stmt|;
name|d
operator|->
name|change_ymax
operator|=
name|d
operator|->
name|hil_header
operator|.
name|size_y
operator|-
name|d
operator|->
name|change_xmin
expr_stmt|;
name|d
operator|->
name|change_amt
operator|=
literal|0
expr_stmt|;
block|}
else|else
comment|/* The tablet is the X pointer.  Screen change units 		   are in pixels, since the input will be scaled. 		 */
block|{
name|d
operator|->
name|change_xmin
operator|=
literal|1
expr_stmt|;
name|d
operator|->
name|change_xmax
operator|=
name|d
operator|->
name|pScreen
operator|->
name|width
operator|-
literal|2
expr_stmt|;
name|d
operator|->
name|change_ymin
operator|=
literal|1
expr_stmt|;
name|d
operator|->
name|change_ymax
operator|=
name|d
operator|->
name|pScreen
operator|->
name|height
operator|-
literal|2
expr_stmt|;
name|d
operator|->
name|change_amt
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
else|else
comment|/* This code is called when a relative device is initialized,        and when we are changing screens with a relative device.        These devices  (mice, trackballs, dialboxes, spaceballs)        cause us to change screens by generating values that are        beyond the edge of the screen.      */
block|{
name|d
operator|->
name|change_xmin
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|change_xmax
operator|=
name|d
operator|->
name|pScreen
operator|->
name|width
expr_stmt|;
name|d
operator|->
name|change_ymin
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|change_ymax
operator|=
name|d
operator|->
name|pScreen
operator|->
name|height
expr_stmt|;
name|d
operator|->
name|change_amt
operator|=
name|screen_change_amt
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/****************************************************************************  *  *  queue_motion_event ()  *  This is a convenience routine for xosSetCursorPosition.  *  It is used to artifically generate a motion event when WarpPointer  *  request is made.  *  */
end_comment

begin_macro
name|queue_motion_event
argument_list|(
argument|dev_p
argument_list|)
end_macro

begin_decl_stmt
name|HPInputDevice
modifier|*
name|dev_p
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|coords
index|[
name|MAX_AXES
index|]
decl_stmt|;
specifier|extern
name|TimeStamp
name|currentTime
decl_stmt|;
name|coords
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|coords
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|process_motion
argument_list|(
name|inputInfo
operator|.
name|pointer
argument_list|,
name|dev_p
argument_list|,
name|dev_p
argument_list|,
name|coords
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|format_ev
argument_list|(
name|MotionNotify
argument_list|,
literal|0
argument_list|,
name|currentTime
operator|.
name|milliseconds
argument_list|,
name|dev_p
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|xE
operator|.
name|b
operator|.
name|u
operator|.
name|u
operator|.
name|type
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_comment
comment|/****************************************************************************  *  * format_ev ( )  *	format one or more key, button, motion or proximity xEvents.  *	This routine assumes devices have less than 6 axes, or report only  *      one axis per event.  */
end_comment

begin_define
define|#
directive|define
name|AXES_PER_EVENT
value|6
end_define

begin_function
name|xEvent
modifier|*
name|format_ev
parameter_list|(
name|type
parameter_list|,
name|detail
parameter_list|,
name|event_time
parameter_list|,
name|log
parameter_list|,
name|event
parameter_list|)
name|u_char
name|type
decl_stmt|;
name|u_char
name|detail
decl_stmt|;
name|unsigned
name|int
name|event_time
decl_stmt|;
name|HPInputDevice
modifier|*
name|log
decl_stmt|;
name|xHPEvent
modifier|*
name|event
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|n_axes
init|=
name|log
operator|->
name|hil_header
operator|.
name|ax_num
decl_stmt|;
name|INT32
modifier|*
name|ip
decl_stmt|;
name|xEvent
modifier|*
name|ret
init|=
name|NULL
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|n_axes
operator|/
name|AXES_PER_EVENT
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|event
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|xE
operator|.
name|b
operator|.
name|u
operator|.
name|u
operator|.
name|type
operator|!=
literal|0
condition|)
comment|/* we have a previous motion event  */
block|{
name|event
operator|=
name|allocate_event
argument_list|()
expr_stmt|;
comment|/* queue it before the new event    */
operator|*
name|event
operator|=
name|xE
expr_stmt|;
name|xE
operator|.
name|b
operator|.
name|u
operator|.
name|u
operator|.
name|type
operator|=
literal|0
expr_stmt|;
block|}
name|event
operator|=
name|allocate_event
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ret
condition|)
name|ret
operator|=
operator|(
name|xEvent
operator|*
operator|)
name|event
expr_stmt|;
name|event
operator|->
name|b
operator|.
name|u
operator|.
name|u
operator|.
name|type
operator|=
name|type
expr_stmt|;
name|event
operator|->
name|b
operator|.
name|u
operator|.
name|u
operator|.
name|detail
operator|=
name|detail
expr_stmt|;
name|event
operator|->
name|b
operator|.
name|u
operator|.
name|keyButtonPointer
operator|.
name|time
operator|=
name|event_time
expr_stmt|;
name|event
operator|->
name|b
operator|.
name|u
operator|.
name|keyButtonPointer
operator|.
name|rootX
operator|=
name|hpPointer
operator|->
name|coords
index|[
literal|0
index|]
expr_stmt|;
name|event
operator|->
name|b
operator|.
name|u
operator|.
name|keyButtonPointer
operator|.
name|rootY
operator|=
name|hpPointer
operator|->
name|coords
index|[
literal|1
index|]
expr_stmt|;
name|event
operator|->
name|b
operator|.
name|u
operator|.
name|keyButtonPointer
operator|.
name|pad1
operator|=
name|log
operator|->
name|dev_id
expr_stmt|;
ifdef|#
directive|ifdef
name|XINPUT
if|if
condition|(
name|type
operator|>=
name|FIRST_EXTENSION_EVENT
condition|)
block|{
name|event
operator|->
name|b
operator|.
name|u
operator|.
name|keyButtonPointer
operator|.
name|pad1
operator||=
name|MORE_EVENTS
expr_stmt|;
name|event
operator|->
name|x
operator|.
name|type
operator|=
name|DeviceValuator
expr_stmt|;
name|event
operator|->
name|x
operator|.
name|deviceid
operator|=
name|log
operator|->
name|dev_id
expr_stmt|;
if|if
condition|(
name|log
operator|->
name|hpflags
operator|&
name|NON_CONTIGUOUS_DATA
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
operator|(
name|u_char
operator|)
name|log
operator|->
name|hil_header
operator|.
name|ax_num
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|log
operator|->
name|coords
index|[
name|j
index|]
operator|!=
literal|0
condition|)
block|{
name|event
operator|->
name|x
operator|.
name|num_valuators
operator|=
literal|1
expr_stmt|;
name|event
operator|->
name|x
operator|.
name|first_valuator
operator|=
name|j
expr_stmt|;
name|event
operator|->
name|x
operator|.
name|valuator0
operator|=
name|log
operator|->
name|coords
index|[
name|j
index|]
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
block|}
else|else
block|{
name|event
operator|->
name|x
operator|.
name|num_valuators
operator|=
name|log
operator|->
name|hil_header
operator|.
name|ax_num
expr_stmt|;
name|event
operator|->
name|x
operator|.
name|first_valuator
operator|=
literal|0
expr_stmt|;
name|ip
operator|=
operator|&
name|event
operator|->
name|x
operator|.
name|valuator0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|6
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|i
operator|<
operator|(
name|u_char
operator|)
name|log
operator|->
name|hil_header
operator|.
name|ax_num
condition|)
operator|*
name|ip
operator|++
operator|=
name|log
operator|->
name|coords
index|[
name|j
index|]
expr_stmt|;
else|else
operator|*
name|ip
operator|++
operator|=
literal|0
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* XINPUT */
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/********************************************************************  *  * ProcessInputEvents()  * This routine is invoked from the dispatcher to route events.    * It invokes the dix routines to do this.  *  */
end_comment

begin_define
define|#
directive|define
name|CLICK_VOICE
value|2
end_define

begin_macro
name|ProcessInputEvents
argument_list|()
end_macro

begin_block
block|{
name|int
name|click
decl_stmt|,
name|id
decl_stmt|,
name|i
decl_stmt|;
name|INT32
modifier|*
name|ip
decl_stmt|;
name|int
name|count
decl_stmt|;
name|xHPEvent
modifier|*
name|event
decl_stmt|;
name|DeviceIntPtr
name|dev
decl_stmt|;
name|Bool
name|checkedscreensave
init|=
name|FALSE
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__hp_osf
argument_list|)
if|if
condition|(
name|hil_qp
operator|->
name|hil_evqueue
operator|.
name|head
operator|!=
name|hil_qp
operator|->
name|hil_evqueue
operator|.
name|tail
condition|)
name|read_shmhil
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* __hp_osf */
while|while
condition|(
name|events_queue
operator|->
name|head
operator|!=
name|events_queue
operator|->
name|tail
condition|)
block|{
if|if
condition|(
operator|!
name|checkedscreensave
condition|)
block|{
if|if
condition|(
name|screenIsSaved
operator|==
name|SCREEN_SAVER_ON
operator|&&
operator|!
name|display_borrowed
condition|)
name|SaveScreens
argument_list|(
name|SCREEN_SAVER_OFF
argument_list|,
name|ScreenSaverReset
argument_list|)
expr_stmt|;
name|checkedscreensave
operator|=
name|TRUE
expr_stmt|;
block|}
name|event
operator|=
operator|&
operator|(
operator|(
name|events_queue
operator|->
name|events
operator|)
index|[
operator|(
name|events_queue
operator|->
name|head
operator|)
index|]
operator|)
expr_stmt|;
switch|switch
condition|(
name|event
operator|->
name|b
operator|.
name|u
operator|.
name|u
operator|.
name|type
condition|)
block|{
case|case
name|KeyPress
case|:
if|if
condition|(
name|keyboard_click
condition|)
name|beep
argument_list|(
name|CLICK_VOICE
argument_list|,
literal|800
argument_list|,
name|keyboard_click
argument_list|,
literal|1
argument_list|)
expr_stmt|;
case|case
name|KeyRelease
case|:
name|dev
operator|=
operator|(
name|DeviceIntPtr
operator|)
name|LookupKeyboardDevice
argument_list|()
expr_stmt|;
call|(
modifier|*
name|dev
operator|->
name|public
operator|.
name|processInputProc
call|)
argument_list|(
name|event
argument_list|,
name|dev
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|ButtonPress
case|:
case|case
name|ButtonRelease
case|:
case|case
name|MotionNotify
case|:
name|dev
operator|=
operator|(
name|DeviceIntPtr
operator|)
name|LookupPointerDevice
argument_list|()
expr_stmt|;
call|(
modifier|*
name|dev
operator|->
name|public
operator|.
name|processInputProc
call|)
argument_list|(
name|event
argument_list|,
name|dev
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
default|default:
ifdef|#
directive|ifdef
name|XINPUT
name|id
operator|=
name|event
operator|->
name|b
operator|.
name|u
operator|.
name|keyButtonPointer
operator|.
name|pad1
operator|&
name|DEVICE_BITS
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|event
operator|->
name|b
operator|.
name|u
operator|.
name|keyButtonPointer
operator|.
name|pad1
operator|&
name|MORE_EVENTS
operator|)
condition|)
name|count
operator|=
literal|1
expr_stmt|;
else|else
name|count
operator|=
literal|2
expr_stmt|;
name|dev
operator|=
name|LookupDeviceIntRec
argument_list|(
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
name|event
operator|->
name|b
operator|.
name|u
operator|.
name|u
operator|.
name|type
operator|==
name|DeviceKeyPress
condition|)
block|{
if|if
condition|(
name|dev
operator|->
name|kbdfeed
condition|)
name|click
operator|=
call|(
name|int
call|)
argument_list|(
call|(
name|double
call|)
argument_list|(
name|dev
operator|->
name|kbdfeed
operator|->
name|ctrl
operator|.
name|click
argument_list|)
operator|*
literal|15.0
operator|/
literal|100.0
argument_list|)
expr_stmt|;
if|if
condition|(
name|click
condition|)
name|beep
argument_list|(
name|CLICK_VOICE
argument_list|,
literal|800
argument_list|,
name|click
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|event
operator|->
name|b
operator|.
name|u
operator|.
name|u
operator|.
name|type
operator|==
name|DeviceMotionNotify
condition|)
block|{
name|ip
operator|=
operator|&
name|event
operator|->
name|x
operator|.
name|valuator0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|u_char
operator|)
name|event
operator|->
name|x
operator|.
name|num_valuators
condition|;
name|i
operator|++
control|)
name|dev
operator|->
name|valuator
operator|->
name|axisVal
index|[
name|i
index|]
operator|=
operator|*
operator|(
name|ip
operator|+
name|i
operator|)
expr_stmt|;
block|}
call|(
modifier|*
name|dev
operator|->
name|public
operator|.
name|processInputProc
call|)
argument_list|(
name|event
argument_list|,
name|dev
argument_list|,
name|count
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* XINPUT */
break|break;
block|}
if|if
condition|(
name|events_queue
operator|->
name|head
operator|==
name|WR_EVENTS
condition|)
name|events_queue
operator|->
name|head
operator|=
literal|0
expr_stmt|;
else|else
name|events_queue
operator|->
name|head
operator|++
expr_stmt|;
block|}
name|queue_events_free
operator|=
name|WR_EVENTS
expr_stmt|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|__hp_osf
end_ifdef

begin_comment
comment|/******************************************************************  *   * This routine removes data from the HIL shared memory event queue,  * and processes it through the server ddx input event processing code.  *  */
end_comment

begin_define
define|#
directive|define
name|NONDATA_BYTES
value|7
end_define

begin_define
define|#
directive|define
name|MAXNAMLEN
value|255
end_define

begin_macro
name|read_shmhil
argument_list|()
end_macro

begin_block
block|{
name|int
name|i
decl_stmt|,
name|head
decl_stmt|;
name|char
name|dev_name
index|[
name|MAXNAMLEN
index|]
decl_stmt|;
name|u_char
modifier|*
name|buf
decl_stmt|;
name|DeviceIntPtr
name|dev
decl_stmt|;
name|void
name|process_hil_data
parameter_list|()
function_decl|;
name|xHPEvent
modifier|*
name|xHP
decl_stmt|;
while|while
condition|(
name|hil_qp
operator|->
name|hil_evqueue
operator|.
name|head
operator|!=
name|hil_qp
operator|->
name|hil_evqueue
operator|.
name|tail
condition|)
block|{
name|head
operator|=
name|hil_qp
operator|->
name|hil_evqueue
operator|.
name|head
expr_stmt|;
name|sprintf
argument_list|(
name|dev_name
argument_list|,
literal|"/dev/hil%d"
argument_list|,
name|hil_qp
operator|->
name|hil_event
index|[
name|head
index|]
operator|.
name|dev
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_LOGICAL_DEVS
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|l_devs
index|[
name|i
index|]
operator|.
name|dev_name
argument_list|,
name|dev_name
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|i
operator|==
name|MAX_LOGICAL_DEVS
condition|)
name|FatalError
argument_list|(
literal|"Can't find input device %s\n queue head = %d\n queue tail = %d\n event timestamp = 0x%x\n event pollheader = 0x%x\n event size = %d\n"
argument_list|,
name|dev_name
argument_list|,
name|head
argument_list|,
name|hil_qp
operator|->
name|hil_evqueue
operator|.
name|tail
argument_list|,
name|hil_qp
operator|->
name|hil_event
index|[
name|head
index|]
operator|.
name|tstamp
argument_list|,
name|hil_qp
operator|->
name|hil_event
index|[
name|head
index|]
operator|.
name|poll_hdr
argument_list|,
name|hil_qp
operator|->
name|hil_event
index|[
name|head
index|]
operator|.
name|size
argument_list|)
expr_stmt|;
name|dev
operator|=
name|find_deviceintrec
argument_list|(
operator|&
name|l_devs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|buf
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|&
name|hil_qp
operator|->
name|hil_event
index|[
name|head
index|]
operator|.
name|tstamp
expr_stmt|;
name|hil_info
operator|.
name|timestamp
operator|=
operator|(
operator|(
operator|*
name|buf
operator|&
literal|0x0ff
operator|)
operator|<<
literal|24
operator|)
operator||
operator|(
operator|(
operator|*
operator|(
name|buf
operator|+
literal|1
operator|)
operator|&
literal|0x0ff
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
operator|*
operator|(
name|buf
operator|+
literal|2
operator|)
operator|&
literal|0x0ff
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
operator|*
operator|(
name|buf
operator|+
literal|3
operator|)
operator|&
literal|0x0ff
operator|)
expr_stmt|;
name|hil_info
operator|.
name|timestamp
operator|=
operator|(
name|hil_info
operator|.
name|timestamp
operator|-
literal|1
operator|)
operator|*
literal|10
expr_stmt|;
name|hil_info
operator|.
name|poll_hdr
operator|=
name|hil_qp
operator|->
name|hil_event
index|[
name|head
index|]
operator|.
name|poll_hdr
operator|&
name|HIL_POLL_HDR_BITS
expr_stmt|;
name|pending_bytes
operator|=
name|hil_qp
operator|->
name|hil_event
index|[
name|head
index|]
operator|.
name|size
operator|-
name|NONDATA_BYTES
expr_stmt|;
name|pending_index
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pending_bytes
condition|;
name|i
operator|++
control|)
name|hil_info
operator|.
name|dev_data
index|[
name|i
index|]
operator|=
name|hil_qp
operator|->
name|hil_event
index|[
name|head
index|]
operator|.
name|dev_data
index|[
name|i
index|]
expr_stmt|;
name|lastEventTime
operator|=
name|hil_info
operator|.
name|timestamp
expr_stmt|;
comment|/* Used by ScreenSaver  */
name|process_hil_data
argument_list|(
name|dev
argument_list|,
name|hil_info
operator|.
name|hil_dev
argument_list|,
operator|&
operator|(
name|hil_info
operator|)
argument_list|)
expr_stmt|;
name|hil_qp
operator|->
name|hil_evqueue
operator|.
name|head
operator|=
operator|(
name|hil_qp
operator|->
name|hil_evqueue
operator|.
name|head
operator|+
literal|1
operator|)
operator|%
name|hil_qp
operator|->
name|hil_evqueue
operator|.
name|size
expr_stmt|;
comment|/* MUST use real head pointer, 						   process_button may have 						   incremented it.      */
block|}
if|if
condition|(
name|xE
operator|.
name|b
operator|.
name|u
operator|.
name|u
operator|.
name|type
operator|!=
literal|0
condition|)
comment|/* at least 1 motion event */
block|{
name|xHP
operator|=
name|allocate_event
argument_list|()
expr_stmt|;
comment|/* get current queue pointer*/
operator|*
name|xHP
operator|=
name|xE
expr_stmt|;
comment|/* copy from global struct  */
name|xE
operator|.
name|b
operator|.
name|u
operator|.
name|u
operator|.
name|type
operator|=
literal|0
expr_stmt|;
comment|/* mark it as processed	    */
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __hp_osf */
end_comment

begin_function
name|Bool
name|get_serial_event
parameter_list|(
name|hil_ptr
parameter_list|)
name|struct
name|dev_info
modifier|*
name|hil_ptr
decl_stmt|;
comment|/* holds hil_data */
block|{
name|int
name|i
decl_stmt|,
name|status
decl_stmt|;
name|hil_ptr
operator|->
name|timestamp
operator|=
name|GetTimeInMillis
argument_list|()
expr_stmt|;
name|hil_ptr
operator|->
name|poll_hdr
operator|=
literal|0
expr_stmt|;
name|pending_index
operator|=
literal|0
expr_stmt|;
name|pending_bytes
operator|=
literal|0
expr_stmt|;
name|bzero
argument_list|(
name|hil_ptr
operator|->
name|dev_data
argument_list|,
literal|36
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_serial_devices
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|hil_ptr
operator|->
name|hil_dev
operator|->
name|file_ds
operator|==
name|serialprocs
index|[
name|i
index|]
operator|.
name|fd
condition|)
block|{
name|status
operator|=
operator|(
operator|*
operator|(
name|serialprocs
index|[
name|i
index|]
operator|.
name|read
operator|)
operator|)
operator|(
name|hil_ptr
operator|->
name|hil_dev
operator|->
name|file_ds
operator|,
name|hil_ptr
operator|->
name|dev_data
operator|,
operator|&
name|hil_ptr
operator|->
name|poll_hdr
operator|,
operator|&
name|pending_bytes
operator|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|status
operator|==
name|READ_SUCCESS
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
else|else
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

end_unit

