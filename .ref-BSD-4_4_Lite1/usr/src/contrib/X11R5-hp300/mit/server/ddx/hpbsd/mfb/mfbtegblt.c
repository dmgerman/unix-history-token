begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $XConsortium: mfbtegblt.c,v 5.7 91/05/26 09:02:16 rws Exp $ */
end_comment

begin_comment
comment|/* Combined Purdue/PurduePlus patches, level 2.0, 1/17/89 */
end_comment

begin_comment
comment|/*********************************************************** Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts, and the Massachusetts Institute of Technology, Cambridge, Massachusetts.                          All Rights Reserved  Permission to use, copy, modify, and distribute this software and its  documentation for any purpose and without fee is hereby granted,  provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in  supporting documentation, and that the names of Digital or MIT not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.    DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  ******************************************************************/
end_comment

begin_include
include|#
directive|include
file|"X.h"
end_include

begin_include
include|#
directive|include
file|"Xmd.h"
end_include

begin_include
include|#
directive|include
file|"Xproto.h"
end_include

begin_include
include|#
directive|include
file|"mfb.h"
end_include

begin_include
include|#
directive|include
file|"fontstruct.h"
end_include

begin_include
include|#
directive|include
file|"dixfontstr.h"
end_include

begin_include
include|#
directive|include
file|"gcstruct.h"
end_include

begin_include
include|#
directive|include
file|"windowstr.h"
end_include

begin_include
include|#
directive|include
file|"scrnintstr.h"
end_include

begin_include
include|#
directive|include
file|"pixmapstr.h"
end_include

begin_include
include|#
directive|include
file|"regionstr.h"
end_include

begin_include
include|#
directive|include
file|"maskbits.h"
end_include

begin_comment
comment|/*     this works for fonts with glyphs<= 32 bits wide.      This should be called only with a terminal-emulator font; this means that the FIXED_METRICS flag is set, and that glyphbounds == charbounds.      in theory, this goes faster; even if it doesn't, it reduces the flicker caused by writing a string over itself with image text (since the background gets repainted per character instead of per string.) this seems to be important for some converted X10 applications.      Image text looks at the bits in the glyph and the fg and bg in the GC.  it paints a rectangle, as defined in the protocol dcoument, and the paints the characters.     to avoid source proliferation, this file is compiled two times: 	MFBTEGLYPHBLT		OP 	mfbTEGlyphBltWhite		(white text, black bg ) 	mfbTEGlyphBltBlack	~	(black text, white bg )  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|NO_3_60_CG4
argument_list|)
operator|&&
name|defined
argument_list|(
name|FASTPUTBITS
argument_list|)
operator|&&
name|defined
argument_list|(
name|FASTGETBITS
argument_list|)
end_if

begin_define
define|#
directive|define
name|FASTCHARS
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * this macro "knows" that only characters<= 8 bits wide will  * fit this case (which is why it is independent of GLYPHPADBYTES)  */
end_comment

begin_if
if|#
directive|if
operator|(
name|BITMAP_BIT_ORDER
operator|==
name|MSBFirst
operator|)
operator|&&
operator|(
name|GLYPHPADBYTES
operator|!=
literal|4
operator|)
end_if

begin_if
if|#
directive|if
name|GLYPHPADBYTES
operator|==
literal|1
end_if

begin_define
define|#
directive|define
name|ShiftAmnt
value|24
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|ShiftAmnt
value|16
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|GetBits4
value|c = (*char1++<< ShiftAmnt) | \ 			SCRRIGHT (*char2++<< ShiftAmnt, xoff2) | \ 			SCRRIGHT (*char3++<< ShiftAmnt, xoff3) | \ 			SCRRIGHT (*char4++<< ShiftAmnt, xoff4);
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|GetBits4
value|c = *char1++ | \ 			SCRRIGHT (*char2++, xoff2) | \ 			SCRRIGHT (*char3++, xoff3) | \ 			SCRRIGHT (*char4++, xoff4);
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|GLYPHPADBYTES
operator|==
literal|1
end_if

begin_typedef
typedef|typedef
name|unsigned
name|char
modifier|*
name|glyphPointer
typedef|;
end_typedef

begin_define
define|#
directive|define
name|USE_LEFTBITS
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|GLYPHPADBYTES
operator|==
literal|2
end_if

begin_typedef
typedef|typedef
name|unsigned
name|short
modifier|*
name|glyphPointer
typedef|;
end_typedef

begin_define
define|#
directive|define
name|USE_LEFTBITS
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|GLYPHPADBYTES
operator|==
literal|4
end_if

begin_typedef
typedef|typedef
name|unsigned
name|int
modifier|*
name|glyphPointer
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|USE_LEFTBITS
end_ifdef

begin_define
define|#
directive|define
name|GetBits1
value|getleftbits (char1, widthGlyph, c); \ 		    c&= glyphMask; \ 		    char1 = (glyphPointer) (((char *) char1) + glyphBytes);
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|GetBits1
value|c = *char1++;
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|MFBTEGLYPHBLT
parameter_list|(
name|pDrawable
parameter_list|,
name|pGC
parameter_list|,
name|x
parameter_list|,
name|y
parameter_list|,
name|nglyph
parameter_list|,
name|ppci
parameter_list|,
name|pglyphBase
parameter_list|)
name|DrawablePtr
name|pDrawable
decl_stmt|;
name|GC
modifier|*
name|pGC
decl_stmt|;
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
name|unsigned
name|int
name|nglyph
decl_stmt|;
name|CharInfoPtr
modifier|*
name|ppci
decl_stmt|;
comment|/* array of character info */
name|unsigned
name|char
modifier|*
name|pglyphBase
decl_stmt|;
comment|/* start of array of glyphs */
block|{
name|FontPtr
name|pfont
init|=
name|pGC
operator|->
name|font
decl_stmt|;
name|int
name|widthDst
decl_stmt|;
name|unsigned
name|int
modifier|*
name|pdstBase
decl_stmt|;
comment|/* pointer to longword with top row  				   of current glyph */
name|int
name|h
decl_stmt|;
comment|/* height of glyph and char */
specifier|register
name|int
name|xpos
decl_stmt|;
comment|/* current x  */
name|int
name|ypos
decl_stmt|;
comment|/* current y */
name|int
name|widthGlyph
decl_stmt|;
name|int
name|hTmp
decl_stmt|;
comment|/* counter for height */
specifier|register
name|int
name|startmask
decl_stmt|,
name|endmask
decl_stmt|;
name|int
name|nfirst
decl_stmt|;
comment|/* used if glyphs spans a longword boundary */
name|BoxRec
name|bbox
decl_stmt|;
comment|/* for clipping */
name|int
name|widthGlyphs
decl_stmt|;
specifier|register
name|unsigned
name|int
modifier|*
name|dst
decl_stmt|;
specifier|register
name|unsigned
name|int
name|c
decl_stmt|;
specifier|register
name|int
name|xoff1
decl_stmt|,
name|xoff2
decl_stmt|,
name|xoff3
decl_stmt|,
name|xoff4
decl_stmt|;
specifier|register
name|glyphPointer
name|char1
decl_stmt|,
name|char2
decl_stmt|,
name|char3
decl_stmt|,
name|char4
decl_stmt|;
ifdef|#
directive|ifdef
name|USE_LEFTBITS
specifier|register
name|int
name|glyphMask
decl_stmt|;
specifier|register
name|unsigned
name|int
name|tmpSrc
decl_stmt|;
specifier|register
name|int
name|glyphBytes
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
operator|(
name|pGC
operator|->
name|planemask
operator|&
literal|1
operator|)
condition|)
return|return;
if|if
condition|(
name|pDrawable
operator|->
name|type
operator|==
name|DRAWABLE_WINDOW
condition|)
block|{
name|pdstBase
operator|=
operator|(
name|unsigned
name|int
operator|*
operator|)
name|getPrivScreenPtr
argument_list|(
name|pDrawable
operator|->
name|pScreen
argument_list|)
operator|->
name|bits
expr_stmt|;
name|widthDst
operator|=
operator|(
name|int
operator|)
name|getPrivScreenPtr
argument_list|(
name|pDrawable
operator|->
name|pScreen
argument_list|)
operator|->
name|stride
operator|>>
literal|2
expr_stmt|;
block|}
else|else
block|{
name|pdstBase
operator|=
operator|(
name|unsigned
name|int
operator|*
operator|)
name|getPrivPixmapPtr
argument_list|(
name|pDrawable
argument_list|)
operator|->
name|bits
expr_stmt|;
name|widthDst
operator|=
operator|(
name|int
operator|)
name|getPrivPixmapPtr
argument_list|(
name|pDrawable
argument_list|)
operator|->
name|stride
operator|>>
literal|2
expr_stmt|;
block|}
name|xpos
operator|=
name|x
operator|+
name|pDrawable
operator|->
name|x
expr_stmt|;
name|ypos
operator|=
name|y
operator|+
name|pDrawable
operator|->
name|y
expr_stmt|;
name|widthGlyph
operator|=
name|FONTMAXBOUNDS
argument_list|(
name|pfont
argument_list|,
name|characterWidth
argument_list|)
expr_stmt|;
name|h
operator|=
name|FONTASCENT
argument_list|(
name|pfont
argument_list|)
operator|+
name|FONTDESCENT
argument_list|(
name|pfont
argument_list|)
expr_stmt|;
name|xpos
operator|+=
name|FONTMAXBOUNDS
argument_list|(
name|pfont
argument_list|,
name|leftSideBearing
argument_list|)
expr_stmt|;
name|ypos
operator|-=
name|FONTASCENT
argument_list|(
name|pfont
argument_list|)
expr_stmt|;
name|bbox
operator|.
name|x1
operator|=
name|xpos
expr_stmt|;
name|bbox
operator|.
name|x2
operator|=
name|xpos
operator|+
operator|(
name|widthGlyph
operator|*
name|nglyph
operator|)
expr_stmt|;
name|bbox
operator|.
name|y1
operator|=
name|ypos
expr_stmt|;
name|bbox
operator|.
name|y2
operator|=
name|ypos
operator|+
name|h
expr_stmt|;
switch|switch
condition|(
call|(
modifier|*
name|pGC
operator|->
name|pScreen
operator|->
name|RectIn
call|)
argument_list|(
operator|(
operator|(
name|mfbPrivGC
operator|*
operator|)
operator|(
name|pGC
operator|->
name|devPrivates
index|[
name|mfbGCPrivateIndex
index|]
operator|.
name|ptr
operator|)
operator|)
operator|->
name|pCompositeClip
argument_list|,
operator|&
name|bbox
argument_list|)
condition|)
block|{
case|case
name|rgnPART
case|:
comment|/* this is the WRONG thing to do, but it works. 	   calling the non-terminal text is easy, but slow, given 	   what we know about the font.  	   the right thing to do is something like: 	    for each clip rectangle 		compute at which row the glyph starts to be in it, 		   and at which row the glyph ceases to be in it 		compute which is the first glyph inside the left 		    edge, and the last one inside the right edge 		draw a fractional first glyph, using only 		    the rows we know are in 		draw all the whole glyphs, using the appropriate rows 		draw any pieces of the last glyph, using the right rows  	   this way, the code would take advantage of knowing that 	   all glyphs are the same height and don't overlap.  	   one day... 	*/
name|CLIPTETEXT
argument_list|(
name|pDrawable
argument_list|,
name|pGC
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|nglyph
argument_list|,
name|ppci
argument_list|,
name|pglyphBase
argument_list|)
expr_stmt|;
case|case
name|rgnOUT
case|:
return|return;
block|}
name|pdstBase
operator|+=
name|widthDst
operator|*
name|ypos
expr_stmt|;
name|widthGlyphs
operator|=
name|widthGlyph
operator|<<
literal|2
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_LEFTBITS
name|glyphMask
operator|=
name|endtab
index|[
name|widthGlyph
index|]
expr_stmt|;
name|glyphBytes
operator|=
name|GLYPHWIDTHBYTESPADDED
argument_list|(
operator|*
name|ppci
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|nglyph
operator|>=
literal|4
operator|&&
name|widthGlyphs
operator|<=
literal|32
condition|)
block|{
while|while
condition|(
name|nglyph
operator|>=
literal|4
condition|)
block|{
name|nglyph
operator|-=
literal|4
expr_stmt|;
name|xoff1
operator|=
name|xpos
operator|&
literal|0x1f
expr_stmt|;
name|xoff2
operator|=
name|widthGlyph
expr_stmt|;
name|xoff3
operator|=
name|xoff2
operator|+
name|widthGlyph
expr_stmt|;
name|xoff4
operator|=
name|xoff3
operator|+
name|widthGlyph
expr_stmt|;
name|char1
operator|=
operator|(
name|glyphPointer
operator|)
name|FONTGLYPHBITS
argument_list|(
name|pglyphBase
argument_list|,
operator|(
operator|*
name|ppci
operator|++
operator|)
argument_list|)
expr_stmt|;
name|char2
operator|=
operator|(
name|glyphPointer
operator|)
name|FONTGLYPHBITS
argument_list|(
name|pglyphBase
argument_list|,
operator|(
operator|*
name|ppci
operator|++
operator|)
argument_list|)
expr_stmt|;
name|char3
operator|=
operator|(
name|glyphPointer
operator|)
name|FONTGLYPHBITS
argument_list|(
name|pglyphBase
argument_list|,
operator|(
operator|*
name|ppci
operator|++
operator|)
argument_list|)
expr_stmt|;
name|char4
operator|=
operator|(
name|glyphPointer
operator|)
name|FONTGLYPHBITS
argument_list|(
name|pglyphBase
argument_list|,
operator|(
operator|*
name|ppci
operator|++
operator|)
argument_list|)
expr_stmt|;
name|hTmp
operator|=
name|h
expr_stmt|;
name|dst
operator|=
name|pdstBase
operator|+
operator|(
name|xpos
operator|>>
literal|5
operator|)
expr_stmt|;
ifndef|#
directive|ifndef
name|FASTCHARS
if|if
condition|(
name|xoff1
operator|+
name|widthGlyphs
operator|<=
literal|32
condition|)
block|{
name|maskpartialbits
argument_list|(
name|xoff1
argument_list|,
name|widthGlyphs
argument_list|,
name|startmask
argument_list|)
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
name|hTmp
operator|--
condition|)
block|{
name|GetBits4
ifdef|#
directive|ifdef
name|FASTCHARS
if|#
directive|if
name|BITMAP_BIT_ORDER
operator|==
name|MSBFirst
name|c
operator|>>=
literal|32
operator|-
name|widthGlyphs
expr_stmt|;
endif|#
directive|endif
name|FASTPUTBITS
argument_list|(
name|OP
argument_list|(
name|c
argument_list|)
argument_list|,
name|xoff1
argument_list|,
name|widthGlyphs
argument_list|,
name|dst
argument_list|)
expr_stmt|;
else|#
directive|else
operator|*
operator|(
name|dst
operator|)
operator|=
operator|(
operator|*
name|dst
operator|)
operator|&
operator|~
name|startmask
operator||
name|OP
argument_list|(
name|SCRRIGHT
argument_list|(
name|c
argument_list|,
name|xoff1
argument_list|)
argument_list|)
operator|&
name|startmask
expr_stmt|;
endif|#
directive|endif
name|dst
operator|+=
name|widthDst
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|FASTCHARS
block|}
else|else
block|{
name|mask32bits
argument_list|(
name|xoff1
argument_list|,
name|widthGlyphs
argument_list|,
name|startmask
argument_list|,
name|endmask
argument_list|)
expr_stmt|;
name|nfirst
operator|=
literal|32
operator|-
name|xoff1
expr_stmt|;
while|while
condition|(
name|hTmp
operator|--
condition|)
block|{
name|GetBits4
name|dst
index|[
literal|0
index|]
init|=
name|dst
index|[
literal|0
index|]
operator|&
operator|~
name|startmask
operator||
name|OP
argument_list|(
name|SCRRIGHT
argument_list|(
name|c
argument_list|,
name|xoff1
argument_list|)
argument_list|)
operator|&
name|startmask
decl_stmt|;
name|dst
index|[
literal|1
index|]
operator|=
name|dst
index|[
literal|1
index|]
operator|&
operator|~
name|endmask
operator||
name|OP
argument_list|(
name|SCRLEFT
argument_list|(
name|c
argument_list|,
name|nfirst
argument_list|)
argument_list|)
operator|&
name|endmask
expr_stmt|;
name|dst
operator|+=
name|widthDst
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|xpos
operator|+=
name|widthGlyphs
expr_stmt|;
block|}
block|}
while|while
condition|(
name|nglyph
operator|--
condition|)
block|{
name|xoff1
operator|=
name|xpos
operator|&
literal|0x1f
expr_stmt|;
name|char1
operator|=
operator|(
name|glyphPointer
operator|)
name|FONTGLYPHBITS
argument_list|(
name|pglyphBase
argument_list|,
operator|(
operator|*
name|ppci
operator|++
operator|)
argument_list|)
expr_stmt|;
name|hTmp
operator|=
name|h
expr_stmt|;
name|dst
operator|=
name|pdstBase
operator|+
operator|(
name|xpos
operator|>>
literal|5
operator|)
expr_stmt|;
ifndef|#
directive|ifndef
name|FASTCHARS
if|if
condition|(
name|xoff1
operator|+
name|widthGlyph
operator|<=
literal|32
condition|)
block|{
name|maskpartialbits
argument_list|(
name|xoff1
argument_list|,
name|widthGlyph
argument_list|,
name|startmask
argument_list|)
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
name|hTmp
operator|--
condition|)
block|{
ifdef|#
directive|ifdef
name|FASTCHARS
ifdef|#
directive|ifdef
name|USE_LEFTBITS
name|FASTGETBITS
argument_list|(
name|char1
argument_list|,
literal|0
argument_list|,
name|widthGlyph
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|char1
operator|=
call|(
name|glyphPointer
call|)
argument_list|(
operator|(
operator|(
name|char
operator|*
operator|)
name|char1
operator|)
operator|+
name|glyphBytes
argument_list|)
expr_stmt|;
else|#
directive|else
name|c
operator|=
operator|*
name|char1
operator|++
expr_stmt|;
if|#
directive|if
name|BITMAP_BIT_ORDER
operator|==
name|MSBFirst
name|c
operator|>>=
literal|32
operator|-
name|widthGlyph
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
name|FASTPUTBITS
argument_list|(
name|OP
argument_list|(
name|c
argument_list|)
argument_list|,
name|xoff1
argument_list|,
name|widthGlyph
argument_list|,
name|dst
argument_list|)
expr_stmt|;
else|#
directive|else
name|GetBits1
argument_list|(
operator|*
name|dst
argument_list|)
operator|=
operator|(
operator|*
name|dst
operator|)
operator|&
operator|~
name|startmask
operator||
name|OP
argument_list|(
name|SCRRIGHT
argument_list|(
name|c
argument_list|,
name|xoff1
argument_list|)
argument_list|)
operator|&
name|startmask
expr_stmt|;
endif|#
directive|endif
name|dst
operator|+=
name|widthDst
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|FASTCHARS
block|}
else|else
block|{
name|mask32bits
argument_list|(
name|xoff1
argument_list|,
name|widthGlyph
argument_list|,
name|startmask
argument_list|,
name|endmask
argument_list|)
expr_stmt|;
name|nfirst
operator|=
literal|32
operator|-
name|xoff1
expr_stmt|;
while|while
condition|(
name|hTmp
operator|--
condition|)
block|{
name|GetBits1
name|dst
index|[
literal|0
index|]
init|=
name|dst
index|[
literal|0
index|]
operator|&
operator|~
name|startmask
operator||
name|OP
argument_list|(
name|SCRRIGHT
argument_list|(
name|c
argument_list|,
name|xoff1
argument_list|)
argument_list|)
operator|&
name|startmask
decl_stmt|;
name|dst
index|[
literal|1
index|]
operator|=
name|dst
index|[
literal|1
index|]
operator|&
operator|~
name|endmask
operator||
name|OP
argument_list|(
name|SCRLEFT
argument_list|(
name|c
argument_list|,
name|nfirst
argument_list|)
argument_list|)
operator|&
name|endmask
expr_stmt|;
name|dst
operator|+=
name|widthDst
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|xpos
operator|+=
name|widthGlyph
expr_stmt|;
block|}
block|}
end_function

end_unit

