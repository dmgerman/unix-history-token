begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/************************************************************ Copyright 1987 by Sun Microsystems, Inc. Mountain View, CA.                      All Rights Reserved  Permission  to  use,  copy,  modify,  and  distribute   this software  and  its documentation for any purpose and without fee is hereby granted, provided that the above copyright no- tice  appear  in all copies and that both that copyright no- tice and this permission notice appear in  supporting  docu- mentation,  and  that the names of Sun or MIT not be used in advertising or publicity pertaining to distribution  of  the software  without specific prior written permission. Sun and M.I.T. make no representations about the suitability of this software for any purpose. It is provided "as is" without any express or implied warranty.  SUN DISCLAIMS ALL WARRANTIES WITH REGARD TO  THIS  SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FIT- NESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL SUN BE  LI- ABLE  FOR  ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,  DATA  OR PROFITS,  WHETHER  IN  AN  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION  WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  ********************************************************/
end_comment

begin_comment
comment|/*********************************************************** Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts, and the Massachusetts Institute of Technology, Cambridge, Massachusetts.                          All Rights Reserved  Permission to use, copy, modify, and distribute this software and its  documentation for any purpose and without fee is hereby granted,  provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in  supporting documentation, and that the names of Digital or MIT not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.    DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  ******************************************************************/
end_comment

begin_comment
comment|/* $XConsortium: cfbfillsp.c,v 5.17 91/07/18 23:31:04 keith Exp $ */
end_comment

begin_include
include|#
directive|include
file|"X.h"
end_include

begin_include
include|#
directive|include
file|"Xmd.h"
end_include

begin_include
include|#
directive|include
file|"servermd.h"
end_include

begin_include
include|#
directive|include
file|"gcstruct.h"
end_include

begin_include
include|#
directive|include
file|"window.h"
end_include

begin_include
include|#
directive|include
file|"pixmapstr.h"
end_include

begin_include
include|#
directive|include
file|"scrnintstr.h"
end_include

begin_include
include|#
directive|include
file|"windowstr.h"
end_include

begin_include
include|#
directive|include
file|"cfb.h"
end_include

begin_include
include|#
directive|include
file|"cfbmskbits.h"
end_include

begin_include
include|#
directive|include
file|"mergerop.h"
end_include

begin_if
if|#
directive|if
name|PPW
operator|==
literal|4
end_if

begin_include
include|#
directive|include
file|"cfb8bit.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|void
name|mfbInvertSolidFS
argument_list|()
decl_stmt|,
name|mfbBlackSolidFS
argument_list|()
decl_stmt|,
name|mfbWhiteSolidFS
argument_list|()
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* scanline filling for color frame buffer    written by drewry, oct 1986 modified by smarks    changes for compatibility with Little-endian systems Jul 1987; MIT:yba.     these routines all clip.  they assume that anything that has called them has already translated the points (i.e. pGC->miTranslate is non-zero, which is howit gets set in cfbCreateGC().)     the number of new scnalines created by clipping == MaxRectsPerBand * nSpans.      FillSolid is overloaded to be used for OpaqueStipple as well, if fgPixel == bgPixel.   Note that for solids, PrivGC.rop == PrivGC.ropOpStip       FillTiled is overloaded to be used for OpaqueStipple, if fgPixel != bgPixel.  based on the fill style, it uses {RotatedTile, gc.alu} or {RotatedStipple, PrivGC.ropOpStip} */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|notdef
end_ifdef

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_expr_stmt
specifier|static
name|dumpspans
argument_list|(
argument|n
argument_list|,
argument|ppt
argument_list|,
argument|pwidth
argument_list|)
name|int
name|n
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|DDXPointPtr
name|ppt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|pwidth
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d spans\n"
argument_list|,
name|n
argument_list|)
expr_stmt|;
while|while
condition|(
name|n
operator|--
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"[%d,%d] %d\n"
argument_list|,
name|ppt
operator|->
name|x
argument_list|,
name|ppt
operator|->
name|y
argument_list|,
operator|*
name|pwidth
argument_list|)
expr_stmt|;
name|ppt
operator|++
expr_stmt|;
name|pwidth
operator|++
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Fill spans with tiles that aren't 32 bits wide */
end_comment

begin_function
name|void
name|cfbUnnaturalTileFS
parameter_list|(
name|pDrawable
parameter_list|,
name|pGC
parameter_list|,
name|nInit
parameter_list|,
name|pptInit
parameter_list|,
name|pwidthInit
parameter_list|,
name|fSorted
parameter_list|)
name|DrawablePtr
name|pDrawable
decl_stmt|;
name|GC
modifier|*
name|pGC
decl_stmt|;
name|int
name|nInit
decl_stmt|;
comment|/* number of spans to fill */
name|DDXPointPtr
name|pptInit
decl_stmt|;
comment|/* pointer to list of start points */
name|int
modifier|*
name|pwidthInit
decl_stmt|;
comment|/* pointer to list of n widths */
name|int
name|fSorted
decl_stmt|;
block|{
name|int
name|n
decl_stmt|;
comment|/* number of spans to fill */
specifier|register
name|DDXPointPtr
name|ppt
decl_stmt|;
comment|/* pointer to list of start points */
specifier|register
name|int
modifier|*
name|pwidth
decl_stmt|;
comment|/* pointer to list of n widths */
name|void
function_decl|(
modifier|*
name|fill
function_decl|)
parameter_list|()
function_decl|;
specifier|extern
name|void
name|cfbFillSpanTileOddCopy
parameter_list|()
function_decl|;
specifier|extern
name|void
name|cfbFillSpanTileOddGeneral
parameter_list|()
function_decl|;
specifier|extern
name|void
name|cfbFillSpanTile32sCopy
parameter_list|()
function_decl|;
specifier|extern
name|void
name|cfbFillSpanTile32sGeneral
parameter_list|()
function_decl|;
name|int
name|xrot
decl_stmt|,
name|yrot
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|pGC
operator|->
name|planemask
operator|)
condition|)
return|return;
if|if
condition|(
name|pGC
operator|->
name|tile
operator|.
name|pixmap
operator|->
name|drawable
operator|.
name|width
operator|&
name|PIM
condition|)
block|{
name|fill
operator|=
name|cfbFillSpanTileOddGeneral
expr_stmt|;
if|if
condition|(
operator|(
name|pGC
operator|->
name|planemask
operator|&
name|PMSK
operator|)
operator|==
name|PMSK
condition|)
block|{
if|if
condition|(
name|pGC
operator|->
name|alu
operator|==
name|GXcopy
condition|)
name|fill
operator|=
name|cfbFillSpanTileOddCopy
expr_stmt|;
block|}
block|}
else|else
block|{
name|fill
operator|=
name|cfbFillSpanTile32sGeneral
expr_stmt|;
if|if
condition|(
operator|(
name|pGC
operator|->
name|planemask
operator|&
name|PMSK
operator|)
operator|==
name|PMSK
condition|)
block|{
if|if
condition|(
name|pGC
operator|->
name|alu
operator|==
name|GXcopy
condition|)
name|fill
operator|=
name|cfbFillSpanTile32sCopy
expr_stmt|;
block|}
block|}
name|n
operator|=
name|nInit
operator|*
name|miFindMaxBand
argument_list|(
operator|(
operator|(
name|cfbPrivGC
operator|*
operator|)
operator|(
name|pGC
operator|->
name|devPrivates
index|[
name|cfbGCPrivateIndex
index|]
operator|.
name|ptr
operator|)
operator|)
operator|->
name|pCompositeClip
argument_list|)
expr_stmt|;
name|pwidth
operator|=
operator|(
name|int
operator|*
operator|)
name|ALLOCATE_LOCAL
argument_list|(
name|n
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|ppt
operator|=
operator|(
name|DDXPointRec
operator|*
operator|)
name|ALLOCATE_LOCAL
argument_list|(
name|n
operator|*
sizeof|sizeof
argument_list|(
name|DDXPointRec
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ppt
operator|||
operator|!
name|pwidth
condition|)
block|{
if|if
condition|(
name|ppt
condition|)
name|DEALLOCATE_LOCAL
argument_list|(
name|ppt
argument_list|)
expr_stmt|;
if|if
condition|(
name|pwidth
condition|)
name|DEALLOCATE_LOCAL
argument_list|(
name|pwidth
argument_list|)
expr_stmt|;
return|return;
block|}
name|n
operator|=
name|miClipSpans
argument_list|(
operator|(
operator|(
name|cfbPrivGC
operator|*
operator|)
operator|(
name|pGC
operator|->
name|devPrivates
index|[
name|cfbGCPrivateIndex
index|]
operator|.
name|ptr
operator|)
operator|)
operator|->
name|pCompositeClip
argument_list|,
name|pptInit
argument_list|,
name|pwidthInit
argument_list|,
name|nInit
argument_list|,
name|ppt
argument_list|,
name|pwidth
argument_list|,
name|fSorted
argument_list|)
expr_stmt|;
name|xrot
operator|=
name|pDrawable
operator|->
name|x
operator|+
name|pGC
operator|->
name|patOrg
operator|.
name|x
expr_stmt|;
name|yrot
operator|=
name|pDrawable
operator|->
name|y
operator|+
name|pGC
operator|->
name|patOrg
operator|.
name|y
expr_stmt|;
call|(
modifier|*
name|fill
call|)
argument_list|(
name|pDrawable
argument_list|,
name|n
argument_list|,
name|ppt
argument_list|,
name|pwidth
argument_list|,
name|pGC
operator|->
name|tile
operator|.
name|pixmap
argument_list|,
name|xrot
argument_list|,
name|yrot
argument_list|,
name|pGC
operator|->
name|alu
argument_list|,
name|pGC
operator|->
name|planemask
argument_list|)
expr_stmt|;
name|DEALLOCATE_LOCAL
argument_list|(
name|ppt
argument_list|)
expr_stmt|;
name|DEALLOCATE_LOCAL
argument_list|(
name|pwidth
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|PPW
operator|==
literal|4
end_if

begin_function
name|void
name|cfbUnnaturalStippleFS
parameter_list|(
name|pDrawable
parameter_list|,
name|pGC
parameter_list|,
name|nInit
parameter_list|,
name|pptInit
parameter_list|,
name|pwidthInit
parameter_list|,
name|fSorted
parameter_list|)
name|DrawablePtr
name|pDrawable
decl_stmt|;
name|GC
modifier|*
name|pGC
decl_stmt|;
name|int
name|nInit
decl_stmt|;
comment|/* number of spans to fill */
name|DDXPointPtr
name|pptInit
decl_stmt|;
comment|/* pointer to list of start points */
name|int
modifier|*
name|pwidthInit
decl_stmt|;
comment|/* pointer to list of n widths */
name|int
name|fSorted
decl_stmt|;
block|{
comment|/* next three parameters are post-clip */
name|int
name|n
decl_stmt|;
comment|/* number of spans to fill */
name|DDXPointPtr
name|ppt
decl_stmt|;
comment|/* pointer to list of start points */
name|int
modifier|*
name|pwidth
decl_stmt|;
comment|/* pointer to list of n widths */
name|int
modifier|*
name|pwidthFree
decl_stmt|;
comment|/* copies of the pointers to free */
name|DDXPointPtr
name|pptFree
decl_stmt|;
name|unsigned
name|long
modifier|*
name|pdstBase
decl_stmt|;
comment|/* pointer to start of bitmap */
name|int
name|nlwDst
decl_stmt|;
comment|/* width in longwords of bitmap */
specifier|register
name|unsigned
name|long
modifier|*
name|pdst
decl_stmt|;
comment|/* pointer to current word in bitmap */
name|PixmapPtr
name|pStipple
decl_stmt|;
comment|/* pointer to stipple we want to fill with */
name|hpPrivPixmapPtr
name|pPrivStipple
decl_stmt|;
comment|/* private data of stipple */
name|int
name|nlw
decl_stmt|;
name|int
name|x
decl_stmt|,
name|y
decl_stmt|,
name|w
decl_stmt|,
name|xrem
decl_stmt|,
name|xSrc
decl_stmt|,
name|ySrc
decl_stmt|;
name|int
name|stwidth
decl_stmt|,
name|stippleWidth
decl_stmt|;
name|int
name|stippleHeight
decl_stmt|;
specifier|register
name|unsigned
name|long
name|bits
decl_stmt|,
name|inputBits
decl_stmt|;
specifier|register
name|int
name|partBitsLeft
decl_stmt|;
name|int
name|nextPartBits
decl_stmt|;
name|int
name|bitsLeft
decl_stmt|,
name|bitsWhole
decl_stmt|;
name|unsigned
name|long
modifier|*
name|srcTemp
decl_stmt|,
modifier|*
name|srcStart
decl_stmt|;
name|unsigned
name|long
modifier|*
name|psrcBase
decl_stmt|;
name|unsigned
name|long
name|startmask
decl_stmt|,
name|endmask
decl_stmt|;
if|if
condition|(
name|pGC
operator|->
name|fillStyle
operator|==
name|FillStippled
condition|)
name|cfb8CheckStipple
argument_list|(
name|pGC
operator|->
name|alu
argument_list|,
name|pGC
operator|->
name|fgPixel
argument_list|,
name|pGC
operator|->
name|planemask
argument_list|)
expr_stmt|;
else|else
name|cfb8CheckOpaqueStipple
argument_list|(
name|pGC
operator|->
name|alu
argument_list|,
name|pGC
operator|->
name|fgPixel
argument_list|,
name|pGC
operator|->
name|bgPixel
argument_list|,
name|pGC
operator|->
name|planemask
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfb8StippleRRop
operator|==
name|GXnoop
condition|)
return|return;
name|n
operator|=
name|nInit
operator|*
name|miFindMaxBand
argument_list|(
operator|(
operator|(
name|cfbPrivGC
operator|*
operator|)
operator|(
name|pGC
operator|->
name|devPrivates
index|[
name|cfbGCPrivateIndex
index|]
operator|.
name|ptr
operator|)
operator|)
operator|->
name|pCompositeClip
argument_list|)
expr_stmt|;
name|pwidthFree
operator|=
operator|(
name|int
operator|*
operator|)
name|ALLOCATE_LOCAL
argument_list|(
name|n
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|pptFree
operator|=
operator|(
name|DDXPointRec
operator|*
operator|)
name|ALLOCATE_LOCAL
argument_list|(
name|n
operator|*
sizeof|sizeof
argument_list|(
name|DDXPointRec
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pptFree
operator|||
operator|!
name|pwidthFree
condition|)
block|{
if|if
condition|(
name|pptFree
condition|)
name|DEALLOCATE_LOCAL
argument_list|(
name|pptFree
argument_list|)
expr_stmt|;
if|if
condition|(
name|pwidthFree
condition|)
name|DEALLOCATE_LOCAL
argument_list|(
name|pwidthFree
argument_list|)
expr_stmt|;
return|return;
block|}
name|pwidth
operator|=
name|pwidthFree
expr_stmt|;
name|ppt
operator|=
name|pptFree
expr_stmt|;
name|n
operator|=
name|miClipSpans
argument_list|(
operator|(
operator|(
name|cfbPrivGC
operator|*
operator|)
operator|(
name|pGC
operator|->
name|devPrivates
index|[
name|cfbGCPrivateIndex
index|]
operator|.
name|ptr
operator|)
operator|)
operator|->
name|pCompositeClip
argument_list|,
name|pptInit
argument_list|,
name|pwidthInit
argument_list|,
name|nInit
argument_list|,
name|ppt
argument_list|,
name|pwidth
argument_list|,
name|fSorted
argument_list|)
expr_stmt|;
comment|/*      *  OK,  so what's going on here?  We have two Drawables:      *      *  The Stipple:      *		Depth = 1      *		Width = stippleWidth      *		Words per scanline = stwidth      *		Pointer to pixels = pStipple->devPrivate.ptr      */
name|pStipple
operator|=
name|pGC
operator|->
name|stipple
expr_stmt|;
name|pPrivStipple
operator|=
call|(
name|hpPrivPixmapPtr
call|)
argument_list|(
name|pStipple
operator|->
name|devPrivate
operator|.
name|ptr
argument_list|)
expr_stmt|;
name|stwidth
operator|=
name|pPrivStipple
operator|->
name|stride
operator|>>
literal|2
expr_stmt|;
name|stippleWidth
operator|=
name|pStipple
operator|->
name|drawable
operator|.
name|width
expr_stmt|;
name|stippleHeight
operator|=
name|pStipple
operator|->
name|drawable
operator|.
name|height
expr_stmt|;
name|psrcBase
operator|=
operator|(
name|unsigned
name|long
operator|*
operator|)
name|pPrivStipple
operator|->
name|bits
expr_stmt|;
comment|/*      *	The Target:      *		Depth = PSZ      *		Width = determined from *pwidth      *		Words per scanline = nlwDst      *		Pointer to pixels = addrlBase      */
name|cfbGetLongWidthAndPointer
argument_list|(
argument|pDrawable
argument_list|,
argument|nlwDst
argument_list|,
argument|pdstBase
argument_list|)
comment|/* this replaces rotating the stipple. Instead we just adjust the offset      * at which we start grabbing bits from the stipple.      * Ensure that ppt->x - xSrc>= 0 and ppt->y - ySrc>= 0,      * so that iline and xrem always stay within the stipple bounds.      */
name|modulus
argument_list|(
name|pGC
operator|->
name|patOrg
operator|.
name|x
argument_list|,
name|stippleWidth
argument_list|,
name|xSrc
argument_list|)
expr_stmt|;
name|xSrc
operator|+=
name|pDrawable
operator|->
name|x
operator|-
name|stippleWidth
expr_stmt|;
name|modulus
argument_list|(
name|pGC
operator|->
name|patOrg
operator|.
name|y
argument_list|,
name|stippleHeight
argument_list|,
name|ySrc
argument_list|)
expr_stmt|;
name|ySrc
operator|+=
name|pDrawable
operator|->
name|y
operator|-
name|stippleHeight
expr_stmt|;
name|bitsWhole
operator|=
name|stippleWidth
expr_stmt|;
name|SET_REGISTERS_FOR_WRITING
argument_list|(
name|pDrawable
operator|->
name|pScreen
argument_list|,
operator|~
literal|0
argument_list|,
name|GXcopy
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|if (pStipple->devKind == PIXMAP_FRAME_BUFFER)         WAIT_READY_TO_RENDER(pStipple->drawable.pScreen);
endif|#
directive|endif
while|while
condition|(
name|n
operator|--
condition|)
block|{
name|x
operator|=
name|ppt
operator|->
name|x
expr_stmt|;
name|y
operator|=
name|ppt
operator|->
name|y
expr_stmt|;
name|ppt
operator|++
expr_stmt|;
name|w
operator|=
operator|*
name|pwidth
operator|++
expr_stmt|;
name|pdst
operator|=
name|pdstBase
operator|+
name|y
operator|*
name|nlwDst
operator|+
operator|(
name|x
operator|>>
name|PWSH
operator|)
expr_stmt|;
name|y
operator|=
operator|(
name|y
operator|-
name|ySrc
operator|)
operator|%
name|stippleHeight
expr_stmt|;
name|srcStart
operator|=
name|psrcBase
operator|+
name|y
operator|*
name|stwidth
expr_stmt|;
name|xrem
operator|=
operator|(
operator|(
name|x
operator|&
operator|~
literal|3
operator|)
operator|-
name|xSrc
operator|)
operator|%
name|stippleWidth
expr_stmt|;
name|srcTemp
operator|=
name|srcStart
operator|+
operator|(
name|xrem
operator|>>
literal|5
operator|)
expr_stmt|;
name|bitsLeft
operator|=
name|stippleWidth
operator|-
operator|(
name|xrem
operator|&
operator|~
literal|0x1f
operator|)
expr_stmt|;
name|xrem
operator|&=
literal|0x1f
expr_stmt|;
name|NextUnnaturalStippleWord
if|if
condition|(
name|partBitsLeft
operator|<
name|xrem
condition|)
name|FatalError
argument_list|(
literal|"cfbUnnaturalStippleFS bad partBitsLeft %d xrem %d"
argument_list|,
name|partBitsLeft
argument_list|,
name|xrem
argument_list|)
expr_stmt|;
name|NextSomeBits
argument_list|(
name|inputBits
argument_list|,
name|xrem
argument_list|)
expr_stmt|;
name|partBitsLeft
operator|-=
name|xrem
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|x
operator|&
name|PIM
operator|)
operator|+
name|w
operator|)
operator|<=
name|PPW
condition|)
block|{
name|maskpartialbits
argument_list|(
argument|x
argument_list|,
argument|w
argument_list|,
argument|startmask
argument_list|)
name|NextUnnaturalStippleBits
modifier|*
name|pdst
init|=
name|MaskRRopPixels
argument_list|(
operator|*
name|pdst
argument_list|,
name|bits
argument_list|,
name|startmask
argument_list|)
decl_stmt|;
block|}
else|else
block|{
name|maskbits
argument_list|(
name|x
argument_list|,
name|w
argument_list|,
name|startmask
argument_list|,
name|endmask
argument_list|,
name|nlw
argument_list|)
expr_stmt|;
name|nextPartBits
operator|=
operator|(
name|x
operator|&
literal|0x3
operator|)
operator|+
name|w
expr_stmt|;
if|if
condition|(
name|nextPartBits
operator|<
name|partBitsLeft
condition|)
block|{
if|if
condition|(
name|startmask
condition|)
block|{
name|MaskRRopFourBits
argument_list|(
argument|pdst
argument_list|,
argument|GetFourBits(inputBits)
argument_list|,
argument|startmask
argument_list|)
name|pdst
operator|++
expr_stmt|;
name|NextFourBits
argument_list|(
name|inputBits
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|nlw
operator|--
condition|)
block|{
name|RRopFourBits
argument_list|(
name|pdst
argument_list|,
name|GetFourBits
argument_list|(
name|inputBits
argument_list|)
argument_list|)
expr_stmt|;
name|pdst
operator|++
expr_stmt|;
name|NextFourBits
argument_list|(
name|inputBits
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|endmask
condition|)
block|{
name|MaskRRopFourBits
argument_list|(
argument|pdst
argument_list|,
argument|GetFourBits(inputBits)
argument_list|,
argument|endmask
argument_list|)
block|}
block|}
elseif|else
if|if
condition|(
name|bitsLeft
operator|!=
name|bitsWhole
operator|&&
name|nextPartBits
operator|<
name|partBitsLeft
operator|+
name|bitsLeft
condition|)
block|{
name|NextUnnaturalStippleBitsFast
if|if
condition|(
name|startmask
condition|)
block|{
operator|*
name|pdst
operator|=
name|MaskRRopPixels
argument_list|(
operator|*
name|pdst
argument_list|,
name|bits
argument_list|,
name|startmask
argument_list|)
expr_stmt|;
name|pdst
operator|++
expr_stmt|;
name|NextUnnaturalStippleBitsFast
block|}
while|while
condition|(
name|nlw
operator|--
condition|)
block|{
operator|*
name|pdst
operator|=
name|RRopPixels
argument_list|(
operator|*
name|pdst
argument_list|,
name|bits
argument_list|)
expr_stmt|;
name|pdst
operator|++
expr_stmt|;
name|NextUnnaturalStippleBitsFast
block|}
if|if
condition|(
name|endmask
condition|)
operator|*
name|pdst
operator|=
name|MaskRRopPixels
argument_list|(
operator|*
name|pdst
argument_list|,
name|bits
argument_list|,
name|endmask
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|NextUnnaturalStippleBits
if|if
condition|(
name|startmask
condition|)
block|{
operator|*
name|pdst
operator|=
name|MaskRRopPixels
argument_list|(
operator|*
name|pdst
argument_list|,
name|bits
argument_list|,
name|startmask
argument_list|)
expr_stmt|;
name|pdst
operator|++
expr_stmt|;
name|NextUnnaturalStippleBits
block|}
while|while
condition|(
name|nlw
operator|--
condition|)
block|{
operator|*
name|pdst
operator|=
name|RRopPixels
argument_list|(
operator|*
name|pdst
argument_list|,
name|bits
argument_list|)
expr_stmt|;
name|pdst
operator|++
expr_stmt|;
name|NextUnnaturalStippleBits
block|}
if|if
condition|(
name|endmask
condition|)
operator|*
name|pdst
operator|=
name|MaskRRopPixels
argument_list|(
operator|*
name|pdst
argument_list|,
name|bits
argument_list|,
name|endmask
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|DEALLOCATE_LOCAL
argument_list|(
name|pptFree
argument_list|)
expr_stmt|;
name|DEALLOCATE_LOCAL
argument_list|(
name|pwidthFree
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* Fill spans with stipples that aren't 32 bits wide */
end_comment

begin_function
name|void
name|cfbUnnaturalStippleFS
parameter_list|(
name|pDrawable
parameter_list|,
name|pGC
parameter_list|,
name|nInit
parameter_list|,
name|pptInit
parameter_list|,
name|pwidthInit
parameter_list|,
name|fSorted
parameter_list|)
name|DrawablePtr
name|pDrawable
decl_stmt|;
name|GC
modifier|*
name|pGC
decl_stmt|;
name|int
name|nInit
decl_stmt|;
comment|/* number of spans to fill */
name|DDXPointPtr
name|pptInit
decl_stmt|;
comment|/* pointer to list of start points */
name|int
modifier|*
name|pwidthInit
decl_stmt|;
comment|/* pointer to list of n widths */
name|int
name|fSorted
decl_stmt|;
block|{
comment|/* next three parameters are post-clip */
name|int
name|n
decl_stmt|;
comment|/* number of spans to fill */
specifier|register
name|DDXPointPtr
name|ppt
decl_stmt|;
comment|/* pointer to list of start points */
specifier|register
name|unsigned
name|long
modifier|*
name|pwidth
decl_stmt|;
comment|/* pointer to list of n widths */
name|int
name|iline
decl_stmt|;
comment|/* first line of tile to use */
name|unsigned
name|long
modifier|*
name|addrlBase
decl_stmt|;
comment|/* pointer to start of bitmap */
name|int
name|nlwidth
decl_stmt|;
comment|/* width in longwords of bitmap */
specifier|register
name|unsigned
name|long
modifier|*
name|pdst
decl_stmt|;
comment|/* pointer to current word in bitmap */
name|PixmapPtr
name|pStipple
decl_stmt|;
comment|/* pointer to stipple we want to fill with */
name|hpPrivPixmapPtr
name|pPrivStipple
decl_stmt|;
comment|/* private data of stipple */
specifier|register
name|int
name|w
decl_stmt|;
name|int
name|width
decl_stmt|,
name|x
decl_stmt|,
name|xrem
decl_stmt|,
name|xSrc
decl_stmt|,
name|ySrc
decl_stmt|;
name|unsigned
name|long
name|tmpSrc
decl_stmt|,
name|tmpDst1
decl_stmt|,
name|tmpDst2
decl_stmt|;
name|int
name|stwidth
decl_stmt|,
name|stippleWidth
decl_stmt|;
name|unsigned
name|long
modifier|*
name|psrcS
decl_stmt|;
name|int
name|rop
decl_stmt|,
name|stiprop
decl_stmt|;
name|int
name|stippleHeight
decl_stmt|;
name|int
modifier|*
name|pwidthFree
decl_stmt|;
comment|/* copies of the pointers to free */
name|DDXPointPtr
name|pptFree
decl_stmt|;
name|unsigned
name|long
name|fgfill
decl_stmt|,
name|bgfill
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|pGC
operator|->
name|planemask
operator|)
condition|)
return|return;
name|n
operator|=
name|nInit
operator|*
name|miFindMaxBand
argument_list|(
operator|(
operator|(
name|cfbPrivGC
operator|*
operator|)
operator|(
name|pGC
operator|->
name|devPrivates
index|[
name|cfbGCPrivateIndex
index|]
operator|.
name|ptr
operator|)
operator|)
operator|->
name|pCompositeClip
argument_list|)
expr_stmt|;
name|pwidthFree
operator|=
operator|(
name|int
operator|*
operator|)
name|ALLOCATE_LOCAL
argument_list|(
name|n
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|pptFree
operator|=
operator|(
name|DDXPointRec
operator|*
operator|)
name|ALLOCATE_LOCAL
argument_list|(
name|n
operator|*
sizeof|sizeof
argument_list|(
name|DDXPointRec
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pptFree
operator|||
operator|!
name|pwidthFree
condition|)
block|{
if|if
condition|(
name|pptFree
condition|)
name|DEALLOCATE_LOCAL
argument_list|(
name|pptFree
argument_list|)
expr_stmt|;
if|if
condition|(
name|pwidthFree
condition|)
name|DEALLOCATE_LOCAL
argument_list|(
name|pwidthFree
argument_list|)
expr_stmt|;
return|return;
block|}
name|pwidth
operator|=
name|pwidthFree
expr_stmt|;
name|ppt
operator|=
name|pptFree
expr_stmt|;
name|n
operator|=
name|miClipSpans
argument_list|(
operator|(
operator|(
name|cfbPrivGC
operator|*
operator|)
operator|(
name|pGC
operator|->
name|devPrivates
index|[
name|cfbGCPrivateIndex
index|]
operator|.
name|ptr
operator|)
operator|)
operator|->
name|pCompositeClip
argument_list|,
name|pptInit
argument_list|,
name|pwidthInit
argument_list|,
name|nInit
argument_list|,
name|ppt
argument_list|,
name|pwidth
argument_list|,
name|fSorted
argument_list|)
expr_stmt|;
name|rop
operator|=
name|pGC
operator|->
name|alu
expr_stmt|;
if|if
condition|(
name|pGC
operator|->
name|fillStyle
operator|==
name|FillStippled
condition|)
block|{
switch|switch
condition|(
name|rop
condition|)
block|{
case|case
name|GXand
case|:
case|case
name|GXcopy
case|:
case|case
name|GXnoop
case|:
case|case
name|GXor
case|:
name|stiprop
operator|=
name|rop
expr_stmt|;
break|break;
default|default:
name|stiprop
operator|=
name|rop
expr_stmt|;
name|rop
operator|=
name|GXcopy
expr_stmt|;
block|}
block|}
name|fgfill
operator|=
name|PFILL
argument_list|(
name|pGC
operator|->
name|fgPixel
argument_list|)
expr_stmt|;
name|bgfill
operator|=
name|PFILL
argument_list|(
name|pGC
operator|->
name|bgPixel
argument_list|)
expr_stmt|;
comment|/*      *  OK,  so what's going on here?  We have two Drawables:      *      *  The Stipple:      *		Depth = 1      *		Width = stippleWidth      *		Words per scanline = stwidth      *		Pointer to pixels = pStipple->devPrivate.ptr      */
name|pStipple
operator|=
name|pGC
operator|->
name|stipple
expr_stmt|;
name|pPrivStipple
operator|=
call|(
name|hpPrivPixmapPtr
call|)
argument_list|(
name|pStipple
operator|->
name|devPrivate
operator|.
name|ptr
argument_list|)
expr_stmt|;
name|stwidth
operator|=
name|pPrivStipple
operator|->
name|stride
operator|>>
literal|2
expr_stmt|;
name|stippleWidth
operator|=
name|pStipple
operator|->
name|drawable
operator|.
name|width
expr_stmt|;
name|stippleHeight
operator|=
name|pStipple
operator|->
name|drawable
operator|.
name|height
expr_stmt|;
comment|/*      *	The Target:      *		Depth = PSZ      *		Width = determined from *pwidth      *		Words per scanline = nlwidth      *		Pointer to pixels = addrlBase      */
name|cfbGetLongWidthAndPointer
argument_list|(
argument|pDrawable
argument_list|,
argument|nlwidth
argument_list|,
argument|addrlBase
argument_list|)
comment|/* this replaces rotating the stipple. Instead we just adjust the offset      * at which we start grabbing bits from the stipple.      * Ensure that ppt->x - xSrc>= 0 and ppt->y - ySrc>= 0,      * so that iline and xrem always stay within the stipple bounds.      */
name|modulus
argument_list|(
name|pGC
operator|->
name|patOrg
operator|.
name|x
argument_list|,
name|stippleWidth
argument_list|,
name|xSrc
argument_list|)
expr_stmt|;
name|xSrc
operator|+=
name|pDrawable
operator|->
name|x
operator|-
name|stippleWidth
expr_stmt|;
name|modulus
argument_list|(
name|pGC
operator|->
name|patOrg
operator|.
name|y
argument_list|,
name|stippleHeight
argument_list|,
name|ySrc
argument_list|)
expr_stmt|;
name|ySrc
operator|+=
name|pDrawable
operator|->
name|y
operator|-
name|stippleHeight
expr_stmt|;
name|SET_REGISTERS_FOR_WRITING
argument_list|(
name|pDrawable
operator|->
name|pScreen
argument_list|,
operator|~
literal|0
argument_list|,
name|GXcopy
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|if (pStipple->devKind == PIXMAP_FRAME_BUFFER) 	WAIT_READY_TO_RENDER(pStipple->drawable.pScreen);
endif|#
directive|endif
while|while
condition|(
name|n
operator|--
condition|)
block|{
name|iline
operator|=
operator|(
name|ppt
operator|->
name|y
operator|-
name|ySrc
operator|)
operator|%
name|stippleHeight
expr_stmt|;
name|x
operator|=
name|ppt
operator|->
name|x
expr_stmt|;
name|pdst
operator|=
name|addrlBase
operator|+
operator|(
name|ppt
operator|->
name|y
operator|*
name|nlwidth
operator|)
expr_stmt|;
name|psrcS
operator|=
operator|(
name|int
operator|*
operator|)
name|pPrivStipple
operator|->
name|bits
operator|+
operator|(
name|iline
operator|*
name|stwidth
operator|)
expr_stmt|;
if|if
condition|(
operator|*
name|pwidth
condition|)
block|{
name|width
operator|=
operator|*
name|pwidth
expr_stmt|;
while|while
condition|(
name|width
operator|>
literal|0
condition|)
block|{
name|int
name|xtemp
decl_stmt|,
name|tmpx
decl_stmt|;
specifier|register
name|unsigned
name|int
modifier|*
name|ptemp
decl_stmt|;
specifier|register
name|int
modifier|*
name|pdsttmp
decl_stmt|;
comment|/* 		 *  Do a stripe through the stipple& destination w pixels 		 *  wide.  w is not more than: 		 *	-	the width of the destination 		 *	-	the width of the stipple 		 *	-	the distance between x and the next word  		 *		boundary in the destination 		 *	-	the distance between x and the next word 		 *		boundary in the stipple 		 */
comment|/* width of dest/stipple */
name|xrem
operator|=
operator|(
name|x
operator|-
name|xSrc
operator|)
operator|%
name|stippleWidth
expr_stmt|;
name|w
operator|=
name|min
argument_list|(
operator|(
name|stippleWidth
operator|-
name|xrem
operator|)
argument_list|,
name|width
argument_list|)
expr_stmt|;
comment|/* dist to word bound in dest */
name|w
operator|=
name|min
argument_list|(
name|w
argument_list|,
name|PPW
operator|-
operator|(
name|x
operator|&
name|PIM
operator|)
argument_list|)
expr_stmt|;
comment|/* dist to word bound in stip */
name|w
operator|=
name|min
argument_list|(
name|w
argument_list|,
literal|32
operator|-
operator|(
name|x
operator|&
literal|0x1f
operator|)
argument_list|)
expr_stmt|;
name|xtemp
operator|=
operator|(
name|xrem
operator|&
literal|0x1f
operator|)
expr_stmt|;
name|ptemp
operator|=
operator|(
name|unsigned
name|int
operator|*
operator|)
operator|(
name|psrcS
operator|+
operator|(
name|xrem
operator|>>
literal|5
operator|)
operator|)
expr_stmt|;
name|tmpx
operator|=
name|x
operator|&
name|PIM
expr_stmt|;
name|pdsttmp
operator|=
name|pdst
operator|+
operator|(
name|x
operator|>>
name|PWSH
operator|)
expr_stmt|;
switch|switch
condition|(
name|pGC
operator|->
name|fillStyle
condition|)
block|{
case|case
name|FillOpaqueStippled
case|:
name|getstipplepixels
argument_list|(
name|ptemp
argument_list|,
name|xtemp
argument_list|,
name|w
argument_list|,
literal|0
argument_list|,
operator|&
name|bgfill
argument_list|,
operator|&
name|tmpDst1
argument_list|)
expr_stmt|;
name|getstipplepixels
argument_list|(
name|ptemp
argument_list|,
name|xtemp
argument_list|,
name|w
argument_list|,
literal|1
argument_list|,
operator|&
name|fgfill
argument_list|,
operator|&
name|tmpDst2
argument_list|)
expr_stmt|;
break|break;
case|case
name|FillStippled
case|:
comment|/* Fill tmpSrc with the source pixels */
name|getbits
argument_list|(
name|pdsttmp
argument_list|,
name|tmpx
argument_list|,
name|w
argument_list|,
name|tmpSrc
argument_list|)
expr_stmt|;
name|getstipplepixels
argument_list|(
name|ptemp
argument_list|,
name|xtemp
argument_list|,
name|w
argument_list|,
literal|0
argument_list|,
operator|&
name|tmpSrc
argument_list|,
operator|&
name|tmpDst1
argument_list|)
expr_stmt|;
if|if
condition|(
name|rop
operator|!=
name|stiprop
condition|)
block|{
name|putbitsrop
argument_list|(
name|fgfill
argument_list|,
literal|0
argument_list|,
name|w
argument_list|,
operator|&
name|tmpSrc
argument_list|,
name|pGC
operator|->
name|planemask
argument_list|,
name|stiprop
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tmpSrc
operator|=
name|fgfill
expr_stmt|;
block|}
name|getstipplepixels
argument_list|(
name|ptemp
argument_list|,
name|xtemp
argument_list|,
name|w
argument_list|,
literal|1
argument_list|,
operator|&
name|tmpSrc
argument_list|,
operator|&
name|tmpDst2
argument_list|)
expr_stmt|;
break|break;
block|}
name|tmpDst2
operator||=
name|tmpDst1
expr_stmt|;
name|putbitsrop
argument_list|(
name|tmpDst2
argument_list|,
name|tmpx
argument_list|,
name|w
argument_list|,
name|pdsttmp
argument_list|,
name|pGC
operator|->
name|planemask
argument_list|,
name|rop
argument_list|)
expr_stmt|;
name|x
operator|+=
name|w
expr_stmt|;
name|width
operator|-=
name|w
expr_stmt|;
block|}
block|}
name|ppt
operator|++
expr_stmt|;
name|pwidth
operator|++
expr_stmt|;
block|}
name|DEALLOCATE_LOCAL
argument_list|(
name|pptFree
argument_list|)
expr_stmt|;
name|DEALLOCATE_LOCAL
argument_list|(
name|pwidthFree
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PPW == 4 */
end_comment

begin_if
if|#
directive|if
name|PPW
operator|==
literal|4
end_if

begin_function
name|void
name|cfb8Stipple32FS
parameter_list|(
name|pDrawable
parameter_list|,
name|pGC
parameter_list|,
name|nInit
parameter_list|,
name|pptInit
parameter_list|,
name|pwidthInit
parameter_list|,
name|fSorted
parameter_list|)
name|DrawablePtr
name|pDrawable
decl_stmt|;
name|GCPtr
name|pGC
decl_stmt|;
name|int
name|nInit
decl_stmt|;
comment|/* number of spans to fill */
name|DDXPointPtr
name|pptInit
decl_stmt|;
comment|/* pointer to list of start points */
name|int
modifier|*
name|pwidthInit
decl_stmt|;
comment|/* pointer to list of n widths */
name|int
name|fSorted
decl_stmt|;
block|{
comment|/* next three parameters are post-clip */
name|int
name|n
decl_stmt|;
comment|/* number of spans to fill */
name|DDXPointPtr
name|ppt
decl_stmt|;
comment|/* pointer to list of start points */
name|int
modifier|*
name|pwidth
decl_stmt|;
comment|/* pointer to list of n widths */
name|unsigned
name|long
modifier|*
name|src
decl_stmt|;
comment|/* pointer to bits in stipple, if needed */
name|int
name|stippleHeight
decl_stmt|;
comment|/* height of the stipple */
name|PixmapPtr
name|stipple
decl_stmt|;
name|hpPrivPixmapPtr
name|privStipple
decl_stmt|;
name|int
name|nlwDst
decl_stmt|;
comment|/* width in longwords of the dest pixmap */
name|int
name|x
decl_stmt|,
name|y
decl_stmt|,
name|w
decl_stmt|;
comment|/* current span */
name|unsigned
name|long
name|startmask
decl_stmt|;
name|unsigned
name|long
name|endmask
decl_stmt|;
specifier|register
name|unsigned
name|long
modifier|*
name|dst
decl_stmt|;
comment|/* pointer to bits we're writing */
specifier|register
name|int
name|nlw
decl_stmt|;
name|unsigned
name|long
modifier|*
name|dstTmp
decl_stmt|;
name|int
name|nlwTmp
decl_stmt|;
name|unsigned
name|long
modifier|*
name|pbits
decl_stmt|;
comment|/* pointer to start of pixmap */
specifier|register
name|unsigned
name|long
name|xor
decl_stmt|;
specifier|register
name|unsigned
name|long
name|mask
decl_stmt|;
specifier|register
name|unsigned
name|long
name|bits
decl_stmt|;
comment|/* bits from stipple */
name|int
name|wEnd
decl_stmt|;
name|int
modifier|*
name|pwidthFree
decl_stmt|;
comment|/* copies of the pointers to free */
name|DDXPointPtr
name|pptFree
decl_stmt|;
name|cfbPrivGCPtr
name|devPriv
decl_stmt|;
name|devPriv
operator|=
operator|(
name|cfbPrivGCPtr
operator|)
name|pGC
operator|->
name|devPrivates
index|[
name|cfbGCPrivateIndex
index|]
operator|.
name|ptr
expr_stmt|;
name|cfb8CheckStipple
argument_list|(
name|pGC
operator|->
name|alu
argument_list|,
name|pGC
operator|->
name|fgPixel
argument_list|,
name|pGC
operator|->
name|planemask
argument_list|)
expr_stmt|;
name|n
operator|=
name|nInit
operator|*
name|miFindMaxBand
argument_list|(
name|devPriv
operator|->
name|pCompositeClip
argument_list|)
expr_stmt|;
name|pwidthFree
operator|=
operator|(
name|int
operator|*
operator|)
name|ALLOCATE_LOCAL
argument_list|(
name|n
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|pptFree
operator|=
operator|(
name|DDXPointRec
operator|*
operator|)
name|ALLOCATE_LOCAL
argument_list|(
name|n
operator|*
sizeof|sizeof
argument_list|(
name|DDXPointRec
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pptFree
operator|||
operator|!
name|pwidthFree
condition|)
block|{
if|if
condition|(
name|pptFree
condition|)
name|DEALLOCATE_LOCAL
argument_list|(
name|pptFree
argument_list|)
expr_stmt|;
if|if
condition|(
name|pwidthFree
condition|)
name|DEALLOCATE_LOCAL
argument_list|(
name|pwidthFree
argument_list|)
expr_stmt|;
return|return;
block|}
name|pwidth
operator|=
name|pwidthFree
expr_stmt|;
name|ppt
operator|=
name|pptFree
expr_stmt|;
name|n
operator|=
name|miClipSpans
argument_list|(
name|devPriv
operator|->
name|pCompositeClip
argument_list|,
name|pptInit
argument_list|,
name|pwidthInit
argument_list|,
name|nInit
argument_list|,
name|ppt
argument_list|,
name|pwidth
argument_list|,
name|fSorted
argument_list|)
expr_stmt|;
name|stipple
operator|=
name|devPriv
operator|->
name|pRotatedPixmap
expr_stmt|;
name|privStipple
operator|=
call|(
name|hpPrivPixmapPtr
call|)
argument_list|(
name|stipple
operator|->
name|devPrivate
operator|.
name|ptr
argument_list|)
expr_stmt|;
name|src
operator|=
operator|(
name|unsigned
name|long
operator|*
operator|)
name|privStipple
operator|->
name|bits
expr_stmt|;
name|stippleHeight
operator|=
name|stipple
operator|->
name|drawable
operator|.
name|height
expr_stmt|;
name|cfbGetLongWidthAndPointer
argument_list|(
argument|pDrawable
argument_list|,
argument|nlwDst
argument_list|,
argument|pbits
argument_list|)
name|SET_REGISTERS_FOR_WRITING
argument_list|(
name|pDrawable
operator|->
name|pScreen
argument_list|,
operator|~
literal|0
argument_list|,
name|GXcopy
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* stipples are depth 1 => never in frame buffer otherwise        would need to adjust bits calc below to allow for width of         frame buffer */
block|if (stipple->devKind == PIXMAP_FRAME_BUFFER) 	WAIT_READY_TO_RENDER(stipple->drawable.pScreen);
endif|#
directive|endif
while|while
condition|(
name|n
operator|--
condition|)
block|{
name|w
operator|=
operator|*
name|pwidth
operator|++
expr_stmt|;
name|x
operator|=
name|ppt
operator|->
name|x
expr_stmt|;
name|y
operator|=
name|ppt
operator|->
name|y
expr_stmt|;
name|ppt
operator|++
expr_stmt|;
name|dst
operator|=
name|pbits
operator|+
operator|(
name|y
operator|*
name|nlwDst
operator|)
operator|+
operator|(
name|x
operator|>>
name|PWSH
operator|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|x
operator|&
name|PIM
operator|)
operator|+
name|w
operator|)
operator|<=
name|PPW
condition|)
block|{
name|maskpartialbits
argument_list|(
name|x
argument_list|,
name|w
argument_list|,
name|startmask
argument_list|)
expr_stmt|;
name|endmask
operator|=
literal|0
expr_stmt|;
name|nlw
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|maskbits
argument_list|(
name|x
argument_list|,
name|w
argument_list|,
name|startmask
argument_list|,
name|endmask
argument_list|,
name|nlw
argument_list|)
expr_stmt|;
block|}
name|bits
operator|=
name|src
index|[
name|y
operator|%
name|stippleHeight
index|]
expr_stmt|;
name|RotBitsLeft
argument_list|(
name|bits
argument_list|,
operator|(
name|x
operator|&
operator|(
literal|31
operator|&
operator|~
literal|3
operator|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfb8StippleRRop
operator|==
name|GXcopy
condition|)
block|{
name|xor
operator|=
name|devPriv
operator|->
name|xor
expr_stmt|;
if|if
condition|(
name|w
operator|<
literal|64
condition|)
block|{
if|if
condition|(
name|startmask
condition|)
block|{
name|mask
operator|=
name|cfb8PixelMasks
index|[
name|GetFourBits
argument_list|(
name|bits
argument_list|)
index|]
expr_stmt|;
operator|*
name|dst
operator|=
operator|(
operator|*
name|dst
operator|&
operator|~
operator|(
name|mask
operator|&
name|startmask
operator|)
operator|)
operator||
operator|(
name|xor
operator|&
operator|(
name|mask
operator|&
name|startmask
operator|)
operator|)
expr_stmt|;
name|dst
operator|++
expr_stmt|;
name|RotBitsLeft
argument_list|(
name|bits
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|nlw
operator|--
condition|)
block|{
name|WriteFourBits
argument_list|(
argument|dst
argument_list|,
argument|xor
argument_list|,
argument|GetFourBits(bits)
argument_list|)
name|dst
operator|++
expr_stmt|;
name|RotBitsLeft
argument_list|(
name|bits
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|endmask
condition|)
block|{
name|mask
operator|=
name|cfb8PixelMasks
index|[
name|GetFourBits
argument_list|(
name|bits
argument_list|)
index|]
expr_stmt|;
operator|*
name|dst
operator|=
operator|(
operator|*
name|dst
operator|&
operator|~
operator|(
name|mask
operator|&
name|endmask
operator|)
operator|)
operator||
operator|(
name|xor
operator|&
operator|(
name|mask
operator|&
name|endmask
operator|)
operator|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|wEnd
operator|=
literal|7
operator|-
operator|(
name|nlw
operator|&
literal|7
operator|)
expr_stmt|;
name|nlw
operator|=
operator|(
name|nlw
operator|>>
literal|3
operator|)
operator|+
literal|1
expr_stmt|;
name|dstTmp
operator|=
name|dst
expr_stmt|;
name|nlwTmp
operator|=
name|nlw
expr_stmt|;
if|if
condition|(
name|startmask
condition|)
block|{
name|mask
operator|=
name|cfb8PixelMasks
index|[
name|GetFourBits
argument_list|(
name|bits
argument_list|)
index|]
expr_stmt|;
operator|*
name|dstTmp
operator|=
operator|(
operator|*
name|dstTmp
operator|&
operator|~
operator|(
name|mask
operator|&
name|startmask
operator|)
operator|)
operator||
operator|(
name|xor
operator|&
operator|(
name|mask
operator|&
name|startmask
operator|)
operator|)
expr_stmt|;
name|dstTmp
operator|++
expr_stmt|;
name|RotBitsLeft
argument_list|(
name|bits
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
name|w
operator|=
literal|7
operator|-
name|wEnd
expr_stmt|;
while|while
condition|(
name|w
operator|--
condition|)
block|{
name|dst
operator|=
name|dstTmp
expr_stmt|;
name|dstTmp
operator|++
expr_stmt|;
name|nlw
operator|=
name|nlwTmp
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__GNUC__
argument_list|)
operator|&&
name|defined
argument_list|(
name|mc68020
argument_list|)
name|mask
operator|=
name|cfb8PixelMasks
index|[
name|GetFourBits
argument_list|(
name|bits
argument_list|)
index|]
expr_stmt|;
name|xor
operator|=
name|xor
operator|&
name|mask
expr_stmt|;
name|mask
operator|=
operator|~
name|mask
expr_stmt|;
while|while
condition|(
name|nlw
operator|--
condition|)
block|{
operator|*
name|dst
operator|=
operator|(
operator|*
name|dst
operator|&
name|mask
operator|)
operator||
name|xor
expr_stmt|;
name|dst
operator|+=
literal|8
expr_stmt|;
block|}
name|xor
operator|=
name|devPriv
operator|->
name|xor
expr_stmt|;
else|#
directive|else
define|#
directive|define
name|SwitchBitsLoop
parameter_list|(
name|body
parameter_list|)
define|\
value|while (nlw--)	\     {		\ 	body	\ 	dst += 8;	\     }
name|SwitchFourBits
argument_list|(
name|dst
argument_list|,
name|xor
argument_list|,
name|GetFourBits
argument_list|(
name|bits
argument_list|)
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|SwitchBitsLoop
endif|#
directive|endif
name|NextFourBits
argument_list|(
name|bits
argument_list|)
expr_stmt|;
block|}
name|nlwTmp
operator|--
expr_stmt|;
name|w
operator|=
name|wEnd
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|endmask
condition|)
block|{
name|mask
operator|=
name|cfb8PixelMasks
index|[
name|GetFourBits
argument_list|(
name|bits
argument_list|)
index|]
expr_stmt|;
name|dst
operator|=
name|dstTmp
operator|+
operator|(
name|nlwTmp
operator|<<
literal|3
operator|)
expr_stmt|;
operator|*
name|dst
operator|=
operator|(
operator|*
name|dst
operator|&
operator|~
operator|(
name|mask
operator|&
name|endmask
operator|)
operator|)
operator||
operator|(
name|xor
operator|&
operator|(
name|mask
operator|&
name|endmask
operator|)
operator|)
expr_stmt|;
block|}
while|while
condition|(
name|w
operator|--
condition|)
block|{
name|nlw
operator|=
name|nlwTmp
expr_stmt|;
name|dst
operator|=
name|dstTmp
expr_stmt|;
name|dstTmp
operator|++
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__GNUC__
argument_list|)
operator|&&
name|defined
argument_list|(
name|mc68020
argument_list|)
name|mask
operator|=
name|cfb8PixelMasks
index|[
name|GetFourBits
argument_list|(
name|bits
argument_list|)
index|]
expr_stmt|;
name|xor
operator|=
name|xor
operator|&
name|mask
expr_stmt|;
name|mask
operator|=
operator|~
name|mask
expr_stmt|;
while|while
condition|(
name|nlw
operator|--
condition|)
block|{
operator|*
name|dst
operator|=
operator|(
operator|*
name|dst
operator|&
name|mask
operator|)
operator||
name|xor
expr_stmt|;
name|dst
operator|+=
literal|8
expr_stmt|;
block|}
name|xor
operator|=
name|devPriv
operator|->
name|xor
expr_stmt|;
else|#
directive|else
define|#
directive|define
name|SwitchBitsLoop
parameter_list|(
name|body
parameter_list|)
define|\
value|while (nlw--)	\ 	{		\ 	    body	\ 	    dst += 8;	\ 	}
name|SwitchFourBits
argument_list|(
name|dst
argument_list|,
name|xor
argument_list|,
name|GetFourBits
argument_list|(
name|bits
argument_list|)
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|SwitchBitsLoop
endif|#
directive|endif
name|NextFourBits
argument_list|(
name|bits
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|startmask
condition|)
block|{
name|xor
operator|=
name|GetFourBits
argument_list|(
name|bits
argument_list|)
expr_stmt|;
operator|*
name|dst
operator|=
name|MaskRRopPixels
argument_list|(
operator|*
name|dst
argument_list|,
name|xor
argument_list|,
name|startmask
argument_list|)
expr_stmt|;
name|dst
operator|++
expr_stmt|;
name|RotBitsLeft
argument_list|(
name|bits
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|nlw
operator|--
condition|)
block|{
name|RRopFourBits
argument_list|(
name|dst
argument_list|,
name|GetFourBits
argument_list|(
name|bits
argument_list|)
argument_list|)
expr_stmt|;
name|dst
operator|++
expr_stmt|;
name|RotBitsLeft
argument_list|(
name|bits
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|endmask
condition|)
block|{
name|xor
operator|=
name|GetFourBits
argument_list|(
name|bits
argument_list|)
expr_stmt|;
operator|*
name|dst
operator|=
name|MaskRRopPixels
argument_list|(
operator|*
name|dst
argument_list|,
name|xor
argument_list|,
name|endmask
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|DEALLOCATE_LOCAL
argument_list|(
name|pptFree
argument_list|)
expr_stmt|;
name|DEALLOCATE_LOCAL
argument_list|(
name|pwidthFree
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cfb8OpaqueStipple32FS
parameter_list|(
name|pDrawable
parameter_list|,
name|pGC
parameter_list|,
name|nInit
parameter_list|,
name|pptInit
parameter_list|,
name|pwidthInit
parameter_list|,
name|fSorted
parameter_list|)
name|DrawablePtr
name|pDrawable
decl_stmt|;
name|GCPtr
name|pGC
decl_stmt|;
name|int
name|nInit
decl_stmt|;
comment|/* number of spans to fill */
name|DDXPointPtr
name|pptInit
decl_stmt|;
comment|/* pointer to list of start points */
name|int
modifier|*
name|pwidthInit
decl_stmt|;
comment|/* pointer to list of n widths */
name|int
name|fSorted
decl_stmt|;
block|{
comment|/* next three parameters are post-clip */
name|int
name|n
decl_stmt|;
comment|/* number of spans to fill */
name|DDXPointPtr
name|ppt
decl_stmt|;
comment|/* pointer to list of start points */
name|int
modifier|*
name|pwidth
decl_stmt|;
comment|/* pointer to list of n widths */
name|unsigned
name|long
modifier|*
name|src
decl_stmt|;
comment|/* pointer to bits in stipple, if needed */
name|int
name|stippleHeight
decl_stmt|;
comment|/* height of the stipple */
name|PixmapPtr
name|stipple
decl_stmt|;
name|hpPrivPixmapPtr
name|privStipple
decl_stmt|;
name|int
name|nlwDst
decl_stmt|;
comment|/* width in longwords of the dest pixmap */
name|int
name|x
decl_stmt|,
name|y
decl_stmt|,
name|w
decl_stmt|;
comment|/* current span */
name|unsigned
name|long
name|startmask
decl_stmt|;
name|unsigned
name|long
name|endmask
decl_stmt|;
specifier|register
name|unsigned
name|long
modifier|*
name|dst
decl_stmt|;
comment|/* pointer to bits we're writing */
specifier|register
name|int
name|nlw
decl_stmt|;
name|unsigned
name|long
modifier|*
name|dstTmp
decl_stmt|;
name|int
name|nlwTmp
decl_stmt|;
name|unsigned
name|long
modifier|*
name|pbits
decl_stmt|;
comment|/* pointer to start of pixmap */
specifier|register
name|unsigned
name|long
name|xor
decl_stmt|;
specifier|register
name|unsigned
name|long
name|mask
decl_stmt|;
specifier|register
name|unsigned
name|long
name|bits
decl_stmt|;
comment|/* bits from stipple */
name|int
name|wEnd
decl_stmt|;
name|int
modifier|*
name|pwidthFree
decl_stmt|;
comment|/* copies of the pointers to free */
name|DDXPointPtr
name|pptFree
decl_stmt|;
name|cfbPrivGCPtr
name|devPriv
decl_stmt|;
name|devPriv
operator|=
operator|(
name|cfbPrivGCPtr
operator|)
name|pGC
operator|->
name|devPrivates
index|[
name|cfbGCPrivateIndex
index|]
operator|.
name|ptr
expr_stmt|;
name|cfb8CheckOpaqueStipple
argument_list|(
name|pGC
operator|->
name|alu
argument_list|,
name|pGC
operator|->
name|fgPixel
argument_list|,
name|pGC
operator|->
name|bgPixel
argument_list|,
name|pGC
operator|->
name|planemask
argument_list|)
expr_stmt|;
name|n
operator|=
name|nInit
operator|*
name|miFindMaxBand
argument_list|(
name|devPriv
operator|->
name|pCompositeClip
argument_list|)
expr_stmt|;
name|pwidthFree
operator|=
operator|(
name|int
operator|*
operator|)
name|ALLOCATE_LOCAL
argument_list|(
name|n
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|pptFree
operator|=
operator|(
name|DDXPointRec
operator|*
operator|)
name|ALLOCATE_LOCAL
argument_list|(
name|n
operator|*
sizeof|sizeof
argument_list|(
name|DDXPointRec
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pptFree
operator|||
operator|!
name|pwidthFree
condition|)
block|{
if|if
condition|(
name|pptFree
condition|)
name|DEALLOCATE_LOCAL
argument_list|(
name|pptFree
argument_list|)
expr_stmt|;
if|if
condition|(
name|pwidthFree
condition|)
name|DEALLOCATE_LOCAL
argument_list|(
name|pwidthFree
argument_list|)
expr_stmt|;
return|return;
block|}
name|pwidth
operator|=
name|pwidthFree
expr_stmt|;
name|ppt
operator|=
name|pptFree
expr_stmt|;
name|n
operator|=
name|miClipSpans
argument_list|(
name|devPriv
operator|->
name|pCompositeClip
argument_list|,
name|pptInit
argument_list|,
name|pwidthInit
argument_list|,
name|nInit
argument_list|,
name|ppt
argument_list|,
name|pwidth
argument_list|,
name|fSorted
argument_list|)
expr_stmt|;
name|stipple
operator|=
name|devPriv
operator|->
name|pRotatedPixmap
expr_stmt|;
name|privStipple
operator|=
call|(
name|hpPrivPixmapPtr
call|)
argument_list|(
name|stipple
operator|->
name|devPrivate
operator|.
name|ptr
argument_list|)
expr_stmt|;
name|src
operator|=
operator|(
name|unsigned
name|long
operator|*
operator|)
name|privStipple
operator|->
name|bits
expr_stmt|;
name|stippleHeight
operator|=
name|stipple
operator|->
name|drawable
operator|.
name|height
expr_stmt|;
name|cfbGetLongWidthAndPointer
argument_list|(
argument|pDrawable
argument_list|,
argument|nlwDst
argument_list|,
argument|pbits
argument_list|)
name|SET_REGISTERS_FOR_WRITING
argument_list|(
name|pDrawable
operator|->
name|pScreen
argument_list|,
operator|~
literal|0
argument_list|,
name|GXcopy
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* stipples are depth 1 => never in frame buffer otherwise        would need to adjust bits calc below to allow for width of         frame buffer */
block|if (stipple->devKind == PIXMAP_FRAME_BUFFER) 	WAIT_READY_TO_RENDER(stipple->drawable.pScreen);
endif|#
directive|endif
while|while
condition|(
name|n
operator|--
condition|)
block|{
name|w
operator|=
operator|*
name|pwidth
operator|++
expr_stmt|;
name|x
operator|=
name|ppt
operator|->
name|x
expr_stmt|;
name|y
operator|=
name|ppt
operator|->
name|y
expr_stmt|;
name|ppt
operator|++
expr_stmt|;
name|dst
operator|=
name|pbits
operator|+
operator|(
name|y
operator|*
name|nlwDst
operator|)
operator|+
operator|(
name|x
operator|>>
name|PWSH
operator|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|x
operator|&
name|PIM
operator|)
operator|+
name|w
operator|)
operator|<=
name|PPW
condition|)
block|{
name|maskpartialbits
argument_list|(
name|x
argument_list|,
name|w
argument_list|,
name|startmask
argument_list|)
expr_stmt|;
name|endmask
operator|=
literal|0
expr_stmt|;
name|nlw
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|maskbits
argument_list|(
name|x
argument_list|,
name|w
argument_list|,
name|startmask
argument_list|,
name|endmask
argument_list|,
name|nlw
argument_list|)
expr_stmt|;
block|}
name|bits
operator|=
name|src
index|[
name|y
operator|%
name|stippleHeight
index|]
expr_stmt|;
name|RotBitsLeft
argument_list|(
name|bits
argument_list|,
operator|(
name|x
operator|&
operator|(
literal|31
operator|&
operator|~
literal|3
operator|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfb8StippleRRop
operator|==
name|GXcopy
condition|)
block|{
name|xor
operator|=
name|devPriv
operator|->
name|xor
expr_stmt|;
if|if
condition|(
name|w
operator|<
literal|64
condition|)
block|{
if|if
condition|(
name|startmask
condition|)
block|{
operator|*
name|dst
operator|=
operator|*
name|dst
operator|&
operator|~
name|startmask
operator||
name|GetFourPixels
argument_list|(
name|bits
argument_list|)
operator|&
name|startmask
expr_stmt|;
name|dst
operator|++
expr_stmt|;
name|RotBitsLeft
argument_list|(
name|bits
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|nlw
operator|--
condition|)
block|{
operator|*
name|dst
operator|++
operator|=
name|GetFourPixels
argument_list|(
name|bits
argument_list|)
expr_stmt|;
name|RotBitsLeft
argument_list|(
name|bits
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|endmask
condition|)
block|{
operator|*
name|dst
operator|=
operator|*
name|dst
operator|&
operator|~
name|endmask
operator||
name|GetFourPixels
argument_list|(
name|bits
argument_list|)
operator|&
name|endmask
expr_stmt|;
block|}
block|}
else|else
block|{
name|wEnd
operator|=
literal|7
operator|-
operator|(
name|nlw
operator|&
literal|7
operator|)
expr_stmt|;
name|nlw
operator|=
operator|(
name|nlw
operator|>>
literal|3
operator|)
operator|+
literal|1
expr_stmt|;
name|dstTmp
operator|=
name|dst
expr_stmt|;
name|nlwTmp
operator|=
name|nlw
expr_stmt|;
if|if
condition|(
name|startmask
condition|)
block|{
operator|*
name|dstTmp
operator|=
operator|*
name|dstTmp
operator|&
operator|~
name|startmask
operator||
name|GetFourPixels
argument_list|(
name|bits
argument_list|)
operator|&
name|startmask
expr_stmt|;
name|dstTmp
operator|++
expr_stmt|;
name|RotBitsLeft
argument_list|(
name|bits
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
name|w
operator|=
literal|7
operator|-
name|wEnd
expr_stmt|;
while|while
condition|(
name|w
operator|--
condition|)
block|{
name|nlw
operator|=
name|nlwTmp
expr_stmt|;
name|dst
operator|=
name|dstTmp
expr_stmt|;
name|dstTmp
operator|++
expr_stmt|;
name|xor
operator|=
name|GetFourPixels
argument_list|(
name|bits
argument_list|)
expr_stmt|;
while|while
condition|(
name|nlw
operator|--
condition|)
block|{
operator|*
name|dst
operator|=
name|xor
expr_stmt|;
name|dst
operator|+=
literal|8
expr_stmt|;
block|}
name|NextFourBits
argument_list|(
name|bits
argument_list|)
expr_stmt|;
block|}
name|nlwTmp
operator|--
expr_stmt|;
name|w
operator|=
name|wEnd
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|endmask
condition|)
block|{
name|dst
operator|=
name|dstTmp
operator|+
operator|(
name|nlwTmp
operator|<<
literal|3
operator|)
expr_stmt|;
operator|*
name|dst
operator|=
operator|(
operator|*
name|dst
operator|&
operator|~
name|endmask
operator|)
operator||
name|GetFourPixels
argument_list|(
name|bits
argument_list|)
operator|&
name|endmask
expr_stmt|;
block|}
while|while
condition|(
name|w
operator|--
condition|)
block|{
name|nlw
operator|=
name|nlwTmp
expr_stmt|;
name|dst
operator|=
name|dstTmp
expr_stmt|;
name|dstTmp
operator|++
expr_stmt|;
name|xor
operator|=
name|GetFourPixels
argument_list|(
name|bits
argument_list|)
expr_stmt|;
while|while
condition|(
name|nlw
operator|--
condition|)
block|{
operator|*
name|dst
operator|=
name|xor
expr_stmt|;
name|dst
operator|+=
literal|8
expr_stmt|;
block|}
name|NextFourBits
argument_list|(
name|bits
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|startmask
condition|)
block|{
name|xor
operator|=
name|GetFourBits
argument_list|(
name|bits
argument_list|)
expr_stmt|;
operator|*
name|dst
operator|=
name|MaskRRopPixels
argument_list|(
operator|*
name|dst
argument_list|,
name|xor
argument_list|,
name|startmask
argument_list|)
expr_stmt|;
name|dst
operator|++
expr_stmt|;
name|RotBitsLeft
argument_list|(
name|bits
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|nlw
operator|--
condition|)
block|{
name|RRopFourBits
argument_list|(
name|dst
argument_list|,
name|GetFourBits
argument_list|(
name|bits
argument_list|)
argument_list|)
expr_stmt|;
name|dst
operator|++
expr_stmt|;
name|RotBitsLeft
argument_list|(
name|bits
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|endmask
condition|)
block|{
name|xor
operator|=
name|GetFourBits
argument_list|(
name|bits
argument_list|)
expr_stmt|;
operator|*
name|dst
operator|=
name|MaskRRopPixels
argument_list|(
operator|*
name|dst
argument_list|,
name|xor
argument_list|,
name|endmask
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|DEALLOCATE_LOCAL
argument_list|(
name|pptFree
argument_list|)
expr_stmt|;
name|DEALLOCATE_LOCAL
argument_list|(
name|pwidthFree
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

