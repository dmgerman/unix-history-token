begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*********************************************************** Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts, and the Massachusetts Institute of Technology, Cambridge, Massachusetts.                          All Rights Reserved  Permission to use, copy, modify, and distribute this software and its  documentation for any purpose and without fee is hereby granted,  provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in  supporting documentation, and that the names of Digital or MIT not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.    DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  ******************************************************************/
end_comment

begin_include
include|#
directive|include
file|"X.h"
end_include

begin_include
include|#
directive|include
file|"Xmd.h"
end_include

begin_include
include|#
directive|include
file|"servermd.h"
end_include

begin_include
include|#
directive|include
file|"misc.h"
end_include

begin_include
include|#
directive|include
file|"region.h"
end_include

begin_include
include|#
directive|include
file|"gc.h"
end_include

begin_include
include|#
directive|include
file|"windowstr.h"
end_include

begin_include
include|#
directive|include
file|"pixmapstr.h"
end_include

begin_include
include|#
directive|include
file|"scrnintstr.h"
end_include

begin_include
include|#
directive|include
file|"cfb.h"
end_include

begin_include
include|#
directive|include
file|"cfbmskbits.h"
end_include

begin_comment
comment|/* GetSpans -- for each span, gets bits from drawable starting at ppt[i]  * and continuing for pwidth[i] bits  * Each scanline returned will be server scanline padded, i.e., it will come  * out to an integral number of words.  */
end_comment

begin_function
name|void
name|cfbGetSpans
parameter_list|(
name|pDrawable
parameter_list|,
name|wMax
parameter_list|,
name|ppt
parameter_list|,
name|pwidth
parameter_list|,
name|nspans
parameter_list|,
name|pdstStart
parameter_list|)
name|DrawablePtr
name|pDrawable
decl_stmt|;
comment|/* drawable from which to get bits */
name|int
name|wMax
decl_stmt|;
comment|/* largest value of all *pwidths */
specifier|register
name|DDXPointPtr
name|ppt
decl_stmt|;
comment|/* points to start copying from */
name|int
modifier|*
name|pwidth
decl_stmt|;
comment|/* list of number of bits to copy */
name|int
name|nspans
decl_stmt|;
comment|/* number of scanlines to copy */
name|unsigned
name|long
modifier|*
name|pdstStart
decl_stmt|;
comment|/* where to put the bits */
block|{
specifier|register
name|unsigned
name|long
modifier|*
name|pdst
decl_stmt|;
comment|/* where to put the bits */
specifier|register
name|unsigned
name|long
modifier|*
name|psrc
decl_stmt|;
comment|/* where to get the bits */
specifier|register
name|unsigned
name|long
name|tmpSrc
decl_stmt|;
comment|/* scratch buffer for bits */
name|unsigned
name|long
modifier|*
name|psrcBase
decl_stmt|;
comment|/* start of src bitmap */
name|int
name|widthSrc
decl_stmt|;
comment|/* width of pixmap in bytes */
specifier|register
name|DDXPointPtr
name|pptLast
decl_stmt|;
comment|/* one past last point to get */
name|int
name|xEnd
decl_stmt|;
comment|/* last pixel to copy from */
specifier|register
name|int
name|nstart
decl_stmt|;
name|int
name|nend
decl_stmt|;
name|int
name|srcStartOver
decl_stmt|;
name|unsigned
name|long
name|startmask
decl_stmt|,
name|endmask
decl_stmt|;
name|int
name|nlMiddle
decl_stmt|,
name|nl
decl_stmt|,
name|srcBit
decl_stmt|;
name|int
name|w
decl_stmt|;
name|unsigned
name|long
modifier|*
name|pdstNext
decl_stmt|;
switch|switch
condition|(
name|pDrawable
operator|->
name|bitsPerPixel
condition|)
block|{
case|case
literal|1
case|:
name|mfbGetSpans
argument_list|(
name|pDrawable
argument_list|,
name|wMax
argument_list|,
name|ppt
argument_list|,
name|pwidth
argument_list|,
name|nspans
argument_list|,
name|pdstStart
argument_list|)
expr_stmt|;
return|return;
case|case
name|PSZ
case|:
break|break;
default|default:
name|FatalError
argument_list|(
literal|"cfbGetSpans: invalid depth\n"
argument_list|)
expr_stmt|;
block|}
name|cfbGetLongWidthAndPointer
argument_list|(
argument|pDrawable
argument_list|,
argument|widthSrc
argument_list|,
argument|psrcBase
argument_list|)
name|WAIT_READY_TO_RENDER
argument_list|(
name|pDrawable
operator|->
name|pScreen
argument_list|)
expr_stmt|;
if|#
directive|if
name|PPW
operator|==
literal|4
if|if
condition|(
operator|(
name|nspans
operator|==
literal|1
operator|)
operator|&&
operator|(
operator|*
name|pwidth
operator|==
literal|1
operator|)
condition|)
block|{
name|tmpSrc
operator|=
operator|*
operator|(
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|(
name|psrcBase
operator|+
operator|(
name|ppt
operator|->
name|y
operator|*
operator|(
name|widthSrc
operator|>>
literal|2
operator|)
operator|)
operator|)
operator|+
name|ppt
operator|->
name|x
operator|)
expr_stmt|;
if|#
directive|if
name|BITMAP_BIT_ORDER
operator|==
name|MSBFirst
name|tmpSrc
operator|<<=
literal|24
expr_stmt|;
endif|#
directive|endif
operator|*
name|pdstStart
operator|=
name|tmpSrc
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|pdst
operator|=
name|pdstStart
expr_stmt|;
name|pptLast
operator|=
name|ppt
operator|+
name|nspans
expr_stmt|;
while|while
condition|(
name|ppt
operator|<
name|pptLast
condition|)
block|{
name|xEnd
operator|=
name|min
argument_list|(
name|ppt
operator|->
name|x
operator|+
operator|*
name|pwidth
argument_list|,
name|widthSrc
operator|<<
operator|(
name|PWSH
operator|-
literal|2
operator|)
argument_list|)
expr_stmt|;
name|psrc
operator|=
name|psrcBase
operator|+
operator|(
name|ppt
operator|->
name|y
operator|*
operator|(
name|widthSrc
operator|>>
literal|2
operator|)
operator|)
operator|+
operator|(
name|ppt
operator|->
name|x
operator|>>
name|PWSH
operator|)
expr_stmt|;
name|w
operator|=
name|xEnd
operator|-
name|ppt
operator|->
name|x
expr_stmt|;
name|srcBit
operator|=
name|ppt
operator|->
name|x
operator|&
name|PIM
expr_stmt|;
comment|/* This shouldn't be needed */
name|pdstNext
operator|=
name|pdst
operator|+
name|PixmapWidthInPadUnits
argument_list|(
name|w
argument_list|,
name|PSZ
argument_list|)
expr_stmt|;
if|if
condition|(
name|srcBit
operator|+
name|w
operator|<=
name|PPW
condition|)
block|{
name|getbits
argument_list|(
name|psrc
argument_list|,
name|srcBit
argument_list|,
name|w
argument_list|,
name|tmpSrc
argument_list|)
expr_stmt|;
comment|/*XXX*/
name|putbits
argument_list|(
name|tmpSrc
argument_list|,
literal|0
argument_list|,
name|w
argument_list|,
name|pdst
argument_list|,
operator|~
operator|(
operator|(
name|unsigned
name|long
operator|)
literal|0
operator|)
argument_list|)
expr_stmt|;
name|pdst
operator|++
expr_stmt|;
block|}
else|else
block|{
name|maskbits
argument_list|(
name|ppt
operator|->
name|x
argument_list|,
name|w
argument_list|,
name|startmask
argument_list|,
name|endmask
argument_list|,
name|nlMiddle
argument_list|)
expr_stmt|;
if|if
condition|(
name|startmask
condition|)
name|nstart
operator|=
name|PPW
operator|-
name|srcBit
expr_stmt|;
else|else
name|nstart
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|endmask
condition|)
name|nend
operator|=
name|xEnd
operator|&
name|PIM
expr_stmt|;
name|srcStartOver
operator|=
name|srcBit
operator|+
name|nstart
operator|>
name|PLST
expr_stmt|;
if|if
condition|(
name|startmask
condition|)
block|{
name|getbits
argument_list|(
name|psrc
argument_list|,
name|srcBit
argument_list|,
name|nstart
argument_list|,
name|tmpSrc
argument_list|)
expr_stmt|;
comment|/*XXX*/
name|putbits
argument_list|(
name|tmpSrc
argument_list|,
literal|0
argument_list|,
name|nstart
argument_list|,
name|pdst
argument_list|,
operator|~
operator|(
operator|(
name|unsigned
name|long
operator|)
literal|0
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|srcStartOver
condition|)
name|psrc
operator|++
expr_stmt|;
block|}
name|nl
operator|=
name|nlMiddle
expr_stmt|;
while|while
condition|(
name|nl
operator|--
condition|)
block|{
name|tmpSrc
operator|=
operator|*
name|psrc
expr_stmt|;
comment|/*XXX*/
name|putbits
argument_list|(
name|tmpSrc
argument_list|,
name|nstart
argument_list|,
name|PPW
argument_list|,
name|pdst
argument_list|,
operator|~
operator|(
operator|(
name|unsigned
name|long
operator|)
literal|0
operator|)
argument_list|)
expr_stmt|;
name|psrc
operator|++
expr_stmt|;
name|pdst
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|endmask
condition|)
block|{
name|getbits
argument_list|(
name|psrc
argument_list|,
literal|0
argument_list|,
name|nend
argument_list|,
name|tmpSrc
argument_list|)
expr_stmt|;
comment|/*XXX*/
name|putbits
argument_list|(
name|tmpSrc
argument_list|,
name|nstart
argument_list|,
name|nend
argument_list|,
name|pdst
argument_list|,
operator|~
operator|(
operator|(
name|unsigned
name|long
operator|)
literal|0
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nstart
operator|+
name|nend
operator|>=
name|PPW
condition|)
name|pdst
operator|++
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|notdef
name|pdst
operator|++
expr_stmt|;
while|while
condition|(
name|pdst
operator|<
name|pdstNext
condition|)
block|{
operator|*
name|pdst
operator|++
operator|=
literal|0
expr_stmt|;
block|}
else|#
directive|else
name|pdst
operator|=
name|pdstNext
expr_stmt|;
endif|#
directive|endif
block|}
name|ppt
operator|++
expr_stmt|;
name|pwidth
operator|++
expr_stmt|;
block|}
block|}
end_function

end_unit

