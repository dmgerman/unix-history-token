begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* symbols.c -symbol table-    Copyright (C) 1987 Free Software Foundation, Inc.  This file is part of GAS, the GNU Assembler.  GAS is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version.  GAS is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GAS; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|"hash.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_comment
comment|/* For "symbols.h" */
end_comment

begin_include
include|#
directive|include
file|"struc-symbol.h"
end_include

begin_include
include|#
directive|include
file|"symbols.h"
end_include

begin_include
include|#
directive|include
file|"frags.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|WORKING_DOT_WORD
end_ifndef

begin_decl_stmt
specifier|extern
name|int
name|new_broken_words
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|VMS
end_ifdef

begin_decl_stmt
specifier|extern
name|char
name|const_flag
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|struct
name|hash_control
modifier|*
name|sy_hash
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* symbol-name => struct symbol pointer */
end_comment

begin_comment
comment|/* Below are commented in "symbols.h". */
end_comment

begin_decl_stmt
name|unsigned
name|int
name|local_bss_counter
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|symbolS
modifier|*
name|symbol_rootP
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|symbolS
modifier|*
name|symbol_lastP
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|symbolS
name|abs_symbol
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|obstack
name|notes
decl_stmt|;
end_decl_stmt

begin_function_decl
name|symbolS
modifier|*
name|symbol_find
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Keep C compiler happy. */
end_comment

begin_comment
comment|/*  * Un*x idea of local labels. They are made by "n:" where n  * is any decimal digit. Refer to them with  *  "nb" for previous (backward) n:  *  or "nf" for next (forward) n:.  *  * Like Un*x AS, we have one set of local label counters for entire assembly,  * not one set per (sub)segment like in most assemblers. This implies that  * one can refer to a label in another segment, and indeed some crufty  * compilers have done just that.  *  * I document the symbol names here to save duplicating words elsewhere.  * The mth occurence of label n: is turned into the symbol "Ln^Am" where  * n is a digit and m is a decimal number. "L" makes it a label discarded  * unless debugging and "^A"('\1') ensures no ordinary symbol SHOULD get the  * same name as a local label symbol. The first "4:" is "L4^A1" - the m  * numbers begin at 1.  */
end_comment

begin_typedef
typedef|typedef
name|short
name|unsigned
name|int
name|local_label_countT
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|local_label_countT
name|local_label_counter
index|[
literal|10
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
comment|/* Returned to caller, then copied. */
name|char
name|symbol_name_build
index|[
literal|12
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* used for created names ("4f") */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SUN_ASM_SYNTAX
end_ifdef

begin_decl_stmt
name|int
name|local_label_defined
index|[
literal|10
index|]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_function
name|void
name|symbol_begin
parameter_list|()
block|{
name|symbol_lastP
operator|=
name|NULL
expr_stmt|;
name|symbol_rootP
operator|=
name|NULL
expr_stmt|;
comment|/* In case we have 0 symbols (!!) */
name|sy_hash
operator|=
name|hash_new
argument_list|()
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
operator|&
name|abs_symbol
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|abs_symbol
argument_list|)
argument_list|)
expr_stmt|;
name|abs_symbol
operator|.
name|sy_type
operator|=
name|N_ABS
expr_stmt|;
comment|/* Can't initialise a union. Sigh. */
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|local_label_counter
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|local_label_counter
argument_list|)
argument_list|)
expr_stmt|;
name|local_bss_counter
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *			local_label_name()  *  * Caller must copy returned name: we re-use the area for the next name.  */
end_comment

begin_function
name|char
modifier|*
comment|/* Return local label name. */
name|local_label_name
parameter_list|(
name|n
parameter_list|,
name|augend
parameter_list|)
specifier|register
name|int
name|n
decl_stmt|;
comment|/* we just saw "n:", "nf" or "nb" : n a digit */
specifier|register
name|int
name|augend
decl_stmt|;
comment|/* 0 for nb, 1 for n:, nf */
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|char
modifier|*
name|q
decl_stmt|;
name|char
name|symbol_name_temporary
index|[
literal|10
index|]
decl_stmt|;
comment|/* build up a number, BACKWARDS */
name|know
argument_list|(
name|n
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|know
argument_list|(
name|augend
operator|==
literal|0
operator|||
name|augend
operator|==
literal|1
argument_list|)
expr_stmt|;
name|p
operator|=
name|symbol_name_build
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'L'
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|n
operator|+
literal|'0'
expr_stmt|;
comment|/* Make into ASCII */
operator|*
name|p
operator|++
operator|=
literal|1
expr_stmt|;
comment|/* ^A */
name|n
operator|=
name|local_label_counter
index|[
name|n
index|]
operator|+
name|augend
expr_stmt|;
comment|/* version number of this local label */
comment|/*    * Next code just does sprintf( {}, "%d", n);    * It is more elegant to do the next part recursively, but a procedure    * call for each digit emitted is considered too costly.    */
name|q
operator|=
name|symbol_name_temporary
expr_stmt|;
for|for
control|(
operator|*
name|q
operator|++
operator|=
literal|0
init|;
name|n
condition|;
name|q
operator|++
control|)
comment|/* emits NOTHING if n starts as 0 */
block|{
name|know
argument_list|(
name|n
operator|>
literal|0
argument_list|)
expr_stmt|;
comment|/* We expect n> 0 always */
operator|*
name|q
operator|=
name|n
operator|%
literal|10
operator|+
literal|'0'
expr_stmt|;
name|n
operator|/=
literal|10
expr_stmt|;
block|}
while|while
condition|(
operator|*
name|p
operator|++
operator|=
operator|*
operator|--
name|q
condition|)
block|{     }
comment|/* The label, as a '\0' ended string, starts at symbol_name_build. */
return|return
operator|(
name|symbol_name_build
operator|)
return|;
block|}
end_function

begin_function
name|void
name|local_colon
parameter_list|(
name|n
parameter_list|)
name|int
name|n
decl_stmt|;
comment|/* just saw "n:" */
block|{
name|local_label_counter
index|[
name|n
index|]
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|SUN_ASM_SYNTAX
name|local_label_defined
index|[
name|n
index|]
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
name|colon
argument_list|(
name|local_label_name
argument_list|(
name|n
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *			symbol_new()  *  * Return a pointer to a new symbol.  * Die if we can't make a new symbol.  * Fill in the symbol's values.  * Add symbol to end of symbol chain.  *  *  * Please always call this to create a new symbol.  *  * Changes since 1985: Symbol names may not contain '\0'. Sigh.  */
end_comment

begin_function
name|symbolS
modifier|*
name|symbol_new
parameter_list|(
name|name
parameter_list|,
name|type
parameter_list|,
name|other
parameter_list|,
name|desc
parameter_list|,
name|value
parameter_list|,
name|frag
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
comment|/* We copy this: OK to alter your copy. */
name|unsigned
name|char
name|type
decl_stmt|;
comment|/* As in<a.out.h>. */
name|char
name|other
decl_stmt|;
comment|/* As in<a.out.h>. */
name|short
name|int
name|desc
decl_stmt|;
comment|/* As in<a.out.h>. */
name|valueT
name|value
decl_stmt|;
comment|/* As in<a.out.h>, often an address. */
comment|/* Often used as offset from frag address. */
name|struct
name|frag
modifier|*
name|frag
decl_stmt|;
comment|/* For sy_frag. */
block|{
specifier|register
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
specifier|register
name|char
modifier|*
name|preserved_copy_of_name
decl_stmt|;
specifier|register
name|unsigned
name|int
name|name_length
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|name_length
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
expr_stmt|;
name|obstack_grow
argument_list|(
operator|&
name|notes
argument_list|,
name|name
argument_list|,
name|name_length
argument_list|)
expr_stmt|;
name|p
operator|=
name|obstack_finish
argument_list|(
operator|&
name|notes
argument_list|)
expr_stmt|;
comment|/* obstack_1done(&notes, name, name_length,&p ); */
name|preserved_copy_of_name
operator|=
name|p
expr_stmt|;
name|p
operator|=
name|obstack_alloc
argument_list|(
operator|&
name|notes
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
comment|/* obstack_1blank(&notes, sizeof(struct symbol),&p ); */
name|symbolP
operator|=
operator|(
name|symbolS
operator|*
operator|)
name|p
expr_stmt|;
name|symbolP
operator|->
name|sy_name
operator|=
name|preserved_copy_of_name
expr_stmt|;
name|symbolP
operator|->
name|sy_type
operator|=
name|type
expr_stmt|;
name|symbolP
operator|->
name|sy_other
operator|=
name|other
expr_stmt|;
name|symbolP
operator|->
name|sy_desc
operator|=
name|desc
expr_stmt|;
name|symbolP
operator|->
name|sy_value
operator|=
name|value
expr_stmt|;
name|symbolP
operator|->
name|sy_frag
operator|=
name|frag
expr_stmt|;
name|symbolP
operator|->
name|sy_next
operator|=
name|NULL
expr_stmt|;
comment|/* End of chain. */
name|symbolP
operator|->
name|sy_forward
operator|=
name|NULL
expr_stmt|;
comment|/* JF */
ifdef|#
directive|ifdef
name|SUSPECT
name|symbolP
operator|->
name|sy_name_offset
operator|=
operator|~
literal|0
expr_stmt|;
comment|/* Impossible offset catches errors. */
name|symbolP
operator|->
name|sy_number
operator|=
operator|~
literal|0
expr_stmt|;
comment|/* Ditto. */
endif|#
directive|endif
comment|/*    * Link to end of symbol chain.    */
if|if
condition|(
name|symbol_lastP
condition|)
block|{
name|symbol_lastP
operator|->
name|sy_next
operator|=
name|symbolP
expr_stmt|;
block|}
else|else
block|{
name|symbol_rootP
operator|=
name|symbolP
expr_stmt|;
block|}
name|symbol_lastP
operator|=
name|symbolP
expr_stmt|;
return|return
operator|(
name|symbolP
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *			colon()  *  * We have just seen "<name>:".  * Creates a struct symbol unless it already exists.  *  * Gripes if we are redefining a symbol incompatibly (and ignores it).  *  */
end_comment

begin_function
name|void
name|colon
parameter_list|(
name|sym_name
parameter_list|)
comment|/* just seen "x:" - rattle symbols& frags */
specifier|register
name|char
modifier|*
name|sym_name
decl_stmt|;
comment|/* symbol name, as a cannonical string */
comment|/* We copy this string: OK to alter later. */
block|{
specifier|register
name|struct
name|symbol
modifier|*
name|symbolP
decl_stmt|;
comment|/* symbol we are working with */
ifdef|#
directive|ifdef
name|SUN_ASM_SYNTAX
comment|/* Sun local labes go out of scope whenever a non-local symbol is      defined.  */
if|if
condition|(
operator|*
name|sym_name
operator|!=
literal|'L'
condition|)
name|bzero
argument_list|(
operator|(
name|void
operator|*
operator|)
name|local_label_defined
argument_list|,
sizeof|sizeof
argument_list|(
name|local_label_defined
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|WORKING_DOT_WORD
if|if
condition|(
name|new_broken_words
condition|)
block|{
name|struct
name|broken_word
modifier|*
name|a
decl_stmt|;
name|int
name|possible_bytes
decl_stmt|;
name|fragS
modifier|*
name|frag_tmp
decl_stmt|;
name|char
modifier|*
name|frag_opcode
decl_stmt|;
extern|extern md_short_jump_size;
extern|extern md_long_jump_size;
name|possible_bytes
operator|=
name|md_short_jump_size
operator|+
name|new_broken_words
operator|*
name|md_long_jump_size
expr_stmt|;
name|frag_tmp
operator|=
name|frag_now
expr_stmt|;
name|frag_opcode
operator|=
name|frag_var
argument_list|(
name|rs_broken_word
argument_list|,
name|possible_bytes
argument_list|,
name|possible_bytes
argument_list|,
operator|(
name|relax_substateT
operator|)
literal|0
argument_list|,
operator|(
name|symbolS
operator|*
operator|)
name|broken_words
argument_list|,
operator|(
name|long
name|int
operator|)
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
comment|/* We want to store the pointer to where to insert the jump table in the        fr_opcode of the rs_broken_word frag.  This requires a little hackery */
while|while
condition|(
name|frag_tmp
operator|&&
operator|(
name|frag_tmp
operator|->
name|fr_type
operator|!=
name|rs_broken_word
operator|||
name|frag_tmp
operator|->
name|fr_opcode
operator|)
condition|)
name|frag_tmp
operator|=
name|frag_tmp
operator|->
name|fr_next
expr_stmt|;
name|know
argument_list|(
name|frag_tmp
argument_list|)
expr_stmt|;
name|frag_tmp
operator|->
name|fr_opcode
operator|=
name|frag_opcode
expr_stmt|;
name|new_broken_words
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|a
operator|=
name|broken_words
init|;
name|a
operator|&&
name|a
operator|->
name|dispfrag
operator|==
literal|0
condition|;
name|a
operator|=
name|a
operator|->
name|next_broken_word
control|)
name|a
operator|->
name|dispfrag
operator|=
name|frag_tmp
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|symbolP
operator|=
name|symbol_table_lookup
argument_list|(
name|sym_name
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|VMS
comment|/*        *	If the new symbol is .comm AND it has a size of zero,        *	we ignore it (i.e. the old symbol overrides it)        */
if|if
condition|(
operator|(
name|seg_N_TYPE
index|[
operator|(
name|int
operator|)
name|now_seg
index|]
operator|==
operator|(
name|N_UNDF
operator||
name|N_EXT
operator|)
operator|)
operator|&&
operator|(
operator|(
name|obstack_next_free
argument_list|(
operator|&
name|frags
argument_list|)
operator|-
name|frag_now
operator|->
name|fr_literal
operator|)
operator|==
literal|0
operator|)
condition|)
return|return;
comment|/*        *	If the old symbol is .comm and it has a size of zero,        *	we override it with the new symbol value.        */
if|if
condition|(
operator|(
name|symbolP
operator|->
name|sy_type
operator|==
operator|(
name|N_UNDF
operator||
name|N_EXT
operator|)
operator|)
operator|&&
operator|(
name|symbolP
operator|->
name|sy_value
operator|==
literal|0
operator|)
condition|)
block|{
name|symbolP
operator|->
name|sy_frag
operator|=
name|frag_now
expr_stmt|;
name|symbolP
operator|->
name|sy_other
operator|=
name|const_flag
expr_stmt|;
name|symbolP
operator|->
name|sy_value
operator|=
name|obstack_next_free
argument_list|(
operator|&
name|frags
argument_list|)
operator|-
name|frag_now
operator|->
name|fr_literal
expr_stmt|;
name|symbolP
operator|->
name|sy_type
operator||=
name|seg_N_TYPE
index|[
operator|(
name|int
operator|)
name|now_seg
index|]
expr_stmt|;
comment|/* keep N_EXT bit */
return|return;
block|}
endif|#
directive|endif
comment|/* VMS */
comment|/*        *	Now check for undefined symbols        */
if|if
condition|(
operator|(
name|symbolP
operator|->
name|sy_type
operator|&
name|N_TYPE
operator|)
operator|==
name|N_UNDF
condition|)
block|{
if|if
condition|(
name|symbolP
operator|->
name|sy_other
operator|==
literal|0
operator|&&
name|symbolP
operator|->
name|sy_desc
operator|==
literal|0
operator|&&
name|symbolP
operator|->
name|sy_value
operator|==
literal|0
condition|)
block|{
name|symbolP
operator|->
name|sy_frag
operator|=
name|frag_now
expr_stmt|;
ifdef|#
directive|ifdef
name|VMS
name|symbolP
operator|->
name|sy_other
operator|=
name|const_flag
expr_stmt|;
endif|#
directive|endif
name|symbolP
operator|->
name|sy_value
operator|=
name|obstack_next_free
argument_list|(
operator|&
name|frags
argument_list|)
operator|-
name|frag_now
operator|->
name|fr_literal
expr_stmt|;
name|know
argument_list|(
name|N_UNDF
operator|==
literal|0
argument_list|)
expr_stmt|;
name|symbolP
operator|->
name|sy_type
operator||=
name|seg_N_TYPE
index|[
operator|(
name|int
operator|)
name|now_seg
index|]
expr_stmt|;
comment|/* keep N_EXT bit */
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|VMS
comment|/* 	       *	There are still several cases to check: 	       *		A .comm/.lcomm symbol being redefined as 	       *			initialized data is OK 	       *		A .comm/.lcomm symbol being redefined with 	       *			a larger size is also OK 	       */
name|char
name|New_Type
init|=
name|seg_N_TYPE
index|[
operator|(
name|int
operator|)
name|now_seg
index|]
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|symbolP
operator|->
name|sy_type
operator|==
operator|(
name|N_UNDF
operator||
name|N_EXT
operator|)
operator|)
operator|||
operator|(
name|symbolP
operator|->
name|sy_type
operator|==
name|N_BSS
operator|)
operator|)
operator|&&
operator|(
operator|(
operator|(
name|New_Type
operator|&
operator|~
name|N_EXT
operator|)
operator|==
name|N_DATA
operator|)
operator|||
operator|(
name|New_Type
operator|==
name|symbolP
operator|->
name|sy_type
operator|)
operator|)
condition|)
block|{
comment|/* 			 *	Select which of the 2 cases this is 			 */
if|if
condition|(
name|New_Type
operator|==
name|symbolP
operator|->
name|sy_type
condition|)
block|{
comment|/* 				 *	If the new size is larger we just 				 *	change its value.  If the new size 				 *	is smaller, we ignore this symbol 				 */
if|if
condition|(
name|symbolP
operator|->
name|sy_value
operator|<
operator|(
name|obstack_next_free
argument_list|(
operator|&
name|frags
argument_list|)
operator|-
name|frag_now
operator|->
name|fr_literal
operator|)
condition|)
block|{
name|symbolP
operator|->
name|sy_value
operator|=
name|obstack_next_free
argument_list|(
operator|&
name|frags
argument_list|)
operator|-
name|frag_now
operator|->
name|fr_literal
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 				 *	It is a .comm/.lcomm being converted 				 *	to initialized data. 				 */
name|symbolP
operator|->
name|sy_frag
operator|=
name|frag_now
expr_stmt|;
name|symbolP
operator|->
name|sy_other
operator|=
name|const_flag
expr_stmt|;
name|symbolP
operator|->
name|sy_value
operator|=
name|obstack_next_free
argument_list|(
operator|&
name|frags
argument_list|)
operator|-
name|frag_now
operator|->
name|fr_literal
expr_stmt|;
name|symbolP
operator|->
name|sy_type
operator||=
name|seg_N_TYPE
index|[
operator|(
name|int
operator|)
name|now_seg
index|]
expr_stmt|;
comment|/* keep N_EXT bit */
block|}
block|}
else|else
block|{
endif|#
directive|endif
comment|/* VMS */
name|as_fatal
argument_list|(
literal|"Symbol \"%s\" is already defined as \"%s\"/%d.%d.%d."
argument_list|,
name|sym_name
argument_list|,
name|seg_name
index|[
operator|(
name|int
operator|)
name|N_TYPE_seg
index|[
name|symbolP
operator|->
name|sy_type
operator|&
name|N_TYPE
index|]
index|]
argument_list|,
name|symbolP
operator|->
name|sy_other
argument_list|,
name|symbolP
operator|->
name|sy_desc
argument_list|,
name|symbolP
operator|->
name|sy_value
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|VMS
block|}
endif|#
directive|endif
comment|/* VMS */
block|}
block|}
else|else
block|{
name|as_fatal
argument_list|(
literal|"Symbol %s already defined."
argument_list|,
name|sym_name
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|symbolP
operator|=
name|symbol_new
argument_list|(
name|sym_name
argument_list|,
call|(
name|unsigned
name|char
call|)
argument_list|(
name|seg_N_TYPE
index|[
operator|(
name|int
operator|)
name|now_seg
index|]
argument_list|)
argument_list|,
ifdef|#
directive|ifdef
name|VMS
name|const_flag
argument_list|,
else|#
directive|else
literal|0
argument_list|,
endif|#
directive|endif
literal|0
argument_list|,
call|(
name|valueT
call|)
argument_list|(
name|obstack_next_free
argument_list|(
operator|&
name|frags
argument_list|)
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|)
argument_list|,
name|frag_now
argument_list|)
expr_stmt|;
name|symbol_table_insert
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *			symbol_table_insert()  *  * Die if we can't insert the symbol.  *  */
end_comment

begin_function
name|void
name|symbol_table_insert
parameter_list|(
name|symbolP
parameter_list|)
name|struct
name|symbol
modifier|*
name|symbolP
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|error_string
decl_stmt|;
name|know
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
name|know
argument_list|(
name|symbolP
operator|->
name|sy_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|error_string
operator|=
name|hash_jam
argument_list|(
name|sy_hash
argument_list|,
name|symbolP
operator|->
name|sy_name
argument_list|,
operator|(
name|char
operator|*
operator|)
name|symbolP
argument_list|)
operator|)
condition|)
block|{
name|as_fatal
argument_list|(
literal|"Inserting \"%s\" into symbol table failed: %s"
argument_list|,
name|symbolP
operator|->
name|sy_name
argument_list|,
name|error_string
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *			symbol_find_or_make()  *  * If a symbol name does not exist, create it as undefined, and insert  * it into the symbol table. Return a pointer to it.  */
end_comment

begin_function
name|symbolS
modifier|*
name|symbol_find_or_make
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
name|symbolP
operator|=
name|symbol_table_lookup
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|symbolP
operator|==
name|NULL
condition|)
block|{
name|symbolP
operator|=
name|symbol_new
argument_list|(
name|name
argument_list|,
name|N_UNDF
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
expr_stmt|;
name|symbol_table_insert
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|symbolP
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *			symbol_find()  *   * Implement symbol table lookup.  * In:	A symbol's name as a string: '\0' can't be part of a symbol name.  * Out:	NULL if the name was not in the symbol table, else the address  *	of a struct symbol associated with that name.  */
end_comment

begin_function
name|symbolS
modifier|*
name|symbol_find
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
return|return
operator|(
operator|(
name|symbolS
operator|*
operator|)
name|hash_find
argument_list|(
name|sy_hash
argument_list|,
name|name
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* end: symbols.c */
end_comment

end_unit

