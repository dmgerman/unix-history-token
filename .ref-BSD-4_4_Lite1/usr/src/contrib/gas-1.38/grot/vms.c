begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* vms.c -- Write out a VAX/VMS object file    Copyright (C) 1987, 1988 Free Software Foundation, Inc.  This file is part of GAS, the GNU Assembler.  GAS is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version.  GAS is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GAS; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* Written by David L. Kashtan */
end_comment

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|"md.h"
end_include

begin_include
include|#
directive|include
file|"subsegs.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"struc-symbol.h"
end_include

begin_include
include|#
directive|include
file|"write.h"
end_include

begin_include
include|#
directive|include
file|"symbols.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|VMS
end_ifdef

begin_comment
comment|/* THIS MODULE IS FOR VMS ONLY */
end_comment

begin_include
include|#
directive|include
file|<stab.h>
end_include

begin_include
include|#
directive|include
file|"objrecdef.h"
end_include

begin_comment
comment|/* Define VMS Object record lang. */
end_comment

begin_include
include|#
directive|include
file|<vms/fabdef.h>
end_include

begin_comment
comment|/* Define File Access Block	  */
end_comment

begin_include
include|#
directive|include
file|<vms/namdef.h>
end_include

begin_comment
comment|/* Define NAM Block		  */
end_comment

begin_include
include|#
directive|include
file|<vms/xabdef.h>
end_include

begin_comment
comment|/* Define XAB			  */
end_comment

begin_include
include|#
directive|include
file|<vms/xabdatdef.h>
end_include

begin_comment
comment|/* Define Date XAB		  */
end_comment

begin_include
include|#
directive|include
file|<vms/xabfhcdef.h>
end_include

begin_comment
comment|/* Define File Header XAB	  */
end_comment

begin_comment
comment|/*  *	Version string of the compiler that produced the code we are  *	assembling.  (And this assembler, if we do not have compiler info.)  */
end_comment

begin_decl_stmt
specifier|extern
name|char
name|version_string
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|compiler_version_string
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|myname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|symbolS
modifier|*
name|Entry_Point_Symbol
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointer to "_main"	 */
end_comment

begin_comment
comment|/*  *	We augment the "gas" symbol structure with this  */
end_comment

begin_struct
struct|struct
name|VMS_Symbol
block|{
name|struct
name|VMS_Symbol
modifier|*
name|Next
decl_stmt|;
name|struct
name|symbol
modifier|*
name|Symbol
decl_stmt|;
name|int
name|Size
decl_stmt|;
name|int
name|Psect_Index
decl_stmt|;
name|int
name|Psect_Offset
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|VMS_Symbol
modifier|*
name|VMS_Symbols
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* we need this to keep track of the various input files, so that we can  * give the debugger the correct source line   */
end_comment

begin_struct
struct|struct
name|input_file
block|{
name|struct
name|input_file
modifier|*
name|next
decl_stmt|;
name|struct
name|input_file
modifier|*
name|same_file_fpnt
decl_stmt|;
name|int
name|file_number
decl_stmt|;
name|int
name|max_line
decl_stmt|;
name|int
name|min_line
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|char
name|flag
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|symbolS
modifier|*
name|spnt
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|input_file
modifier|*
name|file_root
init|=
operator|(
expr|struct
name|input_file
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_function_decl
name|struct
name|input_file
modifier|*
name|find_file
parameter_list|(
name|symbolS
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/*  *	If the procedure "main()" exists we have to add the instruction  *	"jsb c$main_args" at the beginning to be compatible with VAX-11 "C".  */
end_comment

begin_macro
name|VMS_Check_For_Main
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
ifdef|#
directive|ifdef
name|HACK_DEC_C_STARTUP
comment|/* JF */
specifier|register
name|struct
name|frchain
modifier|*
name|frchainP
decl_stmt|;
specifier|register
name|fragS
modifier|*
name|fragP
decl_stmt|;
specifier|register
name|fragS
modifier|*
modifier|*
name|prev_fragPP
decl_stmt|;
specifier|register
name|struct
name|fix
modifier|*
name|fixP
decl_stmt|;
specifier|register
name|fragS
modifier|*
name|New_Frag
decl_stmt|;
name|int
name|i
decl_stmt|;
endif|#
directive|endif
endif|HACK_DEC_C_STARTUP
name|symbolP
operator|=
operator|(
expr|struct
name|symbol
operator|*
operator|)
name|symbol_find
argument_list|(
literal|"_main"
argument_list|)
expr_stmt|;
if|if
condition|(
name|symbolP
operator|&&
operator|(
name|symbolP
operator|->
name|sy_nlist
operator|.
name|n_type
operator|==
operator|(
name|N_TEXT
operator||
name|N_EXT
operator|)
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|HACK_DEC_C_STARTUP
if|if
condition|(
operator|!
name|flagseen
index|[
literal|'+'
index|]
condition|)
block|{
endif|#
directive|endif
comment|/* 		 *	Remember the entry point symbol 		 */
name|Entry_Point_Symbol
operator|=
name|symbolP
expr_stmt|;
ifdef|#
directive|ifdef
name|HACK_DEC_C_STARTUP
block|}
else|else
block|{
comment|/* 		 *	Scan all the fragment chains for the one with "_main" 		 *	(Actually we know the fragment from the symbol, but we need 		 *	 the previous fragment so we can change its pointer) 		 */
name|frchainP
operator|=
name|frchain_root
expr_stmt|;
while|while
condition|(
name|frchainP
condition|)
block|{
comment|/* 			 *	Scan all the fragments in this chain, remembering 			 *	the "previous fragment" 			 */
name|prev_fragPP
operator|=
operator|&
name|frchainP
operator|->
name|frch_root
expr_stmt|;
name|fragP
operator|=
name|frchainP
operator|->
name|frch_root
expr_stmt|;
while|while
condition|(
name|fragP
operator|&&
operator|(
name|fragP
operator|!=
name|frchainP
operator|->
name|frch_last
operator|)
condition|)
block|{
comment|/* 				 *	Is this the fragment? 				 */
if|if
condition|(
name|fragP
operator|==
name|symbolP
operator|->
name|sy_frag
condition|)
block|{
comment|/* 					 *	Yes: Modify the fragment by replacing 					 *	     it with a new fragment. 					 */
name|New_Frag
operator|=
operator|(
name|fragS
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|New_Frag
argument_list|)
operator|+
name|fragP
operator|->
name|fr_fix
operator|+
name|fragP
operator|->
name|fr_var
operator|+
literal|5
argument_list|)
expr_stmt|;
comment|/* 					 *	The fragments are the same except 					 *	that the "fixed" area is larger 					 */
operator|*
name|New_Frag
operator|=
operator|*
name|fragP
expr_stmt|;
name|New_Frag
operator|->
name|fr_fix
operator|+=
literal|6
expr_stmt|;
comment|/* 					 *	Copy the literal data opening a hole 					 *	2 bytes after "_main" (i.e. just after 					 *	the entry mask).  Into which we place 					 *	the JSB instruction. 					 */
name|New_Frag
operator|->
name|fr_literal
index|[
literal|0
index|]
operator|=
name|fragP
operator|->
name|fr_literal
index|[
literal|0
index|]
expr_stmt|;
name|New_Frag
operator|->
name|fr_literal
index|[
literal|1
index|]
operator|=
name|fragP
operator|->
name|fr_literal
index|[
literal|1
index|]
expr_stmt|;
name|New_Frag
operator|->
name|fr_literal
index|[
literal|2
index|]
operator|=
literal|0x16
expr_stmt|;
comment|/* Jsb */
name|New_Frag
operator|->
name|fr_literal
index|[
literal|3
index|]
operator|=
literal|0xef
expr_stmt|;
name|New_Frag
operator|->
name|fr_literal
index|[
literal|4
index|]
operator|=
literal|0
expr_stmt|;
name|New_Frag
operator|->
name|fr_literal
index|[
literal|5
index|]
operator|=
literal|0
expr_stmt|;
name|New_Frag
operator|->
name|fr_literal
index|[
literal|6
index|]
operator|=
literal|0
expr_stmt|;
name|New_Frag
operator|->
name|fr_literal
index|[
literal|7
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
name|fragP
operator|->
name|fr_fix
operator|+
name|fragP
operator|->
name|fr_var
condition|;
name|i
operator|++
control|)
name|New_Frag
operator|->
name|fr_literal
index|[
name|i
operator|+
literal|6
index|]
operator|=
name|fragP
operator|->
name|fr_literal
index|[
name|i
index|]
expr_stmt|;
comment|/* 					 *	Now replace the old fragment with the 					 *	newly generated one. 					 */
operator|*
name|prev_fragPP
operator|=
name|New_Frag
expr_stmt|;
comment|/* 					 *	Remember the entry point symbol 					 */
name|Entry_Point_Symbol
operator|=
name|symbolP
expr_stmt|;
comment|/* 					 *	Scan the text area fixup structures 					 *	as offsets in the fragment may have 					 *	changed 					 */
for|for
control|(
name|fixP
operator|=
name|text_fix_root
init|;
name|fixP
condition|;
name|fixP
operator|=
name|fixP
operator|->
name|fx_next
control|)
block|{
comment|/* 						 *	Look for references to this 						 *	fragment. 						 */
if|if
condition|(
name|fixP
operator|->
name|fx_frag
operator|==
name|fragP
condition|)
block|{
comment|/* 							 *	Change the fragment 							 *	pointer 							 */
name|fixP
operator|->
name|fx_frag
operator|=
name|New_Frag
expr_stmt|;
comment|/* 							 *	If the offset is after 							 *	the entry mask we need 							 *	to account for the JSB 							 *	instruction we just 							 *	inserted. 							 */
if|if
condition|(
name|fixP
operator|->
name|fx_where
operator|>=
literal|2
condition|)
name|fixP
operator|->
name|fx_where
operator|+=
literal|6
expr_stmt|;
block|}
block|}
comment|/* 					 *	Scan the symbols as offsets in the 					 *	fragment may have changed 					 */
for|for
control|(
name|symbolP
operator|=
name|symbol_rootP
init|;
name|symbolP
condition|;
name|symbolP
operator|=
name|symbolP
operator|->
name|sy_next
control|)
block|{
comment|/* 						 *	Look for references to this 						 *	fragment. 						 */
if|if
condition|(
name|symbolP
operator|->
name|sy_frag
operator|==
name|fragP
condition|)
block|{
comment|/* 							 *	Change the fragment 							 *	pointer 							 */
name|symbolP
operator|->
name|sy_frag
operator|=
name|New_Frag
expr_stmt|;
comment|/* 							 *	If the offset is after 							 *	the entry mask we need 							 *	to account for the JSB 							 *	instruction we just 							 *	inserted. 							 */
if|if
condition|(
name|symbolP
operator|->
name|sy_nlist
operator|.
name|n_value
operator|>=
literal|2
condition|)
name|symbolP
operator|->
name|sy_nlist
operator|.
name|n_value
operator|+=
literal|6
expr_stmt|;
block|}
block|}
comment|/* 					 *	Make a symbol reference to 					 *	"_c$main_args" so we can get 					 *	its address inserted into the 					 *	JSB instruction. 					 */
name|symbolP
operator|=
operator|(
name|symbolS
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|symbolP
argument_list|)
argument_list|)
expr_stmt|;
name|symbolP
operator|->
name|sy_nlist
operator|.
name|n_un
operator|.
name|n_name
operator|=
literal|"_c$main_args"
expr_stmt|;
name|symbolP
operator|->
name|sy_nlist
operator|.
name|n_type
operator|=
name|N_UNDF
expr_stmt|;
name|symbolP
operator|->
name|sy_nlist
operator|.
name|n_other
operator|=
literal|0
expr_stmt|;
name|symbolP
operator|->
name|sy_nlist
operator|.
name|n_desc
operator|=
literal|0
expr_stmt|;
name|symbolP
operator|->
name|sy_nlist
operator|.
name|n_value
operator|=
literal|0
expr_stmt|;
name|symbolP
operator|->
name|sy_name_offset
operator|=
literal|0
expr_stmt|;
name|symbolP
operator|->
name|sy_number
operator|=
literal|0
expr_stmt|;
name|symbolP
operator|->
name|sy_frag
operator|=
name|New_Frag
expr_stmt|;
name|symbolP
operator|->
name|sy_forward
operator|=
literal|0
expr_stmt|;
name|symbolP
operator|->
name|sy_next
operator|=
name|symbol_rootP
expr_stmt|;
name|symbol_rootP
operator|=
name|symbolP
expr_stmt|;
comment|/* 					 *	Generate a text fixup structure 					 *	to get "_c$main_args" stored into the 					 *	JSB instruction. 					 */
name|fixP
operator|=
operator|(
expr|struct
name|fix
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|fixP
argument_list|)
argument_list|)
expr_stmt|;
name|fixP
operator|->
name|fx_frag
operator|=
name|New_Frag
expr_stmt|;
name|fixP
operator|->
name|fx_where
operator|=
literal|4
expr_stmt|;
name|fixP
operator|->
name|fx_addsy
operator|=
name|symbolP
expr_stmt|;
name|fixP
operator|->
name|fx_subsy
operator|=
literal|0
expr_stmt|;
name|fixP
operator|->
name|fx_offset
operator|=
literal|0
expr_stmt|;
name|fixP
operator|->
name|fx_size
operator|=
sizeof|sizeof
argument_list|(
name|long
argument_list|)
expr_stmt|;
name|fixP
operator|->
name|fx_pcrel
operator|=
literal|1
expr_stmt|;
name|fixP
operator|->
name|fx_next
operator|=
name|text_fix_root
expr_stmt|;
name|text_fix_root
operator|=
name|fixP
expr_stmt|;
comment|/* 					 *	Now make sure we exit from the loop 					 */
name|frchainP
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/* 				 *	Try the next fragment 				 */
name|prev_fragPP
operator|=
operator|&
name|fragP
operator|->
name|fr_next
expr_stmt|;
name|fragP
operator|=
name|fragP
operator|->
name|fr_next
expr_stmt|;
block|}
comment|/* 			 *	Try the next fragment chain 			 */
if|if
condition|(
name|frchainP
condition|)
name|frchainP
operator|=
name|frchainP
operator|->
name|frch_next
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* HACK_DEC_C_STARTUP */
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  *	Write a VAX/VMS object file (everything else has been done!)  */
end_comment

begin_macro
name|VMS_write_object_file
argument_list|(
argument|text_siz
argument_list|,
argument|data_siz
argument_list|,
argument|text_frag_root
argument_list|,
argument|data_frag_root
argument_list|)
end_macro

begin_decl_stmt
name|unsigned
name|text_siz
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|data_siz
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|frag
modifier|*
name|text_frag_root
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|frag
modifier|*
name|data_frag_root
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|fragS
modifier|*
name|fragP
decl_stmt|;
specifier|register
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
specifier|register
name|symbolS
modifier|*
name|sp
decl_stmt|;
specifier|register
name|struct
name|fix
modifier|*
name|fixP
decl_stmt|;
specifier|register
name|struct
name|VMS_Symbol
modifier|*
name|vsp
decl_stmt|;
name|int
name|Local_Initialized_Data_Size
init|=
literal|0
decl_stmt|;
name|int
name|Psect_Number
init|=
literal|0
decl_stmt|;
comment|/* Psect Index Number */
name|int
name|Text_Psect
init|=
operator|-
literal|1
decl_stmt|;
comment|/* Text Psect Index   */
name|int
name|Data_Psect
init|=
operator|-
literal|2
decl_stmt|;
comment|/* Data Psect Index   JF: Was -1 */
name|int
name|Bss_Psect
init|=
operator|-
literal|3
decl_stmt|;
comment|/* Bss Psect Index    JF: Was -1 */
comment|/*     *	Create the VMS object file     */
name|Create_VMS_Object_File
argument_list|()
expr_stmt|;
comment|/*     *	Write the module header records     */
name|Write_VMS_MHD_Records
argument_list|()
expr_stmt|;
comment|/*      *	Generate the VMS object file records      *	1st GSD then TIR records      */
comment|/*******       Global Symbol Dictionary       *******/
comment|/* 	 *	Define the Text Psect 	 */
if|if
condition|(
name|text_siz
operator|>
literal|0
condition|)
block|{
name|Text_Psect
operator|=
name|Psect_Number
operator|++
expr_stmt|;
name|VMS_Psect_Spec
argument_list|(
literal|"$code"
argument_list|,
name|text_siz
argument_list|,
literal|"TEXT"
argument_list|)
expr_stmt|;
block|}
comment|/* 	 *	Define the BSS Psect 	 */
if|if
condition|(
name|local_bss_counter
operator|>
literal|0
condition|)
block|{
name|Bss_Psect
operator|=
name|Psect_Number
operator|++
expr_stmt|;
name|VMS_Psect_Spec
argument_list|(
literal|"$uninitialized_data"
argument_list|,
name|local_bss_counter
argument_list|,
literal|"DATA"
argument_list|)
expr_stmt|;
block|}
comment|/* 	 *	Now scan the symbols and emit the appropriate GSD records 	 */
for|for
control|(
name|sp
operator|=
name|symbol_rootP
init|;
name|sp
condition|;
name|sp
operator|=
name|sp
operator|->
name|sy_next
control|)
block|{
comment|/* 		 *	Dispatch on symbol type 		 */
switch|switch
condition|(
name|sp
operator|->
name|sy_type
condition|)
block|{
comment|/* 			 *	Global uninitialized data 			 */
case|case
name|N_UNDF
operator||
name|N_EXT
case|:
comment|/* 				 *	Make a VMS data symbol entry 				 */
name|vsp
operator|=
operator|(
expr|struct
name|VMS_Symbol
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|vsp
argument_list|)
argument_list|)
expr_stmt|;
name|vsp
operator|->
name|Symbol
operator|=
name|sp
expr_stmt|;
name|vsp
operator|->
name|Size
operator|=
name|sp
operator|->
name|sy_nlist
operator|.
name|n_value
expr_stmt|;
name|vsp
operator|->
name|Psect_Index
operator|=
name|Psect_Number
operator|++
expr_stmt|;
name|vsp
operator|->
name|Psect_Offset
operator|=
literal|0
expr_stmt|;
name|vsp
operator|->
name|Next
operator|=
name|VMS_Symbols
expr_stmt|;
name|VMS_Symbols
operator|=
name|vsp
expr_stmt|;
name|sp
operator|->
name|sy_number
operator|=
operator|(
name|int
operator|)
name|vsp
expr_stmt|;
comment|/* 				 *	Make the psect for this data 				 */
if|if
condition|(
name|sp
operator|->
name|sy_nlist
operator|.
name|n_other
condition|)
name|VMS_Psect_Spec
argument_list|(
name|sp
operator|->
name|sy_nlist
operator|.
name|n_un
operator|.
name|n_name
argument_list|,
name|vsp
operator|->
name|Size
argument_list|,
literal|"CONST"
argument_list|)
expr_stmt|;
else|else
name|VMS_Psect_Spec
argument_list|(
name|sp
operator|->
name|sy_nlist
operator|.
name|n_un
operator|.
name|n_name
argument_list|,
name|vsp
operator|->
name|Size
argument_list|,
literal|"COMMON"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NOT_VAX_11_C_COMPATIBLE
comment|/* 				 *	Place a global symbol at the 				 *	beginning of the Psect 				 */
name|VMS_Global_Symbol_Spec
argument_list|(
name|sp
operator|->
name|sy_nlist
operator|.
name|n_un
operator|.
name|n_name
argument_list|,
name|vsp
operator|->
name|Psect_Index
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|NOT_VAX_11_C_COMPATIBLE
break|break;
comment|/* 			 *	Local uninitialized data 			 */
case|case
name|N_BSS
case|:
comment|/* 				 *	Make a VMS data symbol entry 				 */
name|vsp
operator|=
operator|(
expr|struct
name|VMS_Symbol
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|vsp
argument_list|)
argument_list|)
expr_stmt|;
name|vsp
operator|->
name|Symbol
operator|=
name|sp
expr_stmt|;
name|vsp
operator|->
name|Size
operator|=
literal|0
expr_stmt|;
name|vsp
operator|->
name|Psect_Index
operator|=
name|Bss_Psect
expr_stmt|;
name|vsp
operator|->
name|Psect_Offset
operator|=
name|sp
operator|->
name|sy_nlist
operator|.
name|n_value
operator|-
name|bss_address_frag
operator|.
name|fr_address
expr_stmt|;
name|vsp
operator|->
name|Next
operator|=
name|VMS_Symbols
expr_stmt|;
name|VMS_Symbols
operator|=
name|vsp
expr_stmt|;
name|sp
operator|->
name|sy_number
operator|=
operator|(
name|int
operator|)
name|vsp
expr_stmt|;
break|break;
comment|/* 			 *	Global initialized data 			 */
case|case
name|N_DATA
operator||
name|N_EXT
case|:
comment|/* 				 *	Make a VMS data symbol entry 				 */
name|vsp
operator|=
operator|(
expr|struct
name|VMS_Symbol
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|vsp
argument_list|)
argument_list|)
expr_stmt|;
name|vsp
operator|->
name|Symbol
operator|=
name|sp
expr_stmt|;
name|vsp
operator|->
name|Size
operator|=
name|VMS_Initialized_Data_Size
argument_list|(
name|sp
argument_list|,
name|text_siz
operator|+
name|data_siz
argument_list|)
expr_stmt|;
name|vsp
operator|->
name|Psect_Index
operator|=
name|Psect_Number
operator|++
expr_stmt|;
name|vsp
operator|->
name|Psect_Offset
operator|=
literal|0
expr_stmt|;
name|vsp
operator|->
name|Next
operator|=
name|VMS_Symbols
expr_stmt|;
name|VMS_Symbols
operator|=
name|vsp
expr_stmt|;
name|sp
operator|->
name|sy_number
operator|=
operator|(
name|int
operator|)
name|vsp
expr_stmt|;
comment|/* 				 *	Make its psect 				 */
if|if
condition|(
name|sp
operator|->
name|sy_nlist
operator|.
name|n_other
condition|)
name|VMS_Psect_Spec
argument_list|(
name|sp
operator|->
name|sy_nlist
operator|.
name|n_un
operator|.
name|n_name
argument_list|,
name|vsp
operator|->
name|Size
argument_list|,
literal|"CONST"
argument_list|)
expr_stmt|;
else|else
name|VMS_Psect_Spec
argument_list|(
name|sp
operator|->
name|sy_nlist
operator|.
name|n_un
operator|.
name|n_name
argument_list|,
name|vsp
operator|->
name|Size
argument_list|,
literal|"COMMON"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NOT_VAX_11_C_COMPATIBLE
comment|/* 				 *	Place a global symbol at the 				 *	beginning of the Psect 				 */
name|VMS_Global_Symbol_Spec
argument_list|(
name|sp
operator|->
name|sy_nlist
operator|.
name|n_un
operator|.
name|n_name
argument_list|,
name|vsp
operator|->
name|Psect_Index
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|NOT_VAX_11_C_COMPATIBLE
break|break;
comment|/* 			 *	Local initialized data 			 */
case|case
name|N_DATA
case|:
comment|/* 				 *	Make a VMS data symbol entry 				 */
name|vsp
operator|=
operator|(
expr|struct
name|VMS_Symbol
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|vsp
argument_list|)
argument_list|)
expr_stmt|;
name|vsp
operator|->
name|Symbol
operator|=
name|sp
expr_stmt|;
name|vsp
operator|->
name|Size
operator|=
name|VMS_Initialized_Data_Size
argument_list|(
name|sp
argument_list|,
name|text_siz
operator|+
name|data_siz
argument_list|)
expr_stmt|;
name|vsp
operator|->
name|Psect_Index
operator|=
name|Data_Psect
expr_stmt|;
name|vsp
operator|->
name|Psect_Offset
operator|=
name|Local_Initialized_Data_Size
expr_stmt|;
name|Local_Initialized_Data_Size
operator|+=
name|vsp
operator|->
name|Size
expr_stmt|;
name|vsp
operator|->
name|Next
operator|=
name|VMS_Symbols
expr_stmt|;
name|VMS_Symbols
operator|=
name|vsp
expr_stmt|;
name|sp
operator|->
name|sy_number
operator|=
operator|(
name|int
operator|)
name|vsp
expr_stmt|;
break|break;
comment|/* 			 *	Global Text definition 			 */
case|case
name|N_TEXT
operator||
name|N_EXT
case|:
block|{
name|unsigned
name|short
name|Entry_Mask
decl_stmt|;
comment|/* 				 *	Get the entry mask 				 */
name|fragP
operator|=
name|sp
operator|->
name|sy_frag
expr_stmt|;
name|Entry_Mask
operator|=
operator|(
name|fragP
operator|->
name|fr_literal
index|[
literal|0
index|]
operator|&
literal|0xff
operator|)
operator|+
operator|(
operator|(
name|fragP
operator|->
name|fr_literal
index|[
literal|1
index|]
operator|&
literal|0xff
operator|)
operator|<<
literal|8
operator|)
expr_stmt|;
comment|/* 				 *	Define the Procedure entry pt. 				 */
name|VMS_Procedure_Entry_Pt
argument_list|(
name|sp
operator|->
name|sy_nlist
operator|.
name|n_un
operator|.
name|n_name
argument_list|,
name|Text_Psect
argument_list|,
name|sp
operator|->
name|sy_nlist
operator|.
name|n_value
argument_list|,
name|Entry_Mask
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 			 *	Local Text definition 			 */
case|case
name|N_TEXT
case|:
comment|/* 				 *	Make a VMS data symbol entry 				 */
if|if
condition|(
name|Text_Psect
operator|!=
operator|-
literal|1
condition|)
block|{
name|vsp
operator|=
operator|(
expr|struct
name|VMS_Symbol
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|vsp
argument_list|)
argument_list|)
expr_stmt|;
name|vsp
operator|->
name|Symbol
operator|=
name|sp
expr_stmt|;
name|vsp
operator|->
name|Size
operator|=
literal|0
expr_stmt|;
name|vsp
operator|->
name|Psect_Index
operator|=
name|Text_Psect
expr_stmt|;
name|vsp
operator|->
name|Psect_Offset
operator|=
name|sp
operator|->
name|sy_nlist
operator|.
name|n_value
expr_stmt|;
name|vsp
operator|->
name|Next
operator|=
name|VMS_Symbols
expr_stmt|;
name|VMS_Symbols
operator|=
name|vsp
expr_stmt|;
name|sp
operator|->
name|sy_number
operator|=
operator|(
name|int
operator|)
name|vsp
expr_stmt|;
block|}
break|break;
comment|/* 			 *	Global Reference 			 */
case|case
name|N_UNDF
case|:
comment|/* 				 *	Make a GSD global symbol reference 				 *	record. 				 */
name|VMS_Global_Symbol_Spec
argument_list|(
name|sp
operator|->
name|sy_nlist
operator|.
name|n_un
operator|.
name|n_name
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
comment|/* 			 *	Anything else 			 */
default|default:
comment|/* 				 *	Ignore STAB symbols 				 *	Including .stabs emitted by g++ 				 */
if|if
condition|(
operator|(
name|sp
operator|->
name|sy_type
operator|&
name|N_STAB
operator|)
operator|!=
literal|0
operator|||
name|sp
operator|->
name|sy_nlist
operator|.
name|n_type
operator|==
literal|22
condition|)
break|break;
comment|/* 				 *	Error 				 */
if|if
condition|(
name|sp
operator|->
name|sy_nlist
operator|.
name|n_type
operator|!=
literal|22
condition|)
name|printf
argument_list|(
literal|" ERROR, unknown type (%d)\n"
argument_list|,
name|sp
operator|->
name|sy_nlist
operator|.
name|n_type
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* 	 *	Define the Data Psect 	 */
if|if
condition|(
operator|(
name|data_siz
operator|>
literal|0
operator|)
operator|&&
operator|(
name|Local_Initialized_Data_Size
operator|>
literal|0
operator|)
condition|)
block|{
comment|/* 		 *	Do it 		 */
name|Data_Psect
operator|=
name|Psect_Number
operator|++
expr_stmt|;
name|VMS_Psect_Spec
argument_list|(
literal|"$data"
argument_list|,
name|Local_Initialized_Data_Size
argument_list|,
literal|"DATA"
argument_list|)
expr_stmt|;
comment|/* 		 *	Scan the VMS symbols and fill in the data psect 		 */
for|for
control|(
name|vsp
operator|=
name|VMS_Symbols
init|;
name|vsp
condition|;
name|vsp
operator|=
name|vsp
operator|->
name|Next
control|)
block|{
comment|/* 			 *	Only look for undefined psects 			 */
if|if
condition|(
name|vsp
operator|->
name|Psect_Index
operator|<
literal|0
condition|)
block|{
comment|/* 				 *	And only initialized data 				 */
if|if
condition|(
name|vsp
operator|->
name|Symbol
operator|->
name|sy_nlist
operator|.
name|n_type
operator|==
name|N_DATA
condition|)
name|vsp
operator|->
name|Psect_Index
operator|=
name|Data_Psect
expr_stmt|;
block|}
block|}
block|}
comment|/*******  Text Information and Relocation Records  *******/
comment|/* 	 *	Write the text segment data 	 */
if|if
condition|(
name|text_siz
operator|>
literal|0
condition|)
block|{
comment|/* 		 *	Scan the text fragments 		 */
for|for
control|(
name|fragP
operator|=
name|text_frag_root
init|;
name|fragP
condition|;
name|fragP
operator|=
name|fragP
operator|->
name|fr_next
control|)
block|{
comment|/* 			 *	Stop if we get to the data fragments 			 */
if|if
condition|(
name|fragP
operator|==
name|data_frag_root
condition|)
break|break;
comment|/* 			 *	Ignore fragments with no data 			 */
if|if
condition|(
operator|(
name|fragP
operator|->
name|fr_fix
operator|==
literal|0
operator|)
operator|&&
operator|(
name|fragP
operator|->
name|fr_var
operator|==
literal|0
operator|)
condition|)
continue|continue;
comment|/* 			 *	Go the the appropriate offset in the 			 *	Text Psect. 			 */
name|VMS_Set_Psect
argument_list|(
name|Text_Psect
argument_list|,
name|fragP
operator|->
name|fr_address
argument_list|,
name|OBJ$C_TIR
argument_list|)
expr_stmt|;
comment|/* 			 *	Store the "fixed" part 			 */
if|if
condition|(
name|fragP
operator|->
name|fr_fix
condition|)
name|VMS_Store_Immediate_Data
argument_list|(
name|fragP
operator|->
name|fr_literal
argument_list|,
name|fragP
operator|->
name|fr_fix
argument_list|,
name|OBJ$C_TIR
argument_list|)
expr_stmt|;
comment|/* 			 *	Store the "variable" part 			 */
if|if
condition|(
name|fragP
operator|->
name|fr_var
operator|&&
name|fragP
operator|->
name|fr_offset
condition|)
name|VMS_Store_Repeated_Data
argument_list|(
name|fragP
operator|->
name|fr_offset
argument_list|,
name|fragP
operator|->
name|fr_literal
operator|+
name|fragP
operator|->
name|fr_fix
argument_list|,
name|fragP
operator|->
name|fr_var
argument_list|,
name|OBJ$C_TIR
argument_list|)
expr_stmt|;
block|}
comment|/* 		 *	Now we go through the text segment fixups and 		 *	generate TIR records to fix up addresses within 		 *	the Text Psect 		 */
for|for
control|(
name|fixP
operator|=
name|text_fix_root
init|;
name|fixP
condition|;
name|fixP
operator|=
name|fixP
operator|->
name|fx_next
control|)
block|{
comment|/* 			 *	We DO handle the case of "Symbol - Symbol" as 			 *	long as it is in the same segment. 			 */
if|if
condition|(
name|fixP
operator|->
name|fx_subsy
operator|&&
name|fixP
operator|->
name|fx_addsy
condition|)
block|{
name|int
name|i
decl_stmt|;
comment|/* 				 *	They need to be in the same segment 				 */
if|if
condition|(
name|fixP
operator|->
name|fx_subsy
operator|->
name|sy_type
operator|!=
name|fixP
operator|->
name|fx_addsy
operator|->
name|sy_type
condition|)
name|error
argument_list|(
literal|"Fixup data addsy and subsy didn't have the same type"
argument_list|)
expr_stmt|;
comment|/* 				 *	And they need to be in one that we 				 *	can check the psect on 				 */
if|if
condition|(
operator|(
operator|(
name|fixP
operator|->
name|fx_addsy
operator|->
name|sy_type
operator|&
operator|~
name|N_EXT
operator|)
operator|!=
name|N_DATA
operator|)
operator|&&
operator|(
operator|(
name|fixP
operator|->
name|fx_addsy
operator|->
name|sy_type
operator|&
operator|~
name|N_EXT
operator|)
operator|!=
name|N_TEXT
operator|)
condition|)
name|error
argument_list|(
literal|"Fixup data addsy and subsy didn't have an appropriate type"
argument_list|)
expr_stmt|;
comment|/* 				 *	This had better not be PC relative! 				 */
if|if
condition|(
name|fixP
operator|->
name|fx_pcrel
condition|)
name|error
argument_list|(
literal|"Fixup data was erroneously \"pcrel\""
argument_list|)
expr_stmt|;
comment|/* 				 *	Subtract their values to get the 				 *	difference. 				 */
name|i
operator|=
name|fixP
operator|->
name|fx_addsy
operator|->
name|sy_value
operator|-
name|fixP
operator|->
name|fx_subsy
operator|->
name|sy_value
expr_stmt|;
comment|/* 				 *	Now generate the fixup object records 				 *	Set the psect and store the data 				 */
name|VMS_Set_Psect
argument_list|(
name|Text_Psect
argument_list|,
name|fixP
operator|->
name|fx_where
operator|+
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_address
argument_list|,
name|OBJ$C_TIR
argument_list|)
expr_stmt|;
name|VMS_Store_Immediate_Data
argument_list|(
operator|&
name|i
argument_list|,
name|fixP
operator|->
name|fx_size
argument_list|,
name|OBJ$C_TIR
argument_list|)
expr_stmt|;
comment|/* 				 *	Done 				 */
continue|continue;
block|}
comment|/* 			 *	Size will HAVE to be "long" 			 */
if|if
condition|(
name|fixP
operator|->
name|fx_size
operator|!=
sizeof|sizeof
argument_list|(
name|long
argument_list|)
condition|)
name|error
argument_list|(
literal|"Fixup datum was not a longword"
argument_list|)
expr_stmt|;
comment|/* 			 *	Symbol must be "added" (if it is ever 			 *				subtracted we can 			 *				fix this assumption) 			 */
if|if
condition|(
name|fixP
operator|->
name|fx_addsy
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"Fixup datum was not \"fixP->fx_addsy\""
argument_list|)
expr_stmt|;
comment|/* 			 *	Store the symbol value in a PIC fashion 			 */
name|VMS_Store_PIC_Symbol_Reference
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|,
name|fixP
operator|->
name|fx_offset
argument_list|,
name|fixP
operator|->
name|fx_pcrel
argument_list|,
name|Text_Psect
argument_list|,
name|fixP
operator|->
name|fx_where
operator|+
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_address
argument_list|,
name|OBJ$C_TIR
argument_list|)
expr_stmt|;
comment|/* 			 *	Check for indirect address reference, 			 *	which has to be fixed up (as the linker 			 *	will screw it up with TIR$C_STO_PICR). 			 */
if|if
condition|(
name|fixP
operator|->
name|fx_pcrel
condition|)
name|VMS_Fix_Indirect_Reference
argument_list|(
name|Text_Psect
argument_list|,
name|fixP
operator|->
name|fx_where
operator|+
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_address
argument_list|,
name|fixP
operator|->
name|fx_frag
argument_list|,
name|text_frag_root
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 *	Store the Data segment: 	 * 	 *	Since this is REALLY hard to do any other way, 	 *	we actually manufacture the data segment and 	 *	the store the appropriate values out of it. 	 */
if|if
condition|(
name|data_siz
operator|>
literal|0
condition|)
block|{
name|char
modifier|*
name|Data_Segment
decl_stmt|;
comment|/* 		 *	Allocate the data segment 		 */
name|Data_Segment
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|data_siz
argument_list|)
expr_stmt|;
comment|/* 		 *	Run through the data fragments, filling in the segment 		 */
for|for
control|(
name|fragP
operator|=
name|data_frag_root
init|;
name|fragP
condition|;
name|fragP
operator|=
name|fragP
operator|->
name|fr_next
control|)
block|{
specifier|register
name|long
name|int
name|count
decl_stmt|;
specifier|register
name|char
modifier|*
name|fill_literal
decl_stmt|;
specifier|register
name|long
name|int
name|fill_size
decl_stmt|;
name|int
name|i
decl_stmt|;
name|i
operator|=
name|fragP
operator|->
name|fr_address
operator|-
name|text_siz
expr_stmt|;
if|if
condition|(
name|fragP
operator|->
name|fr_fix
condition|)
name|bcopy
argument_list|(
name|fragP
operator|->
name|fr_literal
argument_list|,
name|Data_Segment
operator|+
name|i
argument_list|,
name|fragP
operator|->
name|fr_fix
argument_list|)
expr_stmt|;
name|i
operator|+=
name|fragP
operator|->
name|fr_fix
expr_stmt|;
name|fill_literal
operator|=
name|fragP
operator|->
name|fr_literal
operator|+
name|fragP
operator|->
name|fr_fix
expr_stmt|;
name|fill_size
operator|=
name|fragP
operator|->
name|fr_var
expr_stmt|;
for|for
control|(
name|count
operator|=
name|fragP
operator|->
name|fr_offset
init|;
name|count
condition|;
name|count
operator|--
control|)
block|{
if|if
condition|(
name|fill_size
condition|)
name|bcopy
argument_list|(
name|fill_literal
argument_list|,
name|Data_Segment
operator|+
name|i
argument_list|,
name|fill_size
argument_list|)
expr_stmt|;
name|i
operator|+=
name|fill_size
expr_stmt|;
block|}
block|}
comment|/* 		 *	Now we can run through all the data symbols 		 *	and store the data 		 */
for|for
control|(
name|vsp
operator|=
name|VMS_Symbols
init|;
name|vsp
condition|;
name|vsp
operator|=
name|vsp
operator|->
name|Next
control|)
block|{
comment|/* 			 *	Ignore anything other than data symbols 			 */
if|if
condition|(
operator|(
name|vsp
operator|->
name|Symbol
operator|->
name|sy_nlist
operator|.
name|n_type
operator|&
operator|~
name|N_EXT
operator|)
operator|!=
name|N_DATA
condition|)
continue|continue;
comment|/* 			 *	Set the Psect + Offset 			 */
name|VMS_Set_Psect
argument_list|(
name|vsp
operator|->
name|Psect_Index
argument_list|,
name|vsp
operator|->
name|Psect_Offset
argument_list|,
name|OBJ$C_TIR
argument_list|)
expr_stmt|;
comment|/* 			 *	Store the data 			 */
name|VMS_Store_Immediate_Data
argument_list|(
name|Data_Segment
operator|+
name|vsp
operator|->
name|Symbol
operator|->
name|sy_nlist
operator|.
name|n_value
operator|-
name|text_siz
argument_list|,
name|vsp
operator|->
name|Size
argument_list|,
name|OBJ$C_TIR
argument_list|)
expr_stmt|;
block|}
comment|/* 		 *	Now we go through the data segment fixups and 		 *	generate TIR records to fix up addresses within 		 *	the Data Psects 		 */
for|for
control|(
name|fixP
operator|=
name|data_fix_root
init|;
name|fixP
condition|;
name|fixP
operator|=
name|fixP
operator|->
name|fx_next
control|)
block|{
comment|/* 			 *	Find the symbol for the containing datum 			 */
for|for
control|(
name|vsp
operator|=
name|VMS_Symbols
init|;
name|vsp
condition|;
name|vsp
operator|=
name|vsp
operator|->
name|Next
control|)
block|{
comment|/* 				 *	Only bother with Data symbols 				 */
name|sp
operator|=
name|vsp
operator|->
name|Symbol
expr_stmt|;
if|if
condition|(
operator|(
name|sp
operator|->
name|sy_nlist
operator|.
name|n_type
operator|&
operator|~
name|N_EXT
operator|)
operator|!=
name|N_DATA
condition|)
continue|continue;
comment|/* 				 *	Ignore symbol if After fixup 				 */
if|if
condition|(
name|sp
operator|->
name|sy_nlist
operator|.
name|n_value
operator|>
operator|(
name|fixP
operator|->
name|fx_where
operator|+
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_address
operator|)
condition|)
continue|continue;
comment|/* 				 *	See if the datum is here 				 */
if|if
condition|(
operator|(
name|sp
operator|->
name|sy_nlist
operator|.
name|n_value
operator|+
name|vsp
operator|->
name|Size
operator|)
operator|<=
operator|(
name|fixP
operator|->
name|fx_where
operator|+
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_address
operator|)
condition|)
continue|continue;
comment|/* 				 *	We DO handle the case of "Symbol - Symbol" as 				 *	long as it is in the same segment. 				 */
if|if
condition|(
name|fixP
operator|->
name|fx_subsy
operator|&&
name|fixP
operator|->
name|fx_addsy
condition|)
block|{
name|int
name|i
decl_stmt|;
comment|/* 					 *	They need to be in the same segment 					 */
if|if
condition|(
name|fixP
operator|->
name|fx_subsy
operator|->
name|sy_type
operator|!=
name|fixP
operator|->
name|fx_addsy
operator|->
name|sy_type
condition|)
name|error
argument_list|(
literal|"Fixup data addsy and subsy didn't have the same type"
argument_list|)
expr_stmt|;
comment|/* 					 *	And they need to be in one that we 					 *	can check the psect on 					 */
if|if
condition|(
operator|(
operator|(
name|fixP
operator|->
name|fx_addsy
operator|->
name|sy_type
operator|&
operator|~
name|N_EXT
operator|)
operator|!=
name|N_DATA
operator|)
operator|&&
operator|(
operator|(
name|fixP
operator|->
name|fx_addsy
operator|->
name|sy_type
operator|&
operator|~
name|N_EXT
operator|)
operator|!=
name|N_TEXT
operator|)
condition|)
name|error
argument_list|(
literal|"Fixup data addsy and subsy didn't have an appropriate type"
argument_list|)
expr_stmt|;
comment|/* 					 *	This had better not be PC relative! 					 */
if|if
condition|(
name|fixP
operator|->
name|fx_pcrel
condition|)
name|error
argument_list|(
literal|"Fixup data was erroneously \"pcrel\""
argument_list|)
expr_stmt|;
comment|/* 					 *	Subtract their values to get the 					 *	difference. 					 */
name|i
operator|=
name|fixP
operator|->
name|fx_addsy
operator|->
name|sy_value
operator|-
name|fixP
operator|->
name|fx_subsy
operator|->
name|sy_value
expr_stmt|;
comment|/* 					 *	Now generate the fixup object records 					 *	Set the psect and store the data 					 */
name|VMS_Set_Psect
argument_list|(
name|vsp
operator|->
name|Psect_Index
argument_list|,
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
name|fixP
operator|->
name|fx_where
operator|-
name|vsp
operator|->
name|Symbol
operator|->
name|sy_value
operator|+
name|vsp
operator|->
name|Psect_Offset
argument_list|,
name|OBJ$C_TIR
argument_list|)
expr_stmt|;
name|VMS_Store_Immediate_Data
argument_list|(
operator|&
name|i
argument_list|,
name|fixP
operator|->
name|fx_size
argument_list|,
name|OBJ$C_TIR
argument_list|)
expr_stmt|;
comment|/* 					 *	Done 					 */
break|break;
block|}
comment|/* 				 *	Size will HAVE to be "long" 				 */
if|if
condition|(
name|fixP
operator|->
name|fx_size
operator|!=
sizeof|sizeof
argument_list|(
name|long
argument_list|)
condition|)
name|error
argument_list|(
literal|"Fixup datum was not a longword"
argument_list|)
expr_stmt|;
comment|/* 				 *	Symbol must be "added" (if it is ever 				 *				subtracted we can 				 *				fix this assumption) 				 */
if|if
condition|(
name|fixP
operator|->
name|fx_addsy
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"Fixup datum was not \"fixP->fx_addsy\""
argument_list|)
expr_stmt|;
comment|/* 				 *	Store the symbol value in a PIC fashion 				 */
name|VMS_Store_PIC_Symbol_Reference
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|,
name|fixP
operator|->
name|fx_offset
argument_list|,
name|fixP
operator|->
name|fx_pcrel
argument_list|,
name|vsp
operator|->
name|Psect_Index
argument_list|,
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
name|fixP
operator|->
name|fx_where
operator|-
name|vsp
operator|->
name|Symbol
operator|->
name|sy_value
operator|+
name|vsp
operator|->
name|Psect_Offset
argument_list|,
name|OBJ$C_TIR
argument_list|)
expr_stmt|;
comment|/* 				 *	Done 				 */
break|break;
block|}
block|}
block|}
comment|/* 	 *	Write the Traceback Begin Module record 	 */
name|VMS_TBT_Module_Begin
argument_list|()
expr_stmt|;
comment|/* 	 *	Scan the symbols and write out the routines 	 *	(this makes the assumption that symbols are in 	 *	 order of ascending text segment offset) 	 */
block|{
name|struct
name|symbol
modifier|*
name|Current_Routine
init|=
literal|0
decl_stmt|;
name|int
name|Current_Line_Number
init|=
literal|0
decl_stmt|;
name|int
name|Current_Offset
init|=
operator|-
literal|1
decl_stmt|;
name|struct
name|input_file
modifier|*
name|Current_File
decl_stmt|;
comment|/* Output debugging info for global variables and static variables that are not  * specific to one routine. We also need to examine all stabs directives, to  * find the definitions to all of the advanced data types, and this is done by  * VMS_LSYM_Parse.  This needs to be done before any definitions are output to  * the object file, since there can be forward references in the stabs  * directives. When through with parsing, the text of the stabs directive  * is altered, with the definitions removed, so that later passes will see  * directives as they would be written if the type were already defined.  *  * We also look for files and include files, and make a list of them.  We  * examine the source file numbers to establish the actual lines that code was  * generated from, and then generate offsets.  */
name|VMS_LSYM_Parse
argument_list|()
expr_stmt|;
for|for
control|(
name|symbolP
operator|=
name|symbol_rootP
init|;
name|symbolP
condition|;
name|symbolP
operator|=
name|symbolP
operator|->
name|sy_next
control|)
block|{
comment|/* 		 *	Deal with STAB symbols 		 */
if|if
condition|(
operator|(
name|symbolP
operator|->
name|sy_nlist
operator|.
name|n_type
operator|&
name|N_STAB
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		   *	Dispatch on STAB type 		   */
switch|switch
condition|(
operator|(
name|unsigned
name|char
operator|)
name|symbolP
operator|->
name|sy_nlist
operator|.
name|n_type
condition|)
block|{
case|case
name|N_SLINE
case|:
if|if
condition|(
name|symbolP
operator|->
name|sy_nlist
operator|.
name|n_desc
operator|>
name|Current_File
operator|->
name|max_line
condition|)
name|Current_File
operator|->
name|max_line
operator|=
name|symbolP
operator|->
name|sy_nlist
operator|.
name|n_desc
expr_stmt|;
if|if
condition|(
name|symbolP
operator|->
name|sy_nlist
operator|.
name|n_desc
operator|<
name|Current_File
operator|->
name|min_line
condition|)
name|Current_File
operator|->
name|min_line
operator|=
name|symbolP
operator|->
name|sy_nlist
operator|.
name|n_desc
expr_stmt|;
break|break;
case|case
name|N_SO
case|:
name|Current_File
operator|=
name|find_file
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
name|Current_File
operator|->
name|flag
operator|=
literal|1
expr_stmt|;
name|Current_File
operator|->
name|min_line
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|N_SOL
case|:
name|Current_File
operator|=
name|find_file
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
break|break;
case|case
name|N_GSYM
case|:
name|VMS_GSYM_Parse
argument_list|(
name|symbolP
argument_list|,
name|Text_Psect
argument_list|)
expr_stmt|;
break|break;
case|case
name|N_LCSYM
case|:
name|VMS_LCSYM_Parse
argument_list|(
name|symbolP
argument_list|,
name|Text_Psect
argument_list|)
expr_stmt|;
break|break;
case|case
name|N_FUN
case|:
comment|/* For static constant symbols */
case|case
name|N_STSYM
case|:
name|VMS_STSYM_Parse
argument_list|(
name|symbolP
argument_list|,
name|Text_Psect
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* now we take a quick sweep through the files and assign offsets 	to each one.  This will essentially be the starting line number to the        debugger for each file.  Output the info for the debugger to specify the        files, and then tell it how many lines to use */
block|{
name|int
name|File_Number
init|=
literal|0
decl_stmt|;
name|int
name|Debugger_Offset
init|=
literal|0
decl_stmt|;
name|int
name|file_available
decl_stmt|;
name|Current_File
operator|=
name|file_root
expr_stmt|;
for|for
control|(
name|Current_File
operator|=
name|file_root
init|;
name|Current_File
condition|;
name|Current_File
operator|=
name|Current_File
operator|->
name|next
control|)
block|{
if|if
condition|(
name|Current_File
operator|==
operator|(
expr|struct
name|input_file
operator|*
operator|)
name|NULL
condition|)
break|break;
if|if
condition|(
name|Current_File
operator|->
name|max_line
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|(
name|strncmp
argument_list|(
name|Current_File
operator|->
name|name
argument_list|,
literal|"GNU_GXX_INCLUDE:"
argument_list|,
literal|16
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|!
name|flagseen
index|[
literal|'D'
index|]
condition|)
continue|continue;
if|if
condition|(
operator|(
name|strncmp
argument_list|(
name|Current_File
operator|->
name|name
argument_list|,
literal|"GNU_CC_INCLUDE:"
argument_list|,
literal|15
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|!
name|flagseen
index|[
literal|'D'
index|]
condition|)
continue|continue;
comment|/* show a few extra lines at the start of the region selected */
if|if
condition|(
name|Current_File
operator|->
name|min_line
operator|>
literal|2
condition|)
name|Current_File
operator|->
name|min_line
operator|-=
literal|2
expr_stmt|;
name|Current_File
operator|->
name|offset
operator|=
name|Debugger_Offset
operator|-
name|Current_File
operator|->
name|min_line
operator|+
literal|1
expr_stmt|;
name|Debugger_Offset
operator|+=
name|Current_File
operator|->
name|max_line
operator|-
name|Current_File
operator|->
name|min_line
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|Current_File
operator|->
name|same_file_fpnt
operator|!=
operator|(
expr|struct
name|input_file
operator|*
operator|)
name|NULL
condition|)
name|Current_File
operator|->
name|file_number
operator|=
name|Current_File
operator|->
name|same_file_fpnt
operator|->
name|file_number
expr_stmt|;
else|else
block|{
name|Current_File
operator|->
name|file_number
operator|=
operator|++
name|File_Number
expr_stmt|;
name|file_available
operator|=
name|VMS_TBT_Source_File
argument_list|(
name|Current_File
operator|->
name|name
argument_list|,
name|Current_File
operator|->
name|file_number
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|file_available
condition|)
block|{
name|Current_File
operator|->
name|file_number
operator|=
literal|0
expr_stmt|;
name|File_Number
operator|--
expr_stmt|;
continue|continue;
block|}
empty_stmt|;
block|}
empty_stmt|;
name|VMS_TBT_Source_Lines
argument_list|(
name|Current_File
operator|->
name|file_number
argument_list|,
name|Current_File
operator|->
name|min_line
argument_list|,
name|Current_File
operator|->
name|max_line
operator|-
name|Current_File
operator|->
name|min_line
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
comment|/* for */
block|}
empty_stmt|;
comment|/* scope */
name|Current_File
operator|=
operator|(
expr|struct
name|input_file
operator|*
operator|)
name|NULL
expr_stmt|;
for|for
control|(
name|symbolP
operator|=
name|symbol_rootP
init|;
name|symbolP
condition|;
name|symbolP
operator|=
name|symbolP
operator|->
name|sy_next
control|)
block|{
comment|/* 		 *	Deal with text symbols 		 */
if|if
condition|(
operator|(
name|symbolP
operator|->
name|sy_nlist
operator|.
name|n_type
operator|&
operator|~
name|N_EXT
operator|)
operator|==
name|N_TEXT
condition|)
block|{
comment|/* 			 *	Ignore symbols starting with "L", 			 *	as they are local symbols 			 */
if|if
condition|(
name|symbolP
operator|->
name|sy_nlist
operator|.
name|n_un
operator|.
name|n_name
index|[
literal|0
index|]
operator|==
literal|'L'
condition|)
continue|continue;
comment|/* 			 *	If there is a routine start defined, 			 *	terminate it. 			 */
if|if
condition|(
name|Current_Routine
condition|)
block|{
comment|/* 				 *	End the routine 				 */
name|VMS_TBT_Routine_End
argument_list|(
name|text_siz
argument_list|,
name|Current_Routine
argument_list|)
expr_stmt|;
block|}
comment|/* 			 *	Store the routine begin traceback info 			 */
if|if
condition|(
name|Text_Psect
operator|!=
operator|-
literal|1
condition|)
block|{
name|VMS_TBT_Routine_Begin
argument_list|(
name|symbolP
argument_list|,
name|Text_Psect
argument_list|)
expr_stmt|;
name|Current_Routine
operator|=
name|symbolP
expr_stmt|;
block|}
comment|/* Output local symbols, i.e. all symbols that are associated with a specific  * routine.  We output them now so the debugger recognizes them as local to  * this routine.  */
block|{
name|symbolS
modifier|*
name|symbolP1
decl_stmt|;
name|char
modifier|*
name|pnt
decl_stmt|;
name|char
modifier|*
name|pnt1
decl_stmt|;
for|for
control|(
name|symbolP1
operator|=
name|Current_Routine
init|;
name|symbolP1
condition|;
name|symbolP1
operator|=
name|symbolP1
operator|->
name|sy_next
control|)
block|{
if|if
condition|(
operator|(
name|symbolP1
operator|->
name|sy_nlist
operator|.
name|n_type
operator|&
name|N_STAB
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|symbolP1
operator|->
name|sy_nlist
operator|.
name|n_type
operator|!=
name|N_FUN
condition|)
continue|continue;
name|pnt
operator|=
name|symbolP
operator|->
name|sy_nlist
operator|.
name|n_un
operator|.
name|n_name
expr_stmt|;
name|pnt1
operator|=
name|symbolP1
operator|->
name|sy_nlist
operator|.
name|n_un
operator|.
name|n_name
expr_stmt|;
if|if
condition|(
operator|*
name|pnt
operator|++
operator|!=
literal|'_'
condition|)
continue|continue;
while|while
condition|(
operator|*
name|pnt
operator|++
operator|==
operator|*
name|pnt1
operator|++
condition|)
block|{}
empty_stmt|;
if|if
condition|(
operator|(
operator|*
operator|(
operator|--
name|pnt
operator|)
operator|==
literal|'\0'
operator|)
operator|&&
operator|(
operator|*
operator|(
operator|--
name|pnt1
operator|)
operator|==
literal|':'
operator|)
condition|)
break|break;
block|}
empty_stmt|;
if|if
condition|(
name|symbolP1
operator|!=
operator|(
name|symbolS
operator|*
operator|)
name|NULL
condition|)
name|VMS_DBG_Define_Routine
argument_list|(
name|symbolP1
argument_list|,
name|Current_Routine
argument_list|,
name|Text_Psect
argument_list|)
expr_stmt|;
block|}
comment|/* local symbol block */
comment|/* 			 *	Done 			 */
continue|continue;
block|}
comment|/* 		 *	Deal with STAB symbols 		 */
if|if
condition|(
operator|(
name|symbolP
operator|->
name|sy_nlist
operator|.
name|n_type
operator|&
name|N_STAB
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		   *	Dispatch on STAB type 		   */
switch|switch
condition|(
operator|(
name|unsigned
name|char
operator|)
name|symbolP
operator|->
name|sy_nlist
operator|.
name|n_type
condition|)
block|{
comment|/* 			 *	Line number 			 */
case|case
name|N_SLINE
case|:
comment|/* Offset the line into the correct portion 				 * of the file */
if|if
condition|(
name|Current_File
operator|->
name|file_number
operator|==
literal|0
condition|)
break|break;
comment|/* Sometimes the same offset gets several source 				 * lines assigned to it. 				 * We should be selective about which lines 				 * we allow, we should prefer lines that are 				 * in the main source file when debugging 				 * inline functions. */
if|if
condition|(
operator|(
name|Current_File
operator|->
name|file_number
operator|!=
literal|1
operator|)
operator|&&
name|symbolP
operator|->
name|sy_nlist
operator|.
name|n_value
operator|==
name|Current_Offset
condition|)
break|break;
comment|/* calculate actual debugger source line */
name|symbolP
operator|->
name|sy_nlist
operator|.
name|n_desc
operator|+=
name|Current_File
operator|->
name|offset
expr_stmt|;
comment|/* 				 *	If this is the 1st N_SLINE, setup 				 *	PC/Line correlation.  Otherwise 				 *	do the delta PC/Line.  If the offset 				 *	for the line number is not +ve we need 				 *	to do another PC/Line correlation 				 *	setup 				 */
if|if
condition|(
name|Current_Offset
operator|==
operator|-
literal|1
condition|)
block|{
name|VMS_TBT_Line_PC_Correlation
argument_list|(
name|symbolP
operator|->
name|sy_nlist
operator|.
name|n_desc
argument_list|,
name|symbolP
operator|->
name|sy_nlist
operator|.
name|n_value
argument_list|,
name|Text_Psect
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|symbolP
operator|->
name|sy_nlist
operator|.
name|n_desc
operator|-
name|Current_Line_Number
operator|)
operator|<=
literal|0
condition|)
block|{
comment|/* 					 *	Line delta is not +ve, we 					 *	need to close the line and 					 *	start a new PC/Line 					 *	correlation. 					 */
name|VMS_TBT_Line_PC_Correlation
argument_list|(
literal|0
argument_list|,
name|symbolP
operator|->
name|sy_nlist
operator|.
name|n_value
operator|-
name|Current_Offset
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|VMS_TBT_Line_PC_Correlation
argument_list|(
name|symbolP
operator|->
name|sy_nlist
operator|.
name|n_desc
argument_list|,
name|symbolP
operator|->
name|sy_nlist
operator|.
name|n_value
argument_list|,
name|Text_Psect
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 					 *	Line delta is +ve, all is well 					 */
name|VMS_TBT_Line_PC_Correlation
argument_list|(
name|symbolP
operator|->
name|sy_nlist
operator|.
name|n_desc
operator|-
name|Current_Line_Number
argument_list|,
name|symbolP
operator|->
name|sy_nlist
operator|.
name|n_value
operator|-
name|Current_Offset
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 				 *	Update the current line/PC 				 */
name|Current_Line_Number
operator|=
name|symbolP
operator|->
name|sy_nlist
operator|.
name|n_desc
expr_stmt|;
name|Current_Offset
operator|=
name|symbolP
operator|->
name|sy_nlist
operator|.
name|n_value
expr_stmt|;
comment|/* 				 *	Done 				 */
break|break;
comment|/* 			 *	Source file 			 */
case|case
name|N_SO
case|:
comment|/* 				 *	Remember that we had a source file 				 *	and emit the source file debugger 				 *	record 				 */
name|Current_File
operator|=
name|find_file
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
break|break;
comment|/* We need to make sure that we are really in the actual source file when  * we compute the maximum line number.  Otherwise the debugger gets really  * confused */
case|case
name|N_SOL
case|:
name|Current_File
operator|=
name|find_file
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* 	    *	If there is a routine start defined, 	    *	terminate it (and the line numbers) 	    */
if|if
condition|(
name|Current_Routine
condition|)
block|{
comment|/* 		 *	Terminate the line numbers 		 */
name|VMS_TBT_Line_PC_Correlation
argument_list|(
literal|0
argument_list|,
name|text_siz
operator|-
name|Current_Routine
operator|->
name|sy_nlist
operator|.
name|n_value
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* 		 *	Terminate the routine 		 */
name|VMS_TBT_Routine_End
argument_list|(
name|text_siz
argument_list|,
name|Current_Routine
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 *	Write the Traceback End Module TBT record 	 */
name|VMS_TBT_Module_End
argument_list|()
expr_stmt|;
comment|/* 	 *	Write the End Of Module record 	 */
if|if
condition|(
name|Entry_Point_Symbol
operator|==
literal|0
condition|)
name|Write_VMS_EOM_Record
argument_list|(
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|Write_VMS_EOM_Record
argument_list|(
name|Text_Psect
argument_list|,
name|Entry_Point_Symbol
operator|->
name|sy_nlist
operator|.
name|n_value
argument_list|)
expr_stmt|;
comment|/*     *	All done, close the object file     */
name|Close_VMS_Object_File
argument_list|()
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/****** VMS OBJECT FILE HACKING ROUTINES *******/
end_comment

begin_comment
comment|/*  *	Global data (Object records limited to 512 bytes by VAX-11 "C" runtime)  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|VMS_Object_File_FD
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* File Descriptor for object file */
end_comment

begin_decl_stmt
specifier|static
name|char
name|Object_Record_Buffer
index|[
literal|512
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Buffer for object file records  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|Object_Record_Offset
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Offset to end of data	   */
end_comment

begin_decl_stmt
specifier|static
name|int
name|Current_Object_Record_Type
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Type of record in above	   */
end_comment

begin_comment
comment|/*  *	Macros for placing data into the object record buffer  */
end_comment

begin_define
define|#
directive|define
name|PUT_LONG
parameter_list|(
name|val
parameter_list|)
value|*((long *)(Object_Record_Buffer + \ 				  Object_Record_Offset)) = val; \ 			Object_Record_Offset += sizeof(long)
end_define

begin_define
define|#
directive|define
name|PUT_SHORT
parameter_list|(
name|val
parameter_list|)
value|*((short *)(Object_Record_Buffer + \ 				  Object_Record_Offset)) = val; \ 			Object_Record_Offset += sizeof(short)
end_define

begin_define
define|#
directive|define
name|PUT_CHAR
parameter_list|(
name|val
parameter_list|)
value|Object_Record_Buffer[Object_Record_Offset++] = val
end_define

begin_define
define|#
directive|define
name|PUT_COUNTED_STRING
parameter_list|(
name|cp
parameter_list|)
value|{\ 			register char *p = cp; \ 			PUT_CHAR(strlen(p)); \ 			while(*p) PUT_CHAR(*p++);}
end_define

begin_comment
comment|/*  *	Macro for determining if a Name has psect attributes attached  *	to it.  */
end_comment

begin_define
define|#
directive|define
name|PSECT_ATTRIBUTES_STRING
value|"$$PsectAttributes_"
end_define

begin_define
define|#
directive|define
name|PSECT_ATTRIBUTES_STRING_LENGTH
value|18
end_define

begin_define
define|#
directive|define
name|HAS_PSECT_ATTRIBUTES
parameter_list|(
name|Name
parameter_list|)
define|\
value|(strncmp((Name[0] == '_' ? Name + 1 : Name), \ 		 PSECT_ATTRIBUTES_STRING, \ 		 PSECT_ATTRIBUTES_STRING_LENGTH) == 0)
end_define

begin_escape
end_escape

begin_comment
comment|/*  *	Create the VMS object file  */
end_comment

begin_macro
name|Create_VMS_Object_File
argument_list|()
end_macro

begin_block
block|{
ifdef|#
directive|ifdef
name|eunice
name|VMS_Object_File_FD
operator|=
name|creat
argument_list|(
name|out_file_name
argument_list|,
literal|0777
argument_list|,
literal|"var"
argument_list|)
expr_stmt|;
else|#
directive|else
else|eunice
name|VMS_Object_File_FD
operator|=
name|creat
argument_list|(
name|out_file_name
argument_list|,
literal|0
argument_list|,
literal|"rfm=var"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|eunice
comment|/* 	 *	Deal with errors 	 */
if|if
condition|(
name|VMS_Object_File_FD
operator|<
literal|0
condition|)
block|{
name|char
name|Error_Line
index|[
literal|256
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|Error_Line
argument_list|,
literal|"Couldn't create VMS object file \"%s\""
argument_list|,
name|out_file_name
argument_list|)
expr_stmt|;
name|error
argument_list|(
name|Error_Line
argument_list|)
expr_stmt|;
block|}
comment|/* 	 *	Initialize object file hacking variables 	 */
name|Object_Record_Offset
operator|=
literal|0
expr_stmt|;
name|Current_Object_Record_Type
operator|=
operator|-
literal|1
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  *	Declare a particular type of object file record  */
end_comment

begin_macro
name|Set_VMS_Object_File_Record
argument_list|(
argument|Type
argument_list|)
end_macro

begin_decl_stmt
name|int
name|Type
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* 	 *	If the type matches, we are done 	 */
if|if
condition|(
name|Type
operator|==
name|Current_Object_Record_Type
condition|)
return|return;
comment|/* 	 *	Otherwise: flush the buffer 	 */
name|Flush_VMS_Object_Record_Buffer
argument_list|()
expr_stmt|;
comment|/* 	 *	Set the new type 	 */
name|Current_Object_Record_Type
operator|=
name|Type
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  *	Flush the object record buffer to the object file  */
end_comment

begin_macro
name|Flush_VMS_Object_Record_Buffer
argument_list|()
end_macro

begin_block
block|{
name|int
name|i
decl_stmt|;
comment|/* 	 *	If the buffer is empty, we are done 	 */
if|if
condition|(
name|Object_Record_Offset
operator|==
literal|0
condition|)
return|return;
comment|/* 	 *	Write the data to the file 	 */
name|i
operator|=
name|write
argument_list|(
name|VMS_Object_File_FD
argument_list|,
name|Object_Record_Buffer
argument_list|,
name|Object_Record_Offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|Object_Record_Offset
condition|)
name|error
argument_list|(
literal|"I/O error writing VMS object file"
argument_list|)
expr_stmt|;
comment|/* 	 *	The buffer is now empty 	 */
name|Object_Record_Offset
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  *	Close the VMS Object file  */
end_comment

begin_macro
name|Close_VMS_Object_File
argument_list|()
end_macro

begin_block
block|{
name|close
argument_list|(
name|VMS_Object_File_FD
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  *	Write the MHD (Module Header) records  */
end_comment

begin_macro
name|Write_VMS_MHD_Records
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|cp1
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
struct|struct
block|{
name|int
name|Size
decl_stmt|;
name|char
modifier|*
name|Ptr
decl_stmt|;
block|}
name|Descriptor
struct|;
name|char
name|Module_Name
index|[
literal|256
index|]
decl_stmt|;
name|char
name|Now
index|[
literal|17
index|]
decl_stmt|;
comment|/* 	 *	We are writing a module header record 	 */
name|Set_VMS_Object_File_Record
argument_list|(
name|OBJ$C_HDR
argument_list|)
expr_stmt|;
comment|/* 	 *	*************************** 	 *	*MAIN MODULE HEADER RECORD* 	 *	*************************** 	 * 	 *	Store record type and header type 	 */
name|PUT_CHAR
argument_list|(
name|OBJ$C_HDR
argument_list|)
expr_stmt|;
name|PUT_CHAR
argument_list|(
name|MHD$C_MHD
argument_list|)
expr_stmt|;
comment|/* 	 *	Structure level is 0 	 */
name|PUT_CHAR
argument_list|(
name|OBJ$C_STRLVL
argument_list|)
expr_stmt|;
comment|/* 	 *	Maximum record size is size of the object record buffer 	 */
name|PUT_SHORT
argument_list|(
sizeof|sizeof
argument_list|(
name|Object_Record_Buffer
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 *	Get module name (the FILENAME part of the object file) 	 */
name|cp
operator|=
name|out_file_name
expr_stmt|;
name|cp1
operator|=
name|Module_Name
expr_stmt|;
while|while
condition|(
operator|*
name|cp
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|cp
operator|==
literal|']'
operator|)
operator|||
operator|(
operator|*
name|cp
operator|==
literal|'>'
operator|)
operator|||
operator|(
operator|*
name|cp
operator|==
literal|':'
operator|)
operator|||
operator|(
operator|*
name|cp
operator|==
literal|'/'
operator|)
condition|)
block|{
name|cp1
operator|=
name|Module_Name
expr_stmt|;
name|cp
operator|++
expr_stmt|;
continue|continue;
block|}
operator|*
name|cp1
operator|++
operator|=
name|islower
argument_list|(
operator|*
name|cp
argument_list|)
condition|?
name|toupper
argument_list|(
operator|*
name|cp
operator|++
argument_list|)
else|:
operator|*
name|cp
operator|++
expr_stmt|;
block|}
operator|*
name|cp1
operator|=
literal|0
expr_stmt|;
comment|/* 	 *	Limit it to 31 characters and store in the object record 	 */
while|while
condition|(
operator|--
name|cp1
operator|>=
name|Module_Name
condition|)
if|if
condition|(
operator|*
name|cp1
operator|==
literal|'.'
condition|)
operator|*
name|cp1
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|Module_Name
argument_list|)
operator|>
literal|31
condition|)
block|{
if|if
condition|(
name|flagseen
index|[
literal|'+'
index|]
condition|)
name|printf
argument_list|(
literal|"%s: Module name truncated: %s\n"
argument_list|,
name|myname
argument_list|,
name|Module_Name
argument_list|)
expr_stmt|;
name|Module_Name
index|[
literal|31
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|PUT_COUNTED_STRING
argument_list|(
name|Module_Name
argument_list|)
expr_stmt|;
comment|/* 	 *	Module Version is "V1.0" 	 */
name|PUT_COUNTED_STRING
argument_list|(
literal|"V1.0"
argument_list|)
expr_stmt|;
comment|/* 	 *	Creation time is "now" (17 chars of time string) 	 */
name|Descriptor
operator|.
name|Size
operator|=
literal|17
expr_stmt|;
name|Descriptor
operator|.
name|Ptr
operator|=
name|Now
expr_stmt|;
name|sys$asctim
argument_list|(
literal|0
argument_list|,
operator|&
name|Descriptor
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|17
condition|;
name|i
operator|++
control|)
name|PUT_CHAR
argument_list|(
name|Now
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* 	 *	Patch time is "never" (17 zeros) 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|17
condition|;
name|i
operator|++
control|)
name|PUT_CHAR
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 *	Flush the record 	 */
name|Flush_VMS_Object_Record_Buffer
argument_list|()
expr_stmt|;
comment|/* 	 *	************************* 	 *	*LANGUAGE PROCESSOR NAME* 	 *	************************* 	 * 	 *	Store record type and header type 	 */
name|PUT_CHAR
argument_list|(
name|OBJ$C_HDR
argument_list|)
expr_stmt|;
name|PUT_CHAR
argument_list|(
name|MHD$C_LNM
argument_list|)
expr_stmt|;
comment|/* 	 *	Store language processor name and version 	 *	(not a counted string!) 	 */
name|cp
operator|=
name|compiler_version_string
expr_stmt|;
if|if
condition|(
name|cp
operator|==
literal|0
condition|)
block|{
name|cp
operator|=
literal|"GNU AS  V"
expr_stmt|;
while|while
condition|(
operator|*
name|cp
condition|)
name|PUT_CHAR
argument_list|(
operator|*
name|cp
operator|++
argument_list|)
expr_stmt|;
name|cp
operator|=
name|strchr
argument_list|(
operator|&
name|version_string
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|cp
operator|!=
literal|' '
condition|)
name|cp
operator|--
expr_stmt|;
name|cp
operator|++
expr_stmt|;
block|}
empty_stmt|;
while|while
condition|(
operator|*
name|cp
operator|>=
literal|32
condition|)
name|PUT_CHAR
argument_list|(
operator|*
name|cp
operator|++
argument_list|)
expr_stmt|;
comment|/* 	 *	Flush the record 	 */
name|Flush_VMS_Object_Record_Buffer
argument_list|()
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  *	Write the EOM (End Of Module) record  */
end_comment

begin_macro
name|Write_VMS_EOM_Record
argument_list|(
argument|Psect
argument_list|,
argument|Offset
argument_list|)
end_macro

begin_decl_stmt
name|int
name|Psect
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|Offset
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* 	 *	We are writing an end-of-module record 	 */
name|Set_VMS_Object_File_Record
argument_list|(
name|OBJ$C_EOM
argument_list|)
expr_stmt|;
comment|/* 	 *	Store record Type 	 */
name|PUT_CHAR
argument_list|(
name|OBJ$C_EOM
argument_list|)
expr_stmt|;
comment|/* 	 *	Store the error severity (0) 	 */
name|PUT_CHAR
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 *	Store the entry point, if it exists 	 */
if|if
condition|(
name|Psect
operator|>=
literal|0
condition|)
block|{
comment|/* 		 *	Store the entry point Psect 		 */
name|PUT_CHAR
argument_list|(
name|Psect
argument_list|)
expr_stmt|;
comment|/* 		 *	Store the entry point Psect offset 		 */
name|PUT_LONG
argument_list|(
name|Offset
argument_list|)
expr_stmt|;
block|}
comment|/* 	 *	Flush the record 	 */
name|Flush_VMS_Object_Record_Buffer
argument_list|()
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* this hash routine borrowed from GNU-EMACS, and strengthened slightly  ERY*/
end_comment

begin_function
specifier|static
name|int
name|hash_string
parameter_list|(
name|ptr
parameter_list|)
name|unsigned
name|char
modifier|*
name|ptr
decl_stmt|;
block|{
specifier|register
name|unsigned
name|char
modifier|*
name|p
init|=
name|ptr
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|end
init|=
name|p
operator|+
name|strlen
argument_list|(
name|ptr
argument_list|)
decl_stmt|;
specifier|register
name|unsigned
name|char
name|c
decl_stmt|;
specifier|register
name|int
name|hash
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|p
operator|!=
name|end
condition|)
block|{
name|c
operator|=
operator|*
name|p
operator|++
expr_stmt|;
name|hash
operator|=
operator|(
operator|(
name|hash
operator|<<
literal|3
operator|)
operator|+
operator|(
name|hash
operator|<<
literal|15
operator|)
operator|+
operator|(
name|hash
operator|>>
literal|28
operator|)
operator|+
name|c
operator|)
expr_stmt|;
block|}
return|return
name|hash
return|;
block|}
end_function

begin_comment
comment|/*  *	Generate a Case-Hacked VMS symbol name (limited to 31 chars)  */
end_comment

begin_expr_stmt
name|VMS_Case_Hack_Symbol
argument_list|(
name|In
argument_list|,
name|Out
argument_list|)
specifier|register
name|char
operator|*
name|In
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|char
modifier|*
name|Out
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|long
name|int
name|init
init|=
literal|0
decl_stmt|;
name|long
name|int
name|result
decl_stmt|;
name|char
modifier|*
name|pnt
decl_stmt|;
name|char
modifier|*
name|new_name
decl_stmt|;
name|char
modifier|*
name|old_name
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|destructor
init|=
literal|0
decl_stmt|;
comment|/*hack to allow for case sens in a destructor*/
name|int
name|truncate
init|=
literal|0
decl_stmt|;
name|int
name|Case_Hack_Bits
init|=
literal|0
decl_stmt|;
name|int
name|Saw_Dollar
init|=
literal|0
decl_stmt|;
specifier|static
name|char
name|Hex_Table
index|[
literal|16
index|]
init|=
block|{
literal|'0'
block|,
literal|'1'
block|,
literal|'2'
block|,
literal|'3'
block|,
literal|'4'
block|,
literal|'5'
block|,
literal|'6'
block|,
literal|'7'
block|,
literal|'8'
block|,
literal|'9'
block|,
literal|'A'
block|,
literal|'B'
block|,
literal|'C'
block|,
literal|'D'
block|,
literal|'E'
block|,
literal|'F'
block|}
decl_stmt|;
comment|/* 	 *	Kill any leading "_" 	 */
if|if
condition|(
operator|*
name|In
operator|==
literal|'_'
condition|)
name|In
operator|++
expr_stmt|;
name|new_name
operator|=
name|Out
expr_stmt|;
comment|/* save this for later*/
if|if
condition|(
operator|(
name|In
index|[
literal|0
index|]
operator|==
literal|'_'
operator|)
operator|&&
operator|(
name|In
index|[
literal|1
index|]
operator|==
literal|'$'
operator|)
operator|&&
operator|(
name|In
index|[
literal|2
index|]
operator|==
literal|'_'
operator|)
condition|)
name|destructor
operator|=
literal|1
expr_stmt|;
comment|/* We may need to truncate the symbol, save the hash for later*/
if|if
condition|(
name|strlen
argument_list|(
name|In
argument_list|)
operator|>
literal|23
condition|)
name|result
operator|=
name|hash_string
argument_list|(
name|In
argument_list|)
expr_stmt|;
comment|/* 	 *	Is there a Psect Attribute to skip?? 	 */
if|if
condition|(
name|HAS_PSECT_ATTRIBUTES
argument_list|(
name|In
argument_list|)
condition|)
block|{
comment|/* 		 *	Yes: Skip it 		 */
name|In
operator|+=
name|PSECT_ATTRIBUTES_STRING_LENGTH
expr_stmt|;
while|while
condition|(
operator|*
name|In
condition|)
block|{
if|if
condition|(
operator|(
name|In
index|[
literal|0
index|]
operator|==
literal|'$'
operator|)
operator|&&
operator|(
name|In
index|[
literal|1
index|]
operator|==
literal|'$'
operator|)
condition|)
block|{
name|In
operator|+=
literal|2
expr_stmt|;
break|break;
block|}
name|In
operator|++
expr_stmt|;
block|}
block|}
name|old_name
operator|=
name|In
expr_stmt|;
comment|/*	if(strlen(In)> 31&& flagseen['+']) 		printf("%s: Symbol name truncated: %s\n",myname,In);*/
comment|/* 	 *	Do the case conversion 	 */
name|i
operator|=
literal|23
expr_stmt|;
comment|/* Maximum of 23 chars */
while|while
condition|(
operator|*
name|In
operator|&&
operator|(
operator|--
name|i
operator|>=
literal|0
operator|)
condition|)
block|{
name|Case_Hack_Bits
operator|<<=
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|In
operator|==
literal|'$'
condition|)
name|Saw_Dollar
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|destructor
operator|==
literal|1
operator|)
operator|&&
operator|(
name|i
operator|==
literal|21
operator|)
condition|)
name|Saw_Dollar
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|isupper
argument_list|(
operator|*
name|In
argument_list|)
condition|)
block|{
operator|*
name|Out
operator|++
operator|=
operator|*
name|In
operator|++
expr_stmt|;
name|Case_Hack_Bits
operator||=
literal|1
expr_stmt|;
block|}
else|else
block|{
operator|*
name|Out
operator|++
operator|=
name|islower
argument_list|(
operator|*
name|In
argument_list|)
condition|?
name|toupper
argument_list|(
operator|*
name|In
operator|++
argument_list|)
else|:
operator|*
name|In
operator|++
expr_stmt|;
block|}
block|}
comment|/* 	 *	If we saw a dollar sign, we don't do case hacking 	 */
if|if
condition|(
name|flagseen
index|[
literal|'h'
index|]
operator|||
name|Saw_Dollar
condition|)
name|Case_Hack_Bits
operator|=
literal|0
expr_stmt|;
comment|/* 	 *	If we have more than 23 characters and everything is lowercase 	 *	we can insert the full 31 characters 	 */
if|if
condition|(
operator|*
name|In
condition|)
block|{
comment|/* 		 *	We  have more than 23 characters 		 * If we must add the case hack, then we have truncated the str 		 */
name|pnt
operator|=
name|Out
expr_stmt|;
name|truncate
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|Case_Hack_Bits
operator|==
literal|0
condition|)
block|{
comment|/* 			 *	And so far they are all lower case: 			 *		Check up to 8 more characters 			 *		and ensure that they are lowercase 			 */
if|if
condition|(
name|flagseen
index|[
literal|'h'
index|]
condition|)
name|i
operator|=
literal|8
expr_stmt|;
else|else
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|In
index|[
name|i
index|]
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|i
operator|<
literal|8
operator|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|isupper
argument_list|(
name|In
index|[
name|i
index|]
argument_list|)
operator|&&
operator|!
name|Saw_Dollar
condition|)
break|break;
if|if
condition|(
name|In
index|[
name|i
index|]
operator|==
literal|0
condition|)
name|truncate
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|>=
literal|8
operator|)
operator|||
operator|(
name|In
index|[
name|i
index|]
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* 				 *	They are:  Copy up to 31 characters 				 *			to the output string 				 */
name|i
operator|=
literal|8
expr_stmt|;
while|while
condition|(
operator|(
operator|--
name|i
operator|>=
literal|0
operator|)
operator|&&
operator|(
operator|*
name|In
operator|)
condition|)
operator|*
name|Out
operator|++
operator|=
name|islower
argument_list|(
operator|*
name|In
argument_list|)
condition|?
name|toupper
argument_list|(
operator|*
name|In
operator|++
argument_list|)
else|:
operator|*
name|In
operator|++
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 *	If there were any uppercase characters in the name we 	 *	take on the case hacking string 	 */
comment|/* Old behavior for regular GNU-C compiler */
if|if
condition|(
operator|!
name|flagseen
index|[
literal|'+'
index|]
condition|)
name|truncate
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|Case_Hack_Bits
operator|!=
literal|0
operator|)
operator|||
operator|(
name|truncate
operator|==
literal|1
operator|)
condition|)
block|{
if|if
condition|(
name|truncate
operator|==
literal|0
condition|)
block|{
operator|*
name|Out
operator|++
operator|=
literal|'_'
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|6
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|Out
operator|++
operator|=
name|Hex_Table
index|[
name|Case_Hack_Bits
operator|&
literal|0xf
index|]
expr_stmt|;
name|Case_Hack_Bits
operator|>>=
literal|4
expr_stmt|;
block|}
operator|*
name|Out
operator|++
operator|=
literal|'X'
expr_stmt|;
block|}
else|else
block|{
name|Out
operator|=
name|pnt
expr_stmt|;
comment|/*Cut back to 23 characters maximum */
operator|*
name|Out
operator|++
operator|=
literal|'_'
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|7
condition|;
name|i
operator|++
control|)
block|{
name|init
operator|=
name|result
operator|&
literal|0x01f
expr_stmt|;
if|if
condition|(
name|init
operator|<
literal|10
condition|)
operator|*
name|Out
operator|++
operator|=
literal|'0'
operator|+
name|init
expr_stmt|;
else|else
operator|*
name|Out
operator|++
operator|=
literal|'A'
operator|+
name|init
operator|-
literal|10
expr_stmt|;
name|result
operator|=
name|result
operator|>>
literal|5
expr_stmt|;
block|}
block|}
block|}
comment|/*Case Hack */
comment|/* 	 *	Done 	 */
operator|*
name|Out
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|truncate
operator|==
literal|1
operator|&&
name|flagseen
index|[
literal|'+'
index|]
operator|&&
name|flagseen
index|[
literal|'H'
index|]
condition|)
name|printf
argument_list|(
literal|"%s: Symbol %s replaced by %s\n"
argument_list|,
name|myname
argument_list|,
name|old_name
argument_list|,
name|new_name
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  *	Scan a symbol name for a psect attribute specification  */
end_comment

begin_macro
name|VMS_Modify_Psect_Attributes
argument_list|(
argument|Name
argument_list|,
argument|Attribute_Pointer
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|Name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|Attribute_Pointer
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|Negate
decl_stmt|;
specifier|static
struct|struct
block|{
name|char
modifier|*
name|Name
decl_stmt|;
name|int
name|Value
decl_stmt|;
block|}
name|Attributes
index|[]
init|=
block|{
block|{
literal|"PIC"
block|,
name|GPS$M_PIC
block|}
block|,
block|{
literal|"LIB"
block|,
name|GPS$M_LIB
block|}
block|,
block|{
literal|"OVR"
block|,
name|GPS$M_OVR
block|}
block|,
block|{
literal|"REL"
block|,
name|GPS$M_REL
block|}
block|,
block|{
literal|"GBL"
block|,
name|GPS$M_GBL
block|}
block|,
block|{
literal|"SHR"
block|,
name|GPS$M_SHR
block|}
block|,
block|{
literal|"EXE"
block|,
name|GPS$M_EXE
block|}
block|,
block|{
literal|"RD"
block|,
name|GPS$M_RD
block|}
block|,
block|{
literal|"WRT"
block|,
name|GPS$M_WRT
block|}
block|,
block|{
literal|"VEC"
block|,
name|GPS$M_VEC
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
struct|;
comment|/* 	 *	Kill leading "_" 	 */
if|if
condition|(
operator|*
name|Name
operator|==
literal|'_'
condition|)
name|Name
operator|++
expr_stmt|;
comment|/* 	 *	Check for a PSECT attribute list 	 */
if|if
condition|(
operator|!
name|HAS_PSECT_ATTRIBUTES
argument_list|(
name|Name
argument_list|)
condition|)
return|return;
comment|/* If not, return */
comment|/* 	 *	Skip the attribute list indicator 	 */
name|Name
operator|+=
name|PSECT_ATTRIBUTES_STRING_LENGTH
expr_stmt|;
comment|/* 	 *	Process the attributes ("_" separated, "$" terminated) 	 */
while|while
condition|(
operator|*
name|Name
operator|!=
literal|'$'
condition|)
block|{
comment|/* 		 *	Assume not negating 		 */
name|Negate
operator|=
literal|0
expr_stmt|;
comment|/* 		 *	Check for "NO" 		 */
if|if
condition|(
operator|(
name|Name
index|[
literal|0
index|]
operator|==
literal|'N'
operator|)
operator|&&
operator|(
name|Name
index|[
literal|1
index|]
operator|==
literal|'O'
operator|)
condition|)
block|{
comment|/* 			 *	We are negating (and skip the NO) 			 */
name|Negate
operator|=
literal|1
expr_stmt|;
name|Name
operator|+=
literal|2
expr_stmt|;
block|}
comment|/* 		 *	Find the token delimiter 		 */
name|cp
operator|=
name|Name
expr_stmt|;
while|while
condition|(
operator|*
name|cp
operator|&&
operator|(
operator|*
name|cp
operator|!=
literal|'_'
operator|)
operator|&&
operator|(
operator|*
name|cp
operator|!=
literal|'$'
operator|)
condition|)
name|cp
operator|++
expr_stmt|;
comment|/* 		 *	Look for the token in the attribute list 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|Attributes
index|[
name|i
index|]
operator|.
name|Name
condition|;
name|i
operator|++
control|)
block|{
comment|/* 			 *	If the strings match, set/clear the attr. 			 */
if|if
condition|(
name|strncmp
argument_list|(
name|Name
argument_list|,
name|Attributes
index|[
name|i
index|]
operator|.
name|Name
argument_list|,
name|cp
operator|-
name|Name
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 				 *	Set or clear 				 */
if|if
condition|(
name|Negate
condition|)
operator|*
name|Attribute_Pointer
operator|&=
operator|~
name|Attributes
index|[
name|i
index|]
operator|.
name|Value
expr_stmt|;
else|else
operator|*
name|Attribute_Pointer
operator||=
name|Attributes
index|[
name|i
index|]
operator|.
name|Value
expr_stmt|;
comment|/* 				 *	Done 				 */
break|break;
block|}
block|}
comment|/* 		 *	Now skip the attribute 		 */
name|Name
operator|=
name|cp
expr_stmt|;
if|if
condition|(
operator|*
name|Name
operator|==
literal|'_'
condition|)
name|Name
operator|++
expr_stmt|;
block|}
comment|/* 	 *	Done 	 */
return|return;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  *	Define a psect  */
end_comment

begin_macro
name|VMS_Psect_Spec
argument_list|(
argument|Name
argument_list|,
argument|Size
argument_list|,
argument|Type
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|Name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|Size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|Type
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|Local
index|[
literal|32
index|]
decl_stmt|;
name|int
name|Psect_Attributes
decl_stmt|;
comment|/* 	 *	We are writing a GSD record 	 */
name|Set_VMS_Object_File_Record
argument_list|(
name|OBJ$C_GSD
argument_list|)
expr_stmt|;
comment|/* 	 *	If the buffer is empty we must insert the GSD record type 	 */
if|if
condition|(
name|Object_Record_Offset
operator|==
literal|0
condition|)
name|PUT_CHAR
argument_list|(
name|OBJ$C_GSD
argument_list|)
expr_stmt|;
comment|/* 	 *	We are writing a PSECT definition subrecord 	 */
name|PUT_CHAR
argument_list|(
name|GSD$C_PSC
argument_list|)
expr_stmt|;
comment|/* 	 *	Psects are always LONGWORD aligned 	 */
name|PUT_CHAR
argument_list|(
literal|2
argument_list|)
expr_stmt|;
comment|/* 	 *	Generate the appropriate PSECT flags given the PSECT type 	 */
if|if
condition|(
name|strcmp
argument_list|(
name|Type
argument_list|,
literal|"COMMON"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 *	Common block psects are:  PIC,OVR,REL,GBL,SHR,RD,WRT 		 */
name|Psect_Attributes
operator|=
operator|(
name|GPS$M_PIC
operator||
name|GPS$M_OVR
operator||
name|GPS$M_REL
operator||
name|GPS$M_GBL
operator||
name|GPS$M_SHR
operator||
name|GPS$M_RD
operator||
name|GPS$M_WRT
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|Type
argument_list|,
literal|"CONST"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 *	Common block psects are:  PIC,OVR,REL,GBL,SHR,RD 		 */
name|Psect_Attributes
operator|=
operator|(
name|GPS$M_PIC
operator||
name|GPS$M_OVR
operator||
name|GPS$M_REL
operator||
name|GPS$M_GBL
operator||
name|GPS$M_SHR
operator||
name|GPS$M_RD
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|Type
argument_list|,
literal|"DATA"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 *	The Data psects are PIC,REL,RD,WRT 		 */
name|Psect_Attributes
operator|=
operator|(
name|GPS$M_PIC
operator||
name|GPS$M_REL
operator||
name|GPS$M_RD
operator||
name|GPS$M_WRT
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|Type
argument_list|,
literal|"TEXT"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 *	The Text psects are PIC,REL,SHR,EXE,RD 		 */
name|Psect_Attributes
operator|=
operator|(
name|GPS$M_PIC
operator||
name|GPS$M_REL
operator||
name|GPS$M_SHR
operator||
name|GPS$M_EXE
operator||
name|GPS$M_RD
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 *	Error: Unknown psect type 		 */
name|error
argument_list|(
literal|"Unknown VMS psect type"
argument_list|)
expr_stmt|;
block|}
comment|/* 	 *	Modify the psect attributes according to any attribute string 	 */
if|if
condition|(
name|HAS_PSECT_ATTRIBUTES
argument_list|(
name|Name
argument_list|)
condition|)
name|VMS_Modify_Psect_Attributes
argument_list|(
name|Name
argument_list|,
operator|&
name|Psect_Attributes
argument_list|)
expr_stmt|;
comment|/* 	 *	Specify the psect attributes 	 */
name|PUT_SHORT
argument_list|(
name|Psect_Attributes
argument_list|)
expr_stmt|;
comment|/* 	 *	Specify the allocation 	 */
name|PUT_LONG
argument_list|(
name|Size
argument_list|)
expr_stmt|;
comment|/* 	 *	Finally, the psect name 	 */
name|VMS_Case_Hack_Symbol
argument_list|(
name|Name
argument_list|,
name|Local
argument_list|)
expr_stmt|;
name|PUT_COUNTED_STRING
argument_list|(
name|Local
argument_list|)
expr_stmt|;
comment|/* 	 *	Flush the buffer if it is more than 75% full 	 */
if|if
condition|(
name|Object_Record_Offset
operator|>
operator|(
sizeof|sizeof
argument_list|(
name|Object_Record_Buffer
argument_list|)
operator|*
literal|3
operator|/
literal|4
operator|)
condition|)
name|Flush_VMS_Object_Record_Buffer
argument_list|()
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  *	Define a global symbol  */
end_comment

begin_macro
name|VMS_Global_Symbol_Spec
argument_list|(
argument|Name
argument_list|,
argument|Psect_Number
argument_list|,
argument|Psect_Offset
argument_list|,
argument|Defined
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|Name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|Psect_Number
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|Psect_Offset
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|Local
index|[
literal|32
index|]
decl_stmt|;
comment|/* 	 *	We are writing a GSD record 	 */
name|Set_VMS_Object_File_Record
argument_list|(
name|OBJ$C_GSD
argument_list|)
expr_stmt|;
comment|/* 	 *	If the buffer is empty we must insert the GSD record type 	 */
if|if
condition|(
name|Object_Record_Offset
operator|==
literal|0
condition|)
name|PUT_CHAR
argument_list|(
name|OBJ$C_GSD
argument_list|)
expr_stmt|;
comment|/* 	 *	We are writing a Global symbol definition subrecord 	 */
if|if
condition|(
name|Psect_Number
operator|<=
literal|255
condition|)
block|{
name|PUT_CHAR
argument_list|(
name|GSD$C_SYM
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|PUT_CHAR
argument_list|(
name|GSD$C_SYMW
argument_list|)
expr_stmt|;
block|}
comment|/* 	 *	Data type is undefined 	 */
name|PUT_CHAR
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 *	Switch on Definition/Reference 	 */
if|if
condition|(
name|Defined
condition|)
block|{
comment|/* 		 *	Definition: 		 *	Flags = "RELOCATABLE" and "DEFINED" 		 */
name|PUT_SHORT
argument_list|(
name|GSY$M_DEF
operator||
name|GSY$M_REL
argument_list|)
expr_stmt|;
comment|/* 		 *	Psect Number 		 */
if|if
condition|(
name|Psect_Number
operator|<=
literal|255
condition|)
block|{
name|PUT_CHAR
argument_list|(
name|Psect_Number
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|PUT_SHORT
argument_list|(
name|Psect_Number
argument_list|)
expr_stmt|;
block|}
comment|/* 		 *	Offset 		 */
name|PUT_LONG
argument_list|(
name|Psect_Offset
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 *	Reference: 		 *	Flags = "RELOCATABLE" 		 */
name|PUT_SHORT
argument_list|(
name|GSY$M_REL
argument_list|)
expr_stmt|;
block|}
comment|/* 	 *	Finally, the global symbol name 	 */
name|VMS_Case_Hack_Symbol
argument_list|(
name|Name
argument_list|,
name|Local
argument_list|)
expr_stmt|;
name|PUT_COUNTED_STRING
argument_list|(
name|Local
argument_list|)
expr_stmt|;
comment|/* 	 *	Flush the buffer if it is more than 75% full 	 */
if|if
condition|(
name|Object_Record_Offset
operator|>
operator|(
sizeof|sizeof
argument_list|(
name|Object_Record_Buffer
argument_list|)
operator|*
literal|3
operator|/
literal|4
operator|)
condition|)
name|Flush_VMS_Object_Record_Buffer
argument_list|()
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  *	Define a procedure entry pt/mask  */
end_comment

begin_macro
name|VMS_Procedure_Entry_Pt
argument_list|(
argument|Name
argument_list|,
argument|Psect_Number
argument_list|,
argument|Psect_Offset
argument_list|,
argument|Entry_Mask
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|Name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|Psect_Number
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|Psect_Offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|Entry_Mask
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|Local
index|[
literal|32
index|]
decl_stmt|;
comment|/* 	 *	We are writing a GSD record 	 */
name|Set_VMS_Object_File_Record
argument_list|(
name|OBJ$C_GSD
argument_list|)
expr_stmt|;
comment|/* 	 *	If the buffer is empty we must insert the GSD record type 	 */
if|if
condition|(
name|Object_Record_Offset
operator|==
literal|0
condition|)
name|PUT_CHAR
argument_list|(
name|OBJ$C_GSD
argument_list|)
expr_stmt|;
comment|/* 	 *	We are writing a Procedure Entry Pt/Mask subrecord 	 */
if|if
condition|(
name|Psect_Number
operator|<=
literal|255
condition|)
block|{
name|PUT_CHAR
argument_list|(
name|GSD$C_EPM
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|PUT_CHAR
argument_list|(
name|GSD$C_EPMW
argument_list|)
expr_stmt|;
block|}
comment|/* 	 *	Data type is undefined 	 */
name|PUT_CHAR
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 *	Flags = "RELOCATABLE" and "DEFINED" 	 */
name|PUT_SHORT
argument_list|(
name|GSY$M_DEF
operator||
name|GSY$M_REL
argument_list|)
expr_stmt|;
comment|/* 	 *	Psect Number 	 */
if|if
condition|(
name|Psect_Number
operator|<=
literal|255
condition|)
block|{
name|PUT_CHAR
argument_list|(
name|Psect_Number
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|PUT_SHORT
argument_list|(
name|Psect_Number
argument_list|)
expr_stmt|;
block|}
comment|/* 	 *	Offset 	 */
name|PUT_LONG
argument_list|(
name|Psect_Offset
argument_list|)
expr_stmt|;
comment|/* 	 *	Entry mask 	 */
name|PUT_SHORT
argument_list|(
name|Entry_Mask
argument_list|)
expr_stmt|;
comment|/* 	 *	Finally, the global symbol name 	 */
name|VMS_Case_Hack_Symbol
argument_list|(
name|Name
argument_list|,
name|Local
argument_list|)
expr_stmt|;
name|PUT_COUNTED_STRING
argument_list|(
name|Local
argument_list|)
expr_stmt|;
comment|/* 	 *	Flush the buffer if it is more than 75% full 	 */
if|if
condition|(
name|Object_Record_Offset
operator|>
operator|(
sizeof|sizeof
argument_list|(
name|Object_Record_Buffer
argument_list|)
operator|*
literal|3
operator|/
literal|4
operator|)
condition|)
name|Flush_VMS_Object_Record_Buffer
argument_list|()
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  *	Set the current location counter to a particular Psect and Offset  */
end_comment

begin_macro
name|VMS_Set_Psect
argument_list|(
argument|Psect_Index
argument_list|,
argument|Offset
argument_list|,
argument|Record_Type
argument_list|)
end_macro

begin_decl_stmt
name|int
name|Psect_Index
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|Offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|Record_Type
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* 	 *	We are writing a "Record_Type" record 	 */
name|Set_VMS_Object_File_Record
argument_list|(
name|Record_Type
argument_list|)
expr_stmt|;
comment|/* 	 *	If the buffer is empty we must insert the record type 	 */
if|if
condition|(
name|Object_Record_Offset
operator|==
literal|0
condition|)
name|PUT_CHAR
argument_list|(
name|Record_Type
argument_list|)
expr_stmt|;
comment|/* 	 *	Stack the Psect base + Longword Offset 	 */
if|if
condition|(
name|Psect_Index
operator|<
literal|255
condition|)
block|{
name|PUT_CHAR
argument_list|(
name|TIR$C_STA_PL
argument_list|)
expr_stmt|;
name|PUT_CHAR
argument_list|(
name|Psect_Index
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|PUT_CHAR
argument_list|(
name|TIR$C_STA_WPL
argument_list|)
expr_stmt|;
name|PUT_SHORT
argument_list|(
name|Psect_Index
argument_list|)
expr_stmt|;
block|}
name|PUT_LONG
argument_list|(
name|Offset
argument_list|)
expr_stmt|;
comment|/* 	 *	Set relocation base 	 */
name|PUT_CHAR
argument_list|(
name|TIR$C_CTL_SETRB
argument_list|)
expr_stmt|;
comment|/* 	 *	Flush the buffer if it is more than 75% full 	 */
if|if
condition|(
name|Object_Record_Offset
operator|>
operator|(
sizeof|sizeof
argument_list|(
name|Object_Record_Buffer
argument_list|)
operator|*
literal|3
operator|/
literal|4
operator|)
condition|)
name|Flush_VMS_Object_Record_Buffer
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  *	Make a data reference  */
end_comment

begin_macro
name|VMS_Set_Data
argument_list|(
argument|Psect_Index
argument_list|,
argument|Offset
argument_list|,
argument|Record_Type
argument_list|,
argument|Force
argument_list|)
end_macro

begin_decl_stmt
name|int
name|Psect_Index
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|Offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|Record_Type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|Force
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* 	 *	We are writing a "Record_Type" record 	 */
name|Set_VMS_Object_File_Record
argument_list|(
name|Record_Type
argument_list|)
expr_stmt|;
comment|/* 	 *	If the buffer is empty we must insert the record type 	 */
if|if
condition|(
name|Object_Record_Offset
operator|==
literal|0
condition|)
name|PUT_CHAR
argument_list|(
name|Record_Type
argument_list|)
expr_stmt|;
comment|/* 	 *	Stack the Psect base + Longword Offset 	 */
if|if
condition|(
name|Force
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|Psect_Index
operator|>
literal|127
condition|)
block|{
name|PUT_CHAR
argument_list|(
name|TIR$C_STA_WPL
argument_list|)
expr_stmt|;
name|PUT_SHORT
argument_list|(
name|Psect_Index
argument_list|)
expr_stmt|;
name|PUT_LONG
argument_list|(
name|Offset
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|PUT_CHAR
argument_list|(
name|TIR$C_STA_PL
argument_list|)
expr_stmt|;
name|PUT_CHAR
argument_list|(
name|Psect_Index
argument_list|)
expr_stmt|;
name|PUT_LONG
argument_list|(
name|Offset
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|Offset
operator|>
literal|32767
condition|)
block|{
name|PUT_CHAR
argument_list|(
name|TIR$C_STA_WPL
argument_list|)
expr_stmt|;
name|PUT_SHORT
argument_list|(
name|Psect_Index
argument_list|)
expr_stmt|;
name|PUT_LONG
argument_list|(
name|Offset
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Offset
operator|>
literal|127
condition|)
block|{
name|PUT_CHAR
argument_list|(
name|TIR$C_STA_WPW
argument_list|)
expr_stmt|;
name|PUT_SHORT
argument_list|(
name|Psect_Index
argument_list|)
expr_stmt|;
name|PUT_SHORT
argument_list|(
name|Offset
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|PUT_CHAR
argument_list|(
name|TIR$C_STA_WPB
argument_list|)
expr_stmt|;
name|PUT_SHORT
argument_list|(
name|Psect_Index
argument_list|)
expr_stmt|;
name|PUT_CHAR
argument_list|(
name|Offset
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
block|}
empty_stmt|;
comment|/* 	 *	Set relocation base 	 */
name|PUT_CHAR
argument_list|(
name|TIR$C_STO_PIDR
argument_list|)
expr_stmt|;
comment|/* 	 *	Flush the buffer if it is more than 75% full 	 */
if|if
condition|(
name|Object_Record_Offset
operator|>
operator|(
sizeof|sizeof
argument_list|(
name|Object_Record_Buffer
argument_list|)
operator|*
literal|3
operator|/
literal|4
operator|)
condition|)
name|Flush_VMS_Object_Record_Buffer
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  *	Make a debugger reference to a struct, union or enum.  */
end_comment

begin_macro
name|VMS_Store_Struct
argument_list|(
argument|int Struct_Index
argument_list|)
end_macro

begin_block
block|{
comment|/* 	 *	We are writing a "OBJ$C_DBG" record 	 */
name|Set_VMS_Object_File_Record
argument_list|(
name|OBJ$C_DBG
argument_list|)
expr_stmt|;
comment|/* 	 *	If the buffer is empty we must insert the record type 	 */
if|if
condition|(
name|Object_Record_Offset
operator|==
literal|0
condition|)
name|PUT_CHAR
argument_list|(
name|OBJ$C_DBG
argument_list|)
expr_stmt|;
name|PUT_CHAR
argument_list|(
name|TIR$C_STA_UW
argument_list|)
expr_stmt|;
name|PUT_SHORT
argument_list|(
name|Struct_Index
argument_list|)
expr_stmt|;
name|PUT_CHAR
argument_list|(
name|TIR$C_CTL_STKDL
argument_list|)
expr_stmt|;
name|PUT_CHAR
argument_list|(
name|TIR$C_STO_L
argument_list|)
expr_stmt|;
comment|/* 	 *	Flush the buffer if it is more than 75% full 	 */
if|if
condition|(
name|Object_Record_Offset
operator|>
operator|(
sizeof|sizeof
argument_list|(
name|Object_Record_Buffer
argument_list|)
operator|*
literal|3
operator|/
literal|4
operator|)
condition|)
name|Flush_VMS_Object_Record_Buffer
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  *	Make a debugger reference to partially define a struct, union or enum.  */
end_comment

begin_macro
name|VMS_Def_Struct
argument_list|(
argument|int Struct_Index
argument_list|)
end_macro

begin_block
block|{
comment|/* 	 *	We are writing a "OBJ$C_DBG" record 	 */
name|Set_VMS_Object_File_Record
argument_list|(
name|OBJ$C_DBG
argument_list|)
expr_stmt|;
comment|/* 	 *	If the buffer is empty we must insert the record type 	 */
if|if
condition|(
name|Object_Record_Offset
operator|==
literal|0
condition|)
name|PUT_CHAR
argument_list|(
name|OBJ$C_DBG
argument_list|)
expr_stmt|;
name|PUT_CHAR
argument_list|(
name|TIR$C_STA_UW
argument_list|)
expr_stmt|;
name|PUT_SHORT
argument_list|(
name|Struct_Index
argument_list|)
expr_stmt|;
name|PUT_CHAR
argument_list|(
name|TIR$C_CTL_DFLOC
argument_list|)
expr_stmt|;
comment|/* 	 *	Flush the buffer if it is more than 75% full 	 */
if|if
condition|(
name|Object_Record_Offset
operator|>
operator|(
sizeof|sizeof
argument_list|(
name|Object_Record_Buffer
argument_list|)
operator|*
literal|3
operator|/
literal|4
operator|)
condition|)
name|Flush_VMS_Object_Record_Buffer
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|VMS_Set_Struct
argument_list|(
argument|int Struct_Index
argument_list|)
end_macro

begin_block
block|{
comment|/* see previous functions for comments */
name|Set_VMS_Object_File_Record
argument_list|(
name|OBJ$C_DBG
argument_list|)
expr_stmt|;
if|if
condition|(
name|Object_Record_Offset
operator|==
literal|0
condition|)
name|PUT_CHAR
argument_list|(
name|OBJ$C_DBG
argument_list|)
expr_stmt|;
name|PUT_CHAR
argument_list|(
name|TIR$C_STA_UW
argument_list|)
expr_stmt|;
name|PUT_SHORT
argument_list|(
name|Struct_Index
argument_list|)
expr_stmt|;
name|PUT_CHAR
argument_list|(
name|TIR$C_CTL_STLOC
argument_list|)
expr_stmt|;
if|if
condition|(
name|Object_Record_Offset
operator|>
operator|(
sizeof|sizeof
argument_list|(
name|Object_Record_Buffer
argument_list|)
operator|*
literal|3
operator|/
literal|4
operator|)
condition|)
name|Flush_VMS_Object_Record_Buffer
argument_list|()
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  *	Store immediate data in current Psect  */
end_comment

begin_expr_stmt
name|VMS_Store_Immediate_Data
argument_list|(
name|Pointer
argument_list|,
name|Size
argument_list|,
name|Record_Type
argument_list|)
specifier|register
name|char
operator|*
name|Pointer
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|Size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|Record_Type
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
comment|/* 	 *	We are writing a "Record_Type" record 	 */
name|Set_VMS_Object_File_Record
argument_list|(
name|Record_Type
argument_list|)
expr_stmt|;
comment|/* 	 *	We can only store 128 bytes at a time 	 */
while|while
condition|(
name|Size
operator|>
literal|0
condition|)
block|{
comment|/* 		 *	Store a maximum of 128 bytes 		 */
name|i
operator|=
operator|(
name|Size
operator|>
literal|128
operator|)
condition|?
literal|128
else|:
name|Size
expr_stmt|;
name|Size
operator|-=
name|i
expr_stmt|;
comment|/* 		 *	If we cannot accommodate this record, flush the 		 *	buffer. 		 */
if|if
condition|(
operator|(
name|Object_Record_Offset
operator|+
name|i
operator|+
literal|1
operator|)
operator|>=
sizeof|sizeof
argument_list|(
name|Object_Record_Buffer
argument_list|)
condition|)
name|Flush_VMS_Object_Record_Buffer
argument_list|()
expr_stmt|;
comment|/* 		 *	If the buffer is empty we must insert record type 		 */
if|if
condition|(
name|Object_Record_Offset
operator|==
literal|0
condition|)
name|PUT_CHAR
argument_list|(
name|Record_Type
argument_list|)
expr_stmt|;
comment|/* 		 *	Store the count 		 */
name|PUT_CHAR
argument_list|(
operator|-
name|i
operator|&
literal|0xff
argument_list|)
expr_stmt|;
comment|/* 		 *	Store the data 		 */
while|while
condition|(
operator|--
name|i
operator|>=
literal|0
condition|)
name|PUT_CHAR
argument_list|(
operator|*
name|Pointer
operator|++
argument_list|)
expr_stmt|;
comment|/* 		 *	Flush the buffer if it is more than 75% full 		 */
if|if
condition|(
name|Object_Record_Offset
operator|>
operator|(
sizeof|sizeof
argument_list|(
name|Object_Record_Buffer
argument_list|)
operator|*
literal|3
operator|/
literal|4
operator|)
condition|)
name|Flush_VMS_Object_Record_Buffer
argument_list|()
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  *	Store repeated immediate data in current Psect  */
end_comment

begin_macro
name|VMS_Store_Repeated_Data
argument_list|(
argument|Repeat_Count
argument_list|,
argument|Pointer
argument_list|,
argument|Size
argument_list|,
argument|Record_Type
argument_list|)
end_macro

begin_decl_stmt
name|int
name|Repeat_Count
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|char
modifier|*
name|Pointer
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|Size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|Record_Type
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* 	 *	Ignore zero bytes/words/longwords 	 */
if|if
condition|(
operator|(
name|Size
operator|==
sizeof|sizeof
argument_list|(
name|char
argument_list|)
operator|)
operator|&&
operator|(
operator|*
name|Pointer
operator|==
literal|0
operator|)
condition|)
return|return;
if|if
condition|(
operator|(
name|Size
operator|==
sizeof|sizeof
argument_list|(
name|short
argument_list|)
operator|)
operator|&&
operator|(
operator|*
operator|(
name|short
operator|*
operator|)
name|Pointer
operator|==
literal|0
operator|)
condition|)
return|return;
if|if
condition|(
operator|(
name|Size
operator|==
sizeof|sizeof
argument_list|(
name|long
argument_list|)
operator|)
operator|&&
operator|(
operator|*
operator|(
name|long
operator|*
operator|)
name|Pointer
operator|==
literal|0
operator|)
condition|)
return|return;
comment|/* 	 *	If the data is too big for a TIR$C_STO_RIVB sub-record 	 *	then we do it manually 	 */
if|if
condition|(
name|Size
operator|>
literal|255
condition|)
block|{
while|while
condition|(
operator|--
name|Repeat_Count
operator|>=
literal|0
condition|)
name|VMS_Store_Immediate_Data
argument_list|(
name|Pointer
argument_list|,
name|Size
argument_list|,
name|Record_Type
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 *	We are writing a "Record_Type" record 	 */
name|Set_VMS_Object_File_Record
argument_list|(
name|Record_Type
argument_list|)
expr_stmt|;
comment|/* 	 *	If the buffer is empty we must insert record type 	 */
if|if
condition|(
name|Object_Record_Offset
operator|==
literal|0
condition|)
name|PUT_CHAR
argument_list|(
name|Record_Type
argument_list|)
expr_stmt|;
comment|/* 	 *	Stack the repeat count 	 */
name|PUT_CHAR
argument_list|(
name|TIR$C_STA_LW
argument_list|)
expr_stmt|;
name|PUT_LONG
argument_list|(
name|Repeat_Count
argument_list|)
expr_stmt|;
comment|/* 	 *	And now the command and its data 	 */
name|PUT_CHAR
argument_list|(
name|TIR$C_STO_RIVB
argument_list|)
expr_stmt|;
name|PUT_CHAR
argument_list|(
name|Size
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|Size
operator|>=
literal|0
condition|)
name|PUT_CHAR
argument_list|(
operator|*
name|Pointer
operator|++
argument_list|)
expr_stmt|;
comment|/* 	 *	Flush the buffer if it is more than 75% full 	 */
if|if
condition|(
name|Object_Record_Offset
operator|>
operator|(
sizeof|sizeof
argument_list|(
name|Object_Record_Buffer
argument_list|)
operator|*
literal|3
operator|/
literal|4
operator|)
condition|)
name|Flush_VMS_Object_Record_Buffer
argument_list|()
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  *	Store a Position Independent Reference  */
end_comment

begin_macro
name|VMS_Store_PIC_Symbol_Reference
argument_list|(
argument|Symbol
argument_list|,
argument|Offset
argument_list|,
argument|PC_Relative
argument_list|,
argument|Psect
argument_list|,
argument|Psect_Offset
argument_list|,
argument|Record_Type
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|symbol
modifier|*
name|Symbol
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|Offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|PC_Relative
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|Psect
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|Psect_Offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|Record_Type
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|VMS_Symbol
modifier|*
name|vsp
init|=
operator|(
expr|struct
name|VMS_Symbol
operator|*
operator|)
operator|(
name|Symbol
operator|->
name|sy_number
operator|)
decl_stmt|;
name|char
name|Local
index|[
literal|32
index|]
decl_stmt|;
comment|/* 	 *	We are writing a "Record_Type" record 	 */
name|Set_VMS_Object_File_Record
argument_list|(
name|Record_Type
argument_list|)
expr_stmt|;
comment|/* 	 *	If the buffer is empty we must insert record type 	 */
if|if
condition|(
name|Object_Record_Offset
operator|==
literal|0
condition|)
name|PUT_CHAR
argument_list|(
name|Record_Type
argument_list|)
expr_stmt|;
comment|/* 	 *	Set to the appropriate offset in the Psect 	 */
if|if
condition|(
name|PC_Relative
condition|)
block|{
comment|/* 		 *	For a Code reference we need to fix the operand 		 *	specifier as well (so back up 1 byte) 		 */
name|VMS_Set_Psect
argument_list|(
name|Psect
argument_list|,
name|Psect_Offset
operator|-
literal|1
argument_list|,
name|Record_Type
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 *	For a Data reference we just store HERE 		 */
name|VMS_Set_Psect
argument_list|(
name|Psect
argument_list|,
name|Psect_Offset
argument_list|,
name|Record_Type
argument_list|)
expr_stmt|;
block|}
comment|/* 	 *	Make sure we are still generating a "Record Type" record 	 */
if|if
condition|(
name|Object_Record_Offset
operator|==
literal|0
condition|)
name|PUT_CHAR
argument_list|(
name|Record_Type
argument_list|)
expr_stmt|;
comment|/* 	 *	Dispatch on symbol type (so we can stack its value) 	 */
switch|switch
condition|(
name|Symbol
operator|->
name|sy_nlist
operator|.
name|n_type
condition|)
block|{
comment|/* 		 *	Global symbol 		 */
ifdef|#
directive|ifdef
name|NOT_VAX_11_C_COMPATIBLE
case|case
name|N_UNDF
operator||
name|N_EXT
case|:
case|case
name|N_DATA
operator||
name|N_EXT
case|:
endif|#
directive|endif
endif|NOT_VAX_11_C_COMPATIBLE
case|case
name|N_UNDF
case|:
case|case
name|N_TEXT
operator||
name|N_EXT
case|:
comment|/* 			 *	Get the symbol name (case hacked) 			 */
name|VMS_Case_Hack_Symbol
argument_list|(
name|Symbol
operator|->
name|sy_nlist
operator|.
name|n_un
operator|.
name|n_name
argument_list|,
name|Local
argument_list|)
expr_stmt|;
comment|/* 			 *	Stack the global symbol value 			 */
name|PUT_CHAR
argument_list|(
name|TIR$C_STA_GBL
argument_list|)
expr_stmt|;
name|PUT_COUNTED_STRING
argument_list|(
name|Local
argument_list|)
expr_stmt|;
if|if
condition|(
name|Offset
condition|)
block|{
comment|/* 				 *	Stack the longword offset 				 */
name|PUT_CHAR
argument_list|(
name|TIR$C_STA_LW
argument_list|)
expr_stmt|;
name|PUT_LONG
argument_list|(
name|Offset
argument_list|)
expr_stmt|;
comment|/* 				 *	Add the two, leaving the result on the stack 				 */
name|PUT_CHAR
argument_list|(
name|TIR$C_OPR_ADD
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* 		 *	Uninitialized local data 		 */
case|case
name|N_BSS
case|:
comment|/* 			 *	Stack the Psect (+offset) 			 */
if|if
condition|(
name|vsp
operator|->
name|Psect_Index
operator|<
literal|255
condition|)
block|{
name|PUT_CHAR
argument_list|(
name|TIR$C_STA_PL
argument_list|)
expr_stmt|;
name|PUT_CHAR
argument_list|(
name|vsp
operator|->
name|Psect_Index
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|PUT_CHAR
argument_list|(
name|TIR$C_STA_WPL
argument_list|)
expr_stmt|;
name|PUT_SHORT
argument_list|(
name|vsp
operator|->
name|Psect_Index
argument_list|)
expr_stmt|;
block|}
name|PUT_LONG
argument_list|(
name|vsp
operator|->
name|Psect_Offset
operator|+
name|Offset
argument_list|)
expr_stmt|;
break|break;
comment|/* 		 *	Local text 		 */
case|case
name|N_TEXT
case|:
comment|/* 			 *	Stack the Psect (+offset) 			 */
if|if
condition|(
name|vsp
operator|->
name|Psect_Index
operator|<
literal|255
condition|)
block|{
name|PUT_CHAR
argument_list|(
name|TIR$C_STA_PL
argument_list|)
expr_stmt|;
name|PUT_CHAR
argument_list|(
name|vsp
operator|->
name|Psect_Index
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|PUT_CHAR
argument_list|(
name|TIR$C_STA_WPL
argument_list|)
expr_stmt|;
name|PUT_SHORT
argument_list|(
name|vsp
operator|->
name|Psect_Index
argument_list|)
expr_stmt|;
block|}
name|PUT_LONG
argument_list|(
name|Symbol
operator|->
name|sy_nlist
operator|.
name|n_value
argument_list|)
expr_stmt|;
break|break;
comment|/* 		 *	Initialized local or global data 		 */
case|case
name|N_DATA
case|:
ifndef|#
directive|ifndef
name|NOT_VAX_11_C_COMPATIBLE
case|case
name|N_UNDF
operator||
name|N_EXT
case|:
case|case
name|N_DATA
operator||
name|N_EXT
case|:
endif|#
directive|endif
endif|NOT_VAX_11_C_COMPATIBLE
comment|/* 			 *	Stack the Psect (+offset) 			 */
if|if
condition|(
name|vsp
operator|->
name|Psect_Index
operator|<
literal|255
condition|)
block|{
name|PUT_CHAR
argument_list|(
name|TIR$C_STA_PL
argument_list|)
expr_stmt|;
name|PUT_CHAR
argument_list|(
name|vsp
operator|->
name|Psect_Index
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|PUT_CHAR
argument_list|(
name|TIR$C_STA_WPL
argument_list|)
expr_stmt|;
name|PUT_SHORT
argument_list|(
name|vsp
operator|->
name|Psect_Index
argument_list|)
expr_stmt|;
block|}
name|PUT_LONG
argument_list|(
name|vsp
operator|->
name|Psect_Offset
operator|+
name|Offset
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 	 *	Store either a code or data reference 	 */
name|PUT_CHAR
argument_list|(
name|PC_Relative
condition|?
name|TIR$C_STO_PICR
else|:
name|TIR$C_STO_PIDR
argument_list|)
expr_stmt|;
comment|/* 	 *	Flush the buffer if it is more than 75% full 	 */
if|if
condition|(
name|Object_Record_Offset
operator|>
operator|(
sizeof|sizeof
argument_list|(
name|Object_Record_Buffer
argument_list|)
operator|*
literal|3
operator|/
literal|4
operator|)
condition|)
name|Flush_VMS_Object_Record_Buffer
argument_list|()
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  *	Check in the text area for an indirect pc-relative reference  *	and fix it up with addressing mode 0xff [PC indirect]  *  *	THIS SHOULD BE REPLACED BY THE USE OF TIR$C_STO_PIRR IN THE  *	PIC CODE GENERATING FIXUP ROUTINE.  */
end_comment

begin_macro
name|VMS_Fix_Indirect_Reference
argument_list|(
argument|Text_Psect
argument_list|,
argument|Offset
argument_list|,
argument|fragP
argument_list|,
argument|text_frag_root
argument_list|)
end_macro

begin_decl_stmt
name|int
name|Text_Psect
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|Offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|fragS
modifier|*
name|fragP
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|frag
modifier|*
name|text_frag_root
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* 	 *	The addressing mode byte is 1 byte before the address 	 */
name|Offset
operator|--
expr_stmt|;
comment|/* 	 *	Is it in THIS frag?? 	 */
if|if
condition|(
operator|(
name|Offset
operator|<
name|fragP
operator|->
name|fr_address
operator|)
operator|||
operator|(
name|Offset
operator|>=
operator|(
name|fragP
operator|->
name|fr_address
operator|+
name|fragP
operator|->
name|fr_fix
operator|)
operator|)
condition|)
block|{
comment|/* 		 *	We need to search for the fragment containing this 		 *	Offset 		 */
for|for
control|(
name|fragP
operator|=
name|text_frag_root
init|;
name|fragP
condition|;
name|fragP
operator|=
name|fragP
operator|->
name|fr_next
control|)
block|{
if|if
condition|(
operator|(
name|Offset
operator|>=
name|fragP
operator|->
name|fr_address
operator|)
operator|&&
operator|(
name|Offset
operator|<
operator|(
name|fragP
operator|->
name|fr_address
operator|+
name|fragP
operator|->
name|fr_fix
operator|)
operator|)
condition|)
break|break;
block|}
comment|/* 		 *	If we couldn't find the frag, things are BAD!! 		 */
if|if
condition|(
name|fragP
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"Couldn't find fixup fragment when checking for indirect reference"
argument_list|)
expr_stmt|;
block|}
comment|/* 	 *	Check for indirect PC relative addressing mode 	 */
if|if
condition|(
name|fragP
operator|->
name|fr_literal
index|[
name|Offset
operator|-
name|fragP
operator|->
name|fr_address
index|]
operator|==
operator|(
name|char
operator|)
literal|0xff
condition|)
block|{
specifier|static
name|char
name|Address_Mode
init|=
literal|0xff
decl_stmt|;
comment|/* 		 *	Yes: Store the indirect mode back into the image 		 *	     to fix up the damage done by STO_PICR 		 */
name|VMS_Set_Psect
argument_list|(
name|Text_Psect
argument_list|,
name|Offset
argument_list|,
name|OBJ$C_TIR
argument_list|)
expr_stmt|;
name|VMS_Store_Immediate_Data
argument_list|(
operator|&
name|Address_Mode
argument_list|,
literal|1
argument_list|,
name|OBJ$C_TIR
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  *	Write the Traceback Module Begin record  */
end_comment

begin_macro
name|VMS_TBT_Module_Begin
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|cp1
decl_stmt|;
name|int
name|Size
decl_stmt|;
name|char
name|Module_Name
index|[
literal|256
index|]
decl_stmt|;
name|char
name|Local
index|[
literal|256
index|]
decl_stmt|;
comment|/* 	 *	Get module name (the FILENAME part of the object file) 	 */
name|cp
operator|=
name|out_file_name
expr_stmt|;
name|cp1
operator|=
name|Module_Name
expr_stmt|;
while|while
condition|(
operator|*
name|cp
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|cp
operator|==
literal|']'
operator|)
operator|||
operator|(
operator|*
name|cp
operator|==
literal|'>'
operator|)
operator|||
operator|(
operator|*
name|cp
operator|==
literal|':'
operator|)
operator|||
operator|(
operator|*
name|cp
operator|==
literal|'/'
operator|)
condition|)
block|{
name|cp1
operator|=
name|Module_Name
expr_stmt|;
name|cp
operator|++
expr_stmt|;
continue|continue;
block|}
operator|*
name|cp1
operator|++
operator|=
name|islower
argument_list|(
operator|*
name|cp
argument_list|)
condition|?
name|toupper
argument_list|(
operator|*
name|cp
operator|++
argument_list|)
else|:
operator|*
name|cp
operator|++
expr_stmt|;
block|}
operator|*
name|cp1
operator|=
literal|0
expr_stmt|;
comment|/* 	 *	Limit it to 31 characters 	 */
while|while
condition|(
operator|--
name|cp1
operator|>=
name|Module_Name
condition|)
if|if
condition|(
operator|*
name|cp1
operator|==
literal|'.'
condition|)
operator|*
name|cp1
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|Module_Name
argument_list|)
operator|>
literal|31
condition|)
block|{
if|if
condition|(
name|flagseen
index|[
literal|'+'
index|]
condition|)
name|printf
argument_list|(
literal|"%s: Module name truncated: %s\n"
argument_list|,
name|myname
argument_list|,
name|Module_Name
argument_list|)
expr_stmt|;
name|Module_Name
index|[
literal|31
index|]
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 *	Arrange to store the data locally (leave room for size byte) 	 */
name|cp
operator|=
name|Local
operator|+
literal|1
expr_stmt|;
comment|/* 	 *	Begin module 	 */
operator|*
name|cp
operator|++
operator|=
name|DST$C_MODBEG
expr_stmt|;
comment|/* 	 *	Unused 	 */
operator|*
name|cp
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* 	 *	Language type == "C" 	 */
operator|*
operator|(
name|long
operator|*
operator|)
name|cp
operator|=
name|DST$C_C
expr_stmt|;
name|cp
operator|+=
sizeof|sizeof
argument_list|(
name|long
argument_list|)
expr_stmt|;
comment|/* 	 *	Store the module name 	 */
operator|*
name|cp
operator|++
operator|=
name|strlen
argument_list|(
name|Module_Name
argument_list|)
expr_stmt|;
name|cp1
operator|=
name|Module_Name
expr_stmt|;
while|while
condition|(
operator|*
name|cp1
condition|)
operator|*
name|cp
operator|++
operator|=
operator|*
name|cp1
operator|++
expr_stmt|;
comment|/* 	 *	Now we can store the record size 	 */
name|Size
operator|=
operator|(
name|cp
operator|-
name|Local
operator|)
expr_stmt|;
name|Local
index|[
literal|0
index|]
operator|=
name|Size
operator|-
literal|1
expr_stmt|;
comment|/* 	 *	Put it into the object record 	 */
name|VMS_Store_Immediate_Data
argument_list|(
name|Local
argument_list|,
name|Size
argument_list|,
name|OBJ$C_TBT
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  *	Write the Traceback Module End record */
end_comment

begin_macro
name|VMS_TBT_Module_End
argument_list|()
end_macro

begin_block
block|{
name|char
name|Local
index|[
literal|2
index|]
decl_stmt|;
comment|/* 	 *	End module 	 */
name|Local
index|[
literal|0
index|]
operator|=
literal|1
expr_stmt|;
name|Local
index|[
literal|1
index|]
operator|=
name|DST$C_MODEND
expr_stmt|;
comment|/* 	 *	Put it into the object record 	 */
name|VMS_Store_Immediate_Data
argument_list|(
name|Local
argument_list|,
literal|2
argument_list|,
name|OBJ$C_TBT
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  *	Write the Traceback Routine Begin record  */
end_comment

begin_macro
name|VMS_TBT_Routine_Begin
argument_list|(
argument|symbolP
argument_list|,
argument|Psect
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|symbol
modifier|*
name|symbolP
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|Psect
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|cp1
decl_stmt|;
name|char
modifier|*
name|Name
decl_stmt|;
name|int
name|Offset
decl_stmt|;
name|int
name|Size
decl_stmt|;
name|char
name|Local
index|[
literal|512
index|]
decl_stmt|;
comment|/* 	 *	Strip the leading "_" from the name 	 */
name|Name
operator|=
name|symbolP
operator|->
name|sy_nlist
operator|.
name|n_un
operator|.
name|n_name
expr_stmt|;
if|if
condition|(
operator|*
name|Name
operator|==
literal|'_'
condition|)
name|Name
operator|++
expr_stmt|;
comment|/* 	 *	Get the text psect offset 	 */
name|Offset
operator|=
name|symbolP
operator|->
name|sy_nlist
operator|.
name|n_value
expr_stmt|;
comment|/* 	 *	Calculate the record size 	 */
name|Size
operator|=
literal|1
operator|+
literal|1
operator|+
literal|4
operator|+
literal|1
operator|+
name|strlen
argument_list|(
name|Name
argument_list|)
expr_stmt|;
comment|/* 	 *	Record Size 	 */
name|Local
index|[
literal|0
index|]
operator|=
name|Size
expr_stmt|;
comment|/* 	 *	Begin Routine 	 */
name|Local
index|[
literal|1
index|]
operator|=
name|DST$C_RTNBEG
expr_stmt|;
comment|/* 	 *	Uses CallS/CallG 	 */
name|Local
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
comment|/* 	 *	Store the data so far 	 */
name|VMS_Store_Immediate_Data
argument_list|(
name|Local
argument_list|,
literal|3
argument_list|,
name|OBJ$C_TBT
argument_list|)
expr_stmt|;
comment|/* 	 *	Make sure we are still generating a OBJ$C_TBT record 	 */
if|if
condition|(
name|Object_Record_Offset
operator|==
literal|0
condition|)
name|PUT_CHAR
argument_list|(
name|OBJ$C_TBT
argument_list|)
expr_stmt|;
comment|/* 	 *	Now get the symbol address 	 */
name|PUT_CHAR
argument_list|(
name|TIR$C_STA_WPL
argument_list|)
expr_stmt|;
name|PUT_SHORT
argument_list|(
name|Psect
argument_list|)
expr_stmt|;
name|PUT_LONG
argument_list|(
name|Offset
argument_list|)
expr_stmt|;
comment|/* 	 *	Store the data reference 	 */
name|PUT_CHAR
argument_list|(
name|TIR$C_STO_PIDR
argument_list|)
expr_stmt|;
comment|/* 	 *	Store the counted string as data 	 */
name|cp
operator|=
name|Local
expr_stmt|;
name|cp1
operator|=
name|Name
expr_stmt|;
name|Size
operator|=
name|strlen
argument_list|(
name|cp1
argument_list|)
operator|+
literal|1
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
name|Size
operator|-
literal|1
expr_stmt|;
while|while
condition|(
operator|*
name|cp1
condition|)
operator|*
name|cp
operator|++
operator|=
operator|*
name|cp1
operator|++
expr_stmt|;
name|VMS_Store_Immediate_Data
argument_list|(
name|Local
argument_list|,
name|Size
argument_list|,
name|OBJ$C_TBT
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  *	Write the Traceback Routine End record  * 	We *must* search the symbol table to find the next routine, since  * 	the assember has a way of reassembling the symbol table OUT OF ORDER  * 	Thus the next routine in the symbol list is not necessarily the   *	next one in memory.  For debugging to work correctly we must know the  *	size of the routine.  */
end_comment

begin_macro
name|VMS_TBT_Routine_End
argument_list|(
argument|Max_Size
argument_list|,
argument|sp
argument_list|)
end_macro

begin_decl_stmt
name|int
name|Max_Size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|symbolS
modifier|*
name|sp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
name|int
name|Size
init|=
literal|0x7fffffff
decl_stmt|;
name|char
name|Local
index|[
literal|16
index|]
decl_stmt|;
for|for
control|(
name|symbolP
operator|=
name|symbol_rootP
init|;
name|symbolP
condition|;
name|symbolP
operator|=
name|symbolP
operator|->
name|sy_next
control|)
block|{
if|if
condition|(
operator|(
name|symbolP
operator|->
name|sy_nlist
operator|.
name|n_type
operator|&
operator|~
name|N_EXT
operator|)
operator|==
name|N_TEXT
condition|)
block|{
if|if
condition|(
name|symbolP
operator|->
name|sy_nlist
operator|.
name|n_un
operator|.
name|n_name
index|[
literal|0
index|]
operator|==
literal|'L'
condition|)
continue|continue;
if|if
condition|(
operator|(
name|symbolP
operator|->
name|sy_nlist
operator|.
name|n_value
operator|>
name|sp
operator|->
name|sy_nlist
operator|.
name|n_value
operator|)
operator|&&
operator|(
name|symbolP
operator|->
name|sy_nlist
operator|.
name|n_value
operator|<
name|Size
operator|)
condition|)
name|Size
operator|=
name|symbolP
operator|->
name|sy_nlist
operator|.
name|n_value
expr_stmt|;
comment|/* check if gcc_compiled. has size of zero */
if|if
condition|(
operator|(
name|symbolP
operator|->
name|sy_nlist
operator|.
name|n_value
operator|==
name|sp
operator|->
name|sy_nlist
operator|.
name|n_value
operator|)
operator|&&
name|sp
operator|!=
name|symbolP
operator|&&
operator|!
name|strcmp
argument_list|(
name|sp
operator|->
name|sy_nlist
operator|.
name|n_un
operator|.
name|n_name
argument_list|,
literal|"gcc_compiled."
argument_list|)
condition|)
name|Size
operator|=
name|symbolP
operator|->
name|sy_nlist
operator|.
name|n_value
expr_stmt|;
block|}
empty_stmt|;
block|}
empty_stmt|;
if|if
condition|(
name|Size
operator|==
literal|0x7fffffff
condition|)
name|Size
operator|=
name|Max_Size
expr_stmt|;
name|Size
operator|-=
name|sp
operator|->
name|sy_nlist
operator|.
name|n_value
expr_stmt|;
comment|/* and get the size of the routine */
comment|/* 	 *	Record Size 	 */
name|Local
index|[
literal|0
index|]
operator|=
literal|6
expr_stmt|;
comment|/* 	 *	End of Routine 	 */
name|Local
index|[
literal|1
index|]
operator|=
name|DST$C_RTNEND
expr_stmt|;
comment|/* 	 *	Unused 	 */
name|Local
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
comment|/* 	 *	Size of routine 	 */
operator|*
operator|(
operator|(
name|long
operator|*
operator|)
operator|(
name|Local
operator|+
literal|3
operator|)
operator|)
operator|=
name|Size
expr_stmt|;
comment|/* 	 *	Store the record 	 */
name|VMS_Store_Immediate_Data
argument_list|(
name|Local
argument_list|,
literal|7
argument_list|,
name|OBJ$C_TBT
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  *	Write the Traceback Block End record  */
end_comment

begin_macro
name|VMS_TBT_Block_Begin
argument_list|(
argument|symbolP
argument_list|,
argument|Psect
argument_list|,
argument|Name
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|symbol
modifier|*
name|symbolP
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|Psect
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|Name
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|cp1
decl_stmt|;
name|int
name|Offset
decl_stmt|;
name|int
name|Size
decl_stmt|;
name|char
name|Local
index|[
literal|512
index|]
decl_stmt|;
comment|/* 	 *	Begin block 	 */
name|Size
operator|=
literal|1
operator|+
literal|1
operator|+
literal|4
operator|+
literal|1
operator|+
name|strlen
argument_list|(
name|Name
argument_list|)
expr_stmt|;
comment|/* 	 *	Record Size 	 */
name|Local
index|[
literal|0
index|]
operator|=
name|Size
expr_stmt|;
comment|/* 	 *	Begin Block - We simulate with a phony routine 	 */
name|Local
index|[
literal|1
index|]
operator|=
name|DST$C_BLKBEG
expr_stmt|;
comment|/* 	 *	Uses CallS/CallG 	 */
name|Local
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
comment|/* 	 *	Store the data so far 	 */
name|VMS_Store_Immediate_Data
argument_list|(
name|Local
argument_list|,
literal|3
argument_list|,
name|OBJ$C_DBG
argument_list|)
expr_stmt|;
comment|/* 	 *	Make sure we are still generating a OBJ$C_DBG record 	 */
if|if
condition|(
name|Object_Record_Offset
operator|==
literal|0
condition|)
name|PUT_CHAR
argument_list|(
name|OBJ$C_DBG
argument_list|)
expr_stmt|;
comment|/* 	 *	Now get the symbol address 	 */
name|PUT_CHAR
argument_list|(
name|TIR$C_STA_WPL
argument_list|)
expr_stmt|;
name|PUT_SHORT
argument_list|(
name|Psect
argument_list|)
expr_stmt|;
comment|/* 	 *	Get the text psect offset 	 */
name|Offset
operator|=
name|symbolP
operator|->
name|sy_nlist
operator|.
name|n_value
expr_stmt|;
name|PUT_LONG
argument_list|(
name|Offset
argument_list|)
expr_stmt|;
comment|/* 	 *	Store the data reference 	 */
name|PUT_CHAR
argument_list|(
name|TIR$C_STO_PIDR
argument_list|)
expr_stmt|;
comment|/* 	 *	Store the counted string as data 	 */
name|cp
operator|=
name|Local
expr_stmt|;
name|cp1
operator|=
name|Name
expr_stmt|;
name|Size
operator|=
name|strlen
argument_list|(
name|cp1
argument_list|)
operator|+
literal|1
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
name|Size
operator|-
literal|1
expr_stmt|;
while|while
condition|(
operator|*
name|cp1
condition|)
operator|*
name|cp
operator|++
operator|=
operator|*
name|cp1
operator|++
expr_stmt|;
name|VMS_Store_Immediate_Data
argument_list|(
name|Local
argument_list|,
name|Size
argument_list|,
name|OBJ$C_DBG
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  *	Write the Traceback Block End record  */
end_comment

begin_macro
name|VMS_TBT_Block_End
argument_list|(
argument|int Size
argument_list|)
end_macro

begin_block
block|{
name|char
name|Local
index|[
literal|16
index|]
decl_stmt|;
comment|/* 	 *	End block - simulate with a phony end routine 	 */
name|Local
index|[
literal|0
index|]
operator|=
literal|6
expr_stmt|;
name|Local
index|[
literal|1
index|]
operator|=
name|DST$C_BLKEND
expr_stmt|;
operator|*
operator|(
operator|(
name|long
operator|*
operator|)
operator|(
name|Local
operator|+
literal|3
operator|)
operator|)
operator|=
name|Size
expr_stmt|;
comment|/* 	 *	Unused 	 */
name|Local
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|VMS_Store_Immediate_Data
argument_list|(
name|Local
argument_list|,
literal|7
argument_list|,
name|OBJ$C_DBG
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  *	Write a Line number / PC correlation record  */
end_comment

begin_macro
name|VMS_TBT_Line_PC_Correlation
argument_list|(
argument|Line_Number
argument_list|,
argument|Offset
argument_list|,
argument|Psect
argument_list|,
argument|Do_Delta
argument_list|)
end_macro

begin_decl_stmt
name|int
name|Line_Number
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|Offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|Psect
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|Do_Delta
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|char
name|Local
index|[
literal|64
index|]
decl_stmt|;
comment|/* *	If not delta, set our PC/Line number correlation */
if|if
condition|(
name|Do_Delta
operator|==
literal|0
condition|)
block|{
comment|/* 		 *	Size 		 */
name|Local
index|[
literal|0
index|]
operator|=
literal|1
operator|+
literal|1
operator|+
literal|2
operator|+
literal|1
operator|+
literal|4
expr_stmt|;
comment|/* 		 *	Line Number/PC correlation 		 */
name|Local
index|[
literal|1
index|]
operator|=
name|DST$C_LINE_NUM
expr_stmt|;
comment|/* 		 *	Set Line number 		 */
name|Local
index|[
literal|2
index|]
operator|=
name|DST$C_SET_LINE_NUM
expr_stmt|;
operator|*
operator|(
operator|(
name|unsigned
name|short
operator|*
operator|)
operator|(
name|Local
operator|+
literal|3
operator|)
operator|)
operator|=
name|Line_Number
operator|-
literal|1
expr_stmt|;
comment|/* 		 *	Set PC 		 */
name|Local
index|[
literal|5
index|]
operator|=
name|DST$C_SET_ABS_PC
expr_stmt|;
name|VMS_Store_Immediate_Data
argument_list|(
name|Local
argument_list|,
literal|6
argument_list|,
name|OBJ$C_TBT
argument_list|)
expr_stmt|;
comment|/* 		 *	Make sure we are still generating a OBJ$C_TBT record 		 */
if|if
condition|(
name|Object_Record_Offset
operator|==
literal|0
condition|)
name|PUT_CHAR
argument_list|(
name|OBJ$C_TBT
argument_list|)
expr_stmt|;
if|if
condition|(
name|Psect
operator|<
literal|255
condition|)
block|{
name|PUT_CHAR
argument_list|(
name|TIR$C_STA_PL
argument_list|)
expr_stmt|;
name|PUT_CHAR
argument_list|(
name|Psect
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|PUT_CHAR
argument_list|(
name|TIR$C_STA_WPL
argument_list|)
expr_stmt|;
name|PUT_SHORT
argument_list|(
name|Psect
argument_list|)
expr_stmt|;
block|}
name|PUT_LONG
argument_list|(
name|Offset
argument_list|)
expr_stmt|;
name|PUT_CHAR
argument_list|(
name|TIR$C_STO_PIDR
argument_list|)
expr_stmt|;
comment|/* 		 *	Do a PC offset of 0 to register the line number 		 */
name|Local
index|[
literal|0
index|]
operator|=
literal|2
expr_stmt|;
name|Local
index|[
literal|1
index|]
operator|=
name|DST$C_LINE_NUM
expr_stmt|;
name|Local
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Increment PC by 0 and register line # */
name|VMS_Store_Immediate_Data
argument_list|(
name|Local
argument_list|,
literal|3
argument_list|,
name|OBJ$C_TBT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 *	If Delta is negative, terminate the line numbers 		 */
if|if
condition|(
name|Do_Delta
operator|<
literal|0
condition|)
block|{
name|Local
index|[
literal|0
index|]
operator|=
literal|1
operator|+
literal|1
operator|+
literal|4
expr_stmt|;
name|Local
index|[
literal|1
index|]
operator|=
name|DST$C_LINE_NUM
expr_stmt|;
name|Local
index|[
literal|2
index|]
operator|=
name|DST$C_TERM_L
expr_stmt|;
operator|*
operator|(
operator|(
name|long
operator|*
operator|)
operator|(
name|Local
operator|+
literal|3
operator|)
operator|)
operator|=
name|Offset
expr_stmt|;
name|VMS_Store_Immediate_Data
argument_list|(
name|Local
argument_list|,
literal|7
argument_list|,
name|OBJ$C_TBT
argument_list|)
expr_stmt|;
comment|/* 			 *	Done 			 */
return|return;
block|}
comment|/* 		 *	Do a PC/Line delta 		 */
name|cp
operator|=
name|Local
operator|+
literal|1
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
name|DST$C_LINE_NUM
expr_stmt|;
if|if
condition|(
name|Line_Number
operator|>
literal|1
condition|)
block|{
comment|/* 			 *	We need to increment the line number 			 */
if|if
condition|(
name|Line_Number
operator|-
literal|1
operator|<=
literal|255
condition|)
block|{
operator|*
name|cp
operator|++
operator|=
name|DST$C_INCR_LINUM
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
name|Line_Number
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
operator|*
name|cp
operator|++
operator|=
name|DST$C_INCR_LINUM_W
expr_stmt|;
operator|*
operator|(
name|short
operator|*
operator|)
name|cp
operator|=
name|Line_Number
operator|-
literal|1
expr_stmt|;
name|cp
operator|+=
sizeof|sizeof
argument_list|(
name|short
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 		 *	Increment the PC 		 */
if|if
condition|(
name|Offset
operator|<=
literal|128
condition|)
block|{
operator|*
name|cp
operator|++
operator|=
operator|-
name|Offset
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|Offset
operator|<
literal|0x10000
condition|)
block|{
operator|*
name|cp
operator|++
operator|=
name|DST$C_DELTA_PC_W
expr_stmt|;
operator|*
operator|(
name|short
operator|*
operator|)
name|cp
operator|=
name|Offset
expr_stmt|;
name|cp
operator|+=
sizeof|sizeof
argument_list|(
name|short
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|cp
operator|++
operator|=
name|DST$C_DELTA_PC_L
expr_stmt|;
operator|*
operator|(
name|long
operator|*
operator|)
name|cp
operator|=
name|Offset
expr_stmt|;
name|cp
operator|+=
sizeof|sizeof
argument_list|(
name|long
argument_list|)
expr_stmt|;
block|}
block|}
name|Local
index|[
literal|0
index|]
operator|=
name|cp
operator|-
operator|(
name|Local
operator|+
literal|1
operator|)
expr_stmt|;
name|VMS_Store_Immediate_Data
argument_list|(
name|Local
argument_list|,
name|cp
operator|-
name|Local
argument_list|,
name|OBJ$C_TBT
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  *	Describe a source file to the debugger  */
end_comment

begin_macro
name|VMS_TBT_Source_File
argument_list|(
argument|Filename
argument_list|,
argument|ID_Number
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|Filename
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ID_Number
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|cp1
decl_stmt|;
name|int
name|Status
decl_stmt|,
name|i
decl_stmt|;
name|char
name|Local
index|[
literal|512
index|]
decl_stmt|;
specifier|static
name|struct
name|FAB
name|Fab
decl_stmt|;
specifier|static
name|struct
name|NAM
name|Nam
decl_stmt|;
specifier|static
name|struct
name|XABDAT
name|Date_Xab
decl_stmt|;
specifier|static
name|struct
name|XABFHC
name|File_Header_Xab
decl_stmt|;
name|char
name|Es_String
index|[
literal|255
index|]
decl_stmt|,
name|Rs_String
index|[
literal|255
index|]
decl_stmt|;
comment|/* 	 *	Setup the Fab 	 */
name|Fab
operator|.
name|fab$b_bid
operator|=
name|FAB$C_BID
expr_stmt|;
name|Fab
operator|.
name|fab$b_bln
operator|=
sizeof|sizeof
argument_list|(
name|Fab
argument_list|)
expr_stmt|;
name|Fab
operator|.
name|fab$l_nam
operator|=
operator|(
operator|&
name|Nam
operator|)
expr_stmt|;
name|Fab
operator|.
name|fab$l_xab
operator|=
operator|(
expr|struct
name|XAB
operator|*
operator|)
operator|&
name|Date_Xab
expr_stmt|;
comment|/* 	 *	Setup the Nam block so we can find out the FULL name 	 *	of the source file. 	 */
name|Nam
operator|.
name|nam$b_bid
operator|=
name|NAM$C_BID
expr_stmt|;
name|Nam
operator|.
name|nam$b_bln
operator|=
sizeof|sizeof
argument_list|(
name|Nam
argument_list|)
expr_stmt|;
name|Nam
operator|.
name|nam$l_rsa
operator|=
name|Rs_String
expr_stmt|;
name|Nam
operator|.
name|nam$b_rss
operator|=
sizeof|sizeof
argument_list|(
name|Rs_String
argument_list|)
expr_stmt|;
name|Nam
operator|.
name|nam$l_esa
operator|=
name|Es_String
expr_stmt|;
name|Nam
operator|.
name|nam$b_ess
operator|=
sizeof|sizeof
argument_list|(
name|Es_String
argument_list|)
expr_stmt|;
comment|/* 	 *	Setup the Date and File Header Xabs 	 */
name|Date_Xab
operator|.
name|xab$b_cod
operator|=
name|XAB$C_DAT
expr_stmt|;
name|Date_Xab
operator|.
name|xab$b_bln
operator|=
sizeof|sizeof
argument_list|(
name|Date_Xab
argument_list|)
expr_stmt|;
name|Date_Xab
operator|.
name|xab$l_nxt
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|File_Header_Xab
expr_stmt|;
name|File_Header_Xab
operator|.
name|xab$b_cod
operator|=
name|XAB$C_FHC
expr_stmt|;
name|File_Header_Xab
operator|.
name|xab$b_bln
operator|=
sizeof|sizeof
argument_list|(
name|File_Header_Xab
argument_list|)
expr_stmt|;
comment|/* ((struct XAB *)&Date_Xab)->xab$b_cod = XAB$C_DAT;				*/
comment|/* ((struct XAB *)&Date_Xab)->xab$b_bln = sizeof(Date_Xab);			*/
comment|/* ((struct XAB *)&Date_Xab)->xab$l_nxt = (struct XAB *)&File_Header_Xab;	*/
comment|/* ((struct XAB *)&File_Header_Xab)->xab$b_cod = XAB$C_FHC;			*/
comment|/* ((struct XAB *)&File_Header_Xab)->xab$b_bln = sizeof(File_Header_Xab);	*/
comment|/* 	 *	Get the file information 	 */
name|Fab
operator|.
name|fab$l_fna
operator|=
name|Filename
expr_stmt|;
name|Fab
operator|.
name|fab$b_fns
operator|=
name|strlen
argument_list|(
name|Filename
argument_list|)
expr_stmt|;
name|Status
operator|=
name|sys$open
argument_list|(
operator|&
name|Fab
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|Status
operator|&
literal|1
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"gas: Couldn't find source file \"%s\", Error = %%X%x\n"
argument_list|,
name|Filename
argument_list|,
name|Status
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|sys$close
argument_list|(
operator|&
name|Fab
argument_list|)
expr_stmt|;
comment|/* 	 *	Calculate the size of the resultant string 	 */
name|i
operator|=
name|Nam
operator|.
name|nam$b_rsl
expr_stmt|;
comment|/* 	 *	Size of record 	 */
name|Local
index|[
literal|0
index|]
operator|=
literal|1
operator|+
literal|1
operator|+
literal|1
operator|+
literal|1
operator|+
literal|1
operator|+
literal|2
operator|+
literal|8
operator|+
literal|4
operator|+
literal|2
operator|+
literal|1
operator|+
literal|1
operator|+
name|i
operator|+
literal|1
expr_stmt|;
comment|/* 	 *	Source declaration 	 */
name|Local
index|[
literal|1
index|]
operator|=
name|DST$C_SOURCE
expr_stmt|;
comment|/* 	 *	Make formfeeds count as source records 	 */
name|Local
index|[
literal|2
index|]
operator|=
name|DST$C_SRC_FORMFEED
expr_stmt|;
comment|/* 	 *	Declare source file 	 */
name|Local
index|[
literal|3
index|]
operator|=
name|DST$C_SRC_DECLFILE
expr_stmt|;
name|Local
index|[
literal|4
index|]
operator|=
literal|1
operator|+
literal|2
operator|+
literal|8
operator|+
literal|4
operator|+
literal|2
operator|+
literal|1
operator|+
literal|1
operator|+
name|i
operator|+
literal|1
expr_stmt|;
name|cp
operator|=
name|Local
operator|+
literal|5
expr_stmt|;
comment|/* 	 *	Flags 	 */
operator|*
name|cp
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* 	 *	File ID 	 */
operator|*
operator|(
name|short
operator|*
operator|)
name|cp
operator|=
name|ID_Number
expr_stmt|;
name|cp
operator|+=
sizeof|sizeof
argument_list|(
name|short
argument_list|)
expr_stmt|;
comment|/* 	 *	Creation Date 	 */
operator|*
operator|(
name|long
operator|*
operator|)
name|cp
operator|=
operator|(
operator|(
name|long
operator|*
operator|)
operator|&
name|Date_Xab
operator|.
name|xab$q_cdt
operator|)
index|[
literal|0
index|]
expr_stmt|;
name|cp
operator|+=
sizeof|sizeof
argument_list|(
name|long
argument_list|)
expr_stmt|;
operator|*
operator|(
name|long
operator|*
operator|)
name|cp
operator|=
operator|(
operator|(
name|long
operator|*
operator|)
operator|&
name|Date_Xab
operator|.
name|xab$q_cdt
operator|)
index|[
literal|1
index|]
expr_stmt|;
name|cp
operator|+=
sizeof|sizeof
argument_list|(
name|long
argument_list|)
expr_stmt|;
comment|/* 	 *	End of file block 	 */
operator|*
operator|(
name|long
operator|*
operator|)
name|cp
operator|=
name|File_Header_Xab
operator|.
name|xab$l_ebk
expr_stmt|;
name|cp
operator|+=
sizeof|sizeof
argument_list|(
name|long
argument_list|)
expr_stmt|;
comment|/* 	 *	First free byte 	 */
operator|*
operator|(
name|short
operator|*
operator|)
name|cp
operator|=
name|File_Header_Xab
operator|.
name|xab$w_ffb
expr_stmt|;
name|cp
operator|+=
sizeof|sizeof
argument_list|(
name|short
argument_list|)
expr_stmt|;
comment|/* 	 *	Record format 	 */
operator|*
name|cp
operator|++
operator|=
name|File_Header_Xab
operator|.
name|xab$b_rfo
expr_stmt|;
comment|/* 	 *	Filename 	 */
operator|*
name|cp
operator|++
operator|=
name|i
expr_stmt|;
name|cp1
operator|=
name|Rs_String
expr_stmt|;
while|while
condition|(
operator|--
name|i
operator|>=
literal|0
condition|)
operator|*
name|cp
operator|++
operator|=
operator|*
name|cp1
operator|++
expr_stmt|;
comment|/* 	 *	Library module name (none) 	 */
operator|*
name|cp
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* 	 *	Done 	 */
name|VMS_Store_Immediate_Data
argument_list|(
name|Local
argument_list|,
name|cp
operator|-
name|Local
argument_list|,
name|OBJ$C_TBT
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  *	Give the number of source lines to the debugger  */
end_comment

begin_macro
name|VMS_TBT_Source_Lines
argument_list|(
argument|ID_Number
argument_list|,
argument|Starting_Line_Number
argument_list|,
argument|Number_Of_Lines
argument_list|)
end_macro

begin_decl_stmt
name|int
name|ID_Number
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|Starting_Line_Number
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|Number_Of_Lines
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|cp1
decl_stmt|;
name|char
name|Local
index|[
literal|16
index|]
decl_stmt|;
comment|/* 	 *	Size of record 	 */
name|Local
index|[
literal|0
index|]
operator|=
literal|1
operator|+
literal|1
operator|+
literal|2
operator|+
literal|1
operator|+
literal|4
operator|+
literal|1
operator|+
literal|2
expr_stmt|;
comment|/* 	 *	Source declaration 	 */
name|Local
index|[
literal|1
index|]
operator|=
name|DST$C_SOURCE
expr_stmt|;
comment|/* 	 *	Set Source File 	 */
name|cp
operator|=
name|Local
operator|+
literal|2
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
name|DST$C_SRC_SETFILE
expr_stmt|;
comment|/* 	 *	File ID Number 	 */
operator|*
operator|(
name|short
operator|*
operator|)
name|cp
operator|=
name|ID_Number
expr_stmt|;
name|cp
operator|+=
sizeof|sizeof
argument_list|(
name|short
argument_list|)
expr_stmt|;
comment|/* 	 *	Set record number 	 */
operator|*
name|cp
operator|++
operator|=
name|DST$C_SRC_SETREC_L
expr_stmt|;
operator|*
operator|(
name|long
operator|*
operator|)
name|cp
operator|=
name|Starting_Line_Number
expr_stmt|;
name|cp
operator|+=
sizeof|sizeof
argument_list|(
name|long
argument_list|)
expr_stmt|;
comment|/* 	 *	Define lines 	 */
operator|*
name|cp
operator|++
operator|=
name|DST$C_SRC_DEFLINES_W
expr_stmt|;
operator|*
operator|(
name|short
operator|*
operator|)
name|cp
operator|=
name|Number_Of_Lines
expr_stmt|;
name|cp
operator|+=
sizeof|sizeof
argument_list|(
name|short
argument_list|)
expr_stmt|;
comment|/* 	 *	Done 	 */
name|VMS_Store_Immediate_Data
argument_list|(
name|Local
argument_list|,
name|cp
operator|-
name|Local
argument_list|,
name|OBJ$C_TBT
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  *	Given the pointer to a symbol we calculate how big the data at the  *	symbol is.  We do this by looking for the next symbol (local or  *	global) which will indicate the start of another datum.  */
end_comment

begin_function
name|int
name|VMS_Initialized_Data_Size
parameter_list|(
name|sp
parameter_list|,
name|End_Of_Data
parameter_list|)
specifier|register
name|struct
name|symbol
modifier|*
name|sp
decl_stmt|;
name|int
name|End_Of_Data
decl_stmt|;
block|{
specifier|register
name|struct
name|symbol
modifier|*
name|sp1
decl_stmt|,
modifier|*
name|Next_Symbol
decl_stmt|;
comment|/* 	 *	Find the next symbol 	 *	it delimits this datum 	 */
name|Next_Symbol
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|sp1
operator|=
name|symbol_rootP
init|;
name|sp1
condition|;
name|sp1
operator|=
name|sp1
operator|->
name|sy_next
control|)
block|{
comment|/* 		 *	The data type must match 		 */
if|if
condition|(
operator|(
name|sp1
operator|->
name|sy_nlist
operator|.
name|n_type
operator|&
operator|~
name|N_EXT
operator|)
operator|!=
name|N_DATA
condition|)
continue|continue;
comment|/* 		 *	The symbol must be AFTER this symbol 		 */
if|if
condition|(
name|sp1
operator|->
name|sy_nlist
operator|.
name|n_value
operator|<=
name|sp
operator|->
name|sy_nlist
operator|.
name|n_value
condition|)
continue|continue;
comment|/* 		 *	We ignore THIS symbol 		 */
if|if
condition|(
name|sp1
operator|==
name|sp
condition|)
continue|continue;
comment|/* 		 *	If there is already a candidate selected for the 		 *	next symbol, see if we are a better candidate 		 */
if|if
condition|(
name|Next_Symbol
condition|)
block|{
comment|/* 			 *	We are a better candidate if we are "closer" 			 *	to the symbol 			 */
if|if
condition|(
name|sp1
operator|->
name|sy_nlist
operator|.
name|n_value
operator|>
name|Next_Symbol
operator|->
name|sy_nlist
operator|.
name|n_value
condition|)
continue|continue;
comment|/* 			 *	Win:  Make this the candidate 			 */
name|Next_Symbol
operator|=
name|sp1
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 *	This is the 1st candidate 			 */
name|Next_Symbol
operator|=
name|sp1
expr_stmt|;
block|}
block|}
comment|/* 	 *	Calculate its size 	 */
return|return
operator|(
name|Next_Symbol
condition|?
operator|(
name|Next_Symbol
operator|->
name|sy_nlist
operator|.
name|n_value
operator|-
name|sp
operator|->
name|sy_nlist
operator|.
name|n_value
operator|)
else|:
operator|(
name|End_Of_Data
operator|-
name|sp
operator|->
name|sy_nlist
operator|.
name|n_value
operator|)
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* this routine locates a file in the list of files.  If an entry does not  * exist, one is created.  For include files, a new entry is always created  * such that inline functions can be properly debugged */
end_comment

begin_function
name|struct
name|input_file
modifier|*
name|find_file
parameter_list|(
name|sp
parameter_list|)
name|symbolS
modifier|*
name|sp
decl_stmt|;
block|{
name|struct
name|input_file
modifier|*
name|same_file
decl_stmt|;
name|struct
name|input_file
modifier|*
name|fpnt
decl_stmt|;
name|same_file
operator|=
operator|(
expr|struct
name|input_file
operator|*
operator|)
name|NULL
expr_stmt|;
for|for
control|(
name|fpnt
operator|=
name|file_root
init|;
name|fpnt
condition|;
name|fpnt
operator|=
name|fpnt
operator|->
name|next
control|)
block|{
if|if
condition|(
name|fpnt
operator|==
operator|(
expr|struct
name|input_file
operator|*
operator|)
name|NULL
condition|)
break|break;
if|if
condition|(
name|fpnt
operator|->
name|spnt
operator|==
name|sp
condition|)
return|return
name|fpnt
return|;
block|}
empty_stmt|;
for|for
control|(
name|fpnt
operator|=
name|file_root
init|;
name|fpnt
condition|;
name|fpnt
operator|=
name|fpnt
operator|->
name|next
control|)
block|{
if|if
condition|(
name|fpnt
operator|==
operator|(
expr|struct
name|input_file
operator|*
operator|)
name|NULL
condition|)
break|break;
if|if
condition|(
name|strcmp
argument_list|(
name|sp
operator|->
name|sy_nlist
operator|.
name|n_un
operator|.
name|n_name
argument_list|,
name|fpnt
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|fpnt
operator|->
name|flag
operator|==
literal|1
condition|)
return|return
name|fpnt
return|;
name|same_file
operator|=
name|fpnt
expr_stmt|;
break|break;
block|}
empty_stmt|;
block|}
empty_stmt|;
name|fpnt
operator|=
operator|(
expr|struct
name|input_file
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|input_file
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|file_root
operator|==
operator|(
expr|struct
name|input_file
operator|*
operator|)
name|NULL
condition|)
name|file_root
operator|=
name|fpnt
expr_stmt|;
else|else
block|{
name|struct
name|input_file
modifier|*
name|fpnt1
decl_stmt|;
for|for
control|(
name|fpnt1
operator|=
name|file_root
init|;
name|fpnt1
operator|->
name|next
condition|;
name|fpnt1
operator|=
name|fpnt1
operator|->
name|next
control|)
empty_stmt|;
name|fpnt1
operator|->
name|next
operator|=
name|fpnt
expr_stmt|;
block|}
empty_stmt|;
name|fpnt
operator|->
name|next
operator|=
operator|(
expr|struct
name|input_file
operator|*
operator|)
name|NULL
expr_stmt|;
name|fpnt
operator|->
name|name
operator|=
name|sp
operator|->
name|sy_nlist
operator|.
name|n_un
operator|.
name|n_name
expr_stmt|;
name|fpnt
operator|->
name|min_line
operator|=
literal|0x7fffffff
expr_stmt|;
name|fpnt
operator|->
name|max_line
operator|=
literal|0
expr_stmt|;
name|fpnt
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
name|fpnt
operator|->
name|flag
operator|=
literal|0
expr_stmt|;
name|fpnt
operator|->
name|file_number
operator|=
literal|0
expr_stmt|;
name|fpnt
operator|->
name|spnt
operator|=
name|sp
expr_stmt|;
name|fpnt
operator|->
name|same_file_fpnt
operator|=
name|same_file
expr_stmt|;
return|return
name|fpnt
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *	This is a hacked _doprnt() for VAX-11 "C".  It understands that  *	it is ONLY called by as_fatal(Format, Args) with a pointer to the  *	"Args" argument.  From this we can make it all work right!  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|eunice
end_ifndef

begin_macro
name|_doprnt
argument_list|(
argument|Format
argument_list|,
argument|a
argument_list|,
argument|f
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|Format
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|f
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|a
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|Nargs
init|=
operator|(
operator|(
name|int
operator|*
operator|)
name|a
operator|)
index|[
operator|-
literal|2
index|]
decl_stmt|;
comment|/* This understands as_fatal() */
switch|switch
condition|(
name|Nargs
condition|)
block|{
default|default:
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"_doprnt error on \"%s\"!!"
argument_list|,
name|Format
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|fprintf
argument_list|(
name|f
argument_list|,
name|Format
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|fprintf
argument_list|(
name|f
argument_list|,
name|Format
argument_list|,
name|a
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|fprintf
argument_list|(
name|f
argument_list|,
name|Format
argument_list|,
name|a
index|[
literal|0
index|]
argument_list|,
name|a
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|fprintf
argument_list|(
name|f
argument_list|,
name|Format
argument_list|,
name|a
index|[
literal|0
index|]
argument_list|,
name|a
index|[
literal|1
index|]
argument_list|,
name|a
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|5
case|:
name|fprintf
argument_list|(
name|f
argument_list|,
name|Format
argument_list|,
name|a
index|[
literal|0
index|]
argument_list|,
name|a
index|[
literal|1
index|]
argument_list|,
name|a
index|[
literal|2
index|]
argument_list|,
name|a
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|6
case|:
name|fprintf
argument_list|(
name|f
argument_list|,
name|Format
argument_list|,
name|a
index|[
literal|0
index|]
argument_list|,
name|a
index|[
literal|1
index|]
argument_list|,
name|a
index|[
literal|2
index|]
argument_list|,
name|a
index|[
literal|3
index|]
argument_list|,
name|a
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|7
case|:
name|fprintf
argument_list|(
name|f
argument_list|,
name|Format
argument_list|,
name|a
index|[
literal|0
index|]
argument_list|,
name|a
index|[
literal|1
index|]
argument_list|,
name|a
index|[
literal|2
index|]
argument_list|,
name|a
index|[
literal|3
index|]
argument_list|,
name|a
index|[
literal|4
index|]
argument_list|,
name|a
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|fprintf
argument_list|(
name|f
argument_list|,
name|Format
argument_list|,
name|a
index|[
literal|0
index|]
argument_list|,
name|a
index|[
literal|1
index|]
argument_list|,
name|a
index|[
literal|2
index|]
argument_list|,
name|a
index|[
literal|3
index|]
argument_list|,
name|a
index|[
literal|4
index|]
argument_list|,
name|a
index|[
literal|5
index|]
argument_list|,
name|a
index|[
literal|6
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|9
case|:
name|fprintf
argument_list|(
name|f
argument_list|,
name|Format
argument_list|,
name|a
index|[
literal|0
index|]
argument_list|,
name|a
index|[
literal|1
index|]
argument_list|,
name|a
index|[
literal|2
index|]
argument_list|,
name|a
index|[
literal|3
index|]
argument_list|,
name|a
index|[
literal|4
index|]
argument_list|,
name|a
index|[
literal|5
index|]
argument_list|,
name|a
index|[
literal|6
index|]
argument_list|,
name|a
index|[
literal|7
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|10
case|:
name|fprintf
argument_list|(
name|f
argument_list|,
name|Format
argument_list|,
name|a
index|[
literal|0
index|]
argument_list|,
name|a
index|[
literal|1
index|]
argument_list|,
name|a
index|[
literal|2
index|]
argument_list|,
name|a
index|[
literal|3
index|]
argument_list|,
name|a
index|[
literal|4
index|]
argument_list|,
name|a
index|[
literal|5
index|]
argument_list|,
name|a
index|[
literal|6
index|]
argument_list|,
name|a
index|[
literal|7
index|]
argument_list|,
name|a
index|[
literal|8
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* eunice */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* VMS */
end_comment

end_unit

