begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|"struc-symbol.h"
end_include

begin_include
include|#
directive|include
file|"symbols.h"
end_include

begin_include
include|#
directive|include
file|"objrecdef.h"
end_include

begin_include
include|#
directive|include
file|<stab.h>
end_include

begin_comment
comment|/* This file contains many of the routines needed to output debugging info into  * the object file that the VMS debugger needs to understand symbols.  These  * routines are called very late in the assembly process, and thus we can be  * fairly lax about changing things, since the GSD and the TIR sections have  * already been output.  */
end_comment

begin_comment
comment|/* We need this info to cross correlate between the stabs def for a symbol and  * the actual symbol def.  The actual symbol def contains the psect number and  * offset, which is needed to declare a variable to the debugger for global  * and static variables  */
end_comment

begin_struct
struct|struct
name|VMS_Symbol
block|{
name|struct
name|VMS_Symbol
modifier|*
name|Next
decl_stmt|;
name|struct
name|symbol
modifier|*
name|Symbol
decl_stmt|;
name|int
name|Size
decl_stmt|;
name|int
name|Psect_Index
decl_stmt|;
name|int
name|Psect_Offset
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|extern
name|struct
name|VMS_Symbol
modifier|*
name|VMS_Symbols
decl_stmt|;
end_decl_stmt

begin_enum
enum|enum
name|advanced_type
block|{
name|BASIC
block|,
name|POINTER
block|,
name|ARRAY
block|,
name|ENUM
block|,
name|STRUCT
block|,
name|UNION
block|,
name|FUNCTION
block|,
name|VOID
block|,
name|UNKNOWN
block|}
enum|;
end_enum

begin_comment
comment|/* this structure contains the information from the stabs directives, and the  * information is filled in by VMS_typedef_parse.  Everything that is needed  * to generate the debugging record for a given symbol is present here.  * This could be done more efficiently, using nested struct/unions, but for now  * I am happy that it works.  */
end_comment

begin_struct
struct|struct
name|VMS_DBG_Symbol
block|{
name|struct
name|VMS_DBG_Symbol
modifier|*
name|next
decl_stmt|;
name|enum
name|advanced_type
name|advanced
decl_stmt|;
comment|/* description of what this is */
name|int
name|dbx_type
decl_stmt|;
comment|/* this record is for this type */
name|int
name|type2
decl_stmt|;
comment|/* For advanced types this is the type referred to. 				i.e. the type a pointer points to, or the type 				of object that makes up an array */
name|int
name|VMS_type
decl_stmt|;
comment|/* Use this type when generating a variable def */
name|int
name|index_min
decl_stmt|;
comment|/* used for arrays - this will be present for all */
name|int
name|index_max
decl_stmt|;
comment|/* entries, but will be meaningless for non-arrays */
name|int
name|data_size
decl_stmt|;
comment|/* size in bytes of the data type.  For an array, this 			   is the size of one element in the array */
name|int
name|struc_numb
decl_stmt|;
comment|/* Number of the structure/union/enum - used for ref */
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|VMS_DBG_Symbol
modifier|*
name|VMS_Symbol_type_list
init|=
block|{
operator|(
expr|struct
name|VMS_DBG_Symbol
operator|*
operator|)
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* we need this structure to keep track of forward references to  * struct/union/enum that have not been defined yet.  When they are ultimately  * defined, then we can go back and generate the TIR commands to make a back  * reference.  */
end_comment

begin_struct
struct|struct
name|forward_ref
block|{
name|struct
name|forward_ref
modifier|*
name|next
decl_stmt|;
name|int
name|dbx_type
decl_stmt|;
name|int
name|struc_numb
decl_stmt|;
name|char
name|resolved
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|forward_ref
modifier|*
name|f_ref_root
init|=
block|{
operator|(
expr|struct
name|forward_ref
operator|*
operator|)
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|symbol_name
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|structure_count
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* this routine converts a number string into an integer, and stops when it  * sees an invalid character the return value is the address of the character   * just past the last character read.  No error is generated.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|cvt_integer
parameter_list|(
name|char
modifier|*
name|str
parameter_list|,
name|int
modifier|*
name|rtn
parameter_list|)
block|{
name|int
name|ival
decl_stmt|,
name|neg
decl_stmt|;
name|neg
operator|=
operator|*
name|str
operator|==
literal|'-'
condition|?
operator|++
name|str
operator|,
operator|-
literal|1
operator|:
literal|1
expr_stmt|;
name|ival
operator|=
literal|0
expr_stmt|;
comment|/* first get the number of the type for dbx */
while|while
condition|(
operator|(
operator|*
name|str
operator|<=
literal|'9'
operator|)
operator|&&
operator|(
operator|*
name|str
operator|>=
literal|'0'
operator|)
condition|)
name|ival
operator|=
literal|10
operator|*
name|ival
operator|+
operator|*
name|str
operator|++
operator|-
literal|'0'
expr_stmt|;
operator|*
name|rtn
operator|=
name|neg
operator|*
name|ival
expr_stmt|;
return|return
name|str
return|;
block|}
end_function

begin_comment
comment|/* this routine fixes the names that are generated by C++, ".this" is a good  * example.  The period does not work for the debugger, since it looks like  * the syntax for a structure element, and thus it gets mightily confused  */
end_comment

begin_expr_stmt
specifier|static
name|fix_name
argument_list|(
argument|char* pnt
argument_list|)
block|{
for|for
control|(
init|;
operator|*
name|pnt
operator|!=
literal|0
condition|;
name|pnt
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|pnt
operator|==
literal|'.'
condition|)
operator|*
name|pnt
operator|=
literal|'$'
expr_stmt|;
block|}
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|/* this routine is used to compare the names of certain types to various  * fixed types that are known by the debugger.  */
end_comment

begin_define
define|#
directive|define
name|type_check
parameter_list|(
name|x
parameter_list|)
value|!strcmp( symbol_name , x )
end_define

begin_comment
comment|/* When defining a structure, this routine is called to find the name of  * the actual structure.  It is assumed that str points to the equal sign  * in the definition, and it moves backward until it finds the start of the  * name.  If it finds a 0, then it knows that this structure def is in the  * outermost level, and thus symbol_name points to the symbol name.  */
end_comment

begin_function
unit|static
name|char
modifier|*
name|get_struct_name
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
name|char
modifier|*
name|pnt
decl_stmt|;
name|pnt
operator|=
name|str
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|pnt
operator|!=
literal|':'
operator|)
operator|&&
operator|(
operator|*
name|pnt
operator|!=
literal|'\0'
operator|)
condition|)
name|pnt
operator|--
expr_stmt|;
if|if
condition|(
operator|*
name|pnt
operator|==
literal|'\0'
condition|)
return|return
name|symbol_name
return|;
operator|*
name|pnt
operator|--
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|pnt
operator|!=
literal|';'
operator|)
operator|&&
operator|(
operator|*
name|pnt
operator|!=
literal|'='
operator|)
condition|)
name|pnt
operator|--
expr_stmt|;
if|if
condition|(
operator|*
name|pnt
operator|==
literal|';'
condition|)
return|return
name|pnt
operator|+
literal|1
return|;
while|while
condition|(
operator|(
operator|*
name|pnt
operator|<
literal|'0'
operator|)
operator|||
operator|(
operator|*
name|pnt
operator|>
literal|'9'
operator|)
condition|)
name|pnt
operator|++
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|pnt
operator|>=
literal|'0'
operator|)
operator|&&
operator|(
operator|*
name|pnt
operator|<=
literal|'9'
operator|)
condition|)
name|pnt
operator|++
expr_stmt|;
return|return
name|pnt
return|;
block|}
end_function

begin_comment
comment|/* search symbol list for type number dbx_type.  Return a pointer to struct */
end_comment

begin_function
specifier|static
name|struct
name|VMS_DBG_Symbol
modifier|*
name|find_symbol
parameter_list|(
name|int
name|dbx_type
parameter_list|)
block|{
name|struct
name|VMS_DBG_Symbol
modifier|*
name|spnt
decl_stmt|;
name|spnt
operator|=
name|VMS_Symbol_type_list
expr_stmt|;
while|while
condition|(
name|spnt
operator|!=
operator|(
expr|struct
name|VMS_DBG_Symbol
operator|*
operator|)
name|NULL
condition|)
block|{
if|if
condition|(
name|spnt
operator|->
name|dbx_type
operator|==
name|dbx_type
condition|)
break|break;
name|spnt
operator|=
name|spnt
operator|->
name|next
expr_stmt|;
block|}
empty_stmt|;
if|if
condition|(
name|spnt
operator|==
operator|(
expr|struct
name|VMS_DBG_Symbol
operator|*
operator|)
name|NULL
condition|)
return|return
literal|0
return|;
comment|/*Dunno what this is*/
return|return
name|spnt
return|;
block|}
end_function

begin_comment
comment|/* Many good programmers cringe when they see a fixed size array - since I am  * using this to generate the various descriptors for the data types present,  * you might argue that the descriptor could overflow the array for a  * complicated variable, and then I am in deep doo-doo.  My answer to this is  * that the debugger records that we write have all sorts of length bytes  * stored in them all over the place, and if we exceed 127 bytes (since the top  * bit indicates data, rather than a command), we are dead anyhow.  So I figure  * why not do this the easy way.  Besides, to get 128 bytes, you need something  * like an array with 10 indicies, or something like  *       char **************************************** var;   * Lets get real.  If some idiot writes programs like that he/she gets what  * they deserve.  (It is possible to overflow the record with a somewhat  * simpler example, like: int (*(*(*(*(*(* sarr6)[1])[1])[2])[3])[4])[5];  * but still...).  And if someone in the peanut gallery wants to know "What  * does VAX-C do with something like this?", I will tell you.  It crashes.  * At least this code has the good sense to convert it to *void.  * In practice, I do not think that this presents too much of a problem, since  * struct/union/enum all use defined types, which sort of terminate the  * definition.  It occurs to me that we could possibly do the same thing with  * arrays and pointers, but I don't know quite how it would be coded.  *  * And now back to the regularly scheduled program...  */
end_comment

begin_define
define|#
directive|define
name|MAX_DEBUG_RECORD
value|128
end_define

begin_decl_stmt
specifier|static
name|char
name|Local
index|[
name|MAX_DEBUG_RECORD
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* buffer for variable descriptor */
end_comment

begin_decl_stmt
specifier|static
name|int
name|Lpnt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* index into Local */
end_comment

begin_decl_stmt
specifier|static
name|char
name|Asuffix
index|[
name|MAX_DEBUG_RECORD
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* buffer for array descriptor */
end_comment

begin_decl_stmt
specifier|static
name|int
name|Apoint
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* index into Asuffix */
end_comment

begin_decl_stmt
specifier|static
name|char
name|overflow
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* flag to indicate we have written too much*/
end_comment

begin_decl_stmt
specifier|static
name|int
name|total_len
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* used to calculate the total length of variable 			descriptor plus array descriptor - used for len byte*/
end_comment

begin_decl_stmt
specifier|static
name|int
name|struct_number
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* counter used to assign indexes to struct 					unions and enums */
end_comment

begin_comment
comment|/* this routine puts info into either Local or Asuffix, depending on the sign  * of size.  The reason is that it is easier to build the variable descriptor  * backwards, while the array descriptor is best built forwards.  In the end  * they get put together, if there is not a struct/union/enum along the way  */
end_comment

begin_macro
name|push
argument_list|(
argument|int value
argument_list|,
argument|int size
argument_list|)
end_macro

begin_block
block|{
name|char
modifier|*
name|pnt
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|size1
decl_stmt|;
name|long
name|int
name|val
decl_stmt|;
name|val
operator|=
name|value
expr_stmt|;
name|pnt
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|val
expr_stmt|;
name|size1
operator|=
name|size
expr_stmt|;
if|if
condition|(
name|size
operator|<
literal|0
condition|)
block|{
name|size1
operator|=
operator|-
name|size
expr_stmt|;
name|pnt
operator|+=
name|size1
operator|-
literal|1
expr_stmt|;
block|}
empty_stmt|;
if|if
condition|(
name|size
operator|<
literal|0
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size1
condition|;
name|i
operator|++
control|)
block|{
name|Local
index|[
name|Lpnt
operator|--
index|]
operator|=
operator|*
name|pnt
operator|--
expr_stmt|;
if|if
condition|(
name|Lpnt
operator|<
literal|0
condition|)
block|{
name|overflow
operator|=
literal|1
expr_stmt|;
name|Lpnt
operator|=
literal|1
expr_stmt|;
block|}
empty_stmt|;
block|}
else|else
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size1
condition|;
name|i
operator|++
control|)
block|{
name|Asuffix
index|[
name|Apoint
operator|++
index|]
operator|=
operator|*
name|pnt
operator|++
expr_stmt|;
if|if
condition|(
name|Apoint
operator|>=
name|MAX_DEBUG_RECORD
condition|)
block|{
name|overflow
operator|=
literal|1
expr_stmt|;
name|Apoint
operator|=
name|MAX_DEBUG_RECORD
operator|-
literal|1
expr_stmt|;
block|}
empty_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* this routine generates the array descriptor for a given array */
end_comment

begin_expr_stmt
specifier|static
name|array_suffix
argument_list|(
argument|struct VMS_DBG_Symbol* spnt2
argument_list|)
block|{ 	struct
name|VMS_DBG_Symbol
operator|*
name|spnt
block|; 	struct
name|VMS_DBG_Symbol
operator|*
name|spnt1
block|;
name|int
name|rank
block|;
name|int
name|total_size
block|;
name|int
name|i
block|;
name|rank
operator|=
literal|0
block|;
name|spnt
operator|=
name|spnt2
block|;
while|while
condition|(
name|spnt
operator|->
name|advanced
operator|!=
name|ARRAY
condition|)
block|{
name|spnt
operator|=
name|find_symbol
argument_list|(
name|spnt
operator|->
name|type2
argument_list|)
expr_stmt|;
if|if
condition|(
name|spnt
operator|==
operator|(
expr|struct
name|VMS_DBG_Symbol
operator|*
operator|)
name|NULL
condition|)
return|return;
block|}
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|spnt1
operator|=
name|spnt
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|spnt1
operator|=
name|spnt
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|total_size
operator|=
literal|1
expr_stmt|;
end_expr_stmt

begin_while
while|while
condition|(
name|spnt1
operator|->
name|advanced
operator|==
name|ARRAY
condition|)
block|{
name|rank
operator|++
expr_stmt|;
name|total_size
operator|*=
operator|(
name|spnt1
operator|->
name|index_max
operator|-
name|spnt1
operator|->
name|index_min
operator|+
literal|1
operator|)
expr_stmt|;
name|spnt1
operator|=
name|find_symbol
argument_list|(
name|spnt1
operator|->
name|type2
argument_list|)
expr_stmt|;
block|}
end_while

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|total_size
operator|=
name|total_size
operator|*
name|spnt1
operator|->
name|data_size
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|push
argument_list|(
name|spnt1
operator|->
name|data_size
argument_list|,
literal|2
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|spnt1
operator|->
name|VMS_type
operator|==
literal|0xa3
condition|)
name|push
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|push
argument_list|(
name|spnt1
operator|->
name|VMS_type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_if

begin_expr_stmt
name|push
argument_list|(
literal|4
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_for
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|6
condition|;
name|i
operator|++
control|)
name|push
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_for

begin_expr_stmt
name|push
argument_list|(
literal|0xc0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|push
argument_list|(
name|rank
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|push
argument_list|(
name|total_size
argument_list|,
literal|4
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|push
argument_list|(
literal|0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|spnt1
operator|=
name|spnt
expr_stmt|;
end_expr_stmt

begin_while
while|while
condition|(
name|spnt1
operator|->
name|advanced
operator|==
name|ARRAY
condition|)
block|{
name|push
argument_list|(
name|spnt1
operator|->
name|index_max
operator|-
name|spnt1
operator|->
name|index_min
operator|+
literal|1
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|spnt1
operator|=
name|find_symbol
argument_list|(
name|spnt1
operator|->
name|type2
argument_list|)
expr_stmt|;
block|}
end_while

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|spnt1
operator|=
name|spnt
expr_stmt|;
end_expr_stmt

begin_while
while|while
condition|(
name|spnt1
operator|->
name|advanced
operator|==
name|ARRAY
condition|)
block|{
name|push
argument_list|(
name|spnt1
operator|->
name|index_min
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|push
argument_list|(
name|spnt1
operator|->
name|index_max
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|spnt1
operator|=
name|find_symbol
argument_list|(
name|spnt1
operator|->
name|type2
argument_list|)
expr_stmt|;
block|}
end_while

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
unit|}
comment|/* this routine generates the start of a variable descriptor based upon  * a struct/union/enum that has yet to be defined.  We define this spot as  * a new location, and save four bytes for the address.  When the struct is  * finally defined, then we can go back and plug in the correct address */
end_comment

begin_macro
unit|static
name|new_forward_ref
argument_list|(
argument|int dbx_type
argument_list|)
end_macro

begin_block
block|{
name|struct
name|forward_ref
modifier|*
name|fpnt
decl_stmt|;
name|fpnt
operator|=
operator|(
expr|struct
name|forward_ref
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|forward_ref
argument_list|)
argument_list|)
expr_stmt|;
name|fpnt
operator|->
name|next
operator|=
name|f_ref_root
expr_stmt|;
name|f_ref_root
operator|=
name|fpnt
expr_stmt|;
name|fpnt
operator|->
name|dbx_type
operator|=
name|dbx_type
expr_stmt|;
name|fpnt
operator|->
name|struc_numb
operator|=
operator|++
name|structure_count
expr_stmt|;
name|fpnt
operator|->
name|resolved
operator|=
literal|'N'
expr_stmt|;
name|push
argument_list|(
literal|3
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|total_len
operator|=
literal|5
expr_stmt|;
name|push
argument_list|(
name|total_len
argument_list|,
operator|-
literal|2
argument_list|)
expr_stmt|;
name|struct_number
operator|=
operator|-
name|fpnt
operator|->
name|struc_numb
expr_stmt|;
block|}
end_block

begin_comment
comment|/* this routine generates the variable descriptor used to describe non-basic  * variables.  It calls itself recursively until it gets to the bottom of it  * all, and then builds the descriptor backwards.  It is easiest to do it this  *way since we must periodically write length bytes, and it is easiest if we know  *the value when it is time to write it.  */
end_comment

begin_function
specifier|static
name|int
name|gen1
parameter_list|(
name|struct
name|VMS_DBG_Symbol
modifier|*
name|spnt
parameter_list|,
name|int
name|array_suffix_len
parameter_list|)
block|{
name|struct
name|VMS_DBG_Symbol
modifier|*
name|spnt1
decl_stmt|;
name|int
name|i
decl_stmt|;
switch|switch
condition|(
name|spnt
operator|->
name|advanced
condition|)
block|{
case|case
name|VOID
case|:
name|push
argument_list|(
name|DBG$C_VOID
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|total_len
operator|+=
literal|1
expr_stmt|;
name|push
argument_list|(
name|total_len
argument_list|,
operator|-
literal|2
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|BASIC
case|:
case|case
name|FUNCTION
case|:
if|if
condition|(
name|array_suffix_len
operator|==
literal|0
condition|)
block|{
name|push
argument_list|(
name|spnt
operator|->
name|VMS_type
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|push
argument_list|(
name|DBG$C_BASIC
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|total_len
operator|=
literal|2
expr_stmt|;
name|push
argument_list|(
name|total_len
argument_list|,
operator|-
literal|2
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
empty_stmt|;
name|push
argument_list|(
literal|0
argument_list|,
operator|-
literal|4
argument_list|)
expr_stmt|;
name|push
argument_list|(
literal|0xfa02
argument_list|,
operator|-
literal|2
argument_list|)
expr_stmt|;
name|total_len
operator|=
operator|-
literal|2
expr_stmt|;
return|return
literal|1
return|;
case|case
name|STRUCT
case|:
case|case
name|UNION
case|:
case|case
name|ENUM
case|:
name|struct_number
operator|=
name|spnt
operator|->
name|struc_numb
expr_stmt|;
if|if
condition|(
name|struct_number
operator|<
literal|0
condition|)
block|{
name|new_forward_ref
argument_list|(
name|spnt
operator|->
name|dbx_type
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|push
argument_list|(
name|DBG$C_STRUCT
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|total_len
operator|=
literal|5
expr_stmt|;
name|push
argument_list|(
name|total_len
argument_list|,
operator|-
literal|2
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
name|POINTER
case|:
name|spnt1
operator|=
name|find_symbol
argument_list|(
name|spnt
operator|->
name|type2
argument_list|)
expr_stmt|;
name|i
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|spnt1
operator|==
operator|(
expr|struct
name|VMS_DBG_Symbol
operator|*
operator|)
name|NULL
condition|)
name|new_forward_ref
argument_list|(
name|spnt
operator|->
name|type2
argument_list|)
expr_stmt|;
else|else
name|i
operator|=
name|gen1
argument_list|(
name|spnt1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
condition|)
block|{
comment|/* (*void) is a special case, do not put pointer suffix*/
name|push
argument_list|(
name|DBG$C_POINTER
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|total_len
operator|+=
literal|3
expr_stmt|;
name|push
argument_list|(
name|total_len
argument_list|,
operator|-
literal|2
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
return|return
literal|1
return|;
case|case
name|ARRAY
case|:
name|spnt1
operator|=
name|spnt
expr_stmt|;
while|while
condition|(
name|spnt1
operator|->
name|advanced
operator|==
name|ARRAY
condition|)
block|{
name|spnt1
operator|=
name|find_symbol
argument_list|(
name|spnt1
operator|->
name|type2
argument_list|)
expr_stmt|;
if|if
condition|(
name|spnt1
operator|==
operator|(
expr|struct
name|VMS_DBG_Symbol
operator|*
operator|)
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"gcc-as warning(debugger output):"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Forward reference error, dbx type %d\n"
argument_list|,
name|spnt
operator|->
name|type2
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
empty_stmt|;
comment|/* It is too late to generate forward references, so the user gets a message.  * This should only happen on a compiler error */
name|i
operator|=
name|gen1
argument_list|(
name|spnt1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|i
operator|=
name|Apoint
expr_stmt|;
name|array_suffix
argument_list|(
name|spnt
argument_list|)
expr_stmt|;
name|array_suffix_len
operator|=
name|Apoint
operator|-
name|i
expr_stmt|;
switch|switch
condition|(
name|spnt1
operator|->
name|advanced
condition|)
block|{
case|case
name|BASIC
case|:
case|case
name|FUNCTION
case|:
break|break;
default|default:
name|push
argument_list|(
literal|0
argument_list|,
operator|-
literal|2
argument_list|)
expr_stmt|;
name|total_len
operator|+=
literal|2
expr_stmt|;
name|push
argument_list|(
name|total_len
argument_list|,
operator|-
literal|2
argument_list|)
expr_stmt|;
name|push
argument_list|(
literal|0xfa
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|push
argument_list|(
literal|0x0101
argument_list|,
operator|-
literal|2
argument_list|)
expr_stmt|;
name|push
argument_list|(
name|DBG$C_COMPLEX_ARRAY
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
name|total_len
operator|+=
name|array_suffix_len
operator|+
literal|8
expr_stmt|;
name|push
argument_list|(
name|total_len
argument_list|,
operator|-
literal|2
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
block|}
end_function

begin_comment
comment|/* this generates a suffix for a variable.  If it is not a defined type yet,  * then dbx_type contains the type we are expecting so we can generate a  * forward reference.  This calls gen1 to build most of the descriptor, and  * then it puts the icing on at the end.  It then dumps whatever is needed  * to get a complete descriptor (i.e. struct reference, array suffix ).  */
end_comment

begin_expr_stmt
specifier|static
name|generate_suffix
argument_list|(
argument|struct VMS_DBG_Symbol * spnt
argument_list|,
argument|int dbx_type
argument_list|)
block|{
name|int
name|ilen
block|;
name|int
name|i
block|;
name|char
name|pvoid
index|[
literal|6
index|]
operator|=
block|{
literal|5
block|,
literal|0xaf
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|5
block|}
block|; 	struct
name|VMS_DBG_Symbol
operator|*
name|spnt1
block|;
name|Apoint
operator|=
literal|0
block|;
name|Lpnt
operator|=
name|MAX_DEBUG_RECORD
operator|-
literal|1
block|;
name|total_len
operator|=
literal|0
block|;
name|struct_number
operator|=
literal|0
block|;
name|overflow
operator|=
literal|0
block|;
if|if
condition|(
name|spnt
operator|==
operator|(
expr|struct
name|VMS_DBG_Symbol
operator|*
operator|)
name|NULL
condition|)
name|new_forward_ref
argument_list|(
name|dbx_type
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|spnt
operator|->
name|VMS_type
operator|!=
literal|0xa3
condition|)
return|return
literal|0
return|;
comment|/* no suffix needed */
name|gen1
argument_list|(
name|spnt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|push
argument_list|(
literal|0x00af
argument_list|,
operator|-
literal|2
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|total_len
operator|+=
literal|4
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|push
argument_list|(
name|total_len
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* if the variable descriptor overflows the record, output a descriptor for  * a pointer to void.  */
end_comment

begin_if
if|if
condition|(
operator|(
name|total_len
operator|>=
name|MAX_DEBUG_RECORD
operator|)
operator|||
name|overflow
condition|)
block|{
name|printf
argument_list|(
literal|" Variable descriptor %d too complicated. Defined as *void "
argument_list|,
name|spnt
operator|->
name|dbx_type
argument_list|)
expr_stmt|;
name|VMS_Store_Immediate_Data
argument_list|(
name|pvoid
argument_list|,
literal|6
argument_list|,
name|OBJ$C_DBG
argument_list|)
expr_stmt|;
return|return;
block|}
end_if

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|i
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_while
while|while
condition|(
name|Lpnt
operator|<
name|MAX_DEBUG_RECORD
operator|-
literal|1
condition|)
name|Local
index|[
name|i
operator|++
index|]
operator|=
name|Local
index|[
operator|++
name|Lpnt
index|]
expr_stmt|;
end_while

begin_expr_stmt
name|Lpnt
operator|=
name|i
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* we use this for a reference to a structure that has already been defined */
end_comment

begin_if
if|if
condition|(
name|struct_number
operator|>
literal|0
condition|)
block|{
name|VMS_Store_Immediate_Data
argument_list|(
name|Local
argument_list|,
name|Lpnt
argument_list|,
name|OBJ$C_DBG
argument_list|)
expr_stmt|;
name|Lpnt
operator|=
literal|0
expr_stmt|;
name|VMS_Store_Struct
argument_list|(
name|struct_number
argument_list|)
expr_stmt|;
block|}
end_if

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/* we use this for a forward reference to a structure that has yet to be *defined.  We store four bytes of zero to make room for the actual address once * it is known */
end_comment

begin_if
if|if
condition|(
name|struct_number
operator|<
literal|0
condition|)
block|{
name|struct_number
operator|=
operator|-
name|struct_number
expr_stmt|;
name|VMS_Store_Immediate_Data
argument_list|(
name|Local
argument_list|,
name|Lpnt
argument_list|,
name|OBJ$C_DBG
argument_list|)
expr_stmt|;
name|Lpnt
operator|=
literal|0
expr_stmt|;
name|VMS_Def_Struct
argument_list|(
name|struct_number
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
name|Local
index|[
name|Lpnt
operator|++
index|]
operator|=
literal|0
expr_stmt|;
name|VMS_Store_Immediate_Data
argument_list|(
name|Local
argument_list|,
name|Lpnt
argument_list|,
name|OBJ$C_DBG
argument_list|)
expr_stmt|;
name|Lpnt
operator|=
literal|0
expr_stmt|;
block|}
end_if

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|i
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_while
while|while
condition|(
name|i
operator|<
name|Apoint
condition|)
name|Local
index|[
name|Lpnt
operator|++
index|]
operator|=
name|Asuffix
index|[
name|i
operator|++
index|]
expr_stmt|;
end_while

begin_if
if|if
condition|(
name|Lpnt
operator|!=
literal|0
condition|)
name|VMS_Store_Immediate_Data
argument_list|(
name|Local
argument_list|,
name|Lpnt
argument_list|,
name|OBJ$C_DBG
argument_list|)
expr_stmt|;
end_if

begin_expr_stmt
name|Lpnt
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|/* This routine generates a symbol definition for a C sybmol for the debugger.  * It takes a psect and offset for global symbols - if psect< 0, then this is  * a local variable and the offset is relative to FP.  In this case it can  * be either a variable (Offset< 0) or a parameter (Offset> 0).  */
end_comment

begin_expr_stmt
unit|VMS_DBG_record
operator|(
expr|struct
name|VMS_DBG_Symbol
operator|*
name|spnt
operator|,
name|int
name|Psect
operator|,
name|int
name|Offset
operator|,
name|char
operator|*
name|Name
operator|)
block|{
name|char
operator|*
name|pnt
block|;
name|int
name|j
block|;
name|int
name|maxlen
block|;
name|int
name|i
operator|=
literal|0
block|;
if|if
condition|(
name|Psect
operator|<
literal|0
condition|)
block|{
comment|/* this is a local variable, referenced to SP */
name|maxlen
operator|=
literal|7
operator|+
name|strlen
argument_list|(
name|Name
argument_list|)
expr_stmt|;
name|Local
index|[
name|i
operator|++
index|]
operator|=
name|maxlen
expr_stmt|;
name|Local
index|[
name|i
operator|++
index|]
operator|=
name|spnt
operator|->
name|VMS_type
expr_stmt|;
if|if
condition|(
name|Offset
operator|>
literal|0
condition|)
name|Local
index|[
name|i
operator|++
index|]
operator|=
name|DBG$C_FUNCTION_PARAMETER
expr_stmt|;
else|else
name|Local
index|[
name|i
operator|++
index|]
operator|=
name|DBG$C_LOCAL_SYM
expr_stmt|;
name|pnt
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|Offset
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|4
condition|;
name|j
operator|++
control|)
name|Local
index|[
name|i
operator|++
index|]
operator|=
operator|*
name|pnt
operator|++
expr_stmt|;
comment|/* copy the offset */
block|}
end_expr_stmt

begin_else
else|else
block|{
name|maxlen
operator|=
literal|7
operator|+
name|strlen
argument_list|(
name|Name
argument_list|)
expr_stmt|;
comment|/* symbols fixed in memory */
name|Local
index|[
name|i
operator|++
index|]
operator|=
literal|7
operator|+
name|strlen
argument_list|(
name|Name
argument_list|)
expr_stmt|;
name|Local
index|[
name|i
operator|++
index|]
operator|=
name|spnt
operator|->
name|VMS_type
expr_stmt|;
name|Local
index|[
name|i
operator|++
index|]
operator|=
literal|1
expr_stmt|;
name|VMS_Store_Immediate_Data
argument_list|(
name|Local
argument_list|,
name|i
argument_list|,
name|OBJ$C_DBG
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|VMS_Set_Data
argument_list|(
name|Psect
argument_list|,
name|Offset
argument_list|,
name|OBJ$C_DBG
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_else

begin_expr_stmt
name|Local
index|[
name|i
operator|++
index|]
operator|=
name|strlen
argument_list|(
name|Name
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|pnt
operator|=
name|Name
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|fix_name
argument_list|(
name|pnt
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* if there are bad characters in name, convert them */
end_comment

begin_while
while|while
condition|(
operator|*
name|pnt
operator|!=
literal|'\0'
condition|)
name|Local
index|[
name|i
operator|++
index|]
operator|=
operator|*
name|pnt
operator|++
expr_stmt|;
end_while

begin_expr_stmt
name|VMS_Store_Immediate_Data
argument_list|(
name|Local
argument_list|,
name|i
argument_list|,
name|OBJ$C_DBG
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|spnt
operator|->
name|VMS_type
operator|==
name|DBG$C_ADVANCED_TYPE
condition|)
name|generate_suffix
argument_list|(
name|spnt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_if

begin_comment
unit|}
comment|/* This routine parses the stabs entries in order to make the definition  * for the debugger of local symbols and function parameters  */
end_comment

begin_macro
unit|int
name|VMS_local_stab_Parse
argument_list|(
argument|symbolS * sp
argument_list|)
end_macro

begin_block
block|{
name|char
modifier|*
name|pnt
decl_stmt|;
name|char
modifier|*
name|pnt1
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
name|struct
name|VMS_DBG_Symbol
modifier|*
name|spnt
decl_stmt|;
name|struct
name|VMS_Symbol
modifier|*
name|vsp
decl_stmt|;
name|int
name|dbx_type
decl_stmt|;
name|int
name|VMS_type
decl_stmt|;
name|dbx_type
operator|=
literal|0
expr_stmt|;
name|str
operator|=
name|sp
operator|->
name|sy_nlist
operator|.
name|n_un
operator|.
name|n_name
expr_stmt|;
name|pnt
operator|=
operator|(
name|char
operator|*
operator|)
name|strchr
argument_list|(
name|str
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|pnt
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
return|return;
comment|/* no colon present */
name|pnt1
operator|=
name|pnt
operator|++
expr_stmt|;
comment|/* save this for later, and skip colon */
if|if
condition|(
operator|*
name|pnt
operator|==
literal|'c'
condition|)
return|return
literal|0
return|;
comment|/* ignore static constants */
comment|/* there is one little catch that we must be aware of.  Sometimes function  * parameters are optimized into registers, and the compiler, in its infiite  * wisdom outputs stabs records for *both*.  In general we want to use the  * register if it is present, so we must search the rest of the symbols for   * this function to see if this parameter is assigned to a register.  */
block|{
name|char
modifier|*
name|str1
decl_stmt|;
name|char
modifier|*
name|pnt2
decl_stmt|;
name|symbolS
modifier|*
name|sp1
decl_stmt|;
if|if
condition|(
operator|*
name|pnt
operator|==
literal|'p'
condition|)
block|{
for|for
control|(
name|sp1
operator|=
name|sp
operator|->
name|sy_next
init|;
name|sp1
condition|;
name|sp1
operator|=
name|sp1
operator|->
name|sy_next
control|)
block|{
if|if
condition|(
operator|(
name|sp1
operator|->
name|sy_nlist
operator|.
name|n_type
operator|&
name|N_STAB
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|(
name|unsigned
name|char
operator|)
name|sp1
operator|->
name|sy_nlist
operator|.
name|n_type
operator|==
name|N_FUN
condition|)
break|break;
if|if
condition|(
operator|(
name|unsigned
name|char
operator|)
name|sp1
operator|->
name|sy_nlist
operator|.
name|n_type
operator|!=
name|N_RSYM
condition|)
continue|continue;
name|str1
operator|=
name|sp1
operator|->
name|sy_nlist
operator|.
name|n_un
operator|.
name|n_name
expr_stmt|;
comment|/* and get the name */
name|pnt2
operator|=
name|str
expr_stmt|;
while|while
condition|(
operator|*
name|pnt2
operator|!=
literal|':'
condition|)
block|{
if|if
condition|(
operator|*
name|pnt2
operator|!=
operator|*
name|str1
condition|)
break|break;
name|pnt2
operator|++
expr_stmt|;
name|str1
operator|++
expr_stmt|;
block|}
empty_stmt|;
if|if
condition|(
operator|(
operator|*
name|str1
operator|!=
literal|':'
operator|)
operator|||
operator|(
operator|*
name|pnt2
operator|!=
literal|':'
operator|)
condition|)
continue|continue;
return|return;
comment|/* they are the same!  lets skip this one */
block|}
empty_stmt|;
comment|/* for */
comment|/* first find the dbx symbol type from list, and then find VMS type */
name|pnt
operator|++
expr_stmt|;
comment|/* skip p in case no register */
block|}
empty_stmt|;
comment|/* if */
block|}
empty_stmt|;
comment|/* p block */
name|pnt
operator|=
name|cvt_integer
argument_list|(
name|pnt
argument_list|,
operator|&
name|dbx_type
argument_list|)
expr_stmt|;
name|spnt
operator|=
name|find_symbol
argument_list|(
name|dbx_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|spnt
operator|==
operator|(
expr|struct
name|VMS_DBG_Symbol
operator|*
operator|)
name|NULL
condition|)
return|return
literal|0
return|;
comment|/*Dunno what this is*/
operator|*
name|pnt1
operator|=
literal|'\0'
expr_stmt|;
name|VMS_DBG_record
argument_list|(
name|spnt
argument_list|,
operator|-
literal|1
argument_list|,
name|sp
operator|->
name|sy_nlist
operator|.
name|n_value
argument_list|,
name|str
argument_list|)
expr_stmt|;
operator|*
name|pnt1
operator|=
literal|':'
expr_stmt|;
comment|/* and restore the string */
return|return
literal|1
return|;
block|}
end_block

begin_comment
comment|/* this routine parses a stabs entry to find the information required to define  * a variable.  It is used for global and static variables.   * Basically we need to know the address of the symbol.  With older versions  * of the compiler, const symbols are  * treated differently, in that if they are global they are written into the  * text psect.  The global symbol entry for such a const is actually written  * as a program entry point (Yuk!!), so if we cannot find a symbol in the list  * of psects, we must search the entry points as well.  static consts are even  * harder, since they are never assigned a memory address.  The compiler passes  * a stab to tell us the value, but I am not sure what to do with it.  */
end_comment

begin_expr_stmt
specifier|static
name|gave_compiler_message
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|VMS_stab_parse
parameter_list|(
name|symbolS
modifier|*
name|sp
parameter_list|,
name|char
name|expected_type
parameter_list|,
name|int
name|type1
parameter_list|,
name|int
name|type2
parameter_list|,
name|int
name|Text_Psect
parameter_list|)
block|{
name|char
modifier|*
name|pnt
decl_stmt|;
name|char
modifier|*
name|pnt1
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
name|symbolS
modifier|*
name|sp1
decl_stmt|;
name|struct
name|VMS_DBG_Symbol
modifier|*
name|spnt
decl_stmt|;
name|struct
name|VMS_Symbol
modifier|*
name|vsp
decl_stmt|;
name|int
name|dbx_type
decl_stmt|;
name|int
name|VMS_type
decl_stmt|;
name|dbx_type
operator|=
literal|0
expr_stmt|;
name|str
operator|=
name|sp
operator|->
name|sy_nlist
operator|.
name|n_un
operator|.
name|n_name
expr_stmt|;
name|pnt
operator|=
operator|(
name|char
operator|*
operator|)
name|strchr
argument_list|(
name|str
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|pnt
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
return|return;
comment|/* no colon present */
name|pnt1
operator|=
name|pnt
expr_stmt|;
comment|/* save this for later*/
name|pnt
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|pnt
operator|==
name|expected_type
condition|)
block|{
name|pnt
operator|=
name|cvt_integer
argument_list|(
name|pnt
operator|+
literal|1
argument_list|,
operator|&
name|dbx_type
argument_list|)
expr_stmt|;
name|spnt
operator|=
name|find_symbol
argument_list|(
name|dbx_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|spnt
operator|==
operator|(
expr|struct
name|VMS_DBG_Symbol
operator|*
operator|)
name|NULL
condition|)
return|return
literal|0
return|;
comment|/*Dunno what this is*/
comment|/* now we need to search the symbol table to find the psect and offset for  * this variable.  */
operator|*
name|pnt1
operator|=
literal|'\0'
expr_stmt|;
name|vsp
operator|=
name|VMS_Symbols
expr_stmt|;
while|while
condition|(
name|vsp
operator|!=
operator|(
expr|struct
name|VMS_Symbol
operator|*
operator|)
name|NULL
condition|)
block|{
name|pnt
operator|=
name|vsp
operator|->
name|Symbol
operator|->
name|sy_nlist
operator|.
name|n_un
operator|.
name|n_name
expr_stmt|;
if|if
condition|(
name|pnt
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
if|if
condition|(
operator|*
name|pnt
operator|++
operator|==
literal|'_'
condition|)
comment|/* make sure name is the same, and make sure correct symbol type */
if|if
condition|(
operator|(
name|strlen
argument_list|(
name|pnt
argument_list|)
operator|==
name|strlen
argument_list|(
name|str
argument_list|)
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|pnt
argument_list|,
name|str
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|vsp
operator|->
name|Symbol
operator|->
name|sy_type
operator|==
name|type1
operator|)
operator|||
operator|(
name|vsp
operator|->
name|Symbol
operator|->
name|sy_type
operator|==
name|type2
operator|)
operator|)
condition|)
break|break;
name|vsp
operator|=
name|vsp
operator|->
name|Next
expr_stmt|;
block|}
empty_stmt|;
if|if
condition|(
name|vsp
operator|!=
operator|(
expr|struct
name|VMS_Symbol
operator|*
operator|)
name|NULL
condition|)
block|{
name|VMS_DBG_record
argument_list|(
name|spnt
argument_list|,
name|vsp
operator|->
name|Psect_Index
argument_list|,
name|vsp
operator|->
name|Psect_Offset
argument_list|,
name|str
argument_list|)
expr_stmt|;
operator|*
name|pnt1
operator|=
literal|':'
expr_stmt|;
comment|/* and restore the string */
return|return
literal|1
return|;
block|}
empty_stmt|;
comment|/* the symbol was not in the symbol list, but it may be an "entry point"    if it was a constant */
for|for
control|(
name|sp1
operator|=
name|symbol_rootP
init|;
name|sp1
condition|;
name|sp1
operator|=
name|sp1
operator|->
name|sy_next
control|)
block|{
comment|/* 		   *	Dispatch on STAB type 		   */
if|if
condition|(
name|sp1
operator|->
name|sy_type
operator|!=
operator|(
name|N_TEXT
operator||
name|N_EXT
operator|)
operator|&&
name|sp1
operator|->
name|sy_type
operator|!=
name|N_TEXT
condition|)
continue|continue;
name|pnt
operator|=
name|sp1
operator|->
name|sy_nlist
operator|.
name|n_un
operator|.
name|n_name
expr_stmt|;
if|if
condition|(
operator|*
name|pnt
operator|==
literal|'_'
condition|)
name|pnt
operator|++
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|pnt
argument_list|,
name|str
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|gave_compiler_message
operator|&&
name|expected_type
operator|==
literal|'G'
condition|)
block|{
name|printf
argument_list|(
literal|"***Warning - the assembly code generated by the compiler has placed\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"global constant(s) in the text psect.  These will not be available to\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"other modules, since this is not the correct way to handle this. You\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"have two options: 1) get a patched compiler that does not put global\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"constants in the text psect, or 2) remove the 'const' keyword from\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"definitions of global variables in your source module(s).  Don't say\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"I didn't warn you!"
argument_list|)
expr_stmt|;
name|gave_compiler_message
operator|=
literal|1
expr_stmt|;
block|}
empty_stmt|;
name|VMS_DBG_record
argument_list|(
name|spnt
argument_list|,
name|Text_Psect
argument_list|,
name|sp1
operator|->
name|sy_nlist
operator|.
name|n_value
argument_list|,
name|str
argument_list|)
expr_stmt|;
operator|*
name|pnt1
operator|=
literal|':'
expr_stmt|;
operator|*
operator|(
name|sp1
operator|->
name|sy_nlist
operator|.
name|n_un
operator|.
name|n_name
operator|)
operator|=
literal|'L'
expr_stmt|;
comment|/* fool assembler to not output this 					 * as a routine in the TBT */
return|return
literal|1
return|;
block|}
empty_stmt|;
block|}
empty_stmt|;
block|}
empty_stmt|;
operator|*
name|pnt1
operator|=
literal|':'
expr_stmt|;
comment|/* and restore the string */
return|return
literal|0
return|;
block|}
end_function

begin_macro
name|VMS_GSYM_Parse
argument_list|(
argument|symbolS * sp
argument_list|,
argument|int Text_Psect
argument_list|)
end_macro

begin_block
block|{
comment|/* Global variables */
name|VMS_stab_parse
argument_list|(
name|sp
argument_list|,
literal|'G'
argument_list|,
operator|(
name|N_UNDF
operator||
name|N_EXT
operator|)
argument_list|,
operator|(
name|N_DATA
operator||
name|N_EXT
operator|)
argument_list|,
name|Text_Psect
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|VMS_LCSYM_Parse
argument_list|(
argument|symbolS * sp
argument_list|,
argument|int Text_Psect
argument_list|)
end_macro

begin_block
block|{
comment|/* Static symbols - uninitialized */
name|VMS_stab_parse
argument_list|(
name|sp
argument_list|,
literal|'S'
argument_list|,
name|N_BSS
argument_list|,
operator|-
literal|1
argument_list|,
name|Text_Psect
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|VMS_STSYM_Parse
argument_list|(
argument|symbolS * sp
argument_list|,
argument|int Text_Psect
argument_list|)
end_macro

begin_block
block|{
comment|/*Static symbols - initialized */
name|VMS_stab_parse
argument_list|(
name|sp
argument_list|,
literal|'S'
argument_list|,
name|N_DATA
argument_list|,
operator|-
literal|1
argument_list|,
name|Text_Psect
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* for register symbols, we must figure out what range of addresses within the  * psect are valid. We will use the brackets in the stab directives to give us  * guidance as to the PC range that this variable is in scope.  I am still not  * completely comfortable with this but as I learn more, I seem to get a better  * handle on what is going on.  * Caveat Emptor.  */
end_comment

begin_macro
name|VMS_RSYM_Parse
argument_list|(
argument|symbolS * sp
argument_list|,
argument|symbolS * Current_Routine
argument_list|,
argument|int Text_Psect
argument_list|)
end_macro

begin_block
block|{
name|char
modifier|*
name|pnt
decl_stmt|;
name|char
modifier|*
name|pnt1
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
name|int
name|dbx_type
decl_stmt|;
name|struct
name|VMS_DBG_Symbol
modifier|*
name|spnt
decl_stmt|;
name|int
name|j
decl_stmt|;
name|int
name|maxlen
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|int
name|bcnt
init|=
literal|0
decl_stmt|;
name|int
name|Min_Offset
init|=
operator|-
literal|1
decl_stmt|;
comment|/* min PC of validity */
name|int
name|Max_Offset
init|=
literal|0
decl_stmt|;
comment|/* max PC of validity */
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
for|for
control|(
name|symbolP
operator|=
name|sp
init|;
name|symbolP
condition|;
name|symbolP
operator|=
name|symbolP
operator|->
name|sy_next
control|)
block|{
comment|/* 		   *	Dispatch on STAB type 		   */
switch|switch
condition|(
operator|(
name|unsigned
name|char
operator|)
name|symbolP
operator|->
name|sy_type
condition|)
block|{
case|case
name|N_LBRAC
case|:
if|if
condition|(
name|bcnt
operator|++
operator|==
literal|0
condition|)
name|Min_Offset
operator|=
name|symbolP
operator|->
name|sy_nlist
operator|.
name|n_value
expr_stmt|;
break|break;
case|case
name|N_RBRAC
case|:
if|if
condition|(
operator|--
name|bcnt
operator|==
literal|0
condition|)
name|Max_Offset
operator|=
name|symbolP
operator|->
name|sy_nlist
operator|.
name|n_value
operator|-
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|Min_Offset
operator|!=
operator|-
literal|1
operator|)
operator|&&
operator|(
name|bcnt
operator|==
literal|0
operator|)
condition|)
break|break;
if|if
condition|(
operator|(
name|unsigned
name|char
operator|)
name|symbolP
operator|->
name|sy_type
operator|==
name|N_FUN
condition|)
break|break;
block|}
comment|/* check to see that the addresses were defined.  If not, then there were no  * brackets in the function, and we must try to search for the next function  * Since functions can be in any order, we should search all of the symbol list  * to find the correct ending address. */
if|if
condition|(
name|Min_Offset
operator|==
operator|-
literal|1
condition|)
block|{
name|int
name|Max_Source_Offset
decl_stmt|;
name|int
name|This_Offset
decl_stmt|;
name|Min_Offset
operator|=
name|sp
operator|->
name|sy_nlist
operator|.
name|n_value
expr_stmt|;
for|for
control|(
name|symbolP
operator|=
name|symbol_rootP
init|;
name|symbolP
condition|;
name|symbolP
operator|=
name|symbolP
operator|->
name|sy_next
control|)
block|{
comment|/* 		   *	Dispatch on STAB type 		   */
name|This_Offset
operator|=
name|symbolP
operator|->
name|sy_nlist
operator|.
name|n_value
expr_stmt|;
switch|switch
condition|(
name|symbolP
operator|->
name|sy_type
condition|)
block|{
case|case
name|N_TEXT
operator||
name|N_EXT
case|:
if|if
condition|(
operator|(
name|This_Offset
operator|>
name|Min_Offset
operator|)
operator|&&
operator|(
name|This_Offset
operator|<
name|Max_Offset
operator|)
condition|)
name|Max_Offset
operator|=
name|This_Offset
expr_stmt|;
break|break;
case|case
name|N_SLINE
case|:
if|if
condition|(
name|This_Offset
operator|>
name|Max_Source_Offset
condition|)
name|Max_Source_Offset
operator|=
name|This_Offset
expr_stmt|;
block|}
block|}
comment|/* if this is the last routine, then we use the PC of the last source line  * as a marker of the max PC for which this reg is valid */
if|if
condition|(
name|Max_Offset
operator|==
literal|0x7fffffff
condition|)
name|Max_Offset
operator|=
name|Max_Source_Offset
expr_stmt|;
block|}
empty_stmt|;
name|dbx_type
operator|=
literal|0
expr_stmt|;
name|str
operator|=
name|sp
operator|->
name|sy_nlist
operator|.
name|n_un
operator|.
name|n_name
expr_stmt|;
name|pnt
operator|=
operator|(
name|char
operator|*
operator|)
name|strchr
argument_list|(
name|str
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|pnt
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
return|return;
comment|/* no colon present */
name|pnt1
operator|=
name|pnt
expr_stmt|;
comment|/* save this for later*/
name|pnt
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|pnt
operator|!=
literal|'r'
condition|)
return|return
literal|0
return|;
name|pnt
operator|=
name|cvt_integer
argument_list|(
name|pnt
operator|+
literal|1
argument_list|,
operator|&
name|dbx_type
argument_list|)
expr_stmt|;
name|spnt
operator|=
name|find_symbol
argument_list|(
name|dbx_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|spnt
operator|==
operator|(
expr|struct
name|VMS_DBG_Symbol
operator|*
operator|)
name|NULL
condition|)
return|return
literal|0
return|;
comment|/*Dunno what this is yet*/
operator|*
name|pnt1
operator|=
literal|'\0'
expr_stmt|;
name|maxlen
operator|=
literal|25
operator|+
name|strlen
argument_list|(
name|sp
operator|->
name|sy_nlist
operator|.
name|n_un
operator|.
name|n_name
argument_list|)
expr_stmt|;
name|Local
index|[
name|i
operator|++
index|]
operator|=
name|maxlen
expr_stmt|;
name|Local
index|[
name|i
operator|++
index|]
operator|=
name|spnt
operator|->
name|VMS_type
expr_stmt|;
name|Local
index|[
name|i
operator|++
index|]
operator|=
literal|0xfb
expr_stmt|;
name|Local
index|[
name|i
operator|++
index|]
operator|=
name|strlen
argument_list|(
name|sp
operator|->
name|sy_nlist
operator|.
name|n_un
operator|.
name|n_name
argument_list|)
operator|+
literal|1
expr_stmt|;
name|Local
index|[
name|i
operator|++
index|]
operator|=
literal|0x00
expr_stmt|;
name|Local
index|[
name|i
operator|++
index|]
operator|=
literal|0x00
expr_stmt|;
name|Local
index|[
name|i
operator|++
index|]
operator|=
literal|0x00
expr_stmt|;
name|Local
index|[
name|i
operator|++
index|]
operator|=
name|strlen
argument_list|(
name|sp
operator|->
name|sy_nlist
operator|.
name|n_un
operator|.
name|n_name
argument_list|)
expr_stmt|;
name|pnt
operator|=
name|sp
operator|->
name|sy_nlist
operator|.
name|n_un
operator|.
name|n_name
expr_stmt|;
name|fix_name
argument_list|(
name|pnt
argument_list|)
expr_stmt|;
comment|/* if there are bad characters in name, convert them */
while|while
condition|(
operator|*
name|pnt
operator|!=
literal|'\0'
condition|)
name|Local
index|[
name|i
operator|++
index|]
operator|=
operator|*
name|pnt
operator|++
expr_stmt|;
name|Local
index|[
name|i
operator|++
index|]
operator|=
literal|0xfd
expr_stmt|;
name|Local
index|[
name|i
operator|++
index|]
operator|=
literal|0x0f
expr_stmt|;
name|Local
index|[
name|i
operator|++
index|]
operator|=
literal|0x00
expr_stmt|;
name|Local
index|[
name|i
operator|++
index|]
operator|=
literal|0x03
expr_stmt|;
name|Local
index|[
name|i
operator|++
index|]
operator|=
literal|0x01
expr_stmt|;
name|VMS_Store_Immediate_Data
argument_list|(
name|Local
argument_list|,
name|i
argument_list|,
name|OBJ$C_DBG
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|VMS_Set_Data
argument_list|(
name|Text_Psect
argument_list|,
name|Min_Offset
argument_list|,
name|OBJ$C_DBG
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|VMS_Set_Data
argument_list|(
name|Text_Psect
argument_list|,
name|Max_Offset
argument_list|,
name|OBJ$C_DBG
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|Local
index|[
name|i
operator|++
index|]
operator|=
literal|0x03
expr_stmt|;
name|Local
index|[
name|i
operator|++
index|]
operator|=
name|sp
operator|->
name|sy_nlist
operator|.
name|n_value
expr_stmt|;
name|Local
index|[
name|i
operator|++
index|]
operator|=
literal|0x00
expr_stmt|;
name|Local
index|[
name|i
operator|++
index|]
operator|=
literal|0x00
expr_stmt|;
name|Local
index|[
name|i
operator|++
index|]
operator|=
literal|0x00
expr_stmt|;
name|VMS_Store_Immediate_Data
argument_list|(
name|Local
argument_list|,
name|i
argument_list|,
name|OBJ$C_DBG
argument_list|)
expr_stmt|;
operator|*
name|pnt1
operator|=
literal|':'
expr_stmt|;
if|if
condition|(
name|spnt
operator|->
name|VMS_type
operator|==
name|DBG$C_ADVANCED_TYPE
condition|)
name|generate_suffix
argument_list|(
name|spnt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* this function examines a structure definition, checking all of the elements  * to make sure that all of them are fully defined.  The only thing that we  * kick out are arrays of undefined structs, since we do not know how big  * they are.  All others we can handle with a normal forward reference.  */
end_comment

begin_function
specifier|static
name|int
name|forward_reference
parameter_list|(
name|char
modifier|*
name|pnt
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|VMS_DBG_Symbol
modifier|*
name|spnt
decl_stmt|;
name|struct
name|VMS_DBG_Symbol
modifier|*
name|spnt1
decl_stmt|;
name|pnt
operator|=
name|cvt_integer
argument_list|(
name|pnt
operator|+
literal|1
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|pnt
operator|==
literal|';'
condition|)
return|return
literal|0
return|;
comment|/* no forward references */
do|do
block|{
name|pnt
operator|=
operator|(
name|char
operator|*
operator|)
name|strchr
argument_list|(
name|pnt
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
name|pnt
operator|=
name|cvt_integer
argument_list|(
name|pnt
operator|+
literal|1
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
name|spnt
operator|=
name|find_symbol
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|spnt
operator|==
operator|(
expr|struct
name|VMS_DBG_Symbol
operator|*
operator|)
name|NULL
condition|)
return|return
literal|0
return|;
while|while
condition|(
operator|(
name|spnt
operator|->
name|advanced
operator|==
name|POINTER
operator|)
operator|||
operator|(
name|spnt
operator|->
name|advanced
operator|==
name|ARRAY
operator|)
condition|)
block|{
name|i
operator|=
name|spnt
operator|->
name|type2
expr_stmt|;
name|spnt1
operator|=
name|find_symbol
argument_list|(
name|spnt
operator|->
name|type2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|spnt
operator|->
name|advanced
operator|==
name|ARRAY
operator|)
operator|&&
operator|(
name|spnt1
operator|==
operator|(
expr|struct
name|VMS_DBG_Symbol
operator|*
operator|)
name|NULL
operator|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|spnt1
operator|==
operator|(
expr|struct
name|VMS_DBG_Symbol
operator|*
operator|)
name|NULL
condition|)
break|break;
name|spnt
operator|=
name|spnt1
expr_stmt|;
block|}
empty_stmt|;
name|pnt
operator|=
name|cvt_integer
argument_list|(
name|pnt
operator|+
literal|1
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
name|pnt
operator|=
name|cvt_integer
argument_list|(
name|pnt
operator|+
literal|1
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|*
operator|++
name|pnt
operator|!=
literal|';'
condition|)
do|;
return|return
literal|0
return|;
comment|/* no forward refences found */
block|}
end_function

begin_comment
comment|/* This routine parses the stabs directives to find any definitions of dbx type  * numbers.  It makes a note of all of them, creating a structure element  * of VMS_DBG_Symbol that describes it.  This also generates the info for the  * debugger that describes the struct/union/enum, so that further references  * to these data types will be by number  * 	We have to process pointers right away, since there can be references  * to them later in the same stabs directive.  We cannot have forward  * references to pointers, (but we can have a forward reference to a pointer to  * a structure/enum/union) and this is why we process them immediately.  * After we process the pointer, then we search for defs that are nested even  * deeper.  */
end_comment

begin_function
specifier|static
name|int
name|VMS_typedef_parse
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
name|char
modifier|*
name|pnt
decl_stmt|;
name|char
modifier|*
name|pnt1
decl_stmt|;
name|char
modifier|*
name|pnt2
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|dtype
decl_stmt|;
name|struct
name|forward_ref
modifier|*
name|fpnt
decl_stmt|;
name|int
name|i1
decl_stmt|,
name|i2
decl_stmt|,
name|i3
decl_stmt|;
name|int
name|convert_integer
decl_stmt|;
name|struct
name|VMS_DBG_Symbol
modifier|*
name|spnt
decl_stmt|;
name|struct
name|VMS_DBG_Symbol
modifier|*
name|spnt1
decl_stmt|;
comment|/* check for any nested def's */
name|pnt
operator|=
operator|(
name|char
operator|*
operator|)
name|strchr
argument_list|(
name|str
operator|+
literal|1
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pnt
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
operator|&&
operator|(
operator|*
operator|(
name|str
operator|+
literal|1
operator|)
operator|!=
literal|'*'
operator|)
condition|)
if|if
condition|(
name|VMS_typedef_parse
argument_list|(
name|pnt
argument_list|)
operator|==
literal|1
condition|)
return|return
literal|1
return|;
comment|/* now find dbx_type of entry */
name|pnt
operator|=
name|str
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|pnt
operator|==
literal|'c'
condition|)
block|{
comment|/* check for static constants */
operator|*
name|str
operator|=
literal|'\0'
expr_stmt|;
comment|/* for now we ignore them */
return|return
literal|0
return|;
block|}
empty_stmt|;
while|while
condition|(
operator|(
operator|*
name|pnt
operator|<=
literal|'9'
operator|)
operator|&&
operator|(
operator|*
name|pnt
operator|>=
literal|'0'
operator|)
condition|)
name|pnt
operator|--
expr_stmt|;
name|pnt
operator|++
expr_stmt|;
comment|/* and get back to the number */
name|cvt_integer
argument_list|(
name|pnt
argument_list|,
operator|&
name|i1
argument_list|)
expr_stmt|;
name|spnt
operator|=
name|find_symbol
argument_list|(
name|i1
argument_list|)
expr_stmt|;
comment|/* first we see if this has been defined already, due to a forward reference*/
if|if
condition|(
name|spnt
operator|==
operator|(
expr|struct
name|VMS_DBG_Symbol
operator|*
operator|)
name|NULL
condition|)
block|{
if|if
condition|(
name|VMS_Symbol_type_list
operator|==
operator|(
expr|struct
name|VMS_DBG_Symbol
operator|*
operator|)
name|NULL
condition|)
block|{
name|spnt
operator|=
operator|(
expr|struct
name|VMS_DBG_Symbol
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|VMS_DBG_Symbol
argument_list|)
argument_list|)
expr_stmt|;
name|spnt
operator|->
name|next
operator|=
operator|(
expr|struct
name|VMS_DBG_Symbol
operator|*
operator|)
name|NULL
expr_stmt|;
name|VMS_Symbol_type_list
operator|=
name|spnt
expr_stmt|;
block|}
else|else
block|{
name|spnt
operator|=
operator|(
expr|struct
name|VMS_DBG_Symbol
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|VMS_DBG_Symbol
argument_list|)
argument_list|)
expr_stmt|;
name|spnt
operator|->
name|next
operator|=
name|VMS_Symbol_type_list
expr_stmt|;
name|VMS_Symbol_type_list
operator|=
name|spnt
expr_stmt|;
block|}
empty_stmt|;
name|spnt
operator|->
name|dbx_type
operator|=
name|i1
expr_stmt|;
comment|/* and save the type */
block|}
empty_stmt|;
comment|/* for structs and unions, do a partial parse, otherwise we sometimes get  * circular definitions that are impossible to resolve. We read enough info  * so that any reference to this type has enough info to be resolved   */
name|pnt
operator|=
name|str
operator|+
literal|1
expr_stmt|;
comment|/* point to character past equal sign */
if|if
condition|(
operator|(
operator|*
name|pnt
operator|==
literal|'u'
operator|)
operator|||
operator|(
operator|*
name|pnt
operator|==
literal|'s'
operator|)
condition|)
block|{ 	}
empty_stmt|;
if|if
condition|(
operator|(
operator|*
name|pnt
operator|<=
literal|'9'
operator|)
operator|&&
operator|(
operator|*
name|pnt
operator|>=
literal|'0'
operator|)
condition|)
block|{
if|if
condition|(
name|type_check
argument_list|(
literal|"void"
argument_list|)
condition|)
block|{
comment|/* this is the void symbol */
operator|*
name|str
operator|=
literal|'\0'
expr_stmt|;
name|spnt
operator|->
name|advanced
operator|=
name|VOID
expr_stmt|;
return|return
literal|0
return|;
block|}
empty_stmt|;
name|printf
argument_list|(
literal|"gcc-as warning(debugger output):"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %d is an unknown untyped variable.\n"
argument_list|,
name|spnt
operator|->
name|dbx_type
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
comment|/* do not know what this is */
block|}
empty_stmt|;
comment|/* now define this module*/
name|pnt
operator|=
name|str
operator|+
literal|1
expr_stmt|;
comment|/* point to character past equal sign */
switch|switch
condition|(
operator|*
name|pnt
condition|)
block|{
case|case
literal|'r'
case|:
name|spnt
operator|->
name|advanced
operator|=
name|BASIC
expr_stmt|;
if|if
condition|(
name|type_check
argument_list|(
literal|"int"
argument_list|)
condition|)
block|{
name|spnt
operator|->
name|VMS_type
operator|=
name|DBG$C_SLINT
expr_stmt|;
name|spnt
operator|->
name|data_size
operator|=
literal|4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type_check
argument_list|(
literal|"long int"
argument_list|)
condition|)
block|{
name|spnt
operator|->
name|VMS_type
operator|=
name|DBG$C_SLINT
expr_stmt|;
name|spnt
operator|->
name|data_size
operator|=
literal|4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type_check
argument_list|(
literal|"unsigned int"
argument_list|)
condition|)
block|{
name|spnt
operator|->
name|VMS_type
operator|=
name|DBG$C_ULINT
expr_stmt|;
name|spnt
operator|->
name|data_size
operator|=
literal|4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type_check
argument_list|(
literal|"long unsigned int"
argument_list|)
condition|)
block|{
name|spnt
operator|->
name|VMS_type
operator|=
name|DBG$C_ULINT
expr_stmt|;
name|spnt
operator|->
name|data_size
operator|=
literal|4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type_check
argument_list|(
literal|"short int"
argument_list|)
condition|)
block|{
name|spnt
operator|->
name|VMS_type
operator|=
name|DBG$C_SSINT
expr_stmt|;
name|spnt
operator|->
name|data_size
operator|=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type_check
argument_list|(
literal|"short unsigned int"
argument_list|)
condition|)
block|{
name|spnt
operator|->
name|VMS_type
operator|=
name|DBG$C_USINT
expr_stmt|;
name|spnt
operator|->
name|data_size
operator|=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type_check
argument_list|(
literal|"char"
argument_list|)
condition|)
block|{
name|spnt
operator|->
name|VMS_type
operator|=
name|DBG$C_SCHAR
expr_stmt|;
name|spnt
operator|->
name|data_size
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type_check
argument_list|(
literal|"signed char"
argument_list|)
condition|)
block|{
name|spnt
operator|->
name|VMS_type
operator|=
name|DBG$C_SCHAR
expr_stmt|;
name|spnt
operator|->
name|data_size
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type_check
argument_list|(
literal|"unsigned char"
argument_list|)
condition|)
block|{
name|spnt
operator|->
name|VMS_type
operator|=
name|DBG$C_UCHAR
expr_stmt|;
name|spnt
operator|->
name|data_size
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type_check
argument_list|(
literal|"float"
argument_list|)
condition|)
block|{
name|spnt
operator|->
name|VMS_type
operator|=
name|DBG$C_REAL4
expr_stmt|;
name|spnt
operator|->
name|data_size
operator|=
literal|4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type_check
argument_list|(
literal|"double"
argument_list|)
condition|)
block|{
name|spnt
operator|->
name|VMS_type
operator|=
name|DBG$C_REAL8
expr_stmt|;
name|spnt
operator|->
name|data_size
operator|=
literal|8
expr_stmt|;
block|}
name|pnt1
operator|=
operator|(
name|char
operator|*
operator|)
name|strchr
argument_list|(
name|str
argument_list|,
literal|';'
argument_list|)
operator|+
literal|1
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
case|case
literal|'u'
case|:
if|if
condition|(
operator|*
name|pnt
operator|==
literal|'s'
condition|)
name|spnt
operator|->
name|advanced
operator|=
name|STRUCT
expr_stmt|;
else|else
name|spnt
operator|->
name|advanced
operator|=
name|UNION
expr_stmt|;
name|spnt
operator|->
name|VMS_type
operator|=
name|DBG$C_ADVANCED_TYPE
expr_stmt|;
name|pnt1
operator|=
name|cvt_integer
argument_list|(
name|pnt
operator|+
literal|1
argument_list|,
operator|&
name|spnt
operator|->
name|data_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|forward_reference
argument_list|(
name|pnt
argument_list|)
condition|)
block|{
name|spnt
operator|->
name|struc_numb
operator|=
operator|-
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
name|spnt
operator|->
name|struc_numb
operator|=
operator|++
name|structure_count
expr_stmt|;
name|pnt1
operator|--
expr_stmt|;
name|pnt
operator|=
name|get_struct_name
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|VMS_Def_Struct
argument_list|(
name|spnt
operator|->
name|struc_numb
argument_list|)
expr_stmt|;
name|fpnt
operator|=
name|f_ref_root
expr_stmt|;
while|while
condition|(
name|fpnt
operator|!=
operator|(
expr|struct
name|forward_ref
operator|*
operator|)
name|NULL
condition|)
block|{
if|if
condition|(
name|fpnt
operator|->
name|dbx_type
operator|==
name|spnt
operator|->
name|dbx_type
condition|)
block|{
name|fpnt
operator|->
name|resolved
operator|=
literal|'Y'
expr_stmt|;
name|VMS_Set_Struct
argument_list|(
name|fpnt
operator|->
name|struc_numb
argument_list|)
expr_stmt|;
name|VMS_Store_Struct
argument_list|(
name|spnt
operator|->
name|struc_numb
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
name|fpnt
operator|=
name|fpnt
operator|->
name|next
expr_stmt|;
block|}
empty_stmt|;
name|VMS_Set_Struct
argument_list|(
name|spnt
operator|->
name|struc_numb
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|Local
index|[
name|i
operator|++
index|]
operator|=
literal|11
operator|+
name|strlen
argument_list|(
name|pnt
argument_list|)
expr_stmt|;
name|Local
index|[
name|i
operator|++
index|]
operator|=
name|DBG$C_STRUCT_START
expr_stmt|;
name|Local
index|[
name|i
operator|++
index|]
operator|=
literal|0x80
expr_stmt|;
for|for
control|(
name|i1
operator|=
literal|0
init|;
name|i1
operator|<
literal|4
condition|;
name|i1
operator|++
control|)
name|Local
index|[
name|i
operator|++
index|]
operator|=
literal|0x00
expr_stmt|;
name|Local
index|[
name|i
operator|++
index|]
operator|=
name|strlen
argument_list|(
name|pnt
argument_list|)
expr_stmt|;
name|pnt2
operator|=
name|pnt
expr_stmt|;
while|while
condition|(
operator|*
name|pnt2
operator|!=
literal|'\0'
condition|)
name|Local
index|[
name|i
operator|++
index|]
operator|=
operator|*
name|pnt2
operator|++
expr_stmt|;
name|i2
operator|=
name|spnt
operator|->
name|data_size
operator|*
literal|8
expr_stmt|;
comment|/* number of bits */
name|pnt2
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|i2
expr_stmt|;
for|for
control|(
name|i1
operator|=
literal|0
init|;
name|i1
operator|<
literal|4
condition|;
name|i1
operator|++
control|)
name|Local
index|[
name|i
operator|++
index|]
operator|=
operator|*
name|pnt2
operator|++
expr_stmt|;
name|VMS_Store_Immediate_Data
argument_list|(
name|Local
argument_list|,
name|i
argument_list|,
name|OBJ$C_DBG
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pnt
operator|!=
name|symbol_name
condition|)
block|{
name|pnt
operator|+=
name|strlen
argument_list|(
name|pnt
argument_list|)
expr_stmt|;
operator|*
name|pnt
operator|=
literal|':'
expr_stmt|;
block|}
empty_stmt|;
comment|/* replace colon for later */
while|while
condition|(
operator|*
operator|++
name|pnt1
operator|!=
literal|';'
condition|)
block|{
name|pnt
operator|=
operator|(
name|char
operator|*
operator|)
name|strchr
argument_list|(
name|pnt1
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
operator|*
name|pnt
operator|=
literal|'\0'
expr_stmt|;
name|pnt2
operator|=
name|pnt1
expr_stmt|;
name|pnt1
operator|=
name|cvt_integer
argument_list|(
name|pnt
operator|+
literal|1
argument_list|,
operator|&
name|dtype
argument_list|)
expr_stmt|;
name|pnt1
operator|=
name|cvt_integer
argument_list|(
name|pnt1
operator|+
literal|1
argument_list|,
operator|&
name|i2
argument_list|)
expr_stmt|;
name|pnt1
operator|=
name|cvt_integer
argument_list|(
name|pnt1
operator|+
literal|1
argument_list|,
operator|&
name|i3
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dtype
operator|==
literal|1
operator|)
operator|&&
operator|(
name|i3
operator|!=
literal|32
operator|)
condition|)
block|{
comment|/* bitfield */
name|Apoint
operator|=
literal|0
expr_stmt|;
name|push
argument_list|(
literal|19
operator|+
name|strlen
argument_list|(
name|pnt2
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|push
argument_list|(
literal|0xfa22
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|push
argument_list|(
literal|1
operator|+
name|strlen
argument_list|(
name|pnt2
argument_list|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|push
argument_list|(
name|strlen
argument_list|(
name|pnt2
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|pnt2
operator|!=
literal|'\0'
condition|)
name|push
argument_list|(
operator|*
name|pnt2
operator|++
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|push
argument_list|(
name|i3
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* size of bitfield */
name|push
argument_list|(
literal|0x0d22
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|push
argument_list|(
literal|0x00
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|push
argument_list|(
name|i2
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* start position */
name|VMS_Store_Immediate_Data
argument_list|(
name|Asuffix
argument_list|,
name|Apoint
argument_list|,
name|OBJ$C_DBG
argument_list|)
expr_stmt|;
name|Apoint
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|Local
index|[
name|i
operator|++
index|]
operator|=
literal|7
operator|+
name|strlen
argument_list|(
name|pnt2
argument_list|)
expr_stmt|;
name|spnt1
operator|=
name|find_symbol
argument_list|(
name|dtype
argument_list|)
expr_stmt|;
comment|/* check if this is a forward reference */
if|if
condition|(
name|spnt1
operator|!=
operator|(
expr|struct
name|VMS_DBG_Symbol
operator|*
operator|)
name|NULL
condition|)
name|Local
index|[
name|i
operator|++
index|]
operator|=
name|spnt1
operator|->
name|VMS_type
expr_stmt|;
else|else
name|Local
index|[
name|i
operator|++
index|]
operator|=
name|DBG$C_ADVANCED_TYPE
expr_stmt|;
name|Local
index|[
name|i
operator|++
index|]
operator|=
name|DBG$C_STRUCT_ITEM
expr_stmt|;
name|pnt
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|i2
expr_stmt|;
for|for
control|(
name|i1
operator|=
literal|0
init|;
name|i1
operator|<
literal|4
condition|;
name|i1
operator|++
control|)
name|Local
index|[
name|i
operator|++
index|]
operator|=
operator|*
name|pnt
operator|++
expr_stmt|;
name|Local
index|[
name|i
operator|++
index|]
operator|=
name|strlen
argument_list|(
name|pnt2
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|pnt2
operator|!=
literal|'\0'
condition|)
name|Local
index|[
name|i
operator|++
index|]
operator|=
operator|*
name|pnt2
operator|++
expr_stmt|;
name|VMS_Store_Immediate_Data
argument_list|(
name|Local
argument_list|,
name|i
argument_list|,
name|OBJ$C_DBG
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|spnt1
operator|==
operator|(
expr|struct
name|VMS_DBG_Symbol
operator|*
operator|)
name|NULL
condition|)
name|generate_suffix
argument_list|(
name|spnt1
argument_list|,
name|dtype
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|spnt1
operator|->
name|VMS_type
operator|==
name|DBG$C_ADVANCED_TYPE
condition|)
name|generate_suffix
argument_list|(
name|spnt1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
block|}
empty_stmt|;
name|pnt1
operator|++
expr_stmt|;
name|Local
index|[
name|i
operator|++
index|]
operator|=
literal|0x01
expr_stmt|;
comment|/* length byte */
name|Local
index|[
name|i
operator|++
index|]
operator|=
name|DBG$C_STRUCT_END
expr_stmt|;
name|VMS_Store_Immediate_Data
argument_list|(
name|Local
argument_list|,
name|i
argument_list|,
name|OBJ$C_DBG
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|spnt
operator|->
name|advanced
operator|=
name|ENUM
expr_stmt|;
name|spnt
operator|->
name|VMS_type
operator|=
name|DBG$C_ADVANCED_TYPE
expr_stmt|;
name|spnt
operator|->
name|struc_numb
operator|=
operator|++
name|structure_count
expr_stmt|;
name|spnt
operator|->
name|data_size
operator|=
literal|4
expr_stmt|;
name|VMS_Def_Struct
argument_list|(
name|spnt
operator|->
name|struc_numb
argument_list|)
expr_stmt|;
name|fpnt
operator|=
name|f_ref_root
expr_stmt|;
while|while
condition|(
name|fpnt
operator|!=
operator|(
expr|struct
name|forward_ref
operator|*
operator|)
name|NULL
condition|)
block|{
if|if
condition|(
name|fpnt
operator|->
name|dbx_type
operator|==
name|spnt
operator|->
name|dbx_type
condition|)
block|{
name|fpnt
operator|->
name|resolved
operator|=
literal|'Y'
expr_stmt|;
name|VMS_Set_Struct
argument_list|(
name|fpnt
operator|->
name|struc_numb
argument_list|)
expr_stmt|;
name|VMS_Store_Struct
argument_list|(
name|spnt
operator|->
name|struc_numb
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
name|fpnt
operator|=
name|fpnt
operator|->
name|next
expr_stmt|;
block|}
empty_stmt|;
name|VMS_Set_Struct
argument_list|(
name|spnt
operator|->
name|struc_numb
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|Local
index|[
name|i
operator|++
index|]
operator|=
literal|3
operator|+
name|strlen
argument_list|(
name|symbol_name
argument_list|)
expr_stmt|;
name|Local
index|[
name|i
operator|++
index|]
operator|=
name|DBG$C_ENUM_START
expr_stmt|;
name|Local
index|[
name|i
operator|++
index|]
operator|=
literal|0x20
expr_stmt|;
name|Local
index|[
name|i
operator|++
index|]
operator|=
name|strlen
argument_list|(
name|symbol_name
argument_list|)
expr_stmt|;
name|pnt2
operator|=
name|symbol_name
expr_stmt|;
while|while
condition|(
operator|*
name|pnt2
operator|!=
literal|'\0'
condition|)
name|Local
index|[
name|i
operator|++
index|]
operator|=
operator|*
name|pnt2
operator|++
expr_stmt|;
name|VMS_Store_Immediate_Data
argument_list|(
name|Local
argument_list|,
name|i
argument_list|,
name|OBJ$C_DBG
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
operator|++
name|pnt
operator|!=
literal|';'
condition|)
block|{
name|pnt1
operator|=
operator|(
name|char
operator|*
operator|)
name|strchr
argument_list|(
name|pnt
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
operator|*
name|pnt1
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|pnt1
operator|=
name|cvt_integer
argument_list|(
name|pnt1
argument_list|,
operator|&
name|i1
argument_list|)
expr_stmt|;
name|Local
index|[
name|i
operator|++
index|]
operator|=
literal|7
operator|+
name|strlen
argument_list|(
name|pnt
argument_list|)
expr_stmt|;
name|Local
index|[
name|i
operator|++
index|]
operator|=
name|DBG$C_ENUM_ITEM
expr_stmt|;
name|Local
index|[
name|i
operator|++
index|]
operator|=
literal|0x00
expr_stmt|;
name|pnt2
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|i1
expr_stmt|;
for|for
control|(
name|i2
operator|=
literal|0
init|;
name|i2
operator|<
literal|4
condition|;
name|i2
operator|++
control|)
name|Local
index|[
name|i
operator|++
index|]
operator|=
operator|*
name|pnt2
operator|++
expr_stmt|;
name|Local
index|[
name|i
operator|++
index|]
operator|=
name|strlen
argument_list|(
name|pnt
argument_list|)
expr_stmt|;
name|pnt2
operator|=
name|pnt
expr_stmt|;
while|while
condition|(
operator|*
name|pnt
operator|!=
literal|'\0'
condition|)
name|Local
index|[
name|i
operator|++
index|]
operator|=
operator|*
name|pnt
operator|++
expr_stmt|;
name|VMS_Store_Immediate_Data
argument_list|(
name|Local
argument_list|,
name|i
argument_list|,
name|OBJ$C_DBG
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|pnt
operator|=
name|pnt1
expr_stmt|;
comment|/* Skip final semicolon */
block|}
empty_stmt|;
name|Local
index|[
name|i
operator|++
index|]
operator|=
literal|0x01
expr_stmt|;
comment|/* len byte */
name|Local
index|[
name|i
operator|++
index|]
operator|=
name|DBG$C_ENUM_END
expr_stmt|;
name|VMS_Store_Immediate_Data
argument_list|(
name|Local
argument_list|,
name|i
argument_list|,
name|OBJ$C_DBG
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|pnt1
operator|=
name|pnt
operator|+
literal|1
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
name|spnt
operator|->
name|advanced
operator|=
name|ARRAY
expr_stmt|;
name|spnt
operator|->
name|VMS_type
operator|=
name|DBG$C_ADVANCED_TYPE
expr_stmt|;
name|pnt
operator|=
operator|(
name|char
operator|*
operator|)
name|strchr
argument_list|(
name|pnt
argument_list|,
literal|';'
argument_list|)
expr_stmt|;
if|if
condition|(
name|pnt
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
return|return
literal|1
return|;
name|pnt1
operator|=
name|cvt_integer
argument_list|(
name|pnt
operator|+
literal|1
argument_list|,
operator|&
name|spnt
operator|->
name|index_min
argument_list|)
expr_stmt|;
name|pnt1
operator|=
name|cvt_integer
argument_list|(
name|pnt1
operator|+
literal|1
argument_list|,
operator|&
name|spnt
operator|->
name|index_max
argument_list|)
expr_stmt|;
name|pnt1
operator|=
name|cvt_integer
argument_list|(
name|pnt1
operator|+
literal|1
argument_list|,
operator|&
name|spnt
operator|->
name|type2
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|spnt
operator|->
name|advanced
operator|=
name|FUNCTION
expr_stmt|;
name|spnt
operator|->
name|VMS_type
operator|=
name|DBG$C_FUNCTION_ADDR
expr_stmt|;
comment|/* this masquerades as a basic type*/
name|spnt
operator|->
name|data_size
operator|=
literal|4
expr_stmt|;
name|pnt1
operator|=
name|cvt_integer
argument_list|(
name|pnt
operator|+
literal|1
argument_list|,
operator|&
name|spnt
operator|->
name|type2
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'*'
case|:
name|spnt
operator|->
name|advanced
operator|=
name|POINTER
expr_stmt|;
name|spnt
operator|->
name|VMS_type
operator|=
name|DBG$C_ADVANCED_TYPE
expr_stmt|;
name|spnt
operator|->
name|data_size
operator|=
literal|4
expr_stmt|;
name|pnt1
operator|=
name|cvt_integer
argument_list|(
name|pnt
operator|+
literal|1
argument_list|,
operator|&
name|spnt
operator|->
name|type2
argument_list|)
expr_stmt|;
name|pnt
operator|=
operator|(
name|char
operator|*
operator|)
name|strchr
argument_list|(
name|str
operator|+
literal|1
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pnt
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
condition|)
if|if
condition|(
name|VMS_typedef_parse
argument_list|(
name|pnt
argument_list|)
operator|==
literal|1
condition|)
return|return
literal|1
return|;
break|break;
default|default:
name|spnt
operator|->
name|advanced
operator|=
name|UNKNOWN
expr_stmt|;
name|spnt
operator|->
name|VMS_type
operator|=
literal|0
expr_stmt|;
name|printf
argument_list|(
literal|"gcc-as warning(debugger output):"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %d is an unknown type of variable.\n"
argument_list|,
name|spnt
operator|->
name|dbx_type
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
comment|/* unable to decipher */
block|}
empty_stmt|;
comment|/* this removes the evidence of the definition so that the outer levels of  parsing do not have to worry about it */
name|pnt
operator|=
name|str
expr_stmt|;
while|while
condition|(
operator|*
name|pnt1
operator|!=
literal|'\0'
condition|)
operator|*
name|pnt
operator|++
operator|=
operator|*
name|pnt1
operator|++
expr_stmt|;
operator|*
name|pnt
operator|=
literal|'\0'
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*   * This is the root routine that parses the stabs entries for definitions.  * it calls VMS_typedef_parse, which can in turn call itself.  * We need to be careful, since sometimes there are forward references to  * other symbol types, and these cannot be resolved until we have completed  * the parse.  */
end_comment

begin_function
name|int
name|VMS_LSYM_Parse
parameter_list|()
block|{
name|char
modifier|*
name|pnt
decl_stmt|;
name|char
modifier|*
name|pnt1
decl_stmt|;
name|char
modifier|*
name|pnt2
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
name|char
name|fixit
index|[
literal|10
index|]
decl_stmt|;
name|int
name|incomplete
decl_stmt|,
name|i
decl_stmt|,
name|pass
decl_stmt|,
name|incom1
decl_stmt|;
name|struct
name|VMS_DBG_Symbol
modifier|*
name|spnt
decl_stmt|;
name|struct
name|VMS_Symbol
modifier|*
name|vsp
decl_stmt|;
name|struct
name|forward_ref
modifier|*
name|fpnt
decl_stmt|;
name|symbolS
modifier|*
name|sp
decl_stmt|;
name|pass
operator|=
literal|0
expr_stmt|;
name|incomplete
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|incom1
operator|=
name|incomplete
expr_stmt|;
name|incomplete
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|sp
operator|=
name|symbol_rootP
init|;
name|sp
condition|;
name|sp
operator|=
name|sp
operator|->
name|sy_next
control|)
block|{
comment|/* 		 *	Deal with STAB symbols 		 */
if|if
condition|(
operator|(
name|sp
operator|->
name|sy_nlist
operator|.
name|n_type
operator|&
name|N_STAB
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		   *	Dispatch on STAB type 		   */
switch|switch
condition|(
operator|(
name|unsigned
name|char
operator|)
name|sp
operator|->
name|sy_nlist
operator|.
name|n_type
condition|)
block|{
case|case
name|N_GSYM
case|:
case|case
name|N_LCSYM
case|:
case|case
name|N_STSYM
case|:
case|case
name|N_PSYM
case|:
case|case
name|N_RSYM
case|:
case|case
name|N_LSYM
case|:
case|case
name|N_FUN
case|:
comment|/*sometimes these contain typedefs*/
name|str
operator|=
name|sp
operator|->
name|sy_nlist
operator|.
name|n_un
operator|.
name|n_name
expr_stmt|;
name|symbol_name
operator|=
name|str
expr_stmt|;
name|pnt
operator|=
operator|(
name|char
operator|*
operator|)
name|strchr
argument_list|(
name|str
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|pnt
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
break|break;
operator|*
name|pnt
operator|=
literal|'\0'
expr_stmt|;
name|pnt1
operator|=
name|pnt
operator|+
literal|1
expr_stmt|;
name|pnt2
operator|=
operator|(
name|char
operator|*
operator|)
name|strchr
argument_list|(
name|pnt1
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
if|if
condition|(
name|pnt2
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
operator|*
name|pnt
operator|=
literal|':'
expr_stmt|;
comment|/* replace colon */
break|break;
block|}
empty_stmt|;
comment|/* no symbol here */
name|incomplete
operator|+=
name|VMS_typedef_parse
argument_list|(
name|pnt2
argument_list|)
expr_stmt|;
operator|*
name|pnt
operator|=
literal|':'
expr_stmt|;
comment|/* put back colon so variable def code finds dbx_type*/
break|break;
block|}
comment|/*switch*/
block|}
comment|/* if */
block|}
comment|/*for*/
name|pass
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|incomplete
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|incomplete
operator|!=
name|incom1
operator|)
condition|)
do|;
comment|/* repeat until all refs resolved if possible */
comment|/*	if(pass> 1) printf(" Required %d passes\n",pass);*/
if|if
condition|(
name|incomplete
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"gcc-as warning(debugger output):"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Unable to resolve %d circular references.\n"
argument_list|,
name|incomplete
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
name|fpnt
operator|=
name|f_ref_root
expr_stmt|;
name|symbol_name
operator|=
literal|"\0"
expr_stmt|;
while|while
condition|(
name|fpnt
operator|!=
operator|(
expr|struct
name|forward_ref
operator|*
operator|)
name|NULL
condition|)
block|{
if|if
condition|(
name|fpnt
operator|->
name|resolved
operator|!=
literal|'Y'
condition|)
block|{
if|if
condition|(
name|find_symbol
argument_list|(
name|fpnt
operator|->
name|dbx_type
argument_list|)
operator|!=
operator|(
expr|struct
name|VMS_DBG_Symbol
operator|*
operator|)
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"gcc-as warning(debugger output):"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Forward reference error, dbx type %d\n"
argument_list|,
name|fpnt
operator|->
name|dbx_type
argument_list|)
expr_stmt|;
break|break;
block|}
empty_stmt|;
name|fixit
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|sprintf
argument_list|(
operator|&
name|fixit
index|[
literal|1
index|]
argument_list|,
literal|"%d=s4;"
argument_list|,
name|fpnt
operator|->
name|dbx_type
argument_list|)
expr_stmt|;
name|pnt2
operator|=
operator|(
name|char
operator|*
operator|)
name|strchr
argument_list|(
operator|&
name|fixit
index|[
literal|1
index|]
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
name|VMS_typedef_parse
argument_list|(
name|pnt2
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
name|fpnt
operator|=
name|fpnt
operator|->
name|next
expr_stmt|;
block|}
empty_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|symbolS
modifier|*
name|Current_Routine
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|Text_Psect
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|Define_Local_Symbols
argument_list|(
argument|symbolS* s1
argument_list|,
argument|symbolS* s2
argument_list|)
block|{
name|symbolS
operator|*
name|symbolP1
block|;
for|for
control|(
name|symbolP1
operator|=
name|s1
operator|->
name|sy_next
init|;
name|symbolP1
operator|!=
name|s2
condition|;
name|symbolP1
operator|=
name|symbolP1
operator|->
name|sy_next
control|)
block|{
if|if
condition|(
name|symbolP1
operator|==
operator|(
name|symbolS
operator|*
operator|)
name|NULL
condition|)
return|return;
if|if
condition|(
name|symbolP1
operator|->
name|sy_nlist
operator|.
name|n_type
operator|==
name|N_FUN
condition|)
return|return;
comment|/* 		 *	Deal with STAB symbols 		 */
if|if
condition|(
operator|(
name|symbolP1
operator|->
name|sy_nlist
operator|.
name|n_type
operator|&
name|N_STAB
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		   *	Dispatch on STAB type 		   */
switch|switch
condition|(
operator|(
name|unsigned
name|char
operator|)
name|symbolP1
operator|->
name|sy_nlist
operator|.
name|n_type
condition|)
block|{
case|case
name|N_LSYM
case|:
case|case
name|N_PSYM
case|:
name|VMS_local_stab_Parse
argument_list|(
name|symbolP1
argument_list|)
expr_stmt|;
break|break;
case|case
name|N_RSYM
case|:
name|VMS_RSYM_Parse
argument_list|(
name|symbolP1
argument_list|,
name|Current_Routine
argument_list|,
name|Text_Psect
argument_list|)
expr_stmt|;
break|break;
block|}
end_expr_stmt

begin_comment
comment|/*switch*/
end_comment

begin_comment
unit|}
comment|/* if */
end_comment

begin_comment
unit|}
comment|/* for */
end_comment

begin_function
unit|}  static
name|symbolS
modifier|*
name|Define_Routine
parameter_list|(
name|symbolS
modifier|*
name|symbolP
parameter_list|,
name|int
name|Level
parameter_list|)
block|{
name|symbolS
modifier|*
name|sstart
decl_stmt|;
name|symbolS
modifier|*
name|symbolP1
decl_stmt|;
name|char
name|str
index|[
literal|10
index|]
decl_stmt|;
name|char
modifier|*
name|pnt
decl_stmt|;
name|int
name|rcount
init|=
literal|0
decl_stmt|;
name|int
name|Offset
decl_stmt|;
name|sstart
operator|=
name|symbolP
expr_stmt|;
for|for
control|(
name|symbolP1
operator|=
name|symbolP
operator|->
name|sy_next
init|;
name|symbolP1
condition|;
name|symbolP1
operator|=
name|symbolP1
operator|->
name|sy_next
control|)
block|{
if|if
condition|(
name|symbolP1
operator|->
name|sy_nlist
operator|.
name|n_type
operator|==
name|N_FUN
condition|)
break|break;
comment|/* 		 *	Deal with STAB symbols 		 */
if|if
condition|(
operator|(
name|symbolP1
operator|->
name|sy_nlist
operator|.
name|n_type
operator|&
name|N_STAB
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		   *	Dispatch on STAB type 		   */
if|if
condition|(
operator|(
name|unsigned
name|char
operator|)
name|symbolP1
operator|->
name|sy_nlist
operator|.
name|n_type
operator|==
name|N_FUN
condition|)
break|break;
switch|switch
condition|(
operator|(
name|unsigned
name|char
operator|)
name|symbolP1
operator|->
name|sy_nlist
operator|.
name|n_type
condition|)
block|{
case|case
name|N_LBRAC
case|:
if|if
condition|(
name|Level
operator|!=
literal|0
condition|)
block|{
name|pnt
operator|=
name|str
operator|+
name|sprintf
argument_list|(
name|str
argument_list|,
literal|"$%d"
argument_list|,
name|rcount
operator|++
argument_list|)
expr_stmt|;
operator|*
name|pnt
operator|=
literal|'\0'
expr_stmt|;
name|VMS_TBT_Block_Begin
argument_list|(
name|symbolP1
argument_list|,
name|Text_Psect
argument_list|,
name|str
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
name|Offset
operator|=
name|symbolP1
operator|->
name|sy_nlist
operator|.
name|n_value
expr_stmt|;
name|Define_Local_Symbols
argument_list|(
name|sstart
argument_list|,
name|symbolP1
argument_list|)
expr_stmt|;
name|symbolP1
operator|=
name|Define_Routine
argument_list|(
name|symbolP1
argument_list|,
name|Level
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|Level
operator|!=
literal|0
condition|)
name|VMS_TBT_Block_End
argument_list|(
name|symbolP1
operator|->
name|sy_nlist
operator|.
name|n_value
operator|-
name|Offset
argument_list|)
expr_stmt|;
name|sstart
operator|=
name|symbolP1
expr_stmt|;
break|break;
case|case
name|N_RBRAC
case|:
return|return
name|symbolP1
return|;
block|}
comment|/*switch*/
block|}
comment|/* if */
block|}
comment|/* for */
comment|/* we end up here if there were no brackets in this function. Define everything */
name|Define_Local_Symbols
argument_list|(
name|sstart
argument_list|,
operator|(
name|symbolS
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|VMS_DBG_Define_Routine
argument_list|(
argument|symbolS* symbolP
argument_list|,
argument|symbolS* Curr_Routine
argument_list|,
argument|int Txt_Psect
argument_list|)
end_macro

begin_block
block|{
name|Current_Routine
operator|=
name|Curr_Routine
expr_stmt|;
name|Text_Psect
operator|=
name|Txt_Psect
expr_stmt|;
name|Define_Routine
argument_list|(
name|symbolP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

