begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* write.c - emit .o file - Copyright(C)1986 Free Software Foundation, Inc.    Copyright (C) 1986,1987 Free Software Foundation, Inc.  This file is part of GAS, the GNU Assembler.  GAS is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version.  GAS is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GAS; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/*      Umm, with real good luck, this thing should be set up to do byteordering    correctly, but I may have managed to miss a place or two.  Treat a.out    very carefully until you're SURE that it works. . .     In order to cross-assemble the target machine must have an a.out header    similar to the one in a.out.h on THIS machine.  Byteorder doesn't matter;    we take special care of it, but the numbers must be the same SIZE (# of    bytes) and in the same PLACE.  If this is not true, you will have some    trouble.  */
end_comment

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|"md.h"
end_include

begin_include
include|#
directive|include
file|"subsegs.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"struc-symbol.h"
end_include

begin_include
include|#
directive|include
file|"write.h"
end_include

begin_include
include|#
directive|include
file|"symbols.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|SPARC
end_ifdef

begin_include
include|#
directive|include
file|"sparc.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|I860
end_ifdef

begin_include
include|#
directive|include
file|"i860.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
name|void
name|append
parameter_list|()
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|hpux
end_ifdef

begin_define
define|#
directive|define
name|EXEC_MACHINE_TYPE
value|HP9000S200_ID
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|DOT_LABEL_PREFIX
end_ifdef

begin_define
define|#
directive|define
name|LOCAL_LABEL
parameter_list|(
name|name
parameter_list|)
value|(name[0] =='.' \&& ( name [1] == 'L' || name [1] == '.' ))
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* not defined DOT_LABEL_PREFIX */
end_comment

begin_define
define|#
directive|define
name|LOCAL_LABEL
parameter_list|(
name|name
parameter_list|)
value|(name [0] == 'L' )
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not defined DOT_LABEL_PREFIX */
end_comment

begin_comment
comment|/*  * In: length of relocation (or of address) in chars: 1, 2 or 4.  * Out: GNU LD relocation length code: 0, 1, or 2.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|nbytes_r_length
index|[]
init|=
block|{
literal|42
block|,
literal|0
block|,
literal|1
block|,
literal|42
block|,
literal|2
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|frag
modifier|*
name|text_frag_root
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|frag
modifier|*
name|data_frag_root
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|frag
modifier|*
name|text_last_frag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Last frag in segment. */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|frag
modifier|*
name|data_last_frag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Last frag in segment. */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|exec
name|the_exec
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|int
name|string_byte_count
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|the_object_file
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|SPARC
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|I860
argument_list|)
end_if

begin_decl_stmt
specifier|static
endif|#
directive|endif
name|char
modifier|*
name|next_object_file_charP
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Tracks object file bytes. */
end_comment

begin_decl_stmt
specifier|static
name|long
name|int
name|size_of_the_object_file
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* # bytes in object file. */
end_comment

begin_comment
comment|/* static long int		length; JF unused */
end_comment

begin_comment
comment|/* String length, including trailing '\0'. */
end_comment

begin_function_decl
specifier|static
name|void
name|relax_segment
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|emit_segment
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|relax_addressT
name|relax_align
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|long
name|int
name|fixup_segment
parameter_list|()
function_decl|;
end_function_decl

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|SPARC
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|I860
argument_list|)
end_if

begin_function_decl
specifier|static
name|void
name|emit_relocations
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/*  *			fix_new()  *  * Create a fixS in obstack 'notes'.  */
end_comment

begin_function
name|void
if|#
directive|if
name|defined
argument_list|(
name|SPARC
argument_list|)
operator|||
name|defined
argument_list|(
name|I860
argument_list|)
name|fix_new
parameter_list|(
name|frag
parameter_list|,
name|where
parameter_list|,
name|size
parameter_list|,
name|add_symbol
parameter_list|,
name|sub_symbol
parameter_list|,
name|offset
parameter_list|,
name|pcrel
parameter_list|,
name|r_type
parameter_list|)
else|#
directive|else
function|fix_new
parameter_list|(
name|frag
parameter_list|,
name|where
parameter_list|,
name|size
parameter_list|,
name|add_symbol
parameter_list|,
name|sub_symbol
parameter_list|,
name|offset
parameter_list|,
name|pcrel
parameter_list|)
endif|#
directive|endif
name|fragS
modifier|*
name|frag
decl_stmt|;
comment|/* Which frag? */
name|int
name|where
decl_stmt|;
comment|/* Where in that frag? */
name|short
name|int
name|size
decl_stmt|;
comment|/* 1, 2  or 4 usually. */
name|symbolS
modifier|*
name|add_symbol
decl_stmt|;
comment|/* X_add_symbol. */
name|symbolS
modifier|*
name|sub_symbol
decl_stmt|;
comment|/* X_subtract_symbol. */
name|long
name|int
name|offset
decl_stmt|;
comment|/* X_add_number. */
name|int
name|pcrel
decl_stmt|;
comment|/* TRUE if PC-relative relocation. */
if|#
directive|if
name|defined
argument_list|(
name|SPARC
argument_list|)
operator|||
name|defined
argument_list|(
name|I860
argument_list|)
name|int
name|r_type
decl_stmt|;
endif|#
directive|endif
block|{
specifier|register
name|fixS
modifier|*
name|fixP
decl_stmt|;
name|fixP
operator|=
operator|(
name|fixS
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|notes
argument_list|,
sizeof|sizeof
argument_list|(
name|fixS
argument_list|)
argument_list|)
expr_stmt|;
name|fixP
operator|->
name|fx_frag
operator|=
name|frag
expr_stmt|;
name|fixP
operator|->
name|fx_where
operator|=
name|where
expr_stmt|;
name|fixP
operator|->
name|fx_size
operator|=
name|size
expr_stmt|;
name|fixP
operator|->
name|fx_addsy
operator|=
name|add_symbol
expr_stmt|;
name|fixP
operator|->
name|fx_subsy
operator|=
name|sub_symbol
expr_stmt|;
name|fixP
operator|->
name|fx_offset
operator|=
name|offset
expr_stmt|;
name|fixP
operator|->
name|fx_pcrel
operator|=
name|pcrel
expr_stmt|;
name|fixP
operator|->
name|fx_next
operator|=
operator|*
name|seg_fix_rootP
expr_stmt|;
comment|/* JF these 'cuz of the NS32K stuff */
name|fixP
operator|->
name|fx_im_disp
operator|=
literal|0
expr_stmt|;
name|fixP
operator|->
name|fx_pcrel_adjust
operator|=
literal|0
expr_stmt|;
name|fixP
operator|->
name|fx_bsr
operator|=
literal|0
expr_stmt|;
name|fixP
operator|->
name|fx_bit_fixP
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|SPARC
argument_list|)
operator|||
name|defined
argument_list|(
name|I860
argument_list|)
name|fixP
operator|->
name|fx_r_type
operator|=
name|r_type
expr_stmt|;
endif|#
directive|endif
operator|*
name|seg_fix_rootP
operator|=
name|fixP
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|write_object_file
parameter_list|()
block|{
specifier|register
name|struct
name|frchain
modifier|*
name|frchainP
decl_stmt|;
comment|/* Track along all frchains. */
specifier|register
name|fragS
modifier|*
name|fragP
decl_stmt|;
comment|/* Track along all frags. */
specifier|register
name|struct
name|frchain
modifier|*
name|next_frchainP
decl_stmt|;
specifier|register
name|fragS
modifier|*
modifier|*
name|prev_fragPP
decl_stmt|;
specifier|register
name|char
modifier|*
name|name
decl_stmt|;
specifier|register
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
specifier|register
name|symbolS
modifier|*
modifier|*
name|symbolPP
decl_stmt|;
comment|/* register fixS *		fixP; JF unused */
name|unsigned
name|text_siz
decl_stmt|,
name|data_siz
decl_stmt|,
name|syms_siz
decl_stmt|,
name|tr_siz
decl_stmt|,
name|dr_siz
decl_stmt|;
name|void
name|output_file_create
parameter_list|()
function_decl|;
name|void
name|output_file_append
parameter_list|()
function_decl|;
name|void
name|output_file_close
parameter_list|()
function_decl|;
ifdef|#
directive|ifdef
name|DONTDEF
name|void
name|gdb_emit
parameter_list|()
function_decl|;
name|void
name|gdb_end
parameter_list|()
function_decl|;
endif|#
directive|endif
specifier|extern
name|long
name|omagic
decl_stmt|;
comment|/* JF magic # to write out.  Is different for 				   Suns and Vaxen and other boxes */
ifdef|#
directive|ifdef
name|VMS
comment|/*    *	Under VMS we try to be compatible with VAX-11 "C".  Thus, we    *	call a routine to check for the definition of the procedure    *	"_main", and if so -- fix it up so that it can be program    *	entry point.    */
name|VMS_Check_For_Main
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* VMS */
comment|/*    * After every sub-segment, we fake an ".align ...". This conforms to BSD4.2    * brane-damage. We then fake ".fill 0" because that is the kind of frag    * that requires least thought. ".align" frags like to have a following    * frag since that makes calculating their intended length trivial.    */
define|#
directive|define
name|SUB_SEGMENT_ALIGN
value|(2)
for|for
control|(
name|frchainP
operator|=
name|frchain_root
init|;
name|frchainP
condition|;
name|frchainP
operator|=
name|frchainP
operator|->
name|frch_next
control|)
block|{
ifdef|#
directive|ifdef
name|VMS
comment|/*        *	Under VAX/VMS, the linker (and PSECT specifications)        *	take care of correctly aligning the segments.        *	Doing the alignment here (on initialized data) can        *	mess up the calculation of global data PSECT sizes.        */
undef|#
directive|undef
name|SUB_SEGMENT_ALIGN
define|#
directive|define
name|SUB_SEGMENT_ALIGN
value|((frchainP->frch_seg != SEG_DATA) ? 2 : 0)
endif|#
directive|endif
comment|/* VMS */
name|subseg_new
argument_list|(
name|frchainP
operator|->
name|frch_seg
argument_list|,
name|frchainP
operator|->
name|frch_subseg
argument_list|)
expr_stmt|;
name|frag_align
argument_list|(
name|SUB_SEGMENT_ALIGN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* frag_align will have left a new frag. */
comment|/* Use this last frag for an empty ".fill". */
comment|/*        * For this segment ...        * Create a last frag. Do not leave a "being filled in frag".        */
name|frag_wane
argument_list|(
name|frag_now
argument_list|)
expr_stmt|;
name|frag_now
operator|->
name|fr_fix
operator|=
literal|0
expr_stmt|;
name|know
argument_list|(
name|frag_now
operator|->
name|fr_next
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* know( frags . obstack_c_base == frags . obstack_c_next_free ); */
comment|/* Above shows we haven't left a half-completed object on obstack. */
block|}
comment|/*    * From now on, we don't care about sub-segments.    * Build one frag chain for each segment. Linked thru fr_next.    * We know that there is at least 1 text frchain& at least 1 data frchain.    */
name|prev_fragPP
operator|=
operator|&
name|text_frag_root
expr_stmt|;
for|for
control|(
name|frchainP
operator|=
name|frchain_root
init|;
name|frchainP
condition|;
name|frchainP
operator|=
name|next_frchainP
control|)
block|{
name|know
argument_list|(
name|frchainP
operator|->
name|frch_root
argument_list|)
expr_stmt|;
operator|*
name|prev_fragPP
operator|=
name|frchainP
operator|->
name|frch_root
expr_stmt|;
name|prev_fragPP
operator|=
operator|&
name|frchainP
operator|->
name|frch_last
operator|->
name|fr_next
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|next_frchainP
operator|=
name|frchainP
operator|->
name|frch_next
operator|)
operator|==
name|NULL
operator|)
operator|||
name|next_frchainP
operator|==
name|data0_frchainP
condition|)
block|{
name|prev_fragPP
operator|=
operator|&
name|data_frag_root
expr_stmt|;
if|if
condition|(
name|next_frchainP
condition|)
block|{
name|text_last_frag
operator|=
name|frchainP
operator|->
name|frch_last
expr_stmt|;
block|}
else|else
block|{
name|data_last_frag
operator|=
name|frchainP
operator|->
name|frch_last
expr_stmt|;
block|}
block|}
block|}
comment|/* for(each struct frchain) */
comment|/*    * We have two segments. If user gave -R flag, then we must put the    * data frags into the text segment. Do this before relaxing so    * we know to take advantage of -R and make shorter addresses.    */
if|if
condition|(
name|flagseen
index|[
literal|'R'
index|]
condition|)
block|{
name|fixS
modifier|*
name|tmp
decl_stmt|;
name|text_last_frag
operator|->
name|fr_next
operator|=
name|data_frag_root
expr_stmt|;
name|text_last_frag
operator|=
name|data_last_frag
expr_stmt|;
name|data_last_frag
operator|=
name|NULL
expr_stmt|;
name|data_frag_root
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|text_fix_root
condition|)
block|{
for|for
control|(
name|tmp
operator|=
name|text_fix_root
init|;
name|tmp
operator|->
name|fx_next
condition|;
name|tmp
operator|=
name|tmp
operator|->
name|fx_next
control|)
empty_stmt|;
name|tmp
operator|->
name|fx_next
operator|=
name|data_fix_root
expr_stmt|;
block|}
else|else
name|text_fix_root
operator|=
name|data_fix_root
expr_stmt|;
name|data_fix_root
operator|=
name|NULL
expr_stmt|;
block|}
name|relax_segment
argument_list|(
name|text_frag_root
argument_list|,
name|SEG_TEXT
argument_list|)
expr_stmt|;
name|relax_segment
argument_list|(
name|data_frag_root
argument_list|,
name|SEG_DATA
argument_list|)
expr_stmt|;
comment|/*    * Now the addresses of frags are correct within the segment.    */
name|know
argument_list|(
name|text_last_frag
operator|->
name|fr_type
operator|==
name|rs_fill
operator|&&
name|text_last_frag
operator|->
name|fr_offset
operator|==
literal|0
argument_list|)
expr_stmt|;
name|text_siz
operator|=
name|text_last_frag
operator|->
name|fr_address
expr_stmt|;
ifdef|#
directive|ifdef
name|SPARC
name|text_siz
operator|=
operator|(
name|text_siz
operator|+
literal|7
operator|)
operator|&
operator|(
operator|~
literal|7
operator|)
expr_stmt|;
name|text_last_frag
operator|->
name|fr_address
operator|=
name|text_siz
expr_stmt|;
endif|#
directive|endif
name|md_number_to_chars
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|the_exec
operator|.
name|a_text
argument_list|,
name|text_siz
argument_list|,
sizeof|sizeof
argument_list|(
name|the_exec
operator|.
name|a_text
argument_list|)
argument_list|)
expr_stmt|;
comment|/* the_exec . a_text = text_last_frag -> fr_address; */
comment|/*    * Join the 2 segments into 1 huge segment.    * To do this, re-compute every rn_address in the SEG_DATA frags.    * Then join the data frags after the text frags.    *    * Determine a_data [length of data segment].    */
if|if
condition|(
name|data_frag_root
condition|)
block|{
specifier|register
name|relax_addressT
name|slide
decl_stmt|;
name|know
argument_list|(
name|text_last_frag
operator|->
name|fr_type
operator|==
name|rs_fill
operator|&&
name|text_last_frag
operator|->
name|fr_offset
operator|==
literal|0
argument_list|)
expr_stmt|;
name|data_siz
operator|=
name|data_last_frag
operator|->
name|fr_address
expr_stmt|;
ifdef|#
directive|ifdef
name|SPARC
name|data_siz
operator|+=
operator|(
literal|8
operator|-
operator|(
name|data_siz
operator|%
literal|8
operator|)
operator|)
operator|%
literal|8
expr_stmt|;
name|data_last_frag
operator|->
name|fr_address
operator|=
name|data_siz
expr_stmt|;
endif|#
directive|endif
name|md_number_to_chars
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|the_exec
operator|.
name|a_data
argument_list|,
name|data_siz
argument_list|,
sizeof|sizeof
argument_list|(
name|the_exec
operator|.
name|a_data
argument_list|)
argument_list|)
expr_stmt|;
comment|/* the_exec . a_data = data_last_frag -> fr_address; */
name|slide
operator|=
name|text_siz
expr_stmt|;
comment|/* Address in file of the data segment. */
for|for
control|(
name|fragP
operator|=
name|data_frag_root
init|;
name|fragP
condition|;
name|fragP
operator|=
name|fragP
operator|->
name|fr_next
control|)
block|{
name|fragP
operator|->
name|fr_address
operator|+=
name|slide
expr_stmt|;
block|}
name|know
argument_list|(
name|text_last_frag
argument_list|)
expr_stmt|;
name|text_last_frag
operator|->
name|fr_next
operator|=
name|data_frag_root
expr_stmt|;
block|}
else|else
block|{
name|md_number_to_chars
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|the_exec
operator|.
name|a_data
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|the_exec
operator|.
name|a_data
argument_list|)
argument_list|)
expr_stmt|;
name|data_siz
operator|=
literal|0
expr_stmt|;
block|}
name|bss_address_frag
operator|.
name|fr_address
operator|=
name|text_siz
operator|+
name|data_siz
expr_stmt|;
ifdef|#
directive|ifdef
name|SPARC
name|local_bss_counter
operator|=
operator|(
name|local_bss_counter
operator|+
literal|7
operator|)
operator|&
operator|(
operator|~
literal|7
operator|)
expr_stmt|;
endif|#
directive|endif
name|md_number_to_chars
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|the_exec
operator|.
name|a_bss
argument_list|,
name|local_bss_counter
argument_list|,
sizeof|sizeof
argument_list|(
name|the_exec
operator|.
name|a_bss
argument_list|)
argument_list|)
expr_stmt|;
comment|/*    *    * Crawl the symbol chain.    *    * For each symbol whose value depends on a frag, take the address of    * that frag and subsume it into the value of the symbol.    * After this, there is just one way to lookup a symbol value.    * Values are left in their final state for object file emission.    * We adjust the values of 'L' local symbols, even if we do    * not intend to emit them to the object file, because their values    * are needed for fix-ups.    *    * Unless we saw a -L flag, remove all symbols that begin with 'L'    * from the symbol chain.    *    * Count the (length of the nlists of the) (remaining) symbols.    * Assign a symbol number to each symbol.    * Count the number of string-table chars we will emit.    *    */
name|know
argument_list|(
name|zero_address_frag
operator|.
name|fr_address
operator|==
literal|0
argument_list|)
expr_stmt|;
name|string_byte_count
operator|=
sizeof|sizeof
argument_list|(
name|string_byte_count
argument_list|)
expr_stmt|;
comment|/* JF deal with forward references first. . . */
for|for
control|(
name|symbolP
operator|=
name|symbol_rootP
init|;
name|symbolP
condition|;
name|symbolP
operator|=
name|symbolP
operator|->
name|sy_next
control|)
block|{
if|if
condition|(
name|symbolP
operator|->
name|sy_forward
condition|)
block|{
name|symbolP
operator|->
name|sy_value
operator|+=
name|symbolP
operator|->
name|sy_forward
operator|->
name|sy_value
operator|+
name|symbolP
operator|->
name|sy_forward
operator|->
name|sy_frag
operator|->
name|fr_address
expr_stmt|;
name|symbolP
operator|->
name|sy_forward
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|symbolPP
operator|=
operator|&
name|symbol_rootP
expr_stmt|;
comment|/* -> last symbol chain link. */
block|{
specifier|register
name|long
name|int
name|symbol_number
decl_stmt|;
name|symbol_number
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|symbolP
operator|=
operator|*
name|symbolPP
condition|)
block|{
name|name
operator|=
name|symbolP
operator|->
name|sy_name
expr_stmt|;
if|if
condition|(
name|flagseen
index|[
literal|'R'
index|]
operator|&&
operator|(
name|symbolP
operator|->
name|sy_nlist
operator|.
name|n_type
operator|&
name|N_DATA
operator|)
condition|)
block|{
name|symbolP
operator|->
name|sy_nlist
operator|.
name|n_type
operator|&=
operator|~
name|N_DATA
expr_stmt|;
name|symbolP
operator|->
name|sy_nlist
operator|.
name|n_type
operator||=
name|N_TEXT
expr_stmt|;
block|}
comment|/* if(symbolP->sy_forward) { 	  symbolP->sy_value += symbolP->sy_forward->sy_value + symbolP->sy_forward->sy_frag->fr_address; 	} */
name|symbolP
operator|->
name|sy_value
operator|+=
name|symbolP
operator|->
name|sy_frag
operator|->
name|fr_address
expr_stmt|;
comment|/* JF the 128 bit is a hack so stabs like 		   "LET_STMT:23. . ."  don't go away */
comment|/* CPH: 128 bit hack is moby loser.  N_SO for file "Lower.c" 	   fell through the cracks.  I think that N_STAB should be 	   used instead of 128. */
comment|/* JF the \001 bit is to make sure that local labels 		   ( 1: - 9: don't make it into the symtable either */
ifndef|#
directive|ifndef
name|VMS
comment|/* Under VMS we need to keep local symbols */
if|if
condition|(
operator|!
name|name
operator|||
operator|(
name|symbolP
operator|->
name|sy_nlist
operator|.
name|n_type
operator|&
name|N_STAB
operator|)
operator|||
operator|(
name|name
index|[
literal|2
index|]
operator|!=
literal|'\001'
operator|&&
operator|(
name|flagseen
index|[
literal|'L'
index|]
operator|||
operator|!
name|LOCAL_LABEL
argument_list|(
name|name
argument_list|)
operator|)
operator|)
condition|)
endif|#
directive|endif
comment|/* not VMS */
block|{
name|symbolP
operator|->
name|sy_number
operator|=
name|symbol_number
operator|++
expr_stmt|;
ifndef|#
directive|ifndef
name|VMS
if|if
condition|(
name|name
condition|)
block|{
comment|/* Ordinary case. */
name|symbolP
operator|->
name|sy_name_offset
operator|=
name|string_byte_count
expr_stmt|;
name|string_byte_count
operator|+=
name|strlen
argument_list|(
name|symbolP
operator|->
name|sy_name
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
else|else
comment|/* .Stabd case. */
endif|#
directive|endif
comment|/* not VMS */
name|symbolP
operator|->
name|sy_name_offset
operator|=
literal|0
expr_stmt|;
name|symbolPP
operator|=
operator|&
operator|(
name|symbolP
operator|->
name|sy_next
operator|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|VMS
else|else
operator|*
name|symbolPP
operator|=
name|symbolP
operator|->
name|sy_next
expr_stmt|;
endif|#
directive|endif
comment|/* not VMS */
block|}
comment|/* for each symbol */
name|syms_siz
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|nlist
argument_list|)
operator|*
name|symbol_number
expr_stmt|;
name|md_number_to_chars
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|the_exec
operator|.
name|a_syms
argument_list|,
name|syms_siz
argument_list|,
sizeof|sizeof
argument_list|(
name|the_exec
operator|.
name|a_syms
argument_list|)
argument_list|)
expr_stmt|;
comment|/* the_exec . a_syms = sizeof( struct nlist) * symbol_number; */
block|}
comment|/*    * Addresses of frags now reflect addresses we use in the object file.    * Symbol values are correct.    * Scan the frags, converting any ".org"s and ".align"s to ".fill"s.    * Also converting any machine-dependent frags using md_convert_frag();    */
name|subseg_change
argument_list|(
name|SEG_TEXT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|fragP
operator|=
name|text_frag_root
init|;
name|fragP
condition|;
name|fragP
operator|=
name|fragP
operator|->
name|fr_next
control|)
block|{
switch|switch
condition|(
name|fragP
operator|->
name|fr_type
condition|)
block|{
case|case
name|rs_align
case|:
case|case
name|rs_org
case|:
name|fragP
operator|->
name|fr_type
operator|=
name|rs_fill
expr_stmt|;
name|know
argument_list|(
name|fragP
operator|->
name|fr_var
operator|==
literal|1
argument_list|)
expr_stmt|;
name|know
argument_list|(
name|fragP
operator|->
name|fr_next
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_offset
operator|=
name|fragP
operator|->
name|fr_next
operator|->
name|fr_address
operator|-
name|fragP
operator|->
name|fr_address
operator|-
name|fragP
operator|->
name|fr_fix
expr_stmt|;
break|break;
case|case
name|rs_fill
case|:
break|break;
case|case
name|rs_machine_dependent
case|:
name|md_convert_frag
argument_list|(
name|fragP
argument_list|)
expr_stmt|;
comment|/* 	   * After md_convert_frag, we make the frag into a ".space 0". 	   * Md_convert_frag() should set up any fixSs and constants 	   * required. 	   */
name|frag_wane
argument_list|(
name|fragP
argument_list|)
expr_stmt|;
break|break;
ifndef|#
directive|ifndef
name|WORKING_DOT_WORD
case|case
name|rs_broken_word
case|:
block|{
name|struct
name|broken_word
modifier|*
name|lie
decl_stmt|;
extern|extern md_short_jump_size;
extern|extern md_long_jump_size;
if|if
condition|(
name|fragP
operator|->
name|fr_subtype
condition|)
block|{
name|fragP
operator|->
name|fr_fix
operator|+=
name|md_short_jump_size
expr_stmt|;
for|for
control|(
name|lie
operator|=
operator|(
expr|struct
name|broken_word
operator|*
operator|)
operator|(
name|fragP
operator|->
name|fr_symbol
operator|)
init|;
name|lie
operator|&&
name|lie
operator|->
name|dispfrag
operator|==
name|fragP
condition|;
name|lie
operator|=
name|lie
operator|->
name|next_broken_word
control|)
if|if
condition|(
name|lie
operator|->
name|added
operator|==
literal|1
condition|)
name|fragP
operator|->
name|fr_fix
operator|+=
name|md_long_jump_size
expr_stmt|;
block|}
name|frag_wane
argument_list|(
name|fragP
argument_list|)
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
default|default:
name|BAD_CASE
argument_list|(
name|fragP
operator|->
name|fr_type
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* switch (fr_type) */
block|}
comment|/* for each frag. */
ifndef|#
directive|ifndef
name|WORKING_DOT_WORD
block|{
name|struct
name|broken_word
modifier|*
name|lie
decl_stmt|;
name|struct
name|broken_word
modifier|*
modifier|*
name|prevP
decl_stmt|;
name|prevP
operator|=
operator|&
name|broken_words
expr_stmt|;
for|for
control|(
name|lie
operator|=
name|broken_words
init|;
name|lie
condition|;
name|lie
operator|=
name|lie
operator|->
name|next_broken_word
control|)
if|if
condition|(
operator|!
name|lie
operator|->
name|added
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|SPARC
argument_list|)
operator|||
name|defined
argument_list|(
name|I860
argument_list|)
name|fix_new
argument_list|(
name|lie
operator|->
name|frag
argument_list|,
name|lie
operator|->
name|word_goes_here
operator|-
name|lie
operator|->
name|frag
operator|->
name|fr_literal
argument_list|,
literal|2
argument_list|,
name|lie
operator|->
name|add
argument_list|,
name|lie
operator|->
name|sub
argument_list|,
name|lie
operator|->
name|addnum
argument_list|,
literal|0
argument_list|,
name|NO_RELOC
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|NS32K
name|fix_new_ns32k
argument_list|(
name|lie
operator|->
name|frag
argument_list|,
name|lie
operator|->
name|word_goes_here
operator|-
name|lie
operator|->
name|frag
operator|->
name|fr_literal
argument_list|,
literal|2
argument_list|,
name|lie
operator|->
name|add
argument_list|,
name|lie
operator|->
name|sub
argument_list|,
name|lie
operator|->
name|addnum
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|!
name|defined
argument_list|(
name|SPARC
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|NS32K
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|I860
argument_list|)
name|fix_new
argument_list|(
name|lie
operator|->
name|frag
argument_list|,
name|lie
operator|->
name|word_goes_here
operator|-
name|lie
operator|->
name|frag
operator|->
name|fr_literal
argument_list|,
literal|2
argument_list|,
name|lie
operator|->
name|add
argument_list|,
name|lie
operator|->
name|sub
argument_list|,
name|lie
operator|->
name|addnum
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* md_number_to_chars(lie->word_goes_here, 			       lie->add->sy_value 			       + lie->addnum 			       - (lie->sub->sy_value), 			     2); */
operator|*
name|prevP
operator|=
name|lie
operator|->
name|next_broken_word
expr_stmt|;
block|}
else|else
name|prevP
operator|=
operator|&
operator|(
name|lie
operator|->
name|next_broken_word
operator|)
expr_stmt|;
for|for
control|(
name|lie
operator|=
name|broken_words
init|;
name|lie
condition|;
control|)
block|{
name|struct
name|broken_word
modifier|*
name|untruth
decl_stmt|;
name|char
modifier|*
name|table_ptr
decl_stmt|;
name|long
name|table_addr
decl_stmt|;
name|long
name|from_addr
decl_stmt|,
name|to_addr
decl_stmt|;
name|int
name|n
decl_stmt|,
name|m
decl_stmt|;
extern|extern	md_short_jump_size;
extern|extern	md_long_jump_size;
name|void
name|md_create_short_jump
parameter_list|()
function_decl|;
name|void
name|md_create_long_jump
parameter_list|()
function_decl|;
name|fragP
operator|=
name|lie
operator|->
name|dispfrag
expr_stmt|;
comment|/* Find out how many broken_words go here */
name|n
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|untruth
operator|=
name|lie
init|;
name|untruth
operator|&&
name|untruth
operator|->
name|dispfrag
operator|==
name|fragP
condition|;
name|untruth
operator|=
name|untruth
operator|->
name|next_broken_word
control|)
if|if
condition|(
name|untruth
operator|->
name|added
operator|==
literal|1
condition|)
name|n
operator|++
expr_stmt|;
name|table_ptr
operator|=
name|lie
operator|->
name|dispfrag
operator|->
name|fr_opcode
expr_stmt|;
name|table_addr
operator|=
name|lie
operator|->
name|dispfrag
operator|->
name|fr_address
operator|+
operator|(
name|table_ptr
operator|-
name|lie
operator|->
name|dispfrag
operator|->
name|fr_literal
operator|)
expr_stmt|;
comment|/* Create the jump around the long jumps */
comment|/* This is a short jump from table_ptr+0 to table_ptr+n*long_jump_size */
name|from_addr
operator|=
name|table_addr
expr_stmt|;
name|to_addr
operator|=
name|table_addr
operator|+
name|md_short_jump_size
operator|+
name|n
operator|*
name|md_long_jump_size
expr_stmt|;
name|md_create_short_jump
argument_list|(
name|table_ptr
argument_list|,
name|from_addr
argument_list|,
name|to_addr
argument_list|,
name|lie
operator|->
name|dispfrag
argument_list|,
name|lie
operator|->
name|add
argument_list|)
expr_stmt|;
name|table_ptr
operator|+=
name|md_short_jump_size
expr_stmt|;
name|table_addr
operator|+=
name|md_short_jump_size
expr_stmt|;
for|for
control|(
name|m
operator|=
literal|0
init|;
name|lie
operator|&&
name|lie
operator|->
name|dispfrag
operator|==
name|fragP
condition|;
name|m
operator|++
operator|,
name|lie
operator|=
name|lie
operator|->
name|next_broken_word
control|)
block|{
if|if
condition|(
name|lie
operator|->
name|added
operator|==
literal|2
condition|)
continue|continue;
comment|/* Patch the jump table */
comment|/* This is the offset from ??? to table_ptr+0 */
name|to_addr
operator|=
name|table_addr
operator|-
operator|(
name|lie
operator|->
name|sub
operator|->
name|sy_value
operator|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|lie
operator|->
name|word_goes_here
argument_list|,
name|to_addr
argument_list|,
literal|2
argument_list|)
expr_stmt|;
for|for
control|(
name|untruth
operator|=
name|lie
operator|->
name|next_broken_word
init|;
name|untruth
operator|&&
name|untruth
operator|->
name|dispfrag
operator|==
name|fragP
condition|;
name|untruth
operator|=
name|untruth
operator|->
name|next_broken_word
control|)
block|{
if|if
condition|(
name|untruth
operator|->
name|use_jump
operator|==
name|lie
condition|)
name|md_number_to_chars
argument_list|(
name|untruth
operator|->
name|word_goes_here
argument_list|,
name|to_addr
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
comment|/* Install the long jump */
comment|/* this is a long jump from table_ptr+0 to the final target */
name|from_addr
operator|=
name|table_addr
expr_stmt|;
name|to_addr
operator|=
name|lie
operator|->
name|add
operator|->
name|sy_value
operator|+
name|lie
operator|->
name|addnum
expr_stmt|;
name|md_create_long_jump
argument_list|(
name|table_ptr
argument_list|,
name|from_addr
argument_list|,
name|to_addr
argument_list|,
name|lie
operator|->
name|dispfrag
argument_list|,
name|lie
operator|->
name|add
argument_list|)
expr_stmt|;
name|table_ptr
operator|+=
name|md_long_jump_size
expr_stmt|;
name|table_addr
operator|+=
name|md_long_jump_size
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
ifndef|#
directive|ifndef
name|VMS
comment|/*    * Scan every FixS performing fixups. We had to wait until now to do    * this because md_convert_frag() may have made some fixSs.    */
comment|/* the_exec . a_trsize     = sizeof(struct relocation_info) * fixup_segment (text_fix_root, N_TEXT);   the_exec . a_drsize     = sizeof(struct relocation_info) * fixup_segment (data_fix_root, N_DATA); */
name|tr_siz
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|relocation_info
argument_list|)
operator|*
name|fixup_segment
argument_list|(
name|text_fix_root
argument_list|,
name|N_TEXT
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|the_exec
operator|.
name|a_trsize
argument_list|,
name|tr_siz
argument_list|,
sizeof|sizeof
argument_list|(
name|the_exec
operator|.
name|a_trsize
argument_list|)
argument_list|)
expr_stmt|;
name|dr_siz
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|relocation_info
argument_list|)
operator|*
name|fixup_segment
argument_list|(
name|data_fix_root
argument_list|,
name|N_DATA
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|the_exec
operator|.
name|a_drsize
argument_list|,
name|dr_siz
argument_list|,
sizeof|sizeof
argument_list|(
name|the_exec
operator|.
name|a_drsize
argument_list|)
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|the_exec
operator|.
name|a_info
argument_list|,
name|omagic
argument_list|,
sizeof|sizeof
argument_list|(
name|the_exec
operator|.
name|a_info
argument_list|)
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|the_exec
operator|.
name|a_entry
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|the_exec
operator|.
name|a_entry
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|EXEC_MACHINE_TYPE
name|md_number_to_chars
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|the_exec
operator|.
name|a_machtype
argument_list|,
name|EXEC_MACHINE_TYPE
argument_list|,
sizeof|sizeof
argument_list|(
name|the_exec
operator|.
name|a_machtype
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|EXEC_VERSION
name|md_number_to_chars
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|the_exec
operator|.
name|a_version
argument_list|,
name|EXEC_VERSION
argument_list|,
sizeof|sizeof
argument_list|(
name|the_exec
operator|.
name|a_version
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* the_exec . a_entry = 0; */
name|size_of_the_object_file
operator|=
sizeof|sizeof
argument_list|(
name|the_exec
argument_list|)
operator|+
name|text_siz
operator|+
name|data_siz
operator|+
name|syms_siz
operator|+
name|tr_siz
operator|+
name|dr_siz
operator|+
name|string_byte_count
expr_stmt|;
name|next_object_file_charP
operator|=
name|the_object_file
operator|=
name|xmalloc
argument_list|(
name|size_of_the_object_file
argument_list|)
expr_stmt|;
name|output_file_create
argument_list|(
name|out_file_name
argument_list|)
expr_stmt|;
name|append
argument_list|(
operator|&
name|next_object_file_charP
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
operator|&
name|the_exec
operator|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
sizeof|sizeof
argument_list|(
name|the_exec
argument_list|)
argument_list|)
expr_stmt|;
comment|/*    * Emit code.    */
for|for
control|(
name|fragP
operator|=
name|text_frag_root
init|;
name|fragP
condition|;
name|fragP
operator|=
name|fragP
operator|->
name|fr_next
control|)
block|{
specifier|register
name|long
name|int
name|count
decl_stmt|;
specifier|register
name|char
modifier|*
name|fill_literal
decl_stmt|;
specifier|register
name|long
name|int
name|fill_size
decl_stmt|;
name|know
argument_list|(
name|fragP
operator|->
name|fr_type
operator|==
name|rs_fill
argument_list|)
expr_stmt|;
name|append
argument_list|(
operator|&
name|next_object_file_charP
argument_list|,
name|fragP
operator|->
name|fr_literal
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|fragP
operator|->
name|fr_fix
argument_list|)
expr_stmt|;
name|fill_literal
operator|=
name|fragP
operator|->
name|fr_literal
operator|+
name|fragP
operator|->
name|fr_fix
expr_stmt|;
name|fill_size
operator|=
name|fragP
operator|->
name|fr_var
expr_stmt|;
name|know
argument_list|(
name|fragP
operator|->
name|fr_offset
operator|>=
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|count
operator|=
name|fragP
operator|->
name|fr_offset
init|;
name|count
condition|;
name|count
operator|--
control|)
name|append
argument_list|(
operator|&
name|next_object_file_charP
argument_list|,
name|fill_literal
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|fill_size
argument_list|)
expr_stmt|;
block|}
comment|/* for each code frag. */
comment|/*    * Emit relocations.    */
name|emit_relocations
argument_list|(
name|text_fix_root
argument_list|,
operator|(
name|relax_addressT
operator|)
literal|0
argument_list|)
expr_stmt|;
name|emit_relocations
argument_list|(
name|data_fix_root
argument_list|,
name|text_last_frag
operator|->
name|fr_address
argument_list|)
expr_stmt|;
comment|/*    * Emit all symbols left in the symbol chain.    * Any symbol still undefined is made N_EXT.    */
for|for
control|(
name|symbolP
operator|=
name|symbol_rootP
init|;
name|symbolP
condition|;
name|symbolP
operator|=
name|symbolP
operator|->
name|sy_next
control|)
block|{
specifier|register
name|char
modifier|*
name|temp
decl_stmt|;
name|temp
operator|=
name|symbolP
operator|->
name|sy_nlist
operator|.
name|n_un
operator|.
name|n_name
expr_stmt|;
comment|/* JF fix the numbers up. Call by value RULES! */
name|md_number_to_chars
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|symbolP
operator|->
name|sy_nlist
operator|.
name|n_un
operator|.
name|n_strx
operator|)
argument_list|,
name|symbolP
operator|->
name|sy_name_offset
argument_list|,
sizeof|sizeof
argument_list|(
name|symbolP
operator|->
name|sy_nlist
operator|.
name|n_un
operator|.
name|n_strx
argument_list|)
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|symbolP
operator|->
name|sy_nlist
operator|.
name|n_desc
operator|)
argument_list|,
name|symbolP
operator|->
name|sy_nlist
operator|.
name|n_desc
argument_list|,
sizeof|sizeof
argument_list|(
name|symbolP
operator|->
name|sy_nlist
operator|.
name|n_desc
argument_list|)
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|symbolP
operator|->
name|sy_nlist
operator|.
name|n_value
operator|)
argument_list|,
name|symbolP
operator|->
name|sy_nlist
operator|.
name|n_value
argument_list|,
sizeof|sizeof
argument_list|(
name|symbolP
operator|->
name|sy_nlist
operator|.
name|n_value
argument_list|)
argument_list|)
expr_stmt|;
comment|/* symbolP -> sy_nlist  . n_un . n_strx = symbolP -> sy_name_offset; JF replaced by md above */
if|if
condition|(
name|symbolP
operator|->
name|sy_type
operator|==
name|N_UNDF
condition|)
name|symbolP
operator|->
name|sy_type
operator||=
name|N_EXT
expr_stmt|;
comment|/* Any undefined symbols become N_EXT. */
name|append
argument_list|(
operator|&
name|next_object_file_charP
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
operator|&
name|symbolP
operator|->
name|sy_nlist
operator|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|nlist
argument_list|)
argument_list|)
expr_stmt|;
name|symbolP
operator|->
name|sy_nlist
operator|.
name|n_un
operator|.
name|n_name
operator|=
name|temp
expr_stmt|;
block|}
comment|/* for each symbol */
comment|/*    * next_object_file_charP -> slot for next object byte.    * Emit strings.    * Find strings by crawling along symbol table chain.    */
comment|/* Gotta do md_ byte-ordering stuff for string_byte_count first - KWK */
name|md_number_to_chars
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|string_byte_count
argument_list|,
name|string_byte_count
argument_list|,
sizeof|sizeof
argument_list|(
name|string_byte_count
argument_list|)
argument_list|)
expr_stmt|;
name|append
argument_list|(
operator|&
name|next_object_file_charP
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|string_byte_count
argument_list|,
operator|(
name|unsigned
name|long
operator|)
sizeof|sizeof
argument_list|(
name|string_byte_count
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|symbolP
operator|=
name|symbol_rootP
init|;
name|symbolP
condition|;
name|symbolP
operator|=
name|symbolP
operator|->
name|sy_next
control|)
block|{
if|if
condition|(
name|symbolP
operator|->
name|sy_name
condition|)
block|{
comment|/* Ordinary case: not .stabd. */
name|append
argument_list|(
operator|&
name|next_object_file_charP
argument_list|,
name|symbolP
operator|->
name|sy_name
argument_list|,
call|(
name|unsigned
name|long
call|)
argument_list|(
name|strlen
argument_list|(
name|symbolP
operator|->
name|sy_name
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* for each symbol */
name|know
argument_list|(
name|next_object_file_charP
operator|==
name|the_object_file
operator|+
name|size_of_the_object_file
argument_list|)
expr_stmt|;
name|output_file_append
argument_list|(
name|the_object_file
argument_list|,
name|size_of_the_object_file
argument_list|,
name|out_file_name
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DONTDEF
if|if
condition|(
name|flagseen
index|[
literal|'G'
index|]
condition|)
comment|/* GDB symbol file to be appended? */
block|{
name|gdb_emit
argument_list|(
name|out_file_name
argument_list|)
expr_stmt|;
name|gdb_end
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
name|output_file_close
argument_list|(
name|out_file_name
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* VMS */
comment|/*    *	Now do the VMS-dependent part of writing the object file    */
name|VMS_write_object_file
argument_list|(
name|text_siz
argument_list|,
name|data_siz
argument_list|,
name|text_frag_root
argument_list|,
name|data_frag_root
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* VMS */
block|}
end_function

begin_comment
comment|/* write_object_file() */
end_comment

begin_escape
end_escape

begin_comment
comment|/*  *			relax_segment()  *  * Now we have a segment, not a crowd of sub-segments, we can make fr_address  * values.  *  * Relax the frags.  *  * After this, all frags in this segment have addresses that are correct  * within the segment. Since segments live in different file addresses,  * these frag addresses may not be the same as final object-file addresses.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|VMS
end_ifndef

begin_function
specifier|static
endif|#
directive|endif
comment|/* not VMS */
name|void
name|relax_segment
parameter_list|(
name|segment_frag_root
parameter_list|,
name|segment_type
parameter_list|)
name|struct
name|frag
modifier|*
name|segment_frag_root
decl_stmt|;
name|segT
name|segment_type
decl_stmt|;
comment|/* N_DATA or N_TEXT */
block|{
specifier|register
name|struct
name|frag
modifier|*
name|fragP
decl_stmt|;
specifier|register
name|relax_addressT
name|address
decl_stmt|;
comment|/* register relax_addressT	old_address; JF unused */
comment|/* register relax_addressT	new_address; JF unused */
name|know
argument_list|(
name|segment_type
operator|==
name|SEG_DATA
operator|||
name|segment_type
operator|==
name|SEG_TEXT
argument_list|)
expr_stmt|;
comment|/* In case md_estimate_size_before_relax() wants to make fixSs. */
name|subseg_change
argument_list|(
name|segment_type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*    * For each frag in segment: count and store  (a 1st guess of) fr_address.    */
name|address
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|fragP
operator|=
name|segment_frag_root
init|;
name|fragP
condition|;
name|fragP
operator|=
name|fragP
operator|->
name|fr_next
control|)
block|{
name|fragP
operator|->
name|fr_address
operator|=
name|address
expr_stmt|;
name|address
operator|+=
name|fragP
operator|->
name|fr_fix
expr_stmt|;
switch|switch
condition|(
name|fragP
operator|->
name|fr_type
condition|)
block|{
case|case
name|rs_fill
case|:
name|address
operator|+=
name|fragP
operator|->
name|fr_offset
operator|*
name|fragP
operator|->
name|fr_var
expr_stmt|;
break|break;
case|case
name|rs_align
case|:
name|address
operator|+=
name|relax_align
argument_list|(
name|address
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|)
expr_stmt|;
break|break;
case|case
name|rs_org
case|:
comment|/* 	   * Assume .org is nugatory. It will grow with 1st relax. 	   */
break|break;
case|case
name|rs_machine_dependent
case|:
name|address
operator|+=
name|md_estimate_size_before_relax
argument_list|(
name|fragP
argument_list|,
name|seg_N_TYPE
index|[
operator|(
name|int
operator|)
name|segment_type
index|]
argument_list|)
expr_stmt|;
break|break;
ifndef|#
directive|ifndef
name|WORKING_DOT_WORD
comment|/* Broken words don't concern us yet */
case|case
name|rs_broken_word
case|:
break|break;
endif|#
directive|endif
default|default:
name|BAD_CASE
argument_list|(
name|fragP
operator|->
name|fr_type
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* switch(fr_type) */
block|}
comment|/* for each frag in the segment */
comment|/*    * Do relax().    */
block|{
specifier|register
name|long
name|int
name|stretch
decl_stmt|;
comment|/* May be any size, 0 or negative. */
comment|/* Cumulative number of addresses we have */
comment|/* relaxed this pass. */
comment|/* We may have relaxed more than one address. */
specifier|register
name|long
name|int
name|stretched
decl_stmt|;
comment|/* Have we stretched on this pass? */
comment|/* This is 'cuz stretch may be zero, when, 				     in fact some piece of code grew, and 				     another shrank.  If a branch instruction 				     doesn't fit anymore, we could be scrod */
do|do
block|{
name|stretch
operator|=
name|stretched
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|fragP
operator|=
name|segment_frag_root
init|;
name|fragP
condition|;
name|fragP
operator|=
name|fragP
operator|->
name|fr_next
control|)
block|{
specifier|register
name|long
name|int
name|growth
decl_stmt|;
specifier|register
name|long
name|int
name|was_address
decl_stmt|;
comment|/* register long int	var; */
specifier|register
name|long
name|int
name|offset
decl_stmt|;
specifier|register
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
specifier|register
name|long
name|int
name|target
decl_stmt|;
specifier|register
name|long
name|int
name|after
decl_stmt|;
specifier|register
name|long
name|int
name|aim
decl_stmt|;
name|was_address
operator|=
name|fragP
operator|->
name|fr_address
expr_stmt|;
name|address
operator|=
name|fragP
operator|->
name|fr_address
operator|+=
name|stretch
expr_stmt|;
name|symbolP
operator|=
name|fragP
operator|->
name|fr_symbol
expr_stmt|;
name|offset
operator|=
name|fragP
operator|->
name|fr_offset
expr_stmt|;
comment|/* var = fragP -> fr_var; */
switch|switch
condition|(
name|fragP
operator|->
name|fr_type
condition|)
block|{
case|case
name|rs_fill
case|:
comment|/* .fill never relaxes. */
name|growth
operator|=
literal|0
expr_stmt|;
break|break;
ifndef|#
directive|ifndef
name|WORKING_DOT_WORD
comment|/* JF:  This is RMS's idea.  I do *NOT* want to be blamed 		   for it I do not want to write it.  I do not want to have 		   anything to do with it.  This is not the proper way to 		   implement this misfeature. */
case|case
name|rs_broken_word
case|:
block|{
name|struct
name|broken_word
modifier|*
name|lie
decl_stmt|;
name|struct
name|broken_word
modifier|*
name|untruth
decl_stmt|;
specifier|extern
name|int
name|md_short_jump_size
decl_stmt|;
specifier|extern
name|int
name|md_long_jump_size
decl_stmt|;
comment|/* Yes this is ugly (storing the broken_word pointer 			   in the symbol slot).  Still, this whole chunk of 			   code is ugly, and I don't feel like doing anything 			   about it.  Think of it as stubbornness in action */
name|growth
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|lie
operator|=
operator|(
expr|struct
name|broken_word
operator|*
operator|)
operator|(
name|fragP
operator|->
name|fr_symbol
operator|)
init|;
name|lie
operator|&&
name|lie
operator|->
name|dispfrag
operator|==
name|fragP
condition|;
name|lie
operator|=
name|lie
operator|->
name|next_broken_word
control|)
block|{
if|if
condition|(
name|lie
operator|->
name|added
condition|)
continue|continue;
name|offset
operator|=
name|lie
operator|->
name|add
operator|->
name|sy_frag
operator|->
name|fr_address
operator|+
name|lie
operator|->
name|add
operator|->
name|sy_value
operator|+
name|lie
operator|->
name|addnum
operator|-
operator|(
name|lie
operator|->
name|sub
operator|->
name|sy_frag
operator|->
name|fr_address
operator|+
name|lie
operator|->
name|sub
operator|->
name|sy_value
operator|)
expr_stmt|;
if|if
condition|(
name|offset
operator|<=
operator|-
literal|32768
operator|||
name|offset
operator|>=
literal|32767
condition|)
block|{
if|if
condition|(
name|flagseen
index|[
literal|'k'
index|]
condition|)
name|as_warn
argument_list|(
literal|".word %s-%s+%ld didn't fit"
argument_list|,
name|lie
operator|->
name|add
operator|->
name|sy_name
argument_list|,
name|lie
operator|->
name|sub
operator|->
name|sy_name
argument_list|,
name|lie
operator|->
name|addnum
argument_list|)
expr_stmt|;
name|lie
operator|->
name|added
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|fragP
operator|->
name|fr_subtype
operator|==
literal|0
condition|)
block|{
name|fragP
operator|->
name|fr_subtype
operator|++
expr_stmt|;
name|growth
operator|+=
name|md_short_jump_size
expr_stmt|;
block|}
for|for
control|(
name|untruth
operator|=
name|lie
operator|->
name|next_broken_word
init|;
name|untruth
operator|&&
name|untruth
operator|->
name|dispfrag
operator|==
name|lie
operator|->
name|dispfrag
condition|;
name|untruth
operator|=
name|untruth
operator|->
name|next_broken_word
control|)
if|if
condition|(
name|untruth
operator|->
name|add
operator|->
name|sy_frag
operator|==
name|lie
operator|->
name|add
operator|->
name|sy_frag
operator|&&
name|untruth
operator|->
name|add
operator|->
name|sy_value
operator|==
name|lie
operator|->
name|add
operator|->
name|sy_value
condition|)
block|{
name|untruth
operator|->
name|added
operator|=
literal|2
expr_stmt|;
name|untruth
operator|->
name|use_jump
operator|=
name|lie
expr_stmt|;
block|}
name|growth
operator|+=
name|md_long_jump_size
expr_stmt|;
block|}
block|}
block|}
break|break;
endif|#
directive|endif
case|case
name|rs_align
case|:
name|growth
operator|=
name|relax_align
argument_list|(
call|(
name|relax_addressT
call|)
argument_list|(
name|address
operator|+
name|fragP
operator|->
name|fr_fix
argument_list|)
argument_list|,
name|offset
argument_list|)
operator|-
name|relax_align
argument_list|(
call|(
name|relax_addressT
call|)
argument_list|(
name|was_address
operator|+
name|fragP
operator|->
name|fr_fix
argument_list|)
argument_list|,
name|offset
argument_list|)
expr_stmt|;
break|break;
case|case
name|rs_org
case|:
name|target
operator|=
name|offset
expr_stmt|;
if|if
condition|(
name|symbolP
condition|)
block|{
name|know
argument_list|(
operator|(
operator|(
name|symbolP
operator|->
name|sy_type
operator|&
name|N_TYPE
operator|)
operator|==
name|N_ABS
operator|)
operator|||
operator|(
operator|(
name|symbolP
operator|->
name|sy_type
operator|&
name|N_TYPE
operator|)
operator|==
name|N_DATA
operator|)
operator|||
operator|(
operator|(
name|symbolP
operator|->
name|sy_type
operator|&
name|N_TYPE
operator|)
operator|==
name|N_TEXT
operator|)
argument_list|)
expr_stmt|;
name|know
argument_list|(
name|symbolP
operator|->
name|sy_frag
argument_list|)
expr_stmt|;
name|know
argument_list|(
operator|(
name|symbolP
operator|->
name|sy_type
operator|&
name|N_TYPE
operator|)
operator|!=
name|N_ABS
operator|||
name|symbolP
operator|->
name|sy_frag
operator|==
operator|&
name|zero_address_frag
argument_list|)
expr_stmt|;
name|target
operator|+=
name|symbolP
operator|->
name|sy_value
operator|+
name|symbolP
operator|->
name|sy_frag
operator|->
name|fr_address
expr_stmt|;
block|}
name|know
argument_list|(
name|fragP
operator|->
name|fr_next
argument_list|)
expr_stmt|;
name|after
operator|=
name|fragP
operator|->
name|fr_next
operator|->
name|fr_address
expr_stmt|;
name|growth
operator|=
operator|(
operator|(
name|target
operator|-
name|after
operator|)
operator|>
literal|0
operator|)
condition|?
operator|(
name|target
operator|-
name|after
operator|)
else|:
literal|0
expr_stmt|;
comment|/* Growth may be -ve, but variable part */
comment|/* of frag cannot have< 0 chars. */
comment|/* That is, we can't .org backwards. */
name|growth
operator|-=
name|stretch
expr_stmt|;
comment|/* This is an absolute growth factor */
break|break;
case|case
name|rs_machine_dependent
case|:
block|{
specifier|register
specifier|const
name|relax_typeS
modifier|*
name|this_type
decl_stmt|;
specifier|register
specifier|const
name|relax_typeS
modifier|*
name|start_type
decl_stmt|;
specifier|register
name|relax_substateT
name|next_state
decl_stmt|;
specifier|register
name|relax_substateT
name|this_state
decl_stmt|;
name|start_type
operator|=
name|this_type
operator|=
name|md_relax_table
operator|+
operator|(
name|this_state
operator|=
name|fragP
operator|->
name|fr_subtype
operator|)
expr_stmt|;
name|target
operator|=
name|offset
expr_stmt|;
if|if
condition|(
name|symbolP
condition|)
block|{
name|know
argument_list|(
operator|(
operator|(
name|symbolP
operator|->
name|sy_type
operator|&
name|N_TYPE
operator|)
operator|==
name|N_ABS
operator|)
operator|||
operator|(
operator|(
name|symbolP
operator|->
name|sy_type
operator|&
name|N_TYPE
operator|)
operator|==
name|N_DATA
operator|)
operator|||
operator|(
operator|(
name|symbolP
operator|->
name|sy_type
operator|&
name|N_TYPE
operator|)
operator|==
name|N_TEXT
operator|)
argument_list|)
expr_stmt|;
name|know
argument_list|(
name|symbolP
operator|->
name|sy_frag
argument_list|)
expr_stmt|;
name|know
argument_list|(
operator|(
name|symbolP
operator|->
name|sy_type
operator|&
name|N_TYPE
operator|)
operator|!=
name|N_ABS
operator|||
name|symbolP
operator|->
name|sy_frag
operator|==
operator|&
name|zero_address_frag
argument_list|)
expr_stmt|;
name|target
operator|+=
name|symbolP
operator|->
name|sy_value
operator|+
name|symbolP
operator|->
name|sy_frag
operator|->
name|fr_address
expr_stmt|;
comment|/* If frag has yet to be reached on this pass, 			   assume it will move by STRETCH just as we did. 			   If this is not so, it will be because some frag 			   between grows, and that will force another pass.  */
comment|/* JF was just address */
comment|/* JF also added is_dnrange hack */
comment|/* There's gotta be a better/faster/etc way 				   to do this. . . */
comment|/* gnu@cygnus.com:  I changed this from> to>= 			   because I ran into a zero-length frag (fr_fix=0) 			   which was created when the obstack needed a new 			   chunk JUST AFTER the opcode of a branch.  Since 			   fr_fix is zero, fr_address of this frag is the same 			   as fr_address of the next frag.  This 			   zero-length frag was variable and jumped to .+2 			   (in the next frag), but since the> comparison 			   below failed (the two were =, not>), "stretch" 			   was not added to the target.  Stretch was 178, so 			   the offset appeared to be .-176 instead, which did 			   not fit into a byte branch, so the assembler 			   relaxed the branch to a word.  This didn't compare 			   with what happened when the same source file was 			   assembled on other machines, which is how I found it. 			   You might want to think about what other places have 			   trouble with zero length frags... */
if|if
condition|(
name|symbolP
operator|->
name|sy_frag
operator|->
name|fr_address
operator|>=
name|was_address
operator|&&
name|is_dnrange
argument_list|(
name|fragP
argument_list|,
name|symbolP
operator|->
name|sy_frag
argument_list|)
condition|)
name|target
operator|+=
name|stretch
expr_stmt|;
block|}
name|aim
operator|=
name|target
operator|-
name|address
operator|-
name|fragP
operator|->
name|fr_fix
expr_stmt|;
comment|/* The displacement is affected by the instruction size 		   * for the 32k architecture. I think we ought to be able 		   * to add fragP->fr_pcrel_adjust in all cases (it should be 		   * zero if not used), but just in case it breaks something 		   * else we'll put this inside #ifdef NS32K ... #endif 		   */
ifdef|#
directive|ifdef
name|NS32K
name|aim
operator|+=
name|fragP
operator|->
name|fr_pcrel_adjust
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|aim
operator|<
literal|0
condition|)
block|{
comment|/* Look backwards. */
for|for
control|(
name|next_state
operator|=
name|this_type
operator|->
name|rlx_more
init|;
name|next_state
condition|;
control|)
block|{
if|if
condition|(
name|aim
operator|>=
name|this_type
operator|->
name|rlx_backward
condition|)
name|next_state
operator|=
literal|0
expr_stmt|;
else|else
block|{
comment|/* Grow to next state. */
name|this_type
operator|=
name|md_relax_table
operator|+
operator|(
name|this_state
operator|=
name|next_state
operator|)
expr_stmt|;
name|next_state
operator|=
name|this_type
operator|->
name|rlx_more
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|DONTDEF
comment|/* JF these next few lines of code are for the mc68020 which can't handle short    offsets of zero in branch instructions.  What a kludge! */
if|if
condition|(
name|aim
operator|==
literal|0
operator|&&
name|this_state
operator|==
operator|(
literal|1
operator|<<
literal|2
operator|+
literal|0
operator|)
condition|)
block|{
comment|/* FOO hard encoded from m.c */
name|aim
operator|=
name|this_type
operator|->
name|rlx_forward
operator|+
literal|1
expr_stmt|;
comment|/* Force relaxation into word mode */
block|}
endif|#
directive|endif
comment|/* JF end of 68020 code */
comment|/* Look forwards. */
for|for
control|(
name|next_state
operator|=
name|this_type
operator|->
name|rlx_more
init|;
name|next_state
condition|;
control|)
block|{
if|if
condition|(
name|aim
operator|<=
name|this_type
operator|->
name|rlx_forward
condition|)
name|next_state
operator|=
literal|0
expr_stmt|;
else|else
block|{
comment|/* Grow to next state. */
name|this_type
operator|=
name|md_relax_table
operator|+
operator|(
name|this_state
operator|=
name|next_state
operator|)
expr_stmt|;
name|next_state
operator|=
name|this_type
operator|->
name|rlx_more
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|growth
operator|=
name|this_type
operator|->
name|rlx_length
operator|-
name|start_type
operator|->
name|rlx_length
condition|)
name|fragP
operator|->
name|fr_subtype
operator|=
name|this_state
expr_stmt|;
block|}
break|break;
default|default:
name|BAD_CASE
argument_list|(
name|fragP
operator|->
name|fr_type
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|growth
condition|)
block|{
name|stretch
operator|+=
name|growth
expr_stmt|;
name|stretched
operator|++
expr_stmt|;
block|}
block|}
comment|/* For each frag in the segment. */
block|}
do|while
condition|(
name|stretched
condition|)
do|;
comment|/* Until nothing further to relax. */
block|}
comment|/*    * We now have valid fr_address'es for each frag.    */
comment|/*    * All fr_address's are correct, relative to their own segment.    * We have made all the fixS we will ever make.    */
block|}
end_function

begin_comment
comment|/* relax_segment() */
end_comment

begin_escape
end_escape

begin_comment
comment|/*  * Relax_align. Advance location counter to next address that has 'alignment'  * lowest order bits all 0s.  */
end_comment

begin_function
specifier|static
name|relax_addressT
comment|/* How many addresses does the .align take? */
name|relax_align
parameter_list|(
name|address
parameter_list|,
name|alignment
parameter_list|)
specifier|register
name|relax_addressT
name|address
decl_stmt|;
comment|/* Address now. */
specifier|register
name|long
name|int
name|alignment
decl_stmt|;
comment|/* Alignment (binary). */
block|{
name|relax_addressT
name|mask
decl_stmt|;
name|relax_addressT
name|new_address
decl_stmt|;
name|mask
operator|=
operator|~
operator|(
operator|(
operator|~
literal|0
operator|)
operator|<<
name|alignment
operator|)
expr_stmt|;
name|new_address
operator|=
operator|(
name|address
operator|+
name|mask
operator|)
operator|&
operator|(
operator|~
name|mask
operator|)
expr_stmt|;
return|return
operator|(
name|new_address
operator|-
name|address
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *			fixup_segment()  */
end_comment

begin_function
specifier|static
name|long
name|int
name|fixup_segment
parameter_list|(
name|fixP
parameter_list|,
name|this_segment_type
parameter_list|)
specifier|register
name|fixS
modifier|*
name|fixP
decl_stmt|;
name|int
name|this_segment_type
decl_stmt|;
comment|/* N_TYPE bits for segment. */
block|{
specifier|register
name|long
name|int
name|seg_reloc_count
decl_stmt|;
comment|/* JF these all used to be local to the for loop, but GDB doesn't seem to be able to deal with them there, so I moved them here for a bit. */
specifier|register
name|symbolS
modifier|*
name|add_symbolP
decl_stmt|;
specifier|register
name|symbolS
modifier|*
name|sub_symbolP
decl_stmt|;
specifier|register
name|long
name|int
name|add_number
decl_stmt|;
specifier|register
name|int
name|size
decl_stmt|;
specifier|register
name|char
modifier|*
name|place
decl_stmt|;
specifier|register
name|long
name|int
name|where
decl_stmt|;
specifier|register
name|char
name|pcrel
decl_stmt|;
specifier|register
name|fragS
modifier|*
name|fragP
decl_stmt|;
specifier|register
name|int
name|add_symbol_N_TYPE
decl_stmt|;
name|seg_reloc_count
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
name|fixP
condition|;
name|fixP
operator|=
name|fixP
operator|->
name|fx_next
control|)
block|{
name|fragP
operator|=
name|fixP
operator|->
name|fx_frag
expr_stmt|;
name|know
argument_list|(
name|fragP
argument_list|)
expr_stmt|;
name|where
operator|=
name|fixP
operator|->
name|fx_where
expr_stmt|;
name|place
operator|=
name|fragP
operator|->
name|fr_literal
operator|+
name|where
expr_stmt|;
name|size
operator|=
name|fixP
operator|->
name|fx_size
expr_stmt|;
name|add_symbolP
operator|=
name|fixP
operator|->
name|fx_addsy
expr_stmt|;
name|sub_symbolP
operator|=
name|fixP
operator|->
name|fx_subsy
expr_stmt|;
name|add_number
operator|=
name|fixP
operator|->
name|fx_offset
expr_stmt|;
name|pcrel
operator|=
name|fixP
operator|->
name|fx_pcrel
expr_stmt|;
if|if
condition|(
name|add_symbolP
condition|)
name|add_symbol_N_TYPE
operator|=
name|add_symbolP
operator|->
name|sy_type
operator|&
name|N_TYPE
expr_stmt|;
if|if
condition|(
name|sub_symbolP
condition|)
block|{
if|if
condition|(
operator|!
name|add_symbolP
condition|)
comment|/* Its just -sym */
block|{
if|if
condition|(
name|sub_symbolP
operator|->
name|sy_type
operator|!=
name|N_ABS
condition|)
name|as_warn
argument_list|(
literal|"Negative of non-absolute symbol %s"
argument_list|,
name|sub_symbolP
operator|->
name|sy_name
argument_list|)
expr_stmt|;
name|add_number
operator|-=
name|sub_symbolP
operator|->
name|sy_value
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|(
name|sub_symbolP
operator|->
name|sy_type
operator|^
name|add_symbol_N_TYPE
operator|)
operator|&
name|N_TYPE
operator|)
operator|==
literal|0
operator|&&
operator|(
name|add_symbol_N_TYPE
operator|==
name|N_DATA
operator|||
name|add_symbol_N_TYPE
operator|==
name|N_TEXT
operator|||
name|add_symbol_N_TYPE
operator|==
name|N_BSS
operator|||
name|add_symbol_N_TYPE
operator|==
name|N_ABS
operator|)
condition|)
block|{
comment|/* Difference of 2 symbols from same segment. */
comment|/* Can't make difference of 2 undefineds: 'value' means */
comment|/* something different for N_UNDF. */
name|add_number
operator|+=
name|add_symbolP
operator|->
name|sy_value
operator|-
name|sub_symbolP
operator|->
name|sy_value
expr_stmt|;
name|add_symbolP
operator|=
name|NULL
expr_stmt|;
name|fixP
operator|->
name|fx_addsy
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
comment|/* Different segments in subtraction. */
name|know
argument_list|(
argument|sub_symbolP -> sy_type != (N_ABS | N_EXT)
argument_list|)
if|if
condition|(
name|sub_symbolP
operator|->
name|sy_type
operator|==
name|N_ABS
condition|)
name|add_number
operator|-=
name|sub_symbolP
operator|->
name|sy_value
expr_stmt|;
else|else
block|{
name|as_warn
argument_list|(
literal|"Can't emit reloc {- %s-seg symbol \"%s\"} @ file address %d."
argument_list|,
name|seg_name
index|[
operator|(
name|int
operator|)
name|N_TYPE_seg
index|[
name|sub_symbolP
operator|->
name|sy_type
operator|&
name|N_TYPE
index|]
index|]
argument_list|,
name|sub_symbolP
operator|->
name|sy_name
argument_list|,
name|fragP
operator|->
name|fr_address
operator|+
name|where
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|add_symbolP
condition|)
block|{
if|if
condition|(
name|add_symbol_N_TYPE
operator|==
name|this_segment_type
operator|&&
name|pcrel
condition|)
block|{
comment|/* 	       * This fixup was made when the symbol's segment was 	       * SEG_UNKNOWN, but it is now in the local segment. 	       * So we know how to do the address without relocation. 	       */
name|add_number
operator|+=
name|add_symbolP
operator|->
name|sy_value
expr_stmt|;
name|add_number
operator|-=
ifndef|#
directive|ifndef
name|NS32K
name|size
operator|+
endif|#
directive|endif
name|where
operator|+
name|fragP
operator|->
name|fr_address
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|NS32K
argument_list|)
operator|&&
name|defined
argument_list|(
name|SEQUENT_COMPATABILITY
argument_list|)
if|if
condition|(
name|fragP
operator|->
name|fr_bsr
condition|)
name|add_number
operator|-=
literal|0x12
expr_stmt|;
comment|/* FOO Kludge alert! */
endif|#
directive|endif
comment|/* Kenny thinks this needs * 		/* add_number +=size-2; */
name|pcrel
operator|=
literal|0
expr_stmt|;
comment|/* Lie. Don't want further pcrel processing. */
name|fixP
operator|->
name|fx_addsy
operator|=
name|NULL
expr_stmt|;
comment|/* No relocations please. */
comment|/* 	       * It would be nice to check that the address does not overflow. 	       * I didn't do this check because: 	       * +  It is machine dependent in the general case (eg 32032) 	       * +  Compiler output will never need this checking, so why 	       *    slow down the usual case? 	       */
block|}
else|else
block|{
switch|switch
condition|(
name|add_symbol_N_TYPE
condition|)
block|{
case|case
name|N_ABS
case|:
name|add_number
operator|+=
name|add_symbolP
operator|->
name|sy_value
expr_stmt|;
name|fixP
operator|->
name|fx_addsy
operator|=
name|NULL
expr_stmt|;
name|add_symbolP
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
name|N_BSS
case|:
case|case
name|N_DATA
case|:
case|case
name|N_TEXT
case|:
name|seg_reloc_count
operator|++
expr_stmt|;
name|add_number
operator|+=
name|add_symbolP
operator|->
name|sy_value
expr_stmt|;
break|break;
case|case
name|N_UNDF
case|:
name|seg_reloc_count
operator|++
expr_stmt|;
break|break;
default|default:
name|BAD_CASE
argument_list|(
name|add_symbol_N_TYPE
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* switch on symbol seg */
block|}
comment|/* if not in local seg */
block|}
comment|/* if there was a + symbol */
if|if
condition|(
name|pcrel
condition|)
block|{
name|add_number
operator|-=
ifndef|#
directive|ifndef
name|NS32K
name|size
operator|+
endif|#
directive|endif
name|where
operator|+
name|fragP
operator|->
name|fr_address
expr_stmt|;
if|if
condition|(
name|add_symbolP
operator|==
literal|0
condition|)
block|{
name|fixP
operator|->
name|fx_addsy
operator|=
operator|&
name|abs_symbol
expr_stmt|;
name|seg_reloc_count
operator|++
expr_stmt|;
block|}
block|}
comment|/* OVE added fx_im_disp for ns32k and others */
if|if
condition|(
operator|!
name|fixP
operator|->
name|fx_bit_fixP
condition|)
block|{
comment|/* JF I hope this works . . . */
if|if
condition|(
operator|(
name|size
operator|==
literal|1
operator|&&
operator|(
name|add_number
operator|&
operator|~
literal|0xFF
operator|)
operator|&&
operator|(
name|add_number
operator|&
operator|~
literal|0xFF
operator|!=
operator|(
operator|-
literal|1
operator|&
operator|~
literal|0xFF
operator|)
operator|)
operator|)
operator|||
operator|(
name|size
operator|==
literal|2
operator|&&
operator|(
name|add_number
operator|&
operator|~
literal|0xFFFF
operator|)
operator|&&
operator|(
name|add_number
operator|&
operator|~
literal|0xFFFF
operator|!=
operator|(
operator|-
literal|1
operator|&
operator|~
literal|0xFFFF
operator|)
operator|)
operator|)
condition|)
name|as_warn
argument_list|(
literal|"Fixup of %d too large for field width of %d"
argument_list|,
name|add_number
argument_list|,
name|size
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|fixP
operator|->
name|fx_im_disp
condition|)
block|{
case|case
literal|0
case|:
if|#
directive|if
name|defined
argument_list|(
name|SPARC
argument_list|)
operator|||
name|defined
argument_list|(
name|I860
argument_list|)
name|fixP
operator|->
name|fx_addnumber
operator|=
name|add_number
expr_stmt|;
name|md_number_to_imm
argument_list|(
name|place
argument_list|,
name|add_number
argument_list|,
name|size
argument_list|,
name|fixP
argument_list|,
name|this_segment_type
argument_list|)
expr_stmt|;
else|#
directive|else
name|md_number_to_imm
argument_list|(
name|place
argument_list|,
name|add_number
argument_list|,
name|size
argument_list|)
expr_stmt|;
comment|/* OVE: the immediates, like disps, have lsb at lowest address */
endif|#
directive|endif
break|break;
case|case
literal|1
case|:
name|md_number_to_disp
argument_list|(
name|place
argument_list|,
name|fixP
operator|->
name|fx_pcrel
condition|?
name|add_number
operator|+
name|fixP
operator|->
name|fx_pcrel_adjust
else|:
name|add_number
argument_list|,
name|size
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* fix requested for .long .word etc */
name|md_number_to_chars
argument_list|(
name|place
argument_list|,
name|add_number
argument_list|,
name|size
argument_list|)
expr_stmt|;
break|break;
default|default:
name|as_fatal
argument_list|(
literal|"Internal error in write.c in fixup_segment"
argument_list|)
expr_stmt|;
block|}
comment|/* OVE: maybe one ought to put _imm _disp _chars in one md-func */
block|}
else|else
block|{
name|md_number_to_field
argument_list|(
name|place
argument_list|,
name|add_number
argument_list|,
name|fixP
operator|->
name|fx_bit_fixP
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* For each fixS in this segment. */
return|return
operator|(
name|seg_reloc_count
operator|)
return|;
block|}
end_function

begin_comment
comment|/* fixup_segment() */
end_comment

begin_escape
end_escape

begin_comment
comment|/* The sparc needs its own emit_relocations() */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|SPARC
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|I860
argument_list|)
end_if

begin_comment
comment|/*  *		emit_relocations()  *  * Crawl along a fixS chain. Emit the segment's relocations.  */
end_comment

begin_function
specifier|static
name|void
name|emit_relocations
parameter_list|(
name|fixP
parameter_list|,
name|segment_address_in_file
parameter_list|)
specifier|register
name|fixS
modifier|*
name|fixP
decl_stmt|;
comment|/* Fixup chain for this segment. */
name|relax_addressT
name|segment_address_in_file
decl_stmt|;
block|{
name|struct
name|relocation_info
name|ri
decl_stmt|;
specifier|register
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
comment|/* JF this is for paranoia */
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|ri
argument_list|,
sizeof|sizeof
argument_list|(
name|ri
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|fixP
condition|;
name|fixP
operator|=
name|fixP
operator|->
name|fx_next
control|)
block|{
if|if
condition|(
name|symbolP
operator|=
name|fixP
operator|->
name|fx_addsy
condition|)
block|{
ifdef|#
directive|ifdef
name|NS32K
comment|/* These two 'cuz of NS32K */
name|ri
operator|.
name|r_bsr
operator|=
name|fixP
operator|->
name|fx_bsr
expr_stmt|;
name|ri
operator|.
name|r_disp
operator|=
name|fixP
operator|->
name|fx_im_disp
expr_stmt|;
endif|#
directive|endif
name|ri
operator|.
name|r_length
operator|=
name|nbytes_r_length
index|[
name|fixP
operator|->
name|fx_size
index|]
expr_stmt|;
name|ri
operator|.
name|r_pcrel
operator|=
name|fixP
operator|->
name|fx_pcrel
expr_stmt|;
name|ri
operator|.
name|r_address
operator|=
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
name|fixP
operator|->
name|fx_where
operator|-
name|segment_address_in_file
expr_stmt|;
if|if
condition|(
operator|(
name|symbolP
operator|->
name|sy_type
operator|&
name|N_TYPE
operator|)
operator|==
name|N_UNDF
condition|)
block|{
name|ri
operator|.
name|r_extern
operator|=
literal|1
expr_stmt|;
name|ri
operator|.
name|r_symbolnum
operator|=
name|symbolP
operator|->
name|sy_number
expr_stmt|;
block|}
else|else
block|{
name|ri
operator|.
name|r_extern
operator|=
literal|0
expr_stmt|;
name|ri
operator|.
name|r_symbolnum
operator|=
name|symbolP
operator|->
name|sy_type
operator|&
name|N_TYPE
expr_stmt|;
block|}
comment|/*  	    The 68k machines assign bit-fields from higher bits to  	    lower bits ("left-to-right") within the int.  VAXen assign  	    bit-fields from lower bits to higher bits ("right-to-left"). 	    Both handle multi-byte numbers in their usual fashion 	    (Big-endian and little-endian stuff). 	    Thus we need a machine dependent routine to make 	    sure the structure is written out correctly.  FUN! 	   */
name|md_ri_to_chars
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|ri
argument_list|,
name|ri
argument_list|)
expr_stmt|;
name|append
argument_list|(
operator|&
name|next_object_file_charP
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ri
argument_list|,
operator|(
name|unsigned
name|long
operator|)
sizeof|sizeof
argument_list|(
name|ri
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|is_dnrange
parameter_list|(
name|f1
parameter_list|,
name|f2
parameter_list|)
name|struct
name|frag
modifier|*
name|f1
decl_stmt|,
decl|*
name|f2
decl_stmt|;
end_function

begin_block
block|{
while|while
condition|(
name|f1
condition|)
block|{
if|if
condition|(
name|f1
operator|->
name|fr_next
operator|==
name|f2
condition|)
return|return
literal|1
return|;
name|f1
operator|=
name|f1
operator|->
name|fr_next
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* End: as-write.c */
end_comment

end_unit

