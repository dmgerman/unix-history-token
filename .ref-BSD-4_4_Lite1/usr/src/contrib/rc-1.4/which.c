begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* which.c: check to see if a file is executable.     This function was originally written with Maarten Litmaath's which.c as    a template, but was changed in order to accomodate the possibility of    rc's running setuid or the possibility of executing files not in the    primary group. Much of this file has been re-vamped by Paul Haahr.    I re-re-vamped the functions that Paul supplied to correct minor bugs    and to strip out unneeded functionality. */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|"rc.h"
end_include

begin_define
define|#
directive|define
name|X_USR
value|0100
end_define

begin_define
define|#
directive|define
name|X_GRP
value|0010
end_define

begin_define
define|#
directive|define
name|X_OTH
value|0001
end_define

begin_define
define|#
directive|define
name|X_ALL
value|(X_USR|X_GRP|X_OTH)
end_define

begin_function_decl
specifier|extern
name|int
name|stat
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|struct
name|stat
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|bool
name|initialized
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|uid
decl_stmt|,
name|gid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ngroups
decl_stmt|,
name|gidset
index|[
name|NGROUPS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* determine whether gid lies in gidset */
end_comment

begin_function
specifier|static
name|int
name|ingidset
parameter_list|(
name|int
name|g
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ngroups
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|g
operator|==
name|gidset
index|[
name|i
index|]
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*    A home-grown access/stat. Does the right thing for group-executable files.    Returns a bool instead of this -1 nonsense. */
end_comment

begin_function
specifier|static
name|bool
name|rc_access
parameter_list|(
name|char
modifier|*
name|path
parameter_list|,
name|bool
name|verbose
parameter_list|)
block|{
name|struct
name|stat
name|st
decl_stmt|;
name|int
name|mask
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|path
argument_list|,
operator|&
name|st
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|verbose
condition|)
comment|/* verbose flag only set for absolute pathname */
name|uerror
argument_list|(
name|path
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|uid
operator|==
literal|0
condition|)
name|mask
operator|=
name|X_ALL
expr_stmt|;
elseif|else
if|if
condition|(
name|uid
operator|==
name|st
operator|.
name|st_uid
condition|)
name|mask
operator|=
name|X_USR
expr_stmt|;
elseif|else
if|if
condition|(
name|gid
operator|==
name|st
operator|.
name|st_gid
operator|||
name|ingidset
argument_list|(
name|st
operator|.
name|st_gid
argument_list|)
condition|)
name|mask
operator|=
name|X_GRP
expr_stmt|;
else|else
name|mask
operator|=
name|X_OTH
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|st
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|==
name|S_IFREG
operator|)
operator|&&
operator|(
name|st
operator|.
name|st_mode
operator|&
name|mask
operator|)
condition|)
return|return
name|TRUE
return|;
name|errno
operator|=
name|EACCES
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|uerror
argument_list|(
name|path
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* return a full pathname by searching $path, and by checking the status of the file */
end_comment

begin_function
specifier|extern
name|char
modifier|*
name|which
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|bool
name|verbose
parameter_list|)
block|{
specifier|static
name|char
modifier|*
name|test
init|=
name|NULL
decl_stmt|;
specifier|static
name|size_t
name|testlen
init|=
literal|0
decl_stmt|;
name|List
modifier|*
name|path
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
comment|/* no filename? can happen with "> foo" as a command */
return|return
name|NULL
return|;
if|if
condition|(
operator|!
name|initialized
condition|)
block|{
name|initialized
operator|=
name|TRUE
expr_stmt|;
name|uid
operator|=
name|geteuid
argument_list|()
expr_stmt|;
name|gid
operator|=
name|getegid
argument_list|()
expr_stmt|;
name|ngroups
operator|=
name|getgroups
argument_list|(
name|NGROUPS
argument_list|,
name|gidset
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isabsolute
argument_list|(
name|name
argument_list|)
condition|)
comment|/* absolute pathname? */
return|return
name|rc_access
argument_list|(
name|name
argument_list|,
name|verbose
argument_list|)
condition|?
name|name
else|:
name|NULL
return|;
name|len
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|path
operator|=
name|varlookup
argument_list|(
literal|"path"
argument_list|)
init|;
name|path
operator|!=
name|NULL
condition|;
name|path
operator|=
name|path
operator|->
name|n
control|)
block|{
name|size_t
name|need
init|=
name|strlen
argument_list|(
name|path
operator|->
name|w
argument_list|)
operator|+
name|len
operator|+
literal|2
decl_stmt|;
comment|/* one for null terminator, one for the '/' */
if|if
condition|(
name|testlen
operator|<
name|need
condition|)
block|{
name|efree
argument_list|(
name|test
argument_list|)
expr_stmt|;
name|test
operator|=
name|ealloc
argument_list|(
name|testlen
operator|=
name|need
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|path
operator|->
name|w
operator|==
literal|'\0'
condition|)
block|{
name|strcpy
argument_list|(
name|test
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|strcpy
argument_list|(
name|test
argument_list|,
name|path
operator|->
name|w
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|streq
argument_list|(
name|test
argument_list|,
literal|"/"
argument_list|)
condition|)
comment|/* "//" is special to POSIX */
name|strcat
argument_list|(
name|test
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|test
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rc_access
argument_list|(
name|test
argument_list|,
name|FALSE
argument_list|)
condition|)
return|return
name|test
return|;
block|}
if|if
condition|(
name|verbose
condition|)
name|fprint
argument_list|(
literal|2
argument_list|,
literal|"%s not found\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

end_unit

