begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|"rc.h"
end_include

begin_include
include|#
directive|include
file|"jbwrap.h"
end_include

begin_comment
comment|/*    A return goes back stack frames to the last return. A break does    not. A signal goes to the last interactive level. (see below) */
end_comment

begin_decl_stmt
name|bool
name|nl_on_intr
init|=
name|TRUE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Estack
modifier|*
name|estack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* add an exception to the input stack. */
end_comment

begin_function
specifier|extern
name|void
name|except
parameter_list|(
name|ecodes
name|e
parameter_list|,
name|Edata
name|data
parameter_list|,
name|Estack
modifier|*
name|ex
parameter_list|)
block|{
name|ex
operator|->
name|prev
operator|=
name|estack
expr_stmt|;
name|estack
operator|=
name|ex
expr_stmt|;
name|estack
operator|->
name|e
operator|=
name|e
expr_stmt|;
name|estack
operator|->
name|data
operator|=
name|data
expr_stmt|;
if|if
condition|(
name|e
operator|==
name|eError
operator|||
name|e
operator|==
name|eBreak
operator|||
name|e
operator|==
name|eReturn
condition|)
name|estack
operator|->
name|interactive
operator|=
name|interactive
expr_stmt|;
block|}
end_function

begin_comment
comment|/* remove an exception, restore last interactive value */
end_comment

begin_function
specifier|extern
name|void
name|unexcept
parameter_list|()
block|{
switch|switch
condition|(
name|estack
operator|->
name|e
condition|)
block|{
default|default:
break|break;
case|case
name|eError
case|:
name|interactive
operator|=
name|estack
operator|->
name|interactive
expr_stmt|;
break|break;
case|case
name|eArena
case|:
name|restoreblock
argument_list|(
name|estack
operator|->
name|data
operator|.
name|b
argument_list|)
expr_stmt|;
break|break;
case|case
name|eFifo
case|:
name|unlink
argument_list|(
name|estack
operator|->
name|data
operator|.
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|eFd
case|:
name|close
argument_list|(
name|estack
operator|->
name|data
operator|.
name|fd
argument_list|)
expr_stmt|;
break|break;
block|}
name|estack
operator|=
name|estack
operator|->
name|prev
expr_stmt|;
block|}
end_function

begin_comment
comment|/*    Raise an exception. The rules are pretty complicated: you can return    from a loop inside a function, but you can't break from a function    inside of a loop. On errors, rc_raise() goes back to the LAST    INTERACTIVE stack frame. If no such frame exists, then rc_raise()    exits the shell.  This is what happens, say, when there is a syntax    error in a noninteractive shell script. While traversing the    exception stack backwards, rc_raise() also removes input sources    (closing file-descriptors, etc.) and pops instances of variables    that have been pushed onto the variable stack (e.g., for a function    call (for $*) or a local assignment). */
end_comment

begin_function
specifier|extern
name|void
name|rc_raise
parameter_list|(
name|ecodes
name|e
parameter_list|)
block|{
if|if
condition|(
name|e
operator|==
name|eError
operator|&&
name|rc_pid
operator|!=
name|getpid
argument_list|()
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* child processes exit on an error/signal */
for|for
control|(
init|;
name|estack
operator|!=
name|NULL
condition|;
name|estack
operator|=
name|estack
operator|->
name|prev
control|)
if|if
condition|(
name|estack
operator|->
name|e
operator|!=
name|e
condition|)
block|{
if|if
condition|(
name|e
operator|==
name|eBreak
operator|&&
name|estack
operator|->
name|e
operator|!=
name|eArena
condition|)
name|rc_error
argument_list|(
literal|"break outside of loop"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|e
operator|==
name|eReturn
operator|&&
name|estack
operator|->
name|e
operator|==
name|eError
condition|)
comment|/* can return from loops inside functions */
name|rc_error
argument_list|(
literal|"return outside of function"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|estack
operator|->
name|e
condition|)
block|{
default|default:
break|break;
case|case
name|eVarstack
case|:
name|varrm
argument_list|(
name|estack
operator|->
name|data
operator|.
name|name
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
break|break;
case|case
name|eArena
case|:
name|restoreblock
argument_list|(
name|estack
operator|->
name|data
operator|.
name|b
argument_list|)
expr_stmt|;
break|break;
case|case
name|eFifo
case|:
name|unlink
argument_list|(
name|estack
operator|->
name|data
operator|.
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|eFd
case|:
name|close
argument_list|(
name|estack
operator|->
name|data
operator|.
name|fd
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
if|if
condition|(
name|e
operator|==
name|eError
operator|&&
operator|!
name|estack
operator|->
name|interactive
condition|)
block|{
name|popinput
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|Jbwrap
modifier|*
name|j
init|=
name|estack
operator|->
name|data
operator|.
name|jb
decl_stmt|;
name|interactive
operator|=
name|estack
operator|->
name|interactive
expr_stmt|;
name|estack
operator|=
name|estack
operator|->
name|prev
expr_stmt|;
name|longjmp
argument_list|(
name|j
operator|->
name|j
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|rc_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* top of exception stack */
block|}
end_function

begin_function
specifier|extern
name|bool
name|outstanding_cmdarg
parameter_list|()
block|{
return|return
name|estack
operator|->
name|e
operator|==
name|eFifo
operator|||
name|estack
operator|->
name|e
operator|==
name|eFd
return|;
block|}
end_function

begin_function
specifier|extern
name|void
name|pop_cmdarg
parameter_list|(
name|bool
name|remove
parameter_list|)
block|{
for|for
control|(
init|;
name|estack
operator|!=
name|NULL
condition|;
name|estack
operator|=
name|estack
operator|->
name|prev
control|)
switch|switch
condition|(
name|estack
operator|->
name|e
condition|)
block|{
case|case
name|eFifo
case|:
if|if
condition|(
name|remove
condition|)
name|unlink
argument_list|(
name|estack
operator|->
name|data
operator|.
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|eFd
case|:
if|if
condition|(
name|remove
condition|)
name|close
argument_list|(
name|estack
operator|->
name|data
operator|.
name|fd
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return;
block|}
block|}
end_function

begin_comment
comment|/* exception handlers */
end_comment

begin_function
specifier|extern
name|void
name|rc_error
parameter_list|(
name|char
modifier|*
name|s
parameter_list|)
block|{
name|pr_error
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|set
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|redirq
operator|=
name|NULL
expr_stmt|;
name|cond
operator|=
name|FALSE
expr_stmt|;
comment|/* no longer inside conditional */
name|rc_raise
argument_list|(
name|eError
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|extern
name|void
name|sigint
parameter_list|(
name|int
name|s
parameter_list|)
block|{
if|if
condition|(
name|s
operator|!=
name|SIGINT
condition|)
name|panic
argument_list|(
literal|"s != SIGINT in sigint catcher"
argument_list|)
expr_stmt|;
comment|/* this is the newline you see when you hit ^C while typing a command */
if|if
condition|(
name|nl_on_intr
condition|)
name|fprint
argument_list|(
literal|2
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|nl_on_intr
operator|=
name|TRUE
expr_stmt|;
name|redirq
operator|=
name|NULL
expr_stmt|;
name|cond
operator|=
name|FALSE
expr_stmt|;
name|rc_raise
argument_list|(
name|eError
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

