begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* tblcmp - table compression routines */
end_comment

begin_comment
comment|/*-  * Copyright (c) 1990 The Regents of the University of California.  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Vern Paxson.  *   * The United States Government has rights in this work pursuant  * to contract no. DE-AC03-76SF00098 between the United States  * Department of Energy and the University of California.  *  * Redistribution and use in source and binary forms are permitted provided  * that: (1) source distributions retain this entire copyright notice and  * comment, and (2) distributions including binaries display the following  * acknowledgement:  ``This product includes software developed by the  * University of California, Berkeley and its contributors'' in the  * documentation or other materials provided with the distribution and in  * all advertising materials mentioning features or use of this software.  * Neither the name of the University nor the names of its contributors may  * be used to endorse or promote products derived from this software without  * specific prior written permission.  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED  * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  */
end_comment

begin_comment
comment|/* $Header: /home/daffy/u0/vern/flex/RCS/tblcmp.c,v 2.10 93/12/07 10:18:30 vern Exp $ */
end_comment

begin_include
include|#
directive|include
file|"flexdef.h"
end_include

begin_comment
comment|/* declarations for functions that have forward references */
end_comment

begin_decl_stmt
name|void
name|mkentry
name|PROTO
argument_list|(
operator|(
specifier|register
name|int
operator|*
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|mkprot
name|PROTO
argument_list|(
operator|(
name|int
index|[]
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|mktemplate
name|PROTO
argument_list|(
operator|(
name|int
index|[]
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|mv2front
name|PROTO
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|tbldiff
name|PROTO
argument_list|(
operator|(
name|int
index|[]
operator|,
name|int
operator|,
name|int
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* bldtbl - build table entries for dfa state  *  * synopsis  *   int state[numecs], statenum, totaltrans, comstate, comfreq;  *   bldtbl( state, statenum, totaltrans, comstate, comfreq );  *  * State is the statenum'th dfa state.  It is indexed by equivalence class and  * gives the number of the state to enter for a given equivalence class.  * totaltrans is the total number of transitions out of the state.  Comstate  * is that state which is the destination of the most transitions out of State.  * Comfreq is how many transitions there are out of State to Comstate.  *  * A note on terminology:  *    "protos" are transition tables which have a high probability of  * either being redundant (a state processed later will have an identical  * transition table) or nearly redundant (a state processed later will have  * many of the same out-transitions).  A "most recently used" queue of  * protos is kept around with the hope that most states will find a proto  * which is similar enough to be usable, and therefore compacting the  * output tables.  *    "templates" are a special type of proto.  If a transition table is  * homogeneous or nearly homogeneous (all transitions go to the same  * destination) then the odds are good that future states will also go  * to the same destination state on basically the same character set.  * These homogeneous states are so common when dealing with large rule  * sets that they merit special attention.  If the transition table were  * simply made into a proto, then (typically) each subsequent, similar  * state will differ from the proto for two out-transitions.  One of these  * out-transitions will be that character on which the proto does not go  * to the common destination, and one will be that character on which the  * state does not go to the common destination.  Templates, on the other  * hand, go to the common state on EVERY transition character, and therefore  * cost only one difference.  */
end_comment

begin_function
name|void
name|bldtbl
parameter_list|(
name|state
parameter_list|,
name|statenum
parameter_list|,
name|totaltrans
parameter_list|,
name|comstate
parameter_list|,
name|comfreq
parameter_list|)
name|int
name|state
index|[]
decl_stmt|,
name|statenum
decl_stmt|,
name|totaltrans
decl_stmt|,
name|comstate
decl_stmt|,
name|comfreq
decl_stmt|;
block|{
name|int
name|extptr
decl_stmt|,
name|extrct
index|[
literal|2
index|]
index|[
name|CSIZE
operator|+
literal|1
index|]
decl_stmt|;
name|int
name|mindiff
decl_stmt|,
name|minprot
decl_stmt|,
name|i
decl_stmt|,
name|d
decl_stmt|;
comment|/* If extptr is 0 then the first array of extrct holds the result 	 * of the "best difference" to date, which is those transitions 	 * which occur in "state" but not in the proto which, to date, 	 * has the fewest differences between itself and "state".  If 	 * extptr is 1 then the second array of extrct hold the best 	 * difference.  The two arrays are toggled between so that the 	 * best difference to date can be kept around and also a difference 	 * just created by checking against a candidate "best" proto. 	 */
name|extptr
operator|=
literal|0
expr_stmt|;
comment|/* If the state has too few out-transitions, don't bother trying to 	 * compact its tables. 	 */
if|if
condition|(
operator|(
name|totaltrans
operator|*
literal|100
operator|)
operator|<
operator|(
name|numecs
operator|*
name|PROTO_SIZE_PERCENTAGE
operator|)
condition|)
name|mkentry
argument_list|(
name|state
argument_list|,
name|numecs
argument_list|,
name|statenum
argument_list|,
name|JAMSTATE
argument_list|,
name|totaltrans
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* "checkcom" is true if we should only check "state" against 		 * protos which have the same "comstate" value. 		 */
name|int
name|checkcom
init|=
name|comfreq
operator|*
literal|100
operator|>
name|totaltrans
operator|*
name|CHECK_COM_PERCENTAGE
decl_stmt|;
name|minprot
operator|=
name|firstprot
expr_stmt|;
name|mindiff
operator|=
name|totaltrans
expr_stmt|;
if|if
condition|(
name|checkcom
condition|)
block|{
comment|/* Find first proto which has the same "comstate". */
for|for
control|(
name|i
operator|=
name|firstprot
init|;
name|i
operator|!=
name|NIL
condition|;
name|i
operator|=
name|protnext
index|[
name|i
index|]
control|)
if|if
condition|(
name|protcomst
index|[
name|i
index|]
operator|==
name|comstate
condition|)
block|{
name|minprot
operator|=
name|i
expr_stmt|;
name|mindiff
operator|=
name|tbldiff
argument_list|(
name|state
argument_list|,
name|minprot
argument_list|,
name|extrct
index|[
name|extptr
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
comment|/* Since we've decided that the most common destination 			 * out of "state" does not occur with a high enough 			 * frequency, we set the "comstate" to zero, assuring 			 * that if this state is entered into the proto list, 			 * it will not be considered a template. 			 */
name|comstate
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|firstprot
operator|!=
name|NIL
condition|)
block|{
name|minprot
operator|=
name|firstprot
expr_stmt|;
name|mindiff
operator|=
name|tbldiff
argument_list|(
name|state
argument_list|,
name|minprot
argument_list|,
name|extrct
index|[
name|extptr
index|]
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* We now have the first interesting proto in "minprot".  If 		 * it matches within the tolerances set for the first proto, 		 * we don't want to bother scanning the rest of the proto list 		 * to see if we have any other reasonable matches. 		 */
if|if
condition|(
name|mindiff
operator|*
literal|100
operator|>
name|totaltrans
operator|*
name|FIRST_MATCH_DIFF_PERCENTAGE
condition|)
block|{
comment|/* Not a good enough match.  Scan the rest of the 			 * protos. 			 */
for|for
control|(
name|i
operator|=
name|minprot
init|;
name|i
operator|!=
name|NIL
condition|;
name|i
operator|=
name|protnext
index|[
name|i
index|]
control|)
block|{
name|d
operator|=
name|tbldiff
argument_list|(
name|state
argument_list|,
name|i
argument_list|,
name|extrct
index|[
literal|1
operator|-
name|extptr
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|<
name|mindiff
condition|)
block|{
name|extptr
operator|=
literal|1
operator|-
name|extptr
expr_stmt|;
name|mindiff
operator|=
name|d
expr_stmt|;
name|minprot
operator|=
name|i
expr_stmt|;
block|}
block|}
block|}
comment|/* Check if the proto we've decided on as our best bet is close 		 * enough to the state we want to match to be usable. 		 */
if|if
condition|(
name|mindiff
operator|*
literal|100
operator|>
name|totaltrans
operator|*
name|ACCEPTABLE_DIFF_PERCENTAGE
condition|)
block|{
comment|/* No good.  If the state is homogeneous enough, 			 * we make a template out of it.  Otherwise, we 			 * make a proto. 			 */
if|if
condition|(
name|comfreq
operator|*
literal|100
operator|>=
name|totaltrans
operator|*
name|TEMPLATE_SAME_PERCENTAGE
condition|)
name|mktemplate
argument_list|(
name|state
argument_list|,
name|statenum
argument_list|,
name|comstate
argument_list|)
expr_stmt|;
else|else
block|{
name|mkprot
argument_list|(
name|state
argument_list|,
name|statenum
argument_list|,
name|comstate
argument_list|)
expr_stmt|;
name|mkentry
argument_list|(
name|state
argument_list|,
name|numecs
argument_list|,
name|statenum
argument_list|,
name|JAMSTATE
argument_list|,
name|totaltrans
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* use the proto */
name|mkentry
argument_list|(
name|extrct
index|[
name|extptr
index|]
argument_list|,
name|numecs
argument_list|,
name|statenum
argument_list|,
name|prottbl
index|[
name|minprot
index|]
argument_list|,
name|mindiff
argument_list|)
expr_stmt|;
comment|/* If this state was sufficiently different from the 			 * proto we built it from, make it, too, a proto. 			 */
if|if
condition|(
name|mindiff
operator|*
literal|100
operator|>=
name|totaltrans
operator|*
name|NEW_PROTO_DIFF_PERCENTAGE
condition|)
name|mkprot
argument_list|(
name|state
argument_list|,
name|statenum
argument_list|,
name|comstate
argument_list|)
expr_stmt|;
comment|/* Since mkprot added a new proto to the proto queue, 			 * it's possible that "minprot" is no longer on the 			 * proto queue (if it happened to have been the last 			 * entry, it would have been bumped off).  If it's 			 * not there, then the new proto took its physical 			 * place (though logically the new proto is at the 			 * beginning of the queue), so in that case the 			 * following call will do nothing. 			 */
name|mv2front
argument_list|(
name|minprot
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* cmptmps - compress template table entries  *  * Template tables are compressed by using the 'template equivalence  * classes', which are collections of transition character equivalence  * classes which always appear together in templates - really meta-equivalence  * classes.  */
end_comment

begin_function
name|void
name|cmptmps
parameter_list|()
block|{
name|int
name|tmpstorage
index|[
name|CSIZE
operator|+
literal|1
index|]
decl_stmt|;
specifier|register
name|int
modifier|*
name|tmp
init|=
name|tmpstorage
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|totaltrans
decl_stmt|,
name|trans
decl_stmt|;
name|peakpairs
operator|=
name|numtemps
operator|*
name|numecs
operator|+
name|tblend
expr_stmt|;
if|if
condition|(
name|usemecs
condition|)
block|{
comment|/* Create equivalence classes based on data gathered on 		 * template transitions. 		 */
name|nummecs
operator|=
name|cre8ecs
argument_list|(
name|tecfwd
argument_list|,
name|tecbck
argument_list|,
name|numecs
argument_list|)
expr_stmt|;
block|}
else|else
name|nummecs
operator|=
name|numecs
expr_stmt|;
while|while
condition|(
name|lastdfa
operator|+
name|numtemps
operator|+
literal|1
operator|>=
name|current_max_dfas
condition|)
name|increase_max_dfas
argument_list|()
expr_stmt|;
comment|/* Loop through each template. */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|numtemps
condition|;
operator|++
name|i
control|)
block|{
comment|/* Number of non-jam transitions out of this template. */
name|totaltrans
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<=
name|numecs
condition|;
operator|++
name|j
control|)
block|{
name|trans
operator|=
name|tnxt
index|[
name|numecs
operator|*
name|i
operator|+
name|j
index|]
expr_stmt|;
if|if
condition|(
name|usemecs
condition|)
block|{
comment|/* The absolute value of tecbck is the 				 * meta-equivalence class of a given 				 * equivalence class, as set up by cre8ecs(). 				 */
if|if
condition|(
name|tecbck
index|[
name|j
index|]
operator|>
literal|0
condition|)
block|{
name|tmp
index|[
name|tecbck
index|[
name|j
index|]
index|]
operator|=
name|trans
expr_stmt|;
if|if
condition|(
name|trans
operator|>
literal|0
condition|)
operator|++
name|totaltrans
expr_stmt|;
block|}
block|}
else|else
block|{
name|tmp
index|[
name|j
index|]
operator|=
name|trans
expr_stmt|;
if|if
condition|(
name|trans
operator|>
literal|0
condition|)
operator|++
name|totaltrans
expr_stmt|;
block|}
block|}
comment|/* It is assumed (in a rather subtle way) in the skeleton 		 * that if we're using meta-equivalence classes, the def[] 		 * entry for all templates is the jam template, i.e., 		 * templates never default to other non-jam table entries 		 * (e.g., another template) 		 */
comment|/* Leave room for the jam-state after the last real state. */
name|mkentry
argument_list|(
name|tmp
argument_list|,
name|nummecs
argument_list|,
name|lastdfa
operator|+
name|i
operator|+
literal|1
argument_list|,
name|JAMSTATE
argument_list|,
name|totaltrans
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* expand_nxt_chk - expand the next check arrays */
end_comment

begin_function
name|void
name|expand_nxt_chk
parameter_list|()
block|{
specifier|register
name|int
name|old_max
init|=
name|current_max_xpairs
decl_stmt|;
name|current_max_xpairs
operator|+=
name|MAX_XPAIRS_INCREMENT
expr_stmt|;
operator|++
name|num_reallocs
expr_stmt|;
name|nxt
operator|=
name|reallocate_integer_array
argument_list|(
name|nxt
argument_list|,
name|current_max_xpairs
argument_list|)
expr_stmt|;
name|chk
operator|=
name|reallocate_integer_array
argument_list|(
name|chk
argument_list|,
name|current_max_xpairs
argument_list|)
expr_stmt|;
name|zero_out
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|chk
operator|+
name|old_max
operator|)
argument_list|,
name|MAX_XPAIRS_INCREMENT
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* find_table_space - finds a space in the table for a state to be placed  *  * synopsis  *     int *state, numtrans, block_start;  *     int find_table_space();  *  *     block_start = find_table_space( state, numtrans );  *  * State is the state to be added to the full speed transition table.  * Numtrans is the number of out-transitions for the state.  *  * find_table_space() returns the position of the start of the first block (in  * chk) able to accommodate the state  *  * In determining if a state will or will not fit, find_table_space() must take  * into account the fact that an end-of-buffer state will be added at [0],  * and an action number will be added in [-1].  */
end_comment

begin_function
name|int
name|find_table_space
parameter_list|(
name|state
parameter_list|,
name|numtrans
parameter_list|)
name|int
modifier|*
name|state
decl_stmt|,
name|numtrans
decl_stmt|;
block|{
comment|/* Firstfree is the position of the first possible occurrence of two 	 * consecutive unused records in the chk and nxt arrays. 	 */
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
modifier|*
name|state_ptr
decl_stmt|,
modifier|*
name|chk_ptr
decl_stmt|;
specifier|register
name|int
modifier|*
name|ptr_to_last_entry_in_state
decl_stmt|;
comment|/* If there are too many out-transitions, put the state at the end of 	 * nxt and chk. 	 */
if|if
condition|(
name|numtrans
operator|>
name|MAX_XTIONS_FULL_INTERIOR_FIT
condition|)
block|{
comment|/* If table is empty, return the first available spot in 		 * chk/nxt, which should be 1. 		 */
if|if
condition|(
name|tblend
operator|<
literal|2
condition|)
return|return
literal|1
return|;
comment|/* Start searching for table space near the end of 		 * chk/nxt arrays. 		 */
name|i
operator|=
name|tblend
operator|-
name|numecs
expr_stmt|;
block|}
else|else
comment|/* Start searching for table space from the beginning 		 * (skipping only the elements which will definitely not 		 * hold the new state). 		 */
name|i
operator|=
name|firstfree
expr_stmt|;
while|while
condition|(
literal|1
condition|)
comment|/* loops until a space is found */
block|{
while|while
condition|(
name|i
operator|+
name|numecs
operator|>=
name|current_max_xpairs
condition|)
name|expand_nxt_chk
argument_list|()
expr_stmt|;
comment|/* Loops until space for end-of-buffer and action number 		 * are found. 		 */
while|while
condition|(
literal|1
condition|)
block|{
comment|/* Check for action number space. */
if|if
condition|(
name|chk
index|[
name|i
operator|-
literal|1
index|]
operator|==
literal|0
condition|)
block|{
comment|/* Check for end-of-buffer space. */
if|if
condition|(
name|chk
index|[
name|i
index|]
operator|==
literal|0
condition|)
break|break;
else|else
comment|/* Since i != 0, there is no use 					 * checking to see if (++i) - 1 == 0, 					 * because that's the same as i == 0, 					 * so we skip a space. 					 */
name|i
operator|+=
literal|2
expr_stmt|;
block|}
else|else
operator|++
name|i
expr_stmt|;
while|while
condition|(
name|i
operator|+
name|numecs
operator|>=
name|current_max_xpairs
condition|)
name|expand_nxt_chk
argument_list|()
expr_stmt|;
block|}
comment|/* If we started search from the beginning, store the new 		 * firstfree for the next call of find_table_space(). 		 */
if|if
condition|(
name|numtrans
operator|<=
name|MAX_XTIONS_FULL_INTERIOR_FIT
condition|)
name|firstfree
operator|=
name|i
operator|+
literal|1
expr_stmt|;
comment|/* Check to see if all elements in chk (and therefore nxt) 		 * that are needed for the new state have not yet been taken. 		 */
name|state_ptr
operator|=
operator|&
name|state
index|[
literal|1
index|]
expr_stmt|;
name|ptr_to_last_entry_in_state
operator|=
operator|&
name|chk
index|[
name|i
operator|+
name|numecs
operator|+
literal|1
index|]
expr_stmt|;
for|for
control|(
name|chk_ptr
operator|=
operator|&
name|chk
index|[
name|i
operator|+
literal|1
index|]
init|;
name|chk_ptr
operator|!=
name|ptr_to_last_entry_in_state
condition|;
operator|++
name|chk_ptr
control|)
if|if
condition|(
operator|*
operator|(
name|state_ptr
operator|++
operator|)
operator|!=
literal|0
operator|&&
operator|*
name|chk_ptr
operator|!=
literal|0
condition|)
break|break;
if|if
condition|(
name|chk_ptr
operator|==
name|ptr_to_last_entry_in_state
condition|)
return|return
name|i
return|;
else|else
operator|++
name|i
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* inittbl - initialize transition tables  *  * Initializes "firstfree" to be one beyond the end of the table.  Initializes  * all "chk" entries to be zero.  */
end_comment

begin_function
name|void
name|inittbl
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|zero_out
argument_list|(
operator|(
name|char
operator|*
operator|)
name|chk
argument_list|,
name|current_max_xpairs
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
name|tblend
operator|=
literal|0
expr_stmt|;
name|firstfree
operator|=
name|tblend
operator|+
literal|1
expr_stmt|;
name|numtemps
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|usemecs
condition|)
block|{
comment|/* Set up doubly-linked meta-equivalence classes; these 		 * are sets of equivalence classes which all have identical 		 * transitions out of TEMPLATES. 		 */
name|tecbck
index|[
literal|1
index|]
operator|=
name|NIL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<=
name|numecs
condition|;
operator|++
name|i
control|)
block|{
name|tecbck
index|[
name|i
index|]
operator|=
name|i
operator|-
literal|1
expr_stmt|;
name|tecfwd
index|[
name|i
operator|-
literal|1
index|]
operator|=
name|i
expr_stmt|;
block|}
name|tecfwd
index|[
name|numecs
index|]
operator|=
name|NIL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* mkdeftbl - make the default, "jam" table entries */
end_comment

begin_function
name|void
name|mkdeftbl
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
name|jamstate
operator|=
name|lastdfa
operator|+
literal|1
expr_stmt|;
operator|++
name|tblend
expr_stmt|;
comment|/* room for transition on end-of-buffer character */
while|while
condition|(
name|tblend
operator|+
name|numecs
operator|>=
name|current_max_xpairs
condition|)
name|expand_nxt_chk
argument_list|()
expr_stmt|;
comment|/* Add in default end-of-buffer transition. */
name|nxt
index|[
name|tblend
index|]
operator|=
name|end_of_buffer_state
expr_stmt|;
name|chk
index|[
name|tblend
index|]
operator|=
name|jamstate
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|numecs
condition|;
operator|++
name|i
control|)
block|{
name|nxt
index|[
name|tblend
operator|+
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|chk
index|[
name|tblend
operator|+
name|i
index|]
operator|=
name|jamstate
expr_stmt|;
block|}
name|jambase
operator|=
name|tblend
expr_stmt|;
name|base
index|[
name|jamstate
index|]
operator|=
name|jambase
expr_stmt|;
name|def
index|[
name|jamstate
index|]
operator|=
literal|0
expr_stmt|;
name|tblend
operator|+=
name|numecs
expr_stmt|;
operator|++
name|numtemps
expr_stmt|;
block|}
end_function

begin_comment
comment|/* mkentry - create base/def and nxt/chk entries for transition array  *  * synopsis  *   int state[numchars + 1], numchars, statenum, deflink, totaltrans;  *   mkentry( state, numchars, statenum, deflink, totaltrans );  *  * "state" is a transition array "numchars" characters in size, "statenum"  * is the offset to be used into the base/def tables, and "deflink" is the  * entry to put in the "def" table entry.  If "deflink" is equal to  * "JAMSTATE", then no attempt will be made to fit zero entries of "state"  * (i.e., jam entries) into the table.  It is assumed that by linking to  * "JAMSTATE" they will be taken care of.  In any case, entries in "state"  * marking transitions to "SAME_TRANS" are treated as though they will be  * taken care of by whereever "deflink" points.  "totaltrans" is the total  * number of transitions out of the state.  If it is below a certain threshold,  * the tables are searched for an interior spot that will accommodate the  * state array.  */
end_comment

begin_function
name|void
name|mkentry
parameter_list|(
name|state
parameter_list|,
name|numchars
parameter_list|,
name|statenum
parameter_list|,
name|deflink
parameter_list|,
name|totaltrans
parameter_list|)
specifier|register
name|int
modifier|*
name|state
decl_stmt|;
name|int
name|numchars
decl_stmt|,
name|statenum
decl_stmt|,
name|deflink
decl_stmt|,
name|totaltrans
decl_stmt|;
block|{
specifier|register
name|int
name|minec
decl_stmt|,
name|maxec
decl_stmt|,
name|i
decl_stmt|,
name|baseaddr
decl_stmt|;
name|int
name|tblbase
decl_stmt|,
name|tbllast
decl_stmt|;
if|if
condition|(
name|totaltrans
operator|==
literal|0
condition|)
block|{
comment|/* there are no out-transitions */
if|if
condition|(
name|deflink
operator|==
name|JAMSTATE
condition|)
name|base
index|[
name|statenum
index|]
operator|=
name|JAMSTATE
expr_stmt|;
else|else
name|base
index|[
name|statenum
index|]
operator|=
literal|0
expr_stmt|;
name|def
index|[
name|statenum
index|]
operator|=
name|deflink
expr_stmt|;
return|return;
block|}
for|for
control|(
name|minec
operator|=
literal|1
init|;
name|minec
operator|<=
name|numchars
condition|;
operator|++
name|minec
control|)
block|{
if|if
condition|(
name|state
index|[
name|minec
index|]
operator|!=
name|SAME_TRANS
condition|)
if|if
condition|(
name|state
index|[
name|minec
index|]
operator|!=
literal|0
operator|||
name|deflink
operator|!=
name|JAMSTATE
condition|)
break|break;
block|}
if|if
condition|(
name|totaltrans
operator|==
literal|1
condition|)
block|{
comment|/* There's only one out-transition.  Save it for later to fill 		 * in holes in the tables. 		 */
name|stack1
argument_list|(
name|statenum
argument_list|,
name|minec
argument_list|,
name|state
index|[
name|minec
index|]
argument_list|,
name|deflink
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|maxec
operator|=
name|numchars
init|;
name|maxec
operator|>
literal|0
condition|;
operator|--
name|maxec
control|)
block|{
if|if
condition|(
name|state
index|[
name|maxec
index|]
operator|!=
name|SAME_TRANS
condition|)
if|if
condition|(
name|state
index|[
name|maxec
index|]
operator|!=
literal|0
operator|||
name|deflink
operator|!=
name|JAMSTATE
condition|)
break|break;
block|}
comment|/* Whether we try to fit the state table in the middle of the table 	 * entries we have already generated, or if we just take the state 	 * table at the end of the nxt/chk tables, we must make sure that we 	 * have a valid base address (i.e., non-negative).  Note that 	 * negative base addresses dangerous at run-time (because indexing 	 * the nxt array with one and a low-valued character will access 	 * memory before the start of the array. 	 */
comment|/* Find the first transition of state that we need to worry about. */
if|if
condition|(
name|totaltrans
operator|*
literal|100
operator|<=
name|numchars
operator|*
name|INTERIOR_FIT_PERCENTAGE
condition|)
block|{
comment|/* Attempt to squeeze it into the middle of the tables. */
name|baseaddr
operator|=
name|firstfree
expr_stmt|;
while|while
condition|(
name|baseaddr
operator|<
name|minec
condition|)
block|{
comment|/* Using baseaddr would result in a negative base 			 * address below; find the next free slot. 			 */
for|for
control|(
operator|++
name|baseaddr
init|;
name|chk
index|[
name|baseaddr
index|]
operator|!=
literal|0
condition|;
operator|++
name|baseaddr
control|)
empty_stmt|;
block|}
while|while
condition|(
name|baseaddr
operator|+
name|maxec
operator|-
name|minec
operator|+
literal|1
operator|>=
name|current_max_xpairs
condition|)
name|expand_nxt_chk
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
name|minec
init|;
name|i
operator|<=
name|maxec
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|state
index|[
name|i
index|]
operator|!=
name|SAME_TRANS
operator|&&
operator|(
name|state
index|[
name|i
index|]
operator|!=
literal|0
operator|||
name|deflink
operator|!=
name|JAMSTATE
operator|)
operator|&&
name|chk
index|[
name|baseaddr
operator|+
name|i
operator|-
name|minec
index|]
operator|!=
literal|0
condition|)
block|{
comment|/* baseaddr unsuitable - find another */
for|for
control|(
operator|++
name|baseaddr
init|;
name|baseaddr
operator|<
name|current_max_xpairs
operator|&&
name|chk
index|[
name|baseaddr
index|]
operator|!=
literal|0
condition|;
operator|++
name|baseaddr
control|)
empty_stmt|;
while|while
condition|(
name|baseaddr
operator|+
name|maxec
operator|-
name|minec
operator|+
literal|1
operator|>=
name|current_max_xpairs
condition|)
name|expand_nxt_chk
argument_list|()
expr_stmt|;
comment|/* Reset the loop counter so we'll start all 				 * over again next time it's incremented. 				 */
name|i
operator|=
name|minec
operator|-
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Ensure that the base address we eventually generate is 		 * non-negative. 		 */
name|baseaddr
operator|=
name|MAX
argument_list|(
name|tblend
operator|+
literal|1
argument_list|,
name|minec
argument_list|)
expr_stmt|;
block|}
name|tblbase
operator|=
name|baseaddr
operator|-
name|minec
expr_stmt|;
name|tbllast
operator|=
name|tblbase
operator|+
name|maxec
expr_stmt|;
while|while
condition|(
name|tbllast
operator|+
literal|1
operator|>=
name|current_max_xpairs
condition|)
name|expand_nxt_chk
argument_list|()
expr_stmt|;
name|base
index|[
name|statenum
index|]
operator|=
name|tblbase
expr_stmt|;
name|def
index|[
name|statenum
index|]
operator|=
name|deflink
expr_stmt|;
for|for
control|(
name|i
operator|=
name|minec
init|;
name|i
operator|<=
name|maxec
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|state
index|[
name|i
index|]
operator|!=
name|SAME_TRANS
condition|)
if|if
condition|(
name|state
index|[
name|i
index|]
operator|!=
literal|0
operator|||
name|deflink
operator|!=
name|JAMSTATE
condition|)
block|{
name|nxt
index|[
name|tblbase
operator|+
name|i
index|]
operator|=
name|state
index|[
name|i
index|]
expr_stmt|;
name|chk
index|[
name|tblbase
operator|+
name|i
index|]
operator|=
name|statenum
expr_stmt|;
block|}
if|if
condition|(
name|baseaddr
operator|==
name|firstfree
condition|)
comment|/* Find next free slot in tables. */
for|for
control|(
operator|++
name|firstfree
init|;
name|chk
index|[
name|firstfree
index|]
operator|!=
literal|0
condition|;
operator|++
name|firstfree
control|)
empty_stmt|;
name|tblend
operator|=
name|MAX
argument_list|(
name|tblend
argument_list|,
name|tbllast
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* mk1tbl - create table entries for a state (or state fragment) which  *            has only one out-transition  */
end_comment

begin_function
name|void
name|mk1tbl
parameter_list|(
name|state
parameter_list|,
name|sym
parameter_list|,
name|onenxt
parameter_list|,
name|onedef
parameter_list|)
name|int
name|state
decl_stmt|,
name|sym
decl_stmt|,
name|onenxt
decl_stmt|,
name|onedef
decl_stmt|;
block|{
if|if
condition|(
name|firstfree
operator|<
name|sym
condition|)
name|firstfree
operator|=
name|sym
expr_stmt|;
while|while
condition|(
name|chk
index|[
name|firstfree
index|]
operator|!=
literal|0
condition|)
if|if
condition|(
operator|++
name|firstfree
operator|>=
name|current_max_xpairs
condition|)
name|expand_nxt_chk
argument_list|()
expr_stmt|;
name|base
index|[
name|state
index|]
operator|=
name|firstfree
operator|-
name|sym
expr_stmt|;
name|def
index|[
name|state
index|]
operator|=
name|onedef
expr_stmt|;
name|chk
index|[
name|firstfree
index|]
operator|=
name|state
expr_stmt|;
name|nxt
index|[
name|firstfree
index|]
operator|=
name|onenxt
expr_stmt|;
if|if
condition|(
name|firstfree
operator|>
name|tblend
condition|)
block|{
name|tblend
operator|=
name|firstfree
operator|++
expr_stmt|;
if|if
condition|(
name|firstfree
operator|>=
name|current_max_xpairs
condition|)
name|expand_nxt_chk
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* mkprot - create new proto entry */
end_comment

begin_function
name|void
name|mkprot
parameter_list|(
name|state
parameter_list|,
name|statenum
parameter_list|,
name|comstate
parameter_list|)
name|int
name|state
index|[]
decl_stmt|,
name|statenum
decl_stmt|,
name|comstate
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|slot
decl_stmt|,
name|tblbase
decl_stmt|;
if|if
condition|(
operator|++
name|numprots
operator|>=
name|MSP
operator|||
name|numecs
operator|*
name|numprots
operator|>=
name|PROT_SAVE_SIZE
condition|)
block|{
comment|/* Gotta make room for the new proto by dropping last entry in 		 * the queue. 		 */
name|slot
operator|=
name|lastprot
expr_stmt|;
name|lastprot
operator|=
name|protprev
index|[
name|lastprot
index|]
expr_stmt|;
name|protnext
index|[
name|lastprot
index|]
operator|=
name|NIL
expr_stmt|;
block|}
else|else
name|slot
operator|=
name|numprots
expr_stmt|;
name|protnext
index|[
name|slot
index|]
operator|=
name|firstprot
expr_stmt|;
if|if
condition|(
name|firstprot
operator|!=
name|NIL
condition|)
name|protprev
index|[
name|firstprot
index|]
operator|=
name|slot
expr_stmt|;
name|firstprot
operator|=
name|slot
expr_stmt|;
name|prottbl
index|[
name|slot
index|]
operator|=
name|statenum
expr_stmt|;
name|protcomst
index|[
name|slot
index|]
operator|=
name|comstate
expr_stmt|;
comment|/* Copy state into save area so it can be compared with rapidly. */
name|tblbase
operator|=
name|numecs
operator|*
operator|(
name|slot
operator|-
literal|1
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|numecs
condition|;
operator|++
name|i
control|)
name|protsave
index|[
name|tblbase
operator|+
name|i
index|]
operator|=
name|state
index|[
name|i
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/* mktemplate - create a template entry based on a state, and connect the state  *              to it  */
end_comment

begin_function
name|void
name|mktemplate
parameter_list|(
name|state
parameter_list|,
name|statenum
parameter_list|,
name|comstate
parameter_list|)
name|int
name|state
index|[]
decl_stmt|,
name|statenum
decl_stmt|,
name|comstate
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|numdiff
decl_stmt|,
name|tmpbase
decl_stmt|,
name|tmp
index|[
name|CSIZE
operator|+
literal|1
index|]
decl_stmt|;
name|Char
name|transset
index|[
name|CSIZE
operator|+
literal|1
index|]
decl_stmt|;
name|int
name|tsptr
decl_stmt|;
operator|++
name|numtemps
expr_stmt|;
name|tsptr
operator|=
literal|0
expr_stmt|;
comment|/* Calculate where we will temporarily store the transition table 	 * of the template in the tnxt[] array.  The final transition table 	 * gets created by cmptmps(). 	 */
name|tmpbase
operator|=
name|numtemps
operator|*
name|numecs
expr_stmt|;
if|if
condition|(
name|tmpbase
operator|+
name|numecs
operator|>=
name|current_max_template_xpairs
condition|)
block|{
name|current_max_template_xpairs
operator|+=
name|MAX_TEMPLATE_XPAIRS_INCREMENT
expr_stmt|;
operator|++
name|num_reallocs
expr_stmt|;
name|tnxt
operator|=
name|reallocate_integer_array
argument_list|(
name|tnxt
argument_list|,
name|current_max_template_xpairs
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|numecs
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|state
index|[
name|i
index|]
operator|==
literal|0
condition|)
name|tnxt
index|[
name|tmpbase
operator|+
name|i
index|]
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|transset
index|[
name|tsptr
operator|++
index|]
operator|=
name|i
expr_stmt|;
name|tnxt
index|[
name|tmpbase
operator|+
name|i
index|]
operator|=
name|comstate
expr_stmt|;
block|}
if|if
condition|(
name|usemecs
condition|)
name|mkeccl
argument_list|(
name|transset
argument_list|,
name|tsptr
argument_list|,
name|tecfwd
argument_list|,
name|tecbck
argument_list|,
name|numecs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mkprot
argument_list|(
name|tnxt
operator|+
name|tmpbase
argument_list|,
operator|-
name|numtemps
argument_list|,
name|comstate
argument_list|)
expr_stmt|;
comment|/* We rely on the fact that mkprot adds things to the beginning 	 * of the proto queue. 	 */
name|numdiff
operator|=
name|tbldiff
argument_list|(
name|state
argument_list|,
name|firstprot
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|mkentry
argument_list|(
name|tmp
argument_list|,
name|numecs
argument_list|,
name|statenum
argument_list|,
operator|-
name|numtemps
argument_list|,
name|numdiff
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* mv2front - move proto queue element to front of queue */
end_comment

begin_function
name|void
name|mv2front
parameter_list|(
name|qelm
parameter_list|)
name|int
name|qelm
decl_stmt|;
block|{
if|if
condition|(
name|firstprot
operator|!=
name|qelm
condition|)
block|{
if|if
condition|(
name|qelm
operator|==
name|lastprot
condition|)
name|lastprot
operator|=
name|protprev
index|[
name|lastprot
index|]
expr_stmt|;
name|protnext
index|[
name|protprev
index|[
name|qelm
index|]
index|]
operator|=
name|protnext
index|[
name|qelm
index|]
expr_stmt|;
if|if
condition|(
name|protnext
index|[
name|qelm
index|]
operator|!=
name|NIL
condition|)
name|protprev
index|[
name|protnext
index|[
name|qelm
index|]
index|]
operator|=
name|protprev
index|[
name|qelm
index|]
expr_stmt|;
name|protprev
index|[
name|qelm
index|]
operator|=
name|NIL
expr_stmt|;
name|protnext
index|[
name|qelm
index|]
operator|=
name|firstprot
expr_stmt|;
name|protprev
index|[
name|firstprot
index|]
operator|=
name|qelm
expr_stmt|;
name|firstprot
operator|=
name|qelm
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* place_state - place a state into full speed transition table  *  * State is the statenum'th state.  It is indexed by equivalence class and  * gives the number of the state to enter for a given equivalence class.  * Transnum is the number of out-transitions for the state.  */
end_comment

begin_function
name|void
name|place_state
parameter_list|(
name|state
parameter_list|,
name|statenum
parameter_list|,
name|transnum
parameter_list|)
name|int
modifier|*
name|state
decl_stmt|,
name|statenum
decl_stmt|,
name|transnum
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
modifier|*
name|state_ptr
decl_stmt|;
name|int
name|position
init|=
name|find_table_space
argument_list|(
name|state
argument_list|,
name|transnum
argument_list|)
decl_stmt|;
comment|/* "base" is the table of start positions. */
name|base
index|[
name|statenum
index|]
operator|=
name|position
expr_stmt|;
comment|/* Put in action number marker; this non-zero number makes sure that 	 * find_table_space() knows that this position in chk/nxt is taken 	 * and should not be used for another accepting number in another 	 * state. 	 */
name|chk
index|[
name|position
operator|-
literal|1
index|]
operator|=
literal|1
expr_stmt|;
comment|/* Put in end-of-buffer marker; this is for the same purposes as 	 * above. 	 */
name|chk
index|[
name|position
index|]
operator|=
literal|1
expr_stmt|;
comment|/* Place the state into chk and nxt. */
name|state_ptr
operator|=
operator|&
name|state
index|[
literal|1
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|numecs
condition|;
operator|++
name|i
operator|,
operator|++
name|state_ptr
control|)
if|if
condition|(
operator|*
name|state_ptr
operator|!=
literal|0
condition|)
block|{
name|chk
index|[
name|position
operator|+
name|i
index|]
operator|=
name|i
expr_stmt|;
name|nxt
index|[
name|position
operator|+
name|i
index|]
operator|=
operator|*
name|state_ptr
expr_stmt|;
block|}
if|if
condition|(
name|position
operator|+
name|numecs
operator|>
name|tblend
condition|)
name|tblend
operator|=
name|position
operator|+
name|numecs
expr_stmt|;
block|}
end_function

begin_comment
comment|/* stack1 - save states with only one out-transition to be processed later  *  * If there's room for another state on the "one-transition" stack, the  * state is pushed onto it, to be processed later by mk1tbl.  If there's  * no room, we process the sucker right now.  */
end_comment

begin_function
name|void
name|stack1
parameter_list|(
name|statenum
parameter_list|,
name|sym
parameter_list|,
name|nextstate
parameter_list|,
name|deflink
parameter_list|)
name|int
name|statenum
decl_stmt|,
name|sym
decl_stmt|,
name|nextstate
decl_stmt|,
name|deflink
decl_stmt|;
block|{
if|if
condition|(
name|onesp
operator|>=
name|ONE_STACK_SIZE
operator|-
literal|1
condition|)
name|mk1tbl
argument_list|(
name|statenum
argument_list|,
name|sym
argument_list|,
name|nextstate
argument_list|,
name|deflink
argument_list|)
expr_stmt|;
else|else
block|{
operator|++
name|onesp
expr_stmt|;
name|onestate
index|[
name|onesp
index|]
operator|=
name|statenum
expr_stmt|;
name|onesym
index|[
name|onesp
index|]
operator|=
name|sym
expr_stmt|;
name|onenext
index|[
name|onesp
index|]
operator|=
name|nextstate
expr_stmt|;
name|onedef
index|[
name|onesp
index|]
operator|=
name|deflink
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* tbldiff - compute differences between two state tables  *  * "state" is the state array which is to be extracted from the pr'th  * proto.  "pr" is both the number of the proto we are extracting from  * and an index into the save area where we can find the proto's complete  * state table.  Each entry in "state" which differs from the corresponding  * entry of "pr" will appear in "ext".  *  * Entries which are the same in both "state" and "pr" will be marked  * as transitions to "SAME_TRANS" in "ext".  The total number of differences  * between "state" and "pr" is returned as function value.  Note that this  * number is "numecs" minus the number of "SAME_TRANS" entries in "ext".  */
end_comment

begin_decl_stmt
name|int
name|tbldiff
argument_list|(
name|state
argument_list|,
name|pr
argument_list|,
name|ext
argument_list|)
name|int
name|state
index|[]
decl_stmt|,
name|pr
decl_stmt|,
name|ext
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
modifier|*
name|sp
init|=
name|state
decl_stmt|,
modifier|*
name|ep
init|=
name|ext
decl_stmt|,
modifier|*
name|protp
decl_stmt|;
specifier|register
name|int
name|numdiff
init|=
literal|0
decl_stmt|;
name|protp
operator|=
operator|&
name|protsave
index|[
name|numecs
operator|*
operator|(
name|pr
operator|-
literal|1
operator|)
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
name|numecs
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
block|{
if|if
condition|(
operator|*
operator|++
name|protp
operator|==
operator|*
operator|++
name|sp
condition|)
operator|*
operator|++
name|ep
operator|=
name|SAME_TRANS
expr_stmt|;
else|else
block|{
operator|*
operator|++
name|ep
operator|=
operator|*
name|sp
expr_stmt|;
operator|++
name|numdiff
expr_stmt|;
block|}
block|}
return|return
name|numdiff
return|;
block|}
end_block

end_unit

