begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  Hunt  *  Copyright (c) 1985 Conrad C. Huang, Gregory S. Couch, Kenneth C.R.C. Arnold  *  San Francisco, California  */
end_comment

begin_include
include|#
directive|include
file|"hunt.h"
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_define
define|#
directive|define
name|PLUS_DELTA
parameter_list|(
name|x
parameter_list|,
name|max
parameter_list|)
value|if (x< max) x++; else x--
end_define

begin_define
define|#
directive|define
name|MINUS_DELTA
parameter_list|(
name|x
parameter_list|,
name|min
parameter_list|)
value|if (x> min) x--; else x++
end_define

begin_comment
comment|/*  * moveshots:  *	Move the shots already in the air, taking explosions into account  */
end_comment

begin_macro
name|moveshots
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|BULLET
modifier|*
name|bp
decl_stmt|,
modifier|*
name|next
decl_stmt|;
specifier|register
name|PLAYER
modifier|*
name|pp
decl_stmt|;
specifier|register
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
specifier|register
name|BULLET
modifier|*
name|blist
decl_stmt|;
name|rollexpl
argument_list|()
expr_stmt|;
if|if
condition|(
name|Bullets
operator|==
name|NULL
condition|)
goto|goto
name|ret
goto|;
comment|/* 	 * First we move through the bullet list BULSPD times, looking 	 * for things we may have run into.  If we do run into 	 * something, we set up the explosion and disappear, checking 	 * for damage to any player who got in the way. 	 */
name|blist
operator|=
name|Bullets
expr_stmt|;
name|Bullets
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|bp
operator|=
name|blist
init|;
name|bp
operator|!=
name|NULL
condition|;
name|bp
operator|=
name|next
control|)
block|{
name|next
operator|=
name|bp
operator|->
name|b_next
expr_stmt|;
name|x
operator|=
name|bp
operator|->
name|b_x
expr_stmt|;
name|y
operator|=
name|bp
operator|->
name|b_y
expr_stmt|;
name|Maze
index|[
name|y
index|]
index|[
name|x
index|]
operator|=
name|bp
operator|->
name|b_over
expr_stmt|;
for|for
control|(
name|pp
operator|=
name|Player
init|;
name|pp
operator|<
name|End_player
condition|;
name|pp
operator|++
control|)
name|check
argument_list|(
name|pp
argument_list|,
name|y
argument_list|,
name|x
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MONITOR
for|for
control|(
name|pp
operator|=
name|Monitor
init|;
name|pp
operator|<
name|End_monitor
condition|;
name|pp
operator|++
control|)
name|check
argument_list|(
name|pp
argument_list|,
name|y
argument_list|,
name|x
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|bp
operator|->
name|b_type
condition|)
block|{
case|case
name|SHOT
case|:
case|case
name|GRENADE
case|:
case|case
name|SATCHEL
case|:
case|case
name|BOMB
case|:
if|if
condition|(
name|move_normal_shot
argument_list|(
name|bp
argument_list|)
condition|)
block|{
name|bp
operator|->
name|b_next
operator|=
name|Bullets
expr_stmt|;
name|Bullets
operator|=
name|bp
expr_stmt|;
block|}
break|break;
ifdef|#
directive|ifdef
name|OOZE
case|case
name|SLIME
case|:
if|if
condition|(
name|bp
operator|->
name|b_expl
operator|||
name|move_normal_shot
argument_list|(
name|bp
argument_list|)
condition|)
block|{
name|bp
operator|->
name|b_next
operator|=
name|Bullets
expr_stmt|;
name|Bullets
operator|=
name|bp
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DRONE
case|case
name|DSHOT
case|:
if|if
condition|(
name|move_drone
argument_list|(
name|bp
argument_list|)
condition|)
block|{
name|bp
operator|->
name|b_next
operator|=
name|Bullets
expr_stmt|;
name|Bullets
operator|=
name|bp
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
default|default:
name|bp
operator|->
name|b_next
operator|=
name|Bullets
expr_stmt|;
name|Bullets
operator|=
name|bp
expr_stmt|;
break|break;
block|}
block|}
name|blist
operator|=
name|Bullets
expr_stmt|;
name|Bullets
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|bp
operator|=
name|blist
init|;
name|bp
operator|!=
name|NULL
condition|;
name|bp
operator|=
name|next
control|)
block|{
name|next
operator|=
name|bp
operator|->
name|b_next
expr_stmt|;
if|if
condition|(
operator|!
name|bp
operator|->
name|b_expl
condition|)
block|{
name|save_bullet
argument_list|(
name|bp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MONITOR
for|for
control|(
name|pp
operator|=
name|Monitor
init|;
name|pp
operator|<
name|End_monitor
condition|;
name|pp
operator|++
control|)
name|check
argument_list|(
name|pp
argument_list|,
name|bp
operator|->
name|b_y
argument_list|,
name|bp
operator|->
name|b_x
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DRONE
if|if
condition|(
name|bp
operator|->
name|b_type
operator|==
name|DSHOT
condition|)
for|for
control|(
name|pp
operator|=
name|Player
init|;
name|pp
operator|<
name|End_player
condition|;
name|pp
operator|++
control|)
if|if
condition|(
name|pp
operator|->
name|p_scan
operator|>=
literal|0
condition|)
name|check
argument_list|(
name|pp
argument_list|,
name|bp
operator|->
name|b_y
argument_list|,
name|bp
operator|->
name|b_x
argument_list|)
expr_stmt|;
endif|#
directive|endif
continue|continue;
block|}
name|chkshot
argument_list|(
name|bp
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|bp
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|pp
operator|=
name|Player
init|;
name|pp
operator|<
name|End_player
condition|;
name|pp
operator|++
control|)
name|Maze
index|[
name|pp
operator|->
name|p_y
index|]
index|[
name|pp
operator|->
name|p_x
index|]
operator|=
name|pp
operator|->
name|p_face
expr_stmt|;
name|ret
label|:
ifdef|#
directive|ifdef
name|BOOTS
for|for
control|(
name|pp
operator|=
name|Boot
init|;
name|pp
operator|<
operator|&
name|Boot
index|[
name|NBOOTS
index|]
condition|;
name|pp
operator|++
control|)
if|if
condition|(
name|pp
operator|->
name|p_flying
operator|>=
literal|0
condition|)
name|move_flyer
argument_list|(
name|pp
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|pp
operator|=
name|Player
init|;
name|pp
operator|<
name|End_player
condition|;
name|pp
operator|++
control|)
block|{
ifdef|#
directive|ifdef
name|FLY
if|if
condition|(
name|pp
operator|->
name|p_flying
operator|>=
literal|0
condition|)
name|move_flyer
argument_list|(
name|pp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sendcom
argument_list|(
name|pp
argument_list|,
name|REFRESH
argument_list|)
expr_stmt|;
comment|/* Flush out the explosions */
name|look
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|sendcom
argument_list|(
name|pp
argument_list|,
name|REFRESH
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|MONITOR
for|for
control|(
name|pp
operator|=
name|Monitor
init|;
name|pp
operator|<
name|End_monitor
condition|;
name|pp
operator|++
control|)
name|sendcom
argument_list|(
name|pp
argument_list|,
name|REFRESH
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
end_block

begin_comment
comment|/*  * move_normal_shot:  *	Move a normal shot along its trajectory  */
end_comment

begin_expr_stmt
name|move_normal_shot
argument_list|(
name|bp
argument_list|)
specifier|register
name|BULLET
operator|*
name|bp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|x
decl_stmt|,
name|y
decl_stmt|;
specifier|register
name|PLAYER
modifier|*
name|pp
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BULSPD
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|bp
operator|->
name|b_expl
condition|)
break|break;
name|x
operator|=
name|bp
operator|->
name|b_x
expr_stmt|;
name|y
operator|=
name|bp
operator|->
name|b_y
expr_stmt|;
switch|switch
condition|(
name|bp
operator|->
name|b_face
condition|)
block|{
case|case
name|LEFTS
case|:
name|x
operator|--
expr_stmt|;
break|break;
case|case
name|RIGHT
case|:
name|x
operator|++
expr_stmt|;
break|break;
case|case
name|ABOVE
case|:
name|y
operator|--
expr_stmt|;
break|break;
case|case
name|BELOW
case|:
name|y
operator|++
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|Maze
index|[
name|y
index|]
index|[
name|x
index|]
condition|)
block|{
case|case
name|SHOT
case|:
if|if
condition|(
name|rand_num
argument_list|(
literal|100
argument_list|)
operator|<
literal|5
condition|)
block|{
name|zapshot
argument_list|(
name|Bullets
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|zapshot
argument_list|(
name|bp
operator|->
name|b_next
argument_list|,
name|bp
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|GRENADE
case|:
if|if
condition|(
name|rand_num
argument_list|(
literal|100
argument_list|)
operator|<
literal|10
condition|)
block|{
name|zapshot
argument_list|(
name|Bullets
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|zapshot
argument_list|(
name|bp
operator|->
name|b_next
argument_list|,
name|bp
argument_list|)
expr_stmt|;
block|}
break|break;
ifdef|#
directive|ifdef
name|REFLECT
case|case
name|WALL4
case|:
comment|/* reflecting walls */
switch|switch
condition|(
name|bp
operator|->
name|b_face
condition|)
block|{
case|case
name|LEFTS
case|:
name|bp
operator|->
name|b_face
operator|=
name|BELOW
expr_stmt|;
break|break;
case|case
name|RIGHT
case|:
name|bp
operator|->
name|b_face
operator|=
name|ABOVE
expr_stmt|;
break|break;
case|case
name|ABOVE
case|:
name|bp
operator|->
name|b_face
operator|=
name|RIGHT
expr_stmt|;
break|break;
case|case
name|BELOW
case|:
name|bp
operator|->
name|b_face
operator|=
name|LEFTS
expr_stmt|;
break|break;
block|}
name|Maze
index|[
name|y
index|]
index|[
name|x
index|]
operator|=
name|WALL5
expr_stmt|;
ifdef|#
directive|ifdef
name|MONITOR
for|for
control|(
name|pp
operator|=
name|Monitor
init|;
name|pp
operator|<
name|End_monitor
condition|;
name|pp
operator|++
control|)
name|check
argument_list|(
name|pp
argument_list|,
name|y
argument_list|,
name|x
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|WALL5
case|:
switch|switch
condition|(
name|bp
operator|->
name|b_face
condition|)
block|{
case|case
name|LEFTS
case|:
name|bp
operator|->
name|b_face
operator|=
name|ABOVE
expr_stmt|;
break|break;
case|case
name|RIGHT
case|:
name|bp
operator|->
name|b_face
operator|=
name|BELOW
expr_stmt|;
break|break;
case|case
name|ABOVE
case|:
name|bp
operator|->
name|b_face
operator|=
name|LEFTS
expr_stmt|;
break|break;
case|case
name|BELOW
case|:
name|bp
operator|->
name|b_face
operator|=
name|RIGHT
expr_stmt|;
break|break;
block|}
name|Maze
index|[
name|y
index|]
index|[
name|x
index|]
operator|=
name|WALL4
expr_stmt|;
ifdef|#
directive|ifdef
name|MONITOR
for|for
control|(
name|pp
operator|=
name|Monitor
init|;
name|pp
operator|<
name|End_monitor
condition|;
name|pp
operator|++
control|)
name|check
argument_list|(
name|pp
argument_list|,
name|y
argument_list|,
name|x
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|RANDOM
case|case
name|DOOR
case|:
switch|switch
condition|(
name|rand_num
argument_list|(
literal|4
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
name|bp
operator|->
name|b_face
operator|=
name|ABOVE
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|bp
operator|->
name|b_face
operator|=
name|BELOW
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|bp
operator|->
name|b_face
operator|=
name|LEFTS
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|bp
operator|->
name|b_face
operator|=
name|RIGHT
expr_stmt|;
break|break;
block|}
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|FLY
case|case
name|FLYER
case|:
name|pp
operator|=
name|play_at
argument_list|(
name|y
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|message
argument_list|(
name|pp
argument_list|,
literal|"Zing!"
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|LEFTS
case|:
case|case
name|RIGHT
case|:
case|case
name|BELOW
case|:
case|case
name|ABOVE
case|:
comment|/* 			 * give the person a chance to catch a 			 * grenade if s/he is facing it 			 */
name|pp
operator|=
name|play_at
argument_list|(
name|y
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|pp
operator|->
name|p_ident
operator|->
name|i_shot
operator|+=
name|bp
operator|->
name|b_charge
expr_stmt|;
if|if
condition|(
name|opposite
argument_list|(
name|bp
operator|->
name|b_face
argument_list|,
name|Maze
index|[
name|y
index|]
index|[
name|x
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|rand_num
argument_list|(
literal|100
argument_list|)
operator|<
literal|10
condition|)
block|{
if|if
condition|(
name|bp
operator|->
name|b_owner
operator|!=
name|NULL
condition|)
name|message
argument_list|(
name|bp
operator|->
name|b_owner
argument_list|,
literal|"Your charge was absorbed!"
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_score
operator|!=
name|NULL
condition|)
name|bp
operator|->
name|b_score
operator|->
name|i_robbed
operator|+=
name|bp
operator|->
name|b_charge
expr_stmt|;
name|pp
operator|->
name|p_ammo
operator|+=
name|bp
operator|->
name|b_charge
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|p_damage
operator|+
name|bp
operator|->
name|b_size
operator|*
name|MINDAM
operator|>
name|pp
operator|->
name|p_damcap
condition|)
name|pp
operator|->
name|p_ident
operator|->
name|i_saved
operator|++
expr_stmt|;
name|message
argument_list|(
name|pp
argument_list|,
literal|"Absorbed charge (good shield!)"
argument_list|)
expr_stmt|;
name|pp
operator|->
name|p_ident
operator|->
name|i_absorbed
operator|+=
name|bp
operator|->
name|b_charge
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|bp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|Buf
argument_list|,
literal|"%3d"
argument_list|,
name|pp
operator|->
name|p_ammo
argument_list|)
expr_stmt|;
name|cgoto
argument_list|(
name|pp
argument_list|,
name|STAT_AMMO_ROW
argument_list|,
name|STAT_VALUE_COL
argument_list|)
expr_stmt|;
name|outstr
argument_list|(
name|pp
argument_list|,
name|Buf
argument_list|,
literal|3
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|pp
operator|->
name|p_ident
operator|->
name|i_faced
operator|+=
name|bp
operator|->
name|b_charge
expr_stmt|;
block|}
comment|/* 			 * Small chance that the bullet just misses the 			 * person.  If so, the bullet just goes on its 			 * merry way without exploding. 			 */
if|if
condition|(
name|rand_num
argument_list|(
literal|100
argument_list|)
operator|<
literal|5
condition|)
block|{
name|pp
operator|->
name|p_ident
operator|->
name|i_ducked
operator|+=
name|bp
operator|->
name|b_charge
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|p_damage
operator|+
name|bp
operator|->
name|b_size
operator|*
name|MINDAM
operator|>
name|pp
operator|->
name|p_damcap
condition|)
name|pp
operator|->
name|p_ident
operator|->
name|i_saved
operator|++
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_score
operator|!=
name|NULL
condition|)
name|bp
operator|->
name|b_score
operator|->
name|i_missed
operator|+=
name|bp
operator|->
name|b_charge
expr_stmt|;
name|message
argument_list|(
name|pp
argument_list|,
literal|"Zing!"
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_owner
operator|==
name|NULL
condition|)
break|break;
name|message
argument_list|(
name|bp
operator|->
name|b_owner
argument_list|,
operator|(
operator|(
name|bp
operator|->
name|b_score
operator|->
name|i_missed
operator|&
literal|0x7
operator|)
operator|==
literal|0x7
operator|)
condition|?
literal|"My!  What a bad shot you are!"
else|:
literal|"Missed him"
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 			 * The shot hit that sucker!  Blow it up. 			 */
comment|/* FALLTHROUGH */
ifndef|#
directive|ifndef
name|RANDOM
case|case
name|DOOR
case|:
endif|#
directive|endif
case|case
name|WALL1
case|:
case|case
name|WALL2
case|:
case|case
name|WALL3
case|:
name|bp
operator|->
name|b_expl
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
name|bp
operator|->
name|b_x
operator|=
name|x
expr_stmt|;
name|bp
operator|->
name|b_y
operator|=
name|y
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|DRONE
end_ifdef

begin_comment
comment|/*  * move_drone:  *	Move the drone to the next square  */
end_comment

begin_expr_stmt
name|move_drone
argument_list|(
name|bp
argument_list|)
specifier|register
name|BULLET
operator|*
name|bp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|mask
decl_stmt|,
name|count
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|,
name|dir
decl_stmt|;
specifier|register
name|PLAYER
modifier|*
name|pp
decl_stmt|;
comment|/* 	 * See if we can give someone a blast 	 */
if|if
condition|(
name|isplayer
argument_list|(
name|Maze
index|[
name|bp
operator|->
name|b_y
index|]
index|[
name|bp
operator|->
name|b_x
operator|-
literal|1
index|]
argument_list|)
condition|)
block|{
name|dir
operator|=
name|WEST
expr_stmt|;
goto|goto
name|drone_move
goto|;
block|}
if|if
condition|(
name|isplayer
argument_list|(
name|Maze
index|[
name|bp
operator|->
name|b_y
operator|-
literal|1
index|]
index|[
name|bp
operator|->
name|b_x
index|]
argument_list|)
condition|)
block|{
name|dir
operator|=
name|NORTH
expr_stmt|;
goto|goto
name|drone_move
goto|;
block|}
if|if
condition|(
name|isplayer
argument_list|(
name|Maze
index|[
name|bp
operator|->
name|b_y
operator|+
literal|1
index|]
index|[
name|bp
operator|->
name|b_x
index|]
argument_list|)
condition|)
block|{
name|dir
operator|=
name|SOUTH
expr_stmt|;
goto|goto
name|drone_move
goto|;
block|}
if|if
condition|(
name|isplayer
argument_list|(
name|Maze
index|[
name|bp
operator|->
name|b_y
index|]
index|[
name|bp
operator|->
name|b_x
operator|+
literal|1
index|]
argument_list|)
condition|)
block|{
name|dir
operator|=
name|EAST
expr_stmt|;
goto|goto
name|drone_move
goto|;
block|}
comment|/* 	 * Find out what directions are clear 	 */
name|mask
operator|=
name|count
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|iswall
argument_list|(
name|bp
operator|->
name|b_y
argument_list|,
name|bp
operator|->
name|b_x
operator|-
literal|1
argument_list|)
condition|)
name|mask
operator||=
name|WEST
operator|,
name|count
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|iswall
argument_list|(
name|bp
operator|->
name|b_y
operator|-
literal|1
argument_list|,
name|bp
operator|->
name|b_x
argument_list|)
condition|)
name|mask
operator||=
name|NORTH
operator|,
name|count
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|iswall
argument_list|(
name|bp
operator|->
name|b_y
operator|+
literal|1
argument_list|,
name|bp
operator|->
name|b_x
argument_list|)
condition|)
name|mask
operator||=
name|SOUTH
operator|,
name|count
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|iswall
argument_list|(
name|bp
operator|->
name|b_y
argument_list|,
name|bp
operator|->
name|b_x
operator|+
literal|1
argument_list|)
condition|)
name|mask
operator||=
name|EAST
operator|,
name|count
operator|++
expr_stmt|;
comment|/* 	 * All blocked up, just you wait 	 */
if|if
condition|(
name|count
operator|==
literal|0
condition|)
return|return
name|TRUE
return|;
comment|/* 	 * Only one way to go. 	 */
if|if
condition|(
name|count
operator|==
literal|1
condition|)
block|{
name|dir
operator|=
name|mask
expr_stmt|;
goto|goto
name|drone_move
goto|;
block|}
comment|/* 	 * Get rid of the direction that we came from 	 */
switch|switch
condition|(
name|bp
operator|->
name|b_face
condition|)
block|{
case|case
name|LEFTS
case|:
if|if
condition|(
name|mask
operator|&
name|EAST
condition|)
name|mask
operator|&=
operator|~
name|EAST
operator|,
name|count
operator|--
expr_stmt|;
break|break;
case|case
name|RIGHT
case|:
if|if
condition|(
name|mask
operator|&
name|WEST
condition|)
name|mask
operator|&=
operator|~
name|WEST
operator|,
name|count
operator|--
expr_stmt|;
break|break;
case|case
name|ABOVE
case|:
if|if
condition|(
name|mask
operator|&
name|SOUTH
condition|)
name|mask
operator|&=
operator|~
name|SOUTH
operator|,
name|count
operator|--
expr_stmt|;
break|break;
case|case
name|BELOW
case|:
if|if
condition|(
name|mask
operator|&
name|NORTH
condition|)
name|mask
operator|&=
operator|~
name|NORTH
operator|,
name|count
operator|--
expr_stmt|;
break|break;
block|}
comment|/* 	 * Pick one of the remaining directions 	 */
name|n
operator|=
name|rand_num
argument_list|(
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>=
literal|0
operator|&&
name|mask
operator|&
name|NORTH
condition|)
name|dir
operator|=
name|NORTH
operator|,
name|n
operator|--
expr_stmt|;
if|if
condition|(
name|n
operator|>=
literal|0
operator|&&
name|mask
operator|&
name|SOUTH
condition|)
name|dir
operator|=
name|SOUTH
operator|,
name|n
operator|--
expr_stmt|;
if|if
condition|(
name|n
operator|>=
literal|0
operator|&&
name|mask
operator|&
name|EAST
condition|)
name|dir
operator|=
name|EAST
operator|,
name|n
operator|--
expr_stmt|;
if|if
condition|(
name|n
operator|>=
literal|0
operator|&&
name|mask
operator|&
name|WEST
condition|)
name|dir
operator|=
name|WEST
operator|,
name|n
operator|--
expr_stmt|;
comment|/* 	 * Now that we know the direction of movement, 	 * just update the position of the drone 	 */
name|drone_move
label|:
switch|switch
condition|(
name|dir
condition|)
block|{
case|case
name|WEST
case|:
name|bp
operator|->
name|b_x
operator|--
expr_stmt|;
name|bp
operator|->
name|b_face
operator|=
name|LEFTS
expr_stmt|;
break|break;
case|case
name|EAST
case|:
name|bp
operator|->
name|b_x
operator|++
expr_stmt|;
name|bp
operator|->
name|b_face
operator|=
name|RIGHT
expr_stmt|;
break|break;
case|case
name|NORTH
case|:
name|bp
operator|->
name|b_y
operator|--
expr_stmt|;
name|bp
operator|->
name|b_face
operator|=
name|ABOVE
expr_stmt|;
break|break;
case|case
name|SOUTH
case|:
name|bp
operator|->
name|b_y
operator|++
expr_stmt|;
name|bp
operator|->
name|b_face
operator|=
name|BELOW
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|Maze
index|[
name|bp
operator|->
name|b_y
index|]
index|[
name|bp
operator|->
name|b_x
index|]
condition|)
block|{
case|case
name|LEFTS
case|:
case|case
name|RIGHT
case|:
case|case
name|BELOW
case|:
case|case
name|ABOVE
case|:
comment|/* 		 * give the person a chance to catch a 		 * drone if s/he is facing it 		 */
if|if
condition|(
name|rand_num
argument_list|(
literal|100
argument_list|)
operator|<
literal|1
operator|&&
name|opposite
argument_list|(
name|bp
operator|->
name|b_face
argument_list|,
name|Maze
index|[
name|bp
operator|->
name|b_y
index|]
index|[
name|bp
operator|->
name|b_x
index|]
argument_list|)
condition|)
block|{
name|pp
operator|=
name|play_at
argument_list|(
name|bp
operator|->
name|b_y
argument_list|,
name|bp
operator|->
name|b_x
argument_list|)
expr_stmt|;
name|pp
operator|->
name|p_ammo
operator|+=
name|bp
operator|->
name|b_charge
expr_stmt|;
name|message
argument_list|(
name|pp
argument_list|,
literal|"**** Absorbed drone ****"
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|bp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|Buf
argument_list|,
literal|"%3d"
argument_list|,
name|pp
operator|->
name|p_ammo
argument_list|)
expr_stmt|;
name|cgoto
argument_list|(
name|pp
argument_list|,
name|STAT_AMMO_ROW
argument_list|,
name|STAT_VALUE_COL
argument_list|)
expr_stmt|;
name|outstr
argument_list|(
name|pp
argument_list|,
name|Buf
argument_list|,
literal|3
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|bp
operator|->
name|b_expl
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
return|return
name|TRUE
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * save_bullet:  *	Put this bullet back onto the bullet list  */
end_comment

begin_expr_stmt
name|save_bullet
argument_list|(
name|bp
argument_list|)
specifier|register
name|BULLET
operator|*
name|bp
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|bp
operator|->
name|b_over
operator|=
name|Maze
index|[
name|bp
operator|->
name|b_y
index|]
index|[
name|bp
operator|->
name|b_x
index|]
expr_stmt|;
switch|switch
condition|(
name|bp
operator|->
name|b_over
condition|)
block|{
case|case
name|SHOT
case|:
case|case
name|GRENADE
case|:
case|case
name|SATCHEL
case|:
case|case
name|BOMB
case|:
ifdef|#
directive|ifdef
name|OOZE
case|case
name|SLIME
case|:
ifdef|#
directive|ifdef
name|VOLCANO
case|case
name|LAVA
case|:
endif|#
directive|endif
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DRONE
case|case
name|DSHOT
case|:
endif|#
directive|endif
name|find_under
argument_list|(
name|Bullets
argument_list|,
name|bp
argument_list|)
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|bp
operator|->
name|b_over
condition|)
block|{
case|case
name|LEFTS
case|:
case|case
name|RIGHT
case|:
case|case
name|ABOVE
case|:
case|case
name|BELOW
case|:
ifdef|#
directive|ifdef
name|FLY
case|case
name|FLYER
case|:
endif|#
directive|endif
name|mark_player
argument_list|(
name|bp
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|BOOTS
case|case
name|BOOT
case|:
case|case
name|BOOT_PAIR
case|:
name|mark_boot
argument_list|(
name|bp
argument_list|)
expr_stmt|;
endif|#
directive|endif
default|default:
name|Maze
index|[
name|bp
operator|->
name|b_y
index|]
index|[
name|bp
operator|->
name|b_x
index|]
operator|=
name|bp
operator|->
name|b_type
expr_stmt|;
break|break;
block|}
name|bp
operator|->
name|b_next
operator|=
name|Bullets
expr_stmt|;
name|Bullets
operator|=
name|bp
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * move_flyer:  *	Update the position of a player in flight  */
end_comment

begin_expr_stmt
name|move_flyer
argument_list|(
name|pp
argument_list|)
specifier|register
name|PLAYER
operator|*
name|pp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
if|if
condition|(
name|pp
operator|->
name|p_undershot
condition|)
block|{
name|fixshots
argument_list|(
name|pp
operator|->
name|p_y
argument_list|,
name|pp
operator|->
name|p_x
argument_list|,
name|pp
operator|->
name|p_over
argument_list|)
expr_stmt|;
name|pp
operator|->
name|p_undershot
operator|=
name|FALSE
expr_stmt|;
block|}
name|Maze
index|[
name|pp
operator|->
name|p_y
index|]
index|[
name|pp
operator|->
name|p_x
index|]
operator|=
name|pp
operator|->
name|p_over
expr_stmt|;
name|x
operator|=
name|pp
operator|->
name|p_x
operator|+
name|pp
operator|->
name|p_flyx
expr_stmt|;
name|y
operator|=
name|pp
operator|->
name|p_y
operator|+
name|pp
operator|->
name|p_flyy
expr_stmt|;
if|if
condition|(
name|x
operator|<
literal|1
condition|)
block|{
name|x
operator|=
literal|1
operator|-
name|x
expr_stmt|;
name|pp
operator|->
name|p_flyx
operator|=
operator|-
name|pp
operator|->
name|p_flyx
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|x
operator|>
name|WIDTH
operator|-
literal|2
condition|)
block|{
name|x
operator|=
operator|(
name|WIDTH
operator|-
literal|2
operator|)
operator|-
operator|(
name|x
operator|-
operator|(
name|WIDTH
operator|-
literal|2
operator|)
operator|)
expr_stmt|;
name|pp
operator|->
name|p_flyx
operator|=
operator|-
name|pp
operator|->
name|p_flyx
expr_stmt|;
block|}
if|if
condition|(
name|y
operator|<
literal|1
condition|)
block|{
name|y
operator|=
literal|1
operator|-
name|y
expr_stmt|;
name|pp
operator|->
name|p_flyy
operator|=
operator|-
name|pp
operator|->
name|p_flyy
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|y
operator|>
name|HEIGHT
operator|-
literal|2
condition|)
block|{
name|y
operator|=
operator|(
name|HEIGHT
operator|-
literal|2
operator|)
operator|-
operator|(
name|y
operator|-
operator|(
name|HEIGHT
operator|-
literal|2
operator|)
operator|)
expr_stmt|;
name|pp
operator|->
name|p_flyy
operator|=
operator|-
name|pp
operator|->
name|p_flyy
expr_stmt|;
block|}
name|again
label|:
switch|switch
condition|(
name|Maze
index|[
name|y
index|]
index|[
name|x
index|]
condition|)
block|{
default|default:
switch|switch
condition|(
name|rand_num
argument_list|(
literal|4
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
name|PLUS_DELTA
argument_list|(
name|x
argument_list|,
name|WIDTH
operator|-
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|MINUS_DELTA
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|PLUS_DELTA
argument_list|(
name|y
argument_list|,
name|HEIGHT
operator|-
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|MINUS_DELTA
argument_list|(
name|y
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
goto|goto
name|again
goto|;
case|case
name|WALL1
case|:
case|case
name|WALL2
case|:
case|case
name|WALL3
case|:
ifdef|#
directive|ifdef
name|REFLECT
case|case
name|WALL4
case|:
case|case
name|WALL5
case|:
endif|#
directive|endif
ifdef|#
directive|ifdef
name|RANDOM
case|case
name|DOOR
case|:
endif|#
directive|endif
if|if
condition|(
name|pp
operator|->
name|p_flying
operator|==
literal|0
condition|)
name|pp
operator|->
name|p_flying
operator|++
expr_stmt|;
break|break;
case|case
name|SPACE
case|:
break|break;
block|}
name|pp
operator|->
name|p_y
operator|=
name|y
expr_stmt|;
name|pp
operator|->
name|p_x
operator|=
name|x
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|p_flying
operator|--
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|BOOTS
if|if
condition|(
name|pp
operator|->
name|p_face
operator|!=
name|BOOT
operator|&&
name|pp
operator|->
name|p_face
operator|!=
name|BOOT_PAIR
condition|)
block|{
endif|#
directive|endif
name|checkdam
argument_list|(
name|pp
argument_list|,
operator|(
name|PLAYER
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|IDENT
operator|*
operator|)
name|NULL
argument_list|,
name|rand_num
argument_list|(
name|pp
operator|->
name|p_damage
operator|/
literal|5
argument_list|)
argument_list|,
name|FALL
argument_list|)
expr_stmt|;
name|pp
operator|->
name|p_face
operator|=
name|rand_dir
argument_list|()
expr_stmt|;
name|showstat
argument_list|(
name|pp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BOOTS
block|}
else|else
block|{
if|if
condition|(
name|Maze
index|[
name|y
index|]
index|[
name|x
index|]
operator|==
name|BOOT
condition|)
name|pp
operator|->
name|p_face
operator|=
name|BOOT_PAIR
expr_stmt|;
name|Maze
index|[
name|y
index|]
index|[
name|x
index|]
operator|=
name|SPACE
expr_stmt|;
block|}
endif|#
directive|endif
block|}
name|pp
operator|->
name|p_over
operator|=
name|Maze
index|[
name|y
index|]
index|[
name|x
index|]
expr_stmt|;
name|Maze
index|[
name|y
index|]
index|[
name|x
index|]
operator|=
name|pp
operator|->
name|p_face
expr_stmt|;
name|showexpl
argument_list|(
name|y
argument_list|,
name|x
argument_list|,
name|pp
operator|->
name|p_face
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * chkshot  *	Handle explosions  */
end_comment

begin_expr_stmt
name|chkshot
argument_list|(
name|bp
argument_list|,
name|next
argument_list|)
specifier|register
name|BULLET
operator|*
name|bp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|BULLET
modifier|*
name|next
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|y
decl_stmt|,
name|x
decl_stmt|;
specifier|register
name|int
name|dy
decl_stmt|,
name|dx
decl_stmt|,
name|absdy
decl_stmt|;
specifier|register
name|int
name|delta
decl_stmt|,
name|damage
decl_stmt|;
specifier|register
name|char
name|expl
decl_stmt|;
specifier|register
name|PLAYER
modifier|*
name|pp
decl_stmt|;
switch|switch
condition|(
name|bp
operator|->
name|b_type
condition|)
block|{
case|case
name|SHOT
case|:
case|case
name|MINE
case|:
case|case
name|GRENADE
case|:
case|case
name|GMINE
case|:
case|case
name|SATCHEL
case|:
case|case
name|BOMB
case|:
name|delta
operator|=
name|bp
operator|->
name|b_size
operator|-
literal|1
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|OOZE
case|case
name|SLIME
case|:
ifdef|#
directive|ifdef
name|VOLCANO
case|case
name|LAVA
case|:
endif|#
directive|endif
name|chkslime
argument_list|(
name|bp
argument_list|,
name|next
argument_list|)
expr_stmt|;
return|return;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DRONE
case|case
name|DSHOT
case|:
name|bp
operator|->
name|b_type
operator|=
name|SLIME
expr_stmt|;
name|chkslime
argument_list|(
name|bp
argument_list|,
name|next
argument_list|)
expr_stmt|;
return|return;
endif|#
directive|endif
block|}
for|for
control|(
name|y
operator|=
name|bp
operator|->
name|b_y
operator|-
name|delta
init|;
name|y
operator|<=
name|bp
operator|->
name|b_y
operator|+
name|delta
condition|;
name|y
operator|++
control|)
block|{
if|if
condition|(
name|y
operator|<
literal|0
operator|||
name|y
operator|>=
name|HEIGHT
condition|)
continue|continue;
name|dy
operator|=
name|y
operator|-
name|bp
operator|->
name|b_y
expr_stmt|;
name|absdy
operator|=
operator|(
name|dy
operator|<
literal|0
operator|)
condition|?
operator|-
name|dy
else|:
name|dy
expr_stmt|;
for|for
control|(
name|x
operator|=
name|bp
operator|->
name|b_x
operator|-
name|delta
init|;
name|x
operator|<=
name|bp
operator|->
name|b_x
operator|+
name|delta
condition|;
name|x
operator|++
control|)
block|{
if|if
condition|(
name|x
operator|<
literal|0
operator|||
name|x
operator|>=
name|WIDTH
condition|)
continue|continue;
name|dx
operator|=
name|x
operator|-
name|bp
operator|->
name|b_x
expr_stmt|;
if|if
condition|(
name|dx
operator|==
literal|0
condition|)
name|expl
operator|=
operator|(
name|dy
operator|==
literal|0
operator|)
condition|?
literal|'*'
else|:
literal|'|'
expr_stmt|;
elseif|else
if|if
condition|(
name|dy
operator|==
literal|0
condition|)
name|expl
operator|=
literal|'-'
expr_stmt|;
elseif|else
if|if
condition|(
name|dx
operator|==
name|dy
condition|)
name|expl
operator|=
literal|'\\'
expr_stmt|;
elseif|else
if|if
condition|(
name|dx
operator|==
operator|-
name|dy
condition|)
name|expl
operator|=
literal|'/'
expr_stmt|;
else|else
name|expl
operator|=
literal|'*'
expr_stmt|;
name|showexpl
argument_list|(
name|y
argument_list|,
name|x
argument_list|,
name|expl
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|Maze
index|[
name|y
index|]
index|[
name|x
index|]
condition|)
block|{
case|case
name|LEFTS
case|:
case|case
name|RIGHT
case|:
case|case
name|ABOVE
case|:
case|case
name|BELOW
case|:
ifdef|#
directive|ifdef
name|FLY
case|case
name|FLYER
case|:
endif|#
directive|endif
if|if
condition|(
name|dx
operator|<
literal|0
condition|)
name|dx
operator|=
operator|-
name|dx
expr_stmt|;
if|if
condition|(
name|absdy
operator|>
name|dx
condition|)
name|damage
operator|=
name|bp
operator|->
name|b_size
operator|-
name|absdy
expr_stmt|;
else|else
name|damage
operator|=
name|bp
operator|->
name|b_size
operator|-
name|dx
expr_stmt|;
name|pp
operator|=
name|play_at
argument_list|(
name|y
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|checkdam
argument_list|(
name|pp
argument_list|,
name|bp
operator|->
name|b_owner
argument_list|,
name|bp
operator|->
name|b_score
argument_list|,
name|damage
operator|*
name|MINDAM
argument_list|,
name|bp
operator|->
name|b_type
argument_list|)
expr_stmt|;
break|break;
case|case
name|GMINE
case|:
case|case
name|MINE
case|:
name|add_shot
argument_list|(
operator|(
name|Maze
index|[
name|y
index|]
index|[
name|x
index|]
operator|==
name|GMINE
operator|)
condition|?
name|GRENADE
else|:
name|SHOT
argument_list|,
name|y
argument_list|,
name|x
argument_list|,
name|LEFTS
argument_list|,
operator|(
name|Maze
index|[
name|y
index|]
index|[
name|x
index|]
operator|==
name|GMINE
operator|)
condition|?
name|GRENREQ
else|:
name|BULREQ
argument_list|,
operator|(
name|PLAYER
operator|*
operator|)
name|NULL
argument_list|,
name|TRUE
argument_list|,
name|SPACE
argument_list|)
expr_stmt|;
name|Maze
index|[
name|y
index|]
index|[
name|x
index|]
operator|=
name|SPACE
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|OOZE
end_ifdef

begin_comment
comment|/*  * chkslime:  *	handle slime shot exploding  */
end_comment

begin_expr_stmt
name|chkslime
argument_list|(
name|bp
argument_list|,
name|next
argument_list|)
specifier|register
name|BULLET
operator|*
name|bp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|BULLET
modifier|*
name|next
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|BULLET
modifier|*
name|nbp
decl_stmt|;
switch|switch
condition|(
name|Maze
index|[
name|bp
operator|->
name|b_y
index|]
index|[
name|bp
operator|->
name|b_x
index|]
condition|)
block|{
case|case
name|WALL1
case|:
case|case
name|WALL2
case|:
case|case
name|WALL3
case|:
ifdef|#
directive|ifdef
name|REFLECT
case|case
name|WALL4
case|:
case|case
name|WALL5
case|:
endif|#
directive|endif
ifdef|#
directive|ifdef
name|RANDOM
case|case
name|DOOR
case|:
endif|#
directive|endif
switch|switch
condition|(
name|bp
operator|->
name|b_face
condition|)
block|{
case|case
name|LEFTS
case|:
name|bp
operator|->
name|b_x
operator|++
expr_stmt|;
break|break;
case|case
name|RIGHT
case|:
name|bp
operator|->
name|b_x
operator|--
expr_stmt|;
break|break;
case|case
name|ABOVE
case|:
name|bp
operator|->
name|b_y
operator|++
expr_stmt|;
break|break;
case|case
name|BELOW
case|:
name|bp
operator|->
name|b_y
operator|--
expr_stmt|;
break|break;
block|}
break|break;
block|}
name|nbp
operator|=
operator|(
name|BULLET
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|BULLET
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|nbp
operator|=
operator|*
name|bp
expr_stmt|;
ifdef|#
directive|ifdef
name|VOLCANO
name|move_slime
argument_list|(
name|nbp
argument_list|,
name|nbp
operator|->
name|b_type
operator|==
name|SLIME
condition|?
name|SLIMESPEED
else|:
name|LAVASPEED
argument_list|,
name|next
argument_list|)
expr_stmt|;
else|#
directive|else
name|move_slime
argument_list|(
name|nbp
argument_list|,
name|SLIMESPEED
argument_list|,
name|next
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_comment
comment|/*  * move_slime:  *	move the given slime shot speed times and add it back if  *	it hasn't fizzled yet  */
end_comment

begin_expr_stmt
name|move_slime
argument_list|(
name|bp
argument_list|,
name|speed
argument_list|,
name|next
argument_list|)
specifier|register
name|BULLET
operator|*
name|bp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|speed
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|BULLET
modifier|*
name|next
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|dirmask
decl_stmt|,
name|count
decl_stmt|;
specifier|register
name|PLAYER
modifier|*
name|pp
decl_stmt|;
specifier|register
name|BULLET
modifier|*
name|nbp
decl_stmt|;
if|if
condition|(
name|speed
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|bp
operator|->
name|b_charge
operator|<=
literal|0
condition|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|bp
argument_list|)
expr_stmt|;
else|else
name|save_bullet
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|VOLCANO
name|showexpl
argument_list|(
name|bp
operator|->
name|b_y
argument_list|,
name|bp
operator|->
name|b_x
argument_list|,
name|bp
operator|->
name|b_type
operator|==
name|LAVA
condition|?
name|LAVA
else|:
literal|'*'
argument_list|)
expr_stmt|;
else|#
directive|else
name|showexpl
argument_list|(
name|bp
operator|->
name|b_y
argument_list|,
name|bp
operator|->
name|b_x
argument_list|,
literal|'*'
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|Maze
index|[
name|bp
operator|->
name|b_y
index|]
index|[
name|bp
operator|->
name|b_x
index|]
condition|)
block|{
case|case
name|LEFTS
case|:
case|case
name|RIGHT
case|:
case|case
name|ABOVE
case|:
case|case
name|BELOW
case|:
ifdef|#
directive|ifdef
name|FLY
case|case
name|FLYER
case|:
endif|#
directive|endif
name|pp
operator|=
name|play_at
argument_list|(
name|bp
operator|->
name|b_y
argument_list|,
name|bp
operator|->
name|b_x
argument_list|)
expr_stmt|;
name|message
argument_list|(
name|pp
argument_list|,
literal|"You've been slimed."
argument_list|)
expr_stmt|;
name|checkdam
argument_list|(
name|pp
argument_list|,
name|bp
operator|->
name|b_owner
argument_list|,
name|bp
operator|->
name|b_score
argument_list|,
name|MINDAM
argument_list|,
name|bp
operator|->
name|b_type
argument_list|)
expr_stmt|;
break|break;
case|case
name|SHOT
case|:
case|case
name|GRENADE
case|:
case|case
name|SATCHEL
case|:
case|case
name|BOMB
case|:
ifdef|#
directive|ifdef
name|DRONE
case|case
name|DSHOT
case|:
endif|#
directive|endif
name|explshot
argument_list|(
name|next
argument_list|,
name|bp
operator|->
name|b_y
argument_list|,
name|bp
operator|->
name|b_x
argument_list|)
expr_stmt|;
name|explshot
argument_list|(
name|Bullets
argument_list|,
name|bp
operator|->
name|b_y
argument_list|,
name|bp
operator|->
name|b_x
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|--
name|bp
operator|->
name|b_charge
operator|<=
literal|0
condition|)
block|{
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|bp
argument_list|)
expr_stmt|;
return|return;
block|}
name|dirmask
operator|=
literal|0
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|bp
operator|->
name|b_face
condition|)
block|{
case|case
name|LEFTS
case|:
if|if
condition|(
operator|!
name|iswall
argument_list|(
name|bp
operator|->
name|b_y
argument_list|,
name|bp
operator|->
name|b_x
operator|-
literal|1
argument_list|)
condition|)
name|dirmask
operator||=
name|WEST
operator|,
name|count
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|iswall
argument_list|(
name|bp
operator|->
name|b_y
operator|-
literal|1
argument_list|,
name|bp
operator|->
name|b_x
argument_list|)
condition|)
name|dirmask
operator||=
name|NORTH
operator|,
name|count
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|iswall
argument_list|(
name|bp
operator|->
name|b_y
operator|+
literal|1
argument_list|,
name|bp
operator|->
name|b_x
argument_list|)
condition|)
name|dirmask
operator||=
name|SOUTH
operator|,
name|count
operator|++
expr_stmt|;
if|if
condition|(
name|dirmask
operator|==
literal|0
condition|)
if|if
condition|(
operator|!
name|iswall
argument_list|(
name|bp
operator|->
name|b_y
argument_list|,
name|bp
operator|->
name|b_x
operator|+
literal|1
argument_list|)
condition|)
name|dirmask
operator||=
name|EAST
operator|,
name|count
operator|++
expr_stmt|;
break|break;
case|case
name|RIGHT
case|:
if|if
condition|(
operator|!
name|iswall
argument_list|(
name|bp
operator|->
name|b_y
argument_list|,
name|bp
operator|->
name|b_x
operator|+
literal|1
argument_list|)
condition|)
name|dirmask
operator||=
name|EAST
operator|,
name|count
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|iswall
argument_list|(
name|bp
operator|->
name|b_y
operator|-
literal|1
argument_list|,
name|bp
operator|->
name|b_x
argument_list|)
condition|)
name|dirmask
operator||=
name|NORTH
operator|,
name|count
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|iswall
argument_list|(
name|bp
operator|->
name|b_y
operator|+
literal|1
argument_list|,
name|bp
operator|->
name|b_x
argument_list|)
condition|)
name|dirmask
operator||=
name|SOUTH
operator|,
name|count
operator|++
expr_stmt|;
if|if
condition|(
name|dirmask
operator|==
literal|0
condition|)
if|if
condition|(
operator|!
name|iswall
argument_list|(
name|bp
operator|->
name|b_y
argument_list|,
name|bp
operator|->
name|b_x
operator|-
literal|1
argument_list|)
condition|)
name|dirmask
operator||=
name|WEST
operator|,
name|count
operator|++
expr_stmt|;
break|break;
case|case
name|ABOVE
case|:
if|if
condition|(
operator|!
name|iswall
argument_list|(
name|bp
operator|->
name|b_y
operator|-
literal|1
argument_list|,
name|bp
operator|->
name|b_x
argument_list|)
condition|)
name|dirmask
operator||=
name|NORTH
operator|,
name|count
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|iswall
argument_list|(
name|bp
operator|->
name|b_y
argument_list|,
name|bp
operator|->
name|b_x
operator|-
literal|1
argument_list|)
condition|)
name|dirmask
operator||=
name|WEST
operator|,
name|count
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|iswall
argument_list|(
name|bp
operator|->
name|b_y
argument_list|,
name|bp
operator|->
name|b_x
operator|+
literal|1
argument_list|)
condition|)
name|dirmask
operator||=
name|EAST
operator|,
name|count
operator|++
expr_stmt|;
if|if
condition|(
name|dirmask
operator|==
literal|0
condition|)
if|if
condition|(
operator|!
name|iswall
argument_list|(
name|bp
operator|->
name|b_y
operator|+
literal|1
argument_list|,
name|bp
operator|->
name|b_x
argument_list|)
condition|)
name|dirmask
operator||=
name|SOUTH
operator|,
name|count
operator|++
expr_stmt|;
break|break;
case|case
name|BELOW
case|:
if|if
condition|(
operator|!
name|iswall
argument_list|(
name|bp
operator|->
name|b_y
operator|+
literal|1
argument_list|,
name|bp
operator|->
name|b_x
argument_list|)
condition|)
name|dirmask
operator||=
name|SOUTH
operator|,
name|count
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|iswall
argument_list|(
name|bp
operator|->
name|b_y
argument_list|,
name|bp
operator|->
name|b_x
operator|-
literal|1
argument_list|)
condition|)
name|dirmask
operator||=
name|WEST
operator|,
name|count
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|iswall
argument_list|(
name|bp
operator|->
name|b_y
argument_list|,
name|bp
operator|->
name|b_x
operator|+
literal|1
argument_list|)
condition|)
name|dirmask
operator||=
name|EAST
operator|,
name|count
operator|++
expr_stmt|;
if|if
condition|(
name|dirmask
operator|==
literal|0
condition|)
if|if
condition|(
operator|!
name|iswall
argument_list|(
name|bp
operator|->
name|b_y
operator|-
literal|1
argument_list|,
name|bp
operator|->
name|b_x
argument_list|)
condition|)
name|dirmask
operator||=
name|NORTH
operator|,
name|count
operator|++
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|count
operator|==
literal|0
condition|)
block|{
comment|/* 		 * No place to go.  Just sit here for a while and wait 		 * for adjacent squares to clear out. 		 */
name|save_bullet
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|bp
operator|->
name|b_charge
operator|<
name|count
condition|)
block|{
comment|/* Only bp->b_charge paths may be taken */
while|while
condition|(
name|count
operator|>
name|bp
operator|->
name|b_charge
condition|)
block|{
if|if
condition|(
name|dirmask
operator|&
name|WEST
condition|)
name|dirmask
operator|&=
operator|~
name|WEST
expr_stmt|;
elseif|else
if|if
condition|(
name|dirmask
operator|&
name|EAST
condition|)
name|dirmask
operator|&=
operator|~
name|EAST
expr_stmt|;
elseif|else
if|if
condition|(
name|dirmask
operator|&
name|NORTH
condition|)
name|dirmask
operator|&=
operator|~
name|NORTH
expr_stmt|;
elseif|else
if|if
condition|(
name|dirmask
operator|&
name|SOUTH
condition|)
name|dirmask
operator|&=
operator|~
name|SOUTH
expr_stmt|;
name|count
operator|--
expr_stmt|;
block|}
block|}
name|i
operator|=
name|bp
operator|->
name|b_charge
operator|/
name|count
expr_stmt|;
name|j
operator|=
name|bp
operator|->
name|b_charge
operator|%
name|count
expr_stmt|;
if|if
condition|(
name|dirmask
operator|&
name|WEST
condition|)
block|{
name|count
operator|--
expr_stmt|;
name|nbp
operator|=
name|create_shot
argument_list|(
name|bp
operator|->
name|b_type
argument_list|,
name|bp
operator|->
name|b_y
argument_list|,
name|bp
operator|->
name|b_x
operator|-
literal|1
argument_list|,
name|LEFTS
argument_list|,
name|i
argument_list|,
name|bp
operator|->
name|b_size
argument_list|,
name|bp
operator|->
name|b_owner
argument_list|,
name|bp
operator|->
name|b_score
argument_list|,
name|TRUE
argument_list|,
name|SPACE
argument_list|)
expr_stmt|;
name|move_slime
argument_list|(
name|nbp
argument_list|,
name|speed
operator|-
literal|1
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dirmask
operator|&
name|EAST
condition|)
block|{
name|count
operator|--
expr_stmt|;
name|nbp
operator|=
name|create_shot
argument_list|(
name|bp
operator|->
name|b_type
argument_list|,
name|bp
operator|->
name|b_y
argument_list|,
name|bp
operator|->
name|b_x
operator|+
literal|1
argument_list|,
name|RIGHT
argument_list|,
operator|(
name|count
operator|<
name|j
operator|)
condition|?
name|i
operator|+
literal|1
else|:
name|i
argument_list|,
name|bp
operator|->
name|b_size
argument_list|,
name|bp
operator|->
name|b_owner
argument_list|,
name|bp
operator|->
name|b_score
argument_list|,
name|TRUE
argument_list|,
name|SPACE
argument_list|)
expr_stmt|;
name|move_slime
argument_list|(
name|nbp
argument_list|,
name|speed
operator|-
literal|1
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dirmask
operator|&
name|NORTH
condition|)
block|{
name|count
operator|--
expr_stmt|;
name|nbp
operator|=
name|create_shot
argument_list|(
name|bp
operator|->
name|b_type
argument_list|,
name|bp
operator|->
name|b_y
operator|-
literal|1
argument_list|,
name|bp
operator|->
name|b_x
argument_list|,
name|ABOVE
argument_list|,
operator|(
name|count
operator|<
name|j
operator|)
condition|?
name|i
operator|+
literal|1
else|:
name|i
argument_list|,
name|bp
operator|->
name|b_size
argument_list|,
name|bp
operator|->
name|b_owner
argument_list|,
name|bp
operator|->
name|b_score
argument_list|,
name|TRUE
argument_list|,
name|SPACE
argument_list|)
expr_stmt|;
name|move_slime
argument_list|(
name|nbp
argument_list|,
name|speed
operator|-
literal|1
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dirmask
operator|&
name|SOUTH
condition|)
block|{
name|count
operator|--
expr_stmt|;
name|nbp
operator|=
name|create_shot
argument_list|(
name|bp
operator|->
name|b_type
argument_list|,
name|bp
operator|->
name|b_y
operator|+
literal|1
argument_list|,
name|bp
operator|->
name|b_x
argument_list|,
name|BELOW
argument_list|,
operator|(
name|count
operator|<
name|j
operator|)
condition|?
name|i
operator|+
literal|1
else|:
name|i
argument_list|,
name|bp
operator|->
name|b_size
argument_list|,
name|bp
operator|->
name|b_owner
argument_list|,
name|bp
operator|->
name|b_score
argument_list|,
name|TRUE
argument_list|,
name|SPACE
argument_list|)
expr_stmt|;
name|move_slime
argument_list|(
name|nbp
argument_list|,
name|speed
operator|-
literal|1
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|bp
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * iswall:  *	returns whether the given location is a wall  */
end_comment

begin_expr_stmt
name|iswall
argument_list|(
name|y
argument_list|,
name|x
argument_list|)
specifier|register
name|int
name|y
operator|,
name|x
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|y
operator|<
literal|0
operator|||
name|x
operator|<
literal|0
operator|||
name|y
operator|>=
name|HEIGHT
operator|||
name|x
operator|>=
name|WIDTH
condition|)
return|return
name|TRUE
return|;
switch|switch
condition|(
name|Maze
index|[
name|y
index|]
index|[
name|x
index|]
condition|)
block|{
case|case
name|WALL1
case|:
case|case
name|WALL2
case|:
case|case
name|WALL3
case|:
ifdef|#
directive|ifdef
name|REFLECT
case|case
name|WALL4
case|:
case|case
name|WALL5
case|:
endif|#
directive|endif
ifdef|#
directive|ifdef
name|RANDOM
case|case
name|DOOR
case|:
endif|#
directive|endif
ifdef|#
directive|ifdef
name|OOZE
case|case
name|SLIME
case|:
ifdef|#
directive|ifdef
name|VOLCANO
case|case
name|LAVA
case|:
endif|#
directive|endif
endif|#
directive|endif
return|return
name|TRUE
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * zapshot:  *	Take a shot out of the air.  */
end_comment

begin_expr_stmt
name|zapshot
argument_list|(
name|blist
argument_list|,
name|obp
argument_list|)
specifier|register
name|BULLET
operator|*
name|blist
operator|,
operator|*
name|obp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|BULLET
modifier|*
name|bp
decl_stmt|;
specifier|register
name|FLAG
name|explode
decl_stmt|;
name|explode
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|bp
operator|=
name|blist
init|;
name|bp
operator|!=
name|NULL
condition|;
name|bp
operator|=
name|bp
operator|->
name|b_next
control|)
block|{
if|if
condition|(
name|bp
operator|->
name|b_x
operator|!=
name|obp
operator|->
name|b_x
operator|||
name|bp
operator|->
name|b_y
operator|!=
name|obp
operator|->
name|b_y
condition|)
continue|continue;
if|if
condition|(
name|bp
operator|->
name|b_face
operator|==
name|obp
operator|->
name|b_face
condition|)
continue|continue;
name|explode
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|explode
condition|)
return|return;
name|explshot
argument_list|(
name|blist
argument_list|,
name|obp
operator|->
name|b_y
argument_list|,
name|obp
operator|->
name|b_x
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * explshot -  *	Make all shots at this location blow up  */
end_comment

begin_expr_stmt
name|explshot
argument_list|(
name|blist
argument_list|,
name|y
argument_list|,
name|x
argument_list|)
specifier|register
name|BULLET
operator|*
name|blist
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|y
decl_stmt|,
name|x
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|BULLET
modifier|*
name|bp
decl_stmt|;
for|for
control|(
name|bp
operator|=
name|blist
init|;
name|bp
operator|!=
name|NULL
condition|;
name|bp
operator|=
name|bp
operator|->
name|b_next
control|)
if|if
condition|(
name|bp
operator|->
name|b_x
operator|==
name|x
operator|&&
name|bp
operator|->
name|b_y
operator|==
name|y
condition|)
block|{
name|bp
operator|->
name|b_expl
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_owner
operator|!=
name|NULL
condition|)
name|message
argument_list|(
name|bp
operator|->
name|b_owner
argument_list|,
literal|"Shot intercepted"
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * play_at:  *	Return a pointer to the player at the given location  */
end_comment

begin_function
name|PLAYER
modifier|*
name|play_at
parameter_list|(
name|y
parameter_list|,
name|x
parameter_list|)
specifier|register
name|int
name|y
decl_stmt|,
name|x
decl_stmt|;
block|{
specifier|register
name|PLAYER
modifier|*
name|pp
decl_stmt|;
for|for
control|(
name|pp
operator|=
name|Player
init|;
name|pp
operator|<
name|End_player
condition|;
name|pp
operator|++
control|)
if|if
condition|(
name|pp
operator|->
name|p_x
operator|==
name|x
operator|&&
name|pp
operator|->
name|p_y
operator|==
name|y
condition|)
return|return
name|pp
return|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"driver: couldn't find player at (%d,%d)\n"
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_function

begin_comment
comment|/*  * opposite:  *	Return TRUE if the bullet direction faces the opposite direction  *	of the player in the maze  */
end_comment

begin_macro
name|opposite
argument_list|(
argument|face
argument_list|,
argument|dir
argument_list|)
end_macro

begin_decl_stmt
name|int
name|face
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|dir
decl_stmt|;
end_decl_stmt

begin_block
block|{
switch|switch
condition|(
name|face
condition|)
block|{
case|case
name|LEFTS
case|:
return|return
operator|(
name|dir
operator|==
name|RIGHT
operator|)
return|;
case|case
name|RIGHT
case|:
return|return
operator|(
name|dir
operator|==
name|LEFTS
operator|)
return|;
case|case
name|ABOVE
case|:
return|return
operator|(
name|dir
operator|==
name|BELOW
operator|)
return|;
case|case
name|BELOW
case|:
return|return
operator|(
name|dir
operator|==
name|ABOVE
operator|)
return|;
default|default:
return|return
name|FALSE
return|;
block|}
block|}
end_block

begin_comment
comment|/*  * is_bullet:  *	Is there a bullet at the given coordinates?  If so, return  *	a pointer to the bullet, otherwise return NULL  */
end_comment

begin_function
name|BULLET
modifier|*
name|is_bullet
parameter_list|(
name|y
parameter_list|,
name|x
parameter_list|)
specifier|register
name|int
name|y
decl_stmt|,
name|x
decl_stmt|;
block|{
specifier|register
name|BULLET
modifier|*
name|bp
decl_stmt|;
for|for
control|(
name|bp
operator|=
name|Bullets
init|;
name|bp
operator|!=
name|NULL
condition|;
name|bp
operator|=
name|bp
operator|->
name|b_next
control|)
if|if
condition|(
name|bp
operator|->
name|b_y
operator|==
name|y
operator|&&
name|bp
operator|->
name|b_x
operator|==
name|x
condition|)
return|return
name|bp
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * fixshots:  *	change the underlying character of the shots at a location  *	to the given character.  */
end_comment

begin_expr_stmt
name|fixshots
argument_list|(
name|y
argument_list|,
name|x
argument_list|,
name|over
argument_list|)
specifier|register
name|int
name|y
operator|,
name|x
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
name|over
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|BULLET
modifier|*
name|bp
decl_stmt|;
for|for
control|(
name|bp
operator|=
name|Bullets
init|;
name|bp
operator|!=
name|NULL
condition|;
name|bp
operator|=
name|bp
operator|->
name|b_next
control|)
if|if
condition|(
name|bp
operator|->
name|b_y
operator|==
name|y
operator|&&
name|bp
operator|->
name|b_x
operator|==
name|x
condition|)
name|bp
operator|->
name|b_over
operator|=
name|over
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * find_under:  *	find the underlying character for a bullet when it lands  *	on another bullet.  */
end_comment

begin_expr_stmt
name|find_under
argument_list|(
name|blist
argument_list|,
name|bp
argument_list|)
specifier|register
name|BULLET
operator|*
name|blist
operator|,
operator|*
name|bp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|BULLET
modifier|*
name|nbp
decl_stmt|;
for|for
control|(
name|nbp
operator|=
name|blist
init|;
name|nbp
operator|!=
name|NULL
condition|;
name|nbp
operator|=
name|nbp
operator|->
name|b_next
control|)
if|if
condition|(
name|bp
operator|->
name|b_y
operator|==
name|nbp
operator|->
name|b_y
operator|&&
name|bp
operator|->
name|b_x
operator|==
name|nbp
operator|->
name|b_x
condition|)
block|{
name|bp
operator|->
name|b_over
operator|=
name|nbp
operator|->
name|b_over
expr_stmt|;
break|break;
block|}
block|}
end_block

begin_comment
comment|/*  * mark_player:  *	mark a player as under a shot  */
end_comment

begin_expr_stmt
name|mark_player
argument_list|(
name|bp
argument_list|)
specifier|register
name|BULLET
operator|*
name|bp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|PLAYER
modifier|*
name|pp
decl_stmt|;
for|for
control|(
name|pp
operator|=
name|Player
init|;
name|pp
operator|<
name|End_player
condition|;
name|pp
operator|++
control|)
if|if
condition|(
name|pp
operator|->
name|p_y
operator|==
name|bp
operator|->
name|b_y
operator|&&
name|pp
operator|->
name|p_x
operator|==
name|bp
operator|->
name|b_x
condition|)
block|{
name|pp
operator|->
name|p_undershot
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|BOOTS
end_ifdef

begin_comment
comment|/*  * mark_boot:  *	mark a boot as under a shot  */
end_comment

begin_expr_stmt
name|mark_boot
argument_list|(
name|bp
argument_list|)
specifier|register
name|BULLET
operator|*
name|bp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|PLAYER
modifier|*
name|pp
decl_stmt|;
for|for
control|(
name|pp
operator|=
name|Boot
init|;
name|pp
operator|<
operator|&
name|Boot
index|[
name|NBOOTS
index|]
condition|;
name|pp
operator|++
control|)
if|if
condition|(
name|pp
operator|->
name|p_y
operator|==
name|bp
operator|->
name|b_y
operator|&&
name|pp
operator|->
name|p_x
operator|==
name|bp
operator|->
name|b_x
condition|)
block|{
name|pp
operator|->
name|p_undershot
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

end_unit

