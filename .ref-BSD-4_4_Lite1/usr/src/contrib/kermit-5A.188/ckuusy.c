begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|NOCMDL
end_ifndef

begin_comment
comment|/*  C K U U S Y --  "User Interface" for Unix Kermit, part Y  */
end_comment

begin_comment
comment|/*  Command-Line Argument Parser */
end_comment

begin_comment
comment|/*   Author: Frank da Cruz (fdc@columbia.edu, FDCCU@CUVMA.BITNET),   Columbia University Center for Computing Activities.   First released January 1985.   Copyright (C) 1985, 1992, Trustees of Columbia University in the City of New   York.  Permission is granted to any individual or institution to use this   software as long as it is not sold for profit.  This copyright notice must be   retained.  This software may not be included in commercial products without   written permission of Columbia University. */
end_comment

begin_include
include|#
directive|include
file|"ckcdeb.h"
end_include

begin_include
include|#
directive|include
file|"ckcasc.h"
end_include

begin_include
include|#
directive|include
file|"ckcker.h"
end_include

begin_include
include|#
directive|include
file|"ckucmd.h"
end_include

begin_include
include|#
directive|include
file|"ckcnet.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|NETCONN
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|SUNX25
end_ifdef

begin_include
include|#
directive|include
file|"ckcnet.h"
end_include

begin_decl_stmt
specifier|extern
name|int
name|revcall
decl_stmt|,
name|closgr
decl_stmt|,
name|cudata
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
name|udata
index|[
name|MAXCUDATA
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|x25fd
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SUNX25 */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|telnetfd
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NETCONN */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|ckxsys
decl_stmt|,
modifier|*
name|ckzsys
decl_stmt|,
modifier|*
name|cmarg
decl_stmt|,
modifier|*
name|cmarg2
decl_stmt|,
modifier|*
modifier|*
name|xargv
decl_stmt|,
modifier|*
modifier|*
name|cmlist
decl_stmt|,
modifier|*
name|clcmds
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|action
decl_stmt|,
name|cflg
decl_stmt|,
name|xargc
decl_stmt|,
name|stdouf
decl_stmt|,
name|stdinf
decl_stmt|,
name|displa
decl_stmt|,
name|cnflg
decl_stmt|,
name|nfils
decl_stmt|,
name|local
decl_stmt|,
name|quiet
decl_stmt|,
name|escape
decl_stmt|,
name|network
decl_stmt|,
name|mdmtyp
decl_stmt|,
name|maxrps
decl_stmt|,
name|rpsiz
decl_stmt|,
name|bgset
decl_stmt|,
name|xargs
decl_stmt|,
name|urpsiz
decl_stmt|,
name|wslotr
decl_stmt|,
name|swcapr
decl_stmt|,
name|binary
decl_stmt|,
name|warn
decl_stmt|,
name|parity
decl_stmt|,
name|turn
decl_stmt|,
name|turnch
decl_stmt|,
name|duplex
decl_stmt|,
name|flow
decl_stmt|,
name|fncact
decl_stmt|,
name|clfils
decl_stmt|,
name|noinit
decl_stmt|,
name|stayflg
decl_stmt|,
name|nettype
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|long
name|speed
decl_stmt|,
name|ttgspd
argument_list|()
decl_stmt|,
name|zchki
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
name|ttname
index|[]
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|NODIAL
end_ifndef

begin_decl_stmt
specifier|extern
name|int
name|nmdm
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|keytab
name|mdmtab
index|[]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NODIAL */
end_comment

begin_comment
comment|/*  C M D L I N  --  Get arguments from command line  */
end_comment

begin_comment
comment|/*  Simple Unix-style command line parser, conforming with 'A Proposed Command  Syntax Standard for Unix Systems', Hemenway& Armitage, Unix/World, Vol.1,  No.3, 1984. */
end_comment

begin_function
name|int
name|cmdlin
parameter_list|()
block|{
name|char
name|x
decl_stmt|;
comment|/* Local general-purpose int */
name|cmarg
operator|=
literal|""
expr_stmt|;
comment|/* Initialize globals */
name|cmarg2
operator|=
literal|""
expr_stmt|;
name|action
operator|=
name|cflg
operator|=
literal|0
expr_stmt|;
comment|/* If we were started directly from a Kermit application file, its name is */
comment|/* in argv[1], so skip past it. */
if|if
condition|(
name|xargc
operator|>
literal|1
condition|)
block|{
if|if
condition|(
operator|*
name|xargv
index|[
literal|0
index|]
operator|!=
literal|'-'
operator|&&
operator|*
name|xargv
index|[
literal|1
index|]
operator|!=
literal|'-'
condition|)
block|{
if|if
condition|(
comment|/* some shells don't put full pathname... */
comment|/* zchki(xargv[0])> 0&& */
comment|/* ...so skip this test */
name|zchki
argument_list|(
name|xargv
index|[
literal|1
index|]
argument_list|)
operator|>
literal|0
condition|)
block|{
comment|/* if it's an existing file */
name|xargc
operator|-=
literal|1
expr_stmt|;
comment|/* skip past it */
name|xargv
operator|+=
literal|1
expr_stmt|;
comment|/* ... */
block|}
block|}
block|}
while|while
condition|(
operator|--
name|xargc
operator|>
literal|0
condition|)
block|{
comment|/* Go through command line words */
name|xargv
operator|++
expr_stmt|;
name|debug
argument_list|(
name|F111
argument_list|,
literal|"xargv"
argument_list|,
operator|*
name|xargv
argument_list|,
name|xargc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|xargv
operator|==
literal|'='
condition|)
return|return
operator|(
literal|0
operator|)
return|;
ifdef|#
directive|ifdef
name|VMS
elseif|else
if|if
condition|(
operator|*
operator|*
name|xargv
operator|==
literal|'/'
condition|)
continue|continue;
endif|#
directive|endif
comment|/* VMS */
elseif|else
if|if
condition|(
operator|*
operator|*
name|xargv
operator|==
literal|'-'
condition|)
block|{
comment|/* Got an option (begins with dash) */
name|x
operator|=
operator|*
operator|(
operator|*
name|xargv
operator|+
literal|1
operator|)
expr_stmt|;
comment|/* Get the option letter */
if|if
condition|(
name|doarg
argument_list|(
name|x
argument_list|)
operator|<
literal|0
condition|)
name|doexit
argument_list|(
name|BAD_EXIT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Go handle option */
block|}
else|else
block|{
comment|/* No dash where expected */
name|usage
argument_list|()
expr_stmt|;
name|doexit
argument_list|(
name|BAD_EXIT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|debug
argument_list|(
name|F101
argument_list|,
literal|"action"
argument_list|,
literal|""
argument_list|,
name|action
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|local
condition|)
block|{
if|if
condition|(
operator|(
name|action
operator|==
literal|'c'
operator|)
operator|||
operator|(
name|cflg
operator|!=
literal|0
operator|)
condition|)
name|fatal
argument_list|(
literal|"-l and -b required"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|cmarg2
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|action
operator|!=
literal|'s'
operator|)
operator|&&
operator|(
name|action
operator|!=
literal|'r'
operator|)
operator|&&
operator|(
name|action
operator|!=
literal|'v'
operator|)
condition|)
name|fatal
argument_list|(
literal|"-a without -s, -r, or -g"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|action
operator|==
literal|'v'
operator|)
operator|&&
operator|(
name|stdouf
operator|)
operator|&&
operator|(
operator|!
name|local
operator|)
condition|)
block|{
if|if
condition|(
name|isatty
argument_list|(
literal|1
argument_list|)
condition|)
name|fatal
argument_list|(
literal|"unredirected -k can only be used in local mode"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|action
operator|==
literal|'s'
operator|)
operator|||
operator|(
name|action
operator|==
literal|'v'
operator|)
operator|||
operator|(
name|action
operator|==
literal|'r'
operator|)
operator|||
operator|(
name|action
operator|==
literal|'x'
operator|)
condition|)
block|{
if|if
condition|(
name|local
condition|)
name|displa
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|stdouf
condition|)
block|{
name|displa
operator|=
literal|0
expr_stmt|;
name|quiet
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|quiet
condition|)
name|displa
operator|=
literal|0
expr_stmt|;
comment|/* No display if quiet requested */
return|return
operator|(
name|action
operator|)
return|;
comment|/* Then do any requested protocol */
block|}
end_function

begin_comment
comment|/*  D O A R G  --  Do a command-line argument.  */
end_comment

begin_function
name|int
ifdef|#
directive|ifdef
name|CK_ANSIC
name|doarg
parameter_list|(
name|char
name|x
parameter_list|)
else|#
directive|else
function|doarg
parameter_list|(
name|x
parameter_list|)
name|char
name|x
decl_stmt|;
endif|#
directive|endif
comment|/* CK_ANSIC */
comment|/* doarg */
block|{
name|int
name|i
decl_stmt|,
name|y
decl_stmt|,
name|z
decl_stmt|;
name|long
name|zz
decl_stmt|;
name|char
modifier|*
name|xp
decl_stmt|;
name|xp
operator|=
operator|*
name|xargv
operator|+
literal|1
expr_stmt|;
comment|/* Pointer for bundled args */
while|while
condition|(
name|x
condition|)
block|{
switch|switch
condition|(
name|x
condition|)
block|{
ifndef|#
directive|ifndef
name|NOSPL
case|case
literal|'C'
case|:
comment|/* Commands for parser */
name|xargv
operator|++
operator|,
name|xargc
operator|--
expr_stmt|;
if|if
condition|(
operator|(
name|xargc
operator|<
literal|1
operator|)
operator|||
operator|(
operator|*
operator|*
name|xargv
operator|==
literal|'-'
operator|)
condition|)
name|fatal
argument_list|(
literal|"No commands given for -C"
argument_list|)
expr_stmt|;
name|clcmds
operator|=
operator|*
name|xargv
expr_stmt|;
comment|/* Get the argument (must be quoted) */
break|break;
endif|#
directive|endif
comment|/* NOSPL */
ifndef|#
directive|ifndef
name|NOICP
case|case
literal|'S'
case|:
comment|/* "Stay" - enter interactive */
name|stayflg
operator|=
literal|1
expr_stmt|;
comment|/* command parser after executing */
break|break;
comment|/* command-line actions. */
endif|#
directive|endif
comment|/* NOICP */
ifndef|#
directive|ifndef
name|NOSERVER
case|case
literal|'x'
case|:
comment|/* server */
if|if
condition|(
name|action
condition|)
name|fatal
argument_list|(
literal|"conflicting actions"
argument_list|)
expr_stmt|;
name|action
operator|=
literal|'x'
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* NOSERVER */
case|case
literal|'f'
case|:
comment|/* finish */
if|if
condition|(
name|action
condition|)
name|fatal
argument_list|(
literal|"conflicting actions"
argument_list|)
expr_stmt|;
name|action
operator|=
name|setgen
argument_list|(
literal|'F'
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
comment|/* receive */
if|if
condition|(
name|action
condition|)
name|fatal
argument_list|(
literal|"conflicting actions"
argument_list|)
expr_stmt|;
name|action
operator|=
literal|'v'
expr_stmt|;
break|break;
case|case
literal|'k'
case|:
comment|/* receive to stdout */
if|if
condition|(
name|action
condition|)
name|fatal
argument_list|(
literal|"conflicting actions"
argument_list|)
expr_stmt|;
name|stdouf
operator|=
literal|1
expr_stmt|;
name|action
operator|=
literal|'v'
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
comment|/* send */
if|if
condition|(
name|action
condition|)
name|fatal
argument_list|(
literal|"conflicting actions"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|xp
operator|+
literal|1
operator|)
condition|)
name|fatal
argument_list|(
literal|"invalid argument bundling after -s"
argument_list|)
expr_stmt|;
name|nfils
operator|=
name|z
operator|=
literal|0
expr_stmt|;
comment|/* Initialize file counter, flag */
name|cmlist
operator|=
name|xargv
operator|+
literal|1
expr_stmt|;
comment|/* Remember this pointer */
while|while
condition|(
operator|--
name|xargc
operator|>
literal|0
condition|)
block|{
comment|/* Traverse the list */
name|xargv
operator|++
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|xargv
operator|==
literal|'-'
condition|)
block|{
comment|/* Check for sending stdin */
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|xargv
argument_list|,
literal|"-"
argument_list|)
operator|!=
literal|0
condition|)
comment|/* Watch out for next option. */
break|break;
name|z
operator|++
expr_stmt|;
comment|/* "-" alone means send from stdin. */
block|}
elseif|else
if|if
condition|(
name|zchki
argument_list|(
operator|*
name|xargv
argument_list|)
operator|>
operator|-
literal|1
comment|/* Check if file exists */
ifndef|#
directive|ifndef
name|UNIX
comment|/* or contains wildcard characters matching real files */
operator|||
operator|(
name|iswild
argument_list|(
operator|*
name|xargv
argument_list|)
operator|&&
name|zxpand
argument_list|(
operator|*
name|xargv
argument_list|)
operator|>
literal|0
operator|)
endif|#
directive|endif
comment|/* UNIX */
condition|)
block|{
name|nfils
operator|++
expr_stmt|;
comment|/* Bump file counter */
block|}
block|}
name|xargc
operator|++
operator|,
name|xargv
operator|--
expr_stmt|;
comment|/* Adjust argv/argc */
if|if
condition|(
name|nfils
operator|<
literal|1
operator|&&
name|z
operator|==
literal|0
condition|)
ifdef|#
directive|ifdef
name|VMS
name|fatal
argument_list|(
literal|"%CKERMIT-E-SEARCHFAIL, no files for -s"
argument_list|)
expr_stmt|;
else|#
directive|else
name|fatal
argument_list|(
literal|"No files for -s"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* VMS */
if|if
condition|(
name|z
operator|>
literal|1
condition|)
name|fatal
argument_list|(
literal|"-s: too many -'s"
argument_list|)
expr_stmt|;
if|if
condition|(
name|z
operator|==
literal|1
operator|&&
name|nfils
operator|>
literal|0
condition|)
name|fatal
argument_list|(
literal|"invalid mixture of filenames and '-' in -s"
argument_list|)
expr_stmt|;
if|if
condition|(
name|nfils
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|isatty
argument_list|(
literal|0
argument_list|)
condition|)
name|fatal
argument_list|(
literal|"sending from terminal not allowed"
argument_list|)
expr_stmt|;
else|else
name|stdinf
operator|=
literal|1
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|COMMENT
comment|/* If only one filespec was given, indicate "internal list" rather than */
comment|/* "expanded list", so in case it includes wildcards, C-Kermit can */
comment|/* expand them itself. */
if|if
condition|(
name|nfils
operator|==
literal|1
condition|)
block|{
name|cmarg
operator|=
operator|*
name|cmlist
expr_stmt|;
name|nfils
operator|=
operator|-
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* COMMENT */
name|debug
argument_list|(
name|F101
argument_list|,
operator|*
name|xargv
argument_list|,
literal|""
argument_list|,
name|nfils
argument_list|)
expr_stmt|;
name|action
operator|=
literal|'s'
expr_stmt|;
ifdef|#
directive|ifdef
name|UNIX
comment|/* When set, this flag tells Kermit not to expand wildcard characters. */
comment|/* In UNIX, the shell has already expanded them.  In VMS, OS/2, etc, */
comment|/* Kermit must expand them.  Kermit must not expand them in UNIX because */
comment|/* a filename might itself contain metacharacters.  Imagine, for example, */
comment|/* what would happen if a directory contained a file named "*". */
name|clfils
operator|=
literal|1
expr_stmt|;
comment|/* Flag for command-line files */
endif|#
directive|endif
comment|/* UNIX */
break|break;
case|case
literal|'g'
case|:
comment|/* get */
if|if
condition|(
name|action
condition|)
name|fatal
argument_list|(
literal|"conflicting actions"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|xp
operator|+
literal|1
operator|)
condition|)
name|fatal
argument_list|(
literal|"invalid argument bundling after -g"
argument_list|)
expr_stmt|;
name|xargv
operator|++
operator|,
name|xargc
operator|--
expr_stmt|;
if|if
condition|(
operator|(
name|xargc
operator|==
literal|0
operator|)
operator|||
operator|(
operator|*
operator|*
name|xargv
operator|==
literal|'-'
operator|)
condition|)
name|fatal
argument_list|(
literal|"missing filename for -g"
argument_list|)
expr_stmt|;
name|cmarg
operator|=
operator|*
name|xargv
expr_stmt|;
name|action
operator|=
literal|'r'
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
comment|/* connect before */
name|cflg
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
comment|/* connect after */
name|cnflg
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
comment|/* help */
name|usage
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|NOICP
if|if
condition|(
name|stayflg
condition|)
break|break;
else|else
endif|#
directive|endif
comment|/* NOICP */
name|doexit
argument_list|(
name|GOOD_EXIT
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
case|case
literal|'a'
case|:
comment|/* "as" */
if|if
condition|(
operator|*
operator|(
name|xp
operator|+
literal|1
operator|)
condition|)
name|fatal
argument_list|(
literal|"invalid argument bundling after -a"
argument_list|)
expr_stmt|;
name|xargv
operator|++
operator|,
name|xargc
operator|--
expr_stmt|;
if|if
condition|(
operator|(
name|xargc
operator|<
literal|1
operator|)
operator|||
operator|(
operator|*
operator|*
name|xargv
operator|==
literal|'-'
operator|)
condition|)
name|fatal
argument_list|(
literal|"missing name in -a"
argument_list|)
expr_stmt|;
name|cmarg2
operator|=
operator|*
name|xargv
expr_stmt|;
break|break;
ifndef|#
directive|ifndef
name|NOICP
case|case
literal|'Y'
case|:
comment|/* No initialization file */
name|noinit
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'y'
case|:
comment|/* Alternate init-file name */
if|if
condition|(
operator|*
operator|(
name|xp
operator|+
literal|1
operator|)
condition|)
name|fatal
argument_list|(
literal|"invalid argument bundling after -y"
argument_list|)
expr_stmt|;
name|xargv
operator|++
operator|,
name|xargc
operator|--
expr_stmt|;
if|if
condition|(
name|xargc
operator|<
literal|1
condition|)
name|fatal
argument_list|(
literal|"missing name in -y"
argument_list|)
expr_stmt|;
comment|/* strcpy(kermrc,*xargv); ...this was already done in prescan()... */
break|break;
endif|#
directive|endif
comment|/* NOICP */
case|case
literal|'l'
case|:
comment|/* set line */
ifdef|#
directive|ifdef
name|NETCONN
case|case
literal|'X'
case|:
comment|/* set host to X.25 address */
case|case
literal|'Z'
case|:
comment|/* set host to X.25 file descriptor */
case|case
literal|'j'
case|:
comment|/* set host (TCP/IP socket) */
endif|#
directive|endif
comment|/* NETCONN */
name|network
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|xp
operator|+
literal|1
operator|)
condition|)
name|fatal
argument_list|(
literal|"invalid argument bundling after -l or -j"
argument_list|)
expr_stmt|;
name|xargv
operator|++
operator|,
name|xargc
operator|--
expr_stmt|;
if|if
condition|(
operator|(
name|xargc
operator|<
literal|1
operator|)
operator|||
operator|(
operator|*
operator|*
name|xargv
operator|==
literal|'-'
operator|)
condition|)
name|fatal
argument_list|(
literal|"communication line device name missing"
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|ttname
argument_list|,
operator|*
name|xargv
argument_list|)
expr_stmt|;
name|local
operator|=
operator|(
name|strcmp
argument_list|(
name|ttname
argument_list|,
name|CTTNAM
argument_list|)
operator|!=
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|x
operator|==
literal|'l'
condition|)
block|{
if|if
condition|(
name|ttopen
argument_list|(
name|ttname
argument_list|,
operator|&
name|local
argument_list|,
name|mdmtyp
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
name|fatal
argument_list|(
literal|"can't open device"
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|"cmdlin speed"
argument_list|,
literal|""
argument_list|,
name|speed
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|COMMENT
comment|/* What can it hurt? */
if|if
condition|(
name|speed
operator|<
literal|0L
condition|)
comment|/* If speed hasn't been set yet, */
endif|#
directive|endif
comment|/* COMMENT */
name|speed
operator|=
name|ttgspd
argument_list|()
expr_stmt|;
comment|/* get it. */
ifdef|#
directive|ifdef
name|NETCONN
block|}
else|else
block|{
if|if
condition|(
name|x
operator|==
literal|'j'
condition|)
block|{
comment|/* IP network host name */
name|mdmtyp
operator|=
operator|-
name|nettype
expr_stmt|;
comment|/* perhaps alread set in init file */
name|telnetfd
operator|=
literal|1
expr_stmt|;
comment|/* Or maybe an open file descriptor */
ifdef|#
directive|ifdef
name|SUNX25
block|}
elseif|else
if|if
condition|(
name|x
operator|==
literal|'X'
condition|)
block|{
comment|/* X.25 address */
name|mdmtyp
operator|=
literal|0
operator|-
name|NET_SX25
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|x
operator|==
literal|'Z'
condition|)
block|{
comment|/* Open X.25 file descriptor */
name|mdmtyp
operator|=
literal|0
operator|-
name|NET_SX25
expr_stmt|;
name|x25fd
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* SUNX25 */
block|}
if|if
condition|(
name|ttopen
argument_list|(
name|ttname
argument_list|,
operator|&
name|local
argument_list|,
name|mdmtyp
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
name|fatal
argument_list|(
literal|"can't open host connection"
argument_list|)
expr_stmt|;
name|network
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* NETCONN */
block|}
comment|/* add more here later - decnet, etc... */
break|break;
ifdef|#
directive|ifdef
name|SUNX25
case|case
literal|'U'
case|:
comment|/* X.25 call user data */
if|if
condition|(
operator|*
operator|(
name|xp
operator|+
literal|1
operator|)
condition|)
name|fatal
argument_list|(
literal|"invalid argument bundling"
argument_list|)
expr_stmt|;
name|xargv
operator|++
operator|,
name|xargc
operator|--
expr_stmt|;
if|if
condition|(
operator|(
name|xargc
operator|<
literal|1
operator|)
operator|||
operator|(
operator|*
operator|*
name|xargv
operator|==
literal|'-'
operator|)
condition|)
name|fatal
argument_list|(
literal|"missing call user data string"
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|udata
argument_list|,
operator|*
name|xargv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|udata
argument_list|)
operator|<=
name|MAXCUDATA
condition|)
name|cudata
operator|=
literal|1
expr_stmt|;
else|else
name|fatal
argument_list|(
literal|"Invalid call user data"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
comment|/* X.25 closed user group */
if|if
condition|(
operator|*
operator|(
name|xp
operator|+
literal|1
operator|)
condition|)
name|fatal
argument_list|(
literal|"invalid argument bundling"
argument_list|)
expr_stmt|;
name|xargv
operator|++
operator|,
name|xargc
operator|--
expr_stmt|;
if|if
condition|(
operator|(
name|xargc
operator|<
literal|1
operator|)
operator|||
operator|(
operator|*
operator|*
name|xargv
operator|==
literal|'-'
operator|)
condition|)
name|fatal
argument_list|(
literal|"missing closed user group index"
argument_list|)
expr_stmt|;
name|z
operator|=
name|atoi
argument_list|(
operator|*
name|xargv
argument_list|)
expr_stmt|;
comment|/* Convert to number */
if|if
condition|(
name|z
operator|>=
literal|0
operator|&&
name|z
operator|<=
literal|99
condition|)
name|closgr
operator|=
name|z
expr_stmt|;
else|else
name|fatal
argument_list|(
literal|"Invalid closed user group index"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
comment|/* X.25 reverse charge call */
name|revcall
operator|=
literal|1
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* SUNX25 */
case|case
literal|'b'
case|:
comment|/* set bits-per-second for serial */
if|if
condition|(
operator|*
operator|(
name|xp
operator|+
literal|1
operator|)
condition|)
name|fatal
argument_list|(
literal|"invalid argument bundling"
argument_list|)
expr_stmt|;
comment|/* communication device */
name|xargv
operator|++
operator|,
name|xargc
operator|--
expr_stmt|;
if|if
condition|(
operator|(
name|xargc
operator|<
literal|1
operator|)
operator|||
operator|(
operator|*
operator|*
name|xargv
operator|==
literal|'-'
operator|)
condition|)
name|fatal
argument_list|(
literal|"missing baud"
argument_list|)
expr_stmt|;
name|zz
operator|=
name|atol
argument_list|(
operator|*
name|xargv
argument_list|)
expr_stmt|;
comment|/* Convert to long int */
name|i
operator|=
name|zz
operator|/
literal|10L
expr_stmt|;
if|if
condition|(
name|ttsspd
argument_list|(
name|i
argument_list|)
operator|>
operator|-
literal|1
condition|)
comment|/* Check and set it */
name|speed
operator|=
name|zz
expr_stmt|;
else|else
name|fatal
argument_list|(
literal|"unsupported transmission rate"
argument_list|)
expr_stmt|;
break|break;
ifndef|#
directive|ifndef
name|NODIAL
case|case
literal|'m'
case|:
comment|/* Modem type */
if|if
condition|(
operator|*
operator|(
name|xp
operator|+
literal|1
operator|)
condition|)
name|fatal
argument_list|(
literal|"invalid argument bundling after -m"
argument_list|)
expr_stmt|;
name|xargv
operator|++
operator|,
name|xargc
operator|--
expr_stmt|;
if|if
condition|(
operator|(
name|xargc
operator|<
literal|1
operator|)
operator|||
operator|(
operator|*
operator|*
name|xargv
operator|==
literal|'-'
operator|)
condition|)
name|fatal
argument_list|(
literal|"modem type missing"
argument_list|)
expr_stmt|;
name|y
operator|=
name|lookup
argument_list|(
name|mdmtab
argument_list|,
operator|*
name|xargv
argument_list|,
name|nmdm
argument_list|,
operator|&
name|z
argument_list|)
expr_stmt|;
if|if
condition|(
name|y
operator|<
literal|0
condition|)
name|fatal
argument_list|(
literal|"unknown modem type"
argument_list|)
expr_stmt|;
name|mdmtyp
operator|=
name|y
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|'e'
case|:
comment|/* Extended packet length */
if|if
condition|(
operator|*
operator|(
name|xp
operator|+
literal|1
operator|)
condition|)
name|fatal
argument_list|(
literal|"invalid argument bundling after -e"
argument_list|)
expr_stmt|;
name|xargv
operator|++
operator|,
name|xargc
operator|--
expr_stmt|;
if|if
condition|(
operator|(
name|xargc
operator|<
literal|1
operator|)
operator|||
operator|(
operator|*
operator|*
name|xargv
operator|==
literal|'-'
operator|)
condition|)
name|fatal
argument_list|(
literal|"missing length"
argument_list|)
expr_stmt|;
name|z
operator|=
name|atoi
argument_list|(
operator|*
name|xargv
argument_list|)
expr_stmt|;
comment|/* Convert to number */
if|if
condition|(
name|z
operator|>
literal|10
operator|&&
name|z
operator|<=
name|maxrps
condition|)
block|{
name|rpsiz
operator|=
name|urpsiz
operator|=
name|z
expr_stmt|;
if|if
condition|(
name|z
operator|>
literal|94
condition|)
name|rpsiz
operator|=
literal|94
expr_stmt|;
comment|/* Fallback if other Kermit can't */
block|}
else|else
name|fatal
argument_list|(
literal|"Unsupported packet length"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
comment|/* Vindow size */
if|if
condition|(
operator|*
operator|(
name|xp
operator|+
literal|1
operator|)
condition|)
name|fatal
argument_list|(
literal|"invalid argument bundling"
argument_list|)
expr_stmt|;
name|xargv
operator|++
operator|,
name|xargc
operator|--
expr_stmt|;
if|if
condition|(
operator|(
name|xargc
operator|<
literal|1
operator|)
operator|||
operator|(
operator|*
operator|*
name|xargv
operator|==
literal|'-'
operator|)
condition|)
name|fatal
argument_list|(
literal|"missing or bad window size"
argument_list|)
expr_stmt|;
name|z
operator|=
name|atoi
argument_list|(
operator|*
name|xargv
argument_list|)
expr_stmt|;
comment|/* Convert to number */
if|if
condition|(
name|z
operator|<
literal|32
condition|)
block|{
comment|/* If in range */
name|wslotr
operator|=
name|z
expr_stmt|;
comment|/* set it */
if|if
condition|(
name|z
operator|>
literal|1
condition|)
name|swcapr
operator|=
literal|1
expr_stmt|;
comment|/* Set capas bit if windowing */
block|}
else|else
name|fatal
argument_list|(
literal|"Unsupported packet length"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
comment|/* Treat files as binary */
name|binary
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
comment|/* Writeover */
name|warn
operator|=
literal|0
expr_stmt|;
name|fncact
operator|=
name|XYFX_X
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
comment|/* Quiet */
name|quiet
operator|=
literal|1
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|DEBUG
case|case
literal|'d'
case|:
comment|/* debug */
comment|/** debopn("debug.log"); *** already did this in prescan() **/
break|break;
endif|#
directive|endif
comment|/* DEBUG */
case|case
literal|'p'
case|:
comment|/* set parity */
if|if
condition|(
operator|*
operator|(
name|xp
operator|+
literal|1
operator|)
condition|)
name|fatal
argument_list|(
literal|"invalid argument bundling"
argument_list|)
expr_stmt|;
name|xargv
operator|++
operator|,
name|xargc
operator|--
expr_stmt|;
if|if
condition|(
operator|(
name|xargc
operator|<
literal|1
operator|)
operator|||
operator|(
operator|*
operator|*
name|xargv
operator|==
literal|'-'
operator|)
condition|)
name|fatal
argument_list|(
literal|"missing parity"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|x
operator|=
operator|*
operator|*
name|xargv
condition|)
block|{
case|case
literal|'e'
case|:
case|case
literal|'o'
case|:
case|case
literal|'m'
case|:
case|case
literal|'s'
case|:
name|parity
operator|=
name|x
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|parity
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|fatal
argument_list|(
literal|"invalid parity"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'t'
case|:
name|turn
operator|=
literal|1
expr_stmt|;
comment|/* Line turnaround handshake */
name|turnch
operator|=
name|XON
expr_stmt|;
comment|/* XON is turnaround character */
name|duplex
operator|=
literal|1
expr_stmt|;
comment|/* Half duplex */
name|flow
operator|=
literal|0
expr_stmt|;
comment|/* No flow control */
break|break;
case|case
literal|'z'
case|:
comment|/* Not background */
name|bgset
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|fatal
argument_list|(
literal|"invalid argument, type 'kermit -h' for help"
argument_list|)
expr_stmt|;
block|}
name|x
operator|=
operator|*
operator|++
name|xp
expr_stmt|;
comment|/* See if options are bundled */
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* No command-line interface... */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|xargc
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|cmdlin
parameter_list|()
block|{
if|if
condition|(
name|xargc
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"Sorry, command-line options disabled.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NOCMDL */
end_comment

end_unit

