begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|NOICP
end_ifndef

begin_comment
comment|/*  C K U U S 4 --  "User Interface" for Unix Kermit, part 4  */
end_comment

begin_comment
comment|/*   Author: Frank da Cruz (fdc@columbia.edu, FDCCU@CUVMA.BITNET),   Columbia University Center for Computing Activities.   First released January 1985.   Copyright (C) 1985, 1992, Trustees of Columbia University in the City of New   York.  Permission is granted to any individual or institution to use this   software as long as it is not sold for profit.  This copyright notice must be   retained.  This software may not be included in commercial products without   written permission of Columbia University. */
end_comment

begin_comment
comment|/*   File ckuus4.c -- Functions moved from other ckuus*.c modules to even   out their sizes. */
end_comment

begin_include
include|#
directive|include
file|"ckcdeb.h"
end_include

begin_include
include|#
directive|include
file|"ckcasc.h"
end_include

begin_include
include|#
directive|include
file|"ckcker.h"
end_include

begin_include
include|#
directive|include
file|"ckuusr.h"
end_include

begin_include
include|#
directive|include
file|"ckuver.h"
end_include

begin_include
include|#
directive|include
file|"ckcnet.h"
end_include

begin_comment
comment|/* Network symbols */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NOCSETS
end_ifndef

begin_comment
comment|/* Character sets */
end_comment

begin_include
include|#
directive|include
file|"ckcxla.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NOCSETS */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|AMIGA
end_ifndef

begin_ifndef
ifndef|#
directive|ifndef
name|MAC
end_ifndef

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MAC */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* AMIGA */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SUNX25
end_ifdef

begin_decl_stmt
specifier|extern
name|int
name|revcall
decl_stmt|,
name|closgr
decl_stmt|,
name|cudata
decl_stmt|,
name|npadx3
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|x25ver
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
name|udata
index|[
name|MAXCUDATA
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|CHAR
name|padparms
index|[
name|MAXPADPARMS
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|keytab
name|padx3tab
index|[]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SUNX25 */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|NETCONN
end_ifdef

begin_decl_stmt
specifier|extern
name|char
name|ipaddr
index|[]
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|TNCODE
end_ifdef

begin_decl_stmt
specifier|extern
name|int
name|tn_duplex
decl_stmt|,
name|tn_nlm
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|tn_term
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TNCODE */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NETCONN */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NOSPL
end_ifndef

begin_comment
comment|/* This needs to be internationalized... */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|months
index|[]
init|=
block|{
literal|"Jan"
block|,
literal|"Feb"
block|,
literal|"Mar"
block|,
literal|"Apr"
block|,
literal|"May"
block|,
literal|"Jun"
block|,
literal|"Jul"
block|,
literal|"Aug"
block|,
literal|"Sep"
block|,
literal|"Oct"
block|,
literal|"Nov"
block|,
literal|"Dec"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|wkdays
index|[]
init|=
block|{
literal|"Sun"
block|,
literal|"Mon"
block|,
literal|"Tue"
block|,
literal|"Wed"
block|,
literal|"Thu"
block|,
literal|"Fri"
block|,
literal|"Sat"
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NOSPL */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|UNIX
end_ifdef

begin_decl_stmt
specifier|extern
name|int
name|ttyfd
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* UNIX */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|OS2
end_ifdef

begin_decl_stmt
specifier|extern
name|int
name|ttyfd
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OS2 */
end_comment

begin_macro
name|_PROTOTYP
argument_list|(
argument|static VOID shods
argument_list|,
argument|(char *)
argument_list|)
end_macro

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_decl_stmt
specifier|extern
name|struct
name|keytab
name|colxtab
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|CHAR
name|eol
decl_stmt|,
name|mypadc
decl_stmt|,
name|mystch
decl_stmt|,
name|padch
decl_stmt|,
name|seol
decl_stmt|,
name|stchr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
name|kermrc
index|[]
decl_stmt|,
name|ttname
index|[]
decl_stmt|,
modifier|*
name|ckxsys
decl_stmt|,
modifier|*
name|versio
decl_stmt|,
modifier|*
modifier|*
name|xargv
decl_stmt|,
modifier|*
name|zinptr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|atcapr
decl_stmt|,
name|autopar
decl_stmt|,
name|bctr
decl_stmt|,
name|bctu
decl_stmt|,
name|bgset
decl_stmt|,
name|bigrbsiz
decl_stmt|,
name|bigsbsiz
decl_stmt|,
name|binary
decl_stmt|,
name|carrier
decl_stmt|,
name|cdtimo
decl_stmt|,
name|cmask
decl_stmt|,
name|crunched
decl_stmt|,
name|delay
decl_stmt|,
name|duplex
decl_stmt|,
name|ebq
decl_stmt|,
name|ebqflg
decl_stmt|,
name|escape
decl_stmt|,
name|flow
decl_stmt|,
name|fmask
decl_stmt|,
name|fncact
decl_stmt|,
name|fncnv
decl_stmt|,
name|incase
decl_stmt|,
name|inecho
decl_stmt|,
name|keep
decl_stmt|,
name|local
decl_stmt|,
name|lscapr
decl_stmt|,
name|lscapu
decl_stmt|,
name|maxrps
decl_stmt|,
name|maxsps
decl_stmt|,
name|maxtry
decl_stmt|,
name|mdmspd
decl_stmt|,
name|mdmtyp
decl_stmt|,
name|mypadn
decl_stmt|,
name|ncolx
decl_stmt|,
name|nettype
decl_stmt|,
name|network
decl_stmt|,
name|nmac
decl_stmt|,
name|noinit
decl_stmt|,
name|npad
decl_stmt|,
name|parity
decl_stmt|,
name|pktlog
decl_stmt|,
name|pkttim
decl_stmt|,
name|rcflag
decl_stmt|,
name|retrans
decl_stmt|,
name|rpackets
decl_stmt|,
name|rptflg
decl_stmt|,
name|rptq
decl_stmt|,
name|rtimo
decl_stmt|,
name|seslog
decl_stmt|,
name|sessft
decl_stmt|,
name|sosi
decl_stmt|,
name|spackets
decl_stmt|,
name|spsiz
decl_stmt|,
name|spsizf
decl_stmt|,
name|spsizr
decl_stmt|,
name|srvtim
decl_stmt|,
name|stayflg
decl_stmt|,
name|success
decl_stmt|,
name|timeouts
decl_stmt|,
name|tralog
decl_stmt|,
name|tsecs
decl_stmt|,
name|ttnproto
decl_stmt|,
name|turn
decl_stmt|,
name|turnch
decl_stmt|,
name|urpsiz
decl_stmt|,
name|wmax
decl_stmt|,
name|wslotn
decl_stmt|,
name|wslotr
decl_stmt|,
name|xargc
decl_stmt|,
name|xargs
decl_stmt|,
name|zincnt
decl_stmt|,
name|fdispla
decl_stmt|,
name|tlevel
decl_stmt|,
name|xitsta
decl_stmt|,
name|spmax
decl_stmt|,
name|insilence
decl_stmt|,
name|cmdmsk
decl_stmt|,
name|timint
decl_stmt|,
name|timef
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|VMS
end_ifdef

begin_decl_stmt
specifier|extern
name|int
name|frecl
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* VMS */
end_comment

begin_decl_stmt
specifier|extern
name|long
name|ffc
decl_stmt|,
name|filcnt
decl_stmt|,
name|rptn
decl_stmt|,
name|speed
decl_stmt|,
name|tfc
decl_stmt|,
name|tlci
decl_stmt|,
name|tlco
decl_stmt|,
name|vernum
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|NOSPL
end_ifndef

begin_decl_stmt
specifier|extern
name|char
name|fspec
index|[]
decl_stmt|,
name|myhost
index|[]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NOSPL */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|tfnam
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Command file names */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DCMDBUF
end_ifdef

begin_decl_stmt
specifier|extern
name|struct
name|cmdptr
modifier|*
name|cmdstk
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|line
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|extern
name|struct
name|cmdptr
name|cmdstk
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
name|line
index|[]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DCMDBUF */
end_comment

begin_decl_stmt
specifier|extern
name|char
name|pktfil
index|[]
decl_stmt|,
comment|/* Packet log file name */
ifdef|#
directive|ifdef
name|DEBUG
name|debfil
index|[]
decl_stmt|,
comment|/* Debug log file name */
endif|#
directive|endif
comment|/* DEBUG */
ifdef|#
directive|ifdef
name|TLOG
name|trafil
index|[]
decl_stmt|,
comment|/* Transaction log file name */
endif|#
directive|endif
comment|/* TLOG */
name|sesfil
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Session log file name */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NOXMIT
end_ifndef

begin_comment
comment|/* TRANSMIT command variables */
end_comment

begin_decl_stmt
specifier|extern
name|char
name|xmitbuf
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|xmitf
decl_stmt|,
name|xmitl
decl_stmt|,
name|xmitp
decl_stmt|,
name|xmitx
decl_stmt|,
name|xmits
decl_stmt|,
name|xmitw
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NOXMIT */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NOSPL
end_ifndef

begin_comment
comment|/* Script programming language items */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
modifier|*
name|a_ptr
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Arrays */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|a_dim
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
name|inpbuf
index|[]
decl_stmt|,
name|inchar
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Buffers for INPUT and REINPUT */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|inpbp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* And pointer to same */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|inpbps
init|=
name|inpbuf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* And another */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|incount
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* INPUT character count */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|maclvl
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Macro invocation level */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|mtab
modifier|*
name|mactab
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Macro table */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|mrval
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|macargc
index|[]
decl_stmt|,
name|cmdlvl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|m_arg
index|[
name|MACLEVEL
index|]
index|[
literal|10
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* You have to put in the dimensions */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|g_var
index|[
name|GVARS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* for external 2-dimensional arrays. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DCMDBUF
end_ifdef

begin_decl_stmt
specifier|extern
name|int
modifier|*
name|count
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|extern
name|int
name|count
index|[]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DCMDBUF */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NOSPL */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|UNIX
end_ifdef

begin_decl_stmt
specifier|extern
name|int
name|haslock
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For UUCP locks */
end_comment

begin_decl_stmt
specifier|extern
name|char
name|flfnam
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|maxnam
decl_stmt|,
name|maxpath
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Longest name, path length */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* UNIX */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NODIAL
end_ifndef

begin_comment
comment|/* DIAL-related variables */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|nmdm
decl_stmt|,
name|dialhng
decl_stmt|,
name|dialtmo
decl_stmt|,
name|dialksp
decl_stmt|,
name|dialdpy
decl_stmt|,
name|dialmnp
decl_stmt|,
name|dialmhu
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|dialnum
decl_stmt|,
modifier|*
name|dialdir
decl_stmt|,
modifier|*
name|dialnpr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|keytab
name|mdmtab
index|[]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NODIAL */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NOCSETS
end_ifndef

begin_comment
comment|/* Translation stuff */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|fcharset
decl_stmt|,
name|tcharset
decl_stmt|,
name|tslevel
decl_stmt|,
name|language
decl_stmt|,
name|nlng
decl_stmt|,
name|tcsr
decl_stmt|,
name|tcsl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|keytab
name|lngtab
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|csinfo
name|fcsinfo
index|[]
decl_stmt|,
name|tcsinfo
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|langinfo
name|langs
index|[]
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|CK_ANSIC
end_ifdef

begin_function_decl
specifier|extern
name|CHAR
function_decl|(
modifier|*
name|xls
index|[
name|MAXTCSETS
operator|+
literal|1
index|]
index|[
name|MAXFCSETS
operator|+
literal|1
index|]
function_decl|)
parameter_list|(
name|CHAR
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Character set */
end_comment

begin_function_decl
specifier|extern
name|CHAR
function_decl|(
modifier|*
name|xlr
index|[
name|MAXTCSETS
operator|+
literal|1
index|]
index|[
name|MAXFCSETS
operator|+
literal|1
index|]
function_decl|)
parameter_list|(
name|CHAR
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* translation functions */
end_comment

begin_else
else|#
directive|else
end_else

begin_function_decl
specifier|extern
name|CHAR
function_decl|(
modifier|*
name|xls
index|[
name|MAXTCSETS
operator|+
literal|1
index|]
index|[
name|MAXFCSETS
operator|+
literal|1
index|]
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Character set */
end_comment

begin_function_decl
specifier|extern
name|CHAR
function_decl|(
modifier|*
name|xlr
index|[
name|MAXTCSETS
operator|+
literal|1
index|]
index|[
name|MAXFCSETS
operator|+
literal|1
index|]
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* translation functions. */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CK_ANSIC */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NOCSETS */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NOSPL
end_ifndef

begin_comment
comment|/* Built-in variable names, maximum length VNAML (20 characters) */
end_comment

begin_decl_stmt
name|struct
name|keytab
name|vartab
index|[]
init|=
block|{
literal|"argc"
block|,
name|VN_ARGC
block|,
literal|0
block|,
literal|"args"
block|,
name|VN_ARGS
block|,
literal|0
block|,
literal|"cmdfile"
block|,
name|VN_CMDF
block|,
literal|0
block|,
literal|"cmdlevel"
block|,
name|VN_CMDL
block|,
literal|0
block|,
literal|"cmdsource"
block|,
name|VN_CMDS
block|,
literal|0
block|,
literal|"count"
block|,
name|VN_COUN
block|,
literal|0
block|,
literal|"cpu"
block|,
name|VN_CPU
block|,
literal|0
block|,
literal|"date"
block|,
name|VN_DATE
block|,
literal|0
block|,
literal|"day"
block|,
name|VN_DAY
block|,
literal|0
block|,
comment|/* Edit 181 */
literal|"directory"
block|,
name|VN_DIRE
block|,
literal|0
block|,
literal|"exitstatus"
block|,
name|VN_EXIT
block|,
literal|0
block|,
literal|"filespec"
block|,
name|VN_FILE
block|,
literal|0
block|,
literal|"fsize"
block|,
name|VN_FFC
block|,
literal|0
block|,
literal|"home"
block|,
name|VN_HOME
block|,
literal|0
block|,
literal|"host"
block|,
name|VN_HOST
block|,
literal|0
block|,
literal|"input"
block|,
name|VN_IBUF
block|,
literal|0
block|,
literal|"inchar"
block|,
name|VN_ICHR
block|,
literal|0
block|,
literal|"incount"
block|,
name|VN_ICNT
block|,
literal|0
block|,
literal|"line"
block|,
name|VN_LINE
block|,
literal|0
block|,
literal|"local"
block|,
name|VN_LCL
block|,
literal|0
block|,
literal|"macro"
block|,
name|VN_MAC
block|,
literal|0
block|,
literal|"ndate"
block|,
name|VN_NDAT
block|,
literal|0
block|,
literal|"nday"
block|,
name|VN_NDAY
block|,
literal|0
block|,
literal|"ntime"
block|,
name|VN_NTIM
block|,
literal|0
block|,
literal|"platform"
block|,
name|VN_SYSV
block|,
literal|0
block|,
literal|"program"
block|,
name|VN_PROG
block|,
literal|0
block|,
literal|"return"
block|,
name|VN_RET
block|,
literal|0
block|,
literal|"speed"
block|,
name|VN_SPEE
block|,
literal|0
block|,
literal|"status"
block|,
name|VN_SUCC
block|,
literal|0
block|,
literal|"system"
block|,
name|VN_SYST
block|,
literal|0
block|,
literal|"tfsize"
block|,
name|VN_TFC
block|,
literal|0
block|,
literal|"time"
block|,
name|VN_TIME
block|,
literal|0
block|,
ifdef|#
directive|ifdef
name|UNIX
literal|"ttyfd"
block|,
name|VN_TTYF
block|,
literal|0
block|,
endif|#
directive|endif
comment|/* UNIX */
ifdef|#
directive|ifdef
name|OS2
literal|"ttyfd"
block|,
name|VN_TTYF
block|,
literal|0
block|,
endif|#
directive|endif
comment|/* OS2 */
literal|"version"
block|,
name|VN_VERS
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nvars
init|=
operator|(
sizeof|sizeof
argument_list|(
name|vartab
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|keytab
argument_list|)
operator|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NOSPL */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NOSPL
end_ifndef

begin_decl_stmt
name|struct
name|keytab
name|fnctab
index|[]
init|=
block|{
comment|/* Function names */
literal|"character"
block|,
name|FN_CHR
block|,
literal|0
block|,
comment|/* Character from code */
literal|"code"
block|,
name|FN_COD
block|,
literal|0
block|,
comment|/* Code from character */
literal|"contents"
block|,
name|FN_CON
block|,
literal|0
block|,
comment|/* Definition (contents) of variable */
literal|"definition"
block|,
name|FN_DEF
block|,
literal|0
block|,
comment|/* Return definition of given macro */
literal|"evaluate"
block|,
name|FN_EVA
block|,
literal|0
block|,
comment|/* Evaluate given arith expression */
literal|"execute"
block|,
name|FN_EXE
block|,
literal|0
block|,
comment|/* Execute given macro */
literal|"files"
block|,
name|FN_FC
block|,
literal|0
block|,
comment|/* File count */
literal|"index"
block|,
name|FN_IND
block|,
literal|0
block|,
comment|/* Index (string search) */
literal|"length"
block|,
name|FN_LEN
block|,
literal|0
block|,
comment|/* Return length of argument */
literal|"literal"
block|,
name|FN_LIT
block|,
literal|0
block|,
comment|/* Return argument literally */
literal|"lower"
block|,
name|FN_LOW
block|,
literal|0
block|,
comment|/* Return lowercased argument */
literal|"lpad"
block|,
name|FN_LPA
block|,
literal|0
block|,
comment|/* Return left-padded argument */
literal|"maximum"
block|,
name|FN_MAX
block|,
literal|0
block|,
comment|/* Return maximum of two arguments */
literal|"minimim"
block|,
name|FN_MIN
block|,
literal|0
block|,
comment|/* Return minimum of two arguments */
ifdef|#
directive|ifdef
name|COMMENT
comment|/* not needed because \feval() has it */
literal|"modulus"
block|,
name|FN_MOD
block|,
literal|0
block|,
comment|/* Return modulus of two arguments */
endif|#
directive|endif
comment|/* COMMENT */
literal|"nextfile"
block|,
name|FN_FIL
block|,
literal|0
block|,
comment|/* Next file in list */
literal|"repeat"
block|,
name|FN_REP
block|,
literal|0
block|,
comment|/* Repeat argument given # of times */
ifndef|#
directive|ifndef
name|NOFRILLS
literal|"reverse"
block|,
name|FN_REV
block|,
literal|0
block|,
comment|/* Reverse the argument string */
endif|#
directive|endif
comment|/* NOFRILLS */
literal|"right"
block|,
name|FN_RIG
block|,
literal|0
block|,
comment|/* Rightmost n characters */
literal|"rpad"
block|,
name|FN_RPA
block|,
literal|0
block|,
comment|/* Right-pad the argument */
literal|"substring"
block|,
name|FN_SUB
block|,
literal|0
block|,
comment|/* Extract substring from argument */
literal|"upper"
block|,
name|FN_UPP
block|,
literal|0
comment|/* Return uppercased argument */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nfuncs
init|=
operator|(
sizeof|sizeof
argument_list|(
name|fnctab
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|keytab
argument_list|)
operator|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NOSPL */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NOSPL
end_ifndef

begin_comment
comment|/* Buffer for expansion of */
end_comment

begin_define
define|#
directive|define
name|VVBUFL
value|60
end_define

begin_comment
comment|/* built-in variables. */
end_comment

begin_decl_stmt
name|char
name|vvbuf
index|[
name|VVBUFL
index|]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NOSPL */
end_comment

begin_decl_stmt
name|struct
name|keytab
name|disptb
index|[]
init|=
block|{
comment|/* Log file disposition */
literal|"append"
block|,
literal|1
block|,
literal|0
block|,
literal|"new"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  P R E S C A N -- Quick look thru command-line args for init file name */
end_comment

begin_comment
comment|/*  Also for -d (debug), -z (force foreground), -S (stay) */
end_comment

begin_function
name|VOID
name|prescan
parameter_list|()
block|{
name|int
name|yargc
decl_stmt|;
name|char
modifier|*
modifier|*
name|yargv
decl_stmt|;
name|char
name|x
decl_stmt|;
name|yargc
operator|=
name|xargc
expr_stmt|;
name|yargv
operator|=
name|xargv
expr_stmt|;
name|strcpy
argument_list|(
name|kermrc
argument_list|,
name|KERMRC
argument_list|)
expr_stmt|;
comment|/* Default init file name */
ifndef|#
directive|ifndef
name|NOCMDL
while|while
condition|(
operator|--
name|yargc
operator|>
literal|0
condition|)
block|{
comment|/* Look for -y on command line */
name|yargv
operator|++
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|yargv
operator|==
literal|'-'
condition|)
block|{
comment|/* Option starting with dash */
name|x
operator|=
operator|*
operator|(
operator|*
name|yargv
operator|+
literal|1
operator|)
expr_stmt|;
comment|/* Get option letter */
if|if
condition|(
name|x
operator|==
literal|'Y'
condition|)
block|{
comment|/* Is it Y (= no init file?) */
name|noinit
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|x
operator|==
literal|'y'
condition|)
block|{
comment|/* Is it y? */
name|yargv
operator|++
operator|,
name|yargc
operator|--
expr_stmt|;
comment|/* Yes, count and check argument */
if|if
condition|(
name|yargc
operator|<
literal|1
condition|)
name|fatal
argument_list|(
literal|"missing name in -y"
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|kermrc
argument_list|,
operator|*
name|yargv
argument_list|)
expr_stmt|;
comment|/* Replace init file name */
name|rcflag
operator|=
literal|1
expr_stmt|;
comment|/* Flag that this has been done */
continue|continue;
block|}
elseif|else
if|if
condition|(
name|x
operator|==
literal|'d'
condition|)
block|{
comment|/* Do this early as possible! */
name|debopn
argument_list|(
literal|"debug.log"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|x
operator|==
literal|'z'
condition|)
block|{
comment|/* = SET BACKGROUND OFF */
name|bgset
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|x
operator|==
literal|'S'
condition|)
block|{
name|stayflg
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
block|}
block|}
endif|#
directive|endif
comment|/* NOCMDL */
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|tr_int
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Flag if TRANSMIT interrupted */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|MAC
end_ifndef

begin_function
name|SIGTYP
name|trtrap
parameter_list|(
name|foo
parameter_list|)
name|int
name|foo
decl_stmt|;
block|{
comment|/* TRANSMIT interrupt trap */
ifdef|#
directive|ifdef
name|__EMX__
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_ACK
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|tr_int
operator|=
literal|1
expr_stmt|;
comment|/* (Need arg for ANSI C) */
name|SIGRETURN
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MAC */
end_comment

begin_comment
comment|/*  G E T T C S  --  Get Transfer (Intermediate) Character Set  */
end_comment

begin_comment
comment|/*   Given two file character sets, this routine picks out the appropriate   "transfer" character set to use for translating between them.   The transfer character set number is returned.    Translation between two file character sets is done, for example,   by the CONNECT, TRANSMIT, and TRANSLATE commands.    Translation between Kanji character sets is not yet supported. */
end_comment

begin_function
name|int
name|gettcs
parameter_list|(
name|cs1
parameter_list|,
name|cs2
parameter_list|)
name|int
name|cs1
decl_stmt|,
name|cs2
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|NOCSETS
comment|/* No character-set support */
return|return
operator|(
literal|0
operator|)
return|;
comment|/* so no translation */
else|#
directive|else
name|int
name|tcs
init|=
name|TC_TRANSP
decl_stmt|;
ifdef|#
directive|ifdef
name|KANJI
comment|/* Kanji not supported yet */
if|if
condition|(
name|fcsinfo
index|[
name|cs1
index|]
operator|.
name|alphabet
operator|==
name|AL_JAPAN
operator|||
name|fcsinfo
index|[
name|cs2
index|]
operator|.
name|alphabet
operator|==
name|AL_JAPAN
condition|)
name|tcs
operator|=
name|TC_TRANSP
expr_stmt|;
elseif|else
endif|#
directive|endif
comment|/* KANJI */
ifdef|#
directive|ifdef
name|CYRILLIC
comment|/*   I can't remember why we don't test both sets here, but I think there   must have been a reason... */
if|if
condition|(
name|fcsinfo
index|[
name|cs2
index|]
operator|.
name|alphabet
operator|==
name|AL_CYRIL
condition|)
name|tcs
operator|=
name|TC_CYRILL
expr_stmt|;
elseif|else
endif|#
directive|endif
comment|/* CYRILLIC */
ifdef|#
directive|ifdef
name|LATIN2
if|if
condition|(
name|cs1
operator|==
name|FC_2LATIN
operator|||
name|cs1
operator|==
name|FC_2LATIN
operator|||
name|cs1
operator|==
name|FC_CP852
operator|||
name|cs1
operator|==
name|FC_CP852
condition|)
name|tcs
operator|=
name|TC_2LATIN
expr_stmt|;
else|else
endif|#
directive|endif
comment|/* LATIN2 */
name|tcs
operator|=
name|TC_1LATIN
expr_stmt|;
return|return
operator|(
name|tcs
operator|)
return|;
endif|#
directive|endif
comment|/* NOCSETS */
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|NOXMIT
end_ifndef

begin_comment
comment|/*  T R A N S M I T  --  Raw upload  */
end_comment

begin_comment
comment|/*  Obey current line, duplex, parity, flow, text/binary settings. */
end_comment

begin_comment
comment|/*  Returns 0 upon apparent success, 1 on obvious failure.  */
end_comment

begin_comment
comment|/***  Things to add:  . Make both text and binary mode obey set file bytesize.  . Maybe allow user to specify terminators other than CR?  . Maybe allow user to specify prompts other than single characters? ***/
end_comment

begin_comment
comment|/*  T R A N S M I T  --  Raw upload  */
end_comment

begin_comment
comment|/*  s is the filename, t is the turnaround (prompt) character  */
end_comment

begin_comment
comment|/*   Maximum number of characters to buffer.   Must be less than LINBUFSIZ */
end_comment

begin_define
define|#
directive|define
name|XMBUFS
value|120
end_define

begin_function
name|int
ifdef|#
directive|ifdef
name|CK_ANSIC
name|transmit
parameter_list|(
name|char
modifier|*
name|s
parameter_list|,
name|char
name|t
parameter_list|)
else|#
directive|else
function|transmit
parameter_list|(
name|s
parameter_list|,
name|t
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
name|char
name|t
decl_stmt|;
endif|#
directive|endif
comment|/* CK_ANSIC */
comment|/* transmit */
block|{
ifdef|#
directive|ifdef
name|MAC
specifier|extern
name|char
name|sstate
decl_stmt|;
name|int
name|count
init|=
literal|100
decl_stmt|;
else|#
directive|else
name|SIGTYP
function_decl|(
modifier|*
name|oldsig
function_decl|)
parameter_list|()
function_decl|;
comment|/* For saving old interrupt trap. */
endif|#
directive|endif
comment|/* MAC */
name|long
name|zz
decl_stmt|;
name|int
name|z
init|=
literal|1
decl_stmt|;
comment|/* Return code. 0=fail, 1=succeed. */
name|int
name|x
decl_stmt|,
name|c
decl_stmt|,
name|i
decl_stmt|;
comment|/* Workers... */
name|int
name|myflow
decl_stmt|;
name|CHAR
name|csave
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
ifndef|#
directive|ifndef
name|NOCSETS
name|int
name|tcs
init|=
name|TC_TRANSP
decl_stmt|;
comment|/* Intermediate (xfer) char set */
name|int
name|langsv
init|=
name|L_USASCII
decl_stmt|;
comment|/* Save current language */
name|_PROTOTYP
argument_list|(
name|CHAR
argument_list|(
operator|*
name|sxo
argument_list|)
argument_list|,
operator|(
name|CHAR
operator|)
argument_list|)
operator|=
name|NULL
expr_stmt|;
comment|/* Translation functions */
name|_PROTOTYP
argument_list|(
name|CHAR
argument_list|(
operator|*
name|rxo
argument_list|)
argument_list|,
operator|(
name|CHAR
operator|)
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|_PROTOTYP
argument_list|(
name|CHAR
argument_list|(
operator|*
name|sxi
argument_list|)
argument_list|,
operator|(
name|CHAR
operator|)
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|_PROTOTYP
argument_list|(
name|CHAR
argument_list|(
operator|*
name|rxi
argument_list|)
argument_list|,
operator|(
name|CHAR
operator|)
argument_list|)
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
comment|/* NOCSETS */
if|if
condition|(
name|zopeni
argument_list|(
name|ZIFILE
argument_list|,
name|s
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Open the file to be transmitted */
name|printf
argument_list|(
literal|"?Can't open file %s\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|x
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Open the communication line */
if|if
condition|(
name|ttopen
argument_list|(
name|ttname
argument_list|,
operator|&
name|x
argument_list|,
name|mdmtyp
argument_list|,
name|cdtimo
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* (no harm if already open) */
name|printf
argument_list|(
literal|"Can't open device %s\n"
argument_list|,
name|ttname
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|zz
operator|=
name|x
condition|?
name|speed
else|:
operator|-
literal|1L
expr_stmt|;
if|if
condition|(
name|binary
condition|)
block|{
comment|/* Binary file transmission */
name|myflow
operator|=
operator|(
name|flow
operator|==
name|FLO_XONX
operator|)
condition|?
name|FLO_NONE
else|:
name|flow
expr_stmt|;
if|if
condition|(
name|ttvt
argument_list|(
name|zz
argument_list|,
name|myflow
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* So no Xon/Xoff! */
name|printf
argument_list|(
literal|"Can't condition line\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|ttpkt
argument_list|(
name|zz
argument_list|,
name|flow
argument_list|,
name|parity
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* Put the line in "packet mode" */
name|printf
argument_list|(
literal|"Can't condition line\n"
argument_list|)
expr_stmt|;
comment|/* so Xon/Xoff will work, etc. */
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
ifndef|#
directive|ifndef
name|NOCSETS
name|tcs
operator|=
name|gettcs
argument_list|(
name|tcsr
argument_list|,
name|tcsl
argument_list|)
expr_stmt|;
comment|/* Get intermediate set. */
comment|/* Set up character set translations */
if|if
condition|(
name|binary
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|tcsr
operator|==
name|tcsl
operator|||
name|binary
condition|)
block|{
comment|/* Remote and local sets the same? */
name|sxo
operator|=
name|rxo
operator|=
name|NULL
expr_stmt|;
comment|/* Or file type is not text? */
name|sxi
operator|=
name|rxi
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
comment|/* Otherwise, set up */
name|sxo
operator|=
name|xls
index|[
name|tcs
index|]
index|[
name|tcsl
index|]
expr_stmt|;
comment|/* translation function */
name|rxo
operator|=
name|xlr
index|[
name|tcs
index|]
index|[
name|tcsr
index|]
expr_stmt|;
comment|/* pointers for output functions */
name|sxi
operator|=
name|xls
index|[
name|tcs
index|]
index|[
name|tcsr
index|]
expr_stmt|;
comment|/* and for input functions. */
name|rxi
operator|=
name|xlr
index|[
name|tcs
index|]
index|[
name|tcsl
index|]
expr_stmt|;
block|}
comment|/*   This is to prevent use of zmstuff() and zdstuff() by translation functions.   They only work with disk i/o, not with communication i/o.  Luckily Russian   translation functions don't do any stuffing... */
name|langsv
operator|=
name|language
expr_stmt|;
name|language
operator|=
name|L_USASCII
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* NOCSETS */
name|i
operator|=
literal|0
expr_stmt|;
comment|/* Beginning of buffer. */
ifndef|#
directive|ifndef
name|MAC
ifndef|#
directive|ifndef
name|AMIGA
name|oldsig
operator|=
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|trtrap
argument_list|)
expr_stmt|;
comment|/* Save current interrupt trap. */
endif|#
directive|endif
comment|/* AMIGA */
endif|#
directive|endif
comment|/* MAC */
name|tr_int
operator|=
literal|0
expr_stmt|;
comment|/* Have not been interrupted (yet). */
name|z
operator|=
literal|1
expr_stmt|;
comment|/* Return code presumed good. */
ifdef|#
directive|ifdef
name|VMS
name|conres
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* VMS */
name|c
operator|=
literal|0
expr_stmt|;
comment|/* Initial condition */
while|while
condition|(
name|c
operator|>
operator|-
literal|1
condition|)
block|{
comment|/* Loop for all characters in file */
ifdef|#
directive|ifdef
name|MAC
comment|/* 	 * It is expensive to run the miniparser so don't do it for 	 * every character. 	 */
if|if
condition|(
operator|--
name|count
operator|<
literal|0
condition|)
block|{
name|count
operator|=
literal|100
expr_stmt|;
name|miniparser
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|sstate
operator|==
literal|'a'
condition|)
block|{
name|sstate
operator|=
literal|'\0'
expr_stmt|;
name|z
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
else|#
directive|else
comment|/* Not MAC */
if|if
condition|(
name|tr_int
condition|)
block|{
comment|/* Interrupted? */
name|printf
argument_list|(
literal|"^C...\n"
argument_list|)
expr_stmt|;
comment|/* Print message */
name|z
operator|=
literal|0
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
comment|/* MAC */
name|c
operator|=
name|zminchar
argument_list|()
expr_stmt|;
comment|/* Get a file character */
name|debug
argument_list|(
name|F101
argument_list|,
literal|"transmit char"
argument_list|,
literal|""
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
operator|-
literal|1
condition|)
comment|/* Test for end-of-file */
break|break;
name|c
operator|&=
name|fmask
expr_stmt|;
comment|/* Apply SET FILE BYTESIZE mask */
if|if
condition|(
name|binary
condition|)
block|{
comment|/* If binary file, */
if|if
condition|(
name|ttoc
argument_list|(
name|dopar
argument_list|(
operator|(
name|char
operator|)
name|c
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* else just send the char */
name|printf
argument_list|(
literal|"?Can't transmit character\n"
argument_list|)
expr_stmt|;
name|z
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|xmitw
condition|)
name|msleep
argument_list|(
name|xmitw
argument_list|)
expr_stmt|;
comment|/* Pause if requested */
if|if
condition|(
name|xmitx
condition|)
block|{
comment|/* SET TRANSMIT ECHO ON? */
if|if
condition|(
name|duplex
condition|)
block|{
comment|/* Yes, for half duplex */
name|conoc
argument_list|(
call|(
name|char
call|)
argument_list|(
name|c
operator|&
name|cmdmsk
argument_list|)
argument_list|)
expr_stmt|;
comment|/* echo locally. */
block|}
else|else
block|{
comment|/* For full duplex, */
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
comment|/* display whatever is there. */
name|n
operator|=
name|ttchk
argument_list|()
expr_stmt|;
comment|/* How many chars are waiting? */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
comment|/* Read and echo that many. */
name|x
operator|=
name|ttinc
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* Timed read just in case. */
if|if
condition|(
name|x
operator|>
operator|-
literal|1
condition|)
block|{
comment|/* If no timeout */
if|if
condition|(
name|parity
condition|)
name|x
operator|&=
literal|0x7f
expr_stmt|;
name|conoc
argument_list|(
call|(
name|char
call|)
argument_list|(
name|x
operator|&
name|cmdmsk
argument_list|)
argument_list|)
expr_stmt|;
comment|/* display the char, */
block|}
else|else
break|break;
comment|/* otherwise stop reading. */
block|}
block|}
block|}
else|else
name|ttflui
argument_list|()
expr_stmt|;
comment|/* Not echoing, just flush input. */
block|}
else|else
block|{
comment|/* Text mode, line at a time. */
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
comment|/* Got a line */
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
comment|/* Blank line? */
if|if
condition|(
name|xmitf
condition|)
comment|/* Yes, insert fill if asked. */
name|line
index|[
name|i
operator|++
index|]
operator|=
name|dopar
argument_list|(
operator|(
name|char
operator|)
name|xmitf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
literal|0
operator|||
name|line
index|[
name|i
operator|-
literal|1
index|]
operator|!=
name|dopar
argument_list|(
name|CR
argument_list|)
condition|)
name|line
index|[
name|i
operator|++
index|]
operator|=
name|dopar
argument_list|(
name|CR
argument_list|)
expr_stmt|;
comment|/* Terminate it with CR */
if|if
condition|(
name|xmitl
ifdef|#
directive|ifdef
name|TNCODE
operator|||
operator|(
name|network
operator|&&
name|ttnproto
operator|==
name|NP_TELNET
operator|&&
name|tn_nlm
operator|)
endif|#
directive|endif
comment|/* TNCODE */
condition|)
name|line
index|[
name|i
operator|++
index|]
operator|=
name|dopar
argument_list|(
name|LF
argument_list|)
expr_stmt|;
comment|/* Include LF if asked */
block|}
elseif|else
if|if
condition|(
name|c
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* Not a newline, regular character */
name|csave
operator|=
name|c
expr_stmt|;
comment|/* Remember untranslated version */
ifndef|#
directive|ifndef
name|NOCSETS
comment|/* Translate character sets */
if|if
condition|(
name|sxo
condition|)
name|c
operator|=
call|(
modifier|*
name|sxo
call|)
argument_list|(
operator|(
name|CHAR
operator|)
name|c
argument_list|)
expr_stmt|;
comment|/* From local to intermediate */
if|if
condition|(
name|rxo
condition|)
name|c
operator|=
call|(
modifier|*
name|rxo
call|)
argument_list|(
operator|(
name|CHAR
operator|)
name|c
argument_list|)
expr_stmt|;
comment|/* From intermediate to remote */
endif|#
directive|endif
comment|/* NOCSETS */
if|if
condition|(
name|xmits
operator|&&
name|parity
operator|&&
operator|(
name|c
operator|&
literal|0200
operator|)
condition|)
block|{
comment|/* If shifting */
name|line
index|[
name|i
operator|++
index|]
operator|=
name|dopar
argument_list|(
name|SO
argument_list|)
expr_stmt|;
comment|/* needs to be done, */
name|line
index|[
name|i
operator|++
index|]
operator|=
name|dopar
argument_list|(
operator|(
name|char
operator|)
name|c
argument_list|)
expr_stmt|;
comment|/* do it here, */
name|line
index|[
name|i
operator|++
index|]
operator|=
name|dopar
argument_list|(
name|SI
argument_list|)
expr_stmt|;
comment|/* crudely. */
block|}
else|else
block|{
name|line
index|[
name|i
operator|++
index|]
operator|=
name|dopar
argument_list|(
operator|(
name|char
operator|)
name|c
argument_list|)
expr_stmt|;
comment|/* else, just char itself */
block|}
block|}
comment|/* Send characters if buffer full, or at end of line, or at end of file */
if|if
condition|(
name|i
operator|>=
name|XMBUFS
operator|||
name|c
operator|==
literal|'\n'
operator|||
name|c
operator|==
operator|-
literal|1
condition|)
block|{
name|p
operator|=
name|line
expr_stmt|;
name|line
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
name|debug
argument_list|(
name|F111
argument_list|,
literal|"transmit buf"
argument_list|,
name|p
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|ttol
argument_list|(
operator|(
name|CHAR
operator|*
operator|)
name|p
argument_list|,
name|i
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* try to send it. */
name|printf
argument_list|(
literal|"Can't send buffer\n"
argument_list|)
expr_stmt|;
name|z
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|i
operator|=
literal|0
expr_stmt|;
comment|/* Reset buffer pointer. */
comment|/* Worry about echoing here. "xmitx" is SET TRANSMIT ECHO flag. */
if|if
condition|(
name|duplex
operator|&&
name|xmitx
condition|)
block|{
comment|/* If local echo, echo it */
if|if
condition|(
name|parity
operator|||
name|cmdmsk
operator|==
literal|0x7f
condition|)
block|{
comment|/* Strip off high bits */
name|char
modifier|*
name|s
init|=
name|p
decl_stmt|;
comment|/* if necessary */
while|while
condition|(
operator|*
name|s
condition|)
block|{
operator|*
name|s
operator|&=
literal|0x7f
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
name|conoll
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|xmitw
condition|)
comment|/* Give receiver time to digest. */
name|msleep
argument_list|(
name|xmitw
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|!=
literal|0
operator|&&
name|c
operator|==
literal|'\n'
condition|)
block|{
comment|/* Want a turnaround character */
name|x
operator|=
literal|0
expr_stmt|;
comment|/* Wait for it */
while|while
condition|(
name|x
operator|!=
name|t
condition|)
block|{
if|if
condition|(
operator|(
name|x
operator|=
name|ttinc
argument_list|(
literal|1
argument_list|)
operator|)
operator|<
literal|0
condition|)
break|break;
if|if
condition|(
name|xmitx
operator|&&
operator|!
name|duplex
condition|)
block|{
comment|/* Echo any echoes */
if|if
condition|(
name|parity
condition|)
name|x
operator|&=
literal|0x7f
expr_stmt|;
ifndef|#
directive|ifndef
name|NOCSETS
if|if
condition|(
name|sxi
condition|)
name|x
operator|=
call|(
modifier|*
name|sxi
call|)
argument_list|(
operator|(
name|CHAR
operator|)
name|x
argument_list|)
expr_stmt|;
comment|/* But translate */
if|if
condition|(
name|rxi
condition|)
name|x
operator|=
call|(
modifier|*
name|rxi
call|)
argument_list|(
operator|(
name|CHAR
operator|)
name|x
argument_list|)
expr_stmt|;
comment|/* them first... */
endif|#
directive|endif
comment|/* NOCSETS */
name|conoc
argument_list|(
operator|(
name|char
operator|)
name|x
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|xmitx
operator|&&
operator|!
name|duplex
condition|)
block|{
comment|/* Otherwise, */
while|while
condition|(
name|ttchk
argument_list|()
operator|>
literal|0
condition|)
block|{
comment|/* echo for as long as */
if|if
condition|(
operator|(
name|x
operator|=
name|ttinc
argument_list|(
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
break|break;
comment|/* anything is there. */
if|if
condition|(
name|parity
condition|)
name|x
operator|&=
literal|0x7f
expr_stmt|;
ifndef|#
directive|ifndef
name|NOCSETS
if|if
condition|(
name|sxi
condition|)
name|x
operator|=
call|(
modifier|*
name|sxi
call|)
argument_list|(
operator|(
name|CHAR
operator|)
name|x
argument_list|)
expr_stmt|;
comment|/* Translate first */
if|if
condition|(
name|rxi
condition|)
name|x
operator|=
call|(
modifier|*
name|rxi
call|)
argument_list|(
operator|(
name|CHAR
operator|)
name|x
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* NOCSETS */
name|conoc
argument_list|(
operator|(
name|char
operator|)
name|x
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|ttflui
argument_list|()
expr_stmt|;
comment|/* Otherwise just flush input buffer */
block|}
comment|/* End of buffer-dumping block */
block|}
comment|/* End of text mode */
block|}
comment|/* End of character-reading loop */
if|if
condition|(
operator|*
name|xmitbuf
condition|)
block|{
comment|/* Anything to send at EOF? */
name|p
operator|=
name|xmitbuf
expr_stmt|;
comment|/* Yes, point to string. */
while|while
condition|(
operator|*
name|p
condition|)
comment|/* Send it. */
name|ttoc
argument_list|(
name|dopar
argument_list|(
operator|*
name|p
operator|++
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Don't worry about echo here. */
block|}
ifndef|#
directive|ifndef
name|AMIGA
ifndef|#
directive|ifndef
name|MAC
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|oldsig
argument_list|)
expr_stmt|;
comment|/* Put old signal action back. */
endif|#
directive|endif
comment|/* MAC */
endif|#
directive|endif
comment|/* AMIGA */
ifdef|#
directive|ifdef
name|VMS
name|concb
argument_list|(
name|escape
argument_list|)
expr_stmt|;
comment|/* Put terminal back, */
endif|#
directive|endif
comment|/* VMS */
name|zclose
argument_list|(
name|ZIFILE
argument_list|)
expr_stmt|;
comment|/* Close file, */
ifndef|#
directive|ifndef
name|NOCSETS
name|language
operator|=
name|langsv
expr_stmt|;
comment|/* restore language, */
endif|#
directive|endif
comment|/* NOCSETS */
return|return
operator|(
name|z
operator|)
return|;
comment|/* and return successfully. */
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NOXMIT */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|MAC
end_ifdef

begin_comment
comment|/*   This code is not used any more, except on the Macintosh.  Instead we call   system to do the typing.  Revive this code if your system can't be called   to do this. */
end_comment

begin_comment
comment|/*  D O T Y P E  --  Type a file  */
end_comment

begin_function
name|int
name|dotype
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|MAC
specifier|extern
name|char
name|sstate
decl_stmt|;
name|int
name|count
init|=
literal|100
decl_stmt|;
else|#
directive|else
name|SIGTYP
function_decl|(
modifier|*
name|oldsig
function_decl|)
parameter_list|()
function_decl|;
comment|/* For saving old interrupt trap. */
endif|#
directive|endif
comment|/* MAC */
name|int
name|z
decl_stmt|;
comment|/* Return code. */
name|int
name|c
decl_stmt|;
comment|/* Worker. */
if|if
condition|(
name|zopeni
argument_list|(
name|ZIFILE
argument_list|,
name|s
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Open the file to be typed */
name|printf
argument_list|(
literal|"?Can't open %s\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
ifndef|#
directive|ifndef
name|AMIGA
ifndef|#
directive|ifndef
name|MAC
name|oldsig
operator|=
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|trtrap
argument_list|)
expr_stmt|;
comment|/* Save current interrupt trap. */
endif|#
directive|endif
comment|/* MAC */
endif|#
directive|endif
comment|/* AMIGA */
name|tr_int
operator|=
literal|0
expr_stmt|;
comment|/* Have not been interrupted (yet). */
name|z
operator|=
literal|1
expr_stmt|;
comment|/* Return code presumed good. */
ifdef|#
directive|ifdef
name|VMS
name|conoc
argument_list|(
name|CR
argument_list|)
expr_stmt|;
comment|/* On VMS, display blank line first */
name|conoc
argument_list|(
name|LF
argument_list|)
expr_stmt|;
name|conres
argument_list|()
expr_stmt|;
comment|/* So Ctrl-C/Y will work */
endif|#
directive|endif
comment|/* VMS */
while|while
condition|(
operator|(
name|c
operator|=
name|zminchar
argument_list|()
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* Loop for all characters in file */
ifdef|#
directive|ifdef
name|MAC
comment|/* 	 * It is expensive to run the miniparser so don't do it for 	 * every character. 	 */
if|if
condition|(
operator|--
name|count
operator|<
literal|0
condition|)
block|{
name|count
operator|=
literal|100
expr_stmt|;
name|miniparser
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|sstate
operator|==
literal|'a'
condition|)
block|{
name|sstate
operator|=
literal|'\0'
expr_stmt|;
name|z
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
name|putchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* Not MAC */
if|if
condition|(
name|tr_int
condition|)
block|{
comment|/* Interrupted? */
name|printf
argument_list|(
literal|"^C...\n"
argument_list|)
expr_stmt|;
comment|/* Print message */
name|z
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|conoc
argument_list|(
name|c
argument_list|)
expr_stmt|;
comment|/* Echo character on screen */
endif|#
directive|endif
comment|/* MAC */
block|}
ifndef|#
directive|ifndef
name|AMIGA
ifndef|#
directive|ifndef
name|MAC
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|oldsig
argument_list|)
expr_stmt|;
comment|/* put old signal action back. */
endif|#
directive|endif
comment|/* MAC */
endif|#
directive|endif
comment|/* AMIGA */
name|tr_int
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|VMS
name|concb
argument_list|(
name|escape
argument_list|)
expr_stmt|;
comment|/* Get back in command-parsing mode, */
endif|#
directive|endif
comment|/* VMS */
name|zclose
argument_list|(
name|ZIFILE
argument_list|)
expr_stmt|;
comment|/* close file, */
return|return
operator|(
name|z
operator|)
return|;
comment|/* and return successfully. */
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MAC */
end_comment

begin_escape
end_escape

begin_ifndef
ifndef|#
directive|ifndef
name|NOCSETS
end_ifndef

begin_expr_stmt
name|_PROTOTYP
argument_list|(
name|CHAR
argument_list|(
operator|*
name|sxx
argument_list|)
argument_list|,
operator|(
name|CHAR
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Local translation function */
end_comment

begin_expr_stmt
name|_PROTOTYP
argument_list|(
name|CHAR
argument_list|(
operator|*
name|rxx
argument_list|)
argument_list|,
operator|(
name|CHAR
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Local translation function */
end_comment

begin_macro
name|_PROTOTYP
argument_list|(
argument|CHAR zl1as
argument_list|,
argument|(CHAR)
argument_list|)
end_macro

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/* Latin-1 to ascii */
end_comment

begin_macro
name|_PROTOTYP
argument_list|(
argument|CHAR xl1as
argument_list|,
argument|(CHAR)
argument_list|)
end_macro

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/* ditto */
end_comment

begin_comment
comment|/*  X L A T E  --  Translate a local file from one character set to another */
end_comment

begin_comment
comment|/*   Translates input file (fin) from character set csin to character set csout   and puts the result in the output file (fout).  The two character sets are   file character sets from fcstab. */
end_comment

begin_function
name|int
name|xlate
parameter_list|(
name|fin
parameter_list|,
name|fout
parameter_list|,
name|csin
parameter_list|,
name|csout
parameter_list|)
name|char
modifier|*
name|fin
decl_stmt|,
decl|*
name|fout
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|csin
decl_stmt|,
name|csout
decl_stmt|;
end_decl_stmt

begin_block
block|{
ifndef|#
directive|ifndef
name|MAC
name|SIGTYP
function_decl|(
modifier|*
name|oldsig
function_decl|)
parameter_list|()
function_decl|;
comment|/* For saving old interrupt trap. */
endif|#
directive|endif
comment|/* MAC */
name|int
name|filecode
decl_stmt|;
comment|/* Code for output file */
name|int
name|z
init|=
literal|1
decl_stmt|;
comment|/* Return code. */
name|int
name|c
decl_stmt|,
name|tcs
decl_stmt|;
comment|/* Workers */
if|if
condition|(
name|zopeni
argument_list|(
name|ZIFILE
argument_list|,
name|fin
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Open the file to be translated */
name|printf
argument_list|(
literal|"?Can't open input file %s\n"
argument_list|,
name|fin
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|MAC
comment|/*   If user specified no output file, it goes to the screen.  For the Mac,   this must be done a special way (result goes to a new window); the Mac   doesn't have a "controlling terminal" device name. */
name|filecode
operator|=
operator|!
name|strcmp
argument_list|(
name|fout
argument_list|,
name|CTTNAM
argument_list|)
condition|?
name|ZCTERM
else|:
name|ZOFILE
expr_stmt|;
else|#
directive|else
name|filecode
operator|=
name|ZOFILE
expr_stmt|;
endif|#
directive|endif
comment|/* MAC */
if|if
condition|(
name|zopeno
argument_list|(
name|filecode
argument_list|,
name|fout
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* And the output file */
name|printf
argument_list|(
literal|"?Can't open output file %s\n"
argument_list|,
name|fout
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
ifndef|#
directive|ifndef
name|AMIGA
ifndef|#
directive|ifndef
name|MAC
name|oldsig
operator|=
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|trtrap
argument_list|)
expr_stmt|;
comment|/* Save current interrupt trap. */
endif|#
directive|endif
comment|/* MAC */
endif|#
directive|endif
comment|/* AMIGA */
name|tr_int
operator|=
literal|0
expr_stmt|;
comment|/* Have not been interrupted (yet). */
name|z
operator|=
literal|1
expr_stmt|;
comment|/* Return code presumed good. */
name|tcs
operator|=
name|gettcs
argument_list|(
name|csin
argument_list|,
name|csout
argument_list|)
expr_stmt|;
comment|/* Get intermediate set. */
name|printf
argument_list|(
literal|"%s (%s) => %s (%s)\n"
argument_list|,
comment|/* Say what we're doing. */
name|fin
argument_list|,
name|fcsinfo
index|[
name|csin
index|]
operator|.
name|name
argument_list|,
name|fout
argument_list|,
name|fcsinfo
index|[
name|csout
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"via %s"
argument_list|,
name|tcsinfo
index|[
name|tcs
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|language
condition|)
name|printf
argument_list|(
literal|", language: %s\n"
argument_list|,
name|langs
index|[
name|language
index|]
operator|.
name|description
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|csin
operator|==
name|csout
condition|)
block|{
comment|/* Input and output sets the same? */
name|sxx
operator|=
name|rxx
operator|=
name|NULL
expr_stmt|;
comment|/* If so, no translation. */
block|}
else|else
block|{
comment|/* Otherwise, set up */
name|sxx
operator|=
name|xls
index|[
name|tcs
index|]
index|[
name|csin
index|]
expr_stmt|;
comment|/* translation function */
name|rxx
operator|=
name|xlr
index|[
name|tcs
index|]
index|[
name|csout
index|]
expr_stmt|;
comment|/* pointers. */
if|if
condition|(
name|rxx
operator|==
name|zl1as
condition|)
name|rxx
operator|=
name|xl1as
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|c
operator|=
name|zminchar
argument_list|()
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* Loop for all characters in file */
if|if
condition|(
name|tr_int
condition|)
block|{
comment|/* Interrupted? */
name|printf
argument_list|(
literal|"^C...\n"
argument_list|)
expr_stmt|;
comment|/* Print message */
name|z
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|sxx
condition|)
name|c
operator|=
call|(
modifier|*
name|sxx
call|)
argument_list|(
operator|(
name|CHAR
operator|)
name|c
argument_list|)
expr_stmt|;
comment|/* From fcs1 to tcs */
if|if
condition|(
name|rxx
condition|)
name|c
operator|=
call|(
modifier|*
name|rxx
call|)
argument_list|(
operator|(
name|CHAR
operator|)
name|c
argument_list|)
expr_stmt|;
comment|/* from tcs to fcs2 */
if|if
condition|(
name|zchout
argument_list|(
name|ZOFILE
argument_list|,
operator|(
name|char
operator|)
name|c
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* Output the translated character */
name|printf
argument_list|(
literal|"File output error\n"
argument_list|)
expr_stmt|;
name|z
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
ifndef|#
directive|ifndef
name|AMIGA
ifndef|#
directive|ifndef
name|MAC
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|oldsig
argument_list|)
expr_stmt|;
comment|/* put old signal action back. */
endif|#
directive|endif
comment|/* MAC */
endif|#
directive|endif
comment|/* AMIGA */
name|tr_int
operator|=
literal|0
expr_stmt|;
name|zclose
argument_list|(
name|ZIFILE
argument_list|)
expr_stmt|;
comment|/* close files, */
name|zclose
argument_list|(
name|ZOFILE
argument_list|)
expr_stmt|;
return|return
operator|(
name|z
operator|)
return|;
comment|/* and return successfully. */
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NOCSETS */
end_comment

begin_escape
end_escape

begin_comment
comment|/*  D O L O G  --  Do the log command  */
end_comment

begin_function
name|int
name|dolog
parameter_list|(
name|x
parameter_list|)
name|int
name|x
decl_stmt|;
block|{
name|int
name|y
decl_stmt|,
name|disp
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
switch|switch
condition|(
name|x
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
case|case
name|LOGD
case|:
name|y
operator|=
name|cmofi
argument_list|(
literal|"Name of debugging log file"
argument_list|,
literal|"debug.log"
argument_list|,
operator|&
name|s
argument_list|,
name|xxstring
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* DEBUG */
case|case
name|LOGP
case|:
name|y
operator|=
name|cmofi
argument_list|(
literal|"Name of packet log file"
argument_list|,
literal|"packet.log"
argument_list|,
operator|&
name|s
argument_list|,
name|xxstring
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOGS
case|:
name|y
operator|=
name|cmofi
argument_list|(
literal|"Name of session log file"
argument_list|,
literal|"session.log"
argument_list|,
operator|&
name|s
argument_list|,
name|xxstring
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|TLOG
case|case
name|LOGT
case|:
name|y
operator|=
name|cmofi
argument_list|(
literal|"Name of transaction log file"
argument_list|,
literal|"transact.log"
argument_list|,
operator|&
name|s
argument_list|,
name|xxstring
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* TLOG */
default|default:
name|printf
argument_list|(
literal|"\n?Unknown log designator - %d\n"
argument_list|,
name|x
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
if|if
condition|(
name|y
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
name|strcpy
argument_list|(
name|line
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|s
operator|=
name|line
expr_stmt|;
if|if
condition|(
operator|(
name|y
operator|=
name|cmkey
argument_list|(
name|disptb
argument_list|,
literal|2
argument_list|,
literal|"Disposition"
argument_list|,
literal|"new"
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
name|disp
operator|=
name|y
expr_stmt|;
if|if
condition|(
operator|(
name|y
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
switch|switch
condition|(
name|x
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
case|case
name|LOGD
case|:
return|return
operator|(
name|deblog
operator|=
name|debopn
argument_list|(
name|s
argument_list|,
name|disp
argument_list|)
operator|)
return|;
endif|#
directive|endif
comment|/* DEBUG */
case|case
name|LOGP
case|:
return|return
operator|(
name|pktlog
operator|=
name|pktopn
argument_list|(
name|s
argument_list|,
name|disp
argument_list|)
operator|)
return|;
case|case
name|LOGS
case|:
return|return
operator|(
name|seslog
operator|=
name|sesopn
argument_list|(
name|s
argument_list|,
name|disp
argument_list|)
operator|)
return|;
ifdef|#
directive|ifdef
name|TLOG
case|case
name|LOGT
case|:
return|return
operator|(
name|tralog
operator|=
name|traopn
argument_list|(
name|s
argument_list|,
name|disp
argument_list|)
operator|)
return|;
endif|#
directive|endif
comment|/* TLOG */
default|default:
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
block|}
end_function

begin_function
name|int
name|pktopn
parameter_list|(
name|s
parameter_list|,
name|disp
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|disp
decl_stmt|;
block|{
specifier|extern
name|char
name|pktfil
index|[]
decl_stmt|;
specifier|static
name|struct
name|filinfo
name|xx
decl_stmt|;
name|int
name|y
decl_stmt|;
name|zclose
argument_list|(
name|ZPFILE
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|disp
condition|)
block|{
name|xx
operator|.
name|bs
operator|=
literal|0
expr_stmt|;
name|xx
operator|.
name|cs
operator|=
literal|0
expr_stmt|;
name|xx
operator|.
name|rl
operator|=
literal|0
expr_stmt|;
name|xx
operator|.
name|org
operator|=
literal|0
expr_stmt|;
name|xx
operator|.
name|cc
operator|=
literal|0
expr_stmt|;
name|xx
operator|.
name|typ
operator|=
literal|0
expr_stmt|;
name|xx
operator|.
name|dsp
operator|=
name|XYFZ_A
expr_stmt|;
name|xx
operator|.
name|os_specific
operator|=
literal|'\0'
expr_stmt|;
name|xx
operator|.
name|lblopts
operator|=
literal|0
expr_stmt|;
name|y
operator|=
name|zopeno
argument_list|(
name|ZPFILE
argument_list|,
name|s
argument_list|,
name|NULL
argument_list|,
operator|&
name|xx
argument_list|)
expr_stmt|;
block|}
else|else
name|y
operator|=
name|zopeno
argument_list|(
name|ZPFILE
argument_list|,
name|s
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|y
operator|>
literal|0
condition|)
name|strcpy
argument_list|(
name|pktfil
argument_list|,
name|s
argument_list|)
expr_stmt|;
else|else
operator|*
name|pktfil
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|y
operator|)
return|;
block|}
end_function

begin_function
name|int
name|traopn
parameter_list|(
name|s
parameter_list|,
name|disp
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|disp
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|TLOG
specifier|extern
name|char
name|trafil
index|[]
decl_stmt|;
specifier|static
name|struct
name|filinfo
name|xx
decl_stmt|;
name|int
name|y
decl_stmt|;
name|zclose
argument_list|(
name|ZTFILE
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|disp
condition|)
block|{
name|xx
operator|.
name|bs
operator|=
literal|0
expr_stmt|;
name|xx
operator|.
name|cs
operator|=
literal|0
expr_stmt|;
name|xx
operator|.
name|rl
operator|=
literal|0
expr_stmt|;
name|xx
operator|.
name|org
operator|=
literal|0
expr_stmt|;
name|xx
operator|.
name|cc
operator|=
literal|0
expr_stmt|;
name|xx
operator|.
name|typ
operator|=
literal|0
expr_stmt|;
name|xx
operator|.
name|dsp
operator|=
name|XYFZ_A
expr_stmt|;
name|xx
operator|.
name|os_specific
operator|=
literal|'\0'
expr_stmt|;
name|xx
operator|.
name|lblopts
operator|=
literal|0
expr_stmt|;
name|y
operator|=
name|zopeno
argument_list|(
name|ZTFILE
argument_list|,
name|s
argument_list|,
name|NULL
argument_list|,
operator|&
name|xx
argument_list|)
expr_stmt|;
block|}
else|else
name|y
operator|=
name|zopeno
argument_list|(
name|ZTFILE
argument_list|,
name|s
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|y
operator|>
literal|0
condition|)
block|{
name|strcpy
argument_list|(
name|trafil
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|tlog
argument_list|(
name|F110
argument_list|,
literal|"Transaction Log:"
argument_list|,
name|versio
argument_list|,
literal|0L
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|MAC
name|tlog
argument_list|(
name|F100
argument_list|,
name|ckxsys
argument_list|,
literal|""
argument_list|,
literal|0L
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MAC */
name|ztime
argument_list|(
operator|&
name|s
argument_list|)
expr_stmt|;
name|tlog
argument_list|(
name|F100
argument_list|,
name|s
argument_list|,
literal|""
argument_list|,
literal|0L
argument_list|)
expr_stmt|;
block|}
else|else
operator|*
name|trafil
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|y
operator|)
return|;
else|#
directive|else
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|int
name|sesopn
parameter_list|(
name|s
parameter_list|,
name|disp
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|disp
decl_stmt|;
block|{
specifier|extern
name|char
name|sesfil
index|[]
decl_stmt|;
specifier|static
name|struct
name|filinfo
name|xx
decl_stmt|;
name|int
name|y
decl_stmt|;
name|zclose
argument_list|(
name|ZSFILE
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|disp
condition|)
block|{
name|xx
operator|.
name|bs
operator|=
literal|0
expr_stmt|;
name|xx
operator|.
name|cs
operator|=
literal|0
expr_stmt|;
name|xx
operator|.
name|rl
operator|=
literal|0
expr_stmt|;
name|xx
operator|.
name|org
operator|=
literal|0
expr_stmt|;
name|xx
operator|.
name|cc
operator|=
literal|0
expr_stmt|;
name|xx
operator|.
name|typ
operator|=
literal|0
expr_stmt|;
name|xx
operator|.
name|dsp
operator|=
name|XYFZ_A
expr_stmt|;
name|xx
operator|.
name|os_specific
operator|=
literal|'\0'
expr_stmt|;
name|xx
operator|.
name|lblopts
operator|=
literal|0
expr_stmt|;
name|y
operator|=
name|zopeno
argument_list|(
name|ZSFILE
argument_list|,
name|s
argument_list|,
name|NULL
argument_list|,
operator|&
name|xx
argument_list|)
expr_stmt|;
block|}
else|else
name|y
operator|=
name|zopeno
argument_list|(
name|ZSFILE
argument_list|,
name|s
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|y
operator|>
literal|0
condition|)
name|strcpy
argument_list|(
name|sesfil
argument_list|,
name|s
argument_list|)
expr_stmt|;
else|else
operator|*
name|sesfil
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|y
operator|)
return|;
block|}
end_function

begin_function
name|int
name|debopn
parameter_list|(
name|s
parameter_list|,
name|disp
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|disp
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|char
modifier|*
name|tp
decl_stmt|;
specifier|static
name|struct
name|filinfo
name|xx
decl_stmt|;
name|zclose
argument_list|(
name|ZDFILE
argument_list|)
expr_stmt|;
if|if
condition|(
name|disp
condition|)
block|{
name|xx
operator|.
name|bs
operator|=
literal|0
expr_stmt|;
name|xx
operator|.
name|cs
operator|=
literal|0
expr_stmt|;
name|xx
operator|.
name|rl
operator|=
literal|0
expr_stmt|;
name|xx
operator|.
name|org
operator|=
literal|0
expr_stmt|;
name|xx
operator|.
name|cc
operator|=
literal|0
expr_stmt|;
name|xx
operator|.
name|typ
operator|=
literal|0
expr_stmt|;
name|xx
operator|.
name|dsp
operator|=
name|XYFZ_A
expr_stmt|;
name|xx
operator|.
name|os_specific
operator|=
literal|'\0'
expr_stmt|;
name|xx
operator|.
name|lblopts
operator|=
literal|0
expr_stmt|;
name|deblog
operator|=
name|zopeno
argument_list|(
name|ZDFILE
argument_list|,
name|s
argument_list|,
name|NULL
argument_list|,
operator|&
name|xx
argument_list|)
expr_stmt|;
block|}
else|else
name|deblog
operator|=
name|zopeno
argument_list|(
name|ZDFILE
argument_list|,
name|s
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|deblog
operator|>
literal|0
condition|)
block|{
name|strcpy
argument_list|(
name|debfil
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F110
argument_list|,
literal|"Debug Log "
argument_list|,
name|versio
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|MAC
name|debug
argument_list|(
name|F100
argument_list|,
name|ckxsys
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MAC */
name|ztime
argument_list|(
operator|&
name|tp
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F100
argument_list|,
name|tp
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
operator|*
name|debfil
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|deblog
operator|)
return|;
else|#
directive|else
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|NOSHOW
end_ifndef

begin_comment
comment|/*  S H O P A R  --  Show Parameters  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SUNX25
end_ifdef

begin_function
name|VOID
name|shox25
parameter_list|()
block|{
if|if
condition|(
name|nettype
operator|==
name|NET_SX25
condition|)
block|{
name|printf
argument_list|(
literal|"SunLink X.25 V%d.%d"
argument_list|,
name|x25ver
operator|/
literal|10
argument_list|,
name|x25ver
operator|%
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|ttnproto
operator|==
name|NP_X3
condition|)
name|printf
argument_list|(
literal|", PAD X.3, X.28, X.29 protocol,"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n Reverse charge call %s"
argument_list|,
name|revcall
condition|?
literal|"selected"
else|:
literal|"not selected"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|", Closed user group "
argument_list|)
expr_stmt|;
if|if
condition|(
name|closgr
operator|>
operator|-
literal|1
condition|)
name|printf
argument_list|(
literal|"%d"
argument_list|,
name|closgr
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"not selected"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|","
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n Call user data %s.\n"
argument_list|,
name|cudata
condition|?
name|udata
else|:
literal|"not selected"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SUNX25 */
end_comment

begin_function
name|VOID
name|shoparc
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|long
name|zz
decl_stmt|;
name|puts
argument_list|(
literal|"Communications Parameters:"
argument_list|)
expr_stmt|;
if|if
condition|(
name|network
condition|)
block|{
name|printf
argument_list|(
literal|" Host: %s"
argument_list|,
name|ttname
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|" Line: %s, speed: "
argument_list|,
name|ttname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|zz
operator|=
name|ttgspd
argument_list|()
operator|)
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"unknown"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|speed
operator|==
literal|8880
condition|)
name|printf
argument_list|(
literal|"75/1200"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%ld"
argument_list|,
name|zz
argument_list|)
expr_stmt|;
block|}
block|}
name|printf
argument_list|(
literal|", mode: "
argument_list|)
expr_stmt|;
if|if
condition|(
name|local
condition|)
name|printf
argument_list|(
literal|"local"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"remote"
argument_list|)
expr_stmt|;
if|if
condition|(
name|network
operator|==
literal|0
condition|)
block|{
ifndef|#
directive|ifndef
name|NODIAL
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nmdm
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|mdmtab
index|[
name|i
index|]
operator|.
name|kwval
operator|==
name|mdmtyp
condition|)
block|{
name|printf
argument_list|(
literal|", modem: %s"
argument_list|,
name|mdmtab
index|[
name|i
index|]
operator|.
name|kwd
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
endif|#
directive|endif
comment|/* NODIAL */
block|}
else|else
block|{
if|if
condition|(
name|nettype
operator|==
name|NET_TCPA
condition|)
name|printf
argument_list|(
literal|", TCP/IP"
argument_list|)
expr_stmt|;
if|if
condition|(
name|nettype
operator|==
name|NET_TCPB
condition|)
name|printf
argument_list|(
literal|", TCP/IP"
argument_list|)
expr_stmt|;
if|if
condition|(
name|nettype
operator|==
name|NET_DEC
condition|)
block|{
if|if
condition|(
name|ttnproto
operator|==
name|NP_LAT
condition|)
name|printf
argument_list|(
literal|", DECnet LAT"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ttnproto
operator|==
name|NP_CTERM
condition|)
name|printf
argument_list|(
literal|", DECnet CTERM"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|", DECnet"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nettype
operator|==
name|NET_PIPE
condition|)
name|printf
argument_list|(
literal|", Named Pipe"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SUNX25
name|shox25
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* SUNX25 */
if|if
condition|(
name|ttnproto
operator|==
name|NP_TELNET
condition|)
name|printf
argument_list|(
literal|", telnet protocol"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|local
condition|)
block|{
name|i
operator|=
name|parity
condition|?
literal|7
else|:
literal|8
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|8
condition|)
name|i
operator|=
operator|(
name|cmask
operator|==
literal|0177
operator|)
condition|?
literal|7
else|:
literal|8
expr_stmt|;
name|printf
argument_list|(
literal|"\n Terminal bits: %d, p"
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"\n P"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"arity: %s"
argument_list|,
name|parnam
argument_list|(
operator|(
name|char
operator|)
name|parity
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|", duplex: "
argument_list|)
expr_stmt|;
if|if
condition|(
name|duplex
condition|)
name|printf
argument_list|(
literal|"half, "
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"full, "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"flow: "
argument_list|)
expr_stmt|;
if|if
condition|(
name|flow
operator|==
name|FLO_KEEP
condition|)
name|printf
argument_list|(
literal|"keep"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|flow
operator|==
name|FLO_XONX
condition|)
name|printf
argument_list|(
literal|"xon/xoff"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|flow
operator|==
name|FLO_NONE
condition|)
name|printf
argument_list|(
literal|"none"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|flow
operator|==
name|FLO_DTRT
condition|)
name|printf
argument_list|(
literal|"dtr/cts"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|flow
operator|==
name|FLO_RTSC
condition|)
name|printf
argument_list|(
literal|"rts/cts"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|flow
operator|==
name|FLO_DTRC
condition|)
name|printf
argument_list|(
literal|"dtr/cd"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%d"
argument_list|,
name|flow
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|", handshake: "
argument_list|)
expr_stmt|;
if|if
condition|(
name|turn
condition|)
name|printf
argument_list|(
literal|"%d\n"
argument_list|,
name|turnch
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"none\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|local
operator|&&
operator|!
name|network
condition|)
block|{
comment|/* Lockfile& carrier stuff */
if|if
condition|(
name|carrier
operator|==
name|CAR_OFF
condition|)
name|s
operator|=
literal|"off"
expr_stmt|;
elseif|else
if|if
condition|(
name|carrier
operator|==
name|CAR_ON
condition|)
name|s
operator|=
literal|"on"
expr_stmt|;
elseif|else
if|if
condition|(
name|carrier
operator|==
name|CAR_AUT
condition|)
name|s
operator|=
literal|"auto"
expr_stmt|;
else|else
name|s
operator|=
literal|"unknown"
expr_stmt|;
name|printf
argument_list|(
literal|" Carrier: %s"
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|carrier
operator|==
name|CAR_ON
condition|)
block|{
if|if
condition|(
name|cdtimo
condition|)
name|printf
argument_list|(
literal|", timeout: %d sec"
argument_list|,
name|cdtimo
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|", timeout: none"
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|UNIX
if|if
condition|(
name|haslock
operator|&&
operator|*
name|flfnam
condition|)
block|{
comment|/* Lockfiles only apply to UNIX... */
name|printf
argument_list|(
literal|", lockfile: %s"
argument_list|,
name|flfnam
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* UNIX */
name|printf
argument_list|(
literal|"\n Escape character: %d (^%c)\n"
argument_list|,
name|escape
argument_list|,
name|ctl
argument_list|(
name|escape
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|TNCODE
end_ifdef

begin_function
specifier|static
name|VOID
name|shotel
parameter_list|()
block|{
name|printf
argument_list|(
literal|"SET TELNET parameters:\n echo: %s\n newline-mode: %s\n"
argument_list|,
name|tn_duplex
condition|?
literal|"local"
else|:
literal|"remote"
argument_list|,
name|tn_nlm
condition|?
literal|"on"
else|:
literal|"off"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" terminal-type: "
argument_list|)
expr_stmt|;
if|if
condition|(
name|tn_term
condition|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|tn_term
argument_list|)
expr_stmt|;
else|else
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|getenv
argument_list|(
literal|"TERM"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
name|printf
argument_list|(
literal|"none (%s will be used)\n"
argument_list|,
name|p
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"none\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TNCODE */
end_comment

begin_function
name|VOID
name|shonet
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|NETCONN
name|printf
argument_list|(
literal|"\nNo networks are supported in this version of C-Kermit\n"
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
literal|"\nSupported networks:\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|VMS
ifdef|#
directive|ifdef
name|MULTINET
name|printf
argument_list|(
literal|" TGV MultiNet TCP/IP"
argument_list|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|WINTCP
name|printf
argument_list|(
literal|" WOLLONGONG WIN/TCP"
argument_list|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|DEC_TCPIP
name|printf
argument_list|(
literal|" DEC TCP/IP Services for (Open)VMS"
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
literal|" None"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEC_TCPIP */
endif|#
directive|endif
comment|/* WINTCP */
endif|#
directive|endif
comment|/* MULTINET */
ifdef|#
directive|ifdef
name|TNCODE
name|printf
argument_list|(
literal|", TELNET protocol\n\n"
argument_list|)
expr_stmt|;
name|shotel
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* TNCODE */
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* Not VMS */
ifdef|#
directive|ifdef
name|SUNX25
name|printf
argument_list|(
literal|" SunLink X.25\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SUNX25 */
ifdef|#
directive|ifdef
name|DECNET
name|printf
argument_list|(
literal|" DECnet\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DECNET */
ifdef|#
directive|ifdef
name|NPIPE
name|printf
argument_list|(
literal|" LAN Manager Named Pipe\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DECNET */
ifdef|#
directive|ifdef
name|TCPSOCKET
name|printf
argument_list|(
literal|" TCP/IP"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TNCODE
name|printf
argument_list|(
literal|", TELNET protocol\n\n"
argument_list|)
expr_stmt|;
name|shotel
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* TNCODE */
endif|#
directive|endif
comment|/* TCPSOCKET */
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* VMS */
name|printf
argument_list|(
literal|"Current network type:\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|nettype
operator|==
name|NET_TCPA
operator|||
name|nettype
operator|==
name|NET_TCPB
condition|)
name|printf
argument_list|(
literal|" TCP/IP\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SUNX25
elseif|else
if|if
condition|(
name|nettype
operator|==
name|NET_SX25
condition|)
name|printf
argument_list|(
literal|" X.25\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SUNX25 */
ifdef|#
directive|ifdef
name|DECNET
elseif|else
if|if
condition|(
name|nettype
operator|==
name|NET_DEC
condition|)
name|printf
argument_list|(
literal|" DECnet\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DECNET */
name|printf
argument_list|(
literal|"\nActive SET HOST connection:\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|network
condition|)
block|{
name|printf
argument_list|(
literal|" %s"
argument_list|,
name|ttname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ipaddr
condition|)
name|printf
argument_list|(
literal|" [%s]"
argument_list|,
name|ipaddr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n Via: "
argument_list|)
expr_stmt|;
if|if
condition|(
name|nettype
operator|==
name|NET_TCPA
operator|||
name|nettype
operator|==
name|NET_TCPB
condition|)
name|printf
argument_list|(
literal|"TCP/IP\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|nettype
operator|==
name|NET_SX25
condition|)
name|printf
argument_list|(
literal|"SunLink X.25\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|nettype
operator|==
name|NET_DEC
condition|)
block|{
if|if
condition|(
name|ttnproto
operator|==
name|NP_LAT
condition|)
name|printf
argument_list|(
literal|"DECnet LAT\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ttnproto
operator|==
name|NP_CTERM
condition|)
name|printf
argument_list|(
literal|"DECnet CTERM\n"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"DECnet\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nettype
operator|==
name|NET_PIPE
condition|)
name|printf
argument_list|(
literal|"LAN Manager Named Pipe\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SUNX25
if|if
condition|(
name|nettype
operator|==
name|NET_SX25
condition|)
name|shox25
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* SUNX25 */
ifdef|#
directive|ifdef
name|TNCODE
if|if
condition|(
name|ttnproto
operator|==
name|NP_TELNET
condition|)
block|{
name|printf
argument_list|(
literal|" TELNET protocol\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" Echoing is currently %s\n"
argument_list|,
name|duplex
condition|?
literal|"local"
else|:
literal|"remote"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* TNCODE */
block|}
else|else
name|printf
argument_list|(
literal|" None\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* NETCONN */
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|NODIAL
end_ifndef

begin_function
name|VOID
name|shodial
parameter_list|()
block|{
if|if
condition|(
name|mdmtyp
operator|>=
literal|0
operator|||
name|local
operator|!=
literal|0
condition|)
name|doshodial
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|VOID
name|shods
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
comment|/* Show a dial-related string */
name|char
name|c
decl_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
operator|(
operator|*
name|s
operator|)
condition|)
block|{
comment|/* Empty? */
name|printf
argument_list|(
literal|"(none)\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Not empty. */
while|while
condition|(
name|c
operator|=
operator|*
name|s
operator|++
condition|)
comment|/* Can contain controls */
if|if
condition|(
name|c
operator|>
literal|31
operator|&&
name|c
operator|<
literal|127
condition|)
block|{
name|putchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
comment|/* so display them */
else|else
name|printf
argument_list|(
literal|"\\{%d}"
argument_list|,
name|c
argument_list|)
expr_stmt|;
comment|/* in backslash notation */
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|doshodial
parameter_list|()
block|{
name|printf
argument_list|(
literal|" Dial directory: %s\n"
argument_list|,
name|dialdir
condition|?
name|dialdir
else|:
literal|"(none)"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" Dial hangup: %s, dial modem-hangup: %s\n"
argument_list|,
name|dialhng
condition|?
literal|"on"
else|:
literal|"off"
argument_list|,
name|dialmhu
condition|?
literal|"on"
else|:
literal|"off"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" Dial kermit-spoof: %s"
argument_list|,
name|dialksp
condition|?
literal|"on"
else|:
literal|"off"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|", dial display: %s\n"
argument_list|,
name|dialdpy
condition|?
literal|"on"
else|:
literal|"off"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" Dial speed-matching: %s"
argument_list|,
name|mdmspd
condition|?
literal|"on"
else|:
literal|"off"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|", dial mnp-enable: %s\n"
argument_list|,
name|dialmnp
condition|?
literal|"on"
else|:
literal|"off"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" Dial init-string: "
argument_list|)
expr_stmt|;
name|shods
argument_list|(
name|getdws
argument_list|(
name|mdmtyp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Ask dial module for it */
name|printf
argument_list|(
literal|" Dial dial-command: "
argument_list|)
expr_stmt|;
name|shods
argument_list|(
name|getdcs
argument_list|(
name|mdmtyp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Ask dial module for it */
name|printf
argument_list|(
literal|" Dial prefix: "
argument_list|)
expr_stmt|;
name|shods
argument_list|(
name|dialnpr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" Dial timeout: "
argument_list|)
expr_stmt|;
if|if
condition|(
name|dialtmo
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|"%d sec"
argument_list|,
name|dialtmo
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"0 (auto)"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|", Redial number: %s\n"
argument_list|,
name|dialnum
condition|?
name|dialnum
else|:
literal|"(none)"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NODIAL */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SUNX25
end_ifdef

begin_function
name|VOID
name|shopad
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
name|printf
argument_list|(
literal|"\nX.3 PAD Parameters:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|npadx3
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|" [%d] %s %d\n"
argument_list|,
name|padx3tab
index|[
name|i
index|]
operator|.
name|kwval
argument_list|,
name|padx3tab
index|[
name|i
index|]
operator|.
name|kwd
argument_list|,
name|padparms
index|[
name|padx3tab
index|[
name|i
index|]
operator|.
name|kwval
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SUNX25 */
end_comment

begin_comment
comment|/*  Show File Parameters */
end_comment

begin_function
name|VOID
name|shoparf
parameter_list|()
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|i
decl_stmt|;
name|printf
argument_list|(
literal|"\nFile parameters:       "
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|COMMENT
name|printf
argument_list|(
literal|"Blocksize:     %5d      "
argument_list|,
name|fblksiz
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* COMMENT */
name|printf
argument_list|(
literal|" Attributes:       "
argument_list|)
expr_stmt|;
if|if
condition|(
name|atcapr
condition|)
name|printf
argument_list|(
literal|"on"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"off"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|VMS
name|printf
argument_list|(
literal|"  Record-Length: %5d"
argument_list|,
name|frecl
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* VMS */
name|printf
argument_list|(
literal|"\n Names:   "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%-12s"
argument_list|,
operator|(
name|fncnv
operator|)
condition|?
literal|"converted"
else|:
literal|"literal"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
ifndef|#
directive|ifndef
name|MAC
name|printf
argument_list|(
literal|"  Debugging Log:    "
argument_list|)
expr_stmt|;
if|if
condition|(
name|deblog
condition|)
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|debfil
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"none"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MAC */
endif|#
directive|endif
comment|/* DEBUG */
name|printf
argument_list|(
literal|"\n Type:    "
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|binary
condition|)
block|{
case|case
name|XYFT_T
case|:
name|s
operator|=
literal|"text"
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|VMS
case|case
name|XYFT_B
case|:
name|s
operator|=
literal|"binary fixed"
expr_stmt|;
break|break;
case|case
name|XYFT_I
case|:
name|s
operator|=
literal|"image"
expr_stmt|;
break|break;
case|case
name|XYFT_L
case|:
name|s
operator|=
literal|"labeled"
expr_stmt|;
break|break;
case|case
name|XYFT_U
case|:
name|s
operator|=
literal|"binary undef"
expr_stmt|;
break|break;
else|#
directive|else
case|case
name|XYFT_B
case|:
name|s
operator|=
literal|"binary"
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* VMS */
default|default:
name|s
operator|=
literal|"?"
expr_stmt|;
break|break;
block|}
name|printf
argument_list|(
literal|"%-12s"
argument_list|,
name|s
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|COMMENT
name|printf
argument_list|(
literal|" Organization:  "
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|forg
condition|)
block|{
case|case
name|XYFO_I
case|:
name|printf
argument_list|(
literal|"%-10s"
argument_list|,
literal|"indexed"
argument_list|)
expr_stmt|;
break|break;
case|case
name|XYFO_R
case|:
name|printf
argument_list|(
literal|"%-10s"
argument_list|,
literal|"relative"
argument_list|)
expr_stmt|;
break|break;
case|case
name|XYFO_S
case|:
name|printf
argument_list|(
literal|"%-10s"
argument_list|,
literal|"sequential"
argument_list|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
comment|/* COMMENT */
ifndef|#
directive|ifndef
name|MAC
name|printf
argument_list|(
literal|"  Packet Log:       "
argument_list|)
expr_stmt|;
if|if
condition|(
name|pktlog
condition|)
name|printf
argument_list|(
name|pktfil
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"none"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MAC */
ifdef|#
directive|ifdef
name|UNIX
name|printf
argument_list|(
literal|"  Longest filename: %d"
argument_list|,
name|maxnam
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* UNIX */
name|printf
argument_list|(
literal|"\n Collide: "
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ncolx
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|colxtab
index|[
name|i
index|]
operator|.
name|kwval
operator|==
name|fncact
condition|)
break|break;
name|printf
argument_list|(
literal|"%-12s"
argument_list|,
operator|(
name|i
operator|==
name|ncolx
operator|)
condition|?
literal|"unknown"
else|:
name|colxtab
index|[
name|i
index|]
operator|.
name|kwd
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|COMMENT
name|printf
argument_list|(
literal|" Format:        "
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|frecfm
condition|)
block|{
case|case
name|XYFF_F
case|:
name|printf
argument_list|(
literal|"%-10s"
argument_list|,
literal|"fixed"
argument_list|)
expr_stmt|;
break|break;
case|case
name|XYFF_VB
case|:
name|printf
argument_list|(
literal|"%-10s"
argument_list|,
literal|"rcw"
argument_list|)
expr_stmt|;
break|break;
case|case
name|XYFF_S
case|:
name|printf
argument_list|(
literal|"%-10s"
argument_list|,
literal|"stream"
argument_list|)
expr_stmt|;
break|break;
case|case
name|XYFF_U
case|:
name|printf
argument_list|(
literal|"%-10s"
argument_list|,
literal|"undefined"
argument_list|)
expr_stmt|;
break|break;
case|case
name|XYFF_V
case|:
name|printf
argument_list|(
literal|"%-10s"
argument_list|,
literal|"variable"
argument_list|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
comment|/* COMMENT */
ifndef|#
directive|ifndef
name|MAC
name|printf
argument_list|(
literal|"  Session Log:      "
argument_list|)
expr_stmt|;
if|if
condition|(
name|seslog
condition|)
name|printf
argument_list|(
name|sesfil
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"none"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MAC */
ifdef|#
directive|ifdef
name|UNIX
name|printf
argument_list|(
literal|"  Longest pathname: %d"
argument_list|,
name|maxpath
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* UNIX */
name|printf
argument_list|(
literal|"\n Display: "
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|fdispla
condition|)
block|{
case|case
name|XYFD_N
case|:
name|printf
argument_list|(
literal|"%-12s"
argument_list|,
literal|"none"
argument_list|)
expr_stmt|;
break|break;
case|case
name|XYFD_R
case|:
name|printf
argument_list|(
literal|"%-12s"
argument_list|,
literal|"serial"
argument_list|)
expr_stmt|;
break|break;
case|case
name|XYFD_C
case|:
name|printf
argument_list|(
literal|"%-12s"
argument_list|,
literal|"fullscreen"
argument_list|)
expr_stmt|;
break|break;
case|case
name|XYFD_S
case|:
name|printf
argument_list|(
literal|"%-12s"
argument_list|,
literal|"crt"
argument_list|)
expr_stmt|;
break|break;
block|}
ifdef|#
directive|ifdef
name|COMMENT
name|printf
argument_list|(
literal|"Carriage-Control: "
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|fcctrl
condition|)
block|{
case|case
name|XYFP_F
case|:
name|printf
argument_list|(
literal|"%-10s"
argument_list|,
literal|"fortran"
argument_list|)
expr_stmt|;
break|break;
case|case
name|XYFP_N
case|:
name|printf
argument_list|(
literal|"%-10s"
argument_list|,
literal|"newline"
argument_list|)
expr_stmt|;
break|break;
case|case
name|XYFP_P
case|:
name|printf
argument_list|(
literal|"%-10s"
argument_list|,
literal|"machine"
argument_list|)
expr_stmt|;
break|break;
case|case
name|XYFP_X
case|:
name|printf
argument_list|(
literal|"%-10s"
argument_list|,
literal|"none"
argument_list|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
comment|/* COMMENT */
ifdef|#
directive|ifdef
name|TLOG
ifndef|#
directive|ifndef
name|MAC
name|printf
argument_list|(
literal|"  Transaction Log:  "
argument_list|)
expr_stmt|;
if|if
condition|(
name|tralog
condition|)
name|printf
argument_list|(
name|trafil
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"none"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MAC */
endif|#
directive|endif
comment|/* TLOG */
ifndef|#
directive|ifndef
name|NOCSETS
if|if
condition|(
name|binary
operator|==
name|XYFT_T
condition|)
block|{
name|shocharset
argument_list|()
expr_stmt|;
block|}
else|else
endif|#
directive|endif
comment|/* NOCSETS */
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\nFile Byte Size: %d"
argument_list|,
operator|(
name|fmask
operator|==
literal|0177
operator|)
condition|?
literal|7
else|:
literal|8
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|", Incomplete Files: "
argument_list|)
expr_stmt|;
if|if
condition|(
name|keep
condition|)
name|printf
argument_list|(
literal|"keep"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"discard"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|KERMRC
name|printf
argument_list|(
literal|", Init file: %s"
argument_list|,
name|kermrc
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* KERMRC */
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|VOID
name|shoparp
parameter_list|()
block|{
name|printf
argument_list|(
literal|"\nProtocol Parameters:   Send    Receive"
argument_list|)
expr_stmt|;
if|if
condition|(
name|timef
condition|)
name|printf
argument_list|(
literal|"\n Timeout (used=%2d):%7d*%8d "
argument_list|,
name|timint
argument_list|,
name|rtimo
argument_list|,
name|pkttim
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"\n Timeout (used=%2d):%7d%9d "
argument_list|,
name|timint
argument_list|,
name|rtimo
argument_list|,
name|pkttim
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NOSERVER
name|printf
argument_list|(
literal|"       Server Timeout:%4d\n"
argument_list|,
name|srvtim
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* NOSERVER */
name|printf
argument_list|(
literal|" Padding:      %11d%9d"
argument_list|,
name|npad
argument_list|,
name|mypadn
argument_list|)
expr_stmt|;
if|if
condition|(
name|bctr
operator|==
literal|4
condition|)
name|printf
argument_list|(
literal|"        Block Check: blank-free-2\n"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"        Block Check: %6d\n"
argument_list|,
name|bctr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" Pad Character:%11d%9d"
argument_list|,
name|padch
argument_list|,
name|mypadc
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"        Delay:       %6d\n"
argument_list|,
name|delay
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" Packet Start: %11d%9d"
argument_list|,
name|mystch
argument_list|,
name|stchr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"        Max Retries: %6d\n"
argument_list|,
name|maxtry
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" Packet End:   %11d%9d"
argument_list|,
name|seol
argument_list|,
name|eol
argument_list|)
expr_stmt|;
if|if
condition|(
name|ebqflg
condition|)
name|printf
argument_list|(
literal|"        8th-Bit Prefix: '%c'"
argument_list|,
name|ebq
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|COMMENT
comment|/*   This is confusing. */
name|printf
argument_list|(
literal|"\n Packet Length:%11d"
argument_list|,
name|spsizf
condition|?
name|spsizr
else|:
name|spsiz
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|spsizf
condition|?
literal|"*"
else|:
literal|" "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%8d"
argument_list|,
name|urpsiz
argument_list|)
expr_stmt|;
name|printf
argument_list|(
operator|(
name|urpsiz
operator|>
literal|94
operator|)
condition|?
literal|" (94)"
else|:
literal|"     "
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
literal|"\n Packet Length:%11d "
argument_list|,
name|spmax
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%8d     "
argument_list|,
name|urpsiz
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* COMMENT */
if|if
condition|(
name|rptflg
condition|)
name|printf
argument_list|(
literal|"   Repeat Prefix:  '%c'"
argument_list|,
name|rptq
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n Maximum Length: %9d%9d"
argument_list|,
name|maxsps
argument_list|,
name|maxrps
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"        Window Size:%7d set, %d used\n"
argument_list|,
name|wslotr
argument_list|,
name|wmax
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" Buffer Size:  %11d%9d"
argument_list|,
name|bigsbsiz
argument_list|,
name|bigrbsiz
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"        Locking-Shift:    "
argument_list|)
expr_stmt|;
if|if
condition|(
name|lscapu
operator|==
literal|2
condition|)
block|{
name|printf
argument_list|(
literal|"forced\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"%s"
argument_list|,
operator|(
name|lscapr
condition|?
literal|"enabled"
else|:
literal|"disabled"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|lscapr
condition|)
name|printf
argument_list|(
literal|",%s%s"
argument_list|,
operator|(
name|lscapu
condition|?
literal|" "
else|:
literal|" not "
operator|)
argument_list|,
literal|"used"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|NOCSETS
end_ifndef

begin_function
name|VOID
name|shoparl
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|COMMENT
name|int
name|i
decl_stmt|;
comment|/* Misleading... */
name|printf
argument_list|(
literal|"\nAvailable Languages:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXLANG
condition|;
name|i
operator|++
control|)
block|{
name|printf
argument_list|(
literal|" %s\n"
argument_list|,
name|langs
index|[
name|i
index|]
operator|.
name|description
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|printf
argument_list|(
literal|"\nLanguage-specific translation rules: %s\n"
argument_list|,
name|language
operator|==
name|L_USASCII
condition|?
literal|"none"
else|:
name|langs
index|[
name|language
index|]
operator|.
name|description
argument_list|)
expr_stmt|;
name|shocharset
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"\n\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* COMMENT */
block|}
end_function

begin_function
name|VOID
name|shocharset
parameter_list|()
block|{
name|int
name|x
decl_stmt|;
name|printf
argument_list|(
literal|"\n File Character-Set: %s ("
argument_list|,
name|fcsinfo
index|[
name|fcharset
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|x
operator|=
name|fcsinfo
index|[
name|fcharset
index|]
operator|.
name|size
operator|)
operator|==
literal|128
condition|)
name|printf
argument_list|(
literal|"7-bit)"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|x
operator|==
literal|256
condition|)
name|printf
argument_list|(
literal|"8-bit)"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"(multibyte)"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n Transfer Character-Set"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|COMMENT
if|if
condition|(
name|tslevel
operator|==
name|TS_L2
condition|)
name|printf
argument_list|(
literal|": (international)"
argument_list|)
expr_stmt|;
elseif|else
endif|#
directive|endif
comment|/* COMMENT */
if|if
condition|(
name|tcharset
operator|==
name|TC_TRANSP
condition|)
name|printf
argument_list|(
literal|": Transparent"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|": %s"
argument_list|,
name|tcsinfo
index|[
name|tcharset
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NOCSETS */
end_comment

begin_function
name|VOID
name|shopar
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|MAC
name|printf
argument_list|(
literal|"\n%s,%s\n"
argument_list|,
name|versio
argument_list|,
name|ckxsys
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MAC */
name|shoparc
argument_list|()
expr_stmt|;
name|shoparp
argument_list|()
expr_stmt|;
name|shoparf
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NOSHOW */
end_comment

begin_escape
end_escape

begin_comment
comment|/*  D O S T A T  --  Display file transfer statistics.  */
end_comment

begin_function
name|int
name|dostat
parameter_list|()
block|{
name|printf
argument_list|(
literal|"\nMost recent transaction --\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n files: %ld\n"
argument_list|,
name|filcnt
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" characters last file   : %ld\n"
argument_list|,
name|ffc
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" total file characters  : %ld\n"
argument_list|,
name|tfc
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" communication line in  : %ld\n"
argument_list|,
name|tlci
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" communication line out : %ld\n"
argument_list|,
name|tlco
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" packets sent           : %d\n"
argument_list|,
name|spackets
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" packets received       : %d\n"
argument_list|,
name|rpackets
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" damaged packets rec'd  : %d\n"
argument_list|,
name|crunched
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" timeouts               : %d\n"
argument_list|,
name|timeouts
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" retransmissions        : %d\n"
argument_list|,
name|retrans
argument_list|)
expr_stmt|;
if|if
condition|(
name|filcnt
operator|>
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|" parity                 : %s"
argument_list|,
name|parnam
argument_list|(
operator|(
name|char
operator|)
name|parity
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|autopar
condition|)
name|printf
argument_list|(
literal|" (detected automatically)"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n 8th bit prefixing      : "
argument_list|)
expr_stmt|;
if|if
condition|(
name|ebqflg
condition|)
name|printf
argument_list|(
literal|"yes [%c]\n"
argument_list|,
name|ebq
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"no\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" locking shifts         : %s\n"
argument_list|,
name|lscapu
condition|?
literal|"yes"
else|:
literal|"no"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" window slots used      : %d of %d\n"
argument_list|,
name|wmax
argument_list|,
name|wslotr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" packet length          : %d (send), %d (receive)\n"
argument_list|,
name|spmax
argument_list|,
name|urpsiz
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" compression            : "
argument_list|)
expr_stmt|;
if|if
condition|(
name|rptflg
condition|)
name|printf
argument_list|(
literal|"yes [%c] (%d)\n"
argument_list|,
name|rptq
argument_list|,
name|rptn
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"no\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|bctu
operator|==
literal|4
condition|)
name|printf
argument_list|(
literal|" block check type used  : blank-free-2\n"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|" block check type used  : %d\n"
argument_list|,
name|bctu
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" elapsed time           : %d sec\n"
argument_list|,
name|tsecs
argument_list|)
expr_stmt|;
if|if
condition|(
name|speed
operator|<=
literal|0L
condition|)
name|speed
operator|=
name|ttgspd
argument_list|()
expr_stmt|;
if|if
condition|(
name|speed
operator|>
literal|0L
condition|)
block|{
if|if
condition|(
name|speed
operator|==
literal|8880
condition|)
name|printf
argument_list|(
literal|" transmission rate      : 75/1200 bps\n"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|" transmission rate      : %ld bps\n"
argument_list|,
name|speed
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tsecs
operator|>
literal|0
condition|)
block|{
name|long
name|lx
decl_stmt|;
name|lx
operator|=
operator|(
name|tfc
operator|*
literal|10L
operator|)
operator|/
operator|(
name|long
operator|)
name|tsecs
expr_stmt|;
name|printf
argument_list|(
literal|" effective data rate    : %ld cps\n"
argument_list|,
name|lx
operator|/
literal|10L
argument_list|)
expr_stmt|;
if|if
condition|(
name|speed
operator|>
literal|0L
operator|&&
name|speed
operator|!=
literal|8880L
operator|&&
name|network
operator|==
literal|0
condition|)
block|{
name|lx
operator|=
operator|(
name|lx
operator|*
literal|100L
operator|)
operator|/
name|speed
expr_stmt|;
name|printf
argument_list|(
literal|" efficiency (percent)   : %ld\n"
argument_list|,
name|lx
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|COMMENT
name|lx
operator|=
operator|(
name|tlci
operator|*
literal|10L
operator|)
operator|/
operator|(
name|long
operator|)
name|tsecs
expr_stmt|;
name|printf
argument_list|(
literal|" throughput (in)        : %ld cps\n"
argument_list|,
name|lx
operator|/
literal|10l
argument_list|)
expr_stmt|;
name|lx
operator|=
operator|(
name|tlco
operator|*
literal|10L
operator|)
operator|/
operator|(
name|long
operator|)
name|tsecs
expr_stmt|;
name|printf
argument_list|(
literal|" throughput (out)       : %ld cps\n"
argument_list|,
name|lx
operator|/
literal|10l
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* COMMENT */
block|}
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  D O C O N E C T  --  Do the connect command  */
end_comment

begin_comment
comment|/*  Note, we don't call this directly from dial, because we need to give */
end_comment

begin_comment
comment|/*  the user a chance to change parameters (e.g. parity) after the */
end_comment

begin_comment
comment|/*  connection is made. */
end_comment

begin_function
name|int
name|doconect
parameter_list|()
block|{
name|int
name|x
decl_stmt|;
name|conres
argument_list|()
expr_stmt|;
comment|/* Put console back to normal */
name|x
operator|=
name|conect
argument_list|()
expr_stmt|;
comment|/* Connect */
name|concb
argument_list|(
operator|(
name|char
operator|)
name|escape
argument_list|)
expr_stmt|;
comment|/* Put console into cbreak mode, */
return|return
operator|(
name|x
operator|)
return|;
comment|/* for more command parsing. */
block|}
end_function

begin_escape
end_escape

begin_ifndef
ifndef|#
directive|ifndef
name|NOSPL
end_ifndef

begin_comment
comment|/* The INPUT command */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|NETCONN
end_ifdef

begin_decl_stmt
specifier|extern
name|int
name|tn_init
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|IAC
end_ifndef

begin_define
define|#
directive|define
name|IAC
value|255
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* IAC */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NETCONN */
end_comment

begin_function
name|int
name|doinput
parameter_list|(
name|timo
parameter_list|,
name|s
parameter_list|)
name|int
name|timo
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|int
name|x
decl_stmt|,
name|y
decl_stmt|,
name|i
decl_stmt|,
name|t
decl_stmt|,
name|icn
decl_stmt|,
name|anychar
decl_stmt|;
name|int
name|lastchar
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|xp
decl_stmt|,
modifier|*
name|xq
init|=
operator|(
name|char
operator|*
operator|)
literal|0
decl_stmt|;
name|CHAR
name|c
decl_stmt|;
if|if
condition|(
name|local
condition|)
block|{
comment|/* Put line in "ttvt" mode */
name|y
operator|=
name|ttvt
argument_list|(
name|speed
argument_list|,
name|flow
argument_list|)
expr_stmt|;
comment|/* if not already. */
if|if
condition|(
name|y
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"?Can't condition line for INPUT\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Watch out for failure. */
block|}
block|}
if|if
condition|(
operator|!
name|s
condition|)
name|s
operator|=
literal|""
expr_stmt|;
name|y
operator|=
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* If search string is empty */
name|anychar
operator|=
operator|(
name|y
operator|<
literal|1
operator|)
expr_stmt|;
comment|/* any input character will do. */
name|debug
argument_list|(
name|F111
argument_list|,
literal|"doinput"
argument_list|,
name|s
argument_list|,
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|timo
operator|<=
literal|0
condition|)
name|timo
operator|=
literal|1
expr_stmt|;
comment|/* Give at least 1 second timeout */
name|x
operator|=
literal|0
expr_stmt|;
comment|/* Return code, assume failure */
name|i
operator|=
literal|0
expr_stmt|;
comment|/* String pattern match position */
if|if
condition|(
operator|!
name|incase
condition|)
block|{
comment|/* INPUT CASE = IGNORE?  */
name|xp
operator|=
name|malloc
argument_list|(
name|y
operator|+
literal|2
argument_list|)
expr_stmt|;
comment|/* Make a separate copy of the */
if|if
condition|(
operator|!
name|xp
condition|)
block|{
comment|/* input string for editing. */
name|printf
argument_list|(
literal|"?malloc error 5\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|x
operator|)
return|;
block|}
else|else
name|xq
operator|=
name|xp
expr_stmt|;
comment|/* Save pointer to beginning */
while|while
condition|(
operator|*
name|s
condition|)
block|{
comment|/* Convert to lowercase */
operator|*
name|xp
operator|=
operator|*
name|s
expr_stmt|;
if|if
condition|(
name|isupper
argument_list|(
operator|*
name|xp
argument_list|)
condition|)
operator|*
name|xp
operator|=
name|tolower
argument_list|(
operator|*
name|xp
argument_list|)
expr_stmt|;
name|xp
operator|++
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
operator|*
name|xp
operator|=
name|NUL
expr_stmt|;
comment|/* Terminate the search string. */
name|s
operator|=
name|xq
expr_stmt|;
comment|/* Point back to beginning. */
block|}
name|inpbps
operator|=
name|inpbp
expr_stmt|;
comment|/* Save current pointer. */
name|rtimer
argument_list|()
expr_stmt|;
comment|/* Reset timer. */
name|t
operator|=
literal|0
expr_stmt|;
comment|/* Time is 0. */
name|incount
operator|=
literal|0
expr_stmt|;
comment|/* Character counter */
while|while
condition|(
literal|1
condition|)
block|{
comment|/* Character-getting loop */
if|if
condition|(
name|local
condition|)
block|{
comment|/* One case for local */
name|y
operator|=
name|ttinc
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* Get character from comm line. */
name|debug
argument_list|(
name|F101
argument_list|,
literal|"input ttinc(1) returns"
argument_list|,
literal|""
argument_list|,
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|icn
operator|=
name|conchk
argument_list|()
condition|)
block|{
comment|/* Interrupted from keyboard? */
name|debug
argument_list|(
name|F101
argument_list|,
literal|"input interrupted from keyboard"
argument_list|,
literal|""
argument_list|,
name|icn
argument_list|)
expr_stmt|;
while|while
condition|(
name|icn
operator|--
condition|)
name|coninc
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Yes, read what was typed. */
break|break;
comment|/* And fail. */
block|}
block|}
else|else
block|{
comment|/* Another for remote */
name|y
operator|=
name|coninc
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|"input coninc(1) returns"
argument_list|,
literal|""
argument_list|,
name|y
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|y
operator|>
operator|-
literal|1
condition|)
block|{
comment|/* A character arrived */
ifdef|#
directive|ifdef
name|TNCODE
comment|/* Check for telnet protocol negotiation */
if|if
condition|(
name|network
operator|&&
operator|(
name|ttnproto
operator|==
name|NP_TELNET
operator|)
operator|&&
operator|(
operator|(
name|y
operator|&
literal|0xff
operator|)
operator|==
name|IAC
operator|)
condition|)
block|{
switch|switch
condition|(
name|tn_doop
argument_list|(
call|(
name|CHAR
call|)
argument_list|(
name|y
operator|&
literal|0xff
argument_list|)
argument_list|,
name|duplex
argument_list|,
name|ttinc
argument_list|)
condition|)
block|{
case|case
literal|2
case|:
name|duplex
operator|=
literal|0
expr_stmt|;
continue|continue;
case|case
literal|1
case|:
name|duplex
operator|=
literal|1
expr_stmt|;
default|default:
continue|continue;
block|}
block|}
endif|#
directive|endif
comment|/* TNCODE */
comment|/* Real input character to be checked */
name|c
operator|=
name|cmask
operator|&
operator|(
name|CHAR
operator|)
name|y
expr_stmt|;
comment|/* Mask off parity */
name|inchar
index|[
literal|0
index|]
operator|=
name|c
expr_stmt|;
comment|/* Remember character for \v(inchar) */
name|lastchar
operator|=
name|gtimer
argument_list|()
expr_stmt|;
comment|/* Remember when it came. */
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
block|{
comment|/* NUL, we can't use it */
if|if
condition|(
name|anychar
condition|)
block|{
comment|/* Any character will do? */
name|x
operator|=
literal|1
expr_stmt|;
comment|/* Yes, done. */
name|incount
operator|=
literal|1
expr_stmt|;
comment|/* This must be the first and only. */
break|break;
block|}
else|else
continue|continue;
comment|/* Otherwise continue INPUTting */
block|}
operator|*
name|inpbp
operator|++
operator|=
name|c
expr_stmt|;
comment|/* Store char in circular buffer */
name|incount
operator|++
expr_stmt|;
comment|/* Count it for \v(incount) */
if|if
condition|(
name|inpbp
operator|>=
name|inpbuf
operator|+
name|INPBUFSIZ
condition|)
block|{
comment|/* Time to wrap around? */
name|inpbp
operator|=
name|inpbuf
expr_stmt|;
comment|/* Yes. */
operator|*
operator|(
name|inpbp
operator|+
name|INPBUFSIZ
operator|)
operator|=
name|NUL
expr_stmt|;
comment|/* Make sure it's null-terminated. */
block|}
ifdef|#
directive|ifdef
name|MAC
block|{
specifier|extern
name|char
modifier|*
name|ttermw
decl_stmt|;
comment|/* fake pointer cast */
if|if
condition|(
name|inecho
condition|)
block|{
name|outchar
argument_list|(
name|ttermw
argument_list|,
name|c
argument_list|)
expr_stmt|;
comment|/* echo to terminal window */
comment|/* this might be too much overhead to do here ? */
name|updatecommand
argument_list|(
name|ttermw
argument_list|)
expr_stmt|;
block|}
block|}
else|#
directive|else
comment|/* Not MAC */
if|if
condition|(
name|inecho
condition|)
name|conoc
argument_list|(
name|c
argument_list|)
expr_stmt|;
comment|/* Echo and log the input character */
endif|#
directive|endif
comment|/* MAC */
if|if
condition|(
name|seslog
condition|)
block|{
ifdef|#
directive|ifdef
name|UNIX
if|if
condition|(
name|sessft
operator|!=
literal|0
operator|||
name|c
operator|!=
literal|'\r'
condition|)
endif|#
directive|endif
comment|/* UNIX */
if|if
condition|(
name|zchout
argument_list|(
name|ZSFILE
argument_list|,
name|c
argument_list|)
operator|<
literal|0
condition|)
name|seslog
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|anychar
condition|)
block|{
comment|/* Any character will do? */
name|x
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|incase
condition|)
block|{
comment|/* Ignore alphabetic case? */
if|if
condition|(
name|isupper
argument_list|(
name|c
argument_list|)
condition|)
name|c
operator|=
name|tolower
argument_list|(
name|c
argument_list|)
expr_stmt|;
comment|/* Yes */
block|}
name|debug
argument_list|(
name|F000
argument_list|,
literal|"doinput char"
argument_list|,
literal|""
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F000
argument_list|,
literal|"compare char"
argument_list|,
literal|""
argument_list|,
name|s
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|s
index|[
name|i
index|]
condition|)
block|{
comment|/* Check for match */
name|i
operator|++
expr_stmt|;
comment|/* Got one, go to next character */
block|}
else|else
block|{
comment|/* Don't have a match */
name|int
name|j
decl_stmt|,
name|size
decl_stmt|;
for|for
control|(
name|j
operator|=
name|i
init|;
name|i
operator|--
operator|>
literal|0
condition|;
control|)
block|{
comment|/* [jrs] search backwards */
if|if
condition|(
name|c
operator|==
name|s
index|[
name|i
index|]
condition|)
block|{
name|size
operator|=
name|j
operator|-
name|i
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|s
argument_list|,
operator|&
name|s
index|[
name|j
operator|-
name|i
index|]
argument_list|,
name|i
operator|-
name|size
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
block|}
name|i
operator|++
expr_stmt|;
comment|/* [jrs] count last char matched    */
block|}
comment|/* [jrs] or return to zero from -1  */
if|if
condition|(
name|s
index|[
name|i
index|]
operator|==
literal|'\0'
condition|)
block|{
comment|/* Matched all the way to end? */
name|x
operator|=
literal|1
expr_stmt|;
comment|/* Yes, */
break|break;
comment|/* done. */
block|}
block|}
if|if
condition|(
operator|(
name|t
operator|=
name|gtimer
argument_list|()
operator|)
operator|>
name|timo
condition|)
comment|/* Did not match, timer exceeded? */
break|break;
elseif|else
if|if
condition|(
name|insilence
operator|>
literal|0
operator|&&
operator|(
name|t
operator|-
name|lastchar
operator|)
operator|>
name|insilence
condition|)
break|break;
block|}
comment|/* Still have time left, continue. */
if|if
condition|(
operator|!
name|incase
condition|)
if|if
condition|(
name|xq
condition|)
name|free
argument_list|(
name|xq
argument_list|)
expr_stmt|;
comment|/* Done, free dynamic memory. */
return|return
operator|(
name|x
operator|)
return|;
comment|/* Return the return code. */
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NOSPL */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NOSPL
end_ifndef

begin_comment
comment|/* REINPUT Command */
end_comment

begin_comment
comment|/* Note, the timeout parameter is required, but ignored. */
end_comment

begin_comment
comment|/* Syntax is compatible with MS-DOS Kermit except timeout can't be omitted. */
end_comment

begin_comment
comment|/* This function only looks at the characters already received */
end_comment

begin_comment
comment|/* and does not read any new characters from the communication line. */
end_comment

begin_function
name|int
name|doreinp
parameter_list|(
name|timo
parameter_list|,
name|s
parameter_list|)
name|int
name|timo
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|int
name|x
decl_stmt|,
name|y
decl_stmt|,
name|i
decl_stmt|;
name|char
modifier|*
name|xx
decl_stmt|,
modifier|*
name|xp
decl_stmt|,
modifier|*
name|xq
init|=
operator|(
name|char
operator|*
operator|)
literal|0
decl_stmt|;
name|CHAR
name|c
decl_stmt|;
name|y
operator|=
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F111
argument_list|,
literal|"doreinput"
argument_list|,
name|s
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|x
operator|=
literal|0
expr_stmt|;
comment|/* Return code, assume failure */
name|i
operator|=
literal|0
expr_stmt|;
comment|/* String pattern match position */
if|if
condition|(
operator|!
name|incase
condition|)
block|{
comment|/* INPUT CASE = IGNORE?  */
name|xp
operator|=
name|malloc
argument_list|(
name|y
operator|+
literal|2
argument_list|)
expr_stmt|;
comment|/* Make a separate copy of the */
if|if
condition|(
operator|!
name|xp
condition|)
block|{
comment|/* search string. */
name|printf
argument_list|(
literal|"?malloc error 6\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|x
operator|)
return|;
block|}
else|else
name|xq
operator|=
name|xp
expr_stmt|;
comment|/* Keep pointer to beginning. */
while|while
condition|(
operator|*
name|s
condition|)
block|{
comment|/* Yes, convert to lowercase */
operator|*
name|xp
operator|=
operator|*
name|s
expr_stmt|;
if|if
condition|(
name|isupper
argument_list|(
operator|*
name|xp
argument_list|)
condition|)
operator|*
name|xp
operator|=
name|tolower
argument_list|(
operator|*
name|xp
argument_list|)
expr_stmt|;
name|xp
operator|++
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
operator|*
name|xp
operator|=
name|NUL
expr_stmt|;
comment|/* Terminate it! */
name|s
operator|=
name|xq
expr_stmt|;
comment|/* Move search pointer to it. */
block|}
name|xx
operator|=
name|inpbp
expr_stmt|;
comment|/* Current INPUT buffer pointer */
do|do
block|{
name|c
operator|=
operator|*
name|xx
operator|++
expr_stmt|;
comment|/* Get next character */
if|if
condition|(
name|xx
operator|>=
name|inpbuf
operator|+
name|INPBUFSIZ
condition|)
name|xx
operator|=
name|inpbuf
expr_stmt|;
comment|/* Wrap around */
if|if
condition|(
operator|!
name|incase
condition|)
block|{
comment|/* Ignore alphabetic case? */
if|if
condition|(
name|isupper
argument_list|(
name|c
argument_list|)
condition|)
name|c
operator|=
name|tolower
argument_list|(
name|c
argument_list|)
expr_stmt|;
comment|/* Yes */
block|}
name|debug
argument_list|(
name|F000
argument_list|,
literal|"doreinp char"
argument_list|,
literal|""
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F000
argument_list|,
literal|"compare char"
argument_list|,
literal|""
argument_list|,
name|s
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|s
index|[
name|i
index|]
condition|)
block|{
comment|/* Check for match */
name|i
operator|++
expr_stmt|;
comment|/* Got one, go to next character */
block|}
else|else
block|{
comment|/* Don't have a match */
name|int
name|j
decl_stmt|,
name|size
decl_stmt|;
for|for
control|(
name|j
operator|=
name|i
init|;
name|i
operator|--
operator|>
literal|0
condition|;
control|)
block|{
comment|/* [jrs] search backwards for it  */
if|if
condition|(
name|c
operator|==
name|s
index|[
name|i
index|]
condition|)
block|{
name|size
operator|=
name|j
operator|-
name|i
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|s
argument_list|,
operator|&
name|s
index|[
name|j
operator|-
name|i
index|]
argument_list|,
name|i
operator|-
name|size
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
block|}
name|i
operator|++
expr_stmt|;
comment|/* [jrs] count last char matched */
block|}
comment|/* [jrs] or return to zero from -1 */
if|if
condition|(
name|s
index|[
name|i
index|]
operator|==
literal|'\0'
condition|)
block|{
comment|/* Matched all the way to end? */
name|x
operator|=
literal|1
expr_stmt|;
comment|/* Yes, */
break|break;
comment|/* done. */
block|}
block|}
do|while
condition|(
name|xx
operator|!=
name|inpbp
condition|)
do|;
comment|/* Until back where we started. */
if|if
condition|(
operator|!
name|incase
condition|)
if|if
condition|(
name|xq
condition|)
name|free
argument_list|(
name|xq
argument_list|)
expr_stmt|;
comment|/* Free this if it was malloc'd. */
return|return
operator|(
name|x
operator|)
return|;
comment|/* Return search result. */
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|NOSPL
end_ifndef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NOSPL */
end_comment

begin_comment
comment|/*  X X S T R I N G  --  Interpret strings containing backslash escapes  */
end_comment

begin_comment
comment|/*  Copies result to new string.   strips enclosing braces or doublequotes.   interprets backslash escapes.   returns 0 on success, nonzero on failure.   tries to be compatible with MS-DOS Kermit.   Syntax of input string:   string = chars | "chars" | {chars}   chars = (c*e*)*   where c = any printable character, ascii 32-126   and e = a backslash escape   and * means 0 or more repetitions of preceding quantity   backslash escape = \operand   operand = {number} | number | fname(operand) | v(name) | $(name) | m(name)   number = [r]n[n[n]]], i.e. an optional radix code followed by 1-3 digits   radix code is oO (octal), hHxX (hex), dD or none (decimal). */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NOFRILLS
end_ifndef

begin_function
name|int
name|yystring
parameter_list|(
name|s
parameter_list|,
name|s2
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
name|char
modifier|*
modifier|*
name|s2
decl_stmt|;
block|{
comment|/* Reverse a string */
name|int
name|x
decl_stmt|;
specifier|static
name|char
modifier|*
name|new
decl_stmt|;
name|new
operator|=
operator|*
name|s2
expr_stmt|;
if|if
condition|(
operator|!
name|s
operator|||
operator|!
name|new
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* Watch out for null pointers. */
if|if
condition|(
operator|(
name|x
operator|=
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|s
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Recursion done. */
operator|*
name|new
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|x
operator|--
expr_stmt|;
comment|/* Otherwise, call self */
operator|*
name|new
operator|++
operator|=
name|s
index|[
name|x
index|]
expr_stmt|;
comment|/* to reverse rest of string. */
name|s
index|[
name|x
index|]
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|yystring
argument_list|(
name|s
argument_list|,
operator|&
name|new
argument_list|)
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NOFRILLS */
end_comment

begin_define
define|#
directive|define
name|FNVALL
value|1000
end_define

begin_decl_stmt
name|char
name|fnval
index|[
name|FNVALL
operator|+
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return value */
end_comment

begin_decl_stmt
name|char
modifier|*
comment|/* Evaluate builtin function */
name|fneval
argument_list|(
name|fn
argument_list|,
name|argp
argument_list|,
name|argn
argument_list|)
name|char
modifier|*
name|fn
decl_stmt|,
modifier|*
name|argp
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|argn
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|len1
decl_stmt|,
name|len2
decl_stmt|,
name|n
decl_stmt|,
name|x
decl_stmt|,
name|y
decl_stmt|;
name|char
modifier|*
name|bp
index|[
name|FNARGS
index|]
decl_stmt|;
comment|/* Pointers to malloc'd strings */
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|s
decl_stmt|;
if|if
condition|(
operator|!
name|fn
condition|)
name|fn
operator|=
literal|""
expr_stmt|;
comment|/* Paranoia */
name|debug
argument_list|(
name|F111
argument_list|,
literal|"fneval"
argument_list|,
name|fn
argument_list|,
name|argn
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F110
argument_list|,
literal|"fneval"
argument_list|,
name|argp
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|y
operator|=
name|lookup
argument_list|(
name|fnctab
argument_list|,
name|fn
argument_list|,
name|nfuncs
argument_list|,
operator|&
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|y
operator|<
literal|0
condition|)
comment|/* bad function name */
return|return
operator|(
literal|""
operator|)
return|;
comment|/* so value is null */
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|deblog
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|argn
condition|;
name|j
operator|++
control|)
name|debug
argument_list|(
name|F111
argument_list|,
literal|"fneval function arg"
argument_list|,
name|argp
index|[
name|j
index|]
argument_list|,
name|j
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* DEBUG */
if|if
condition|(
name|y
operator|==
name|FN_LIT
condition|)
comment|/* literal(arg1) */
return|return
operator|(
name|argp
index|[
literal|0
index|]
condition|?
name|argp
index|[
literal|0
index|]
else|:
literal|""
operator|)
return|;
comment|/* return a pointer to arg itself */
if|if
condition|(
name|y
operator|==
name|FN_CON
condition|)
block|{
comment|/* Contents of variable, unexpanded. */
name|char
name|c
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|p
operator|=
name|argp
index|[
literal|0
index|]
operator|)
operator|||
operator|!
operator|*
name|p
condition|)
return|return
operator|(
literal|""
operator|)
return|;
if|if
condition|(
operator|*
name|p
operator|==
name|CMDQ
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
operator|*
name|p
operator|)
operator|==
literal|'%'
condition|)
block|{
comment|/* Scalar variable. */
name|c
operator|=
operator|*
operator|++
name|p
expr_stmt|;
comment|/* Get ID character. */
name|p
operator|=
literal|""
expr_stmt|;
comment|/* Assume definition is empty */
if|if
condition|(
operator|!
name|c
condition|)
return|return
operator|(
name|p
operator|)
return|;
comment|/* Double paranoia */
if|if
condition|(
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
condition|)
block|{
comment|/* Digit for macro arg */
name|c
operator|-=
literal|'0'
expr_stmt|;
comment|/* convert character to integer */
if|if
condition|(
name|maclvl
operator|<
literal|0
condition|)
comment|/* Digit variables are global */
name|p
operator|=
name|g_var
index|[
name|c
index|]
expr_stmt|;
comment|/* if no macro is active */
else|else
comment|/* otherwise */
name|p
operator|=
name|m_arg
index|[
name|maclvl
index|]
index|[
name|c
index|]
expr_stmt|;
comment|/* they're on the stack */
block|}
else|else
block|{
if|if
condition|(
name|isupper
argument_list|(
name|c
argument_list|)
condition|)
name|c
operator|-=
operator|(
literal|'a'
operator|-
literal|'A'
operator|)
expr_stmt|;
name|p
operator|=
name|g_var
index|[
name|c
index|]
expr_stmt|;
comment|/* Letter for global variable */
block|}
return|return
operator|(
name|p
condition|?
name|p
else|:
literal|""
operator|)
return|;
block|}
if|if
condition|(
name|c
operator|==
literal|'&'
condition|)
block|{
comment|/* Array reference. */
name|int
name|vbi
decl_stmt|,
name|d
decl_stmt|;
if|if
condition|(
name|arraynam
argument_list|(
name|p
argument_list|,
operator|&
name|vbi
argument_list|,
operator|&
name|d
argument_list|)
operator|<
literal|0
condition|)
comment|/* Get name and subscript */
return|return
operator|(
literal|""
operator|)
return|;
if|if
condition|(
name|chkarray
argument_list|(
name|vbi
argument_list|,
name|d
argument_list|)
operator|>
literal|0
condition|)
block|{
comment|/* Array is declared? */
name|vbi
operator|-=
literal|'a'
expr_stmt|;
comment|/* Convert name to index */
if|if
condition|(
name|a_dim
index|[
name|vbi
index|]
operator|>=
name|d
condition|)
block|{
comment|/* If subscript in range */
name|char
modifier|*
modifier|*
name|ap
decl_stmt|;
name|ap
operator|=
name|a_ptr
index|[
name|vbi
index|]
expr_stmt|;
comment|/* get data pointer */
if|if
condition|(
name|ap
condition|)
block|{
comment|/* and if there is one */
return|return
operator|(
name|ap
index|[
name|d
index|]
operator|)
return|;
comment|/* return what it points to */
block|}
block|}
block|}
return|return
operator|(
name|p
condition|?
name|p
else|:
literal|""
operator|)
return|;
comment|/* Otherwise its enexpanded value. */
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argn
condition|;
name|i
operator|++
control|)
block|{
comment|/* Not literal, expand the args */
name|n
operator|=
literal|1024
expr_stmt|;
comment|/* allow 1K per expanded arg, yow! */
name|bp
index|[
name|i
index|]
operator|=
name|s
operator|=
name|malloc
argument_list|(
name|n
argument_list|)
expr_stmt|;
comment|/* get the new space */
if|if
condition|(
name|bp
index|[
name|i
index|]
operator|==
name|NULL
condition|)
block|{
comment|/* handle failure to get space */
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|i
condition|;
name|k
operator|++
control|)
if|if
condition|(
name|bp
index|[
name|k
index|]
condition|)
name|free
argument_list|(
name|bp
index|[
name|k
index|]
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|"fneval malloc failure, arg"
argument_list|,
literal|""
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
operator|(
literal|""
operator|)
return|;
block|}
name|p
operator|=
name|argp
index|[
name|i
index|]
condition|?
name|argp
index|[
name|i
index|]
else|:
literal|""
expr_stmt|;
comment|/* Point to this argument */
comment|/*   Trim leading and trailing spaces from the original argument, before   evaluation.  This code new to edit 184. */
if|if
condition|(
name|y
operator|!=
name|FN_REP
operator|||
name|i
operator|!=
literal|0
condition|)
block|{
comment|/* Don't trim 1st REPEAT argument */
name|int
name|j
decl_stmt|;
comment|/* All others... */
while|while
condition|(
operator|*
name|p
operator|==
name|SP
operator|||
operator|*
name|p
operator|==
name|HT
condition|)
comment|/* Point past leading whitespace */
name|p
operator|++
expr_stmt|;
name|j
operator|=
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|p
argument_list|)
operator|-
literal|1
expr_stmt|;
comment|/* Trim trailing whitespace */
while|while
condition|(
name|j
operator|>
literal|0
operator|&&
operator|(
operator|*
operator|(
name|p
operator|+
name|j
operator|)
operator|==
name|SP
operator|||
operator|*
operator|(
name|p
operator|+
name|j
operator|)
operator|==
name|HT
operator|)
condition|)
operator|*
operator|(
name|p
operator|+
name|j
operator|--
operator|)
operator|=
name|NUL
expr_stmt|;
block|}
comment|/* Now evaluate the argument */
if|if
condition|(
name|xxstring
argument_list|(
name|p
argument_list|,
operator|&
name|s
argument_list|,
operator|&
name|n
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* Expand arg into new space */
name|debug
argument_list|(
name|F101
argument_list|,
literal|"fneval xxstring fails, arg"
argument_list|,
literal|""
argument_list|,
name|i
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<=
name|i
condition|;
name|k
operator|++
control|)
comment|/* Free up previous space on error */
if|if
condition|(
name|bp
index|[
name|k
index|]
condition|)
name|free
argument_list|(
name|bp
index|[
name|k
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
literal|""
operator|)
return|;
comment|/* and return null string. */
block|}
name|debug
argument_list|(
name|F111
argument_list|,
literal|"fneval arg"
argument_list|,
name|bp
index|[
name|i
index|]
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|deblog
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|argn
condition|;
name|j
operator|++
control|)
block|{
name|debug
argument_list|(
name|F111
argument_list|,
literal|"fneval arg post eval"
argument_list|,
name|argp
index|[
name|j
index|]
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F111
argument_list|,
literal|"fneval evaluated arg"
argument_list|,
name|bp
index|[
name|j
index|]
argument_list|,
name|j
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* DEBUG */
switch|switch
condition|(
name|y
condition|)
block|{
comment|/* Do function on expanded args */
case|case
name|FN_DEF
case|:
name|k
operator|=
name|mlook
argument_list|(
name|mactab
argument_list|,
name|bp
index|[
literal|0
index|]
argument_list|,
name|nmac
argument_list|)
expr_stmt|;
comment|/* def(arg1) - Return a macro def */
name|p
operator|=
operator|(
name|k
operator|>
operator|-
literal|1
operator|)
condition|?
name|mactab
index|[
name|k
index|]
operator|.
name|mval
else|:
literal|""
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|argn
condition|;
name|k
operator|++
control|)
if|if
condition|(
name|bp
index|[
name|k
index|]
condition|)
name|free
argument_list|(
name|bp
index|[
name|k
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
condition|?
name|p
else|:
literal|""
operator|)
return|;
case|case
name|FN_EVA
case|:
comment|/* eval(arg1) */
name|p
operator|=
name|evala
argument_list|(
name|bp
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|argn
condition|;
name|k
operator|++
control|)
if|if
condition|(
name|bp
index|[
name|k
index|]
condition|)
name|free
argument_list|(
name|bp
index|[
name|k
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
condition|?
name|p
else|:
literal|""
operator|)
return|;
case|case
name|FN_EXE
case|:
comment|/* execute(arg1) */
name|j
operator|=
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|s
operator|=
name|bp
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* Length of macro invocation */
name|p
operator|=
literal|""
expr_stmt|;
comment|/* Initialize return value to null */
if|if
condition|(
name|j
condition|)
block|{
comment|/* If there is a macro to execute */
while|while
condition|(
operator|*
name|s
operator|==
name|SP
condition|)
name|s
operator|++
operator|,
name|j
operator|--
expr_stmt|;
comment|/* strip leading spaces */
name|p
operator|=
name|s
expr_stmt|;
comment|/* remember beginning of macro name */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|j
condition|;
name|i
operator|++
control|)
block|{
comment|/* find end of macro name */
if|if
condition|(
operator|*
name|s
operator|==
name|SP
condition|)
break|break;
name|s
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|s
operator|==
name|SP
condition|)
block|{
comment|/* if there was a space after */
operator|*
name|s
operator|++
operator|=
name|NUL
expr_stmt|;
comment|/* terminate the macro name */
while|while
condition|(
operator|*
name|s
operator|==
name|SP
condition|)
name|s
operator|++
expr_stmt|;
comment|/* skip past any extra spaces */
block|}
else|else
name|s
operator|=
literal|""
expr_stmt|;
comment|/* maybe there are no arguments */
if|if
condition|(
name|p
operator|&&
operator|*
name|p
condition|)
name|k
operator|=
name|mlook
argument_list|(
name|mactab
argument_list|,
name|p
argument_list|,
name|nmac
argument_list|)
expr_stmt|;
comment|/* Look up the macro name */
else|else
name|k
operator|=
operator|-
literal|1
expr_stmt|;
name|p
operator|=
literal|""
expr_stmt|;
comment|/* Initialize return value */
if|if
condition|(
name|k
operator|>=
literal|0
condition|)
block|{
comment|/* If macro found in table */
if|if
condition|(
operator|(
name|j
operator|=
name|dodo
argument_list|(
name|k
argument_list|,
name|s
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
comment|/* Go set it up (like DO cmd) */
if|if
condition|(
name|cmpush
argument_list|()
operator|>
operator|-
literal|1
condition|)
block|{
comment|/* Push command parser state */
specifier|extern
name|int
name|ifc
decl_stmt|;
name|int
name|ifcsav
init|=
name|ifc
decl_stmt|;
comment|/* Push IF condition on stack */
name|k
operator|=
name|parser
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* Call parser to execute the macro */
name|cmpop
argument_list|()
expr_stmt|;
comment|/* Pop command parser */
name|ifc
operator|=
name|ifcsav
expr_stmt|;
comment|/* Restore IF condition */
if|if
condition|(
name|k
operator|==
literal|0
condition|)
block|{
comment|/* No errors, ignore action cmds. */
name|p
operator|=
name|mrval
index|[
name|maclvl
operator|+
literal|1
index|]
expr_stmt|;
comment|/* If OK, set return value. */
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
name|p
operator|=
literal|""
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Can't push any more */
name|debug
argument_list|(
name|F100
argument_list|,
literal|"fexec pushed too deep"
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n?\\fexec() too deeply nested\n"
argument_list|)
expr_stmt|;
while|while
condition|(
name|cmpop
argument_list|()
operator|>
operator|-
literal|1
condition|)
empty_stmt|;
name|p
operator|=
literal|""
expr_stmt|;
block|}
block|}
block|}
block|}
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|argn
condition|;
name|k
operator|++
control|)
if|if
condition|(
name|bp
index|[
name|k
index|]
condition|)
name|free
argument_list|(
name|bp
index|[
name|k
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
condition|?
name|p
else|:
literal|""
operator|)
return|;
case|case
name|FN_FC
case|:
comment|/* File count. */
name|p
operator|=
name|fnval
expr_stmt|;
operator|*
name|p
operator|=
name|NUL
expr_stmt|;
if|if
condition|(
name|argn
operator|>
literal|0
condition|)
block|{
name|k
operator|=
name|zxpand
argument_list|(
name|bp
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|fnval
argument_list|,
literal|"%d"
argument_list|,
name|k
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|argn
condition|;
name|k
operator|++
control|)
if|if
condition|(
name|bp
index|[
name|k
index|]
condition|)
name|free
argument_list|(
name|bp
index|[
name|k
index|]
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|p
operator|)
return|;
case|case
name|FN_FIL
case|:
comment|/* Next file in list. */
name|p
operator|=
name|fnval
expr_stmt|;
comment|/* (no args) */
operator|*
name|p
operator|=
name|NUL
expr_stmt|;
name|znext
argument_list|(
name|p
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|argn
condition|;
name|k
operator|++
control|)
if|if
condition|(
name|bp
index|[
name|k
index|]
condition|)
name|free
argument_list|(
name|bp
index|[
name|k
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
condition|?
name|p
else|:
literal|""
operator|)
return|;
case|case
name|FN_IND
case|:
comment|/* index(arg1,arg2) */
if|if
condition|(
name|argn
operator|>
literal|1
condition|)
block|{
comment|/* Only works if we have 2 args */
name|int
name|start
decl_stmt|;
name|len1
operator|=
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|bp
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* length of string to look for */
name|len2
operator|=
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|s
operator|=
name|bp
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* length of string to look in */
if|if
condition|(
name|len1
operator|<
literal|0
condition|)
return|return
operator|(
literal|""
operator|)
return|;
comment|/* paranoia */
if|if
condition|(
name|len2
operator|<
literal|0
condition|)
return|return
operator|(
literal|""
operator|)
return|;
name|j
operator|=
name|len2
operator|-
name|len1
expr_stmt|;
comment|/* length difference */
name|start
operator|=
literal|0
expr_stmt|;
comment|/* starting position */
if|if
condition|(
name|argn
operator|>
literal|2
condition|)
block|{
if|if
condition|(
name|chknum
argument_list|(
name|bp
index|[
literal|2
index|]
argument_list|)
condition|)
block|{
name|start
operator|=
name|atoi
argument_list|(
name|bp
index|[
literal|2
index|]
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|start
operator|<
literal|0
condition|)
name|start
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|j
operator|<
literal|0
operator|||
name|start
operator|>
name|j
condition|)
block|{
comment|/* search string is longer */
name|p
operator|=
literal|"0"
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|incase
condition|)
block|{
comment|/* input case ignore? */
name|lower
argument_list|(
name|bp
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|lower
argument_list|(
name|bp
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
name|s
operator|=
name|bp
index|[
literal|1
index|]
operator|+
name|start
expr_stmt|;
comment|/* Point to beginning of target */
name|p
operator|=
literal|"0"
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
operator|(
name|j
operator|-
name|start
operator|)
condition|;
name|i
operator|++
control|)
block|{
comment|/* Now compare */
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|bp
index|[
literal|0
index|]
argument_list|,
name|s
operator|++
argument_list|,
name|len1
argument_list|)
condition|)
block|{
name|sprintf
argument_list|(
name|fnval
argument_list|,
literal|"%d"
argument_list|,
name|i
operator|+
literal|1
operator|+
name|start
argument_list|)
expr_stmt|;
name|p
operator|=
name|fnval
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
else|else
name|p
operator|=
literal|"0"
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|argn
condition|;
name|k
operator|++
control|)
if|if
condition|(
name|bp
index|[
name|k
index|]
condition|)
name|free
argument_list|(
name|bp
index|[
name|k
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
case|case
name|FN_CHR
case|:
comment|/* character(arg1) */
if|if
condition|(
name|chknum
argument_list|(
name|bp
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
comment|/* Must be numeric */
name|i
operator|=
name|atoi
argument_list|(
name|bp
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>=
literal|0
operator|&&
name|i
operator|<
literal|256
condition|)
block|{
comment|/* Must be an 8-bit value */
name|p
operator|=
name|fnval
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|i
expr_stmt|;
operator|*
name|p
operator|=
name|NUL
expr_stmt|;
name|p
operator|=
name|fnval
expr_stmt|;
block|}
else|else
name|p
operator|=
literal|""
expr_stmt|;
comment|/* Otherwise return null */
block|}
else|else
name|p
operator|=
literal|""
expr_stmt|;
comment|/* Otherwise return null */
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|argn
condition|;
name|k
operator|++
control|)
if|if
condition|(
name|bp
index|[
name|k
index|]
condition|)
name|free
argument_list|(
name|bp
index|[
name|k
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
case|case
name|FN_COD
case|:
comment|/* code(char) */
name|p
operator|=
literal|""
expr_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|bp
index|[
literal|0
index|]
argument_list|)
operator|>
literal|0
condition|)
block|{
name|p
operator|=
name|fnval
expr_stmt|;
name|i
operator|=
operator|*
name|bp
index|[
literal|0
index|]
expr_stmt|;
name|sprintf
argument_list|(
name|p
argument_list|,
literal|"%d"
argument_list|,
operator|(
name|i
operator|&
literal|0xff
operator|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|argn
condition|;
name|k
operator|++
control|)
if|if
condition|(
name|bp
index|[
name|k
index|]
condition|)
name|free
argument_list|(
name|bp
index|[
name|k
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
case|case
name|FN_LEN
case|:
comment|/* length(arg1) */
name|p
operator|=
name|fnval
expr_stmt|;
name|sprintf
argument_list|(
name|p
argument_list|,
literal|"%d"
argument_list|,
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|bp
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|argn
condition|;
name|k
operator|++
control|)
if|if
condition|(
name|bp
index|[
name|k
index|]
condition|)
name|free
argument_list|(
name|bp
index|[
name|k
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
case|case
name|FN_LOW
case|:
comment|/* lower(arg1) */
name|s
operator|=
name|bp
index|[
literal|0
index|]
expr_stmt|;
name|p
operator|=
name|fnval
expr_stmt|;
while|while
condition|(
operator|*
name|s
condition|)
block|{
if|if
condition|(
name|isupper
argument_list|(
operator|*
name|s
argument_list|)
condition|)
operator|*
name|p
operator|=
name|tolower
argument_list|(
operator|*
name|s
argument_list|)
expr_stmt|;
else|else
operator|*
name|p
operator|=
operator|*
name|s
expr_stmt|;
name|p
operator|++
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
operator|*
name|p
operator|=
name|NUL
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|argn
condition|;
name|k
operator|++
control|)
if|if
condition|(
name|bp
index|[
name|k
index|]
condition|)
name|free
argument_list|(
name|bp
index|[
name|k
index|]
argument_list|)
expr_stmt|;
name|p
operator|=
name|fnval
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
case|case
name|FN_MAX
case|:
comment|/* max(arg1,arg2) */
case|case
name|FN_MIN
case|:
comment|/* min(arg1,arg2) */
case|case
name|FN_MOD
case|:
comment|/* mod(arg1,arg2) */
if|if
condition|(
name|chknum
argument_list|(
name|bp
index|[
literal|0
index|]
argument_list|)
operator|&&
name|chknum
argument_list|(
name|bp
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|i
operator|=
name|atoi
argument_list|(
name|bp
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|j
operator|=
name|atoi
argument_list|(
name|bp
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|y
condition|)
block|{
case|case
name|FN_MAX
case|:
if|if
condition|(
name|j
operator|<
name|i
condition|)
name|j
operator|=
name|i
expr_stmt|;
break|break;
case|case
name|FN_MIN
case|:
if|if
condition|(
name|j
operator|>
name|i
condition|)
name|j
operator|=
name|i
expr_stmt|;
break|break;
case|case
name|FN_MOD
case|:
name|j
operator|=
name|i
operator|%
name|j
expr_stmt|;
break|break;
block|}
name|p
operator|=
name|fnval
expr_stmt|;
name|sprintf
argument_list|(
name|p
argument_list|,
literal|"%d"
argument_list|,
name|j
argument_list|)
expr_stmt|;
block|}
else|else
name|p
operator|=
literal|""
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|argn
condition|;
name|k
operator|++
control|)
if|if
condition|(
name|bp
index|[
name|k
index|]
condition|)
name|free
argument_list|(
name|bp
index|[
name|k
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
case|case
name|FN_SUB
case|:
comment|/* substr(arg1,arg2,arg3) */
case|case
name|FN_RIG
case|:
comment|/* right(arg1,arg2) */
if|if
condition|(
operator|(
operator|(
name|argn
operator|>
literal|1
operator|)
operator|&&
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|bp
index|[
literal|1
index|]
argument_list|)
operator|&&
operator|!
name|rdigits
argument_list|(
name|bp
index|[
literal|1
index|]
argument_list|)
operator|)
operator|||
operator|(
operator|(
name|y
operator|==
name|FN_SUB
operator|)
operator|&&
operator|(
operator|(
name|argn
operator|>
literal|2
operator|)
operator|&&
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|bp
index|[
literal|2
index|]
argument_list|)
operator|&&
operator|!
name|rdigits
argument_list|(
name|bp
index|[
literal|2
index|]
argument_list|)
operator|)
operator|)
condition|)
block|{
name|p
operator|=
literal|""
expr_stmt|;
comment|/* if either, return null */
block|}
else|else
block|{
name|int
name|lx
decl_stmt|;
name|p
operator|=
name|fnval
expr_stmt|;
comment|/* pointer to result */
name|lx
operator|=
name|strlen
argument_list|(
name|bp
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* length of arg1 */
if|if
condition|(
name|y
operator|==
name|FN_SUB
condition|)
block|{
comment|/* substring */
name|k
operator|=
operator|(
name|argn
operator|>
literal|2
operator|)
condition|?
name|atoi
argument_list|(
name|bp
index|[
literal|2
index|]
argument_list|)
else|:
literal|1023
expr_stmt|;
comment|/* length */
name|j
operator|=
operator|(
name|argn
operator|>
literal|1
operator|)
condition|?
name|atoi
argument_list|(
name|bp
index|[
literal|1
index|]
argument_list|)
else|:
literal|1
expr_stmt|;
comment|/* start pos for substr */
block|}
else|else
block|{
comment|/* right */
name|k
operator|=
operator|(
name|argn
operator|>
literal|1
operator|)
condition|?
name|atoi
argument_list|(
name|bp
index|[
literal|1
index|]
argument_list|)
else|:
name|lx
expr_stmt|;
comment|/* length */
name|j
operator|=
name|lx
operator|-
name|k
operator|+
literal|1
expr_stmt|;
comment|/* start pos for right */
if|if
condition|(
name|j
operator|<
literal|1
condition|)
name|j
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|k
operator|>
literal|0
operator|&&
name|j
operator|<=
name|lx
condition|)
block|{
comment|/* if start pos in range */
name|s
operator|=
name|bp
index|[
literal|0
index|]
operator|+
name|j
operator|-
literal|1
expr_stmt|;
comment|/* point to source string */
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|i
operator|<
name|k
operator|)
operator|&&
operator|(
operator|*
name|p
operator|++
operator|=
operator|*
name|s
operator|++
operator|)
condition|;
name|i
operator|++
control|)
empty_stmt|;
comment|/* copy */
block|}
operator|*
name|p
operator|=
name|NUL
expr_stmt|;
comment|/* terminate the result */
name|p
operator|=
name|fnval
expr_stmt|;
comment|/* and point to it. */
block|}
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|argn
condition|;
name|k
operator|++
control|)
if|if
condition|(
name|bp
index|[
name|k
index|]
condition|)
name|free
argument_list|(
name|bp
index|[
name|k
index|]
argument_list|)
expr_stmt|;
comment|/* Free temp mem */
return|return
operator|(
name|p
operator|)
return|;
case|case
name|FN_UPP
case|:
comment|/* upper(arg1) */
name|s
operator|=
name|bp
index|[
literal|0
index|]
expr_stmt|;
name|p
operator|=
name|fnval
expr_stmt|;
while|while
condition|(
operator|*
name|s
condition|)
block|{
if|if
condition|(
name|islower
argument_list|(
operator|*
name|s
argument_list|)
condition|)
operator|*
name|p
operator|=
name|toupper
argument_list|(
operator|*
name|s
argument_list|)
expr_stmt|;
else|else
operator|*
name|p
operator|=
operator|*
name|s
expr_stmt|;
name|p
operator|++
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
operator|*
name|p
operator|=
name|NUL
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|argn
condition|;
name|k
operator|++
control|)
if|if
condition|(
name|bp
index|[
name|k
index|]
condition|)
name|free
argument_list|(
name|bp
index|[
name|k
index|]
argument_list|)
expr_stmt|;
name|p
operator|=
name|fnval
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
case|case
name|FN_REP
case|:
comment|/* Repeat */
name|p
operator|=
literal|""
expr_stmt|;
comment|/* Return value */
if|if
condition|(
name|chknum
argument_list|(
name|bp
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
comment|/* Repeat count */
name|n
operator|=
name|atoi
argument_list|(
name|bp
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>
literal|0
condition|)
block|{
comment|/* Make n copies */
name|p
operator|=
name|fnval
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|k
operator|=
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|bp
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* Make sure string has some length */
if|if
condition|(
name|k
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|s
operator|=
name|bp
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|k
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|p
operator|-
name|fnval
operator|)
operator|>=
name|FNVALL
condition|)
block|{
comment|/* Protect against */
name|p
operator|=
literal|""
expr_stmt|;
comment|/* core dumps... */
break|break;
block|}
else|else
operator|*
name|p
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
block|}
block|}
operator|*
name|p
operator|=
name|NUL
expr_stmt|;
block|}
block|}
block|}
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|argn
condition|;
name|k
operator|++
control|)
if|if
condition|(
name|bp
index|[
name|k
index|]
condition|)
name|free
argument_list|(
name|bp
index|[
name|k
index|]
argument_list|)
expr_stmt|;
name|p
operator|=
name|fnval
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
ifndef|#
directive|ifndef
name|NOFRILLS
case|case
name|FN_REV
case|:
name|p
operator|=
name|fnval
expr_stmt|;
name|yystring
argument_list|(
name|bp
index|[
literal|0
index|]
argument_list|,
operator|&
name|p
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|argn
condition|;
name|k
operator|++
control|)
if|if
condition|(
name|bp
index|[
name|k
index|]
condition|)
name|free
argument_list|(
name|bp
index|[
name|k
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
endif|#
directive|endif
comment|/* NOFRILLS */
case|case
name|FN_RPA
case|:
comment|/* RPAD and LPAD */
case|case
name|FN_LPA
case|:
operator|*
name|fnval
operator|=
name|NUL
expr_stmt|;
comment|/* Return value */
if|if
condition|(
name|argn
operator|==
literal|1
condition|)
block|{
comment|/* If a number wasn't given */
name|p
operator|=
name|fnval
expr_stmt|;
comment|/* just return the original string */
name|strncpy
argument_list|(
name|p
argument_list|,
name|bp
index|[
literal|0
index|]
argument_list|,
name|FNVALL
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|chknum
argument_list|(
name|bp
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
comment|/* Repeat count */
name|char
name|pc
decl_stmt|;
name|n
operator|=
name|atoi
argument_list|(
name|bp
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>=
literal|0
condition|)
block|{
comment|/* Pad it out */
name|p
operator|=
name|fnval
expr_stmt|;
name|k
operator|=
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|bp
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* Length of string to be padded */
name|pc
operator|=
operator|(
name|argn
operator|<
literal|3
operator|)
condition|?
name|SP
else|:
operator|*
name|bp
index|[
literal|2
index|]
expr_stmt|;
comment|/* Padding character */
if|if
condition|(
name|n
operator|>
name|FNVALL
condition|)
name|n
operator|=
name|FNVALL
operator|-
literal|1
expr_stmt|;
comment|/* protect against overruns */
if|if
condition|(
name|k
operator|>
name|FNVALL
condition|)
name|k
operator|=
name|FNVALL
operator|-
literal|1
expr_stmt|;
comment|/* and silly args. */
if|if
condition|(
name|k
operator|>
name|n
condition|)
name|k
operator|=
name|n
expr_stmt|;
if|if
condition|(
name|y
operator|==
name|FN_RPA
condition|)
block|{
comment|/* RPAD */
name|strncpy
argument_list|(
name|p
argument_list|,
name|bp
index|[
literal|0
index|]
argument_list|,
name|k
argument_list|)
expr_stmt|;
name|p
operator|+=
name|k
expr_stmt|;
for|for
control|(
name|i
operator|=
name|k
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
operator|*
name|p
operator|++
operator|=
name|pc
expr_stmt|;
block|}
else|else
block|{
comment|/* LPAD */
name|n
operator|-=
name|k
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
operator|*
name|p
operator|++
operator|=
name|pc
expr_stmt|;
name|strncpy
argument_list|(
name|p
argument_list|,
name|bp
index|[
literal|0
index|]
argument_list|,
name|k
argument_list|)
expr_stmt|;
name|p
operator|+=
name|k
expr_stmt|;
block|}
operator|*
name|p
operator|=
name|NUL
expr_stmt|;
block|}
block|}
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|argn
condition|;
name|k
operator|++
control|)
if|if
condition|(
name|bp
index|[
name|k
index|]
condition|)
name|free
argument_list|(
name|bp
index|[
name|k
index|]
argument_list|)
expr_stmt|;
name|p
operator|=
name|fnval
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
default|default:
return|return
operator|(
literal|""
operator|)
return|;
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NOSPL */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NOSPL
end_ifndef

begin_function
name|char
modifier|*
comment|/* Evaluate builtin variable */
name|nvlook
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
name|long
name|z
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|x
operator|=
literal|30
expr_stmt|;
name|p
operator|=
name|vvbuf
expr_stmt|;
if|if
condition|(
name|xxstring
argument_list|(
name|s
argument_list|,
operator|&
name|p
argument_list|,
operator|&
name|x
argument_list|)
operator|<
literal|0
condition|)
block|{
name|y
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|s
operator|=
name|vvbuf
expr_stmt|;
if|if
condition|(
operator|(
name|y
operator|=
name|lookup
argument_list|(
name|vartab
argument_list|,
name|s
argument_list|,
name|nvars
argument_list|,
operator|&
name|x
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
block|}
switch|switch
condition|(
name|y
condition|)
block|{
case|case
name|VN_ARGC
case|:
comment|/* ARGC */
name|sprintf
argument_list|(
name|vvbuf
argument_list|,
literal|"%d"
argument_list|,
name|macargc
index|[
name|maclvl
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|vvbuf
operator|)
return|;
case|case
name|VN_ARGS
case|:
comment|/* ARGS */
name|sprintf
argument_list|(
name|vvbuf
argument_list|,
literal|"%d"
argument_list|,
name|xargs
argument_list|)
expr_stmt|;
return|return
operator|(
name|vvbuf
operator|)
return|;
case|case
name|VN_COUN
case|:
comment|/* COUNT */
name|sprintf
argument_list|(
name|vvbuf
argument_list|,
literal|"%d"
argument_list|,
name|count
index|[
name|cmdlvl
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|vvbuf
operator|)
return|;
case|case
name|VN_DATE
case|:
comment|/* DATE */
name|ztime
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
comment|/* Get "asctime" string */
if|if
condition|(
name|p
operator|==
name|NULL
operator|||
operator|*
name|p
operator|==
name|NUL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|vvbuf
index|[
literal|0
index|]
operator|=
name|p
index|[
literal|8
index|]
expr_stmt|;
comment|/* dd */
name|vvbuf
index|[
literal|1
index|]
operator|=
name|p
index|[
literal|9
index|]
expr_stmt|;
name|vvbuf
index|[
literal|2
index|]
operator|=
name|SP
expr_stmt|;
name|vvbuf
index|[
literal|3
index|]
operator|=
name|p
index|[
literal|4
index|]
expr_stmt|;
comment|/* mmm */
name|vvbuf
index|[
literal|4
index|]
operator|=
name|p
index|[
literal|5
index|]
expr_stmt|;
name|vvbuf
index|[
literal|5
index|]
operator|=
name|p
index|[
literal|6
index|]
expr_stmt|;
name|vvbuf
index|[
literal|6
index|]
operator|=
name|SP
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|20
init|;
name|x
operator|<
literal|24
condition|;
name|x
operator|++
control|)
comment|/* yyyy */
name|vvbuf
index|[
name|x
operator|-
literal|13
index|]
operator|=
name|p
index|[
name|x
index|]
expr_stmt|;
name|vvbuf
index|[
literal|11
index|]
operator|=
name|NUL
expr_stmt|;
return|return
operator|(
name|vvbuf
operator|)
return|;
case|case
name|VN_NDAT
case|:
comment|/* Numeric date */
name|ztime
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
comment|/* Get "asctime" string */
if|if
condition|(
name|p
operator|==
name|NULL
operator|||
operator|*
name|p
operator|==
name|NUL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
for|for
control|(
name|x
operator|=
literal|20
init|;
name|x
operator|<
literal|24
condition|;
name|x
operator|++
control|)
comment|/* yyyy */
name|vvbuf
index|[
name|x
operator|-
literal|20
index|]
operator|=
name|p
index|[
name|x
index|]
expr_stmt|;
name|vvbuf
index|[
literal|6
index|]
operator|=
operator|(
name|p
index|[
literal|8
index|]
operator|==
literal|' '
operator|)
condition|?
literal|'0'
else|:
name|p
index|[
literal|8
index|]
expr_stmt|;
name|vvbuf
index|[
literal|7
index|]
operator|=
name|p
index|[
literal|9
index|]
expr_stmt|;
comment|/* dd */
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
literal|12
condition|;
name|x
operator|++
control|)
comment|/* mm */
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|p
operator|+
literal|4
argument_list|,
name|months
index|[
name|x
index|]
argument_list|,
literal|3
argument_list|)
condition|)
break|break;
if|if
condition|(
name|x
operator|==
literal|12
condition|)
block|{
name|vvbuf
index|[
literal|4
index|]
operator|=
name|vvbuf
index|[
literal|5
index|]
operator|=
literal|'?'
expr_stmt|;
block|}
else|else
block|{
name|x
operator|++
expr_stmt|;
name|vvbuf
index|[
literal|4
index|]
operator|=
operator|(
name|x
operator|<
literal|10
operator|)
condition|?
literal|'0'
else|:
literal|'1'
expr_stmt|;
name|vvbuf
index|[
literal|5
index|]
operator|=
operator|(
name|x
operator|%
literal|10
operator|)
operator|+
literal|48
expr_stmt|;
block|}
name|vvbuf
index|[
literal|8
index|]
operator|=
name|NUL
expr_stmt|;
return|return
operator|(
name|vvbuf
operator|)
return|;
case|case
name|VN_DIRE
case|:
comment|/* DIRECTORY */
return|return
operator|(
name|zgtdir
argument_list|()
operator|)
return|;
case|case
name|VN_FILE
case|:
comment|/* filespec */
return|return
operator|(
name|fspec
operator|)
return|;
case|case
name|VN_HOST
case|:
comment|/* host name */
if|if
condition|(
operator|*
name|myhost
condition|)
block|{
comment|/* If known */
return|return
operator|(
name|myhost
operator|)
return|;
comment|/* return it. */
block|}
else|else
block|{
comment|/* Otherwise */
name|strcpy
argument_list|(
name|vvbuf
argument_list|,
literal|"unknown"
argument_list|)
expr_stmt|;
comment|/* just say "unknown" */
return|return
operator|(
name|vvbuf
operator|)
return|;
block|}
case|case
name|VN_SYST
case|:
comment|/* System type */
ifdef|#
directive|ifdef
name|UNIX
name|strcpy
argument_list|(
name|vvbuf
argument_list|,
literal|"UNIX"
argument_list|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|VMS
name|strcpy
argument_list|(
name|vvbuf
argument_list|,
literal|"VMS"
argument_list|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|OSK
name|strcpy
argument_list|(
name|vvbuf
argument_list|,
literal|"OS9/68K"
argument_list|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|AMIGA
name|strcpy
argument_list|(
name|vvbuf
argument_list|,
literal|"Amiga"
argument_list|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|MAC
name|strcpy
argument_list|(
name|vvbuf
argument_list|,
literal|"Macintosh"
argument_list|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|OS2
name|strcpy
argument_list|(
name|vvbuf
argument_list|,
literal|"OS/2"
argument_list|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|datageneral
name|strcpy
argument_list|(
name|vvbuf
argument_list|,
literal|"AOS/VS"
argument_list|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|GEMDOS
name|strcpy
argument_list|(
name|vvbuf
argument_list|,
literal|"Atari_ST"
argument_list|)
expr_stmt|;
else|#
directive|else
name|strcpy
argument_list|(
name|vvbuf
argument_list|,
literal|"unknown"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* GEMDOS */
endif|#
directive|endif
comment|/* datageneral */
endif|#
directive|endif
comment|/* OS2 */
endif|#
directive|endif
comment|/* MAC */
endif|#
directive|endif
comment|/* AMIGA */
endif|#
directive|endif
comment|/* OSK */
endif|#
directive|endif
comment|/* VMS */
endif|#
directive|endif
comment|/* UNIX */
return|return
operator|(
name|vvbuf
operator|)
return|;
case|case
name|VN_SYSV
case|:
comment|/* System herald */
for|for
control|(
name|x
operator|=
name|y
operator|=
literal|0
init|;
name|x
operator|<
name|VVBUFL
condition|;
name|x
operator|++
control|)
block|{
if|if
condition|(
name|ckxsys
index|[
name|x
index|]
operator|==
name|SP
operator|&&
name|y
operator|==
literal|0
condition|)
continue|continue;
name|vvbuf
index|[
name|y
operator|++
index|]
operator|=
operator|(
name|ckxsys
index|[
name|x
index|]
operator|==
name|SP
operator|)
condition|?
literal|'_'
else|:
name|ckxsys
index|[
name|x
index|]
expr_stmt|;
block|}
name|vvbuf
index|[
name|y
index|]
operator|=
name|NUL
expr_stmt|;
return|return
operator|(
name|vvbuf
operator|)
return|;
case|case
name|VN_TIME
case|:
comment|/* TIME. Assumes that ztime returns */
name|ztime
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
comment|/* "Thu Feb  8 12:00:00 1990" */
if|if
condition|(
name|p
operator|==
name|NULL
operator|||
operator|*
name|p
operator|==
name|NUL
condition|)
comment|/* like asctime()! */
return|return
operator|(
name|NULL
operator|)
return|;
for|for
control|(
name|x
operator|=
literal|11
init|;
name|x
operator|<
literal|19
condition|;
name|x
operator|++
control|)
comment|/* copy hh:mm:ss */
name|vvbuf
index|[
name|x
operator|-
literal|11
index|]
operator|=
name|p
index|[
name|x
index|]
expr_stmt|;
comment|/* to vvbuf */
name|vvbuf
index|[
literal|8
index|]
operator|=
name|NUL
expr_stmt|;
comment|/* terminate */
return|return
operator|(
name|vvbuf
operator|)
return|;
comment|/* and return it */
case|case
name|VN_NTIM
case|:
comment|/* Numeric time */
name|ztime
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
comment|/* "Thu Feb  8 12:00:00 1990" */
if|if
condition|(
name|p
operator|==
name|NULL
operator|||
operator|*
name|p
operator|==
name|NUL
condition|)
comment|/* like asctime()! */
return|return
operator|(
name|NULL
operator|)
return|;
name|z
operator|=
name|atol
argument_list|(
name|p
operator|+
literal|11
argument_list|)
operator|*
literal|3600L
operator|+
name|atol
argument_list|(
name|p
operator|+
literal|14
argument_list|)
operator|*
literal|60L
operator|+
name|atol
argument_list|(
name|p
operator|+
literal|17
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|vvbuf
argument_list|,
literal|"%ld"
argument_list|,
name|z
argument_list|)
expr_stmt|;
return|return
operator|(
name|vvbuf
operator|)
return|;
ifdef|#
directive|ifdef
name|UNIX
case|case
name|VN_TTYF
case|:
comment|/* TTY file descriptor */
name|sprintf
argument_list|(
name|vvbuf
argument_list|,
literal|"%d"
argument_list|,
name|ttyfd
argument_list|)
expr_stmt|;
return|return
operator|(
name|vvbuf
operator|)
return|;
else|#
directive|else
ifdef|#
directive|ifdef
name|OS2
case|case
name|VN_TTYF
case|:
comment|/* TTY file descriptor */
name|sprintf
argument_list|(
name|vvbuf
argument_list|,
literal|"%d"
argument_list|,
name|ttyfd
argument_list|)
expr_stmt|;
return|return
operator|(
name|vvbuf
operator|)
return|;
endif|#
directive|endif
comment|/* OS2 */
endif|#
directive|endif
comment|/* UNIX */
case|case
name|VN_VERS
case|:
comment|/* Numeric Kermit version number */
name|sprintf
argument_list|(
name|vvbuf
argument_list|,
literal|"%ld"
argument_list|,
name|vernum
argument_list|)
expr_stmt|;
return|return
operator|(
name|vvbuf
operator|)
return|;
case|case
name|VN_HOME
case|:
comment|/* Home directory */
ifdef|#
directive|ifdef
name|UNIX
name|sprintf
argument_list|(
name|vvbuf
argument_list|,
literal|"%s/"
argument_list|,
name|zhome
argument_list|()
argument_list|)
expr_stmt|;
return|return
operator|(
name|vvbuf
operator|)
return|;
else|#
directive|else
return|return
operator|(
name|zhome
argument_list|()
operator|)
return|;
endif|#
directive|endif
comment|/* UNIX */
case|case
name|VN_IBUF
case|:
comment|/* INPUT buffer */
return|return
operator|(
name|inpbuf
operator|)
return|;
case|case
name|VN_ICHR
case|:
comment|/* INPUT character */
name|inchar
index|[
literal|1
index|]
operator|=
name|NUL
expr_stmt|;
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|inchar
operator|)
return|;
case|case
name|VN_ICNT
case|:
comment|/* INPUT character count */
name|sprintf
argument_list|(
name|vvbuf
argument_list|,
literal|"%d"
argument_list|,
name|incount
argument_list|)
expr_stmt|;
return|return
operator|(
name|vvbuf
operator|)
return|;
case|case
name|VN_SPEE
case|:
block|{
comment|/* Transmission SPEED */
name|long
name|t
decl_stmt|;
name|t
operator|=
name|ttgspd
argument_list|()
expr_stmt|;
if|if
condition|(
name|t
operator|<
literal|0L
condition|)
name|sprintf
argument_list|(
name|vvbuf
argument_list|,
literal|"unknown"
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|vvbuf
argument_list|,
literal|"%ld"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|vvbuf
operator|)
return|;
block|}
case|case
name|VN_SUCC
case|:
comment|/* SUCCESS flag */
name|sprintf
argument_list|(
name|vvbuf
argument_list|,
literal|"%d"
argument_list|,
operator|(
name|success
operator|==
literal|0
operator|)
condition|?
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|vvbuf
operator|)
return|;
case|case
name|VN_LINE
case|:
comment|/* LINE */
name|p
operator|=
operator|(
name|char
operator|*
operator|)
name|ttname
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
case|case
name|VN_PROG
case|:
comment|/* Program name */
ifdef|#
directive|ifdef
name|MAC
return|return
operator|(
literal|"Mac-Kermit"
operator|)
return|;
else|#
directive|else
return|return
operator|(
literal|"C-Kermit"
operator|)
return|;
endif|#
directive|endif
comment|/* MAC */
case|case
name|VN_RET
case|:
comment|/* Value of most recent RETURN */
name|p
operator|=
name|mrval
index|[
name|maclvl
operator|+
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
name|p
operator|=
literal|""
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
case|case
name|VN_FFC
case|:
comment|/* Size of most recent file */
name|sprintf
argument_list|(
name|vvbuf
argument_list|,
literal|"%ld"
argument_list|,
name|ffc
argument_list|)
expr_stmt|;
return|return
operator|(
name|vvbuf
operator|)
return|;
case|case
name|VN_TFC
case|:
comment|/* Size of most recent file group */
name|sprintf
argument_list|(
name|vvbuf
argument_list|,
literal|"%ld"
argument_list|,
name|tfc
argument_list|)
expr_stmt|;
return|return
operator|(
name|vvbuf
operator|)
return|;
case|case
name|VN_CPU
case|:
comment|/* CPU type */
ifdef|#
directive|ifdef
name|CKCPU
return|return
operator|(
name|CKCPU
operator|)
return|;
else|#
directive|else
return|return
operator|(
literal|"unknown"
operator|)
return|;
endif|#
directive|endif
comment|/* CKCPU */
case|case
name|VN_CMDL
case|:
comment|/* Command level */
name|sprintf
argument_list|(
name|vvbuf
argument_list|,
literal|"%d"
argument_list|,
name|cmdlvl
argument_list|)
expr_stmt|;
return|return
operator|(
name|vvbuf
operator|)
return|;
case|case
name|VN_DAY
case|:
comment|/* Day of week */
case|case
name|VN_NDAY
case|:
comment|/*   Depends on ztime() returning ENGLISH asctime()-format string!   asctime() format is: "Thu Feb  8 12:00:00 1990".   Needs updating to accommodate non-English asctime() strings. */
name|ztime
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
operator|&&
operator|*
name|p
operator|!=
name|NUL
condition|)
block|{
comment|/* ztime() succeeded. */
if|if
condition|(
name|y
operator|==
name|VN_DAY
condition|)
block|{
comment|/* String day. */
name|strncpy
argument_list|(
name|vvbuf
argument_list|,
name|p
argument_list|,
literal|3
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Numeric day. */
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
literal|7
condition|;
name|x
operator|++
control|)
comment|/* Look up day string in table */
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|p
argument_list|,
name|wkdays
index|[
name|x
index|]
argument_list|,
literal|3
argument_list|)
condition|)
break|break;
if|if
condition|(
name|x
operator|>
literal|6
condition|)
name|x
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Not found */
name|sprintf
argument_list|(
name|vvbuf
argument_list|,
literal|"%d"
argument_list|,
name|x
argument_list|)
expr_stmt|;
comment|/* Return the number */
block|}
block|}
else|else
name|vvbuf
index|[
literal|0
index|]
operator|=
name|NUL
expr_stmt|;
comment|/* ztime() failed. */
return|return
operator|(
name|vvbuf
operator|)
return|;
comment|/* Return what we got. */
case|case
name|VN_LCL
case|:
comment|/* Local (vs remote) mode */
name|strcpy
argument_list|(
name|vvbuf
argument_list|,
name|local
condition|?
literal|"1"
else|:
literal|"0"
argument_list|)
expr_stmt|;
return|return
operator|(
name|vvbuf
operator|)
return|;
case|case
name|VN_CMDS
case|:
comment|/* Command source */
if|if
condition|(
name|cmdstk
index|[
name|cmdlvl
index|]
operator|.
name|src
operator|==
name|CMD_KB
condition|)
name|strcpy
argument_list|(
name|vvbuf
argument_list|,
literal|"prompt"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|cmdstk
index|[
name|cmdlvl
index|]
operator|.
name|src
operator|==
name|CMD_MD
condition|)
name|strcpy
argument_list|(
name|vvbuf
argument_list|,
literal|"macro"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|cmdstk
index|[
name|cmdlvl
index|]
operator|.
name|src
operator|==
name|CMD_TF
condition|)
name|strcpy
argument_list|(
name|vvbuf
argument_list|,
literal|"file"
argument_list|)
expr_stmt|;
else|else
name|strcpy
argument_list|(
name|vvbuf
argument_list|,
literal|"unknown"
argument_list|)
expr_stmt|;
return|return
operator|(
name|vvbuf
operator|)
return|;
case|case
name|VN_CMDF
case|:
comment|/* Current command file name */
return|return
operator|(
name|tfnam
index|[
name|tlevel
index|]
condition|?
name|tfnam
index|[
name|tlevel
index|]
else|:
literal|""
operator|)
return|;
case|case
name|VN_MAC
case|:
comment|/* Current macro name */
return|return
operator|(
operator|(
name|maclvl
operator|>
operator|-
literal|1
operator|)
condition|?
name|m_arg
index|[
name|maclvl
index|]
index|[
literal|0
index|]
else|:
literal|""
operator|)
return|;
case|case
name|VN_EXIT
case|:
name|sprintf
argument_list|(
name|vvbuf
argument_list|,
literal|"%d"
argument_list|,
name|xitsta
argument_list|)
expr_stmt|;
return|return
operator|(
name|vvbuf
operator|)
return|;
default|default:
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NOSPL */
end_comment

begin_comment
comment|/*   X X S T R I N G  --  Expand variables and backslash codes.      int xxtstring(s,&s2,&n);    Expands \ escapes via recursive descent.   Argument s is a pointer to string to expand (source).   Argument s2 is the address of where to put result (destination).   Argument n is the length of the destination string (to prevent overruns).   Returns -1 on failure, 0 on success,     with destination string null-terminated and s2 pointing to the     terminating null, so that subsequent characters can be added. */
end_comment

begin_define
define|#
directive|define
name|XXDEPLIM
value|100
end_define

begin_comment
comment|/* Recursion depth limit */
end_comment

begin_function
name|int
name|xxstring
parameter_list|(
name|s
parameter_list|,
name|s2
parameter_list|,
name|n
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
name|char
modifier|*
modifier|*
name|s2
decl_stmt|;
name|int
modifier|*
name|n
decl_stmt|;
block|{
name|int
name|x
decl_stmt|,
comment|/* Current character */
name|y
decl_stmt|,
comment|/* Worker */
name|pp
decl_stmt|,
comment|/* Paren level */
name|argn
decl_stmt|,
comment|/* Function argument counter */
name|n2
decl_stmt|,
comment|/* Local copy of n */
name|d
decl_stmt|,
comment|/* Array dimension */
name|vbi
decl_stmt|,
comment|/* Variable id (integer form) */
name|argl
decl_stmt|;
comment|/* String argument length */
name|char
name|vb
decl_stmt|,
comment|/* Variable id (char form) */
modifier|*
name|vp
decl_stmt|,
comment|/* Pointer to variable definition */
modifier|*
name|new
decl_stmt|,
comment|/* Local pointer to target string */
modifier|*
name|p
decl_stmt|,
comment|/* Worker */
modifier|*
name|q
decl_stmt|;
comment|/* Worker */
name|char
modifier|*
name|r
init|=
operator|(
name|char
operator|*
operator|)
literal|0
decl_stmt|;
comment|/* For holding function args */
name|char
modifier|*
name|r2
init|=
operator|(
name|char
operator|*
operator|)
literal|0
decl_stmt|;
ifndef|#
directive|ifndef
name|NOSPL
name|char
name|vnambuf
index|[
name|VNAML
index|]
decl_stmt|;
comment|/* Buffer for variable/function name */
name|char
modifier|*
name|argp
index|[
name|FNARGS
index|]
decl_stmt|;
comment|/* Pointers to function args */
endif|#
directive|endif
comment|/* NOSPL */
specifier|static
name|int
name|depth
init|=
literal|0
decl_stmt|;
comment|/* Call depth, avoid overflow */
name|n2
operator|=
operator|*
name|n
expr_stmt|;
comment|/* Make local copies of args */
name|new
operator|=
operator|*
name|s2
expr_stmt|;
comment|/* for one less level of indirection */
name|depth
operator|++
expr_stmt|;
comment|/* Sink to a new depth */
if|if
condition|(
name|depth
operator|>
name|XXDEPLIM
condition|)
block|{
comment|/* Too deep? */
name|printf
argument_list|(
literal|"?definition is circular or too deep\n"
argument_list|)
expr_stmt|;
name|depth
operator|=
literal|0
expr_stmt|;
operator|*
name|new
operator|=
name|NUL
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|s
operator|||
operator|!
name|new
condition|)
block|{
comment|/* Watch out for null pointers */
name|depth
operator|=
literal|0
expr_stmt|;
operator|*
name|new
operator|=
name|NUL
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|argl
operator|=
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* Get length of source string */
name|debug
argument_list|(
name|F111
argument_list|,
literal|"xxstring"
argument_list|,
name|s
argument_list|,
name|argl
argument_list|)
expr_stmt|;
if|if
condition|(
name|argl
operator|<
literal|0
condition|)
block|{
comment|/* Watch out for garbage */
name|depth
operator|=
literal|0
expr_stmt|;
operator|*
name|new
operator|=
name|NUL
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
while|while
condition|(
name|x
operator|=
operator|*
name|s
condition|)
block|{
comment|/* Loop for all characters */
if|if
condition|(
name|x
operator|!=
name|CMDQ
condition|)
block|{
comment|/* Is it the command-quote char? */
operator|*
name|new
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
comment|/* No, normal char, just copy */
if|if
condition|(
name|n2
operator|--
operator|<
literal|0
condition|)
block|{
comment|/* and count it, careful of overflow */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
continue|continue;
block|}
comment|/* We have the command-quote character. */
name|x
operator|=
operator|*
operator|(
name|s
operator|+
literal|1
operator|)
expr_stmt|;
comment|/* Get the following character. */
switch|switch
condition|(
name|x
condition|)
block|{
comment|/* Act according to variable type */
ifndef|#
directive|ifndef
name|NOSPL
case|case
literal|'%'
case|:
comment|/* Variable */
name|s
operator|+=
literal|2
expr_stmt|;
comment|/* Get the letter or digit */
name|vb
operator|=
operator|*
name|s
operator|++
expr_stmt|;
comment|/* and move source pointer past it */
name|vp
operator|=
name|NULL
expr_stmt|;
comment|/* Assume definition is empty */
if|if
condition|(
name|vb
operator|>=
literal|'0'
operator|&&
name|vb
operator|<=
literal|'9'
condition|)
block|{
comment|/* Digit for macro arg */
if|if
condition|(
name|maclvl
operator|<
literal|0
condition|)
comment|/* Digit variables are global */
name|vp
operator|=
name|g_var
index|[
name|vb
index|]
expr_stmt|;
comment|/* if no macro is active */
else|else
comment|/* otherwise */
name|vp
operator|=
name|m_arg
index|[
name|maclvl
index|]
index|[
name|vb
operator|-
literal|'0'
index|]
expr_stmt|;
comment|/* they're on the stack */
block|}
else|else
block|{
if|if
condition|(
name|isupper
argument_list|(
name|vb
argument_list|)
condition|)
name|vb
operator|-=
operator|(
literal|'a'
operator|-
literal|'A'
operator|)
expr_stmt|;
name|vp
operator|=
name|g_var
index|[
name|vb
index|]
expr_stmt|;
comment|/* Letter for global variable */
block|}
if|if
condition|(
name|vp
condition|)
block|{
comment|/* If definition not empty */
if|if
condition|(
name|xxstring
argument_list|(
name|vp
argument_list|,
operator|&
name|new
argument_list|,
operator|&
name|n2
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* call self to evaluate it */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* Pass along failure */
block|}
block|}
break|break;
case|case
literal|'&'
case|:
comment|/* An array reference */
if|if
condition|(
name|arraynam
argument_list|(
name|s
argument_list|,
operator|&
name|vbi
argument_list|,
operator|&
name|d
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* Get name and subscript */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|pp
operator|=
literal|0
expr_stmt|;
comment|/* Bracket counter */
while|while
condition|(
operator|*
name|s
condition|)
block|{
comment|/* Advance source pointer */
if|if
condition|(
operator|*
name|s
operator|==
literal|'['
condition|)
name|pp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|']'
operator|&&
operator|--
name|pp
operator|==
literal|0
condition|)
break|break;
name|s
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|s
operator|==
literal|']'
condition|)
name|s
operator|++
expr_stmt|;
comment|/* past the closing bracket. */
if|if
condition|(
name|chkarray
argument_list|(
name|vbi
argument_list|,
name|d
argument_list|)
operator|>
literal|0
condition|)
block|{
comment|/* Array is declared? */
name|vbi
operator|-=
literal|96
expr_stmt|;
comment|/* Convert name to index */
if|if
condition|(
name|a_dim
index|[
name|vbi
index|]
operator|>=
name|d
condition|)
block|{
comment|/* If subscript in range */
name|char
modifier|*
modifier|*
name|ap
decl_stmt|;
name|ap
operator|=
name|a_ptr
index|[
name|vbi
index|]
expr_stmt|;
comment|/* get data pointer */
if|if
condition|(
name|ap
condition|)
block|{
comment|/* and if there is one */
if|if
condition|(
name|ap
index|[
name|d
index|]
condition|)
block|{
comment|/* If definition not empty */
if|if
condition|(
name|xxstring
argument_list|(
name|ap
index|[
name|d
index|]
argument_list|,
operator|&
name|new
argument_list|,
operator|&
name|n2
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* evaluate */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* Pass along failure */
block|}
block|}
block|}
block|}
block|}
break|break;
case|case
literal|'F'
case|:
comment|/* A builtin function */
case|case
literal|'f'
case|:
name|q
operator|=
name|vnambuf
expr_stmt|;
comment|/* Copy the name */
name|y
operator|=
literal|0
expr_stmt|;
comment|/* into a separate buffer */
name|s
operator|+=
literal|2
expr_stmt|;
comment|/* point past 'F' */
while|while
condition|(
name|y
operator|++
operator|<
name|VNAML
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|'('
condition|)
block|{
name|s
operator|++
expr_stmt|;
break|break;
block|}
comment|/* Look for open paren */
if|if
condition|(
operator|(
operator|*
name|q
operator|=
operator|*
name|s
operator|)
operator|==
name|NUL
condition|)
break|break;
comment|/* or end of string */
name|s
operator|++
expr_stmt|;
name|q
operator|++
expr_stmt|;
block|}
operator|*
name|q
operator|=
name|NUL
expr_stmt|;
comment|/* Terminate function name */
if|if
condition|(
name|y
operator|>=
name|VNAML
condition|)
block|{
comment|/* Handle pathological case */
while|while
condition|(
operator|*
name|s
operator|&&
operator|(
operator|*
name|s
operator|!=
literal|'('
operator|)
condition|)
comment|/* of very long string entered */
name|s
operator|++
expr_stmt|;
comment|/* as function name. */
if|if
condition|(
operator|*
name|s
operator|==
literal|')'
condition|)
name|s
operator|++
expr_stmt|;
comment|/* Skip past it. */
block|}
name|r
operator|=
name|r2
operator|=
name|malloc
argument_list|(
name|argl
operator|+
literal|2
argument_list|)
expr_stmt|;
comment|/* And make a place to copy args */
name|debug
argument_list|(
name|F101
argument_list|,
literal|"xxstring r2"
argument_list|,
literal|""
argument_list|,
name|r2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|r2
condition|)
block|{
comment|/* Watch out for malloc failure */
name|depth
operator|=
literal|0
expr_stmt|;
operator|*
name|new
operator|=
name|NUL
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|argn
operator|=
literal|0
expr_stmt|;
comment|/* Argument counter */
name|argp
index|[
name|argn
operator|++
index|]
operator|=
name|r
expr_stmt|;
comment|/* Point to first argument */
name|y
operator|=
literal|0
expr_stmt|;
comment|/* Completion flag */
name|pp
operator|=
literal|1
expr_stmt|;
comment|/* Paren level (already have one). */
while|while
condition|(
operator|*
name|r
operator|=
operator|*
name|s
condition|)
block|{
comment|/* Copy each argument, char by char. */
if|if
condition|(
operator|*
name|r
operator|==
literal|'('
condition|)
name|pp
operator|++
expr_stmt|;
comment|/* Count an opening paren. */
if|if
condition|(
operator|*
name|r
operator|==
literal|')'
condition|)
block|{
comment|/* Closing paren, count it. */
if|if
condition|(
operator|--
name|pp
operator|==
literal|0
condition|)
block|{
comment|/* Final one? */
operator|*
name|r
operator|=
name|NUL
expr_stmt|;
comment|/* Make it a terminating null */
name|s
operator|++
expr_stmt|;
name|y
operator|=
literal|1
expr_stmt|;
comment|/* Flag we've got all the args */
break|break;
block|}
block|}
if|if
condition|(
operator|*
name|r
operator|==
literal|','
condition|)
block|{
comment|/* Comma */
if|if
condition|(
name|pp
operator|==
literal|1
condition|)
block|{
comment|/* If not within ()'s, */
operator|*
name|r
operator|=
name|NUL
expr_stmt|;
comment|/* new arg, skip past it, */
name|argp
index|[
name|argn
operator|++
index|]
operator|=
name|r
operator|+
literal|1
expr_stmt|;
comment|/* point to new arg. */
if|if
condition|(
name|argn
operator|==
name|FNARGS
condition|)
comment|/* Too many args */
break|break;
block|}
comment|/* Otherwise just skip past  */
block|}
name|s
operator|++
expr_stmt|;
name|r
operator|++
expr_stmt|;
comment|/* Advance pointers */
block|}
name|debug
argument_list|(
name|F110
argument_list|,
literal|"xxstring function name"
argument_list|,
name|vnambuf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|y
condition|)
block|{
comment|/* If we didn't find closing paren */
name|debug
argument_list|(
name|F101
argument_list|,
literal|"xxstring r2 before free"
argument_list|,
literal|""
argument_list|,
name|r2
argument_list|)
expr_stmt|;
if|if
condition|(
name|r2
condition|)
name|free
argument_list|(
name|r2
argument_list|)
expr_stmt|;
comment|/* free the temporary storage */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* and return failure. */
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|deblog
condition|)
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|argn
condition|;
name|y
operator|++
control|)
name|debug
argument_list|(
name|F111
argument_list|,
literal|"xxstring function arg"
argument_list|,
name|argp
index|[
name|y
index|]
argument_list|,
name|y
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
name|vp
operator|=
name|fneval
argument_list|(
name|vnambuf
argument_list|,
name|argp
argument_list|,
name|argn
argument_list|)
expr_stmt|;
comment|/* Evaluate the function. */
if|if
condition|(
name|vp
condition|)
block|{
comment|/* If definition not empty */
while|while
condition|(
operator|*
name|new
operator|++
operator|=
operator|*
name|vp
operator|++
condition|)
comment|/* copy it to output string */
if|if
condition|(
name|n2
operator|--
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* mindful of overflow */
name|new
operator|--
expr_stmt|;
comment|/* Back up over terminating null */
name|n2
operator|++
expr_stmt|;
comment|/* to allow for further deposits. */
block|}
if|if
condition|(
name|r2
condition|)
block|{
name|debug
argument_list|(
name|F101
argument_list|,
literal|"xxstring freeing r2"
argument_list|,
literal|""
argument_list|,
name|r2
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|r2
argument_list|)
expr_stmt|;
comment|/* Now free the temporary storage */
name|r2
operator|=
name|NULL
expr_stmt|;
block|}
break|break;
case|case
literal|'$'
case|:
comment|/* An environment variable */
case|case
literal|'V'
case|:
comment|/* Or a named builtin variable. */
case|case
literal|'v'
case|:
case|case
literal|'M'
case|:
comment|/* Or a macro = long variable */
case|case
literal|'m'
case|:
name|p
operator|=
name|s
operator|+
literal|2
expr_stmt|;
comment|/* $/V/M must be followed by (name) */
if|if
condition|(
operator|*
name|p
operator|!=
literal|'('
condition|)
block|{
comment|/* as in \$(HOME) or \V(count) */
operator|*
name|new
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
comment|/* If not, just copy it */
if|if
condition|(
name|n2
operator|--
operator|<
literal|0
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
break|break;
block|}
name|p
operator|++
expr_stmt|;
comment|/* Point to 1st char of name */
name|q
operator|=
name|vnambuf
expr_stmt|;
comment|/* Copy the name */
name|y
operator|=
literal|0
expr_stmt|;
comment|/* into a separate buffer */
while|while
condition|(
name|y
operator|++
operator|<
name|VNAML
condition|)
block|{
comment|/* Watch out for name too long */
if|if
condition|(
operator|*
name|p
operator|==
literal|')'
condition|)
block|{
comment|/* Name properly terminated with ')' */
name|p
operator|++
expr_stmt|;
comment|/* Move source pointer past ')' */
break|break;
block|}
if|if
condition|(
operator|(
operator|*
name|q
operator|=
operator|*
name|p
operator|)
operator|==
name|NUL
condition|)
comment|/* String ends before ')' */
break|break;
name|p
operator|++
expr_stmt|;
name|q
operator|++
expr_stmt|;
comment|/* Advance pointers */
block|}
operator|*
name|q
operator|=
name|NUL
expr_stmt|;
comment|/* Terminate the variable name */
if|if
condition|(
name|y
operator|>=
name|VNAML
condition|)
block|{
comment|/* Handle pathological case */
while|while
condition|(
operator|*
name|p
operator|&&
operator|(
operator|*
name|p
operator|!=
literal|')'
operator|)
condition|)
comment|/* of very long string entered */
name|p
operator|++
expr_stmt|;
comment|/* as variable name. */
if|if
condition|(
operator|*
name|p
operator|==
literal|')'
condition|)
name|p
operator|++
expr_stmt|;
comment|/* Skip ahead to the end of it. */
block|}
name|s
operator|=
name|p
expr_stmt|;
comment|/* Adjust global source pointer */
name|p
operator|=
name|malloc
argument_list|(
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|vnambuf
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* Make temporary space */
if|if
condition|(
name|p
condition|)
block|{
comment|/* If we got the space */
name|vp
operator|=
name|vnambuf
expr_stmt|;
comment|/* Point to original */
name|strcpy
argument_list|(
name|p
argument_list|,
name|vp
argument_list|)
expr_stmt|;
comment|/* Make a copy of it */
name|y
operator|=
name|VNAML
expr_stmt|;
comment|/* Length of name buffer */
name|xxstring
argument_list|(
name|p
argument_list|,
operator|&
name|vp
argument_list|,
operator|&
name|y
argument_list|)
expr_stmt|;
comment|/* Evaluate the copy */
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* Free the temporary space */
block|}
name|debug
argument_list|(
name|F110
argument_list|,
literal|"xxstring vname"
argument_list|,
name|vnambuf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|==
literal|'$'
condition|)
block|{
comment|/* Look up its value */
name|vp
operator|=
name|getenv
argument_list|(
name|vnambuf
argument_list|)
expr_stmt|;
comment|/* This way for environment variable */
block|}
elseif|else
if|if
condition|(
name|x
operator|==
literal|'m'
operator|||
name|x
operator|==
literal|'M'
condition|)
block|{
comment|/* or this way for macro */
name|y
operator|=
name|mlook
argument_list|(
name|mactab
argument_list|,
name|vnambuf
argument_list|,
name|nmac
argument_list|)
expr_stmt|;
comment|/* contents (= long variable */
name|vp
operator|=
operator|(
name|y
operator|>
operator|-
literal|1
operator|)
condition|?
name|mactab
index|[
name|y
index|]
operator|.
name|mval
else|:
literal|""
expr_stmt|;
comment|/* name)... */
block|}
else|else
block|{
comment|/*  or */
name|vp
operator|=
name|nvlook
argument_list|(
name|vnambuf
argument_list|)
expr_stmt|;
comment|/* this way for builtin variable */
block|}
if|if
condition|(
name|vp
condition|)
block|{
comment|/* If definition not empty */
while|while
condition|(
operator|*
name|new
operator|++
operator|=
operator|*
name|vp
operator|++
condition|)
comment|/* copy it to output string. */
if|if
condition|(
name|n2
operator|--
operator|<
literal|0
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|new
operator|--
expr_stmt|;
comment|/* Back up over terminating null */
name|n2
operator|++
expr_stmt|;
comment|/* to allow for further deposits. */
block|}
break|break;
endif|#
directive|endif
comment|/* NOSPL	*/
comment|/* Handle \nnn even if NOSPL. */
default|default:
comment|/* Maybe it's a backslash code */
name|y
operator|=
name|xxesc
argument_list|(
operator|&
name|s
argument_list|)
expr_stmt|;
comment|/* Go interpret it */
if|if
condition|(
name|y
operator|<
literal|0
condition|)
block|{
comment|/* Upon failure */
operator|*
name|new
operator|++
operator|=
name|x
expr_stmt|;
comment|/* Just quote the next character */
name|s
operator|+=
literal|2
expr_stmt|;
comment|/* Move past the pair */
name|n2
operator|-=
literal|2
expr_stmt|;
if|if
condition|(
name|n2
operator|<
literal|0
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
continue|continue;
comment|/* and go back for more */
block|}
else|else
block|{
operator|*
name|new
operator|++
operator|=
name|y
expr_stmt|;
comment|/* else deposit interpreted value */
if|if
condition|(
name|n2
operator|--
operator|<
literal|0
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
block|}
block|}
operator|*
name|new
operator|=
name|NUL
expr_stmt|;
comment|/* Terminate the new string */
name|depth
operator|--
expr_stmt|;
comment|/* Adjust stack depth gauge */
operator|*
name|s2
operator|=
name|new
expr_stmt|;
comment|/* Copy results back into */
operator|*
name|n
operator|=
name|n2
expr_stmt|;
comment|/* the argument addresses */
return|return
operator|(
literal|0
operator|)
return|;
comment|/* and return. */
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NOICP */
end_comment

end_unit

