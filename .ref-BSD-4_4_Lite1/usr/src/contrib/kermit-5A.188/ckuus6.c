begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|NOICP
end_ifndef

begin_comment
comment|/*  C K U U S 6 --  "User Interface" for Unix Kermit (Part 6)  */
end_comment

begin_comment
comment|/*   Author: Frank da Cruz (fdc@columbia.edu, FDCCU@CUVMA.BITNET),   Columbia University Center for Computing Activities.   First released January 1985.   Copyright (C) 1985, 1992, Trustees of Columbia University in the City of New   York.  Permission is granted to any individual or institution to use this   software as long as it is not sold for profit.  This copyright notice must be   retained.  This software may not be included in commercial products without   written permission of Columbia University. */
end_comment

begin_comment
comment|/* Includes */
end_comment

begin_include
include|#
directive|include
file|"ckcdeb.h"
end_include

begin_include
include|#
directive|include
file|"ckcasc.h"
end_include

begin_include
include|#
directive|include
file|"ckcker.h"
end_include

begin_include
include|#
directive|include
file|"ckuusr.h"
end_include

begin_include
include|#
directive|include
file|"ckcxla.h"
end_include

begin_include
include|#
directive|include
file|"ckcnet.h"
end_include

begin_comment
comment|/* Network symbols */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|datageneral
end_ifdef

begin_define
define|#
directive|define
name|fgets
parameter_list|(
name|stringbuf
parameter_list|,
name|max
parameter_list|,
name|fd
parameter_list|)
value|dg_fgets(stringbuf,max,fd)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* datageneral */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|MAC
end_ifdef

begin_comment
comment|/* internal MAC file routines */
end_comment

begin_define
define|#
directive|define
name|feof
value|mac_feof
end_define

begin_define
define|#
directive|define
name|rewind
value|mac_rewind
end_define

begin_define
define|#
directive|define
name|fgets
value|mac_fgets
end_define

begin_define
define|#
directive|define
name|fopen
value|mac_fopen
end_define

begin_define
define|#
directive|define
name|fclose
value|mac_fclose
end_define

begin_function_decl
name|int
name|mac_feof
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|mac_rewind
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|mac_fgets
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|FILE
modifier|*
name|mac_fopen
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|mac_fclose
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MAC */
end_comment

begin_comment
comment|/* External Kermit Variables, see ckmain.c for description. */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|size
decl_stmt|,
name|rpsiz
decl_stmt|,
name|urpsiz
decl_stmt|,
name|local
decl_stmt|,
name|stdinf
decl_stmt|,
name|sndsrc
decl_stmt|,
name|xitsta
decl_stmt|,
name|displa
decl_stmt|,
name|binary
decl_stmt|,
name|parity
decl_stmt|,
name|escape
decl_stmt|,
name|xargc
decl_stmt|,
name|flow
decl_stmt|,
name|turn
decl_stmt|,
name|duplex
decl_stmt|,
name|nfils
decl_stmt|,
name|ckxech
decl_stmt|,
name|pktlog
decl_stmt|,
name|seslog
decl_stmt|,
name|tralog
decl_stmt|,
name|stdouf
decl_stmt|,
name|turnch
decl_stmt|,
name|dfloc
decl_stmt|,
name|keep
decl_stmt|,
name|maxrps
decl_stmt|,
name|warn
decl_stmt|,
name|cnflg
decl_stmt|,
name|tlevel
decl_stmt|,
name|pflag
decl_stmt|,
name|msgflg
decl_stmt|,
name|mdmtyp
decl_stmt|,
name|zincnt
decl_stmt|,
name|fblksiz
decl_stmt|,
name|frecl
decl_stmt|,
name|frecfm
decl_stmt|,
name|atcapr
decl_stmt|,
name|atdiso
decl_stmt|,
name|verwho
decl_stmt|,
name|quiet
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|repars
decl_stmt|,
name|terror
decl_stmt|,
name|techo
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|long
name|vernum
decl_stmt|,
name|speed
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|versio
decl_stmt|,
modifier|*
name|protv
decl_stmt|,
modifier|*
name|ckxv
decl_stmt|,
modifier|*
name|ckzv
decl_stmt|,
modifier|*
name|fnsv
decl_stmt|,
modifier|*
name|connv
decl_stmt|,
modifier|*
name|dftty
decl_stmt|,
modifier|*
name|cmdv
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|dialv
decl_stmt|,
modifier|*
name|loginv
decl_stmt|,
modifier|*
name|for_def
index|[]
decl_stmt|,
modifier|*
name|whil_def
index|[]
decl_stmt|,
modifier|*
name|xif_def
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|ckxsys
decl_stmt|,
modifier|*
name|ckzsys
decl_stmt|,
modifier|*
name|cmarg
decl_stmt|,
modifier|*
name|cmarg2
decl_stmt|,
modifier|*
modifier|*
name|xargv
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|DIRCMD
decl_stmt|,
modifier|*
name|PWDCMD
decl_stmt|,
modifier|*
name|DELCMD
decl_stmt|,
modifier|*
name|WHOCMD
decl_stmt|,
name|ttname
index|[]
decl_stmt|,
name|filnam
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|CHAR
name|sstate
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|zinptr
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|NOMSEND
end_ifndef

begin_comment
comment|/* Multiple SEND */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|msfiles
index|[]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NOMSEND */
end_comment

begin_decl_stmt
specifier|extern
name|char
name|fspec
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Most recent filespec */
end_comment

begin_comment
comment|/* Declarations from cmd package */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DCMDBUF
end_ifdef

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|cmdbuf
decl_stmt|,
modifier|*
name|atmbuf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Command buffers */
end_comment

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|extern
name|char
name|cmdbuf
index|[]
decl_stmt|,
name|atmbuf
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Command buffers */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DCMDBUF */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NOSPL
end_ifndef

begin_decl_stmt
specifier|extern
name|struct
name|mtab
modifier|*
name|mactab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|nmac
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NOSPL */
end_comment

begin_comment
comment|/* Declarations from ck?fio.c module */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|backgrd
decl_stmt|,
name|bgset
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Kermit executing in background */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|COMMENT
end_ifdef

begin_comment
comment|/*   These must be on stack! */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NOSPL
end_ifndef

begin_decl_stmt
specifier|extern
name|char
name|vnambuf
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Buffer for variable names */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|vnp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointer to same */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NOSPL */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* COMMENT */
end_comment

begin_decl_stmt
specifier|extern
name|char
name|psave
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For saving& restoring prompt */
end_comment

begin_decl_stmt
specifier|extern
name|char
name|tmpbuf
index|[]
decl_stmt|,
modifier|*
name|tp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Temporary buffer */
end_comment

begin_comment
comment|/* Keyword tables specific to this module */
end_comment

begin_comment
comment|/* Modem signal table */
end_comment

begin_decl_stmt
name|struct
name|keytab
name|mstab
index|[]
init|=
block|{
ifdef|#
directive|ifdef
name|COMMENT
comment|/* The forms preceded by backslash are for MS-DOS Kermit compatibility. */
comment|/* But... \dsr doesn't work because \d = decimal constant introducer */
literal|"\\cd"
block|,
name|BM_DCD
block|,
name|CM_INV
block|,
comment|/* Carrier Detect */
literal|"\\cts"
block|,
name|BM_CTS
block|,
name|CM_INV
block|,
comment|/* Clear To Send  */
literal|"\\dsr"
block|,
name|BM_DSR
block|,
name|CM_INV
block|,
comment|/* Data Set Ready */
literal|"\\ri"
block|,
name|BM_RNG
block|,
name|CM_INV
block|,
comment|/* Ring Indicator */
endif|#
directive|endif
comment|/* COMMENT */
literal|"cd"
block|,
name|BM_DCD
block|,
literal|0
block|,
comment|/* Carrier Detect */
literal|"cts"
block|,
name|BM_CTS
block|,
literal|0
block|,
comment|/* Clear To Send  */
literal|"dsr"
block|,
name|BM_DSR
block|,
literal|0
block|,
comment|/* Data Set Ready */
literal|"ri"
block|,
name|BM_RNG
block|,
literal|0
comment|/* Ring Indicator */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nms
init|=
operator|(
sizeof|sizeof
argument_list|(
name|mstab
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|keytab
argument_list|)
operator|)
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|NOSPL
end_ifndef

begin_decl_stmt
name|struct
name|keytab
name|opntab
index|[]
init|=
block|{
ifndef|#
directive|ifndef
name|NOPUSH
literal|"!read"
block|,
name|XYFZ_Y
block|,
literal|0
block|,
literal|"!write"
block|,
name|XYFZ_X
block|,
literal|0
block|,
endif|#
directive|endif
comment|/* NOPUSH */
literal|"append"
block|,
name|XYFZ_A
block|,
literal|0
block|,
literal|"read"
block|,
name|XYFZ_O
block|,
literal|0
block|,
literal|"write"
block|,
name|XYFZ_N
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nopn
init|=
operator|(
sizeof|sizeof
argument_list|(
name|opntab
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|keytab
argument_list|)
operator|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|keytab
name|iftab
index|[]
init|=
block|{
comment|/* IF commands */
literal|"<"
block|,
name|XXIFLT
block|,
literal|0
block|,
literal|"="
block|,
name|XXIFAE
block|,
literal|0
block|,
literal|">"
block|,
name|XXIFGT
block|,
literal|0
block|,
literal|"background"
block|,
name|XXIFBG
block|,
literal|0
block|,
literal|"count"
block|,
name|XXIFCO
block|,
literal|0
block|,
literal|"defined"
block|,
name|XXIFDE
block|,
literal|0
block|,
ifdef|#
directive|ifdef
name|COMMENT
literal|"eof"
block|,
name|XXIFEO
block|,
literal|0
block|,
endif|#
directive|endif
comment|/* COMMENT */
literal|"equal"
block|,
name|XXIFEQ
block|,
literal|0
block|,
literal|"error"
block|,
name|XXIFFA
block|,
name|CM_INV
block|,
literal|"exist"
block|,
name|XXIFEX
block|,
literal|0
block|,
literal|"failure"
block|,
name|XXIFFA
block|,
literal|0
block|,
literal|"foreground"
block|,
name|XXIFFG
block|,
literal|0
block|,
literal|"llt"
block|,
name|XXIFLL
block|,
literal|0
block|,
literal|"lgt"
block|,
name|XXIFLG
block|,
literal|0
block|,
literal|"not"
block|,
name|XXIFNO
block|,
literal|0
block|,
literal|"numeric"
block|,
name|XXIFNU
block|,
literal|0
block|,
literal|"success"
block|,
name|XXIFSU
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nif
init|=
operator|(
sizeof|sizeof
argument_list|(
name|iftab
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|keytab
argument_list|)
operator|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NOSPL */
end_comment

begin_comment
comment|/* Variables and symbols local to this module */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NODIAL
end_ifndef

begin_decl_stmt
name|char
modifier|*
name|dialnum
init|=
operator|(
name|char
operator|*
operator|)
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Remember DIAL number for REDIAL */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|dialdir
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Dial directory file name */
end_comment

begin_decl_stmt
specifier|extern
name|FILE
modifier|*
name|dialfd
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Dial directory file descriptor */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NODIAL */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NOSPL
end_ifndef

begin_decl_stmt
name|int
name|ifc
decl_stmt|,
comment|/* IF case */
name|not
init|=
literal|0
decl_stmt|,
comment|/* Flag for IF NOT */
name|ifargs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Count of IF condition words */
end_comment

begin_decl_stmt
name|char
name|ifcond
index|[
literal|100
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* IF condition text */
end_comment

begin_decl_stmt
name|char
modifier|*
name|ifcp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointer to IF condition text */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DCMDBUF
end_ifdef

begin_decl_stmt
specifier|extern
name|int
modifier|*
name|ifcmd
decl_stmt|,
modifier|*
name|count
decl_stmt|,
modifier|*
name|iftest
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|extern
name|int
name|ifcmd
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Last command was IF */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|iftest
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Last IF was true */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|count
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For IF COUNT, one for each cmdlvl */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DCMDBUF */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NOSPL */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DCMDBUF
end_ifdef

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|line
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Character buffer for anything */
end_comment

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|extern
name|char
name|line
index|[]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DCMDBUF */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|lp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointer to line buffer */
end_comment

begin_decl_stmt
name|int
name|cwdf
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* CWD has been done */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|en_cwd
decl_stmt|,
name|en_del
decl_stmt|,
name|en_dir
decl_stmt|,
name|en_fin
decl_stmt|,
comment|/* Flags for ENABLE/DISABLE */
name|en_get
decl_stmt|,
name|en_hos
decl_stmt|,
name|en_sen
decl_stmt|,
name|en_set
decl_stmt|,
name|en_spa
decl_stmt|,
name|en_typ
decl_stmt|,
name|en_who
decl_stmt|,
name|en_bye
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|FILE
modifier|*
name|tfile
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* File pointers for TAKE command */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|tfnam
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Names of TAKE files */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|success
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Command success/failure flag */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NOSPL
end_ifndef

begin_decl_stmt
specifier|extern
name|int
comment|/* SET INPUT parameters. */
name|incase
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|maclvl
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Macro to execute */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|macx
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Index of current macro */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|mrval
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Macro return value */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|macp
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointer to macro */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|macargc
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ARGC from macro invocation */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|m_arg
index|[
name|MACLEVEL
index|]
index|[
name|NARGS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Stack of macro arguments */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|g_var
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Global variables %a, %b, etc */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DCMDBUF
end_ifdef

begin_decl_stmt
specifier|extern
name|struct
name|cmdptr
modifier|*
name|cmdstk
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The command stack itself */
end_comment

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|extern
name|struct
name|cmdptr
name|cmdstk
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The command stack itself */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DCMDBUF */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|cmdlvl
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current position in command stack */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NOSPL */
end_comment

begin_define
define|#
directive|define
name|xsystem
parameter_list|(
name|s
parameter_list|)
value|zsyscmd(s)
end_define

begin_decl_stmt
specifier|static
name|int
name|x
decl_stmt|,
name|y
decl_stmt|,
name|z
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  X X S T R C M P  --  Caseless string comparison  */
end_comment

begin_comment
comment|/*   Call with pointers to the two strings, s1 and s2, and a length, n.   Compares up to n characters of the two strings and returns:     1 if s1> t1     0 if s1 = s2    -1 if s1< t1 */
end_comment

begin_function
name|int
name|xxstrcmp
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|,
name|n
parameter_list|)
name|char
modifier|*
name|s1
decl_stmt|,
decl|*
name|s2
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* Caseless string comparison. */
name|char
name|t1
decl_stmt|,
name|t2
decl_stmt|;
if|if
condition|(
operator|!
name|s1
condition|)
name|s1
operator|=
literal|""
expr_stmt|;
comment|/* Watch out for null pointers. */
if|if
condition|(
operator|!
name|s2
condition|)
name|s2
operator|=
literal|""
expr_stmt|;
while|while
condition|(
name|n
operator|--
condition|)
block|{
name|t1
operator|=
operator|*
name|s1
operator|++
expr_stmt|;
comment|/* Get next character from each. */
if|if
condition|(
name|isupper
argument_list|(
name|t1
argument_list|)
condition|)
name|t1
operator|=
name|tolower
argument_list|(
name|t1
argument_list|)
expr_stmt|;
name|t2
operator|=
operator|*
name|s2
operator|++
expr_stmt|;
if|if
condition|(
name|isupper
argument_list|(
name|t2
argument_list|)
condition|)
name|t2
operator|=
name|tolower
argument_list|(
name|t2
argument_list|)
expr_stmt|;
if|if
condition|(
name|t1
operator|<
name|t2
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* s1< s2 */
if|if
condition|(
name|t1
operator|>
name|t2
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* s1> s2 */
block|}
return|return
operator|(
literal|0
operator|)
return|;
comment|/* They're equal */
block|}
end_block

begin_ifndef
ifndef|#
directive|ifndef
name|NOSPL
end_ifndef

begin_comment
comment|/* Do the ASK, ASKQ, GETOK, and READ commands */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NOFRILLS
end_ifndef

begin_decl_stmt
specifier|extern
name|struct
name|keytab
name|yesno
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|nyesno
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NOFRILLS */
end_comment

begin_function
name|int
name|doask
parameter_list|(
name|cx
parameter_list|)
name|int
name|cx
decl_stmt|;
block|{
if|if
condition|(
name|cx
operator|!=
name|XXGOK
condition|)
block|{
comment|/* Get variable name */
if|if
condition|(
operator|(
name|y
operator|=
name|cmfld
argument_list|(
literal|"Variable name"
argument_list|,
literal|""
argument_list|,
operator|&
name|s
argument_list|,
name|NULL
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|y
operator|==
operator|-
literal|3
condition|)
block|{
name|printf
argument_list|(
literal|"?Variable name required\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|9
operator|)
return|;
block|}
else|else
return|return
operator|(
name|y
operator|)
return|;
block|}
name|strcpy
argument_list|(
name|line
argument_list|,
name|s
argument_list|)
expr_stmt|;
comment|/* Make a copy. */
name|lp
operator|=
name|line
expr_stmt|;
if|if
condition|(
operator|(
name|y
operator|=
name|parsevar
argument_list|(
name|s
argument_list|,
operator|&
name|x
argument_list|,
operator|&
name|z
argument_list|)
operator|)
operator|<
literal|0
condition|)
comment|/* Check to make sure it's a */
return|return
operator|(
name|y
operator|)
return|;
comment|/* variable name. */
block|}
if|if
condition|(
name|cx
operator|==
name|XXREA
condition|)
block|{
comment|/* READ command */
if|if
condition|(
operator|(
name|y
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
comment|/* Get confirmation */
return|return
operator|(
name|y
operator|)
return|;
if|if
condition|(
name|chkfn
argument_list|(
name|ZRFILE
argument_list|)
operator|<
literal|1
condition|)
block|{
comment|/* File open? */
name|printf
argument_list|(
literal|"?Read file not open\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|s
operator|=
name|line
operator|+
name|VNAML
operator|+
literal|1
expr_stmt|;
comment|/* Where to read into. */
name|y
operator|=
name|zsinl
argument_list|(
name|ZRFILE
argument_list|,
name|s
argument_list|,
name|LINBUFSIZ
operator|-
name|VNAML
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* Read a line. */
name|debug
argument_list|(
name|F111
argument_list|,
literal|"read zsinl"
argument_list|,
name|s
argument_list|,
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|y
operator|<
literal|0
condition|)
block|{
comment|/* On EOF or other error, */
name|zclose
argument_list|(
name|ZRFILE
argument_list|)
expr_stmt|;
comment|/* close the file, */
name|delmac
argument_list|(
name|lp
argument_list|)
expr_stmt|;
comment|/* delete the variable, */
return|return
operator|(
name|success
operator|=
literal|0
operator|)
return|;
comment|/* and return failure. */
block|}
else|else
block|{
comment|/* Read was OK. */
name|success
operator|=
operator|(
name|addmac
argument_list|(
name|lp
argument_list|,
name|s
argument_list|)
operator|<
literal|0
condition|?
literal|0
else|:
literal|1
operator|)
expr_stmt|;
comment|/* Define the variable */
name|debug
argument_list|(
name|F111
argument_list|,
literal|"read addmac"
argument_list|,
name|lp
argument_list|,
name|success
argument_list|)
expr_stmt|;
return|return
operator|(
name|success
operator|)
return|;
comment|/* Return success. */
block|}
block|}
comment|/* ASK, ASKQ, or GETOK */
if|if
condition|(
operator|(
name|y
operator|=
name|cmtxt
argument_list|(
literal|"Prompt, enclose in { braces } to preserve\n\ leading and trailing spaces, precede question mark with backslash (\\)."
argument_list|,
name|cx
operator|==
name|XXGOK
condition|?
literal|"{ Yes or no? }"
else|:
literal|""
argument_list|,
operator|&
name|p
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
name|cmsavp
argument_list|(
name|psave
argument_list|,
literal|80
argument_list|)
expr_stmt|;
comment|/* Save old prompt */
if|if
condition|(
operator|*
name|p
operator|==
literal|'{'
condition|)
block|{
comment|/* New prompt enclosed in braces? */
name|x
operator|=
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|p
argument_list|)
operator|-
literal|1
expr_stmt|;
comment|/* Yes, strip them. */
if|if
condition|(
name|p
index|[
name|x
index|]
operator|==
literal|'}'
condition|)
block|{
name|p
index|[
name|x
index|]
operator|=
name|NUL
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
block|}
name|cmsetp
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* Make new prompt */
if|if
condition|(
name|cx
operator|==
name|XXASKQ
condition|)
block|{
comment|/* For ASKQ, */
name|concb
argument_list|(
operator|(
name|char
operator|)
name|escape
argument_list|)
expr_stmt|;
comment|/* put console in cbreak mode */
name|cmini
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* and no-echo mode. */
block|}
else|else
block|{
comment|/* For others, regular echoing. */
name|cmini
argument_list|(
name|ckxech
argument_list|)
expr_stmt|;
block|}
name|x
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* This means to reparse. */
name|reprompt
label|:
if|if
condition|(
name|pflag
condition|)
name|prompt
argument_list|(
name|xxstring
argument_list|)
expr_stmt|;
comment|/* Issue prompt. */
if|if
condition|(
name|cx
operator|==
name|XXGOK
condition|)
block|{
ifndef|#
directive|ifndef
name|NOFRILLS
name|x
operator|=
name|cmkey
argument_list|(
name|yesno
argument_list|,
name|nyesno
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
name|xxstring
argument_list|)
expr_stmt|;
comment|/* GETOK uses keyword table */
if|if
condition|(
name|x
operator|<
literal|0
condition|)
block|{
comment|/* Parse error */
if|if
condition|(
name|x
operator|==
operator|-
literal|3
condition|)
block|{
comment|/* No answer? */
name|printf
argument_list|(
literal|"Please respond Yes or No\n"
argument_list|)
expr_stmt|;
comment|/* Make them answer */
name|cmini
argument_list|(
name|ckxech
argument_list|)
expr_stmt|;
block|}
goto|goto
name|reprompt
goto|;
block|}
if|if
condition|(
operator|(
name|y
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
comment|/* Get confirmation */
goto|goto
name|reprompt
goto|;
name|cmsetp
argument_list|(
name|psave
argument_list|)
expr_stmt|;
comment|/* Restore prompt */
return|return
operator|(
name|x
operator|)
return|;
comment|/* Return success or failure */
else|#
directive|else
empty_stmt|;
endif|#
directive|endif
comment|/* NOFRILLS */
block|}
else|else
block|{
comment|/* ASK or ASKQ */
while|while
condition|(
name|x
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* Prompt till they answer */
name|x
operator|=
name|cmtxt
argument_list|(
literal|"Please respond.\n\  Type \\? to include a question mark in your response."
argument_list|,
literal|""
argument_list|,
operator|&
name|s
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F111
argument_list|,
literal|" cmtxt"
argument_list|,
name|s
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cx
operator|==
name|XXASKQ
condition|)
comment|/* ASKQ must echo CRLF here */
name|printf
argument_list|(
literal|"\r\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|<
literal|0
condition|)
block|{
comment|/* If cmtxt parse error, */
name|cmsetp
argument_list|(
name|psave
argument_list|)
expr_stmt|;
comment|/* restore original prompt */
return|return
operator|(
name|x
operator|)
return|;
comment|/* and return cmtxt's error code. */
block|}
if|if
condition|(
operator|*
name|s
operator|==
name|NUL
condition|)
block|{
comment|/* If user typed a bare CR, */
name|cmsetp
argument_list|(
name|psave
argument_list|)
expr_stmt|;
comment|/* Restore old prompt, */
name|delmac
argument_list|(
name|lp
argument_list|)
expr_stmt|;
comment|/* delete variable if it exists, */
return|return
operator|(
name|success
operator|=
literal|1
operator|)
return|;
comment|/* and return. */
block|}
name|y
operator|=
name|addmac
argument_list|(
name|lp
argument_list|,
name|s
argument_list|)
expr_stmt|;
comment|/* Add it to the macro table. */
name|debug
argument_list|(
name|F111
argument_list|,
literal|"ask addmac"
argument_list|,
name|lp
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|cmsetp
argument_list|(
name|psave
argument_list|)
expr_stmt|;
comment|/* Restore old prompt. */
return|return
operator|(
name|success
operator|=
name|y
operator|<
literal|0
condition|?
literal|0
else|:
literal|1
operator|)
return|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NOSPL */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NOSPL
end_ifndef

begin_function
name|int
name|doincr
parameter_list|(
name|cx
parameter_list|)
name|int
name|cx
decl_stmt|;
block|{
comment|/* INCREMENT, DECREMENT */
name|char
name|vnambuf
index|[
name|VNAML
index|]
decl_stmt|;
comment|/* Buffer for variable names */
if|if
condition|(
operator|(
name|y
operator|=
name|cmfld
argument_list|(
literal|"Variable name"
argument_list|,
literal|""
argument_list|,
operator|&
name|s
argument_list|,
name|NULL
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|y
operator|==
operator|-
literal|3
condition|)
block|{
name|printf
argument_list|(
literal|"?Variable name required\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|9
operator|)
return|;
block|}
else|else
return|return
operator|(
name|y
operator|)
return|;
block|}
if|if
condition|(
operator|*
name|s
operator|!=
name|CMDQ
condition|)
block|{
operator|*
name|vnambuf
operator|=
name|CMDQ
expr_stmt|;
name|strncpy
argument_list|(
name|vnambuf
operator|+
literal|1
argument_list|,
name|s
argument_list|,
name|VNAML
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|strncpy
argument_list|(
name|vnambuf
argument_list|,
name|s
argument_list|,
name|VNAML
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|y
operator|=
name|parsevar
argument_list|(
name|vnambuf
argument_list|,
operator|&
name|x
argument_list|,
operator|&
name|z
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
if|if
condition|(
operator|(
name|y
operator|=
name|cmnum
argument_list|(
literal|"by amount"
argument_list|,
literal|"1"
argument_list|,
literal|10
argument_list|,
operator|&
name|x
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
if|if
condition|(
operator|(
name|y
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
name|z
operator|=
operator|(
name|cx
operator|==
name|XXINC
condition|?
literal|1
else|:
literal|0
operator|)
expr_stmt|;
comment|/* Increment or decrement? */
if|if
condition|(
name|incvar
argument_list|(
name|vnambuf
argument_list|,
name|x
argument_list|,
name|z
argument_list|,
operator|&
name|y
argument_list|)
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"?Variable %s not defined or not numeric\n"
argument_list|,
name|vnambuf
argument_list|)
expr_stmt|;
return|return
operator|(
name|success
operator|=
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|success
operator|=
literal|1
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NOSPL */
end_comment

begin_comment
comment|/* Do the (_)DEFINE and (_)ASSIGN commands */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NOSPL
end_ifndef

begin_function
name|int
name|dodef
parameter_list|(
name|cx
parameter_list|)
name|int
name|cx
decl_stmt|;
block|{
name|char
name|vnambuf
index|[
name|VNAML
index|]
decl_stmt|;
comment|/* Buffer for variable names */
name|char
modifier|*
name|vnp
decl_stmt|;
comment|/* Pointer to same */
if|if
condition|(
name|cx
operator|==
name|XXDFX
operator|||
name|cx
operator|==
name|XXASX
condition|)
name|y
operator|=
name|cmfld
argument_list|(
literal|"Macro or variable name"
argument_list|,
literal|""
argument_list|,
operator|&
name|s
argument_list|,
name|xxstring
argument_list|)
expr_stmt|;
comment|/* eval var name */
else|else
name|y
operator|=
name|cmfld
argument_list|(
literal|"Macro or variable name"
argument_list|,
literal|""
argument_list|,
operator|&
name|s
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* don't evaluate */
if|if
condition|(
name|y
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|y
operator|==
operator|-
literal|3
condition|)
block|{
name|printf
argument_list|(
literal|"?Variable name required\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|9
operator|)
return|;
block|}
else|else
return|return
operator|(
name|y
operator|)
return|;
block|}
name|debug
argument_list|(
name|F110
argument_list|,
literal|"dodef"
argument_list|,
name|s
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|vnambuf
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|vnp
operator|=
name|vnambuf
expr_stmt|;
if|if
condition|(
name|vnambuf
index|[
literal|0
index|]
operator|==
name|CMDQ
operator|&&
operator|(
name|vnambuf
index|[
literal|1
index|]
operator|==
literal|'%'
operator|||
name|vnambuf
index|[
literal|1
index|]
operator|==
literal|'&'
operator|)
condition|)
name|vnp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|vnp
operator|==
literal|'%'
operator|||
operator|*
name|vnp
operator|==
literal|'&'
condition|)
block|{
if|if
condition|(
operator|(
name|y
operator|=
name|parsevar
argument_list|(
name|vnp
argument_list|,
operator|&
name|x
argument_list|,
operator|&
name|z
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|"dodef"
argument_list|,
literal|""
argument_list|,
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|y
operator|==
literal|1
condition|)
block|{
comment|/* Simple variable */
if|if
condition|(
operator|(
name|y
operator|=
name|cmtxt
argument_list|(
literal|"Definition of variable"
argument_list|,
literal|""
argument_list|,
operator|&
name|s
argument_list|,
name|NULL
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
name|debug
argument_list|(
name|F110
argument_list|,
literal|"xxdef var name"
argument_list|,
name|vnp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F110
argument_list|,
literal|"xxdef var def"
argument_list|,
name|s
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|y
operator|==
literal|2
condition|)
block|{
comment|/* Array element */
if|if
condition|(
operator|(
name|y
operator|=
name|arraynam
argument_list|(
name|s
argument_list|,
operator|&
name|x
argument_list|,
operator|&
name|z
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
if|if
condition|(
name|x
operator|==
literal|96
condition|)
block|{
name|printf
argument_list|(
literal|"?Argument vector array is read-only\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|9
operator|)
return|;
block|}
if|if
condition|(
name|chkarray
argument_list|(
name|x
argument_list|,
name|z
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|2
operator|)
return|;
if|if
condition|(
operator|(
name|y
operator|=
name|cmtxt
argument_list|(
literal|"Definition of array element"
argument_list|,
literal|""
argument_list|,
operator|&
name|s
argument_list|,
name|NULL
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
name|debug
argument_list|(
name|F110
argument_list|,
literal|"xxdef array ref"
argument_list|,
name|vnp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F110
argument_list|,
literal|"xxdef array def"
argument_list|,
name|s
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Macro */
if|if
condition|(
operator|(
name|y
operator|=
name|cmtxt
argument_list|(
literal|"Definition of macro"
argument_list|,
literal|""
argument_list|,
operator|&
name|s
argument_list|,
name|NULL
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
name|debug
argument_list|(
name|F110
argument_list|,
literal|"xxdef macro name"
argument_list|,
name|vnp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F110
argument_list|,
literal|"xxdef macro def"
argument_list|,
name|s
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'{'
condition|)
block|{
comment|/* Allow macro def to be bracketed. */
name|s
operator|++
expr_stmt|;
comment|/* If it is, remove the brackets. */
name|y
operator|=
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* FOR command depends on this! */
if|if
condition|(
name|y
operator|>
literal|0
operator|&&
name|s
index|[
name|y
operator|-
literal|1
index|]
operator|==
literal|'}'
condition|)
name|s
index|[
name|y
operator|-
literal|1
index|]
operator|=
name|NUL
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|*
name|s
operator|==
name|NUL
condition|)
block|{
comment|/* No arg given, undefine */
name|delmac
argument_list|(
name|vnp
argument_list|)
expr_stmt|;
comment|/* silently... */
return|return
operator|(
name|success
operator|=
literal|1
operator|)
return|;
comment|/* even if it doesn't exist... */
block|}
comment|/* Defining a new macro or variable */
if|if
condition|(
name|cx
operator|==
name|XXASS
operator|||
name|cx
operator|==
name|XXASX
condition|)
block|{
comment|/* ASSIGN rather than DEFINE? */
name|int
name|t
decl_stmt|;
name|t
operator|=
name|LINBUFSIZ
operator|-
literal|1
expr_stmt|;
name|lp
operator|=
name|line
expr_stmt|;
comment|/* If so, expand its value now */
name|xxstring
argument_list|(
name|s
argument_list|,
operator|&
name|lp
argument_list|,
operator|&
name|t
argument_list|)
expr_stmt|;
name|s
operator|=
name|line
expr_stmt|;
block|}
name|debug
argument_list|(
name|F111
argument_list|,
literal|"calling addmac"
argument_list|,
name|s
argument_list|,
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|y
operator|=
name|addmac
argument_list|(
name|vnp
argument_list|,
name|s
argument_list|)
expr_stmt|;
comment|/* Add it to the appropriate table. */
if|if
condition|(
name|y
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"?%s failed\n"
argument_list|,
operator|(
name|cx
operator|==
name|XXASS
operator|||
name|cx
operator|==
name|XXASX
operator|)
condition|?
literal|"ASSIGN"
else|:
literal|"DEFINE"
argument_list|)
expr_stmt|;
return|return
operator|(
name|success
operator|=
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|success
operator|=
literal|1
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NOSPL */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NODIAL
end_ifndef

begin_decl_stmt
specifier|extern
name|struct
name|keytab
name|partab
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*    L U D I A L  --  Lookup up dialing directory entry.       Call with string to look up and file descriptor of open dialing directory    file.  On success, returns pointer to phone number and sets speed    and parity according to the directory entry.  On failure, returns the NULL    pointer. */
end_comment

begin_function
name|char
modifier|*
name|ludial
parameter_list|(
name|s
parameter_list|,
name|f
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
name|FILE
modifier|*
name|f
decl_stmt|;
block|{
name|int
name|n
decl_stmt|,
name|n1
decl_stmt|,
name|n2
decl_stmt|,
name|i
decl_stmt|,
name|t
decl_stmt|;
comment|/* Workers */
name|long
name|xspeed
init|=
operator|-
literal|1L
decl_stmt|,
name|x2
decl_stmt|;
comment|/* Speed to set from directory entry */
name|int
name|xparity
init|=
operator|-
literal|1
decl_stmt|;
comment|/* Parity to set ...*/
name|char
modifier|*
name|info
index|[
literal|5
index|]
decl_stmt|;
comment|/* Array of words from entry */
if|if
condition|(
operator|!
name|s
operator|||
operator|!
name|f
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* Validate arguments */
if|if
condition|(
operator|(
name|n1
operator|=
name|strlen
argument_list|(
name|s
argument_list|)
operator|)
operator|<
literal|1
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/*   We make one or two passes.  The first pass searches for an exact match.   If it fails, the second pass searches for the first entry of which the   search string is an abbreviation.  Of course this could be done in one   pass, but it was safer to add a couple lines for the for-loop than to   totally rearrange the code at the last minute.  (Edit 186) */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
block|{
comment|/* Do this twice */
name|debug
argument_list|(
name|F101
argument_list|,
literal|"ludial pass"
argument_list|,
literal|""
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
name|rewind
argument_list|(
name|f
argument_list|)
expr_stmt|;
comment|/* Go to beginning of directory file */
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|fgets
argument_list|(
name|line
argument_list|,
name|LINBUFSIZ
argument_list|,
name|f
argument_list|)
operator|==
name|NULL
condition|)
block|{
comment|/* Read a line */
if|if
condition|(
name|i
operator|==
literal|0
condition|)
comment|/* EOF */
break|break;
comment|/* If first pass, start second pass */
if|if
condition|(
operator|!
name|backgrd
operator|&&
operator|!
name|quiet
condition|)
comment|/* If second pass, give message */
name|printf
argument_list|(
literal|" %s not in %s\n"
argument_list|,
name|s
argument_list|,
name|dialdir
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F110
argument_list|,
literal|"ludial fails"
argument_list|,
name|s
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|n
operator|=
name|strlen
argument_list|(
name|line
argument_list|)
expr_stmt|;
comment|/* Strip terminator(s) */
while|while
condition|(
operator|(
name|n
operator|>
literal|0
operator|)
operator|&&
operator|(
name|line
index|[
name|n
operator|-
literal|1
index|]
operator|<
literal|'!'
operator|)
condition|)
name|line
index|[
operator|--
name|n
index|]
operator|=
name|NUL
expr_stmt|;
name|debug
argument_list|(
name|F111
argument_list|,
literal|"ludial"
argument_list|,
name|line
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|info
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
name|info
index|[
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
name|info
index|[
literal|2
index|]
operator|=
name|NULL
expr_stmt|;
name|info
index|[
literal|3
index|]
operator|=
name|NULL
expr_stmt|;
name|info
index|[
literal|4
index|]
operator|=
name|NULL
expr_stmt|;
name|xwords
argument_list|(
name|line
argument_list|,
literal|4
argument_list|,
name|info
argument_list|)
expr_stmt|;
comment|/* Get the words. */
if|if
condition|(
name|info
index|[
literal|1
index|]
condition|)
block|{
comment|/* First word. */
if|if
condition|(
operator|(
name|n2
operator|=
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|info
index|[
literal|1
index|]
argument_list|)
operator|)
operator|<
literal|1
condition|)
comment|/* Its length */
continue|continue;
comment|/* If no first word, keep looking. */
if|if
condition|(
name|n2
operator|<
name|n1
condition|)
comment|/* If directory entry name shorter */
continue|continue;
comment|/* than search name, then no match. */
if|if
condition|(
name|i
operator|==
literal|0
operator|&&
name|n2
operator|!=
name|n1
condition|)
comment|/* Require exact match on first pass */
continue|continue;
if|if
condition|(
name|xxstrcmp
argument_list|(
name|s
argument_list|,
name|info
index|[
literal|1
index|]
argument_list|,
name|n1
argument_list|)
condition|)
comment|/* Caseless string comparison */
continue|continue;
comment|/* up to length of search name */
if|if
condition|(
operator|!
name|backgrd
operator|&&
operator|!
name|quiet
condition|)
name|printf
argument_list|(
literal|" From dialing directory %s: %s=%s\n"
argument_list|,
name|dialdir
argument_list|,
name|info
index|[
literal|1
index|]
argument_list|,
name|info
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
index|[
literal|3
index|]
condition|)
block|{
comment|/* Third word = speed */
if|if
condition|(
operator|*
name|info
index|[
literal|3
index|]
operator|!=
literal|'='
condition|)
block|{
comment|/* "=" means don't change it */
name|xspeed
operator|=
name|atol
argument_list|(
name|info
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|x2
operator|=
name|xspeed
operator|/
literal|10L
expr_stmt|;
if|if
condition|(
name|x2
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|ttsspd
argument_list|(
operator|(
name|int
operator|)
name|x2
argument_list|)
operator|<
literal|0
condition|)
name|printf
argument_list|(
literal|"\n Can't set speed to %s\n"
argument_list|,
name|info
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
else|else
name|speed
operator|=
name|xspeed
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|info
index|[
literal|4
index|]
condition|)
block|{
comment|/* 4th word = parity */
if|if
condition|(
operator|*
name|info
index|[
literal|4
index|]
operator|!=
literal|'='
condition|)
block|{
comment|/* "=" means don't change it */
if|if
condition|(
operator|(
name|xparity
operator|=
name|lookup
argument_list|(
name|partab
argument_list|,
name|info
index|[
literal|4
index|]
argument_list|,
literal|5
argument_list|,
operator|&
name|t
argument_list|)
operator|)
operator|>
operator|-
literal|1
condition|)
name|parity
operator|=
name|xparity
expr_stmt|;
block|}
block|}
return|return
operator|(
name|info
index|[
literal|2
index|]
operator|)
return|;
comment|/* Return 2nd word = phone number */
block|}
block|}
block|}
block|}
end_function

begin_function
name|int
name|dodial
parameter_list|(
name|cx
parameter_list|)
name|int
name|cx
decl_stmt|;
block|{
comment|/* DIAL or REDIAL */
if|if
condition|(
name|cx
operator|==
name|XXRED
condition|)
block|{
comment|/* REDIAL or... */
if|if
condition|(
operator|(
name|y
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
if|if
condition|(
name|dialnum
condition|)
block|{
name|s
operator|=
name|dialnum
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"?No DIAL command given yet\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|9
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|cx
operator|==
name|XXDIAL
condition|)
block|{
comment|/* DIAL command */
name|char
modifier|*
name|s2
decl_stmt|;
if|if
condition|(
name|dialdir
operator|&&
operator|*
name|dialdir
condition|)
name|s2
operator|=
literal|"Number to dial or entry from dial directory"
expr_stmt|;
else|else
name|s2
operator|=
literal|"Number to dial"
expr_stmt|;
if|if
condition|(
operator|(
name|x
operator|=
name|cmtxt
argument_list|(
name|s2
argument_list|,
literal|""
argument_list|,
operator|&
name|s
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|s
argument_list|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"?You must specify a number to dial\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|9
operator|)
return|;
block|}
if|if
condition|(
name|dialfd
condition|)
block|{
comment|/* Have dialing directory? */
if|if
condition|(
name|s2
operator|=
name|ludial
argument_list|(
name|s
argument_list|,
name|dialfd
argument_list|)
condition|)
comment|/* Look up in dialing directory */
name|s
operator|=
name|s2
expr_stmt|;
comment|/* Make substitution if found */
block|}
if|if
condition|(
name|dialnum
condition|)
name|free
argument_list|(
name|dialnum
argument_list|)
expr_stmt|;
comment|/* Make copy for REDIAL */
name|dialnum
operator|=
name|malloc
argument_list|(
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|dialnum
condition|)
name|strcpy
argument_list|(
name|dialnum
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
else|else
return|return
operator|(
operator|-
literal|2
operator|)
return|;
ifdef|#
directive|ifdef
name|VMS
name|conres
argument_list|()
expr_stmt|;
comment|/* So Ctrl-C/Y will work */
endif|#
directive|endif
comment|/* VMS */
name|success
operator|=
name|ckdial
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* Try to dial */
ifdef|#
directive|ifdef
name|OS2
name|ttres
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* OS2 */
ifdef|#
directive|ifdef
name|VMS
name|concb
argument_list|(
operator|(
name|char
operator|)
name|escape
argument_list|)
expr_stmt|;
comment|/* Back to command parsing mode */
endif|#
directive|endif
comment|/* VMS */
return|return
operator|(
name|success
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NODIAL */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|MAC
end_ifndef

begin_function
name|int
comment|/* Do the DIRECTORY command */
name|dodir
parameter_list|()
block|{
name|char
modifier|*
name|dc
decl_stmt|;
ifdef|#
directive|ifdef
name|VMS
if|if
condition|(
operator|(
name|x
operator|=
name|cmtxt
argument_list|(
literal|"Directory/file specification"
argument_list|,
literal|""
argument_list|,
operator|&
name|s
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
comment|/* now do this the same as a shell command - helps with LAT  */
name|conres
argument_list|()
expr_stmt|;
comment|/* make console normal */
name|lp
operator|=
name|line
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|dc
operator|=
name|getenv
argument_list|(
literal|"CK_DIR"
argument_list|)
operator|)
condition|)
name|dc
operator|=
name|DIRCMD
expr_stmt|;
name|sprintf
argument_list|(
name|lp
argument_list|,
literal|"%s %s"
argument_list|,
name|dc
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F110
argument_list|,
literal|"Directory string: "
argument_list|,
name|line
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|xsystem
argument_list|(
name|lp
argument_list|)
expr_stmt|;
return|return
operator|(
name|success
operator|=
literal|0
operator|)
return|;
else|#
directive|else
ifdef|#
directive|ifdef
name|AMIGA
if|if
condition|(
operator|(
name|x
operator|=
name|cmtxt
argument_list|(
literal|"Directory/file specification"
argument_list|,
literal|""
argument_list|,
operator|&
name|s
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
else|#
directive|else
ifdef|#
directive|ifdef
name|datageneral
if|if
condition|(
operator|(
name|x
operator|=
name|cmtxt
argument_list|(
literal|"Directory/file specification"
argument_list|,
literal|"+"
argument_list|,
operator|&
name|s
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
else|#
directive|else
comment|/* General Case */
if|if
condition|(
operator|(
name|x
operator|=
name|cmdir
argument_list|(
literal|"Directory/file specification"
argument_list|,
literal|""
argument_list|,
operator|&
name|s
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
if|if
condition|(
name|x
operator|!=
operator|-
literal|3
condition|)
return|return
operator|(
name|x
operator|)
return|;
name|strcpy
argument_list|(
name|tmpbuf
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|y
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
name|s
operator|=
name|tmpbuf
expr_stmt|;
endif|#
directive|endif
comment|/* datageneral */
endif|#
directive|endif
comment|/* AMIGA */
comment|/* General case again */
name|lp
operator|=
name|line
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|dc
operator|=
name|getenv
argument_list|(
literal|"CK_DIR"
argument_list|)
operator|)
condition|)
name|dc
operator|=
name|DIRCMD
expr_stmt|;
name|sprintf
argument_list|(
name|lp
argument_list|,
literal|"%s %s"
argument_list|,
name|dc
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|xsystem
argument_list|(
name|line
argument_list|)
expr_stmt|;
return|return
operator|(
name|success
operator|=
literal|1
operator|)
return|;
comment|/* who cares... */
endif|#
directive|endif
comment|/* VMS */
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MAC */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NOFRILLS
end_ifndef

begin_comment
comment|/* Do the ENABLE and DISABLE commands */
end_comment

begin_function
name|int
name|doenable
parameter_list|(
name|cx
parameter_list|,
name|x
parameter_list|)
name|int
name|cx
decl_stmt|,
name|x
decl_stmt|;
block|{
name|y
operator|=
operator|(
operator|(
name|cx
operator|==
name|XXENA
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
expr_stmt|;
switch|switch
condition|(
name|x
condition|)
block|{
case|case
name|EN_ALL
case|:
name|en_cwd
operator|=
name|en_del
operator|=
name|en_dir
operator|=
name|en_fin
operator|=
name|en_get
operator|=
name|y
expr_stmt|;
name|en_sen
operator|=
name|en_set
operator|=
name|en_spa
operator|=
name|en_typ
operator|=
name|en_who
operator|=
name|y
expr_stmt|;
ifndef|#
directive|ifndef
name|datageneral
name|en_bye
operator|=
name|y
expr_stmt|;
endif|#
directive|endif
comment|/* datageneral */
ifndef|#
directive|ifndef
name|NOPUSH
name|en_hos
operator|=
name|y
expr_stmt|;
endif|#
directive|endif
comment|/* NOPUSH */
break|break;
case|case
name|EN_BYE
case|:
ifndef|#
directive|ifndef
name|datageneral
comment|/*   In Data General AOS/VS Kermit can't log out its superior process. */
name|en_bye
operator|=
name|y
expr_stmt|;
endif|#
directive|endif
comment|/* datageneral */
break|break;
case|case
name|EN_CWD
case|:
name|en_cwd
operator|=
name|y
expr_stmt|;
break|break;
case|case
name|EN_DEL
case|:
name|en_del
operator|=
name|y
expr_stmt|;
break|break;
case|case
name|EN_DIR
case|:
name|en_dir
operator|=
name|y
expr_stmt|;
break|break;
case|case
name|EN_FIN
case|:
name|en_fin
operator|=
name|y
expr_stmt|;
break|break;
case|case
name|EN_GET
case|:
name|en_get
operator|=
name|y
expr_stmt|;
break|break;
ifndef|#
directive|ifndef
name|NOPUSH
case|case
name|EN_HOS
case|:
name|en_hos
operator|=
name|y
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* NOPUSH */
case|case
name|EN_SEN
case|:
name|en_sen
operator|=
name|y
expr_stmt|;
break|break;
case|case
name|EN_SET
case|:
name|en_set
operator|=
name|y
expr_stmt|;
break|break;
case|case
name|EN_SPA
case|:
name|en_spa
operator|=
name|y
expr_stmt|;
break|break;
case|case
name|EN_TYP
case|:
name|en_typ
operator|=
name|y
expr_stmt|;
break|break;
case|case
name|EN_WHO
case|:
name|en_who
operator|=
name|y
expr_stmt|;
break|break;
default|default:
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NOFRILLS */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NOFRILLS
end_ifndef

begin_function
name|int
name|dodel
parameter_list|()
block|{
comment|/* DELETE */
name|long
name|zl
decl_stmt|;
if|if
condition|(
operator|(
name|x
operator|=
name|cmifi
argument_list|(
literal|"File(s) to delete"
argument_list|,
literal|""
argument_list|,
operator|&
name|s
argument_list|,
operator|&
name|y
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|x
operator|==
operator|-
literal|3
condition|)
block|{
name|printf
argument_list|(
literal|"?A file specification is required\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|9
operator|)
return|;
block|}
else|else
return|return
operator|(
name|x
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|MAC
name|strcpy
argument_list|(
name|line
argument_list|,
name|s
argument_list|)
expr_stmt|;
else|#
directive|else
name|strncpy
argument_list|(
name|tmpbuf
argument_list|,
name|s
argument_list|,
literal|50
argument_list|)
expr_stmt|;
comment|/* Make a safe copy of the name. */
name|debug
argument_list|(
name|F110
argument_list|,
literal|"xxdel tmpbuf"
argument_list|,
name|s
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|line
argument_list|,
literal|"%s %s"
argument_list|,
name|DELCMD
argument_list|,
name|s
argument_list|)
expr_stmt|;
comment|/* Construct the system command. */
endif|#
directive|endif
comment|/* MAC */
name|debug
argument_list|(
name|F110
argument_list|,
literal|"xxdel line"
argument_list|,
name|line
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|y
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
comment|/* Confirm the user's command. */
ifdef|#
directive|ifdef
name|VMS
name|conres
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* VMS */
ifdef|#
directive|ifdef
name|MAC
name|s
operator|=
name|line
expr_stmt|;
name|success
operator|=
operator|(
name|zdelet
argument_list|(
name|line
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
else|#
directive|else
name|s
operator|=
name|tmpbuf
expr_stmt|;
name|xsystem
argument_list|(
name|line
argument_list|)
expr_stmt|;
comment|/* Let the system do it. */
name|zl
operator|=
name|zchki
argument_list|(
name|tmpbuf
argument_list|)
expr_stmt|;
name|success
operator|=
operator|(
name|zl
operator|==
operator|-
literal|1L
operator|)
expr_stmt|;
endif|#
directive|endif
comment|/* MAC */
if|if
condition|(
name|msgflg
condition|)
name|printf
argument_list|(
literal|"%s - %sdeleted\n"
argument_list|,
name|s
argument_list|,
name|success
condition|?
literal|""
else|:
literal|"not "
argument_list|)
expr_stmt|;
return|return
operator|(
name|success
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NOFRILLS */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NOSPL
end_ifndef

begin_comment
comment|/* The ELSE command */
end_comment

begin_function
name|int
name|doelse
parameter_list|()
block|{
if|if
condition|(
operator|!
name|ifcmd
index|[
name|cmdlvl
index|]
condition|)
block|{
name|printf
argument_list|(
literal|"?ELSE doesn't follow IF\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|COMMENT
comment|/*   Wrong.  This prevents IF..ELSE IF...ELSE IF...ELSE IF...ELSE...   from working. */
name|ifcmd
index|[
name|cmdlvl
index|]
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* COMMENT */
if|if
condition|(
operator|!
name|iftest
index|[
name|cmdlvl
index|]
condition|)
block|{
comment|/* If IF was false do ELSE part */
if|if
condition|(
name|maclvl
operator|>
operator|-
literal|1
condition|)
block|{
comment|/* In macro, */
name|pushcmd
argument_list|()
expr_stmt|;
comment|/* save rest of command. */
block|}
elseif|else
if|if
condition|(
name|tlevel
operator|>
operator|-
literal|1
condition|)
block|{
comment|/* In take file, */
name|pushcmd
argument_list|()
expr_stmt|;
comment|/* save rest of command. */
block|}
else|else
block|{
comment|/* If interactive, */
name|cmini
argument_list|(
name|ckxech
argument_list|)
expr_stmt|;
comment|/* just start a new command */
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* (like in MS-DOS Kermit) */
if|if
condition|(
name|pflag
condition|)
name|prompt
argument_list|(
name|xxstring
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Condition is false */
if|if
condition|(
operator|(
name|y
operator|=
name|cmtxt
argument_list|(
literal|"command to be ignored"
argument_list|,
literal|""
argument_list|,
operator|&
name|s
argument_list|,
name|NULL
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
comment|/* Gobble up rest of line */
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NOSPL */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NOSPL
end_ifndef

begin_function
name|int
name|dofor
parameter_list|()
block|{
comment|/* The FOR command. */
name|int
name|fx
decl_stmt|,
name|fy
decl_stmt|,
name|fz
decl_stmt|;
comment|/* loop variables */
name|char
modifier|*
name|ap
decl_stmt|;
comment|/* macro argument pointer */
if|if
condition|(
operator|(
name|y
operator|=
name|cmfld
argument_list|(
literal|"Variable name"
argument_list|,
literal|""
argument_list|,
operator|&
name|s
argument_list|,
name|NULL
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
comment|/* Get variable name */
if|if
condition|(
name|y
operator|==
operator|-
literal|3
condition|)
block|{
name|printf
argument_list|(
literal|"?Variable name required\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|9
operator|)
return|;
block|}
else|else
return|return
operator|(
name|y
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|y
operator|=
name|parsevar
argument_list|(
name|s
argument_list|,
operator|&
name|x
argument_list|,
operator|&
name|z
argument_list|)
operator|)
operator|<
literal|0
condition|)
comment|/* Check it. */
return|return
operator|(
name|y
operator|)
return|;
name|lp
operator|=
name|line
expr_stmt|;
comment|/* Build a copy of the command */
name|strcpy
argument_list|(
name|lp
argument_list|,
literal|"_forx "
argument_list|)
expr_stmt|;
name|lp
operator|+=
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|line
argument_list|)
expr_stmt|;
comment|/* "_for" macro. */
name|ap
operator|=
name|lp
expr_stmt|;
comment|/* Save pointer to macro args. */
if|if
condition|(
operator|*
name|s
operator|==
name|CMDQ
condition|)
name|s
operator|++
expr_stmt|;
comment|/* Skip past backslash if any. */
while|while
condition|(
operator|*
name|lp
operator|++
operator|=
operator|*
name|s
operator|++
condition|)
empty_stmt|;
comment|/* copy it */
name|lp
operator|--
expr_stmt|;
operator|*
name|lp
operator|++
operator|=
name|SP
expr_stmt|;
comment|/* add a space */
if|if
condition|(
operator|(
name|y
operator|=
name|cmnum
argument_list|(
literal|"initial value"
argument_list|,
literal|""
argument_list|,
literal|10
argument_list|,
operator|&
name|fx
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|y
operator|==
operator|-
literal|3
condition|)
return|return
operator|(
operator|-
literal|2
operator|)
return|;
else|else
return|return
operator|(
name|y
operator|)
return|;
block|}
name|s
operator|=
name|atmbuf
expr_stmt|;
comment|/* Copy the atom buffer */
if|if
condition|(
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|s
argument_list|)
operator|<
literal|1
condition|)
goto|goto
name|badfor
goto|;
while|while
condition|(
operator|*
name|lp
operator|++
operator|=
operator|*
name|s
operator|++
condition|)
empty_stmt|;
comment|/* (what they actually typed) */
name|lp
operator|--
expr_stmt|;
operator|*
name|lp
operator|++
operator|=
name|SP
expr_stmt|;
if|if
condition|(
operator|(
name|y
operator|=
name|cmnum
argument_list|(
literal|"final value"
argument_list|,
literal|""
argument_list|,
literal|10
argument_list|,
operator|&
name|fy
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|y
operator|==
operator|-
literal|3
condition|)
return|return
operator|(
operator|-
literal|2
operator|)
return|;
else|else
return|return
operator|(
name|y
operator|)
return|;
block|}
name|s
operator|=
name|atmbuf
expr_stmt|;
comment|/* Same deal */
if|if
condition|(
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|s
argument_list|)
operator|<
literal|1
condition|)
goto|goto
name|badfor
goto|;
while|while
condition|(
operator|*
name|lp
operator|++
operator|=
operator|*
name|s
operator|++
condition|)
empty_stmt|;
name|lp
operator|--
expr_stmt|;
operator|*
name|lp
operator|++
operator|=
name|SP
expr_stmt|;
if|if
condition|(
operator|(
name|y
operator|=
name|cmnum
argument_list|(
literal|"increment"
argument_list|,
literal|"1"
argument_list|,
literal|10
argument_list|,
operator|&
name|fz
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|y
operator|==
operator|-
literal|3
condition|)
return|return
operator|(
operator|-
literal|2
operator|)
return|;
else|else
return|return
operator|(
name|y
operator|)
return|;
block|}
name|sprintf
argument_list|(
name|tmpbuf
argument_list|,
literal|"%d "
argument_list|,
name|fz
argument_list|)
expr_stmt|;
name|s
operator|=
name|atmbuf
expr_stmt|;
comment|/* same deal */
if|if
condition|(
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|s
argument_list|)
operator|<
literal|1
condition|)
goto|goto
name|badfor
goto|;
while|while
condition|(
operator|*
name|lp
operator|++
operator|=
operator|*
name|s
operator|++
condition|)
empty_stmt|;
name|lp
operator|--
expr_stmt|;
operator|*
name|lp
operator|++
operator|=
name|SP
expr_stmt|;
comment|/* Insert the appropriate comparison operator */
if|if
condition|(
name|fz
operator|<
literal|0
condition|)
operator|*
name|lp
operator|++
operator|=
literal|'<'
expr_stmt|;
else|else
operator|*
name|lp
operator|++
operator|=
literal|'>'
expr_stmt|;
operator|*
name|lp
operator|++
operator|=
name|SP
expr_stmt|;
if|if
condition|(
operator|(
name|y
operator|=
name|cmtxt
argument_list|(
literal|"Command to execute"
argument_list|,
literal|""
argument_list|,
operator|&
name|s
argument_list|,
name|NULL
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
if|if
condition|(
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|s
argument_list|)
operator|<
literal|1
condition|)
return|return
operator|(
operator|-
literal|2
operator|)
return|;
if|if
condition|(
name|litcmd
argument_list|(
operator|&
name|s
argument_list|,
operator|&
name|lp
argument_list|)
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"?Unbalanced brackets\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|fz
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"?Zero increment not allowed\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|x
operator|=
name|mlook
argument_list|(
name|mactab
argument_list|,
literal|"_forx"
argument_list|,
name|nmac
argument_list|)
expr_stmt|;
comment|/* Look up FOR macro definition */
if|if
condition|(
name|x
operator|<
literal|0
condition|)
block|{
comment|/* Not there? */
name|addmmac
argument_list|(
literal|"_forx"
argument_list|,
name|for_def
argument_list|)
expr_stmt|;
comment|/* Put it back. */
if|if
condition|(
operator|(
name|x
operator|=
name|mlook
argument_list|(
name|mactab
argument_list|,
literal|"_forx"
argument_list|,
name|nmac
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
comment|/* Look it up again. */
name|printf
argument_list|(
literal|"?FOR macro definition gone!\n"
argument_list|)
expr_stmt|;
comment|/* Shouldn't happen. */
return|return
operator|(
name|success
operator|=
literal|0
operator|)
return|;
block|}
block|}
name|debug
argument_list|(
name|F110
argument_list|,
literal|"FOR command"
argument_list|,
name|line
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|success
operator|=
name|dodo
argument_list|(
name|x
argument_list|,
name|ap
argument_list|)
operator|)
return|;
comment|/* Execute the FOR macro. */
name|badfor
label|:
name|printf
argument_list|(
literal|"?Incomplete FOR command\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NOSPL */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NOFRILLS
end_ifndef

begin_comment
comment|/* Do the BUG command */
end_comment

begin_function
name|int
name|dobug
parameter_list|()
block|{
name|printf
argument_list|(
literal|"\n%s,%s\n Numeric: %ld"
argument_list|,
name|versio
argument_list|,
name|ckxsys
argument_list|,
name|vernum
argument_list|)
expr_stmt|;
if|if
condition|(
name|verwho
condition|)
name|printf
argument_list|(
literal|"-%d"
argument_list|,
name|verwho
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\nTo report C-Kermit bugs, send e-mail to:\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" Info-Kermit@columbia.edu (Internet)\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" KERMIT@CUVMA (EARN/BITNET)\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" ...!uunet!columbia.edu!info-kermit (Usenet)\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Or write to:\n Kermit Development\n Columbia University\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" Center for Computing Activities\n 612 W 115 Street\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" New York, NY 10025 USA\nOr call:\n (212) 854-5126 (USA)\n\n"
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NOSHOW
ifndef|#
directive|ifndef
name|NOFRILLS
name|printf
argument_list|(
literal|"Before reporting problems, please use the SHOW VERSION and SHOW FEATURES\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"commands to get detailed program version and configuration information.\n\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* NOFRILLS */
endif|#
directive|endif
comment|/* NOSHOW */
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NOFRILLS */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NOSPL
end_ifndef

begin_function
name|int
name|dopaus
parameter_list|(
name|cx
parameter_list|)
name|int
name|cx
decl_stmt|;
block|{
comment|/* Both should take not only secs but also hh:mm:ss as argument. */
if|if
condition|(
name|cx
operator|==
name|XXWAI
condition|)
name|y
operator|=
name|cmnum
argument_list|(
literal|"seconds to wait"
argument_list|,
literal|"1"
argument_list|,
literal|10
argument_list|,
operator|&
name|x
argument_list|,
name|xxstring
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|cx
operator|==
name|XXPAU
condition|)
name|y
operator|=
name|cmnum
argument_list|(
literal|"seconds to pause"
argument_list|,
literal|"1"
argument_list|,
literal|10
argument_list|,
operator|&
name|x
argument_list|,
name|xxstring
argument_list|)
expr_stmt|;
else|else
name|y
operator|=
name|cmnum
argument_list|(
literal|"milliseconds to sleep"
argument_list|,
literal|"100"
argument_list|,
literal|10
argument_list|,
operator|&
name|x
argument_list|,
name|xxstring
argument_list|)
expr_stmt|;
if|if
condition|(
name|y
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
if|if
condition|(
name|x
operator|<
literal|0
condition|)
name|x
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|cx
condition|)
block|{
case|case
name|XXPAU
case|:
comment|/* PAUSE */
case|case
name|XXMSL
case|:
comment|/* MSLEEP */
if|if
condition|(
operator|(
name|y
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
break|break;
case|case
name|XXWAI
case|:
comment|/* WAIT */
name|z
operator|=
literal|0
expr_stmt|;
comment|/* Modem signal mask */
while|while
condition|(
literal|1
condition|)
block|{
comment|/* Read zero or more signal names */
name|y
operator|=
name|cmkey
argument_list|(
name|mstab
argument_list|,
name|nms
argument_list|,
literal|"modem signal"
argument_list|,
literal|""
argument_list|,
name|xxstring
argument_list|)
expr_stmt|;
if|if
condition|(
name|y
operator|==
operator|-
literal|3
condition|)
break|break;
comment|/* -3 means they typed CR */
if|if
condition|(
name|y
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
comment|/* Other negatives are errors */
name|z
operator||=
name|y
expr_stmt|;
comment|/* OR the bit into the signal mask */
block|}
break|break;
default|default:
comment|/* Shouldn't happen */
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
comment|/* Command is entered, now do it. */
if|if
condition|(
name|cx
operator|==
name|XXMSL
condition|)
block|{
comment|/* Millisecond sleep */
name|msleep
argument_list|(
name|x
argument_list|)
expr_stmt|;
return|return
operator|(
name|success
operator|=
literal|1
operator|)
return|;
block|}
while|while
condition|(
name|x
operator|--
condition|)
block|{
comment|/* Sleep loop */
name|int
name|mdmsig
decl_stmt|;
if|if
condition|(
name|y
operator|=
name|conchk
argument_list|()
condition|)
block|{
comment|/* Did they type something? */
while|while
condition|(
name|y
operator|--
condition|)
name|coninc
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Yes, gobble it up */
break|break;
comment|/* And quit PAUSing or WAITing */
block|}
if|if
condition|(
name|cx
operator|==
name|XXWAI
operator|&&
name|z
operator|!=
literal|0
condition|)
block|{
name|mdmsig
operator|=
name|ttgmdm
argument_list|()
expr_stmt|;
if|if
condition|(
name|mdmsig
operator|<
literal|0
condition|)
return|return
operator|(
name|success
operator|=
literal|0
operator|)
return|;
if|if
condition|(
operator|(
name|mdmsig
operator|&
name|z
operator|)
operator|==
name|z
condition|)
return|return
operator|(
name|success
operator|=
literal|1
operator|)
return|;
block|}
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* No interrupt, sleep one second */
block|}
if|if
condition|(
name|cx
operator|==
name|XXWAI
condition|)
name|success
operator|=
literal|0
expr_stmt|;
else|else
name|success
operator|=
operator|(
name|x
operator|==
operator|-
literal|1
operator|)
expr_stmt|;
comment|/* Set SUCCESS/FAILURE for PAUSE. */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NOSPL */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NOFRILLS
end_ifndef

begin_function
name|int
name|dorenam
parameter_list|()
block|{
if|if
condition|(
operator|(
name|x
operator|=
name|cmifi
argument_list|(
literal|"File to rename"
argument_list|,
literal|""
argument_list|,
operator|&
name|s
argument_list|,
operator|&
name|y
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|x
operator|==
operator|-
literal|3
condition|)
block|{
name|printf
argument_list|(
literal|"?Name of existing file required\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|9
operator|)
return|;
block|}
else|else
return|return
operator|(
name|x
operator|)
return|;
block|}
if|if
condition|(
name|y
condition|)
block|{
comment|/* No wildcards allowed */
name|printf
argument_list|(
literal|"\n?Please specify a single file\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|9
operator|)
return|;
block|}
name|strcpy
argument_list|(
name|line
argument_list|,
name|s
argument_list|)
expr_stmt|;
comment|/* Make a safe copy of the old name */
name|p
operator|=
name|line
operator|+
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|line
argument_list|)
operator|+
literal|2
expr_stmt|;
comment|/* Place for new name */
if|if
condition|(
operator|(
name|x
operator|=
name|cmofi
argument_list|(
literal|"New name"
argument_list|,
literal|""
argument_list|,
operator|&
name|s
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
comment|/* Get new name */
if|if
condition|(
name|x
operator|==
operator|-
literal|3
condition|)
block|{
name|printf
argument_list|(
literal|"?New name for file required\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|9
operator|)
return|;
block|}
else|else
return|return
operator|(
name|x
operator|)
return|;
block|}
name|strcpy
argument_list|(
name|p
argument_list|,
name|s
argument_list|)
expr_stmt|;
comment|/* Make a safe copy of the new name */
if|if
condition|(
operator|(
name|y
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
ifdef|#
directive|ifdef
name|VMS
name|conres
argument_list|()
expr_stmt|;
comment|/* Let Ctrl-C work. */
endif|#
directive|endif
comment|/* VMS */
return|return
operator|(
name|zrename
argument_list|(
name|line
argument_list|,
name|p
argument_list|)
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NOFRILLS */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NOSPL
end_ifndef

begin_comment
comment|/* Do the RETURN command */
end_comment

begin_function
name|int
name|doreturn
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|int
name|x
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|maclvl
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"\n?Can't return from level %d\n"
argument_list|,
name|maclvl
argument_list|)
expr_stmt|;
return|return
operator|(
name|success
operator|=
literal|0
operator|)
return|;
block|}
name|lp
operator|=
name|line
expr_stmt|;
comment|/* Expand return value now */
name|x
operator|=
name|LINBUFSIZ
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|xxstring
argument_list|(
name|s
argument_list|,
operator|&
name|lp
argument_list|,
operator|&
name|x
argument_list|)
operator|>
operator|-
literal|1
condition|)
block|{
name|s
operator|=
name|line
expr_stmt|;
block|}
name|x
operator|=
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* Is there a return value? */
if|if
condition|(
name|x
condition|)
block|{
comment|/* Yes */
name|p
operator|=
name|malloc
argument_list|(
name|x
operator|+
literal|2
argument_list|)
expr_stmt|;
comment|/* Allocate a place to keep it */
if|if
condition|(
name|p
condition|)
block|{
comment|/* Did we get a place? */
name|strcpy
argument_list|(
name|p
argument_list|,
name|s
argument_list|)
expr_stmt|;
comment|/* Yes, copy the string into it. */
name|mrval
index|[
name|maclvl
index|]
operator|=
name|p
expr_stmt|;
comment|/* Make return value point to it. */
block|}
else|else
block|{
comment|/* No, could not get space. */
name|mrval
index|[
name|maclvl
index|]
operator|=
name|NULL
expr_stmt|;
comment|/* Return null pointer. */
name|x
operator|=
literal|0
expr_stmt|;
comment|/* Set failure return code. */
block|}
block|}
else|else
name|mrval
index|[
name|maclvl
index|]
operator|=
name|NULL
expr_stmt|;
comment|/* Blank return code */
undef|#
directive|undef
name|FORRET
comment|/*   If we are in a FOR, WHILE, or XIF command list, also copy the return value   two levels up.  (But this doesn't work, so forget it.) */
ifdef|#
directive|ifdef
name|FORRET
if|if
condition|(
name|maclvl
operator|>
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|m_arg
index|[
name|maclvl
index|]
index|[
literal|0
index|]
argument_list|,
literal|"_for"
argument_list|,
literal|4
argument_list|)
operator|||
operator|!
name|strncmp
argument_list|(
name|m_arg
index|[
name|maclvl
index|]
index|[
literal|0
index|]
argument_list|,
literal|"_whi"
argument_list|,
literal|4
argument_list|)
operator|||
operator|!
name|strncmp
argument_list|(
name|m_arg
index|[
name|maclvl
index|]
index|[
literal|0
index|]
argument_list|,
literal|"_xif"
argument_list|,
literal|4
argument_list|)
condition|)
block|{
name|mrval
index|[
name|maclvl
operator|-
literal|2
index|]
operator|=
name|p
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* FORRET */
name|popclvl
argument_list|()
expr_stmt|;
comment|/* Pop command level */
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|mrval
index|[
name|maclvl
operator|+
literal|1
index|]
condition|)
name|debug
argument_list|(
name|F111
argument_list|,
literal|"&return"
argument_list|,
name|mrval
index|[
name|maclvl
operator|+
literal|1
index|]
argument_list|,
name|maclvl
argument_list|)
expr_stmt|;
else|else
name|debug
argument_list|(
name|F111
argument_list|,
literal|"&return"
argument_list|,
literal|"NULL"
argument_list|,
name|maclvl
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
return|return
operator|(
name|success
operator|=
name|x
condition|?
literal|1
else|:
literal|0
operator|)
return|;
comment|/* Return status code */
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NOSPL */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NOSPL
end_ifndef

begin_comment
comment|/* Do the OPEN command */
end_comment

begin_function
name|int
name|doopen
parameter_list|()
block|{
comment|/* OPEN { append, read, write } */
name|int
name|x
decl_stmt|,
name|y
decl_stmt|,
name|z
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
specifier|static
name|struct
name|filinfo
name|fcb
decl_stmt|;
comment|/* (must be static) */
if|if
condition|(
operator|(
name|x
operator|=
name|cmkey
argument_list|(
name|opntab
argument_list|,
name|nopn
argument_list|,
literal|"mode"
argument_list|,
literal|""
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|x
operator|==
operator|-
literal|3
condition|)
block|{
name|printf
argument_list|(
literal|"?Mode required\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|9
operator|)
return|;
block|}
else|else
return|return
operator|(
name|x
operator|)
return|;
block|}
switch|switch
condition|(
name|x
condition|)
block|{
case|case
name|XYFZ_O
case|:
comment|/* Old file (READ) */
if|if
condition|(
name|chkfn
argument_list|(
name|ZRFILE
argument_list|)
operator|>
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"?Read file already open\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|z
operator|=
name|cmifi
argument_list|(
literal|"File to read"
argument_list|,
literal|""
argument_list|,
operator|&
name|s
argument_list|,
operator|&
name|y
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|z
operator|==
operator|-
literal|3
condition|)
block|{
name|printf
argument_list|(
literal|"?Input filename required\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|9
operator|)
return|;
block|}
else|else
return|return
operator|(
name|z
operator|)
return|;
block|}
if|if
condition|(
name|y
condition|)
block|{
comment|/* No wildcards allowed */
name|printf
argument_list|(
literal|"\n?Please specify a single file\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
name|strcpy
argument_list|(
name|line
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|line
argument_list|)
operator|<
literal|1
condition|)
return|return
operator|(
operator|-
literal|2
operator|)
return|;
if|if
condition|(
operator|(
name|y
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
return|return
operator|(
name|success
operator|=
name|zopeni
argument_list|(
name|ZRFILE
argument_list|,
name|line
argument_list|)
operator|)
return|;
ifndef|#
directive|ifndef
name|MAC
ifndef|#
directive|ifndef
name|NOPUSH
case|case
name|XYFZ_Y
case|:
comment|/* Pipe/Process (READ) */
if|if
condition|(
name|chkfn
argument_list|(
name|ZRFILE
argument_list|)
operator|>
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"?Read file already open\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|y
operator|=
name|cmtxt
argument_list|(
literal|"System command to read from"
argument_list|,
literal|""
argument_list|,
operator|&
name|s
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|y
operator|==
operator|-
literal|3
condition|)
block|{
name|printf
argument_list|(
literal|"?Command name required\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|9
operator|)
return|;
block|}
else|else
return|return
operator|(
name|y
operator|)
return|;
block|}
name|strcpy
argument_list|(
name|line
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|line
argument_list|)
operator|<
literal|1
condition|)
return|return
operator|(
operator|-
literal|2
operator|)
return|;
if|if
condition|(
operator|(
name|y
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
return|return
operator|(
name|success
operator|=
name|zxcmd
argument_list|(
name|ZRFILE
argument_list|,
name|line
argument_list|)
operator|)
return|;
case|case
name|XYFZ_X
case|:
comment|/* Write to pipe */
if|if
condition|(
name|chkfn
argument_list|(
name|ZWFILE
argument_list|)
operator|>
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"?Write file already open\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|y
operator|=
name|cmtxt
argument_list|(
literal|"System command to write to"
argument_list|,
literal|""
argument_list|,
operator|&
name|s
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|y
operator|==
operator|-
literal|3
condition|)
block|{
name|printf
argument_list|(
literal|"?Command name required\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|9
operator|)
return|;
block|}
else|else
return|return
operator|(
name|y
operator|)
return|;
block|}
name|strcpy
argument_list|(
name|line
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|line
argument_list|)
operator|<
literal|1
condition|)
return|return
operator|(
operator|-
literal|2
operator|)
return|;
if|if
condition|(
operator|(
name|y
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
name|success
operator|=
name|zxcmd
argument_list|(
name|ZWFILE
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|success
operator|&&
name|msgflg
condition|)
name|printf
argument_list|(
literal|"Can't open process for writing: %s\n"
argument_list|,
name|line
argument_list|)
expr_stmt|;
return|return
operator|(
name|success
operator|)
return|;
endif|#
directive|endif
comment|/* NOPUSH */
endif|#
directive|endif
comment|/* MAC */
case|case
name|XYFZ_N
case|:
comment|/* New file (WRITE) */
case|case
name|XYFZ_A
case|:
comment|/* (APPEND) */
if|if
condition|(
operator|(
name|z
operator|=
name|cmofi
argument_list|(
literal|"Name of local file to create"
argument_list|,
literal|""
argument_list|,
operator|&
name|s
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|z
operator|==
operator|-
literal|3
condition|)
block|{
name|printf
argument_list|(
literal|"?Filename required\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|9
operator|)
return|;
block|}
else|else
return|return
operator|(
name|z
operator|)
return|;
block|}
if|if
condition|(
name|chkfn
argument_list|(
name|ZWFILE
argument_list|)
operator|>
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"?Write/Append file already open\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
name|fcb
operator|.
name|bs
operator|=
name|fcb
operator|.
name|cs
operator|=
name|fcb
operator|.
name|rl
operator|=
name|fcb
operator|.
name|fmt
operator|=
name|fcb
operator|.
name|org
operator|=
name|fcb
operator|.
name|cc
operator|=
name|fcb
operator|.
name|typ
operator|=
literal|0
expr_stmt|;
name|fcb
operator|.
name|lblopts
operator|=
literal|0
expr_stmt|;
name|fcb
operator|.
name|dsp
operator|=
name|x
expr_stmt|;
comment|/* Create or Append */
name|strcpy
argument_list|(
name|line
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|line
argument_list|)
operator|<
literal|1
condition|)
return|return
operator|(
operator|-
literal|2
operator|)
return|;
if|if
condition|(
operator|(
name|y
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
return|return
operator|(
name|success
operator|=
name|zopeno
argument_list|(
name|ZWFILE
argument_list|,
name|line
argument_list|,
name|NULL
argument_list|,
operator|&
name|fcb
argument_list|)
operator|)
return|;
default|default:
name|printf
argument_list|(
literal|"?Not implemented"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NOSPL */
end_comment

begin_comment
comment|/* Finish parsing and do the GET command */
end_comment

begin_function
name|int
name|doget
parameter_list|()
block|{
name|int
name|x
decl_stmt|;
name|char
modifier|*
name|cbp
decl_stmt|;
name|cmarg2
operator|=
literal|""
expr_stmt|;
comment|/* Initialize as-name to nothing */
name|x
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|NOFRILLS
if|if
condition|(
operator|*
name|cmarg
operator|==
name|NUL
condition|)
block|{
name|printf
argument_list|(
literal|"?Remote filespec required\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|3
operator|)
return|;
block|}
else|#
directive|else
comment|/*   If remote file name omitted, get foreign and local names separately.   But multine GET is allowed only if NOFRILLS is not defined. */
if|if
condition|(
operator|*
name|cmarg
operator|==
name|NUL
condition|)
block|{
if|if
condition|(
name|tlevel
operator|>
operator|-
literal|1
ifndef|#
directive|ifndef
name|NOSPL
operator|&&
name|cmdstk
index|[
name|cmdlvl
index|]
operator|.
name|src
operator|==
name|CMD_TF
endif|#
directive|endif
comment|/* NOSPL */
condition|)
block|{
comment|/* Input is from a command file. */
comment|/* Read 2nd line of GET command */
if|if
condition|(
name|getnct
argument_list|(
name|cmdbuf
argument_list|,
name|CMDBL
argument_list|)
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Command file ends prematurely in multiline GET\n"
argument_list|)
expr_stmt|;
name|popclvl
argument_list|()
expr_stmt|;
return|return
operator|(
operator|-
literal|9
operator|)
return|;
block|}
name|cmres
argument_list|()
expr_stmt|;
comment|/* Parse it */
if|if
condition|(
operator|(
name|x
operator|=
name|cmtxt
argument_list|(
literal|"Oofa"
argument_list|,
literal|""
argument_list|,
operator|&
name|s
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'{'
condition|)
block|{
comment|/* Strip enclosing braces */
name|x
operator|=
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
index|[
name|x
operator|-
literal|1
index|]
operator|==
literal|'}'
condition|)
block|{
name|s
index|[
name|x
operator|-
literal|1
index|]
operator|=
name|NUL
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
block|}
name|strcpy
argument_list|(
name|line
argument_list|,
name|s
argument_list|)
expr_stmt|;
comment|/* Make a safe copy */
name|cmarg
operator|=
name|line
expr_stmt|;
comment|/* Point to remote filename */
if|if
condition|(
operator|*
name|cmarg
operator|==
name|NUL
condition|)
block|{
comment|/* Make sure there is one */
name|printf
argument_list|(
literal|"Remote filename missing in multiline GET\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|9
operator|)
return|;
block|}
name|lp
operator|=
name|line
operator|+
name|strlen
argument_list|(
name|line
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* Place for as-name */
comment|/* And third line... */
name|cmarg2
operator|=
literal|""
expr_stmt|;
comment|/* Assume no as-name */
if|if
condition|(
name|getnct
argument_list|(
name|cmdbuf
argument_list|,
name|CMDBL
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* Get next line */
name|popclvl
argument_list|()
expr_stmt|;
comment|/* There isn't one. */
block|}
else|else
block|{
comment|/* There is... */
if|if
condition|(
operator|*
name|cmdbuf
operator|>=
literal|' '
condition|)
block|{
comment|/* Parse as output filename */
name|cmres
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|x
operator|=
name|cmofi
argument_list|(
literal|"Mupeen"
argument_list|,
name|cmarg
argument_list|,
operator|&
name|s
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
name|strcpy
argument_list|(
name|lp
argument_list|,
name|s
argument_list|)
expr_stmt|;
comment|/* Make a safe copy */
name|cmarg2
operator|=
name|lp
expr_stmt|;
comment|/* Point as-name pointer at it */
block|}
block|}
name|x
operator|=
literal|0
expr_stmt|;
comment|/* Return code OK */
ifndef|#
directive|ifndef
name|NOSPL
comment|/* Reading commands from a macro definition */
block|}
elseif|else
if|if
condition|(
name|cmdlvl
operator|>
literal|0
operator|&&
name|cmdstk
index|[
name|cmdlvl
index|]
operator|.
name|src
operator|==
name|CMD_MD
condition|)
block|{
comment|/* Read second line of GET command */
name|cbp
operator|=
name|cmdbuf
expr_stmt|;
if|if
condition|(
name|getncm
argument_list|(
name|cbp
argument_list|,
name|CMDBL
argument_list|)
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Macro definition ends prematurely in multiline GET\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|9
operator|)
return|;
block|}
name|cmres
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|x
operator|=
name|cmtxt
argument_list|(
literal|"Oofa"
argument_list|,
literal|""
argument_list|,
operator|&
name|s
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
if|if
condition|(
operator|*
name|s
operator|==
name|NUL
condition|)
block|{
comment|/* Make sure we got something */
name|printf
argument_list|(
literal|"Remote filename missing in multiline GET\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|9
operator|)
return|;
block|}
if|if
condition|(
operator|*
name|s
operator|==
literal|'{'
condition|)
block|{
comment|/* Strip enclosing braces */
name|x
operator|=
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
index|[
name|x
operator|-
literal|1
index|]
operator|==
literal|'}'
condition|)
block|{
name|s
index|[
name|x
operator|-
literal|1
index|]
operator|=
name|NUL
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
block|}
name|strcpy
argument_list|(
name|line
argument_list|,
name|s
argument_list|)
expr_stmt|;
comment|/* Copy filename to safe place */
name|cmarg
operator|=
name|line
expr_stmt|;
comment|/* Point to it */
name|x
operator|=
name|strlen
argument_list|(
name|line
argument_list|)
expr_stmt|;
comment|/* Get its length */
name|lp
operator|=
name|line
operator|+
name|x
operator|+
literal|1
expr_stmt|;
comment|/* Where to put the next bit */
name|y
operator|=
name|LINBUFSIZ
operator|-
name|x
operator|-
literal|1
expr_stmt|;
comment|/* Room left for next bit */
comment|/* And third line... */
name|cmarg2
operator|=
literal|""
expr_stmt|;
comment|/* Assume no as-name */
if|if
condition|(
name|getncm
argument_list|(
name|lp
argument_list|,
name|y
argument_list|)
operator|>
operator|-
literal|1
operator|&&
operator|*
name|lp
operator|>=
literal|' '
condition|)
block|{
comment|/* Read next line */
name|x
operator|=
name|strlen
argument_list|(
name|lp
argument_list|)
expr_stmt|;
if|if
condition|(
name|lp
index|[
name|x
operator|-
literal|1
index|]
operator|==
name|CR
condition|)
name|lp
index|[
name|x
operator|-
literal|1
index|]
operator|=
name|NUL
expr_stmt|;
comment|/* Remove CR */
name|cbp
operator|=
name|cmdbuf
expr_stmt|;
comment|/* Interpret the line */
operator|*
name|cbp
operator|=
name|NUL
expr_stmt|;
comment|/* ... */
name|y
operator|=
name|CMDBL
expr_stmt|;
comment|/* into the command buffer */
name|xxstring
argument_list|(
name|lp
argument_list|,
operator|&
name|cbp
argument_list|,
operator|&
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|cmdbuf
condition|)
block|{
comment|/* If we have something */
name|cmres
argument_list|()
expr_stmt|;
comment|/* parse it as an output filename */
name|strcat
argument_list|(
name|cmdbuf
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|x
operator|=
name|cmofi
argument_list|(
literal|"Mupeen"
argument_list|,
literal|""
argument_list|,
operator|&
name|s
argument_list|,
name|NULL
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
name|strcpy
argument_list|(
name|lp
argument_list|,
name|s
argument_list|)
expr_stmt|;
comment|/* Copy the name to safe place */
name|cmarg2
operator|=
name|lp
expr_stmt|;
comment|/* and make as-name pointer */
block|}
block|}
name|x
operator|=
literal|0
expr_stmt|;
comment|/* Return code OK */
endif|#
directive|endif
comment|/* NOSPL */
block|}
else|else
block|{
comment|/* Input is from terminal */
name|cmsavp
argument_list|(
name|psave
argument_list|,
literal|80
argument_list|)
expr_stmt|;
name|cmsetp
argument_list|(
literal|" Remote file specification: "
argument_list|)
expr_stmt|;
comment|/* Make new one */
name|cmini
argument_list|(
name|ckxech
argument_list|)
expr_stmt|;
name|x
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|pflag
condition|)
name|prompt
argument_list|(
name|xxstring
argument_list|)
expr_stmt|;
while|while
condition|(
name|x
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* Prompt till they answer */
name|x
operator|=
name|cmtxt
argument_list|(
literal|"Name of remote file(s)"
argument_list|,
literal|""
argument_list|,
operator|&
name|cmarg
argument_list|,
name|xxstring
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F111
argument_list|,
literal|" cmtxt"
argument_list|,
name|cmarg
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|x
operator|<
literal|0
condition|)
block|{
name|cmsetp
argument_list|(
name|psave
argument_list|)
expr_stmt|;
return|return
operator|(
name|x
operator|)
return|;
block|}
if|if
condition|(
operator|*
name|cmarg
operator|==
name|NUL
condition|)
block|{
comment|/* If user types a bare CR, */
name|printf
argument_list|(
literal|"(cancelled)\n"
argument_list|)
expr_stmt|;
comment|/* Forget about this. */
name|cmsetp
argument_list|(
name|psave
argument_list|)
expr_stmt|;
comment|/* Restore old prompt, */
return|return
operator|(
literal|0
operator|)
return|;
comment|/* and return. */
block|}
if|if
condition|(
operator|*
name|cmarg
operator|==
literal|'{'
condition|)
block|{
comment|/* Strip enclosing braces */
name|x
operator|=
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|cmarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmarg
index|[
name|x
operator|-
literal|1
index|]
operator|==
literal|'}'
condition|)
block|{
name|cmarg
index|[
name|x
operator|-
literal|1
index|]
operator|=
name|NUL
expr_stmt|;
name|cmarg
operator|++
expr_stmt|;
block|}
block|}
name|strcpy
argument_list|(
name|line
argument_list|,
name|cmarg
argument_list|)
expr_stmt|;
comment|/* Make a safe copy */
name|cmarg
operator|=
name|line
expr_stmt|;
name|cmsetp
argument_list|(
literal|" Local name to store it under: "
argument_list|)
expr_stmt|;
comment|/* New prompt */
name|cmini
argument_list|(
name|ckxech
argument_list|)
expr_stmt|;
name|x
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|pflag
condition|)
name|prompt
argument_list|(
name|xxstring
argument_list|)
expr_stmt|;
while|while
condition|(
name|x
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* Again, parse till answered */
name|x
operator|=
name|cmofi
argument_list|(
literal|"Local file name"
argument_list|,
literal|""
argument_list|,
operator|&
name|cmarg2
argument_list|,
name|xxstring
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|x
operator|<
literal|0
condition|)
block|{
comment|/* Parse error */
if|if
condition|(
name|x
operator|==
operator|-
literal|3
condition|)
block|{
comment|/* CR = cancel */
name|printf
argument_list|(
literal|"(cancelled)\n"
argument_list|)
expr_stmt|;
comment|/* Print message */
name|x
operator|=
literal|0
expr_stmt|;
comment|/* Avoid further messages */
block|}
name|cmsetp
argument_list|(
name|psave
argument_list|)
expr_stmt|;
comment|/* Restore prompt */
return|return
operator|(
name|x
operator|)
return|;
block|}
name|x
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Get confirmation. */
while|while
condition|(
name|x
operator|==
operator|-
literal|1
condition|)
name|x
operator|=
name|cmcfm
argument_list|()
expr_stmt|;
name|cmsetp
argument_list|(
name|psave
argument_list|)
expr_stmt|;
comment|/* Restore old prompt. */
block|}
block|}
endif|#
directive|endif
comment|/* NOFRILLS */
if|if
condition|(
name|x
operator|==
literal|0
condition|)
block|{
comment|/* Good return from cmtxt or cmcfm, */
name|debug
argument_list|(
name|F110
argument_list|,
literal|"xxget cmarg"
argument_list|,
name|cmarg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|fspec
argument_list|,
name|cmarg
argument_list|,
name|FSPECL
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F111
argument_list|,
literal|"xxget fspec"
argument_list|,
name|fspec
argument_list|,
name|FSPECL
argument_list|)
expr_stmt|;
name|sstate
operator|=
literal|'r'
expr_stmt|;
comment|/* Set start state. */
if|if
condition|(
name|local
condition|)
block|{
name|displa
operator|=
literal|1
expr_stmt|;
name|ttflui
argument_list|()
expr_stmt|;
block|}
block|}
return|return
operator|(
name|x
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|NOSPL
end_ifndef

begin_function
name|int
name|dogta
parameter_list|(
name|cx
parameter_list|)
name|int
name|cx
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|char
name|c
decl_stmt|;
name|char
name|mbuf
index|[
literal|4
index|]
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|(
name|y
operator|=
name|cmcfm
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
if|if
condition|(
name|cx
operator|==
name|XXGTA
condition|)
name|debug
argument_list|(
name|F101
argument_list|,
literal|"_getargs maclvl"
argument_list|,
literal|""
argument_list|,
name|maclvl
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|cx
operator|==
name|XXPTA
condition|)
name|debug
argument_list|(
name|F101
argument_list|,
literal|"_putargs maclvl"
argument_list|,
literal|""
argument_list|,
name|maclvl
argument_list|)
expr_stmt|;
else|else
return|return
operator|(
operator|-
literal|2
operator|)
return|;
if|if
condition|(
name|maclvl
operator|<
literal|1
condition|)
return|return
operator|(
name|success
operator|=
literal|0
operator|)
return|;
ifdef|#
directive|ifdef
name|COMMENT
ifdef|#
directive|ifdef
name|NEXT
comment|/*    For some reason, this routine makes Kermit core dump on the next after   it returns to docmd().  It works fine, as the debug log shows, but when   docmd returns, it gets a memory fault. */
else|else
return|return
operator|(
literal|1
operator|)
return|;
endif|#
directive|endif
comment|/* NEXT */
endif|#
directive|endif
comment|/* COMMENT */
name|mbuf
index|[
literal|0
index|]
operator|=
literal|'%'
expr_stmt|;
name|mbuf
index|[
literal|1
index|]
operator|=
literal|'0'
expr_stmt|;
name|mbuf
index|[
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Argument name buf */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|10
condition|;
name|i
operator|++
control|)
block|{
comment|/* For all args */
name|c
operator|=
operator|(
name|char
operator|)
name|i
operator|+
literal|'0'
expr_stmt|;
comment|/* Make name */
name|mbuf
index|[
literal|1
index|]
operator|=
name|c
expr_stmt|;
comment|/* Insert digit */
if|if
condition|(
name|cx
operator|==
name|XXGTA
condition|)
block|{
comment|/* Get arg from level-minus-2 */
if|if
condition|(
name|maclvl
operator|==
literal|1
condition|)
name|p
operator|=
name|g_var
index|[
name|c
index|]
expr_stmt|;
comment|/* If at level 1 use globals 0..9 */
else|else
name|p
operator|=
name|m_arg
index|[
name|maclvl
operator|-
literal|2
index|]
index|[
name|i
index|]
expr_stmt|;
comment|/* Otherwise they're on the stack */
if|if
condition|(
operator|!
name|p
condition|)
block|{
name|debug
argument_list|(
name|F111
argument_list|,
literal|"_getarg p"
argument_list|,
literal|"(null pointer)"
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
else|else
name|debug
argument_list|(
name|F111
argument_list|,
literal|"_getarg p"
argument_list|,
name|p
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|addmac
argument_list|(
name|mbuf
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cx
operator|==
name|XXPTA
condition|)
block|{
comment|/* Put args level+2 */
ifndef|#
directive|ifndef
name|MAC
name|connoi
argument_list|()
expr_stmt|;
comment|/* Turn off interrupts. */
endif|#
directive|endif
comment|/* MAC */
name|maclvl
operator|-=
literal|2
expr_stmt|;
comment|/* This is gross.. */
name|p
operator|=
name|m_arg
index|[
name|maclvl
operator|+
literal|2
index|]
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|p
condition|)
name|debug
argument_list|(
name|F111
argument_list|,
literal|"_putarg m_arg[maclvl+2][i]"
argument_list|,
name|p
argument_list|,
name|i
argument_list|)
expr_stmt|;
else|else
name|debug
argument_list|(
name|F111
argument_list|,
literal|"_putarg m_arg[maclvl+2][i]"
argument_list|,
literal|"(null pointer)"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|addmac
argument_list|(
name|mbuf
argument_list|,
name|m_arg
index|[
name|maclvl
operator|+
literal|2
index|]
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|maclvl
operator|+=
literal|2
expr_stmt|;
ifndef|#
directive|ifndef
name|MAC
name|conint
argument_list|(
name|trap
argument_list|,
name|stptrap
argument_list|)
expr_stmt|;
comment|/* Restore interrupts */
endif|#
directive|endif
comment|/* MAC */
block|}
else|else
return|return
operator|(
name|success
operator|=
literal|0
operator|)
return|;
block|}
name|debug
argument_list|(
name|F101
argument_list|,
literal|"_get/putarg exit"
argument_list|,
literal|""
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|"_get/putarg exit maclvl"
argument_list|,
literal|""
argument_list|,
name|maclvl
argument_list|)
expr_stmt|;
return|return
operator|(
name|success
operator|=
literal|1
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NOSPL */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NOSPL
end_ifndef

begin_comment
comment|/* Do the GOTO command */
end_comment

begin_function
name|int
name|dogoto
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|x
decl_stmt|,
name|y
decl_stmt|;
name|char
name|tmplbl
index|[
literal|50
index|]
decl_stmt|,
modifier|*
name|lp
decl_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|"goto cmdlvl"
argument_list|,
literal|""
argument_list|,
name|cmdlvl
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|"goto maclvl"
argument_list|,
literal|""
argument_list|,
name|maclvl
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|"goto tlevel"
argument_list|,
literal|""
argument_list|,
name|tlevel
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F110
argument_list|,
literal|"goto before conversion"
argument_list|,
name|s
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|y
operator|=
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|!=
literal|':'
condition|)
block|{
comment|/* If the label mentioned */
for|for
control|(
name|i
operator|=
name|y
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
comment|/* does not begin with a colon, */
name|s
index|[
name|i
index|]
operator|=
name|s
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
comment|/* then insert one. */
block|}
comment|/* Also, convert to lowercase. */
name|s
index|[
literal|0
index|]
operator|=
literal|':'
expr_stmt|;
name|s
index|[
operator|++
name|y
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
name|debug
argument_list|(
name|F111
argument_list|,
literal|"goto after conversion"
argument_list|,
name|s
argument_list|,
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
index|[
literal|1
index|]
operator|==
literal|'.'
operator|||
name|s
index|[
literal|1
index|]
operator|==
name|SP
operator|||
name|s
index|[
literal|1
index|]
operator|==
name|NUL
condition|)
block|{
name|printf
argument_list|(
literal|"?Bad label syntax - '%s'\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|success
operator|=
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|cmdlvl
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"?Sorry, GOTO only works in a command file or macro\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|success
operator|=
literal|0
operator|)
return|;
block|}
while|while
condition|(
name|cmdlvl
operator|>
literal|0
condition|)
block|{
comment|/* Only works inside macros& files */
if|if
condition|(
name|cmdstk
index|[
name|cmdlvl
index|]
operator|.
name|src
operator|==
name|CMD_MD
condition|)
block|{
comment|/* GOTO inside macro */
name|int
name|i
decl_stmt|,
name|m
decl_stmt|,
name|flag
decl_stmt|;
name|char
modifier|*
name|xp
decl_stmt|,
modifier|*
name|tp
decl_stmt|;
name|lp
operator|=
name|macx
index|[
name|maclvl
index|]
expr_stmt|;
name|m
operator|=
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|lp
argument_list|)
operator|-
name|y
operator|+
literal|1
expr_stmt|;
name|debug
argument_list|(
name|F111
argument_list|,
literal|"goto in macro"
argument_list|,
name|lp
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|flag
operator|=
literal|1
expr_stmt|;
comment|/* flag for valid label position */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|m
condition|;
name|i
operator|++
operator|,
name|lp
operator|++
control|)
block|{
comment|/* search for label in macro body */
if|if
condition|(
operator|*
name|lp
operator|==
literal|','
condition|)
block|{
comment|/* Really should also watch out */
name|flag
operator|=
literal|1
expr_stmt|;
comment|/* for braces here...  Commas in */
continue|continue;
comment|/* in braces are not really commas */
block|}
if|if
condition|(
name|flag
condition|)
block|{
comment|/* If in valid label position */
if|if
condition|(
operator|*
name|lp
operator|==
name|SP
condition|)
comment|/* eat leading spaces */
continue|continue;
if|if
condition|(
operator|*
name|lp
operator|!=
literal|':'
condition|)
block|{
comment|/* Look for label introducer */
name|flag
operator|=
literal|0
expr_stmt|;
comment|/* this isn't it */
continue|continue;
comment|/* keep looking */
block|}
block|}
if|if
condition|(
operator|!
name|flag
condition|)
comment|/* We don't have a label */
continue|continue;
comment|/*  so keep looking... */
name|xp
operator|=
name|lp
expr_stmt|;
name|tp
operator|=
name|tmplbl
expr_stmt|;
comment|/* Copy the label from the macro */
name|j
operator|=
literal|0
expr_stmt|;
comment|/* to make it null-terminated */
while|while
condition|(
operator|*
name|tp
operator|=
operator|*
name|xp
condition|)
block|{
if|if
condition|(
name|j
operator|++
operator|>
literal|50
condition|)
break|break;
comment|/* j = length of word from macro */
if|if
condition|(
operator|*
name|tp
operator|<
literal|33
operator|||
operator|*
name|tp
operator|==
literal|','
condition|)
comment|/* Look for end of word */
break|break;
else|else
name|tp
operator|++
operator|,
name|xp
operator|++
expr_stmt|;
comment|/* Next character */
block|}
operator|*
name|tp
operator|=
literal|'\0'
expr_stmt|;
comment|/* In case we stopped early */
comment|/* Now do caseless string comparison, using longest length */
name|debug
argument_list|(
name|F111
argument_list|,
literal|"macro GOTO label"
argument_list|,
name|s
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F111
argument_list|,
literal|"macro target label"
argument_list|,
name|tmplbl
argument_list|,
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|xxstrcmp
argument_list|(
name|s
argument_list|,
name|tmplbl
argument_list|,
operator|(
name|y
operator|>
name|j
operator|)
condition|?
name|y
else|:
name|j
argument_list|)
condition|)
break|break;
else|else
name|flag
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
name|m
condition|)
block|{
comment|/* didn't find the label */
name|debug
argument_list|(
name|F101
argument_list|,
literal|"goto failed at cmdlvl"
argument_list|,
literal|""
argument_list|,
name|cmdlvl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|popclvl
argument_list|()
condition|)
block|{
comment|/* pop up to next higher level */
name|printf
argument_list|(
literal|"?Label '%s' not found\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
comment|/* if none */
return|return
operator|(
literal|0
operator|)
return|;
comment|/* quit */
block|}
else|else
continue|continue;
comment|/* otherwise look again */
block|}
name|debug
argument_list|(
name|F110
argument_list|,
literal|"goto found macro label"
argument_list|,
name|lp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|macp
index|[
name|maclvl
index|]
operator|=
name|lp
expr_stmt|;
comment|/* set macro buffer pointer */
return|return
operator|(
literal|1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|cmdstk
index|[
name|cmdlvl
index|]
operator|.
name|src
operator|==
name|CMD_TF
condition|)
block|{
name|x
operator|=
literal|0
expr_stmt|;
comment|/* GOTO issued in take file */
name|rewind
argument_list|(
name|tfile
index|[
name|tlevel
index|]
argument_list|)
expr_stmt|;
comment|/* Search file from beginning */
while|while
condition|(
operator|!
name|feof
argument_list|(
name|tfile
index|[
name|tlevel
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|fgets
argument_list|(
name|line
argument_list|,
name|LINBUFSIZ
argument_list|,
name|tfile
index|[
name|tlevel
index|]
argument_list|)
operator|==
name|NULL
condition|)
comment|/* Get line */
break|break;
comment|/* If no more, done, label not found */
name|lp
operator|=
name|line
expr_stmt|;
comment|/* Got line */
while|while
condition|(
operator|*
name|lp
operator|==
name|SP
operator|||
operator|*
name|lp
operator|==
name|HT
condition|)
name|lp
operator|++
expr_stmt|;
comment|/* Strip leading whitespace */
if|if
condition|(
operator|*
name|lp
operator|!=
literal|':'
condition|)
continue|continue;
comment|/* Check for label introducer */
name|tp
operator|=
name|lp
expr_stmt|;
comment|/* Get end of word */
name|j
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|tp
condition|)
block|{
comment|/* And null-terminate it */
if|if
condition|(
operator|*
name|tp
operator|<
literal|33
condition|)
block|{
operator|*
name|tp
operator|=
literal|'\0'
expr_stmt|;
break|break;
block|}
else|else
name|tp
operator|++
operator|,
name|j
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|xxstrcmp
argument_list|(
name|lp
argument_list|,
name|s
argument_list|,
operator|(
name|y
operator|>
name|j
operator|)
condition|?
name|y
else|:
name|j
argument_list|)
condition|)
block|{
comment|/* Caseless compare */
name|x
operator|=
literal|1
expr_stmt|;
comment|/* Got it */
break|break;
comment|/* done. */
block|}
block|}
if|if
condition|(
name|x
operator|==
literal|0
condition|)
block|{
comment|/* If not found, print message */
name|debug
argument_list|(
name|F101
argument_list|,
literal|"goto failed at cmdlvl"
argument_list|,
literal|""
argument_list|,
name|cmdlvl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|popclvl
argument_list|()
condition|)
block|{
comment|/* pop up to next higher level */
name|printf
argument_list|(
literal|"?Label '%s' not found\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
comment|/* if none */
return|return
operator|(
literal|0
operator|)
return|;
comment|/* quit */
block|}
else|else
continue|continue;
comment|/* otherwise look again */
block|}
return|return
operator|(
name|x
operator|)
return|;
comment|/* Send back return code */
block|}
block|}
name|printf
argument_list|(
literal|"?Stack problem in GOTO %s\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
comment|/* Shouldn't see this */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NOSPL */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NOSPL
end_ifndef

begin_comment
comment|/* Finish parsing and do the IF, XIF, and WHILE commands */
end_comment

begin_function
name|int
name|doif
parameter_list|(
name|cx
parameter_list|)
name|int
name|cx
decl_stmt|;
block|{
name|int
name|x
decl_stmt|,
name|y
decl_stmt|,
name|z
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|not
operator|=
literal|0
expr_stmt|;
comment|/* Flag for whether "NOT" was seen */
name|z
operator|=
literal|0
expr_stmt|;
comment|/* Initial IF condition */
name|ifargs
operator|=
literal|0
expr_stmt|;
comment|/* Count of IF condition words */
name|ifagain
label|:
if|if
condition|(
operator|(
name|ifc
operator|=
name|cmkey
argument_list|(
name|iftab
argument_list|,
name|nif
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
comment|/* If what?... */
if|if
condition|(
name|ifc
operator|==
operator|-
literal|3
condition|)
block|{
name|printf
argument_list|(
literal|"?Condition required\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|9
operator|)
return|;
block|}
else|else
return|return
operator|(
name|ifc
operator|)
return|;
block|}
switch|switch
condition|(
name|ifc
condition|)
block|{
comment|/* set z = 1 for true, 0 for false */
case|case
name|XXIFNO
case|:
comment|/* IF NOT */
name|not
operator|^=
literal|1
expr_stmt|;
comment|/* So NOT NOT NOT ... will work */
name|ifargs
operator|++
expr_stmt|;
goto|goto
name|ifagain
goto|;
case|case
name|XXIFSU
case|:
comment|/* IF SUCCESS */
name|z
operator|=
operator|(
name|success
operator|!=
literal|0
operator|)
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|"if success"
argument_list|,
literal|""
argument_list|,
name|z
argument_list|)
expr_stmt|;
name|ifargs
operator|+=
literal|1
expr_stmt|;
break|break;
case|case
name|XXIFFA
case|:
comment|/* IF FAILURE */
name|z
operator|=
operator|(
name|success
operator|==
literal|0
operator|)
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|"if failure"
argument_list|,
literal|""
argument_list|,
name|z
argument_list|)
expr_stmt|;
name|ifargs
operator|+=
literal|1
expr_stmt|;
break|break;
case|case
name|XXIFDE
case|:
comment|/* IF DEFINED */
if|if
condition|(
operator|(
name|x
operator|=
name|cmfld
argument_list|(
literal|"Macro or variable name"
argument_list|,
literal|""
argument_list|,
operator|&
name|s
argument_list|,
name|NULL
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|x
operator|==
operator|-
literal|3
condition|)
return|return
operator|(
operator|-
literal|2
operator|)
return|;
else|else
return|return
operator|(
name|x
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|COMMENT
name|strcpy
argument_list|(
name|line
argument_list|,
name|s
argument_list|)
expr_stmt|;
comment|/* Make a copy */
if|if
condition|(
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|line
argument_list|)
operator|<
literal|1
condition|)
return|return
operator|(
operator|-
literal|2
operator|)
return|;
name|lp
operator|=
name|line
expr_stmt|;
if|if
condition|(
name|line
index|[
literal|0
index|]
operator|==
name|CMDQ
operator|&&
operator|(
name|line
index|[
literal|1
index|]
operator|==
literal|'%'
operator|||
name|line
index|[
literal|1
index|]
operator|==
literal|'&'
operator|)
condition|)
name|lp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|lp
operator|==
literal|'%'
condition|)
block|{
comment|/* Is it a variable? */
name|x
operator|=
operator|*
operator|(
name|lp
operator|+
literal|1
operator|)
expr_stmt|;
comment|/* Fold case */
if|if
condition|(
name|isupper
argument_list|(
name|x
argument_list|)
condition|)
operator|*
operator|(
name|lp
operator|+
literal|1
operator|)
operator|=
name|tolower
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|>=
literal|'0'
operator|&&
name|x
operator|<=
literal|'9'
operator|&&
name|maclvl
operator|>
operator|-
literal|1
condition|)
comment|/* Digit is macro arg */
name|z
operator|=
operator|(
operator|(
name|m_arg
index|[
name|maclvl
index|]
index|[
name|x
operator|-
literal|'0'
index|]
operator|!=
operator|(
name|char
operator|*
operator|)
literal|0
operator|)
operator|&&
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|m_arg
index|[
name|maclvl
index|]
index|[
name|x
operator|-
literal|'0'
index|]
argument_list|)
operator|!=
literal|0
operator|)
expr_stmt|;
else|else
comment|/* Otherwise it's a global variable */
name|z
operator|=
operator|(
operator|(
name|g_var
index|[
name|x
index|]
operator|!=
operator|(
name|char
operator|*
operator|)
literal|0
operator|)
operator|&&
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|g_var
index|[
name|x
index|]
argument_list|)
operator|!=
literal|0
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|lp
operator|==
literal|'&'
condition|)
block|{
comment|/* Array reference */
name|int
name|cc
decl_stmt|,
name|nn
decl_stmt|;
if|if
condition|(
name|arraynam
argument_list|(
name|lp
argument_list|,
operator|&
name|cc
argument_list|,
operator|&
name|nn
argument_list|)
operator|<
literal|0
condition|)
name|z
operator|=
literal|0
expr_stmt|;
else|else
name|z
operator|=
operator|(
name|arrayval
argument_list|(
name|cc
argument_list|,
name|nn
argument_list|)
operator|==
name|NULL
condition|?
literal|0
else|:
literal|1
operator|)
expr_stmt|;
block|}
else|#
directive|else
if|if
condition|(
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|s
argument_list|)
operator|<
literal|1
condition|)
return|return
operator|(
operator|-
literal|2
operator|)
return|;
name|z
operator|=
literal|0
expr_stmt|;
comment|/* Assume failure. */
if|if
condition|(
operator|*
name|s
operator|==
name|CMDQ
condition|)
block|{
comment|/* Object begins with backslash. */
name|char
name|c
decl_stmt|;
name|c
operator|=
name|s
index|[
literal|1
index|]
expr_stmt|;
comment|/* Character following backslash */
if|if
condition|(
name|c
condition|)
block|{
name|c
operator|=
name|islower
argument_list|(
name|c
argument_list|)
condition|?
name|toupper
argument_list|(
name|c
argument_list|)
else|:
name|c
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'%'
operator|||
comment|/* Simple variable */
name|c
operator|==
literal|'&'
operator|||
comment|/* Array element */
name|c
operator|==
literal|'$'
operator|||
comment|/* Environment variable */
name|c
operator|==
literal|'V'
operator|||
comment|/* Builtin named variable */
name|c
operator|==
literal|'M'
operator|||
comment|/* Macro name */
name|c
operator|==
literal|'F'
condition|)
block|{
comment|/* Builtin function */
name|int
name|t
decl_stmt|;
comment|/* Let xxstring() evaluate it */
name|t
operator|=
name|LINBUFSIZ
operator|-
literal|1
expr_stmt|;
comment|/* This lets us test \v(xxx) */
name|lp
operator|=
name|line
expr_stmt|;
comment|/* and even \f...(xxx) */
name|xxstring
argument_list|(
name|s
argument_list|,
operator|&
name|lp
argument_list|,
operator|&
name|t
argument_list|)
expr_stmt|;
name|t
operator|=
name|strlen
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F111
argument_list|,
literal|"IF DEF"
argument_list|,
name|line
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|z
operator|=
name|t
operator|>
literal|0
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
comment|/* COMMENT */
else|else
block|{
comment|/* Otherwise it's a macro name */
name|z
operator|=
operator|(
name|mxlook
argument_list|(
name|mactab
argument_list|,
name|s
argument_list|,
name|nmac
argument_list|)
operator|>
operator|-
literal|1
operator|)
expr_stmt|;
comment|/* Look for exact match */
block|}
name|debug
argument_list|(
name|F111
argument_list|,
literal|"if defined"
argument_list|,
name|s
argument_list|,
name|z
argument_list|)
expr_stmt|;
name|ifargs
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|XXIFBG
case|:
comment|/* IF BACKGROUND */
case|case
name|XXIFFG
case|:
comment|/* IF FOREGROUND */
name|bgchk
argument_list|()
expr_stmt|;
comment|/* Check background status */
if|if
condition|(
name|ifc
operator|==
name|XXIFFG
condition|)
comment|/* Foreground */
name|z
operator|=
name|pflag
condition|?
literal|1
else|:
literal|0
expr_stmt|;
else|else
name|z
operator|=
name|pflag
condition|?
literal|0
else|:
literal|1
expr_stmt|;
comment|/* Background */
name|ifargs
operator|+=
literal|1
expr_stmt|;
break|break;
case|case
name|XXIFCO
case|:
comment|/* IF COUNT */
name|z
operator|=
operator|(
operator|--
name|count
index|[
name|cmdlvl
index|]
operator|>
literal|0
operator|)
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|"if count"
argument_list|,
literal|""
argument_list|,
name|z
argument_list|)
expr_stmt|;
name|ifargs
operator|+=
literal|1
expr_stmt|;
break|break;
case|case
name|XXIFEX
case|:
comment|/* IF EXIST */
if|if
condition|(
operator|(
name|x
operator|=
name|cmfld
argument_list|(
literal|"File"
argument_list|,
literal|""
argument_list|,
operator|&
name|s
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|x
operator|==
operator|-
literal|3
condition|)
block|{
name|printf
argument_list|(
literal|"?Filename required\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|9
operator|)
return|;
block|}
else|else
return|return
operator|(
name|x
operator|)
return|;
block|}
name|z
operator|=
operator|(
name|zchki
argument_list|(
name|s
argument_list|)
operator|>
operator|-
literal|1L
operator|)
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|"if exist"
argument_list|,
literal|""
argument_list|,
name|z
argument_list|)
expr_stmt|;
name|ifargs
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|XXIFEQ
case|:
comment|/* IF EQUAL (string comparison) */
case|case
name|XXIFLL
case|:
comment|/* IF Lexically Less Than */
case|case
name|XXIFLG
case|:
comment|/* If Lexically Greater Than */
if|if
condition|(
operator|(
name|x
operator|=
name|cmfld
argument_list|(
literal|"first word or variable name"
argument_list|,
literal|""
argument_list|,
operator|&
name|s
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|x
operator|==
operator|-
literal|3
condition|)
block|{
name|printf
argument_list|(
literal|"?Text required\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|9
operator|)
return|;
block|}
else|else
return|return
operator|(
name|x
operator|)
return|;
block|}
name|x
operator|=
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|>
name|LINBUFSIZ
operator|-
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"?IF: strings too long\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
name|lp
operator|=
name|line
expr_stmt|;
comment|/* lp points to first string */
name|strcpy
argument_list|(
name|lp
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|y
operator|=
name|cmfld
argument_list|(
literal|"second word or variable name"
argument_list|,
literal|""
argument_list|,
operator|&
name|s
argument_list|,
name|xxstring
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|y
operator|==
operator|-
literal|3
condition|)
block|{
name|printf
argument_list|(
literal|"?Text required\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|9
operator|)
return|;
block|}
else|else
return|return
operator|(
name|y
operator|)
return|;
block|}
name|y
operator|=
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|+
name|y
operator|+
literal|2
operator|>
name|LINBUFSIZ
condition|)
block|{
name|printf
argument_list|(
literal|"?IF: strings too long\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
name|tp
operator|=
name|lp
operator|+
name|y
operator|+
literal|2
expr_stmt|;
comment|/* tp points to second string */
name|strcpy
argument_list|(
name|tp
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|incase
condition|)
comment|/* INPUT CASE OBSERVE */
name|x
operator|=
name|strcmp
argument_list|(
name|lp
argument_list|,
name|tp
argument_list|)
expr_stmt|;
else|else
comment|/* INPUT CASE IGNORE */
name|x
operator|=
name|xxstrcmp
argument_list|(
name|lp
argument_list|,
name|tp
argument_list|,
operator|(
name|y
operator|>
name|x
operator|)
condition|?
name|y
else|:
name|x
argument_list|)
expr_stmt|;
comment|/* Use longest length */
name|debug
argument_list|(
name|F101
argument_list|,
literal|"IF comparison"
argument_list|,
literal|""
argument_list|,
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ifc
condition|)
block|{
case|case
name|XXIFEQ
case|:
comment|/* IF EQUAL (string comparison) */
name|z
operator|=
operator|(
name|x
operator|==
literal|0
operator|)
expr_stmt|;
break|break;
case|case
name|XXIFLL
case|:
comment|/* IF Lexically Less Than */
name|z
operator|=
operator|(
name|x
operator|<
literal|0
operator|)
expr_stmt|;
break|break;
case|case
name|XXIFLG
case|:
comment|/* If Lexically Greater Than */
name|z
operator|=
operator|(
name|x
operator|>
literal|0
operator|)
expr_stmt|;
break|break;
block|}
name|ifargs
operator|+=
literal|3
expr_stmt|;
break|break;
case|case
name|XXIFAE
case|:
comment|/* IF (arithmetically) = */
case|case
name|XXIFLT
case|:
comment|/* IF (arithmetically)< */
case|case
name|XXIFGT
case|:
block|{
comment|/* IF (arithmetically)> */
comment|/* Really should use longs here... */
comment|/* But cmnum parses ints. */
name|int
name|n1
decl_stmt|,
name|n2
decl_stmt|;
name|x
operator|=
name|cmfld
argument_list|(
literal|"first number or variable name"
argument_list|,
literal|""
argument_list|,
operator|&
name|s
argument_list|,
name|xxstring
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|==
operator|-
literal|3
condition|)
block|{
name|printf
argument_list|(
literal|"?Quantity required\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|9
operator|)
return|;
block|}
if|if
condition|(
name|x
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|"xxifgt cmfld"
argument_list|,
literal|""
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|lp
operator|=
name|line
expr_stmt|;
name|strcpy
argument_list|(
name|lp
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F110
argument_list|,
literal|"xxifgt exp1"
argument_list|,
name|lp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|xxstrcmp
argument_list|(
name|lp
argument_list|,
literal|"count"
argument_list|,
literal|5
argument_list|)
condition|)
block|{
name|n1
operator|=
name|count
index|[
name|cmdlvl
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|xxstrcmp
argument_list|(
name|lp
argument_list|,
literal|"version"
argument_list|,
literal|7
argument_list|)
condition|)
block|{
name|n1
operator|=
operator|(
name|int
operator|)
name|vernum
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|xxstrcmp
argument_list|(
name|lp
argument_list|,
literal|"argc"
argument_list|,
literal|4
argument_list|)
condition|)
block|{
name|n1
operator|=
operator|(
name|int
operator|)
name|macargc
index|[
name|maclvl
index|]
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|chknum
argument_list|(
name|lp
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|2
operator|)
return|;
name|n1
operator|=
name|atoi
argument_list|(
name|lp
argument_list|)
expr_stmt|;
block|}
name|y
operator|=
name|cmfld
argument_list|(
literal|"second number or variable name"
argument_list|,
literal|""
argument_list|,
operator|&
name|s
argument_list|,
name|xxstring
argument_list|)
expr_stmt|;
if|if
condition|(
name|y
operator|==
operator|-
literal|3
condition|)
block|{
name|printf
argument_list|(
literal|"?Quantity required\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|9
operator|)
return|;
block|}
if|if
condition|(
name|y
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
if|if
condition|(
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|s
argument_list|)
operator|<
literal|1
condition|)
return|return
operator|(
operator|-
literal|2
operator|)
return|;
name|x
operator|=
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|lp
argument_list|)
expr_stmt|;
name|tp
operator|=
name|line
operator|+
name|x
operator|+
literal|2
expr_stmt|;
name|strcpy
argument_list|(
name|tp
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F110
argument_list|,
literal|"xxifgt exp2"
argument_list|,
name|tp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|xxstrcmp
argument_list|(
name|tp
argument_list|,
literal|"count"
argument_list|,
literal|5
argument_list|)
condition|)
block|{
name|n2
operator|=
name|count
index|[
name|cmdlvl
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|xxstrcmp
argument_list|(
name|tp
argument_list|,
literal|"version"
argument_list|,
literal|7
argument_list|)
condition|)
block|{
name|n2
operator|=
operator|(
name|int
operator|)
name|vernum
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|xxstrcmp
argument_list|(
name|tp
argument_list|,
literal|"argc"
argument_list|,
literal|4
argument_list|)
condition|)
block|{
name|n2
operator|=
operator|(
name|int
operator|)
name|macargc
index|[
name|maclvl
index|]
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|chknum
argument_list|(
name|tp
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|2
operator|)
return|;
name|n2
operator|=
name|atoi
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
name|debug
argument_list|(
name|F101
argument_list|,
literal|"xxifft ifc"
argument_list|,
literal|""
argument_list|,
name|ifc
argument_list|)
expr_stmt|;
name|z
operator|=
operator|(
operator|(
name|n1
operator|<
name|n2
operator|&&
name|ifc
operator|==
name|XXIFLT
operator|)
operator|||
operator|(
name|n1
operator|==
name|n2
operator|&&
name|ifc
operator|==
name|XXIFAE
operator|)
operator|||
operator|(
name|n1
operator|>
name|n2
operator|&&
name|ifc
operator|==
name|XXIFGT
operator|)
operator|)
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|"xxifft n1"
argument_list|,
literal|""
argument_list|,
name|n1
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|"xxifft n2"
argument_list|,
literal|""
argument_list|,
name|n2
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|"xxifft z"
argument_list|,
literal|""
argument_list|,
name|z
argument_list|)
expr_stmt|;
name|ifargs
operator|+=
literal|3
expr_stmt|;
break|break;
block|}
case|case
name|XXIFNU
case|:
comment|/* IF NUMERIC */
name|x
operator|=
name|cmfld
argument_list|(
literal|"variable name or constant"
argument_list|,
literal|""
argument_list|,
operator|&
name|s
argument_list|,
name|xxstring
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|==
operator|-
literal|3
condition|)
block|{
name|printf
argument_list|(
literal|"?Quantity required\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|9
operator|)
return|;
block|}
if|if
condition|(
name|x
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|)
return|;
name|debug
argument_list|(
name|F111
argument_list|,
literal|"xxifnu cmfld"
argument_list|,
name|s
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|lp
operator|=
name|line
expr_stmt|;
name|strcpy
argument_list|(
name|lp
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F110
argument_list|,
literal|"xxifnu quantity"
argument_list|,
name|lp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|z
operator|=
name|chknum
argument_list|(
name|lp
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F101
argument_list|,
literal|"xxifnu chknum"
argument_list|,
literal|""
argument_list|,
name|z
argument_list|)
expr_stmt|;
name|ifargs
operator|+=
literal|2
expr_stmt|;
break|break;
default|default:
comment|/* Shouldn't happen */
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
switch|switch
condition|(
name|cx
condition|)
block|{
comment|/* Separate handling for IF and XIF */
case|case
name|XXIF
case|:
comment|/* This is IF... */
name|ifcmd
index|[
name|cmdlvl
index|]
operator|=
literal|1
expr_stmt|;
comment|/* We just completed an IF command */
if|if
condition|(
name|not
condition|)
name|z
operator|=
operator|!
name|z
expr_stmt|;
comment|/* Handle NOT here */
if|if
condition|(
name|z
condition|)
block|{
comment|/* Condition is true */
name|iftest
index|[
name|cmdlvl
index|]
operator|=
literal|1
expr_stmt|;
comment|/* Remember that IF succeeded */
if|if
condition|(
name|maclvl
operator|>
operator|-
literal|1
condition|)
block|{
comment|/* In macro, */
name|pushcmd
argument_list|()
expr_stmt|;
comment|/* save rest of command. */
block|}
elseif|else
if|if
condition|(
name|tlevel
operator|>
operator|-
literal|1
condition|)
block|{
comment|/* In take file, */
name|debug
argument_list|(
name|F100
argument_list|,
literal|"doif: pushing command"
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pushcmd
argument_list|()
expr_stmt|;
comment|/* save rest of command. */
block|}
else|else
block|{
comment|/* If interactive, */
name|cmini
argument_list|(
name|ckxech
argument_list|)
expr_stmt|;
comment|/* just start a new command */
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* (like in MS-DOS Kermit) */
if|if
condition|(
name|pflag
condition|)
name|prompt
argument_list|(
name|xxstring
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Condition is false */
name|iftest
index|[
name|cmdlvl
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Remember command failed. */
if|if
condition|(
operator|(
name|y
operator|=
name|cmtxt
argument_list|(
literal|"command to be ignored"
argument_list|,
literal|""
argument_list|,
operator|&
name|s
argument_list|,
name|NULL
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
comment|/* Gobble up rest of line */
block|}
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|XXIFX
case|:
block|{
comment|/* This is XIF (Extended IF) */
name|char
modifier|*
name|p
decl_stmt|;
name|char
name|e
index|[
literal|5
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|(
name|y
operator|=
name|cmtxt
argument_list|(
literal|"Object command"
argument_list|,
literal|""
argument_list|,
operator|&
name|s
argument_list|,
name|NULL
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
comment|/* Get object command. */
name|p
operator|=
name|s
expr_stmt|;
name|lp
operator|=
name|line
expr_stmt|;
if|if
condition|(
name|litcmd
argument_list|(
operator|&
name|p
argument_list|,
operator|&
name|lp
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* Insert quotes in THEN-part */
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|z
condition|)
block|{
comment|/* Use ELSE-part, if any */
name|lp
operator|=
name|line
expr_stmt|;
comment|/* Write over THEN part. */
operator|*
name|lp
operator|=
name|NUL
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|==
name|SP
condition|)
name|p
operator|++
expr_stmt|;
comment|/* Strip trailing spaces */
if|if
condition|(
operator|*
name|p
condition|)
block|{
comment|/* At end? */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
name|e
index|[
name|i
index|]
operator|=
operator|*
name|p
operator|++
expr_stmt|;
comment|/* No, check for ELSE */
if|if
condition|(
name|xxstrcmp
argument_list|(
name|e
argument_list|,
literal|"else"
argument_list|,
literal|4
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|2
operator|)
return|;
comment|/* No, syntax error */
if|if
condition|(
name|litcmd
argument_list|(
operator|&
name|p
argument_list|,
operator|&
name|lp
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* Insert quotes */
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
while|while
condition|(
operator|*
name|p
operator|==
name|SP
condition|)
name|p
operator|++
expr_stmt|;
comment|/* Strip trailing spaces */
if|if
condition|(
operator|*
name|p
condition|)
return|return
operator|(
operator|-
literal|2
operator|)
return|;
comment|/* Should be nothing here. */
block|}
block|}
if|if
condition|(
name|line
index|[
literal|0
index|]
condition|)
block|{
name|x
operator|=
name|mlook
argument_list|(
name|mactab
argument_list|,
literal|"_xif"
argument_list|,
name|nmac
argument_list|)
expr_stmt|;
comment|/* get index of "_xif" macro. */
if|if
condition|(
name|x
operator|<
literal|0
condition|)
block|{
comment|/* Not there? */
name|addmmac
argument_list|(
literal|"_xif"
argument_list|,
name|xif_def
argument_list|)
expr_stmt|;
comment|/* Put it back. */
if|if
condition|(
name|mlook
argument_list|(
name|mactab
argument_list|,
literal|"_xif"
argument_list|,
name|nmac
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* Look it up again. */
name|printf
argument_list|(
literal|"?XIF macro gone!\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|success
operator|=
literal|0
operator|)
return|;
block|}
block|}
name|dodo
argument_list|(
name|x
argument_list|,
name|line
argument_list|)
expr_stmt|;
comment|/* Do the XIF macro */
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
case|case
name|XXWHI
case|:
block|{
comment|/* WHILE Command */
name|p
operator|=
name|cmdbuf
expr_stmt|;
comment|/* Capture IF condition */
name|ifcond
index|[
literal|0
index|]
operator|=
name|NUL
expr_stmt|;
comment|/* from command buffer */
while|while
condition|(
operator|*
name|p
operator|==
name|SP
condition|)
name|p
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
name|SP
condition|)
name|p
operator|++
expr_stmt|;
name|ifcp
operator|=
name|ifcond
expr_stmt|;
name|strcpy
argument_list|(
name|ifcp
argument_list|,
literal|"{ \\flit(if not "
argument_list|)
expr_stmt|;
name|ifcp
operator|+=
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|ifcp
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'{'
operator|&&
operator|*
name|p
operator|!=
name|NUL
condition|)
operator|*
name|ifcp
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
name|p
operator|=
literal|" goto wbot) } "
expr_stmt|;
while|while
condition|(
operator|*
name|ifcp
operator|++
operator|=
operator|*
name|p
operator|++
condition|)
empty_stmt|;
name|debug
argument_list|(
name|F110
argument_list|,
literal|"WHILE cmd"
argument_list|,
name|ifcond
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|y
operator|=
name|cmtxt
argument_list|(
literal|"Object command"
argument_list|,
literal|""
argument_list|,
operator|&
name|s
argument_list|,
name|NULL
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|y
operator|)
return|;
comment|/* Get object command. */
name|p
operator|=
name|s
expr_stmt|;
name|lp
operator|=
name|line
expr_stmt|;
if|if
condition|(
name|litcmd
argument_list|(
operator|&
name|p
argument_list|,
operator|&
name|lp
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* Insert quotes in object command */
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
name|debug
argument_list|(
name|F110
argument_list|,
literal|"WHILE body"
argument_list|,
name|line
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
index|[
literal|0
index|]
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|x
operator|=
name|mlook
argument_list|(
name|mactab
argument_list|,
literal|"_while"
argument_list|,
name|nmac
argument_list|)
expr_stmt|;
comment|/* index of "_while" macro. */
if|if
condition|(
name|x
operator|<
literal|0
condition|)
block|{
comment|/* Not there? */
name|addmmac
argument_list|(
literal|"_while"
argument_list|,
name|whil_def
argument_list|)
expr_stmt|;
comment|/* Put it back. */
if|if
condition|(
name|mlook
argument_list|(
name|mactab
argument_list|,
literal|"_while"
argument_list|,
name|nmac
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* Look it up again */
name|printf
argument_list|(
literal|"?WHILE macro definition gone!\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|success
operator|=
literal|0
operator|)
return|;
block|}
block|}
name|p
operator|=
name|malloc
argument_list|(
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|ifcond
argument_list|)
operator|+
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|line
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
block|{
name|strcpy
argument_list|(
name|p
argument_list|,
name|ifcond
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|p
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F110
argument_list|,
literal|"WHILE dodo"
argument_list|,
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dodo
argument_list|(
name|x
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"?Can't allocate storage for WHILE command"
argument_list|)
expr_stmt|;
return|return
operator|(
name|success
operator|=
literal|0
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
default|default:
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NOSPL */
end_comment

begin_comment
comment|/* Set up a TAKE command file */
end_comment

begin_function
name|int
name|dotake
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
if|if
condition|(
operator|(
name|tfile
index|[
operator|++
name|tlevel
index|]
operator|=
name|fopen
argument_list|(
name|s
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|debug
argument_list|(
name|F110
argument_list|,
literal|"Failure to open"
argument_list|,
name|s
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|success
operator|=
literal|0
expr_stmt|;
name|tlevel
operator|--
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|VMS
name|conres
argument_list|()
expr_stmt|;
comment|/* So Ctrl-C will work */
endif|#
directive|endif
comment|/* VMS */
ifndef|#
directive|ifndef
name|NOSPL
name|cmdlvl
operator|++
expr_stmt|;
comment|/* Entering a new command level */
if|if
condition|(
name|cmdlvl
operator|>
name|CMDSTKL
condition|)
block|{
name|cmdlvl
operator|--
expr_stmt|;
name|printf
argument_list|(
literal|"?TAKE files and/or DO commands nested too deeply\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|success
operator|=
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|tfnam
index|[
name|tlevel
index|]
condition|)
name|free
argument_list|(
name|tfnam
index|[
name|tlevel
index|]
argument_list|)
expr_stmt|;
comment|/* Copy the filename */
if|if
condition|(
name|tfnam
index|[
name|tlevel
index|]
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
literal|1
argument_list|)
condition|)
name|strcpy
argument_list|(
name|tfnam
index|[
name|tlevel
index|]
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|ifcmd
index|[
name|cmdlvl
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Set variables for this cmd file */
name|iftest
index|[
name|cmdlvl
index|]
operator|=
literal|0
expr_stmt|;
name|count
index|[
name|cmdlvl
index|]
operator|=
literal|0
expr_stmt|;
name|cmdstk
index|[
name|cmdlvl
index|]
operator|.
name|src
operator|=
name|CMD_TF
expr_stmt|;
comment|/* Say we're in a TAKE file */
name|cmdstk
index|[
name|cmdlvl
index|]
operator|.
name|lvl
operator|=
name|tlevel
expr_stmt|;
comment|/* nested at this level */
endif|#
directive|endif
comment|/* NOSPL */
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NOICP */
end_comment

end_unit

