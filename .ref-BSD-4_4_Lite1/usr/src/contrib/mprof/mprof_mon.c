begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	mprof_mon.c 1.1 9/14/90 11:59:04	*/
end_comment

begin_comment
comment|/*	Copyright (c) 1987, Benjamin G. Zorn */
end_comment

begin_comment
comment|/* mprof_mon -- code that is attached to executing programs.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|"mprof.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|mips
end_ifdef

begin_include
include|#
directive|include
file|<filehdr.h>
end_include

begin_include
include|#
directive|include
file|<syms.h>
end_include

begin_include
include|#
directive|include
file|<ldfcn.h>
end_include

begin_decl_stmt
name|int
name|intloc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* for use by assembly routines */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* local routines */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|mips
end_ifdef

begin_function_decl
name|pPDR
name|getpdr
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
name|void
name|mp_note_alloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|mp_note_free
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|mpcell
name|mp_note_parent
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|mp_note_leaf
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|mpsstk
name|mprof
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|mprof_note_free
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|mprof_startup
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|mprof_writefile
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|mprof_cleanup
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* local variables */
end_comment

begin_decl_stmt
name|char
modifier|*
name|mprof_filename
init|=
literal|"mprof.data"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|mprof_autosave
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|mprof_file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|mprof_initialized
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|mprofing
init|=
name|TRUE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|mprof_create_mask
init|=
literal|0644
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|int
name|main
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|unsigned
name|mp_root_address
init|=
name|CRT0_ADDRESS
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|mprof_bound1
init|=
literal|32
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|mprof_bound2
init|=
literal|256
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|mprof_bound3
init|=
literal|2048
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|mprof_alloc_bins
index|[
name|MP_NUM_BINS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|mprof_free_bins
index|[
name|MP_NUM_BINS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* mp_zero_bins() -- initialize the bins to zero  */
end_comment

begin_function
name|void
name|mp_zero_bins
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MP_NUM_BINS
condition|;
name|i
operator|++
control|)
name|mprof_alloc_bins
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MP_NUM_BINS
condition|;
name|i
operator|++
control|)
name|mprof_free_bins
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* mp_inc_bin(bin, size) -- increment the bin of the appropriate size.  */
end_comment

begin_function
name|void
name|mp_inc_bin
parameter_list|(
name|bin
parameter_list|,
name|size
parameter_list|)
name|int
name|bin
index|[]
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
if|if
condition|(
name|size
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"mp_inc_bin -- negative size\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|size
operator|<
name|MP_NUM_BINS
operator|-
literal|2
condition|)
block|{
name|bin
index|[
name|size
index|]
operator|++
expr_stmt|;
block|}
else|else
block|{
name|bin
index|[
name|MP_NUM_BINS
operator|-
literal|2
index|]
operator|++
expr_stmt|;
name|bin
index|[
name|MP_NUM_BINS
operator|-
literal|1
index|]
operator|+=
name|size
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* mp_print_bins(file) -- print the bins to a file  */
end_comment

begin_function
name|void
name|mp_print_bins
parameter_list|(
name|file
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|char
name|digits
index|[
literal|32
index|]
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MP_NUM_BINS
condition|;
name|i
operator|++
control|)
block|{
name|sprintf
argument_list|(
name|digits
argument_list|,
literal|"%d\n"
argument_list|,
name|mprof_alloc_bins
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|file
argument_list|,
name|digits
argument_list|,
name|strlen
argument_list|(
name|digits
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MP_NUM_BINS
condition|;
name|i
operator|++
control|)
block|{
name|sprintf
argument_list|(
name|digits
argument_list|,
literal|"%d\n"
argument_list|,
name|mprof_free_bins
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|file
argument_list|,
name|digits
argument_list|,
name|strlen
argument_list|(
name|digits
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* mp_note_alloc -- note allocation by bin.  There are currently  * four bins with boundaries that are potentially user setable.  */
end_comment

begin_function
name|void
name|mp_note_alloc
parameter_list|(
name|d
parameter_list|,
name|nbytes
parameter_list|)
name|mpdata
name|d
decl_stmt|;
name|int
name|nbytes
decl_stmt|;
block|{
if|if
condition|(
name|nbytes
operator|<=
name|mprof_bound1
condition|)
block|{
name|dt_b_small
argument_list|(
name|d
argument_list|)
operator|+=
name|nbytes
expr_stmt|;
name|dt_d_small
argument_list|(
name|d
argument_list|)
operator|+=
name|nbytes
expr_stmt|;
name|dt_n_small
argument_list|(
name|d
argument_list|)
operator|+=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nbytes
operator|<=
name|mprof_bound2
condition|)
block|{
name|dt_b_med
argument_list|(
name|d
argument_list|)
operator|+=
name|nbytes
expr_stmt|;
name|dt_d_med
argument_list|(
name|d
argument_list|)
operator|+=
name|nbytes
expr_stmt|;
name|dt_n_med
argument_list|(
name|d
argument_list|)
operator|+=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nbytes
operator|<=
name|mprof_bound3
condition|)
block|{
name|dt_b_large
argument_list|(
name|d
argument_list|)
operator|+=
name|nbytes
expr_stmt|;
name|dt_d_large
argument_list|(
name|d
argument_list|)
operator|+=
name|nbytes
expr_stmt|;
name|dt_n_large
argument_list|(
name|d
argument_list|)
operator|+=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|dt_b_xlarge
argument_list|(
name|d
argument_list|)
operator|+=
name|nbytes
expr_stmt|;
name|dt_d_xlarge
argument_list|(
name|d
argument_list|)
operator|+=
name|nbytes
expr_stmt|;
name|dt_n_xlarge
argument_list|(
name|d
argument_list|)
operator|+=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* mp_note_free -- note when a memory block is released.  */
end_comment

begin_function
name|void
name|mp_note_free
parameter_list|(
name|d
parameter_list|,
name|nbytes
parameter_list|)
name|mpdata
name|d
decl_stmt|;
name|int
name|nbytes
decl_stmt|;
block|{
if|if
condition|(
name|nbytes
operator|<=
name|mprof_bound1
condition|)
block|{
name|dt_d_small
argument_list|(
name|d
argument_list|)
operator|-=
name|nbytes
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nbytes
operator|<=
name|mprof_bound2
condition|)
block|{
name|dt_d_med
argument_list|(
name|d
argument_list|)
operator|-=
name|nbytes
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nbytes
operator|<=
name|mprof_bound3
condition|)
block|{
name|dt_d_large
argument_list|(
name|d
argument_list|)
operator|-=
name|nbytes
expr_stmt|;
block|}
else|else
block|{
name|dt_d_xlarge
argument_list|(
name|d
argument_list|)
operator|-=
name|nbytes
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* mp_note_parent -- record a caller/callee relationship.  * Allocate a data cell and put the parent on the parents list if  * necessary.  */
end_comment

begin_function
name|mpcell
name|mp_note_parent
parameter_list|(
name|p
parameter_list|,
name|c
parameter_list|,
name|nbytes
parameter_list|)
name|mpsym
name|p
decl_stmt|,
name|c
decl_stmt|;
name|int
name|nbytes
decl_stmt|;
block|{
name|mpcell
name|ppair
decl_stmt|;
name|mpdata
name|dcell
decl_stmt|;
comment|/* if yes -- is parent already listed?      */
name|ppair
operator|=
name|mp_has_parent
argument_list|(
name|c
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mp_null
argument_list|(
name|ppair
argument_list|)
condition|)
block|{
comment|/* if yes -- increment count of calls from parent 	 */
name|mp_note_alloc
argument_list|(
operator|(
name|mpdata
operator|)
name|mp_cdr
argument_list|(
name|ppair
argument_list|)
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* if no -- add this parent to the list of parents 	 */
name|dcell
operator|=
name|mp_new_data
argument_list|()
expr_stmt|;
name|mp_note_alloc
argument_list|(
name|dcell
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
name|ppair
operator|=
name|mp_cons
argument_list|(
operator|(
name|int
operator|)
name|p
argument_list|,
operator|(
name|mpcell
operator|)
name|dcell
argument_list|)
expr_stmt|;
name|fn_parents
argument_list|(
name|c
argument_list|)
operator|=
name|mp_cons
argument_list|(
operator|(
name|int
operator|)
name|ppair
argument_list|,
name|fn_parents
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|ppair
return|;
block|}
end_function

begin_comment
comment|/* mp_note_leaf -- note allocation directly in the function.  */
end_comment

begin_function
name|void
name|mp_note_leaf
parameter_list|(
name|l
parameter_list|,
name|nbytes
parameter_list|)
name|mpsym
name|l
decl_stmt|;
name|int
name|nbytes
decl_stmt|;
block|{
name|mp_note_alloc
argument_list|(
name|fn_lcount
argument_list|(
name|l
argument_list|)
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|MAXCALLS
value|5000
end_define

begin_comment
comment|/* variables to record information about the monitoring  */
end_comment

begin_decl_stmt
name|int
name|mprof_cs_maxdepth
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|mprof_cs_sameC
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|mprof_cs_allC
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|mprof_allocC
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|mprof_freeC
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|mprof_debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|no_call_graph
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|pcs1
index|[
name|MAXCALLS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|pcs2
index|[
name|MAXCALLS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
modifier|*
name|fpcs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|mpsym
name|fsyms
index|[
name|MAXCALLS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|mpcell
name|fpcells
index|[
name|MAXCALLS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|fstk_i
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
modifier|*
name|last_fpcs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|last_fstk_i
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|short_callstack
index|[
name|SHORT_CALLSTACK_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_function
name|mpsstk
name|mprof
parameter_list|(
name|nbytes
parameter_list|)
name|int
name|nbytes
decl_stmt|;
block|{
name|unsigned
name|first_local
decl_stmt|;
comment|/* WARNING -- This MUST be the first 					 * local variable in this function. 					 */
name|unsigned
name|fp
decl_stmt|;
name|unsigned
name|ret_addr
decl_stmt|;
name|mpsym
name|child
decl_stmt|,
name|parent
decl_stmt|;
name|int
name|i
decl_stmt|,
name|lasti
decl_stmt|,
name|j
decl_stmt|;
name|int
name|lookupcount
decl_stmt|,
name|samecount
decl_stmt|;
name|unsigned
modifier|*
name|pcstmp
decl_stmt|;
name|mpsstk
name|leakdata
decl_stmt|;
ifdef|#
directive|ifdef
name|mips
name|pPDR
name|pdr
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|mprof_initialized
condition|)
block|{
name|mprof_startup
argument_list|()
expr_stmt|;
name|mprof_initialized
operator|=
name|TRUE
expr_stmt|;
block|}
name|mprof_allocC
operator|++
expr_stmt|;
name|mp_inc_bin
argument_list|(
name|mprof_alloc_bins
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|mprof_autosave
operator|&&
operator|(
name|mprof_allocC
operator|%
name|mprof_autosave
operator|)
operator|==
literal|0
condition|)
block|{
name|mprof_writefile
argument_list|()
expr_stmt|;
block|}
name|fstk_i
operator|=
literal|0
expr_stmt|;
comment|/* gather return addresses from the callstack      */
ifndef|#
directive|ifndef
name|mips
name|fp
operator|=
name|get_current_fp
argument_list|(
name|first_local
argument_list|)
expr_stmt|;
name|ret_addr
operator|=
name|ret_addr_from_fp
argument_list|(
name|fp
argument_list|)
expr_stmt|;
comment|/* Step back 1 frame (to the caller of malloc)      */
name|fp
operator|=
name|prev_fp_from_fp
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|ret_addr
operator|=
name|ret_addr_from_fp
argument_list|(
name|fp
argument_list|)
expr_stmt|;
while|while
condition|(
name|ret_addr
operator|>
name|mp_root_address
condition|)
block|{
if|if
condition|(
name|no_call_graph
operator|&&
operator|(
name|fstk_i
operator|>
name|SHORT_CALLSTACK_SIZE
operator|)
condition|)
break|break;
name|fpcs
index|[
name|fstk_i
index|]
operator|=
name|ret_addr
expr_stmt|;
name|fstk_i
operator|++
expr_stmt|;
name|fp
operator|=
name|prev_fp_from_fp
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
literal|0
condition|)
break|break;
name|ret_addr
operator|=
name|ret_addr_from_fp
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|get31
argument_list|()
expr_stmt|;
name|pdr
operator|=
name|getpdr
argument_list|(
name|intloc
argument_list|)
expr_stmt|;
name|getsp
argument_list|()
expr_stmt|;
name|fp
operator|=
name|intloc
expr_stmt|;
name|ret_addr
operator|=
name|getretaddr
argument_list|(
operator|&
name|fp
argument_list|,
name|pdr
argument_list|)
expr_stmt|;
comment|/* fp is changed */
comment|/* Step back 1 frame (to the caller of malloc) */
name|pdr
operator|=
name|getpdr
argument_list|(
name|ret_addr
argument_list|)
expr_stmt|;
name|ret_addr
operator|=
name|getretaddr
argument_list|(
operator|&
name|fp
argument_list|,
name|pdr
argument_list|)
expr_stmt|;
comment|/* fp is changed */
while|while
condition|(
name|ret_addr
operator|>
name|mp_root_address
condition|)
block|{
if|if
condition|(
name|no_call_graph
operator|&&
operator|(
name|fstk_i
operator|>
name|SHORT_CALLSTACK_SIZE
operator|)
condition|)
break|break;
name|fpcs
index|[
name|fstk_i
index|]
operator|=
name|ret_addr
expr_stmt|;
name|fstk_i
operator|++
expr_stmt|;
name|pdr
operator|=
name|getpdr
argument_list|(
name|ret_addr
argument_list|)
expr_stmt|;
name|ret_addr
operator|=
name|getretaddr
argument_list|(
operator|&
name|fp
argument_list|,
name|pdr
argument_list|)
expr_stmt|;
comment|/* fp is updated */
block|}
endif|#
directive|endif
comment|/* note last N addresses (short_callstack) for the leak table      */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SHORT_CALLSTACK_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|short_callstack
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
operator|(
name|i
operator|<
name|SHORT_CALLSTACK_SIZE
operator|)
operator|&&
operator|(
name|i
operator|<
name|fstk_i
operator|)
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|short_callstack
index|[
name|i
index|]
operator|=
name|fpcs
index|[
name|i
index|]
expr_stmt|;
block|}
name|leakdata
operator|=
name|mp_add_leak_table
argument_list|(
name|short_callstack
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|no_call_graph
condition|)
block|{
comment|/* note the direct allocation 	 */
name|mp_note_leaf
argument_list|(
name|pc_lookup
argument_list|(
name|fpcs
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
return|return
name|leakdata
return|;
block|}
comment|/* note maximum stack depth      */
if|if
condition|(
name|fstk_i
operator|>
name|mprof_cs_maxdepth
condition|)
name|mprof_cs_maxdepth
operator|=
name|fstk_i
expr_stmt|;
comment|/* determine the overlap with the last callstack      */
name|i
operator|=
name|fstk_i
operator|-
literal|1
expr_stmt|;
name|lasti
operator|=
name|last_fstk_i
operator|-
literal|1
expr_stmt|;
while|while
condition|(
operator|(
name|lasti
operator|>
literal|0
operator|)
operator|&&
operator|(
name|i
operator|>
literal|0
operator|)
operator|&&
operator|(
name|fpcs
index|[
name|i
index|]
operator|==
name|last_fpcs
index|[
name|lasti
index|]
operator|)
condition|)
block|{
name|i
operator|--
expr_stmt|;
name|lasti
operator|--
expr_stmt|;
block|}
comment|/* i is the index of the first difference of pc's in the stack      * i+1 is the number of pc's that need to be looked up      */
name|lookupcount
operator|=
name|i
operator|+
literal|1
expr_stmt|;
comment|/* put the new calls in the stack of functions      */
if|if
condition|(
name|lookupcount
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|j
operator|=
name|fstk_i
operator|-
name|lookupcount
init|;
name|j
operator|<
name|fstk_i
condition|;
name|j
operator|++
control|)
block|{
name|fsyms
index|[
name|j
index|]
operator|=
name|pc_lookup
argument_list|(
name|fpcs
index|[
name|fstk_i
operator|-
name|j
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|samecount
operator|=
name|fstk_i
operator|-
name|lookupcount
expr_stmt|;
name|mprof_cs_sameC
operator|+=
name|samecount
expr_stmt|;
name|mprof_cs_allC
operator|+=
name|fstk_i
expr_stmt|;
comment|/* record the parent/child relations      */
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|fstk_i
operator|-
literal|1
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|parent
operator|=
name|fsyms
index|[
name|i
index|]
expr_stmt|;
name|child
operator|=
name|fsyms
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|mprof_debug
condition|)
name|printf
argument_list|(
literal|"%d -> "
argument_list|,
name|fn_addr
argument_list|(
name|parent
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
operator|(
name|samecount
operator|-
literal|1
operator|)
condition|)
block|{
name|mp_note_alloc
argument_list|(
operator|(
name|mpdata
operator|)
name|mp_cdr
argument_list|(
name|fpcells
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fpcells
index|[
name|i
operator|+
literal|1
index|]
operator|=
name|mp_note_parent
argument_list|(
name|parent
argument_list|,
name|child
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|mprof_debug
condition|)
name|printf
argument_list|(
literal|"%d\n"
argument_list|,
name|fn_addr
argument_list|(
name|child
argument_list|)
argument_list|)
expr_stmt|;
name|mp_note_leaf
argument_list|(
name|fsyms
index|[
operator|(
name|fstk_i
operator|-
literal|1
operator|)
index|]
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
comment|/* swap the last pc stack with the current one      */
name|pcstmp
operator|=
name|fpcs
expr_stmt|;
name|fpcs
operator|=
name|last_fpcs
expr_stmt|;
name|last_fpcs
operator|=
name|pcstmp
expr_stmt|;
name|last_fstk_i
operator|=
name|fstk_i
expr_stmt|;
return|return
name|leakdata
return|;
block|}
end_function

begin_function
name|void
name|mprof_note_free
parameter_list|(
name|leakdata
parameter_list|,
name|nbytes
parameter_list|)
name|mpsstk
name|leakdata
decl_stmt|;
name|int
name|nbytes
decl_stmt|;
block|{
name|mpsym
name|f
decl_stmt|;
name|unsigned
name|addr
decl_stmt|;
name|addr
operator|=
name|leakdata
operator|->
name|sstack
index|[
literal|0
index|]
expr_stmt|;
name|mprof_freeC
operator|++
expr_stmt|;
name|mp_inc_bin
argument_list|(
name|mprof_free_bins
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
name|f
operator|=
name|pc_lookup
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|mp_note_free
argument_list|(
name|fn_lcount
argument_list|(
name|f
argument_list|)
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
name|mp_remove_leak_table
argument_list|(
name|leakdata
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|mprof_startup
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|sun
name|on_exit
argument_list|(
name|mprof_exit
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|strcmp
argument_list|(
name|mprof_filename
argument_list|,
literal|""
argument_list|)
operator|==
literal|0
condition|)
block|{
name|mprof_file
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|mprof_file
operator|=
name|open
argument_list|(
name|mprof_filename
argument_list|,
operator|(
name|O_WRONLY
operator||
name|O_CREAT
operator||
name|O_TRUNC
operator|)
argument_list|,
name|mprof_create_mask
argument_list|)
expr_stmt|;
block|}
name|mpstruct_init
argument_list|()
expr_stmt|;
name|mp_zero_bins
argument_list|()
expr_stmt|;
name|mpleak_init
argument_list|()
expr_stmt|;
name|mprof_cs_maxdepth
operator|=
literal|0
expr_stmt|;
name|mprof_cs_sameC
operator|=
literal|0
expr_stmt|;
name|mprof_cs_allC
operator|=
literal|0
expr_stmt|;
name|mprof_allocC
operator|=
literal|0
expr_stmt|;
name|mprof_freeC
operator|=
literal|0
expr_stmt|;
name|last_fstk_i
operator|=
literal|0
expr_stmt|;
name|fpcs
operator|=
name|pcs1
expr_stmt|;
name|last_fpcs
operator|=
name|pcs2
expr_stmt|;
ifdef|#
directive|ifdef
name|mips
name|pdrinit
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|mprof_writefile
parameter_list|()
block|{
name|char
name|stats
index|[
literal|256
index|]
decl_stmt|;
specifier|extern
name|int
name|mprof_fmemC
decl_stmt|,
name|mprof_dmemC
decl_stmt|,
name|mprof_lmemC
decl_stmt|,
name|mprof_smemC
decl_stmt|;
name|ftruncate
argument_list|(
name|mprof_file
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|lseek
argument_list|(
name|mprof_file
argument_list|,
literal|0L
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|stats
argument_list|,
literal|"alloc=%d free=%d depth=%d same=%d all=%d\n"
argument_list|,
name|mprof_allocC
argument_list|,
name|mprof_freeC
argument_list|,
name|mprof_cs_maxdepth
argument_list|,
name|mprof_cs_sameC
argument_list|,
name|mprof_cs_allC
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|mprof_file
argument_list|,
name|stats
argument_list|,
name|strlen
argument_list|(
name|stats
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|stats
argument_list|,
literal|"fmem=%d dmem=%d lmem=%d smem=%d\n"
argument_list|,
operator|(
name|mprof_fmemC
operator|*
name|MPSYM_SIZE
operator|)
operator|/
literal|1024
argument_list|,
operator|(
name|mprof_dmemC
operator|*
name|MPDATA_SIZE
operator|)
operator|/
literal|1024
argument_list|,
operator|(
name|mprof_lmemC
operator|*
name|MPCELL_SIZE
operator|)
operator|/
literal|1024
argument_list|,
operator|(
name|mprof_smemC
operator|*
name|MPSSTK_SIZE
operator|)
operator|/
literal|1024
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|mprof_file
argument_list|,
name|stats
argument_list|,
name|strlen
argument_list|(
name|stats
argument_list|)
argument_list|)
expr_stmt|;
name|mp_print_bins
argument_list|(
name|mprof_file
argument_list|)
expr_stmt|;
name|mp_print_leak_table
argument_list|(
name|mprof_file
argument_list|)
expr_stmt|;
name|mprof_print
argument_list|(
name|mprof_file
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|mprof_cleanup
parameter_list|()
block|{
if|if
condition|(
name|mprof_initialized
condition|)
block|{
name|mprof_writefile
argument_list|()
expr_stmt|;
name|close
argument_list|(
name|mprof_file
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* external interface --     void    set_mprof_autosave(count)	-- set the autosave count of profile data    int count;			   count = 0 (default)  implies no autosave     void    mprof_stop()			-- stop the memory profile in progress     void    mprof_restart(datafile)	-- restart memory profiling  */
end_comment

begin_function
name|void
name|set_mprof_autosave
parameter_list|(
name|count
parameter_list|)
name|int
name|count
decl_stmt|;
block|{
name|mprof_autosave
operator|=
name|count
expr_stmt|;
block|}
end_function

begin_function
name|void
name|mprof_restart
parameter_list|(
name|datafile
parameter_list|)
name|char
modifier|*
name|datafile
decl_stmt|;
block|{
if|if
condition|(
name|mprofing
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"mprof_restart -- restart ingnored; memory profiling in progress\n"
argument_list|)
expr_stmt|;
else|else
block|{
name|mprof_initialized
operator|=
name|FALSE
expr_stmt|;
name|mprofing
operator|=
name|TRUE
expr_stmt|;
name|mprof_filename
operator|=
name|datafile
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|mprof_stop
parameter_list|()
block|{
if|if
condition|(
operator|!
name|mprofing
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"mprof_stop -- stop ingnored; memory profiling not in progress\n"
argument_list|)
expr_stmt|;
else|else
block|{
name|mprof_cleanup
argument_list|()
expr_stmt|;
name|mprofing
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|mips
end_ifdef

begin_decl_stmt
name|pPDR
name|pdrarray
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LDFILE
modifier|*
name|ldptr
decl_stmt|;
end_decl_stmt

begin_macro
name|pdrinit
argument_list|()
end_macro

begin_block
block|{
name|int
name|i
decl_stmt|;
name|SYMR
name|asym
decl_stmt|;
specifier|extern
name|char
modifier|*
modifier|*
name|__Argv
decl_stmt|;
comment|/* hack */
name|pFDR
name|pfd
decl_stmt|;
name|ldptr
operator|=
name|ldopen
argument_list|(
name|__Argv
index|[
literal|0
index|]
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* hack */
name|pdrarray
operator|=
operator|(
name|pPDR
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|PDR
argument_list|)
operator|*
name|SYMHEADER
argument_list|(
name|ldptr
argument_list|)
operator|.
name|ipdMax
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|notdef
comment|/* doesn't work for libraries compiled -O */
comment|/* read in pdr table */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SYMHEADER
argument_list|(
name|ldptr
argument_list|)
operator|.
name|ipdMax
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ldgetpd
argument_list|(
name|ldptr
argument_list|,
name|i
argument_list|,
operator|&
name|pdrarray
index|[
name|i
index|]
argument_list|)
operator|!=
name|SUCCESS
condition|)
block|{
name|printf
argument_list|(
literal|"bad pdr %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|i
operator|--
expr_stmt|;
continue|continue;
block|}
block|}
endif|#
directive|endif
comment|/* indirectly read in pdr table through the file descriptor table */
for|for
control|(
name|pfd
operator|=
name|PFD
argument_list|(
name|ldptr
argument_list|)
init|;
name|pfd
operator|<
name|PFD
argument_list|(
name|ldptr
argument_list|)
operator|+
name|SYMHEADER
argument_list|(
name|ldptr
argument_list|)
operator|.
name|ifdMax
condition|;
name|pfd
operator|++
control|)
block|{
for|for
control|(
name|i
operator|=
name|pfd
operator|->
name|ipdFirst
init|;
name|i
operator|<
name|pfd
operator|->
name|ipdFirst
operator|+
name|pfd
operator|->
name|cpd
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ldgetpd
argument_list|(
name|ldptr
argument_list|,
name|i
argument_list|,
operator|&
name|pdrarray
index|[
name|i
index|]
argument_list|)
operator|!=
name|SUCCESS
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"can't read pdr %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pdrarray
index|[
name|i
index|]
operator|.
name|isym
operator|!=
name|isymNil
condition|)
block|{
if|if
condition|(
name|ldtbread
argument_list|(
name|ldptr
argument_list|,
name|pfd
operator|->
name|csym
condition|?
name|pdrarray
index|[
name|i
index|]
operator|.
name|isym
else|:
name|pdrarray
index|[
name|i
index|]
operator|.
name|isym
operator|+
name|SYMHEADER
argument_list|(
name|ldptr
argument_list|)
operator|.
name|isymMax
argument_list|,
operator|&
name|asym
argument_list|)
operator|!=
name|SUCCESS
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"can't read symbol"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|pdrarray
index|[
name|i
index|]
operator|.
name|adr
operator|=
name|asym
operator|.
name|value
expr_stmt|;
block|}
block|}
block|}
comment|/* This is guaranteed to be between __start and main. */
name|mp_root_address
operator|=
name|pdrarray
index|[
literal|1
index|]
operator|.
name|adr
operator|-
literal|1
expr_stmt|;
block|}
end_block

begin_function
name|pPDR
name|getpdr
parameter_list|(
name|loc
parameter_list|)
name|int
name|loc
decl_stmt|;
block|{
name|int
name|low
init|=
literal|0
decl_stmt|,
name|high
init|=
name|SYMHEADER
argument_list|(
name|ldptr
argument_list|)
operator|.
name|ipdMax
operator|-
literal|1
decl_stmt|,
name|mid
decl_stmt|;
comment|/* do binary search on address */
while|while
condition|(
name|low
operator|<=
name|high
condition|)
block|{
name|mid
operator|=
operator|(
name|low
operator|+
name|high
operator|)
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|loc
operator|<
name|pdrarray
index|[
name|mid
index|]
operator|.
name|adr
condition|)
block|{
name|high
operator|=
name|mid
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|loc
operator|>
name|pdrarray
index|[
name|mid
index|]
operator|.
name|adr
condition|)
block|{
name|low
operator|=
name|mid
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
return|return
operator|(
operator|&
name|pdrarray
index|[
name|mid
index|]
operator|)
return|;
block|}
block|}
return|return
operator|(
operator|&
name|pdrarray
index|[
name|low
operator|-
literal|1
index|]
operator|)
return|;
block|}
end_function

begin_macro
name|getretaddr
argument_list|(
argument|pfp
argument_list|,
argument|pdr
argument_list|)
end_macro

begin_decl_stmt
name|int
modifier|*
name|pfp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|pPDR
name|pdr
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|fp
init|=
operator|*
name|pfp
decl_stmt|;
name|int
name|retaddr
decl_stmt|;
name|int
name|saved31loc
decl_stmt|;
comment|/* return return address and update fp 	   1.  I am told what my current fp and pdr is 	   2.  see what the return register is 	   3.  see if return reg is on stack 	   4.  add the framesize to framereg to get the virtual fp 	   5.  add the frameoffset to fp to get to the save register area 	   6.  read the stack to get the return address 	*/
if|if
condition|(
name|pdr
operator|->
name|pcreg
operator|<
literal|0
condition|)
block|{
name|punt
argument_list|(
literal|"return addreses not in a saved register"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|pdr
operator|->
name|regmask
operator|&
operator|(
literal|1
operator|<<
name|pdr
operator|->
name|pcreg
operator|)
operator|)
condition|)
block|{
comment|/* in a register and register is not saved */
name|punt
argument_list|(
literal|"don't know how to get register"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pdr
operator|->
name|framereg
operator|!=
literal|29
condition|)
name|punt
argument_list|(
literal|"framereg != 29"
argument_list|)
expr_stmt|;
name|fp
operator|+=
name|pdr
operator|->
name|frameoffset
expr_stmt|;
name|saved31loc
operator|=
name|fp
operator|+
name|pdr
operator|->
name|regoffset
expr_stmt|;
comment|/* assume pcreg is 31, else have to figure out where it is in saved 		area */
if|if
condition|(
name|pdr
operator|->
name|pcreg
operator|!=
literal|31
condition|)
name|punt
argument_list|(
literal|"return reg not 31"
argument_list|)
expr_stmt|;
name|retaddr
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|saved31loc
expr_stmt|;
operator|*
name|pfp
operator|=
name|fp
expr_stmt|;
return|return
operator|(
name|retaddr
operator|)
return|;
block|}
end_block

begin_macro
name|punt
argument_list|(
argument|str
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|str
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

end_unit

