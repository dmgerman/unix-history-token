begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	mprof.c 2.6 9/14/90 16:01:20	*/
end_comment

begin_comment
comment|/*	Copyright (c) 1987, 1990, Benjamin G. Zorn */
end_comment

begin_comment
comment|/*	mprof.c -- code to analyse and print out mprof data  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<a.out.h>
end_include

begin_include
include|#
directive|include
file|<stab.h>
end_include

begin_include
include|#
directive|include
file|"mprof.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|mips
end_ifdef

begin_include
include|#
directive|include
file|<ldfcn.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|mips
argument_list|)
operator|||
name|defined
argument_list|(
name|vax
argument_list|)
end_if

begin_function
name|char
modifier|*
name|strdup
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|char
modifier|*
name|result
init|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
literal|1
argument_list|)
decl_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|result
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|extern
name|void
name|mprof_graph_ops
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* from mpgraph.c */
end_comment

begin_define
define|#
directive|define
name|check_fscanf
parameter_list|(
name|x
parameter_list|)
define|\
value|{ int result = (x); \       if (!result) { \ 	 fprintf(stderr, "fscanf -- can't read input\n"); \ 	 exit(1); \        } \     }
end_define

begin_struct
struct|struct
name|leakpair
block|{
name|char
modifier|*
name|func
decl_stmt|;
name|int
name|offset
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|leakentry
block|{
name|struct
name|leakpair
name|path
index|[
name|SHORT_CALLSTACK_SIZE
index|]
decl_stmt|;
name|int
name|all_no
decl_stmt|;
name|int
name|all_by
decl_stmt|;
name|int
name|fre_no
decl_stmt|;
name|int
name|fre_by
decl_stmt|;
name|struct
name|leakentry
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_macro
name|lte_str_compar
argument_list|(
argument|lte1
argument_list|,
argument|lte2
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|leakentry
modifier|*
name|lte1
decl_stmt|,
modifier|*
name|lte2
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|leakpair
modifier|*
name|path1
decl_stmt|,
modifier|*
name|path2
decl_stmt|;
name|int
name|i
decl_stmt|;
name|path1
operator|=
name|lte1
operator|->
name|path
expr_stmt|;
name|path2
operator|=
name|lte2
operator|->
name|path
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SHORT_CALLSTACK_SIZE
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|path1
index|[
name|i
index|]
operator|.
name|func
argument_list|,
name|path2
index|[
name|i
index|]
operator|.
name|func
argument_list|)
operator|!=
literal|0
condition|)
block|{
return|return
name|strcmp
argument_list|(
name|path1
index|[
name|i
index|]
operator|.
name|func
argument_list|,
name|path2
index|[
name|i
index|]
operator|.
name|func
argument_list|)
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_block

begin_function
name|int
name|path_equal
parameter_list|(
name|path1
parameter_list|,
name|path2
parameter_list|)
name|struct
name|leakpair
modifier|*
name|path1
decl_stmt|,
decl|*
name|path2
decl_stmt|;
end_function

begin_block
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SHORT_CALLSTACK_SIZE
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|path1
index|[
name|i
index|]
operator|.
name|func
argument_list|,
name|path2
index|[
name|i
index|]
operator|.
name|func
argument_list|)
operator|!=
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_block

begin_function
name|int
name|lte_size_compar
parameter_list|(
name|lte1
parameter_list|,
name|lte2
parameter_list|)
name|struct
name|leakentry
modifier|*
name|lte1
decl_stmt|,
decl|*
name|lte2
decl_stmt|;
end_function

begin_block
block|{
if|if
condition|(
operator|(
name|lte1
operator|->
name|all_by
operator|-
name|lte1
operator|->
name|fre_by
operator|)
operator|<
operator|(
name|lte2
operator|->
name|all_by
operator|-
name|lte2
operator|->
name|fre_by
operator|)
condition|)
block|{
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|lte1
operator|->
name|all_by
operator|-
name|lte1
operator|->
name|fre_by
operator|)
operator|>
operator|(
name|lte2
operator|->
name|all_by
operator|-
name|lte2
operator|->
name|fre_by
operator|)
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
else|else
block|{
return|return
literal|0
return|;
block|}
block|}
end_block

begin_define
define|#
directive|define
name|V_TERSE
value|0
end_define

begin_define
define|#
directive|define
name|V_NORMAL
value|1
end_define

begin_define
define|#
directive|define
name|V_VERBOSE
value|2
end_define

begin_decl_stmt
name|int
name|verbosity
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|LEAK_NONE
value|0
end_define

begin_define
define|#
directive|define
name|LEAK_SHOW
value|1
end_define

begin_define
define|#
directive|define
name|LEAK_OFFSETS
value|2
end_define

begin_decl_stmt
name|int
name|leak_level
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|TYPE_EQUAL
value|0
end_define

begin_define
define|#
directive|define
name|TYPE_GREATERTHAN
value|1
end_define

begin_function_decl
name|void
name|print_type_list
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|print_bin_table
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|print_leak_table
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|char
modifier|*
name|percent
parameter_list|(
name|m
parameter_list|,
name|n
parameter_list|)
name|int
name|m
decl_stmt|,
name|n
decl_stmt|;
block|{
name|int
name|d
decl_stmt|;
name|char
name|buf
index|[
literal|80
index|]
decl_stmt|;
name|char
modifier|*
name|result
decl_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
name|d
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|d
operator|=
operator|(
literal|100
operator|*
name|m
operator|)
operator|/
name|n
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%d"
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|result
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|strlen
argument_list|(
name|buf
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|result
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|percent_string
parameter_list|(
name|m
parameter_list|,
name|n
parameter_list|)
name|int
name|m
decl_stmt|,
name|n
decl_stmt|;
block|{
name|int
name|intpart
decl_stmt|,
name|frac
decl_stmt|;
name|int
name|d
decl_stmt|;
name|char
name|buf
index|[
literal|80
index|]
decl_stmt|;
name|char
modifier|*
name|result
decl_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
goto|goto
name|rest
goto|;
block|}
else|else
block|{
name|intpart
operator|=
operator|(
literal|100
operator|*
name|m
operator|)
operator|/
name|n
expr_stmt|;
name|frac
operator|=
operator|(
literal|100
operator|*
name|m
operator|)
operator|%
name|n
expr_stmt|;
if|if
condition|(
operator|(
name|intpart
operator|==
literal|0
operator|)
operator|&&
operator|(
name|frac
operator|==
literal|0
operator|)
condition|)
block|{
return|return
literal|""
return|;
block|}
elseif|else
if|if
condition|(
name|intpart
operator|==
literal|0
condition|)
block|{
return|return
literal|"(.)"
return|;
block|}
elseif|else
if|if
condition|(
name|intpart
operator|==
literal|100
condition|)
block|{
return|return
literal|"(**)"
return|;
block|}
block|}
name|rest
label|:
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
name|d
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|d
operator|=
operator|(
literal|100
operator|*
name|m
operator|)
operator|/
name|n
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"(%d)"
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|result
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|strlen
argument_list|(
name|buf
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|result
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* functions for uniquely recording recording each structure type  */
end_comment

begin_struct
struct|struct
name|sthash
block|{
name|int
name|kind
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
name|int
name|size
decl_stmt|;
name|struct
name|stconscell
modifier|*
name|numlist
decl_stmt|;
name|struct
name|sthash
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|STHASH_SIZE
value|2047
end_define

begin_decl_stmt
name|struct
name|sthash
modifier|*
name|sthmem
index|[
name|STHASH_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|STNIL
value|NULL
end_define

begin_struct
struct|struct
name|stconscell
block|{
name|int
name|car
decl_stmt|;
name|struct
name|stconscell
modifier|*
name|cdr
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
name|struct
name|sthash
modifier|*
modifier|*
name|read_and_sort_types
parameter_list|()
function_decl|;
end_function_decl

begin_macro
name|sthash_compar
argument_list|(
argument|ste1
argument_list|,
argument|ste2
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|sthash
modifier|*
modifier|*
name|ste1
decl_stmt|,
modifier|*
modifier|*
name|ste2
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
operator|(
operator|*
name|ste1
operator|)
operator|->
name|size
operator|<
operator|(
operator|*
name|ste2
operator|)
operator|->
name|size
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|ste1
operator|)
operator|->
name|size
operator|>
operator|(
operator|*
name|ste2
operator|)
operator|->
name|size
condition|)
block|{
return|return
literal|1
return|;
block|}
else|else
block|{
return|return
name|strcmp
argument_list|(
operator|(
operator|*
name|ste1
operator|)
operator|->
name|str
argument_list|,
operator|(
operator|*
name|ste2
operator|)
operator|->
name|str
argument_list|)
return|;
block|}
block|}
end_block

begin_function
name|struct
name|stconscell
modifier|*
name|stcons
parameter_list|(
name|car
parameter_list|,
name|cdr
parameter_list|)
name|int
name|car
decl_stmt|;
name|struct
name|stconscell
modifier|*
name|cdr
decl_stmt|;
block|{
name|struct
name|stconscell
modifier|*
name|newcons
decl_stmt|;
name|newcons
operator|=
operator|(
expr|struct
name|stconscell
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|stconscell
argument_list|)
argument_list|)
expr_stmt|;
name|newcons
operator|->
name|car
operator|=
name|car
expr_stmt|;
name|newcons
operator|->
name|cdr
operator|=
name|cdr
expr_stmt|;
return|return
name|newcons
return|;
block|}
end_function

begin_function
name|struct
name|stconscell
modifier|*
name|stmember
parameter_list|(
name|item
parameter_list|,
name|stlist
parameter_list|)
name|int
name|item
decl_stmt|;
name|struct
name|stconscell
modifier|*
name|stlist
decl_stmt|;
block|{
name|struct
name|stconscell
modifier|*
name|s
init|=
name|stlist
decl_stmt|;
while|while
condition|(
name|s
operator|!=
name|STNIL
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|car
operator|==
name|item
condition|)
return|return
name|s
return|;
name|s
operator|=
name|s
operator|->
name|cdr
expr_stmt|;
block|}
return|return
name|STNIL
return|;
block|}
end_function

begin_function
name|bool
name|stmatchlist
parameter_list|(
name|l1
parameter_list|,
name|l2
parameter_list|)
name|struct
name|stconscell
modifier|*
name|l1
decl_stmt|,
decl|*
name|l2
decl_stmt|;
end_function

begin_block
block|{
name|struct
name|stconscell
modifier|*
name|s1
decl_stmt|,
modifier|*
name|s2
decl_stmt|;
name|int
name|len1
decl_stmt|,
name|len2
decl_stmt|;
for|for
control|(
name|len1
operator|=
literal|0
operator|,
name|s1
operator|=
name|l1
init|;
name|s1
operator|!=
name|STNIL
condition|;
name|len1
operator|++
operator|,
name|s1
operator|=
name|s1
operator|->
name|cdr
control|)
empty_stmt|;
for|for
control|(
name|len2
operator|=
literal|0
operator|,
name|s2
operator|=
name|l2
init|;
name|s2
operator|!=
name|STNIL
condition|;
name|len2
operator|++
operator|,
name|s2
operator|=
name|s2
operator|->
name|cdr
control|)
empty_stmt|;
if|if
condition|(
name|len1
operator|==
name|len2
condition|)
block|{
for|for
control|(
name|s1
operator|=
name|l1
init|;
name|s1
operator|!=
name|STNIL
condition|;
name|s1
operator|=
name|s1
operator|->
name|cdr
control|)
block|{
if|if
condition|(
name|stmember
argument_list|(
name|s1
operator|->
name|car
argument_list|,
name|l2
argument_list|)
operator|==
name|STNIL
condition|)
block|{
return|return
name|FALSE
return|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_block

begin_define
define|#
directive|define
name|T_STRUCT
value|0
end_define

begin_define
define|#
directive|define
name|T_TYPEDEF
value|1
end_define

begin_function
name|struct
name|sthash
modifier|*
name|mpf_new_stlink
parameter_list|(
name|kind
parameter_list|,
name|str
parameter_list|,
name|size
parameter_list|,
name|numlist
parameter_list|,
name|next
parameter_list|)
name|int
name|kind
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
name|int
name|size
decl_stmt|;
name|struct
name|stconscell
modifier|*
name|numlist
decl_stmt|;
name|struct
name|sthash
modifier|*
name|next
decl_stmt|;
block|{
name|struct
name|sthash
modifier|*
name|new_stl
decl_stmt|;
name|new_stl
operator|=
operator|(
expr|struct
name|sthash
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sthash
argument_list|)
argument_list|)
expr_stmt|;
name|new_stl
operator|->
name|kind
operator|=
name|kind
expr_stmt|;
name|new_stl
operator|->
name|str
operator|=
name|str
expr_stmt|;
name|new_stl
operator|->
name|size
operator|=
name|size
expr_stmt|;
name|new_stl
operator|->
name|numlist
operator|=
name|numlist
expr_stmt|;
name|new_stl
operator|->
name|next
operator|=
name|next
expr_stmt|;
return|return
name|new_stl
return|;
block|}
end_function

begin_function
name|int
name|mpf_sthash
parameter_list|(
name|s
parameter_list|,
name|len
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|hash
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|hash
operator|=
name|hash
operator|^
operator|(
operator|(
operator|(
name|int
operator|)
operator|*
operator|(
name|s
operator|+
name|i
operator|)
operator|)
operator|<<
operator|(
name|i
operator|%
literal|6
operator|)
operator|)
expr_stmt|;
block|}
return|return
operator|(
operator|(
name|hash
operator|>>
literal|3
operator|)
operator|%
name|STHASH_SIZE
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|N_EXCEPTIONS
value|11
end_define

begin_decl_stmt
name|char
modifier|*
name|struct_exceptions
index|[]
init|=
block|{
literal|"mp_function_struct"
block|,
literal|"mp_cons_struct"
block|,
literal|"mp_data_struct"
block|,
literal|"mp_sstk_struct"
block|,
literal|"mpheader"
block|,
literal|"_physadr"
block|,
literal|"_iobuf"
block|,
literal|"_quad"
block|,
literal|"flock"
block|,
literal|"fd_set"
block|,
literal|"label_t"
block|,
ifdef|#
directive|ifdef
name|mips
literal|"pdr"
block|,
literal|"fdr"
block|,
literal|"runtime_pdr"
block|,
endif|#
directive|endif
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|mpf_intern_type
parameter_list|(
name|s
parameter_list|,
name|size
parameter_list|,
name|structsize
parameter_list|,
name|tnumber
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|size
decl_stmt|;
name|int
name|structsize
decl_stmt|;
name|int
name|tnumber
decl_stmt|;
block|{
name|int
name|hash
init|=
name|mpf_sthash
argument_list|(
name|s
argument_list|,
name|size
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|sthash
modifier|*
name|ste
init|=
name|sthmem
index|[
name|hash
index|]
decl_stmt|;
name|char
modifier|*
name|newstr
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N_EXCEPTIONS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|s
argument_list|,
name|struct_exceptions
index|[
name|i
index|]
argument_list|,
name|strlen
argument_list|(
name|struct_exceptions
index|[
name|i
index|]
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return;
block|}
block|}
while|while
condition|(
name|ste
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|strncmp
argument_list|(
name|s
argument_list|,
name|ste
operator|->
name|str
argument_list|,
name|size
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|*
operator|(
operator|(
name|ste
operator|->
name|str
operator|)
operator|+
name|size
operator|)
operator|==
name|NULL
operator|)
condition|)
block|{
comment|/* add the number to the list of numbers 	     */
if|if
condition|(
name|stmember
argument_list|(
name|tnumber
argument_list|,
name|ste
operator|->
name|numlist
argument_list|)
operator|==
name|STNIL
condition|)
name|ste
operator|->
name|numlist
operator|=
name|stcons
argument_list|(
name|tnumber
argument_list|,
name|ste
operator|->
name|numlist
argument_list|)
expr_stmt|;
return|return;
block|}
name|ste
operator|=
name|ste
operator|->
name|next
expr_stmt|;
block|}
name|newstr
operator|=
name|malloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|size
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|newstr
argument_list|,
name|s
argument_list|,
name|size
argument_list|)
expr_stmt|;
operator|*
operator|(
name|char
operator|*
operator|)
operator|(
operator|(
name|int
operator|)
name|newstr
operator|+
name|size
operator|)
operator|=
name|NULL
expr_stmt|;
name|ste
operator|=
name|mpf_new_stlink
argument_list|(
name|T_STRUCT
argument_list|,
name|newstr
argument_list|,
name|structsize
argument_list|,
name|stcons
argument_list|(
name|tnumber
argument_list|,
name|STNIL
argument_list|)
argument_list|,
name|sthmem
index|[
name|hash
index|]
argument_list|)
expr_stmt|;
name|sthmem
index|[
name|hash
index|]
operator|=
name|ste
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|mpf_intern_typedef
parameter_list|(
name|s
parameter_list|,
name|size
parameter_list|,
name|tnumber
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|size
decl_stmt|;
name|int
name|tnumber
decl_stmt|;
block|{
name|int
name|hash
init|=
name|mpf_sthash
argument_list|(
name|s
argument_list|,
name|size
argument_list|)
decl_stmt|;
name|struct
name|sthash
modifier|*
name|ste
init|=
name|sthmem
index|[
name|hash
index|]
decl_stmt|;
name|char
modifier|*
name|newstr
decl_stmt|;
while|while
condition|(
name|ste
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|strncmp
argument_list|(
name|s
argument_list|,
name|ste
operator|->
name|str
argument_list|,
name|size
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|*
operator|(
operator|(
name|ste
operator|->
name|str
operator|)
operator|+
name|size
operator|)
operator|==
name|NULL
operator|)
condition|)
block|{
comment|/* add the number to the list of numbers 	     */
if|if
condition|(
name|stmember
argument_list|(
name|tnumber
argument_list|,
name|ste
operator|->
name|numlist
argument_list|)
operator|==
name|STNIL
condition|)
name|ste
operator|->
name|numlist
operator|=
name|stcons
argument_list|(
name|tnumber
argument_list|,
name|ste
operator|->
name|numlist
argument_list|)
expr_stmt|;
return|return;
block|}
name|ste
operator|=
name|ste
operator|->
name|next
expr_stmt|;
block|}
name|newstr
operator|=
name|malloc
argument_list|(
name|size
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|newstr
argument_list|,
name|s
argument_list|,
name|size
argument_list|)
expr_stmt|;
operator|*
operator|(
name|char
operator|*
operator|)
operator|(
operator|(
name|int
operator|)
name|newstr
operator|+
name|size
operator|)
operator|=
name|NULL
expr_stmt|;
name|ste
operator|=
name|mpf_new_stlink
argument_list|(
name|T_TYPEDEF
argument_list|,
name|newstr
argument_list|,
literal|0
argument_list|,
name|stcons
argument_list|(
name|tnumber
argument_list|,
name|STNIL
argument_list|)
argument_list|,
name|sthmem
index|[
name|hash
index|]
argument_list|)
expr_stmt|;
name|sthmem
index|[
name|hash
index|]
operator|=
name|ste
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|struct
name|sthash
modifier|*
modifier|*
name|read_and_sort_types
parameter_list|(
name|number
parameter_list|)
name|int
modifier|*
name|number
decl_stmt|;
block|{
name|struct
name|sthash
modifier|*
name|ste
decl_stmt|,
modifier|*
name|ste1
decl_stmt|;
name|struct
name|stconscell
modifier|*
name|typedefs
decl_stmt|,
modifier|*
name|tl
decl_stmt|,
modifier|*
name|structs
decl_stmt|,
modifier|*
name|sl
decl_stmt|;
name|int
name|tnum
decl_stmt|;
name|int
name|i
decl_stmt|,
name|pair_count
decl_stmt|;
name|struct
name|sthash
modifier|*
modifier|*
name|result
decl_stmt|;
comment|/* first, make a list of all typedefs and structs      */
name|typedefs
operator|=
name|STNIL
expr_stmt|;
name|structs
operator|=
name|STNIL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|STHASH_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|ste
operator|=
name|sthmem
index|[
name|i
index|]
expr_stmt|;
while|while
condition|(
name|ste
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ste
operator|->
name|kind
operator|==
name|T_TYPEDEF
condition|)
block|{
name|typedefs
operator|=
name|stcons
argument_list|(
operator|(
name|int
operator|)
name|ste
argument_list|,
name|typedefs
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ste
operator|->
name|kind
operator|==
name|T_STRUCT
condition|)
block|{
name|structs
operator|=
name|stcons
argument_list|(
operator|(
name|int
operator|)
name|ste
argument_list|,
name|structs
argument_list|)
expr_stmt|;
block|}
name|ste
operator|=
name|ste
operator|->
name|next
expr_stmt|;
block|}
block|}
comment|/* for each typedef, if it points to a struct, change to a struct,      * add the size, and remove the struct      */
name|tl
operator|=
name|typedefs
expr_stmt|;
while|while
condition|(
name|tl
operator|!=
name|STNIL
condition|)
block|{
name|ste
operator|=
operator|(
expr|struct
name|sthash
operator|*
operator|)
name|tl
operator|->
name|car
expr_stmt|;
name|tnum
operator|=
name|ste
operator|->
name|numlist
operator|->
name|car
expr_stmt|;
name|sl
operator|=
name|structs
expr_stmt|;
while|while
condition|(
name|sl
operator|!=
name|STNIL
condition|)
block|{
name|ste1
operator|=
operator|(
expr|struct
name|sthash
operator|*
operator|)
name|sl
operator|->
name|car
expr_stmt|;
if|if
condition|(
operator|(
name|stmember
argument_list|(
name|tnum
argument_list|,
name|ste1
operator|->
name|numlist
argument_list|)
operator|!=
name|STNIL
operator|)
operator|&&
operator|(
name|stmatchlist
argument_list|(
name|ste
operator|->
name|numlist
argument_list|,
name|ste1
operator|->
name|numlist
argument_list|)
operator|)
condition|)
block|{
name|ste
operator|->
name|kind
operator|=
name|T_STRUCT
expr_stmt|;
name|ste
operator|->
name|size
operator|=
name|ste1
operator|->
name|size
expr_stmt|;
name|ste1
operator|->
name|kind
operator|=
name|T_TYPEDEF
expr_stmt|;
break|break;
block|}
name|sl
operator|=
name|sl
operator|->
name|cdr
expr_stmt|;
block|}
name|tl
operator|=
name|tl
operator|->
name|cdr
expr_stmt|;
block|}
comment|/*      * First, count how many there are      */
name|pair_count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|STHASH_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|ste
operator|=
name|sthmem
index|[
name|i
index|]
expr_stmt|;
while|while
condition|(
name|ste
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ste
operator|->
name|kind
operator|==
name|T_STRUCT
condition|)
block|{
name|pair_count
operator|+=
literal|1
expr_stmt|;
block|}
name|ste
operator|=
name|ste
operator|->
name|next
expr_stmt|;
block|}
block|}
comment|/*      * Allocate a vector containing that many entries.      */
name|result
operator|=
operator|(
expr|struct
name|sthash
operator|*
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sthash
operator|*
argument_list|)
operator|*
name|pair_count
argument_list|)
expr_stmt|;
name|pair_count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|STHASH_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|ste
operator|=
name|sthmem
index|[
name|i
index|]
expr_stmt|;
while|while
condition|(
name|ste
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ste
operator|->
name|kind
operator|==
name|T_STRUCT
condition|)
block|{
name|result
index|[
name|pair_count
index|]
operator|=
name|ste
expr_stmt|;
name|pair_count
operator|+=
literal|1
expr_stmt|;
block|}
name|ste
operator|=
name|ste
operator|->
name|next
expr_stmt|;
block|}
block|}
name|qsort
argument_list|(
operator|(
name|char
operator|*
operator|)
name|result
argument_list|,
name|pair_count
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sthash
operator|*
argument_list|)
argument_list|,
name|sthash_compar
argument_list|)
expr_stmt|;
operator|*
name|number
operator|=
name|pair_count
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_struct
struct|struct
name|finfo
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|unsigned
name|addr
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|stab_name
parameter_list|(
name|x
parameter_list|)
value|(stab[(x)].name)
end_define

begin_define
define|#
directive|define
name|stab_addr
parameter_list|(
name|x
parameter_list|)
value|(stab[(x)].addr)
end_define

begin_define
define|#
directive|define
name|ST_SIZE
value|5000
end_define

begin_define
define|#
directive|define
name|ST_NOT_FOUND
value|-1
end_define

begin_typedef
typedef|typedef
name|int
name|stindex
typedef|;
end_typedef

begin_decl_stmt
name|struct
name|finfo
name|stab
index|[
name|ST_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|stab_i
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|stab_incr
parameter_list|(
name|idx
parameter_list|)
value|(((idx)< ST_SIZE) ? (idx)++ : \ 			 (fprintf(stderr, "stab_incr -- stab table overflow (%d)\n", \ 				 idx), exit(0)));
end_define

begin_function_decl
name|void
name|st_init
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|stab_compare
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|st_read
parameter_list|()
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|mips
end_ifdef

begin_function_decl
name|int
name|st_read_structure
parameter_list|()
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_function_decl
name|void
name|st_read_structure
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
name|stindex
name|st_locate
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|st_print
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|st_print_one
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|char
modifier|*
name|st_strings
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|mprofing
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|stab_compare
parameter_list|(
name|e1
parameter_list|,
name|e2
parameter_list|)
name|struct
name|finfo
modifier|*
name|e1
decl_stmt|,
decl|*
name|e2
decl_stmt|;
end_function

begin_block
block|{
if|if
condition|(
name|e1
operator|->
name|addr
operator|<
name|e2
operator|->
name|addr
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|e1
operator|->
name|addr
operator|>
name|e2
operator|->
name|addr
condition|)
block|{
return|return
literal|1
return|;
block|}
else|else
block|{
return|return
literal|0
return|;
block|}
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|mips
end_ifdef

begin_decl_stmt
name|LDFILE
modifier|*
name|ldptr
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|st_read
parameter_list|(
name|exec_name
parameter_list|)
name|char
modifier|*
name|exec_name
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|PDR
name|pdr
decl_stmt|;
name|SYMR
name|asym
decl_stmt|,
name|asym2
decl_stmt|;
specifier|extern
name|char
modifier|*
name|ldgetname
parameter_list|()
function_decl|;
comment|/* why isn't this in some header file? */
specifier|extern
name|pAUXU
name|ldgetaux
parameter_list|()
function_decl|;
comment|/* why isn't this in some header file? */
name|pFDR
name|pfd
decl_stmt|;
name|pAUXU
name|aux
decl_stmt|;
name|AUXU
name|localaux
decl_stmt|,
name|aux2
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|fdindex
decl_stmt|;
name|int
name|symindex
decl_stmt|;
name|int
name|rfd
decl_stmt|,
name|rfi
decl_stmt|;
name|ldptr
operator|=
name|ldopen
argument_list|(
name|exec_name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ldreadst
argument_list|(
name|ldptr
argument_list|,
name|ST_PSYMS
operator||
name|ST_PAUXS
operator||
name|ST_PFDS
operator||
name|ST_PPDS
argument_list|)
expr_stmt|;
comment|/* read in pdr table */
for|for
control|(
name|pfd
operator|=
name|PFD
argument_list|(
name|ldptr
argument_list|)
init|;
name|pfd
operator|<
name|PFD
argument_list|(
name|ldptr
argument_list|)
operator|+
name|SYMHEADER
argument_list|(
name|ldptr
argument_list|)
operator|.
name|ifdMax
condition|;
name|pfd
operator|++
control|)
block|{
for|for
control|(
name|i
operator|=
name|pfd
operator|->
name|ipdFirst
init|;
name|i
operator|<
name|pfd
operator|->
name|ipdFirst
operator|+
name|pfd
operator|->
name|cpd
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ldgetpd
argument_list|(
name|ldptr
argument_list|,
name|i
argument_list|,
operator|&
name|pdr
argument_list|)
operator|!=
name|SUCCESS
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"can't read pdr %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pdr
operator|.
name|isym
operator|!=
name|isymNil
condition|)
block|{
if|if
condition|(
name|ldtbread
argument_list|(
name|ldptr
argument_list|,
name|pfd
operator|->
name|csym
condition|?
name|pdr
operator|.
name|isym
else|:
name|pdr
operator|.
name|isym
operator|+
name|SYMHEADER
argument_list|(
name|ldptr
argument_list|)
operator|.
name|isymMax
argument_list|,
operator|&
name|asym
argument_list|)
operator|!=
name|SUCCESS
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"can't read symbol"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|pdr
operator|.
name|adr
operator|=
name|asym
operator|.
name|value
expr_stmt|;
block|}
comment|/* fill in finfo array */
name|stab
index|[
name|i
index|]
operator|.
name|addr
operator|=
name|pdr
operator|.
name|adr
expr_stmt|;
if|if
condition|(
name|pdr
operator|.
name|isym
operator|==
name|isymNil
condition|)
block|{
name|stab
index|[
name|i
index|]
operator|.
name|name
operator|=
literal|"<stripped>"
expr_stmt|;
block|}
else|else
block|{
name|stab
index|[
name|i
index|]
operator|.
name|name
operator|=
name|ldgetname
argument_list|(
name|ldptr
argument_list|,
operator|&
name|asym
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|stab_name
argument_list|(
name|i
argument_list|)
operator|=
literal|"unknown"
expr_stmt|;
name|stab_addr
argument_list|(
name|i
argument_list|)
operator|=
name|stab_addr
argument_list|(
name|i
operator|-
literal|1
argument_list|)
operator|+
literal|0x10000
expr_stmt|;
name|stab_incr
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|stab_name
argument_list|(
name|i
argument_list|)
operator|=
literal|"end_marker"
expr_stmt|;
name|stab_addr
argument_list|(
name|i
argument_list|)
operator|=
literal|0xffffffff
expr_stmt|;
name|stab_incr
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|stab_i
operator|=
name|i
expr_stmt|;
comment|/* read in structures        this mips symbol table is extremely esoteric */
ifdef|#
directive|ifdef
name|DEBUG
define|#
directive|define
name|err_print
parameter_list|(
name|str
parameter_list|,
name|index
parameter_list|)
value|fprintf(stderr, str, index)
else|#
directive|else
define|#
directive|define
name|err_print
parameter_list|(
name|str
parameter_list|,
name|index
parameter_list|)
endif|#
directive|endif
if|if
condition|(
name|ldtbseek
argument_list|(
name|ldptr
argument_list|)
operator|==
name|SUCCESS
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SYMHEADER
argument_list|(
name|ldptr
argument_list|)
operator|.
name|isymMax
operator|+
name|SYMHEADER
argument_list|(
name|ldptr
argument_list|)
operator|.
name|iextMax
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ldtbread
argument_list|(
name|ldptr
argument_list|,
name|i
argument_list|,
operator|&
name|asym
argument_list|)
operator|!=
name|SUCCESS
condition|)
block|{
name|err_print
argument_list|(
literal|"can't read symbol, index = %d\n"
argument_list|,
name|asym
operator|.
name|index
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 	 *  check locals and globals for possible structures and unions 	 */
if|if
condition|(
name|asym
operator|.
name|st
operator|==
name|stLocal
operator|||
name|asym
operator|.
name|st
operator|==
name|stGlobal
condition|)
block|{
if|if
condition|(
name|asym
operator|.
name|index
operator|==
name|indexNil
condition|)
continue|continue;
if|if
condition|(
operator|!
operator|(
name|aux
operator|=
name|ldgetaux
argument_list|(
name|ldptr
argument_list|,
name|asym
operator|.
name|index
argument_list|)
operator|)
condition|)
block|{
name|err_print
argument_list|(
literal|"can't read aux symbol, index = %d\n"
argument_list|,
name|asym
operator|.
name|index
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|localaux
operator|=
operator|*
name|aux
expr_stmt|;
comment|/* have to make copy before swapping */
name|fdindex
operator|=
name|ld_ifd_iaux
argument_list|(
name|ldptr
argument_list|,
name|asym
operator|.
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|LDAUXSWAP
argument_list|(
name|ldptr
argument_list|,
name|fdindex
argument_list|)
condition|)
name|swap_aux
argument_list|(
operator|&
name|localaux
argument_list|,
name|ST_AUX_TIR
argument_list|,
name|gethostsex
argument_list|()
argument_list|)
expr_stmt|;
comment|/* see if it's a struct or union */
if|if
condition|(
name|localaux
operator|.
name|ti
operator|.
name|bt
operator|==
name|btStruct
operator|||
name|localaux
operator|.
name|ti
operator|.
name|bt
operator|==
name|btUnion
condition|)
block|{
comment|/* if width specified, skip it */
if|if
condition|(
name|localaux
operator|.
name|ti
operator|.
name|fBitfield
condition|)
block|{
name|aux
operator|++
expr_stmt|;
block|}
name|ldgetrndx
argument_list|(
name|ldptr
argument_list|,
name|fdindex
argument_list|,
name|aux
operator|+
literal|1
argument_list|,
operator|&
name|rfd
argument_list|,
operator|&
name|aux2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|aux2
operator|.
name|rndx
operator|.
name|index
operator|||
name|aux2
operator|.
name|rndx
operator|.
name|index
operator|==
name|ST_ANONINDEX
condition|)
continue|continue;
name|rfi
operator|=
name|ldgetrfd
argument_list|(
name|ldptr
argument_list|,
name|PFD
argument_list|(
name|ldptr
argument_list|)
index|[
name|fdindex
index|]
operator|.
name|rfdBase
operator|+
name|rfd
argument_list|)
expr_stmt|;
name|symindex
operator|=
name|PFD
argument_list|(
name|ldptr
argument_list|)
index|[
name|rfi
index|]
operator|.
name|isymBase
operator|+
name|aux2
operator|.
name|rndx
operator|.
name|index
expr_stmt|;
if|if
condition|(
name|ldtbread
argument_list|(
name|ldptr
argument_list|,
name|symindex
argument_list|,
operator|&
name|asym2
argument_list|)
operator|!=
name|SUCCESS
condition|)
block|{
name|err_print
argument_list|(
literal|"can't read symbol, index = %d\n"
argument_list|,
name|symindex
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|name
operator|=
name|ldgetname
argument_list|(
name|ldptr
argument_list|,
operator|&
name|asym2
argument_list|)
expr_stmt|;
name|mpf_intern_type
argument_list|(
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|,
name|asym2
operator|.
name|value
argument_list|,
name|asym2
operator|.
name|index
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|asym
operator|.
name|st
operator|==
name|stTypedef
condition|)
block|{
if|if
condition|(
name|asym
operator|.
name|index
operator|==
name|indexNil
condition|)
continue|continue;
if|if
condition|(
operator|!
operator|(
name|aux
operator|=
name|ldgetaux
argument_list|(
name|ldptr
argument_list|,
name|asym
operator|.
name|index
argument_list|)
operator|)
condition|)
block|{
name|err_print
argument_list|(
literal|"can't read aux symbol, index = %d\n"
argument_list|,
name|asym
operator|.
name|index
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|localaux
operator|=
operator|*
name|aux
expr_stmt|;
comment|/* have to make copy before swapping */
name|fdindex
operator|=
name|ld_ifd_iaux
argument_list|(
name|ldptr
argument_list|,
name|asym
operator|.
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|LDAUXSWAP
argument_list|(
name|ldptr
argument_list|,
name|fdindex
argument_list|)
condition|)
name|swap_aux
argument_list|(
operator|&
name|localaux
argument_list|,
name|ST_AUX_TIR
argument_list|,
name|gethostsex
argument_list|()
argument_list|)
expr_stmt|;
comment|/* if width specified, skip it */
if|if
condition|(
name|localaux
operator|.
name|ti
operator|.
name|fBitfield
condition|)
block|{
name|aux
operator|++
expr_stmt|;
block|}
name|ldgetrndx
argument_list|(
name|ldptr
argument_list|,
name|fdindex
argument_list|,
name|aux
operator|+
literal|1
argument_list|,
operator|&
name|rfd
argument_list|,
operator|&
name|aux2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|aux2
operator|.
name|rndx
operator|.
name|index
operator|||
name|aux2
operator|.
name|rndx
operator|.
name|index
operator|==
name|ST_ANONINDEX
condition|)
continue|continue;
name|rfi
operator|=
name|ldgetrfd
argument_list|(
name|ldptr
argument_list|,
name|PFD
argument_list|(
name|ldptr
argument_list|)
index|[
name|fdindex
index|]
operator|.
name|rfdBase
operator|+
name|rfd
argument_list|)
expr_stmt|;
name|symindex
operator|=
name|PFD
argument_list|(
name|ldptr
argument_list|)
index|[
name|rfi
index|]
operator|.
name|isymBase
operator|+
name|aux2
operator|.
name|rndx
operator|.
name|index
expr_stmt|;
if|if
condition|(
name|ldtbread
argument_list|(
name|ldptr
argument_list|,
name|symindex
argument_list|,
operator|&
name|asym2
argument_list|)
operator|!=
name|SUCCESS
condition|)
block|{
name|err_print
argument_list|(
literal|"can't read symbol, index = %d\n"
argument_list|,
name|symindex
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|name
operator|=
name|ldgetname
argument_list|(
name|ldptr
argument_list|,
operator|&
name|asym
argument_list|)
expr_stmt|;
name|mpf_intern_typedef
argument_list|(
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|,
name|asym2
operator|.
name|index
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
name|void
name|st_read
parameter_list|(
name|exec_name
parameter_list|)
name|char
modifier|*
name|exec_name
decl_stmt|;
block|{
name|int
name|aout_file
init|=
name|open
argument_list|(
name|exec_name
argument_list|,
operator|(
name|O_RDONLY
operator|)
argument_list|)
decl_stmt|;
name|struct
name|exec
name|hdr
decl_stmt|;
name|struct
name|nlist
name|asym
decl_stmt|;
specifier|extern
name|char
modifier|*
name|index
parameter_list|()
function_decl|;
specifier|extern
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
name|char
modifier|*
name|stmp
decl_stmt|;
name|int
name|string_size
decl_stmt|;
name|unsigned
name|char
name|type
decl_stmt|;
name|char
modifier|*
name|fname
decl_stmt|;
name|int
name|i
decl_stmt|;
name|read
argument_list|(
name|aout_file
argument_list|,
operator|&
name|hdr
argument_list|,
sizeof|sizeof
argument_list|(
name|hdr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hdr
operator|.
name|a_syms
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"st_read -- no symbols in executable\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* read in the string table      */
name|lseek
argument_list|(
name|aout_file
argument_list|,
name|N_STROFF
argument_list|(
name|hdr
argument_list|)
argument_list|,
name|L_SET
argument_list|)
expr_stmt|;
name|read
argument_list|(
name|aout_file
argument_list|,
operator|&
name|string_size
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|st_strings
operator|=
name|malloc
argument_list|(
name|string_size
argument_list|)
expr_stmt|;
name|lseek
argument_list|(
name|aout_file
argument_list|,
name|N_STROFF
argument_list|(
name|hdr
argument_list|)
argument_list|,
name|L_SET
argument_list|)
expr_stmt|;
name|read
argument_list|(
name|aout_file
argument_list|,
name|st_strings
argument_list|,
name|string_size
argument_list|)
expr_stmt|;
comment|/* read in the symbols one at a time      */
name|lseek
argument_list|(
name|aout_file
argument_list|,
name|N_SYMOFF
argument_list|(
name|hdr
argument_list|)
argument_list|,
name|L_SET
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|hdr
operator|.
name|a_syms
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|nlist
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|read
argument_list|(
name|aout_file
argument_list|,
operator|&
name|asym
argument_list|,
sizeof|sizeof
argument_list|(
name|asym
argument_list|)
argument_list|)
expr_stmt|;
name|type
operator|=
name|asym
operator|.
name|n_type
expr_stmt|;
comment|/* check for functions compiled with -g 	 */
if|if
condition|(
name|type
operator|&
name|N_STAB
condition|)
block|{
if|if
condition|(
name|asym
operator|.
name|n_type
operator|==
name|N_FUN
condition|)
block|{
comment|/*	     		stab_name(stab_i) = (char *) (st_strings + asym.n_un.n_strx); 		stab_addr(stab_i) = asym.n_value; 		stmp = index(stab_name(stab_i), ':'); 		*stmp = NULL; 		stab_incr(stab_i); */
block|}
elseif|else
if|if
condition|(
operator|(
name|asym
operator|.
name|n_type
operator|==
name|N_LSYM
operator|)
operator|||
operator|(
name|asym
operator|.
name|n_type
operator|==
name|N_GSYM
operator|)
condition|)
block|{
comment|/* a local symbol that may be a structure definition 		 */
name|st_read_structure
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|st_strings
operator|+
name|asym
operator|.
name|n_un
operator|.
name|n_strx
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* here's a candidate for a function name 	     */
if|if
condition|(
operator|(
name|type
operator|&
name|N_TYPE
operator|)
operator|==
name|N_TEXT
condition|)
block|{
name|fname
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|st_strings
operator|+
name|asym
operator|.
name|n_un
operator|.
name|n_strx
operator|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|fname
operator|==
literal|'_'
operator|)
operator|&
operator|!
name|index
argument_list|(
name|fname
argument_list|,
literal|'.'
argument_list|)
condition|)
block|{
comment|/* since there is not '.' in the name, its probably a 		     * function name 		     */
name|stab_name
argument_list|(
name|stab_i
argument_list|)
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
operator|(
name|int
operator|)
name|fname
operator|+
literal|1
operator|)
expr_stmt|;
name|stab_addr
argument_list|(
name|stab_i
argument_list|)
operator|=
name|asym
operator|.
name|n_value
expr_stmt|;
name|stab_incr
argument_list|(
name|stab_i
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
name|stab_name
argument_list|(
name|stab_i
argument_list|)
operator|=
literal|"unknown"
expr_stmt|;
name|stab_addr
argument_list|(
name|stab_i
argument_list|)
operator|=
name|stab_addr
argument_list|(
name|stab_i
operator|-
literal|1
argument_list|)
operator|+
literal|0x10000
expr_stmt|;
name|stab_incr
argument_list|(
name|stab_i
argument_list|)
expr_stmt|;
name|stab_name
argument_list|(
name|stab_i
argument_list|)
operator|=
literal|"end_marker"
expr_stmt|;
name|stab_addr
argument_list|(
name|stab_i
argument_list|)
operator|=
literal|0xffffffff
expr_stmt|;
name|stab_incr
argument_list|(
name|stab_i
argument_list|)
expr_stmt|;
name|qsort
argument_list|(
name|stab
argument_list|,
name|stab_i
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|finfo
argument_list|)
argument_list|,
name|stab_compare
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|st_read_structure
parameter_list|(
name|symp
parameter_list|)
name|char
modifier|*
name|symp
decl_stmt|;
block|{
name|char
modifier|*
name|eqp
decl_stmt|,
modifier|*
name|colp
decl_stmt|;
name|int
name|ssize
decl_stmt|,
name|tnum
decl_stmt|;
specifier|extern
name|int
name|atoi
parameter_list|()
function_decl|;
specifier|extern
name|char
modifier|*
name|index
parameter_list|()
function_decl|;
name|eqp
operator|=
name|index
argument_list|(
name|symp
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
name|colp
operator|=
name|index
argument_list|(
name|symp
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|eqp
operator|==
name|NULL
operator|)
operator|&&
operator|(
operator|*
operator|(
name|colp
operator|+
literal|1
operator|)
operator|==
literal|'t'
operator|)
condition|)
block|{
comment|/* 	 * Check for a Sun stabs type definition. 	 */
if|if
condition|(
operator|*
operator|(
name|colp
operator|+
literal|2
operator|)
operator|==
literal|'('
condition|)
block|{
name|char
modifier|*
name|commap
decl_stmt|;
name|commap
operator|=
name|index
argument_list|(
name|symp
argument_list|,
literal|','
argument_list|)
expr_stmt|;
operator|*
name|commap
operator|=
literal|'0'
expr_stmt|;
name|tnum
operator|=
name|atoi
argument_list|(
operator|(
name|char
operator|*
operator|)
name|index
argument_list|(
name|symp
argument_list|,
literal|'('
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tnum
operator|=
name|atoi
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|colp
operator|+
literal|2
operator|)
argument_list|)
expr_stmt|;
block|}
name|mpf_intern_typedef
argument_list|(
name|symp
argument_list|,
name|colp
operator|-
name|symp
argument_list|,
name|tnum
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|eqp
operator|!=
name|NULL
operator|)
operator|&&
operator|*
operator|(
name|eqp
operator|+
literal|1
operator|)
operator|==
literal|'s'
condition|)
block|{
comment|/* we have a structure entry... 	 * 1. get the size, number, and name 	 * 3. enter into the structure hash table 	 */
comment|/* get the size (follows eqp+1) 	 */
name|ssize
operator|=
name|atoi
argument_list|(
operator|(
name|char
operator|*
operator|)
name|eqp
operator|+
literal|2
argument_list|)
expr_stmt|;
comment|/* 	 * Get the number (follows :T) 	 */
comment|/* 	 * Check for a Sun stabs type definition. 	 */
if|if
condition|(
operator|*
operator|(
name|colp
operator|+
literal|2
operator|)
operator|==
literal|'('
condition|)
block|{
name|char
modifier|*
name|commap
decl_stmt|;
name|commap
operator|=
name|index
argument_list|(
name|symp
argument_list|,
literal|','
argument_list|)
expr_stmt|;
operator|*
name|commap
operator|=
literal|'0'
expr_stmt|;
name|tnum
operator|=
name|atoi
argument_list|(
operator|(
name|char
operator|*
operator|)
name|index
argument_list|(
name|symp
argument_list|,
literal|'('
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tnum
operator|=
name|atoi
argument_list|(
operator|(
name|char
operator|*
operator|)
name|colp
operator|+
literal|2
argument_list|)
expr_stmt|;
block|}
comment|/* enter the name into the structure hash table 	 */
name|mpf_intern_type
argument_list|(
name|symp
argument_list|,
operator|(
name|index
argument_list|(
name|symp
argument_list|,
literal|':'
argument_list|)
operator|-
name|symp
operator|)
argument_list|,
name|ssize
argument_list|,
name|tnum
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|stindex
name|st_locate
parameter_list|(
name|addr
parameter_list|)
name|unsigned
name|addr
decl_stmt|;
block|{
name|int
name|upper
init|=
name|stab_i
operator|-
literal|1
decl_stmt|;
name|int
name|lower
init|=
literal|0
decl_stmt|;
name|int
name|middle
init|=
operator|(
name|upper
operator|+
name|lower
operator|)
operator|/
literal|2
decl_stmt|;
while|while
condition|(
operator|!
operator|(
operator|(
name|stab_addr
argument_list|(
name|middle
argument_list|)
operator|<=
name|addr
operator|)
operator|&&
operator|(
name|stab_addr
argument_list|(
name|middle
operator|+
literal|1
argument_list|)
operator|>
name|addr
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|middle
operator|==
name|upper
operator|||
name|middle
operator|==
name|lower
condition|)
block|{
return|return
name|ST_NOT_FOUND
return|;
block|}
if|if
condition|(
name|stab_addr
argument_list|(
name|middle
argument_list|)
operator|>
name|addr
condition|)
block|{
name|upper
operator|=
name|middle
expr_stmt|;
block|}
else|else
block|{
name|lower
operator|=
name|middle
expr_stmt|;
block|}
name|middle
operator|=
operator|(
name|upper
operator|+
name|lower
operator|)
operator|/
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|middle
operator|>=
operator|(
name|stab_i
operator|-
literal|2
operator|)
condition|)
block|{
return|return
name|ST_NOT_FOUND
return|;
block|}
else|else
block|{
return|return
name|middle
return|;
block|}
block|}
end_function

begin_function
name|void
name|st_print
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
name|printf
argument_list|(
literal|"function symbol table:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|stab_i
condition|;
name|i
operator|++
control|)
block|{
name|st_print_one
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|st_print_one
parameter_list|(
name|i
parameter_list|)
name|stindex
name|i
decl_stmt|;
block|{
name|printf
argument_list|(
literal|" %d	%-15s  %10d\n"
argument_list|,
name|i
argument_list|,
name|stab_name
argument_list|(
name|i
argument_list|)
argument_list|,
name|stab_addr
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|increment_data
parameter_list|(
name|dt
parameter_list|,
name|d1
parameter_list|,
name|d2
parameter_list|,
name|d3
parameter_list|,
name|d4
parameter_list|,
name|d5
parameter_list|,
name|d6
parameter_list|,
name|d7
parameter_list|,
name|d8
parameter_list|,
name|d9
parameter_list|,
name|d10
parameter_list|,
name|d11
parameter_list|,
name|d12
parameter_list|)
name|mpdata
name|dt
decl_stmt|;
name|int
name|d1
decl_stmt|,
name|d2
decl_stmt|,
name|d3
decl_stmt|,
name|d4
decl_stmt|,
name|d5
decl_stmt|,
name|d6
decl_stmt|,
name|d7
decl_stmt|,
name|d8
decl_stmt|,
name|d9
decl_stmt|,
name|d10
decl_stmt|,
name|d11
decl_stmt|,
name|d12
decl_stmt|;
block|{
name|dt_b_small
argument_list|(
name|dt
argument_list|)
operator|+=
name|d1
expr_stmt|;
name|dt_b_med
argument_list|(
name|dt
argument_list|)
operator|+=
name|d2
expr_stmt|;
name|dt_b_large
argument_list|(
name|dt
argument_list|)
operator|+=
name|d3
expr_stmt|;
name|dt_b_xlarge
argument_list|(
name|dt
argument_list|)
operator|+=
name|d4
expr_stmt|;
name|dt_n_small
argument_list|(
name|dt
argument_list|)
operator|+=
name|d5
expr_stmt|;
name|dt_n_med
argument_list|(
name|dt
argument_list|)
operator|+=
name|d6
expr_stmt|;
name|dt_n_large
argument_list|(
name|dt
argument_list|)
operator|+=
name|d7
expr_stmt|;
name|dt_n_xlarge
argument_list|(
name|dt
argument_list|)
operator|+=
name|d8
expr_stmt|;
name|dt_d_small
argument_list|(
name|dt
argument_list|)
operator|+=
name|d9
expr_stmt|;
name|dt_d_med
argument_list|(
name|dt
argument_list|)
operator|+=
name|d10
expr_stmt|;
name|dt_d_large
argument_list|(
name|dt
argument_list|)
operator|+=
name|d11
expr_stmt|;
name|dt_d_xlarge
argument_list|(
name|dt
argument_list|)
operator|+=
name|d12
expr_stmt|;
block|}
end_function

begin_function
name|void
name|st_convert
parameter_list|(
name|data_filename
parameter_list|)
name|char
modifier|*
name|data_filename
decl_stmt|;
block|{
name|FILE
modifier|*
name|f
init|=
name|fopen
argument_list|(
name|data_filename
argument_list|,
literal|"r"
argument_list|)
decl_stmt|;
name|unsigned
name|faddr
decl_stmt|,
name|paddr
decl_stmt|;
name|stindex
name|fx
decl_stmt|,
name|px
decl_stmt|;
name|mpsym
name|fsym
decl_stmt|,
name|psym
decl_stmt|;
name|mpdata
name|dcell
decl_stmt|;
name|mpcell
name|ppair
decl_stmt|;
name|int
name|d1
decl_stmt|,
name|d2
decl_stmt|,
name|d3
decl_stmt|,
name|d4
decl_stmt|,
name|d5
decl_stmt|,
name|d6
decl_stmt|,
name|d7
decl_stmt|,
name|d8
decl_stmt|,
name|d9
decl_stmt|,
name|d10
decl_stmt|,
name|d11
decl_stmt|,
name|d12
decl_stmt|;
name|int
name|i
decl_stmt|,
name|x
decl_stmt|;
comment|/*      * read the prolog containing stats      * handle the stats data first as a special case      */
name|check_fscanf
argument_list|(
name|fscanf
argument_list|(
name|f
argument_list|,
literal|"alloc=%d free=%d depth=%d same=%d all=%d\n"
argument_list|,
operator|&
name|d1
argument_list|,
operator|&
name|d2
argument_list|,
operator|&
name|d3
argument_list|,
operator|&
name|d4
argument_list|,
operator|&
name|d5
argument_list|)
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|check_fscanf
argument_list|(
name|fscanf
argument_list|(
name|f
argument_list|,
literal|"fmem=%d dmem=%d lmem=%d smem=%d\n"
argument_list|,
operator|&
name|d6
argument_list|,
operator|&
name|d7
argument_list|,
operator|&
name|d8
argument_list|,
operator|&
name|d9
argument_list|)
argument_list|)
expr_stmt|;
comment|/*      * print the prolog      */
name|printf
argument_list|(
literal|"--c%2s+--v3.0+--m%d+--+--+--+--+--+--+--+--+ MPROF +--+--+--+--+--+--+--s%d+--f%d+--d%d+--l%d+\n\n\n"
argument_list|,
name|percent
argument_list|(
name|d4
argument_list|,
name|d5
argument_list|)
argument_list|,
name|d3
argument_list|,
name|d9
argument_list|,
name|d6
argument_list|,
name|d7
argument_list|,
name|d8
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|print_bin_table
argument_list|(
name|f
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|print_leak_table
argument_list|(
name|f
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
while|while
condition|(
name|fscanf
argument_list|(
name|f
argument_list|,
literal|"%d\n"
argument_list|,
operator|&
name|faddr
argument_list|)
operator|!=
name|EOF
condition|)
block|{
name|fx
operator|=
name|st_locate
argument_list|(
name|faddr
argument_list|)
expr_stmt|;
name|fsym
operator|=
name|pc_lookup
argument_list|(
name|stab_addr
argument_list|(
name|fx
argument_list|)
argument_list|)
expr_stmt|;
name|fn_name
argument_list|(
name|fsym
argument_list|)
operator|=
name|stab_name
argument_list|(
name|fx
argument_list|)
expr_stmt|;
name|fscanf
argument_list|(
name|f
argument_list|,
literal|"%d %d %d %d %d %d %d %d %d %d %d %d\n"
argument_list|,
operator|&
name|d1
argument_list|,
operator|&
name|d2
argument_list|,
operator|&
name|d3
argument_list|,
operator|&
name|d4
argument_list|,
operator|&
name|d5
argument_list|,
operator|&
name|d6
argument_list|,
operator|&
name|d7
argument_list|,
operator|&
name|d8
argument_list|,
operator|&
name|d9
argument_list|,
operator|&
name|d10
argument_list|,
operator|&
name|d11
argument_list|,
operator|&
name|d12
argument_list|)
expr_stmt|;
name|increment_data
argument_list|(
name|fn_lcount
argument_list|(
name|fsym
argument_list|)
argument_list|,
name|d1
argument_list|,
name|d2
argument_list|,
name|d3
argument_list|,
name|d4
argument_list|,
name|d5
argument_list|,
name|d6
argument_list|,
name|d7
argument_list|,
name|d8
argument_list|,
name|d9
argument_list|,
name|d10
argument_list|,
name|d11
argument_list|,
name|d12
argument_list|)
expr_stmt|;
name|fscanf
argument_list|(
name|f
argument_list|,
literal|"%d\n"
argument_list|,
operator|&
name|paddr
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|int
operator|)
name|paddr
operator|!=
name|MP_NIL
condition|)
block|{
name|px
operator|=
name|st_locate
argument_list|(
name|paddr
argument_list|)
expr_stmt|;
name|psym
operator|=
name|pc_lookup
argument_list|(
name|stab_addr
argument_list|(
name|px
argument_list|)
argument_list|)
expr_stmt|;
name|ppair
operator|=
name|mp_has_parent
argument_list|(
name|fsym
argument_list|,
name|psym
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp_null
argument_list|(
name|ppair
argument_list|)
condition|)
block|{
name|dcell
operator|=
name|mp_new_data
argument_list|()
expr_stmt|;
name|ppair
operator|=
name|mp_cons
argument_list|(
operator|(
name|int
operator|)
name|psym
argument_list|,
operator|(
name|int
operator|)
name|dcell
argument_list|)
expr_stmt|;
name|fn_parents
argument_list|(
name|fsym
argument_list|)
operator|=
name|mp_cons
argument_list|(
operator|(
name|int
operator|)
name|ppair
argument_list|,
name|fn_parents
argument_list|(
name|fsym
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|fscanf
argument_list|(
name|f
argument_list|,
literal|"%d %d %d %d %d %d %d %d %d %d %d %d\n"
argument_list|,
operator|&
name|d1
argument_list|,
operator|&
name|d2
argument_list|,
operator|&
name|d3
argument_list|,
operator|&
name|d4
argument_list|,
operator|&
name|d5
argument_list|,
operator|&
name|d6
argument_list|,
operator|&
name|d7
argument_list|,
operator|&
name|d8
argument_list|,
operator|&
name|d9
argument_list|,
operator|&
name|d10
argument_list|,
operator|&
name|d11
argument_list|,
operator|&
name|d12
argument_list|)
expr_stmt|;
name|increment_data
argument_list|(
name|mp_cdr
argument_list|(
name|ppair
argument_list|)
argument_list|,
name|d1
argument_list|,
name|d2
argument_list|,
name|d3
argument_list|,
name|d4
argument_list|,
name|d5
argument_list|,
name|d6
argument_list|,
name|d7
argument_list|,
name|d8
argument_list|,
name|d9
argument_list|,
name|d10
argument_list|,
name|d11
argument_list|,
name|d12
argument_list|)
expr_stmt|;
name|fscanf
argument_list|(
name|f
argument_list|,
literal|"%d\n"
argument_list|,
operator|&
name|paddr
argument_list|)
expr_stmt|;
block|}
block|}
name|mprof_graph_ops
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|print_bin_table
parameter_list|(
name|infile
parameter_list|,
name|outfile
parameter_list|)
name|FILE
modifier|*
name|infile
decl_stmt|,
decl|*
name|outfile
decl_stmt|;
end_function

begin_block
block|{
name|int
name|i
decl_stmt|;
name|int
name|type_count
decl_stmt|,
name|type_index
init|=
literal|0
decl_stmt|;
name|struct
name|sthash
modifier|*
modifier|*
name|type_table
decl_stmt|;
name|int
name|alloc_bins
index|[
name|MP_NUM_BINS
index|]
decl_stmt|;
name|int
name|free_bins
index|[
name|MP_NUM_BINS
index|]
decl_stmt|;
name|int
name|big_alloc_count
decl_stmt|,
name|big_alloc_bytes
decl_stmt|;
name|int
name|big_free_count
decl_stmt|,
name|big_free_bytes
decl_stmt|;
name|int
name|alloc_count
init|=
literal|0
decl_stmt|,
name|alloc_bytes
init|=
literal|0
decl_stmt|,
name|free_count
init|=
literal|0
decl_stmt|,
name|free_bytes
init|=
literal|0
decl_stmt|;
name|int
name|other_alloc_count
init|=
literal|0
decl_stmt|,
name|other_alloc_bytes
init|=
literal|0
decl_stmt|;
name|int
name|other_free_count
init|=
literal|0
decl_stmt|,
name|other_free_bytes
init|=
literal|0
decl_stmt|;
name|int
name|abin
decl_stmt|,
name|fbin
decl_stmt|;
name|int
name|byte_difference
decl_stmt|;
comment|/*      * Read in and print out the Bin table information.      */
name|type_table
operator|=
name|read_and_sort_types
argument_list|(
operator|&
name|type_count
argument_list|)
expr_stmt|;
comment|/* read in the bins and save the data      */
name|alloc_count
operator|=
literal|0
expr_stmt|;
name|alloc_bytes
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|MP_NUM_BINS
operator|-
literal|2
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|check_fscanf
argument_list|(
name|fscanf
argument_list|(
name|infile
argument_list|,
literal|"%d\n"
argument_list|,
operator|&
name|alloc_bins
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|alloc_count
operator|+=
name|alloc_bins
index|[
name|i
index|]
expr_stmt|;
name|alloc_bytes
operator|+=
name|alloc_bins
index|[
name|i
index|]
operator|*
name|i
expr_stmt|;
block|}
name|check_fscanf
argument_list|(
name|fscanf
argument_list|(
name|infile
argument_list|,
literal|"%d\n"
argument_list|,
operator|&
name|big_alloc_count
argument_list|)
argument_list|)
expr_stmt|;
name|alloc_count
operator|+=
name|big_alloc_count
expr_stmt|;
if|if
condition|(
name|alloc_count
operator|==
literal|0
condition|)
block|{
name|alloc_count
operator|=
literal|1
expr_stmt|;
block|}
name|check_fscanf
argument_list|(
name|fscanf
argument_list|(
name|infile
argument_list|,
literal|"%d\n"
argument_list|,
operator|&
name|big_alloc_bytes
argument_list|)
argument_list|)
expr_stmt|;
name|alloc_bytes
operator|+=
name|big_alloc_bytes
expr_stmt|;
name|free_count
operator|=
literal|0
expr_stmt|;
name|free_bytes
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|MP_NUM_BINS
operator|-
literal|2
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|check_fscanf
argument_list|(
name|fscanf
argument_list|(
name|infile
argument_list|,
literal|"%d\n"
argument_list|,
operator|&
name|free_bins
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|free_count
operator|+=
name|free_bins
index|[
name|i
index|]
expr_stmt|;
name|free_bytes
operator|+=
name|free_bins
index|[
name|i
index|]
operator|*
name|i
expr_stmt|;
block|}
name|check_fscanf
argument_list|(
name|fscanf
argument_list|(
name|infile
argument_list|,
literal|"%d\n"
argument_list|,
operator|&
name|big_free_count
argument_list|)
argument_list|)
expr_stmt|;
name|free_count
operator|+=
name|big_free_count
expr_stmt|;
if|if
condition|(
name|free_count
operator|==
literal|0
condition|)
block|{
name|free_count
operator|=
literal|1
expr_stmt|;
block|}
name|check_fscanf
argument_list|(
name|fscanf
argument_list|(
name|infile
argument_list|,
literal|"%d\n"
argument_list|,
operator|&
name|big_free_bytes
argument_list|)
argument_list|)
expr_stmt|;
name|free_bytes
operator|+=
name|big_free_bytes
expr_stmt|;
name|byte_difference
operator|=
name|alloc_bytes
operator|-
name|free_bytes
expr_stmt|;
define|#
directive|define
name|abin_template
define|\
value|"%11d%10d%10d %-4s%10d%10d %-4s   "
define|#
directive|define
name|abin_template2
define|\
value|"%11s%10d%10d %-4s%10d%10d %-4s   "
define|#
directive|define
name|abin_titles_template
define|\
value|"%11s%10s%10s %-4s%10s%10s %-4s    %-8s\n"
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"--------- Allocation Bins with possible Types ------------\n\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
name|abin_titles_template
argument_list|,
literal|"size:"
argument_list|,
literal|"allocs"
argument_list|,
literal|"bytes"
argument_list|,
literal|"(%)"
argument_list|,
literal|"frees"
argument_list|,
literal|"kept"
argument_list|,
literal|"(%)"
argument_list|,
literal|"types"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|MP_NUM_BINS
operator|-
literal|2
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|abin
operator|=
name|alloc_bins
index|[
name|i
index|]
expr_stmt|;
name|fbin
operator|=
name|free_bins
index|[
name|i
index|]
expr_stmt|;
comment|/* 	 * Print things depending on the level of verbosity. 	 */
if|if
condition|(
operator|(
operator|(
name|verbosity
operator|==
name|V_VERBOSE
operator|)
operator|&&
operator|(
operator|(
name|abin
operator|>
literal|0
operator|)
operator|||
operator|(
name|fbin
operator|>
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
operator|(
name|verbosity
operator|==
name|V_NORMAL
operator|)
operator|&&
operator|(
operator|(
operator|(
name|abin
operator|>
literal|0
operator|)
operator|&&
operator|(
name|i
operator|>
literal|100
operator|)
operator|)
operator|||
operator|(
operator|(
operator|(
name|double
operator|)
name|abin
operator|/
name|alloc_count
operator|)
operator|>
literal|1.0
operator|/
literal|500.0
operator|)
operator|||
operator|(
operator|(
name|type_index
operator|!=
name|type_count
operator|)
operator|&&
operator|(
operator|(
operator|(
name|double
operator|)
name|abin
operator|/
name|alloc_count
operator|)
operator|>
literal|1.0
operator|/
literal|100.0
operator|)
operator|&&
operator|(
operator|(
name|type_table
index|[
name|type_index
index|]
operator|)
operator|->
name|size
operator|==
name|i
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
operator|(
name|verbosity
operator|==
name|V_TERSE
operator|)
operator|&&
operator|(
operator|(
operator|(
operator|(
name|double
operator|)
name|abin
operator|/
name|alloc_count
operator|)
operator|>
literal|1.0
operator|/
literal|50.0
operator|)
operator|||
operator|(
operator|(
name|type_index
operator|!=
name|type_count
operator|)
operator|&&
operator|(
operator|(
operator|(
name|double
operator|)
name|abin
operator|/
name|alloc_count
operator|)
operator|>
literal|1.0
operator|/
literal|100.0
operator|)
operator|&&
operator|(
operator|(
name|type_table
index|[
name|type_index
index|]
operator|)
operator|->
name|size
operator|==
name|i
operator|)
operator|)
operator|)
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|outfile
argument_list|,
name|abin_template
argument_list|,
name|i
argument_list|,
name|abin
argument_list|,
name|i
operator|*
name|abin
argument_list|,
name|percent_string
argument_list|(
name|i
operator|*
name|abin
argument_list|,
name|alloc_bytes
argument_list|)
argument_list|,
name|fbin
argument_list|,
operator|(
name|i
operator|*
name|abin
operator|)
operator|-
operator|(
name|i
operator|*
name|fbin
operator|)
argument_list|,
name|percent_string
argument_list|(
operator|(
name|i
operator|*
name|abin
operator|)
operator|-
operator|(
name|i
operator|*
name|fbin
operator|)
argument_list|,
name|byte_difference
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	     * Print out relevant types. 	     */
name|print_type_list
argument_list|(
name|outfile
argument_list|,
name|type_table
argument_list|,
name|TYPE_EQUAL
argument_list|,
name|i
argument_list|,
name|type_count
argument_list|,
operator|&
name|type_index
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|other_alloc_count
operator|+=
name|abin
expr_stmt|;
name|other_free_count
operator|+=
name|fbin
expr_stmt|;
name|other_alloc_bytes
operator|+=
name|abin
operator|*
name|i
expr_stmt|;
name|other_free_bytes
operator|+=
name|fbin
operator|*
name|i
expr_stmt|;
block|}
block|}
comment|/*      * Print the things at the end of the table.      */
name|fprintf
argument_list|(
name|outfile
argument_list|,
name|abin_template2
argument_list|,
literal|"> 1024"
argument_list|,
name|big_alloc_count
argument_list|,
name|big_alloc_bytes
argument_list|,
name|percent_string
argument_list|(
name|big_alloc_bytes
argument_list|,
name|alloc_bytes
argument_list|)
argument_list|,
name|big_free_count
argument_list|,
operator|(
name|big_alloc_bytes
operator|-
name|big_free_bytes
operator|)
argument_list|,
name|percent_string
argument_list|(
operator|(
name|big_alloc_bytes
operator|-
name|big_free_bytes
operator|)
argument_list|,
name|byte_difference
argument_list|)
argument_list|)
expr_stmt|;
name|print_type_list
argument_list|(
name|outfile
argument_list|,
name|type_table
argument_list|,
name|TYPE_GREATERTHAN
argument_list|,
literal|1024
argument_list|,
name|type_count
argument_list|,
operator|&
name|type_index
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\n\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|other_alloc_count
operator|>
literal|0
operator|)
operator|||
operator|(
name|other_free_count
operator|>
literal|0
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|outfile
argument_list|,
name|abin_template2
argument_list|,
literal|"other bins"
argument_list|,
name|other_alloc_count
argument_list|,
name|other_alloc_bytes
argument_list|,
name|percent_string
argument_list|(
name|other_alloc_bytes
argument_list|,
name|alloc_bytes
argument_list|)
argument_list|,
name|other_free_count
argument_list|,
operator|(
name|other_alloc_bytes
operator|-
name|other_free_bytes
operator|)
argument_list|,
name|percent_string
argument_list|(
operator|(
name|other_alloc_bytes
operator|-
name|other_free_bytes
operator|)
argument_list|,
name|byte_difference
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|outfile
argument_list|,
name|abin_template2
argument_list|,
literal|"<TOTAL>"
argument_list|,
name|alloc_count
argument_list|,
name|alloc_bytes
argument_list|,
literal|""
argument_list|,
name|free_count
argument_list|,
name|byte_difference
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\n\f\n\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|outfile
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|void
name|print_type_list
parameter_list|(
name|outfile
parameter_list|,
name|tlist
parameter_list|,
name|compar
parameter_list|,
name|binsize
parameter_list|,
name|type_count
parameter_list|,
name|type_index
parameter_list|)
name|FILE
modifier|*
name|outfile
decl_stmt|;
name|struct
name|sthash
modifier|*
modifier|*
name|tlist
decl_stmt|;
name|int
name|compar
decl_stmt|,
name|binsize
decl_stmt|,
name|type_count
decl_stmt|;
name|int
modifier|*
name|type_index
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|cond
decl_stmt|,
name|pcount
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
operator|*
name|type_index
init|;
operator|(
operator|(
name|i
operator|<
name|type_count
operator|)
operator|&&
operator|(
name|tlist
index|[
name|i
index|]
operator|->
name|size
operator|<=
name|binsize
operator|)
operator|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|compar
operator|==
name|TYPE_EQUAL
condition|)
block|{
name|cond
operator|=
operator|(
name|tlist
index|[
name|i
index|]
operator|->
name|size
operator|==
name|binsize
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|compar
operator|==
name|TYPE_GREATERTHAN
condition|)
block|{
name|cond
operator|=
operator|(
name|tlist
index|[
name|i
index|]
operator|->
name|size
operator|>
name|binsize
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|cond
condition|)
block|{
comment|/* 	     * Make the spacing nice. 	     */
if|if
condition|(
operator|(
name|pcount
operator|>
literal|0
operator|)
operator|&&
operator|(
operator|(
name|pcount
operator|%
literal|3
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\n%64s"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"%-12s "
argument_list|,
name|tlist
index|[
name|i
index|]
operator|->
name|str
argument_list|)
expr_stmt|;
name|pcount
operator|+=
literal|1
expr_stmt|;
block|}
block|}
operator|*
name|type_index
operator|=
name|i
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_define
define|#
directive|define
name|leak_titles_template1
define|\
value|"%10s %-4s%10s%10s %-4s%10s%10s %-4s    %-8s\n"
end_define

begin_define
define|#
directive|define
name|leak_titles_template2
define|\
value|"%10s %-4s%10s%10s %-4s    %-8s\n"
end_define

begin_define
define|#
directive|define
name|leak_template1
define|\
value|"%10d %-4s%10d%10d %-4s%10d%10d %-4s   "
end_define

begin_define
define|#
directive|define
name|leak_template2
define|\
value|"%10d %-4s%10d%10d %-4s   "
end_define

begin_function
name|void
name|print_leak_table
parameter_list|(
name|infile
parameter_list|,
name|outfile
parameter_list|)
name|FILE
modifier|*
name|infile
decl_stmt|,
decl|*
name|outfile
decl_stmt|;
end_function

begin_block
block|{
name|int
name|total_allocs
init|=
literal|0
decl_stmt|,
name|bytes_alloced
init|=
literal|0
decl_stmt|;
name|int
name|total_frees
init|=
literal|0
decl_stmt|,
name|bytes_freed
init|=
literal|0
decl_stmt|;
name|int
name|byte_diff
decl_stmt|;
name|struct
name|leakentry
modifier|*
name|lt_root
init|=
name|NULL
decl_stmt|,
modifier|*
name|lte
init|=
name|NULL
decl_stmt|,
modifier|*
name|lt_vec
init|=
name|NULL
decl_stmt|;
name|int
name|lte_count
init|=
literal|0
decl_stmt|;
name|int
name|d1
decl_stmt|,
name|d2
decl_stmt|,
name|d3
decl_stmt|,
name|d4
decl_stmt|,
name|d5
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|,
name|real_i
decl_stmt|;
name|stindex
name|fx
decl_stmt|;
name|mpsym
name|fsym
decl_stmt|;
comment|/* read in the leak table and print it back out      */
name|check_fscanf
argument_list|(
name|fscanf
argument_list|(
name|infile
argument_list|,
literal|"%d %d %d %d\n"
argument_list|,
operator|&
name|d1
argument_list|,
operator|&
name|d2
argument_list|,
operator|&
name|d3
argument_list|,
operator|&
name|d4
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|d1
operator|!=
operator|-
literal|2
condition|)
block|{
comment|/* 	 * Gather the path for a single leak table entry. 	 */
name|lte
operator|=
operator|(
expr|struct
name|leakentry
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|leakentry
argument_list|)
argument_list|)
expr_stmt|;
name|lte_count
operator|+=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SHORT_CALLSTACK_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|check_fscanf
argument_list|(
name|fscanf
argument_list|(
name|infile
argument_list|,
literal|"%d\n"
argument_list|,
operator|&
name|d5
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|d5
operator|!=
literal|0
condition|)
block|{
name|fx
operator|=
name|st_locate
argument_list|(
name|d5
argument_list|)
expr_stmt|;
name|fsym
operator|=
name|pc_lookup
argument_list|(
name|stab_addr
argument_list|(
name|fx
argument_list|)
argument_list|)
expr_stmt|;
name|fn_name
argument_list|(
name|fsym
argument_list|)
operator|=
name|stab_name
argument_list|(
name|fx
argument_list|)
expr_stmt|;
name|lte
operator|->
name|path
index|[
name|SHORT_CALLSTACK_SIZE
operator|-
operator|(
name|i
operator|+
literal|1
operator|)
index|]
operator|.
name|func
operator|=
name|fn_name
argument_list|(
name|fsym
argument_list|)
expr_stmt|;
name|lte
operator|->
name|path
index|[
name|SHORT_CALLSTACK_SIZE
operator|-
operator|(
name|i
operator|+
literal|1
operator|)
index|]
operator|.
name|offset
operator|=
name|d5
operator|-
name|stab_addr
argument_list|(
name|fx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|lte
operator|->
name|path
index|[
name|SHORT_CALLSTACK_SIZE
operator|-
operator|(
name|i
operator|+
literal|1
operator|)
index|]
operator|.
name|func
operator|=
literal|""
expr_stmt|;
name|lte
operator|->
name|path
index|[
name|SHORT_CALLSTACK_SIZE
operator|-
operator|(
name|i
operator|+
literal|1
operator|)
index|]
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|lte
operator|->
name|all_no
operator|=
name|d1
expr_stmt|;
name|total_allocs
operator|+=
name|d1
expr_stmt|;
name|lte
operator|->
name|all_by
operator|=
name|d2
expr_stmt|;
name|bytes_alloced
operator|+=
name|d2
expr_stmt|;
name|lte
operator|->
name|fre_no
operator|=
name|d3
expr_stmt|;
name|total_frees
operator|+=
name|d3
expr_stmt|;
name|lte
operator|->
name|fre_by
operator|=
name|d4
expr_stmt|;
name|bytes_freed
operator|+=
name|d4
expr_stmt|;
comment|/* 	 * Add to the list of leak entries. 	 */
name|lte
operator|->
name|next
operator|=
name|lt_root
expr_stmt|;
name|lt_root
operator|=
name|lte
expr_stmt|;
name|check_fscanf
argument_list|(
name|fscanf
argument_list|(
name|infile
argument_list|,
literal|"%d %d %d %d"
argument_list|,
operator|&
name|d1
argument_list|,
operator|&
name|d2
argument_list|,
operator|&
name|d3
argument_list|,
operator|&
name|d4
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|byte_diff
operator|=
name|bytes_alloced
operator|-
name|bytes_freed
expr_stmt|;
if|if
condition|(
operator|(
name|lte_count
operator|==
literal|0
operator|)
operator|||
operator|(
name|leak_level
operator|==
name|LEAK_NONE
operator|)
condition|)
block|{
return|return;
block|}
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"--------- Partial Dynamic Call Paths for Memory Leaks ------------\n\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"Total bytes not freed: %d\n\n"
argument_list|,
name|byte_diff
argument_list|)
expr_stmt|;
if|if
condition|(
name|total_frees
operator|>
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|outfile
argument_list|,
name|leak_titles_template1
argument_list|,
literal|"kept bytes"
argument_list|,
literal|"(%)"
argument_list|,
literal|"allocs"
argument_list|,
literal|"bytes"
argument_list|,
literal|"(%)"
argument_list|,
literal|"frees"
argument_list|,
literal|"bytes"
argument_list|,
literal|"(%)"
argument_list|,
literal|"path"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|outfile
argument_list|,
name|leak_titles_template2
argument_list|,
literal|"kept bytes"
argument_list|,
literal|"(%)"
argument_list|,
literal|"allocs"
argument_list|,
literal|"bytes"
argument_list|,
literal|"(%)"
argument_list|,
literal|"path"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
comment|/*      * Here we put the leak table entries into a vector so we can      * manipulate them.      */
name|lt_vec
operator|=
operator|(
expr|struct
name|leakentry
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|leakentry
argument_list|)
operator|*
name|lte_count
argument_list|)
expr_stmt|;
name|lte
operator|=
name|lt_root
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|lte
operator|!=
name|NULL
condition|)
block|{
name|struct
name|leakentry
modifier|*
name|tmp
decl_stmt|;
name|lt_vec
index|[
name|i
index|]
operator|=
operator|*
name|lte
expr_stmt|;
name|i
operator|++
expr_stmt|;
name|tmp
operator|=
name|lte
expr_stmt|;
name|lte
operator|=
name|lte
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|leak_level
operator|==
name|LEAK_SHOW
condition|)
block|{
comment|/* 	 * Sort the entries so that duplicate paths are together. 	 */
name|qsort
argument_list|(
operator|(
name|char
operator|*
operator|)
name|lt_vec
argument_list|,
name|lte_count
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|leakentry
argument_list|)
argument_list|,
name|lte_str_compar
argument_list|)
expr_stmt|;
if|if
condition|(
name|lte_count
operator|>
literal|1
condition|)
block|{
name|real_i
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|lte_count
condition|;
control|)
block|{
if|if
condition|(
name|path_equal
argument_list|(
name|lt_vec
index|[
name|real_i
index|]
operator|.
name|path
argument_list|,
name|lt_vec
index|[
name|i
index|]
operator|.
name|path
argument_list|)
condition|)
block|{
comment|/* 		     * Merge the data from identical paths together. 		     */
name|lt_vec
index|[
name|real_i
index|]
operator|.
name|all_no
operator|+=
name|lt_vec
index|[
name|i
index|]
operator|.
name|all_no
expr_stmt|;
name|lt_vec
index|[
name|real_i
index|]
operator|.
name|all_by
operator|+=
name|lt_vec
index|[
name|i
index|]
operator|.
name|all_by
expr_stmt|;
name|lt_vec
index|[
name|real_i
index|]
operator|.
name|fre_no
operator|+=
name|lt_vec
index|[
name|i
index|]
operator|.
name|fre_no
expr_stmt|;
name|lt_vec
index|[
name|real_i
index|]
operator|.
name|fre_by
operator|+=
name|lt_vec
index|[
name|i
index|]
operator|.
name|fre_by
expr_stmt|;
name|i
operator|+=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|real_i
operator|+=
literal|1
expr_stmt|;
comment|/* 		     * First, copy the data, compressing out bubbles 		     */
if|if
condition|(
name|real_i
operator|!=
name|i
condition|)
block|{
name|lt_vec
index|[
name|real_i
index|]
operator|=
name|lt_vec
index|[
name|i
index|]
expr_stmt|;
block|}
name|i
operator|+=
literal|1
expr_stmt|;
block|}
block|}
name|lte_count
operator|=
name|real_i
operator|+
literal|1
expr_stmt|;
block|}
block|}
name|qsort
argument_list|(
operator|(
name|char
operator|*
operator|)
name|lt_vec
argument_list|,
name|lte_count
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|leakentry
argument_list|)
argument_list|,
name|lte_size_compar
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|lte_count
condition|;
name|i
operator|+=
literal|1
control|)
block|{
name|struct
name|leakentry
name|lte
decl_stmt|;
name|lte
operator|=
name|lt_vec
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|verbosity
operator|==
name|V_TERSE
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|double
operator|)
name|lte
operator|.
name|all_by
operator|/
name|bytes_alloced
operator|)
operator|<
literal|0.01
condition|)
block|{
continue|continue;
block|}
block|}
elseif|else
if|if
condition|(
name|verbosity
operator|==
name|V_NORMAL
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|double
operator|)
name|lte
operator|.
name|all_by
operator|/
name|bytes_alloced
operator|)
operator|<
literal|0.005
condition|)
block|{
continue|continue;
block|}
block|}
if|if
condition|(
name|total_frees
operator|>
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|outfile
argument_list|,
name|leak_template1
argument_list|,
operator|(
name|lte
operator|.
name|all_by
operator|-
name|lte
operator|.
name|fre_by
operator|)
argument_list|,
name|percent_string
argument_list|(
operator|(
name|lte
operator|.
name|all_by
operator|-
name|lte
operator|.
name|fre_by
operator|)
argument_list|,
name|byte_diff
argument_list|)
argument_list|,
name|lte
operator|.
name|all_no
argument_list|,
name|lte
operator|.
name|all_by
argument_list|,
name|percent_string
argument_list|(
name|lte
operator|.
name|all_by
argument_list|,
name|bytes_alloced
argument_list|)
argument_list|,
name|lte
operator|.
name|fre_no
argument_list|,
name|lte
operator|.
name|fre_by
argument_list|,
name|percent_string
argument_list|(
name|lte
operator|.
name|fre_by
argument_list|,
name|bytes_freed
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|outfile
argument_list|,
name|leak_template2
argument_list|,
operator|(
name|lte
operator|.
name|all_by
operator|-
name|lte
operator|.
name|fre_by
operator|)
argument_list|,
name|percent_string
argument_list|(
operator|(
name|lte
operator|.
name|all_by
operator|-
name|lte
operator|.
name|fre_by
operator|)
argument_list|,
name|byte_diff
argument_list|)
argument_list|,
name|lte
operator|.
name|all_no
argument_list|,
name|lte
operator|.
name|all_by
argument_list|,
name|percent_string
argument_list|(
name|lte
operator|.
name|all_by
argument_list|,
name|bytes_alloced
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|strcmp
argument_list|(
name|lte
operator|.
name|path
index|[
literal|0
index|]
operator|.
name|func
argument_list|,
literal|""
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|strcmp
argument_list|(
name|lte
operator|.
name|path
index|[
literal|0
index|]
operator|.
name|func
argument_list|,
literal|"main"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"|| "
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"..."
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|SHORT_CALLSTACK_SIZE
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|lte
operator|.
name|path
index|[
name|j
index|]
operator|.
name|func
argument_list|,
literal|""
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|leak_level
operator|==
name|LEAK_SHOW
condition|)
block|{
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"> %s "
argument_list|,
name|lte
operator|.
name|path
index|[
name|j
index|]
operator|.
name|func
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|leak_level
operator|==
name|LEAK_OFFSETS
condition|)
block|{
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"> %s+%d "
argument_list|,
name|lte
operator|.
name|path
index|[
name|j
index|]
operator|.
name|func
argument_list|,
name|lte
operator|.
name|path
index|[
name|j
index|]
operator|.
name|offset
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\n\f\n\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|outfile
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_function
name|void
name|usage
parameter_list|()
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage: mprof [-leaktable | -noleaktable] \n\ 		[-verbose | -normal | -terse] \n\ 		[a.out-name] [data-name]\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|str_equal
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|)
value|(strcmp((s1), (s2)) == 0)
end_define

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|exec_file
init|=
literal|"a.out"
decl_stmt|;
name|char
modifier|*
name|data_file
init|=
literal|"mprof.data"
decl_stmt|;
comment|/*      * Default settings.      */
name|leak_level
operator|=
name|LEAK_SHOW
expr_stmt|;
name|verbosity
operator|=
name|V_NORMAL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|str_equal
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-leaktable"
argument_list|)
condition|)
block|{
name|leak_level
operator|=
name|LEAK_SHOW
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|str_equal
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-noleaktable"
argument_list|)
condition|)
block|{
name|leak_level
operator|=
name|LEAK_NONE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|str_equal
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-offsets"
argument_list|)
condition|)
block|{
name|leak_level
operator|=
name|LEAK_OFFSETS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|str_equal
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-verbose"
argument_list|)
condition|)
block|{
name|verbosity
operator|=
name|V_VERBOSE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|str_equal
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-normal"
argument_list|)
condition|)
block|{
name|verbosity
operator|=
name|V_NORMAL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|str_equal
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-terse"
argument_list|)
condition|)
block|{
name|verbosity
operator|=
name|V_TERSE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|==
operator|(
name|argc
operator|-
literal|1
operator|)
condition|)
block|{
name|exec_file
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|i
operator|==
operator|(
name|argc
operator|-
literal|2
operator|)
condition|)
block|{
name|exec_file
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
name|data_file
operator|=
name|argv
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
break|break;
block|}
else|else
block|{
name|usage
argument_list|()
expr_stmt|;
block|}
block|}
name|mpstruct_init
argument_list|()
expr_stmt|;
name|stab_i
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ST_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|stab_name
argument_list|(
name|i
argument_list|)
operator|=
name|NULL
expr_stmt|;
block|}
name|st_read
argument_list|(
name|exec_file
argument_list|)
expr_stmt|;
name|st_convert
argument_list|(
name|data_file
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

