begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	mpgraph.c 1.5 10/12/90 15:57:57	*/
end_comment

begin_comment
comment|/*	Copyright (c) 1987, Benjamin G. Zorn */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"mprof.h"
end_include

begin_typedef
typedef|typedef
struct|struct
name|entry
block|{
name|char
modifier|*
name|key
decl_stmt|;
comment|/* assume keys are character strings */
name|char
modifier|*
name|data
decl_stmt|;
block|}
name|ENTRY
typedef|;
end_typedef

begin_typedef
typedef|typedef
enum|enum
block|{
name|FIND
block|,
name|ENTER
block|}
name|ACTION
typedef|;
end_typedef

begin_function_decl
name|void
name|henter
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|ENTRY
modifier|*
name|hsearch
parameter_list|()
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|min
parameter_list|(
name|i1
parameter_list|,
name|i2
parameter_list|)
value|(((i1)< (i2)) ? (i1) : (i2))
end_define

begin_define
define|#
directive|define
name|UNDEFINED
value|-1
end_define

begin_define
define|#
directive|define
name|UNUSED
value|-1
end_define

begin_define
define|#
directive|define
name|USED
value|0
end_define

begin_decl_stmt
name|FILE
modifier|*
name|stout
init|=
name|stdout
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|sterr
init|=
name|stderr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|mpcell
name|hmem
index|[]
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|char
modifier|*
name|strdup
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|percent_string
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|new_cycle_name
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|mpdata
name|add_data_over
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|sum_vertex_incoming_calls
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|sum_vertex_outgoing_calls
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|print_dynamic_graph_header
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|print_separator
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|print_cycle_information
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|print_vertex_in_cycle
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|print_normal_vertex
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|print_self_line
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|vdata_compar
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|vbytes_compar
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|print_vertex
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|print_edge
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|print_vecons
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|v_count
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|e_count
decl_stmt|;
end_decl_stmt

begin_struct_decl
struct_decl|struct
name|vecons_struct
struct_decl|;
end_struct_decl

begin_typedef
typedef|typedef
struct|struct
name|vertex_struct
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|number
decl_stmt|;
name|int
name|srefs
decl_stmt|;
name|mpdata
name|data
decl_stmt|;
name|struct
name|vecons_struct
modifier|*
name|edges
decl_stmt|;
name|struct
name|vecons_struct
modifier|*
name|backedges
decl_stmt|;
name|int
modifier|*
name|other
decl_stmt|;
name|int
modifier|*
name|save
decl_stmt|;
name|int
modifier|*
name|scratch
decl_stmt|;
name|struct
name|vertex_struct
modifier|*
name|save_copy
decl_stmt|;
comment|/*      * For SCC detection      */
name|struct
name|vertex_struct
modifier|*
name|father
decl_stmt|;
name|int
name|k
decl_stmt|,
name|L
decl_stmt|;
name|bool
name|on_S
decl_stmt|;
comment|/*      * For SCC representation.      */
name|struct
name|vecons_struct
modifier|*
name|scc_members
decl_stmt|;
name|struct
name|vertex_struct
modifier|*
name|in_cycle
decl_stmt|;
comment|/*      * For printing out.      */
name|int
name|index
decl_stmt|;
block|}
typedef|*
name|vertex
operator|,
name|vertex_item
typedef|;
end_typedef

begin_function
name|vertex
name|make_vertex
parameter_list|(
name|name
parameter_list|,
name|number
parameter_list|,
name|data
parameter_list|,
name|scratch
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|number
decl_stmt|;
name|mpdata
name|data
decl_stmt|;
name|int
modifier|*
name|scratch
decl_stmt|;
block|{
name|vertex
name|result
init|=
operator|(
name|vertex
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|vertex_item
argument_list|)
argument_list|)
decl_stmt|;
name|result
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|result
operator|->
name|number
operator|=
name|number
expr_stmt|;
name|result
operator|->
name|srefs
operator|=
literal|0
expr_stmt|;
name|result
operator|->
name|data
operator|=
name|data
expr_stmt|;
name|result
operator|->
name|backedges
operator|=
name|NULL
expr_stmt|;
name|result
operator|->
name|edges
operator|=
name|NULL
expr_stmt|;
name|result
operator|->
name|scratch
operator|=
name|scratch
expr_stmt|;
name|result
operator|->
name|save_copy
operator|=
name|NULL
expr_stmt|;
name|result
operator|->
name|father
operator|=
operator|(
name|vertex
operator|)
name|UNDEFINED
expr_stmt|;
name|result
operator|->
name|k
operator|=
literal|0
expr_stmt|;
name|result
operator|->
name|L
operator|=
literal|0
expr_stmt|;
name|result
operator|->
name|on_S
operator|=
name|FALSE
expr_stmt|;
name|result
operator|->
name|scc_members
operator|=
name|NULL
expr_stmt|;
name|result
operator|->
name|in_cycle
operator|=
name|NULL
expr_stmt|;
name|result
operator|->
name|index
operator|=
literal|0
expr_stmt|;
name|henter
argument_list|(
name|name
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_typedef
typedef|typedef
struct|struct
name|edge_struct
block|{
name|vertex
name|from
decl_stmt|,
name|to
decl_stmt|;
name|mpdata
name|data
decl_stmt|;
name|int
name|mark
decl_stmt|;
block|struct
name|edge_struct
operator|*
name|save
block|}
typedef|*
name|edge
operator|,
name|edge_item
typedef|;
end_typedef

begin_function
name|edge
name|make_edge
parameter_list|(
name|vfrom
parameter_list|,
name|vto
parameter_list|,
name|data
parameter_list|)
name|vertex
name|vfrom
decl_stmt|,
name|vto
decl_stmt|;
name|mpdata
name|data
decl_stmt|;
block|{
name|edge
name|result
init|=
operator|(
name|edge
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|edge_item
argument_list|)
argument_list|)
decl_stmt|;
name|result
operator|->
name|from
operator|=
name|vfrom
expr_stmt|;
name|result
operator|->
name|to
operator|=
name|vto
expr_stmt|;
name|result
operator|->
name|data
operator|=
name|data
expr_stmt|;
name|result
operator|->
name|mark
operator|=
name|UNUSED
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_typedef
typedef|typedef
enum|enum
block|{
name|VERTEX
block|,
name|EDGE
block|,
name|VECONS
block|}
name|vetype
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|vecons_struct
block|{
name|vetype
name|headtype
decl_stmt|;
name|int
modifier|*
name|vehead
decl_stmt|;
name|struct
name|vecons_struct
modifier|*
name|vetail
decl_stmt|;
block|}
name|vecell_item
operator|,
typedef|*
name|vecell
typedef|;
end_typedef

begin_define
define|#
directive|define
name|VECELL_SIZE
value|(sizeof(vecell_item))
end_define

begin_define
define|#
directive|define
name|vehdtype
parameter_list|(
name|i
parameter_list|)
value|((i)->headtype)
end_define

begin_define
define|#
directive|define
name|vehd
parameter_list|(
name|i
parameter_list|)
value|((i)->vehead)
end_define

begin_define
define|#
directive|define
name|vetl
parameter_list|(
name|i
parameter_list|)
value|((i)->vetail)
end_define

begin_define
define|#
directive|define
name|venull
parameter_list|(
name|i
parameter_list|)
value|(((char *) i) == NULL)
end_define

begin_function
name|vecell
name|vecons
parameter_list|(
name|headtype
parameter_list|,
name|head
parameter_list|,
name|tail
parameter_list|)
name|vetype
name|headtype
decl_stmt|;
name|int
modifier|*
name|head
decl_stmt|;
name|vecell
name|tail
decl_stmt|;
block|{
name|vecell
name|result
init|=
operator|(
name|vecell
operator|)
name|malloc
argument_list|(
name|VECELL_SIZE
argument_list|)
decl_stmt|;
name|vehdtype
argument_list|(
name|result
argument_list|)
operator|=
name|headtype
expr_stmt|;
name|vehd
argument_list|(
name|result
argument_list|)
operator|=
name|head
expr_stmt|;
name|vetl
argument_list|(
name|result
argument_list|)
operator|=
name|tail
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_define
define|#
directive|define
name|ccons
parameter_list|(
name|h
parameter_list|,
name|t
parameter_list|)
value|vecons(VECONS, (int *) (h), (t))
end_define

begin_define
define|#
directive|define
name|econs
parameter_list|(
name|h
parameter_list|,
name|t
parameter_list|)
value|vecons(EDGE, (int *) (h), (t))
end_define

begin_define
define|#
directive|define
name|vcons
parameter_list|(
name|h
parameter_list|,
name|t
parameter_list|)
value|vecons(VERTEX, (int *) (h), (t))
end_define

begin_define
define|#
directive|define
name|epush
parameter_list|(
name|item
parameter_list|,
name|listvar
parameter_list|)
define|\
value|(listvar = (vecons(EDGE, (int *) (item), listvar)))
end_define

begin_define
define|#
directive|define
name|vpush
parameter_list|(
name|item
parameter_list|,
name|listvar
parameter_list|)
define|\
value|(listvar = (vecons(VERTEX, (int *) (item), listvar)))
end_define

begin_define
define|#
directive|define
name|cpush
parameter_list|(
name|item
parameter_list|,
name|listvar
parameter_list|)
define|\
value|(listvar = (vecons(VECONS, (int *) (item), listvar)))
end_define

begin_define
define|#
directive|define
name|DO_VLIST
parameter_list|(
name|var
parameter_list|,
name|list
parameter_list|)
define|\
value|{vertex var; vecell TMPlisttail; \ 	   for(TMPlisttail = (list); \ 	       !venull(TMPlisttail); \ 	       TMPlisttail = vetl(TMPlisttail)) { \ 	     var = (vertex) vehd(TMPlisttail); {
end_define

begin_define
define|#
directive|define
name|DO_ELIST
parameter_list|(
name|var
parameter_list|,
name|list
parameter_list|)
define|\
value|{edge var; vecell TMPlisttail; \ 	   for(TMPlisttail = (list); \ 	       !venull(TMPlisttail); \ 	       TMPlisttail = vetl(TMPlisttail)) { \ 	     var = (edge) vehd(TMPlisttail); {
end_define

begin_define
define|#
directive|define
name|DO_LIST
parameter_list|(
name|var
parameter_list|,
name|list
parameter_list|)
define|\
value|{vecell var; vecell TMPlisttail; \ 	   for(TMPlisttail = (list); \ 	       !venull(TMPlisttail); \ 	       TMPlisttail = vetl(TMPlisttail)) { \ 	     var = (vecell) vehd(TMPlisttail); {
end_define

begin_define
define|#
directive|define
name|END_DO
value|}}}
end_define

begin_function_decl
name|vecell
name|vsort
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|void
name|print_vecons
parameter_list|(
name|f
parameter_list|,
name|cell
parameter_list|)
name|FILE
modifier|*
name|f
decl_stmt|;
name|vecell
name|cell
decl_stmt|;
block|{
name|vecell
name|rest
init|=
name|cell
decl_stmt|;
if|if
condition|(
name|venull
argument_list|(
name|cell
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"[]"
argument_list|)
expr_stmt|;
return|return;
block|}
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"["
argument_list|)
expr_stmt|;
do|do
block|{
comment|/* 	 * Print the car 	 */
if|if
condition|(
name|vehdtype
argument_list|(
name|cell
argument_list|)
operator|==
name|EDGE
condition|)
block|{
name|print_edge
argument_list|(
name|f
argument_list|,
operator|(
name|edge
operator|)
name|vehd
argument_list|(
name|rest
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vehdtype
argument_list|(
name|cell
argument_list|)
operator|==
name|VERTEX
condition|)
block|{
name|print_vertex
argument_list|(
name|f
argument_list|,
operator|(
name|vertex
operator|)
name|vehd
argument_list|(
name|rest
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vehdtype
argument_list|(
name|cell
argument_list|)
operator|==
name|VECONS
condition|)
block|{
name|print_vecons
argument_list|(
name|f
argument_list|,
operator|(
name|vecell
operator|)
name|vehd
argument_list|(
name|rest
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Check the cdr. 	 */
if|if
condition|(
name|venull
argument_list|(
name|vetl
argument_list|(
name|rest
argument_list|)
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"]"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
block|}
name|rest
operator|=
name|vetl
argument_list|(
name|rest
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|venull
argument_list|(
name|rest
argument_list|)
condition|)
do|;
block|}
end_function

begin_function
name|int
name|velength
parameter_list|(
name|vel
parameter_list|)
name|vecell
name|vel
decl_stmt|;
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|!
name|venull
argument_list|(
name|vel
argument_list|)
condition|)
block|{
name|count
operator|+=
literal|1
expr_stmt|;
name|vel
operator|=
operator|(
name|vecell
operator|)
name|vetl
argument_list|(
name|vel
argument_list|)
expr_stmt|;
block|}
return|return
name|count
return|;
block|}
end_function

begin_function
name|vecell
name|vereverse
parameter_list|(
name|vel
parameter_list|)
name|vecell
name|vel
decl_stmt|;
block|{
name|vecell
name|newl
init|=
name|NULL
decl_stmt|;
while|while
condition|(
operator|!
name|venull
argument_list|(
name|vel
argument_list|)
condition|)
block|{
name|vpush
argument_list|(
operator|(
name|vertex
operator|)
name|vehd
argument_list|(
name|vel
argument_list|)
argument_list|,
name|newl
argument_list|)
expr_stmt|;
name|vel
operator|=
operator|(
name|vecell
operator|)
name|vetl
argument_list|(
name|vel
argument_list|)
expr_stmt|;
block|}
return|return
name|newl
return|;
block|}
end_function

begin_function
name|void
name|print_vertex
parameter_list|(
name|f
parameter_list|,
name|v
parameter_list|)
name|FILE
modifier|*
name|f
decl_stmt|;
name|vertex
name|v
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"#v(%s :out ("
argument_list|,
name|v
operator|->
name|name
argument_list|)
expr_stmt|;
name|DO_ELIST
argument_list|(
argument|e
argument_list|,
argument|v->edges
argument_list|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%s "
argument_list|,
name|e
operator|->
name|to
operator|->
name|name
argument_list|)
expr_stmt|;
name|END_DO
name|fprintf
argument_list|(
name|f
argument_list|,
literal|") :in ("
argument_list|)
decl_stmt|;
name|DO_ELIST
argument_list|(
argument|e
argument_list|,
argument|v->backedges
argument_list|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%s "
argument_list|,
name|e
operator|->
name|from
operator|->
name|name
argument_list|)
expr_stmt|;
name|END_DO
name|fprintf
argument_list|(
name|f
argument_list|,
literal|")\n"
argument_list|)
decl_stmt|;
comment|/*    mp_sprint_data(v->data) */
comment|/*  fprintf(f, "edges:");     print_vecons(f, v->edges);     fprintf(f, "backedges:");     print_vecons(f, v->backedges); */
name|fflush
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|print_edge
parameter_list|(
name|f
parameter_list|,
name|e
parameter_list|)
name|FILE
modifier|*
name|f
decl_stmt|;
name|edge
name|e
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"#e(%s %s)\n"
argument_list|,
name|e
operator|->
name|from
operator|->
name|name
argument_list|,
name|e
operator|->
name|to
operator|->
name|name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%s\n"
argument_list|,
name|mp_sprint_data
argument_list|(
name|e
operator|->
name|data
argument_list|)
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
end_function

begin_typedef
typedef|typedef
struct|struct
name|graph_struct
block|{
name|int
name|v_count
decl_stmt|;
name|vecell
name|vset
decl_stmt|;
name|int
name|e_count
decl_stmt|;
name|vecell
name|eset
decl_stmt|;
name|struct
name|graph_struct
modifier|*
name|derived
decl_stmt|;
block|}
typedef|*
name|graph
operator|,
name|graph_item
typedef|;
end_typedef

begin_function_decl
name|graph
name|read_graph
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|graph
name|merge_scc
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|graph
name|make_graph
parameter_list|(
name|v_count
parameter_list|,
name|vset
parameter_list|,
name|e_count
parameter_list|,
name|eset
parameter_list|)
name|int
name|v_count
decl_stmt|;
name|vecell
name|vset
decl_stmt|;
name|int
name|e_count
decl_stmt|;
name|vecell
name|eset
decl_stmt|;
block|{
name|graph
name|result
init|=
operator|(
name|graph
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|graph_item
argument_list|)
argument_list|)
decl_stmt|;
name|result
operator|->
name|v_count
operator|=
name|v_count
expr_stmt|;
name|result
operator|->
name|vset
operator|=
name|vset
expr_stmt|;
name|result
operator|->
name|e_count
operator|=
name|e_count
expr_stmt|;
name|result
operator|->
name|eset
operator|=
name|eset
expr_stmt|;
name|result
operator|->
name|derived
operator|=
name|NULL
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
name|void
name|print_graph
parameter_list|(
name|f
parameter_list|,
name|g
parameter_list|)
name|FILE
modifier|*
name|f
decl_stmt|;
name|graph
name|g
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"#g(vc:%d "
argument_list|,
name|g
operator|->
name|v_count
argument_list|)
expr_stmt|;
name|print_vecons
argument_list|(
name|f
argument_list|,
name|g
operator|->
name|vset
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\nec:%d "
argument_list|,
name|g
operator|->
name|e_count
argument_list|)
expr_stmt|;
name|print_vecons
argument_list|(
name|f
argument_list|,
name|g
operator|->
name|eset
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|")\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * copy_graph -- basically, we have to copy all the vertices and edges  * from the old graph structure.  */
end_comment

begin_function
name|void
name|free_graph
parameter_list|(
name|g
parameter_list|)
name|graph
name|g
decl_stmt|;
block|{
name|vecell
name|rest
decl_stmt|,
name|tmp
decl_stmt|;
for|for
control|(
name|rest
operator|=
name|g
operator|->
name|vset
init|;
operator|!
name|venull
argument_list|(
name|rest
argument_list|)
condition|;
control|)
block|{
name|tmp
operator|=
name|rest
expr_stmt|;
name|rest
operator|=
name|vetl
argument_list|(
name|rest
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|vehd
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|rest
operator|=
name|g
operator|->
name|eset
init|;
operator|!
name|venull
argument_list|(
name|rest
argument_list|)
condition|;
control|)
block|{
name|tmp
operator|=
name|rest
expr_stmt|;
name|rest
operator|=
name|vetl
argument_list|(
name|rest
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|vehd
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|g
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * copy_graph -- basically, we have to copy all the vertices and edges  * from the old graph structure.  */
end_comment

begin_function
name|graph
name|copy_graph
parameter_list|(
name|g
parameter_list|)
name|graph
name|g
decl_stmt|;
block|{
name|vecell
name|new_vset
init|=
name|NULL
decl_stmt|,
name|new_eset
init|=
name|NULL
decl_stmt|;
name|vertex
name|new_v
decl_stmt|;
name|edge
name|new_e
decl_stmt|;
name|graph
name|newg
init|=
name|make_graph
argument_list|(
name|g
operator|->
name|v_count
argument_list|,
name|g
operator|->
name|vset
argument_list|,
name|g
operator|->
name|e_count
argument_list|,
name|g
operator|->
name|eset
argument_list|)
decl_stmt|;
name|DO_VLIST
argument_list|(
argument|v
argument_list|,
argument|g->vset
argument_list|)
name|new_v
operator|=
name|make_vertex
argument_list|(
name|v
operator|->
name|name
argument_list|,
name|v
operator|->
name|number
argument_list|,
name|v
operator|->
name|data
argument_list|,
name|v
operator|->
name|scratch
argument_list|)
expr_stmt|;
name|v
operator|->
name|save_copy
operator|=
name|new_v
expr_stmt|;
name|vpush
argument_list|(
name|new_v
argument_list|,
name|new_vset
argument_list|)
expr_stmt|;
name|END_DO
name|DO_ELIST
argument_list|(
name|e
argument_list|,
name|g
operator|->
name|eset
argument_list|)
name|mpdata
name|newdata
init|=
name|mp_new_data
argument_list|()
decl_stmt|;
name|vertex
name|old_vfrom
decl_stmt|,
name|old_vto
decl_stmt|;
name|newdata
operator|=
name|mp_add_data
argument_list|(
name|newdata
argument_list|,
name|e
operator|->
name|data
argument_list|)
expr_stmt|;
name|old_vfrom
operator|=
name|e
operator|->
name|from
expr_stmt|;
name|old_vto
operator|=
name|e
operator|->
name|to
expr_stmt|;
name|new_e
operator|=
name|make_edge
argument_list|(
name|old_vfrom
operator|->
name|save_copy
argument_list|,
name|old_vto
operator|->
name|save_copy
argument_list|,
name|newdata
argument_list|)
expr_stmt|;
name|epush
argument_list|(
name|new_e
argument_list|,
operator|(
operator|(
name|new_e
operator|->
name|from
operator|)
operator|->
name|edges
operator|)
argument_list|)
expr_stmt|;
name|epush
argument_list|(
name|new_e
argument_list|,
operator|(
operator|(
name|new_e
operator|->
name|to
operator|)
operator|->
name|backedges
operator|)
argument_list|)
expr_stmt|;
name|epush
argument_list|(
name|new_e
argument_list|,
name|new_eset
argument_list|)
expr_stmt|;
name|END_DO
name|DO_VLIST
argument_list|(
name|v
argument_list|,
name|g
operator|->
name|vset
argument_list|)
name|v
operator|->
name|save_copy
init|=
name|NULL
decl_stmt|;
name|END_DO
name|newg
operator|->
name|vset
init|=
name|new_vset
decl_stmt|;
name|newg
operator|->
name|eset
operator|=
name|new_eset
expr_stmt|;
name|newg
operator|->
name|derived
operator|=
name|g
expr_stmt|;
return|return
name|newg
return|;
block|}
end_function

begin_function_decl
name|vecell
name|scc
parameter_list|()
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/*  * Hash routines -- specialized from on routines available in SunOS  * and Ultrix libraries, but not in Berkeley Unix.  */
end_comment

begin_decl_stmt
name|ENTRY
modifier|*
name|htable
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|htableSize
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|hcreate
parameter_list|(
name|tableSize
parameter_list|)
name|unsigned
name|tableSize
decl_stmt|;
block|{
name|htableSize
operator|=
name|tableSize
expr_stmt|;
name|htable
operator|=
operator|(
name|ENTRY
operator|*
operator|)
name|calloc
argument_list|(
name|tableSize
argument_list|,
sizeof|sizeof
argument_list|(
name|ENTRY
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|htable
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|void
name|hdestroy
parameter_list|()
block|{
name|free
argument_list|(
name|htable
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|hash_fn
parameter_list|(
name|str
parameter_list|,
name|tableSize
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
name|int
name|tableSize
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|result
init|=
literal|12345
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|strlen
argument_list|(
name|str
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|result
operator|=
operator|(
operator|(
name|result
operator|+
operator|(
operator|(
name|int
operator|)
name|str
index|[
name|i
index|]
operator|)
operator|*
literal|1013
operator|)
operator|&
literal|0x7ffffff
operator|)
operator|>>
literal|3
expr_stmt|;
block|}
return|return
operator|(
name|result
operator|%
name|tableSize
operator|)
return|;
block|}
end_function

begin_function
name|ENTRY
modifier|*
name|hsearch
parameter_list|(
name|item
parameter_list|,
name|action
parameter_list|)
name|ENTRY
name|item
decl_stmt|;
name|ACTION
name|action
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|hindex
decl_stmt|;
name|int
name|hvalue
init|=
name|hash_fn
argument_list|(
name|item
operator|.
name|key
argument_list|,
name|htableSize
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|htableSize
condition|;
name|i
operator|++
control|)
block|{
name|hindex
operator|=
operator|(
operator|(
name|i
operator|+
name|hvalue
operator|)
operator|%
name|htableSize
operator|)
expr_stmt|;
if|if
condition|(
name|htable
index|[
name|hindex
index|]
operator|.
name|key
operator|==
literal|0
condition|)
block|{
comment|/* 	     * Won't find the item. 	     */
if|if
condition|(
name|action
operator|==
name|ENTER
condition|)
block|{
name|htable
index|[
name|hindex
index|]
operator|=
name|item
expr_stmt|;
return|return
operator|&
operator|(
name|htable
index|[
name|hindex
index|]
operator|)
return|;
block|}
else|else
block|{
return|return
name|NULL
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|htable
index|[
name|hindex
index|]
operator|.
name|key
argument_list|,
name|item
operator|.
name|key
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 	     * Found the item in the table. 	     */
if|if
condition|(
name|action
operator|==
name|ENTER
condition|)
block|{
name|htable
index|[
name|hindex
index|]
operator|=
name|item
expr_stmt|;
block|}
return|return
operator|&
operator|(
name|htable
index|[
name|hindex
index|]
operator|)
return|;
block|}
block|}
comment|/*      * We won't find the item.      */
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|void
name|henter
parameter_list|(
name|key
parameter_list|,
name|vp
parameter_list|)
name|char
modifier|*
name|key
decl_stmt|;
name|vertex
name|vp
decl_stmt|;
block|{
name|ENTRY
name|e
decl_stmt|;
name|e
operator|.
name|key
operator|=
name|key
expr_stmt|;
name|e
operator|.
name|data
operator|=
operator|(
name|char
operator|*
operator|)
name|vp
expr_stmt|;
operator|(
name|void
operator|)
name|hsearch
argument_list|(
name|e
argument_list|,
name|ENTER
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|vertex
name|hlookup
parameter_list|(
name|key
parameter_list|)
name|char
modifier|*
name|key
decl_stmt|;
block|{
name|ENTRY
name|e
decl_stmt|,
modifier|*
name|result
decl_stmt|;
name|e
operator|.
name|key
operator|=
name|key
expr_stmt|;
name|result
operator|=
name|hsearch
argument_list|(
name|e
argument_list|,
name|FIND
argument_list|)
expr_stmt|;
return|return
operator|(
name|vertex
operator|)
name|result
operator|->
name|data
return|;
block|}
end_function

begin_define
define|#
directive|define
name|template0
define|\
value|"\n---------------------------s--m--l--x-------------------s--m--l--x---------------\n\n"
end_define

begin_define
define|#
directive|define
name|template1
define|\
value|"  %8s %12s |%-12s | %12s |%-12s | %12s   %-s\n"
end_define

begin_define
define|#
directive|define
name|template1n
define|\
value|"  %8s %12d |%-12s | %12d |%-12s | %12d   %-s\n"
end_define

begin_define
define|#
directive|define
name|template1f
define|\
value|"  %8.1f %12d |%-12s | %12d |%-12s | %12d   %-s\n"
end_define

begin_define
define|#
directive|define
name|template2
define|\
value|"%-5s%7s%9s %-5s |%-12s |%-12s |%8s%-9s%-s\n"
end_define

begin_define
define|#
directive|define
name|template2p1
define|\
value|"%-5s%7s%9d %-5s |%-12s |%-12s |%8s%-9s%-s\n"
end_define

begin_define
define|#
directive|define
name|template2p2
define|\
value|"%-5s%7s%9d %-5s |%-12s |%-12s |%8d%-9s%-s\n"
end_define

begin_define
define|#
directive|define
name|template2c1
define|\
value|"%-5s%7s%9s %-5s |%-12s |%-12s |%8d%-9s%-s\n"
end_define

begin_function
name|double
name|dpercent
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
block|{
if|if
condition|(
name|y
operator|==
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
else|else
block|{
return|return
operator|(
literal|100.0
operator|*
name|x
operator|)
operator|/
name|y
return|;
block|}
block|}
end_function

begin_function
name|char
modifier|*
name|truncate_or_blank
parameter_list|(
name|d
parameter_list|)
name|double
name|d
decl_stmt|;
block|{
name|char
name|cbuf
index|[
literal|80
index|]
decl_stmt|;
name|int
name|intpart
init|=
name|d
decl_stmt|;
name|double
name|fraction
init|=
name|d
operator|-
name|intpart
decl_stmt|;
if|if
condition|(
operator|(
name|intpart
operator|==
literal|0
operator|)
operator|&&
operator|(
name|fraction
operator|<
literal|0.00001
operator|)
condition|)
block|{
return|return
literal|""
return|;
block|}
elseif|else
if|if
condition|(
name|intpart
operator|==
literal|0
condition|)
block|{
return|return
literal|"."
return|;
block|}
elseif|else
if|if
condition|(
name|intpart
operator|==
literal|100
condition|)
block|{
return|return
literal|"**"
return|;
block|}
else|else
block|{
name|sprintf
argument_list|(
name|cbuf
argument_list|,
literal|"%2d"
argument_list|,
name|intpart
argument_list|)
expr_stmt|;
return|return
name|strdup
argument_list|(
name|cbuf
argument_list|)
return|;
block|}
block|}
end_function

begin_function
name|char
modifier|*
name|data_type_string
parameter_list|(
name|d
parameter_list|,
name|divisor
parameter_list|)
name|mpdata
name|d
decl_stmt|;
name|int
name|divisor
decl_stmt|;
block|{
name|char
name|cbuf
index|[
literal|100
index|]
decl_stmt|;
if|if
condition|(
name|divisor
operator|==
literal|0
condition|)
block|{
return|return
literal|""
return|;
block|}
else|else
block|{
name|sprintf
argument_list|(
name|cbuf
argument_list|,
literal|" %2s %2s %2s %2s"
argument_list|,
name|truncate_or_blank
argument_list|(
name|dpercent
argument_list|(
name|dt_b_small
argument_list|(
name|d
argument_list|)
argument_list|,
name|divisor
argument_list|)
argument_list|)
argument_list|,
name|truncate_or_blank
argument_list|(
name|dpercent
argument_list|(
name|dt_b_med
argument_list|(
name|d
argument_list|)
argument_list|,
name|divisor
argument_list|)
argument_list|)
argument_list|,
name|truncate_or_blank
argument_list|(
name|dpercent
argument_list|(
name|dt_b_large
argument_list|(
name|d
argument_list|)
argument_list|,
name|divisor
argument_list|)
argument_list|)
argument_list|,
name|truncate_or_blank
argument_list|(
name|dpercent
argument_list|(
name|dt_b_xlarge
argument_list|(
name|d
argument_list|)
argument_list|,
name|divisor
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|strdup
argument_list|(
name|cbuf
argument_list|)
return|;
block|}
block|}
end_function

begin_function
name|char
modifier|*
name|data_kept_string
parameter_list|(
name|d
parameter_list|,
name|divisor
parameter_list|)
name|mpdata
name|d
decl_stmt|;
name|int
name|divisor
decl_stmt|;
block|{
name|char
name|cbuf
index|[
literal|100
index|]
decl_stmt|;
if|if
condition|(
name|divisor
operator|==
literal|0
condition|)
block|{
return|return
literal|""
return|;
block|}
else|else
block|{
name|sprintf
argument_list|(
name|cbuf
argument_list|,
literal|" %2s %2s %2s %2s"
argument_list|,
name|truncate_or_blank
argument_list|(
name|dpercent
argument_list|(
name|dt_d_small
argument_list|(
name|d
argument_list|)
argument_list|,
name|divisor
argument_list|)
argument_list|)
argument_list|,
name|truncate_or_blank
argument_list|(
name|dpercent
argument_list|(
name|dt_d_med
argument_list|(
name|d
argument_list|)
argument_list|,
name|divisor
argument_list|)
argument_list|)
argument_list|,
name|truncate_or_blank
argument_list|(
name|dpercent
argument_list|(
name|dt_d_large
argument_list|(
name|d
argument_list|)
argument_list|,
name|divisor
argument_list|)
argument_list|)
argument_list|,
name|truncate_or_blank
argument_list|(
name|dpercent
argument_list|(
name|dt_d_xlarge
argument_list|(
name|d
argument_list|)
argument_list|,
name|divisor
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|strdup
argument_list|(
name|cbuf
argument_list|)
return|;
block|}
block|}
end_function

begin_function
name|char
modifier|*
name|relative_type_string
parameter_list|(
name|num
parameter_list|,
name|den
parameter_list|)
name|mpdata
name|num
decl_stmt|,
name|den
decl_stmt|;
block|{
return|return
name|data_type_string
argument_list|(
name|num
argument_list|,
name|mp_sum_data
argument_list|(
name|den
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|relative_kept_string
parameter_list|(
name|num
parameter_list|,
name|den
parameter_list|)
name|mpdata
name|num
decl_stmt|,
name|den
decl_stmt|;
block|{
return|return
name|data_kept_string
argument_list|(
name|num
argument_list|,
name|mp_sum_kept
argument_list|(
name|den
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|type_fraction_string
parameter_list|(
name|d
parameter_list|)
name|mpdata
name|d
decl_stmt|;
block|{
return|return
name|data_type_string
argument_list|(
name|d
argument_list|,
name|mp_sum_data
argument_list|(
name|d
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|kept_fraction_string
parameter_list|(
name|d
parameter_list|)
name|mpdata
name|d
decl_stmt|;
block|{
return|return
name|data_kept_string
argument_list|(
name|d
argument_list|,
name|mp_sum_kept
argument_list|(
name|d
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|sum_data_over_edges
parameter_list|(
name|elist
parameter_list|)
name|vecell
name|elist
decl_stmt|;
block|{
name|int
name|sum
init|=
literal|0
decl_stmt|;
name|DO_ELIST
argument_list|(
argument|e
argument_list|,
argument|elist
argument_list|)
if|if
condition|(
operator|!
operator|(
operator|(
name|e
operator|->
name|to
operator|->
name|in_cycle
operator|!=
name|NULL
operator|)
operator|||
operator|(
name|e
operator|->
name|from
operator|->
name|in_cycle
operator|!=
name|NULL
operator|)
operator|)
condition|)
block|{
name|sum
operator|+=
name|mp_sum_data
argument_list|(
name|e
operator|->
name|data
argument_list|)
expr_stmt|;
block|}
name|END_DO
return|return
name|sum
return|;
block|}
end_function

begin_function
name|int
name|sum_calls_over_edges
parameter_list|(
name|elist
parameter_list|)
name|vecell
name|elist
decl_stmt|;
block|{
name|int
name|sum
init|=
literal|0
decl_stmt|;
name|DO_ELIST
argument_list|(
argument|e
argument_list|,
argument|elist
argument_list|)
if|if
condition|(
operator|!
operator|(
operator|(
name|e
operator|->
name|to
operator|->
name|in_cycle
operator|!=
name|NULL
operator|)
operator|||
operator|(
name|e
operator|->
name|from
operator|->
name|in_cycle
operator|!=
name|NULL
operator|)
operator|)
condition|)
block|{
name|sum
operator|+=
name|mp_sum_calls
argument_list|(
name|e
operator|->
name|data
argument_list|)
expr_stmt|;
block|}
name|END_DO
return|return
name|sum
return|;
block|}
end_function

begin_function
name|int
name|sum_vertex_bytes
parameter_list|(
name|v
parameter_list|)
name|vertex
name|v
decl_stmt|;
block|{
if|if
condition|(
name|v
operator|->
name|in_cycle
operator|==
name|NULL
condition|)
block|{
return|return
name|mp_sum_data
argument_list|(
name|v
operator|->
name|data
argument_list|)
operator|+
name|sum_data_over_edges
argument_list|(
name|v
operator|->
name|edges
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|sum_vertex_bytes
argument_list|(
name|v
operator|->
name|in_cycle
argument_list|)
return|;
block|}
block|}
end_function

begin_function
name|int
name|sum_vertex_bytes1
parameter_list|(
name|v
parameter_list|)
name|vertex
name|v
decl_stmt|;
block|{
if|if
condition|(
name|v
operator|->
name|in_cycle
operator|==
name|NULL
condition|)
block|{
return|return
name|mp_sum_data
argument_list|(
name|v
operator|->
name|data
argument_list|)
operator|+
name|sum_data_over_edges
argument_list|(
name|v
operator|->
name|edges
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|mp_sum_data
argument_list|(
name|v
operator|->
name|data
argument_list|)
return|;
block|}
block|}
end_function

begin_function
name|int
name|sum_vertex_incoming_calls
parameter_list|(
name|v
parameter_list|)
name|vertex
name|v
decl_stmt|;
block|{
if|if
condition|(
name|v
operator|->
name|in_cycle
operator|==
name|NULL
condition|)
block|{
return|return
name|sum_calls_over_edges
argument_list|(
name|v
operator|->
name|backedges
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|sum_vertex_incoming_calls
argument_list|(
name|v
operator|->
name|in_cycle
argument_list|)
return|;
block|}
block|}
end_function

begin_function
name|int
name|sum_vertex_outgoing_calls
parameter_list|(
name|v
parameter_list|)
name|vertex
name|v
decl_stmt|;
block|{
if|if
condition|(
name|v
operator|->
name|in_cycle
operator|==
name|NULL
condition|)
block|{
return|return
name|sum_calls_over_edges
argument_list|(
name|v
operator|->
name|edges
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|sum_vertex_outgoing_calls
argument_list|(
name|v
operator|->
name|in_cycle
argument_list|)
return|;
block|}
block|}
end_function

begin_function
name|void
name|mprof_graph_ops
parameter_list|(
name|f
parameter_list|)
name|FILE
modifier|*
name|f
decl_stmt|;
block|{
name|graph
name|g
init|=
name|read_graph
argument_list|()
decl_stmt|;
name|graph
name|newg
init|=
name|merge_scc
argument_list|(
name|g
argument_list|)
decl_stmt|;
name|int
name|cumul_bytes
decl_stmt|;
name|int
name|total_bytes
decl_stmt|;
name|int
name|total_calls
decl_stmt|;
name|int
name|total_kept
decl_stmt|;
name|mpdata
name|total_data
init|=
name|mp_new_data
argument_list|()
decl_stmt|;
name|vecell
name|old_vset
init|=
name|g
operator|->
name|vset
decl_stmt|;
name|vecell
name|vset
init|=
name|newg
operator|->
name|vset
decl_stmt|;
name|vecell
name|ordered_vset
init|=
name|NULL
decl_stmt|;
name|vecell
name|old_ordered_vset
decl_stmt|;
name|int
name|i
decl_stmt|;
name|old_ordered_vset
operator|=
name|vsort
argument_list|(
name|old_vset
argument_list|,
name|vdata_compar
argument_list|)
expr_stmt|;
name|DO_VLIST
argument_list|(
argument|v
argument_list|,
argument|old_vset
argument_list|)
name|total_data
operator|=
name|mp_add_data
argument_list|(
name|total_data
argument_list|,
name|v
operator|->
name|data
argument_list|)
expr_stmt|;
name|END_DO
name|total_bytes
init|=
name|mp_sum_data
argument_list|(
name|total_data
argument_list|)
decl_stmt|;
name|total_calls
operator|=
name|mp_sum_calls
argument_list|(
name|total_data
argument_list|)
expr_stmt|;
name|total_kept
operator|=
name|mp_sum_kept
argument_list|(
name|total_data
argument_list|)
expr_stmt|;
comment|/*      * Print out the allocation recorded in the leaf nodes.      */
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"---------  Direct Allocation Table ------------\n\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
name|template1
argument_list|,
literal|" % mem"
argument_list|,
literal|"bytes"
argument_list|,
literal|" % mem(size)"
argument_list|,
literal|"bytes kept"
argument_list|,
literal|"  % all kept"
argument_list|,
literal|"calls"
argument_list|,
literal|"name"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
name|template0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
name|template1n
argument_list|,
literal|"-----"
argument_list|,
name|total_bytes
argument_list|,
name|type_fraction_string
argument_list|(
name|total_data
argument_list|)
argument_list|,
name|total_kept
argument_list|,
name|kept_fraction_string
argument_list|(
name|total_data
argument_list|)
argument_list|,
name|total_calls
argument_list|,
literal|"<TOTAL>"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|DO_VLIST
argument_list|(
argument|v
argument_list|,
argument|old_ordered_vset
argument_list|)
name|mpdata
name|vdata
init|=
name|v
operator|->
name|data
decl_stmt|;
name|int
name|nbytes
init|=
name|mp_sum_data
argument_list|(
name|vdata
argument_list|)
decl_stmt|;
if|if
condition|(
name|nbytes
operator|!=
literal|0
condition|)
block|{
name|cumul_bytes
operator|+=
name|nbytes
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
name|template1f
argument_list|,
name|dpercent
argument_list|(
name|nbytes
argument_list|,
name|total_bytes
argument_list|)
argument_list|,
name|nbytes
argument_list|,
name|relative_type_string
argument_list|(
name|vdata
argument_list|,
name|total_data
argument_list|)
argument_list|,
name|mp_sum_kept
argument_list|(
name|vdata
argument_list|)
argument_list|,
name|data_kept_string
argument_list|(
name|vdata
argument_list|,
name|total_kept
argument_list|)
argument_list|,
name|mp_sum_calls
argument_list|(
name|vdata
argument_list|)
argument_list|,
name|v
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
name|END_DO
comment|/*      * Check allocation consistency from children to parents.      */
name|DO_VLIST
argument_list|(
name|v
argument_list|,
name|vereverse
argument_list|(
name|vset
argument_list|)
argument_list|)
comment|/* 	 * Because the vertex list is sorted, we always encounter a 	 * node before any of the callers of that node and after all 	 * the nodes it calls. 	 */
name|vecell
name|clist
init|=
name|v
operator|->
name|edges
decl_stmt|;
name|vecell
name|plist
init|=
name|v
operator|->
name|backedges
decl_stmt|;
name|int
name|csum
init|=
name|sum_data_over_edges
argument_list|(
name|clist
argument_list|)
decl_stmt|;
name|int
name|psum
init|=
name|sum_data_over_edges
argument_list|(
name|plist
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|v
operator|->
name|in_cycle
operator|)
operator|&&
operator|(
name|v
operator|->
name|backedges
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|psum
operator|!=
operator|(
name|csum
operator|+
name|mp_sum_data
argument_list|(
name|v
operator|->
name|data
argument_list|)
operator|)
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"Parent and child disagree on data allocation\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%s --> %d != %d + %d (%d)\n"
argument_list|,
name|v
operator|->
name|name
argument_list|,
name|psum
argument_list|,
name|csum
argument_list|,
name|csum
operator|+
name|mp_sum_data
argument_list|(
name|v
operator|->
name|data
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|END_DO
name|ordered_vset
init|=
name|vsort
argument_list|(
name|vset
argument_list|,
name|vbytes_compar
argument_list|)
decl_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|DO_VLIST
argument_list|(
argument|v
argument_list|,
argument|ordered_vset
argument_list|)
name|v
operator|->
name|index
operator|=
name|i
expr_stmt|;
name|i
operator|+=
literal|1
expr_stmt|;
name|END_DO
comment|/*      * Print the header for the dynamic allocation graph.      */
name|print_dynamic_graph_header
argument_list|(
name|f
argument_list|)
decl_stmt|;
name|DO_VLIST
argument_list|(
argument|v
argument_list|,
argument|ordered_vset
argument_list|)
if|if
condition|(
name|v
operator|->
name|scc_members
operator|!=
name|NULL
condition|)
block|{
name|print_cycle_information
argument_list|(
name|v
argument_list|,
name|f
argument_list|,
name|total_bytes
argument_list|)
expr_stmt|;
name|print_separator
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|print_normal_vertex
argument_list|(
name|v
argument_list|,
name|f
argument_list|,
name|total_bytes
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|v
operator|->
name|in_cycle
operator|!=
name|NULL
condition|)
block|{
name|print_vertex_in_cycle
argument_list|(
name|v
argument_list|,
name|f
argument_list|,
name|total_bytes
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|print_normal_vertex
argument_list|(
name|v
argument_list|,
name|f
argument_list|,
name|total_bytes
argument_list|)
expr_stmt|;
block|}
name|print_separator
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|END_DO
name|fflush
argument_list|(
name|f
argument_list|)
decl_stmt|;
block|}
end_function

begin_function
name|graph
name|read_graph
parameter_list|()
block|{
name|mpsym
name|s
decl_stmt|;
name|int
name|i
decl_stmt|,
name|count
decl_stmt|;
name|mpcell
name|chain
decl_stmt|;
name|mpcell
name|rest
decl_stmt|;
name|mpcell
name|p
decl_stmt|;
name|int
name|v_count
decl_stmt|,
name|e_count
decl_stmt|;
name|vecell
name|vset
decl_stmt|,
name|eset
decl_stmt|;
comment|/*      * First count the nodes and allocate space for them.      */
name|v_count
operator|=
name|mp_count_nodes
argument_list|()
expr_stmt|;
name|e_count
operator|=
literal|0
expr_stmt|;
name|vset
operator|=
name|NULL
expr_stmt|;
name|eset
operator|=
name|NULL
expr_stmt|;
name|hcreate
argument_list|(
literal|2
operator|*
name|v_count
argument_list|)
expr_stmt|;
comment|/*      * Read in each vertex and store associated information.      */
name|count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MP_HASH_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|chain
operator|=
name|hmem
index|[
name|i
index|]
expr_stmt|;
while|while
condition|(
operator|!
name|mp_null
argument_list|(
name|chain
argument_list|)
condition|)
block|{
name|vertex
name|v
decl_stmt|;
name|s
operator|=
operator|(
name|mpsym
operator|)
name|mp_car
argument_list|(
name|chain
argument_list|)
expr_stmt|;
name|v
operator|=
name|make_vertex
argument_list|(
name|fn_name
argument_list|(
name|s
argument_list|)
argument_list|,
name|count
argument_list|,
name|fn_lcount
argument_list|(
name|s
argument_list|)
argument_list|,
name|fn_parents
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|vpush
argument_list|(
name|v
argument_list|,
name|vset
argument_list|)
expr_stmt|;
name|count
operator|+=
literal|1
expr_stmt|;
name|chain
operator|=
operator|(
name|mpcell
operator|)
name|mp_cdr
argument_list|(
name|chain
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*      * Create the backedges      */
name|DO_VLIST
argument_list|(
argument|vto
argument_list|,
argument|vset
argument_list|)
name|vecell
name|elist
init|=
name|NULL
decl_stmt|;
name|mpcell
name|rest
decl_stmt|;
comment|/* 	 * The parent list is stored in the scratch slot of the          * vertex. 	 */
name|rest
operator|=
operator|(
name|mpcell
operator|)
name|vto
operator|->
name|scratch
expr_stmt|;
while|while
condition|(
operator|!
name|mp_null
argument_list|(
name|rest
argument_list|)
condition|)
block|{
name|char
modifier|*
name|parent_name
decl_stmt|;
name|mpdata
name|parent_data
decl_stmt|;
name|mpcell
name|parent
init|=
operator|(
name|mpcell
operator|)
name|mp_car
argument_list|(
name|rest
argument_list|)
decl_stmt|;
name|vertex
name|vfrom
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|parent_name
operator|=
name|fn_name
argument_list|(
operator|(
name|mpsym
operator|)
name|mp_car
argument_list|(
name|parent
argument_list|)
argument_list|)
expr_stmt|;
name|parent_data
operator|=
operator|(
name|mpdata
operator|)
name|mp_cdr
argument_list|(
name|parent
argument_list|)
expr_stmt|;
name|vfrom
operator|=
name|hlookup
argument_list|(
name|parent_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|vfrom
operator|==
name|vto
condition|)
block|{
name|vto
operator|->
name|srefs
operator|+=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|e
operator|=
name|make_edge
argument_list|(
name|vfrom
argument_list|,
name|vto
argument_list|,
name|parent_data
argument_list|)
expr_stmt|;
name|e_count
operator|+=
literal|1
expr_stmt|;
name|epush
argument_list|(
name|e
argument_list|,
name|eset
argument_list|)
expr_stmt|;
name|epush
argument_list|(
name|e
argument_list|,
name|elist
argument_list|)
expr_stmt|;
block|}
name|rest
operator|=
name|mp_cdr
argument_list|(
name|rest
argument_list|)
expr_stmt|;
block|}
name|vto
operator|->
name|backedges
operator|=
name|elist
expr_stmt|;
name|END_DO
name|DO_VLIST
argument_list|(
name|v
argument_list|,
name|vset
argument_list|)
name|DO_ELIST
argument_list|(
name|e
argument_list|,
name|v
operator|->
name|backedges
argument_list|)
name|vertex
name|vfrom
init|=
name|e
operator|->
name|from
decl_stmt|;
name|epush
argument_list|(
name|e
argument_list|,
name|vfrom
operator|->
name|edges
argument_list|)
expr_stmt|;
name|END_DO
name|END_DO
return|return
name|make_graph
argument_list|(
name|v_count
argument_list|,
name|vset
argument_list|,
name|e_count
argument_list|,
name|eset
argument_list|)
return|;
block|}
end_function

begin_function
name|edge
name|same_edge
parameter_list|(
name|from_v
parameter_list|,
name|to_v
parameter_list|,
name|elist
parameter_list|)
name|vertex
name|from_v
decl_stmt|,
name|to_v
decl_stmt|;
name|vecell
name|elist
decl_stmt|;
block|{
name|DO_ELIST
argument_list|(
argument|e
argument_list|,
argument|elist
argument_list|)
if|if
condition|(
operator|(
name|e
operator|->
name|to
operator|==
name|to_v
operator|)
operator|&&
operator|(
name|e
operator|->
name|from
operator|==
name|from_v
operator|)
condition|)
block|{
return|return
name|e
return|;
block|}
name|END_DO
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|int
name|edge_less_compar
parameter_list|(
name|e1
parameter_list|,
name|e2
parameter_list|)
name|edge
modifier|*
name|e1
decl_stmt|,
decl|*
name|e2
decl_stmt|;
end_function

begin_block
block|{
name|char
modifier|*
name|e1_from
decl_stmt|,
modifier|*
name|e1_to
decl_stmt|,
modifier|*
name|e2_from
decl_stmt|,
modifier|*
name|e2_to
decl_stmt|;
name|e1_from
operator|=
operator|(
operator|*
name|e1
operator|)
operator|->
name|from
operator|->
name|name
expr_stmt|;
name|e1_to
operator|=
operator|(
operator|*
name|e1
operator|)
operator|->
name|to
operator|->
name|name
expr_stmt|;
name|e2_from
operator|=
operator|(
operator|*
name|e2
operator|)
operator|->
name|from
operator|->
name|name
expr_stmt|;
name|e2_to
operator|=
operator|(
operator|*
name|e2
operator|)
operator|->
name|to
operator|->
name|name
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|e1_from
argument_list|,
name|e2_from
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
name|strcmp
argument_list|(
name|e1_to
argument_list|,
name|e2_to
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|strcmp
argument_list|(
name|e1_from
argument_list|,
name|e2_from
argument_list|)
return|;
block|}
block|}
end_block

begin_function
name|int
name|vdata_compar
parameter_list|(
name|v1p
parameter_list|,
name|v2p
parameter_list|)
name|vertex
modifier|*
name|v1p
decl_stmt|,
decl|*
name|v2p
decl_stmt|;
end_function

begin_block
block|{
name|int
name|d1
init|=
name|mp_sum_data
argument_list|(
operator|(
operator|*
name|v1p
operator|)
operator|->
name|data
argument_list|)
decl_stmt|;
name|int
name|d2
init|=
name|mp_sum_data
argument_list|(
operator|(
operator|*
name|v2p
operator|)
operator|->
name|data
argument_list|)
decl_stmt|;
if|if
condition|(
name|d1
operator|<
name|d2
condition|)
block|{
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|d1
operator|>
name|d2
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
else|else
block|{
return|return
literal|0
return|;
block|}
block|}
end_block

begin_function
name|int
name|vbytes_compar
parameter_list|(
name|v1p
parameter_list|,
name|v2p
parameter_list|)
name|vertex
modifier|*
name|v1p
decl_stmt|,
decl|*
name|v2p
decl_stmt|;
end_function

begin_block
block|{
name|int
name|d1
init|=
name|sum_vertex_bytes1
argument_list|(
operator|*
name|v1p
argument_list|)
decl_stmt|;
name|int
name|d2
init|=
name|sum_vertex_bytes1
argument_list|(
operator|*
name|v2p
argument_list|)
decl_stmt|;
if|if
condition|(
name|d1
operator|<
name|d2
condition|)
block|{
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|d1
operator|>
name|d2
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
else|else
block|{
return|return
literal|0
return|;
block|}
block|}
end_block

begin_decl_stmt
name|vecell
name|vsort
argument_list|(
name|vlist
argument_list|,
name|compar
argument_list|)
name|vecell
name|vlist
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
function_decl|(
modifier|*
name|compar
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_block
block|{
name|int
name|llength
init|=
name|velength
argument_list|(
name|vlist
argument_list|)
decl_stmt|;
name|vertex
modifier|*
name|vvec
init|=
operator|(
name|vertex
operator|*
operator|)
name|calloc
argument_list|(
name|llength
argument_list|,
sizeof|sizeof
argument_list|(
name|vertex
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|vecell
name|newvlist
init|=
name|NULL
decl_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|DO_VLIST
argument_list|(
argument|v
argument_list|,
argument|vlist
argument_list|)
name|vvec
index|[
name|i
index|]
operator|=
name|v
expr_stmt|;
name|i
operator|+=
literal|1
expr_stmt|;
name|END_DO
name|qsort
argument_list|(
operator|(
name|char
operator|*
operator|)
name|vvec
argument_list|,
name|llength
argument_list|,
sizeof|sizeof
argument_list|(
name|vertex
argument_list|)
argument_list|,
name|compar
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
operator|(
name|llength
operator|-
literal|1
operator|)
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|epush
argument_list|(
name|vvec
index|[
name|i
index|]
argument_list|,
name|newvlist
argument_list|)
expr_stmt|;
block|}
return|return
name|newvlist
return|;
block|}
end_block

begin_decl_stmt
name|vecell
name|esort
argument_list|(
name|elist
argument_list|,
name|compar
argument_list|)
name|vecell
name|elist
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
function_decl|(
modifier|*
name|compar
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_block
block|{
name|int
name|llength
init|=
name|velength
argument_list|(
name|elist
argument_list|)
decl_stmt|;
name|edge
modifier|*
name|evec
init|=
operator|(
name|edge
operator|*
operator|)
name|calloc
argument_list|(
name|llength
argument_list|,
sizeof|sizeof
argument_list|(
name|edge
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|vecell
name|newelist
init|=
name|NULL
decl_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|DO_ELIST
argument_list|(
argument|e
argument_list|,
argument|elist
argument_list|)
name|evec
index|[
name|i
index|]
operator|=
name|e
expr_stmt|;
name|i
operator|+=
literal|1
expr_stmt|;
name|END_DO
name|qsort
argument_list|(
operator|(
name|char
operator|*
operator|)
name|evec
argument_list|,
name|llength
argument_list|,
sizeof|sizeof
argument_list|(
name|edge
argument_list|)
argument_list|,
name|compar
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
operator|(
name|llength
operator|-
literal|1
operator|)
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|epush
argument_list|(
name|evec
index|[
name|i
index|]
argument_list|,
name|newelist
argument_list|)
expr_stmt|;
block|}
return|return
name|newelist
return|;
block|}
end_block

begin_function
name|graph
name|merge_scc
parameter_list|(
name|g
parameter_list|)
name|graph
name|g
decl_stmt|;
block|{
name|graph
name|newg
init|=
name|copy_graph
argument_list|(
name|g
argument_list|)
decl_stmt|;
name|vecell
name|vset
init|=
name|NULL
decl_stmt|,
name|eset
init|=
name|NULL
decl_stmt|,
name|added_eset
init|=
name|NULL
decl_stmt|;
name|int
name|cycle_count
init|=
literal|0
decl_stmt|;
name|vecell
name|cc_list
init|=
name|scc
argument_list|(
name|newg
argument_list|)
decl_stmt|;
comment|/*    print_graph(stdout, newg); */
comment|/*      * Create vertices corresponding to each of the cycles.      */
name|DO_LIST
argument_list|(
argument|cc
argument_list|,
argument|cc_list
argument_list|)
if|if
condition|(
name|velength
argument_list|(
name|cc
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|vertex
name|newv
decl_stmt|;
comment|/* 	     * Create a vertex to represent the SCC. 	     */
name|cycle_count
operator|+=
literal|1
expr_stmt|;
name|newv
operator|=
name|make_vertex
argument_list|(
name|new_cycle_name
argument_list|(
name|cycle_count
argument_list|)
argument_list|,
name|cycle_count
operator|+
name|newg
operator|->
name|v_count
operator|-
literal|1
argument_list|,
name|mp_new_data
argument_list|()
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|vpush
argument_list|(
name|newv
argument_list|,
name|vset
argument_list|)
expr_stmt|;
name|newv
operator|->
name|scc_members
operator|=
name|cc
expr_stmt|;
name|DO_VLIST
argument_list|(
argument|v
argument_list|,
argument|cc
argument_list|)
name|vpush
argument_list|(
name|v
argument_list|,
name|vset
argument_list|)
expr_stmt|;
name|v
operator|->
name|in_cycle
operator|=
name|newv
expr_stmt|;
name|newv
operator|->
name|data
operator|=
name|mp_add_data
argument_list|(
name|newv
operator|->
name|data
argument_list|,
name|v
operator|->
name|data
argument_list|)
expr_stmt|;
name|END_DO
block|}
else|else
block|{
name|vpush
argument_list|(
operator|(
name|vertex
operator|)
name|vehd
argument_list|(
name|cc
argument_list|)
argument_list|,
name|vset
argument_list|)
expr_stmt|;
block|}
name|END_DO
comment|/*      * Look at all the edges and create a new edge set.      */
name|DO_ELIST
argument_list|(
name|e
argument_list|,
name|newg
operator|->
name|eset
argument_list|)
comment|/* 	 * Cases -- 	 * 1. Either vertex is part of a cycle. 	 * 2. Neither vertex is in a cycle. 	 */
name|vertex
name|from_v
init|=
operator|(
name|e
operator|->
name|from
operator|)
operator|->
name|in_cycle
decl_stmt|;
name|vertex
name|to_v
init|=
operator|(
name|e
operator|->
name|to
operator|)
operator|->
name|in_cycle
decl_stmt|;
if|if
condition|(
operator|(
name|from_v
operator|!=
name|NULL
operator|)
operator|||
operator|(
name|to_v
operator|!=
name|NULL
operator|)
condition|)
block|{
if|if
condition|(
name|from_v
operator|==
name|NULL
condition|)
block|{
name|from_v
operator|=
name|e
operator|->
name|from
expr_stmt|;
block|}
if|if
condition|(
name|to_v
operator|==
name|NULL
condition|)
block|{
name|to_v
operator|=
name|e
operator|->
name|to
expr_stmt|;
block|}
if|if
condition|(
name|from_v
operator|!=
name|to_v
condition|)
block|{
name|edge
name|newe
init|=
name|same_edge
argument_list|(
name|from_v
argument_list|,
name|to_v
argument_list|,
name|added_eset
argument_list|)
decl_stmt|;
if|if
condition|(
name|newe
operator|!=
name|NULL
condition|)
block|{
name|newe
operator|->
name|data
operator|=
name|mp_add_data
argument_list|(
name|newe
operator|->
name|data
argument_list|,
name|e
operator|->
name|data
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mpdata
name|newdata
init|=
name|mp_new_data
argument_list|()
decl_stmt|;
name|newdata
operator|=
name|mp_add_data
argument_list|(
name|newdata
argument_list|,
name|e
operator|->
name|data
argument_list|)
expr_stmt|;
name|newe
operator|=
name|make_edge
argument_list|(
name|from_v
argument_list|,
name|to_v
argument_list|,
name|newdata
argument_list|)
expr_stmt|;
name|epush
argument_list|(
name|newe
argument_list|,
name|added_eset
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|from_v
operator|->
name|srefs
operator|+=
literal|1
expr_stmt|;
block|}
block|}
name|epush
argument_list|(
name|e
argument_list|,
name|eset
argument_list|)
expr_stmt|;
name|END_DO
name|DO_ELIST
argument_list|(
name|e
argument_list|,
name|added_eset
argument_list|)
name|epush
argument_list|(
name|e
argument_list|,
name|eset
argument_list|)
decl_stmt|;
name|END_DO
name|eset
init|=
name|esort
argument_list|(
name|eset
argument_list|,
name|edge_less_compar
argument_list|)
decl_stmt|;
comment|/*      * Remove the old edges and add the new ones.      */
name|DO_VLIST
argument_list|(
argument|v
argument_list|,
argument|vset
argument_list|)
name|v
operator|->
name|edges
operator|=
name|NULL
expr_stmt|;
name|v
operator|->
name|backedges
operator|=
name|NULL
expr_stmt|;
name|END_DO
name|DO_ELIST
argument_list|(
name|e
argument_list|,
name|eset
argument_list|)
name|vertex
name|vfrom
init|=
name|e
operator|->
name|from
decl_stmt|;
name|vertex
name|vto
init|=
name|e
operator|->
name|to
decl_stmt|;
name|epush
argument_list|(
name|e
argument_list|,
name|vfrom
operator|->
name|edges
argument_list|)
expr_stmt|;
name|epush
argument_list|(
name|e
argument_list|,
name|vto
operator|->
name|backedges
argument_list|)
expr_stmt|;
name|END_DO
name|newg
operator|->
name|v_count
init|=
name|velength
argument_list|(
name|vset
argument_list|)
decl_stmt|;
name|newg
operator|->
name|vset
operator|=
name|vereverse
argument_list|(
name|vset
argument_list|)
expr_stmt|;
name|newg
operator|->
name|e_count
operator|=
name|velength
argument_list|(
name|eset
argument_list|)
expr_stmt|;
name|newg
operator|->
name|eset
operator|=
name|eset
expr_stmt|;
return|return
name|newg
return|;
block|}
end_function

begin_function
name|bool
name|no_unused_incident_edges_from
parameter_list|(
name|v
parameter_list|)
name|vertex
name|v
decl_stmt|;
block|{
name|vecell
name|elist
init|=
name|v
operator|->
name|edges
decl_stmt|;
name|DO_ELIST
argument_list|(
argument|e
argument_list|,
argument|elist
argument_list|)
if|if
condition|(
name|e
operator|->
name|mark
operator|==
name|UNUSED
condition|)
block|{
return|return
name|FALSE
return|;
block|}
name|END_DO
return|return
name|TRUE
return|;
block|}
end_function

begin_function
name|edge
name|first_unused_edge
parameter_list|(
name|elist
parameter_list|)
name|vecell
name|elist
decl_stmt|;
block|{
name|DO_ELIST
argument_list|(
argument|e
argument_list|,
argument|elist
argument_list|)
if|if
condition|(
name|e
operator|->
name|mark
operator|==
name|UNUSED
condition|)
block|{
return|return
name|e
return|;
block|}
name|END_DO
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"first_unused_edge -- no unused edges present:\n"
argument_list|)
decl_stmt|;
name|print_vecons
argument_list|(
name|stderr
argument_list|,
name|elist
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|vertex
name|find_vertex_with_k_equal_zero
parameter_list|(
name|vlist
parameter_list|)
name|vecell
name|vlist
decl_stmt|;
block|{
name|DO_VLIST
argument_list|(
argument|v
argument_list|,
argument|vlist
argument_list|)
if|if
condition|(
name|v
operator|->
name|k
operator|==
literal|0
condition|)
block|{
return|return
name|v
return|;
block|}
name|END_DO
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * Find the strongly connected components in the graph.  */
end_comment

begin_function
name|vecell
name|scc
parameter_list|(
name|g
parameter_list|)
name|graph
name|g
decl_stmt|;
block|{
name|vecell
name|vset
init|=
name|g
operator|->
name|vset
decl_stmt|;
name|vecell
name|eset
init|=
name|g
operator|->
name|eset
decl_stmt|;
name|vecell
name|scc_vset
init|=
name|NULL
decl_stmt|;
name|vecell
name|S
init|=
name|NULL
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|vertex
name|v
init|=
operator|(
name|vertex
operator|)
name|vehd
argument_list|(
name|vset
argument_list|)
decl_stmt|;
name|vertex
name|u
decl_stmt|,
name|new_u
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|DO_ELIST
argument_list|(
argument|e
argument_list|,
argument|eset
argument_list|)
name|e
operator|->
name|mark
operator|=
name|UNUSED
expr_stmt|;
name|END_DO
name|DO_VLIST
argument_list|(
name|v
argument_list|,
name|vset
argument_list|)
name|v
operator|->
name|father
init|=
operator|(
name|vertex
operator|)
name|UNDEFINED
decl_stmt|;
name|v
operator|->
name|k
operator|=
literal|0
expr_stmt|;
name|END_DO
name|step2
range|:
name|i
operator|+=
literal|1
decl_stmt|;
name|v
operator|->
name|k
operator|=
name|i
expr_stmt|;
name|v
operator|->
name|L
operator|=
name|i
expr_stmt|;
name|vpush
argument_list|(
name|v
argument_list|,
name|S
argument_list|)
expr_stmt|;
name|v
operator|->
name|on_S
operator|=
name|TRUE
expr_stmt|;
name|step3
label|:
if|if
condition|(
name|no_unused_incident_edges_from
argument_list|(
name|v
argument_list|)
condition|)
block|{
goto|goto
name|step7
goto|;
block|}
name|step4
label|:
name|e
operator|=
name|first_unused_edge
argument_list|(
name|v
operator|->
name|edges
argument_list|)
expr_stmt|;
name|u
operator|=
name|e
operator|->
name|to
expr_stmt|;
name|e
operator|->
name|mark
operator|=
name|USED
expr_stmt|;
if|if
condition|(
name|u
operator|->
name|k
operator|==
literal|0
condition|)
block|{
name|u
operator|->
name|father
operator|=
name|v
expr_stmt|;
name|v
operator|=
name|u
expr_stmt|;
goto|goto
name|step2
goto|;
block|}
name|step5
label|:
if|if
condition|(
name|u
operator|->
name|k
operator|>
name|v
operator|->
name|k
condition|)
block|{
goto|goto
name|step3
goto|;
block|}
if|if
condition|(
operator|!
operator|(
name|u
operator|->
name|on_S
operator|)
condition|)
block|{
goto|goto
name|step3
goto|;
block|}
name|step6
label|:
if|if
condition|(
operator|!
operator|(
operator|(
name|u
operator|->
name|k
operator|<
name|v
operator|->
name|k
operator|)
operator|&&
name|u
operator|->
name|on_S
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"assertion at step6 failed\n"
argument_list|)
expr_stmt|;
block|}
name|v
operator|->
name|L
operator|=
name|min
argument_list|(
name|v
operator|->
name|L
argument_list|,
name|u
operator|->
name|k
argument_list|)
expr_stmt|;
goto|goto
name|step3
goto|;
name|step7
label|:
if|if
condition|(
name|v
operator|->
name|L
operator|==
name|v
operator|->
name|k
condition|)
block|{
name|vecell
name|comp
init|=
name|NULL
decl_stmt|;
name|vertex
name|topv
decl_stmt|;
do|do
block|{
name|topv
operator|=
operator|(
name|vertex
operator|)
name|vehd
argument_list|(
name|S
argument_list|)
expr_stmt|;
name|S
operator|=
name|vetl
argument_list|(
name|S
argument_list|)
expr_stmt|;
name|vpush
argument_list|(
name|topv
argument_list|,
name|comp
argument_list|)
expr_stmt|;
name|topv
operator|->
name|on_S
operator|=
name|FALSE
expr_stmt|;
block|}
do|while
condition|(
name|topv
operator|!=
name|v
condition|)
do|;
name|cpush
argument_list|(
name|comp
argument_list|,
name|scc_vset
argument_list|)
expr_stmt|;
block|}
name|step8
label|:
if|if
condition|(
name|v
operator|->
name|father
operator|!=
operator|(
name|vertex
operator|)
name|UNDEFINED
condition|)
block|{
operator|(
name|v
operator|->
name|father
operator|)
operator|->
name|L
operator|=
name|min
argument_list|(
name|v
operator|->
name|L
argument_list|,
operator|(
name|v
operator|->
name|father
operator|)
operator|->
name|L
argument_list|)
expr_stmt|;
name|v
operator|=
name|v
operator|->
name|father
expr_stmt|;
goto|goto
name|step3
goto|;
block|}
name|step9
label|:
if|if
condition|(
name|v
operator|->
name|father
operator|!=
operator|(
name|vertex
operator|)
name|UNDEFINED
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"assertion at step9 failed\n"
argument_list|)
expr_stmt|;
block|}
name|new_u
operator|=
name|find_vertex_with_k_equal_zero
argument_list|(
name|vset
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_u
operator|!=
name|NULL
condition|)
block|{
name|v
operator|=
name|new_u
expr_stmt|;
goto|goto
name|step2
goto|;
block|}
if|if
condition|(
name|S
operator|!=
name|NULL
condition|)
block|{
name|cpush
argument_list|(
name|S
argument_list|,
name|scc_vset
argument_list|)
expr_stmt|;
block|}
return|return
name|scc_vset
return|;
block|}
end_function

begin_function
name|int
name|mp_count_nodes
parameter_list|()
block|{
name|int
name|i
decl_stmt|,
name|count
decl_stmt|;
name|mpcell
name|chain
decl_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MP_HASH_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|chain
operator|=
name|hmem
index|[
name|i
index|]
expr_stmt|;
while|while
condition|(
operator|!
name|mp_null
argument_list|(
name|chain
argument_list|)
condition|)
block|{
name|count
operator|+=
literal|1
expr_stmt|;
name|chain
operator|=
operator|(
name|mpcell
operator|)
name|mp_cdr
argument_list|(
name|chain
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|count
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|new_cycle_name
parameter_list|(
name|n
parameter_list|)
name|int
name|n
decl_stmt|;
block|{
name|char
name|chars
index|[
literal|255
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|chars
argument_list|,
literal|"<cycle %d>"
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return
name|strdup
argument_list|(
name|chars
argument_list|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|int1_sprintf
parameter_list|(
name|fmt
parameter_list|,
name|n
parameter_list|)
name|char
modifier|*
name|fmt
decl_stmt|;
name|int
name|n
decl_stmt|;
block|{
name|char
name|chars
index|[
literal|255
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|chars
argument_list|,
name|fmt
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return
name|strdup
argument_list|(
name|chars
argument_list|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|s1_sprintf
parameter_list|(
name|fmt
parameter_list|,
name|s
parameter_list|)
name|char
modifier|*
name|fmt
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|char
name|chars
index|[
literal|255
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|chars
argument_list|,
name|fmt
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
name|strdup
argument_list|(
name|chars
argument_list|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|f1_sprintf
parameter_list|(
name|fmt
parameter_list|,
name|d
parameter_list|)
name|char
modifier|*
name|fmt
decl_stmt|;
name|double
name|d
decl_stmt|;
block|{
name|char
name|chars
index|[
literal|255
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|chars
argument_list|,
name|fmt
argument_list|,
name|d
argument_list|)
expr_stmt|;
return|return
name|strdup
argument_list|(
name|chars
argument_list|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|vertex_name_string
parameter_list|(
name|v
parameter_list|)
name|vertex
name|v
decl_stmt|;
block|{
name|char
name|chars
index|[
literal|255
index|]
decl_stmt|;
if|if
condition|(
name|v
operator|->
name|in_cycle
operator|==
name|NULL
condition|)
block|{
name|sprintf
argument_list|(
name|chars
argument_list|,
literal|"%s [%d]"
argument_list|,
name|v
operator|->
name|name
argument_list|,
name|v
operator|->
name|index
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sprintf
argument_list|(
name|chars
argument_list|,
literal|"%s [%d] in %s"
argument_list|,
name|v
operator|->
name|name
argument_list|,
name|v
operator|->
name|index
argument_list|,
name|v
operator|->
name|in_cycle
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
return|return
name|strdup
argument_list|(
name|chars
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|print_dynamic_graph_header
parameter_list|(
name|f
parameter_list|)
name|FILE
modifier|*
name|f
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\f\n\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
name|template2
argument_list|,
literal|""
argument_list|,
literal|"self"
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
literal|"     /ances"
argument_list|,
literal|"     /ances"
argument_list|,
literal|"called"
argument_list|,
literal|"/total "
argument_list|,
literal|"    ancestors"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
name|template2
argument_list|,
literal|"index"
argument_list|,
literal|"+  "
argument_list|,
literal|"self"
argument_list|,
literal|"(%)"
argument_list|,
literal|" size-func"
argument_list|,
literal|" frac"
argument_list|,
literal|"called"
argument_list|,
literal|"/recur"
argument_list|,
literal|"name [index]"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
name|template2
argument_list|,
literal|""
argument_list|,
literal|"desc"
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
literal|"     \\desc"
argument_list|,
literal|"     \\desc"
argument_list|,
literal|"called"
argument_list|,
literal|"/total"
argument_list|,
literal|"    descendents"
argument_list|)
expr_stmt|;
name|print_separator
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|template3
define|\
value|"\n-------------------------------s--m--l--x----s--m--l--x----------\n\n"
end_define

begin_function
name|void
name|print_separator
parameter_list|(
name|f
parameter_list|)
name|FILE
modifier|*
name|f
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
name|template3
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|vecell
name|filter_cycle_edges
parameter_list|(
name|elist
parameter_list|)
name|vecell
name|elist
decl_stmt|;
block|{
name|vecell
name|result
init|=
name|NULL
decl_stmt|;
name|DO_ELIST
argument_list|(
argument|e
argument_list|,
argument|elist
argument_list|)
if|if
condition|(
operator|!
operator|(
operator|(
name|e
operator|->
name|to
operator|->
name|scc_members
operator|!=
name|NULL
operator|)
operator|||
operator|(
name|e
operator|->
name|from
operator|->
name|scc_members
operator|!=
name|NULL
operator|)
operator|)
condition|)
block|{
name|epush
argument_list|(
name|e
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
name|END_DO
return|return
name|vereverse
argument_list|(
name|result
argument_list|)
return|;
block|}
end_function

begin_function
name|mpdata
name|add_data_over
parameter_list|(
name|elist
parameter_list|)
name|vecell
name|elist
decl_stmt|;
block|{
name|mpdata
name|result
init|=
name|mp_new_data
argument_list|()
decl_stmt|;
name|DO_ELIST
argument_list|(
argument|e
argument_list|,
argument|elist
argument_list|)
name|result
operator|=
name|mp_add_data
argument_list|(
name|result
argument_list|,
name|e
operator|->
name|data
argument_list|)
expr_stmt|;
name|END_DO
return|return
name|result
return|;
block|}
end_function

begin_function
name|void
name|print_normal_vertex
parameter_list|(
name|v
parameter_list|,
name|f
parameter_list|,
name|nbytes
parameter_list|)
name|vertex
name|v
decl_stmt|;
name|FILE
modifier|*
name|f
decl_stmt|;
name|int
name|nbytes
decl_stmt|;
block|{
name|vecell
name|plist
init|=
name|v
operator|->
name|backedges
decl_stmt|;
name|vecell
name|clist
init|=
name|v
operator|->
name|edges
decl_stmt|;
name|vecell
name|filt_plist
decl_stmt|,
name|filt_clist
decl_stmt|;
name|int
name|pbytesum
init|=
name|sum_data_over_edges
argument_list|(
name|plist
argument_list|)
decl_stmt|;
name|int
name|cbytesum
init|=
name|sum_data_over_edges
argument_list|(
name|clist
argument_list|)
decl_stmt|;
name|mpdata
name|all_pdata
decl_stmt|;
name|mpdata
name|all_cdata
decl_stmt|;
if|if
condition|(
name|v
operator|->
name|scc_members
operator|!=
name|NULL
condition|)
block|{
name|filt_plist
operator|=
name|plist
expr_stmt|;
name|filt_clist
operator|=
name|clist
expr_stmt|;
block|}
else|else
block|{
name|filt_plist
operator|=
name|filter_cycle_edges
argument_list|(
name|plist
argument_list|)
expr_stmt|;
name|filt_clist
operator|=
name|filter_cycle_edges
argument_list|(
name|clist
argument_list|)
expr_stmt|;
block|}
name|all_pdata
operator|=
name|add_data_over
argument_list|(
name|filt_plist
argument_list|)
expr_stmt|;
name|all_cdata
operator|=
name|add_data_over
argument_list|(
name|filt_clist
argument_list|)
expr_stmt|;
comment|/*      * Parent listings.      */
if|if
condition|(
name|velength
argument_list|(
name|filt_plist
argument_list|)
operator|>
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
name|template2p1
argument_list|,
literal|""
argument_list|,
literal|"all"
argument_list|,
name|mp_sum_data
argument_list|(
name|all_pdata
argument_list|)
argument_list|,
literal|""
argument_list|,
name|type_fraction_string
argument_list|(
name|all_pdata
argument_list|)
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
name|DO_ELIST
argument_list|(
argument|e
argument_list|,
argument|filt_plist
argument_list|)
name|mpdata
name|edata
init|=
name|e
operator|->
name|data
decl_stmt|;
name|int
name|pcallsum
init|=
name|sum_vertex_outgoing_calls
argument_list|(
name|e
operator|->
name|from
argument_list|)
decl_stmt|;
name|int
name|ecallsum
init|=
name|mp_sum_calls
argument_list|(
name|edata
argument_list|)
decl_stmt|;
name|int
name|ebytesum
init|=
name|mp_sum_data
argument_list|(
name|edata
argument_list|)
decl_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
name|template2p2
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
name|ebytesum
argument_list|,
name|percent_string
argument_list|(
name|ebytesum
argument_list|,
name|pbytesum
argument_list|)
argument_list|,
name|type_fraction_string
argument_list|(
name|edata
argument_list|)
argument_list|,
name|relative_type_string
argument_list|(
name|edata
argument_list|,
name|all_pdata
argument_list|)
argument_list|,
name|ecallsum
argument_list|,
name|int1_sprintf
argument_list|(
literal|"/%d"
argument_list|,
name|pcallsum
argument_list|)
argument_list|,
name|s1_sprintf
argument_list|(
literal|"    %s"
argument_list|,
name|vertex_name_string
argument_list|(
name|e
operator|->
name|from
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|END_DO
comment|/*      * Self listing.      */
name|print_self_line
argument_list|(
name|f
argument_list|,
name|v
argument_list|,
name|nbytes
argument_list|,
name|FALSE
argument_list|)
decl_stmt|;
comment|/*      * Children listings.      */
name|DO_ELIST
argument_list|(
argument|e
argument_list|,
argument|filt_clist
argument_list|)
name|mpdata
name|edata
init|=
name|e
operator|->
name|data
decl_stmt|;
name|int
name|ccallsum
init|=
name|sum_vertex_incoming_calls
argument_list|(
name|e
operator|->
name|to
argument_list|)
decl_stmt|;
name|int
name|ecallsum
init|=
name|mp_sum_calls
argument_list|(
name|edata
argument_list|)
decl_stmt|;
name|int
name|ebytesum
init|=
name|mp_sum_data
argument_list|(
name|edata
argument_list|)
decl_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
name|template2p2
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
name|ebytesum
argument_list|,
name|percent_string
argument_list|(
name|ebytesum
argument_list|,
name|cbytesum
argument_list|)
argument_list|,
name|type_fraction_string
argument_list|(
name|edata
argument_list|)
argument_list|,
name|relative_type_string
argument_list|(
name|edata
argument_list|,
name|all_cdata
argument_list|)
argument_list|,
name|ecallsum
argument_list|,
name|int1_sprintf
argument_list|(
literal|"/%d"
argument_list|,
name|ccallsum
argument_list|)
argument_list|,
name|s1_sprintf
argument_list|(
literal|"    %s"
argument_list|,
name|vertex_name_string
argument_list|(
name|e
operator|->
name|to
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|END_DO
if|if
condition|(
name|velength
argument_list|(
name|filt_clist
argument_list|)
operator|>
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
name|template2p1
argument_list|,
literal|""
argument_list|,
literal|"all"
argument_list|,
name|mp_sum_data
argument_list|(
name|all_cdata
argument_list|)
argument_list|,
literal|""
argument_list|,
name|type_fraction_string
argument_list|(
name|all_cdata
argument_list|)
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|print_self_line
parameter_list|(
name|f
parameter_list|,
name|v
parameter_list|,
name|nbytes
parameter_list|,
name|cyclep
parameter_list|)
name|FILE
modifier|*
name|f
decl_stmt|;
name|vertex
name|v
decl_stmt|;
name|int
name|nbytes
decl_stmt|;
name|bool
name|cyclep
decl_stmt|;
block|{
name|vecell
name|plist
init|=
name|v
operator|->
name|backedges
decl_stmt|;
name|vecell
name|clist
init|=
name|v
operator|->
name|edges
decl_stmt|;
name|int
name|pcallsum
init|=
name|sum_calls_over_edges
argument_list|(
name|plist
argument_list|)
decl_stmt|;
name|int
name|cbytesum
init|=
name|sum_data_over_edges
argument_list|(
name|clist
argument_list|)
decl_stmt|;
name|int
name|self_bytesum
init|=
name|mp_sum_data
argument_list|(
name|v
operator|->
name|data
argument_list|)
decl_stmt|;
name|int
name|fbytesum
init|=
name|self_bytesum
operator|+
name|cbytesum
decl_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
name|template2p2
argument_list|,
name|int1_sprintf
argument_list|(
literal|"[%d]"
argument_list|,
name|v
operator|->
name|index
argument_list|)
argument_list|,
name|f1_sprintf
argument_list|(
literal|"%7.1f"
argument_list|,
name|dpercent
argument_list|(
name|fbytesum
argument_list|,
name|nbytes
argument_list|)
argument_list|)
argument_list|,
name|self_bytesum
argument_list|,
name|percent_string
argument_list|(
name|self_bytesum
argument_list|,
name|fbytesum
argument_list|)
argument_list|,
name|type_fraction_string
argument_list|(
name|v
operator|->
name|data
argument_list|)
argument_list|,
literal|" -----------"
argument_list|,
name|pcallsum
argument_list|,
operator|(
operator|(
name|v
operator|->
name|srefs
operator|==
literal|0
operator|)
condition|?
literal|""
else|:
name|int1_sprintf
argument_list|(
literal|"+%d"
argument_list|,
name|v
operator|->
name|srefs
argument_list|)
operator|)
argument_list|,
operator|(
operator|(
name|cyclep
operator|!=
literal|0
operator|)
condition|?
name|s1_sprintf
argument_list|(
literal|"%s as a whole"
argument_list|,
name|vertex_name_string
argument_list|(
name|v
argument_list|)
argument_list|)
else|:
name|vertex_name_string
argument_list|(
name|v
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|print_vertex_in_cycle
parameter_list|(
name|v
parameter_list|,
name|f
parameter_list|,
name|nbytes
parameter_list|)
name|vertex
name|v
decl_stmt|;
name|FILE
modifier|*
name|f
decl_stmt|;
name|int
name|nbytes
decl_stmt|;
block|{
name|vecell
name|plist
init|=
name|filter_cycle_edges
argument_list|(
name|v
operator|->
name|backedges
argument_list|)
decl_stmt|;
name|vecell
name|clist
init|=
name|filter_cycle_edges
argument_list|(
name|v
operator|->
name|edges
argument_list|)
decl_stmt|;
name|int
name|pcallsum
init|=
literal|0
decl_stmt|;
name|int
name|self_bytesum
init|=
name|mp_sum_data
argument_list|(
name|v
operator|->
name|data
argument_list|)
decl_stmt|;
comment|/*      * Parent listings.      */
name|DO_ELIST
argument_list|(
argument|e
argument_list|,
argument|plist
argument_list|)
name|mpdata
name|edata
init|=
name|e
operator|->
name|data
decl_stmt|;
name|int
name|ecallsum
init|=
name|mp_sum_calls
argument_list|(
name|edata
argument_list|)
decl_stmt|;
name|pcallsum
operator|+=
name|ecallsum
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
name|template2c1
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
name|ecallsum
argument_list|,
literal|""
argument_list|,
name|s1_sprintf
argument_list|(
literal|"    %s"
argument_list|,
name|vertex_name_string
argument_list|(
name|e
operator|->
name|from
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|END_DO
comment|/*      * Self listing.      */
name|fprintf
argument_list|(
name|f
argument_list|,
name|template2p2
argument_list|,
name|int1_sprintf
argument_list|(
literal|"[%d]"
argument_list|,
name|v
operator|->
name|index
argument_list|)
argument_list|,
name|f1_sprintf
argument_list|(
literal|"%7.1f"
argument_list|,
name|dpercent
argument_list|(
name|self_bytesum
argument_list|,
name|nbytes
argument_list|)
argument_list|)
argument_list|,
name|self_bytesum
argument_list|,
literal|""
argument_list|,
name|type_fraction_string
argument_list|(
name|v
operator|->
name|data
argument_list|)
argument_list|,
literal|" -----------"
argument_list|,
name|pcallsum
argument_list|,
operator|(
operator|(
name|v
operator|->
name|srefs
operator|==
literal|0
operator|)
condition|?
literal|""
else|:
name|int1_sprintf
argument_list|(
literal|"+%d"
argument_list|,
name|v
operator|->
name|srefs
argument_list|)
operator|)
argument_list|,
name|vertex_name_string
argument_list|(
name|v
argument_list|)
argument_list|)
decl_stmt|;
comment|/*      * Children listings.      */
name|DO_ELIST
argument_list|(
argument|e
argument_list|,
argument|clist
argument_list|)
name|mpdata
name|edata
init|=
name|e
operator|->
name|data
decl_stmt|;
name|int
name|ecallsum
init|=
name|mp_sum_calls
argument_list|(
name|edata
argument_list|)
decl_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
name|template2c1
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
name|ecallsum
argument_list|,
literal|""
argument_list|,
name|s1_sprintf
argument_list|(
literal|"    %s"
argument_list|,
name|vertex_name_string
argument_list|(
name|e
operator|->
name|to
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|END_DO
block|}
end_function

begin_function
name|void
name|print_cycle_information
parameter_list|(
name|v
parameter_list|,
name|f
parameter_list|,
name|nbytes
parameter_list|)
name|vertex
name|v
decl_stmt|;
name|FILE
modifier|*
name|f
decl_stmt|;
name|int
name|nbytes
decl_stmt|;
block|{
name|vecell
name|members
init|=
name|v
operator|->
name|scc_members
decl_stmt|;
name|mpdata
name|mdata
init|=
name|v
operator|->
name|data
decl_stmt|;
name|int
name|mbytesum
init|=
name|mp_sum_data
argument_list|(
name|mdata
argument_list|)
decl_stmt|;
comment|/*      * Self listing.      */
name|print_self_line
argument_list|(
name|f
argument_list|,
name|v
argument_list|,
name|nbytes
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/*      * Members listing.      */
name|DO_VLIST
argument_list|(
argument|v
argument_list|,
argument|members
argument_list|)
name|mpdata
name|vdata
init|=
name|v
operator|->
name|data
decl_stmt|;
name|int
name|vbytesum
init|=
name|mp_sum_data
argument_list|(
name|vdata
argument_list|)
decl_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
name|template2p1
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
name|vbytesum
argument_list|,
name|percent_string
argument_list|(
name|vbytesum
argument_list|,
operator|(
name|mbytesum
operator|==
literal|0
condition|?
literal|1
else|:
name|mbytesum
operator|)
argument_list|)
argument_list|,
name|type_fraction_string
argument_list|(
name|vdata
argument_list|)
argument_list|,
name|relative_type_string
argument_list|(
name|vdata
argument_list|,
name|mdata
argument_list|)
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
name|s1_sprintf
argument_list|(
literal|"    %s"
argument_list|,
name|vertex_name_string
argument_list|(
name|v
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|END_DO
block|}
end_function

end_unit

