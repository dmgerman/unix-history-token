begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $RCSfile: doarg.c,v $$Revision: 4.0.1.8 $$Date: 1993/02/05 19:32:27 $  *  *    Copyright (c) 1991, Larry Wall  *  *    You may distribute under the terms of either the GNU General Public  *    License or the Artistic License, as specified in the README file.  *  * $Log: doarg.c,v $  * Revision 4.0.1.8  1993/02/05  19:32:27  lwall  * patch36: substitution didn't always invalidate numericity  *  * Revision 4.0.1.7  92/06/11  21:07:11  lwall  * patch34: join with null list attempted negative allocation  * patch34: sprintf("%6.4s", "abcdefg") didn't print "abcd  "  *   * Revision 4.0.1.6  92/06/08  12:34:30  lwall  * patch20: removed implicit int declarations on funcions  * patch20: pattern modifiers i and o didn't interact right  * patch20: join() now pre-extends target string to avoid excessive copying  * patch20: fixed confusion between a *var's real name and its effective name  * patch20: subroutines didn't localize $`, $&, $', $1 et al correctly  * patch20: usersub routines didn't reclaim temp values soon enough  * patch20: ($<,$>) = ... didn't work on some architectures  * patch20: added Atari ST portability  *   * Revision 4.0.1.5  91/11/11  16:31:58  lwall  * patch19: added little-endian pack/unpack options  *   * Revision 4.0.1.4  91/11/05  16:35:06  lwall  * patch11: /$foo/o optimizer could access deallocated data  * patch11: minimum match length calculation in regexp is now cumulative  * patch11: added some support for 64-bit integers  * patch11: prepared for ctype implementations that don't define isascii()  * patch11: sprintf() now supports any length of s field  * patch11: indirect subroutine calls through magic vars (e.g.&$1) didn't work  * patch11: defined(&$foo) and undef(&$foo) didn't work  *   * Revision 4.0.1.3  91/06/10  01:18:41  lwall  * patch10: pack(hh,1) dumped core  *   * Revision 4.0.1.2  91/06/07  10:42:17  lwall  * patch4: new copyright notice  * patch4: // wouldn't use previous pattern if it started with a null character  * patch4: //o and s///o now optimize themselves fully at runtime  * patch4: added global modifier for pattern matches  * patch4: undef @array disabled "@array" interpolation  * patch4: chop("") was returning "\0" rather than ""  * patch4: vector logical operations&, | and ^ sometimes returned null string  * patch4: syscall couldn't pass numbers with most significant bit set on sparcs  *   * Revision 4.0.1.1  91/04/11  17:40:14  lwall  * patch1: fixed undefined environ problem  * patch1: fixed debugger coredump on subroutines  *   * Revision 4.0  91/03/20  01:06:42  lwall  * 4.0 baseline.  *   */
end_comment

begin_include
include|#
directive|include
file|"EXTERN.h"
end_include

begin_include
include|#
directive|include
file|"perl.h"
end_include

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|NSIG
argument_list|)
operator|||
name|defined
argument_list|(
name|M_UNIX
argument_list|)
operator|||
name|defined
argument_list|(
name|M_XENIX
argument_list|)
end_if

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|unsigned
name|char
name|fold
index|[]
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|BUGGY_MSC
end_ifdef

begin_pragma
pragma|#
directive|pragma
name|function
name|(
name|memcmp
name|)
end_pragma

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* BUGGY_MSC */
end_comment

begin_function_decl
specifier|static
name|void
name|doencodes
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|int
name|do_subst
parameter_list|(
name|str
parameter_list|,
name|arg
parameter_list|,
name|sp
parameter_list|)
name|STR
modifier|*
name|str
decl_stmt|;
name|ARG
modifier|*
name|arg
decl_stmt|;
name|int
name|sp
decl_stmt|;
block|{
specifier|register
name|SPAT
modifier|*
name|spat
decl_stmt|;
name|SPAT
modifier|*
name|rspat
decl_stmt|;
specifier|register
name|STR
modifier|*
name|dstr
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
init|=
name|str_get
argument_list|(
name|str
argument_list|)
decl_stmt|;
name|char
modifier|*
name|strend
init|=
name|s
operator|+
name|str
operator|->
name|str_cur
decl_stmt|;
specifier|register
name|char
modifier|*
name|m
decl_stmt|;
name|char
modifier|*
name|c
decl_stmt|;
specifier|register
name|char
modifier|*
name|d
decl_stmt|;
name|int
name|clen
decl_stmt|;
name|int
name|iters
init|=
literal|0
decl_stmt|;
name|int
name|maxiters
init|=
operator|(
name|strend
operator|-
name|s
operator|)
operator|+
literal|10
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|bool
name|once
decl_stmt|;
name|char
modifier|*
name|orig
decl_stmt|;
name|int
name|safebase
decl_stmt|;
name|rspat
operator|=
name|spat
operator|=
name|arg
index|[
literal|2
index|]
operator|.
name|arg_ptr
operator|.
name|arg_spat
expr_stmt|;
if|if
condition|(
operator|!
name|spat
operator|||
operator|!
name|s
condition|)
name|fatal
argument_list|(
literal|"panic: do_subst"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|spat
operator|->
name|spat_runtime
condition|)
block|{
name|nointrp
operator|=
literal|"|)"
expr_stmt|;
operator|(
name|void
operator|)
name|eval
argument_list|(
name|spat
operator|->
name|spat_runtime
argument_list|,
name|G_SCALAR
argument_list|,
name|sp
argument_list|)
expr_stmt|;
name|m
operator|=
name|str_get
argument_list|(
name|dstr
operator|=
name|stack
operator|->
name|ary_array
index|[
name|sp
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
name|nointrp
operator|=
literal|""
expr_stmt|;
if|if
condition|(
name|spat
operator|->
name|spat_regexp
condition|)
block|{
name|regfree
argument_list|(
name|spat
operator|->
name|spat_regexp
argument_list|)
expr_stmt|;
name|spat
operator|->
name|spat_regexp
operator|=
name|Null
argument_list|(
name|REGEXP
operator|*
argument_list|)
expr_stmt|;
comment|/* required if regcomp pukes */
block|}
name|spat
operator|->
name|spat_regexp
operator|=
name|regcomp
argument_list|(
name|m
argument_list|,
name|m
operator|+
name|dstr
operator|->
name|str_cur
argument_list|,
name|spat
operator|->
name|spat_flags
operator|&
name|SPAT_FOLD
argument_list|)
expr_stmt|;
if|if
condition|(
name|spat
operator|->
name|spat_flags
operator|&
name|SPAT_KEEP
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|spat
operator|->
name|spat_flags
operator|&
name|SPAT_FOLD
operator|)
condition|)
name|scanconst
argument_list|(
name|spat
argument_list|,
name|m
argument_list|,
name|dstr
operator|->
name|str_cur
argument_list|)
expr_stmt|;
name|arg_free
argument_list|(
name|spat
operator|->
name|spat_runtime
argument_list|)
expr_stmt|;
comment|/* it won't change, so */
name|spat
operator|->
name|spat_runtime
operator|=
name|Nullarg
expr_stmt|;
comment|/* no point compiling again */
name|hoistmust
argument_list|(
name|spat
argument_list|)
expr_stmt|;
if|if
condition|(
name|curcmd
operator|->
name|c_expr
operator|&&
operator|(
name|curcmd
operator|->
name|c_flags
operator|&
name|CF_OPTIMIZE
operator|)
operator|==
name|CFT_EVAL
condition|)
block|{
name|curcmd
operator|->
name|c_flags
operator|&=
operator|~
name|CF_OPTIMIZE
expr_stmt|;
name|opt_arg
argument_list|(
name|curcmd
argument_list|,
literal|1
argument_list|,
name|curcmd
operator|->
name|c_type
operator|==
name|C_EXPR
argument_list|)
expr_stmt|;
block|}
block|}
block|}
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
name|debug
operator|&
literal|8
condition|)
block|{
name|deb
argument_list|(
literal|"2.SPAT /%s/\n"
argument_list|,
name|spat
operator|->
name|spat_regexp
operator|->
name|precomp
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|safebase
operator|=
operator|(
operator|(
operator|!
name|spat
operator|->
name|spat_regexp
operator|||
operator|!
name|spat
operator|->
name|spat_regexp
operator|->
name|nparens
operator|)
operator|&&
operator|!
name|sawampersand
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|spat
operator|->
name|spat_regexp
operator|->
name|prelen
operator|&&
name|lastspat
condition|)
name|spat
operator|=
name|lastspat
expr_stmt|;
name|orig
operator|=
name|m
operator|=
name|s
expr_stmt|;
if|if
condition|(
name|hint
condition|)
block|{
if|if
condition|(
name|hint
operator|<
name|s
operator|||
name|hint
operator|>
name|strend
condition|)
name|fatal
argument_list|(
literal|"panic: hint in do_match"
argument_list|)
expr_stmt|;
name|s
operator|=
name|hint
expr_stmt|;
name|hint
operator|=
name|Nullch
expr_stmt|;
if|if
condition|(
name|spat
operator|->
name|spat_regexp
operator|->
name|regback
operator|>=
literal|0
condition|)
block|{
name|s
operator|-=
name|spat
operator|->
name|spat_regexp
operator|->
name|regback
expr_stmt|;
if|if
condition|(
name|s
operator|<
name|m
condition|)
name|s
operator|=
name|m
expr_stmt|;
block|}
else|else
name|s
operator|=
name|m
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|spat
operator|->
name|spat_short
condition|)
block|{
if|if
condition|(
name|spat
operator|->
name|spat_flags
operator|&
name|SPAT_SCANFIRST
condition|)
block|{
if|if
condition|(
name|str
operator|->
name|str_pok
operator|&
name|SP_STUDIED
condition|)
block|{
if|if
condition|(
name|screamfirst
index|[
name|spat
operator|->
name|spat_short
operator|->
name|str_rare
index|]
operator|<
literal|0
condition|)
goto|goto
name|nope
goto|;
elseif|else
if|if
condition|(
operator|!
operator|(
name|s
operator|=
name|screaminstr
argument_list|(
name|str
argument_list|,
name|spat
operator|->
name|spat_short
argument_list|)
operator|)
condition|)
goto|goto
name|nope
goto|;
block|}
ifndef|#
directive|ifndef
name|lint
elseif|else
if|if
condition|(
operator|!
operator|(
name|s
operator|=
name|fbminstr
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|s
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|strend
argument_list|,
name|spat
operator|->
name|spat_short
argument_list|)
operator|)
condition|)
goto|goto
name|nope
goto|;
endif|#
directive|endif
if|if
condition|(
name|s
operator|&&
name|spat
operator|->
name|spat_regexp
operator|->
name|regback
operator|>=
literal|0
condition|)
block|{
operator|++
name|spat
operator|->
name|spat_short
operator|->
name|str_u
operator|.
name|str_useful
expr_stmt|;
name|s
operator|-=
name|spat
operator|->
name|spat_regexp
operator|->
name|regback
expr_stmt|;
if|if
condition|(
name|s
operator|<
name|m
condition|)
name|s
operator|=
name|m
expr_stmt|;
block|}
else|else
name|s
operator|=
name|m
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|multiline
operator|&&
operator|(
operator|*
name|spat
operator|->
name|spat_short
operator|->
name|str_ptr
operator|!=
operator|*
name|s
operator|||
name|bcmp
argument_list|(
name|spat
operator|->
name|spat_short
operator|->
name|str_ptr
argument_list|,
name|s
argument_list|,
name|spat
operator|->
name|spat_slen
argument_list|)
operator|)
condition|)
goto|goto
name|nope
goto|;
if|if
condition|(
operator|--
name|spat
operator|->
name|spat_short
operator|->
name|str_u
operator|.
name|str_useful
operator|<
literal|0
condition|)
block|{
name|str_free
argument_list|(
name|spat
operator|->
name|spat_short
argument_list|)
expr_stmt|;
name|spat
operator|->
name|spat_short
operator|=
name|Nullstr
expr_stmt|;
comment|/* opt is being useless */
block|}
block|}
name|once
operator|=
operator|!
operator|(
name|rspat
operator|->
name|spat_flags
operator|&
name|SPAT_GLOBAL
operator|)
expr_stmt|;
if|if
condition|(
name|rspat
operator|->
name|spat_flags
operator|&
name|SPAT_CONST
condition|)
block|{
comment|/* known replacement string? */
if|if
condition|(
operator|(
name|rspat
operator|->
name|spat_repl
index|[
literal|1
index|]
operator|.
name|arg_type
operator|&
name|A_MASK
operator|)
operator|==
name|A_SINGLE
condition|)
name|dstr
operator|=
name|rspat
operator|->
name|spat_repl
index|[
literal|1
index|]
operator|.
name|arg_ptr
operator|.
name|arg_str
expr_stmt|;
else|else
block|{
comment|/* constant over loop, anyway */
operator|(
name|void
operator|)
name|eval
argument_list|(
name|rspat
operator|->
name|spat_repl
argument_list|,
name|G_SCALAR
argument_list|,
name|sp
argument_list|)
expr_stmt|;
name|dstr
operator|=
name|stack
operator|->
name|ary_array
index|[
name|sp
operator|+
literal|1
index|]
expr_stmt|;
block|}
name|c
operator|=
name|str_get
argument_list|(
name|dstr
argument_list|)
expr_stmt|;
name|clen
operator|=
name|dstr
operator|->
name|str_cur
expr_stmt|;
if|if
condition|(
name|clen
operator|<=
name|spat
operator|->
name|spat_regexp
operator|->
name|minlen
condition|)
block|{
comment|/* can do inplace substitution */
if|if
condition|(
name|regexec
argument_list|(
name|spat
operator|->
name|spat_regexp
argument_list|,
name|s
argument_list|,
name|strend
argument_list|,
name|orig
argument_list|,
literal|0
argument_list|,
name|str
operator|->
name|str_pok
operator|&
name|SP_STUDIED
condition|?
name|str
else|:
name|Nullstr
argument_list|,
name|safebase
argument_list|)
condition|)
block|{
if|if
condition|(
name|spat
operator|->
name|spat_regexp
operator|->
name|subbase
condition|)
comment|/* oops, no we can't */
goto|goto
name|long_way
goto|;
name|d
operator|=
name|s
expr_stmt|;
name|lastspat
operator|=
name|spat
expr_stmt|;
name|str
operator|->
name|str_pok
operator|=
name|SP_VALID
expr_stmt|;
comment|/* disable possible screamer */
if|if
condition|(
name|once
condition|)
block|{
name|m
operator|=
name|spat
operator|->
name|spat_regexp
operator|->
name|startp
index|[
literal|0
index|]
expr_stmt|;
name|d
operator|=
name|spat
operator|->
name|spat_regexp
operator|->
name|endp
index|[
literal|0
index|]
expr_stmt|;
name|s
operator|=
name|orig
expr_stmt|;
if|if
condition|(
name|m
operator|-
name|s
operator|>
name|strend
operator|-
name|d
condition|)
block|{
comment|/* faster to shorten from end */
if|if
condition|(
name|clen
condition|)
block|{
name|Copy
argument_list|(
name|c
argument_list|,
name|m
argument_list|,
name|clen
argument_list|,
name|char
argument_list|)
expr_stmt|;
name|m
operator|+=
name|clen
expr_stmt|;
block|}
name|i
operator|=
name|strend
operator|-
name|d
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|Move
argument_list|(
name|d
argument_list|,
name|m
argument_list|,
name|i
argument_list|,
name|char
argument_list|)
expr_stmt|;
name|m
operator|+=
name|i
expr_stmt|;
block|}
operator|*
name|m
operator|=
literal|'\0'
expr_stmt|;
name|str
operator|->
name|str_cur
operator|=
name|m
operator|-
name|s
expr_stmt|;
name|STABSET
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|str_numset
argument_list|(
name|arg
operator|->
name|arg_ptr
operator|.
name|arg_str
argument_list|,
literal|1.0
argument_list|)
expr_stmt|;
name|stack
operator|->
name|ary_array
index|[
operator|++
name|sp
index|]
operator|=
name|arg
operator|->
name|arg_ptr
operator|.
name|arg_str
expr_stmt|;
name|str
operator|->
name|str_nok
operator|=
literal|0
expr_stmt|;
return|return
name|sp
return|;
block|}
comment|/*SUPPRESS 560*/
elseif|else
if|if
condition|(
name|i
operator|=
name|m
operator|-
name|s
condition|)
block|{
comment|/* faster from front */
name|d
operator|-=
name|clen
expr_stmt|;
name|m
operator|=
name|d
expr_stmt|;
name|str_chop
argument_list|(
name|str
argument_list|,
name|d
operator|-
name|i
argument_list|)
expr_stmt|;
name|s
operator|+=
name|i
expr_stmt|;
while|while
condition|(
name|i
operator|--
condition|)
operator|*
operator|--
name|d
operator|=
operator|*
operator|--
name|s
expr_stmt|;
if|if
condition|(
name|clen
condition|)
name|Copy
argument_list|(
name|c
argument_list|,
name|m
argument_list|,
name|clen
argument_list|,
name|char
argument_list|)
expr_stmt|;
name|STABSET
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|str_numset
argument_list|(
name|arg
operator|->
name|arg_ptr
operator|.
name|arg_str
argument_list|,
literal|1.0
argument_list|)
expr_stmt|;
name|stack
operator|->
name|ary_array
index|[
operator|++
name|sp
index|]
operator|=
name|arg
operator|->
name|arg_ptr
operator|.
name|arg_str
expr_stmt|;
name|str
operator|->
name|str_nok
operator|=
literal|0
expr_stmt|;
return|return
name|sp
return|;
block|}
elseif|else
if|if
condition|(
name|clen
condition|)
block|{
name|d
operator|-=
name|clen
expr_stmt|;
name|str_chop
argument_list|(
name|str
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|Copy
argument_list|(
name|c
argument_list|,
name|d
argument_list|,
name|clen
argument_list|,
name|char
argument_list|)
expr_stmt|;
name|STABSET
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|str_numset
argument_list|(
name|arg
operator|->
name|arg_ptr
operator|.
name|arg_str
argument_list|,
literal|1.0
argument_list|)
expr_stmt|;
name|stack
operator|->
name|ary_array
index|[
operator|++
name|sp
index|]
operator|=
name|arg
operator|->
name|arg_ptr
operator|.
name|arg_str
expr_stmt|;
name|str
operator|->
name|str_nok
operator|=
literal|0
expr_stmt|;
return|return
name|sp
return|;
block|}
else|else
block|{
name|str_chop
argument_list|(
name|str
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|STABSET
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|str_numset
argument_list|(
name|arg
operator|->
name|arg_ptr
operator|.
name|arg_str
argument_list|,
literal|1.0
argument_list|)
expr_stmt|;
name|stack
operator|->
name|ary_array
index|[
operator|++
name|sp
index|]
operator|=
name|arg
operator|->
name|arg_ptr
operator|.
name|arg_str
expr_stmt|;
name|str
operator|->
name|str_nok
operator|=
literal|0
expr_stmt|;
return|return
name|sp
return|;
block|}
comment|/* NOTREACHED */
block|}
do|do
block|{
if|if
condition|(
name|iters
operator|++
operator|>
name|maxiters
condition|)
name|fatal
argument_list|(
literal|"Substitution loop"
argument_list|)
expr_stmt|;
name|m
operator|=
name|spat
operator|->
name|spat_regexp
operator|->
name|startp
index|[
literal|0
index|]
expr_stmt|;
comment|/*SUPPRESS 560*/
if|if
condition|(
name|i
operator|=
name|m
operator|-
name|s
condition|)
block|{
if|if
condition|(
name|s
operator|!=
name|d
condition|)
name|Move
argument_list|(
name|s
argument_list|,
name|d
argument_list|,
name|i
argument_list|,
name|char
argument_list|)
expr_stmt|;
name|d
operator|+=
name|i
expr_stmt|;
block|}
if|if
condition|(
name|clen
condition|)
block|{
name|Copy
argument_list|(
name|c
argument_list|,
name|d
argument_list|,
name|clen
argument_list|,
name|char
argument_list|)
expr_stmt|;
name|d
operator|+=
name|clen
expr_stmt|;
block|}
name|s
operator|=
name|spat
operator|->
name|spat_regexp
operator|->
name|endp
index|[
literal|0
index|]
expr_stmt|;
block|}
do|while
condition|(
name|regexec
argument_list|(
name|spat
operator|->
name|spat_regexp
argument_list|,
name|s
argument_list|,
name|strend
argument_list|,
name|orig
argument_list|,
name|s
operator|==
name|m
argument_list|,
name|Nullstr
argument_list|,
name|TRUE
argument_list|)
condition|)
do|;
comment|/* (don't match same null twice) */
if|if
condition|(
name|s
operator|!=
name|d
condition|)
block|{
name|i
operator|=
name|strend
operator|-
name|s
expr_stmt|;
name|str
operator|->
name|str_cur
operator|=
name|d
operator|-
name|str
operator|->
name|str_ptr
operator|+
name|i
expr_stmt|;
name|Move
argument_list|(
name|s
argument_list|,
name|d
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|char
argument_list|)
expr_stmt|;
comment|/* include the Null */
block|}
name|STABSET
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|str_numset
argument_list|(
name|arg
operator|->
name|arg_ptr
operator|.
name|arg_str
argument_list|,
operator|(
name|double
operator|)
name|iters
argument_list|)
expr_stmt|;
name|stack
operator|->
name|ary_array
index|[
operator|++
name|sp
index|]
operator|=
name|arg
operator|->
name|arg_ptr
operator|.
name|arg_str
expr_stmt|;
name|str
operator|->
name|str_nok
operator|=
literal|0
expr_stmt|;
return|return
name|sp
return|;
block|}
name|str_numset
argument_list|(
name|arg
operator|->
name|arg_ptr
operator|.
name|arg_str
argument_list|,
literal|0.0
argument_list|)
expr_stmt|;
name|stack
operator|->
name|ary_array
index|[
operator|++
name|sp
index|]
operator|=
name|arg
operator|->
name|arg_ptr
operator|.
name|arg_str
expr_stmt|;
return|return
name|sp
return|;
block|}
block|}
else|else
name|c
operator|=
name|Nullch
expr_stmt|;
if|if
condition|(
name|regexec
argument_list|(
name|spat
operator|->
name|spat_regexp
argument_list|,
name|s
argument_list|,
name|strend
argument_list|,
name|orig
argument_list|,
literal|0
argument_list|,
name|str
operator|->
name|str_pok
operator|&
name|SP_STUDIED
condition|?
name|str
else|:
name|Nullstr
argument_list|,
name|safebase
argument_list|)
condition|)
block|{
name|long_way
label|:
name|dstr
operator|=
name|Str_new
argument_list|(
literal|25
argument_list|,
name|str_len
argument_list|(
name|str
argument_list|)
argument_list|)
expr_stmt|;
name|str_nset
argument_list|(
name|dstr
argument_list|,
name|m
argument_list|,
name|s
operator|-
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|spat
operator|->
name|spat_regexp
operator|->
name|subbase
condition|)
name|curspat
operator|=
name|spat
expr_stmt|;
name|lastspat
operator|=
name|spat
expr_stmt|;
do|do
block|{
if|if
condition|(
name|iters
operator|++
operator|>
name|maxiters
condition|)
name|fatal
argument_list|(
literal|"Substitution loop"
argument_list|)
expr_stmt|;
if|if
condition|(
name|spat
operator|->
name|spat_regexp
operator|->
name|subbase
operator|&&
name|spat
operator|->
name|spat_regexp
operator|->
name|subbase
operator|!=
name|orig
condition|)
block|{
name|m
operator|=
name|s
expr_stmt|;
name|s
operator|=
name|orig
expr_stmt|;
name|orig
operator|=
name|spat
operator|->
name|spat_regexp
operator|->
name|subbase
expr_stmt|;
name|s
operator|=
name|orig
operator|+
operator|(
name|m
operator|-
name|s
operator|)
expr_stmt|;
name|strend
operator|=
name|s
operator|+
operator|(
name|strend
operator|-
name|m
operator|)
expr_stmt|;
block|}
name|m
operator|=
name|spat
operator|->
name|spat_regexp
operator|->
name|startp
index|[
literal|0
index|]
expr_stmt|;
name|str_ncat
argument_list|(
name|dstr
argument_list|,
name|s
argument_list|,
name|m
operator|-
name|s
argument_list|)
expr_stmt|;
name|s
operator|=
name|spat
operator|->
name|spat_regexp
operator|->
name|endp
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|c
condition|)
block|{
if|if
condition|(
name|clen
condition|)
name|str_ncat
argument_list|(
name|dstr
argument_list|,
name|c
argument_list|,
name|clen
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|mysubbase
init|=
name|spat
operator|->
name|spat_regexp
operator|->
name|subbase
decl_stmt|;
name|spat
operator|->
name|spat_regexp
operator|->
name|subbase
operator|=
name|Nullch
expr_stmt|;
comment|/* so recursion works */
operator|(
name|void
operator|)
name|eval
argument_list|(
name|rspat
operator|->
name|spat_repl
argument_list|,
name|G_SCALAR
argument_list|,
name|sp
argument_list|)
expr_stmt|;
name|str_scat
argument_list|(
name|dstr
argument_list|,
name|stack
operator|->
name|ary_array
index|[
name|sp
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|spat
operator|->
name|spat_regexp
operator|->
name|subbase
condition|)
name|Safefree
argument_list|(
name|spat
operator|->
name|spat_regexp
operator|->
name|subbase
argument_list|)
expr_stmt|;
name|spat
operator|->
name|spat_regexp
operator|->
name|subbase
operator|=
name|mysubbase
expr_stmt|;
block|}
if|if
condition|(
name|once
condition|)
break|break;
block|}
do|while
condition|(
name|regexec
argument_list|(
name|spat
operator|->
name|spat_regexp
argument_list|,
name|s
argument_list|,
name|strend
argument_list|,
name|orig
argument_list|,
name|s
operator|==
name|m
argument_list|,
name|Nullstr
argument_list|,
name|safebase
argument_list|)
condition|)
do|;
name|str_ncat
argument_list|(
name|dstr
argument_list|,
name|s
argument_list|,
name|strend
operator|-
name|s
argument_list|)
expr_stmt|;
name|str_replace
argument_list|(
name|str
argument_list|,
name|dstr
argument_list|)
expr_stmt|;
name|STABSET
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|str_numset
argument_list|(
name|arg
operator|->
name|arg_ptr
operator|.
name|arg_str
argument_list|,
operator|(
name|double
operator|)
name|iters
argument_list|)
expr_stmt|;
name|stack
operator|->
name|ary_array
index|[
operator|++
name|sp
index|]
operator|=
name|arg
operator|->
name|arg_ptr
operator|.
name|arg_str
expr_stmt|;
name|str
operator|->
name|str_nok
operator|=
literal|0
expr_stmt|;
return|return
name|sp
return|;
block|}
name|str_numset
argument_list|(
name|arg
operator|->
name|arg_ptr
operator|.
name|arg_str
argument_list|,
literal|0.0
argument_list|)
expr_stmt|;
name|stack
operator|->
name|ary_array
index|[
operator|++
name|sp
index|]
operator|=
name|arg
operator|->
name|arg_ptr
operator|.
name|arg_str
expr_stmt|;
return|return
name|sp
return|;
name|nope
label|:
operator|++
name|spat
operator|->
name|spat_short
operator|->
name|str_u
operator|.
name|str_useful
expr_stmt|;
name|str_numset
argument_list|(
name|arg
operator|->
name|arg_ptr
operator|.
name|arg_str
argument_list|,
literal|0.0
argument_list|)
expr_stmt|;
name|stack
operator|->
name|ary_array
index|[
operator|++
name|sp
index|]
operator|=
name|arg
operator|->
name|arg_ptr
operator|.
name|arg_str
expr_stmt|;
return|return
name|sp
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|BUGGY_MSC
end_ifdef

begin_pragma
pragma|#
directive|pragma
name|intrinsic
name|(
name|memcmp
name|)
end_pragma

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* BUGGY_MSC */
end_comment

begin_function
name|int
name|do_trans
parameter_list|(
name|str
parameter_list|,
name|arg
parameter_list|)
name|STR
modifier|*
name|str
decl_stmt|;
name|ARG
modifier|*
name|arg
decl_stmt|;
block|{
specifier|register
name|short
modifier|*
name|tbl
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
specifier|register
name|int
name|matches
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|ch
decl_stmt|;
specifier|register
name|char
modifier|*
name|send
decl_stmt|;
specifier|register
name|char
modifier|*
name|d
decl_stmt|;
specifier|register
name|int
name|squash
init|=
name|arg
index|[
literal|2
index|]
operator|.
name|arg_len
operator|&
literal|1
decl_stmt|;
name|tbl
operator|=
operator|(
name|short
operator|*
operator|)
name|arg
index|[
literal|2
index|]
operator|.
name|arg_ptr
operator|.
name|arg_cval
expr_stmt|;
name|s
operator|=
name|str_get
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|send
operator|=
name|s
operator|+
name|str
operator|->
name|str_cur
expr_stmt|;
if|if
condition|(
operator|!
name|tbl
operator|||
operator|!
name|s
condition|)
name|fatal
argument_list|(
literal|"panic: do_trans"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
name|debug
operator|&
literal|8
condition|)
block|{
name|deb
argument_list|(
literal|"2.TBL\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|!
name|arg
index|[
literal|2
index|]
operator|.
name|arg_len
condition|)
block|{
while|while
condition|(
name|s
operator|<
name|send
condition|)
block|{
if|if
condition|(
operator|(
name|ch
operator|=
name|tbl
index|[
operator|*
name|s
operator|&
literal|0377
index|]
operator|)
operator|>=
literal|0
condition|)
block|{
name|matches
operator|++
expr_stmt|;
operator|*
name|s
operator|=
name|ch
expr_stmt|;
block|}
name|s
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
name|d
operator|=
name|s
expr_stmt|;
while|while
condition|(
name|s
operator|<
name|send
condition|)
block|{
if|if
condition|(
operator|(
name|ch
operator|=
name|tbl
index|[
operator|*
name|s
operator|&
literal|0377
index|]
operator|)
operator|>=
literal|0
condition|)
block|{
operator|*
name|d
operator|=
name|ch
expr_stmt|;
if|if
condition|(
name|matches
operator|++
operator|&&
name|squash
condition|)
block|{
if|if
condition|(
name|d
index|[
operator|-
literal|1
index|]
operator|==
operator|*
name|d
condition|)
name|matches
operator|--
expr_stmt|;
else|else
name|d
operator|++
expr_stmt|;
block|}
else|else
name|d
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
operator|-
literal|1
condition|)
comment|/* -1 is unmapped character */
operator|*
name|d
operator|++
operator|=
operator|*
name|s
expr_stmt|;
comment|/* -2 is delete character */
name|s
operator|++
expr_stmt|;
block|}
name|matches
operator|+=
name|send
operator|-
name|d
expr_stmt|;
comment|/* account for disappeared chars */
operator|*
name|d
operator|=
literal|'\0'
expr_stmt|;
name|str
operator|->
name|str_cur
operator|=
name|d
operator|-
name|str
operator|->
name|str_ptr
expr_stmt|;
block|}
name|STABSET
argument_list|(
name|str
argument_list|)
expr_stmt|;
return|return
name|matches
return|;
block|}
end_function

begin_function
name|void
name|do_join
parameter_list|(
name|str
parameter_list|,
name|arglast
parameter_list|)
specifier|register
name|STR
modifier|*
name|str
decl_stmt|;
name|int
modifier|*
name|arglast
decl_stmt|;
block|{
specifier|register
name|STR
modifier|*
modifier|*
name|st
init|=
name|stack
operator|->
name|ary_array
decl_stmt|;
name|int
name|sp
init|=
name|arglast
index|[
literal|1
index|]
decl_stmt|;
specifier|register
name|int
name|items
init|=
name|arglast
index|[
literal|2
index|]
operator|-
name|sp
decl_stmt|;
specifier|register
name|char
modifier|*
name|delim
init|=
name|str_get
argument_list|(
name|st
index|[
name|sp
index|]
argument_list|)
decl_stmt|;
specifier|register
name|STRLEN
name|len
decl_stmt|;
name|int
name|delimlen
init|=
name|st
index|[
name|sp
index|]
operator|->
name|str_cur
decl_stmt|;
name|st
operator|+=
name|sp
operator|+
literal|1
expr_stmt|;
name|len
operator|=
operator|(
name|items
operator|>
literal|0
condition|?
operator|(
name|delimlen
operator|*
operator|(
name|items
operator|-
literal|1
operator|)
operator|)
else|:
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|str
operator|->
name|str_len
operator|<
name|len
operator|+
name|items
condition|)
block|{
comment|/* current length is way too short */
while|while
condition|(
name|items
operator|--
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|*
name|st
condition|)
name|len
operator|+=
operator|(
operator|*
name|st
operator|)
operator|->
name|str_cur
expr_stmt|;
name|st
operator|++
expr_stmt|;
block|}
name|STR_GROW
argument_list|(
name|str
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* so try to pre-extend */
name|items
operator|=
name|arglast
index|[
literal|2
index|]
operator|-
name|sp
expr_stmt|;
name|st
operator|-=
name|items
expr_stmt|;
block|}
if|if
condition|(
name|items
operator|--
operator|>
literal|0
condition|)
name|str_sset
argument_list|(
name|str
argument_list|,
operator|*
name|st
operator|++
argument_list|)
expr_stmt|;
else|else
name|str_set
argument_list|(
name|str
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|len
operator|=
name|delimlen
expr_stmt|;
if|if
condition|(
name|len
condition|)
block|{
for|for
control|(
init|;
name|items
operator|>
literal|0
condition|;
name|items
operator|--
operator|,
name|st
operator|++
control|)
block|{
name|str_ncat
argument_list|(
name|str
argument_list|,
name|delim
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|str_scat
argument_list|(
name|str
argument_list|,
operator|*
name|st
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
init|;
name|items
operator|>
literal|0
condition|;
name|items
operator|--
operator|,
name|st
operator|++
control|)
name|str_scat
argument_list|(
name|str
argument_list|,
operator|*
name|st
argument_list|)
expr_stmt|;
block|}
name|STABSET
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|do_pack
parameter_list|(
name|str
parameter_list|,
name|arglast
parameter_list|)
specifier|register
name|STR
modifier|*
name|str
decl_stmt|;
name|int
modifier|*
name|arglast
decl_stmt|;
block|{
specifier|register
name|STR
modifier|*
modifier|*
name|st
init|=
name|stack
operator|->
name|ary_array
decl_stmt|;
specifier|register
name|int
name|sp
init|=
name|arglast
index|[
literal|1
index|]
decl_stmt|;
specifier|register
name|int
name|items
decl_stmt|;
specifier|register
name|char
modifier|*
name|pat
init|=
name|str_get
argument_list|(
name|st
index|[
name|sp
index|]
argument_list|)
decl_stmt|;
specifier|register
name|char
modifier|*
name|patend
init|=
name|pat
operator|+
name|st
index|[
name|sp
index|]
operator|->
name|str_cur
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
name|int
name|datumtype
decl_stmt|;
name|STR
modifier|*
name|fromstr
decl_stmt|;
comment|/*SUPPRESS 442*/
specifier|static
name|char
modifier|*
name|null10
init|=
literal|"\0\0\0\0\0\0\0\0\0\0"
decl_stmt|;
specifier|static
name|char
modifier|*
name|space10
init|=
literal|"          "
decl_stmt|;
comment|/* These must not be in registers: */
name|char
name|achar
decl_stmt|;
name|short
name|ashort
decl_stmt|;
name|int
name|aint
decl_stmt|;
name|unsigned
name|int
name|auint
decl_stmt|;
name|long
name|along
decl_stmt|;
name|unsigned
name|long
name|aulong
decl_stmt|;
ifdef|#
directive|ifdef
name|QUAD
name|quad
name|aquad
decl_stmt|;
name|unsigned
name|quad
name|auquad
decl_stmt|;
endif|#
directive|endif
name|char
modifier|*
name|aptr
decl_stmt|;
name|float
name|afloat
decl_stmt|;
name|double
name|adouble
decl_stmt|;
name|items
operator|=
name|arglast
index|[
literal|2
index|]
operator|-
name|sp
expr_stmt|;
name|st
operator|+=
operator|++
name|sp
expr_stmt|;
name|str_nset
argument_list|(
name|str
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|pat
operator|<
name|patend
condition|)
block|{
define|#
directive|define
name|NEXTFROM
value|(items--> 0 ? *st++ :&str_no)
name|datumtype
operator|=
operator|*
name|pat
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|pat
operator|==
literal|'*'
condition|)
block|{
name|len
operator|=
name|index
argument_list|(
literal|"@Xxu"
argument_list|,
name|datumtype
argument_list|)
condition|?
literal|0
else|:
name|items
expr_stmt|;
name|pat
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isDIGIT
argument_list|(
operator|*
name|pat
argument_list|)
condition|)
block|{
name|len
operator|=
operator|*
name|pat
operator|++
operator|-
literal|'0'
expr_stmt|;
while|while
condition|(
name|isDIGIT
argument_list|(
operator|*
name|pat
argument_list|)
condition|)
name|len
operator|=
operator|(
name|len
operator|*
literal|10
operator|)
operator|+
operator|(
operator|*
name|pat
operator|++
operator|-
literal|'0'
operator|)
expr_stmt|;
block|}
else|else
name|len
operator|=
literal|1
expr_stmt|;
switch|switch
condition|(
name|datumtype
condition|)
block|{
default|default:
break|break;
case|case
literal|'%'
case|:
name|fatal
argument_list|(
literal|"% may only be used in unpack"
argument_list|)
expr_stmt|;
case|case
literal|'@'
case|:
name|len
operator|-=
name|str
operator|->
name|str_cur
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
condition|)
goto|goto
name|grow
goto|;
name|len
operator|=
operator|-
name|len
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
condition|)
goto|goto
name|shrink
goto|;
break|break;
case|case
literal|'X'
case|:
name|shrink
label|:
if|if
condition|(
name|str
operator|->
name|str_cur
operator|<
name|len
condition|)
name|fatal
argument_list|(
literal|"X outside of string"
argument_list|)
expr_stmt|;
name|str
operator|->
name|str_cur
operator|-=
name|len
expr_stmt|;
name|str
operator|->
name|str_ptr
index|[
name|str
operator|->
name|str_cur
index|]
operator|=
literal|'\0'
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|grow
label|:
while|while
condition|(
name|len
operator|>=
literal|10
condition|)
block|{
name|str_ncat
argument_list|(
name|str
argument_list|,
name|null10
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|len
operator|-=
literal|10
expr_stmt|;
block|}
name|str_ncat
argument_list|(
name|str
argument_list|,
name|null10
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'A'
case|:
case|case
literal|'a'
case|:
name|fromstr
operator|=
name|NEXTFROM
expr_stmt|;
name|aptr
operator|=
name|str_get
argument_list|(
name|fromstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|pat
index|[
operator|-
literal|1
index|]
operator|==
literal|'*'
condition|)
name|len
operator|=
name|fromstr
operator|->
name|str_cur
expr_stmt|;
if|if
condition|(
name|fromstr
operator|->
name|str_cur
operator|>
name|len
condition|)
name|str_ncat
argument_list|(
name|str
argument_list|,
name|aptr
argument_list|,
name|len
argument_list|)
expr_stmt|;
else|else
block|{
name|str_ncat
argument_list|(
name|str
argument_list|,
name|aptr
argument_list|,
name|fromstr
operator|->
name|str_cur
argument_list|)
expr_stmt|;
name|len
operator|-=
name|fromstr
operator|->
name|str_cur
expr_stmt|;
if|if
condition|(
name|datumtype
operator|==
literal|'A'
condition|)
block|{
while|while
condition|(
name|len
operator|>=
literal|10
condition|)
block|{
name|str_ncat
argument_list|(
name|str
argument_list|,
name|space10
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|len
operator|-=
literal|10
expr_stmt|;
block|}
name|str_ncat
argument_list|(
name|str
argument_list|,
name|space10
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|len
operator|>=
literal|10
condition|)
block|{
name|str_ncat
argument_list|(
name|str
argument_list|,
name|null10
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|len
operator|-=
literal|10
expr_stmt|;
block|}
name|str_ncat
argument_list|(
name|str
argument_list|,
name|null10
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'B'
case|:
case|case
literal|'b'
case|:
block|{
name|char
modifier|*
name|savepat
init|=
name|pat
decl_stmt|;
name|int
name|saveitems
decl_stmt|;
name|fromstr
operator|=
name|NEXTFROM
expr_stmt|;
name|saveitems
operator|=
name|items
expr_stmt|;
name|aptr
operator|=
name|str_get
argument_list|(
name|fromstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|pat
index|[
operator|-
literal|1
index|]
operator|==
literal|'*'
condition|)
name|len
operator|=
name|fromstr
operator|->
name|str_cur
expr_stmt|;
name|pat
operator|=
name|aptr
expr_stmt|;
name|aint
operator|=
name|str
operator|->
name|str_cur
expr_stmt|;
name|str
operator|->
name|str_cur
operator|+=
operator|(
name|len
operator|+
literal|7
operator|)
operator|/
literal|8
expr_stmt|;
name|STR_GROW
argument_list|(
name|str
argument_list|,
name|str
operator|->
name|str_cur
operator|+
literal|1
argument_list|)
expr_stmt|;
name|aptr
operator|=
name|str
operator|->
name|str_ptr
operator|+
name|aint
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|fromstr
operator|->
name|str_cur
condition|)
name|len
operator|=
name|fromstr
operator|->
name|str_cur
expr_stmt|;
name|aint
operator|=
name|len
expr_stmt|;
name|items
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|datumtype
operator|==
literal|'B'
condition|)
block|{
for|for
control|(
name|len
operator|=
literal|0
init|;
name|len
operator|++
operator|<
name|aint
condition|;
control|)
block|{
name|items
operator||=
operator|*
name|pat
operator|++
operator|&
literal|1
expr_stmt|;
if|if
condition|(
name|len
operator|&
literal|7
condition|)
name|items
operator|<<=
literal|1
expr_stmt|;
else|else
block|{
operator|*
name|aptr
operator|++
operator|=
name|items
operator|&
literal|0xff
expr_stmt|;
name|items
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
for|for
control|(
name|len
operator|=
literal|0
init|;
name|len
operator|++
operator|<
name|aint
condition|;
control|)
block|{
if|if
condition|(
operator|*
name|pat
operator|++
operator|&
literal|1
condition|)
name|items
operator||=
literal|128
expr_stmt|;
if|if
condition|(
name|len
operator|&
literal|7
condition|)
name|items
operator|>>=
literal|1
expr_stmt|;
else|else
block|{
operator|*
name|aptr
operator|++
operator|=
name|items
operator|&
literal|0xff
expr_stmt|;
name|items
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|aint
operator|&
literal|7
condition|)
block|{
if|if
condition|(
name|datumtype
operator|==
literal|'B'
condition|)
name|items
operator|<<=
literal|7
operator|-
operator|(
name|aint
operator|&
literal|7
operator|)
expr_stmt|;
else|else
name|items
operator|>>=
literal|7
operator|-
operator|(
name|aint
operator|&
literal|7
operator|)
expr_stmt|;
operator|*
name|aptr
operator|++
operator|=
name|items
operator|&
literal|0xff
expr_stmt|;
block|}
name|pat
operator|=
name|str
operator|->
name|str_ptr
operator|+
name|str
operator|->
name|str_cur
expr_stmt|;
while|while
condition|(
name|aptr
operator|<=
name|pat
condition|)
operator|*
name|aptr
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|pat
operator|=
name|savepat
expr_stmt|;
name|items
operator|=
name|saveitems
expr_stmt|;
block|}
break|break;
case|case
literal|'H'
case|:
case|case
literal|'h'
case|:
block|{
name|char
modifier|*
name|savepat
init|=
name|pat
decl_stmt|;
name|int
name|saveitems
decl_stmt|;
name|fromstr
operator|=
name|NEXTFROM
expr_stmt|;
name|saveitems
operator|=
name|items
expr_stmt|;
name|aptr
operator|=
name|str_get
argument_list|(
name|fromstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|pat
index|[
operator|-
literal|1
index|]
operator|==
literal|'*'
condition|)
name|len
operator|=
name|fromstr
operator|->
name|str_cur
expr_stmt|;
name|pat
operator|=
name|aptr
expr_stmt|;
name|aint
operator|=
name|str
operator|->
name|str_cur
expr_stmt|;
name|str
operator|->
name|str_cur
operator|+=
operator|(
name|len
operator|+
literal|1
operator|)
operator|/
literal|2
expr_stmt|;
name|STR_GROW
argument_list|(
name|str
argument_list|,
name|str
operator|->
name|str_cur
operator|+
literal|1
argument_list|)
expr_stmt|;
name|aptr
operator|=
name|str
operator|->
name|str_ptr
operator|+
name|aint
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|fromstr
operator|->
name|str_cur
condition|)
name|len
operator|=
name|fromstr
operator|->
name|str_cur
expr_stmt|;
name|aint
operator|=
name|len
expr_stmt|;
name|items
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|datumtype
operator|==
literal|'H'
condition|)
block|{
for|for
control|(
name|len
operator|=
literal|0
init|;
name|len
operator|++
operator|<
name|aint
condition|;
control|)
block|{
if|if
condition|(
name|isALPHA
argument_list|(
operator|*
name|pat
argument_list|)
condition|)
name|items
operator||=
operator|(
operator|(
operator|*
name|pat
operator|++
operator|&
literal|15
operator|)
operator|+
literal|9
operator|)
operator|&
literal|15
expr_stmt|;
else|else
name|items
operator||=
operator|*
name|pat
operator|++
operator|&
literal|15
expr_stmt|;
if|if
condition|(
name|len
operator|&
literal|1
condition|)
name|items
operator|<<=
literal|4
expr_stmt|;
else|else
block|{
operator|*
name|aptr
operator|++
operator|=
name|items
operator|&
literal|0xff
expr_stmt|;
name|items
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
for|for
control|(
name|len
operator|=
literal|0
init|;
name|len
operator|++
operator|<
name|aint
condition|;
control|)
block|{
if|if
condition|(
name|isALPHA
argument_list|(
operator|*
name|pat
argument_list|)
condition|)
name|items
operator||=
operator|(
operator|(
operator|(
operator|*
name|pat
operator|++
operator|&
literal|15
operator|)
operator|+
literal|9
operator|)
operator|&
literal|15
operator|)
operator|<<
literal|4
expr_stmt|;
else|else
name|items
operator||=
operator|(
operator|*
name|pat
operator|++
operator|&
literal|15
operator|)
operator|<<
literal|4
expr_stmt|;
if|if
condition|(
name|len
operator|&
literal|1
condition|)
name|items
operator|>>=
literal|4
expr_stmt|;
else|else
block|{
operator|*
name|aptr
operator|++
operator|=
name|items
operator|&
literal|0xff
expr_stmt|;
name|items
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|aint
operator|&
literal|1
condition|)
operator|*
name|aptr
operator|++
operator|=
name|items
operator|&
literal|0xff
expr_stmt|;
name|pat
operator|=
name|str
operator|->
name|str_ptr
operator|+
name|str
operator|->
name|str_cur
expr_stmt|;
while|while
condition|(
name|aptr
operator|<=
name|pat
condition|)
operator|*
name|aptr
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|pat
operator|=
name|savepat
expr_stmt|;
name|items
operator|=
name|saveitems
expr_stmt|;
block|}
break|break;
case|case
literal|'C'
case|:
case|case
literal|'c'
case|:
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
block|{
name|fromstr
operator|=
name|NEXTFROM
expr_stmt|;
name|aint
operator|=
operator|(
name|int
operator|)
name|str_gnum
argument_list|(
name|fromstr
argument_list|)
expr_stmt|;
name|achar
operator|=
name|aint
expr_stmt|;
name|str_ncat
argument_list|(
name|str
argument_list|,
operator|&
name|achar
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* Float and double added by gnb@melba.bby.oz.au  22/11/89 */
case|case
literal|'f'
case|:
case|case
literal|'F'
case|:
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
block|{
name|fromstr
operator|=
name|NEXTFROM
expr_stmt|;
name|afloat
operator|=
operator|(
name|float
operator|)
name|str_gnum
argument_list|(
name|fromstr
argument_list|)
expr_stmt|;
name|str_ncat
argument_list|(
name|str
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|afloat
argument_list|,
sizeof|sizeof
argument_list|(
name|float
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'d'
case|:
case|case
literal|'D'
case|:
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
block|{
name|fromstr
operator|=
name|NEXTFROM
expr_stmt|;
name|adouble
operator|=
operator|(
name|double
operator|)
name|str_gnum
argument_list|(
name|fromstr
argument_list|)
expr_stmt|;
name|str_ncat
argument_list|(
name|str
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|adouble
argument_list|,
sizeof|sizeof
argument_list|(
name|double
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'n'
case|:
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
block|{
name|fromstr
operator|=
name|NEXTFROM
expr_stmt|;
name|ashort
operator|=
operator|(
name|short
operator|)
name|str_gnum
argument_list|(
name|fromstr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAS_HTONS
name|ashort
operator|=
name|htons
argument_list|(
name|ashort
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|str_ncat
argument_list|(
name|str
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ashort
argument_list|,
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'v'
case|:
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
block|{
name|fromstr
operator|=
name|NEXTFROM
expr_stmt|;
name|ashort
operator|=
operator|(
name|short
operator|)
name|str_gnum
argument_list|(
name|fromstr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAS_HTOVS
name|ashort
operator|=
name|htovs
argument_list|(
name|ashort
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|str_ncat
argument_list|(
name|str
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ashort
argument_list|,
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'S'
case|:
case|case
literal|'s'
case|:
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
block|{
name|fromstr
operator|=
name|NEXTFROM
expr_stmt|;
name|ashort
operator|=
operator|(
name|short
operator|)
name|str_gnum
argument_list|(
name|fromstr
argument_list|)
expr_stmt|;
name|str_ncat
argument_list|(
name|str
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ashort
argument_list|,
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'I'
case|:
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
block|{
name|fromstr
operator|=
name|NEXTFROM
expr_stmt|;
name|auint
operator|=
name|U_I
argument_list|(
name|str_gnum
argument_list|(
name|fromstr
argument_list|)
argument_list|)
expr_stmt|;
name|str_ncat
argument_list|(
name|str
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|auint
argument_list|,
expr|sizeof
operator|(
name|unsigned
name|int
operator|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'i'
case|:
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
block|{
name|fromstr
operator|=
name|NEXTFROM
expr_stmt|;
name|aint
operator|=
operator|(
name|int
operator|)
name|str_gnum
argument_list|(
name|fromstr
argument_list|)
expr_stmt|;
name|str_ncat
argument_list|(
name|str
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|aint
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'N'
case|:
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
block|{
name|fromstr
operator|=
name|NEXTFROM
expr_stmt|;
name|aulong
operator|=
name|U_L
argument_list|(
name|str_gnum
argument_list|(
name|fromstr
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAS_HTONL
name|aulong
operator|=
name|htonl
argument_list|(
name|aulong
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|str_ncat
argument_list|(
name|str
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|aulong
argument_list|,
expr|sizeof
operator|(
name|unsigned
name|long
operator|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'V'
case|:
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
block|{
name|fromstr
operator|=
name|NEXTFROM
expr_stmt|;
name|aulong
operator|=
name|U_L
argument_list|(
name|str_gnum
argument_list|(
name|fromstr
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAS_HTOVL
name|aulong
operator|=
name|htovl
argument_list|(
name|aulong
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|str_ncat
argument_list|(
name|str
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|aulong
argument_list|,
expr|sizeof
operator|(
name|unsigned
name|long
operator|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'L'
case|:
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
block|{
name|fromstr
operator|=
name|NEXTFROM
expr_stmt|;
name|aulong
operator|=
name|U_L
argument_list|(
name|str_gnum
argument_list|(
name|fromstr
argument_list|)
argument_list|)
expr_stmt|;
name|str_ncat
argument_list|(
name|str
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|aulong
argument_list|,
expr|sizeof
operator|(
name|unsigned
name|long
operator|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'l'
case|:
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
block|{
name|fromstr
operator|=
name|NEXTFROM
expr_stmt|;
name|along
operator|=
operator|(
name|long
operator|)
name|str_gnum
argument_list|(
name|fromstr
argument_list|)
expr_stmt|;
name|str_ncat
argument_list|(
name|str
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|along
argument_list|,
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
ifdef|#
directive|ifdef
name|QUAD
case|case
literal|'Q'
case|:
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
block|{
name|fromstr
operator|=
name|NEXTFROM
expr_stmt|;
name|auquad
operator|=
operator|(
name|unsigned
name|quad
operator|)
name|str_gnum
argument_list|(
name|fromstr
argument_list|)
expr_stmt|;
name|str_ncat
argument_list|(
name|str
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|auquad
argument_list|,
expr|sizeof
operator|(
name|unsigned
name|quad
operator|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'q'
case|:
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
block|{
name|fromstr
operator|=
name|NEXTFROM
expr_stmt|;
name|aquad
operator|=
operator|(
name|quad
operator|)
name|str_gnum
argument_list|(
name|fromstr
argument_list|)
expr_stmt|;
name|str_ncat
argument_list|(
name|str
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|aquad
argument_list|,
sizeof|sizeof
argument_list|(
name|quad
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
comment|/* QUAD */
case|case
literal|'p'
case|:
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
block|{
name|fromstr
operator|=
name|NEXTFROM
expr_stmt|;
name|aptr
operator|=
name|str_get
argument_list|(
name|fromstr
argument_list|)
expr_stmt|;
name|str_ncat
argument_list|(
name|str
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|aptr
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'u'
case|:
name|fromstr
operator|=
name|NEXTFROM
expr_stmt|;
name|aptr
operator|=
name|str_get
argument_list|(
name|fromstr
argument_list|)
expr_stmt|;
name|aint
operator|=
name|fromstr
operator|->
name|str_cur
expr_stmt|;
name|STR_GROW
argument_list|(
name|str
argument_list|,
name|aint
operator|*
literal|4
operator|/
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<=
literal|1
condition|)
name|len
operator|=
literal|45
expr_stmt|;
else|else
name|len
operator|=
name|len
operator|/
literal|3
operator|*
literal|3
expr_stmt|;
while|while
condition|(
name|aint
operator|>
literal|0
condition|)
block|{
name|int
name|todo
decl_stmt|;
if|if
condition|(
name|aint
operator|>
name|len
condition|)
name|todo
operator|=
name|len
expr_stmt|;
else|else
name|todo
operator|=
name|aint
expr_stmt|;
name|doencodes
argument_list|(
name|str
argument_list|,
name|aptr
argument_list|,
name|todo
argument_list|)
expr_stmt|;
name|aint
operator|-=
name|todo
expr_stmt|;
name|aptr
operator|+=
name|todo
expr_stmt|;
block|}
break|break;
block|}
block|}
name|STABSET
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|NEXTFROM
end_undef

begin_function
specifier|static
name|void
name|doencodes
parameter_list|(
name|str
parameter_list|,
name|s
parameter_list|,
name|len
parameter_list|)
specifier|register
name|STR
modifier|*
name|str
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
block|{
name|char
name|hunk
index|[
literal|5
index|]
decl_stmt|;
operator|*
name|hunk
operator|=
name|len
operator|+
literal|' '
expr_stmt|;
name|str_ncat
argument_list|(
name|str
argument_list|,
name|hunk
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|hunk
index|[
literal|4
index|]
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|hunk
index|[
literal|0
index|]
operator|=
literal|' '
operator|+
operator|(
literal|077
operator|&
operator|(
operator|*
name|s
operator|>>
literal|2
operator|)
operator|)
expr_stmt|;
name|hunk
index|[
literal|1
index|]
operator|=
literal|' '
operator|+
operator|(
literal|077
operator|&
operator|(
operator|(
operator|*
name|s
operator|<<
literal|4
operator|)
operator|&
literal|060
operator||
operator|(
name|s
index|[
literal|1
index|]
operator|>>
literal|4
operator|)
operator|&
literal|017
operator|)
operator|)
expr_stmt|;
name|hunk
index|[
literal|2
index|]
operator|=
literal|' '
operator|+
operator|(
literal|077
operator|&
operator|(
operator|(
name|s
index|[
literal|1
index|]
operator|<<
literal|2
operator|)
operator|&
literal|074
operator||
operator|(
name|s
index|[
literal|2
index|]
operator|>>
literal|6
operator|)
operator|&
literal|03
operator|)
operator|)
expr_stmt|;
name|hunk
index|[
literal|3
index|]
operator|=
literal|' '
operator|+
operator|(
literal|077
operator|&
operator|(
name|s
index|[
literal|2
index|]
operator|&
literal|077
operator|)
operator|)
expr_stmt|;
name|str_ncat
argument_list|(
name|str
argument_list|,
name|hunk
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|s
operator|+=
literal|3
expr_stmt|;
name|len
operator|-=
literal|3
expr_stmt|;
block|}
for|for
control|(
name|s
operator|=
name|str
operator|->
name|str_ptr
init|;
operator|*
name|s
condition|;
name|s
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|' '
condition|)
operator|*
name|s
operator|=
literal|'`'
expr_stmt|;
block|}
name|str_ncat
argument_list|(
name|str
argument_list|,
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|do_sprintf
parameter_list|(
name|str
parameter_list|,
name|len
parameter_list|,
name|sarg
parameter_list|)
specifier|register
name|STR
modifier|*
name|str
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
specifier|register
name|STR
modifier|*
modifier|*
name|sarg
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
specifier|register
name|char
modifier|*
name|t
decl_stmt|;
specifier|register
name|char
modifier|*
name|f
decl_stmt|;
name|bool
name|dolong
decl_stmt|;
ifdef|#
directive|ifdef
name|QUAD
name|bool
name|doquad
decl_stmt|;
endif|#
directive|endif
comment|/* QUAD */
name|char
name|ch
decl_stmt|;
specifier|static
name|STR
modifier|*
name|sargnull
init|=
operator|&
name|str_no
decl_stmt|;
specifier|register
name|char
modifier|*
name|send
decl_stmt|;
specifier|register
name|STR
modifier|*
name|arg
decl_stmt|;
name|char
modifier|*
name|xs
decl_stmt|;
name|int
name|xlen
decl_stmt|;
name|int
name|pre
decl_stmt|;
name|int
name|post
decl_stmt|;
name|double
name|value
decl_stmt|;
name|str_set
argument_list|(
name|str
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|len
operator|--
expr_stmt|;
comment|/* don't count pattern string */
name|t
operator|=
name|s
operator|=
name|str_get
argument_list|(
operator|*
name|sarg
argument_list|)
expr_stmt|;
name|send
operator|=
name|s
operator|+
operator|(
operator|*
name|sarg
operator|)
operator|->
name|str_cur
expr_stmt|;
name|sarg
operator|++
expr_stmt|;
for|for
control|(
init|;
condition|;
name|len
operator|--
control|)
block|{
comment|/*SUPPRESS 560*/
if|if
condition|(
name|len
operator|<=
literal|0
operator|||
operator|!
operator|(
name|arg
operator|=
operator|*
name|sarg
operator|++
operator|)
condition|)
name|arg
operator|=
name|sargnull
expr_stmt|;
comment|/*SUPPRESS 530*/
for|for
control|(
init|;
name|t
operator|<
name|send
operator|&&
operator|*
name|t
operator|!=
literal|'%'
condition|;
name|t
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|t
operator|>=
name|send
condition|)
break|break;
comment|/* end of format string, ignore extra args */
name|f
operator|=
name|t
expr_stmt|;
operator|*
name|buf
operator|=
literal|'\0'
expr_stmt|;
name|xs
operator|=
name|buf
expr_stmt|;
ifdef|#
directive|ifdef
name|QUAD
name|doquad
operator|=
endif|#
directive|endif
comment|/* QUAD */
name|dolong
operator|=
name|FALSE
expr_stmt|;
name|pre
operator|=
name|post
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|t
operator|++
init|;
name|t
operator|<
name|send
condition|;
name|t
operator|++
control|)
block|{
switch|switch
condition|(
operator|*
name|t
condition|)
block|{
default|default:
name|ch
operator|=
operator|*
operator|(
operator|++
name|t
operator|)
expr_stmt|;
operator|*
name|t
operator|=
literal|'\0'
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|xs
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|len
operator|++
operator|,
name|sarg
operator|--
expr_stmt|;
name|xlen
operator|=
name|strlen
argument_list|(
name|xs
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
case|case
literal|'.'
case|:
case|case
literal|'#'
case|:
case|case
literal|'-'
case|:
case|case
literal|'+'
case|:
case|case
literal|' '
case|:
continue|continue;
case|case
literal|'l'
case|:
ifdef|#
directive|ifdef
name|QUAD
if|if
condition|(
name|dolong
condition|)
block|{
name|dolong
operator|=
name|FALSE
expr_stmt|;
name|doquad
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
endif|#
directive|endif
name|dolong
operator|=
name|TRUE
expr_stmt|;
continue|continue;
case|case
literal|'c'
case|:
name|ch
operator|=
operator|*
operator|(
operator|++
name|t
operator|)
expr_stmt|;
operator|*
name|t
operator|=
literal|'\0'
expr_stmt|;
name|xlen
operator|=
operator|(
name|int
operator|)
name|str_gnum
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|f
argument_list|,
literal|"%c"
argument_list|)
condition|)
block|{
comment|/* some printfs fail on null chars */
operator|*
name|xs
operator|=
name|xlen
expr_stmt|;
name|xs
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|xlen
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|xs
argument_list|,
name|f
argument_list|,
name|xlen
argument_list|)
expr_stmt|;
name|xlen
operator|=
name|strlen
argument_list|(
name|xs
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'D'
case|:
name|dolong
operator|=
name|TRUE
expr_stmt|;
comment|/* FALL THROUGH */
case|case
literal|'d'
case|:
name|ch
operator|=
operator|*
operator|(
operator|++
name|t
operator|)
expr_stmt|;
operator|*
name|t
operator|=
literal|'\0'
expr_stmt|;
ifdef|#
directive|ifdef
name|QUAD
if|if
condition|(
name|doquad
condition|)
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
name|s
argument_list|,
operator|(
name|quad
operator|)
name|str_gnum
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
endif|#
directive|endif
if|if
condition|(
name|dolong
condition|)
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|xs
argument_list|,
name|f
argument_list|,
operator|(
name|long
operator|)
name|str_gnum
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|xs
argument_list|,
name|f
argument_list|,
operator|(
name|int
operator|)
name|str_gnum
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
name|xlen
operator|=
name|strlen
argument_list|(
name|xs
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'X'
case|:
case|case
literal|'O'
case|:
name|dolong
operator|=
name|TRUE
expr_stmt|;
comment|/* FALL THROUGH */
case|case
literal|'x'
case|:
case|case
literal|'o'
case|:
case|case
literal|'u'
case|:
name|ch
operator|=
operator|*
operator|(
operator|++
name|t
operator|)
expr_stmt|;
operator|*
name|t
operator|=
literal|'\0'
expr_stmt|;
name|value
operator|=
name|str_gnum
argument_list|(
name|arg
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|QUAD
if|if
condition|(
name|doquad
condition|)
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
name|s
argument_list|,
operator|(
name|unsigned
name|quad
operator|)
name|value
argument_list|)
expr_stmt|;
elseif|else
endif|#
directive|endif
if|if
condition|(
name|dolong
condition|)
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|xs
argument_list|,
name|f
argument_list|,
name|U_L
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|xs
argument_list|,
name|f
argument_list|,
name|U_I
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|xlen
operator|=
name|strlen
argument_list|(
name|xs
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
case|case
literal|'e'
case|:
case|case
literal|'f'
case|:
case|case
literal|'G'
case|:
case|case
literal|'g'
case|:
name|ch
operator|=
operator|*
operator|(
operator|++
name|t
operator|)
expr_stmt|;
operator|*
name|t
operator|=
literal|'\0'
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|xs
argument_list|,
name|f
argument_list|,
name|str_gnum
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
name|xlen
operator|=
name|strlen
argument_list|(
name|xs
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|ch
operator|=
operator|*
operator|(
operator|++
name|t
operator|)
expr_stmt|;
operator|*
name|t
operator|=
literal|'\0'
expr_stmt|;
name|xs
operator|=
name|str_get
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|xlen
operator|=
name|arg
operator|->
name|str_cur
expr_stmt|;
if|if
condition|(
operator|*
name|xs
operator|==
literal|'S'
operator|&&
name|xs
index|[
literal|1
index|]
operator|==
literal|'t'
operator|&&
name|xs
index|[
literal|2
index|]
operator|==
literal|'B'
operator|&&
name|xs
index|[
literal|3
index|]
operator|==
literal|'\0'
operator|&&
name|xlen
operator|==
sizeof|sizeof
argument_list|(
name|STBP
argument_list|)
condition|)
block|{
name|STR
modifier|*
name|tmpstr
init|=
name|Str_new
argument_list|(
literal|24
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|stab_efullname
argument_list|(
name|tmpstr
argument_list|,
operator|(
operator|(
name|STAB
operator|*
operator|)
name|arg
operator|)
argument_list|)
expr_stmt|;
comment|/* a stab value! */
name|sprintf
argument_list|(
name|tokenbuf
argument_list|,
literal|"*%s"
argument_list|,
name|tmpstr
operator|->
name|str_ptr
argument_list|)
expr_stmt|;
comment|/* reformat to non-binary */
name|xs
operator|=
name|tokenbuf
expr_stmt|;
name|xlen
operator|=
name|strlen
argument_list|(
name|tokenbuf
argument_list|)
expr_stmt|;
name|str_free
argument_list|(
name|tmpstr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strEQ
argument_list|(
name|f
argument_list|,
literal|"%s"
argument_list|)
condition|)
block|{
comment|/* some printfs fail on>128 chars */
break|break;
comment|/* so handle simple cases */
block|}
elseif|else
if|if
condition|(
name|f
index|[
literal|1
index|]
operator|==
literal|'-'
condition|)
block|{
name|char
modifier|*
name|mp
init|=
name|index
argument_list|(
name|f
argument_list|,
literal|'.'
argument_list|)
decl_stmt|;
name|int
name|min
init|=
name|atoi
argument_list|(
name|f
operator|+
literal|2
argument_list|)
decl_stmt|;
if|if
condition|(
name|mp
condition|)
block|{
name|int
name|max
init|=
name|atoi
argument_list|(
name|mp
operator|+
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|xlen
operator|>
name|max
condition|)
name|xlen
operator|=
name|max
expr_stmt|;
block|}
if|if
condition|(
name|xlen
operator|<
name|min
condition|)
name|post
operator|=
name|min
operator|-
name|xlen
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|isDIGIT
argument_list|(
name|f
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|char
modifier|*
name|mp
init|=
name|index
argument_list|(
name|f
argument_list|,
literal|'.'
argument_list|)
decl_stmt|;
name|int
name|min
init|=
name|atoi
argument_list|(
name|f
operator|+
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|mp
condition|)
block|{
name|int
name|max
init|=
name|atoi
argument_list|(
name|mp
operator|+
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|xlen
operator|>
name|max
condition|)
name|xlen
operator|=
name|max
expr_stmt|;
block|}
if|if
condition|(
name|xlen
operator|<
name|min
condition|)
name|pre
operator|=
name|min
operator|-
name|xlen
expr_stmt|;
break|break;
block|}
name|strcpy
argument_list|(
name|tokenbuf
operator|+
literal|64
argument_list|,
name|f
argument_list|)
expr_stmt|;
comment|/* sprintf($s,...$s...) */
operator|*
name|t
operator|=
name|ch
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
name|tokenbuf
operator|+
literal|64
argument_list|,
name|xs
argument_list|)
expr_stmt|;
name|xs
operator|=
name|buf
expr_stmt|;
name|xlen
operator|=
name|strlen
argument_list|(
name|xs
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* end of switch, copy results */
operator|*
name|t
operator|=
name|ch
expr_stmt|;
name|STR_GROW
argument_list|(
name|str
argument_list|,
name|str
operator|->
name|str_cur
operator|+
operator|(
name|f
operator|-
name|s
operator|)
operator|+
name|xlen
operator|+
literal|1
operator|+
name|pre
operator|+
name|post
argument_list|)
expr_stmt|;
name|str_ncat
argument_list|(
name|str
argument_list|,
name|s
argument_list|,
name|f
operator|-
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|pre
condition|)
block|{
name|repeatcpy
argument_list|(
name|str
operator|->
name|str_ptr
operator|+
name|str
operator|->
name|str_cur
argument_list|,
literal|" "
argument_list|,
literal|1
argument_list|,
name|pre
argument_list|)
expr_stmt|;
name|str
operator|->
name|str_cur
operator|+=
name|pre
expr_stmt|;
block|}
name|str_ncat
argument_list|(
name|str
argument_list|,
name|xs
argument_list|,
name|xlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|post
condition|)
block|{
name|repeatcpy
argument_list|(
name|str
operator|->
name|str_ptr
operator|+
name|str
operator|->
name|str_cur
argument_list|,
literal|" "
argument_list|,
literal|1
argument_list|,
name|post
argument_list|)
expr_stmt|;
name|str
operator|->
name|str_cur
operator|+=
name|post
expr_stmt|;
block|}
name|s
operator|=
name|t
expr_stmt|;
break|break;
comment|/* break from for loop */
block|}
block|}
name|str_ncat
argument_list|(
name|str
argument_list|,
name|s
argument_list|,
name|t
operator|-
name|s
argument_list|)
expr_stmt|;
name|STABSET
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|STR
modifier|*
name|do_push
parameter_list|(
name|ary
parameter_list|,
name|arglast
parameter_list|)
specifier|register
name|ARRAY
modifier|*
name|ary
decl_stmt|;
name|int
modifier|*
name|arglast
decl_stmt|;
block|{
specifier|register
name|STR
modifier|*
modifier|*
name|st
init|=
name|stack
operator|->
name|ary_array
decl_stmt|;
specifier|register
name|int
name|sp
init|=
name|arglast
index|[
literal|1
index|]
decl_stmt|;
specifier|register
name|int
name|items
init|=
name|arglast
index|[
literal|2
index|]
operator|-
name|sp
decl_stmt|;
specifier|register
name|STR
modifier|*
name|str
init|=
operator|&
name|str_undef
decl_stmt|;
for|for
control|(
name|st
operator|+=
operator|++
name|sp
init|;
name|items
operator|>
literal|0
condition|;
name|items
operator|--
operator|,
name|st
operator|++
control|)
block|{
name|str
operator|=
name|Str_new
argument_list|(
literal|26
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|st
condition|)
name|str_sset
argument_list|(
name|str
argument_list|,
operator|*
name|st
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|apush
argument_list|(
name|ary
argument_list|,
name|str
argument_list|)
expr_stmt|;
block|}
return|return
name|str
return|;
block|}
end_function

begin_function
name|void
name|do_unshift
parameter_list|(
name|ary
parameter_list|,
name|arglast
parameter_list|)
specifier|register
name|ARRAY
modifier|*
name|ary
decl_stmt|;
name|int
modifier|*
name|arglast
decl_stmt|;
block|{
specifier|register
name|STR
modifier|*
modifier|*
name|st
init|=
name|stack
operator|->
name|ary_array
decl_stmt|;
specifier|register
name|int
name|sp
init|=
name|arglast
index|[
literal|1
index|]
decl_stmt|;
specifier|register
name|int
name|items
init|=
name|arglast
index|[
literal|2
index|]
operator|-
name|sp
decl_stmt|;
specifier|register
name|STR
modifier|*
name|str
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|aunshift
argument_list|(
name|ary
argument_list|,
name|items
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|st
operator|+=
operator|++
name|sp
init|;
name|i
operator|<
name|items
condition|;
name|i
operator|++
operator|,
name|st
operator|++
control|)
block|{
name|str
operator|=
name|Str_new
argument_list|(
literal|27
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|str_sset
argument_list|(
name|str
argument_list|,
operator|*
name|st
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|astore
argument_list|(
name|ary
argument_list|,
name|i
argument_list|,
name|str
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|do_subr
parameter_list|(
name|arg
parameter_list|,
name|gimme
parameter_list|,
name|arglast
parameter_list|)
specifier|register
name|ARG
modifier|*
name|arg
decl_stmt|;
name|int
name|gimme
decl_stmt|;
name|int
modifier|*
name|arglast
decl_stmt|;
block|{
specifier|register
name|STR
modifier|*
modifier|*
name|st
init|=
name|stack
operator|->
name|ary_array
decl_stmt|;
specifier|register
name|int
name|sp
init|=
name|arglast
index|[
literal|1
index|]
decl_stmt|;
specifier|register
name|int
name|items
init|=
name|arglast
index|[
literal|2
index|]
operator|-
name|sp
decl_stmt|;
specifier|register
name|SUBR
modifier|*
name|sub
decl_stmt|;
name|SPAT
modifier|*
name|VOLATILE
name|oldspat
init|=
name|curspat
decl_stmt|;
name|STR
modifier|*
name|str
decl_stmt|;
name|STAB
modifier|*
name|stab
decl_stmt|;
name|int
name|oldsave
init|=
name|savestack
operator|->
name|ary_fill
decl_stmt|;
name|int
name|oldtmps_base
init|=
name|tmps_base
decl_stmt|;
name|int
name|hasargs
init|=
operator|(
operator|(
name|arg
index|[
literal|2
index|]
operator|.
name|arg_type
operator|&
name|A_MASK
operator|)
operator|!=
name|A_NULL
operator|)
decl_stmt|;
specifier|register
name|CSV
modifier|*
name|csv
decl_stmt|;
if|if
condition|(
operator|(
name|arg
index|[
literal|1
index|]
operator|.
name|arg_type
operator|&
name|A_MASK
operator|)
operator|==
name|A_WORD
condition|)
name|stab
operator|=
name|arg
index|[
literal|1
index|]
operator|.
name|arg_ptr
operator|.
name|arg_stab
expr_stmt|;
else|else
block|{
name|STR
modifier|*
name|tmpstr
init|=
name|STAB_STR
argument_list|(
name|arg
index|[
literal|1
index|]
operator|.
name|arg_ptr
operator|.
name|arg_stab
argument_list|)
decl_stmt|;
if|if
condition|(
name|tmpstr
condition|)
name|stab
operator|=
name|stabent
argument_list|(
name|str_get
argument_list|(
name|tmpstr
argument_list|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
else|else
name|stab
operator|=
name|Nullstab
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|stab
condition|)
name|fatal
argument_list|(
literal|"Undefined subroutine called"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|sub
operator|=
name|stab_sub
argument_list|(
name|stab
argument_list|)
operator|)
condition|)
block|{
name|STR
modifier|*
name|tmpstr
init|=
name|arg
index|[
literal|0
index|]
operator|.
name|arg_ptr
operator|.
name|arg_str
decl_stmt|;
name|stab_efullname
argument_list|(
name|tmpstr
argument_list|,
name|stab
argument_list|)
expr_stmt|;
name|fatal
argument_list|(
literal|"Undefined subroutine \"%s\" called"
argument_list|,
name|tmpstr
operator|->
name|str_ptr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|arg
operator|->
name|arg_type
operator|==
name|O_DBSUBR
operator|&&
operator|!
name|sub
operator|->
name|usersub
condition|)
block|{
name|str
operator|=
name|stab_val
argument_list|(
name|DBsub
argument_list|)
expr_stmt|;
name|saveitem
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|stab_efullname
argument_list|(
name|str
argument_list|,
name|stab
argument_list|)
expr_stmt|;
name|sub
operator|=
name|stab_sub
argument_list|(
name|DBsub
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sub
condition|)
name|fatal
argument_list|(
literal|"No DBsub routine"
argument_list|)
expr_stmt|;
block|}
name|str
operator|=
name|Str_new
argument_list|(
literal|15
argument_list|,
sizeof|sizeof
argument_list|(
name|CSV
argument_list|)
argument_list|)
expr_stmt|;
name|str
operator|->
name|str_state
operator|=
name|SS_SCSV
expr_stmt|;
operator|(
name|void
operator|)
name|apush
argument_list|(
name|savestack
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|csv
operator|=
operator|(
name|CSV
operator|*
operator|)
name|str
operator|->
name|str_ptr
expr_stmt|;
name|csv
operator|->
name|sub
operator|=
name|sub
expr_stmt|;
name|csv
operator|->
name|stab
operator|=
name|stab
expr_stmt|;
name|csv
operator|->
name|curcsv
operator|=
name|curcsv
expr_stmt|;
name|csv
operator|->
name|curcmd
operator|=
name|curcmd
expr_stmt|;
name|csv
operator|->
name|depth
operator|=
name|sub
operator|->
name|depth
expr_stmt|;
name|csv
operator|->
name|wantarray
operator|=
name|gimme
expr_stmt|;
name|csv
operator|->
name|hasargs
operator|=
name|hasargs
expr_stmt|;
name|curcsv
operator|=
name|csv
expr_stmt|;
name|tmps_base
operator|=
name|tmps_max
expr_stmt|;
if|if
condition|(
name|sub
operator|->
name|usersub
condition|)
block|{
name|csv
operator|->
name|hasargs
operator|=
literal|0
expr_stmt|;
name|csv
operator|->
name|savearray
operator|=
name|Null
argument_list|(
name|ARRAY
operator|*
argument_list|)
expr_stmt|;
empty_stmt|;
name|csv
operator|->
name|argarray
operator|=
name|Null
argument_list|(
name|ARRAY
operator|*
argument_list|)
expr_stmt|;
name|st
index|[
name|sp
index|]
operator|=
name|arg
operator|->
name|arg_ptr
operator|.
name|arg_str
expr_stmt|;
if|if
condition|(
operator|!
name|hasargs
condition|)
name|items
operator|=
literal|0
expr_stmt|;
name|sp
operator|=
call|(
modifier|*
name|sub
operator|->
name|usersub
call|)
argument_list|(
name|sub
operator|->
name|userindex
argument_list|,
name|sp
argument_list|,
name|items
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|hasargs
condition|)
block|{
name|csv
operator|->
name|savearray
operator|=
name|stab_xarray
argument_list|(
name|defstab
argument_list|)
expr_stmt|;
name|csv
operator|->
name|argarray
operator|=
name|afake
argument_list|(
name|defstab
argument_list|,
name|items
argument_list|,
operator|&
name|st
index|[
name|sp
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
name|stab_xarray
argument_list|(
name|defstab
argument_list|)
operator|=
name|csv
operator|->
name|argarray
expr_stmt|;
block|}
name|sub
operator|->
name|depth
operator|++
expr_stmt|;
if|if
condition|(
name|sub
operator|->
name|depth
operator|>=
literal|2
condition|)
block|{
comment|/* save temporaries on recursion? */
if|if
condition|(
name|sub
operator|->
name|depth
operator|==
literal|100
operator|&&
name|dowarn
condition|)
name|warn
argument_list|(
literal|"Deep recursion on subroutine \"%s\""
argument_list|,
name|stab_ename
argument_list|(
name|stab
argument_list|)
argument_list|)
expr_stmt|;
name|savelist
argument_list|(
name|sub
operator|->
name|tosave
operator|->
name|ary_array
argument_list|,
name|sub
operator|->
name|tosave
operator|->
name|ary_fill
argument_list|)
expr_stmt|;
block|}
name|sp
operator|=
name|cmd_exec
argument_list|(
name|sub
operator|->
name|cmd
argument_list|,
name|gimme
argument_list|,
operator|--
name|sp
argument_list|)
expr_stmt|;
comment|/* so do it already */
block|}
name|st
operator|=
name|stack
operator|->
name|ary_array
expr_stmt|;
name|tmps_base
operator|=
name|oldtmps_base
expr_stmt|;
for|for
control|(
name|items
operator|=
name|arglast
index|[
literal|0
index|]
operator|+
literal|1
init|;
name|items
operator|<=
name|sp
condition|;
name|items
operator|++
control|)
name|st
index|[
name|items
index|]
operator|=
name|str_mortal
argument_list|(
name|st
index|[
name|items
index|]
argument_list|)
expr_stmt|;
comment|/* in case restore wipes old str */
name|restorelist
argument_list|(
name|oldsave
argument_list|)
expr_stmt|;
name|curspat
operator|=
name|oldspat
expr_stmt|;
return|return
name|sp
return|;
block|}
end_function

begin_function
name|int
name|do_assign
parameter_list|(
name|arg
parameter_list|,
name|gimme
parameter_list|,
name|arglast
parameter_list|)
specifier|register
name|ARG
modifier|*
name|arg
decl_stmt|;
name|int
name|gimme
decl_stmt|;
name|int
modifier|*
name|arglast
decl_stmt|;
block|{
specifier|register
name|STR
modifier|*
modifier|*
name|st
init|=
name|stack
operator|->
name|ary_array
decl_stmt|;
name|STR
modifier|*
modifier|*
name|firstrelem
init|=
name|st
operator|+
name|arglast
index|[
literal|1
index|]
operator|+
literal|1
decl_stmt|;
name|STR
modifier|*
modifier|*
name|firstlelem
init|=
name|st
operator|+
name|arglast
index|[
literal|0
index|]
operator|+
literal|1
decl_stmt|;
name|STR
modifier|*
modifier|*
name|lastrelem
init|=
name|st
operator|+
name|arglast
index|[
literal|2
index|]
decl_stmt|;
name|STR
modifier|*
modifier|*
name|lastlelem
init|=
name|st
operator|+
name|arglast
index|[
literal|1
index|]
decl_stmt|;
specifier|register
name|STR
modifier|*
modifier|*
name|relem
decl_stmt|;
specifier|register
name|STR
modifier|*
modifier|*
name|lelem
decl_stmt|;
specifier|register
name|STR
modifier|*
name|str
decl_stmt|;
specifier|register
name|ARRAY
modifier|*
name|ary
decl_stmt|;
specifier|register
name|int
name|makelocal
decl_stmt|;
name|HASH
modifier|*
name|hash
decl_stmt|;
name|int
name|i
decl_stmt|;
name|makelocal
operator|=
operator|(
name|arg
operator|->
name|arg_flags
operator|&
name|AF_LOCAL
operator|)
operator|!=
literal|0
expr_stmt|;
name|localizing
operator|=
name|makelocal
expr_stmt|;
name|delaymagic
operator|=
name|DM_DELAY
expr_stmt|;
comment|/* catch simultaneous items */
comment|/* If there's a common identifier on both sides we have to take      * special care that assigning the identifier on the left doesn't      * clobber a value on the right that's used later in the list.      */
if|if
condition|(
name|arg
operator|->
name|arg_flags
operator|&
name|AF_COMMON
condition|)
block|{
for|for
control|(
name|relem
operator|=
name|firstrelem
init|;
name|relem
operator|<=
name|lastrelem
condition|;
name|relem
operator|++
control|)
block|{
comment|/*SUPPRESS 560*/
if|if
condition|(
name|str
operator|=
operator|*
name|relem
condition|)
operator|*
name|relem
operator|=
name|str_mortal
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
block|}
name|relem
operator|=
name|firstrelem
expr_stmt|;
name|lelem
operator|=
name|firstlelem
expr_stmt|;
name|ary
operator|=
name|Null
argument_list|(
name|ARRAY
operator|*
argument_list|)
expr_stmt|;
name|hash
operator|=
name|Null
argument_list|(
name|HASH
operator|*
argument_list|)
expr_stmt|;
while|while
condition|(
name|lelem
operator|<=
name|lastlelem
condition|)
block|{
name|str
operator|=
operator|*
name|lelem
operator|++
expr_stmt|;
if|if
condition|(
name|str
operator|->
name|str_state
operator|>=
name|SS_HASH
condition|)
block|{
if|if
condition|(
name|str
operator|->
name|str_state
operator|==
name|SS_ARY
condition|)
block|{
if|if
condition|(
name|makelocal
condition|)
name|ary
operator|=
name|saveary
argument_list|(
name|str
operator|->
name|str_u
operator|.
name|str_stab
argument_list|)
expr_stmt|;
else|else
block|{
name|ary
operator|=
name|stab_array
argument_list|(
name|str
operator|->
name|str_u
operator|.
name|str_stab
argument_list|)
expr_stmt|;
name|ary
operator|->
name|ary_fill
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|relem
operator|<=
name|lastrelem
condition|)
block|{
comment|/* gobble up all the rest */
name|str
operator|=
name|Str_new
argument_list|(
literal|28
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|relem
condition|)
name|str_sset
argument_list|(
name|str
argument_list|,
operator|*
name|relem
argument_list|)
expr_stmt|;
operator|*
operator|(
name|relem
operator|++
operator|)
operator|=
name|str
expr_stmt|;
operator|(
name|void
operator|)
name|astore
argument_list|(
name|ary
argument_list|,
name|i
operator|++
argument_list|,
name|str
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|str
operator|->
name|str_state
operator|==
name|SS_HASH
condition|)
block|{
name|char
modifier|*
name|tmps
decl_stmt|;
name|STR
modifier|*
name|tmpstr
decl_stmt|;
name|int
name|magic
init|=
literal|0
decl_stmt|;
name|STAB
modifier|*
name|tmpstab
init|=
name|str
operator|->
name|str_u
operator|.
name|str_stab
decl_stmt|;
if|if
condition|(
name|makelocal
condition|)
name|hash
operator|=
name|savehash
argument_list|(
name|str
operator|->
name|str_u
operator|.
name|str_stab
argument_list|)
expr_stmt|;
else|else
block|{
name|hash
operator|=
name|stab_hash
argument_list|(
name|str
operator|->
name|str_u
operator|.
name|str_stab
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmpstab
operator|==
name|envstab
condition|)
block|{
name|magic
operator|=
literal|'E'
expr_stmt|;
name|environ
index|[
literal|0
index|]
operator|=
name|Nullch
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tmpstab
operator|==
name|sigstab
condition|)
block|{
name|magic
operator|=
literal|'S'
expr_stmt|;
ifndef|#
directive|ifndef
name|NSIG
define|#
directive|define
name|NSIG
value|32
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|NSIG
condition|;
name|i
operator|++
control|)
name|signal
argument_list|(
name|i
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
comment|/* crunch, crunch, crunch */
block|}
ifdef|#
directive|ifdef
name|SOME_DBM
elseif|else
if|if
condition|(
name|hash
operator|->
name|tbl_dbm
condition|)
name|magic
operator|=
literal|'D'
expr_stmt|;
endif|#
directive|endif
name|hclear
argument_list|(
name|hash
argument_list|,
name|magic
operator|==
literal|'D'
argument_list|)
expr_stmt|;
comment|/* wipe any dbm file too */
block|}
while|while
condition|(
name|relem
operator|<
name|lastrelem
condition|)
block|{
comment|/* gobble up all the rest */
if|if
condition|(
operator|*
name|relem
condition|)
name|str
operator|=
operator|*
operator|(
name|relem
operator|++
operator|)
expr_stmt|;
else|else
name|str
operator|=
operator|&
name|str_no
operator|,
name|relem
operator|++
expr_stmt|;
name|tmps
operator|=
name|str_get
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|tmpstr
operator|=
name|Str_new
argument_list|(
literal|29
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|relem
condition|)
name|str_sset
argument_list|(
name|tmpstr
argument_list|,
operator|*
name|relem
argument_list|)
expr_stmt|;
comment|/* value */
operator|*
operator|(
name|relem
operator|++
operator|)
operator|=
name|tmpstr
expr_stmt|;
operator|(
name|void
operator|)
name|hstore
argument_list|(
name|hash
argument_list|,
name|tmps
argument_list|,
name|str
operator|->
name|str_cur
argument_list|,
name|tmpstr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|magic
condition|)
block|{
name|str_magic
argument_list|(
name|tmpstr
argument_list|,
name|tmpstab
argument_list|,
name|magic
argument_list|,
name|tmps
argument_list|,
name|str
operator|->
name|str_cur
argument_list|)
expr_stmt|;
name|stabset
argument_list|(
name|tmpstr
operator|->
name|str_magic
argument_list|,
name|tmpstr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
name|fatal
argument_list|(
literal|"panic: do_assign"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|makelocal
condition|)
name|saveitem
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|relem
operator|<=
name|lastrelem
condition|)
block|{
name|str_sset
argument_list|(
name|str
argument_list|,
operator|*
name|relem
argument_list|)
expr_stmt|;
operator|*
operator|(
name|relem
operator|++
operator|)
operator|=
name|str
expr_stmt|;
block|}
else|else
block|{
name|str_sset
argument_list|(
name|str
argument_list|,
operator|&
name|str_undef
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimme
operator|==
name|G_ARRAY
condition|)
block|{
name|i
operator|=
operator|++
name|lastrelem
operator|-
name|firstrelem
expr_stmt|;
name|relem
operator|++
expr_stmt|;
comment|/* tacky, I suppose */
name|astore
argument_list|(
name|stack
argument_list|,
name|i
argument_list|,
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|st
operator|!=
name|stack
operator|->
name|ary_array
condition|)
block|{
name|st
operator|=
name|stack
operator|->
name|ary_array
expr_stmt|;
name|firstrelem
operator|=
name|st
operator|+
name|arglast
index|[
literal|1
index|]
operator|+
literal|1
expr_stmt|;
name|firstlelem
operator|=
name|st
operator|+
name|arglast
index|[
literal|0
index|]
operator|+
literal|1
expr_stmt|;
name|lastlelem
operator|=
name|st
operator|+
name|arglast
index|[
literal|1
index|]
expr_stmt|;
name|lastrelem
operator|=
name|st
operator|+
name|i
expr_stmt|;
name|relem
operator|=
name|lastrelem
operator|+
literal|1
expr_stmt|;
block|}
block|}
block|}
name|STABSET
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|delaymagic
operator|&
operator|~
name|DM_DELAY
condition|)
block|{
if|if
condition|(
name|delaymagic
operator|&
name|DM_UID
condition|)
block|{
ifdef|#
directive|ifdef
name|HAS_SETREUID
operator|(
name|void
operator|)
name|setreuid
argument_list|(
name|uid
argument_list|,
name|euid
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* not HAS_SETREUID */
ifdef|#
directive|ifdef
name|HAS_SETRUID
if|if
condition|(
operator|(
name|delaymagic
operator|&
name|DM_UID
operator|)
operator|==
name|DM_RUID
condition|)
block|{
operator|(
name|void
operator|)
name|setruid
argument_list|(
name|uid
argument_list|)
expr_stmt|;
name|delaymagic
operator|=
operator|~
name|DM_RUID
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* HAS_SETRUID */
ifdef|#
directive|ifdef
name|HAS_SETEUID
if|if
condition|(
operator|(
name|delaymagic
operator|&
name|DM_UID
operator|)
operator|==
name|DM_EUID
condition|)
block|{
operator|(
name|void
operator|)
name|seteuid
argument_list|(
name|uid
argument_list|)
expr_stmt|;
name|delaymagic
operator|=
operator|~
name|DM_EUID
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* HAS_SETEUID */
if|if
condition|(
name|delaymagic
operator|&
name|DM_UID
condition|)
block|{
if|if
condition|(
name|uid
operator|!=
name|euid
condition|)
name|fatal
argument_list|(
literal|"No setreuid available"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|setuid
argument_list|(
name|uid
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* not HAS_SETREUID */
name|uid
operator|=
operator|(
name|int
operator|)
name|getuid
argument_list|()
expr_stmt|;
name|euid
operator|=
operator|(
name|int
operator|)
name|geteuid
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|delaymagic
operator|&
name|DM_GID
condition|)
block|{
ifdef|#
directive|ifdef
name|HAS_SETREGID
operator|(
name|void
operator|)
name|setregid
argument_list|(
name|gid
argument_list|,
name|egid
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* not HAS_SETREGID */
ifdef|#
directive|ifdef
name|HAS_SETRGID
if|if
condition|(
operator|(
name|delaymagic
operator|&
name|DM_GID
operator|)
operator|==
name|DM_RGID
condition|)
block|{
operator|(
name|void
operator|)
name|setrgid
argument_list|(
name|gid
argument_list|)
expr_stmt|;
name|delaymagic
operator|=
operator|~
name|DM_RGID
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* HAS_SETRGID */
ifdef|#
directive|ifdef
name|HAS_SETEGID
if|if
condition|(
operator|(
name|delaymagic
operator|&
name|DM_GID
operator|)
operator|==
name|DM_EGID
condition|)
block|{
operator|(
name|void
operator|)
name|setegid
argument_list|(
name|gid
argument_list|)
expr_stmt|;
name|delaymagic
operator|=
operator|~
name|DM_EGID
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* HAS_SETEGID */
if|if
condition|(
name|delaymagic
operator|&
name|DM_GID
condition|)
block|{
if|if
condition|(
name|gid
operator|!=
name|egid
condition|)
name|fatal
argument_list|(
literal|"No setregid available"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|setgid
argument_list|(
name|gid
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* not HAS_SETREGID */
name|gid
operator|=
operator|(
name|int
operator|)
name|getgid
argument_list|()
expr_stmt|;
name|egid
operator|=
operator|(
name|int
operator|)
name|getegid
argument_list|()
expr_stmt|;
block|}
block|}
name|delaymagic
operator|=
literal|0
expr_stmt|;
name|localizing
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|gimme
operator|==
name|G_ARRAY
condition|)
block|{
name|i
operator|=
name|lastrelem
operator|-
name|firstrelem
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|ary
operator|||
name|hash
condition|)
name|Copy
argument_list|(
name|firstrelem
argument_list|,
name|firstlelem
argument_list|,
name|i
argument_list|,
name|STR
operator|*
argument_list|)
expr_stmt|;
return|return
name|arglast
index|[
literal|0
index|]
operator|+
name|i
return|;
block|}
else|else
block|{
name|str_numset
argument_list|(
name|arg
operator|->
name|arg_ptr
operator|.
name|arg_str
argument_list|,
call|(
name|double
call|)
argument_list|(
name|arglast
index|[
literal|2
index|]
operator|-
name|arglast
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|firstlelem
operator|=
name|arg
operator|->
name|arg_ptr
operator|.
name|arg_str
expr_stmt|;
return|return
name|arglast
index|[
literal|0
index|]
operator|+
literal|1
return|;
block|}
block|}
end_function

begin_function
name|int
comment|/*SUPPRESS 590*/
name|do_study
parameter_list|(
name|str
parameter_list|,
name|arg
parameter_list|,
name|gimme
parameter_list|,
name|arglast
parameter_list|)
name|STR
modifier|*
name|str
decl_stmt|;
name|ARG
modifier|*
name|arg
decl_stmt|;
name|int
name|gimme
decl_stmt|;
name|int
modifier|*
name|arglast
decl_stmt|;
block|{
specifier|register
name|unsigned
name|char
modifier|*
name|s
decl_stmt|;
specifier|register
name|int
name|pos
init|=
name|str
operator|->
name|str_cur
decl_stmt|;
specifier|register
name|int
name|ch
decl_stmt|;
specifier|register
name|int
modifier|*
name|sfirst
decl_stmt|;
specifier|register
name|int
modifier|*
name|snext
decl_stmt|;
specifier|static
name|int
name|maxscream
init|=
operator|-
literal|1
decl_stmt|;
specifier|static
name|STR
modifier|*
name|lastscream
init|=
name|Nullstr
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|int
name|retarg
init|=
name|arglast
index|[
literal|0
index|]
operator|+
literal|1
decl_stmt|;
ifndef|#
directive|ifndef
name|lint
name|s
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|(
name|str_get
argument_list|(
name|str
argument_list|)
operator|)
expr_stmt|;
else|#
directive|else
name|s
operator|=
name|Null
argument_list|(
argument|unsigned char*
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|lastscream
condition|)
name|lastscream
operator|->
name|str_pok
operator|&=
operator|~
name|SP_STUDIED
expr_stmt|;
name|lastscream
operator|=
name|str
expr_stmt|;
if|if
condition|(
name|pos
operator|<=
literal|0
condition|)
block|{
name|retval
operator|=
literal|0
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
if|if
condition|(
name|pos
operator|>
name|maxscream
condition|)
block|{
if|if
condition|(
name|maxscream
operator|<
literal|0
condition|)
block|{
name|maxscream
operator|=
name|pos
operator|+
literal|80
expr_stmt|;
name|New
argument_list|(
literal|301
argument_list|,
name|screamfirst
argument_list|,
literal|256
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|New
argument_list|(
literal|302
argument_list|,
name|screamnext
argument_list|,
name|maxscream
argument_list|,
name|int
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|maxscream
operator|=
name|pos
operator|+
name|pos
operator|/
literal|4
expr_stmt|;
name|Renew
argument_list|(
name|screamnext
argument_list|,
name|maxscream
argument_list|,
name|int
argument_list|)
expr_stmt|;
block|}
block|}
name|sfirst
operator|=
name|screamfirst
expr_stmt|;
name|snext
operator|=
name|screamnext
expr_stmt|;
if|if
condition|(
operator|!
name|sfirst
operator|||
operator|!
name|snext
condition|)
name|fatal
argument_list|(
literal|"do_study: out of memory"
argument_list|)
expr_stmt|;
for|for
control|(
name|ch
operator|=
literal|256
init|;
name|ch
condition|;
operator|--
name|ch
control|)
operator|*
name|sfirst
operator|++
operator|=
operator|-
literal|1
expr_stmt|;
name|sfirst
operator|-=
literal|256
expr_stmt|;
while|while
condition|(
operator|--
name|pos
operator|>=
literal|0
condition|)
block|{
name|ch
operator|=
name|s
index|[
name|pos
index|]
expr_stmt|;
if|if
condition|(
name|sfirst
index|[
name|ch
index|]
operator|>=
literal|0
condition|)
name|snext
index|[
name|pos
index|]
operator|=
name|sfirst
index|[
name|ch
index|]
operator|-
name|pos
expr_stmt|;
else|else
name|snext
index|[
name|pos
index|]
operator|=
operator|-
name|pos
expr_stmt|;
name|sfirst
index|[
name|ch
index|]
operator|=
name|pos
expr_stmt|;
comment|/* If there were any case insensitive searches, we must assume they 	 * all are.  This speeds up insensitive searches much more than 	 * it slows down sensitive ones. 	 */
if|if
condition|(
name|sawi
condition|)
name|sfirst
index|[
name|fold
index|[
name|ch
index|]
index|]
operator|=
name|pos
expr_stmt|;
block|}
name|str
operator|->
name|str_pok
operator||=
name|SP_STUDIED
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
name|ret
label|:
name|str_numset
argument_list|(
name|arg
operator|->
name|arg_ptr
operator|.
name|arg_str
argument_list|,
operator|(
name|double
operator|)
name|retval
argument_list|)
expr_stmt|;
name|stack
operator|->
name|ary_array
index|[
name|retarg
index|]
operator|=
name|arg
operator|->
name|arg_ptr
operator|.
name|arg_str
expr_stmt|;
return|return
name|retarg
return|;
block|}
end_function

begin_function
name|int
comment|/*SUPPRESS 590*/
name|do_defined
parameter_list|(
name|str
parameter_list|,
name|arg
parameter_list|,
name|gimme
parameter_list|,
name|arglast
parameter_list|)
name|STR
modifier|*
name|str
decl_stmt|;
specifier|register
name|ARG
modifier|*
name|arg
decl_stmt|;
name|int
name|gimme
decl_stmt|;
name|int
modifier|*
name|arglast
decl_stmt|;
block|{
specifier|register
name|int
name|type
decl_stmt|;
specifier|register
name|int
name|retarg
init|=
name|arglast
index|[
literal|0
index|]
operator|+
literal|1
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|ARRAY
modifier|*
name|ary
decl_stmt|;
name|HASH
modifier|*
name|hash
decl_stmt|;
if|if
condition|(
operator|(
name|arg
index|[
literal|1
index|]
operator|.
name|arg_type
operator|&
name|A_MASK
operator|)
operator|!=
name|A_LEXPR
condition|)
name|fatal
argument_list|(
literal|"Illegal argument to defined()"
argument_list|)
expr_stmt|;
name|arg
operator|=
name|arg
index|[
literal|1
index|]
operator|.
name|arg_ptr
operator|.
name|arg_arg
expr_stmt|;
name|type
operator|=
name|arg
operator|->
name|arg_type
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|O_SUBR
operator|||
name|type
operator|==
name|O_DBSUBR
condition|)
block|{
if|if
condition|(
operator|(
name|arg
index|[
literal|1
index|]
operator|.
name|arg_type
operator|&
name|A_MASK
operator|)
operator|==
name|A_WORD
condition|)
name|retval
operator|=
name|stab_sub
argument_list|(
name|arg
index|[
literal|1
index|]
operator|.
name|arg_ptr
operator|.
name|arg_stab
argument_list|)
operator|!=
literal|0
expr_stmt|;
else|else
block|{
name|STR
modifier|*
name|tmpstr
init|=
name|STAB_STR
argument_list|(
name|arg
index|[
literal|1
index|]
operator|.
name|arg_ptr
operator|.
name|arg_stab
argument_list|)
decl_stmt|;
name|retval
operator|=
name|tmpstr
operator|&&
name|stab_sub
argument_list|(
name|stabent
argument_list|(
name|str_get
argument_list|(
name|tmpstr
argument_list|)
argument_list|,
name|TRUE
argument_list|)
argument_list|)
operator|!=
literal|0
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|O_ARRAY
operator|||
name|type
operator|==
name|O_LARRAY
operator|||
name|type
operator|==
name|O_ASLICE
operator|||
name|type
operator|==
name|O_LASLICE
condition|)
name|retval
operator|=
operator|(
operator|(
name|ary
operator|=
name|stab_xarray
argument_list|(
name|arg
index|[
literal|1
index|]
operator|.
name|arg_ptr
operator|.
name|arg_stab
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|ary
operator|->
name|ary_max
operator|>=
literal|0
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
name|O_HASH
operator|||
name|type
operator|==
name|O_LHASH
operator|||
name|type
operator|==
name|O_HSLICE
operator|||
name|type
operator|==
name|O_LHSLICE
condition|)
name|retval
operator|=
operator|(
operator|(
name|hash
operator|=
name|stab_xhash
argument_list|(
name|arg
index|[
literal|1
index|]
operator|.
name|arg_ptr
operator|.
name|arg_stab
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|hash
operator|->
name|tbl_array
operator|)
expr_stmt|;
else|else
name|retval
operator|=
name|FALSE
expr_stmt|;
name|str_numset
argument_list|(
name|str
argument_list|,
operator|(
name|double
operator|)
name|retval
argument_list|)
expr_stmt|;
name|stack
operator|->
name|ary_array
index|[
name|retarg
index|]
operator|=
name|str
expr_stmt|;
return|return
name|retarg
return|;
block|}
end_function

begin_function
name|int
comment|/*SUPPRESS 590*/
name|do_undef
parameter_list|(
name|str
parameter_list|,
name|arg
parameter_list|,
name|gimme
parameter_list|,
name|arglast
parameter_list|)
name|STR
modifier|*
name|str
decl_stmt|;
specifier|register
name|ARG
modifier|*
name|arg
decl_stmt|;
name|int
name|gimme
decl_stmt|;
name|int
modifier|*
name|arglast
decl_stmt|;
block|{
specifier|register
name|int
name|type
decl_stmt|;
specifier|register
name|STAB
modifier|*
name|stab
decl_stmt|;
name|int
name|retarg
init|=
name|arglast
index|[
literal|0
index|]
operator|+
literal|1
decl_stmt|;
if|if
condition|(
operator|(
name|arg
index|[
literal|1
index|]
operator|.
name|arg_type
operator|&
name|A_MASK
operator|)
operator|!=
name|A_LEXPR
condition|)
name|fatal
argument_list|(
literal|"Illegal argument to undef()"
argument_list|)
expr_stmt|;
name|arg
operator|=
name|arg
index|[
literal|1
index|]
operator|.
name|arg_ptr
operator|.
name|arg_arg
expr_stmt|;
name|type
operator|=
name|arg
operator|->
name|arg_type
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|O_ARRAY
operator|||
name|type
operator|==
name|O_LARRAY
condition|)
block|{
name|stab
operator|=
name|arg
index|[
literal|1
index|]
operator|.
name|arg_ptr
operator|.
name|arg_stab
expr_stmt|;
name|afree
argument_list|(
name|stab_xarray
argument_list|(
name|stab
argument_list|)
argument_list|)
expr_stmt|;
name|stab_xarray
argument_list|(
name|stab
argument_list|)
operator|=
name|anew
argument_list|(
name|stab
argument_list|)
expr_stmt|;
comment|/* so "@array" still works */
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|O_HASH
operator|||
name|type
operator|==
name|O_LHASH
condition|)
block|{
name|stab
operator|=
name|arg
index|[
literal|1
index|]
operator|.
name|arg_ptr
operator|.
name|arg_stab
expr_stmt|;
if|if
condition|(
name|stab
operator|==
name|envstab
condition|)
name|environ
index|[
literal|0
index|]
operator|=
name|Nullch
expr_stmt|;
elseif|else
if|if
condition|(
name|stab
operator|==
name|sigstab
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|NSIG
condition|;
name|i
operator|++
control|)
name|signal
argument_list|(
name|i
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
comment|/* munch, munch, munch */
block|}
operator|(
name|void
operator|)
name|hfree
argument_list|(
name|stab_xhash
argument_list|(
name|stab
argument_list|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|stab_xhash
argument_list|(
name|stab
argument_list|)
operator|=
name|Null
argument_list|(
name|HASH
operator|*
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|O_SUBR
operator|||
name|type
operator|==
name|O_DBSUBR
condition|)
block|{
name|stab
operator|=
name|arg
index|[
literal|1
index|]
operator|.
name|arg_ptr
operator|.
name|arg_stab
expr_stmt|;
if|if
condition|(
operator|(
name|arg
index|[
literal|1
index|]
operator|.
name|arg_type
operator|&
name|A_MASK
operator|)
operator|!=
name|A_WORD
condition|)
block|{
name|STR
modifier|*
name|tmpstr
init|=
name|STAB_STR
argument_list|(
name|arg
index|[
literal|1
index|]
operator|.
name|arg_ptr
operator|.
name|arg_stab
argument_list|)
decl_stmt|;
if|if
condition|(
name|tmpstr
condition|)
name|stab
operator|=
name|stabent
argument_list|(
name|str_get
argument_list|(
name|tmpstr
argument_list|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
else|else
name|stab
operator|=
name|Nullstab
expr_stmt|;
block|}
if|if
condition|(
name|stab
operator|&&
name|stab_sub
argument_list|(
name|stab
argument_list|)
condition|)
block|{
name|cmd_free
argument_list|(
name|stab_sub
argument_list|(
name|stab
argument_list|)
operator|->
name|cmd
argument_list|)
expr_stmt|;
name|stab_sub
argument_list|(
name|stab
argument_list|)
operator|->
name|cmd
operator|=
name|Nullcmd
expr_stmt|;
name|afree
argument_list|(
name|stab_sub
argument_list|(
name|stab
argument_list|)
operator|->
name|tosave
argument_list|)
expr_stmt|;
name|Safefree
argument_list|(
name|stab_sub
argument_list|(
name|stab
argument_list|)
argument_list|)
expr_stmt|;
name|stab_sub
argument_list|(
name|stab
argument_list|)
operator|=
name|Null
argument_list|(
name|SUBR
operator|*
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|fatal
argument_list|(
literal|"Can't undefine that kind of object"
argument_list|)
expr_stmt|;
name|str_numset
argument_list|(
name|str
argument_list|,
literal|0.0
argument_list|)
expr_stmt|;
name|stack
operator|->
name|ary_array
index|[
name|retarg
index|]
operator|=
name|str
expr_stmt|;
return|return
name|retarg
return|;
block|}
end_function

begin_function
name|int
name|do_vec
parameter_list|(
name|lvalue
parameter_list|,
name|astr
parameter_list|,
name|arglast
parameter_list|)
name|int
name|lvalue
decl_stmt|;
name|STR
modifier|*
name|astr
decl_stmt|;
name|int
modifier|*
name|arglast
decl_stmt|;
block|{
name|STR
modifier|*
modifier|*
name|st
init|=
name|stack
operator|->
name|ary_array
decl_stmt|;
name|int
name|sp
init|=
name|arglast
index|[
literal|0
index|]
decl_stmt|;
specifier|register
name|STR
modifier|*
name|str
init|=
name|st
index|[
operator|++
name|sp
index|]
decl_stmt|;
specifier|register
name|int
name|offset
init|=
operator|(
name|int
operator|)
name|str_gnum
argument_list|(
name|st
index|[
operator|++
name|sp
index|]
argument_list|)
decl_stmt|;
specifier|register
name|int
name|size
init|=
operator|(
name|int
operator|)
name|str_gnum
argument_list|(
name|st
index|[
operator|++
name|sp
index|]
argument_list|)
decl_stmt|;
name|unsigned
name|char
modifier|*
name|s
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|str_get
argument_list|(
name|str
argument_list|)
decl_stmt|;
name|unsigned
name|long
name|retnum
decl_stmt|;
name|int
name|len
decl_stmt|;
name|sp
operator|=
name|arglast
index|[
literal|1
index|]
expr_stmt|;
name|offset
operator|*=
name|size
expr_stmt|;
comment|/* turn into bit offset */
name|len
operator|=
operator|(
name|offset
operator|+
name|size
operator|+
literal|7
operator|)
operator|/
literal|8
expr_stmt|;
if|if
condition|(
name|offset
operator|<
literal|0
operator|||
name|size
operator|<
literal|1
condition|)
name|retnum
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|lvalue
operator|&&
name|len
operator|>
name|str
operator|->
name|str_cur
condition|)
name|retnum
operator|=
literal|0
expr_stmt|;
else|else
block|{
if|if
condition|(
name|len
operator|>
name|str
operator|->
name|str_cur
condition|)
block|{
name|STR_GROW
argument_list|(
name|str
argument_list|,
name|len
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|memzero
argument_list|(
name|str
operator|->
name|str_ptr
operator|+
name|str
operator|->
name|str_cur
argument_list|,
name|len
operator|-
name|str
operator|->
name|str_cur
argument_list|)
expr_stmt|;
name|str
operator|->
name|str_cur
operator|=
name|len
expr_stmt|;
block|}
name|s
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|str_get
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|<
literal|8
condition|)
name|retnum
operator|=
operator|(
name|s
index|[
name|offset
operator|>>
literal|3
index|]
operator|>>
operator|(
name|offset
operator|&
literal|7
operator|)
operator|)
operator|&
operator|(
operator|(
literal|1
operator|<<
name|size
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
else|else
block|{
name|offset
operator|>>=
literal|3
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|8
condition|)
name|retnum
operator|=
name|s
index|[
name|offset
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|size
operator|==
literal|16
condition|)
name|retnum
operator|=
operator|(
operator|(
name|unsigned
name|long
operator|)
name|s
index|[
name|offset
index|]
operator|<<
literal|8
operator|)
operator|+
name|s
index|[
name|offset
operator|+
literal|1
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|size
operator|==
literal|32
condition|)
name|retnum
operator|=
operator|(
operator|(
name|unsigned
name|long
operator|)
name|s
index|[
name|offset
index|]
operator|<<
literal|24
operator|)
operator|+
operator|(
operator|(
name|unsigned
name|long
operator|)
name|s
index|[
name|offset
operator|+
literal|1
index|]
operator|<<
literal|16
operator|)
operator|+
operator|(
name|s
index|[
name|offset
operator|+
literal|2
index|]
operator|<<
literal|8
operator|)
operator|+
name|s
index|[
name|offset
operator|+
literal|3
index|]
expr_stmt|;
block|}
if|if
condition|(
name|lvalue
condition|)
block|{
comment|/* it's an lvalue! */
name|struct
name|lstring
modifier|*
name|lstr
init|=
operator|(
expr|struct
name|lstring
operator|*
operator|)
name|astr
decl_stmt|;
name|astr
operator|->
name|str_magic
operator|=
name|str
expr_stmt|;
name|st
index|[
name|sp
index|]
operator|->
name|str_rare
operator|=
literal|'v'
expr_stmt|;
name|lstr
operator|->
name|lstr_offset
operator|=
name|offset
expr_stmt|;
name|lstr
operator|->
name|lstr_len
operator|=
name|size
expr_stmt|;
block|}
block|}
name|str_numset
argument_list|(
name|astr
argument_list|,
operator|(
name|double
operator|)
name|retnum
argument_list|)
expr_stmt|;
name|st
index|[
name|sp
index|]
operator|=
name|astr
expr_stmt|;
return|return
name|sp
return|;
block|}
end_function

begin_function
name|void
name|do_vecset
parameter_list|(
name|mstr
parameter_list|,
name|str
parameter_list|)
name|STR
modifier|*
name|mstr
decl_stmt|;
name|STR
modifier|*
name|str
decl_stmt|;
block|{
name|struct
name|lstring
modifier|*
name|lstr
init|=
operator|(
expr|struct
name|lstring
operator|*
operator|)
name|str
decl_stmt|;
specifier|register
name|int
name|offset
decl_stmt|;
specifier|register
name|int
name|size
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|s
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|mstr
operator|->
name|str_ptr
decl_stmt|;
specifier|register
name|unsigned
name|long
name|lval
init|=
name|U_L
argument_list|(
name|str_gnum
argument_list|(
name|str
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|mask
decl_stmt|;
name|mstr
operator|->
name|str_rare
operator|=
literal|0
expr_stmt|;
name|str
operator|->
name|str_magic
operator|=
name|Nullstr
expr_stmt|;
name|offset
operator|=
name|lstr
operator|->
name|lstr_offset
expr_stmt|;
name|size
operator|=
name|lstr
operator|->
name|lstr_len
expr_stmt|;
if|if
condition|(
name|size
operator|<
literal|8
condition|)
block|{
name|mask
operator|=
operator|(
literal|1
operator|<<
name|size
operator|)
operator|-
literal|1
expr_stmt|;
name|size
operator|=
name|offset
operator|&
literal|7
expr_stmt|;
name|lval
operator|&=
name|mask
expr_stmt|;
name|offset
operator|>>=
literal|3
expr_stmt|;
name|s
index|[
name|offset
index|]
operator|&=
operator|~
operator|(
name|mask
operator|<<
name|size
operator|)
expr_stmt|;
name|s
index|[
name|offset
index|]
operator||=
name|lval
operator|<<
name|size
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|size
operator|==
literal|8
condition|)
name|s
index|[
name|offset
index|]
operator|=
name|lval
operator|&
literal|255
expr_stmt|;
elseif|else
if|if
condition|(
name|size
operator|==
literal|16
condition|)
block|{
name|s
index|[
name|offset
index|]
operator|=
operator|(
name|lval
operator|>>
literal|8
operator|)
operator|&
literal|255
expr_stmt|;
name|s
index|[
name|offset
operator|+
literal|1
index|]
operator|=
name|lval
operator|&
literal|255
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|size
operator|==
literal|32
condition|)
block|{
name|s
index|[
name|offset
index|]
operator|=
operator|(
name|lval
operator|>>
literal|24
operator|)
operator|&
literal|255
expr_stmt|;
name|s
index|[
name|offset
operator|+
literal|1
index|]
operator|=
operator|(
name|lval
operator|>>
literal|16
operator|)
operator|&
literal|255
expr_stmt|;
name|s
index|[
name|offset
operator|+
literal|2
index|]
operator|=
operator|(
name|lval
operator|>>
literal|8
operator|)
operator|&
literal|255
expr_stmt|;
name|s
index|[
name|offset
operator|+
literal|3
index|]
operator|=
name|lval
operator|&
literal|255
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|do_chop
parameter_list|(
name|astr
parameter_list|,
name|str
parameter_list|)
specifier|register
name|STR
modifier|*
name|astr
decl_stmt|;
specifier|register
name|STR
modifier|*
name|str
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|tmps
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|ARRAY
modifier|*
name|ary
decl_stmt|;
name|HASH
modifier|*
name|hash
decl_stmt|;
name|HENT
modifier|*
name|entry
decl_stmt|;
if|if
condition|(
operator|!
name|str
condition|)
return|return;
if|if
condition|(
name|str
operator|->
name|str_state
operator|==
name|SS_ARY
condition|)
block|{
name|ary
operator|=
name|stab_array
argument_list|(
name|str
operator|->
name|str_u
operator|.
name|str_stab
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|ary
operator|->
name|ary_fill
condition|;
name|i
operator|++
control|)
name|do_chop
argument_list|(
name|astr
argument_list|,
name|ary
operator|->
name|ary_array
index|[
name|i
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|str
operator|->
name|str_state
operator|==
name|SS_HASH
condition|)
block|{
name|hash
operator|=
name|stab_hash
argument_list|(
name|str
operator|->
name|str_u
operator|.
name|str_stab
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|hiterinit
argument_list|(
name|hash
argument_list|)
expr_stmt|;
comment|/*SUPPRESS 560*/
while|while
condition|(
name|entry
operator|=
name|hiternext
argument_list|(
name|hash
argument_list|)
condition|)
name|do_chop
argument_list|(
name|astr
argument_list|,
name|hiterval
argument_list|(
name|hash
argument_list|,
name|entry
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|tmps
operator|=
name|str_get
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmps
operator|&&
name|str
operator|->
name|str_cur
condition|)
block|{
name|tmps
operator|+=
name|str
operator|->
name|str_cur
operator|-
literal|1
expr_stmt|;
name|str_nset
argument_list|(
name|astr
argument_list|,
name|tmps
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* remember last char */
operator|*
name|tmps
operator|=
literal|'\0'
expr_stmt|;
comment|/* wipe it out */
name|str
operator|->
name|str_cur
operator|=
name|tmps
operator|-
name|str
operator|->
name|str_ptr
expr_stmt|;
name|str
operator|->
name|str_nok
operator|=
literal|0
expr_stmt|;
name|STABSET
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
else|else
name|str_nset
argument_list|(
name|astr
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|do_vop
parameter_list|(
name|optype
parameter_list|,
name|str
parameter_list|,
name|left
parameter_list|,
name|right
parameter_list|)
name|STR
modifier|*
name|str
decl_stmt|;
name|STR
modifier|*
name|left
decl_stmt|;
name|STR
modifier|*
name|right
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
specifier|register
name|char
modifier|*
name|l
init|=
name|str_get
argument_list|(
name|left
argument_list|)
decl_stmt|;
specifier|register
name|char
modifier|*
name|r
init|=
name|str_get
argument_list|(
name|right
argument_list|)
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
name|len
operator|=
name|left
operator|->
name|str_cur
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|right
operator|->
name|str_cur
condition|)
name|len
operator|=
name|right
operator|->
name|str_cur
expr_stmt|;
if|if
condition|(
name|str
operator|->
name|str_cur
operator|>
name|len
condition|)
name|str
operator|->
name|str_cur
operator|=
name|len
expr_stmt|;
elseif|else
if|if
condition|(
name|str
operator|->
name|str_cur
operator|<
name|len
condition|)
block|{
name|STR_GROW
argument_list|(
name|str
argument_list|,
name|len
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|memzero
argument_list|(
name|str
operator|->
name|str_ptr
operator|+
name|str
operator|->
name|str_cur
argument_list|,
name|len
operator|-
name|str
operator|->
name|str_cur
argument_list|)
expr_stmt|;
name|str
operator|->
name|str_cur
operator|=
name|len
expr_stmt|;
block|}
name|str
operator|->
name|str_pok
operator|=
literal|1
expr_stmt|;
name|str
operator|->
name|str_nok
operator|=
literal|0
expr_stmt|;
name|s
operator|=
name|str
operator|->
name|str_ptr
expr_stmt|;
if|if
condition|(
operator|!
name|s
condition|)
block|{
name|str_nset
argument_list|(
name|str
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|s
operator|=
name|str
operator|->
name|str_ptr
expr_stmt|;
block|}
switch|switch
condition|(
name|optype
condition|)
block|{
case|case
name|O_BIT_AND
case|:
while|while
condition|(
name|len
operator|--
condition|)
operator|*
name|s
operator|++
operator|=
operator|*
name|l
operator|++
operator|&
operator|*
name|r
operator|++
expr_stmt|;
break|break;
case|case
name|O_XOR
case|:
while|while
condition|(
name|len
operator|--
condition|)
operator|*
name|s
operator|++
operator|=
operator|*
name|l
operator|++
operator|^
operator|*
name|r
operator|++
expr_stmt|;
goto|goto
name|mop_up
goto|;
case|case
name|O_BIT_OR
case|:
while|while
condition|(
name|len
operator|--
condition|)
operator|*
name|s
operator|++
operator|=
operator|*
name|l
operator|++
operator||
operator|*
name|r
operator|++
expr_stmt|;
name|mop_up
label|:
name|len
operator|=
name|str
operator|->
name|str_cur
expr_stmt|;
if|if
condition|(
name|right
operator|->
name|str_cur
operator|>
name|len
condition|)
name|str_ncat
argument_list|(
name|str
argument_list|,
name|right
operator|->
name|str_ptr
operator|+
name|len
argument_list|,
name|right
operator|->
name|str_cur
operator|-
name|len
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|left
operator|->
name|str_cur
operator|>
name|len
condition|)
name|str_ncat
argument_list|(
name|str
argument_list|,
name|left
operator|->
name|str_ptr
operator|+
name|len
argument_list|,
name|left
operator|->
name|str_cur
operator|-
name|len
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
name|int
name|do_syscall
parameter_list|(
name|arglast
parameter_list|)
name|int
modifier|*
name|arglast
decl_stmt|;
block|{
specifier|register
name|STR
modifier|*
modifier|*
name|st
init|=
name|stack
operator|->
name|ary_array
decl_stmt|;
specifier|register
name|int
name|sp
init|=
name|arglast
index|[
literal|1
index|]
decl_stmt|;
specifier|register
name|int
name|items
init|=
name|arglast
index|[
literal|2
index|]
operator|-
name|sp
decl_stmt|;
ifdef|#
directive|ifdef
name|atarist
name|unsigned
name|long
name|arg
index|[
literal|14
index|]
decl_stmt|;
comment|/* yes, we really need that many ! */
else|#
directive|else
name|unsigned
name|long
name|arg
index|[
literal|8
index|]
decl_stmt|;
endif|#
directive|endif
specifier|register
name|int
name|i
init|=
literal|0
decl_stmt|;
name|int
name|retval
init|=
operator|-
literal|1
decl_stmt|;
ifdef|#
directive|ifdef
name|HAS_SYSCALL
ifdef|#
directive|ifdef
name|TAINT
for|for
control|(
name|st
operator|+=
operator|++
name|sp
init|;
name|items
operator|--
condition|;
name|st
operator|++
control|)
name|tainted
operator||=
operator|(
operator|*
name|st
operator|)
operator|->
name|str_tainted
expr_stmt|;
name|st
operator|=
name|stack
operator|->
name|ary_array
expr_stmt|;
name|sp
operator|=
name|arglast
index|[
literal|1
index|]
expr_stmt|;
name|items
operator|=
name|arglast
index|[
literal|2
index|]
operator|-
name|sp
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TAINT
name|taintproper
argument_list|(
literal|"Insecure dependency in syscall"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* This probably won't work on machines where sizeof(long) != sizeof(int)      * or where sizeof(long) != sizeof(char*).  But such machines will      * not likely have syscall implemented either, so who cares?      */
while|while
condition|(
name|items
operator|--
condition|)
block|{
if|if
condition|(
name|st
index|[
operator|++
name|sp
index|]
operator|->
name|str_nok
operator|||
operator|!
name|i
condition|)
name|arg
index|[
name|i
operator|++
index|]
operator|=
operator|(
name|unsigned
name|long
operator|)
name|str_gnum
argument_list|(
name|st
index|[
name|sp
index|]
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|lint
else|else
name|arg
index|[
name|i
operator|++
index|]
operator|=
operator|(
name|unsigned
name|long
operator|)
name|st
index|[
name|sp
index|]
operator|->
name|str_ptr
expr_stmt|;
endif|#
directive|endif
comment|/* lint */
block|}
name|sp
operator|=
name|arglast
index|[
literal|1
index|]
expr_stmt|;
name|items
operator|=
name|arglast
index|[
literal|2
index|]
operator|-
name|sp
expr_stmt|;
switch|switch
condition|(
name|items
condition|)
block|{
case|case
literal|0
case|:
name|fatal
argument_list|(
literal|"Too few args to syscall"
argument_list|)
expr_stmt|;
case|case
literal|1
case|:
name|retval
operator|=
name|syscall
argument_list|(
name|arg
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|retval
operator|=
name|syscall
argument_list|(
name|arg
index|[
literal|0
index|]
argument_list|,
name|arg
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|retval
operator|=
name|syscall
argument_list|(
name|arg
index|[
literal|0
index|]
argument_list|,
name|arg
index|[
literal|1
index|]
argument_list|,
name|arg
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|retval
operator|=
name|syscall
argument_list|(
name|arg
index|[
literal|0
index|]
argument_list|,
name|arg
index|[
literal|1
index|]
argument_list|,
name|arg
index|[
literal|2
index|]
argument_list|,
name|arg
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|5
case|:
name|retval
operator|=
name|syscall
argument_list|(
name|arg
index|[
literal|0
index|]
argument_list|,
name|arg
index|[
literal|1
index|]
argument_list|,
name|arg
index|[
literal|2
index|]
argument_list|,
name|arg
index|[
literal|3
index|]
argument_list|,
name|arg
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|6
case|:
name|retval
operator|=
name|syscall
argument_list|(
name|arg
index|[
literal|0
index|]
argument_list|,
name|arg
index|[
literal|1
index|]
argument_list|,
name|arg
index|[
literal|2
index|]
argument_list|,
name|arg
index|[
literal|3
index|]
argument_list|,
name|arg
index|[
literal|4
index|]
argument_list|,
name|arg
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|7
case|:
name|retval
operator|=
name|syscall
argument_list|(
name|arg
index|[
literal|0
index|]
argument_list|,
name|arg
index|[
literal|1
index|]
argument_list|,
name|arg
index|[
literal|2
index|]
argument_list|,
name|arg
index|[
literal|3
index|]
argument_list|,
name|arg
index|[
literal|4
index|]
argument_list|,
name|arg
index|[
literal|5
index|]
argument_list|,
name|arg
index|[
literal|6
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|retval
operator|=
name|syscall
argument_list|(
name|arg
index|[
literal|0
index|]
argument_list|,
name|arg
index|[
literal|1
index|]
argument_list|,
name|arg
index|[
literal|2
index|]
argument_list|,
name|arg
index|[
literal|3
index|]
argument_list|,
name|arg
index|[
literal|4
index|]
argument_list|,
name|arg
index|[
literal|5
index|]
argument_list|,
name|arg
index|[
literal|6
index|]
argument_list|,
name|arg
index|[
literal|7
index|]
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|atarist
case|case
literal|9
case|:
name|retval
operator|=
name|syscall
argument_list|(
name|arg
index|[
literal|0
index|]
argument_list|,
name|arg
index|[
literal|1
index|]
argument_list|,
name|arg
index|[
literal|2
index|]
argument_list|,
name|arg
index|[
literal|3
index|]
argument_list|,
name|arg
index|[
literal|4
index|]
argument_list|,
name|arg
index|[
literal|5
index|]
argument_list|,
name|arg
index|[
literal|6
index|]
argument_list|,
name|arg
index|[
literal|7
index|]
argument_list|,
name|arg
index|[
literal|8
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|10
case|:
name|retval
operator|=
name|syscall
argument_list|(
name|arg
index|[
literal|0
index|]
argument_list|,
name|arg
index|[
literal|1
index|]
argument_list|,
name|arg
index|[
literal|2
index|]
argument_list|,
name|arg
index|[
literal|3
index|]
argument_list|,
name|arg
index|[
literal|4
index|]
argument_list|,
name|arg
index|[
literal|5
index|]
argument_list|,
name|arg
index|[
literal|6
index|]
argument_list|,
name|arg
index|[
literal|7
index|]
argument_list|,
name|arg
index|[
literal|8
index|]
argument_list|,
name|arg
index|[
literal|9
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|11
case|:
name|retval
operator|=
name|syscall
argument_list|(
name|arg
index|[
literal|0
index|]
argument_list|,
name|arg
index|[
literal|1
index|]
argument_list|,
name|arg
index|[
literal|2
index|]
argument_list|,
name|arg
index|[
literal|3
index|]
argument_list|,
name|arg
index|[
literal|4
index|]
argument_list|,
name|arg
index|[
literal|5
index|]
argument_list|,
name|arg
index|[
literal|6
index|]
argument_list|,
name|arg
index|[
literal|7
index|]
argument_list|,
name|arg
index|[
literal|8
index|]
argument_list|,
name|arg
index|[
literal|9
index|]
argument_list|,
name|arg
index|[
literal|10
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|12
case|:
name|retval
operator|=
name|syscall
argument_list|(
name|arg
index|[
literal|0
index|]
argument_list|,
name|arg
index|[
literal|1
index|]
argument_list|,
name|arg
index|[
literal|2
index|]
argument_list|,
name|arg
index|[
literal|3
index|]
argument_list|,
name|arg
index|[
literal|4
index|]
argument_list|,
name|arg
index|[
literal|5
index|]
argument_list|,
name|arg
index|[
literal|6
index|]
argument_list|,
name|arg
index|[
literal|7
index|]
argument_list|,
name|arg
index|[
literal|8
index|]
argument_list|,
name|arg
index|[
literal|9
index|]
argument_list|,
name|arg
index|[
literal|10
index|]
argument_list|,
name|arg
index|[
literal|11
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|13
case|:
name|retval
operator|=
name|syscall
argument_list|(
name|arg
index|[
literal|0
index|]
argument_list|,
name|arg
index|[
literal|1
index|]
argument_list|,
name|arg
index|[
literal|2
index|]
argument_list|,
name|arg
index|[
literal|3
index|]
argument_list|,
name|arg
index|[
literal|4
index|]
argument_list|,
name|arg
index|[
literal|5
index|]
argument_list|,
name|arg
index|[
literal|6
index|]
argument_list|,
name|arg
index|[
literal|7
index|]
argument_list|,
name|arg
index|[
literal|8
index|]
argument_list|,
name|arg
index|[
literal|9
index|]
argument_list|,
name|arg
index|[
literal|10
index|]
argument_list|,
name|arg
index|[
literal|11
index|]
argument_list|,
name|arg
index|[
literal|12
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|14
case|:
name|retval
operator|=
name|syscall
argument_list|(
name|arg
index|[
literal|0
index|]
argument_list|,
name|arg
index|[
literal|1
index|]
argument_list|,
name|arg
index|[
literal|2
index|]
argument_list|,
name|arg
index|[
literal|3
index|]
argument_list|,
name|arg
index|[
literal|4
index|]
argument_list|,
name|arg
index|[
literal|5
index|]
argument_list|,
name|arg
index|[
literal|6
index|]
argument_list|,
name|arg
index|[
literal|7
index|]
argument_list|,
name|arg
index|[
literal|8
index|]
argument_list|,
name|arg
index|[
literal|9
index|]
argument_list|,
name|arg
index|[
literal|10
index|]
argument_list|,
name|arg
index|[
literal|11
index|]
argument_list|,
name|arg
index|[
literal|12
index|]
argument_list|,
name|arg
index|[
literal|13
index|]
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* atarist */
block|}
return|return
name|retval
return|;
else|#
directive|else
name|fatal
argument_list|(
literal|"syscall() unimplemented"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

end_unit

