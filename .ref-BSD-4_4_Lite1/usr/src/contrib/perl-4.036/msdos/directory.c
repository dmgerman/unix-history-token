begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $RCSfile: directory.c,v $$Revision: 4.0.1.1 $$Date: 91/06/07 11:22:24 $  *  *    (C) Copyright 1987, 1988, 1990 Diomidis Spinellis.  *  *    You may distribute under the terms of either the GNU General Public  *    License or the Artistic License, as specified in the README file.  *  * $Log:	directory.c,v $  * Revision 4.0.1.1  91/06/07  11:22:24  lwall  * patch4: new copyright notice  *   * Revision 4.0  91/03/20  01:34:24  lwall  * 4.0 baseline.  *   * Revision 3.0.1.1  90/03/27  16:07:37  lwall  * patch16: MSDOS support  *   * Revision 1.3  90/03/16  22:39:40  dds  * Fixed malloc problem.  *  * Revision 1.2  88/07/23  00:08:39  dds  * Added inode non-zero filling.  *  * Revision 1.1  88/07/23  00:03:50  dds  * Initial revision  *  */
end_comment

begin_comment
comment|/*  * UNIX compatible directory access functions  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/dir.h>
end_include

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<dos.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_comment
comment|/*  * File names are converted to lowercase if the  * CONVERT_TO_LOWER_CASE variable is defined.  */
end_comment

begin_define
define|#
directive|define
name|CONVERT_TO_LOWER_CASE
end_define

begin_define
define|#
directive|define
name|PATHLEN
value|65
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$RCSfile: directory.c,v $$Revision: 4.0.1.1 $$Date: 91/06/07 11:22:24 $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|DIR
modifier|*
name|opendir
parameter_list|(
name|char
modifier|*
name|filename
parameter_list|)
block|{
name|DIR
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|oldresult
decl_stmt|,
modifier|*
name|result
decl_stmt|;
name|union
name|REGS
name|srv
decl_stmt|;
name|struct
name|SREGS
name|segregs
decl_stmt|;
specifier|register
name|reslen
operator|=
literal|0
expr_stmt|;
name|char
name|scannamespc
index|[
name|PATHLEN
index|]
decl_stmt|;
name|char
modifier|*
name|scanname
init|=
name|scannamespc
decl_stmt|;
comment|/* To take address we need a pointer */
comment|/* 	 * Structure used by the MS-DOS directory system calls. 	 */
struct|struct
name|dir_buff
block|{
name|char
name|reserved
index|[
literal|21
index|]
decl_stmt|;
comment|/* Reserved for MS-DOS */
name|unsigned
name|char
name|attribute
decl_stmt|;
comment|/* Attribute */
name|unsigned
name|int
name|time
decl_stmt|;
comment|/* Time */
name|unsigned
name|int
name|date
decl_stmt|;
comment|/* Date */
name|long
name|size
decl_stmt|;
comment|/* Size of file */
name|char
name|fn
index|[
literal|13
index|]
decl_stmt|;
comment|/* Filename */
block|}
name|buffspc
struct|,
modifier|*
name|buff
init|=
operator|&
name|buffspc
struct|;
if|if
condition|(
operator|!
operator|(
name|p
operator|=
operator|(
name|DIR
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|DIR
argument_list|)
argument_list|)
operator|)
condition|)
return|return
name|NULL
return|;
comment|/* Initialize result to use realloc on it */
if|if
condition|(
operator|!
operator|(
name|result
operator|=
name|malloc
argument_list|(
literal|1
argument_list|)
operator|)
condition|)
block|{
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Create the search pattern */
name|strcpy
argument_list|(
name|scanname
argument_list|,
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|strchr
argument_list|(
literal|"/\\"
argument_list|,
operator|*
operator|(
name|scanname
operator|+
name|strlen
argument_list|(
name|scanname
argument_list|)
operator|-
literal|1
operator|)
argument_list|)
operator|==
name|NULL
condition|)
name|strcat
argument_list|(
name|scanname
argument_list|,
literal|"/*.*"
argument_list|)
expr_stmt|;
else|else
name|strcat
argument_list|(
name|scanname
argument_list|,
literal|"*.*"
argument_list|)
expr_stmt|;
name|segread
argument_list|(
operator|&
name|segregs
argument_list|)
expr_stmt|;
if|#
directive|if
operator|(
name|defined
argument_list|(
name|M_I86LM
argument_list|)
operator|||
name|defined
argument_list|(
name|M_I86CM
argument_list|)
operator|||
name|defined
argument_list|(
name|M_I86HM
argument_list|)
operator|)
name|segregs
operator|.
name|ds
operator|=
name|FP_SEG
argument_list|(
name|buff
argument_list|)
expr_stmt|;
name|srv
operator|.
name|x
operator|.
name|dx
operator|=
name|FP_OFF
argument_list|(
name|buff
argument_list|)
expr_stmt|;
else|#
directive|else
name|srv
operator|.
name|x
operator|.
name|dx
operator|=
operator|(
name|unsigned
name|int
operator|)
name|buff
expr_stmt|;
endif|#
directive|endif
name|srv
operator|.
name|h
operator|.
name|ah
operator|=
literal|0x1a
expr_stmt|;
comment|/* Set DTA to DS:DX */
name|intdosx
argument_list|(
operator|&
name|srv
argument_list|,
operator|&
name|srv
argument_list|,
operator|&
name|segregs
argument_list|)
expr_stmt|;
if|#
directive|if
operator|(
name|defined
argument_list|(
name|M_I86LM
argument_list|)
operator|||
name|defined
argument_list|(
name|M_I86CM
argument_list|)
operator|||
name|defined
argument_list|(
name|M_I86HM
argument_list|)
operator|)
name|segregs
operator|.
name|ds
operator|=
name|FP_SEG
argument_list|(
name|scanname
argument_list|)
expr_stmt|;
name|srv
operator|.
name|x
operator|.
name|dx
operator|=
name|FP_OFF
argument_list|(
name|scanname
argument_list|)
expr_stmt|;
else|#
directive|else
name|srv
operator|.
name|x
operator|.
name|dx
operator|=
operator|(
name|unsigned
name|int
operator|)
name|scanname
expr_stmt|;
endif|#
directive|endif
name|srv
operator|.
name|x
operator|.
name|cx
operator|=
literal|0xff
expr_stmt|;
comment|/* Search mode */
for|for
control|(
name|srv
operator|.
name|h
operator|.
name|ah
operator|=
literal|0x4e
init|;
operator|!
name|intdosx
argument_list|(
operator|&
name|srv
argument_list|,
operator|&
name|srv
argument_list|,
operator|&
name|segregs
argument_list|)
condition|;
name|srv
operator|.
name|h
operator|.
name|ah
operator|=
literal|0x4f
control|)
block|{
if|if
condition|(
operator|(
name|result
operator|=
operator|(
name|char
operator|*
operator|)
name|realloc
argument_list|(
name|result
argument_list|,
name|reslen
operator|+
name|strlen
argument_list|(
name|buff
operator|->
name|fn
argument_list|)
operator|+
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|oldresult
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|oldresult
operator|=
name|result
expr_stmt|;
ifdef|#
directive|ifdef
name|CONVERT_TO_LOWER_CASE
name|strcpy
argument_list|(
name|result
operator|+
name|reslen
argument_list|,
name|strlwr
argument_list|(
name|buff
operator|->
name|fn
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|strcpy
argument_list|(
name|result
operator|+
name|reslen
argument_list|,
name|buff
operator|->
name|fn
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|reslen
operator|+=
name|strlen
argument_list|(
name|buff
operator|->
name|fn
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|result
operator|=
name|realloc
argument_list|(
name|result
argument_list|,
name|reslen
operator|+
literal|1
argument_list|)
operator|)
condition|)
block|{
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|oldresult
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
else|else
block|{
name|p
operator|->
name|start
operator|=
name|result
expr_stmt|;
name|p
operator|->
name|curr
operator|=
name|result
expr_stmt|;
operator|*
operator|(
name|result
operator|+
name|reslen
operator|)
operator|=
literal|'\0'
expr_stmt|;
return|return
name|p
return|;
block|}
block|}
end_function

begin_function
name|struct
name|direct
modifier|*
name|readdir
parameter_list|(
name|DIR
modifier|*
name|dirp
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|len
expr_stmt|;
specifier|static
name|dummy
expr_stmt|;
name|p
operator|=
name|dirp
operator|->
name|curr
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
condition|)
block|{
name|dirp
operator|->
name|curr
operator|+=
name|len
operator|+
literal|1
expr_stmt|;
name|strcpy
argument_list|(
name|dirp
operator|->
name|dirstr
operator|.
name|d_name
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|dirp
operator|->
name|dirstr
operator|.
name|d_namlen
operator|=
name|len
expr_stmt|;
comment|/* To fool programs */
name|dirp
operator|->
name|dirstr
operator|.
name|d_ino
operator|=
operator|++
name|dummy
expr_stmt|;
return|return
operator|&
operator|(
name|dirp
operator|->
name|dirstr
operator|)
return|;
block|}
else|else
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|long
name|telldir
parameter_list|(
name|DIR
modifier|*
name|dirp
parameter_list|)
block|{
return|return
operator|(
name|long
operator|)
name|dirp
operator|->
name|curr
return|;
comment|/* ouch! pointer to long cast */
block|}
end_function

begin_function
name|void
name|seekdir
parameter_list|(
name|DIR
modifier|*
name|dirp
parameter_list|,
name|long
name|loc
parameter_list|)
block|{
name|dirp
operator|->
name|curr
operator|=
operator|(
name|char
operator|*
operator|)
name|loc
expr_stmt|;
comment|/* ouch! long to pointer cast */
block|}
end_function

begin_function
name|void
name|rewinddir
parameter_list|(
name|DIR
modifier|*
name|dirp
parameter_list|)
block|{
name|dirp
operator|->
name|curr
operator|=
name|dirp
operator|->
name|start
expr_stmt|;
block|}
end_function

begin_function
name|void
name|closedir
parameter_list|(
name|DIR
modifier|*
name|dirp
parameter_list|)
block|{
name|free
argument_list|(
name|dirp
operator|->
name|start
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dirp
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

