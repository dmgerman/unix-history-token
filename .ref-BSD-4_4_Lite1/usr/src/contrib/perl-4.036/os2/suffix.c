begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Suffix appending for in-place editing under MS-DOS and OS/2.  *  * Here are the rules:  *  * Style 0:  Append the suffix exactly as standard perl would do it.  *           If the filesystem groks it, use it.  (HPFS will always  *           grok it.  FAT will rarely accept it.)  *  * Style 1:  The suffix begins with a '.'.  The extension is replaced.  *           If the name matches the original name, use the fallback method.  *  * Style 2:  The suffix is a single character, not a '.'.  Try to add the   *           suffix to the following places, using the first one that works.  *               [1] Append to extension.    *               [2] Append to filename,   *               [3] Replace end of extension,   *               [4] Replace end of filename.  *           If the name matches the original name, use the fallback method.  *  * Style 3:  Any other case:  Ignore the suffix completely and use the  *           fallback method.  *  * Fallback method:  Change the extension to ".$$$".  If that matches the  *           original name, then change the extension to ".~~~".  *  * If filename is more than 1000 characters long, we die a horrible  * death.  Sorry.  *  * The filename restriction is a cheat so that we can use buf[] to store  * assorted temporary goo.  *  * Examples, assuming style 0 failed.  *  * suffix = ".bak" (style 1)  *                foo.bar => foo.bak  *                foo.bak => foo.$$$	(fallback)  *                foo.$$$ => foo.~~~	(fallback)  *                makefile => makefile.bak  *  * suffix = "~" (style 2)  *                foo.c => foo.c~  *                foo.c~ => foo.c~~  *                foo.c~~ => foo~.c~~  *                foo~.c~~ => foo~~.c~~  *                foo~~~~~.c~~ => foo~~~~~.$$$ (fallback)  *  *                foo.pas => foo~.pas  *                makefile => makefile.~  *                longname.fil => longname.fi~  *                longname.fi~ => longnam~.fi~  *                longnam~.fi~ => longnam~.$$$  *                  */
end_comment

begin_include
include|#
directive|include
file|"EXTERN.h"
end_include

begin_include
include|#
directive|include
file|"perl.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|OS2
end_ifdef

begin_define
define|#
directive|define
name|INCL_DOSFILEMGR
end_define

begin_define
define|#
directive|define
name|INCL_DOSERRORS
end_define

begin_include
include|#
directive|include
file|<os2.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OS2 */
end_comment

begin_decl_stmt
specifier|static
name|char
name|suffix1
index|[]
init|=
literal|".$$$"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|suffix2
index|[]
init|=
literal|".~~~"
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|ext
value|(&buf[1000])
end_define

begin_expr_stmt
name|add_suffix
argument_list|(
name|str
argument_list|,
name|suffix
argument_list|)
specifier|register
name|STR
operator|*
name|str
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|char
modifier|*
name|suffix
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|baselen
decl_stmt|;
name|int
name|extlen
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|t
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|STRLEN
name|slen
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|str
operator|->
name|str_pok
operator|)
condition|)
operator|(
name|void
operator|)
name|str_2ptr
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|str
operator|->
name|str_cur
operator|>
literal|1000
condition|)
name|fatal
argument_list|(
literal|"Cannot do inplace edit on long filename (%d characters)"
argument_list|,
name|str
operator|->
name|str_cur
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OS2
comment|/* Style 0 */
name|slen
operator|=
name|str
operator|->
name|str_cur
expr_stmt|;
name|str_cat
argument_list|(
name|str
argument_list|,
name|suffix
argument_list|)
expr_stmt|;
if|if
condition|(
name|valid_filename
argument_list|(
name|str
operator|->
name|str_ptr
argument_list|)
condition|)
return|return;
comment|/* Fooey, style 0 failed.  Fix str before continuing. */
name|str
operator|->
name|str_ptr
index|[
name|str
operator|->
name|str_cur
operator|=
name|slen
index|]
operator|=
literal|'\0'
expr_stmt|;
endif|#
directive|endif
comment|/* OS2 */
name|slen
operator|=
name|strlen
argument_list|(
name|suffix
argument_list|)
expr_stmt|;
name|t
operator|=
name|buf
expr_stmt|;
name|baselen
operator|=
literal|0
expr_stmt|;
name|s
operator|=
name|str
operator|->
name|str_ptr
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|t
operator|=
operator|*
name|s
operator|)
operator|&&
operator|*
name|s
operator|!=
literal|'.'
condition|)
block|{
name|baselen
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'\\'
operator|||
operator|*
name|s
operator|==
literal|'/'
condition|)
name|baselen
operator|=
literal|0
expr_stmt|;
name|s
operator|++
expr_stmt|;
name|t
operator|++
expr_stmt|;
block|}
name|p
operator|=
name|t
expr_stmt|;
name|t
operator|=
name|ext
expr_stmt|;
name|extlen
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|t
operator|++
operator|=
operator|*
name|s
operator|++
condition|)
name|extlen
operator|++
expr_stmt|;
if|if
condition|(
name|extlen
operator|==
literal|0
condition|)
block|{
name|ext
index|[
literal|0
index|]
operator|=
literal|'.'
expr_stmt|;
name|ext
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|extlen
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|suffix
operator|==
literal|'.'
condition|)
block|{
comment|/* Style 1 */
if|if
condition|(
name|strEQ
argument_list|(
name|ext
argument_list|,
name|suffix
argument_list|)
condition|)
goto|goto
name|fallback
goto|;
name|strcpy
argument_list|(
name|p
argument_list|,
name|suffix
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|suffix
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
block|{
comment|/* Style 2 */
if|if
condition|(
name|extlen
operator|<
literal|4
condition|)
block|{
name|ext
index|[
name|extlen
index|]
operator|=
operator|*
name|suffix
expr_stmt|;
name|ext
index|[
operator|++
name|extlen
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|baselen
operator|<
literal|8
condition|)
block|{
operator|*
name|p
operator|++
operator|=
operator|*
name|suffix
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ext
index|[
literal|3
index|]
operator|!=
operator|*
name|suffix
condition|)
block|{
name|ext
index|[
literal|3
index|]
operator|=
operator|*
name|suffix
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|buf
index|[
literal|7
index|]
operator|!=
operator|*
name|suffix
condition|)
block|{
name|buf
index|[
literal|7
index|]
operator|=
operator|*
name|suffix
expr_stmt|;
block|}
else|else
goto|goto
name|fallback
goto|;
name|strcpy
argument_list|(
name|p
argument_list|,
name|ext
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Style 3:  Panic */
name|fallback
label|:
operator|(
name|void
operator|)
name|bcopy
argument_list|(
name|strEQ
argument_list|(
name|ext
argument_list|,
name|suffix1
argument_list|)
condition|?
name|suffix2
else|:
name|suffix1
argument_list|,
name|p
argument_list|,
literal|4
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|str_set
argument_list|(
name|str
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|OS2
end_ifdef

begin_function
name|int
name|valid_filename
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|HFILE
name|hf
decl_stmt|;
name|USHORT
name|usAction
decl_stmt|;
switch|switch
condition|(
name|DosOpen
argument_list|(
name|s
argument_list|,
operator|&
name|hf
argument_list|,
operator|&
name|usAction
argument_list|,
literal|0L
argument_list|,
literal|0
argument_list|,
name|FILE_OPEN
argument_list|,
name|OPEN_ACCESS_READONLY
operator||
name|OPEN_SHARE_DENYNONE
argument_list|,
literal|0L
argument_list|)
condition|)
block|{
case|case
name|ERROR_INVALID_NAME
case|:
case|case
name|ERROR_FILENAME_EXCED_RANGE
case|:
return|return
literal|0
return|;
case|case
name|NO_ERROR
case|:
name|DosClose
argument_list|(
name|hf
argument_list|)
expr_stmt|;
comment|/*FALLTHROUGH*/
default|default:
return|return
literal|1
return|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OS2 */
end_comment

end_unit

