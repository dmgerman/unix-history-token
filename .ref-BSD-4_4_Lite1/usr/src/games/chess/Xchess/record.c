begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* This file contains code for X-CHESS.    Copyright (C) 1986 Free Software Foundation, Inc.  This file is part of X-CHESS.  X-CHESS is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Refer to the X-CHESS General Public License for full details.  Everyone is granted permission to copy, modify and redistribute X-CHESS, but only under the conditions described in the X-CHESS General Public License.   A copy of this license is supposed to have been given to you along with X-CHESS so you can know your rights and responsibilities.  It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  */
end_comment

begin_comment
comment|/* RCS Info: $Revision: 1.4 $ on $Date: 86/11/23 17:18:20 $  *           $Source: /users/faustus/xchess/RCS/record.c,v $  * Copyright (c) 1986 Wayne A. Christopher, U. C. Berkeley CAD Group  *	Permission is granted to do anything with this code except sell it  *	or remove this message.  *  * Deal with recording moves.  */
end_comment

begin_include
include|#
directive|include
file|"xchess.h"
end_include

begin_undef
undef|#
directive|undef
name|smartass
end_undef

begin_decl_stmt
name|bool
name|record_english
init|=
name|true
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|record_file
init|=
name|DEF_RECORD_FILE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|movenum
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|saveflag
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|colnames
index|[]
init|=
block|{
literal|"qr"
block|,
literal|"qn"
block|,
literal|"qb"
block|,
literal|"q"
block|,
literal|"k"
block|,
literal|"kb"
block|,
literal|"kn"
block|,
literal|"kr"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|pcnames
index|[]
init|=
block|{
literal|"P"
block|,
literal|"R"
block|,
literal|"N"
block|,
literal|"B"
block|,
literal|"Q"
block|,
literal|"K"
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|char
modifier|*
name|movestring
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|tstring
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|backup
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|RECORD_HEADER
value|"\n
value|1    XChess Game Record
value|0\n"
end_define

begin_function
name|void
name|record_init
parameter_list|(
name|win
parameter_list|)
name|windata
modifier|*
name|win
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|i
operator|=
name|XTextWidth
argument_list|(
name|win
operator|->
name|medium
argument_list|,
name|RECORD_HEADER
argument_list|,
sizeof|sizeof
argument_list|(
name|RECORD_HEADER
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|i
operator|=
operator|(
literal|40
operator|*
name|win
operator|->
name|small
operator|->
name|max_bounds
operator|.
name|width
operator|-
name|i
operator|*
name|win
operator|->
name|medium
operator|->
name|max_bounds
operator|.
name|width
operator|)
operator|/
name|win
operator|->
name|medium
operator|->
name|max_bounds
operator|.
name|width
operator|/
literal|2
expr_stmt|;
name|TxtGrab
argument_list|(
name|win
operator|->
name|display
argument_list|,
name|win
operator|->
name|recwin
argument_list|,
literal|"xchess"
argument_list|,
name|win
operator|->
name|small
argument_list|,
name|win
operator|->
name|textback
operator|.
name|pixel
argument_list|,
name|win
operator|->
name|textcolor
operator|.
name|pixel
argument_list|,
name|win
operator|->
name|cursorcolor
operator|.
name|pixel
argument_list|)
expr_stmt|;
name|TxtAddFont
argument_list|(
name|win
operator|->
name|display
argument_list|,
name|win
operator|->
name|recwin
argument_list|,
literal|1
argument_list|,
name|win
operator|->
name|medium
argument_list|,
name|win
operator|->
name|textcolor
operator|.
name|pixel
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|++
control|)
name|TxtWriteStr
argument_list|(
name|win
operator|->
name|display
argument_list|,
name|win
operator|->
name|recwin
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|TxtWriteStr
argument_list|(
name|win
operator|->
name|display
argument_list|,
name|win
operator|->
name|recwin
argument_list|,
name|RECORD_HEADER
argument_list|)
expr_stmt|;
if|if
condition|(
name|saveflag
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|backup
operator|=
name|fopen
argument_list|(
name|record_file
argument_list|,
literal|"w"
argument_list|)
operator|)
condition|)
block|{
name|perror
argument_list|(
name|record_file
argument_list|)
expr_stmt|;
name|saveflag
operator|=
name|false
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|backup
argument_list|,
literal|"X Chess -- %s\n"
argument_list|,
name|datestring
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|dispname2
condition|)
name|fprintf
argument_list|(
name|backup
argument_list|,
literal|"\tWhite on %s, black on %s\n"
argument_list|,
name|dispname1
argument_list|,
name|dispname2
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|backup
argument_list|,
literal|"\tGame played on %s\n"
argument_list|,
name|dispname1
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|backup
argument_list|,
literal|"\t%s\n"
argument_list|,
name|record_english
condition|?
literal|"english"
else|:
literal|"algebraic"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|backup
argument_list|)
expr_stmt|;
block|}
block|}
name|movenum
operator|=
literal|0
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|record_reset
parameter_list|()
block|{
name|TxtWriteStr
argument_list|(
name|win1
operator|->
name|display
argument_list|,
name|win1
operator|->
name|recwin
argument_list|,
literal|"\n\n
literal|1    New Game
literal|0\n\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|oneboard
condition|)
block|{
name|TxtWriteStr
argument_list|(
name|win2
operator|->
name|display
argument_list|,
name|win2
operator|->
name|recwin
argument_list|,
literal|"\n\n
literal|1    New Game
literal|0\n\n"
argument_list|)
expr_stmt|;
block|}
name|movenum
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|saveflag
condition|)
block|{
name|fprintf
argument_list|(
name|backup
argument_list|,
literal|"\n\nNew Game\n\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|backup
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
name|void
name|record_end
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|char
name|buf
index|[
name|BSIZE
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"\n%s\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|TxtWriteStr
argument_list|(
name|win1
operator|->
name|display
argument_list|,
name|win1
operator|->
name|recwin
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|oneboard
condition|)
block|{
name|TxtWriteStr
argument_list|(
name|win2
operator|->
name|display
argument_list|,
name|win2
operator|->
name|recwin
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|saveflag
condition|)
block|{
name|fprintf
argument_list|(
name|backup
argument_list|,
literal|"\n%s\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|backup
argument_list|,
literal|"Time: white: %s, "
argument_list|,
name|tstring
argument_list|(
name|whiteseconds
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|backup
argument_list|,
literal|"black: %s\n"
argument_list|,
name|tstring
argument_list|(
name|blackseconds
argument_list|)
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|backup
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
name|void
name|record_save
parameter_list|()
block|{
name|move
modifier|*
name|m
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|record_file
argument_list|,
literal|"w"
argument_list|)
operator|)
condition|)
block|{
name|perror
argument_list|(
name|record_file
argument_list|)
expr_stmt|;
return|return;
block|}
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"X Chess -- %s\n"
argument_list|,
name|datestring
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|dispname2
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\tWhite on %s, black on %s\n"
argument_list|,
name|dispname1
argument_list|,
name|dispname2
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\tGame played on %s\n"
argument_list|,
name|dispname1
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t%s\n"
argument_list|,
name|record_english
condition|?
literal|"english"
else|:
literal|"algebraic"
argument_list|)
expr_stmt|;
for|for
control|(
name|m
operator|=
name|moves
operator|,
name|i
operator|=
literal|1
init|;
name|m
condition|;
name|i
operator|++
control|)
block|{
name|s
operator|=
name|movestring
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%2d. %-16s "
argument_list|,
name|i
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|m
operator|=
name|m
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|m
condition|)
name|s
operator|=
name|movestring
argument_list|(
name|m
argument_list|)
expr_stmt|;
else|else
name|s
operator|=
literal|""
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
condition|)
name|m
operator|=
name|m
operator|->
name|next
expr_stmt|;
block|}
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|record_move
parameter_list|(
name|m
parameter_list|)
name|move
modifier|*
name|m
decl_stmt|;
block|{
name|char
modifier|*
name|s
decl_stmt|,
name|buf
index|[
name|BSIZE
index|]
decl_stmt|;
name|s
operator|=
name|movestring
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|piece
operator|.
name|color
operator|==
name|WHITE
condition|)
block|{
name|movenum
operator|++
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%2d. %-16s "
argument_list|,
name|movenum
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
name|TxtWriteStr
argument_list|(
name|win1
operator|->
name|display
argument_list|,
name|win1
operator|->
name|recwin
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|oneboard
condition|)
block|{
name|TxtWriteStr
argument_list|(
name|win2
operator|->
name|display
argument_list|,
name|win2
operator|->
name|recwin
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|saveflag
condition|)
block|{
name|fprintf
argument_list|(
name|backup
argument_list|,
literal|"%s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|backup
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
name|void
name|record_back
parameter_list|()
block|{
specifier|extern
name|move
modifier|*
name|lastmove
decl_stmt|;
name|move
modifier|*
name|m
init|=
name|lastmove
decl_stmt|;
name|char
modifier|*
name|s
init|=
name|movestring
argument_list|(
name|m
argument_list|)
decl_stmt|;
name|char
name|buf
index|[
name|BSIZE
index|]
decl_stmt|;
name|long
name|i
decl_stmt|;
if|if
condition|(
name|m
operator|->
name|piece
operator|.
name|color
operator|==
name|WHITE
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%2d. %-16s "
argument_list|,
name|movenum
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
name|s
operator|=
name|buf
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|*
name|s
operator|!=
literal|'\0'
condition|;
name|i
operator|++
control|)
operator|*
name|s
operator|++
operator|=
literal|'
literal|'
expr_stmt|;
comment|/* control H, backspace */
name|TxtWriteStr
argument_list|(
name|win1
operator|->
name|display
argument_list|,
name|win1
operator|->
name|recwin
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|oneboard
condition|)
block|{
name|TxtWriteStr
argument_list|(
name|win2
operator|->
name|display
argument_list|,
name|win2
operator|->
name|recwin
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nexttomove
operator|==
name|BLACK
condition|)
name|movenum
operator|--
expr_stmt|;
if|if
condition|(
name|saveflag
condition|)
block|{
name|fseek
argument_list|(
name|backup
argument_list|,
operator|-
name|i
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|backup
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|movestring
parameter_list|(
name|m
parameter_list|)
name|move
modifier|*
name|m
decl_stmt|;
block|{
name|int
name|fy
decl_stmt|,
name|ty
decl_stmt|;
specifier|static
name|char
name|buf
index|[
name|BSIZE
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|record_english
operator|||
operator|(
name|m
operator|->
name|piece
operator|.
name|color
operator|==
name|WHITE
operator|)
condition|)
block|{
name|fy
operator|=
name|SIZE
operator|-
name|m
operator|->
name|fromy
expr_stmt|;
name|ty
operator|=
name|SIZE
operator|-
name|m
operator|->
name|toy
expr_stmt|;
block|}
else|else
block|{
name|fy
operator|=
name|m
operator|->
name|fromy
operator|+
literal|1
expr_stmt|;
name|ty
operator|=
name|m
operator|->
name|toy
operator|+
literal|1
expr_stmt|;
block|}
switch|switch
condition|(
name|m
operator|->
name|type
condition|)
block|{
case|case
name|MOVE
case|:
if|if
condition|(
name|record_english
condition|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s/%s%d-%s%d%s"
argument_list|,
name|pcnames
index|[
operator|(
name|int
operator|)
name|m
operator|->
name|piece
operator|.
name|type
index|]
argument_list|,
name|colnames
index|[
name|m
operator|->
name|fromx
index|]
argument_list|,
name|fy
argument_list|,
name|colnames
index|[
name|m
operator|->
name|tox
index|]
argument_list|,
name|ty
argument_list|,
name|m
operator|->
name|check
condition|?
literal|"+"
else|:
literal|""
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%c%d%c%d"
argument_list|,
literal|'a'
operator|+
name|m
operator|->
name|fromx
argument_list|,
name|fy
argument_list|,
literal|'a'
operator|+
name|m
operator|->
name|tox
argument_list|,
name|ty
argument_list|)
expr_stmt|;
break|break;
case|case
name|CAPTURE
case|:
if|if
condition|(
name|record_english
condition|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s/%s%dx%s/%s%d%s%s"
argument_list|,
name|pcnames
index|[
operator|(
name|int
operator|)
name|m
operator|->
name|piece
operator|.
name|type
index|]
argument_list|,
name|colnames
index|[
name|m
operator|->
name|fromx
index|]
argument_list|,
name|fy
argument_list|,
name|pcnames
index|[
operator|(
name|int
operator|)
name|m
operator|->
name|taken
operator|.
name|type
index|]
argument_list|,
name|colnames
index|[
name|m
operator|->
name|tox
index|]
argument_list|,
name|ty
argument_list|,
name|m
operator|->
name|enpassant
condition|?
literal|"e.p."
else|:
literal|""
argument_list|,
name|m
operator|->
name|check
condition|?
literal|"+"
else|:
literal|""
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%c%d%c%d"
argument_list|,
literal|'a'
operator|+
name|m
operator|->
name|fromx
argument_list|,
name|fy
argument_list|,
literal|'a'
operator|+
name|m
operator|->
name|tox
argument_list|,
name|ty
argument_list|)
expr_stmt|;
break|break;
case|case
name|KCASTLE
case|:
if|if
condition|(
name|record_english
condition|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"O-O%s"
argument_list|,
name|m
operator|->
name|check
condition|?
literal|"ch"
else|:
literal|""
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|m
operator|->
name|piece
operator|.
name|color
operator|==
name|WHITE
condition|)
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|"e1g1"
argument_list|)
expr_stmt|;
else|else
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|"e8g8"
argument_list|)
expr_stmt|;
break|break;
case|case
name|QCASTLE
case|:
if|if
condition|(
name|record_english
condition|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"O-O-O%s"
argument_list|,
name|m
operator|->
name|check
condition|?
literal|"ch"
else|:
literal|""
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|m
operator|->
name|piece
operator|.
name|color
operator|==
name|WHITE
condition|)
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|"e1c1"
argument_list|)
expr_stmt|;
else|else
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|"e8c8"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"something strange"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|m
operator|->
name|piece
operator|.
name|type
operator|==
name|PAWN
operator|)
operator|&&
operator|(
operator|(
operator|(
name|m
operator|->
name|piece
operator|.
name|color
operator|==
name|BLACK
operator|)
operator|&&
operator|(
name|m
operator|->
name|toy
operator|==
literal|7
operator|)
operator|)
operator|||
operator|(
operator|(
name|m
operator|->
name|piece
operator|.
name|color
operator|==
name|WHITE
operator|)
operator|&&
operator|(
name|m
operator|->
name|toy
operator|==
literal|0
operator|)
operator|)
operator|)
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"(Q)"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|smartass
if|if
condition|(
operator|!
operator|(
name|random
argument_list|()
operator|%
literal|50
operator|)
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"?"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
operator|(
name|random
argument_list|()
operator|%
literal|50
operator|)
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"!"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
operator|(
name|random
argument_list|()
operator|%
literal|500
operator|)
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"???"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
operator|(
name|random
argument_list|()
operator|%
literal|500
operator|)
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"!!!"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|smartass
return|return
operator|(
name|buf
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|tstring
parameter_list|(
name|s
parameter_list|)
name|int
name|s
decl_stmt|;
block|{
specifier|static
name|char
name|buf
index|[
literal|64
index|]
decl_stmt|;
if|if
condition|(
name|s
operator|>
literal|3600
condition|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%dh %dm %ds"
argument_list|,
name|s
operator|/
literal|3600
argument_list|,
operator|(
name|s
operator|%
literal|3600
operator|)
operator|/
literal|60
argument_list|,
name|s
operator|%
literal|60
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|s
operator|>
literal|60
condition|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%dm %ds"
argument_list|,
operator|(
name|s
operator|%
literal|3600
operator|)
operator|/
literal|60
argument_list|,
name|s
operator|%
literal|60
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%ds"
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
block|}
end_function

end_unit

