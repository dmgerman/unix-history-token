begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|"refer..c"
end_include

begin_define
define|#
directive|define
name|SAME
value|0
end_define

begin_define
define|#
directive|define
name|NFLAB
value|3000
end_define

begin_define
define|#
directive|define
name|NLABC
value|1000
end_define

begin_decl_stmt
specifier|static
name|char
name|sig
index|[
literal|400
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|bflab
index|[
name|NFLAB
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|labtab
index|[
name|NLABC
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|lookat
argument_list|()
decl_stmt|,
modifier|*
name|artskp
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|lbp
init|=
name|bflab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|labc
index|[
name|NLABC
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|stbuff
index|[
literal|50
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|prevsig
decl_stmt|;
end_decl_stmt

begin_macro
name|putsig
argument_list|(
argument|nf
argument_list|,
argument|flds
argument_list|,
argument|nref
argument_list|,
argument|nstline
argument_list|,
argument|endline
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|flds
index|[]
decl_stmt|,
modifier|*
name|nstline
decl_stmt|,
modifier|*
name|endline
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* choose signal style */
name|char
name|t
index|[
literal|200
index|]
decl_stmt|,
name|t1
index|[
literal|200
index|]
decl_stmt|,
name|t2
index|[
literal|200
index|]
decl_stmt|,
name|format
index|[
literal|10
index|]
decl_stmt|,
modifier|*
name|sd
decl_stmt|;
name|char
modifier|*
name|fpar
parameter_list|()
function_decl|;
name|int
name|another
init|=
literal|0
decl_stmt|;
name|int
name|addon
decl_stmt|,
name|addlet
decl_stmt|;
name|char
modifier|*
name|stline
decl_stmt|,
modifier|*
name|pr
decl_stmt|;
specifier|static
name|FILE
modifier|*
name|fhide
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|labels
condition|)
block|{
if|if
condition|(
name|nf
operator|==
literal|0
condition|)
comment|/* old */
name|sprintf
argument_list|(
name|t
argument_list|,
literal|"%s%c"
argument_list|,
name|labtab
index|[
name|nref
index|]
argument_list|,
name|labc
index|[
name|nref
index|]
argument_list|)
expr_stmt|;
else|else
block|{
operator|*
name|t
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|keywant
condition|)
block|{
name|pr
operator|=
name|fpar
argument_list|(
name|nf
argument_list|,
name|flds
argument_list|,
name|t1
argument_list|,
name|keywant
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|pr
condition|)
name|strcpy
argument_list|(
name|t
argument_list|,
name|pr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|t
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|labblkflg
condition|)
name|sprintf
argument_list|(
name|format
argument_list|,
name|nmlen
operator|>
literal|0
condition|?
literal|"%%.%ds %%s"
else|:
literal|"%%s %%s"
argument_list|,
name|nmlen
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|format
argument_list|,
name|nmlen
operator|>
literal|0
condition|?
literal|"%%.%ds%%s"
else|:
literal|"%%s%%s"
argument_list|,
name|nmlen
argument_list|)
expr_stmt|;
if|#
directive|if
name|D1
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"format is /%s/\n"
argument_list|,
name|format
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* format is %s%s for default labels or %.3s%s eg if wanted */
name|sd
operator|=
name|fpar
argument_list|(
name|nf
argument_list|,
name|flds
argument_list|,
name|t2
argument_list|,
literal|'D'
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|dtlen
operator|>
literal|0
condition|)
block|{
name|char
modifier|*
name|sdb
decl_stmt|;
for|for
control|(
name|sdb
operator|=
name|sd
init|;
operator|*
name|sd
condition|;
name|sd
operator|++
control|)
empty_stmt|;
name|sd
operator|=
name|sd
operator|-
name|dtlen
expr_stmt|;
if|if
condition|(
name|sd
operator|<
name|sdb
condition|)
name|sd
operator|=
name|sdb
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|t
argument_list|,
name|format
argument_list|,
name|fpar
argument_list|(
name|nf
argument_list|,
name|flds
argument_list|,
name|t1
argument_list|,
literal|'A'
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|sd
argument_list|)
expr_stmt|;
if|#
directive|if
name|D1
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"tag is /%s/\n"
argument_list|,
name|t
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|keywant
condition|)
block|{
name|addon
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|sd
operator|=
name|t
init|;
operator|*
name|sd
condition|;
name|sd
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|*
operator|--
name|sd
operator|==
literal|'-'
condition|)
block|{
name|addon
operator|=
literal|1
expr_stmt|;
operator|*
name|sd
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|addlet
operator|=
name|keylet
argument_list|(
name|t
argument_list|,
name|nref
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|keywant
operator|||
name|addon
condition|)
name|addch
argument_list|(
name|t
argument_list|,
name|addlet
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sort
condition|)
name|sprintf
argument_list|(
name|t
argument_list|,
literal|"%c%d%c"
argument_list|,
name|FLAG
argument_list|,
name|nref
argument_list|,
name|FLAG
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|sort
condition|)
name|sprintf
argument_list|(
name|t
argument_list|,
literal|"%c%d%c"
argument_list|,
name|FLAG
argument_list|,
name|nref
argument_list|,
name|FLAG
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|t
argument_list|,
literal|"%d"
argument_list|,
name|nref
argument_list|)
expr_stmt|;
block|}
name|another
operator|=
name|prefix
argument_list|(
literal|".["
argument_list|,
name|sd
operator|=
name|lookat
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|another
operator|&&
operator|(
name|strcmp
argument_list|(
literal|".[\n"
argument_list|,
name|sd
argument_list|)
operator|!=
name|SAME
operator|)
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"File %s, line %d- punctuation ignored from: %s"
argument_list|,
name|Ifile
argument_list|,
name|Iline
argument_list|,
name|sd
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|sig
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|#
directive|if
name|D1
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"sig is now %s leng %d\n"
argument_list|,
name|sig
argument_list|,
name|strlen
argument_list|(
name|sig
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|trimnl
argument_list|(
name|nstline
argument_list|)
expr_stmt|;
name|trimnl
argument_list|(
name|endline
argument_list|)
expr_stmt|;
name|stline
operator|=
name|stbuff
expr_stmt|;
if|if
condition|(
name|prevsig
operator|==
literal|0
condition|)
block|{
name|strcpy
argument_list|(
name|stline
argument_list|,
name|nstline
argument_list|)
expr_stmt|;
name|prevsig
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|stline
index|[
literal|2
index|]
operator|||
name|endline
index|[
literal|2
index|]
condition|)
block|{
name|stline
operator|+=
literal|2
expr_stmt|;
name|endline
operator|+=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|stline
operator|=
literal|"\\*([."
expr_stmt|;
name|endline
operator|=
literal|"\\*(.]"
expr_stmt|;
block|}
if|#
directive|if
name|D1
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"bare %d fhide %o fo %o another %d\n"
argument_list|,
name|bare
argument_list|,
name|fhide
argument_list|,
name|fo
argument_list|,
name|another
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|bare
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|another
operator|==
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|t1
argument_list|,
literal|"%s%s\%s\n"
argument_list|,
name|stline
argument_list|,
name|sig
argument_list|,
name|endline
argument_list|)
expr_stmt|;
name|append
argument_list|(
name|t1
argument_list|)
expr_stmt|;
name|flout
argument_list|()
expr_stmt|;
name|sig
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|prevsig
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|fo
operator|!=
name|NULL
operator|&&
name|fo
operator|==
name|fhide
condition|)
block|{
name|int
name|ch
decl_stmt|;
if|#
directive|if
name|D1
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"more hiding\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fclose
argument_list|(
name|fhide
argument_list|)
expr_stmt|;
name|fhide
operator|=
name|fopen
argument_list|(
name|hidenam
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|fo
operator|=
name|ftemp
expr_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
name|getc
argument_list|(
name|fhide
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
name|putc
argument_list|(
name|ch
argument_list|,
name|fo
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fhide
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|hidenam
argument_list|)
expr_stmt|;
if|#
directive|if
name|D1
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"past this stuff\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
else|else
block|{
name|strcat
argument_list|(
name|sig
argument_list|,
operator|(
name|labels
condition|?
literal|", "
else|:
literal|",\\|"
operator|)
argument_list|)
expr_stmt|;
comment|/* hide if need be */
if|if
condition|(
name|fo
operator|==
name|ftemp
condition|)
block|{
name|sprintf
argument_list|(
name|hidenam
argument_list|,
literal|"/tmp/rj%dc"
argument_list|,
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
if|#
directive|if
name|D1
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"hiding in %s\n"
argument_list|,
name|hidenam
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fhide
operator|=
name|fopen
argument_list|(
name|hidenam
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fhide
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|"Can't get scratch file %s"
argument_list|,
name|hidenam
argument_list|)
expr_stmt|;
name|fo
operator|=
name|fhide
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|bare
operator|<
literal|2
condition|)
if|if
condition|(
name|nf
operator|>
literal|0
condition|)
name|fprintf
argument_list|(
name|fo
argument_list|,
literal|".ds [F %s%c"
argument_list|,
name|t
argument_list|,
name|sep
argument_list|)
expr_stmt|;
if|if
condition|(
name|bare
operator|>
literal|0
condition|)
name|flout
argument_list|()
expr_stmt|;
if|#
directive|if
name|D1
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"sig is now %s\n"
argument_list|,
name|sig
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_function
name|char
modifier|*
name|fpar
parameter_list|(
name|nf
parameter_list|,
name|flds
parameter_list|,
name|out
parameter_list|,
name|c
parameter_list|,
name|seq
parameter_list|,
name|prepend
parameter_list|)
name|char
modifier|*
name|flds
index|[]
decl_stmt|,
decl|*
name|out
decl_stmt|;
end_function

begin_block
block|{
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|s
decl_stmt|;
name|int
name|i
decl_stmt|,
name|fnd
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nf
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|control
argument_list|(
name|flds
index|[
name|i
index|]
index|[
literal|0
index|]
argument_list|)
operator|&&
name|flds
index|[
name|i
index|]
index|[
literal|1
index|]
operator|==
name|c
operator|&&
operator|++
name|fnd
operator|>=
name|seq
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'L'
condition|)
block|{
name|p
operator|=
name|flds
index|[
name|i
index|]
operator|+
literal|3
expr_stmt|;
name|strcpy
argument_list|(
name|out
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|out
operator|)
return|;
block|}
if|if
condition|(
name|c
operator|!=
literal|'A'
operator|&&
name|c
operator|!=
literal|'D'
condition|)
comment|/* if not author, date use first word */
block|{
name|p
operator|=
name|flds
index|[
name|i
index|]
operator|+
literal|3
expr_stmt|;
name|p
operator|=
name|artskp
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|mycpy2
argument_list|(
name|out
argument_list|,
name|p
argument_list|,
literal|20
argument_list|)
expr_stmt|;
return|return
operator|(
name|out
operator|)
return|;
block|}
if|if
condition|(
name|c
operator|==
literal|'A'
operator|&&
name|lfirst
argument_list|(
name|p
operator|=
name|flds
index|[
name|i
index|]
operator|+
literal|3
argument_list|)
condition|)
comment|/* author in style Jones, A. */
block|{
for|for
control|(
name|s
operator|=
name|out
init|;
operator|*
name|p
operator|!=
literal|','
condition|;
name|p
operator|++
control|)
operator|*
name|s
operator|++
operator|=
operator|*
name|p
expr_stmt|;
operator|*
name|s
operator|++
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|prepend
condition|)
block|{
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
operator|*
name|s
operator|++
operator|=
operator|*
name|p
expr_stmt|;
operator|*
name|s
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|out
operator|)
return|;
block|}
for|for
control|(
name|s
operator|=
name|p
operator|=
name|flds
index|[
name|i
index|]
operator|+
literal|2
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
empty_stmt|;
while|while
condition|(
name|p
operator|>
name|s
operator|&&
operator|*
name|p
operator|!=
literal|' '
condition|)
name|p
operator|--
expr_stmt|;
comment|/* special wart for authors */
if|if
condition|(
name|c
operator|==
literal|'A'
operator|&&
operator|(
name|p
index|[
operator|-
literal|1
index|]
operator|==
literal|','
operator|||
name|p
index|[
literal|1
index|]
operator|==
literal|'('
operator|)
condition|)
block|{
name|p
operator|--
expr_stmt|;
while|while
condition|(
name|p
operator|>
name|s
operator|&&
operator|*
name|p
operator|!=
literal|' '
condition|)
name|p
operator|--
expr_stmt|;
name|mycpy
argument_list|(
name|out
argument_list|,
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|strcpy
argument_list|(
name|out
argument_list|,
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'A'
operator|&&
name|prepend
condition|)
name|initadd
argument_list|(
name|out
argument_list|,
name|flds
index|[
name|i
index|]
operator|+
literal|2
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|out
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|putkey
argument_list|(
argument|nf
argument_list|,
argument|flds
argument_list|,
argument|nref
argument_list|,
argument|keystr
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|flds
index|[]
decl_stmt|,
modifier|*
name|keystr
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|t1
index|[
literal|50
index|]
decl_stmt|,
modifier|*
name|sf
decl_stmt|;
name|int
name|ctype
decl_stmt|,
name|i
decl_stmt|,
name|count
decl_stmt|;
name|fprintf
argument_list|(
name|fo
argument_list|,
literal|".\\\""
argument_list|)
expr_stmt|;
if|if
condition|(
name|nf
operator|<=
literal|0
condition|)
name|fprintf
argument_list|(
name|fo
argument_list|,
literal|"%s%c%c"
argument_list|,
name|labtab
index|[
name|nref
index|]
argument_list|,
name|labc
index|[
name|nref
index|]
argument_list|,
name|sep
argument_list|)
expr_stmt|;
else|else
block|{
while|while
condition|(
name|ctype
operator|=
operator|*
name|keystr
operator|++
condition|)
block|{
name|count
operator|=
name|atoi
argument_list|(
name|keystr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|keystr
operator|==
literal|'+'
condition|)
name|count
operator|=
literal|999
expr_stmt|;
if|if
condition|(
name|count
operator|<=
literal|0
condition|)
name|count
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|count
condition|;
name|i
operator|++
control|)
block|{
name|sf
operator|=
name|fpar
argument_list|(
name|nf
argument_list|,
name|flds
argument_list|,
name|t1
argument_list|,
name|ctype
argument_list|,
name|i
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|sf
operator|==
literal|0
condition|)
break|break;
name|sf
operator|=
name|artskp
argument_list|(
name|sf
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fo
argument_list|,
literal|"%s%c"
argument_list|,
name|sf
argument_list|,
literal|'-'
argument_list|)
expr_stmt|;
block|}
block|}
name|fprintf
argument_list|(
name|fo
argument_list|,
literal|"%d%c"
argument_list|,
name|nref
argument_list|,
name|sep
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|keylet
argument_list|(
argument|t
argument_list|,
argument|nref
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|t
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
name|int
name|x
init|=
literal|'a'
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|nref
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|labtab
index|[
name|i
index|]
argument_list|,
name|t
argument_list|)
operator|==
literal|0
condition|)
name|x
operator|=
name|labc
index|[
name|i
index|]
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|labtab
index|[
name|nref
index|]
operator|=
name|lbp
argument_list|,
name|t
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|lbp
operator|++
condition|)
empty_stmt|;
if|if
condition|(
name|lbp
operator|-
name|bflab
operator|>
name|NFLAB
condition|)
name|err
argument_list|(
literal|"bflab overflow (%d)"
argument_list|,
name|NFLAB
argument_list|)
expr_stmt|;
if|if
condition|(
name|nref
operator|>
name|NLABC
condition|)
name|err
argument_list|(
literal|"nref in labc overflow (%d)"
argument_list|,
name|NLABC
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|D1
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"lbp up to %d of 2000\n"
argument_list|,
name|lbp
operator|-
name|bflab
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|labc
index|[
name|nref
index|]
operator|=
name|x
operator|+
literal|1
operator|)
return|;
block|}
end_block

begin_macro
name|mycpy
argument_list|(
argument|s
argument_list|,
argument|t
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|t
decl_stmt|;
end_decl_stmt

begin_block
block|{
while|while
condition|(
operator|*
name|t
operator|&&
operator|*
name|t
operator|!=
literal|','
operator|&&
operator|*
name|t
operator|!=
literal|' '
condition|)
operator|*
name|s
operator|++
operator|=
operator|*
name|t
operator|++
expr_stmt|;
operator|*
name|s
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_macro
name|mycpy2
argument_list|(
argument|s
argument_list|,
argument|t
argument_list|,
argument|n
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|t
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|c
decl_stmt|;
while|while
condition|(
name|n
operator|--
operator|&&
operator|(
name|c
operator|=
operator|*
name|t
operator|++
operator|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|' '
condition|)
name|c
operator|=
literal|'-'
expr_stmt|;
operator|*
name|s
operator|++
operator|=
name|c
expr_stmt|;
block|}
operator|*
name|s
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_macro
name|initadd
argument_list|(
argument|to
argument_list|,
argument|from
argument_list|,
argument|stop
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|to
decl_stmt|,
modifier|*
name|from
decl_stmt|,
modifier|*
name|stop
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|c
decl_stmt|,
name|nalph
init|=
literal|1
decl_stmt|;
while|while
condition|(
operator|*
name|to
condition|)
name|to
operator|++
expr_stmt|;
while|while
condition|(
name|from
operator|<
name|stop
condition|)
block|{
name|c
operator|=
operator|*
name|from
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|isalpha
argument_list|(
name|c
argument_list|)
condition|)
block|{
if|if
condition|(
name|nalph
condition|)
operator|*
name|to
operator|++
operator|=
literal|'.'
expr_stmt|;
name|nalph
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|nalph
operator|++
operator|==
literal|0
condition|)
operator|*
name|to
operator|++
operator|=
name|c
expr_stmt|;
block|}
operator|*
name|to
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_decl_stmt
specifier|static
name|char
modifier|*
name|articles
index|[]
init|=
block|{
literal|"the "
block|,
literal|"an "
block|,
literal|"a "
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|char
modifier|*
name|artskp
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
comment|/* skips over initial "a ", "an ", or "the " in s */
name|char
modifier|*
modifier|*
name|p
decl_stmt|,
modifier|*
name|r1
decl_stmt|,
modifier|*
name|r2
decl_stmt|;
for|for
control|(
name|p
operator|=
name|articles
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
block|{
name|r2
operator|=
name|s
expr_stmt|;
for|for
control|(
name|r1
operator|=
operator|*
name|p
init|;
operator|(
operator|(
operator|*
name|r1
operator|^
operator|*
name|r2
operator|)
operator|&
operator|~
literal|040
operator|)
operator|==
literal|0
condition|;
name|r1
operator|++
control|)
name|r2
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|r1
operator|==
literal|0
operator|&&
operator|*
name|r2
operator|!=
literal|0
condition|)
return|return
operator|(
name|r2
operator|)
return|;
block|}
return|return
operator|(
name|s
operator|)
return|;
block|}
end_function

begin_macro
name|expkey
argument_list|(
argument|or
argument_list|,
argument|nr
argument_list|,
argument|fwrite
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|fwrite
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|uniq
decl_stmt|,
name|less
decl_stmt|,
name|i
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
if|#
directive|if
name|D1
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"old %d key %s: '%c' new %d\n"
argument_list|,
name|or
argument_list|,
name|labtab
index|[
name|or
index|]
argument_list|,
name|labc
index|[
name|or
index|]
argument_list|,
name|nr
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* is this unique? how many are before it ? */
name|uniq
operator|=
literal|1
expr_stmt|;
name|less
operator|=
literal|'a'
expr_stmt|;
name|s
operator|=
name|labtab
index|[
name|or
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|refnum
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|==
name|or
condition|)
continue|continue;
if|if
condition|(
name|strcmp
argument_list|(
name|labtab
index|[
name|i
index|]
argument_list|,
name|s
argument_list|)
operator|!=
name|SAME
condition|)
continue|continue;
name|uniq
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|newr
index|[
name|i
index|]
operator|!=
literal|0
operator|&&
name|newr
index|[
name|i
index|]
operator|<
name|nr
condition|)
name|less
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|uniq
condition|)
name|fprintf
argument_list|(
name|fwrite
argument_list|,
literal|"%s"
argument_list|,
name|s
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|fwrite
argument_list|,
literal|"%s%c"
argument_list|,
name|s
argument_list|,
name|less
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|lfirst
argument_list|(
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* decides if s is name of format Jones, A */
name|char
modifier|*
name|index
argument_list|()
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|index
argument_list|(
name|s
argument_list|,
literal|','
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
while|while
condition|(
name|isspace
argument_list|(
operator|*
operator|++
name|p
argument_list|)
condition|)
empty_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"Jr"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"II"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|isupper
argument_list|(
operator|*
name|p
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

end_unit

