begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid
init|=
literal|"$Header: /na/franz/franz/RCS/sysat.c,v 1.5 83/02/19 15:33:09 layer Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*					-[Fri Feb 11 04:09:31 1983 by layer]-  * 	sysat.c				$Locker:  $  * startup data structure creation  *  * (c) copyright 1982, Regents of the University of California  */
end_comment

begin_include
include|#
directive|include
file|"global.h"
end_include

begin_include
include|#
directive|include
file|"lfuncs.h"
end_include

begin_define
define|#
directive|define
name|MK
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|,
name|z
parameter_list|)
value|mfun(x,y,z)
end_define

begin_define
define|#
directive|define
name|FIDDLE
parameter_list|(
name|z
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|,
name|y
parameter_list|)
value|z->a.clb=newdot(); (z->a.clb->d.car=newint())->i=b->i; \ 	z->a.clb->d.cdr=newdot(); (z->a.clb->d.cdr->d.car=newint())->i=c->i; \ 	z->a.clb->d.cdr->d.cdr=newdot(); (z->a.clb->d.cdr->d.cdr->d.car=newint())->i=y; \ 	b = z->a.clb->d.car; c = z->a.clb->d.cdr->d.car; \ 	copval(z,z->a.clb); z->a.clb = nil;
end_define

begin_define
define|#
directive|define
name|cforget
parameter_list|(
name|x
parameter_list|)
value|protect(x); Lforget(); unprot();
end_define

begin_comment
comment|/*  The following array serves as the temporary counters of the items	*/
end_comment

begin_comment
comment|/*  and pages used in each space.					*/
end_comment

begin_decl_stmt
name|long
name|int
name|tint
index|[
literal|2
operator|*
name|NUMSPACES
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|tgcthresh
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|initflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  starts off TRUE to indicate unsafe to gc  */
end_comment

begin_decl_stmt
specifier|extern
name|int
modifier|*
name|beginsweep
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* place for garbage collector to begin sweeping */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|page_limit
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* begin warning messages about running out of space */
end_comment

begin_decl_stmt
specifier|extern
name|char
name|purepage
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* which pages should not be swept by gc */
end_comment

begin_decl_stmt
specifier|extern
name|lispval
name|Iaddstat
argument_list|()
decl_stmt|,
name|Isstatus
argument_list|()
decl_stmt|;
end_decl_stmt

begin_macro
name|makevals
argument_list|()
end_macro

begin_block
block|{
name|int
name|i
decl_stmt|;
name|lispval
name|temp
decl_stmt|;
comment|/*  system list structure and atoms are initialized.  */
comment|/*  Before any lisp data can be created, the space usage */
comment|/*  counters must be set up, temporarily in array tint.  */
name|atom_items
operator|=
operator|(
name|lispval
operator|)
operator|&
name|tint
index|[
literal|0
index|]
expr_stmt|;
name|atom_pages
operator|=
operator|(
name|lispval
operator|)
operator|&
name|tint
index|[
literal|1
index|]
expr_stmt|;
name|str_items
operator|=
operator|(
name|lispval
operator|)
operator|&
name|tint
index|[
literal|2
index|]
expr_stmt|;
name|str_pages
operator|=
operator|(
name|lispval
operator|)
operator|&
name|tint
index|[
literal|3
index|]
expr_stmt|;
name|int_items
operator|=
operator|(
name|lispval
operator|)
operator|&
name|tint
index|[
literal|4
index|]
expr_stmt|;
name|int_pages
operator|=
operator|(
name|lispval
operator|)
operator|&
name|tint
index|[
literal|5
index|]
expr_stmt|;
name|dtpr_items
operator|=
operator|(
name|lispval
operator|)
operator|&
name|tint
index|[
literal|6
index|]
expr_stmt|;
name|dtpr_pages
operator|=
operator|(
name|lispval
operator|)
operator|&
name|tint
index|[
literal|7
index|]
expr_stmt|;
name|doub_items
operator|=
operator|(
name|lispval
operator|)
operator|&
name|tint
index|[
literal|8
index|]
expr_stmt|;
name|doub_pages
operator|=
operator|(
name|lispval
operator|)
operator|&
name|tint
index|[
literal|9
index|]
expr_stmt|;
name|sdot_items
operator|=
operator|(
name|lispval
operator|)
operator|&
name|tint
index|[
literal|10
index|]
expr_stmt|;
name|sdot_pages
operator|=
operator|(
name|lispval
operator|)
operator|&
name|tint
index|[
literal|11
index|]
expr_stmt|;
name|array_items
operator|=
operator|(
name|lispval
operator|)
operator|&
name|tint
index|[
literal|12
index|]
expr_stmt|;
name|array_pages
operator|=
operator|(
name|lispval
operator|)
operator|&
name|tint
index|[
literal|13
index|]
expr_stmt|;
name|val_items
operator|=
operator|(
name|lispval
operator|)
operator|&
name|tint
index|[
literal|14
index|]
expr_stmt|;
name|val_pages
operator|=
operator|(
name|lispval
operator|)
operator|&
name|tint
index|[
literal|15
index|]
expr_stmt|;
name|funct_items
operator|=
operator|(
name|lispval
operator|)
operator|&
name|tint
index|[
literal|16
index|]
expr_stmt|;
name|funct_pages
operator|=
operator|(
name|lispval
operator|)
operator|&
name|tint
index|[
literal|17
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|7
condition|;
name|i
operator|++
control|)
block|{
name|hunk_pages
index|[
name|i
index|]
operator|=
operator|(
name|lispval
operator|)
operator|&
name|tint
index|[
literal|18
operator|+
name|i
operator|*
literal|2
index|]
expr_stmt|;
name|hunk_items
index|[
name|i
index|]
operator|=
operator|(
name|lispval
operator|)
operator|&
name|tint
index|[
literal|19
operator|+
name|i
operator|*
literal|2
index|]
expr_stmt|;
block|}
name|vect_items
operator|=
operator|(
name|lispval
operator|)
operator|&
name|tint
index|[
literal|34
index|]
expr_stmt|;
name|vecti_items
operator|=
operator|(
name|lispval
operator|)
operator|&
name|tint
index|[
literal|35
index|]
expr_stmt|;
name|vect_pages
operator|=
operator|(
name|lispval
operator|)
operator|&
name|tint
index|[
literal|36
index|]
expr_stmt|;
name|vecti_pages
operator|=
operator|(
name|lispval
operator|)
operator|&
name|tint
index|[
literal|37
index|]
expr_stmt|;
name|other_items
operator|=
operator|(
name|lispval
operator|)
operator|&
name|tint
index|[
literal|38
index|]
expr_stmt|;
name|other_pages
operator|=
operator|(
name|lispval
operator|)
operator|&
name|tint
index|[
literal|39
index|]
expr_stmt|;
comment|/*  This also applies to the garbage collection threshhold  */
name|gcthresh
operator|=
operator|(
name|lispval
operator|)
operator|&
name|tgcthresh
expr_stmt|;
comment|/*  Now we commence constructing system lisp structures.  */
comment|/*  nil is a special case, constructed especially at location zero  */
name|hasht
index|[
name|hashfcn
argument_list|(
literal|"nil"
argument_list|)
index|]
operator|=
operator|(
expr|struct
name|atom
operator|*
operator|)
name|nil
expr_stmt|;
comment|/* allocate space for namestack and bindstack first 	 * then set up beginsweep variable so that the sweeper will 	 * ignore these `always in use' pages 	 */
name|lbot
operator|=
name|orgnp
operator|=
name|np
operator|=
operator|(
operator|(
expr|struct
name|argent
operator|*
operator|)
name|csegment
argument_list|(
name|VALUE
argument_list|,
name|NAMESIZE
argument_list|,
name|FALSE
argument_list|)
operator|)
expr_stmt|;
name|orgbnp
operator|=
name|bnp
operator|=
operator|(
operator|(
expr|struct
name|nament
operator|*
operator|)
name|csegment
argument_list|(
name|DTPR
argument_list|,
name|NAMESIZE
argument_list|,
name|FALSE
argument_list|)
operator|)
expr_stmt|;
comment|/* since these dtpr pages will not be swept, we don't want them 	 * to show up in count of dtpr pages allocated or it will confuse 	 * gcafter when it tries to determine how much space is free 	 */
name|dtpr_pages
operator|->
name|i
operator|=
literal|0
expr_stmt|;
name|beginsweep
operator|=
operator|(
name|int
operator|*
operator|)
name|xsbrk
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 *  patching up info in type and pure tables 	 */
for|for
control|(
name|i
operator|=
operator|(
operator|(
name|int
operator|)
name|beginsweep
operator|)
operator|>>
literal|9
init|;
name|i
operator|<
name|TTSIZE
condition|;
name|i
operator|++
control|)
operator|(
name|typetable
operator|+
literal|1
operator|)
index|[
name|i
index|]
operator|=
name|OTHER
expr_stmt|;
name|purepage
index|[
operator|(
operator|(
name|int
operator|)
name|np
operator|)
operator|>>
literal|9
index|]
operator|=
literal|1
expr_stmt|;
comment|/* Mark these as non-gc'd arrays */
name|purepage
index|[
operator|(
operator|(
name|int
operator|)
name|bnp
operator|)
operator|>>
literal|9
index|]
operator|=
literal|1
expr_stmt|;
comment|/* 	 * Names of various spaces and things 	 */
name|atom_name
operator|=
name|matom
argument_list|(
literal|"symbol"
argument_list|)
expr_stmt|;
name|str_name
operator|=
name|matom
argument_list|(
literal|"string"
argument_list|)
expr_stmt|;
name|int_name
operator|=
name|matom
argument_list|(
literal|"fixnum"
argument_list|)
expr_stmt|;
name|dtpr_name
operator|=
name|matom
argument_list|(
literal|"list"
argument_list|)
expr_stmt|;
name|doub_name
operator|=
name|matom
argument_list|(
literal|"flonum"
argument_list|)
expr_stmt|;
name|sdot_name
operator|=
name|matom
argument_list|(
literal|"bignum"
argument_list|)
expr_stmt|;
name|array_name
operator|=
name|matom
argument_list|(
literal|"array"
argument_list|)
expr_stmt|;
name|val_name
operator|=
name|matom
argument_list|(
literal|"value"
argument_list|)
expr_stmt|;
name|funct_name
operator|=
name|matom
argument_list|(
literal|"binary"
argument_list|)
expr_stmt|;
name|port_name
operator|=
name|matom
argument_list|(
literal|"port"
argument_list|)
expr_stmt|;
comment|/* not really a space */
name|vect_name
operator|=
name|matom
argument_list|(
literal|"vector"
argument_list|)
expr_stmt|;
name|vecti_name
operator|=
name|matom
argument_list|(
literal|"vectori"
argument_list|)
expr_stmt|;
name|other_name
operator|=
name|matom
argument_list|(
literal|"other"
argument_list|)
expr_stmt|;
block|{
name|char
name|name
index|[
literal|6
index|]
decl_stmt|,
modifier|*
name|strcpy
argument_list|()
decl_stmt|;
name|strcpy
argument_list|(
name|name
argument_list|,
literal|"hunk0"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|7
condition|;
name|i
operator|++
control|)
block|{
name|hunk_name
index|[
name|i
index|]
operator|=
name|matom
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|name
index|[
literal|4
index|]
operator|++
expr_stmt|;
block|}
block|}
comment|/*  set up the name stack as an array of pointers */
name|nplim
operator|=
name|orgnp
operator|+
name|NAMESIZE
operator|-
literal|6
operator|*
name|NAMINC
expr_stmt|;
name|temp
operator|=
name|matom
argument_list|(
literal|"namestack"
argument_list|)
expr_stmt|;
name|nstack
operator|=
name|temp
operator|->
name|a
operator|.
name|fnbnd
operator|=
name|newarray
argument_list|()
expr_stmt|;
name|nstack
operator|->
name|ar
operator|.
name|data
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|np
operator|)
expr_stmt|;
operator|(
name|nstack
operator|->
name|ar
operator|.
name|length
operator|=
name|newint
argument_list|()
operator|)
operator|->
name|i
operator|=
name|NAMESIZE
expr_stmt|;
operator|(
name|nstack
operator|->
name|ar
operator|.
name|delta
operator|=
name|newint
argument_list|()
operator|)
operator|->
name|i
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|argent
argument_list|)
expr_stmt|;
name|Vnogbar
operator|=
name|matom
argument_list|(
literal|"unmarked_array"
argument_list|)
expr_stmt|;
comment|/* marking of the namestack will be done explicitly in gc1 */
operator|(
name|nstack
operator|->
name|ar
operator|.
name|aux
operator|=
name|newdot
argument_list|()
operator|)
operator|->
name|d
operator|.
name|car
operator|=
name|Vnogbar
expr_stmt|;
comment|/* set up the binding stack as an array of dotted pairs */
name|bnplim
operator|=
name|orgbnp
operator|+
name|NAMESIZE
operator|-
literal|5
expr_stmt|;
name|temp
operator|=
name|matom
argument_list|(
literal|"bindstack"
argument_list|)
expr_stmt|;
name|bstack
operator|=
name|temp
operator|->
name|a
operator|.
name|fnbnd
operator|=
name|newarray
argument_list|()
expr_stmt|;
name|bstack
operator|->
name|ar
operator|.
name|data
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|bnp
operator|)
expr_stmt|;
operator|(
name|bstack
operator|->
name|ar
operator|.
name|length
operator|=
name|newint
argument_list|()
operator|)
operator|->
name|i
operator|=
name|NAMESIZE
expr_stmt|;
operator|(
name|bstack
operator|->
name|ar
operator|.
name|delta
operator|=
name|newint
argument_list|()
operator|)
operator|->
name|i
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|nament
argument_list|)
expr_stmt|;
comment|/* marking of the bindstack will be done explicitly in gc1 */
operator|(
name|bstack
operator|->
name|ar
operator|.
name|aux
operator|=
name|newdot
argument_list|()
operator|)
operator|->
name|d
operator|.
name|car
operator|=
name|Vnogbar
expr_stmt|;
comment|/* more atoms */
name|tatom
operator|=
name|matom
argument_list|(
literal|"t"
argument_list|)
expr_stmt|;
name|tatom
operator|->
name|a
operator|.
name|clb
operator|=
name|tatom
expr_stmt|;
name|lambda
operator|=
name|matom
argument_list|(
literal|"lambda"
argument_list|)
expr_stmt|;
name|nlambda
operator|=
name|matom
argument_list|(
literal|"nlambda"
argument_list|)
expr_stmt|;
name|macro
operator|=
name|matom
argument_list|(
literal|"macro"
argument_list|)
expr_stmt|;
name|ibase
operator|=
name|matom
argument_list|(
literal|"ibase"
argument_list|)
expr_stmt|;
comment|/* base for input conversion */
name|ibase
operator|->
name|a
operator|.
name|clb
operator|=
name|inewint
argument_list|(
literal|10
argument_list|)
expr_stmt|;
operator|(
name|matom
argument_list|(
literal|"base"
argument_list|)
operator|)
operator|->
name|a
operator|.
name|clb
operator|=
name|ibase
operator|->
name|a
operator|.
name|clb
expr_stmt|;
name|fclosure
operator|=
name|matom
argument_list|(
literal|"fclosure"
argument_list|)
expr_stmt|;
name|rsetatom
operator|=
name|matom
argument_list|(
literal|"*rset"
argument_list|)
expr_stmt|;
name|rsetatom
operator|->
name|a
operator|.
name|clb
operator|=
name|nil
expr_stmt|;
name|Vsubrou
operator|=
name|matom
argument_list|(
literal|"subroutine"
argument_list|)
expr_stmt|;
name|Vpiport
operator|=
name|matom
argument_list|(
literal|"piport"
argument_list|)
expr_stmt|;
name|Vpiport
operator|->
name|a
operator|.
name|clb
operator|=
name|P
argument_list|(
name|piport
operator|=
name|stdin
argument_list|)
expr_stmt|;
comment|/* standard input */
name|Vpoport
operator|=
name|matom
argument_list|(
literal|"poport"
argument_list|)
expr_stmt|;
name|Vpoport
operator|->
name|a
operator|.
name|clb
operator|=
name|P
argument_list|(
name|poport
operator|=
name|stdout
argument_list|)
expr_stmt|;
comment|/* stand. output */
name|matom
argument_list|(
literal|"errport"
argument_list|)
operator|->
name|a
operator|.
name|clb
operator|=
operator|(
name|P
argument_list|(
name|errport
operator|=
name|stderr
argument_list|)
operator|)
expr_stmt|;
comment|/* stand. err. */
name|ioname
index|[
name|PN
argument_list|(
name|stdin
argument_list|)
index|]
operator|=
operator|(
name|lispval
operator|)
name|pinewstr
argument_list|(
literal|"$stdin"
argument_list|)
expr_stmt|;
name|ioname
index|[
name|PN
argument_list|(
name|stdout
argument_list|)
index|]
operator|=
operator|(
name|lispval
operator|)
name|pinewstr
argument_list|(
literal|"$stdout"
argument_list|)
expr_stmt|;
name|ioname
index|[
name|PN
argument_list|(
name|stderr
argument_list|)
index|]
operator|=
operator|(
name|lispval
operator|)
name|pinewstr
argument_list|(
literal|"$stderr"
argument_list|)
expr_stmt|;
name|matom
argument_list|(
literal|"Standard-Input"
argument_list|)
operator|->
name|a
operator|.
name|clb
operator|=
name|Vpiport
operator|->
name|a
operator|.
name|clb
expr_stmt|;
name|matom
argument_list|(
literal|"Standard-Output"
argument_list|)
operator|->
name|a
operator|.
name|clb
operator|=
name|Vpoport
operator|->
name|a
operator|.
name|clb
expr_stmt|;
name|matom
argument_list|(
literal|"Standard-Error"
argument_list|)
operator|->
name|a
operator|.
name|clb
operator|=
name|P
argument_list|(
name|errport
argument_list|)
expr_stmt|;
operator|(
name|Vreadtable
operator|=
name|matom
argument_list|(
literal|"readtable"
argument_list|)
operator|)
operator|->
name|a
operator|.
name|clb
operator|=
name|Imkrtab
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|strtab
operator|=
name|Imkrtab
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|Vptport
operator|=
name|matom
argument_list|(
literal|"ptport"
argument_list|)
expr_stmt|;
name|Vptport
operator|->
name|a
operator|.
name|clb
operator|=
name|nil
expr_stmt|;
comment|/* protocal port */
name|Vcntlw
operator|=
name|matom
argument_list|(
literal|"^w"
argument_list|)
expr_stmt|;
comment|/* when non nil, inhibits output to term */
name|Vcntlw
operator|->
name|a
operator|.
name|clb
operator|=
name|nil
expr_stmt|;
name|Vldprt
operator|=
name|matom
argument_list|(
literal|"$ldprint"
argument_list|)
expr_stmt|;
comment|/* when nil, inhibits printing of fasl/autoload   */
comment|/* cfasl messages to term */
name|Vldprt
operator|->
name|a
operator|.
name|clb
operator|=
name|tatom
expr_stmt|;
name|Vprinlevel
operator|=
name|matom
argument_list|(
literal|"prinlevel"
argument_list|)
expr_stmt|;
comment|/* printer recursion count */
name|Vprinlevel
operator|->
name|a
operator|.
name|clb
operator|=
name|nil
expr_stmt|;
comment|/* infinite recursion */
name|Vprinlength
operator|=
name|matom
argument_list|(
literal|"prinlength"
argument_list|)
expr_stmt|;
comment|/* printer element count */
name|Vprinlength
operator|->
name|a
operator|.
name|clb
operator|=
name|nil
expr_stmt|;
comment|/* infinite elements */
name|Vfloatformat
operator|=
name|matom
argument_list|(
literal|"float-format"
argument_list|)
expr_stmt|;
name|Vfloatformat
operator|->
name|a
operator|.
name|clb
operator|=
operator|(
name|lispval
operator|)
name|pinewstr
argument_list|(
literal|"%.16g"
argument_list|)
expr_stmt|;
name|Verdepth
operator|=
name|matom
argument_list|(
literal|"Error-Depth"
argument_list|)
expr_stmt|;
name|Verdepth
operator|->
name|a
operator|.
name|clb
operator|=
name|inewint
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* depth of error */
name|Vpurcopylits
operator|=
name|matom
argument_list|(
literal|"$purcopylits"
argument_list|)
expr_stmt|;
name|Vpurcopylits
operator|->
name|a
operator|.
name|clb
operator|=
name|tatom
expr_stmt|;
comment|/* tells fasl to purcopy 						 *  literals it reads 						 */
name|Vdisplacemacros
operator|=
name|matom
argument_list|(
literal|"displace-macros"
argument_list|)
expr_stmt|;
name|Vdisplacemacros
operator|->
name|a
operator|.
name|clb
operator|=
name|nil
expr_stmt|;
comment|/* replace macros calls 						 * with their expanded forms 						 */
comment|/*  The following atoms are used as tokens by the reader  */
name|perda
operator|=
name|matom
argument_list|(
literal|"."
argument_list|)
expr_stmt|;
name|lpara
operator|=
name|matom
argument_list|(
literal|"("
argument_list|)
expr_stmt|;
name|rpara
operator|=
name|matom
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
name|lbkta
operator|=
name|matom
argument_list|(
literal|"["
argument_list|)
expr_stmt|;
name|rbkta
operator|=
name|matom
argument_list|(
literal|"]"
argument_list|)
expr_stmt|;
name|snqta
operator|=
name|matom
argument_list|(
literal|"'"
argument_list|)
expr_stmt|;
name|exclpa
operator|=
name|matom
argument_list|(
literal|"!"
argument_list|)
expr_stmt|;
operator|(
name|Eofa
operator|=
name|matom
argument_list|(
literal|"eof"
argument_list|)
operator|)
operator|->
name|a
operator|.
name|clb
operator|=
name|eofa
expr_stmt|;
name|cara
operator|=
name|MK
argument_list|(
literal|"car"
argument_list|,
name|Lcar
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|cdra
operator|=
name|MK
argument_list|(
literal|"cdr"
argument_list|,
name|Lcdr
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
comment|/*  The following few atoms have values the reader tokens.  */
comment|/*  Perhaps this is a kludge which should be abandoned.  */
comment|/*  On the other hand, perhaps it is an inspiration.	*/
name|matom
argument_list|(
literal|"perd"
argument_list|)
operator|->
name|a
operator|.
name|clb
operator|=
name|perda
expr_stmt|;
name|matom
argument_list|(
literal|"lpar"
argument_list|)
operator|->
name|a
operator|.
name|clb
operator|=
name|lpara
expr_stmt|;
name|matom
argument_list|(
literal|"rpar"
argument_list|)
operator|->
name|a
operator|.
name|clb
operator|=
name|rpara
expr_stmt|;
name|matom
argument_list|(
literal|"lbkt"
argument_list|)
operator|->
name|a
operator|.
name|clb
operator|=
name|lbkta
expr_stmt|;
name|matom
argument_list|(
literal|"rbkt"
argument_list|)
operator|->
name|a
operator|.
name|clb
operator|=
name|rbkta
expr_stmt|;
name|noptop
operator|=
name|matom
argument_list|(
literal|"noptop"
argument_list|)
expr_stmt|;
comment|/*  atoms used in connection with comments.  */
name|commta
operator|=
name|matom
argument_list|(
literal|"comment"
argument_list|)
expr_stmt|;
name|rcomms
operator|=
name|matom
argument_list|(
literal|"readcomments"
argument_list|)
expr_stmt|;
comment|/*  the following atoms are used for lexprs */
name|lexpr_atom
operator|=
name|matom
argument_list|(
literal|"last lexpr binding\7"
argument_list|)
expr_stmt|;
name|lexpr
operator|=
name|matom
argument_list|(
literal|"lexpr"
argument_list|)
expr_stmt|;
comment|/* the following atom is used to reference the bind stack for eval */
name|bptr_atom
operator|=
name|matom
argument_list|(
literal|"eval1 binding pointer\7"
argument_list|)
expr_stmt|;
name|bptr_atom
operator|->
name|a
operator|.
name|clb
operator|=
name|nil
expr_stmt|;
comment|/* the following atoms are used for evalhook hackery */
name|evalhatom
operator|=
name|matom
argument_list|(
literal|"evalhook"
argument_list|)
expr_stmt|;
name|evalhatom
operator|->
name|a
operator|.
name|clb
operator|=
name|nil
expr_stmt|;
name|evalhcallsw
operator|=
name|FALSE
expr_stmt|;
name|funhatom
operator|=
name|matom
argument_list|(
literal|"funcallhook"
argument_list|)
expr_stmt|;
name|funhatom
operator|->
name|a
operator|.
name|clb
operator|=
name|nil
expr_stmt|;
name|funhcallsw
operator|=
name|FALSE
expr_stmt|;
name|Vevalframe
operator|=
name|matom
argument_list|(
literal|"evalframe"
argument_list|)
expr_stmt|;
name|sysa
operator|=
name|matom
argument_list|(
literal|"sys"
argument_list|)
expr_stmt|;
name|plima
operator|=
name|matom
argument_list|(
literal|"pagelimit"
argument_list|)
expr_stmt|;
comment|/*  max number of pages  */
name|Veval
operator|=
name|MK
argument_list|(
literal|"eval"
argument_list|,
name|Leval1
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"asin"
argument_list|,
name|Lasin
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"acos"
argument_list|,
name|Lacos
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"atan"
argument_list|,
name|Latan
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"cos"
argument_list|,
name|Lcos
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"sin"
argument_list|,
name|Lsin
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"sqrt"
argument_list|,
name|Lsqrt
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"exp"
argument_list|,
name|Lexp
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"log"
argument_list|,
name|Llog
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"lsh"
argument_list|,
name|Llsh
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"bignum-leftshift"
argument_list|,
name|Lbiglsh
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"sticky-bignum-leftshift"
argument_list|,
name|Lsbiglsh
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"frexp"
argument_list|,
name|Lfrexp
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"rot"
argument_list|,
name|Lrot
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"random"
argument_list|,
name|Lrandom
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"atom"
argument_list|,
name|Latom
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"apply"
argument_list|,
name|Lapply
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"funcall"
argument_list|,
name|Lfuncal
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"lexpr-funcall"
argument_list|,
name|Llexfun
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"return"
argument_list|,
name|Lreturn
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
comment|/* 	MK("cont",Lreturn,lambda);  */
name|MK
argument_list|(
literal|"cons"
argument_list|,
name|Lcons
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"scons"
argument_list|,
name|Lscons
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"bignum-to-list"
argument_list|,
name|Lbigtol
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"cadr"
argument_list|,
name|Lcadr
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"caar"
argument_list|,
name|Lcaar
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"cddr"
argument_list|,
name|Lc02r
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"caddr"
argument_list|,
name|Lc12r
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"cdddr"
argument_list|,
name|Lc03r
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"cadddr"
argument_list|,
name|Lc13r
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"cddddr"
argument_list|,
name|Lc04r
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"caddddr"
argument_list|,
name|Lc14r
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"nthelem"
argument_list|,
name|Lnthelem
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"eq"
argument_list|,
name|Leq
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"equal"
argument_list|,
name|Lequal
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
comment|/**	MK("zqual",Zequal,lambda); 	*/
name|MK
argument_list|(
literal|"numberp"
argument_list|,
name|Lnumberp
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"dtpr"
argument_list|,
name|Ldtpr
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"bcdp"
argument_list|,
name|Lbcdp
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"portp"
argument_list|,
name|Lportp
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"arrayp"
argument_list|,
name|Larrayp
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"valuep"
argument_list|,
name|Lvaluep
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"get_pname"
argument_list|,
name|Lpname
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"ptr"
argument_list|,
name|Lptr
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"arrayref"
argument_list|,
name|Larrayref
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"marray"
argument_list|,
name|Lmarray
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"getlength"
argument_list|,
name|Lgetl
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"putlength"
argument_list|,
name|Lputl
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"getaccess"
argument_list|,
name|Lgeta
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"putaccess"
argument_list|,
name|Lputa
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"getdelta"
argument_list|,
name|Lgetdel
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"putdelta"
argument_list|,
name|Lputdel
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"getaux"
argument_list|,
name|Lgetaux
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"putaux"
argument_list|,
name|Lputaux
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"getdata"
argument_list|,
name|Lgetdata
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"putdata"
argument_list|,
name|Lputdata
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"mfunction"
argument_list|,
name|Lmfunction
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"getentry"
argument_list|,
name|Lgetentry
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"getdisc"
argument_list|,
name|Lgetdisc
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"putdisc"
argument_list|,
name|Lputdisc
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"segment"
argument_list|,
name|Lsegment
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"rplaca"
argument_list|,
name|Lrplaca
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"rplacd"
argument_list|,
name|Lrplacd
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"set"
argument_list|,
name|Lset
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"replace"
argument_list|,
name|Lreplace
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"infile"
argument_list|,
name|Linfile
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"outfile"
argument_list|,
name|Loutfile
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"terpr"
argument_list|,
name|Lterpr
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"print"
argument_list|,
name|Lprint
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"close"
argument_list|,
name|Lclose
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"patom"
argument_list|,
name|Lpatom
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"pntlen"
argument_list|,
name|Lpntlen
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"read"
argument_list|,
name|Lread
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"ratom"
argument_list|,
name|Lratom
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"readc"
argument_list|,
name|Lreadc
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"truename"
argument_list|,
name|Ltruename
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"implode"
argument_list|,
name|Limplode
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"maknam"
argument_list|,
name|Lmaknam
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"concat"
argument_list|,
name|Lconcat
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"uconcat"
argument_list|,
name|Luconcat
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"putprop"
argument_list|,
name|Lputprop
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"monitor"
argument_list|,
name|Lmonitor
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"get"
argument_list|,
name|Lget
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"getd"
argument_list|,
name|Lgetd
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"putd"
argument_list|,
name|Lputd
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"prog"
argument_list|,
name|Nprog
argument_list|,
name|nlambda
argument_list|)
expr_stmt|;
name|quota
operator|=
name|MK
argument_list|(
literal|"quote"
argument_list|,
name|Nquote
argument_list|,
name|nlambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"function"
argument_list|,
name|Nfunction
argument_list|,
name|nlambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"go"
argument_list|,
name|Ngo
argument_list|,
name|nlambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"*catch"
argument_list|,
name|Ncatch
argument_list|,
name|nlambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"errset"
argument_list|,
name|Nerrset
argument_list|,
name|nlambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"status"
argument_list|,
name|Nstatus
argument_list|,
name|nlambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"sstatus"
argument_list|,
name|Nsstatus
argument_list|,
name|nlambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"err"
argument_list|,
name|Lerr
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"*throw"
argument_list|,
name|Nthrow
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
comment|/* this is a lambda now !! */
name|reseta
operator|=
name|MK
argument_list|(
literal|"reset"
argument_list|,
name|Nreset
argument_list|,
name|nlambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"break"
argument_list|,
name|Nbreak
argument_list|,
name|nlambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"exit"
argument_list|,
name|Lexit
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"def"
argument_list|,
name|Ndef
argument_list|,
name|nlambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"null"
argument_list|,
name|Lnull
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
comment|/* debugging, remove when done */
block|{
name|lispval
name|Lframedump
parameter_list|()
function_decl|;
name|MK
argument_list|(
literal|"framedump"
argument_list|,
name|Lframedump
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
block|}
name|MK
argument_list|(
literal|"and"
argument_list|,
name|Nand
argument_list|,
name|nlambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"or"
argument_list|,
name|Nor
argument_list|,
name|nlambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"setq"
argument_list|,
name|Nsetq
argument_list|,
name|nlambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"cond"
argument_list|,
name|Ncond
argument_list|,
name|nlambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"list"
argument_list|,
name|Llist
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"load"
argument_list|,
name|Lload
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"nwritn"
argument_list|,
name|Lnwritn
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"*process"
argument_list|,
name|Lprocess
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
comment|/*  execute a shell command  */
name|MK
argument_list|(
literal|"allocate"
argument_list|,
name|Lalloc
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
comment|/*  allocate a page  */
name|MK
argument_list|(
literal|"sizeof"
argument_list|,
name|Lsizeof
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
comment|/*  size of one item of a data type  */
name|MK
argument_list|(
literal|"dumplisp"
argument_list|,
name|Ndumplisp
argument_list|,
name|nlambda
argument_list|)
expr_stmt|;
comment|/*  NEW save the world  */
name|MK
argument_list|(
literal|"top-level"
argument_list|,
name|Ntpl
argument_list|,
name|nlambda
argument_list|)
expr_stmt|;
comment|/*  top level eval-print read loop  */
name|startup
operator|=
name|matom
argument_list|(
literal|"startup"
argument_list|)
expr_stmt|;
comment|/*  used by save and restore  */
name|MK
argument_list|(
literal|"mapcar"
argument_list|,
name|Lmapcar
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"maplist"
argument_list|,
name|Lmaplist
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"mapcan"
argument_list|,
name|Lmapcan
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"mapcon"
argument_list|,
name|Lmapcon
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"assq"
argument_list|,
name|Lassq
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"mapc"
argument_list|,
name|Lmapc
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"map"
argument_list|,
name|Lmap
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"flatc"
argument_list|,
name|Lflatsi
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"alphalessp"
argument_list|,
name|Lalfalp
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"drain"
argument_list|,
name|Ldrain
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"killcopy"
argument_list|,
name|Lkilcopy
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
comment|/*  forks aand aborts for adb */
name|MK
argument_list|(
literal|"opval"
argument_list|,
name|Lopval
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
comment|/*  sets and retrieves system variables  */
name|MK
argument_list|(
literal|"ncons"
argument_list|,
name|Lncons
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|sysa
operator|=
name|matom
argument_list|(
literal|"sys"
argument_list|)
expr_stmt|;
comment|/*  sys indicator for system variables  */
name|MK
argument_list|(
literal|"remob"
argument_list|,
name|Lforget
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
comment|/*  function to take atom out of hash table  */
name|splice
operator|=
name|matom
argument_list|(
literal|"splicing"
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"not"
argument_list|,
name|Lnull
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"plus"
argument_list|,
name|Ladd
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"add"
argument_list|,
name|Ladd
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"times"
argument_list|,
name|Ltimes
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"difference"
argument_list|,
name|Lsub
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"quotient"
argument_list|,
name|Lquo
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"+"
argument_list|,
name|Lfp
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"-"
argument_list|,
name|Lfm
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"*"
argument_list|,
name|Lft
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"/"
argument_list|,
name|Lfd
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"1+"
argument_list|,
name|Lfadd1
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"1-"
argument_list|,
name|Lfsub1
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"<"
argument_list|,
name|Lflessp
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"mod"
argument_list|,
name|Lmod
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"minus"
argument_list|,
name|Lminus
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"absval"
argument_list|,
name|Labsval
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"add1"
argument_list|,
name|Ladd1
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"sub1"
argument_list|,
name|Lsub1
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"greaterp"
argument_list|,
name|Lgreaterp
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"lessp"
argument_list|,
name|Llessp
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"any-zerop"
argument_list|,
name|Lzerop
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
comment|/* used when bignum arg possible */
name|MK
argument_list|(
literal|"zerop"
argument_list|,
name|Lzerop
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"minusp"
argument_list|,
name|Lnegp
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"onep"
argument_list|,
name|Lonep
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"sum"
argument_list|,
name|Ladd
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"product"
argument_list|,
name|Ltimes
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"do"
argument_list|,
name|Ndo
argument_list|,
name|nlambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"progv"
argument_list|,
name|Nprogv
argument_list|,
name|nlambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"progn"
argument_list|,
name|Nprogn
argument_list|,
name|nlambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"prog2"
argument_list|,
name|Nprog2
argument_list|,
name|nlambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"oblist"
argument_list|,
name|Loblist
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"baktrace"
argument_list|,
name|Lbaktrace
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"tyi"
argument_list|,
name|Ltyi
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"tyipeek"
argument_list|,
name|Ltyipeek
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"untyi"
argument_list|,
name|Luntyi
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"tyo"
argument_list|,
name|Ltyo
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"termcapinit"
argument_list|,
name|Ltci
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"termcapexe"
argument_list|,
name|Ltcx
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"int:setsyntax"
argument_list|,
name|Lsetsyn
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
comment|/* an internal function */
name|MK
argument_list|(
literal|"int:getsyntax"
argument_list|,
name|Lgetsyntax
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"int:showstack"
argument_list|,
name|LIshowstack
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"int:franz-call"
argument_list|,
name|LIfranzcall
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"makereadtable"
argument_list|,
name|Lmakertbl
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"zapline"
argument_list|,
name|Lzapline
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"aexplode"
argument_list|,
name|Lexplda
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"aexplodec"
argument_list|,
name|Lexpldc
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"aexploden"
argument_list|,
name|Lexpldn
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"hashtabstat"
argument_list|,
name|Lhashst
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|METER
name|MK
argument_list|(
literal|"gcstat"
argument_list|,
name|Lgcstat
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|MK
argument_list|(
literal|"argv"
argument_list|,
name|Largv
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"arg"
argument_list|,
name|Larg
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"setarg"
argument_list|,
name|Lsetarg
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"showstack"
argument_list|,
name|Lshostk
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"freturn"
argument_list|,
name|Lfretn
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"*rset"
argument_list|,
name|Lrset
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"eval1"
argument_list|,
name|Leval1
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"evalframe"
argument_list|,
name|Levalf
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"evalhook"
argument_list|,
name|Levalhook
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"funcallhook"
argument_list|,
name|Lfunhook
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"resetio"
argument_list|,
name|Nresetio
argument_list|,
name|nlambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"chdir"
argument_list|,
name|Lchdir
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"ascii"
argument_list|,
name|Lascii
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"boole"
argument_list|,
name|Lboole
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"type"
argument_list|,
name|Ltype
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
comment|/* returns type-name of argument */
name|MK
argument_list|(
literal|"fix"
argument_list|,
name|Lfix
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"float"
argument_list|,
name|Lfloat
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"fact"
argument_list|,
name|Lfact
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"cpy1"
argument_list|,
name|Lcpy1
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"Divide"
argument_list|,
name|LDivide
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"Emuldiv"
argument_list|,
name|LEmuldiv
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"readlist"
argument_list|,
name|Lreadli
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"plist"
argument_list|,
name|Lplist
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
comment|/* gives the plist of an atom */
name|MK
argument_list|(
literal|"setplist"
argument_list|,
name|Lsetpli
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
comment|/* get plist of an atom  */
name|MK
argument_list|(
literal|"eval-when"
argument_list|,
name|Nevwhen
argument_list|,
name|nlambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"syscall"
argument_list|,
name|Lsyscall
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"intern"
argument_list|,
name|Lintern
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"ptime"
argument_list|,
name|Lptime
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
comment|/* return process user time */
name|MK
argument_list|(
literal|"fork"
argument_list|,
name|Lfork
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
comment|/* turn on fork and wait */
name|MK
argument_list|(
literal|"wait"
argument_list|,
name|Lwait
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
comment|/*	MK("pipe",Lpipe,lambda);	*/
comment|/*	MK("fdopen",Lfdopen,lambda); */
name|MK
argument_list|(
literal|"exece"
argument_list|,
name|Lexece
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"gensym"
argument_list|,
name|Lgensym
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"remprop"
argument_list|,
name|Lremprop
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"bcdad"
argument_list|,
name|Lbcdad
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"symbolp"
argument_list|,
name|Lsymbolp
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"stringp"
argument_list|,
name|Lstringp
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"rematom"
argument_list|,
name|Lrematom
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
comment|/**	MK("prname",Lprname,lambda);	*/
name|MK
argument_list|(
literal|"getenv"
argument_list|,
name|Lgetenv
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"I-throw-err"
argument_list|,
name|Lctcherr
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
comment|/* directly force a throw or error */
name|MK
argument_list|(
literal|"makunbound"
argument_list|,
name|Lmakunb
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"haipart"
argument_list|,
name|Lhaipar
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"haulong"
argument_list|,
name|Lhau
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"signal"
argument_list|,
name|Lsignal
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"fasl"
argument_list|,
name|Lfasl
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
comment|/* NEW - new fasl loader */
name|MK
argument_list|(
literal|"cfasl"
argument_list|,
name|Lcfasl
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
comment|/* read in compiled C file */
name|MK
argument_list|(
literal|"getaddress"
argument_list|,
name|Lgetaddress
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
comment|/* bind symbols without doing cfasl */
name|MK
argument_list|(
literal|"removeaddress"
argument_list|,
name|Lrmadd
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
comment|/* unbind symbols    */
name|MK
argument_list|(
literal|"boundp"
argument_list|,
name|Lboundp
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
comment|/* tells if an atom is bound */
name|MK
argument_list|(
literal|"fake"
argument_list|,
name|Lfake
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
comment|/* makes a fake lisp pointer */
comment|/***	MK("od",Lod,lambda);		/* dumps info */
name|MK
argument_list|(
literal|"maknum"
argument_list|,
name|Lmaknum
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
comment|/* converts a pointer to an integer */
name|MK
argument_list|(
literal|"*mod"
argument_list|,
name|LstarMod
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
comment|/* return fixnum modulus */
name|MK
argument_list|(
literal|"*invmod"
argument_list|,
name|Lstarinvmod
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
comment|/* return fixnum modulus ^-1 */
name|MK
argument_list|(
literal|"fseek"
argument_list|,
name|Lfseek
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
comment|/* seek to a specific byte in a file */
name|MK
argument_list|(
literal|"fileopen"
argument_list|,
name|Lfileopen
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
comment|/* open a file for read/write/append*/
name|MK
argument_list|(
literal|"pv%"
argument_list|,
name|Lpolyev
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
comment|/* polynomial evaluation instruction*/
name|MK
argument_list|(
literal|"cprintf"
argument_list|,
name|Lcprintf
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
comment|/* formatted print 		    */
name|MK
argument_list|(
literal|"sprintf"
argument_list|,
name|Lsprintf
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
comment|/* formatted print to string	    */
name|MK
argument_list|(
literal|"copyint*"
argument_list|,
name|Lcopyint
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
comment|/* copyint*  */
name|MK
argument_list|(
literal|"purcopy"
argument_list|,
name|Lpurcopy
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
comment|/* pure copy */
name|MK
argument_list|(
literal|"purep"
argument_list|,
name|Lpurep
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
comment|/* check if pure */
name|MK
argument_list|(
literal|"int:memreport"
argument_list|,
name|LImemory
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
comment|/* dump memory stats */
comment|/*  * Hunk stuff  */
name|MK
argument_list|(
literal|"*makhunk"
argument_list|,
name|LMakhunk
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
comment|/* special hunk creater */
name|MK
argument_list|(
literal|"hunkp"
argument_list|,
name|Lhunkp
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
comment|/* test a hunk */
name|MK
argument_list|(
literal|"cxr"
argument_list|,
name|Lcxr
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
comment|/* cxr of a hunk */
name|MK
argument_list|(
literal|"rplacx"
argument_list|,
name|Lrplacx
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
comment|/* replace element of a hunk */
name|MK
argument_list|(
literal|"*rplacx"
argument_list|,
name|Lstarrpx
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
comment|/* rplacx used by hunk */
name|MK
argument_list|(
literal|"hunksize"
argument_list|,
name|Lhunksize
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
comment|/* size of a hunk */
name|MK
argument_list|(
literal|"hunk-to-list"
argument_list|,
name|Lhtol
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
comment|/* hunk to list */
comment|/* vector stuff */
name|MK
argument_list|(
literal|"new-vector"
argument_list|,
name|Lnvec
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"new-vectori-byte"
argument_list|,
name|Lnvecb
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"new-vectori-word"
argument_list|,
name|Lnvecw
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"new-vectori-long"
argument_list|,
name|Lnvecl
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"vectorp"
argument_list|,
name|Lvectorp
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"vectorip"
argument_list|,
name|Lpvp
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"int:vref"
argument_list|,
name|LIvref
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"int:vset"
argument_list|,
name|LIvset
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"int:vsize"
argument_list|,
name|LIvsize
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"vprop"
argument_list|,
name|Lvprop
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"probef"
argument_list|,
name|Lprobef
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
comment|/* test file existance */
name|MK
argument_list|(
literal|"substring"
argument_list|,
name|Lsubstring
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"substringn"
argument_list|,
name|Lsstrn
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|MK
argument_list|(
literal|"time-string"
argument_list|,
name|Ltimestr
argument_list|,
name|lambda
argument_list|)
expr_stmt|;
name|odform
operator|=
name|matom
argument_list|(
literal|"odformat"
argument_list|)
expr_stmt|;
comment|/* format for printf's used in od */
name|rdrsdot
operator|=
name|newsdot
argument_list|()
expr_stmt|;
comment|/* used in io conversions of bignums */
name|rdrsdot2
operator|=
name|newsdot
argument_list|()
expr_stmt|;
comment|/* used in io conversions of bignums */
name|rdrint
operator|=
name|newint
argument_list|()
expr_stmt|;
comment|/* used as a temporary integer */
operator|(
name|nilplist
operator|=
name|newdot
argument_list|()
operator|)
operator|->
name|d
operator|.
name|cdr
operator|=
name|newdot
argument_list|()
expr_stmt|;
comment|/* used as property list for nil, 					   since nil will eventually be put at 					   0 (consequently in text and not 					   writable) */
comment|/* error variables */
operator|(
name|Vererr
operator|=
name|matom
argument_list|(
literal|"ER%err"
argument_list|)
operator|)
operator|->
name|a
operator|.
name|clb
operator|=
name|nil
expr_stmt|;
operator|(
name|Vertpl
operator|=
name|matom
argument_list|(
literal|"ER%tpl"
argument_list|)
operator|)
operator|->
name|a
operator|.
name|clb
operator|=
name|nil
expr_stmt|;
operator|(
name|Verall
operator|=
name|matom
argument_list|(
literal|"ER%all"
argument_list|)
operator|)
operator|->
name|a
operator|.
name|clb
operator|=
name|nil
expr_stmt|;
operator|(
name|Vermisc
operator|=
name|matom
argument_list|(
literal|"ER%misc"
argument_list|)
operator|)
operator|->
name|a
operator|.
name|clb
operator|=
name|nil
expr_stmt|;
operator|(
name|Verbrk
operator|=
name|matom
argument_list|(
literal|"ER%brk"
argument_list|)
operator|)
operator|->
name|a
operator|.
name|clb
operator|=
name|nil
expr_stmt|;
operator|(
name|Verundef
operator|=
name|matom
argument_list|(
literal|"ER%undef"
argument_list|)
operator|)
operator|->
name|a
operator|.
name|clb
operator|=
name|nil
expr_stmt|;
operator|(
name|Vlerall
operator|=
name|newdot
argument_list|()
operator|)
operator|->
name|d
operator|.
name|car
operator|=
name|Verall
expr_stmt|;
comment|/* list (ER%all) */
operator|(
name|Veruwpt
operator|=
name|matom
argument_list|(
literal|"ER%unwind-protect"
argument_list|)
operator|)
operator|->
name|a
operator|.
name|clb
operator|=
name|nil
expr_stmt|;
operator|(
name|Verrset
operator|=
name|matom
argument_list|(
literal|"errset"
argument_list|)
operator|)
operator|->
name|a
operator|.
name|clb
operator|=
name|nil
expr_stmt|;
comment|/* set up the initial status list */
name|stlist
operator|=
name|nil
expr_stmt|;
comment|/* initially nil */
block|{
name|lispval
name|feature
decl_stmt|,
name|dom
decl_stmt|;
name|Iaddstat
argument_list|(
name|matom
argument_list|(
literal|"features"
argument_list|)
argument_list|,
name|ST_READ
argument_list|,
name|ST_NO
argument_list|,
name|nil
argument_list|)
expr_stmt|;
name|Iaddstat
argument_list|(
name|feature
operator|=
name|matom
argument_list|(
literal|"feature"
argument_list|)
argument_list|,
name|ST_FEATR
argument_list|,
name|ST_FEATW
argument_list|,
name|nil
argument_list|)
expr_stmt|;
name|Isstatus
argument_list|(
name|feature
argument_list|,
name|matom
argument_list|(
literal|"franz"
argument_list|)
argument_list|)
expr_stmt|;
name|Isstatus
argument_list|(
name|feature
argument_list|,
name|matom
argument_list|(
literal|"Franz"
argument_list|)
argument_list|)
expr_stmt|;
name|Isstatus
argument_list|(
name|feature
argument_list|,
name|matom
argument_list|(
name|OS
argument_list|)
argument_list|)
expr_stmt|;
name|Isstatus
argument_list|(
name|feature
argument_list|,
name|matom
argument_list|(
literal|"string"
argument_list|)
argument_list|)
expr_stmt|;
name|Isstatus
argument_list|(
name|feature
argument_list|,
name|dom
operator|=
name|matom
argument_list|(
name|DOMAIN
argument_list|)
argument_list|)
expr_stmt|;
name|Iaddstat
argument_list|(
name|matom
argument_list|(
literal|"domain"
argument_list|)
argument_list|,
name|ST_READ
argument_list|,
name|ST_NO
argument_list|,
name|dom
argument_list|)
expr_stmt|;
name|Isstatus
argument_list|(
name|feature
argument_list|,
name|matom
argument_list|(
name|MACHINE
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PORTABLE
name|Isstatus
argument_list|(
name|feature
argument_list|,
name|matom
argument_list|(
literal|"portable"
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|unisoft
name|Isstatus
argument_list|(
name|feature
argument_list|,
name|matom
argument_list|(
literal|"unisoft"
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|sun
name|Isstatus
argument_list|(
name|feature
argument_list|,
name|matom
argument_list|(
literal|"sun"
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|Iaddstat
argument_list|(
name|matom
argument_list|(
literal|"nofeature"
argument_list|)
argument_list|,
name|ST_NFETR
argument_list|,
name|ST_NFETW
argument_list|,
name|nil
argument_list|)
expr_stmt|;
name|Iaddstat
argument_list|(
name|matom
argument_list|(
literal|"syntax"
argument_list|)
argument_list|,
name|ST_SYNT
argument_list|,
name|ST_NO
argument_list|,
name|nil
argument_list|)
expr_stmt|;
name|Iaddstat
argument_list|(
name|matom
argument_list|(
literal|"uctolc"
argument_list|)
argument_list|,
name|ST_READ
argument_list|,
name|ST_TOLC
argument_list|,
name|nil
argument_list|)
expr_stmt|;
name|Iaddstat
argument_list|(
name|matom
argument_list|(
literal|"dumpcore"
argument_list|)
argument_list|,
name|ST_READ
argument_list|,
name|ST_CORE
argument_list|,
name|nil
argument_list|)
expr_stmt|;
name|Isstatus
argument_list|(
name|matom
argument_list|(
literal|"dumpcore"
argument_list|)
argument_list|,
name|nil
argument_list|)
expr_stmt|;
comment|/*set up signals*/
name|Iaddstat
argument_list|(
name|matom
argument_list|(
literal|"chainatom"
argument_list|)
argument_list|,
name|ST_RINTB
argument_list|,
name|ST_INTB
argument_list|,
name|inewint
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|Iaddstat
argument_list|(
name|matom
argument_list|(
literal|"dumpmode"
argument_list|)
argument_list|,
name|ST_DMPR
argument_list|,
name|ST_DMPW
argument_list|,
name|nil
argument_list|)
expr_stmt|;
name|Iaddstat
argument_list|(
name|matom
argument_list|(
literal|"appendmap"
argument_list|)
argument_list|,
name|ST_READ
argument_list|,
name|ST_SET
argument_list|,
name|nil
argument_list|)
expr_stmt|;
comment|/* used by fasl */
name|Iaddstat
argument_list|(
name|matom
argument_list|(
literal|"debugging"
argument_list|)
argument_list|,
name|ST_READ
argument_list|,
name|ST_SET
argument_list|,
name|nil
argument_list|)
expr_stmt|;
name|Iaddstat
argument_list|(
name|matom
argument_list|(
literal|"evalhook"
argument_list|)
argument_list|,
name|ST_RINTB
argument_list|,
name|ST_INTB
argument_list|,
name|inewint
argument_list|(
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|Isstatus
argument_list|(
name|matom
argument_list|(
literal|"evalhook"
argument_list|)
argument_list|,
name|nil
argument_list|)
expr_stmt|;
comment|/*evalhook switch off */
name|Iaddstat
argument_list|(
name|matom
argument_list|(
literal|"bcdtrace"
argument_list|)
argument_list|,
name|ST_READ
argument_list|,
name|ST_BCDTR
argument_list|,
name|nil
argument_list|)
expr_stmt|;
name|Iaddstat
argument_list|(
name|matom
argument_list|(
literal|"ctime"
argument_list|)
argument_list|,
name|ST_CTIM
argument_list|,
name|ST_NO
argument_list|,
name|nil
argument_list|)
expr_stmt|;
name|Iaddstat
argument_list|(
name|matom
argument_list|(
literal|"localtime"
argument_list|)
argument_list|,
name|ST_LOCT
argument_list|,
name|ST_NO
argument_list|,
name|nil
argument_list|)
expr_stmt|;
name|Iaddstat
argument_list|(
name|matom
argument_list|(
literal|"isatty"
argument_list|)
argument_list|,
name|ST_ISTTY
argument_list|,
name|ST_NO
argument_list|,
name|nil
argument_list|)
expr_stmt|;
name|Iaddstat
argument_list|(
name|matom
argument_list|(
literal|"ignoreeof"
argument_list|)
argument_list|,
name|ST_READ
argument_list|,
name|ST_SET
argument_list|,
name|nil
argument_list|)
expr_stmt|;
name|Iaddstat
argument_list|(
name|matom
argument_list|(
literal|"version"
argument_list|)
argument_list|,
name|ST_READ
argument_list|,
name|ST_NO
argument_list|,
name|mstr
argument_list|(
literal|"Franz Lisp, Opus 38"
argument_list|)
argument_list|)
expr_stmt|;
name|Iaddstat
argument_list|(
name|matom
argument_list|(
literal|"automatic-reset"
argument_list|)
argument_list|,
name|ST_READ
argument_list|,
name|ST_AUTR
argument_list|,
name|nil
argument_list|)
expr_stmt|;
name|Iaddstat
argument_list|(
name|matom
argument_list|(
literal|"translink"
argument_list|)
argument_list|,
name|ST_READ
argument_list|,
name|ST_TRAN
argument_list|,
name|nil
argument_list|)
expr_stmt|;
name|Isstatus
argument_list|(
name|matom
argument_list|(
literal|"translink"
argument_list|)
argument_list|,
name|nil
argument_list|)
expr_stmt|;
comment|/* turn off tran links */
name|Iaddstat
argument_list|(
name|matom
argument_list|(
literal|"undeffunc"
argument_list|)
argument_list|,
name|ST_UNDEF
argument_list|,
name|ST_NO
argument_list|,
name|nil
argument_list|)
expr_stmt|;
comment|/* list undef funcs */
name|Iaddstat
argument_list|(
name|matom
argument_list|(
literal|"gcstrings"
argument_list|)
argument_list|,
name|ST_READ
argument_list|,
name|ST_GCSTR
argument_list|,
name|nil
argument_list|)
expr_stmt|;
comment|/* gc strings */
comment|/* garbage collector things */
name|MK
argument_list|(
literal|"gc"
argument_list|,
name|Ngc
argument_list|,
name|nlambda
argument_list|)
expr_stmt|;
name|gcafter
operator|=
name|MK
argument_list|(
literal|"gcafter"
argument_list|,
name|Ngcafter
argument_list|,
name|nlambda
argument_list|)
expr_stmt|;
comment|/* garbage collection wind-up */
name|gcport
operator|=
name|matom
argument_list|(
literal|"gcport"
argument_list|)
expr_stmt|;
comment|/* port for gc dumping */
name|gccheck
operator|=
name|matom
argument_list|(
literal|"gccheck"
argument_list|)
expr_stmt|;
comment|/* flag for checking during gc */
name|gcdis
operator|=
name|matom
argument_list|(
literal|"gcdisable"
argument_list|)
expr_stmt|;
comment|/* variable for disabling the gc */
name|gcdis
operator|->
name|a
operator|.
name|clb
operator|=
name|nil
expr_stmt|;
name|gcload
operator|=
name|matom
argument_list|(
literal|"gcload"
argument_list|)
expr_stmt|;
comment|/* option for gc while loading */
name|loading
operator|=
name|matom
argument_list|(
literal|"loading"
argument_list|)
expr_stmt|;
comment|/* flag--in loader if = t  */
name|noautot
operator|=
name|matom
argument_list|(
literal|"noautotrace"
argument_list|)
expr_stmt|;
comment|/* option to inhibit auto-trace */
operator|(
name|gcthresh
operator|=
name|newint
argument_list|()
operator|)
operator|->
name|i
operator|=
name|tgcthresh
expr_stmt|;
name|gccall1
operator|=
name|newdot
argument_list|()
expr_stmt|;
name|gccall2
operator|=
name|newdot
argument_list|()
expr_stmt|;
comment|/* used to call gcafter */
name|gccall1
operator|->
name|d
operator|.
name|car
operator|=
name|gcafter
expr_stmt|;
comment|/* start constructing a form for eval */
name|arrayst
operator|=
name|mstr
argument_list|(
literal|"ARRAY"
argument_list|)
expr_stmt|;
comment|/* array marker in name stack */
name|bcdst
operator|=
name|mstr
argument_list|(
literal|"BINARY"
argument_list|)
expr_stmt|;
comment|/* binary function marker */
name|listst
operator|=
name|mstr
argument_list|(
literal|"INTERPRETED"
argument_list|)
expr_stmt|;
comment|/* interpreted function marker */
name|macrost
operator|=
name|mstr
argument_list|(
literal|"MACRO"
argument_list|)
expr_stmt|;
comment|/* macro marker */
name|protst
operator|=
name|mstr
argument_list|(
literal|"PROTECTED"
argument_list|)
expr_stmt|;
comment|/* protection marker */
name|badst
operator|=
name|mstr
argument_list|(
literal|"BADPTR"
argument_list|)
expr_stmt|;
comment|/* bad pointer marker */
name|argst
operator|=
name|mstr
argument_list|(
literal|"ARGST"
argument_list|)
expr_stmt|;
comment|/* argument marker */
name|hunkfree
operator|=
name|mstr
argument_list|(
literal|"EMPTY"
argument_list|)
expr_stmt|;
comment|/* empty hunk cell value */
comment|/* type names */
name|FIDDLE
argument_list|(
name|atom_name
argument_list|,
name|atom_items
argument_list|,
name|atom_pages
argument_list|,
name|ATOMSPP
argument_list|)
expr_stmt|;
name|FIDDLE
argument_list|(
name|str_name
argument_list|,
name|str_items
argument_list|,
name|str_pages
argument_list|,
name|STRSPP
argument_list|)
expr_stmt|;
name|FIDDLE
argument_list|(
name|other_name
argument_list|,
name|other_items
argument_list|,
name|other_pages
argument_list|,
name|STRSPP
argument_list|)
expr_stmt|;
name|FIDDLE
argument_list|(
name|int_name
argument_list|,
name|int_items
argument_list|,
name|int_pages
argument_list|,
name|INTSPP
argument_list|)
expr_stmt|;
name|FIDDLE
argument_list|(
name|dtpr_name
argument_list|,
name|dtpr_items
argument_list|,
name|dtpr_pages
argument_list|,
name|DTPRSPP
argument_list|)
expr_stmt|;
name|FIDDLE
argument_list|(
name|doub_name
argument_list|,
name|doub_items
argument_list|,
name|doub_pages
argument_list|,
name|DOUBSPP
argument_list|)
expr_stmt|;
name|FIDDLE
argument_list|(
name|sdot_name
argument_list|,
name|sdot_items
argument_list|,
name|sdot_pages
argument_list|,
name|SDOTSPP
argument_list|)
expr_stmt|;
name|FIDDLE
argument_list|(
name|array_name
argument_list|,
name|array_items
argument_list|,
name|array_pages
argument_list|,
name|ARRAYSPP
argument_list|)
expr_stmt|;
name|FIDDLE
argument_list|(
name|val_name
argument_list|,
name|val_items
argument_list|,
name|val_pages
argument_list|,
name|VALSPP
argument_list|)
expr_stmt|;
name|FIDDLE
argument_list|(
name|funct_name
argument_list|,
name|funct_items
argument_list|,
name|funct_pages
argument_list|,
name|BCDSPP
argument_list|)
expr_stmt|;
name|FIDDLE
argument_list|(
name|hunk_name
index|[
literal|0
index|]
argument_list|,
name|hunk_items
index|[
literal|0
index|]
argument_list|,
name|hunk_pages
index|[
literal|0
index|]
argument_list|,
name|HUNK2SPP
argument_list|)
expr_stmt|;
name|FIDDLE
argument_list|(
name|hunk_name
index|[
literal|1
index|]
argument_list|,
name|hunk_items
index|[
literal|1
index|]
argument_list|,
name|hunk_pages
index|[
literal|1
index|]
argument_list|,
name|HUNK4SPP
argument_list|)
expr_stmt|;
name|FIDDLE
argument_list|(
name|hunk_name
index|[
literal|2
index|]
argument_list|,
name|hunk_items
index|[
literal|2
index|]
argument_list|,
name|hunk_pages
index|[
literal|2
index|]
argument_list|,
name|HUNK8SPP
argument_list|)
expr_stmt|;
name|FIDDLE
argument_list|(
name|hunk_name
index|[
literal|3
index|]
argument_list|,
name|hunk_items
index|[
literal|3
index|]
argument_list|,
name|hunk_pages
index|[
literal|3
index|]
argument_list|,
name|HUNK16SPP
argument_list|)
expr_stmt|;
name|FIDDLE
argument_list|(
name|hunk_name
index|[
literal|4
index|]
argument_list|,
name|hunk_items
index|[
literal|4
index|]
argument_list|,
name|hunk_pages
index|[
literal|4
index|]
argument_list|,
name|HUNK32SPP
argument_list|)
expr_stmt|;
name|FIDDLE
argument_list|(
name|hunk_name
index|[
literal|5
index|]
argument_list|,
name|hunk_items
index|[
literal|5
index|]
argument_list|,
name|hunk_pages
index|[
literal|5
index|]
argument_list|,
name|HUNK64SPP
argument_list|)
expr_stmt|;
name|FIDDLE
argument_list|(
name|hunk_name
index|[
literal|6
index|]
argument_list|,
name|hunk_items
index|[
literal|6
index|]
argument_list|,
name|hunk_pages
index|[
literal|6
index|]
argument_list|,
name|HUNK128SPP
argument_list|)
expr_stmt|;
name|FIDDLE
argument_list|(
argument|vect_name
argument_list|,
argument|vect_items
argument_list|,
argument|vect_pages
argument_list|,
argument|VECTORSPP
argument_list|)
name|FIDDLE
argument_list|(
name|vecti_name
argument_list|,
name|vecti_items
argument_list|,
name|vecti_pages
argument_list|,
name|VECTORSPP
argument_list|)
argument_list|(
name|plimit
operator|=
name|newint
argument_list|()
argument_list|)
operator|->
name|i
operator|=
name|page_limit
expr_stmt|;
name|copval
argument_list|(
name|plima
argument_list|,
name|plimit
argument_list|)
expr_stmt|;
comment|/*  default value  */
comment|/* the following atom is used when reading caar, cdar, etc. */
name|xatom
operator|=
name|matom
argument_list|(
literal|"??"
argument_list|)
expr_stmt|;
comment|/*  now it is OK to collect garbage  */
name|initflag
operator|=
name|FALSE
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  matom("name")  ******************************************************/
end_comment

begin_comment
comment|/*									*/
end_comment

begin_comment
comment|/*  simulates an atom being read in from the reader and returns a	*/
end_comment

begin_comment
comment|/*  pointer to it.							*/
end_comment

begin_comment
comment|/*									*/
end_comment

begin_comment
comment|/*  BEWARE:  if an atom becomes "truly worthless" and is collected,	*/
end_comment

begin_comment
comment|/*  the pointer becomes obsolete.					*/
end_comment

begin_comment
comment|/*									*/
end_comment

begin_function
name|lispval
name|matom
parameter_list|(
name|string
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|strbuf
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|strcatn
argument_list|(
name|strbuf
argument_list|,
name|string
argument_list|,
name|STRBLEN
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* strcpyn always pads to n */
name|strbuf
index|[
name|STRBLEN
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|getatom
argument_list|()
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  mstr  ***************************************************************/
end_comment

begin_comment
comment|/*									*/
end_comment

begin_comment
comment|/*  Makes a string.  Uses matom.					*/
end_comment

begin_comment
comment|/*  Not the most efficient but will do until the string from the code	*/
end_comment

begin_comment
comment|/*  itself can be used as a lispval.					*/
end_comment

begin_function
name|lispval
name|mstr
parameter_list|(
name|string
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
block|{
return|return
operator|(
call|(
name|lispval
call|)
argument_list|(
name|pinewstr
argument_list|(
name|string
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  mfun("name",start)  *************************************************/
end_comment

begin_comment
comment|/*									*/
end_comment

begin_comment
comment|/*  Same as matom, but entry point to c code is associated with		*/
end_comment

begin_comment
comment|/*  "name" as function binding.						*/
end_comment

begin_comment
comment|/*  A pointer to the atom is returned.					*/
end_comment

begin_comment
comment|/*									*/
end_comment

begin_decl_stmt
name|lispval
name|mfun
argument_list|(
name|string
argument_list|,
name|start
argument_list|,
name|discip
argument_list|)
name|char
modifier|*
name|string
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|lispval
argument_list|(
operator|*
name|start
argument_list|)
argument_list|()
decl_stmt|,
name|discip
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|lispval
name|v
decl_stmt|;
name|v
operator|=
name|matom
argument_list|(
name|string
argument_list|)
expr_stmt|;
name|v
operator|->
name|a
operator|.
name|fnbnd
operator|=
name|newfunct
argument_list|()
expr_stmt|;
name|v
operator|->
name|a
operator|.
name|fnbnd
operator|->
name|bcd
operator|.
name|start
operator|=
name|start
expr_stmt|;
name|v
operator|->
name|a
operator|.
name|fnbnd
operator|->
name|bcd
operator|.
name|discipline
operator|=
name|discip
expr_stmt|;
return|return
operator|(
name|v
operator|)
return|;
block|}
end_block

end_unit

