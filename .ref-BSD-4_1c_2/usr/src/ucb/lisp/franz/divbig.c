begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid
init|=
literal|"$Header: /na/franz/franz/RCS/divbig.c,v 1.2 83/01/29 12:32:03 jkf Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*					-[Sat Jan 29 12:22:36 1983 by jkf]-  * 	divbig.c				$Locker:  $  * bignum division  *  * (c) copyright 1982, Regents of the University of California  */
end_comment

begin_include
include|#
directive|include
file|"global.h"
end_include

begin_define
define|#
directive|define
name|b
value|0x40000000
end_define

begin_define
define|#
directive|define
name|toint
parameter_list|(
name|p
parameter_list|)
value|((int) (p))
end_define

begin_macro
name|divbig
argument_list|(
argument|dividend
argument_list|,
argument|divisor
argument_list|,
argument|quotient
argument_list|,
argument|remainder
argument_list|)
end_macro

begin_decl_stmt
name|lispval
name|dividend
decl_stmt|,
name|divisor
decl_stmt|,
modifier|*
name|quotient
decl_stmt|,
modifier|*
name|remainder
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
operator|*
name|ujp
operator|,
operator|*
name|vip
expr_stmt|;
name|int
modifier|*
name|sp
argument_list|()
decl_stmt|,
modifier|*
name|alloca
argument_list|()
decl_stmt|,
name|d
decl_stmt|,
name|negflag
init|=
literal|0
decl_stmt|,
name|m
decl_stmt|,
name|n
decl_stmt|,
name|carry
decl_stmt|,
name|rem
decl_stmt|,
name|qhat
decl_stmt|,
name|j
decl_stmt|;
name|int
name|borrow
decl_stmt|,
name|negrem
init|=
literal|0
decl_stmt|;
name|int
modifier|*
name|utop
init|=
name|sp
argument_list|()
decl_stmt|,
modifier|*
name|ubot
decl_stmt|,
modifier|*
name|vbot
decl_stmt|,
modifier|*
name|qbot
decl_stmt|;
specifier|register
name|lispval
name|work
decl_stmt|;
name|lispval
name|export
parameter_list|()
function_decl|;
comment|/* copy dividend */
for|for
control|(
name|work
operator|=
name|dividend
init|;
name|work
condition|;
name|work
operator|=
name|work
operator|->
name|s
operator|.
name|CDR
control|)
name|stack
argument_list|(
name|work
operator|->
name|s
operator|.
name|I
argument_list|)
expr_stmt|;
name|ubot
operator|=
name|sp
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|ubot
operator|<
literal|0
condition|)
block|{
comment|/* knuth's division alg works only for pos 					bignums				*/
name|negflag
operator|^=
literal|1
expr_stmt|;
name|negrem
operator|=
literal|1
expr_stmt|;
name|dsmult
argument_list|(
name|utop
operator|-
literal|1
argument_list|,
name|ubot
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|stack
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|ubot
operator|=
name|sp
argument_list|()
expr_stmt|;
comment|/*copy divisor */
for|for
control|(
name|work
operator|=
name|divisor
init|;
name|work
condition|;
name|work
operator|=
name|work
operator|->
name|s
operator|.
name|CDR
control|)
name|stack
argument_list|(
name|work
operator|->
name|s
operator|.
name|I
argument_list|)
expr_stmt|;
name|vbot
operator|=
name|sp
argument_list|()
expr_stmt|;
name|stack
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|vbot
operator|<
literal|0
condition|)
block|{
name|negflag
operator|^=
literal|1
expr_stmt|;
name|dsmult
argument_list|(
name|ubot
operator|-
literal|1
argument_list|,
name|vbot
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* check validity of data */
name|n
operator|=
name|ubot
operator|-
name|vbot
expr_stmt|;
name|m
operator|=
name|utop
operator|-
name|ubot
operator|-
name|n
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|1
condition|)
block|{
comment|/* do destructive division by  a single. */
name|rem
operator|=
name|dsdiv
argument_list|(
name|utop
operator|-
literal|1
argument_list|,
name|ubot
argument_list|,
operator|*
name|vbot
argument_list|)
expr_stmt|;
if|if
condition|(
name|negrem
condition|)
name|rem
operator|=
operator|-
name|rem
expr_stmt|;
if|if
condition|(
name|negflag
condition|)
name|dsmult
argument_list|(
name|utop
operator|-
literal|1
argument_list|,
name|ubot
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|remainder
condition|)
operator|*
name|remainder
operator|=
name|inewint
argument_list|(
name|rem
argument_list|)
expr_stmt|;
if|if
condition|(
name|quotient
condition|)
operator|*
name|quotient
operator|=
name|export
argument_list|(
name|utop
argument_list|,
name|ubot
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|m
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|remainder
condition|)
operator|*
name|remainder
operator|=
name|dividend
expr_stmt|;
if|if
condition|(
name|quotient
condition|)
operator|*
name|quotient
operator|=
name|inewint
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
name|qbot
operator|=
name|alloca
argument_list|(
name|toint
argument_list|(
name|utop
argument_list|)
operator|+
name|toint
argument_list|(
name|vbot
argument_list|)
operator|-
literal|2
operator|*
name|toint
argument_list|(
name|ubot
argument_list|)
argument_list|)
expr_stmt|;
name|d1
label|:
name|d
operator|=
name|b
operator|/
operator|(
operator|*
name|vbot
operator|+
literal|1
operator|)
expr_stmt|;
name|dsmult
argument_list|(
name|utop
operator|-
literal|1
argument_list|,
name|ubot
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|dsmult
argument_list|(
name|ubot
operator|-
literal|1
argument_list|,
name|vbot
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|d2
label|:
for|for
control|(
name|j
operator|=
literal|0
operator|,
name|ujp
operator|=
name|ubot
init|;
name|j
operator|<=
name|m
condition|;
name|j
operator|++
operator|,
name|ujp
operator|++
control|)
block|{
name|d3
label|:
name|qhat
operator|=
name|calqhat
argument_list|(
name|ujp
argument_list|,
name|vbot
argument_list|)
expr_stmt|;
name|d4
label|:
if|if
condition|(
operator|(
name|borrow
operator|=
name|mlsb
argument_list|(
name|ujp
operator|+
name|n
argument_list|,
name|ujp
argument_list|,
name|ubot
argument_list|,
operator|-
name|qhat
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|adback
argument_list|(
name|ujp
operator|+
name|n
argument_list|,
name|ujp
argument_list|,
name|ubot
argument_list|)
expr_stmt|;
name|qhat
operator|--
expr_stmt|;
block|}
name|qbot
index|[
name|j
index|]
operator|=
name|qhat
expr_stmt|;
block|}
name|d8
label|:
if|if
condition|(
name|remainder
condition|)
block|{
name|dsdiv
argument_list|(
name|utop
operator|-
literal|1
argument_list|,
name|utop
operator|-
name|n
argument_list|,
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|negrem
condition|)
name|dsmult
argument_list|(
name|utop
operator|-
literal|1
argument_list|,
name|utop
operator|-
name|n
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
operator|*
name|remainder
operator|=
name|export
argument_list|(
name|utop
argument_list|,
name|utop
operator|-
name|n
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|quotient
condition|)
block|{
if|if
condition|(
name|negflag
condition|)
name|dsmult
argument_list|(
name|qbot
operator|+
name|m
argument_list|,
name|qbot
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
operator|*
name|quotient
operator|=
name|export
argument_list|(
name|qbot
operator|+
name|m
operator|+
literal|1
argument_list|,
name|qbot
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * asm code commented out due to optimizer bug calqhat(ujp,v1p) register int *ujp, *v1p; { asm("	cmpl	(r10),(r11)		# v[1] == u[j] ??"); asm("	beql	2f			"); asm("	# calculate qhat and rhat simultaneously,"); asm("	#  qhat in r0"); asm("	#  rhat in r1"); asm("	emul	(r11),$0x40000000,4(r11),r4 # u[j]b+u[j+1] into r4,r5"); asm("	ediv	(r10),r4,r0,r1		# qhat = ((u[j]b+u[j+1])/v[1]) into r0"); asm("					# (u[j]b+u[j+1] -qhat*v[1]) into r1"); asm("					# called rhat"); asm("1:"); asm("	# check if v[2]*qhat> rhat*b+u[j+2]"); asm("	emul	r0,4(r10),$0,r2		# qhat*v[2] into r3,r2"); asm("	emul	r1,$0x40000000,8(r11),r8 #rhat*b + u[j+2] into r9,r8"); asm("	# give up if r3,r2<= r9,r8, otherwise iterate"); asm("	subl2	r8,r2			# perform r3,r2 - r9,r8"); asm("	sbwc	r9,r3"); asm("	bleq	3f			# give up if negative or equal"); asm("	decl	r0			# otherwise, qhat = qhat - 1"); asm("	addl2	(r10),r1		# since dec'ed qhat, inc rhat by v[1]"); asm("	jbr	1b"); asm("2:	"); asm("	# get here if v[1]==u[j]"); asm("	# set qhat to b-1"); asm("	# rhat is easily calculated since if we substitute b-1 for qhat in"); asm("	# the formula, then it simplifies to (u[j+1] + v[1])"); asm("	# "); asm("	addl3	4(r11),(r10),r1		# rhat = u[j+1] + v[1]"); asm("	movl	$0x3fffffff,r0		# qhat = b-1"); asm("	jbr	1b"); asm("3:"); } mlsb(utop,ubot,vtop,nqhat) register int *utop, *ubot, *vtop; register int nqhat; { asm("	clrl	r0"); asm("loop2:	addl2	(r11),r0"); asm("	emul	r8,-(r9),r0,r2"); asm("	extzv	$0,$30,r2,(r11)"); asm("	extv	$30,$32,r2,r0"); asm("	acbl	r10,$-4,r11,loop2"); } adback(utop,ubot,vtop) register int *utop, *ubot, *vtop; { asm("	clrl	r0"); asm("loop3:	addl2	-(r9),r0"); asm("	addl2	(r11),r0"); asm("	extzv	$0,$30,r0,(r11)"); asm("	extv	$30,$2,r0,r0"); asm("	acbl	r10,$-4,r11,loop3"); } dsdiv(top,bot,div) register int* bot; { asm("	clrl	r0"); asm("loop4:	emul	r0,$0x40000000,(r11),r1"); asm("	ediv	12(ap),r1,(r11),r0"); asm("	acbl	4(ap),$4,r11,loop4"); } dsmult(top,bot,mult) register int* top; { asm("	clrl	r0"); asm("loop5:	emul	12(ap),(r11),r0,r1"); asm("	extzv	$0,$30,r1,(r11)"); asm("	extv	$30,$32,r1,r0"); asm("	acbl	8(ap),$-4,r11,loop5"); asm("	movl	r1,4(r11)"); } */
end_comment

begin_function
name|lispval
name|export
parameter_list|(
name|top
parameter_list|,
name|bot
parameter_list|)
specifier|register
name|long
modifier|*
name|top
decl_stmt|,
decl|*
name|bot
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|lispval
name|p
decl_stmt|;
name|lispval
name|result
decl_stmt|;
name|top
operator|--
expr_stmt|;
comment|/* screwey convention matches original 		  vax assembler convenience */
while|while
condition|(
name|bot
operator|<
name|top
condition|)
block|{
if|if
condition|(
operator|*
name|bot
operator|==
literal|0
condition|)
name|bot
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|bot
operator|==
operator|-
literal|1
condition|)
operator|*
operator|++
name|bot
operator||=
literal|0xc0000000
expr_stmt|;
else|else
break|break;
block|}
if|if
condition|(
name|bot
operator|==
name|top
condition|)
return|return
operator|(
name|inewint
argument_list|(
operator|*
name|bot
argument_list|)
operator|)
return|;
name|result
operator|=
name|p
operator|=
name|newsdot
argument_list|()
expr_stmt|;
name|protect
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|s
operator|.
name|I
operator|=
operator|*
name|top
operator|--
expr_stmt|;
while|while
condition|(
name|top
operator|>=
name|bot
condition|)
block|{
name|p
operator|=
name|p
operator|->
name|s
operator|.
name|CDR
operator|=
name|newdot
argument_list|()
expr_stmt|;
name|p
operator|->
name|s
operator|.
name|I
operator|=
operator|*
name|top
operator|--
expr_stmt|;
block|}
name|p
operator|->
name|s
operator|.
name|CDR
operator|=
literal|0
expr_stmt|;
name|np
operator|--
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_block

begin_define
define|#
directive|define
name|MAXINT
value|0x80000000L
end_define

begin_expr_stmt
name|Ihau
argument_list|(
name|fix
argument_list|)
specifier|register
name|int
name|fix
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|count
expr_stmt|;
if|if
condition|(
name|fix
operator|==
name|MAXINT
condition|)
return|return
operator|(
literal|32
operator|)
return|;
if|if
condition|(
name|fix
operator|<
literal|0
condition|)
name|fix
operator|=
operator|-
name|fix
expr_stmt|;
for|for
control|(
name|count
operator|=
literal|0
init|;
name|fix
condition|;
name|count
operator|++
control|)
name|fix
operator|/=
literal|2
expr_stmt|;
return|return
operator|(
name|count
operator|)
return|;
block|}
end_block

begin_function
name|lispval
name|Lhau
parameter_list|()
block|{
specifier|register
name|count
expr_stmt|;
specifier|register
name|lispval
name|handy
decl_stmt|;
specifier|register
name|dum1
operator|,
name|dum2
expr_stmt|;
name|lispval
name|Labsval
parameter_list|()
function_decl|;
name|handy
operator|=
name|lbot
operator|->
name|val
expr_stmt|;
name|top
label|:
switch|switch
condition|(
name|TYPE
argument_list|(
name|handy
argument_list|)
condition|)
block|{
case|case
name|INT
case|:
name|count
operator|=
name|Ihau
argument_list|(
name|handy
operator|->
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
name|SDOT
case|:
name|handy
operator|=
name|Labsval
argument_list|()
expr_stmt|;
for|for
control|(
name|count
operator|=
literal|0
init|;
name|handy
operator|->
name|s
operator|.
name|CDR
operator|!=
operator|(
operator|(
name|lispval
operator|)
literal|0
operator|)
condition|;
name|handy
operator|=
name|handy
operator|->
name|s
operator|.
name|CDR
control|)
name|count
operator|+=
literal|30
expr_stmt|;
name|count
operator|+=
name|Ihau
argument_list|(
name|handy
operator|->
name|s
operator|.
name|I
argument_list|)
expr_stmt|;
break|break;
default|default:
name|handy
operator|=
name|errorh1
argument_list|(
name|Vermisc
argument_list|,
literal|"Haulong: bad argument"
argument_list|,
name|nil
argument_list|,
name|TRUE
argument_list|,
literal|997
argument_list|,
name|handy
argument_list|)
expr_stmt|;
goto|goto
name|top
goto|;
block|}
return|return
operator|(
name|inewint
argument_list|(
name|count
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lhaipar
parameter_list|()
block|{
name|int
modifier|*
name|sp
parameter_list|()
function_decl|;
specifier|register
name|lispval
name|work
decl_stmt|;
specifier|register
name|n
expr_stmt|;
specifier|register
name|int
modifier|*
name|top
init|=
name|sp
argument_list|()
operator|-
literal|1
decl_stmt|;
specifier|register
name|int
modifier|*
name|bot
decl_stmt|;
name|int
name|mylen
decl_stmt|;
comment|/*chkarg(2);*/
name|work
operator|=
name|lbot
operator|->
name|val
expr_stmt|;
comment|/* copy data onto stack */
name|on1
label|:
switch|switch
condition|(
name|TYPE
argument_list|(
name|work
argument_list|)
condition|)
block|{
case|case
name|INT
case|:
name|stack
argument_list|(
name|work
operator|->
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
name|SDOT
case|:
for|for
control|(
init|;
name|work
operator|!=
operator|(
operator|(
name|lispval
operator|)
literal|0
operator|)
condition|;
name|work
operator|=
name|work
operator|->
name|s
operator|.
name|CDR
control|)
name|stack
argument_list|(
name|work
operator|->
name|s
operator|.
name|I
argument_list|)
expr_stmt|;
break|break;
default|default:
name|work
operator|=
name|errorh1
argument_list|(
name|Vermisc
argument_list|,
literal|"Haipart: bad first argument"
argument_list|,
name|nil
argument_list|,
name|TRUE
argument_list|,
literal|996
argument_list|,
name|work
argument_list|)
expr_stmt|;
goto|goto
name|on1
goto|;
block|}
name|bot
operator|=
name|sp
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|bot
operator|<
literal|0
condition|)
block|{
name|stack
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|dsmult
argument_list|(
name|top
argument_list|,
name|bot
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|bot
operator|--
expr_stmt|;
block|}
for|for
control|(
init|;
operator|*
name|bot
operator|==
literal|0
operator|&&
name|bot
operator|<
name|top
condition|;
name|bot
operator|++
control|)
empty_stmt|;
comment|/* recalculate haulong internally */
name|mylen
operator|=
operator|(
name|top
operator|-
name|bot
operator|)
operator|*
literal|30
operator|+
name|Ihau
argument_list|(
operator|*
name|bot
argument_list|)
expr_stmt|;
comment|/* get second argument		  */
name|work
operator|=
name|lbot
index|[
literal|1
index|]
operator|.
name|val
expr_stmt|;
while|while
condition|(
name|TYPE
argument_list|(
name|work
argument_list|)
operator|!=
name|INT
condition|)
name|work
operator|=
name|errorh1
argument_list|(
name|Vermisc
argument_list|,
literal|"Haipart: 2nd arg not int"
argument_list|,
name|nil
argument_list|,
name|TRUE
argument_list|,
literal|995
argument_list|,
name|work
argument_list|)
expr_stmt|;
name|n
operator|=
name|work
operator|->
name|i
expr_stmt|;
if|if
condition|(
name|n
operator|>=
name|mylen
operator|||
operator|-
name|n
operator|>=
name|mylen
condition|)
goto|goto
name|done
goto|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
return|return
operator|(
name|inewint
argument_list|(
literal|0
argument_list|)
operator|)
return|;
if|if
condition|(
name|n
operator|>
literal|0
condition|)
block|{
comment|/* Here we want n most significant bits 				   so chop off mylen - n bits */
name|stack
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|n
operator|=
name|mylen
operator|-
name|n
expr_stmt|;
for|for
control|(
name|n
init|;
name|n
operator|>=
literal|30
condition|;
name|n
operator|-=
literal|30
control|)
name|top
operator|--
expr_stmt|;
if|if
condition|(
name|top
operator|<
name|bot
condition|)
name|error
argument_list|(
literal|"Internal error in haipart #1"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|dsdiv
argument_list|(
name|top
argument_list|,
name|bot
argument_list|,
literal|1
operator|<<
name|n
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* here we want abs(n) low order bits */
name|stack
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|bot
operator|=
name|top
operator|+
literal|1
expr_stmt|;
for|for
control|(
init|;
name|n
operator|<=
literal|0
condition|;
name|n
operator|+=
literal|30
control|)
name|bot
operator|--
expr_stmt|;
name|n
operator|=
literal|30
operator|-
name|n
expr_stmt|;
operator|*
name|bot
operator|&=
operator|~
operator|(
operator|-
literal|1
operator|<<
name|n
operator|)
expr_stmt|;
block|}
name|done
label|:
return|return
operator|(
name|export
argument_list|(
name|top
operator|+
literal|1
argument_list|,
name|bot
argument_list|)
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|STICKY
value|1
end_define

begin_define
define|#
directive|define
name|TOEVEN
value|2
end_define

begin_function
name|lispval
name|Ibiglsh
parameter_list|(
name|bignum
parameter_list|,
name|count
parameter_list|,
name|mode
parameter_list|)
name|lispval
name|bignum
decl_stmt|,
name|count
decl_stmt|;
block|{
name|int
modifier|*
name|sp
parameter_list|()
function_decl|;
specifier|register
name|lispval
name|work
decl_stmt|;
specifier|register
name|n
expr_stmt|;
specifier|register
name|int
modifier|*
name|top
init|=
name|sp
argument_list|()
operator|-
literal|1
decl_stmt|;
specifier|register
name|int
modifier|*
name|bot
decl_stmt|;
name|int
name|mylen
decl_stmt|,
name|guard
init|=
literal|0
decl_stmt|,
name|sticky
init|=
literal|0
decl_stmt|,
name|round
init|=
literal|0
decl_stmt|;
name|lispval
name|export
parameter_list|()
function_decl|;
comment|/* get second argument		  */
name|work
operator|=
name|count
expr_stmt|;
while|while
condition|(
name|TYPE
argument_list|(
name|work
argument_list|)
operator|!=
name|INT
condition|)
name|work
operator|=
name|errorh1
argument_list|(
name|Vermisc
argument_list|,
literal|"Bignum-shift: 2nd arg not int"
argument_list|,
name|nil
argument_list|,
name|TRUE
argument_list|,
literal|995
argument_list|,
name|work
argument_list|)
expr_stmt|;
name|n
operator|=
name|work
operator|->
name|i
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
return|return
operator|(
name|bignum
operator|)
return|;
for|for
control|(
init|;
name|n
operator|>=
literal|30
condition|;
name|n
operator|-=
literal|30
control|)
block|{
comment|/* Here we want to multiply by 2^n 				   so start by copying n/30 zeroes 				   onto stack */
name|stack
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|work
operator|=
name|bignum
expr_stmt|;
comment|/* copy data onto stack */
name|on1
label|:
switch|switch
condition|(
name|TYPE
argument_list|(
name|work
argument_list|)
condition|)
block|{
case|case
name|INT
case|:
name|stack
argument_list|(
name|work
operator|->
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
name|SDOT
case|:
for|for
control|(
init|;
name|work
operator|!=
operator|(
operator|(
name|lispval
operator|)
literal|0
operator|)
condition|;
name|work
operator|=
name|work
operator|->
name|s
operator|.
name|CDR
control|)
name|stack
argument_list|(
name|work
operator|->
name|s
operator|.
name|I
argument_list|)
expr_stmt|;
break|break;
default|default:
name|work
operator|=
name|errorh1
argument_list|(
name|Vermisc
argument_list|,
literal|"Bignum-shift: bad bignum argument"
argument_list|,
name|nil
argument_list|,
name|TRUE
argument_list|,
literal|996
argument_list|,
name|work
argument_list|)
expr_stmt|;
goto|goto
name|on1
goto|;
block|}
name|bot
operator|=
name|sp
argument_list|()
expr_stmt|;
if|if
condition|(
name|n
operator|>=
literal|0
condition|)
block|{
name|stack
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|bot
operator|--
expr_stmt|;
name|dsmult
argument_list|(
name|top
argument_list|,
name|bot
argument_list|,
literal|1
operator|<<
name|n
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Trimming will only work without leading 			   zeroes without my having to think 			   a lot harder about it, if the inputs 			   are canonical */
for|for
control|(
name|n
operator|=
operator|-
name|n
init|;
name|n
operator|>
literal|30
condition|;
name|n
operator|-=
literal|30
control|)
block|{
if|if
condition|(
name|guard
condition|)
name|sticky
operator||=
literal|1
expr_stmt|;
name|guard
operator|=
name|round
expr_stmt|;
if|if
condition|(
name|top
operator|>
name|bot
condition|)
block|{
name|round
operator|=
operator|*
name|top
expr_stmt|;
name|top
operator|--
expr_stmt|;
block|}
else|else
block|{
name|round
operator|=
operator|*
name|top
expr_stmt|;
operator|*
name|top
operator|>>=
literal|30
expr_stmt|;
block|}
block|}
if|if
condition|(
name|n
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|guard
condition|)
name|sticky
operator||=
literal|1
expr_stmt|;
name|guard
operator|=
name|round
expr_stmt|;
name|round
operator|=
name|dsrsh
argument_list|(
name|top
argument_list|,
name|bot
argument_list|,
operator|-
name|n
argument_list|,
operator|-
literal|1
operator|<<
name|n
argument_list|)
expr_stmt|;
block|}
name|stack
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/*so that dsadd1 will work;*/
if|if
condition|(
name|mode
operator|==
name|STICKY
condition|)
block|{
if|if
condition|(
operator|(
operator|(
operator|*
name|top
operator|&
literal|1
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|round
operator||
name|guard
operator||
name|sticky
operator|)
condition|)
name|dsadd1
argument_list|(
name|top
argument_list|,
name|bot
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mode
operator|==
name|TOEVEN
condition|)
block|{
name|int
name|mask
decl_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
name|n
operator|=
literal|30
expr_stmt|;
name|mask
operator|=
operator|(
literal|1
operator|<<
operator|(
name|n
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|round
operator|&
name|mask
operator|)
condition|)
goto|goto
name|chop
goto|;
name|mask
operator|-=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|round
operator|&
name|mask
operator|)
operator|==
literal|0
operator|)
operator|&&
name|guard
operator|==
literal|0
operator|&&
name|sticky
operator|==
literal|0
operator|&&
operator|(
operator|*
name|top
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
goto|goto
name|chop
goto|;
name|dsadd1
argument_list|(
name|top
argument_list|,
name|bot
argument_list|)
expr_stmt|;
block|}
name|chop
label|:
empty_stmt|;
block|}
name|work
operator|=
name|export
argument_list|(
name|top
operator|+
literal|1
argument_list|,
name|bot
argument_list|)
expr_stmt|;
return|return
operator|(
name|work
operator|)
return|;
block|}
end_function

begin_comment
comment|/*From drb  Mon Jul 27 01:25:56 1981 To: sklower  The idea is that the answer/2 is equal to the exact answer/2 rounded towards - infinity.  The final bit of the answer is the "or" of the true final bit, together with all true bits after the binary point.  In other words, the 1's bit of the answer is almost always 1.  THE FINAL BIT OF THE ANSWER IS 0 IFF n*2^i = THE ANSWER RETURNED EXACTLY, WITH A 0 FINAL BIT.   To try again, more succintly:  the answer is correct to within 1, and the 1's bit of the answer will be 0 only if the answer is exactly correct. */
end_comment

begin_function
name|lispval
name|Lsbiglsh
parameter_list|()
block|{
specifier|register
name|struct
name|argent
modifier|*
name|mylbot
init|=
name|lbot
decl_stmt|;
name|chkarg
argument_list|(
literal|2
argument_list|,
literal|"sticky-bignum-leftshift"
argument_list|)
expr_stmt|;
return|return
operator|(
name|Ibiglsh
argument_list|(
name|lbot
operator|->
name|val
argument_list|,
name|lbot
index|[
literal|1
index|]
operator|.
name|val
argument_list|,
name|STICKY
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lbiglsh
parameter_list|()
block|{
specifier|register
name|struct
name|argent
modifier|*
name|mylbot
init|=
name|lbot
decl_stmt|;
name|chkarg
argument_list|(
literal|2
argument_list|,
literal|"bignum-leftshift"
argument_list|)
expr_stmt|;
return|return
operator|(
name|Ibiglsh
argument_list|(
name|lbot
operator|->
name|val
argument_list|,
name|lbot
index|[
literal|1
index|]
operator|.
name|val
argument_list|,
name|TOEVEN
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|HackHex
parameter_list|()
comment|/* this is a one minute function so drb and kls can debug biglsh */
comment|/* (HackHex i) returns a string which is the result of printing i in hex */
block|{
specifier|register
name|struct
name|argent
modifier|*
name|mylbot
init|=
name|lbot
decl_stmt|;
name|char
name|buf
index|[
literal|32
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%lx"
argument_list|,
name|lbot
operator|->
name|val
operator|->
name|i
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|lispval
operator|)
name|inewstr
argument_list|(
name|buf
argument_list|)
operator|)
return|;
block|}
end_function

end_unit

