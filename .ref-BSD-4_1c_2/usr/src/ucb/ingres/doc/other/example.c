begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|"/usr/sys/param.h"
end_include

begin_comment
comment|/* **  DEMO PROGRAM ** **	This hunk of code does virtually nothing of use.  Its main **	purpose is to demonstrate the "official" ingres coding style. ** **	This demonstrates comments.  There should be a block comment **	at the beginning of every file and/or procedure to explain **	the function of the code.  Important information to put here **	includes the parameters of the routines, any options that the **	user may specify, etc. ** **	The first line of the comment should be a one-line description **	of what's going on.  The remainder should be more detailed. **	Blank lines should seperate major points in the comments.  In **	general, ask yourself the question, "If I didn't know what this **	code was, what it was for, how it fit in, etc., and if I didn't **	even have the documentation for it, would these comments be **	enough for me?" ** **	Some general guidelines for the code: ** **	- Commas and semicolons should always be followed by a space. **		Binary operators should be surrounded on both sides by **		spaces.  Unary operators should be in direct contact **		with the object that they act on, except for "sizeof", **		which should be seperated by one space. ** **	- Two statements should never go on the same line.  This includes **		such things as an if and the associated conditionally **		executed statement. **		In cases such as this, the second half of the if **		should be indented one tab stop more than the if.  For **		example, use: **			if (cond) **				statement; **		never: **			if (cond) statement; **		or: **			if (cond) **			statement; ** **	- Braces ({}) should (almost) always be on a line by them- **		selves.  Exceptions are closing a do, and terminating **		a struct definition or variable initialization.  Braces **		should start at the same indent as the statement with **		which they bind, and code inside the braces should be **		indented one stop further.  For example, use: **			while (cond) **			{ **				code **			} **		and never: **			while (cond) **				{ **				code **				} **		or: **			while (cond) { **				code **			} **		or: **			while (cond) **			{ **			code **			} **		or anything else in that line.  Braces which match **		should always be at the same tab stop. ** **	- Declarations should always have at least one tab between the **		declaration part and the variable list part, but never **		any tabs within the declaration part or the variable **		list part.  For example, in the line: **			register int	i, j; **		There is a tab between the "int" and the "i", but a **		space between "register" and "int", since together **		these make up the declaration part. ** **	- There should always be a space following a keyword (i.e., **		for, if, do, while, switch, and return), but never  **		between a function and the paren preceeding its **		arguments.  For example, use: **			if (i == 0) **				exit(); **		never: **			if(i == 0) **				exit (); ** **	- Every case in a switch statement (including default) should **		be preceeded by a blank line.  The actual word "case" or **		"default" should have the indent of the switch statement plus **		two spaces.  It should be followed by a space (not a **		tab) and the case constant.  Multiple case labels on **		a single block of code should be on seperate lines, but **		they should not be seperated by blank lines.  The **		switch statement should in general be used in place of **		such constructs as: **			if (i == 1) **				code1; **			else **				if (i == 34) **					code2; **				else **					if (i == -1643) **						code3; **		which can be more succinctly stated as: **			switch (i) **			{ ** **			  case 1: **				code1; **				break; ** **			  case 34: **				code2; **				break; ** **			  case -1643: **				code3; **				break; ** **			} **		In point of fact the equivalent switch will compile **		extremely efficiently.  (Note that if you had some **		instance where you could not use a case, e.g., checking **		for i< 5, else check for j> 3, else whatever, then **		the above ("if") code is in the correct style.  However, **		an acceptable alternate structure is to consider "else if" **		as a primitive.  Hence: **			if (i< 5) **				code1; **			else if (j> 3) **				code2; **			else **				code3; **		is acceptable. ** **	- Do statements must always be of the form: **			do **			{ **				code; **			} while (cond); **		even if "code" is only one line.  This is done so that **		it is clear that the "while" is with a do, rather than **		a standalone "while" which is used for the side effects of **		evaluation of the condition. ** **	- Defined constants (defined with the # define feature) must **		be entirely upper case.  The exceptions to this are **		compilation flags, which begin with a lower case "x", **		and some sub-types for parser symbols.  In any case, **		the majority of the symbol is upper case. ** **	- Global variables should begin with an upper case letter and **		be otherwise all lower case.  Local symbols should be **		entirely lower case.  Procedure names are all lower **		case.  The only exception to this is the trace routine **		"tTf".  You should avoid user non-local symbols (globals **		or # define'd symbols) which are one character only; **		it is impossible to distinguish them. ** **	- # defines and # includes should have a space after the sharp **		sign and be followed by a tab.  In general, try to make **		things line up.  Use: **			# define	ARPA		25 **			# define	MAXFIELDS	18 **		and not: **			#define ARPA 25 **			#define MAXFIELDS 18 **		Conditional compilation statements should have as many **		tabs as are necessary to bring the "ifdef", **		"ifndef", or "endif" to the tab stop of the surrounding **		code.  The keyword ("ifdef" or "ifndef") should be **		followed by a space and the conditional compilation **		variable.  Conditional compilation should be used **		around all trace information, timing code, and code **		which may vary from version to version of UNIX.  See **		the code below for an example of conditional compila- **		tion use. ** **	- A blank line should seperate the declarations and the code **		in a procedure.  Blank lines should also be used freely **		between major subsections of your code.  The major **		subsections should also have a comment giving some idea **		of what is about to occur. ** **	- Use descriptive variable names, particularly for global var- **		iables.  "IEH3462" tells me nothing; nor does "R".  On **		the other hand, "Resultid" tells me quite a lot, **		including what it might be, where I might go to see **		how it is initialized, etc.  Try not to use variables **		for multiple purposes. ** **	- It is quite possible to name a file "printr.c" and then **		put the code for "destroydb" in it.  Try to arrange **		the names of your files so that given the name of a **		routine, it is fairly easy to figure out which file **		it is in. ** **	- Sometimes it is really pretty much impossible to avoid doing **		something which is not immediately obvious.  In these **		cases, put in a comment telling what you are doing and **		why you are doing it. ** **	- Try to write things that are clear, rather than things which **		you think are easier to compile.  I mean, who really **		cares?  For example, always declare temporary buffers **		as local, rather than as global.  This way you can **		guarantee that you will never clobber the buffer in **		another routine accidently when it still had useful **		info in it. ** **	Remember, it is easy to write incomprehensible code in **	C.  If you really get off on doing this, however, go get **	a job programming in APL. ** **	For efficiency reasons, you should always use register variables **	when possible.  A simple and extremely effective tip is to define **	a register variable, and assign an oft-used parameter to it, **	since it is particularly inefficient to reference a parameter. **	Another particularly inefficient operation is referencing arrays **	of structures.  When possible, define a register pointer to the **	structure, and then say: **		struct xyz		structure[MAX]; **		register struct xyz	*p; **		... **		for (i = 0; i< MAX; i++) **		{ **			p =&structure[i]; **			p->x = p->y + p->z; **			(diddle with p->???) **		} **	and not: **		struct xyz		structure[MAX]; **		... **		for (i = 0; i< MAX; i++) **		{ **			Structure[i].x = Structure[i].y + Structure[i].z; **			(diddle with Structure[i].???) **		} **	Remember, the nice things about register variables is that they **	make your code smaller and they run faster.  It is hard to **	lose with registers.  There are three restrictions which you **	should be aware of on register variables, however.  First, **	The only types which may be registers are int's, char's, **	and pointers.  Second, there may only be three register **	variables per subroutine.  Third, you may not take the address **	of a register variable (i.e., you may not say "&i" if i is **	typed as a register variable). */
end_comment

begin_define
define|#
directive|define
name|XEQ1
value|5
end_define

begin_struct
struct|struct
name|magic
block|{
name|char
modifier|*
name|name
decl_stmt|;
comment|/* name of symbol */
name|int
name|type
decl_stmt|;
comment|/* type of symbol, defined in symbol.h */
name|int
name|value
decl_stmt|;
comment|/* optional value.  This is actually 				 * the value if it is type "integer", 				 * a pointer to the value if it is a 				 * string. */
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|magic
name|Stuff
decl_stmt|;
end_decl_stmt

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
specifier|register
name|struct
name|magic
modifier|*
name|r
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|;
name|int
name|timebuf
index|[
literal|2
index|]
decl_stmt|;
name|int
name|status
decl_stmt|;
comment|/* Note that in the declarations of argc and argv above, all 	 * parameters to any function should be declared, even if they 	 * are of type int (which is the default). */
name|r
operator|=
operator|&
name|Stuff
expr_stmt|;
comment|/* initialize random # generator */
name|time
argument_list|(
name|timebuf
argument_list|)
expr_stmt|;
name|srand
argument_list|(
name|timebuf
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* scan Stuff structure */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XEQ1
condition|;
name|i
operator|++
control|)
block|{
ifdef|#
directive|ifdef
name|xTRACE
if|if
condition|(
name|tTf
argument_list|(
literal|5
argument_list|,
literal|13
argument_list|)
condition|)
name|printf
argument_list|(
literal|"switch on type %d\n"
argument_list|,
name|r
operator|->
name|reltype
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|r
operator|->
name|type
condition|)
block|{
case|case
literal|0
case|:
case|case
literal|1
case|:
case|case
literal|3
case|:
comment|/* initialize */
name|printf
argument_list|(
literal|"hi\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* end of query */
name|printf
argument_list|(
literal|"bye\n"
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* be sure to print plenty of info on an error; 			 * "syserr("bad reltype");" would not have been 			 * sufficient */
name|syserr
argument_list|(
literal|"bad type %d"
argument_list|,
name|r
operator|->
name|type
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* resist the temptation to say "} else {" */
if|if
condition|(
name|i
operator|==
literal|5
condition|)
block|{
name|i
operator|++
expr_stmt|;
name|j
operator|=
literal|4
expr_stmt|;
block|}
else|else
name|i
operator|--
expr_stmt|;
comment|/* plot the results */
do|do
block|{
name|i
operator|=
name|rand
argument_list|()
operator|&
literal|017
expr_stmt|;
while|while
condition|(
name|i
operator|--
condition|)
block|{
name|printf
argument_list|(
literal|"*"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|j
operator|--
condition|)
do|;
comment|/* wait for child processes to complete */
name|wait
argument_list|(
operator|&
name|status
argument_list|)
expr_stmt|;
comment|/* end of run, print termination message and exit */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"bye "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

