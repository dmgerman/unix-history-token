begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|<ingres.h>
end_include

begin_undef
undef|#
directive|undef
name|MAXNAME
end_undef

begin_include
include|#
directive|include
file|"../equel/constants.h"
end_include

begin_include
include|#
directive|include
file|"IIglobals.h"
end_include

begin_include
include|#
directive|include
file|<sccs.h>
end_include

begin_macro
name|SCCSID
argument_list|(
argument|@(#)IIw_right.c
literal|7.1
literal|2
argument|/
literal|5
argument|/
literal|81
argument_list|)
end_macro

begin_comment
comment|/* **  IIw_right -- Write down to the Quel parser a string **	for a target list of anything but a tupret. ** **	Parameters: **		string -- a string which contains the target list **			of a quel statement, where values from C variables **			to be plugged in are flagged by the construct **			'%<ingres_type>" a la printf(). String is left  **			unchanged.  **			To escape the '%' mechanism use '%%'. ** **		argv -- a vector of pointers to **			variables from which the values flagged by the '%' **			mechanism are taken. ** **	Usage: **		argv [0] =&double_raise; **		IIw_right("dom1 = i.ifield * (1+%f8)", argv); ** **	Required By: **		all the parametrized statements except "tupret_p". ** **	Error numbers: **		1004 -- bad type in parametrized statement. */
end_comment

begin_macro
name|IIw_right
argument_list|(
argument|string
argument_list|,
argument|argv
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|string
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|b_st
decl_stmt|,
modifier|*
name|e_st
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|av
decl_stmt|;
name|int
name|type
decl_stmt|;
name|char
modifier|*
name|IIitos
parameter_list|()
function_decl|;
if|if
condition|(
name|IIdebug
condition|)
name|printf
argument_list|(
literal|"ent IIw_right : string \"%s\"\n"
argument_list|,
name|string
argument_list|)
expr_stmt|;
name|av
operator|=
name|argv
expr_stmt|;
for|for
control|(
name|b_st
operator|=
name|e_st
operator|=
name|string
init|;
operator|*
name|e_st
condition|;
control|)
block|{
if|if
condition|(
operator|*
name|e_st
operator|!=
literal|'%'
condition|)
block|{
name|e_st
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* provide '%%' escape mechanism */
if|if
condition|(
name|e_st
index|[
literal|1
index|]
operator|==
literal|'%'
condition|)
block|{
name|e_st
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|IIwrite
argument_list|(
name|b_st
argument_list|)
expr_stmt|;
name|e_st
index|[
literal|1
index|]
operator|=
literal|'%'
expr_stmt|;
name|b_st
operator|=
name|e_st
operator|=
operator|&
name|e_st
index|[
literal|2
index|]
expr_stmt|;
continue|continue;
block|}
operator|*
name|e_st
operator|=
literal|'\0'
expr_stmt|;
name|IIwrite
argument_list|(
name|b_st
argument_list|)
expr_stmt|;
operator|*
name|e_st
operator|++
operator|=
literal|'%'
expr_stmt|;
switch|switch
condition|(
operator|*
name|e_st
condition|)
block|{
case|case
literal|'f'
case|:
switch|switch
condition|(
operator|*
operator|++
name|e_st
condition|)
block|{
case|case
literal|'8'
case|:
name|IIcvar
argument_list|(
operator|*
name|av
argument_list|,
literal|4
argument_list|,
literal|8
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'4'
case|:
name|IIcvar
argument_list|(
operator|*
name|av
argument_list|,
literal|2
argument_list|,
literal|4
argument_list|)
expr_stmt|;
break|break;
default|default :
goto|goto
name|error_label
goto|;
block|}
name|av
operator|++
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
switch|switch
condition|(
operator|*
operator|++
name|e_st
condition|)
block|{
case|case
literal|'4'
case|:
name|IIcvar
argument_list|(
operator|*
name|av
argument_list|,
literal|2
argument_list|,
literal|4
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'2'
case|:
name|IIcvar
argument_list|(
operator|*
name|av
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'1'
case|:
name|IIcvar
argument_list|(
operator|*
name|av
argument_list|,
literal|5
argument_list|,
literal|1
argument_list|)
expr_stmt|;
default|default :
goto|goto
name|error_label
goto|;
block|}
name|av
operator|++
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|IIcvar
argument_list|(
operator|*
name|av
operator|++
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
name|b_st
operator|=
operator|++
name|e_st
expr_stmt|;
block|}
name|IIwrite
argument_list|(
name|b_st
argument_list|)
expr_stmt|;
return|return;
name|error_label
label|:
name|IIerror
argument_list|(
literal|1004
argument_list|,
literal|1
argument_list|,
operator|&
name|string
argument_list|)
expr_stmt|;
name|IIerrflag
operator|=
literal|1004
expr_stmt|;
comment|/* make sure that part already written down will  	 * cause an error, and don't print it. 	 *	The old IIprint_err is restored in IIerror() 	 */
name|IIwrite
argument_list|(
literal|","
argument_list|)
expr_stmt|;
name|IIo_print
operator|=
name|IIprint_err
expr_stmt|;
name|IIprint_err
operator|=
name|IIno_err
expr_stmt|;
block|}
end_block

end_unit

