begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|<ingres.h>
end_include

begin_undef
undef|#
directive|undef
name|MAXNAME
end_undef

begin_include
include|#
directive|include
file|"../equel/constants.h"
end_include

begin_include
include|#
directive|include
file|"IIglobals.h"
end_include

begin_include
include|#
directive|include
file|<sccs.h>
end_include

begin_macro
name|SCCSID
argument_list|(
argument|@(#)IIw_left.c
literal|7.2
literal|10
argument|/
literal|27
argument|/
literal|81
argument_list|)
end_macro

begin_comment
comment|/* **	IIw_left -- writes down a "tupret's" target list. **		 **	Parameters: **		string -- a char * to a string containing everything **			inside the equivalent "retrieve" statement, **			but instead of result domain names, the string **			should have '%<ingres_type>', where<ingres_type> **			is the ingres type of the resulting C variable. **			To escape a '%' use 2 ("%%"). **			'String' is left unchanged after the call. **		argv -- a vector of pointers to the  **			corresponding C variables. ** **	Usage: **		argv [0] =&double_var; **		argv [1] =&int_var; **		IIw_left("%f8 = i.double, %i2=i.ifield", argv); ** **	Required by: **		parametrized retrieves without a target relation ** **	Requires: **		Uses the ret_sym array IIretsym, and the old equel **		method for doing tuprets. NOTE that this does not **		allow dynamic (before each tuple) resolution of  **		the result C variables as does the new tupret method. ** **	Error numbers: **		1003 -- 1 parameter, the erroneous string. **			"Bad format for a domain in a param retrieve **			without a result relation" */
end_comment

begin_macro
name|IIw_left
argument_list|(
argument|string
argument_list|,
argument|argv
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|string
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|b_st
decl_stmt|,
modifier|*
name|e_st
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|av
decl_stmt|;
name|int
name|type
decl_stmt|;
name|char
modifier|*
name|IIitos
parameter_list|()
function_decl|;
if|if
condition|(
name|IIdebug
condition|)
name|printf
argument_list|(
literal|"ent IIw_left : string \"%s\"\n"
argument_list|,
name|string
argument_list|)
expr_stmt|;
name|av
operator|=
name|argv
expr_stmt|;
for|for
control|(
name|b_st
operator|=
name|e_st
operator|=
name|string
init|;
operator|*
name|e_st
condition|;
control|)
block|{
if|if
condition|(
operator|*
name|e_st
operator|!=
literal|'%'
condition|)
block|{
name|e_st
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* provide escape method */
if|if
condition|(
name|e_st
index|[
literal|1
index|]
operator|==
literal|'%'
condition|)
block|{
name|e_st
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|IIwrite
argument_list|(
name|b_st
argument_list|)
expr_stmt|;
comment|/* leave string intact */
name|e_st
index|[
literal|1
index|]
operator|=
literal|'%'
expr_stmt|;
name|b_st
operator|=
name|e_st
operator|=
operator|&
name|e_st
index|[
literal|2
index|]
expr_stmt|;
continue|continue;
block|}
operator|*
name|e_st
operator|=
literal|'\0'
expr_stmt|;
name|IIwrite
argument_list|(
name|b_st
argument_list|)
expr_stmt|;
operator|*
name|e_st
operator|++
operator|=
literal|'%'
expr_stmt|;
name|IIwrite
argument_list|(
literal|" RET_VAR "
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|*
name|e_st
condition|)
block|{
case|case
literal|'f'
case|:
switch|switch
condition|(
operator|*
operator|++
name|e_st
condition|)
block|{
case|case
literal|'8'
case|:
name|type
operator|=
name|opDOUBLE
expr_stmt|;
break|break;
case|case
literal|'4'
case|:
name|type
operator|=
name|opFLOAT
expr_stmt|;
break|break;
default|default :
goto|goto
name|error_label
goto|;
block|}
break|break;
case|case
literal|'i'
case|:
switch|switch
condition|(
operator|*
operator|++
name|e_st
condition|)
block|{
case|case
literal|'4'
case|:
name|type
operator|=
name|opLONG
expr_stmt|;
break|break;
case|case
literal|'2'
case|:
name|type
operator|=
name|opSHORT
expr_stmt|;
break|break;
default|default :
goto|goto
name|error_label
goto|;
block|}
break|break;
case|case
literal|'c'
case|:
name|type
operator|=
name|opSTRING
expr_stmt|;
break|break;
block|}
name|IIretrieve
argument_list|(
operator|*
name|av
operator|++
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|b_st
operator|=
operator|++
name|e_st
expr_stmt|;
block|}
name|IIwrite
argument_list|(
name|b_st
argument_list|)
expr_stmt|;
return|return;
name|error_label
label|:
name|IIerror
argument_list|(
literal|1003
argument_list|,
literal|1
argument_list|,
operator|&
name|string
argument_list|)
expr_stmt|;
name|IIerrflag
operator|=
literal|1003
expr_stmt|;
comment|/* make sure that part already written down will 	 * cause an error, and ignore that error 	 */
name|IIwrite
argument_list|(
literal|","
argument_list|)
expr_stmt|;
name|IIo_print
operator|=
name|IIprint_err
expr_stmt|;
name|IIprint_err
operator|=
name|IIno_err
expr_stmt|;
block|}
end_block

end_unit

