begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|<ingres.h>
end_include

begin_include
include|#
directive|include
file|<aux.h>
end_include

begin_include
include|#
directive|include
file|<access.h>
end_include

begin_include
include|#
directive|include
file|<sccs.h>
end_include

begin_macro
name|SCCSID
argument_list|(
argument|@(#)findbest.c
literal|7.1
literal|2
argument|/
literal|5
argument|/
literal|81
argument_list|)
end_macro

begin_comment
comment|/* **	Findbest - find the "best" place to put a tuple. **	Findbest does not actually put the tuple but rather **	returns and allocates the tid for the tuple. ** **	The initial part of the algorithm depends on whether **	the relation is a heap or not. ** **	If the relation is a heap, if there is a current page **	with room for the tuple, that page is used. Otherwise **	the last page of the heap is considered. ** **	If the relation is hash or isam, then "find" is used **	to determine the primary page for the tuple. ** **	If necessary, findbest will allocate an overflow page **	if there is not sufficient room for the tuple otherwise. ** **	If checkdups is TRUE and the relation is not a heap, **	findbest will check for duplicates. ** **	Returns: ** **		0 tuple not a duplicate, tid allocated **		1 tuple a duplicate of the tuple at tid */
end_comment

begin_macro
name|findbest
argument_list|(
argument|dx
argument_list|,
argument|tidx
argument_list|,
argument|tuple
argument_list|,
argument|need
argument_list|,
argument|checkdups
argument_list|)
end_macro

begin_decl_stmt
name|DESC
modifier|*
name|dx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|TID
modifier|*
name|tidx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|tuple
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|need
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|checkdups
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|DESC
modifier|*
name|d
decl_stmt|;
specifier|register
name|TID
modifier|*
name|tid
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|TID
name|temptid
decl_stmt|;
name|d
operator|=
name|dx
expr_stmt|;
name|tid
operator|=
name|tidx
expr_stmt|;
if|if
condition|(
name|abs
argument_list|(
name|d
operator|->
name|reldum
operator|.
name|relspec
argument_list|)
operator|==
name|M_HEAP
condition|)
block|{
name|checkdups
operator|=
name|FALSE
expr_stmt|;
comment|/* determine a page to place tuple in heap relation */
name|find_page
argument_list|(
name|d
argument_list|,
name|tid
argument_list|,
name|need
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* find a suitable page for isam or hash */
comment|/* determine primary page */
if|if
condition|(
name|i
operator|=
name|find
argument_list|(
name|d
argument_list|,
name|FULLKEY
argument_list|,
name|tid
argument_list|,
name|tid
argument_list|,
name|tuple
argument_list|)
condition|)
block|{
return|return
operator|(
name|i
operator|)
return|;
comment|/* fatal error */
block|}
comment|/* If we are not checking for duplicates then take any 		** convenient page linked to the main page current indicated 		** in "tid" 		*/
if|if
condition|(
operator|!
name|checkdups
condition|)
name|find_page
argument_list|(
name|d
argument_list|,
name|tid
argument_list|,
name|need
argument_list|)
expr_stmt|;
block|}
comment|/* search the chain of pages looking for a spot */
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|i
operator|=
name|get_page
argument_list|(
name|d
argument_list|,
name|tid
argument_list|)
condition|)
break|break;
comment|/* fatal error */
comment|/* if tuple is duplicate, drop out */
if|if
condition|(
name|checkdups
operator|&&
name|dup_check
argument_list|(
name|d
argument_list|,
name|tid
argument_list|,
name|tuple
argument_list|)
condition|)
block|{
name|i
operator|=
literal|1
expr_stmt|;
break|break;
block|}
comment|/* is there space on this page */
if|if
condition|(
name|space_left
argument_list|(
name|Acc_head
argument_list|)
operator|>=
name|need
condition|)
break|break;
comment|/* found a page to use */
comment|/* no space yet. look on next overflow page */
if|if
condition|(
name|Acc_head
operator|->
name|ovflopg
condition|)
block|{
name|stuff_page
argument_list|(
name|tid
argument_list|,
operator|&
name|Acc_head
operator|->
name|ovflopg
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* no space. allocate new overflow page */
if|if
condition|(
name|i
operator|=
name|add_ovflo
argument_list|(
name|d
argument_list|,
name|tid
argument_list|)
condition|)
break|break;
comment|/* fatal error */
block|}
comment|/* check for dups on remaining overflow pages */
comment|/* check only if there hasn't been a dup or a page error */
if|if
condition|(
name|i
operator|==
literal|0
operator|&&
name|checkdups
operator|&&
name|Acc_head
operator|->
name|ovflopg
condition|)
block|{
name|stuff_page
argument_list|(
operator|&
name|temptid
argument_list|,
operator|&
name|Acc_head
operator|->
name|ovflopg
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|=
name|scan_dups
argument_list|(
name|d
argument_list|,
operator|&
name|temptid
argument_list|,
name|tuple
argument_list|)
condition|)
name|bmove
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|temptid
argument_list|,
operator|(
name|char
operator|*
operator|)
name|tid
argument_list|,
sizeof|sizeof
argument_list|(
name|temptid
argument_list|)
argument_list|)
expr_stmt|;
comment|/* tid of duplicate */
block|}
comment|/* if tuple isn't a duplicate, allocate a line number */
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|tid
operator|->
name|line_id
operator|=
name|newlino
argument_list|(
name|need
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|xATR1
if|if
condition|(
name|tTf
argument_list|(
literal|27
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"findbest ret %d,"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|dumptid
argument_list|(
name|tid
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
operator|(
name|i
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **	FINDBEST -- find best page for tuple ** **	Find an appropriate page to put a tuple. **	If HEAP then any page with room will do. If none **	can be found, then use the last page. **	If it is a user relation and a page was found but **	was full, use it anyway. This can happen only on a **	modify (which has checkdups turned off). ** **	For ISAM or HASH look for a page on the same mainpage **	chain. Duplicate checking must not be enforced. ** **	The first page to use will be returned in tid in either **	case. */
end_comment

begin_macro
name|find_page
argument_list|(
argument|dx
argument_list|,
argument|tid
argument_list|,
argument|need
argument_list|)
end_macro

begin_decl_stmt
name|DESC
modifier|*
name|dx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|TID
modifier|*
name|tid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|need
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|DESC
modifier|*
name|d
decl_stmt|;
specifier|register
name|struct
name|accbuf
modifier|*
name|b
decl_stmt|,
modifier|*
name|maxbf
decl_stmt|;
name|int
name|heap
decl_stmt|;
name|long
name|mainpg
decl_stmt|;
name|d
operator|=
name|dx
expr_stmt|;
name|maxbf
operator|=
name|NULL
expr_stmt|;
name|heap
operator|=
name|abs
argument_list|(
name|d
operator|->
name|reldum
operator|.
name|relspec
argument_list|)
operator|==
name|M_HEAP
expr_stmt|;
name|pluck_page
argument_list|(
name|tid
argument_list|,
operator|&
name|mainpg
argument_list|)
expr_stmt|;
name|mainpg
operator|++
expr_stmt|;
comment|/* mainpage in buffer points to next higher mainpage */
comment|/* scan all current buffers looking for one belonging to this relation */
for|for
control|(
name|b
operator|=
name|Acc_head
init|;
name|b
operator|!=
name|NULL
condition|;
name|b
operator|=
name|b
operator|->
name|modf
control|)
block|{
if|if
condition|(
name|d
operator|->
name|reltid
operator|.
name|ltid
operator|==
name|b
operator|->
name|rel_tupid
operator|&&
operator|!
operator|(
name|b
operator|->
name|bufstatus
operator|&
name|BUF_DIRECT
operator|)
operator|&&
operator|(
name|heap
operator|||
operator|(
name|b
operator|->
name|mainpg
operator|==
name|mainpg
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|space_left
argument_list|(
name|b
argument_list|)
operator|>=
name|need
condition|)
block|{
comment|/* use this page */
name|stuff_page
argument_list|(
name|tid
argument_list|,
operator|&
name|b
operator|->
name|thispage
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* save buffer of largest page */
if|if
condition|(
name|maxbf
operator|==
name|NULL
operator|||
name|maxbf
operator|->
name|thispage
operator|<
name|b
operator|->
name|thispage
condition|)
name|maxbf
operator|=
name|b
expr_stmt|;
block|}
block|}
if|if
condition|(
name|heap
condition|)
name|last_page
argument_list|(
name|d
argument_list|,
name|tid
argument_list|,
name|maxbf
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* if we found a full page of a user's relation,use it */
if|if
condition|(
name|maxbf
operator|&&
operator|(
name|d
operator|->
name|reldum
operator|.
name|relstat
operator|&
name|S_CATALOG
operator|)
operator|==
literal|0
condition|)
name|stuff_page
argument_list|(
name|tid
argument_list|,
operator|&
name|maxbf
operator|->
name|thispage
argument_list|)
expr_stmt|;
block|}
block|}
end_block

end_unit

