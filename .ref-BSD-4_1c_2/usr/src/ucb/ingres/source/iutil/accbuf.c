begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|<ingres.h>
end_include

begin_include
include|#
directive|include
file|<access.h>
end_include

begin_include
include|#
directive|include
file|<aux.h>
end_include

begin_include
include|#
directive|include
file|<lock.h>
end_include

begin_include
include|#
directive|include
file|<opsys.h>
end_include

begin_include
include|#
directive|include
file|<sccs.h>
end_include

begin_macro
name|SCCSID
argument_list|(
argument|@(#)accbuf.c
literal|7.1
literal|2
argument|/
literal|5
argument|/
literal|81
argument_list|)
end_macro

begin_comment
comment|/* **	access method buffers and other data areas for buffer maintenance */
end_comment

begin_decl_stmt
name|struct
name|accbuf
name|Acc_buf
index|[
name|NACCBUFS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the buffers */
end_comment

begin_decl_stmt
name|struct
name|accbuf
modifier|*
name|Acc_head
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* head of usage list */
end_comment

begin_decl_stmt
name|struct
name|accbuf
modifier|*
name|Acc_tail
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* tail of usage list */
end_comment

begin_decl_stmt
name|struct
name|lockreq
name|Lock
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* **	structs for admin file data */
end_comment

begin_decl_stmt
name|struct
name|admin
name|Admin
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* **	global flag indicating if access methods **	have been initialized. */
end_comment

begin_decl_stmt
name|int
name|Acc_init
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|Acclock
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* locks enabled flag */
end_comment

begin_decl_stmt
name|int
name|Alockdes
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* file descriptor for lock device*/
end_comment

begin_decl_stmt
name|int
name|Lockrel
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* lock relations flag*/
end_comment

begin_escape
end_escape

begin_comment
comment|/* **	Flush the indicated page and reset all **	important information including the name ** **	Trace Flags: **		20.0,1 */
end_comment

begin_macro
name|resetacc
argument_list|(
argument|buf
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|accbuf
modifier|*
name|buf
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|accbuf
modifier|*
name|b
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|b
operator|=
name|buf
expr_stmt|;
if|if
condition|(
name|b
operator|==
literal|0
condition|)
name|b
operator|=
name|Acc_head
expr_stmt|;
ifdef|#
directive|ifdef
name|xATR3
if|if
condition|(
name|tTf
argument_list|(
literal|20
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"RESETACC: %x="
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|dumptid
argument_list|(
operator|(
name|TID
operator|*
operator|)
operator|&
name|b
operator|->
name|rel_tupid
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|i
operator|=
name|pageflush
argument_list|(
name|b
argument_list|)
expr_stmt|;
comment|/* write the page if necessary */
name|b
operator|->
name|rel_tupid
operator|=
operator|-
literal|1
expr_stmt|;
name|b
operator|->
name|filedesc
operator|=
operator|-
literal|1
expr_stmt|;
name|b
operator|->
name|thispage
operator|=
operator|-
literal|1
expr_stmt|;
name|b
operator|->
name|bufstatus
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **	initialize access method data areas ** **	Trace Flags: **		20.2,3 */
end_comment

begin_macro
name|acc_init
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|accbuf
modifier|*
name|last
decl_stmt|;
specifier|register
name|struct
name|accbuf
modifier|*
name|b
decl_stmt|;
name|struct
name|stat
name|stbuf
decl_stmt|;
specifier|extern
name|int
name|errno
decl_stmt|;
ifdef|#
directive|ifdef
name|xATR3
if|if
condition|(
name|tTf
argument_list|(
literal|20
argument_list|,
literal|2
argument_list|)
condition|)
name|printf
argument_list|(
literal|"ACC_INIT=%d\n"
argument_list|,
name|Acc_init
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|Acc_init
condition|)
return|return;
comment|/* already initialized */
name|last
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|b
operator|=
name|Acc_buf
init|;
name|b
operator|<
operator|&
name|Acc_buf
index|[
name|NACCBUFS
index|]
condition|;
control|)
block|{
name|resetacc
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|b
operator|->
name|modb
operator|=
name|last
expr_stmt|;
name|last
operator|=
name|b
expr_stmt|;
name|b
operator|++
expr_stmt|;
name|last
operator|->
name|modf
operator|=
name|b
expr_stmt|;
block|}
name|last
operator|->
name|modf
operator|=
literal|0
expr_stmt|;
name|Acc_head
operator|=
name|Acc_buf
expr_stmt|;
name|Acc_tail
operator|=
name|last
expr_stmt|;
comment|/* get the admin file */
name|readadmin
argument_list|()
expr_stmt|;
comment|/* 	** Set up locking information. If the database has concurrency 	** control then Lockrel = TRUE and the concurrency device will 	** be opened for writing. If there is no concurrency for the 	** data base or if the lock device isn't installed, then Alockdes 	** = -1 and no locking will (or can) occure. 	*/
name|Lockrel
operator|=
operator|(
name|Admin
operator|.
name|adhdr
operator|.
name|adflags
operator|&
name|A_DBCONCUR
operator|)
operator|!=
literal|0
expr_stmt|;
if|if
condition|(
name|Lockrel
operator|&&
name|Alockdes
operator|<
literal|0
condition|)
name|Alockdes
operator|=
name|open
argument_list|(
literal|"/dev/lock"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
comment|/* clear in case /dev/lock isn't available */
name|Acclock
operator|=
name|TRUE
expr_stmt|;
name|stat
argument_list|(
literal|"."
argument_list|,
operator|&
name|stbuf
argument_list|)
expr_stmt|;
name|bmove
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|stbuf
argument_list|,
operator|(
name|char
operator|*
operator|)
name|Lock
operator|.
name|dbnode
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|Acc_init
operator|=
name|TRUE
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **	place buffer at top of LRU list */
end_comment

begin_macro
name|top_acc
argument_list|(
argument|buf
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|accbuf
modifier|*
name|buf
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|accbuf
modifier|*
name|b
decl_stmt|;
name|b
operator|=
name|buf
expr_stmt|;
if|if
condition|(
name|b
operator|==
name|Acc_head
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|b
operator|==
name|Acc_tail
condition|)
name|Acc_tail
operator|=
name|b
operator|->
name|modb
expr_stmt|;
else|else
name|b
operator|->
name|modf
operator|->
name|modb
operator|=
name|b
operator|->
name|modb
expr_stmt|;
name|b
operator|->
name|modb
operator|->
name|modf
operator|=
name|b
operator|->
name|modf
expr_stmt|;
name|Acc_head
operator|->
name|modb
operator|=
name|b
expr_stmt|;
name|b
operator|->
name|modf
operator|=
name|Acc_head
expr_stmt|;
name|Acc_head
operator|=
name|b
expr_stmt|;
name|b
operator|->
name|modb
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* ** Flush_rel -- flush all pages associated with the relation **	described by the descriptor. If resetflag is TRUE, **	then the buffers are reset so the pages will not be **	found on subsequent calls to find_page(). ** **	Returns "or'ed" result from calls to pageflush. ** **	Trace Flags: **		20.4-5 */
end_comment

begin_expr_stmt
name|flush_rel
argument_list|(
name|d
argument_list|,
name|resetflag
argument_list|)
specifier|register
name|DESC
operator|*
name|d
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|resetflag
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|accbuf
modifier|*
name|b
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|xATR3
if|if
condition|(
name|tTf
argument_list|(
literal|20
argument_list|,
literal|4
argument_list|)
condition|)
name|printf
argument_list|(
literal|"flush_rel: rel=%.14s, reset=%d\n"
argument_list|,
name|d
operator|->
name|reldum
operator|.
name|relid
argument_list|,
name|resetflag
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|b
operator|=
name|Acc_head
init|;
name|b
operator|!=
name|NULL
condition|;
name|b
operator|=
name|b
operator|->
name|modf
control|)
block|{
if|if
condition|(
name|d
operator|->
name|reltid
operator|.
name|ltid
operator|==
name|b
operator|->
name|rel_tupid
condition|)
block|{
if|if
condition|(
name|resetflag
condition|)
name|i
operator||=
name|resetacc
argument_list|(
name|b
argument_list|)
expr_stmt|;
else|else
name|i
operator||=
name|pageflush
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|i
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **	CHOOSE_BUF -- Try to find an empty buffer for assignment. **		If there is no empty buffer, pick the last buffer **		in the LRU queue and make sure it is flushed. ** **		Choose_buf guarantees that the buffer will be reset **		if it was used previously for a different relation. ** **	Choose_buf -- choose a buffer for use with the given relation on **	the given page. The current algorithm is to allow only one buffer **	per relation. If a relation does not have a buffer, it is given a **	free one (if any) or else the Least Recently Used. ** **	Trace Flags: **		29.0,1 */
end_comment

begin_function
name|struct
name|accbuf
modifier|*
name|choose_buf
parameter_list|(
name|dx
parameter_list|,
name|pageid
parameter_list|)
name|DESC
modifier|*
name|dx
decl_stmt|;
name|long
name|pageid
decl_stmt|;
block|{
specifier|register
name|struct
name|accbuf
modifier|*
name|b
decl_stmt|,
modifier|*
name|free
decl_stmt|;
specifier|register
name|DESC
modifier|*
name|d
decl_stmt|;
name|struct
name|accbuf
modifier|*
name|mine
decl_stmt|;
name|d
operator|=
name|dx
expr_stmt|;
name|free
operator|=
name|mine
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|b
operator|=
name|Acc_head
init|;
name|b
operator|!=
literal|0
condition|;
name|b
operator|=
name|b
operator|->
name|modf
control|)
block|{
if|if
condition|(
name|b
operator|->
name|rel_tupid
operator|==
operator|-
literal|1
condition|)
name|free
operator|=
name|b
expr_stmt|;
elseif|else
if|if
condition|(
name|d
operator|->
name|reltid
operator|.
name|ltid
operator|==
name|b
operator|->
name|rel_tupid
condition|)
block|{
if|if
condition|(
name|pageid
operator|==
name|b
operator|->
name|thispage
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|relopn
operator|<
literal|0
condition|)
name|b
operator|->
name|filedesc
operator|=
name|d
operator|->
name|relfp
expr_stmt|;
return|return
operator|(
name|b
operator|)
return|;
block|}
name|mine
operator|=
name|b
expr_stmt|;
block|}
block|}
comment|/* 	** "Free" and "Mine" now reflect the current state of the buffers. 	** There is no buffer with the currently requested page 	*/
ifdef|#
directive|ifdef
name|xATR3
if|if
condition|(
name|tTf
argument_list|(
literal|29
argument_list|,
literal|1
argument_list|)
condition|)
name|printf
argument_list|(
literal|"choosebuf free %x,mine %x\n"
argument_list|,
name|free
argument_list|,
name|mine
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* no current buffer. Choose a free one or LRU */
if|if
condition|(
name|free
operator|==
name|NULL
condition|)
name|free
operator|=
name|resetacc
argument_list|(
name|Acc_tail
argument_list|)
condition|?
name|NULL
else|:
name|Acc_tail
expr_stmt|;
comment|/* error if can't reset the LRU */
if|if
condition|(
name|free
condition|)
block|{
comment|/* copy relevant material (in this order in case of rubout) */
name|free
operator|->
name|filedesc
operator|=
name|d
operator|->
name|relfp
expr_stmt|;
name|free
operator|->
name|rel_tupid
operator|=
name|d
operator|->
name|reltid
operator|.
name|ltid
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|xATR1
if|if
condition|(
name|tTf
argument_list|(
literal|29
argument_list|,
literal|0
argument_list|)
condition|)
name|printf
argument_list|(
literal|"choosebuf:rets %x\n"
argument_list|,
name|free
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|free
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **	ACC_CLOSE -- flush any buffers left around **		and then close the files for relation& attribute. **		The relation and attribute relation are normally left open **		until the end of an INGRES session but must be closed **		and re-opened in the dbu's whenever a new overlay is loaded. */
end_comment

begin_macro
name|acc_close
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|i
operator|=
name|pageflush
argument_list|(
operator|(
expr|struct
name|accbuf
operator|*
operator|)
name|NULL
argument_list|)
condition|)
name|syserr
argument_list|(
literal|"acc_close: pageflush %d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|Admin
operator|.
name|adreld
operator|.
name|relfp
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|Admin
operator|.
name|adattd
operator|.
name|relfp
argument_list|)
expr_stmt|;
name|Admin
operator|.
name|adreld
operator|.
name|relopn
operator|=
name|Admin
operator|.
name|adattd
operator|.
name|relopn
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|Alockdes
operator|>=
literal|0
condition|)
name|close
argument_list|(
name|Alockdes
argument_list|)
expr_stmt|;
name|Alockdes
operator|=
operator|-
literal|1
expr_stmt|;
name|Acc_init
operator|=
name|FALSE
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

end_unit

