begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ingres.h>
end_include

begin_include
include|#
directive|include
file|<aux.h>
end_include

begin_include
include|#
directive|include
file|<version.h>
end_include

begin_include
include|#
directive|include
file|<opsys.h>
end_include

begin_include
include|#
directive|include
file|<access.h>
end_include

begin_include
include|#
directive|include
file|<lock.h>
end_include

begin_include
include|#
directive|include
file|<sccs.h>
end_include

begin_macro
name|SCCSID
argument_list|(
argument|@(#)initucode.c
literal|7.1
literal|2
argument|/
literal|5
argument|/
literal|81
argument_list|)
end_macro

begin_comment
comment|/* **  INITUCODE -- initialize standalone process ** **	This function initializes a standalone process, initializing **	a lot of global variables, scanning the argument vector for **	some special flags (-u and +-w), seperating flags and **	parameters, and so forth. ** **	Every standalone program should begin with the lines: **			i = initucode(argc, argv, ...); **			switch (i) **				... ** **	On a return of 2, 3, or 4, essentially none of the processing **	is done (particularly true with return 4).  Virtually nothing **	can be done in the calling program except print a "usage" **	message and exit.  The exception to this is that 'Pathname' **	is set, so that it can be used in the error printing.  For **	example, ingres.c cats file .../files/usage on this sort of **	error. ** **	If it is preferable to not lock the database at this time, **	the 'waitmode' parameter should be passed as -1.  This still **	causes the 'Wait_action' variable to be initialized, but the **	database is not actually locked.  It can be locked by calling: **		db_lock(Dbpath, M_EXCL); **	at the proper time. ** **	For the main effects of this routine, see the "Side Effects" **	section below. ** **	Parameters: **		argc -- argc from main. **		argv -- argv from main. **		dbflag -- TRUE -- take the first parameter as the **				database name. **			FALSE -- don't take the first parameter as **				the database name. **		paramlist -- a pointer to an array[4] of pointers **			to character; set to the extra fields of **			the users file entry for the real user **			executing the code (not the user on the **			-u flag).  If NULL, this is ignored. **		waitmode -- M_EXCL -- set an exclusive lock on the **				database. **			M_SHARE -- set a shared lock on the database. **			-1 -- don't set a lock on the database. **				However, other stuff (Wait_action) is **				still set up so that the lock can be **				placed later by calling 'db_lock'. ** **	Returns: **		0 -- everything is ok. **		1 -- the database does not exist. **		2 -- you are not authorized to access this database. **		3 -- you are not a valid INGRES user. **		4 -- no database name was specified (only if dbflag **			== TRUE). **		5 -- everything is ok, but there was an indirect **			taken. **		6 -- there was an indirect taken, but there was no **			database there. ** **		If dbflag == FALSE, you can only get returns 0 and **			3. ** **	Side Effects: **		A lot of variables are set, as follows: ** **		Dbpath -- set to the pathname of the database (only **			if dbflag == TRUE).  It is set even if the **			database does not exist. **		Parmvect -- set to the parameters from argv, that is, **			anything not beginning with '+' or '-'. **		Flagvect -- set to the flags from argv, that is, **			everything beginning with '+' or '-'.  The **			flags '+w', '-w', and '-u' are stripped out, **			however. **		Wait_action -- set to the appropriate action (A_SLP **			or A_RTN) based on the +-w flags and whether **			we are running in background or not. **			This is automatically used by 'db_lock()'. **		Usercode -- set to the persons effective user code **			(that is, after the -u processing).  Only **			the INGRES user or the DBA can use the -u **			flag. **		Pathname -- set to the pathname of the INGRES subtree. **		Status -- an integer set to the user status field **			of the users file for the real user. **		Ing_uid -- set to the user id of the INGRES user. ** **		The rubout signal (signal 2) is caught, and refered **		to the standard rubout processor (see rub.c); thus, **		a routine called 'rubproc' must be defined in the **		standalone code (which will just call exit, in the **		normal case). ** **		The 'adminhdr' part of the 'Admin' struct is filled **		in.  This is not done with readadmin() and is not **		equivalent to an 'admininit()', but it does make **		the DBA and database status available. ** **		This routine can also exit immediately with an **		error message. ** **	Defined Constants: **		MAXPARGS -- the maximum number of parameter type **			arguments to any standalone program. **		MAXFARGS -- the maximum number of flag type arg- **			uments to any standalong program (not inclu- **			ding flags in the users file, and the +-w **			and -u flags). ** **	Files: **		/etc/passwd -- to get the pathname for user "ingres". **		.../files/users -- to get all the per-user information, **			and to process the -u flag. ** **	Compilation Flags: **		xB_UNIX, xV6_UNIX -- see comments in aux.h ** **	Trace Flags: **		none */
end_comment

begin_define
define|#
directive|define
name|MAXFARGS
value|15
end_define

begin_comment
comment|/* maximum flag-type arguments */
end_comment

begin_define
define|#
directive|define
name|MAXPARGS
value|20
end_define

begin_comment
comment|/* maximum parameter-type args */
end_comment

begin_decl_stmt
name|char
modifier|*
name|Usercode
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the usercode of the effective user */
end_comment

begin_decl_stmt
name|char
modifier|*
name|Pathname
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* path of INGRES subtree */
end_comment

begin_decl_stmt
name|int
name|Status
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the user status of the real user */
end_comment

begin_decl_stmt
name|int
name|Rubignored
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* set if rubouts ignored */
end_comment

begin_comment
comment|/* (also in initproc for system processes) */
end_comment

begin_decl_stmt
name|int
name|Wait_action
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the action on the db_lock */
end_comment

begin_decl_stmt
name|char
modifier|*
name|Dbpath
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the pathname of the database */
end_comment

begin_decl_stmt
name|char
modifier|*
name|Flagvect
index|[
name|MAXFARGS
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the flags from argv */
end_comment

begin_decl_stmt
name|char
modifier|*
name|Parmvect
index|[
name|MAXPARGS
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the parameters from argv */
end_comment

begin_decl_stmt
name|int
name|Ing_uid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the user id of the INGRES user */
end_comment

begin_macro
name|initucode
argument_list|(
argument|argc
argument_list|,
argument|argv
argument_list|,
argument|dbflag
argument_list|,
argument|paramlist
argument_list|,
argument|waitmode
argument_list|)
end_macro

begin_decl_stmt
name|int
name|argc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|dbflag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|paramlist
index|[
literal|4
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|waitmode
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|q
decl_stmt|;
name|char
name|c
decl_stmt|;
name|FILE
modifier|*
name|iop
decl_stmt|;
specifier|static
name|char
name|sbuf
index|[
name|MAXLINE
operator|*
literal|2
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|sbufp
decl_stmt|;
name|char
name|buf
index|[
name|MAXLINE
operator|+
literal|1
index|]
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|npermit
decl_stmt|;
name|int
name|rtval
decl_stmt|;
name|char
modifier|*
name|field
index|[
name|UF_NFIELDS
index|]
decl_stmt|;
name|int
name|actualuid
decl_stmt|;
specifier|auto
name|int
name|uid
decl_stmt|;
specifier|auto
name|int
name|gid
decl_stmt|;
name|int
name|waitflag
decl_stmt|;
name|char
modifier|*
name|userflag
decl_stmt|;
name|struct
name|sgttyb
name|gttydummy
decl_stmt|;
name|int
name|fvi
decl_stmt|,
name|pvi
decl_stmt|;
name|char
modifier|*
modifier|*
name|avp
decl_stmt|;
name|char
name|usr_ovrd
index|[
literal|3
index|]
decl_stmt|;
specifier|static
name|int
name|reenter
decl_stmt|;
extern|extern		rubcatch(
block|)
end_block

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_decl_stmt
specifier|static
name|short
name|tvect
index|[
literal|100
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|nobuffer
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|xV7_UNIX
end_ifdef

begin_function_decl
specifier|extern
name|char
modifier|*
name|getenv
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
endif|xV7_UNIX
end_endif

begin_comment
comment|/* 	**  Set up interrupts. 	*/
end_comment

begin_expr_stmt
name|reenter
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|setexit
argument_list|()
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|reenter
operator|++
condition|)
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
end_if

begin_if
if|if
condition|(
name|signal
argument_list|(
literal|2
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
condition|)
name|signal
argument_list|(
literal|2
argument_list|,
name|rubcatch
argument_list|)
expr_stmt|;
end_if

begin_ifdef
ifdef|#
directive|ifdef
name|xV6_UNIX
end_ifdef

begin_for
for|for
control|(
name|avp
operator|=
name|argv
init|;
operator|*
name|avp
operator|!=
literal|0
operator|&&
operator|*
name|avp
operator|!=
operator|(
name|char
operator|*
operator|)
operator|-
literal|1
condition|;
name|avp
operator|++
control|)
continue|continue;
end_for

begin_expr_stmt
operator|*
name|avp
operator|=
name|NULL
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* 	**  Do basic initialization, such as setting trace flags. 	*/
end_comment

begin_expr_stmt
name|nobuffer
operator|=
name|tTrace
argument_list|(
name|argv
argument_list|,
literal|'T'
argument_list|,
name|tvect
argument_list|,
literal|100
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
operator|!
name|nobuffer
condition|)
name|set_so_buf
argument_list|()
expr_stmt|;
end_if

begin_expr_stmt
name|sbufp
operator|=
name|sbuf
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* 	**  Get pathname of INGRES subtree from /etc/passwd file 	**  entry for USERINGRES (presumably "ingres") and save it 	**  in 'Pathname'. 	** 	**  This algorithm suggested by Jim Popa. 	*/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|xV7_UNIX
end_ifdef

begin_expr_stmt
name|Pathname
operator|=
name|getenv
argument_list|(
literal|"INGPATH"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|Pathname
operator|==
name|NULL
condition|)
block|{
endif|#
directive|endif
endif|xV7_UNIX
if|if
condition|(
operator|(
name|iop
operator|=
name|fopen
argument_list|(
literal|"/etc/passwd"
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|syserr
argument_list|(
literal|"initucode: passwd"
argument_list|)
expr_stmt|;
do|do
block|{
if|if
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
name|MAXLINE
argument_list|,
name|iop
argument_list|)
operator|==
name|NULL
condition|)
name|syserr
argument_list|(
literal|"initucode: no INGRES"
argument_list|)
expr_stmt|;
comment|/* decode passwd entry */
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
name|buf
init|;
operator|*
name|p
operator|!=
literal|'\n'
operator|&&
operator|*
name|p
operator|!=
literal|'\0'
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|':'
condition|)
block|{
operator|*
name|p
operator|=
literal|0
expr_stmt|;
name|i
operator|++
expr_stmt|;
name|field
index|[
name|i
index|]
operator|=
name|p
operator|+
literal|1
expr_stmt|;
block|}
block|}
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
comment|/* check for enough fields for valid entry */
if|if
condition|(
name|i
operator|<
literal|3
condition|)
name|syserr
argument_list|(
literal|"initucode: passwd fmt %s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|sequal
argument_list|(
name|buf
argument_list|,
name|USERINGRES
argument_list|)
condition|)
do|;
comment|/* we now have the INGRES passwd file entry in 'buf' */
name|fclose
argument_list|(
name|iop
argument_list|)
expr_stmt|;
comment|/* copy pathname entry into 'Pathname' variable */
name|Pathname
operator|=
name|sbufp
expr_stmt|;
name|sbufp
operator|+=
name|smove
argument_list|(
name|field
index|[
name|i
operator|-
literal|1
index|]
argument_list|,
name|sbufp
argument_list|)
operator|+
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|PATHEXT
name|sbufp
operator|+=
name|smove
argument_list|(
name|PATHEXT
argument_list|,
name|sbufp
operator|-
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|PATHEXT
ifdef|#
directive|ifdef
name|xV7_UNIX
block|}
end_if

begin_endif
endif|#
directive|endif
endif|xV7_UNIX
end_endif

begin_comment
comment|/* create the INGRES user id */
end_comment

begin_if
if|if
condition|(
name|atoi
argument_list|(
name|p
operator|=
name|field
index|[
literal|2
index|]
argument_list|,
operator|&
name|Ing_uid
argument_list|)
operator|!=
literal|0
condition|)
name|syserr
argument_list|(
literal|"initucode: bad Ing_uid \"%s\""
argument_list|,
name|p
argument_list|)
expr_stmt|;
end_if

begin_ifdef
ifdef|#
directive|ifdef
name|xV6_UNIX
end_ifdef

begin_expr_stmt
name|Ing_uid
operator|&=
literal|0377
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|xB_UNIX
end_ifdef

begin_if
if|if
condition|(
name|atoi
argument_list|(
name|p
operator|=
name|field
index|[
literal|3
index|]
argument_list|,
operator|&
name|gid
argument_list|)
operator|!=
literal|0
condition|)
name|syserr
argument_list|(
literal|"initucode: bad Ing_gid %s"
argument_list|,
name|p
argument_list|)
expr_stmt|;
end_if

begin_expr_stmt
name|Ing_uid
operator|=
operator|(
name|Ing_uid
operator|&
literal|0377
operator|)
operator||
operator|(
operator|(
name|gid
operator|&
literal|0377
operator|)
operator|<<
literal|8
operator|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* 	**  Scan the argument vector.  The following flags are pulled 	**  out of the vector (and argc and argv are adjusted so it 	**  looks like they never existed): 	**	+w, -w -- (don't) wait for the database to be free. 	**	-uxxx -- run as user xxx.  If first character is a 	**	colon, the format must be '-u:xx' where 'xx' is the 	**	internal user code. 	*/
end_comment

begin_expr_stmt
name|avp
operator|=
name|argv
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|fvi
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|pvi
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|waitflag
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|userflag
operator|=
name|NULL
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|usr_ovrd
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_for
for|for
control|(
name|i
operator|=
name|argc
init|;
operator|--
name|i
operator|>
literal|0
condition|;
control|)
block|{
name|p
operator|=
operator|*
operator|++
name|avp
expr_stmt|;
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'+'
condition|)
block|{
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|'w'
condition|)
name|waitflag
operator|=
literal|1
expr_stmt|;
else|else
goto|goto
name|boring
goto|;
block|}
elseif|else
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
switch|switch
condition|(
name|p
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'w'
case|:
name|waitflag
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
if|if
condition|(
name|p
index|[
literal|2
index|]
operator|==
literal|':'
condition|)
block|{
if|if
condition|(
name|p
index|[
literal|3
index|]
operator|==
literal|0
operator|||
name|p
index|[
literal|4
index|]
operator|==
literal|0
operator|||
name|p
index|[
literal|5
index|]
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Bad flag %s\n"
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|smove
argument_list|(
operator|&
name|p
index|[
literal|3
index|]
argument_list|,
name|usr_ovrd
argument_list|)
expr_stmt|;
block|}
else|else
name|userflag
operator|=
operator|&
name|p
index|[
literal|2
index|]
expr_stmt|;
break|break;
default|default:
comment|/* not an interesting flag */
name|boring
label|:
if|if
condition|(
name|fvi
operator|>=
name|MAXFARGS
condition|)
block|{
name|printf
argument_list|(
literal|"Too many flags\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|Flagvect
index|[
name|fvi
operator|++
index|]
operator|=
name|p
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
comment|/* not a flag: save in Parmvect */
if|if
condition|(
name|pvi
operator|>=
name|MAXPARGS
condition|)
block|{
name|printf
argument_list|(
literal|"Too many parmameters\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|Parmvect
index|[
name|pvi
operator|++
index|]
operator|=
name|p
expr_stmt|;
block|}
block|}
end_for

begin_if
if|if
condition|(
name|pvi
operator|<=
literal|0
operator|&&
name|dbflag
condition|)
block|{
return|return
operator|(
literal|4
operator|)
return|;
comment|/* no database name specified */
block|}
end_if

begin_comment
comment|/* 	**  Scan the "users" file. 	*/
end_comment

begin_if
if|if
condition|(
operator|(
name|iop
operator|=
name|fopen
argument_list|(
name|ztack
argument_list|(
name|Pathname
argument_list|,
literal|"/files/users"
argument_list|)
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|syserr
argument_list|(
literal|"initucode: open error"
argument_list|)
expr_stmt|;
end_if

begin_comment
comment|/* get uid (out of loop) for test */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|xV6_UNIX
end_ifdef

begin_expr_stmt
name|actualuid
operator|=
name|getuid
argument_list|()
operator|&
literal|0377
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|xV6_UNIX
end_ifndef

begin_expr_stmt
name|actualuid
operator|=
name|getuid
argument_list|()
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* scan users file, one line at a time */
end_comment

begin_expr_stmt
name|rtval
operator|=
literal|3
expr_stmt|;
end_expr_stmt

begin_while
while|while
condition|(
operator|(
name|Usercode
operator|==
name|NULL
operator|||
name|userflag
operator|!=
name|NULL
operator|)
operator|&&
name|fgets
argument_list|(
name|buf
argument_list|,
name|MAXLINE
argument_list|,
name|iop
argument_list|)
operator|!=
name|NULL
condition|)
block|{
comment|/* decode users file entry */
name|i
operator|=
literal|0
expr_stmt|;
name|field
index|[
literal|0
index|]
operator|=
name|buf
expr_stmt|;
for|for
control|(
name|p
operator|=
name|buf
init|;
operator|*
name|p
operator|!=
literal|'\n'
operator|&&
operator|*
name|p
operator|!=
literal|'\0'
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|':'
condition|)
block|{
operator|*
name|p
operator|=
literal|0
expr_stmt|;
name|i
operator|++
expr_stmt|;
name|field
index|[
name|i
index|]
operator|=
name|p
operator|+
literal|1
expr_stmt|;
block|}
block|}
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
comment|/* check for correct number of fields */
if|if
condition|(
name|i
operator|!=
name|UF_NFIELDS
operator|-
literal|1
condition|)
name|syserr
argument_list|(
literal|"initucode: users fmt %s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
comment|/* 		**  Check to see if this entry is the override user. 		**  If so, save his user code in usr_ovrd. 		*/
if|if
condition|(
name|userflag
operator|!=
name|NULL
operator|&&
name|sequal
argument_list|(
name|userflag
argument_list|,
name|field
index|[
name|UF_NAME
index|]
argument_list|)
condition|)
block|{
name|smove
argument_list|(
name|field
index|[
name|UF_UCODE
index|]
argument_list|,
name|usr_ovrd
argument_list|)
expr_stmt|;
name|userflag
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* don't bother with this shit if not needed */
if|if
condition|(
name|Usercode
operator|!=
name|NULL
condition|)
continue|continue;
comment|/* 		**  Build the user id of this entry into 'uid' 		**  and see if it is this user. 		*/
if|if
condition|(
name|atoi
argument_list|(
name|p
operator|=
name|field
index|[
name|UF_UID
index|]
argument_list|,
operator|&
name|uid
argument_list|)
operator|!=
literal|0
condition|)
name|syserr
argument_list|(
literal|"initucode: users: bad UID %s"
argument_list|,
name|p
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|xB_UNIX
if|if
condition|(
name|atoi
argument_list|(
name|p
operator|=
name|field
index|[
name|UF_GID
index|]
argument_list|,
operator|&
name|gid
argument_list|)
operator|!=
literal|0
condition|)
name|syserr
argument_list|(
literal|"initucode: users: bad GID %s"
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|uid
operator|=
operator|(
name|uid
operator|&
literal|0377
operator|)
operator||
operator|(
operator|(
name|gid
operator|&
literal|0377
operator|)
operator|<<
literal|8
operator|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|xV6_UNIX
if|if
condition|(
operator|(
name|uid
operator|&
literal|0377
operator|)
operator|!=
name|actualuid
condition|)
continue|continue;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|xV6_UNIX
if|if
condition|(
name|uid
operator|!=
name|actualuid
condition|)
continue|continue;
endif|#
directive|endif
comment|/* 		**  We now have the real user entry. 		**	Fetch the usercode, the status bits, and other 		**	fields from the users file, and save them in 		**	a safe place (sbuf). 		*/
name|Usercode
operator|=
name|sbufp
expr_stmt|;
name|sbufp
operator|+=
name|smove
argument_list|(
name|field
index|[
name|UF_UCODE
index|]
argument_list|,
name|sbufp
argument_list|)
operator|+
literal|1
expr_stmt|;
name|Status
operator|=
name|oatoi
argument_list|(
name|field
index|[
name|UF_STAT
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|paramlist
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|paramlist
index|[
name|i
index|]
operator|=
name|sbufp
expr_stmt|;
name|sbufp
operator|+=
name|smove
argument_list|(
name|field
index|[
name|UF_FLAGS
operator|+
name|i
index|]
argument_list|,
name|sbufp
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
block|}
comment|/* validate access permission */
name|rtval
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|dbflag
operator|||
operator|(
name|Status
operator|&
name|U_SUPER
operator|)
operator|!=
literal|0
condition|)
continue|continue;
name|p
operator|=
name|field
index|[
name|UF_DBLIST
index|]
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|0
condition|)
continue|continue;
comment|/* select permission/no-permission */
name|npermit
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'-'
condition|)
block|{
name|p
operator|++
expr_stmt|;
name|npermit
operator|++
expr_stmt|;
block|}
comment|/* scan for database listed */
if|if
condition|(
operator|!
name|npermit
condition|)
name|rtval
operator|=
literal|2
expr_stmt|;
for|for
control|(
name|c
operator|=
operator|*
name|p
init|;
name|c
operator|!=
literal|0
condition|;
name|p
operator|=
name|q
operator|+
literal|1
control|)
block|{
for|for
control|(
name|q
operator|=
name|p
init|;
operator|*
name|q
operator|!=
literal|','
operator|&&
operator|*
name|q
operator|!=
literal|0
condition|;
name|q
operator|++
control|)
continue|continue;
name|c
operator|=
operator|*
name|q
expr_stmt|;
operator|*
name|q
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sequal
argument_list|(
name|Parmvect
index|[
literal|0
index|]
argument_list|,
name|p
argument_list|)
condition|)
block|{
name|rtval
operator|=
name|npermit
condition|?
literal|2
else|:
literal|0
expr_stmt|;
break|break;
block|}
block|}
block|}
end_while

begin_expr_stmt
name|fclose
argument_list|(
name|iop
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|rtval
operator|!=
literal|0
condition|)
return|return
operator|(
name|rtval
operator|)
return|;
end_if

begin_comment
comment|/* 	**  Check for existance of the database.  This is done by 	**	first building the pathname of the database into 	**	'Dbpath', and then reading the admin file (just 	**	the adhdr part). 	*/
end_comment

begin_if
if|if
condition|(
name|dbflag
condition|)
block|{
name|Dbpath
operator|=
name|sbufp
expr_stmt|;
switch|switch
condition|(
name|i
operator|=
name|initdbpath
argument_list|(
name|Parmvect
index|[
literal|0
index|]
argument_list|,
name|Dbpath
argument_list|,
name|TRUE
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
name|rtval
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|rtval
operator|=
literal|5
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|rtval
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|rtval
operator|=
literal|6
expr_stmt|;
break|break;
default|default:
name|syserr
argument_list|(
literal|"initucode: initdbpath %d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|sbufp
operator|+=
name|length
argument_list|(
name|Dbpath
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|rtval
operator|==
literal|0
operator|||
name|rtval
operator|==
literal|5
condition|)
block|{
name|i
operator|=
name|open
argument_list|(
name|ztack
argument_list|(
name|Dbpath
argument_list|,
literal|"/admin"
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|rtval
operator|+=
literal|1
expr_stmt|;
else|else
block|{
comment|/* open and check admin file */
name|checkadmin
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_if

begin_comment
comment|/* 	**  Check to see if the name on the -u flag is valid, and 	**	that this user is allowed to use it. 	*/
end_comment

begin_if
if|if
condition|(
name|userflag
operator|!=
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"Invalid user name %s\n"
argument_list|,
name|userflag
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_if

begin_if
if|if
condition|(
name|usr_ovrd
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|(
name|Status
operator|&
name|U_SUPER
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|dbflag
operator|||
operator|!
name|bequal
argument_list|(
name|Admin
operator|.
name|adhdr
operator|.
name|adowner
argument_list|,
name|Usercode
argument_list|,
literal|2
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"You may not use the -u flag\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|bmove
argument_list|(
name|usr_ovrd
argument_list|,
name|Usercode
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
end_if

begin_comment
comment|/* 	**  Process the +-w flag. 	**	First, determine the locking mode.  If +w, always 	**	wait; if -w, never wait; if unspecified, wait if in 	**	background, but print error and exit if running 	**	interactive. 	*/
end_comment

begin_if
if|if
condition|(
name|waitflag
operator|>
literal|0
operator|||
operator|(
name|waitflag
operator|==
literal|0
operator|&&
name|gtty
argument_list|(
literal|0
argument_list|,
operator|&
name|gttydummy
argument_list|)
operator|<
literal|0
operator|)
condition|)
name|Wait_action
operator|=
name|A_SLP
expr_stmt|;
else|else
name|Wait_action
operator|=
name|A_RTN
expr_stmt|;
end_if

begin_if
if|if
condition|(
name|dbflag
operator|&&
name|waitmode
operator|>=
literal|0
condition|)
name|db_lock
argument_list|(
name|waitmode
argument_list|)
expr_stmt|;
end_if

begin_comment
comment|/* 	**  Return authorization value. 	*/
end_comment

begin_return
return|return
operator|(
name|rtval
operator|)
return|;
end_return

begin_escape
unit|}
end_escape

begin_comment
comment|/* **  DB_LOCK -- lock database ** **	Locks the database.  Everyone should do this before using any **	database. ** **	Parameters: **		database -- the pathname of the database. **		mode -- M_EXCL -- get an exclusive lock. **			M_SHARE -- get a shared lock. ** **	Returns: **		none ** **	Side Effects: **		Alockdes is opened. */
end_comment

begin_decl_stmt
unit|struct
name|lockreq
name|Lock
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the database lock structure */
end_comment

begin_macro
name|db_lock
argument_list|(
argument|mode
argument_list|)
end_macro

begin_decl_stmt
name|int
name|mode
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
operator|(
name|Admin
operator|.
name|adhdr
operator|.
name|adflags
operator|&
name|A_DBCONCUR
operator|)
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|Alockdes
operator|<
literal|0
condition|)
name|Alockdes
operator|=
name|open
argument_list|(
literal|"/dev/lock"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|setdbl
argument_list|(
name|Wait_action
argument_list|,
name|mode
argument_list|)
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Database temporarily unavailable\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  INITDBPATH -- initialize the pathname of the database ** **	The pathname of a specified database is created.  Indirection **	via a file is supported, so that if the pathname is a file, **	the first line of the file is read and used as the pathname **	of the real database. ** **	Parameters: **		database -- the name of the database.  If NULL, **			the pathname of datadir is returned. **		dbbuf -- a buffer into which the pathname should **			be dumped. **		follow -- if set, follow the indirect chain of **			database pathnames. ** **	Returns: **		0 -- database exists in datadir **		1 -- database exists, but I followed a pointer. **		2 -- database doesn't exist in datadir. **		3 -- databae doesn't exist, but I followed a pointer. ** **	Side Effects: **		none. */
end_comment

begin_macro
name|initdbpath
argument_list|(
argument|database
argument_list|,
argument|dbpath
argument_list|,
argument|follow
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|database
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|dbpath
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|follow
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|stat
name|ibuf
decl_stmt|;
specifier|register
name|char
modifier|*
name|d
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|f
decl_stmt|;
specifier|register
name|int
name|phase
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|int
name|uid
decl_stmt|;
specifier|extern
name|char
modifier|*
name|index
parameter_list|()
function_decl|;
name|d
operator|=
name|dbpath
expr_stmt|;
if|if
condition|(
name|database
operator|==
name|NULL
condition|)
block|{
ifndef|#
directive|ifndef
name|xDBPATH
name|concat
argument_list|(
name|Pathname
argument_list|,
literal|"/data/base/"
argument_list|,
name|d
argument_list|)
expr_stmt|;
else|#
directive|else
name|smove
argument_list|(
name|xDBPATH
argument_list|,
name|d
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* get the basic pathname */
name|concat
argument_list|(
name|ztack
argument_list|(
name|Pathname
argument_list|,
literal|"/datadir/"
argument_list|)
argument_list|,
name|database
argument_list|,
name|d
argument_list|)
expr_stmt|;
comment|/* 	** Iterate looking for database. 	**	"Phase" is what we are trying: 	**	   -1 -- looking in datadir 	**	    0 -- looking in data/base 	**	    1 -- following indirect. 	*/
name|retval
operator|=
literal|2
expr_stmt|;
for|for
control|(
name|phase
operator|=
operator|-
literal|1
init|;
condition|;
control|)
block|{
comment|/* find out what sort of filesystem node this is */
if|if
condition|(
name|stat
argument_list|(
name|d
argument_list|,
operator|&
name|ibuf
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|phase
operator|<
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|xDBPATH
name|concat
argument_list|(
name|xDBPATH
argument_list|,
name|database
argument_list|,
name|d
argument_list|)
expr_stmt|;
else|#
directive|else
name|concat
argument_list|(
name|ztack
argument_list|(
name|Pathname
argument_list|,
literal|"/data/base/"
argument_list|)
argument_list|,
name|database
argument_list|,
name|d
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|phase
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
else|else
return|return
operator|(
name|retval
operator|)
return|;
block|}
comment|/* set up the lock structure for future use */
name|bmove
argument_list|(
operator|&
name|ibuf
argument_list|,
name|Lock
operator|.
name|dbnode
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|retval
operator|-=
literal|2
expr_stmt|;
if|if
condition|(
operator|(
name|ibuf
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|==
name|S_IFDIR
condition|)
return|return
operator|(
name|retval
operator|)
return|;
comment|/* if second time through, the database must be a directory */
if|if
condition|(
name|phase
operator|>
literal|0
condition|)
name|syserr
argument_list|(
literal|"initdbpath: not direc"
argument_list|)
expr_stmt|;
comment|/* if we shouldn't follow the chain, say it exists */
if|if
condition|(
operator|!
name|follow
condition|)
return|return
operator|(
literal|3
operator|)
return|;
comment|/* it's a file -- see if we can use it */
name|uid
operator|=
name|ibuf
operator|.
name|st_uid
expr_stmt|;
ifdef|#
directive|ifdef
name|xB_UNIX
name|uid
operator|=
operator|(
name|uid
operator|&
literal|0377
operator|)
operator||
operator|(
operator|(
name|ibuf
operator|.
name|st_gid
operator|&
literal|0377
operator|)
operator|<<
literal|8
operator|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|xV6_UNIX
name|uid
operator|&=
literal|0377
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|uid
operator|!=
name|Ing_uid
operator|||
operator|(
name|ibuf
operator|.
name|st_mode
operator|&
literal|0777
operator|)
operator|!=
literal|0600
condition|)
return|return
operator|(
literal|3
operator|)
return|;
name|f
operator|=
name|fopen
argument_list|(
name|d
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
name|syserr
argument_list|(
literal|"initdbpath: fopen"
argument_list|)
expr_stmt|;
comment|/* read the pathname of the database */
if|if
condition|(
name|fgets
argument_list|(
name|d
argument_list|,
name|MAXLINE
argument_list|,
name|f
argument_list|)
operator|==
name|NULL
operator|||
name|d
index|[
literal|0
index|]
operator|!=
literal|'/'
condition|)
name|syserr
argument_list|(
literal|"initdbpath: bad indirect"
argument_list|)
expr_stmt|;
operator|*
name|index
argument_list|(
name|d
argument_list|,
literal|'\n'
argument_list|)
operator|=
literal|'\0'
expr_stmt|;
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
comment|/* prepare for next iteration */
name|retval
operator|=
literal|3
expr_stmt|;
name|phase
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_block

end_unit

