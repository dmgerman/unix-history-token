begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|<ingres.h>
end_include

begin_include
include|#
directive|include
file|<aux.h>
end_include

begin_include
include|#
directive|include
file|<symbol.h>
end_include

begin_include
include|#
directive|include
file|<tree.h>
end_include

begin_include
include|#
directive|include
file|"parser.h"
end_include

begin_include
include|#
directive|include
file|<pv.h>
end_include

begin_include
include|#
directive|include
file|"scanner.h"
end_include

begin_include
include|#
directive|include
file|<sccs.h>
end_include

begin_macro
name|SCCSID
argument_list|(
argument|@(#)control.c
literal|7.1
literal|2
argument|/
literal|5
argument|/
literal|81
argument_list|)
end_macro

begin_comment
comment|/* **  CONTROL.C -- -- collection of control functions for the parser ** **	These routines administrate the operation of the parser for internal **	sequencing.  There are 2 pairs of routines, one pair for each **	quel statement, and one for each go-block, and there is one **	routine to finish retrieve statements. ** **	Defines: **		startgo		-- initialize for a go-block **		init_quelst	-- initialize for a quel statement **		endquelst	-- clean up after a quel statement **		endretrieve	-- clean up after a retrieve **		endgo		-- clean up after a go-block ** **	Trace Flags: **		control.c ~~ 48, 49 ** **	History: **		6 Jun 80 (jiw)		modified and redocumented for 6.3 **		15 Jan 79 (rick)	collected and documented more **		ancient history */
end_comment

begin_escape
end_escape

begin_comment
comment|/* ** INIT_QUELST -- set vbles for default mode before each quel statement ** **	Parameters: **		none ** **	Returns: **		nothing ** **	Trace Flags: **		init_quelst ~~ 48.0 */
end_comment

begin_function
name|int
name|init_quelst
parameter_list|()
block|{
specifier|extern
name|int
name|neederr
parameter_list|()
function_decl|;
extern|extern 		ack_err(
block|)
function|;
end_function

begin_decl_stmt
specifier|extern
name|int
name|Err_current
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|Patflag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|Pars
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|Lcase
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|Dcase
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|Agflag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|Opflag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|Resrng
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|Qlflag
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|xPTR3
end_ifdef

begin_expr_stmt
name|tTfp
argument_list|(
literal|48
argument_list|,
literal|0
argument_list|,
literal|"Init_quelst\n"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|Err_current
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* no error yet */
end_comment

begin_expr_stmt
name|Patflag
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* reset pattern matching flag */
end_comment

begin_expr_stmt
name|Pars
operator|=
literal|1
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* set scanner into "parser" mode */
end_comment

begin_expr_stmt
name|Lcase
operator|=
name|Dcase
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* set case mapping to default */
end_comment

begin_expr_stmt
name|Agflag
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* reset aggregate flag */
end_comment

begin_expr_stmt
name|Opflag
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* reset qmode flag */
end_comment

begin_expr_stmt
name|Resrng
operator|=
operator|-
literal|1
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* reset result relation slot */
end_comment

begin_expr_stmt
name|Qlflag
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* reset qualification flag */
end_comment

begin_expr_stmt
name|initp
argument_list|()
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* initialize parameter vector */
end_comment

begin_expr_stmt
name|init_qt
argument_list|()
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* assume we have qrytree */
end_comment

begin_expr_stmt
name|freesym
argument_list|()
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* free symbol table space */
end_comment

begin_expr_stmt
name|rngreset
argument_list|()
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* reset used bits in range tbl */
end_comment

begin_return
return|return
operator|(
literal|1
operator|)
return|;
end_return

begin_escape
unit|}
end_escape

begin_comment
comment|/* ** ENDQUELST -- finish command checking and processing for each quel statement ** **	Parameters: **		op -- the type of query to finish up ** **	Returns: **		nothing ** **	Trace Flags: **		endquelst ~~ 48.4, 48.5 */
end_comment

begin_expr_stmt
unit|int
name|endquelst
argument_list|(
name|op
argument_list|)
specifier|register
name|int
name|op
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|char
name|ibuf
index|[
literal|2
index|]
decl_stmt|;
comment|/* two char buffer for index keys */
specifier|extern
name|char
modifier|*
name|Indexspec
decl_stmt|;
specifier|extern
name|char
modifier|*
name|Indexname
decl_stmt|;
specifier|extern
name|int
name|Equel
decl_stmt|;
specifier|extern
name|int
name|Agflag
decl_stmt|;
specifier|extern
name|struct
name|lasttok
modifier|*
name|Lasttok
decl_stmt|;
specifier|extern
name|int
name|yyerrflag
decl_stmt|;
specifier|extern
name|int
name|Err_current
decl_stmt|;
specifier|extern
name|int
name|Ingerr
decl_stmt|;
specifier|extern
name|int
name|Err_fnd
decl_stmt|;
specifier|extern
name|DESC
name|Attdes
decl_stmt|;
specifier|extern
name|DESC
name|Reldesc
decl_stmt|;
specifier|extern
name|int
name|Rsdmno
decl_stmt|;
specifier|extern
name|PARRNG
name|Parrng
index|[]
decl_stmt|;
specifier|extern
name|int
name|Resrng
decl_stmt|;
specifier|extern
name|int
name|printtrail
parameter_list|()
function_decl|;
ifdef|#
directive|ifdef
name|xPTR3
if|if
condition|(
name|tTf
argument_list|(
literal|48
argument_list|,
literal|4
argument_list|)
condition|)
name|prvect
argument_list|(
literal|0
argument_list|,
name|getp
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* check next token for GOVAL if the next token has been read */
if|if
condition|(
operator|!
name|Err_current
operator|&&
operator|!
name|yyerrflag
condition|)
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|mdSAVE
case|:
case|case
name|mdCOPY
case|:
case|case
name|mdCREATE
case|:
ifdef|#
directive|ifdef
name|DISTRIB
case|case
name|mdDCREATE
case|:
endif|#
directive|endif
case|case
name|mdINDEX
case|:
case|case
name|mdRANGE
case|:
break|break;
default|default:
comment|/* has vble ending and therefore must detect valid end of command */
ifdef|#
directive|ifdef
name|xPTR3
name|tTfp
argument_list|(
literal|48
argument_list|,
literal|5
argument_list|,
literal|"before NXTCMDERR\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|Lastok
operator|.
name|tokop
operator|!=
name|GOVAL
condition|)
comment|/* next token not start of command */
name|par_error
argument_list|(
name|NXTCMDERR
argument_list|,
name|WARN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|Agflag
operator|>=
name|MAXAGG
condition|)
comment|/* too many aggregates */
name|par_error
argument_list|(
name|AGGXTRA
argument_list|,
name|WARN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* command ok so far, finish up */
if|if
condition|(
operator|!
name|Err_fnd
condition|)
block|{
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|mdINDEX
case|:
if|if
condition|(
name|tTf
argument_list|(
literal|48
argument_list|,
literal|5
argument_list|)
condition|)
name|printf
argument_list|(
literal|"mdINDEX\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|call
argument_list|(
name|op
argument_list|,
name|NULL
argument_list|)
operator|<
literal|0
condition|)
name|ack_err
argument_list|()
expr_stmt|;
if|if
condition|(
name|tTf
argument_list|(
literal|48
argument_list|,
literal|5
argument_list|)
condition|)
name|printf
argument_list|(
literal|"after call to call\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|Ingerr
condition|)
block|{
if|if
condition|(
name|tTf
argument_list|(
literal|48
argument_list|,
literal|5
argument_list|)
condition|)
name|printf
argument_list|(
literal|"Ingerr = %d\n"
argument_list|,
name|Ingerr
argument_list|)
expr_stmt|;
name|endgo
argument_list|()
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|Indexspec
condition|)
block|{
name|initp
argument_list|()
expr_stmt|;
name|setp
argument_list|(
name|PV_STR
argument_list|,
name|Indexname
argument_list|)
expr_stmt|;
comment|/* type */
name|setp
argument_list|(
name|PV_STR
argument_list|,
name|Indexspec
argument_list|)
expr_stmt|;
comment|/* specs */
name|setp
argument_list|(
name|PV_STR
argument_list|,
literal|"num"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|Rsdmno
condition|;
name|i
operator|++
control|)
block|{
name|ibuf
index|[
literal|0
index|]
operator|=
name|i
operator|&
name|I1MASK
expr_stmt|;
name|ibuf
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|setp
argument_list|(
name|PV_STR
argument_list|,
name|ibuf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|call
argument_list|(
name|mdMODIFY
argument_list|,
name|NULL
argument_list|)
operator|<
literal|0
condition|)
name|ack_err
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|mdRETR
case|:
case|case
name|mdRET_UNI
case|:
case|case
name|mdVIEW
case|:
if|if
condition|(
name|Resrng
operator|>=
literal|0
condition|)
comment|/* implies result reln */
block|{
if|if
condition|(
name|calln
argument_list|(
name|mdCREATE
argument_list|,
name|NULL
argument_list|)
operator|<
literal|0
condition|)
name|ack_err
argument_list|()
expr_stmt|;
name|cleanrel
argument_list|(
operator|&
name|Attdes
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|openr
argument_list|(
operator|&
name|Reldesc
argument_list|,
operator|-
literal|1
argument_list|,
name|trim_relname
argument_list|(
name|Parrng
index|[
name|Resrng
index|]
operator|.
name|vardesc
operator|.
name|reldum
operator|.
name|relid
argument_list|)
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|syserr
argument_list|(
literal|"result reln: error in openr '%d'"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|rngent
argument_list|(
name|R_INTERNAL
argument_list|,
literal|""
argument_list|,
operator|&
name|Reldesc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|Equel
condition|)
comment|/* need to print header */
name|header
argument_list|(
name|getp
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|Ingerr
condition|)
block|{
comment|/* 				** might be nice to back out the create already done 				** by this point so that the user doesn't need to 				*/
name|resetp
argument_list|()
expr_stmt|;
name|endgo
argument_list|()
expr_stmt|;
comment|/* abort rest of go-block */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|initp
argument_list|()
expr_stmt|;
comment|/* fall through */
case|case
name|mdAPP
case|:
case|case
name|mdDEL
case|:
case|case
name|mdREPL
case|:
if|if
condition|(
name|op
operator|!=
name|mdVIEW
condition|)
block|{
name|call_tree
argument_list|(
name|op
argument_list|,
name|mdQRY
argument_list|,
name|ack_err
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|==
name|mdRETR
operator|||
name|op
operator|==
name|mdRET_UNI
condition|)
name|endretrieve
argument_list|(
name|ack_err
argument_list|)
expr_stmt|;
break|break;
block|}
ifdef|#
directive|ifdef
name|DISTRIB
case|case
name|mdDISTRIB
case|:
name|op
operator|=
name|mdVIEW
expr_stmt|;
endif|#
directive|endif
comment|/* else, do VIEW */
name|setp
argument_list|(
name|PV_STR
argument_list|,
name|trim_relname
argument_list|(
name|Parrng
index|[
name|Resrng
index|]
operator|.
name|vardesc
operator|.
name|reldum
operator|.
name|relid
argument_list|)
argument_list|)
expr_stmt|;
case|case
name|mdINTEG
case|:
case|case
name|mdPROT
case|:
name|call_tree
argument_list|(
name|op
argument_list|,
name|op
argument_list|,
name|ack_err
argument_list|)
expr_stmt|;
break|break;
case|case
name|mdCREATE
case|:
ifdef|#
directive|ifdef
name|DISTRIB
case|case
name|mdDCREATE
case|:
endif|#
directive|endif
case|case
name|mdDESTROY
case|:
case|case
name|mdMODIFY
case|:
ifdef|#
directive|ifdef
name|V6POINT3COMPAT
comment|/* in this case, if an error in the dbu's will not */
comment|/* cause other processing to halt */
name|call
argument_list|(
name|op
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|call
argument_list|(
name|op
argument_list|,
name|NULL
argument_list|)
operator|<
literal|0
condition|)
name|ack_err
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|cleanrel
argument_list|(
operator|&
name|Attdes
argument_list|)
expr_stmt|;
break|break;
case|case
name|mdCOPY
case|:
case|case
name|mdHELP
case|:
case|case
name|mdPRINT
case|:
case|case
name|mdSAVE
case|:
case|case
name|mdDISPLAY
case|:
case|case
name|mdREMQM
case|:
ifdef|#
directive|ifdef
name|V6POINT3COMPAT
name|call
argument_list|(
name|op
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|call
argument_list|(
name|op
argument_list|,
name|NULL
argument_list|)
operator|<
literal|0
condition|)
name|ack_err
argument_list|()
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|mdRANGE
case|:
break|break;
default|default:
name|syserr
argument_list|(
literal|"Endquelst: bad op %d"
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* refresh relstat bits if necessary */
name|rngfresh
argument_list|(
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|init_quelst
argument_list|()
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* ** STARTGO -- do whatever needs doing to set up a go-block ** **	Parameters: **		none ** **	Returns: **		nothing ** **	Trace Flags: **		startgo ~~ 48.8 */
end_comment

begin_macro
name|startgo
argument_list|()
end_macro

begin_block
block|{
specifier|extern
name|int
name|Err_fnd
decl_stmt|;
specifier|extern
name|int
name|Ing_err
decl_stmt|;
specifier|extern
name|int
name|yyline
decl_stmt|;
ifdef|#
directive|ifdef
name|xPTR3
name|tTfp
argument_list|(
literal|48
argument_list|,
literal|8
argument_list|,
literal|"startgo\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* initialize for go-block */
name|get_scan
argument_list|(
name|PRIME
argument_list|)
expr_stmt|;
comment|/* prime the scanner input */
name|Err_fnd
operator|=
literal|0
expr_stmt|;
comment|/* no errors have been found yet */
name|Ingerr
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|init_quelst
argument_list|()
operator|<
literal|0
condition|)
comment|/* most other init's are done for each statement */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|yyline
operator|=
literal|1
expr_stmt|;
comment|/* reset line counter */
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  ENDGO -- do whatever needs doing to clean up after a go block ** **	Parameters: **		none ** **	Returns: **		nothing ** **	Trace Flags: **		endgo ~~ 48.12 */
end_comment

begin_macro
name|endgo
argument_list|()
end_macro

begin_block
block|{
ifdef|#
directive|ifdef
name|xPTR3
name|tTfp
argument_list|(
literal|48
argument_list|,
literal|12
argument_list|,
literal|"endgo\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|Equel
operator|&&
name|Err_fnd
operator|>
literal|1
condition|)
name|error
argument_list|(
name|SUMMARY
argument_list|,
name|iocv
argument_list|(
name|Err_fnd
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|get_scan
argument_list|(
name|SYNC
argument_list|)
expr_stmt|;
name|resetp
argument_list|()
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  ENDRETRIEVE -- finishes any sort of retrieve ** **	Endretrieve either creates a result relation or prints a trailer ** **	Parameters: **		err_fcn -- function to pass to call ** **	Returns: **		nothing ** **	Trace Flags: **		endretrieve ~~ 48.14	 ** **	History: **		June '80 -- (jiw) broken off from call_tree */
end_comment

begin_function_decl
name|endretrieve
function_decl|(
name|err_fcn
function_decl|)
name|int
argument_list|(
argument|*err_fcn
argument_list|)
parameter_list|()
function_decl|;
end_function_decl

begin_block
block|{
specifier|extern
name|int
name|Resrng
decl_stmt|;
specifier|extern
name|char
modifier|*
name|Relspec
decl_stmt|;
specifier|extern
name|PARRNG
name|Parrng
index|[]
decl_stmt|;
specifier|extern
name|int
name|Equel
decl_stmt|;
if|if
condition|(
name|Resrng
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|Relspec
condition|)
block|{
name|initp
argument_list|()
expr_stmt|;
name|setp
argument_list|(
name|PV_STR
argument_list|,
name|trim_relname
argument_list|(
name|Parrng
index|[
name|Resrng
index|]
operator|.
name|vardesc
operator|.
name|reldum
operator|.
name|relid
argument_list|)
argument_list|)
expr_stmt|;
name|setp
argument_list|(
name|PV_STR
argument_list|,
name|Relspec
argument_list|)
expr_stmt|;
if|if
condition|(
name|call
argument_list|(
name|mdMODIFY
argument_list|,
name|err_fcn
argument_list|)
operator|<
literal|0
condition|)
call|(
modifier|*
name|err_fcn
call|)
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|Equel
condition|)
name|printeh
argument_list|()
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_macro
name|printtrail
argument_list|()
end_macro

begin_block
block|{
specifier|extern
name|int
name|Equel
decl_stmt|;
if|if
condition|(
operator|!
name|Equel
condition|)
name|printeh
argument_list|()
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_block

end_unit

