begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|<ingres.h>
end_include

begin_include
include|#
directive|include
file|<aux.h>
end_include

begin_include
include|#
directive|include
file|<tree.h>
end_include

begin_include
include|#
directive|include
file|<symbol.h>
end_include

begin_include
include|#
directive|include
file|"parser.h"
end_include

begin_include
include|#
directive|include
file|<sccs.h>
end_include

begin_macro
name|SCCSID
argument_list|(
argument|@(#)format.c
literal|7.1
literal|2
argument|/
literal|5
argument|/
literal|81
argument_list|)
end_macro

begin_comment
comment|/* **  FORMAT **	routine to compute the format of the result relation attributes **	it is called after ATTLOOKUP so the tuple defining the current **	attribute is already available. **	if the element is a function of more than one attribute, the result **	domain format is computed by the following rules: **		- no fcns allowed on character attributes **		- fcn of integer attribs is an integer fcn with **		  length = MAX(length of all attributes) **		- fcn of floating point attribs is a floating point **		  fcn with length = MIN(length of all attribs) **		- fcn of integer and floating attributes is a **		  floating fcn with length = MIN(length of all floating **		  attributes) ** **	Trace Flags: **		Format ~~ 52.0, 52.1 */
end_comment

begin_macro
name|format
argument_list|(
argument|result1
argument_list|)
end_macro

begin_decl_stmt
name|QTREE
modifier|*
name|result1
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
name|rfrmt
decl_stmt|;
specifier|register
name|char
name|rfrml
decl_stmt|;
specifier|register
name|QTREE
modifier|*
name|result
decl_stmt|;
name|struct
name|constop
modifier|*
name|cpt
decl_stmt|;
specifier|extern
name|struct
name|out_arg
name|Out_arg
decl_stmt|;
specifier|extern
name|struct
name|constop
name|Coptab
index|[]
decl_stmt|;
specifier|extern
name|char
name|Trfrml
decl_stmt|;
specifier|extern
name|char
name|Trfrmt
decl_stmt|;
specifier|extern
name|int
name|Qlflag
decl_stmt|;
ifdef|#
directive|ifdef
name|xPTR2
name|tTfp
argument_list|(
literal|52
argument_list|,
literal|0
argument_list|,
literal|"format:.\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|result
operator|=
name|result1
expr_stmt|;
switch|switch
condition|(
name|result
operator|->
name|sym
operator|.
name|type
condition|)
block|{
case|case
name|VAR
case|:
name|rfrmt
operator|=
name|result
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_var
operator|.
name|varfrmt
expr_stmt|;
name|rfrml
operator|=
name|result
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_var
operator|.
name|varfrml
expr_stmt|;
break|break;
case|case
name|AOP
case|:
switch|switch
condition|(
name|result
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_op
operator|.
name|opno
condition|)
block|{
case|case
name|opAVG
case|:
case|case
name|opAVGU
case|:
name|rfrmt
operator|=
name|FLOAT
expr_stmt|;
name|rfrml
operator|=
literal|8
expr_stmt|;
if|if
condition|(
name|result
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_op
operator|.
name|agfrmt
operator|==
name|CHAR
condition|)
comment|/* character domain not allowed in these aggs */
name|par_error
argument_list|(
name|AVGTYPE
argument_list|,
name|WARN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|opCOUNT
case|:
case|case
name|opCOUNTU
case|:
name|rfrmt
operator|=
name|INT
expr_stmt|;
name|rfrml
operator|=
literal|4
expr_stmt|;
break|break;
case|case
name|opANY
case|:
name|rfrmt
operator|=
name|INT
expr_stmt|;
name|rfrml
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|opSUM
case|:
case|case
name|opSUMU
case|:
name|rfrmt
operator|=
name|result
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_op
operator|.
name|agfrmt
expr_stmt|;
name|rfrml
operator|=
name|result
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_op
operator|.
name|agfrml
expr_stmt|;
if|if
condition|(
name|rfrmt
operator|==
name|CHAR
condition|)
comment|/* no char domains for these aggs */
name|par_error
argument_list|(
name|SUMTYPE
argument_list|,
name|WARN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
default|default:
name|rfrmt
operator|=
name|result
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_op
operator|.
name|agfrmt
expr_stmt|;
name|rfrml
operator|=
name|result
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_op
operator|.
name|agfrml
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|AGHEAD
case|:
comment|/* 		** can get format info from the AOP node because 		** it already has format info computed 		*/
if|if
condition|(
name|result
operator|->
name|left
operator|->
name|sym
operator|.
name|type
operator|==
name|AOP
condition|)
block|{
comment|/* no by-list */
name|rfrmt
operator|=
name|result
operator|->
name|left
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_op
operator|.
name|opfrmt
expr_stmt|;
name|rfrml
operator|=
name|result
operator|->
name|left
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_op
operator|.
name|opfrml
expr_stmt|;
block|}
else|else
block|{
comment|/* skip over by-list */
name|rfrmt
operator|=
name|result
operator|->
name|left
operator|->
name|right
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_resdom
operator|.
name|resfrmt
expr_stmt|;
name|rfrml
operator|=
name|result
operator|->
name|left
operator|->
name|right
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_resdom
operator|.
name|resfrml
expr_stmt|;
block|}
break|break;
case|case
name|RESDOM
case|:
name|format
argument_list|(
name|result
operator|->
name|right
argument_list|)
expr_stmt|;
return|return;
case|case
name|INT
case|:
case|case
name|FLOAT
case|:
case|case
name|CHAR
case|:
name|rfrmt
operator|=
name|result
operator|->
name|sym
operator|.
name|type
expr_stmt|;
name|rfrml
operator|=
name|result
operator|->
name|sym
operator|.
name|len
expr_stmt|;
break|break;
case|case
name|COP
case|:
for|for
control|(
name|cpt
operator|=
name|Coptab
init|;
name|cpt
operator|->
name|copname
condition|;
name|cpt
operator|++
control|)
block|{
if|if
condition|(
name|result
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_op
operator|.
name|opno
operator|==
name|cpt
operator|->
name|copnum
condition|)
block|{
name|rfrmt
operator|=
name|cpt
operator|->
name|coptype
expr_stmt|;
name|rfrml
operator|=
name|cpt
operator|->
name|coplen
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|cpt
operator|->
name|copname
condition|)
name|syserr
argument_list|(
literal|"bad cop in format(%d)"
argument_list|,
name|result
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_op
operator|.
name|opno
argument_list|)
expr_stmt|;
break|break;
case|case
name|UOP
case|:
switch|switch
condition|(
name|result
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_op
operator|.
name|opno
condition|)
block|{
case|case
name|opATAN
case|:
case|case
name|opCOS
case|:
ifdef|#
directive|ifdef
name|xV6_UNIX
case|case
name|opGAMMA
case|:
endif|#
directive|endif
case|case
name|opLOG
case|:
case|case
name|opSIN
case|:
case|case
name|opSQRT
case|:
case|case
name|opEXP
case|:
name|format
argument_list|(
name|result
operator|->
name|left
argument_list|)
expr_stmt|;
if|if
condition|(
name|Trfrmt
operator|==
name|CHAR
condition|)
comment|/* 				** no character expr in FOP 				** if more ops are added, must change error message				*/
name|par_error
argument_list|(
name|FOPTYPE
argument_list|,
name|WARN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
case|case
name|opFLOAT8
case|:
comment|/* float8 is type conversion and can have char values */
name|rfrmt
operator|=
name|FLOAT
expr_stmt|;
name|rfrml
operator|=
literal|8
expr_stmt|;
break|break;
case|case
name|opFLOAT4
case|:
name|rfrmt
operator|=
name|FLOAT
expr_stmt|;
name|rfrml
operator|=
literal|4
expr_stmt|;
break|break;
case|case
name|opINT1
case|:
name|rfrmt
operator|=
name|INT
expr_stmt|;
name|rfrml
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|opINT2
case|:
name|rfrmt
operator|=
name|INT
expr_stmt|;
name|rfrml
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|opINT4
case|:
name|rfrmt
operator|=
name|INT
expr_stmt|;
name|rfrml
operator|=
literal|4
expr_stmt|;
break|break;
case|case
name|opASCII
case|:
name|format
argument_list|(
name|result
operator|->
name|left
argument_list|)
expr_stmt|;
name|rfrmt
operator|=
name|CHAR
expr_stmt|;
name|rfrml
operator|=
name|Trfrml
expr_stmt|;
if|if
condition|(
name|Trfrmt
operator|==
name|INT
condition|)
block|{
if|if
condition|(
name|Trfrml
operator|==
literal|2
condition|)
name|rfrml
operator|=
name|Out_arg
operator|.
name|i2width
expr_stmt|;
elseif|else
if|if
condition|(
name|Trfrml
operator|==
literal|4
condition|)
name|rfrml
operator|=
name|Out_arg
operator|.
name|i4width
expr_stmt|;
elseif|else
if|if
condition|(
name|Trfrml
operator|==
literal|1
condition|)
name|rfrml
operator|=
name|Out_arg
operator|.
name|i1width
expr_stmt|;
else|else
name|syserr
argument_list|(
literal|"bad length %d for INT"
argument_list|,
name|Trfrml
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|Trfrmt
operator|==
name|FLOAT
condition|)
block|{
if|if
condition|(
name|Trfrml
operator|==
literal|8
condition|)
name|rfrml
operator|=
name|Out_arg
operator|.
name|f8width
expr_stmt|;
elseif|else
if|if
condition|(
name|Trfrml
operator|==
literal|4
condition|)
name|rfrml
operator|=
name|Out_arg
operator|.
name|f4width
expr_stmt|;
else|else
name|syserr
argument_list|(
literal|"bad length %d for FLOAT"
argument_list|,
name|Trfrml
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|Trfrmt
operator|==
name|CHAR
condition|)
break|break;
name|syserr
argument_list|(
literal|"bad frmt in opASCII %d"
argument_list|,
name|Trfrmt
argument_list|)
expr_stmt|;
case|case
name|opNOT
case|:
if|if
condition|(
operator|!
name|Qlflag
condition|)
name|syserr
argument_list|(
literal|"opNOT in targ list"
argument_list|)
expr_stmt|;
return|return;
case|case
name|opMINUS
case|:
case|case
name|opPLUS
case|:
name|format
argument_list|(
name|result
operator|->
name|right
argument_list|)
expr_stmt|;
if|if
condition|(
name|Trfrmt
operator|==
name|CHAR
condition|)
comment|/* no chars for these unary ops */
name|par_error
argument_list|(
name|UOPTYPE
argument_list|,
name|WARN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
case|case
name|opABS
case|:
name|format
argument_list|(
name|result
operator|->
name|left
argument_list|)
expr_stmt|;
if|if
condition|(
name|Trfrmt
operator|==
name|CHAR
condition|)
comment|/* no char values in fcn */
name|par_error
argument_list|(
name|FOPTYPE
argument_list|,
name|WARN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
default|default:
name|syserr
argument_list|(
literal|"bad UOP in format %d"
argument_list|,
name|result
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_op
operator|.
name|opno
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|BOP
case|:
switch|switch
condition|(
name|result
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_op
operator|.
name|opno
condition|)
block|{
case|case
name|opEQ
case|:
case|case
name|opNE
case|:
case|case
name|opLT
case|:
case|case
name|opLE
case|:
case|case
name|opGT
case|:
case|case
name|opGE
case|:
if|if
condition|(
operator|!
name|Qlflag
condition|)
name|syserr
argument_list|(
literal|"LBOP in targ list"
argument_list|)
expr_stmt|;
name|format
argument_list|(
name|result
operator|->
name|right
argument_list|)
expr_stmt|;
name|rfrmt
operator|=
name|Trfrmt
expr_stmt|;
name|format
argument_list|(
name|result
operator|->
name|left
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rfrmt
operator|==
name|CHAR
operator|)
operator|!=
operator|(
name|Trfrmt
operator|==
name|CHAR
operator|)
condition|)
comment|/* type conflict on relational operator */
name|par_error
argument_list|(
name|RELTYPE
argument_list|,
name|WARN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
case|case
name|opADD
case|:
case|case
name|opSUB
case|:
case|case
name|opMUL
case|:
case|case
name|opDIV
case|:
name|format
argument_list|(
name|result
operator|->
name|left
argument_list|)
expr_stmt|;
name|rfrmt
operator|=
name|Trfrmt
expr_stmt|;
name|rfrml
operator|=
name|Trfrml
expr_stmt|;
name|format
argument_list|(
name|result
operator|->
name|right
argument_list|)
expr_stmt|;
if|if
condition|(
name|rfrmt
operator|==
name|CHAR
operator|||
name|Trfrmt
operator|==
name|CHAR
condition|)
comment|/* no opns on characters allowed */
name|par_error
argument_list|(
name|NUMTYPE
argument_list|,
name|WARN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rfrmt
operator|==
name|FLOAT
operator|||
name|Trfrmt
operator|==
name|FLOAT
condition|)
block|{
if|if
condition|(
name|rfrmt
operator|==
name|FLOAT
operator|&&
name|Trfrmt
operator|==
name|FLOAT
condition|)
block|{
if|if
condition|(
name|Trfrml
operator|<
name|rfrml
condition|)
name|rfrml
operator|=
name|Trfrml
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Trfrmt
operator|==
name|FLOAT
condition|)
name|rfrml
operator|=
name|Trfrml
expr_stmt|;
name|rfrmt
operator|=
name|FLOAT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Trfrml
operator|>
name|rfrml
condition|)
name|rfrml
operator|=
name|Trfrml
expr_stmt|;
break|break;
case|case
name|opMOD
case|:
name|format
argument_list|(
name|result
operator|->
name|left
argument_list|)
expr_stmt|;
name|rfrmt
operator|=
name|Trfrmt
expr_stmt|;
name|rfrml
operator|=
name|Trfrml
expr_stmt|;
name|format
argument_list|(
name|result
operator|->
name|right
argument_list|)
expr_stmt|;
if|if
condition|(
name|rfrmt
operator|!=
name|INT
operator|||
name|Trfrmt
operator|!=
name|INT
condition|)
comment|/* mod operator not defined */
name|par_error
argument_list|(
name|MODTYPE
argument_list|,
name|WARN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|Trfrml
operator|>
name|rfrml
condition|)
name|rfrml
operator|=
name|Trfrml
expr_stmt|;
break|break;
case|case
name|opPOW
case|:
name|format
argument_list|(
name|result
operator|->
name|right
argument_list|)
expr_stmt|;
name|rfrmt
operator|=
name|Trfrmt
expr_stmt|;
name|rfrml
operator|=
name|Trfrml
expr_stmt|;
name|format
argument_list|(
name|result
operator|->
name|left
argument_list|)
expr_stmt|;
if|if
condition|(
name|rfrmt
operator|==
name|CHAR
operator|||
name|Trfrmt
operator|==
name|CHAR
condition|)
comment|/* no char values for pow */
name|par_error
argument_list|(
name|NUMTYPE
argument_list|,
name|WARN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rfrmt
operator|==
name|FLOAT
operator|&&
name|rfrml
operator|==
literal|4
operator|)
operator|||
operator|(
name|Trfrmt
operator|==
name|FLOAT
operator|&&
name|Trfrml
operator|==
literal|4
operator|)
condition|)
block|{
name|rfrmt
operator|=
name|FLOAT
expr_stmt|;
name|rfrml
operator|=
literal|4
expr_stmt|;
block|}
else|else
block|{
name|rfrmt
operator|=
name|FLOAT
expr_stmt|;
name|rfrml
operator|=
literal|8
expr_stmt|;
block|}
break|break;
case|case
name|opCONCAT
case|:
name|format
argument_list|(
name|result
operator|->
name|left
argument_list|)
expr_stmt|;
name|rfrmt
operator|=
name|Trfrmt
expr_stmt|;
name|rfrml
operator|=
name|Trfrml
expr_stmt|;
name|format
argument_list|(
name|result
operator|->
name|right
argument_list|)
expr_stmt|;
if|if
condition|(
name|rfrmt
operator|!=
name|CHAR
operator|||
name|Trfrmt
operator|!=
name|CHAR
condition|)
comment|/* only character domains allowed */
name|par_error
argument_list|(
name|CONCATTYPE
argument_list|,
name|WARN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rfrml
operator|+=
name|Trfrml
expr_stmt|;
break|break;
default|default:
name|syserr
argument_list|(
literal|"bad BOP in format %d"
argument_list|,
name|result
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_op
operator|.
name|opno
argument_list|)
expr_stmt|;
block|}
block|}
name|Trfrmt
operator|=
name|rfrmt
expr_stmt|;
name|Trfrml
operator|=
name|rfrml
expr_stmt|;
ifdef|#
directive|ifdef
name|xPTR2
name|tTfp
argument_list|(
literal|52
argument_list|,
literal|2
argument_list|,
literal|"format>>: Trfrmt = %d, Trfrml = %d.\n"
argument_list|,
name|Trfrmt
argument_list|,
name|Trfrml
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_block

end_unit

