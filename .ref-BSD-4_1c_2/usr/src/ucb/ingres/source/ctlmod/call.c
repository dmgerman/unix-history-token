begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|"ctlmod.h"
end_include

begin_include
include|#
directive|include
file|"pipes.h"
end_include

begin_include
include|#
directive|include
file|<resp.h>
end_include

begin_include
include|#
directive|include
file|<ingres.h>
end_include

begin_include
include|#
directive|include
file|<aux.h>
end_include

begin_include
include|#
directive|include
file|<tree.h>
end_include

begin_include
include|#
directive|include
file|<sccs.h>
end_include

begin_macro
name|SCCSID
argument_list|(
argument|@(#)call.c
literal|7.1
literal|2
argument|/
literal|5
argument|/
literal|81
argument_list|)
end_macro

begin_comment
comment|/* **  CALL -- Call a state with return. ** **	The state indicated by the indicated entry point is **	called.  Control will return to the current state. ** **	If errflg is non-NULL, it is the address of a function **	which is willing to handle error messages.  If it is **	NULL, the parent of this module (and so forth) will **	handle the error message. ** **	To call a module, the user should call 'initp' to **	initialize a context in which the called module will **	be executed.  Parameters should then be initialized, **	and then the module should be called.  For instance: **		initp(); **		init_qt(qmode);   [only if we have a qtree parameter] **		setp(PV_QTREE, qt, 0); **		setp(PV_INT, ISAM, 0); **		setp(PV_TUPLE, tup, tupsiz); **		call(mdCREATE, catcherr); ** **		Alternatively, the 'call' can be replaced with: **		calln(mdCREATE, catcherr); **		 [save the return value if desired -- not in Qbuf!] **		resetp(); ** **	Parameters: **		entpt -- the entry point; indicates the starting **			state.  If zero, this is an error block. **		errfn -- the address of an error function; **			NULL indicates to pass errors to the **			parent's error handling function. ** **	Returns: **		The return value of the final called state. ** **	Side Effects: **		Sets 'Resp' to be the response vector for the **			final called function. ** **	Trace Flags: **		5 */
end_comment

begin_macro
name|call
argument_list|(
argument|entpt
argument_list|,
argument|errfn
argument_list|)
end_macro

begin_decl_stmt
name|int
name|entpt
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
function_decl|(
modifier|*
name|errfn
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_block
block|{
name|calln
argument_list|(
name|entpt
argument_list|,
name|errfn
argument_list|)
expr_stmt|;
name|resetp
argument_list|()
expr_stmt|;
return|return
operator|(
name|Resp
operator|.
name|resp_resp
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  CALLN -- just like a call, but keep the context around ** **	Parameters: **		(see call) ** **	Returns: **		(see call) ** **	Side Effects: **		(see call) */
end_comment

begin_macro
name|calln
argument_list|(
argument|entpt
argument_list|,
argument|errfn
argument_list|)
end_macro

begin_decl_stmt
name|int
name|entpt
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
function_decl|(
modifier|*
name|errfn
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_block
block|{
name|pb_t
name|pb
decl_stmt|;
ifdef|#
directive|ifdef
name|xMONITOR
specifier|extern
name|struct
name|monitor
name|CmMonBuf
decl_stmt|;
specifier|extern
name|struct
name|monitor
name|MonBuf
index|[]
decl_stmt|;
name|struct
name|monitor
modifier|*
name|savemon
decl_stmt|;
name|struct
name|monitor
name|mon
decl_stmt|;
specifier|extern
name|struct
name|monitor
modifier|*
name|markperf
parameter_list|()
function_decl|;
endif|#
directive|endif
endif|MONITOR
ifdef|#
directive|ifdef
name|xCTR1
if|if
condition|(
name|tTf
argument_list|(
literal|5
argument_list|,
literal|0
argument_list|)
condition|)
name|lprintf
argument_list|(
literal|"call: %d\n"
argument_list|,
name|entpt
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|xMONITOR
name|savemon
operator|=
name|markperf
argument_list|(
operator|&
name|CmMonBuf
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|xMONITOR
comment|/* 	**  Select the starting state. 	*/
if|if
condition|(
name|entpt
operator|>=
name|CM_MAXST
operator|||
name|entpt
operator|<
literal|0
condition|)
name|syserr
argument_list|(
literal|"call: entpt %d"
argument_list|,
name|entpt
argument_list|)
expr_stmt|;
comment|/* 	**  Do final setup on context. 	**	Set up the pipe buffer to use in this call. 	**	Flag the end of the parmvect. 	**	Save the error function address. 	**	Save the monitor struct address.  This monitor struct 	**		will save the collective results of this 	**		module& all children. 	*/
name|pb_prime
argument_list|(
operator|&
name|pb
argument_list|,
name|PB_REG
argument_list|)
expr_stmt|;
name|call_setup
argument_list|(
operator|&
name|pb
argument_list|,
name|entpt
argument_list|,
name|errfn
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|xMONITOR
name|Ctx
operator|.
name|ctx_mon
operator|=
operator|&
name|mon
expr_stmt|;
name|clrmem
argument_list|(
operator|&
name|mon
argument_list|,
sizeof|sizeof
name|mon
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|xMONITOR
comment|/* 	**  Do the sequence. 	*/
ifdef|#
directive|ifdef
name|xCTR1
if|if
condition|(
name|tTf
argument_list|(
literal|5
argument_list|,
literal|2
argument_list|)
condition|)
name|lprintf
argument_list|(
literal|"call: ENT %d cmark %d pmark %d\n"
argument_list|,
name|pb
operator|.
name|pb_st
argument_list|,
name|Ctx
operator|.
name|ctx_cmark
argument_list|,
name|Ctx
operator|.
name|ctx_pmark
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|Ctx
operator|.
name|ctx_new
operator|=
name|FALSE
expr_stmt|;
name|do_seq
argument_list|(
operator|&
name|pb
argument_list|)
expr_stmt|;
name|Ctx
operator|.
name|ctx_new
operator|=
name|TRUE
expr_stmt|;
ifdef|#
directive|ifdef
name|xMONITOR
name|markperf
argument_list|(
name|savemon
argument_list|)
expr_stmt|;
name|Resp
operator|.
name|resp_time
operator|=
name|mon
operator|.
name|mon_utime
operator|+
name|mon
operator|.
name|mon_stime
expr_stmt|;
endif|#
directive|endif
endif|xMONITOR
ifdef|#
directive|ifdef
name|xCTR1
if|if
condition|(
name|tTf
argument_list|(
literal|5
argument_list|,
literal|3
argument_list|)
condition|)
block|{
name|lprintf
argument_list|(
literal|"call: EXIT entpt %d st %d\n"
argument_list|,
name|entpt
argument_list|,
name|pb
operator|.
name|pb_st
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tresp %7d\ttime %7ld\ttups %6ld\n"
argument_list|,
name|Resp
operator|.
name|resp_resp
argument_list|,
name|Resp
operator|.
name|resp_time
argument_list|,
name|Resp
operator|.
name|resp_tups
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tpread %6ld\tpwrit %6ld\n"
argument_list|,
name|Resp
operator|.
name|resp_pread
argument_list|,
name|Resp
operator|.
name|resp_pwrit
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 	**  Return the result of the final function in the chain. 	*/
return|return
operator|(
name|Resp
operator|.
name|resp_resp
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  CALL_SETUP -- Do final setup for call ** **	This routine just does the final setup before the main **	part of a call.  It is broken off here because it is **	also used by 'error'. ** **	Parameters: **		ppb -- pointer to a pipe block to use for this **			call. **		state -- state we are going to enter. **		errfn -- a pointer to the error function to use **			for this call -- NULL if we want to send **			to our parent. ** **	Returns: **		none. ** **	Side Effects: **		Does setup on *ppb, Ctx, and Resp. ** **	Called By: **		call **		error ** **	Trace Flags: **		none. */
end_comment

begin_expr_stmt
name|call_setup
argument_list|(
name|ppb
argument_list|,
name|state
argument_list|,
name|errfn
argument_list|)
specifier|register
name|pb_t
operator|*
name|ppb
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|state
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
function_decl|(
modifier|*
name|errfn
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_block
block|{
ifdef|#
directive|ifdef
name|xCTR1
if|if
condition|(
name|tTf
argument_list|(
literal|5
argument_list|,
literal|5
argument_list|)
condition|)
block|{
name|lprintf
argument_list|(
literal|"call_setup: st %d errfn %x\n"
argument_list|,
name|state
argument_list|,
name|errfn
argument_list|)
expr_stmt|;
name|prvect
argument_list|(
name|Ctx
operator|.
name|ctx_pc
argument_list|,
name|Ctx
operator|.
name|ctx_pv
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|ppb
operator|->
name|pb_st
operator|=
name|state
expr_stmt|;
name|ppb
operator|->
name|pb_resp
operator|=
name|Cm
operator|.
name|cm_myproc
expr_stmt|;
name|Ctx
operator|.
name|ctx_pv
index|[
name|Ctx
operator|.
name|ctx_pc
index|]
operator|.
name|pv_type
operator|=
name|PV_EOF
expr_stmt|;
name|Ctx
operator|.
name|ctx_pv
index|[
name|Ctx
operator|.
name|ctx_pc
index|]
operator|.
name|pv_val
operator|.
name|pv_str
operator|=
name|NULL
expr_stmt|;
name|Ctx
operator|.
name|ctx_ppb
operator|=
name|ppb
expr_stmt|;
name|Ctx
operator|.
name|ctx_errfn
operator|=
name|errfn
expr_stmt|;
name|Ctx
operator|.
name|ctx_init
operator|=
name|FALSE
expr_stmt|;
comment|/* 	Resp.resp_rval.pv_type = PV_EOF; */
block|}
end_block

end_unit

