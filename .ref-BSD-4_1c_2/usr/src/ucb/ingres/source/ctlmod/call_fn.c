begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|"ctlmod.h"
end_include

begin_include
include|#
directive|include
file|<resp.h>
end_include

begin_include
include|#
directive|include
file|<sccs.h>
end_include

begin_macro
name|SCCSID
argument_list|(
argument|@(#)call_fn.c
literal|7.1
literal|2
argument|/
literal|5
argument|/
literal|81
argument_list|)
end_macro

begin_comment
comment|/* **  CALL_FN -- call a local function ** **	This routine, given a pointer to a local function descriptor, **	calls the local function. ** **	Parameters: **		fno -- function definition vector number. **		pc -- the parameter count **		pv -- the parameter vector, gets passed to the **			function. ** **	Returns: **		none ** **	Side Effects: **		Sets 'Resp' to the response vector for this function. **		The old 'Resp' is completely obliterated. ** **	Trace Flags: **		3 */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|xMONITOR
end_ifdef

begin_decl_stmt
name|struct
name|monitor
name|MonBuf
index|[
name|CM_MAXST
index|]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|xMONITOR
end_endif

begin_macro
name|call_fn
argument_list|(
argument|fno
argument_list|,
argument|pc
argument_list|,
argument|pv
argument_list|)
end_macro

begin_decl_stmt
name|int
name|fno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|pc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|PARM
modifier|*
modifier|*
name|pv
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|fn_def
modifier|*
name|f
decl_stmt|;
specifier|register
name|char
modifier|*
name|gp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|xMONITOR
specifier|extern
name|struct
name|monitor
name|CmMonBuf
decl_stmt|;
name|struct
name|monitor
name|mon
decl_stmt|;
name|struct
name|monitor
modifier|*
name|savemon
decl_stmt|;
specifier|extern
name|char
modifier|*
name|cvt_time
parameter_list|()
function_decl|;
endif|#
directive|endif
specifier|extern
name|char
modifier|*
name|Proc_name
decl_stmt|;
name|short
modifier|*
name|tvect
decl_stmt|;
name|char
modifier|*
name|oldname
decl_stmt|;
specifier|extern
name|short
modifier|*
name|tT
decl_stmt|;
specifier|extern
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
name|f
operator|=
name|FuncVect
index|[
name|fno
index|]
expr_stmt|;
if|if
condition|(
name|fno
operator|>
name|NumFunc
operator|||
name|f
operator|->
name|fn_fn
operator|==
name|NULL
operator|||
name|fno
operator|<
literal|0
condition|)
name|syserr
argument_list|(
literal|"call_fn: undef fn %d"
argument_list|,
name|fno
argument_list|)
expr_stmt|;
name|Ctx
operator|.
name|ctx_fn
operator|=
name|f
expr_stmt|;
ifdef|#
directive|ifdef
name|xCTR1
if|if
condition|(
name|tTf
argument_list|(
literal|3
argument_list|,
literal|0
argument_list|)
condition|)
name|lprintf
argument_list|(
literal|"call_fn: fn %d (%s)\n"
argument_list|,
name|fno
argument_list|,
name|f
operator|->
name|fn_name
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	**  Save function globals. 	**	If the function we want to call is already active, 	**	and if it has a global data area, allocate space 	**	and save that area. 	*/
if|if
condition|(
name|f
operator|->
name|fn_active
operator|>
literal|0
operator|&&
name|f
operator|->
name|fn_gptr
operator|!=
name|NULL
condition|)
block|{
comment|/* save globals */
name|gp
operator|=
name|malloc
argument_list|(
name|f
operator|->
name|fn_gsize
argument_list|)
expr_stmt|;
name|bmove
argument_list|(
name|f
operator|->
name|fn_gptr
argument_list|,
name|gp
argument_list|,
name|f
operator|->
name|fn_gsize
argument_list|)
expr_stmt|;
name|Ctx
operator|.
name|ctx_glob
operator|=
name|gp
expr_stmt|;
block|}
else|else
name|Ctx
operator|.
name|ctx_glob
operator|=
name|gp
operator|=
name|NULL
expr_stmt|;
comment|/* 	**  Clear the response vector to a known state and call 	**  the function. 	*/
name|oldname
operator|=
name|Proc_name
expr_stmt|;
name|Ctx
operator|.
name|ctx_name
operator|=
name|Proc_name
operator|=
name|f
operator|->
name|fn_name
expr_stmt|;
name|tvect
operator|=
name|tT
expr_stmt|;
name|Ctx
operator|.
name|ctx_tvect
operator|=
name|tT
operator|=
name|f
operator|->
name|fn_tvect
expr_stmt|;
name|clrmem
argument_list|(
operator|&
name|Resp
argument_list|,
sizeof|sizeof
name|Resp
argument_list|)
expr_stmt|;
name|Resp
operator|.
name|resp_tups
operator|=
operator|-
literal|1
expr_stmt|;
name|markopen
argument_list|(
operator|&
name|Ctx
operator|.
name|ctx_ofiles
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|xCTR2
if|if
condition|(
name|tTf
argument_list|(
literal|3
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|lprintf
argument_list|(
literal|"call_fn: calling %s\n"
argument_list|,
name|Proc_name
argument_list|)
expr_stmt|;
name|prvect
argument_list|(
name|pc
argument_list|,
name|pv
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|xCTR3
if|if
condition|(
name|tTf
argument_list|(
literal|3
argument_list|,
literal|2
argument_list|)
condition|)
block|{
name|lprintf
argument_list|(
literal|"call_fn: Ctx.ctx_ppb "
argument_list|)
expr_stmt|;
name|pb_dump
argument_list|(
name|Ctx
operator|.
name|ctx_ppb
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|xCTR3
ifdef|#
directive|ifdef
name|xMONITOR
name|savemon
operator|=
name|Ctx
operator|.
name|ctx_mon
expr_stmt|;
name|Ctx
operator|.
name|ctx_mon
operator|=
operator|&
name|mon
expr_stmt|;
name|clrmem
argument_list|(
operator|&
name|mon
argument_list|,
sizeof|sizeof
name|mon
argument_list|)
expr_stmt|;
name|markperf
argument_list|(
operator|&
name|mon
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|xMONITOR
name|i
operator|=
call|(
modifier|*
name|f
operator|->
name|fn_fn
call|)
argument_list|(
name|pc
argument_list|,
name|pv
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|xMONITOR
name|markperf
argument_list|(
operator|&
name|CmMonBuf
argument_list|)
expr_stmt|;
name|Ctx
operator|.
name|ctx_mon
operator|=
name|savemon
expr_stmt|;
if|if
condition|(
name|savemon
operator|!=
name|NULL
condition|)
name|add_mon
argument_list|(
operator|&
name|mon
argument_list|,
name|savemon
argument_list|)
expr_stmt|;
name|add_mon
argument_list|(
operator|&
name|mon
argument_list|,
operator|&
name|MonBuf
index|[
name|Ctx
operator|.
name|ctx_ppb
operator|->
name|pb_st
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|xMONITOR
ifdef|#
directive|ifdef
name|xCTR1
if|if
condition|(
name|tTf
argument_list|(
literal|3
argument_list|,
literal|3
argument_list|)
condition|)
name|lprintf
argument_list|(
literal|"call_fn: returns %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|xMONITOR
if|if
condition|(
name|tTf
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
name|printf
argument_list|(
literal|"CPU time for %s = %s sec\n"
argument_list|,
name|Proc_name
argument_list|,
name|cvt_time
argument_list|(
name|mon
operator|.
name|mon_utime
operator|+
name|mon
operator|.
name|mon_stime
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|xMONITOR
name|Resp
operator|.
name|resp_resp
operator|=
name|i
expr_stmt|;
name|closeall
argument_list|(
name|TRUE
argument_list|,
name|Ctx
operator|.
name|ctx_ofiles
argument_list|)
expr_stmt|;
comment|/* 	**  Restore old global memory, if there was any. 	*/
if|if
condition|(
name|gp
operator|!=
name|NULL
condition|)
block|{
name|bmove
argument_list|(
name|gp
argument_list|,
name|f
operator|->
name|fn_gptr
argument_list|,
name|f
operator|->
name|fn_gsize
argument_list|)
expr_stmt|;
name|Ctx
operator|.
name|ctx_glob
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|gp
argument_list|)
expr_stmt|;
block|}
name|Ctx
operator|.
name|ctx_name
operator|=
name|Proc_name
operator|=
name|oldname
expr_stmt|;
name|Ctx
operator|.
name|ctx_tvect
operator|=
name|tT
operator|=
name|tvect
expr_stmt|;
block|}
end_block

end_unit

