begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ingres.h>
end_include

begin_include
include|#
directive|include
file|<aux.h>
end_include

begin_include
include|#
directive|include
file|<catalog.h>
end_include

begin_include
include|#
directive|include
file|<access.h>
end_include

begin_include
include|#
directive|include
file|<batch.h>
end_include

begin_include
include|#
directive|include
file|<opsys.h>
end_include

begin_include
include|#
directive|include
file|<lock.h>
end_include

begin_include
include|#
directive|include
file|<symbol.h>
end_include

begin_include
include|#
directive|include
file|<resp.h>
end_include

begin_include
include|#
directive|include
file|<dir.h>
end_include

begin_include
include|#
directive|include
file|<sccs.h>
end_include

begin_macro
name|SCCSID
argument_list|(
argument|@(#)restore.c
literal|7.2
literal|11
argument|/
literal|5
argument|/
literal|82
argument_list|)
end_macro

begin_comment
comment|/* ** INGRES crash recovery processor **	to recover a database you must be the dba or the ingres superuser **	RESTORE attempts to complete updates from batch files left in a **	database.  After finishing all the batch files it calls PURGE. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|PURGE
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|xV7_UNIX
end_ifdef

begin_define
define|#
directive|define
name|PURGE
value|"purge"
end_define

begin_else
else|#
directive|else
else|xV7_UNIX
end_else

begin_define
define|#
directive|define
name|PURGE
value|"/usr/bin/purge"
end_define

begin_endif
endif|#
directive|endif
endif|xV7_UNIX
end_endif

begin_endif
endif|#
directive|endif
endif|PURGE
end_endif

begin_comment
comment|/* first file to close on error */
end_comment

begin_define
define|#
directive|define
name|CLOSEFILES
value|3
end_define

begin_decl_stmt
specifier|extern
name|int
name|Status
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|Usercode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|Utemp
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|Fileset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|Berror
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* batch error */
end_comment

begin_decl_stmt
name|char
name|Error
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
name|Ask
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
name|Superuser
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
name|All
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
name|Qrymod
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|Direc
init|=
name|CLOSEFILES
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|Wait_action
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|tTvect
index|[
literal|100
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|tTdbu
index|[
literal|100
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|resp
name|Resp
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|direc
block|{
name|int
name|inumber
decl_stmt|;
name|char
name|fname
index|[
literal|15
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
specifier|register
name|int
name|fd
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|dbname
decl_stmt|;
specifier|extern
name|char
modifier|*
name|Proc_name
decl_stmt|;
specifier|auto
name|int
name|stat
decl_stmt|;
specifier|extern
function_decl|(
modifier|*
name|ExitFn
function_decl|)
parameter_list|()
function_decl|;
extern|extern          rubproc(
block|)
operator|,
function|exit
parameter_list|()
function|;
end_function

begin_decl_stmt
name|char
modifier|*
name|nargv
index|[
literal|20
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|avp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|fvp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|Flagvect
index|[]
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|char
modifier|*
name|getnxtdb
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|lookucode
parameter_list|()
function_decl|;
end_function_decl

begin_expr_stmt
name|Proc_name
operator|=
literal|"RESTORE"
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* check param list */
end_comment

begin_expr_stmt
name|argv
index|[
name|argc
index|]
operator|=
name|NULL
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|xTTR1
end_ifdef

begin_expr_stmt
name|tTrace
argument_list|(
name|argv
argument_list|,
literal|'T'
argument_list|,
name|tTvect
argument_list|,
literal|100
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|tTrace
argument_list|(
name|argv
argument_list|,
literal|'Z'
argument_list|,
name|tTdbu
argument_list|,
literal|100
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|initialize
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* do it to it */
end_comment

begin_expr_stmt
name|ExitFn
operator|=
name|rubproc
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|signal
argument_list|(
literal|3
argument_list|,
name|exit
argument_list|)
expr_stmt|;
end_expr_stmt

begin_while
while|while
condition|(
name|dbname
operator|=
name|getnxtdb
argument_list|()
condition|)
block|{
name|Berror
operator|=
name|Error
operator|=
literal|0
expr_stmt|;
comment|/* first restart point for this database */
name|setexit
argument_list|()
expr_stmt|;
if|if
condition|(
name|Error
condition|)
comment|/* if set, will cause skip to next database */
continue|continue;
name|printf
argument_list|(
literal|"\nRestoring database: %s\t"
argument_list|,
name|dbname
argument_list|)
expr_stmt|;
name|acc_init
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"owner: %s\n"
argument_list|,
name|lookucode
argument_list|(
name|Admin
operator|.
name|adhdr
operator|.
name|adowner
argument_list|)
argument_list|)
expr_stmt|;
comment|/* set exclusive lock on data base */
name|db_lock
argument_list|(
name|M_EXCL
argument_list|)
expr_stmt|;
name|restore
argument_list|()
expr_stmt|;
comment|/* recover batch update and modify files */
name|printf
argument_list|(
literal|"\tRecovery of batch files complete.\n"
argument_list|)
expr_stmt|;
comment|/* 		** second restart point for this database 		**	the batch files are completed and now the system 		**	relations need checking 		*/
name|setexit
argument_list|()
expr_stmt|;
if|if
condition|(
name|Error
condition|)
comment|/* again, may cause skipping to next database */
continue|continue;
name|printf
argument_list|(
literal|"\tChecking system relations\n"
argument_list|)
expr_stmt|;
comment|/* 		** check the relation relation 		**	this will mean checking for file existence, 		**	and whether the relstat bits are supported by 		**	the information in the other catalogs. 		*/
name|checkrel
argument_list|()
expr_stmt|;
comment|/* 		** check the attribute relation 		**	for each tuple in the attribute relation, there must 		**	be a tuple in the relation relation. 		**	the indexes relation doesn't need to be reverse checked 		**	into the relation relation since the order things are 		**	handled else where in the system is in the correct 		**	order.  All the other catalogs need to be reverse checked. 		*/
name|checkatts
argument_list|()
expr_stmt|;
comment|/* only check the qrymod catalogs if qrymod is turned on */
if|if
condition|(
name|Qrymod
condition|)
block|{
comment|/* check the protect relation */
name|checkprotect
argument_list|()
expr_stmt|;
comment|/* check the integrities relation */
name|checkinteg
argument_list|()
expr_stmt|;
comment|/* 			** check the tree relation 			** must be done last since it depends upon 			** a state of the system relations provided 			** by the other check... routines. 			*/
name|checktree
argument_list|()
expr_stmt|;
block|}
comment|/* finished, close up the database and go on to the next */
name|closecatalog
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
name|unldb
argument_list|()
expr_stmt|;
name|acc_close
argument_list|()
expr_stmt|;
comment|/* call PURGE if no errors */
if|if
condition|(
operator|!
name|Berror
operator|&&
operator|!
name|Error
condition|)
block|{
name|printf
argument_list|(
literal|"\tCalling purge: "
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|fork
argument_list|()
operator|)
operator|==
operator|-
literal|1
condition|)
name|printf
argument_list|(
literal|"Can't fork\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|i
condition|)
block|{
name|avp
operator|=
name|nargv
expr_stmt|;
operator|*
name|avp
operator|++
operator|=
literal|"Purge"
expr_stmt|;
for|for
control|(
name|fvp
operator|=
name|Flagvect
init|;
operator|*
name|fvp
operator|!=
name|NULL
condition|;
control|)
operator|*
name|avp
operator|++
operator|=
operator|*
name|fvp
operator|++
expr_stmt|;
operator|*
name|avp
operator|++
operator|=
name|dbname
expr_stmt|;
operator|*
name|avp
operator|++
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|xTTR2
if|if
condition|(
name|tTf
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
condition|)
for|for
control|(
name|avp
operator|=
name|nargv
operator|,
name|i
operator|=
literal|0
init|;
operator|*
name|avp
operator|!=
name|NULL
condition|;
name|avp
operator|++
operator|,
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"%d %s\n"
argument_list|,
name|i
argument_list|,
operator|*
name|avp
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|3
init|;
name|i
operator|<=
name|NOFILE
condition|;
name|i
operator|++
control|)
name|close
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|execv
argument_list|(
name|ztack
argument_list|(
name|Pathname
argument_list|,
literal|"/bin/purge"
argument_list|)
argument_list|,
name|nargv
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|xV7_UNIX
name|execvp
argument_list|(
name|PURGE
argument_list|,
name|nargv
argument_list|)
expr_stmt|;
else|#
directive|else
else|xV7_UNIX
name|execv
argument_list|(
name|PURGE
argument_list|,
name|nargv
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|xV7_UNIX
name|printf
argument_list|(
literal|"Cannot exec %s\n"
argument_list|,
name|PURGE
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|wait
argument_list|(
operator|&
name|stat
argument_list|)
expr_stmt|;
block|}
block|}
end_while

begin_escape
unit|}
end_escape

begin_comment
comment|/* ** RESTORE -- find the batch files and process them */
end_comment

begin_expr_stmt
unit|restore
operator|(
operator|)
block|{
name|DESC
name|descr
block|;
ifdef|#
directive|ifdef
name|DIRBLKSIZ
specifier|register
name|DIR
operator|*
name|dirp
block|;
specifier|register
expr|struct
name|direct
operator|*
name|dp
block|;
else|#
directive|else
else|DIRBLKSIZ
block|struct
name|direc
name|dir
block|;
specifier|register
expr|struct
name|direc
operator|*
name|d
block|;
specifier|register
name|int
name|dfd
block|;
endif|#
directive|endif
endif|DIRBLKSIZ
specifier|register
name|int
name|i
block|;
specifier|extern
name|char
operator|*
name|Fileset
block|;
specifier|extern
name|uperr
argument_list|()
block|,
call|(
modifier|*
name|ExitFn
call|)
argument_list|()
block|;
name|int
argument_list|(
operator|*
name|tmpfn
argument_list|)
argument_list|()
block|;
name|char
operator|*
name|lookucode
argument_list|()
block|;
ifdef|#
directive|ifdef
name|DIRBLKSIZ
if|if
condition|(
operator|(
name|dirp
operator|=
name|opendir
argument_list|(
literal|"."
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|syserr
argument_list|(
literal|"Can't open data base directory"
argument_list|)
expr_stmt|;
else|#
directive|else
else|DIRBLKSIZ
name|d
operator|=
operator|&
name|dir
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
operator|(
name|dfd
operator|=
name|open
argument_list|(
literal|"."
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|syserr
argument_list|(
literal|"cannot open database directory"
argument_list|)
expr_stmt|;
end_if

begin_expr_stmt
name|d
operator|->
name|fname
index|[
literal|14
index|]
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
endif|DIRBLKSIZ
end_endif

begin_expr_stmt
name|bmove
argument_list|(
name|Usercode
argument_list|,
name|Utemp
argument_list|,
literal|2
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|Batch_recovery
operator|=
literal|1
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|tmpfn
operator|=
name|ExitFn
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|ExitFn
operator|=
name|uperr
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* restart point */
end_comment

begin_expr_stmt
name|setexit
argument_list|()
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|DIRBLKSIZ
end_ifdef

begin_for
for|for
control|(
name|dp
operator|=
name|readdir
argument_list|(
name|dirp
argument_list|)
init|;
name|dp
operator|!=
name|NULL
condition|;
name|dp
operator|=
name|readdir
argument_list|(
name|dirp
argument_list|)
control|)
else|#
directive|else
else|DIRBLKSIZ
while|while
condition|(
name|read
argument_list|(
name|dfd
argument_list|,
name|d
argument_list|,
literal|16
argument_list|)
operator|==
literal|16
condition|)
endif|#
directive|endif
endif|DIRBLKSIZ
block|{
ifdef|#
directive|ifdef
name|DIRBLKSIZ
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"."
argument_list|,
name|dp
operator|->
name|d_name
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
literal|".."
argument_list|,
name|dp
operator|->
name|d_name
argument_list|)
condition|)
else|#
directive|else
else|DIRBLKSIZ
if|if
condition|(
name|d
operator|->
name|inumber
operator|==
literal|0
condition|)
endif|#
directive|endif
endif|DIRBLKSIZ
continue|continue;
ifdef|#
directive|ifdef
name|DIRBLKSIZ
if|if
condition|(
name|bequal
argument_list|(
literal|"_SYSbatch"
argument_list|,
name|dp
operator|->
name|d_name
argument_list|,
literal|9
argument_list|)
condition|)
else|#
directive|else
else|DIRBLKSIZ
if|if
condition|(
name|bequal
argument_list|(
literal|"_SYSbatch"
argument_list|,
name|d
operator|->
name|fname
argument_list|,
literal|9
argument_list|)
condition|)
endif|#
directive|endif
endif|DIRBLKSIZ
block|{
ifdef|#
directive|ifdef
name|DIRBLKSIZ
name|Fileset
operator|=
operator|&
name|dp
operator|->
name|d_name
index|[
literal|9
index|]
expr_stmt|;
else|#
directive|else
else|DIRBLKSIZ
name|Fileset
operator|=
operator|&
name|d
operator|->
name|fname
index|[
literal|9
index|]
expr_stmt|;
endif|#
directive|endif
endif|DIRBLKSIZ
name|Batch_fp
operator|=
name|open
argument_list|(
name|batchname
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|Batch_cnt
operator|=
name|BATCHSIZE
expr_stmt|;
name|getbatch
argument_list|(
operator|&
name|Batchhd
argument_list|,
sizeof|sizeof
argument_list|(
name|Batchhd
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DIRBLKSIZ
name|printf
argument_list|(
literal|"\tFound batch file:  %s\n"
argument_list|,
name|dp
operator|->
name|d_name
argument_list|)
expr_stmt|;
else|#
directive|else
else|DIRBLKSIZ
name|printf
argument_list|(
literal|"\tFound batch file:  %s\n"
argument_list|,
name|d
operator|->
name|fname
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DIRBLKSIZ
name|printf
argument_list|(
literal|"\tRelation: %s\tUser: %s\n"
argument_list|,
name|Batchhd
operator|.
name|rel_name
argument_list|,
name|lookucode
argument_list|(
name|Batchhd
operator|.
name|userid
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|Batch_fp
argument_list|)
expr_stmt|;
name|bmove
argument_list|(
name|Batchhd
operator|.
name|userid
argument_list|,
name|Usercode
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|ask
argument_list|(
literal|"\tUpdate? "
argument_list|)
condition|)
name|update
argument_list|()
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DIRBLKSIZ
if|if
condition|(
name|bequal
argument_list|(
name|MODBATCH
argument_list|,
name|dp
operator|->
name|d_name
argument_list|,
sizeof|sizeof
argument_list|(
name|MODBATCH
argument_list|)
operator|-
literal|1
argument_list|)
condition|)
block|{
name|Fileset
operator|=
operator|&
name|dp
operator|->
name|d_name
index|[
sizeof|sizeof
argument_list|(
name|MODBATCH
argument_list|)
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|Batch_fp
operator|=
name|open
argument_list|(
name|dp
operator|->
name|d_name
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|syserr
argument_list|(
literal|"Can't open %s"
argument_list|,
name|dp
operator|->
name|d_name
argument_list|)
expr_stmt|;
else|#
directive|else
else|DIRBLKSIZ
if|if
condition|(
name|bequal
argument_list|(
name|MODBATCH
argument_list|,
name|d
operator|->
name|fname
argument_list|,
sizeof|sizeof
argument_list|(
name|MODBATCH
argument_list|)
operator|-
literal|1
argument_list|)
condition|)
block|{
name|Fileset
operator|=
operator|&
name|d
operator|->
name|fname
index|[
sizeof|sizeof
argument_list|(
name|MODBATCH
argument_list|)
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|Batch_fp
operator|=
name|open
argument_list|(
name|d
operator|->
name|fname
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|syserr
argument_list|(
literal|"Can't open %s"
argument_list|,
name|d
operator|->
name|fname
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DIRBLKSIZ
name|Batch_cnt
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|getbatch
argument_list|(
operator|&
name|descr
argument_list|,
sizeof|sizeof
argument_list|(
name|descr
argument_list|)
argument_list|)
operator|)
operator|!=
sizeof|sizeof
argument_list|(
name|descr
argument_list|)
condition|)
name|syserr
argument_list|(
literal|" cant read %d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tFound incomplete modify of %.12s, user = %s\n"
argument_list|,
name|descr
operator|.
name|reldum
operator|.
name|relid
argument_list|,
name|lookucode
argument_list|(
name|descr
operator|.
name|reldum
operator|.
name|relowner
argument_list|)
argument_list|)
expr_stmt|;
name|bmove
argument_list|(
name|descr
operator|.
name|reldum
operator|.
name|relowner
argument_list|,
name|Usercode
argument_list|,
sizeof|sizeof
argument_list|(
name|descr
operator|.
name|reldum
operator|.
name|relowner
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|Batch_fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ask
argument_list|(
literal|"\tComplete? "
argument_list|)
condition|)
name|modupdate
argument_list|()
expr_stmt|;
block|}
block|}
name|bmove
argument_list|(
name|Utemp
argument_list|,
name|Usercode
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|ExitFn
operator|=
name|tmpfn
expr_stmt|;
ifdef|#
directive|ifdef
name|DIRBLKSIZ
name|closedir
argument_list|(
name|dirp
argument_list|)
expr_stmt|;
else|#
directive|else
else|DIRBLKSIZ
name|close
argument_list|(
name|dfd
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DIRBLKSIZ
block|}
end_for

begin_escape
end_escape

begin_comment
comment|/* ** handles syserr's in the update processor */
end_comment

begin_macro
name|uperr
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|Batch_fp
condition|)
name|close
argument_list|(
name|Batch_fp
argument_list|)
expr_stmt|;
name|Berror
operator|++
expr_stmt|;
name|reset
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/* ** Catch errors in other places */
end_comment

begin_macro
name|rubproc
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|desxx
modifier|*
name|p
decl_stmt|;
specifier|extern
name|struct
name|desxx
name|Desxx
index|[]
decl_stmt|;
specifier|extern
name|int
name|Acc_init
decl_stmt|;
name|Error
operator|++
expr_stmt|;
name|printf
argument_list|(
literal|"Unable to restore!
literal|\n"
argument_list|)
expr_stmt|;
comment|/* restore user code */
name|bmove
argument_list|(
name|Utemp
argument_list|,
name|Usercode
argument_list|,
sizeof|sizeof
name|Utemp
argument_list|)
expr_stmt|;
comment|/* close all possible files */
if|if
condition|(
name|Acc_init
condition|)
block|{
name|closecatalog
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
name|unldb
argument_list|()
expr_stmt|;
name|acc_close
argument_list|()
expr_stmt|;
block|}
comment|/* close users file */
name|getuser
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* get everything else */
for|for
control|(
name|i
operator|=
name|Direc
operator|+
literal|1
init|;
name|i
operator|<=
name|NOFILE
condition|;
name|i
operator|++
control|)
name|close
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* ** looks up user by usercode in users file */
end_comment

begin_function
name|char
modifier|*
name|lookucode
parameter_list|(
name|ucode
parameter_list|)
name|char
name|ucode
index|[
literal|2
index|]
decl_stmt|;
block|{
specifier|static
name|char
name|buf
index|[
name|MAXLINE
operator|+
literal|1
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|getuser
argument_list|(
name|ucode
argument_list|,
name|buf
argument_list|)
condition|)
name|syserr
argument_list|(
literal|"cannot identify user %.2s"
argument_list|,
name|ucode
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|buf
init|;
operator|*
name|p
operator|!=
literal|':'
condition|;
name|p
operator|++
control|)
empty_stmt|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* ** CHECKATTS **	Checks that all attributes are in a relation */
end_comment

begin_macro
name|checkatts
argument_list|()
end_macro

begin_block
block|{
specifier|extern
name|DESC
name|Reldes
decl_stmt|,
name|Attdes
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|once
decl_stmt|;
name|TID
name|tid
decl_stmt|,
name|limtid
decl_stmt|,
name|reltid
decl_stmt|;
name|char
name|key
index|[
name|MAXTUP
index|]
decl_stmt|;
name|struct
name|attribute
name|atttup
decl_stmt|;
name|struct
name|relation
name|reltup
decl_stmt|;
name|char
name|lastrel
index|[
name|MAXNAME
operator|+
literal|2
index|]
decl_stmt|;
name|once
operator|=
literal|0
expr_stmt|;
name|opencatalog
argument_list|(
literal|"relation"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|opencatalog
argument_list|(
literal|"attribute"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|clearkeys
argument_list|(
operator|&
name|Attdes
argument_list|)
expr_stmt|;
name|lastrel
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|find
argument_list|(
operator|&
name|Attdes
argument_list|,
name|NOKEY
argument_list|,
operator|&
name|tid
argument_list|,
operator|&
name|limtid
argument_list|)
condition|)
name|syserr
argument_list|(
literal|"CHECKATT: find"
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
operator|(
name|i
operator|=
name|get
argument_list|(
operator|&
name|Attdes
argument_list|,
operator|&
name|tid
argument_list|,
operator|&
name|limtid
argument_list|,
operator|&
name|atttup
argument_list|,
name|TRUE
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|bequal
argument_list|(
name|atttup
operator|.
name|attrelid
argument_list|,
name|lastrel
argument_list|,
name|MAXNAME
operator|+
literal|2
argument_list|)
condition|)
continue|continue;
name|clearkeys
argument_list|(
operator|&
name|Reldes
argument_list|)
expr_stmt|;
name|setkey
argument_list|(
operator|&
name|Reldes
argument_list|,
name|key
argument_list|,
name|atttup
operator|.
name|attrelid
argument_list|,
name|ATTRELID
argument_list|)
expr_stmt|;
name|setkey
argument_list|(
operator|&
name|Reldes
argument_list|,
name|key
argument_list|,
name|atttup
operator|.
name|attowner
argument_list|,
name|ATTOWNER
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|=
name|getequal
argument_list|(
operator|&
name|Reldes
argument_list|,
name|key
argument_list|,
operator|&
name|reltup
argument_list|,
operator|&
name|reltid
argument_list|)
condition|)
block|{
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|syserr
argument_list|(
literal|"ATTCHECK: getequal"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|once
operator|++
condition|)
name|printf
argument_list|(
literal|"\tNo relation for attribute(s):\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\t"
argument_list|)
expr_stmt|;
name|printup
argument_list|(
operator|&
name|Attdes
argument_list|,
operator|&
name|atttup
argument_list|)
expr_stmt|;
if|if
condition|(
name|ask
argument_list|(
literal|"\tDelete?"
argument_list|)
condition|)
if|if
condition|(
name|i
operator|=
name|delete
argument_list|(
operator|&
name|Attdes
argument_list|,
operator|&
name|tid
argument_list|)
condition|)
name|syserr
argument_list|(
literal|"ATTCHECK: delete=%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
else|else
name|bmove
argument_list|(
name|atttup
operator|.
name|attrelid
argument_list|,
name|lastrel
argument_list|,
name|MAXNAME
operator|+
literal|2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|syserr
argument_list|(
literal|"ATTCHECK: get=%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* ** CHECKREL -- check relation relation against every thing else ** **	Each tuple in the relation relation is read and each verifiable **	characteristic is checked for accuracy.  Including the existence **	of the physical file (if not a view), the qrymod definition if **	appropriate and the secondary indexing. */
end_comment

begin_macro
name|checkrel
argument_list|()
end_macro

begin_block
block|{
specifier|extern
name|DESC
name|Reldes
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|struct
name|relation
name|rel
decl_stmt|;
name|TID
name|rtid
decl_stmt|,
name|limtid
decl_stmt|;
name|char
name|fname
index|[
name|MAXNAME
operator|+
literal|3
index|]
decl_stmt|;
comment|/* setup for search of entire relation */
name|opencatalog
argument_list|(
literal|"relation"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|clearkeys
argument_list|(
operator|&
name|Reldes
argument_list|)
expr_stmt|;
if|if
condition|(
name|find
argument_list|(
operator|&
name|Reldes
argument_list|,
name|NOKEY
argument_list|,
operator|&
name|rtid
argument_list|,
operator|&
name|limtid
argument_list|)
condition|)
name|syserr
argument_list|(
literal|"CHECKREL: find"
argument_list|)
expr_stmt|;
comment|/* loop until all tuples checked */
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* for each tuple in the rel-rel */
name|i
operator|=
name|get
argument_list|(
operator|&
name|Reldes
argument_list|,
operator|&
name|rtid
argument_list|,
operator|&
name|limtid
argument_list|,
operator|&
name|rel
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
break|break;
comment|/* have finished */
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|syserr
argument_list|(
literal|"CHECKREL: get=%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* if not a view, check for the file */
if|if
condition|(
operator|(
name|rel
operator|.
name|relstat
operator|&
name|S_VIEW
operator|)
operator|!=
name|S_VIEW
condition|)
block|{
name|ingresname
argument_list|(
name|rel
operator|.
name|relid
argument_list|,
name|rel
operator|.
name|relowner
argument_list|,
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|j
operator|=
name|open
argument_list|(
name|fname
argument_list|,
literal|2
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"\tNo file for:\n\t"
argument_list|)
expr_stmt|;
name|printup
argument_list|(
operator|&
name|Reldes
argument_list|,
operator|&
name|rel
argument_list|)
expr_stmt|;
if|if
condition|(
name|ask
argument_list|(
literal|"\tDelete tuple? "
argument_list|)
condition|)
block|{
if|if
condition|(
name|j
operator|=
name|delete
argument_list|(
operator|&
name|Reldes
argument_list|,
operator|&
name|rtid
argument_list|)
condition|)
name|syserr
argument_list|(
literal|"CHECKREL: delete=%d"
argument_list|,
name|j
argument_list|)
expr_stmt|;
continue|continue;
block|}
else|else
comment|/* don't call purge the file might still be there */
name|Error
operator|++
expr_stmt|;
block|}
else|else
name|close
argument_list|(
name|j
argument_list|)
expr_stmt|;
block|}
comment|/* does it think that it has a secondary index */
if|if
condition|(
name|rel
operator|.
name|relindxd
operator|>
literal|0
condition|)
block|{
comment|/* does it really have an index? */
if|if
condition|(
operator|!
name|hasndx
argument_list|(
name|rel
operator|.
name|relid
argument_list|,
name|rel
operator|.
name|relowner
argument_list|)
condition|)
block|{
comment|/* no, should it be fixed */
name|printf
argument_list|(
literal|"\tNo indexes entry for primary relation:\n\t"
argument_list|)
expr_stmt|;
name|printup
argument_list|(
operator|&
name|Reldes
argument_list|,
operator|&
name|rel
argument_list|)
expr_stmt|;
if|if
condition|(
name|ask
argument_list|(
literal|"\tAdjust? "
argument_list|)
condition|)
block|{
comment|/* fix up relation relation entry */
name|rel
operator|.
name|relindxd
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|i
operator|=
name|replace
argument_list|(
operator|&
name|Reldes
argument_list|,
operator|&
name|rtid
argument_list|,
operator|&
name|rel
argument_list|,
name|FALSE
argument_list|)
condition|)
name|syserr
argument_list|(
literal|"CHECKREL: replace=%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* does it think that it is a secondary index */
if|if
condition|(
name|rel
operator|.
name|relindxd
operator|<
literal|0
condition|)
block|{
comment|/* check to make sure */
if|if
condition|(
operator|!
name|isndx
argument_list|(
name|rel
operator|.
name|relid
argument_list|,
name|rel
operator|.
name|relowner
argument_list|)
condition|)
block|{
comment|/* none, what should be done? */
name|printf
argument_list|(
literal|"\tNo indexes entry for index:\n\t"
argument_list|)
expr_stmt|;
name|printup
argument_list|(
operator|&
name|Reldes
argument_list|,
operator|&
name|rel
argument_list|)
expr_stmt|;
if|if
condition|(
name|ask
argument_list|(
literal|"\tDelete? "
argument_list|)
condition|)
block|{
comment|/* 					** get rid of rel-rel tuple for 					** secondary index, 					** purge will do rest of 					** removal if necessary 					*/
if|if
condition|(
name|i
operator|=
name|delete
argument_list|(
operator|&
name|Reldes
argument_list|,
operator|&
name|rtid
argument_list|)
condition|)
name|syserr
argument_list|(
literal|"CHECKREL: delete=%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
continue|continue;
comment|/* go on to next tuple */
block|}
block|}
block|}
comment|/* if qrymod on in the database, check those catalogs too */
if|if
condition|(
name|Qrymod
condition|)
block|{
comment|/* 			** cannot deal with S_VBASE since there is no way to 			** find the tree catalog entries without decoding the 			** 'treetree' fields. 			** 			** check to see if this is a view 			*/
if|if
condition|(
operator|(
name|rel
operator|.
name|relstat
operator|&
name|S_VIEW
operator|)
operator|&&
operator|!
name|havetree
argument_list|(
name|rel
operator|.
name|relid
argument_list|,
name|rel
operator|.
name|relowner
argument_list|,
name|mdVIEW
argument_list|)
condition|)
block|{
comment|/* no entry, should it be fixed? */
name|printf
argument_list|(
literal|"\tNo tree entry for this view:\n\t"
argument_list|)
expr_stmt|;
name|printup
argument_list|(
operator|&
name|Reldes
argument_list|,
operator|&
name|rel
argument_list|)
expr_stmt|;
if|if
condition|(
name|ask
argument_list|(
literal|"\tDelete tuple? "
argument_list|)
condition|)
block|{
comment|/* delete relation entry */
if|if
condition|(
name|i
operator|=
name|delete
argument_list|(
operator|&
name|Reldes
argument_list|,
operator|&
name|rtid
argument_list|)
condition|)
name|syserr
argument_list|(
literal|"CHECKREL: delete=%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
continue|continue;
comment|/* skip to next entry in rel-rel */
block|}
block|}
comment|/* check to see if has 'protect' entry */
if|if
condition|(
operator|(
name|rel
operator|.
name|relstat
operator|&
name|S_PROTUPS
operator|)
operator|&&
operator|!
name|isprot
argument_list|(
name|rel
operator|.
name|relid
argument_list|,
name|rel
operator|.
name|relowner
argument_list|,
operator|-
literal|1
argument_list|)
condition|)
block|{
comment|/* no entry, should the bit be reset */
name|printf
argument_list|(
literal|"\tNo protect entry for:\n\t"
argument_list|)
expr_stmt|;
name|printup
argument_list|(
operator|&
name|Reldes
argument_list|,
operator|&
name|rel
argument_list|)
expr_stmt|;
if|if
condition|(
name|ask
argument_list|(
literal|"\tAdjust? "
argument_list|)
condition|)
block|{
comment|/* fix the bit */
name|rel
operator|.
name|relstat
operator|&=
operator|~
name|S_PROTUPS
expr_stmt|;
if|if
condition|(
name|i
operator|=
name|replace
argument_list|(
operator|&
name|Reldes
argument_list|,
operator|&
name|rtid
argument_list|,
operator|&
name|rel
argument_list|,
name|FALSE
argument_list|)
condition|)
name|syserr
argument_list|(
literal|"CHECKREL: replace=%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* check to see if has 'integrities entry */
if|if
condition|(
operator|(
name|rel
operator|.
name|relstat
operator|&
name|S_INTEG
operator|)
operator|&&
operator|!
name|isinteg
argument_list|(
name|rel
operator|.
name|relid
argument_list|,
name|rel
operator|.
name|relowner
argument_list|,
operator|-
literal|1
argument_list|)
condition|)
block|{
comment|/* no entry, should bit be reset */
name|printf
argument_list|(
literal|"\tNo integrities entry for:\n\t"
argument_list|)
expr_stmt|;
name|printup
argument_list|(
operator|&
name|Reldes
argument_list|,
operator|&
name|rel
argument_list|)
expr_stmt|;
if|if
condition|(
name|ask
argument_list|(
literal|"\tAdjust? "
argument_list|)
condition|)
block|{
comment|/* fix up the bit */
name|rel
operator|.
name|relstat
operator|&=
operator|~
name|S_INTEG
expr_stmt|;
if|if
condition|(
name|i
operator|=
name|replace
argument_list|(
operator|&
name|Reldes
argument_list|,
operator|&
name|rtid
argument_list|,
operator|&
name|rel
argument_list|,
name|FALSE
argument_list|)
condition|)
name|syserr
argument_list|(
literal|"CHECKREL: replace=%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* ** HASNDX -- the relation indicated an index, check it out ** **	will search the index relation for all secondary indexes **	and check to see that each secondary index named has an **	entry in the relation relation. */
end_comment

begin_macro
name|hasndx
argument_list|(
argument|id
argument_list|,
argument|own
argument_list|)
end_macro

begin_decl_stmt
name|char
name|id
index|[
name|MAXNAME
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|own
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|hasindexes
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|extern
name|DESC
name|Reldes
decl_stmt|,
name|Inddes
decl_stmt|;
name|TID
name|rtid
decl_stmt|;
name|struct
name|relation
name|rkey
decl_stmt|,
name|rel
decl_stmt|;
name|TID
name|itid
decl_stmt|,
name|ihitid
decl_stmt|;
name|struct
name|index
name|ikey
decl_stmt|,
name|ind
decl_stmt|;
comment|/* presume that answer is negative */
name|hasindexes
operator|=
name|FALSE
expr_stmt|;
comment|/* set search for all tuples with 'id' and 'own' in indexes */
name|opencatalog
argument_list|(
literal|"indexes"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|clearkeys
argument_list|(
operator|&
name|Inddes
argument_list|)
expr_stmt|;
name|setkey
argument_list|(
operator|&
name|Inddes
argument_list|,
operator|&
name|ikey
argument_list|,
name|id
argument_list|,
name|IRELIDP
argument_list|)
expr_stmt|;
name|setkey
argument_list|(
operator|&
name|Inddes
argument_list|,
operator|&
name|ikey
argument_list|,
name|own
argument_list|,
name|IOWNERP
argument_list|)
expr_stmt|;
if|if
condition|(
name|find
argument_list|(
operator|&
name|Inddes
argument_list|,
name|EXACTKEY
argument_list|,
operator|&
name|itid
argument_list|,
operator|&
name|ihitid
argument_list|,
operator|&
name|ikey
argument_list|)
condition|)
name|syserr
argument_list|(
literal|"HASNDX: find"
argument_list|)
expr_stmt|;
comment|/* for each possible tuple in the indexes relation */
for|for
control|(
init|;
condition|;
control|)
block|{
name|i
operator|=
name|get
argument_list|(
operator|&
name|Inddes
argument_list|,
operator|&
name|itid
argument_list|,
operator|&
name|ihitid
argument_list|,
operator|&
name|ind
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* check return values */
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|syserr
argument_list|(
literal|"HASNDX: get=%d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
break|break;
comment|/* finished */
comment|/* if key doesn't match, skip to next tuple */
if|if
condition|(
name|kcompare
argument_list|(
operator|&
name|Inddes
argument_list|,
operator|&
name|ikey
argument_list|,
operator|&
name|ind
argument_list|)
condition|)
continue|continue;
name|hasindexes
operator|=
name|TRUE
expr_stmt|;
comment|/* verify that primary entry for sec index exists */
name|opencatalog
argument_list|(
literal|"relation"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|clearkeys
argument_list|(
operator|&
name|Reldes
argument_list|)
expr_stmt|;
name|setkey
argument_list|(
operator|&
name|Reldes
argument_list|,
operator|&
name|rkey
argument_list|,
name|ind
operator|.
name|irelidi
argument_list|,
name|RELID
argument_list|)
expr_stmt|;
name|setkey
argument_list|(
operator|&
name|Reldes
argument_list|,
operator|&
name|rkey
argument_list|,
name|ind
operator|.
name|iownerp
argument_list|,
name|RELOWNER
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|=
name|getequal
argument_list|(
operator|&
name|Reldes
argument_list|,
operator|&
name|rkey
argument_list|,
operator|&
name|rel
argument_list|,
operator|&
name|rtid
argument_list|,
name|FALSE
argument_list|)
condition|)
block|{
comment|/* one doesn't exist, should we ignore it */
if|if
condition|(
name|j
operator|<
literal|0
condition|)
name|syserr
argument_list|(
literal|"HASNDX: getequal=%d"
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tNo secondary index for indexes entry:\n\t"
argument_list|)
expr_stmt|;
name|printup
argument_list|(
operator|&
name|Inddes
argument_list|,
operator|&
name|ind
argument_list|)
expr_stmt|;
if|if
condition|(
name|ask
argument_list|(
literal|"\tDelete? "
argument_list|)
condition|)
block|{
comment|/* get rid of bad entry in indexes relation */
if|if
condition|(
name|j
operator|=
name|delete
argument_list|(
operator|&
name|Inddes
argument_list|,
operator|&
name|itid
argument_list|)
condition|)
name|syserr
argument_list|(
literal|"HASNDX: delete=%d"
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|hasindexes
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
block|}
return|return
operator|(
name|hasindexes
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* ** ISNDX -- so you think that you're a secondary index, I'll check it out. ** **	searches the indexes relation for the name of the primary relation **	and check to see if the primary is real.  Will also update the **	'relindxd' field of the primary if it isn't correct. */
end_comment

begin_macro
name|isndx
argument_list|(
argument|id
argument_list|,
argument|own
argument_list|)
end_macro

begin_decl_stmt
name|char
name|id
index|[
name|MAXNAME
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|own
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|isindex
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|extern
name|DESC
name|Inddes
decl_stmt|;
name|TID
name|itid
decl_stmt|;
name|struct
name|index
name|ind
decl_stmt|,
name|ikey
decl_stmt|;
specifier|extern
name|DESC
name|Reldes
decl_stmt|;
name|TID
name|rtid
decl_stmt|;
name|struct
name|relation
name|rel
decl_stmt|,
name|rkey
decl_stmt|;
comment|/* search for tuple in index relation, should only be one */
name|opencatalog
argument_list|(
literal|"indexes"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|clearkeys
argument_list|(
operator|&
name|Inddes
argument_list|)
expr_stmt|;
name|setkey
argument_list|(
operator|&
name|Inddes
argument_list|,
operator|&
name|ikey
argument_list|,
name|id
argument_list|,
name|IRELIDI
argument_list|)
expr_stmt|;
name|setkey
argument_list|(
operator|&
name|Inddes
argument_list|,
operator|&
name|ikey
argument_list|,
name|own
argument_list|,
name|IOWNERP
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|=
name|getequal
argument_list|(
operator|&
name|Inddes
argument_list|,
operator|&
name|ikey
argument_list|,
operator|&
name|ind
argument_list|,
operator|&
name|itid
argument_list|)
condition|)
block|{
comment|/* there isn't a tuple in the indexes relation */
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|syserr
argument_list|(
literal|"ISNDX: getequal=%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|isindex
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
name|isindex
operator|=
name|TRUE
expr_stmt|;
comment|/* there is a tuple in the indexes relation */
name|opencatalog
argument_list|(
literal|"relation"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|clearkeys
argument_list|(
operator|&
name|Reldes
argument_list|)
expr_stmt|;
name|setkey
argument_list|(
operator|&
name|Reldes
argument_list|,
operator|&
name|rkey
argument_list|,
name|ind
operator|.
name|irelidp
argument_list|,
name|RELID
argument_list|)
expr_stmt|;
name|setkey
argument_list|(
operator|&
name|Reldes
argument_list|,
operator|&
name|rkey
argument_list|,
name|ind
operator|.
name|iownerp
argument_list|,
name|RELOWNER
argument_list|)
expr_stmt|;
comment|/* see if the primary relation exists */
if|if
condition|(
name|i
operator|=
name|getequal
argument_list|(
operator|&
name|Reldes
argument_list|,
operator|&
name|rkey
argument_list|,
operator|&
name|rel
argument_list|,
operator|&
name|rtid
argument_list|)
condition|)
block|{
comment|/* no it doesn't */
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|syserr
argument_list|(
literal|"ISNDX: getequal=%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* what should be done about it */
name|printf
argument_list|(
literal|"\tNo primary relation for index:\n\t"
argument_list|)
expr_stmt|;
name|printup
argument_list|(
operator|&
name|Inddes
argument_list|,
operator|&
name|ind
argument_list|)
expr_stmt|;
if|if
condition|(
name|ask
argument_list|(
literal|"\tDelete?"
argument_list|)
condition|)
block|{
comment|/* 				** get rid of indexes tuple, 				** a FALSE return will also get rid 				** of the relation tuple 				*/
if|if
condition|(
name|i
operator|=
name|delete
argument_list|(
operator|&
name|Inddes
argument_list|,
operator|&
name|itid
argument_list|)
condition|)
name|syserr
argument_list|(
literal|"ISNDX: delete=%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|isindex
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|rel
operator|.
name|relindxd
operator|>
literal|0
operator|)
operator|||
operator|(
name|rel
operator|.
name|relstat
operator|&
name|S_INDEX
operator|)
operator|==
name|S_INDEX
condition|)
block|{
comment|/* 			** the primary tuple exists but isn't marked correctly 			*/
name|printf
argument_list|(
literal|"\t%.12s is index for:\n\t"
argument_list|,
name|rel
operator|.
name|relid
argument_list|)
expr_stmt|;
name|printup
argument_list|(
operator|&
name|Reldes
argument_list|,
operator|&
name|rel
argument_list|)
expr_stmt|;
if|if
condition|(
name|ask
argument_list|(
literal|"\tMark as indexed? "
argument_list|)
condition|)
block|{
name|rel
operator|.
name|relstat
operator||=
name|S_INDEX
expr_stmt|;
name|rel
operator|.
name|relindxd
operator|=
name|SECBASE
expr_stmt|;
if|if
condition|(
name|i
operator|=
name|replace
argument_list|(
operator|&
name|Reldes
argument_list|,
operator|&
name|rtid
argument_list|,
operator|&
name|rel
argument_list|,
name|FALSE
argument_list|)
condition|)
name|syserr
argument_list|(
literal|"ISNDX: replace=%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
operator|(
name|isindex
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* ** HAVETREE -- check tree catalog for an entry with right name and owner ** **	The 'id' and 'own' parameters are used to look in the tree catalog **	for at least on tuple that also has a 'treetype' of 'mdvalue'. ** **	If any tuples are found, havetree returns TRUE, else FALSE */
end_comment

begin_macro
name|havetree
argument_list|(
argument|id
argument_list|,
argument|own
argument_list|,
argument|mdvalue
argument_list|)
end_macro

begin_decl_stmt
name|char
name|id
index|[
name|MAXNAME
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|own
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|mdvalue
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|extern
name|DESC
name|Treedes
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|struct
name|tree
name|tkey
decl_stmt|,
name|trent
decl_stmt|;
name|TID
name|ttid
decl_stmt|,
name|thitid
decl_stmt|;
comment|/* search tree relation for tuple that matches */
name|opencatalog
argument_list|(
literal|"tree"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|clearkeys
argument_list|(
operator|&
name|Treedes
argument_list|)
expr_stmt|;
name|setkey
argument_list|(
operator|&
name|Treedes
argument_list|,
operator|&
name|tkey
argument_list|,
name|id
argument_list|,
name|TREERELID
argument_list|)
expr_stmt|;
name|setkey
argument_list|(
operator|&
name|Treedes
argument_list|,
operator|&
name|tkey
argument_list|,
name|own
argument_list|,
name|TREEOWNER
argument_list|)
expr_stmt|;
name|setkey
argument_list|(
operator|&
name|Treedes
argument_list|,
operator|&
name|tkey
argument_list|,
operator|&
name|mdvalue
argument_list|,
name|TREETYPE
argument_list|)
expr_stmt|;
comment|/* set search limit tids from the key */
if|if
condition|(
name|i
operator|=
name|find
argument_list|(
operator|&
name|Treedes
argument_list|,
name|EXACTKEY
argument_list|,
operator|&
name|ttid
argument_list|,
operator|&
name|thitid
argument_list|,
operator|&
name|tkey
argument_list|)
condition|)
name|syserr
argument_list|(
literal|"HAVETREE: find=%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|i
operator|=
name|get
argument_list|(
operator|&
name|Treedes
argument_list|,
operator|&
name|ttid
argument_list|,
operator|&
name|thitid
argument_list|,
operator|&
name|trent
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|syserr
argument_list|(
literal|"HAVETREE: get=%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
break|break;
comment|/* finished, didn't find one */
if|if
condition|(
name|kcompare
argument_list|(
operator|&
name|Treedes
argument_list|,
operator|&
name|tkey
argument_list|,
operator|&
name|trent
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* ** ISPROT -- check in the 'protect' catalog for a tuple with right name, owner ** **	search the 'protect' catalog for at least on tuple with matches the **	values in the parameters. If 'treeid' is>= 0 then it is not used as **	a key. ** **	if one is found, returns TRUE, otherwise, returns FALSE */
end_comment

begin_macro
name|isprot
argument_list|(
argument|id
argument_list|,
argument|own
argument_list|,
argument|treeid
argument_list|)
end_macro

begin_decl_stmt
name|char
name|id
index|[
name|MAXNAME
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|own
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|treeid
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|extern
name|DESC
name|Prodes
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|struct
name|protect
name|pkey
decl_stmt|,
name|pent
decl_stmt|;
name|TID
name|ptid
decl_stmt|,
name|phitid
decl_stmt|;
comment|/* search the protect relation for at least on matching tuple */
name|opencatalog
argument_list|(
literal|"protect"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|clearkeys
argument_list|(
operator|&
name|Prodes
argument_list|)
expr_stmt|;
name|setkey
argument_list|(
operator|&
name|Prodes
argument_list|,
operator|&
name|pkey
argument_list|,
name|id
argument_list|,
name|PRORELID
argument_list|)
expr_stmt|;
name|setkey
argument_list|(
operator|&
name|Prodes
argument_list|,
operator|&
name|pkey
argument_list|,
name|own
argument_list|,
name|PRORELOWN
argument_list|)
expr_stmt|;
if|if
condition|(
name|treeid
operator|>=
literal|0
condition|)
name|setkey
argument_list|(
operator|&
name|Prodes
argument_list|,
operator|&
name|pkey
argument_list|,
operator|&
name|treeid
argument_list|,
name|PROTREE
argument_list|)
expr_stmt|;
comment|/* set search limit tids from the keys */
if|if
condition|(
name|i
operator|=
name|find
argument_list|(
operator|&
name|Prodes
argument_list|,
name|EXACTKEY
argument_list|,
operator|&
name|ptid
argument_list|,
operator|&
name|phitid
argument_list|,
operator|&
name|pkey
argument_list|)
condition|)
name|syserr
argument_list|(
literal|"ISPROT: find=%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|i
operator|=
name|get
argument_list|(
operator|&
name|Prodes
argument_list|,
operator|&
name|ptid
argument_list|,
operator|&
name|phitid
argument_list|,
operator|&
name|pent
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|syserr
argument_list|(
literal|"ISPROT: get=%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
break|break;
comment|/* finished, didn't find one */
if|if
condition|(
name|kcompare
argument_list|(
operator|&
name|Prodes
argument_list|,
operator|&
name|pkey
argument_list|,
operator|&
name|pent
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* ** ISINTEG -- check for a tuple in 'integrities' ** **	searches the integrities relation for 'id' and 'own'. ** **	returns TRUE if one is found, else FALSE */
end_comment

begin_macro
name|isinteg
argument_list|(
argument|id
argument_list|,
argument|own
argument_list|,
argument|treeid
argument_list|)
end_macro

begin_decl_stmt
name|char
name|id
index|[
name|MAXNAME
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|own
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|treeid
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|extern
name|DESC
name|Intdes
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|struct
name|integrity
name|inkey
decl_stmt|,
name|integ
decl_stmt|;
name|TID
name|intid
decl_stmt|,
name|inhitid
decl_stmt|;
comment|/* search the entire relation for a tuple that matches */
name|opencatalog
argument_list|(
literal|"integrities"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|clearkeys
argument_list|(
operator|&
name|Intdes
argument_list|)
expr_stmt|;
name|setkey
argument_list|(
operator|&
name|Intdes
argument_list|,
operator|&
name|inkey
argument_list|,
name|id
argument_list|,
name|INTRELID
argument_list|)
expr_stmt|;
name|setkey
argument_list|(
operator|&
name|Intdes
argument_list|,
operator|&
name|inkey
argument_list|,
name|own
argument_list|,
name|INTRELOWNER
argument_list|)
expr_stmt|;
if|if
condition|(
name|treeid
operator|>=
literal|0
condition|)
name|setkey
argument_list|(
operator|&
name|Intdes
argument_list|,
operator|&
name|inkey
argument_list|,
operator|&
name|treeid
argument_list|,
name|INTTREE
argument_list|)
expr_stmt|;
comment|/* set the search limit tids from the key */
if|if
condition|(
name|i
operator|=
name|find
argument_list|(
operator|&
name|Intdes
argument_list|,
name|EXACTKEY
argument_list|,
operator|&
name|intid
argument_list|,
operator|&
name|inhitid
argument_list|,
operator|&
name|inkey
argument_list|)
condition|)
name|syserr
argument_list|(
literal|"ISINTEG: find=%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|i
operator|=
name|get
argument_list|(
operator|&
name|Intdes
argument_list|,
operator|&
name|intid
argument_list|,
operator|&
name|inhitid
argument_list|,
operator|&
name|integ
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|syserr
argument_list|(
literal|"ISINTEG: get=%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
break|break;
comment|/* finished, didn't find one */
if|if
condition|(
name|kcompare
argument_list|(
operator|&
name|Intdes
argument_list|,
operator|&
name|inkey
argument_list|,
operator|&
name|integ
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* ** CHECKTREE -- check the tree catalog against the others */
end_comment

begin_macro
name|checktree
argument_list|()
end_macro

begin_block
block|{
specifier|extern
name|DESC
name|Treedes
decl_stmt|,
name|Reldes
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|struct
name|tree
name|tkey
decl_stmt|,
name|trent
decl_stmt|;
name|TID
name|ttid
decl_stmt|,
name|thitid
decl_stmt|;
name|struct
name|relation
name|rkey
decl_stmt|,
name|rel
decl_stmt|;
name|TID
name|rtid
decl_stmt|;
comment|/* search the entire tree catalog */
name|opencatalog
argument_list|(
literal|"tree"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|clearkeys
argument_list|(
operator|&
name|Treedes
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|=
name|find
argument_list|(
operator|&
name|Treedes
argument_list|,
name|NOKEY
argument_list|,
operator|&
name|ttid
argument_list|,
operator|&
name|thitid
argument_list|)
condition|)
name|syserr
argument_list|(
literal|"CHECKTREE: find=%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* for each tuple in 'tree' */
for|for
control|(
init|;
condition|;
control|)
block|{
name|i
operator|=
name|get
argument_list|(
operator|&
name|Treedes
argument_list|,
operator|&
name|ttid
argument_list|,
operator|&
name|thitid
argument_list|,
operator|&
name|trent
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
break|break;
comment|/* finished */
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|syserr
argument_list|(
literal|"CHECKTREE: get=%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* verify that a tuple exists in the relation relation */
name|opencatalog
argument_list|(
literal|"relation"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|clearkeys
argument_list|(
operator|&
name|Reldes
argument_list|)
expr_stmt|;
name|setkey
argument_list|(
operator|&
name|Reldes
argument_list|,
operator|&
name|rkey
argument_list|,
name|trent
operator|.
name|treerelid
argument_list|,
name|RELID
argument_list|)
expr_stmt|;
name|setkey
argument_list|(
operator|&
name|Reldes
argument_list|,
operator|&
name|rkey
argument_list|,
name|trent
operator|.
name|treeowner
argument_list|,
name|RELOWNER
argument_list|)
expr_stmt|;
comment|/* fetch the tuple */
if|if
condition|(
name|i
operator|=
name|getequal
argument_list|(
operator|&
name|Reldes
argument_list|,
operator|&
name|rkey
argument_list|,
operator|&
name|rel
argument_list|,
operator|&
name|rtid
argument_list|)
condition|)
block|{
comment|/* 			** Oops, a tuple doesn't exist in the relation 			** relation. 			** 			** maybe it's just a fatal error 			*/
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|syserr
argument_list|(
literal|"CHECKTREE: getequal=%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* not a fatal error, what to do about it? */
name|printf
argument_list|(
literal|"\tNo relation tuple for:\n\t"
argument_list|)
expr_stmt|;
name|printup
argument_list|(
operator|&
name|Treedes
argument_list|,
operator|&
name|trent
argument_list|)
expr_stmt|;
if|if
condition|(
name|ask
argument_list|(
literal|"\tDelete? "
argument_list|)
condition|)
block|{
if|if
condition|(
name|i
operator|=
name|delete
argument_list|(
operator|&
name|Treedes
argument_list|,
operator|&
name|ttid
argument_list|)
condition|)
name|syserr
argument_list|(
literal|"CHECKTREE: delete=%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
continue|continue;
comment|/* go on to next tuple */
block|}
block|}
else|else
block|{
comment|/* 			** Ah. A tuple does exist. 			** 			** If the relstat bits are correct then we can stop 			** here since elsewhere the 'protect' and 'integrity' 			** entries were verified. 			*/
switch|switch
condition|(
name|trent
operator|.
name|treetype
condition|)
block|{
case|case
name|mdVIEW
case|:
comment|/* mere existence is sufficient */
break|break;
case|case
name|mdPROT
case|:
if|if
condition|(
operator|(
name|rel
operator|.
name|relstat
operator|&
name|S_PROTUPS
operator|)
operator|!=
name|S_PROTUPS
condition|)
block|{
name|printf
argument_list|(
literal|"\tNo 'protect' entry for:\n\t"
argument_list|)
expr_stmt|;
name|deltup
label|:
name|printup
argument_list|(
operator|&
name|Treedes
argument_list|,
operator|&
name|trent
argument_list|)
expr_stmt|;
if|if
condition|(
name|ask
argument_list|(
literal|"\tDelete? "
argument_list|)
condition|)
block|{
if|if
condition|(
name|i
operator|=
name|delete
argument_list|(
operator|&
name|Treedes
argument_list|,
operator|&
name|ttid
argument_list|)
condition|)
name|syserr
argument_list|(
literal|"CHECKTREE: delete=%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
break|break;
case|case
name|mdINTEG
case|:
if|if
condition|(
operator|(
name|rel
operator|.
name|relstat
operator|&
name|S_INTEG
operator|)
operator|!=
name|S_INTEG
condition|)
block|{
name|printf
argument_list|(
literal|"\tNo 'integrities' entry for:\n\t"
argument_list|)
expr_stmt|;
goto|goto
name|deltup
goto|;
block|}
break|break;
default|default:
name|syserr
argument_list|(
literal|"Unknown treetype: %d\n"
argument_list|,
name|trent
operator|.
name|treetype
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  CHECKPROTECT */
end_comment

begin_macro
name|checkprotect
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|extern
name|DESC
name|Reldes
decl_stmt|,
name|Prodes
decl_stmt|;
name|struct
name|protect
name|pkey
decl_stmt|,
name|pent
decl_stmt|;
name|TID
name|ptid
decl_stmt|,
name|phitid
decl_stmt|;
name|struct
name|relation
name|rkey
decl_stmt|,
name|rel
decl_stmt|;
name|TID
name|rtid
decl_stmt|;
comment|/* for each entry in the 'protect' relation */
name|opencatalog
argument_list|(
literal|"protect"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|clearkeys
argument_list|(
operator|&
name|Prodes
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|=
name|find
argument_list|(
operator|&
name|Prodes
argument_list|,
name|NOKEY
argument_list|,
operator|&
name|ptid
argument_list|,
operator|&
name|phitid
argument_list|)
condition|)
name|syserr
argument_list|(
literal|"CHECKPROTECT: find=%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|i
operator|=
name|get
argument_list|(
operator|&
name|Prodes
argument_list|,
operator|&
name|ptid
argument_list|,
operator|&
name|phitid
argument_list|,
operator|&
name|pent
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
break|break;
comment|/* finished */
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|syserr
argument_list|(
literal|"CHECKPROTECT: get=%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* verify that a tuple exists in 'relation' */
name|opencatalog
argument_list|(
literal|"relation"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|clearkeys
argument_list|(
operator|&
name|Reldes
argument_list|)
expr_stmt|;
name|setkey
argument_list|(
operator|&
name|Reldes
argument_list|,
operator|&
name|rkey
argument_list|,
name|pent
operator|.
name|prorelid
argument_list|,
name|RELID
argument_list|)
expr_stmt|;
name|setkey
argument_list|(
operator|&
name|Reldes
argument_list|,
operator|&
name|rkey
argument_list|,
name|pent
operator|.
name|prorelown
argument_list|,
name|RELOWNER
argument_list|)
expr_stmt|;
comment|/* fetch the tuple if possible */
if|if
condition|(
name|i
operator|=
name|getequal
argument_list|(
operator|&
name|Reldes
argument_list|,
operator|&
name|rkey
argument_list|,
operator|&
name|rel
argument_list|,
operator|&
name|rtid
argument_list|)
condition|)
block|{
comment|/* 			** Oops.  A tuple doesn't exits in 'relation' 			** 			** Maybe it's just a fatal error. 			*/
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|syserr
argument_list|(
literal|"CHECKPROTECT: getequal=%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* not a fatal error, what to do? */
name|printf
argument_list|(
literal|"\tNo relation for 'protect' entry:\n\t"
argument_list|)
expr_stmt|;
name|printup
argument_list|(
operator|&
name|Prodes
argument_list|,
operator|&
name|pent
argument_list|)
expr_stmt|;
if|if
condition|(
name|ask
argument_list|(
literal|"\tRemove 'protect' entry? "
argument_list|)
condition|)
block|{
if|if
condition|(
name|i
operator|=
name|delete
argument_list|(
operator|&
name|Prodes
argument_list|,
operator|&
name|ptid
argument_list|)
condition|)
name|syserr
argument_list|(
literal|"CHECKPROTECT: delete=%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
continue|continue;
comment|/* go on to next tuple */
block|}
block|}
else|else
block|{
comment|/* 'relation' entry exists, check for the tree entry */
if|if
condition|(
name|pent
operator|.
name|protree
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|havetree
argument_list|(
name|pent
operator|.
name|prorelid
argument_list|,
name|pent
operator|.
name|prorelown
argument_list|,
name|mdPROT
argument_list|)
condition|)
block|{
comment|/* no tuples in 'tree' */
name|printf
argument_list|(
literal|"\tNo tree for:\n\t"
argument_list|)
expr_stmt|;
name|printup
argument_list|(
operator|&
name|Prodes
argument_list|,
operator|&
name|pent
argument_list|)
expr_stmt|;
if|if
condition|(
name|ask
argument_list|(
literal|"\tDelete entry and fix relation status bits? "
argument_list|)
condition|)
block|{
if|if
condition|(
name|i
operator|=
name|delete
argument_list|(
operator|&
name|Prodes
argument_list|,
operator|&
name|pent
argument_list|)
condition|)
name|syserr
argument_list|(
literal|"CHECKPROTECT: delete=%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|rel
operator|.
name|relstat
operator|&=
operator|~
name|S_PROTUPS
expr_stmt|;
if|if
condition|(
name|i
operator|=
name|replace
argument_list|(
operator|&
name|Reldes
argument_list|,
operator|&
name|rtid
argument_list|,
operator|&
name|rel
argument_list|,
name|FALSE
argument_list|)
condition|)
name|syserr
argument_list|(
literal|"CHECKPROTECT: replace=%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
continue|continue;
comment|/* go on to next tuple */
block|}
block|}
block|}
if|if
condition|(
operator|(
name|rel
operator|.
name|relstat
operator|&
name|S_PROTUPS
operator|)
operator|!=
name|S_PROTUPS
condition|)
block|{
comment|/* bits not set correctly */
name|printf
argument_list|(
literal|"\tIncorrect relation status bits for:\n\t"
argument_list|)
expr_stmt|;
name|printup
argument_list|(
operator|&
name|Reldes
argument_list|,
operator|&
name|rel
argument_list|)
expr_stmt|;
if|if
condition|(
name|ask
argument_list|(
literal|"\tAdjust? "
argument_list|)
condition|)
block|{
name|rel
operator|.
name|relstat
operator||=
name|S_PROTUPS
expr_stmt|;
if|if
condition|(
name|i
operator|=
name|replace
argument_list|(
operator|&
name|Reldes
argument_list|,
operator|&
name|rtid
argument_list|,
operator|&
name|rel
argument_list|,
name|FALSE
argument_list|)
condition|)
name|syserr
argument_list|(
literal|"CHECKPROTECT: replace=%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
continue|continue;
comment|/* go on to next tuple */
block|}
block|}
block|}
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  CHECKINTEG */
end_comment

begin_macro
name|checkinteg
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|extern
name|DESC
name|Reldes
decl_stmt|,
name|Intdes
decl_stmt|;
name|struct
name|integrity
name|inkey
decl_stmt|,
name|inent
decl_stmt|;
name|TID
name|intid
decl_stmt|,
name|inhitid
decl_stmt|;
name|struct
name|relation
name|rkey
decl_stmt|,
name|rel
decl_stmt|;
name|TID
name|rtid
decl_stmt|;
comment|/* for each entry in 'integrities' */
name|opencatalog
argument_list|(
literal|"integrities"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|clearkeys
argument_list|(
operator|&
name|Intdes
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|=
name|find
argument_list|(
operator|&
name|Intdes
argument_list|,
name|NOKEY
argument_list|,
operator|&
name|intid
argument_list|,
operator|&
name|inhitid
argument_list|)
condition|)
name|syserr
argument_list|(
literal|"CHECKINTEG: find=%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|i
operator|=
name|get
argument_list|(
operator|&
name|Intdes
argument_list|,
operator|&
name|intid
argument_list|,
operator|&
name|inhitid
argument_list|,
operator|&
name|inent
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
break|break;
comment|/* finished */
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|syserr
argument_list|(
literal|"CHECKINTEG: get=%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* verify that a tuple exists in 'relation' */
name|opencatalog
argument_list|(
literal|"relation"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|clearkeys
argument_list|(
operator|&
name|Reldes
argument_list|)
expr_stmt|;
name|setkey
argument_list|(
operator|&
name|Reldes
argument_list|,
operator|&
name|rkey
argument_list|,
name|inent
operator|.
name|intrelid
argument_list|,
name|RELID
argument_list|)
expr_stmt|;
name|setkey
argument_list|(
operator|&
name|Reldes
argument_list|,
operator|&
name|rkey
argument_list|,
name|inent
operator|.
name|intrelowner
argument_list|,
name|RELOWNER
argument_list|)
expr_stmt|;
comment|/* fetch the tuple if possible */
if|if
condition|(
name|i
operator|=
name|getequal
argument_list|(
operator|&
name|Reldes
argument_list|,
operator|&
name|rkey
argument_list|,
operator|&
name|rel
argument_list|,
operator|&
name|rtid
argument_list|)
condition|)
block|{
comment|/* 			** Oops.  A tuple doesn't exits in 'relation' 			** 			** Maybe it's just a fatal error. 			*/
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|syserr
argument_list|(
literal|"CHECKINTEG: getequal=%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* not a fatal error, what to do? */
name|printf
argument_list|(
literal|"\tNo relation for 'integrities' entry:\n\t"
argument_list|)
expr_stmt|;
name|printup
argument_list|(
operator|&
name|Intdes
argument_list|,
operator|&
name|inent
argument_list|)
expr_stmt|;
if|if
condition|(
name|ask
argument_list|(
literal|"\tRemove 'integrities' entry? "
argument_list|)
condition|)
block|{
if|if
condition|(
name|i
operator|=
name|delete
argument_list|(
operator|&
name|Intdes
argument_list|,
operator|&
name|intid
argument_list|)
condition|)
name|syserr
argument_list|(
literal|"CHECKINTEG: delete=%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
continue|continue;
comment|/* go on to next tuple */
block|}
block|}
else|else
block|{
comment|/* 'relation' entry exists, check for the tree entry */
if|if
condition|(
name|inent
operator|.
name|inttree
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|havetree
argument_list|(
name|inent
operator|.
name|intrelid
argument_list|,
name|inent
operator|.
name|intrelowner
argument_list|,
name|mdINTEG
argument_list|)
condition|)
block|{
comment|/* no tuples in 'tree' */
name|printf
argument_list|(
literal|"\tNo tree for:\n\t"
argument_list|)
expr_stmt|;
name|printup
argument_list|(
operator|&
name|Intdes
argument_list|,
operator|&
name|inent
argument_list|)
expr_stmt|;
if|if
condition|(
name|ask
argument_list|(
literal|"\tDelete entry and fix relation status bits? "
argument_list|)
condition|)
block|{
if|if
condition|(
name|i
operator|=
name|delete
argument_list|(
operator|&
name|Intdes
argument_list|,
operator|&
name|inent
argument_list|)
condition|)
name|syserr
argument_list|(
literal|"CHECKINTEG: delete=%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|rel
operator|.
name|relstat
operator|&=
operator|~
name|S_INTEG
expr_stmt|;
if|if
condition|(
name|i
operator|=
name|replace
argument_list|(
operator|&
name|Reldes
argument_list|,
operator|&
name|rtid
argument_list|,
operator|&
name|rel
argument_list|,
name|FALSE
argument_list|)
condition|)
name|syserr
argument_list|(
literal|"CHECKINTEG: replace=%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
continue|continue;
comment|/* go on to next tuple */
block|}
block|}
block|}
if|if
condition|(
operator|(
name|rel
operator|.
name|relstat
operator|&
name|S_INTEG
operator|)
operator|!=
name|S_INTEG
condition|)
block|{
comment|/* bits not set correctly */
name|printf
argument_list|(
literal|"\tIncorrect relation status bits for:\n\t"
argument_list|)
expr_stmt|;
name|printup
argument_list|(
operator|&
name|Reldes
argument_list|,
operator|&
name|rel
argument_list|)
expr_stmt|;
if|if
condition|(
name|ask
argument_list|(
literal|"\tAdjust? "
argument_list|)
condition|)
block|{
name|rel
operator|.
name|relstat
operator||=
name|S_INTEG
expr_stmt|;
if|if
condition|(
name|i
operator|=
name|replace
argument_list|(
operator|&
name|Reldes
argument_list|,
operator|&
name|rtid
argument_list|,
operator|&
name|rel
argument_list|,
name|FALSE
argument_list|)
condition|)
name|syserr
argument_list|(
literal|"CHECKINTEG: replace=%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
continue|continue;
comment|/* go on to next tuple */
block|}
block|}
block|}
block|}
block|}
end_block

end_unit

