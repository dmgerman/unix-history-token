begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ingres.h>
end_include

begin_include
include|#
directive|include
file|<aux.h>
end_include

begin_include
include|#
directive|include
file|<version.h>
end_include

begin_include
include|#
directive|include
file|<access.h>
end_include

begin_include
include|#
directive|include
file|<symbol.h>
end_include

begin_include
include|#
directive|include
file|<opsys.h>
end_include

begin_include
include|#
directive|include
file|<pv.h>
end_include

begin_include
include|#
directive|include
file|<sccs.h>
end_include

begin_include
include|#
directive|include
file|<dir.h>
end_include

begin_macro
name|SCCSID
argument_list|(
argument|@(#)creatdb.c
literal|7.5
literal|11
argument|/
literal|2
argument|/
literal|82
argument_list|)
end_macro

begin_comment
comment|/* **  CREATDB -- create database (or modify database status) ** **	This program creates a new database.  It takes the name of **	the new database (syntax defined below) and a series of **	flags (also defined below). ** **	In order to perform this command, you must be enabled by **	having the U_CREATDB bit set in the user status word **	of the users file. ** **	The -m flag specifies that the directory for the database **	already exists.  It stands for "mounted-file-system", **	because this is presumably when you might use this feature. **	The directory must be empty. ** **	The -e flag specifies that the database already exists. **	It must be in all ways a valid database.  This mode allows **	you to turn flags on and off, as controlled by the other **	flags. ** **	Usage: **		creatdb [flags] databasename ** **	Positional Parameters: **		databasename -- the name of the database to create. **			It must conform to all the usual rules **			about names.  Notice that this is more **			restrictive than UNIX usually is:  names **			must begin with an alpha, and must be **			composed of alphanumerics.  It may be **			at most 14 characters long.  Underscore **			counts as an alphabetic. ** **	Flags: **		-m **			This is a mounted filesystem.  Actually, **			this just means that the directory in which **			the database is to reside already exists. **			It must be empty. **		-e **			This database exists.  When the -e flag is **			specified, the database is brought up to date, **			rather than created.  Things which may be **			changed with the -e flag is anything that **			affects the database status or the relation **			status bits. **		-uXX **			Run as user XX (usercode or login name).  This **			flag may only be used by the INGRES superuser. **			Normally, the database administrator for the **			new database is the user who performs the **			command, but the -u flag allows INGRES to **			give the database to someone else.  Thus, it **			is possible for someone to be a DBA without **			having the U_CREATDB bit set. **		-Fpathname **			Use the named file as the database template. **			This is, of course, for debugging use only. **		+-c **			Turn concurrency control on/off.  The default **			for a new database depends on the dbtmplt file, **			but as of this writing it defaults on. **		+-q **			Turn query modification on/off. **		+-l **			Turn protection violation logging on/off. ** **	Files: **		.../files/dbtmplt<VERSION> **			This file drives the entire program.  The **			syntax of this file is defined below in **			readdbtemp().  Briefly, it tells the database **			status, the relations in an 'empty' database, **			and the status and format of those relations. **		.../data/base **			This directory is the directory in which all **			databases eventually reside.  Each database is **			a subdirectory of this directory. ** **	Return Codes: **		zero -- success **		else -- failure. ** **	Defined Constants: **		MAXRELNS **			This defines the maximum number of relations **			which may be declared in the dbtmplt file. **		MAXDBTEMP **			The maximum size of the dbtmplt file.  This **			determines the maximum number of characters **			which may be in the file. ** **	Compilation Flags: **		xB_UNIX -- if defined, says that we have a "Berkeley **			UNIX" system, with no group id's.  If **			undefined, specifies either a version seven **			UNIX (with 16-bit group id's) or version six **			UNIX (with 8-bit group id's); either way, **			"setgid(getgid())" will work. ** **	Trace Flags: **		-Tn, as below: ** **		1 -- makereln() **		2 -- create() **		10 -- makeadmin() **		12 -- makefile() **		20 -- makedb() ** **	Compilation Instructions: **		% setup creatdb ** **		- which translates to - ** **		% cc -n -O creatdb.c error.c ../../lib/dbulib \ **			../../lib/access ../../lib/utility **		% chmod 4711 a.out */
end_comment

begin_define
define|#
directive|define
name|MAXRELNS
value|20
end_define

begin_define
define|#
directive|define
name|MAXDBTEMP
value|2000
end_define

begin_comment
comment|/* relation& attribute reln descriptors used in access methods */
end_comment

begin_decl_stmt
specifier|extern
name|DESC
name|Reldes
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|DESC
name|Attdes
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|Status
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* user status, set by initucode */
end_comment

begin_decl_stmt
name|int
name|Dbstat
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* database status */
end_comment

begin_decl_stmt
name|int
name|Dbson
decl_stmt|,
name|Dbsoff
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* same: bits turned on, bits turned off */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|reldes
block|{
name|int
name|bitson
decl_stmt|;
name|int
name|bitsoff
decl_stmt|;
name|PARM
name|parmv
index|[
name|PV_MAXPC
index|]
decl_stmt|;
block|}
name|RELDES
typedef|;
end_typedef

begin_decl_stmt
name|RELDES
name|Rellist
index|[
name|MAXRELNS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|Delim
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|Dbpath
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|tTdbu
index|[
literal|100
index|]
decl_stmt|;
end_decl_stmt

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|admin
decl_stmt|;
name|char
name|adminbuf
index|[
literal|100
index|]
decl_stmt|;
specifier|extern
name|struct
name|admin
name|Admin
decl_stmt|;
specifier|extern
name|int
name|errno
decl_stmt|;
specifier|auto
name|int
name|code
decl_stmt|;
name|struct
name|relation
name|relk
decl_stmt|;
name|char
modifier|*
name|database
decl_stmt|;
name|char
modifier|*
modifier|*
name|av
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|user_ovrd
decl_stmt|;
name|int
name|faterr
decl_stmt|;
specifier|register
name|int
modifier|*
name|flagv
decl_stmt|;
name|char
modifier|*
name|dbtmpfile
decl_stmt|;
specifier|extern
name|char
modifier|*
name|Parmvect
index|[]
decl_stmt|;
specifier|extern
name|char
modifier|*
name|Flagvect
index|[]
decl_stmt|;
name|int
name|exists
decl_stmt|;
name|int
modifier|*
name|flaglkup
parameter_list|()
function_decl|;
name|char
modifier|*
name|ztack
parameter_list|()
function_decl|;
specifier|extern
name|char
modifier|*
name|rindex
parameter_list|()
function_decl|;
ifdef|#
directive|ifdef
name|DIRBLKSIZ
name|DIR
modifier|*
name|dir_ptr
decl_stmt|;
comment|/* pointer to '.' */
name|struct
name|direct
modifier|*
name|dir
decl_stmt|;
comment|/* directory entry */
else|#
directive|else
else|DIRBLKSIZ
name|struct
name|dir
name|direct
decl_stmt|;
endif|#
directive|endif
endif|DIRBLKSIZ
name|argv
index|[
name|argc
index|]
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|xSTR1
name|tTrace
argument_list|(
name|argv
argument_list|,
literal|'T'
argument_list|,
name|tTdbu
argument_list|,
literal|100
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	**  Do a lot of magic initialization. 	** 	**	'exists' get set to -1 if the database does not exist 	**		at all, 1 if it exists, and 0 if it does not 	**		exist but there is an indirect pointer to it. 	*/
name|exists
operator|=
literal|0
expr_stmt|;
name|i
operator|=
name|initucode
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|TRUE
argument_list|,
name|NULL
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|i
condition|)
block|{
case|case
literal|0
case|:
case|case
literal|5
case|:
name|exists
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|6
case|:
name|exists
operator|=
literal|0
expr_stmt|;
case|case
literal|1
case|:
break|break;
case|case
literal|2
case|:
name|printf
argument_list|(
literal|"You are not authorized to create this database\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
case|case
literal|3
case|:
name|printf
argument_list|(
literal|"You are not a valid INGRES user\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
case|case
literal|4
case|:
name|printf
argument_list|(
literal|"No database name specified\n"
argument_list|)
expr_stmt|;
name|usage
label|:
name|printf
argument_list|(
literal|"Usage: creatdb [-uname] [-e] [-m] [+-c] [+-q] dbname\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
default|default:
name|syserr
argument_list|(
literal|"initucode %d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|faterr
operator|=
literal|0
expr_stmt|;
name|dbtmpfile
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|av
operator|=
name|Flagvect
init|;
operator|(
name|p
operator|=
operator|*
name|av
operator|)
operator|!=
name|NULL
condition|;
name|av
operator|++
control|)
block|{
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|!=
literal|'-'
operator|&&
name|p
index|[
literal|0
index|]
operator|!=
literal|'+'
condition|)
name|syserr
argument_list|(
literal|"flag %s"
argument_list|,
name|p
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|p
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'F'
case|:
comment|/* dbtmplt file */
if|if
condition|(
name|p
index|[
literal|2
index|]
operator|==
literal|0
condition|)
goto|goto
name|badflag
goto|;
name|dbtmpfile
operator|=
operator|&
name|p
index|[
literal|2
index|]
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
comment|/* trace flag */
break|break;
default|default:
if|if
condition|(
name|flagv
operator|=
name|flaglkup
argument_list|(
name|p
index|[
literal|1
index|]
argument_list|,
name|p
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'+'
condition|)
operator|*
name|flagv
operator|=
literal|1
expr_stmt|;
else|else
operator|*
name|flagv
operator|=
operator|-
literal|1
expr_stmt|;
continue|continue;
block|}
name|badflag
label|:
name|printf
argument_list|(
literal|"bad flag %s\n"
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|faterr
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'+'
condition|)
goto|goto
name|badflag
goto|;
block|}
comment|/* check for legality of database name */
name|database
operator|=
name|Parmvect
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|Parmvect
index|[
literal|1
index|]
operator|!=
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"Too many parameters to creatdb"
argument_list|)
expr_stmt|;
goto|goto
name|usage
goto|;
block|}
if|if
condition|(
operator|!
name|check
argument_list|(
name|database
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"Illegal database name %s\n"
argument_list|,
name|database
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|Status
operator|&
name|U_CREATDB
operator|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"You are not allowed this command\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* end of input checking */
if|if
condition|(
name|faterr
operator|!=
literal|0
condition|)
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
comment|/* now see if it should have been there */
if|if
condition|(
name|flagval
argument_list|(
literal|'m'
argument_list|)
operator|||
name|flagval
argument_list|(
literal|'e'
argument_list|)
condition|)
block|{
if|if
condition|(
name|exists
operator|<=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Database %s does not exist\n"
argument_list|,
name|database
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|xSTR3
if|if
condition|(
name|tTf
argument_list|(
literal|1
argument_list|,
literal|14
argument_list|)
condition|)
name|printf
argument_list|(
literal|"Dbpath = '%s'\n"
argument_list|,
name|Dbpath
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|chdir
argument_list|(
name|Dbpath
argument_list|)
operator|<
literal|0
condition|)
name|syserr
argument_list|(
literal|"chdir %s"
argument_list|,
name|Dbpath
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|flagval
argument_list|(
literal|'e'
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DIRBLKSIZ
comment|/* make certain that it is empty */
if|if
condition|(
operator|(
name|dir_ptr
operator|=
name|opendir
argument_list|(
literal|"."
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|syserr
argument_list|(
literal|0
argument_list|,
literal|"Can't open '.'"
argument_list|)
expr_stmt|;
for|for
control|(
name|dir
operator|=
name|readdir
argument_list|(
name|dir_ptr
argument_list|)
init|;
name|dir
operator|!=
name|NULL
condition|;
name|dir
operator|=
name|readdir
argument_list|(
name|dir_ptr
argument_list|)
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
literal|"."
argument_list|,
name|dir
operator|->
name|d_name
argument_list|)
operator|&&
name|strcmp
argument_list|(
literal|".."
argument_list|,
name|dir
operator|->
name|d_name
argument_list|)
condition|)
name|syserr
argument_list|(
literal|0
argument_list|,
literal|"%s is not empty"
argument_list|,
name|database
argument_list|)
expr_stmt|;
block|}
name|closedir
argument_list|(
name|dir_ptr
argument_list|)
expr_stmt|;
else|#
directive|else
else|DIRBLKSIZ
comment|/* make certain that it is empty */
name|freopen
argument_list|(
literal|"."
argument_list|,
literal|"r"
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
comment|/* Skip "." and ".." entries */
name|fread
argument_list|(
operator|&
name|direct
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|dir
argument_list|)
argument_list|,
literal|1
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
name|fread
argument_list|(
operator|&
name|direct
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|dir
argument_list|)
argument_list|,
literal|1
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
while|while
condition|(
name|fread
argument_list|(
operator|&
name|direct
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|dir
argument_list|)
argument_list|,
literal|1
argument_list|,
name|stdin
argument_list|)
operator|!=
name|EOF
condition|)
block|{
if|if
condition|(
name|direct
operator|.
name|d_ino
operator|!=
literal|0
condition|)
name|syserr
argument_list|(
literal|0
argument_list|,
literal|"%s is not empty"
argument_list|,
name|database
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|DIRBLKSIZ
block|}
else|else
block|{
comment|/* check for correct owner */
name|acc_init
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|bequal
argument_list|(
name|Usercode
argument_list|,
name|Admin
operator|.
name|adhdr
operator|.
name|adowner
argument_list|,
literal|2
argument_list|)
condition|)
name|syserr
argument_list|(
literal|0
argument_list|,
literal|"You are not the DBA for this database"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|exists
operator|>
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Database %s already exists\n"
argument_list|,
name|database
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* create it */
name|i
operator|=
name|fork
argument_list|()
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|syserr
argument_list|(
literal|"fork err"
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
comment|/* split off directory */
operator|*
operator|(
name|p
operator|=
name|rindex
argument_list|(
name|Dbpath
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|=
literal|'\0'
expr_stmt|;
name|chdir
argument_list|(
name|Dbpath
argument_list|)
expr_stmt|;
if|if
condition|(
name|setuid
argument_list|(
name|getuid
argument_list|()
argument_list|)
condition|)
name|syserr
argument_list|(
literal|"setuid"
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|xB_UNIX
if|if
condition|(
name|setgid
argument_list|(
name|getgid
argument_list|()
argument_list|)
condition|)
name|syserr
argument_list|(
literal|"setgid"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|xV7_UNIX
name|umask
argument_list|(
literal|00
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|*
name|p
operator|++
operator|=
literal|'/'
expr_stmt|;
name|execl
argument_list|(
literal|"/bin/mkdir"
argument_list|,
literal|"/bin/mkdir"
argument_list|,
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|execl
argument_list|(
literal|"/usr/bin/mkdir"
argument_list|,
literal|"/usr/bin/mkdir"
argument_list|,
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|syserr
argument_list|(
literal|"exec /bin/mkdir"
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|wait
argument_list|(
operator|&
name|code
argument_list|)
operator|!=
operator|-
literal|1
condition|)
continue|continue;
comment|/* move into data/base directory */
if|if
condition|(
name|chdir
argument_list|(
name|Dbpath
argument_list|)
operator|<
literal|0
condition|)
name|syserr
argument_list|(
literal|"chdir %s: probably bad default mode in mkdir"
argument_list|,
name|Dbpath
argument_list|)
expr_stmt|;
comment|/* change the mode of the database */
name|i
operator|=
name|fork
argument_list|()
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|syserr
argument_list|(
literal|"fork 2"
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|setuid
argument_list|(
name|getuid
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|chmod
argument_list|(
literal|"."
argument_list|,
literal|0777
argument_list|)
condition|)
name|syserr
argument_list|(
literal|"chmod"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|wait
argument_list|(
operator|&
name|code
argument_list|)
operator|!=
operator|-
literal|1
condition|)
empty_stmt|;
if|if
condition|(
operator|(
name|code
operator|&
literal|0377
operator|)
operator|!=
literal|0
condition|)
name|exit
argument_list|(
name|code
argument_list|)
expr_stmt|;
block|}
comment|/* reset 'errno', set from possibly bad chdir */
name|errno
operator|=
literal|0
expr_stmt|;
comment|/* determine name of dbtmplt file and open */
if|if
condition|(
name|dbtmpfile
operator|==
name|NULL
condition|)
block|{
comment|/* create dbtmplt file name */
name|dbtmpfile
operator|=
name|ztack
argument_list|(
name|ztack
argument_list|(
name|Pathname
argument_list|,
literal|"/files/dbtmplt"
argument_list|)
argument_list|,
name|VERSION
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|freopen
argument_list|(
name|dbtmpfile
argument_list|,
literal|"r"
argument_list|,
name|stdin
argument_list|)
operator|==
name|NULL
condition|)
name|syserr
argument_list|(
literal|"dbtmplt open %s"
argument_list|,
name|dbtmpfile
argument_list|)
expr_stmt|;
name|readdbtemp
argument_list|()
expr_stmt|;
comment|/* check for type -- update database status versus create */
if|if
condition|(
name|flagval
argument_list|(
literal|'e'
argument_list|)
condition|)
name|changedb
argument_list|()
expr_stmt|;
else|else
name|makedb
argument_list|()
expr_stmt|;
comment|/* close the cache descriptors */
ifdef|#
directive|ifdef
name|xSTR3
if|if
condition|(
name|tTf
argument_list|(
literal|50
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"Attdes.reltid = "
argument_list|)
expr_stmt|;
name|dumptid
argument_list|(
operator|&
name|Attdes
operator|.
name|reltid
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Reldes.reltid = "
argument_list|)
expr_stmt|;
name|dumptid
argument_list|(
operator|&
name|Reldes
operator|.
name|reltid
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|i
operator|=
name|closer
argument_list|(
operator|&
name|Attdes
argument_list|)
condition|)
name|syserr
argument_list|(
literal|"creatdb: closer(att) %d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|=
name|closer
argument_list|(
operator|&
name|Reldes
argument_list|)
condition|)
name|syserr
argument_list|(
literal|"creatdb: closer(rel) %d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* bring tupcount in 'admin' file to date */
name|Admin
operator|.
name|adreld
operator|.
name|reldum
operator|.
name|reltups
operator|=
name|Reldes
operator|.
name|reldum
operator|.
name|reltups
expr_stmt|;
name|Admin
operator|.
name|adattd
operator|.
name|reldum
operator|.
name|reltups
operator|=
name|Attdes
operator|.
name|reldum
operator|.
name|reltups
expr_stmt|;
comment|/* set other fields as appropriate */
name|Admin
operator|.
name|adreld
operator|.
name|relfp
operator|=
name|Admin
operator|.
name|adattd
operator|.
name|relfp
operator|=
operator|-
literal|1
expr_stmt|;
name|Admin
operator|.
name|adreld
operator|.
name|relopn
operator|=
name|Admin
operator|.
name|adattd
operator|.
name|relopn
operator|=
literal|0
expr_stmt|;
name|Admin
operator|.
name|adhdr
operator|.
name|adlength
operator|=
sizeof|sizeof
name|Admin
operator|.
name|adhdr
expr_stmt|;
name|Admin
operator|.
name|adhdr
operator|.
name|adreldsz
operator|=
name|Admin
operator|.
name|adhdr
operator|.
name|adattdsz
operator|=
sizeof|sizeof
name|Admin
operator|.
name|adreld
expr_stmt|;
name|Admin
operator|.
name|adhdr
operator|.
name|adversion
operator|=
name|DBVERCODE
expr_stmt|;
if|if
condition|(
operator|(
name|admin
operator|=
name|creat
argument_list|(
literal|"admin"
argument_list|,
name|FILEMODE
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|syserr
argument_list|(
literal|"main: creat admin"
argument_list|)
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|admin
argument_list|,
operator|&
name|Admin
argument_list|,
sizeof|sizeof
name|Admin
argument_list|)
operator|!=
sizeof|sizeof
name|Admin
condition|)
name|syserr
argument_list|(
literal|"main: write Admin"
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|admin
argument_list|)
expr_stmt|;
comment|/* exit successfully */
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  Rubout processing. */
end_comment

begin_macro
name|rubproc
argument_list|()
end_macro

begin_block
block|{
name|exit
argument_list|(
operator|-
literal|2
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  READDBTEMP -- read the dbtmplt file and build internal form ** **	This routine reads the dbtmplt file (presumably openned as **	the standard input) and initializes the Dbstat (global database **	status word) and Rellist variables. ** **	Rellist is an array of argument vectors, exactly as passed to **	'create'. ** **	The syntax of the dbtmplt file is as follows: ** **	The first line is a single status word (syntax defined below) **	which is the database status. ** **	The rest of the file is sets of lines separated by blank lines. **	Each set of lines define one relation.  Two blank lines in a **	row or an end-of-file define the end of the file.  Each set **	of lines is broken down: ** **	The first line is in the following format: **		relname:status **	which defines the relation name and the relation status for **	this relation (syntax defined in 'getstat' below).  Status **	may be omitted, in which case a default status is assumed. ** **	Second through n'th lines of each set define the attributes. **	They are of the form: **		attname		format **	separated by a single tab.  'Format' is the same as on a **	'create' statement in QUEL. ** **	Notice that we force the S_CATALOG bit to be on in any **	case.  This is because the changedb() routine will fail **	if the -e flag is ever used on this database if any **	relation appears to be a user relation. ** **	Parameters: **		none ** **	Returns: **		none ** **	Side Effects: **		Dbstat gets the database status. **		Rellist is created with a list of the relations, **			(as parameter vectors -01:2st as passed to **			create).  The entry after the last entry **			has its pv[0] == NULL. ** **	Called By: **		main ** **	Trace Flags: **		none */
end_comment

begin_macro
name|readdbtemp
argument_list|()
end_macro

begin_block
block|{
specifier|static
name|char
name|buf
index|[
name|MAXDBTEMP
index|]
decl_stmt|;
specifier|register
name|RELDES
modifier|*
name|r
decl_stmt|;
specifier|register
name|PARM
modifier|*
name|q
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|j
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|defrstat
decl_stmt|;
specifier|auto
name|int
name|bitson
decl_stmt|,
name|bitsoff
decl_stmt|;
comment|/* read database status */
name|defrstat
operator|=
name|S_CATALOG
operator||
name|S_NOUPDT
operator||
name|S_CONCUR
operator||
name|S_PROTALL
expr_stmt|;
name|bitson
operator|=
name|bitsoff
operator|=
literal|0
expr_stmt|;
name|Dbstat
operator|=
name|getstat
argument_list|(
name|A_DBCONCUR
argument_list|,
operator|&
name|Dbson
argument_list|,
operator|&
name|Dbsoff
argument_list|)
expr_stmt|;
if|if
condition|(
name|Delim
operator|==
literal|':'
condition|)
name|defrstat
operator|=
name|getstat
argument_list|(
name|defrstat
argument_list|,
operator|&
name|bitson
argument_list|,
operator|&
name|bitsoff
argument_list|)
expr_stmt|;
if|if
condition|(
name|Delim
operator|!=
literal|'\n'
condition|)
name|syserr
argument_list|(
literal|"readdbtemp: bad Dbstat %c"
argument_list|,
name|Delim
argument_list|)
expr_stmt|;
comment|/* compute default relation status */
comment|/* start reading relation info */
name|p
operator|=
name|buf
expr_stmt|;
for|for
control|(
name|r
operator|=
name|Rellist
init|;
condition|;
name|r
operator|++
control|)
block|{
name|r
operator|->
name|bitson
operator|=
name|bitson
expr_stmt|;
name|r
operator|->
name|bitsoff
operator|=
name|bitsoff
expr_stmt|;
name|q
operator|=
name|r
operator|->
name|parmv
expr_stmt|;
comment|/* get relation name */
name|q
index|[
literal|1
index|]
operator|.
name|pv_type
operator|=
name|PV_STR
expr_stmt|;
name|q
index|[
literal|1
index|]
operator|.
name|pv_val
operator|.
name|pv_str
operator|=
name|p
expr_stmt|;
name|p
operator|+=
name|getname
argument_list|(
name|p
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* test for end of dbtmplt file */
if|if
condition|(
name|q
index|[
literal|1
index|]
operator|.
name|pv_val
operator|.
name|pv_str
index|[
literal|0
index|]
operator|==
literal|0
condition|)
break|break;
comment|/* get relation status */
name|i
operator|=
name|getstat
argument_list|(
name|defrstat
argument_list|,
operator|&
name|r
operator|->
name|bitson
argument_list|,
operator|&
name|r
operator|->
name|bitsoff
argument_list|)
expr_stmt|;
name|i
operator||=
name|S_CATALOG
expr_stmt|;
comment|/* guarantee system catalog */
name|q
operator|->
name|pv_type
operator|=
name|PV_STR
expr_stmt|;
name|q
operator|++
operator|->
name|pv_val
operator|.
name|pv_str
operator|=
name|p
expr_stmt|;
operator|*
name|p
operator|++
operator|=
operator|(
operator|(
name|i
operator|>>
literal|15
operator|)
operator|&
literal|1
operator|)
operator|+
literal|'0'
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|12
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|-=
literal|3
control|)
operator|*
name|p
operator|++
operator|=
operator|(
operator|(
name|i
operator|>>
name|j
operator|)
operator|&
literal|07
operator|)
operator|+
literal|'0'
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|0
expr_stmt|;
name|q
operator|++
expr_stmt|;
if|if
condition|(
name|Delim
operator|!=
literal|'\n'
condition|)
name|syserr
argument_list|(
literal|"readdbtemp: bad rel %c"
argument_list|,
name|Delim
argument_list|)
expr_stmt|;
comment|/* read attribute names and formats */
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* get attribute name */
name|q
operator|->
name|pv_type
operator|=
name|PV_STR
expr_stmt|;
name|q
operator|++
operator|->
name|pv_val
operator|.
name|pv_str
operator|=
name|p
expr_stmt|;
name|p
operator|+=
name|getname
argument_list|(
name|p
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|q
index|[
operator|-
literal|1
index|]
operator|.
name|pv_val
operator|.
name|pv_str
index|[
literal|0
index|]
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|Delim
operator|!=
literal|'\t'
condition|)
name|syserr
argument_list|(
literal|"readdbtemp: bad att %s, d='%c'"
argument_list|,
name|q
index|[
operator|-
literal|1
index|]
operator|.
name|pv_val
operator|.
name|pv_str
argument_list|,
name|Delim
argument_list|)
expr_stmt|;
comment|/* get attribute type */
name|q
operator|->
name|pv_type
operator|=
name|PV_STR
expr_stmt|;
name|q
operator|++
operator|->
name|pv_val
operator|.
name|pv_str
operator|=
name|p
expr_stmt|;
name|p
operator|+=
name|getname
argument_list|(
name|p
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|Delim
operator|!=
literal|'\n'
condition|)
name|syserr
argument_list|(
literal|"readdbtemp: bad type %c"
argument_list|,
name|Delim
argument_list|)
expr_stmt|;
block|}
comment|/* insert end of argv signal */
operator|(
operator|--
name|q
operator|)
operator|->
name|pv_type
operator|=
name|PV_EOF
expr_stmt|;
comment|/* ad-hoc overflow test */
if|if
condition|(
name|p
operator|>=
operator|&
name|buf
index|[
name|MAXDBTEMP
index|]
condition|)
name|syserr
argument_list|(
literal|"readdbtemp: overflow"
argument_list|)
expr_stmt|;
block|}
comment|/* mark the end of list */
name|q
index|[
literal|1
index|]
operator|.
name|pv_type
operator|=
name|PV_EOF
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  GETSTAT -- Get status word ** **	A status word is read from the standard input (presumably **	'dbtmplt').  The string read is interpreted as an octal **	number.  The syntax is: **		N{+c+N[~N]} **	where N is a number, + is a plus or a minus sign, and c is **	a flag.  '+c+N1[~N2]' groups are interpreted as follows: **	If flag 'c' is set (assuming the preceeding character is a +, **	clear if it is a -), then set (clear) bits N1.  If tilde N2 **	is present, then if flag 'c' is unset (called as '-c' ('+c')) **	clear (set) bits N2; if ~N2 is not present, clear (set) **	bits N1. ** **	For example, an entry might be (but probably isn't): **		1-c-1+q+6~2 **	having the following meaning: ** **	1. Default to the 1 bit set. ** **	2. If the -c flag is specified, clear the '1' bit.  If the **	+c flag is specified, set the '1' bit.  If it is unspecified, **	leave the '1' bit alone. ** **	3. If the +q flag is specified, set the '2' bit and the '4' **	bit.  If the -q flag is specified, clear the '2' bit (but leave **	the '4' bit alone).  If the +-q flag is unspecified, leave **	those bits alone. ** **	Thus, a database with this entry is initially created with **	the 1 bit on.  The '4' bit is a history, which says if the **	'q' flag has ever been set, while the '2' bit tells if it is **	currently set. ** **	Parameters: **		def -- the default to return if there is no number **			there at all. **		bitson -- a pointer to a word to contain all the **			bits to be turned on -- used for the -e flag. **		bitsoff -- same, for bits turned off. ** **	Returns: **		The value of the status word. **		There are no error returns. ** **	Side Effects: **		File activity. ** **	Called By: **		readdbtemp ** **	Trace Flags: **		none */
end_comment

begin_macro
name|getstat
argument_list|(
argument|def
argument_list|,
argument|bitson
argument_list|,
argument|bitsoff
argument_list|)
end_macro

begin_decl_stmt
name|int
name|def
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|bitson
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|bitsoff
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|int
name|stat
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|setbits
decl_stmt|;
name|int
name|clrbits
decl_stmt|;
name|char
name|ctlch
decl_stmt|;
comment|/* reset bits being turned on and off */
operator|*
name|bitson
operator|=
operator|*
name|bitsoff
operator|=
literal|0
expr_stmt|;
comment|/* check to see if a base status wolushs defined */
if|if
condition|(
name|Delim
operator|==
literal|'\n'
operator|||
operator|(
name|Delim
operator|=
name|c
operator|=
name|getchar
argument_list|()
operator|)
operator|<
literal|'0'
operator|||
name|c
operator|>
literal|'7'
condition|)
block|{
comment|/* no, use default */
name|stat
operator|=
name|def
expr_stmt|;
block|}
else|else
block|{
comment|/* read base status field */
name|ungetc
argument_list|(
name|c
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
name|stat
operator|=
name|roctal
argument_list|()
expr_stmt|;
block|}
comment|/* scan '+c+N' entries */
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* check for a flag present */
name|c
operator|=
name|Delim
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
operator|||
name|c
operator|==
literal|':'
condition|)
return|return
operator|(
name|stat
operator|)
return|;
if|if
condition|(
name|c
operator|!=
literal|'+'
operator|&&
name|c
operator|!=
literal|'-'
condition|)
block|{
name|badfmt
label|:
name|syserr
argument_list|(
literal|"getstat: bad fmt %c"
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
comment|/* we have some flag -- get it's value */
name|i
operator|=
name|flagval
argument_list|(
name|getchar
argument_list|()
argument_list|)
expr_stmt|;
comment|/* save sign char on flag */
name|ctlch
operator|=
name|c
expr_stmt|;
comment|/* get sign on associated number and the number */
name|c
operator|=
name|getchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'+'
operator|&&
name|c
operator|!=
literal|'-'
condition|)
goto|goto
name|badfmt
goto|;
name|setbits
operator|=
name|roctal
argument_list|()
expr_stmt|;
comment|/* test whether action on -X same as on +X */
if|if
condition|(
name|Delim
operator|==
literal|'~'
condition|)
block|{
comment|/* they have different bits (see above) */
name|clrbits
operator|=
name|roctal
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|/* on 'creatdb -e -X', use opposite bits of +X */
name|clrbits
operator|=
name|setbits
expr_stmt|;
block|}
comment|/* test for any effect at all */
if|if
condition|(
name|i
operator|==
literal|0
condition|)
continue|continue;
comment|/* test whether we should process the '+N' */
if|if
condition|(
operator|(
name|ctlch
operator|==
literal|'-'
operator|)
condition|?
operator|(
name|i
operator|<
literal|0
operator|)
else|:
operator|(
name|i
operator|>
literal|0
operator|)
condition|)
name|i
operator|=
name|setbits
expr_stmt|;
else|else
block|{
name|i
operator|=
name|clrbits
expr_stmt|;
comment|/* switch sense of bit action */
if|if
condition|(
name|c
operator|==
literal|'+'
condition|)
name|c
operator|=
literal|'-'
expr_stmt|;
else|else
name|c
operator|=
literal|'+'
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
literal|'+'
condition|)
block|{
name|stat
operator||=
name|i
expr_stmt|;
operator|*
name|bitson
operator||=
name|i
expr_stmt|;
block|}
else|else
block|{
name|stat
operator|&=
operator|~
name|i
expr_stmt|;
operator|*
name|bitsoff
operator||=
name|i
expr_stmt|;
block|}
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  ROCTAL -- Read an octal number from standard input. ** **	This routine just reads a single octal number from the standard **	input and returns its value.  It will only read up to a non- **	octal digit.  It will also skip initial and trailing blanks. **	'Delim' is set to the next character in the input stream. ** **	Parameters: **		none ** **	Returns: **		value of octal number in the input stream. ** **	Side Effects: **		'Delim' is set to the delimiter which terminated the **			number. **		File activity on stdin. ** **	Called By: **		getstat() ** **	Trace Flags: **		none */
end_comment

begin_macro
name|roctal
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|int
name|val
decl_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
comment|/* skip initial blanks */
while|while
condition|(
operator|(
name|c
operator|=
name|getchar
argument_list|()
operator|)
operator|==
literal|' '
condition|)
continue|continue;
comment|/* get numeric value */
while|while
condition|(
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'7'
condition|)
block|{
name|val
operator|=
operator|(
name|val
operator|<<
literal|3
operator|)
operator||
operator|(
name|c
operator|-
literal|'0'
operator|)
expr_stmt|;
name|c
operator|=
name|getchar
argument_list|()
expr_stmt|;
block|}
comment|/* skip trailing blanks */
while|while
condition|(
name|c
operator|==
literal|' '
condition|)
name|c
operator|=
name|getchar
argument_list|()
expr_stmt|;
comment|/* set Delim and return numeric value */
name|Delim
operator|=
name|c
expr_stmt|;
return|return
operator|(
name|val
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  GETNAME -- get name from standard input ** **	This function reads a name from the standard input.  A **	name is defined as a string of letters and digits. ** **	The character which caused the scan to terminate is stored **	into 'Delim'. ** **	Parameters: **		ptr -- a pointer to the buffer in which to dump the **			name. ** **	Returns: **		The length of the string. ** **	Side Effects: **		File activity on standard input. ** **	Called By: **		readdbtemp ** **	Trace Flags: **		none */
end_comment

begin_macro
name|getname
argument_list|(
argument|ptr
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|ptr
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|len
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
name|ptr
init|;
operator|(
name|c
operator|=
name|getchar
argument_list|()
operator|)
operator|!=
name|EOF
condition|;
name|len
operator|++
control|)
block|{
comment|/* check for end of name */
if|if
condition|(
operator|(
name|c
operator|<
literal|'a'
operator|||
name|c
operator|>
literal|'z'
operator|)
operator|&&
operator|(
name|c
operator|<
literal|'0'
operator|||
name|c
operator|>
literal|'9'
operator|)
condition|)
break|break;
comment|/* store character into buffer */
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
block|}
comment|/* null-terminate the string */
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
comment|/* store the delimiting character and return length of string */
name|Delim
operator|=
name|c
expr_stmt|;
return|return
operator|(
name|len
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  MAKEDB -- make a database from scratch ** **	This is the code to make a database if the -e flag is off. ** **	The first step is to make a copy of the admin file **	in the internal 'Admin' struct.  This is the code which **	subsequently gets used by openr and opencatalog.  Notice **	that the admin file is not written out; this happens after **	makedb returns. ** **	Next, the physical files are created with one initial (empty) **	page.  This has to happen before the 'create' call so **	that it will be possible to flush 'relation' and 'attribute' **	relation pages during the creates of the 'relation' and **	'attribute' relations.  Other relations don't need this, **	but it is more convenient to be symmetric. ** **	The next step is to create the relations.  Of course, all **	this really is is inserting stuff into the system catalogs. ** **	When we are all done we open the relation relation for the **	admin cache (which of course should exist now).  Thus, **	the closer's in main (which must be around to update the **	tuple count) will work right. ** **	Parameters: **		none ** **	Returns: **		none ** **	Side Effects: **		A database is created!! **		Several files will be created in the current directory, **			one for each relation mentioned in the **			'dbtmplt' file. **		The 'Admin' struct will be filled in. ** **	Called By: **		main ** **	Trace Flags: **		20 */
end_comment

begin_macro
name|makedb
argument_list|()
end_macro

begin_block
block|{
name|DESC
name|d
decl_stmt|;
specifier|register
name|RELDES
modifier|*
name|r
decl_stmt|;
ifdef|#
directive|ifdef
name|xSTR3
if|if
condition|(
name|tTf
argument_list|(
literal|51
argument_list|,
literal|0
argument_list|)
condition|)
name|printf
argument_list|(
literal|">>makedb, Usercode = %s (%u)\n"
argument_list|,
name|Usercode
argument_list|,
name|Usercode
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* create the physical files */
for|for
control|(
name|r
operator|=
name|Rellist
init|;
name|r
operator|->
name|parmv
index|[
literal|1
index|]
operator|.
name|pv_type
operator|!=
name|PV_EOF
condition|;
name|r
operator|++
control|)
block|{
name|makefile
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
comment|/* initialize the admin file internal cache */
name|bmove
argument_list|(
name|Usercode
argument_list|,
name|Admin
operator|.
name|adhdr
operator|.
name|adowner
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|Admin
operator|.
name|adhdr
operator|.
name|adflags
operator|=
name|Dbstat
expr_stmt|;
name|makeadmin
argument_list|(
operator|&
name|Admin
operator|.
name|adreld
argument_list|,
name|Rellist
index|[
literal|0
index|]
operator|.
name|parmv
argument_list|)
expr_stmt|;
name|makeadmin
argument_list|(
operator|&
name|Admin
operator|.
name|adattd
argument_list|,
name|Rellist
index|[
literal|1
index|]
operator|.
name|parmv
argument_list|)
expr_stmt|;
comment|/* done with admin initialization */
comment|/* initialize relations */
for|for
control|(
name|r
operator|=
name|Rellist
init|;
name|r
operator|->
name|parmv
index|[
literal|1
index|]
operator|.
name|pv_type
operator|!=
name|PV_EOF
condition|;
name|r
operator|++
control|)
block|{
name|makereln
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  MAKEADMIN -- manually initialize descriptor for admin file ** **	The relation descriptor pointed to by 'pv' is turned into **	a descriptor, returned in 'd'.  Presumably, this descriptor **	is later written out to the admin file. ** **	Notice that the 'reltid' field is filled in sequentially. **	This means that the relations put into the admin file **	must be created in the same order that they are 'made' **	(by this routine), that the format of tid's must not **	change, and that there can not be over one page worth of **	relations in the admin file.  Our current system currently **	handles this easily. ** **	Parameters: **		d -- the descriptor to get the result. **		pv -- a parm vector in 'create' format, which drives **			this routine. ** **	Returns: **		none ** **	Side Effects: **		none ** **	Called By: **		main ** **	Trace Flags: **		10 */
end_comment

begin_macro
name|makeadmin
argument_list|(
argument|d
argument_list|,
argument|pv
argument_list|)
end_macro

begin_decl_stmt
name|DESC
modifier|*
name|d
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|PARM
name|pv
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|DESC
modifier|*
name|des
decl_stmt|;
specifier|register
name|PARM
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|auto
name|int
name|len
decl_stmt|;
specifier|static
name|int
name|lineno
decl_stmt|;
name|char
name|fname
index|[
name|MAXNAME
operator|+
literal|3
index|]
decl_stmt|;
name|des
operator|=
name|d
expr_stmt|;
name|p
operator|=
name|pv
expr_stmt|;
ifdef|#
directive|ifdef
name|xSTR2
if|if
condition|(
name|tTf
argument_list|(
literal|10
argument_list|,
operator|-
literal|1
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"creating %s in admin\n"
argument_list|,
name|p
index|[
literal|1
index|]
operator|.
name|pv_val
operator|.
name|pv_str
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|i
operator|=
name|oatoi
argument_list|(
name|p
operator|++
operator|->
name|pv_val
operator|.
name|pv_str
argument_list|)
expr_stmt|;
name|ingresname
argument_list|(
name|p
operator|++
operator|->
name|pv_val
operator|.
name|pv_str
argument_list|,
name|Usercode
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|bmove
argument_list|(
name|fname
argument_list|,
name|des
operator|->
name|reldum
operator|.
name|relid
argument_list|,
name|MAXNAME
operator|+
literal|2
argument_list|)
expr_stmt|;
name|des
operator|->
name|reldum
operator|.
name|relstat
operator|=
name|i
expr_stmt|;
name|des
operator|->
name|reldum
operator|.
name|relatts
operator|=
literal|0
expr_stmt|;
name|des
operator|->
name|reldum
operator|.
name|relwid
operator|=
literal|0
expr_stmt|;
name|des
operator|->
name|reldum
operator|.
name|relspec
operator|=
name|M_HEAP
expr_stmt|;
name|des
operator|->
name|reltid
operator|.
name|ltid
operator|=
literal|0
expr_stmt|;
name|des
operator|->
name|reltid
operator|.
name|s_tupid
operator|.
name|line_id
operator|=
name|lineno
operator|++
expr_stmt|;
name|des
operator|->
name|relfp
operator|=
name|open
argument_list|(
name|fname
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|des
operator|->
name|relfp
operator|<
literal|0
condition|)
name|syserr
argument_list|(
literal|"makeadmin: open %s"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|des
operator|->
name|relopn
operator|=
operator|(
name|des
operator|->
name|relfp
operator|+
literal|1
operator|)
operator|*
operator|-
literal|5
expr_stmt|;
comment|/* initialize domain info */
for|for
control|(
init|;
name|p
operator|++
operator|->
name|pv_type
operator|!=
name|PV_EOF
condition|;
name|p
operator|++
control|)
block|{
specifier|register
name|char
name|c
decl_stmt|;
name|c
operator|=
name|p
index|[
literal|0
index|]
operator|.
name|pv_val
operator|.
name|pv_str
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'i'
operator|&&
name|c
operator|!=
literal|'c'
operator|&&
name|c
operator|!=
literal|'f'
condition|)
name|syserr
argument_list|(
literal|"dbtmplt: type err on %s"
argument_list|,
name|p
index|[
literal|0
index|]
operator|.
name|pv_val
operator|.
name|pv_str
argument_list|)
expr_stmt|;
name|des
operator|->
name|relfrmt
index|[
operator|++
operator|(
name|des
operator|->
name|reldum
operator|.
name|relatts
operator|)
index|]
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|atoi
argument_list|(
operator|&
name|p
index|[
literal|0
index|]
operator|.
name|pv_val
operator|.
name|pv_str
index|[
literal|1
index|]
argument_list|,
operator|&
name|len
argument_list|)
operator|!=
literal|0
condition|)
name|syserr
argument_list|(
literal|"makeadmin: len err %s"
argument_list|,
name|p
index|[
literal|0
index|]
operator|.
name|pv_val
operator|.
name|pv_str
argument_list|)
expr_stmt|;
name|des
operator|->
name|relfrml
index|[
name|des
operator|->
name|reldum
operator|.
name|relatts
index|]
operator|=
name|len
expr_stmt|;
name|des
operator|->
name|reloff
index|[
name|des
operator|->
name|reldum
operator|.
name|relatts
index|]
operator|=
name|des
operator|->
name|reldum
operator|.
name|relwid
expr_stmt|;
name|des
operator|->
name|reldum
operator|.
name|relwid
operator|+=
name|len
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  MAKEFILE -- make an 'empty' file for a relation ** **	This routine creates a file with a single (empty) page **	on it -- it is part of the 'create' code, essentially. ** **	Parameters: **		rr -- a pointer to the 'reldes' structure for this **			relation (file). ** **	Returns: **		none ** **	Side Effects: **		A file with one page is created. ** **	Called By: **		makedb **		changedb ** **	Trace Flags: **		12 */
end_comment

begin_expr_stmt
name|makefile
argument_list|(
name|r
argument_list|)
specifier|register
name|RELDES
operator|*
name|r
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|DESC
name|d
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|ingresname
argument_list|(
name|r
operator|->
name|parmv
index|[
literal|1
index|]
operator|.
name|pv_val
operator|.
name|pv_str
argument_list|,
name|Usercode
argument_list|,
name|d
operator|.
name|reldum
operator|.
name|relid
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|xSTR1
if|if
condition|(
name|tTf
argument_list|(
literal|12
argument_list|,
literal|0
argument_list|)
condition|)
name|printf
argument_list|(
literal|"creat %s\n"
argument_list|,
name|d
operator|.
name|reldum
operator|.
name|relid
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|d
operator|.
name|relfp
operator|=
name|creat
argument_list|(
name|d
operator|.
name|reldum
operator|.
name|relid
argument_list|,
name|FILEMODE
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|syserr
argument_list|(
literal|"creat %s"
argument_list|,
name|d
operator|.
name|reldum
operator|.
name|relid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|formatpg
argument_list|(
operator|&
name|d
argument_list|,
operator|(
name|long
operator|)
literal|1
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|syserr
argument_list|(
literal|"makefile: formatpg %d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|d
operator|.
name|relfp
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  MAKERELN -- make a relation ** **	This is the second half of the create, started by 'makefile'. ** **	This routine just sets up argument vectors and calls create, **	which does the real work. ** **	Parameters: **		rr -- a pointer to the Rellist entry for the relation **			to be created. ** **	Returns: **		none ** **	Side Effects: **		Information will be inserted into the 'relation' and **			'attribute' relations. ** **	Called By: **		makedb **		changedb ** **	Trace Flags: **		1 */
end_comment

begin_expr_stmt
name|makereln
argument_list|(
name|r
argument_list|)
specifier|register
name|RELDES
operator|*
name|r
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|pc
decl_stmt|;
specifier|register
name|PARM
modifier|*
name|pv
decl_stmt|;
name|int
name|i
decl_stmt|;
name|pc
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|pv
operator|=
name|r
operator|->
name|parmv
init|;
name|pv
operator|->
name|pv_type
operator|!=
name|PV_EOF
condition|;
name|pv
operator|++
control|)
name|pc
operator|++
expr_stmt|;
name|pv
operator|=
name|r
operator|->
name|parmv
expr_stmt|;
name|i
operator|=
name|create
argument_list|(
name|pc
argument_list|,
name|pv
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
name|syserr
argument_list|(
literal|"create %d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  CHECK -- check database name syntax ** **	The name of a database is checked for validity.  A valid **	database name is not more than 14 characters long, begins **	with an alphabetic character, and contains only alpha- **	numerics.  Underscore is considered numeric. ** **	Parameters: **		p -- the string to check. ** **	Returns: **		TRUE -- ok. **		FALSE -- failure. ** **	Side Effects: **		none ** **	Called By: **		main ** **	Trace Flags: **		none */
end_comment

begin_macro
name|check
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
name|c
decl_stmt|;
comment|/* check string length */
if|if
condition|(
name|length
argument_list|(
name|p
argument_list|)
operator|>
literal|14
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
comment|/* check the first character of the string for alphabetic */
name|c
operator|=
operator|*
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|<
literal|'a'
operator|||
name|c
operator|>
literal|'z'
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
comment|/* check the rest for alphanumeric */
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|p
operator|++
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'_'
condition|)
continue|continue;
if|if
condition|(
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
condition|)
continue|continue;
if|if
condition|(
name|c
operator|>=
literal|'a'
operator|&&
name|c
operator|<=
literal|'z'
condition|)
continue|continue;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  FLAGLKUP -- look up user flag ** **	This routine helps support a variety of user flags.  The **	routine takes a given user flag and looks it up (via a **	very crude linear search) in the 'Flags' vector, and **	returns a pointer to the value. ** **	The 'flag' struct defines the flags.  The 'flagname' field **	is the character which is the flag id, for example, 'c' **	in the flag '-c'.  The 'flagtype' field defines how the **	flag may appear; if negative, only '-c' may appear, if **	positive, only '+c' may appear; if zero, either form may **	appear.  Finally, the 'flagval' field is the value of the **	flag -- it may default any way the user wishes. ** **	Parameters: **		flagname -- the name (as defined above) of the **			flag to be looked up. **		plusminus -- a character, '+' means the '+x' form **			was issued, '-' means the '-x' form was **			issued, something else means *don't care*. **			If an illegal form was issued (that is, **			that does not match the 'flagtype' field **			in the structure), the "not found" return **			is taken. ** **	Returns: **		NULL -- flag not found, or was incorrect type, **			as when the '+x' form is specified in the **			parameters, but the 'Flags' struct says **			that only a '-x' form may appear. **		else -- pointer to the 'flagval' field of the correct **			field in the 'Flags' vector. ** **	Side Effects: **		none ** **	Called By: **		main **		flagval ** **	Trace Flags: **		none */
end_comment

begin_struct
struct|struct
name|flag
block|{
name|char
name|flagname
decl_stmt|;
comment|/* the name of the flag */
name|char
name|flagtype
decl_stmt|;
comment|/* -1: -x form; +1: +x form; 0: both */
name|int
name|flagval
decl_stmt|;
comment|/* user-defined value of the flag */
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|flag
name|Flags
index|[]
init|=
block|{
literal|'q'
block|,
literal|0
block|,
literal|0
block|,
literal|'l'
block|,
literal|0
block|,
literal|0
block|,
literal|'c'
block|,
literal|0
block|,
literal|0
block|,
literal|'e'
block|,
operator|-
literal|1
block|,
literal|0
block|,
literal|'m'
block|,
operator|-
literal|1
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|int
modifier|*
name|flaglkup
parameter_list|(
name|flagname
parameter_list|,
name|plusminus
parameter_list|)
name|char
name|flagname
decl_stmt|;
name|char
name|plusminus
decl_stmt|;
block|{
specifier|register
name|char
name|f
decl_stmt|;
specifier|register
name|struct
name|flag
modifier|*
name|p
decl_stmt|;
specifier|register
name|char
name|pm
decl_stmt|;
name|f
operator|=
name|flagname
expr_stmt|;
name|pm
operator|=
name|plusminus
expr_stmt|;
comment|/* look up flag in vector */
for|for
control|(
name|p
operator|=
name|Flags
init|;
name|p
operator|->
name|flagname
operator|!=
name|f
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
name|p
operator|->
name|flagname
operator|==
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* found in list -- check type */
if|if
condition|(
operator|(
name|pm
operator|==
literal|'+'
operator|&&
name|p
operator|->
name|flagtype
operator|<
literal|0
operator|)
operator|||
operator|(
name|pm
operator|==
literal|'-'
operator|&&
name|p
operator|->
name|flagtype
operator|>
literal|0
operator|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* type is OK -- return pointer to value */
return|return
operator|(
operator|&
name|p
operator|->
name|flagval
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  FLAGVAL -- return value of a flag ** **	Similar to 'flaglkup', except that the value is returned **	instead of the address, and no error return can occur. ** **	Parameters: **		f -- the flag to look up (see flaglkup). ** **	Returns: **		The value of flag 'f'. ** **	Side Effects: **		none ** **	Called By: **		readdbtemp() **		main() ** **	Trace Flags: **		none */
end_comment

begin_expr_stmt
name|flagval
argument_list|(
name|f
argument_list|)
specifier|register
name|char
name|f
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|int
modifier|*
name|flaglkup
parameter_list|()
function_decl|;
comment|/* get value of flag */
name|p
operator|=
operator|(
name|char
operator|*
operator|)
name|flaglkup
argument_list|(
name|f
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* test for error return, syserr if so */
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
name|syserr
argument_list|(
literal|"flagval: flag %c"
argument_list|,
name|f
argument_list|)
expr_stmt|;
comment|/* return value */
return|return
operator|(
operator|*
name|p
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  CHANGEDB -- change status bits for database/relations ** **	In this function we change the status bits for use with the **	-e flag. ** **	This module always uses the differential status **	change information, so that existing bits are not touched. ** **	We check to see that invalid updates, such as turning off **	query modification when it is already on, can not occur. **	This is because of potential syserr's when the system is **	later run, e.g., because of views without instantiations. ** **	In the second step, the database status is updated.  This is **	done strictly in-core, and will be updated in the database **	after we return. ** **	The list of valid relations are then scanned.  For each **	relation listed, a series of steps occurs: ** **	(1) The relation is checked for existance.  If it does not **	exist, it is created, and we return to the beginning of the **	loop.  Notice that we don't have to change modes in this **	case, since it already has been done. ** **	(2) If the relation does exist, we check to see that it **	is a system catalog.  If it is not, we have an error, since **	this is a user relation which just happenned to have the **	same name.  We inform the user and give up. ** **	(3) If the relation exists, is a system catalog, and all **	that, then we check the changes we need to make in the **	bits.  If no change need be made, we continue the loop; **	otherwise, we change the bits and replace the tuple in **	the relation relation. ** **	(4) If the relation being updated was the "relation" or **	"attribute" relation, we change the Admin struct accordingly. ** **	Notice that the result of all this is that all relations **	which might ever be used exist and have the correct status. ** **	Notice that it is fatal for either the attribute or relation **	relations to not exist, since the file is created at the **	same time that relation descriptors are filled in.  This **	should not be a problem, since this is only called on an **	existing database. ** **	As a final note, we open the attribute relation cache not **	because we use it, but because we want to do a closer **	in main() to insure that the tupcount is updated in all **	cases. ** **	Parameters: **		none ** **	Returns: **		none ** **	Side Effects: **		The database is brought up to date, as described **			above. **		Tuples may be added or changed in system catalogs. **		Files may be created. ** **	Called By: **		main ** **	Trace Flags: **		40 */
end_comment

begin_macro
name|changedb
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|RELDES
modifier|*
name|r
decl_stmt|;
name|struct
name|relation
name|relk
decl_stmt|,
name|relt
decl_stmt|;
name|TID
name|tid
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|xSTR1
if|if
condition|(
name|tTf
argument_list|(
literal|40
argument_list|,
literal|0
argument_list|)
condition|)
name|printf
argument_list|(
literal|">>> changedb: Dbson=%o, Dbsoff=%o\n"
argument_list|,
name|Dbson
argument_list|,
name|Dbsoff
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* check to see we aren't doing anything illegal */
if|if
condition|(
name|flagval
argument_list|(
literal|'q'
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syserr
argument_list|(
literal|0
argument_list|,
literal|"I'm sorry, it is not possible to turn query modification off"
argument_list|)
expr_stmt|;
block|}
comment|/* update the database status field */
name|Admin
operator|.
name|adhdr
operator|.
name|adflags
operator|=
operator|(
name|Admin
operator|.
name|adhdr
operator|.
name|adflags
operator||
name|Dbson
operator|)
operator|&
operator|~
name|Dbsoff
expr_stmt|;
comment|/* open the system catalog caches */
name|opencatalog
argument_list|(
literal|"relation"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|opencatalog
argument_list|(
literal|"attribute"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* scan the relation list:- Rellist */
for|for
control|(
name|r
operator|=
name|Rellist
init|;
name|r
operator|->
name|parmv
index|[
literal|1
index|]
operator|.
name|pv_type
operator|!=
name|PV_EOF
condition|;
name|r
operator|++
control|)
block|{
comment|/* see if this relation exists */
name|clearkeys
argument_list|(
operator|&
name|Reldes
argument_list|)
expr_stmt|;
name|setkey
argument_list|(
operator|&
name|Reldes
argument_list|,
operator|&
name|relk
argument_list|,
name|r
operator|->
name|parmv
index|[
literal|1
index|]
operator|.
name|pv_val
operator|.
name|pv_str
argument_list|,
name|RELID
argument_list|)
expr_stmt|;
name|i
operator|=
name|getequal
argument_list|(
operator|&
name|Reldes
argument_list|,
operator|&
name|relk
argument_list|,
operator|&
name|relt
argument_list|,
operator|&
name|tid
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|syserr
argument_list|(
literal|"changedb: getequal"
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
comment|/* doesn't exist, create it */
name|printf
argument_list|(
literal|"Creating relation %s\n"
argument_list|,
name|r
operator|->
name|parmv
index|[
literal|1
index|]
operator|.
name|pv_val
operator|.
name|pv_str
argument_list|)
expr_stmt|;
name|makefile
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|makereln
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* exists -- check to make sure it is the right one */
if|if
condition|(
operator|(
name|relt
operator|.
name|relstat
operator|&
name|S_CATALOG
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* exists as a user reln -- tough luck buster */
name|printf
argument_list|(
literal|"Relation %s already exists -- I cannot bring this database\n"
argument_list|,
name|r
operator|->
name|parmv
index|[
literal|1
index|]
operator|.
name|pv_val
operator|.
name|pv_str
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  up to date.  Sorry.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|3
argument_list|)
expr_stmt|;
block|}
comment|/* it exists and is the right one -- update status */
if|if
condition|(
name|r
operator|->
name|bitson
operator|==
literal|0
operator|&&
name|r
operator|->
name|bitsoff
operator|==
literal|0
condition|)
continue|continue;
comment|/* actual work need be done */
name|relt
operator|.
name|relstat
operator|=
operator|(
name|relt
operator|.
name|relstat
operator||
name|r
operator|->
name|bitson
operator|)
operator|&
operator|~
name|r
operator|->
name|bitsoff
expr_stmt|;
comment|/* replace tuple in relation relation */
name|i
operator|=
name|replace
argument_list|(
operator|&
name|Reldes
argument_list|,
operator|&
name|tid
argument_list|,
operator|&
name|relt
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
name|syserr
argument_list|(
literal|"changedb: replace %d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* update Admin struct if "relation" or "attribute" */
if|if
condition|(
name|sequal
argument_list|(
name|r
operator|->
name|parmv
index|[
literal|1
index|]
operator|.
name|pv_val
operator|.
name|pv_str
argument_list|,
literal|"relation"
argument_list|)
condition|)
name|Admin
operator|.
name|adreld
operator|.
name|reldum
operator|.
name|relstat
operator|=
name|relt
operator|.
name|relstat
expr_stmt|;
elseif|else
if|if
condition|(
name|sequal
argument_list|(
name|r
operator|->
name|parmv
index|[
literal|1
index|]
operator|.
name|pv_val
operator|.
name|pv_str
argument_list|,
literal|"attribute"
argument_list|)
condition|)
name|Admin
operator|.
name|adattd
operator|.
name|reldum
operator|.
name|relstat
operator|=
name|relt
operator|.
name|relstat
expr_stmt|;
block|}
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  READADMIN -- read the admin file into the 'Admin' cache ** **	This routine opens and reads the 'Admin' cache from the **	'admin' file in the current directory. ** **	This version of the routine is modified for creatdb -- **	the '-e' flag is checked, and nothing is performed **	unless it is set. ** **	If not set, the 'relation' and 'attribute' relations **	are opened, and the descriptors for them in the Admin **	struct are filled in with their file descriptors. ** **	Parameters: **		none ** **	Returns: **		none ** **	Side Effects: **		The 'Admin' struct is filled in. **		The 'relation...xx' and 'attribute...xx' files are **			opened. ** **	Called By: **		acc_init (accbuf.c) **		changedb ** **	Trace Flags: **		none */
end_comment

begin_macro
name|readadmin
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|char
name|relname
index|[
name|MAXNAME
operator|+
literal|4
index|]
decl_stmt|;
comment|/* read the stuff from the admin file */
if|if
condition|(
name|flagval
argument_list|(
literal|'e'
argument_list|)
condition|)
block|{
name|i
operator|=
name|open
argument_list|(
literal|"admin"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|syserr
argument_list|(
literal|"readadmin: open admin %d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|checkadmin
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|i
argument_list|)
expr_stmt|;
comment|/* open the physical files for 'relation' and 'attribute' */
name|ingresname
argument_list|(
literal|"relation"
argument_list|,
name|Admin
operator|.
name|adhdr
operator|.
name|adowner
argument_list|,
name|relname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|Admin
operator|.
name|adreld
operator|.
name|relfp
operator|=
name|open
argument_list|(
name|relname
argument_list|,
literal|2
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|syserr
argument_list|(
literal|"readadmin: open `%.14s'"
argument_list|,
name|relname
argument_list|)
expr_stmt|;
name|ingresname
argument_list|(
literal|"attribute"
argument_list|,
name|Admin
operator|.
name|adhdr
operator|.
name|adowner
argument_list|,
name|relname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|Admin
operator|.
name|adattd
operator|.
name|relfp
operator|=
name|open
argument_list|(
name|relname
argument_list|,
literal|2
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|syserr
argument_list|(
literal|"readadmin: open `%.14s'"
argument_list|,
name|relname
argument_list|)
expr_stmt|;
name|Admin
operator|.
name|adreld
operator|.
name|relopn
operator|=
operator|(
name|Admin
operator|.
name|adreld
operator|.
name|relfp
operator|+
literal|1
operator|)
operator|*
operator|-
literal|5
expr_stmt|;
name|Admin
operator|.
name|adattd
operator|.
name|relopn
operator|=
operator|(
name|Admin
operator|.
name|adattd
operator|.
name|relfp
operator|+
literal|1
operator|)
operator|*
literal|5
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

end_unit

