begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ingres.h>
end_include

begin_include
include|#
directive|include
file|<aux.h>
end_include

begin_include
include|#
directive|include
file|<symbol.h>
end_include

begin_include
include|#
directive|include
file|<access.h>
end_include

begin_include
include|#
directive|include
file|<func.h>
end_include

begin_include
include|#
directive|include
file|<sccs.h>
end_include

begin_macro
name|SCCSID
argument_list|(
argument|@(#)ksort.c
literal|7.1
literal|2
argument|/
literal|5
argument|/
literal|81
argument_list|)
end_macro

begin_define
define|#
directive|define
name|N
value|7
end_define

begin_define
define|#
directive|define
name|MEM
value|(32768 - 2)
end_define

begin_define
define|#
directive|define
name|BUCKETSIZE
value|4
end_define

begin_define
define|#
directive|define
name|ENDKEY
value|MAXDOM + 1
end_define

begin_comment
comment|/* **	Parameters: ** **		argv[1]:	Fileset **		argv[2]:	trace info (see below) **		argv[3]:	file from which Desc is read **		argv[4]:	Infile **		argv[5]:	Outfile ** ** **	Trace info comes from trace flag Z37 passed as the **	second parameter. The bits used are: ** **		0001	main trace info **		0002	secondary trace info **		0004	terciary trace info **		0010	don't truncate temps **		0020	don't unlink temps **		0040	print am page refs **		0100	print am tuple gets **		0200	print tuples as output */
end_comment

begin_decl_stmt
name|char
modifier|*
name|Infile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|Outfile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|DESC
name|Desc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|Descsort
index|[
name|MAXDOM
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|Oiop
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|Trace
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|Tupsize
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|Bucket
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|File
index|[
literal|15
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|Fileset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|Filep
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|Nfiles
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|Nlines
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|Ccount
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|Lspace
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|Tspace
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|int
name|cmpa
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|long
name|Tupsout
decl_stmt|;
end_decl_stmt

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
specifier|extern
name|char
modifier|*
name|Proc_name
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|;
name|unsigned
name|int
name|mem
decl_stmt|;
name|char
modifier|*
name|start
decl_stmt|;
name|int
name|maxkey
decl_stmt|,
name|rev
decl_stmt|;
specifier|extern
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
name|Proc_name
operator|=
literal|"KSORT"
expr_stmt|;
if|if
condition|(
name|argc
operator|!=
literal|6
condition|)
name|syserr
argument_list|(
literal|"argc"
argument_list|)
expr_stmt|;
name|Fileset
operator|=
name|argv
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|atoi
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|,
operator|&
name|Trace
argument_list|)
operator|<
literal|0
condition|)
name|syserr
argument_list|(
literal|"ksort: bad Trace param: %s"
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|open
argument_list|(
name|argv
index|[
literal|3
index|]
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|cant
argument_list|(
name|argv
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|i
argument_list|,
operator|&
name|Desc
argument_list|,
sizeof|sizeof
name|Desc
argument_list|)
operator|<
sizeof|sizeof
name|Desc
condition|)
name|syserr
argument_list|(
literal|"read(Desc)"
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|i
argument_list|)
expr_stmt|;
comment|/* set up Descsort to indicate the sort order for tuple */
comment|/* if domain zero is given prepare to generate "hash bucket" 	** value for tuple */
name|maxkey
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|Desc
operator|.
name|reldum
operator|.
name|relatts
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|j
operator|=
name|Desc
operator|.
name|relgiven
index|[
name|i
index|]
condition|)
block|{
if|if
condition|(
operator|(
name|rev
operator|=
name|j
operator|)
operator|<
literal|0
condition|)
name|j
operator|=
operator|-
name|j
expr_stmt|;
if|if
condition|(
name|maxkey
operator|<
name|j
condition|)
name|maxkey
operator|=
name|j
expr_stmt|;
name|Descsort
index|[
operator|--
name|j
index|]
operator|=
name|rev
operator|<
literal|0
condition|?
operator|-
name|i
else|:
name|i
expr_stmt|;
block|}
name|Descsort
index|[
name|maxkey
index|]
operator|=
name|ENDKEY
expr_stmt|;
comment|/* mark end of list */
name|Tupsize
operator|=
name|Desc
operator|.
name|reldum
operator|.
name|relwid
expr_stmt|;
if|if
condition|(
name|Bucket
operator|=
operator|(
name|Descsort
index|[
literal|0
index|]
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* we will be generating hash bucket */
name|Tupsize
operator|+=
name|BUCKETSIZE
expr_stmt|;
name|Desc
operator|.
name|relfrml
index|[
literal|0
index|]
operator|=
name|BUCKETSIZE
expr_stmt|;
name|Desc
operator|.
name|relfrmt
index|[
literal|0
index|]
operator|=
name|INT
expr_stmt|;
name|Desc
operator|.
name|reloff
index|[
literal|0
index|]
operator|=
name|Desc
operator|.
name|reldum
operator|.
name|relwid
expr_stmt|;
block|}
if|if
condition|(
name|Trace
operator|&
literal|01
condition|)
block|{
name|printf
argument_list|(
literal|"ksort: reldum.relatts is %d\n"
argument_list|,
name|Desc
operator|.
name|reldum
operator|.
name|relatts
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Bucket is %d,Sort is:\n"
argument_list|,
name|Bucket
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|j
operator|=
name|Descsort
index|[
name|i
index|]
operator|)
operator|!=
name|ENDKEY
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"Descsort[%d]=%d\n"
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|=
operator|(
name|maxkey
operator|-
name|Bucket
operator|-
name|Desc
operator|.
name|reldum
operator|.
name|relatts
operator|)
condition|)
name|syserr
argument_list|(
literal|"%d domains missing\n"
argument_list|,
operator|-
name|i
argument_list|)
expr_stmt|;
name|Infile
operator|=
name|argv
index|[
literal|4
index|]
expr_stmt|;
name|Outfile
operator|=
name|argv
index|[
literal|5
index|]
expr_stmt|;
comment|/* get up to 2**15 - 1 bytes of memory for buffers */
comment|/* note that mem must end up positive so that Nlines computation is right */
name|mem
operator|=
name|MEM
expr_stmt|;
comment|/* take at most 2**15 - 1 bytes */
while|while
condition|(
operator|(
name|Lspace
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|malloc
argument_list|(
name|mem
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|mem
operator|-=
literal|1024
expr_stmt|;
comment|/* compute pointers and sizes into buffer memory */
name|Nlines
operator|=
name|mem
operator|/
operator|(
name|Tupsize
operator|+
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|)
expr_stmt|;
name|Tspace
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|Lspace
operator|+
name|Nlines
operator|)
expr_stmt|;
if|if
condition|(
name|Trace
operator|&
literal|01
condition|)
name|printf
argument_list|(
literal|"Tspace=%x,Lspace=%x,Nlines=%x,mem=%d\n"
argument_list|,
name|Tspace
argument_list|,
name|Lspace
argument_list|,
name|Nlines
argument_list|,
name|mem
argument_list|)
expr_stmt|;
comment|/* set up temp files */
name|concat
argument_list|(
name|ztack
argument_list|(
literal|"_SYSS"
argument_list|,
name|Fileset
argument_list|)
argument_list|,
literal|"Xaa"
argument_list|,
name|File
argument_list|)
expr_stmt|;
name|Filep
operator|=
name|File
expr_stmt|;
while|while
condition|(
operator|*
name|Filep
operator|!=
literal|'X'
condition|)
name|Filep
operator|++
expr_stmt|;
name|Filep
operator|++
expr_stmt|;
comment|/* sort stage -- create a bunch of temporaries */
name|Ccount
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|Trace
operator|&
literal|01
condition|)
name|printf
argument_list|(
literal|"sorting\n"
argument_list|)
expr_stmt|;
name|sort
argument_list|()
expr_stmt|;
name|close
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|Trace
operator|&
literal|01
condition|)
block|{
name|printf
argument_list|(
literal|"done sorting\n%ld tuples written to %d files\n"
argument_list|,
name|Tupsout
argument_list|,
name|Nfiles
operator|-
literal|1
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"sort required %ld compares\n"
argument_list|,
name|Ccount
argument_list|)
expr_stmt|;
block|}
comment|/* merge stage -- merge up to N temps into a new temp */
name|Ccount
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|+
name|N
operator|<
name|Nfiles
condition|;
name|i
operator|+=
name|N
control|)
block|{
name|newfile
argument_list|()
expr_stmt|;
name|merge
argument_list|(
name|i
argument_list|,
name|i
operator|+
name|N
argument_list|)
expr_stmt|;
block|}
comment|/* merge last set of temps into target file */
if|if
condition|(
name|i
operator|!=
name|Nfiles
condition|)
block|{
name|oldfile
argument_list|()
expr_stmt|;
name|merge
argument_list|(
name|i
argument_list|,
name|Nfiles
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Trace
operator|&
literal|01
condition|)
block|{
name|printf
argument_list|(
literal|"%ld tuples in out file\n"
argument_list|,
name|Tupsout
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"merge required %ld compares\n"
argument_list|,
name|Ccount
argument_list|)
expr_stmt|;
block|}
name|term
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  SORT */
end_comment

begin_macro
name|sort
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|lp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|done
decl_stmt|;
name|long
name|ntups
decl_stmt|;
name|struct
name|tup_id
name|tid
decl_stmt|,
name|ltid
decl_stmt|;
name|char
modifier|*
name|xp
decl_stmt|;
name|long
name|pageid
decl_stmt|;
name|long
name|rhash
parameter_list|()
function_decl|;
name|done
operator|=
literal|0
expr_stmt|;
name|ntups
operator|=
literal|0
expr_stmt|;
name|Tupsout
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|Desc
operator|.
name|relfp
operator|=
name|open
argument_list|(
name|Infile
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|cant
argument_list|(
name|Infile
argument_list|)
expr_stmt|;
name|Desc
operator|.
name|relopn
operator|=
operator|(
name|Desc
operator|.
name|relfp
operator|+
literal|1
operator|)
operator|*
literal|5
expr_stmt|;
comment|/* initialize tids for full scan */
name|pageid
operator|=
literal|0
expr_stmt|;
name|tid
operator|.
name|line_id
operator|=
operator|-
literal|1
expr_stmt|;
name|stuff_page
argument_list|(
operator|&
name|tid
argument_list|,
operator|&
name|pageid
argument_list|)
expr_stmt|;
name|pageid
operator|=
operator|-
literal|1
expr_stmt|;
name|ltid
operator|.
name|line_id
operator|=
operator|-
literal|1
expr_stmt|;
name|stuff_page
argument_list|(
operator|&
name|ltid
argument_list|,
operator|&
name|pageid
argument_list|)
expr_stmt|;
do|do
block|{
name|cp
operator|=
name|Tspace
expr_stmt|;
name|lp
operator|=
name|Lspace
expr_stmt|;
while|while
condition|(
name|lp
operator|<
name|Lspace
operator|+
name|Nlines
condition|)
block|{
if|if
condition|(
operator|(
name|i
operator|=
name|get
argument_list|(
operator|&
name|Desc
argument_list|,
operator|&
name|tid
argument_list|,
operator|&
name|ltid
argument_list|,
name|cp
argument_list|,
name|TRUE
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|syserr
argument_list|(
literal|"get %d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|Desc
operator|.
name|relfp
argument_list|)
expr_stmt|;
name|Desc
operator|.
name|relopn
operator|=
literal|0
expr_stmt|;
name|done
operator|++
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|Trace
operator|&
literal|0100
condition|)
name|printup
argument_list|(
operator|&
name|Desc
argument_list|,
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|Bucket
condition|)
block|{
comment|/* compute hash bucket and insert at end */
name|pageid
operator|=
name|rhash
argument_list|(
operator|&
name|Desc
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|bmove
argument_list|(
operator|&
name|pageid
argument_list|,
name|cp
operator|+
name|Desc
operator|.
name|reldum
operator|.
name|relwid
argument_list|,
name|BUCKETSIZE
argument_list|)
expr_stmt|;
block|}
operator|*
name|lp
operator|++
operator|=
name|cp
expr_stmt|;
name|cp
operator|+=
name|Tupsize
expr_stmt|;
name|ntups
operator|++
expr_stmt|;
block|}
name|qsort
argument_list|(
name|Lspace
argument_list|,
name|lp
operator|-
name|Lspace
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|,
name|cmpa
argument_list|)
expr_stmt|;
if|if
condition|(
name|done
operator|==
literal|0
operator|||
name|Nfiles
operator|!=
literal|1
condition|)
name|newfile
argument_list|()
expr_stmt|;
else|else
name|oldfile
argument_list|()
expr_stmt|;
while|while
condition|(
name|lp
operator|>
name|Lspace
condition|)
block|{
name|cp
operator|=
operator|*
operator|--
name|lp
expr_stmt|;
name|xp
operator|=
name|cp
expr_stmt|;
if|if
condition|(
operator|(
name|lp
operator|==
name|Lspace
operator|)
operator|||
operator|(
name|cmpa
argument_list|(
operator|&
name|xp
argument_list|,
operator|&
name|lp
index|[
operator|-
literal|1
index|]
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|Trace
operator|&
literal|0200
condition|)
block|{
name|printf
argument_list|(
literal|"writing "
argument_list|)
expr_stmt|;
name|printup
argument_list|(
operator|&
name|Desc
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|i
operator|=
name|fwrite
argument_list|(
name|cp
argument_list|,
literal|1
argument_list|,
name|Tupsize
argument_list|,
name|Oiop
argument_list|)
operator|)
operator|!=
name|Tupsize
condition|)
name|syserr
argument_list|(
literal|"cant write outfile %d (%d)"
argument_list|,
name|i
argument_list|,
name|Nfiles
argument_list|)
expr_stmt|;
name|Tupsout
operator|++
expr_stmt|;
block|}
block|}
name|fclose
argument_list|(
name|Oiop
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|done
operator|==
literal|0
condition|)
do|;
if|if
condition|(
name|Trace
operator|&
literal|01
condition|)
name|printf
argument_list|(
literal|"%ld tuples in\n"
argument_list|,
name|ntups
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  MERGE */
end_comment

begin_struct
struct|struct
name|merg
block|{
name|char
name|tup
index|[
name|MAXTUP
operator|+
name|BUCKETSIZE
index|]
decl_stmt|;
name|int
name|filedes
decl_stmt|;
name|FILE
modifier|*
name|fiop
decl_stmt|;
block|}
struct|;
end_struct

begin_macro
name|merge
argument_list|(
argument|a
argument_list|,
argument|b
argument_list|)
end_macro

begin_decl_stmt
name|int
name|a
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|b
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|merg
modifier|*
name|merg
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|char
modifier|*
name|f
decl_stmt|,
modifier|*
name|yesno
decl_stmt|;
name|struct
name|merg
modifier|*
name|mbuf
index|[
name|N
operator|+
literal|1
index|]
decl_stmt|;
name|char
modifier|*
name|setfil
parameter_list|()
function_decl|;
if|if
condition|(
name|Trace
operator|&
literal|02
condition|)
name|printf
argument_list|(
literal|"merge %d to %d\n"
argument_list|,
name|a
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|merg
operator|=
operator|(
expr|struct
name|merg
operator|*
operator|)
name|Lspace
expr_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|a
init|;
name|i
operator|<
name|b
condition|;
name|i
operator|++
control|)
block|{
name|f
operator|=
name|setfil
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|mbuf
index|[
name|j
index|]
operator|=
name|merg
expr_stmt|;
name|merg
operator|->
name|filedes
operator|=
name|i
expr_stmt|;
if|if
condition|(
operator|(
name|merg
operator|->
name|fiop
operator|=
name|fopen
argument_list|(
name|f
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|cant
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rline
argument_list|(
name|merg
argument_list|)
condition|)
name|j
operator|++
expr_stmt|;
name|merg
operator|++
expr_stmt|;
block|}
name|i
operator|=
name|j
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|Trace
operator|&
literal|04
condition|)
name|printf
argument_list|(
literal|"start merg with %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
while|while
condition|(
name|i
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|Trace
operator|&
literal|04
condition|)
name|printf
argument_list|(
literal|"mintup %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|mintup
argument_list|(
name|mbuf
argument_list|,
name|i
argument_list|,
name|cmpa
argument_list|)
condition|)
block|{
if|if
condition|(
name|fwrite
argument_list|(
name|mbuf
index|[
name|i
index|]
operator|->
name|tup
argument_list|,
literal|1
argument_list|,
name|Tupsize
argument_list|,
name|Oiop
argument_list|)
operator|!=
name|Tupsize
condition|)
name|syserr
argument_list|(
literal|"cant write merge output"
argument_list|)
expr_stmt|;
name|Tupsout
operator|++
expr_stmt|;
block|}
name|merg
operator|=
name|mbuf
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|rline
argument_list|(
name|merg
argument_list|)
condition|)
block|{
name|yesno
operator|=
literal|"not "
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|Trace
operator|&
literal|010
operator|)
condition|)
block|{
comment|/* truncate temporary files to zero length */
name|yesno
operator|=
literal|""
expr_stmt|;
name|close
argument_list|(
name|creat
argument_list|(
name|setfil
argument_list|(
name|merg
operator|->
name|filedes
argument_list|)
argument_list|,
literal|0600
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Trace
operator|&
literal|02
operator|||
name|Trace
operator|&
literal|010
condition|)
name|printf
argument_list|(
literal|"dropping and %struncating %s\n"
argument_list|,
name|yesno
argument_list|,
name|setfil
argument_list|(
name|merg
operator|->
name|filedes
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|--
expr_stmt|;
block|}
block|}
name|fclose
argument_list|(
name|Oiop
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **	Mintup puts the smallest tuple in mbuf[cnt-1]. **	If the tuple is a duplicate of another then **	mintup returns 0, else 1. ** **	Cnt is the number of compares to make; i.e. **	mbuf[cnt] is the last element. */
end_comment

begin_macro
name|mintup
argument_list|(
argument|mbuf
argument_list|,
argument|cnt
argument_list|,
argument|cmpfunc
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|merg
modifier|*
name|mbuf
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cnt
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
function_decl|(
modifier|*
name|cmpfunc
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_block
block|{
specifier|register
name|struct
name|merg
modifier|*
modifier|*
name|next
decl_stmt|,
modifier|*
modifier|*
name|last
decl_stmt|;
name|struct
name|merg
modifier|*
name|temp
decl_stmt|;
specifier|register
name|int
name|nodup
decl_stmt|;
name|int
name|j
decl_stmt|;
name|nodup
operator|=
name|TRUE
expr_stmt|;
name|next
operator|=
name|mbuf
expr_stmt|;
name|last
operator|=
operator|&
name|next
index|[
name|cnt
index|]
expr_stmt|;
while|while
condition|(
name|cnt
operator|--
condition|)
block|{
if|if
condition|(
name|j
operator|=
call|(
modifier|*
name|cmpfunc
call|)
argument_list|(
name|last
argument_list|,
name|next
argument_list|)
condition|)
block|{
comment|/* tuples not equal. keep smallest */
if|if
condition|(
name|j
operator|<
literal|0
condition|)
block|{
comment|/* exchange */
name|temp
operator|=
operator|*
name|last
expr_stmt|;
operator|*
name|last
operator|=
operator|*
name|next
expr_stmt|;
operator|*
name|next
operator|=
name|temp
expr_stmt|;
name|nodup
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
else|else
name|nodup
operator|=
name|FALSE
expr_stmt|;
name|next
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|nodup
operator|)
return|;
block|}
end_block

begin_macro
name|rline
argument_list|(
argument|mp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|merg
modifier|*
name|mp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|merg
modifier|*
name|merg
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|merg
operator|=
name|mp
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|fread
argument_list|(
name|merg
operator|->
name|tup
argument_list|,
literal|1
argument_list|,
name|Tupsize
argument_list|,
name|merg
operator|->
name|fiop
argument_list|)
operator|)
operator|!=
name|Tupsize
condition|)
block|{
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|fclose
argument_list|(
name|merg
operator|->
name|fiop
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|syserr
argument_list|(
literal|"rd err %d on %s"
argument_list|,
name|i
argument_list|,
name|setfil
argument_list|(
name|merg
operator|->
name|filedes
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|newfile
argument_list|()
end_macro

begin_block
block|{
name|char
modifier|*
name|setfil
parameter_list|()
function_decl|;
name|makfile
argument_list|(
name|setfil
argument_list|(
name|Nfiles
argument_list|)
argument_list|)
expr_stmt|;
name|Nfiles
operator|++
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **	Convert the number i to a char **	sequence aa, ab, ..., az, ba, etc. */
end_comment

begin_function
name|char
modifier|*
name|setfil
parameter_list|(
name|i
parameter_list|)
name|int
name|i
decl_stmt|;
block|{
specifier|register
name|int
name|j
decl_stmt|;
name|j
operator|=
name|i
expr_stmt|;
name|j
operator|--
expr_stmt|;
name|Filep
index|[
literal|0
index|]
operator|=
name|j
operator|/
literal|26
operator|+
literal|'a'
expr_stmt|;
name|Filep
index|[
literal|1
index|]
operator|=
name|j
operator|%
literal|26
operator|+
literal|'a'
expr_stmt|;
return|return
operator|(
name|File
operator|)
return|;
block|}
end_function

begin_macro
name|oldfile
argument_list|()
end_macro

begin_block
block|{
name|makfile
argument_list|(
name|Outfile
argument_list|)
expr_stmt|;
name|Tupsout
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **	Create a file by the name "name" **	and place its fio pointer in Oiop */
end_comment

begin_macro
name|makfile
argument_list|(
argument|name
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
operator|(
name|Oiop
operator|=
name|fopen
argument_list|(
name|name
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|cant
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|cant
argument_list|(
argument|f
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|f
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|syserr
argument_list|(
literal|"open %s"
argument_list|,
name|f
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|term
argument_list|(
argument|error
argument_list|)
end_macro

begin_decl_stmt
name|int
name|error
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|Nfiles
operator|==
literal|1
condition|)
name|Nfiles
operator|++
expr_stmt|;
if|if
condition|(
name|Trace
operator|&
literal|020
condition|)
name|printf
argument_list|(
literal|"temp files not removed\n"
argument_list|)
expr_stmt|;
else|else
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|Nfiles
condition|;
name|i
operator|++
control|)
block|{
name|unlink
argument_list|(
name|setfil
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
name|error
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  CMPA -- compare tuples */
end_comment

begin_macro
name|cmpa
argument_list|(
argument|a
argument_list|,
argument|b
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
modifier|*
name|a
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|b
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|af
index|[
literal|4
index|]
decl_stmt|;
name|int
name|bf
index|[
literal|4
index|]
decl_stmt|;
name|char
modifier|*
name|pa
decl_stmt|,
modifier|*
name|pb
decl_stmt|;
specifier|register
name|union
name|anytype
modifier|*
name|tupa
decl_stmt|,
modifier|*
name|tupb
decl_stmt|;
name|int
name|dom
decl_stmt|;
specifier|register
name|int
name|frml
decl_stmt|;
name|int
name|frmt
decl_stmt|;
name|int
name|off
decl_stmt|;
name|int
name|temp
decl_stmt|;
name|int
name|rt
decl_stmt|;
name|char
modifier|*
name|dp
decl_stmt|;
name|pa
operator|=
operator|*
name|a
expr_stmt|;
name|pb
operator|=
operator|*
name|b
expr_stmt|;
name|Ccount
operator|++
expr_stmt|;
name|dp
operator|=
name|Descsort
expr_stmt|;
while|while
condition|(
operator|(
name|temp
operator|=
operator|*
name|dp
operator|++
operator|)
operator|!=
name|ENDKEY
condition|)
block|{
if|if
condition|(
operator|(
name|dom
operator|=
name|temp
operator|)
operator|<
literal|0
condition|)
name|dom
operator|=
operator|-
name|temp
expr_stmt|;
name|frml
operator|=
name|Desc
operator|.
name|relfrml
index|[
name|dom
index|]
expr_stmt|;
name|frmt
operator|=
name|Desc
operator|.
name|relfrmt
index|[
name|dom
index|]
expr_stmt|;
name|off
operator|=
name|Desc
operator|.
name|reloff
index|[
name|dom
index|]
expr_stmt|;
name|tupa
operator|=
operator|(
expr|union
name|anytype
operator|*
operator|)
operator|&
name|pa
index|[
name|off
index|]
expr_stmt|;
name|tupb
operator|=
operator|(
expr|union
name|anytype
operator|*
operator|)
operator|&
name|pb
index|[
name|off
index|]
expr_stmt|;
if|if
condition|(
name|temp
operator|<
literal|0
condition|)
block|{
name|tupb
operator|=
name|tupa
expr_stmt|;
name|tupa
operator|=
operator|(
expr|union
name|anytype
operator|*
operator|)
operator|&
name|pb
index|[
name|off
index|]
expr_stmt|;
block|}
if|if
condition|(
name|frmt
operator|==
name|CHAR
condition|)
block|{
name|frml
operator|&=
literal|0377
expr_stmt|;
if|if
condition|(
name|rt
operator|=
name|scompare
argument_list|(
name|tupb
argument_list|,
name|frml
argument_list|,
name|tupa
argument_list|,
name|frml
argument_list|)
condition|)
return|return
operator|(
name|rt
operator|)
return|;
continue|continue;
block|}
comment|/* domain is a numeric type */
if|if
condition|(
name|bequal
argument_list|(
name|tupa
argument_list|,
name|tupb
argument_list|,
name|frml
argument_list|)
condition|)
continue|continue;
comment|/* copy to even word boundary */
name|bmove
argument_list|(
name|tupa
argument_list|,
name|af
argument_list|,
name|frml
argument_list|)
expr_stmt|;
name|bmove
argument_list|(
name|tupb
argument_list|,
name|bf
argument_list|,
name|frml
argument_list|)
expr_stmt|;
name|tupa
operator|=
operator|(
expr|union
name|anytype
operator|*
operator|)
name|af
expr_stmt|;
name|tupb
operator|=
operator|(
expr|union
name|anytype
operator|*
operator|)
name|bf
expr_stmt|;
switch|switch
condition|(
name|frmt
condition|)
block|{
case|case
name|INT
case|:
switch|switch
condition|(
name|frml
condition|)
block|{
case|case
literal|1
case|:
return|return
operator|(
name|tupa
operator|->
name|i1type
operator|>
name|tupb
operator|->
name|i1type
condition|?
operator|-
literal|1
else|:
literal|1
operator|)
return|;
case|case
literal|2
case|:
return|return
operator|(
name|tupa
operator|->
name|i2type
operator|>
name|tupb
operator|->
name|i2type
condition|?
operator|-
literal|1
else|:
literal|1
operator|)
return|;
case|case
literal|4
case|:
return|return
operator|(
name|tupa
operator|->
name|i4type
operator|>
name|tupb
operator|->
name|i4type
condition|?
operator|-
literal|1
else|:
literal|1
operator|)
return|;
block|}
case|case
name|FLOAT
case|:
switch|switch
condition|(
name|frml
condition|)
block|{
case|case
literal|4
case|:
return|return
operator|(
name|tupa
operator|->
name|f4type
operator|>
name|tupb
operator|->
name|f4type
condition|?
operator|-
literal|1
else|:
literal|1
operator|)
return|;
case|case
literal|8
case|:
return|return
operator|(
name|tupa
operator|->
name|f8type
operator|>
name|tupb
operator|->
name|f8type
condition|?
operator|-
literal|1
else|:
literal|1
operator|)
return|;
block|}
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **	Replacement for access method routine get_page(); **	and associated globals and routines. */
end_comment

begin_decl_stmt
name|struct
name|accbuf
modifier|*
name|Acc_head
decl_stmt|,
name|Accbuf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|Accuread
decl_stmt|,
name|Accuwrite
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|get_page
argument_list|(
name|d
argument_list|,
name|tid
argument_list|)
specifier|register
name|DESC
operator|*
name|d
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|tup_id
modifier|*
name|tid
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|long
name|pageid
decl_stmt|;
specifier|register
name|struct
name|accbuf
modifier|*
name|b
decl_stmt|;
if|if
condition|(
name|Trace
operator|&
literal|0100
condition|)
block|{
name|printf
argument_list|(
literal|"get_page: %.14s,"
argument_list|,
name|d
operator|->
name|reldum
operator|.
name|relid
argument_list|)
expr_stmt|;
name|dumptid
argument_list|(
name|tid
argument_list|)
expr_stmt|;
block|}
name|b
operator|=
name|Acc_head
expr_stmt|;
if|if
condition|(
name|b
operator|==
literal|0
condition|)
block|{
comment|/* initialize buffer */
name|Acc_head
operator|=
operator|&
name|Accbuf
expr_stmt|;
name|b
operator|=
operator|&
name|Accbuf
expr_stmt|;
name|b
operator|->
name|thispage
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|pluck_page
argument_list|(
name|tid
argument_list|,
operator|&
name|pageid
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|thispage
operator|!=
name|pageid
condition|)
block|{
if|if
condition|(
name|Trace
operator|&
literal|040
condition|)
name|printf
argument_list|(
literal|"get_page: rdg pg %ld\n"
argument_list|,
name|pageid
argument_list|)
expr_stmt|;
name|b
operator|->
name|thispage
operator|=
name|pageid
expr_stmt|;
if|if
condition|(
operator|(
name|lseek
argument_list|(
name|d
operator|->
name|relfp
argument_list|,
name|pageid
operator|*
name|PGSIZE
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
operator|)
operator|||
operator|(
operator|(
name|read
argument_list|(
name|d
operator|->
name|relfp
argument_list|,
name|b
argument_list|,
name|PGSIZE
argument_list|)
operator|)
operator|!=
name|PGSIZE
operator|)
condition|)
block|{
name|i
operator|=
name|AMREAD_ERR
expr_stmt|;
block|}
name|Accuread
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|i
operator|)
return|;
block|}
end_block

begin_macro
name|resetacc
argument_list|(
argument|buf
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|accbuf
modifier|*
name|buf
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|acc_err
argument_list|(
argument|err
argument_list|)
end_macro

begin_decl_stmt
name|int
name|err
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|(
name|err
operator|)
return|;
block|}
end_block

end_unit

