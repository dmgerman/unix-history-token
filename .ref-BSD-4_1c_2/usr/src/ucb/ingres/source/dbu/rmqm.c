begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|<pv.h>
end_include

begin_include
include|#
directive|include
file|<ingres.h>
end_include

begin_include
include|#
directive|include
file|<access.h>
end_include

begin_include
include|#
directive|include
file|<aux.h>
end_include

begin_include
include|#
directive|include
file|<catalog.h>
end_include

begin_include
include|#
directive|include
file|<symbol.h>
end_include

begin_include
include|#
directive|include
file|<func.h>
end_include

begin_include
include|#
directive|include
file|<sccs.h>
end_include

begin_macro
name|SCCSID
argument_list|(
argument|@(#)rmqm.c
literal|7.1
literal|2
argument|/
literal|5
argument|/
literal|81
argument_list|)
end_macro

begin_comment
comment|/* **  RMQM -- DBU to delete protection and integrity constraints ** **	Trace Flags: **		43 */
end_comment

begin_decl_stmt
specifier|extern
name|short
name|tTdbu
index|[]
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|int
name|dest_const
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|null_fn
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|fn_def
name|RmqmFn
init|=
block|{
literal|"RMQM"
block|,
name|dest_const
block|,
name|null_fn
block|,
name|null_fn
block|,
name|NULL
block|,
literal|0
block|,
name|tTdbu
block|,
literal|100
block|,
literal|'Z'
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* **  DEST_CONST -- destroy constraints ** **	Parameters: **		pc -- number of parameters in pv **		pv -- pv [0] == 5 destroy permission **			         == 6 destroy integrity constraint **		        pv [1]    relation from which to destroy constrain **		        pv [2] == if (pc != 2) relation from which to delete **				     	constraints **		        pv[3] ... pv[pc - 1] == id of constraint ** **	Returns: **		0 ** **	Side Effects: **		destroys constraints. Involves activity on catalogs 'relation', **		protect, integrities, and tree. ** **	Trace Flags: **		43, 0 */
end_comment

begin_macro
name|dest_const
argument_list|(
argument|pc
argument_list|,
argument|pv
argument_list|)
end_macro

begin_decl_stmt
name|int
name|pc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|PARM
name|pv
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|DESC
name|d
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|mode
decl_stmt|;
specifier|extern
name|struct
name|admin
name|Admin
decl_stmt|;
ifdef|#
directive|ifdef
name|xZTR1
if|if
condition|(
name|tTf
argument_list|(
literal|43
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"dest_const: "
argument_list|)
expr_stmt|;
name|prvect
argument_list|(
name|pc
argument_list|,
name|pv
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|!
operator|(
name|Admin
operator|.
name|adhdr
operator|.
name|adflags
operator|&
name|A_QRYMOD
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|i
operator|=
name|openr
argument_list|(
operator|&
name|d
argument_list|,
operator|-
literal|1
argument_list|,
name|pv
index|[
literal|1
index|]
operator|.
name|pv_val
operator|.
name|pv_str
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|syserr
argument_list|(
literal|"dest_const: openr(%s) %d"
argument_list|,
name|pv
index|[
literal|1
index|]
operator|.
name|pv_val
operator|.
name|pv_str
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|1
operator|||
operator|!
name|bequal
argument_list|(
name|Usercode
argument_list|,
name|d
operator|.
name|reldum
operator|.
name|relowner
argument_list|,
literal|2
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|5202
argument_list|,
name|pv
index|[
literal|1
index|]
operator|.
name|pv_val
operator|.
name|pv_str
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|atoi
argument_list|(
name|pv
index|[
literal|0
index|]
operator|.
name|pv_val
operator|.
name|pv_str
argument_list|,
operator|&
name|mode
argument_list|)
operator|<
literal|0
condition|)
name|syserr
argument_list|(
literal|"rmqm: bad mode: %s"
argument_list|,
name|pv
index|[
literal|0
index|]
operator|.
name|pv_val
operator|.
name|pv_str
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
literal|5
condition|)
name|dest_prot
argument_list|(
operator|&
name|d
argument_list|,
operator|&
name|pv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|mode
operator|==
literal|6
condition|)
name|dest_integ
argument_list|(
operator|&
name|d
argument_list|,
operator|&
name|pv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
else|else
name|syserr
argument_list|(
literal|"dest_const: bad mode %d"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  DEST_INTEG -- directs destruction of integrity constraints ** **	Parameters: **		desc -- descriptor for relation **		intv -- PV_EOF terminated list of id strings, if first element **		        is PV_EOF means "all" ** **	Returns: **		none ** **	Side Effects: **		deletes integrity constraint. Activity on 'relation', integrities, **		and tree. */
end_comment

begin_expr_stmt
name|dest_integ
argument_list|(
name|d
argument_list|,
name|intv
argument_list|)
specifier|register
name|DESC
operator|*
name|d
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|PARM
name|intv
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|extern
name|DESC
name|Intdes
decl_stmt|;
name|struct
name|integrity
name|tuple
decl_stmt|,
name|key
decl_stmt|;
name|struct
name|tree
name|tkey
decl_stmt|;
specifier|register
name|i
operator|,
name|j
expr_stmt|;
name|int
name|tree_const
parameter_list|()
function_decl|;
name|int
name|int_inttree
parameter_list|()
function_decl|;
ifdef|#
directive|ifdef
name|xZTR1
if|if
condition|(
name|tTf
argument_list|(
literal|43
argument_list|,
literal|1
argument_list|)
condition|)
name|printf
argument_list|(
literal|"dest_integ((%s, %s)...)\n"
argument_list|,
name|d
operator|->
name|reldum
operator|.
name|relid
argument_list|,
name|d
operator|->
name|reldum
operator|.
name|relowner
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|i_cat
argument_list|(
literal|"integrities"
argument_list|,
operator|&
name|Intdes
argument_list|,
operator|&
name|key
argument_list|,
name|d
operator|->
name|reldum
operator|.
name|relid
argument_list|,
name|INTRELID
argument_list|,
name|d
operator|->
name|reldum
operator|.
name|relowner
argument_list|,
name|INTRELOWNER
argument_list|,
name|mdINTEG
argument_list|,
operator|&
name|tkey
argument_list|)
expr_stmt|;
if|if
condition|(
name|intv
index|[
literal|0
index|]
operator|.
name|pv_type
operator|==
name|PV_EOF
condition|)
block|{
comment|/* destroy integrity 'relation' ALL */
if|if
condition|(
operator|!
operator|(
name|d
operator|->
name|reldum
operator|.
name|relstat
operator|&
name|S_INTEG
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|del_all
argument_list|(
name|d
argument_list|,
operator|&
name|Intdes
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|tuple
argument_list|,
operator|&
name|tkey
argument_list|,
name|S_INTEG
argument_list|,
name|tree_const
argument_list|,
name|int_inttree
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* destroy integrity 'relation' int {, int} */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|intv
index|[
name|i
index|]
operator|.
name|pv_type
operator|!=
name|PV_EOF
condition|;
name|i
operator|++
control|)
name|del_int
argument_list|(
operator|&
name|Intdes
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|tuple
argument_list|,
operator|&
name|tkey
argument_list|,
name|intv
index|[
name|i
index|]
operator|.
name|pv_val
operator|.
name|pv_str
argument_list|,
name|INTTREE
argument_list|,
name|tree_const
argument_list|,
name|int_inttree
argument_list|)
expr_stmt|;
comment|/* rescan to output error messages */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|i
condition|;
name|j
operator|++
control|)
if|if
condition|(
operator|*
operator|(
name|intv
index|[
name|j
index|]
operator|.
name|pv_val
operator|.
name|pv_str
operator|)
condition|)
name|error
argument_list|(
literal|5203
argument_list|,
name|intv
index|[
name|j
index|]
operator|.
name|pv_val
operator|.
name|pv_str
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* finally, check that there are still integrity constraints 	** on the relation, if not must reset the S_INTEG bit in the relation 	** relation tuple for that relation. 	*/
name|chk_const
argument_list|(
name|d
argument_list|,
operator|&
name|Intdes
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|tuple
argument_list|,
name|d
operator|->
name|reldum
operator|.
name|relid
argument_list|,
name|INTRELID
argument_list|,
name|d
operator|->
name|reldum
operator|.
name|relowner
argument_list|,
name|INTRELOWNER
argument_list|,
name|S_INTEG
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  DEST_PROT -- directs destruction of protection constraints ** **	Parameters: **		desc -- descriptor for relation **		intv -- PV_EOF terminated list of id strings, if first element **		        is PV_EOF means "all" ** **	Returns: **		none ** **	Side Effects: **		deletes protection constraint. Activity on 'relation',  **		protect, and tree. ** **	Trace Flags: **		43, 2 */
end_comment

begin_expr_stmt
name|dest_prot
argument_list|(
name|d
argument_list|,
name|intv
argument_list|)
specifier|register
name|DESC
operator|*
name|d
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|PARM
name|intv
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|extern
name|DESC
name|Prodes
decl_stmt|;
name|struct
name|protect
name|tuple
decl_stmt|,
name|key
decl_stmt|;
name|struct
name|tree
name|tkey
decl_stmt|;
specifier|register
name|i
operator|,
name|j
expr_stmt|;
name|int
name|propermid
decl_stmt|;
name|int
name|prot_protree
parameter_list|()
function_decl|;
name|int
name|tree_prot
parameter_list|()
function_decl|;
ifdef|#
directive|ifdef
name|xZTR1
if|if
condition|(
name|tTf
argument_list|(
literal|43
argument_list|,
literal|2
argument_list|)
condition|)
name|printf
argument_list|(
literal|"dest_prot((%s, %s)...)\n"
argument_list|,
name|d
operator|->
name|reldum
operator|.
name|relid
argument_list|,
name|d
operator|->
name|reldum
operator|.
name|relowner
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|i_cat
argument_list|(
literal|"protect"
argument_list|,
operator|&
name|Prodes
argument_list|,
operator|&
name|key
argument_list|,
name|d
operator|->
name|reldum
operator|.
name|relid
argument_list|,
name|PRORELID
argument_list|,
name|d
operator|->
name|reldum
operator|.
name|relowner
argument_list|,
name|PRORELOWN
argument_list|,
name|mdPROT
argument_list|,
operator|&
name|tkey
argument_list|)
expr_stmt|;
if|if
condition|(
name|intv
index|[
literal|0
index|]
operator|.
name|pv_type
operator|==
name|PV_EOF
condition|)
block|{
comment|/* destroy permit 'relation' ALL */
if|if
condition|(
operator|!
operator|(
name|d
operator|->
name|reldum
operator|.
name|relstat
operator|&
name|S_PROTRET
operator|)
operator|||
operator|!
operator|(
name|d
operator|->
name|reldum
operator|.
name|relstat
operator|&
name|S_PROTALL
operator|)
condition|)
name|r_relstat
argument_list|(
name|d
argument_list|,
name|S_PROTRET
operator||
name|S_PROTALL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|d
operator|->
name|reldum
operator|.
name|relstat
operator|&
name|S_PROTUPS
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|del_all
argument_list|(
name|d
argument_list|,
operator|&
name|Prodes
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|tuple
argument_list|,
operator|&
name|tkey
argument_list|,
name|S_PROTUPS
argument_list|,
name|tree_prot
argument_list|,
name|prot_protree
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* destroy permit 'relation' int {, int} */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|intv
index|[
name|i
index|]
operator|.
name|pv_type
operator|!=
name|PV_EOF
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|j
operator|=
name|atoi
argument_list|(
name|intv
index|[
name|i
index|]
operator|.
name|pv_val
operator|.
name|pv_str
argument_list|,
operator|&
name|propermid
argument_list|)
condition|)
name|syserr
argument_list|(
literal|"dest_prot: bad atoi \"%s\" %d"
argument_list|,
name|intv
index|[
name|i
index|]
operator|.
name|pv_val
operator|.
name|pv_str
argument_list|,
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
name|propermid
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|d
operator|->
name|reldum
operator|.
name|relstat
operator|&
name|S_PROTALL
operator|)
condition|)
block|{
name|r_relstat
argument_list|(
name|d
argument_list|,
name|S_PROTALL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|intv
index|[
name|i
index|]
operator|.
name|pv_val
operator|.
name|pv_str
operator|=
literal|0
expr_stmt|;
block|}
continue|continue;
block|}
elseif|else
if|if
condition|(
name|propermid
operator|==
literal|1
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|d
operator|->
name|reldum
operator|.
name|relstat
operator|&
name|S_PROTRET
operator|)
condition|)
block|{
name|r_relstat
argument_list|(
name|d
argument_list|,
name|S_PROTRET
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|intv
index|[
name|i
index|]
operator|.
name|pv_val
operator|.
name|pv_str
operator|=
literal|0
expr_stmt|;
block|}
continue|continue;
block|}
name|del_int
argument_list|(
operator|&
name|Prodes
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|tuple
argument_list|,
operator|&
name|tkey
argument_list|,
name|intv
index|[
name|i
index|]
operator|.
name|pv_val
operator|.
name|pv_str
argument_list|,
name|PROPERMID
argument_list|,
name|tree_prot
argument_list|,
name|prot_protree
argument_list|)
expr_stmt|;
block|}
comment|/* rescan to output error messages */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|i
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|intv
index|[
name|j
index|]
operator|.
name|pv_val
operator|.
name|pv_str
condition|)
name|error
argument_list|(
literal|5204
argument_list|,
name|intv
index|[
name|j
index|]
operator|.
name|pv_val
operator|.
name|pv_str
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* finally, check that there are still permissions 	** on the relation, if not must reset the S_PROTUPS bit in the relation 	** relation tuple for that relation's relstat. 	*/
name|chk_const
argument_list|(
name|d
argument_list|,
operator|&
name|Prodes
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|tuple
argument_list|,
name|d
operator|->
name|reldum
operator|.
name|relid
argument_list|,
name|PRORELID
argument_list|,
name|d
operator|->
name|reldum
operator|.
name|relowner
argument_list|,
name|PRORELOWN
argument_list|,
name|S_PROTUPS
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  I_CAT -- prepare catalogs for deletin of constraint ** **	Initializes treerelid, treeowner, and treetype fields **	of tree key. Also relation id and owner fields of **	appropriate catalog c_desc, with key 'key'. ** **	Parameters: **		c_name -- name of catalog for opencatalog **		c_desc -- descriptor of catalog **		key -- key for catalog **		relid -- relation.relid for relation to be de-constrained **		id_attno -- attno of relid in constraint catalog c_desc **		relowner -- relation.relowner for rel to be de-constrained **		own_attno -- attno of owner in constrain catalog **		type -- treetype for tree tuple (depends on catalog) **		tkey -- key for tree catalog ** **	Returns: **		none ** **	Side Effects: **		opencatalogs the constraint catalog c_desc, and the "tree" rel **		for READ/WRITE. Sets keys. ** **	Trace Flags: **		43, 3 */
end_comment

begin_macro
name|i_cat
argument_list|(
argument|c_name
argument_list|,
argument|c_desc
argument_list|,
argument|key
argument_list|,
argument|relid
argument_list|,
argument|id_attno
argument_list|,
argument|relowner
argument_list|,
argument|own_attno
argument_list|,
argument|type
argument_list|,
argument|tkey
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|c_name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|DESC
modifier|*
name|c_desc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|key
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|relid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|id_attno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|relowner
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|own_attno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|tree
modifier|*
name|tkey
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|extern
name|DESC
name|Treedes
decl_stmt|;
ifdef|#
directive|ifdef
name|xZTR1
if|if
condition|(
name|tTf
argument_list|(
literal|43
argument_list|,
literal|3
argument_list|)
condition|)
name|printf
argument_list|(
literal|"i_cat(c_name \"%s\", relid %s id_attno %d relowner %s own_attno %d type %d)\n"
argument_list|,
name|c_name
argument_list|,
name|relid
argument_list|,
name|id_attno
argument_list|,
name|relowner
argument_list|,
name|own_attno
argument_list|,
name|type
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|opencatalog
argument_list|(
literal|"tree"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|setkey
argument_list|(
operator|&
name|Treedes
argument_list|,
name|tkey
argument_list|,
name|relid
argument_list|,
name|TREERELID
argument_list|)
expr_stmt|;
name|setkey
argument_list|(
operator|&
name|Treedes
argument_list|,
name|tkey
argument_list|,
name|relowner
argument_list|,
name|TREEOWNER
argument_list|)
expr_stmt|;
name|setkey
argument_list|(
operator|&
name|Treedes
argument_list|,
name|tkey
argument_list|,
operator|&
name|type
argument_list|,
name|TREETYPE
argument_list|)
expr_stmt|;
name|opencatalog
argument_list|(
name|c_name
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|clearkeys
argument_list|(
name|c_desc
argument_list|)
expr_stmt|;
name|setkey
argument_list|(
name|c_desc
argument_list|,
name|key
argument_list|,
name|relid
argument_list|,
name|id_attno
argument_list|)
expr_stmt|;
name|setkey
argument_list|(
name|c_desc
argument_list|,
name|key
argument_list|,
name|relowner
argument_list|,
name|own_attno
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  DEL_ALL -- delete all constraints for a given relation ** **	Deletes all constraints of a given type given by a constraint **	catalog 'c_desc'. Note that Protection constraints 0& 1, given **	by relation.relstat field are not deleted here. ** **	Parameters: **		r_desc -- descriptor for relation to de-constrain (for **			r_relstat) **		c_desc -- constraint catalog descriptor **		key -- c_desc's key **		tuple -- c_desc's tuple (needed because sizeof tuple is not **			known here, so must be allocated beforehand) **		tkey -- tree key with TREERELID and TREERELOWNER setkeyed **		bit -- bits in relstat to reset after deleting all constraints **		tree_pred -- called with constraint tuple to determine **			wether a tree tuple is present or not (as can happen **			for protect catalog) **		tree_field -- should return the treeid from tuple ** **	Returns: **		none ** **	Side Effects: **		tree and constraint catalog activity ** **	Requires: **		del_tree() **		r_relstat() ** **	Called By: **		dest_???? ** **	Trace Flags: **		43, 4 ** **	Syserrs: **		bad find, get, delete, flush_rel ** **	History: **		1/10/79 -- (marc) written */
end_comment

begin_macro
name|del_all
argument_list|(
argument|r_desc
argument_list|,
argument|c_desc
argument_list|,
argument|key
argument_list|,
argument|tuple
argument_list|,
argument|tkey
argument_list|,
argument|bit
argument_list|,
argument|tree_pred
argument_list|,
argument|tree_field
argument_list|)
end_macro

begin_decl_stmt
name|DESC
modifier|*
name|r_desc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|DESC
modifier|*
name|c_desc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|key
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|tuple
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|tree
modifier|*
name|tkey
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|bit
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
function_decl|(
modifier|*
name|tree_pred
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
function_decl|(
modifier|*
name|tree_field
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_block
block|{
name|TID
name|lotid
decl_stmt|,
name|hitid
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|xZTR1
if|if
condition|(
name|tTf
argument_list|(
literal|43
argument_list|,
literal|4
argument_list|)
condition|)
name|printf
argument_list|(
literal|"del_all(bit=0%o)\n"
argument_list|,
name|bit
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|i
operator|=
name|find
argument_list|(
name|c_desc
argument_list|,
name|EXACTKEY
argument_list|,
operator|&
name|lotid
argument_list|,
operator|&
name|hitid
argument_list|,
name|key
argument_list|)
condition|)
name|syserr
argument_list|(
literal|"del_all: find %d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
operator|(
name|i
operator|=
name|get
argument_list|(
name|c_desc
argument_list|,
operator|&
name|lotid
argument_list|,
operator|&
name|hitid
argument_list|,
name|tuple
argument_list|,
name|TRUE
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|kcompare
argument_list|(
name|c_desc
argument_list|,
name|tuple
argument_list|,
name|key
argument_list|)
condition|)
block|{
comment|/* for each constraint of for a relation */
if|if
condition|(
name|i
operator|=
name|delete
argument_list|(
name|c_desc
argument_list|,
operator|&
name|lotid
argument_list|)
condition|)
name|syserr
argument_list|(
literal|"del_all: delete %d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* for crash recovery */
if|if
condition|(
name|i
operator|=
name|flush_rel
argument_list|(
name|c_desc
argument_list|,
name|FALSE
argument_list|)
condition|)
name|syserr
argument_list|(
literal|"del_all: flush_rel %d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* if there is a tree tuple, destroy it */
if|if
condition|(
call|(
modifier|*
name|tree_pred
call|)
argument_list|(
name|tuple
argument_list|)
condition|)
name|del_tree
argument_list|(
name|tkey
argument_list|,
call|(
modifier|*
name|tree_field
call|)
argument_list|(
name|tuple
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|i
operator|!=
literal|1
condition|)
name|syserr
argument_list|(
literal|"del_all: get %d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* turn off bit in relstat field */
name|r_relstat
argument_list|(
name|r_desc
argument_list|,
name|bit
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  DEL_INT -- delete from a constraint catalog a constraint ** **	Parameters: **		c_desc -- catalog descriptor **		key -- catalog key **		tuple -- catalog tuple (needed because tuple size unknown here) **		tkey -- tree key with TREERELID and TREERELOWNER setkeyed **		constid -- integer constraint id in string form **		constattno -- attno of comstraint number in c_desc **		tree_pred -- predicate on existence of tree tuple  **		tree_field -- returns treeid from constrain tuple ** **	Returns: **		none ** **	Side Effects: **		constraint and tree catalog activity. **		*constid set to 0 if constraint id exists. ** **	Requires: **		del_tree() ** **	Called By: **		dest_???? ** **	Trace Flags: **		43, 5 ** **	Syserrs: **		bad atoi (parser error), getequal, delete, flush_rel ** **	History: **		1/10/79 -- (marc) written */
end_comment

begin_macro
name|del_int
argument_list|(
argument|c_desc
argument_list|,
argument|key
argument_list|,
argument|tuple
argument_list|,
argument|tkey
argument_list|,
argument|constid
argument_list|,
argument|constattno
argument_list|,
argument|tree_pred
argument_list|,
argument|tree_field
argument_list|)
end_macro

begin_decl_stmt
name|DESC
modifier|*
name|c_desc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|key
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|tuple
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|tree
modifier|*
name|tkey
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|constid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|constattno
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
function_decl|(
modifier|*
name|tree_pred
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
function_decl|(
modifier|*
name|tree_field
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_block
block|{
name|TID
name|tid
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|constnum
decl_stmt|;
ifdef|#
directive|ifdef
name|xZTR1
if|if
condition|(
name|tTf
argument_list|(
literal|43
argument_list|,
literal|5
argument_list|)
condition|)
name|printf
argument_list|(
literal|"del_int(constid=%s, constattno=%d)\n"
argument_list|,
name|constid
argument_list|,
name|constattno
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|i
operator|=
name|atoi
argument_list|(
name|constid
argument_list|,
operator|&
name|constnum
argument_list|)
condition|)
name|syserr
argument_list|(
literal|"del_int: bad atoi \"%s\" %d"
argument_list|,
name|constid
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|setkey
argument_list|(
name|c_desc
argument_list|,
name|key
argument_list|,
operator|&
name|constnum
argument_list|,
name|constattno
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|i
operator|=
name|getequal
argument_list|(
name|c_desc
argument_list|,
name|key
argument_list|,
name|tuple
argument_list|,
operator|&
name|tid
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|i
operator|=
name|delete
argument_list|(
name|c_desc
argument_list|,
operator|&
name|tid
argument_list|)
condition|)
name|syserr
argument_list|(
literal|"del_int(%d) %d"
argument_list|,
name|constid
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
call|(
modifier|*
name|tree_pred
call|)
argument_list|(
name|tuple
argument_list|)
condition|)
name|del_tree
argument_list|(
name|tkey
argument_list|,
call|(
modifier|*
name|tree_field
call|)
argument_list|(
name|tuple
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|constid
operator|=
literal|'\0'
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|i
operator|!=
literal|1
condition|)
name|syserr
argument_list|(
literal|"dest_int: getequal %d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* bad constnum */
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  DEST_TREE -- destroy a tree tuple with for a given treeid ** **	Deletes all tuples from tree with 'treeid' and previously set **	keys. ** **	Parameters: **		key -- tre key **		treeid -- integer treeid ** **	Returns: **		none ** **	Side Effects: **		tree activity ** **	Trace Flags: **		43, 6 */
end_comment

begin_macro
name|del_tree
argument_list|(
argument|key
argument_list|,
argument|treeid
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|tree
modifier|*
name|key
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|treeid
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|tree
name|tuple
decl_stmt|;
name|TID
name|lotid
decl_stmt|,
name|hitid
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|flag
decl_stmt|;
specifier|extern
name|DESC
name|Treedes
decl_stmt|;
ifdef|#
directive|ifdef
name|xZTR1
if|if
condition|(
name|tTf
argument_list|(
literal|43
argument_list|,
literal|6
argument_list|)
condition|)
name|printf
argument_list|(
literal|"del_tree(treeid=%d)\n"
argument_list|,
name|treeid
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|setkey
argument_list|(
operator|&
name|Treedes
argument_list|,
name|key
argument_list|,
operator|&
name|treeid
argument_list|,
name|TREEID
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|=
name|find
argument_list|(
operator|&
name|Treedes
argument_list|,
name|EXACTKEY
argument_list|,
operator|&
name|lotid
argument_list|,
operator|&
name|hitid
argument_list|,
name|key
argument_list|)
condition|)
name|syserr
argument_list|(
literal|"del_tree: bad find %d treeid %d"
argument_list|,
name|i
argument_list|,
name|treeid
argument_list|)
expr_stmt|;
name|flag
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
operator|(
name|i
operator|=
name|get
argument_list|(
operator|&
name|Treedes
argument_list|,
operator|&
name|lotid
argument_list|,
operator|&
name|hitid
argument_list|,
operator|&
name|tuple
argument_list|,
name|TRUE
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|kcompare
argument_list|(
operator|&
name|Treedes
argument_list|,
operator|&
name|tuple
argument_list|,
name|key
argument_list|)
condition|)
block|{
if|if
condition|(
name|i
operator|=
name|delete
argument_list|(
operator|&
name|Treedes
argument_list|,
operator|&
name|lotid
argument_list|)
condition|)
name|syserr
argument_list|(
literal|"del_tree: delete treeid %d %d"
argument_list|,
name|treeid
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|flag
condition|)
name|flag
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|i
operator|!=
literal|1
condition|)
name|syserr
argument_list|(
literal|"del_tree: bad get %d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|flag
condition|)
name|syserr
argument_list|(
literal|"del_tree: no tuples qualified treeid %d"
argument_list|,
name|treeid
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|=
name|flush_rel
argument_list|(
operator|&
name|Treedes
argument_list|,
name|FALSE
argument_list|)
condition|)
name|syserr
argument_list|(
literal|"del_tree: flush_rel(&Treedes) %d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  CHK_CONST -- check constraint catlg for tuples for a rel, and reset relatin.relstat ** **	Parameters: **		r_desc -- reon desc for de-constrained relation **		c_desc -- catalog desc **		key -- catalog key (here unknown size) **		tuple -- " tuple space " " " " " **		relid -- relation name **		id_attno -- attno of relid **		relowner -- relation owner **		own_attno -- relowner attno **		bit -- bits to reset in relstat if there are no constraints left ** **	Returns: **		none ** **	Side Effects: **		reads catalog, maybe changes relstat field of relation **		relations's r_desc tuple ** **	Trace Flags: **		43, 7 */
end_comment

begin_macro
name|chk_const
argument_list|(
argument|r_desc
argument_list|,
argument|c_desc
argument_list|,
argument|key
argument_list|,
argument|tuple
argument_list|,
argument|relid
argument_list|,
argument|id_attno
argument_list|,
argument|relowner
argument_list|,
argument|own_attno
argument_list|,
argument|bit
argument_list|)
end_macro

begin_decl_stmt
name|DESC
modifier|*
name|r_desc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|DESC
modifier|*
name|c_desc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|key
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|tuple
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|relid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|id_attno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|relowner
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|own_attno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|bit
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|TID
name|tid
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|xZTR1
if|if
condition|(
name|tTf
argument_list|(
literal|43
argument_list|,
literal|7
argument_list|)
condition|)
name|printf
argument_list|(
literal|"chk_const: relid %s id_attno %d relowner %s own_attno %d bit 0%o)\n"
argument_list|,
name|relid
argument_list|,
name|id_attno
argument_list|,
name|relowner
argument_list|,
name|own_attno
argument_list|,
name|bit
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|clearkeys
argument_list|(
name|c_desc
argument_list|)
expr_stmt|;
name|setkey
argument_list|(
name|c_desc
argument_list|,
name|key
argument_list|,
name|relid
argument_list|,
name|id_attno
argument_list|)
expr_stmt|;
name|setkey
argument_list|(
name|c_desc
argument_list|,
name|key
argument_list|,
name|relowner
argument_list|,
name|own_attno
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|getequal
argument_list|(
name|c_desc
argument_list|,
name|key
argument_list|,
name|tuple
argument_list|,
operator|&
name|tid
argument_list|)
operator|)
operator|==
literal|1
condition|)
name|r_relstat
argument_list|(
name|r_desc
argument_list|,
name|bit
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|syserr
argument_list|(
literal|"chk_const: getequal %d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  R_RELSTAT -- set or reset bits in the relation.relstat field ** **	Does the above for relation described by desc. ** **	Parameters: **		d -- relation to have relation.relstat field changed **		bit -- bits to set or reset **		action -- 0 reset, 1 set ** **	Returns: **		none ** **	Side Effects: **		relation is opened for READ/WRITE, relstat changed ** **	Trace Flags: **		43, 8 */
end_comment

begin_expr_stmt
name|r_relstat
argument_list|(
name|d
argument_list|,
name|bit
argument_list|,
name|action
argument_list|)
specifier|register
name|DESC
operator|*
name|d
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|bit
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|action
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|relation
name|tuple
decl_stmt|,
name|key
decl_stmt|;
name|TID
name|tid
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|extern
name|DESC
name|Reldes
decl_stmt|;
ifdef|#
directive|ifdef
name|xZTR1
if|if
condition|(
name|tTf
argument_list|(
literal|43
argument_list|,
literal|8
argument_list|)
condition|)
name|printf
argument_list|(
literal|"r_relstat(bit=0%o, action %d)\n"
argument_list|,
name|bit
argument_list|,
name|action
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|opencatalog
argument_list|(
literal|"relation"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|clearkeys
argument_list|(
operator|&
name|Reldes
argument_list|)
expr_stmt|;
name|setkey
argument_list|(
operator|&
name|Reldes
argument_list|,
operator|&
name|key
argument_list|,
name|d
operator|->
name|reldum
operator|.
name|relid
argument_list|,
name|RELID
argument_list|)
expr_stmt|;
name|setkey
argument_list|(
operator|&
name|Reldes
argument_list|,
operator|&
name|key
argument_list|,
name|d
operator|->
name|reldum
operator|.
name|relowner
argument_list|,
name|RELOWNER
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|=
name|getequal
argument_list|(
operator|&
name|Reldes
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|tuple
argument_list|,
operator|&
name|tid
argument_list|)
condition|)
name|syserr
argument_list|(
literal|"r_relstat: getequal %s, %s, %d"
argument_list|,
name|d
operator|->
name|reldum
operator|.
name|relid
argument_list|,
name|d
operator|->
name|reldum
operator|.
name|relowner
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|action
condition|)
block|{
if|if
condition|(
name|tuple
operator|.
name|relstat
operator|==
operator|(
name|i
operator|=
name|tuple
operator|.
name|relstat
operator||
name|bit
operator|)
condition|)
return|return;
name|tuple
operator|.
name|relstat
operator|=
name|i
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|tuple
operator|.
name|relstat
operator|==
operator|(
name|i
operator|=
name|tuple
operator|.
name|relstat
operator|&
operator|~
name|bit
operator|)
condition|)
return|return;
name|tuple
operator|.
name|relstat
operator|=
name|i
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|i
operator|=
name|replace
argument_list|(
operator|&
name|Reldes
argument_list|,
operator|&
name|tid
argument_list|,
operator|&
name|tuple
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
operator|||
name|i
operator|==
literal|2
condition|)
name|syserr
argument_list|(
literal|"r_relstat: replace %d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|=
name|flush_rel
argument_list|(
operator|&
name|Reldes
argument_list|,
name|FALSE
argument_list|)
condition|)
name|syserr
argument_list|(
literal|"r_relstat: flush_rel(&Reldes) %d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  TREE_CONST -- True predicate ** **	Called indirectly by routines wishing to know if **	a integrity constraint has an associated tree tuple. **	As this is always the case, returns TRUE always. ** **	Parameters: **		i -- integrity tuple ** **	Returns: **		TRUE ** **	Side Effects: **		none ** **	Trace Flags: **		43, 9 */
end_comment

begin_macro
name|tree_const
argument_list|(
argument|i
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|integrity
modifier|*
name|i
decl_stmt|;
end_decl_stmt

begin_block
block|{
ifdef|#
directive|ifdef
name|xZTR1
if|if
condition|(
name|tTf
argument_list|(
literal|43
argument_list|,
literal|9
argument_list|)
condition|)
name|printf
argument_list|(
literal|"tree_const()\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  TREE_PROT -- Protection tuple tree predicate ** **	Called indirectly by routines wishing to know if **	a protection constraint has an associated tree tuple. ** **	Parameters: **		p -- protect tuple ** **	Returns: **		TRUE -- if p->protree != -1 **		FLASE -- otherwise ** **	Side Effects: **		none ** **	Trace Flags: **		43, 9 */
end_comment

begin_macro
name|tree_prot
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|protect
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
ifdef|#
directive|ifdef
name|xZTR1
if|if
condition|(
name|tTf
argument_list|(
literal|43
argument_list|,
literal|9
argument_list|)
condition|)
name|printf
argument_list|(
literal|"tree_prot(p->protree=%d)\n"
argument_list|,
name|p
operator|->
name|protree
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|p
operator|->
name|protree
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
else|else
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  PROT_PROTREE -- get protree field of a protection tuple ** **	Parameters: **		p -- protect tuple ** **	Returns: **		p->protree ** **	Side Effects: **		none ** **	Trace Flags: **		43, 9 */
end_comment

begin_macro
name|prot_protree
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|protect
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
ifdef|#
directive|ifdef
name|xZTR1
if|if
condition|(
name|tTf
argument_list|(
literal|43
argument_list|,
literal|9
argument_list|)
condition|)
name|printf
argument_list|(
literal|"prot_protree(protree=%d)\n"
argument_list|,
name|p
operator|->
name|protree
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|p
operator|->
name|protree
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  INT_INTTREE -- get inttree field of a integrity tuple ** **	Parameters: **		i -- integrity tuple ** **	Returns: **		i->inttree ** **	Side Effects: **		none ** **	Trace Flags: **		43, 9 */
end_comment

begin_macro
name|int_inttree
argument_list|(
argument|i
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|integrity
modifier|*
name|i
decl_stmt|;
end_decl_stmt

begin_block
block|{
ifdef|#
directive|ifdef
name|xZTR1
if|if
condition|(
name|tTf
argument_list|(
literal|43
argument_list|,
literal|9
argument_list|)
condition|)
name|printf
argument_list|(
literal|"int_inttree(inttree=%d)\n"
argument_list|,
name|i
operator|->
name|inttree
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|i
operator|->
name|inttree
operator|)
return|;
block|}
end_block

end_unit

