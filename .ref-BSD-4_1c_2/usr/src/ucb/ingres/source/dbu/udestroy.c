begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|<ingres.h>
end_include

begin_include
include|#
directive|include
file|<aux.h>
end_include

begin_include
include|#
directive|include
file|<catalog.h>
end_include

begin_include
include|#
directive|include
file|<sccs.h>
end_include

begin_macro
name|SCCSID
argument_list|(
argument|@(#)udestroy.c
literal|7.1
literal|2
argument|/
literal|5
argument|/
literal|81
argument_list|)
end_macro

begin_comment
comment|/* **  USERDESTROY -- auxiliary cleanup for destroy of a user relation ** **	userdestroy is called during the destroy of a non system **	relation. If the relation is indexed or is itself an index **	then the appropriate action is taken. If it is indexed, **	then all secondary indices on the relation are also destroyed. **	If it is a secondary index, then the entry in the indexes relation **	is removed and the "relindxd" bit on the primary relation is **	cleared if this was the last index on the relation. ** **	If the relation was a view or had integrity constraints or **	protection constraints on it, then those definitions are **	removed from the appropriate system catalogues. ** **	Parameters: **		reltup -- the relation relation tuple. ** **	Returns: **		none ** **	Side Effects: **		zero or more system catalogues will be updated. ** **	Called By: **		destroy */
end_comment

begin_macro
name|userdestroy
argument_list|(
argument|reltup
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|relation
modifier|*
name|reltup
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|relation
modifier|*
name|rel
decl_stmt|;
name|struct
name|tup_id
name|tid
decl_stmt|,
name|limtid
decl_stmt|;
name|char
name|newrelname
index|[
name|MAXNAME
operator|+
literal|3
index|]
decl_stmt|;
specifier|extern
name|DESC
name|Reldes
decl_stmt|,
name|Attdes
decl_stmt|,
name|Inddes
decl_stmt|;
specifier|extern
name|DESC
name|Treedes
decl_stmt|,
name|Intdes
decl_stmt|,
name|Prodes
decl_stmt|;
name|struct
name|relation
name|relt
decl_stmt|,
name|relk
decl_stmt|;
name|struct
name|index
name|indk
decl_stmt|,
name|indt
decl_stmt|;
name|rel
operator|=
name|reltup
expr_stmt|;
comment|/* handle special case of destroying a secondary index */
if|if
condition|(
name|rel
operator|->
name|relindxd
operator|<
literal|0
condition|)
block|{
name|opencatalog
argument_list|(
literal|"indexes"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|setkey
argument_list|(
operator|&
name|Inddes
argument_list|,
operator|&
name|indk
argument_list|,
name|rel
operator|->
name|relid
argument_list|,
name|IRELIDI
argument_list|)
expr_stmt|;
name|setkey
argument_list|(
operator|&
name|Inddes
argument_list|,
operator|&
name|indk
argument_list|,
name|rel
operator|->
name|relowner
argument_list|,
name|IOWNERP
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|getequal
argument_list|(
operator|&
name|Inddes
argument_list|,
operator|&
name|indk
argument_list|,
operator|&
name|indt
argument_list|,
operator|&
name|tid
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|syserr
argument_list|(
literal|"destroy: geteq(ind,%.12s) %d"
argument_list|,
name|rel
operator|->
name|relid
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* remove entry in INDEX catalog */
name|bmove
argument_list|(
name|indt
operator|.
name|irelidp
argument_list|,
name|newrelname
argument_list|,
name|MAXNAME
argument_list|)
expr_stmt|;
name|bmove
argument_list|(
name|indt
operator|.
name|iownerp
argument_list|,
operator|&
name|newrelname
index|[
name|MAXNAME
index|]
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|delete
argument_list|(
operator|&
name|Inddes
argument_list|,
operator|&
name|tid
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|syserr
argument_list|(
literal|"DESTROY: delete(ind/%.12s) %d"
argument_list|,
name|rel
operator|->
name|relid
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|clearkeys
argument_list|(
operator|&
name|Inddes
argument_list|)
expr_stmt|;
name|setkey
argument_list|(
operator|&
name|Inddes
argument_list|,
operator|&
name|indk
argument_list|,
name|newrelname
argument_list|,
name|IRELIDP
argument_list|)
expr_stmt|;
name|setkey
argument_list|(
operator|&
name|Inddes
argument_list|,
operator|&
name|indk
argument_list|,
operator|&
name|newrelname
index|[
name|MAXNAME
index|]
argument_list|,
name|IOWNERP
argument_list|)
expr_stmt|;
comment|/* reset relindxd field in relation catalog if no other indexes exist on this primary */
if|if
condition|(
name|getequal
argument_list|(
operator|&
name|Inddes
argument_list|,
operator|&
name|indk
argument_list|,
operator|&
name|indt
argument_list|,
operator|&
name|tid
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|clearkeys
argument_list|(
operator|&
name|Reldes
argument_list|)
expr_stmt|;
name|setkey
argument_list|(
operator|&
name|Reldes
argument_list|,
operator|&
name|relk
argument_list|,
name|newrelname
argument_list|,
name|RELID
argument_list|)
expr_stmt|;
name|setkey
argument_list|(
operator|&
name|Reldes
argument_list|,
operator|&
name|relk
argument_list|,
operator|&
name|newrelname
index|[
name|MAXNAME
index|]
argument_list|,
name|RELOWNER
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|=
name|getequal
argument_list|(
operator|&
name|Reldes
argument_list|,
operator|&
name|relk
argument_list|,
operator|&
name|relt
argument_list|,
operator|&
name|tid
argument_list|)
condition|)
name|syserr
argument_list|(
literal|"destroy: getequal(rel, %s) %d"
argument_list|,
name|newrelname
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|relt
operator|.
name|relindxd
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|replace
argument_list|(
operator|&
name|Reldes
argument_list|,
operator|&
name|tid
argument_list|,
operator|&
name|relt
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|syserr
argument_list|(
literal|"destroy: replace(rel) %d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* check special case of destroying primary relation */
if|if
condition|(
name|rel
operator|->
name|relindxd
operator|>
literal|0
condition|)
block|{
name|opencatalog
argument_list|(
literal|"indexes"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|setkey
argument_list|(
operator|&
name|Inddes
argument_list|,
operator|&
name|indk
argument_list|,
name|rel
operator|->
name|relid
argument_list|,
name|IRELIDP
argument_list|)
expr_stmt|;
name|setkey
argument_list|(
operator|&
name|Inddes
argument_list|,
operator|&
name|indk
argument_list|,
name|rel
operator|->
name|relowner
argument_list|,
name|IOWNERP
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|=
name|find
argument_list|(
operator|&
name|Inddes
argument_list|,
name|EXACTKEY
argument_list|,
operator|&
name|tid
argument_list|,
operator|&
name|limtid
argument_list|,
operator|&
name|indk
argument_list|)
condition|)
name|syserr
argument_list|(
literal|"destroy: find(ind,%.12s) %d"
argument_list|,
name|rel
operator|->
name|relid
argument_list|,
name|i
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|i
operator|=
name|get
argument_list|(
operator|&
name|Inddes
argument_list|,
operator|&
name|tid
argument_list|,
operator|&
name|limtid
argument_list|,
operator|&
name|indt
argument_list|,
name|TRUE
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|kcompare
argument_list|(
operator|&
name|Inddes
argument_list|,
operator|&
name|indk
argument_list|,
operator|&
name|indt
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|(
name|i
operator|=
name|delete
argument_list|(
operator|&
name|Inddes
argument_list|,
operator|&
name|tid
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|syserr
argument_list|(
literal|"DESTROY: delete(ind/%.12s) %d"
argument_list|,
name|rel
operator|->
name|relid
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|clearkeys
argument_list|(
operator|&
name|Reldes
argument_list|)
expr_stmt|;
name|purgetup
argument_list|(
operator|&
name|Reldes
argument_list|,
name|indt
operator|.
name|irelidi
argument_list|,
name|RELID
argument_list|,
name|indt
operator|.
name|iownerp
argument_list|,
name|RELOWNER
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|=
name|flush_rel
argument_list|(
operator|&
name|Reldes
argument_list|,
name|FALSE
argument_list|)
condition|)
comment|/* flush for recovery& concurrency reasons */
name|syserr
argument_list|(
literal|"destroy:flush irel %d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|purgetup
argument_list|(
operator|&
name|Attdes
argument_list|,
name|indt
operator|.
name|irelidi
argument_list|,
name|ATTRELID
argument_list|,
name|indt
operator|.
name|iownerp
argument_list|,
name|ATTOWNER
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ingresname
argument_list|(
name|indt
operator|.
name|irelidi
argument_list|,
name|indt
operator|.
name|iownerp
argument_list|,
name|newrelname
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlink
argument_list|(
name|newrelname
argument_list|)
condition|)
name|syserr
argument_list|(
literal|"destroy: unlink(%s)"
argument_list|,
name|newrelname
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
name|syserr
argument_list|(
literal|"destroy: get(ind) %d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* if any integrity constraints exist, remove them */
if|if
condition|(
name|rel
operator|->
name|relstat
operator|&
name|S_INTEG
condition|)
block|{
name|opencatalog
argument_list|(
literal|"integrities"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|purgetup
argument_list|(
operator|&
name|Intdes
argument_list|,
name|rel
operator|->
name|relid
argument_list|,
name|INTRELID
argument_list|,
name|rel
operator|->
name|relowner
argument_list|,
name|INTRELOWNER
argument_list|)
expr_stmt|;
block|}
comment|/* if any protection clauses exist, remove them */
if|if
condition|(
name|rel
operator|->
name|relstat
operator|&
name|S_PROTUPS
condition|)
block|{
name|opencatalog
argument_list|(
literal|"protect"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|purgetup
argument_list|(
operator|&
name|Prodes
argument_list|,
name|rel
operator|->
name|relid
argument_list|,
name|PRORELID
argument_list|,
name|rel
operator|->
name|relowner
argument_list|,
name|PRORELOWN
argument_list|)
expr_stmt|;
block|}
comment|/* remove any trees associated with the relation */
if|if
condition|(
name|rel
operator|->
name|relstat
operator|&
operator|(
name|S_PROTUPS
operator||
name|S_VIEW
operator||
name|S_INTEG
operator|)
condition|)
block|{
name|opencatalog
argument_list|(
literal|"tree"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|purgetup
argument_list|(
operator|&
name|Treedes
argument_list|,
name|rel
operator|->
name|relid
argument_list|,
name|TREERELID
argument_list|,
name|rel
operator|->
name|relowner
argument_list|,
name|TREEOWNER
argument_list|)
expr_stmt|;
block|}
block|}
end_block

end_unit

