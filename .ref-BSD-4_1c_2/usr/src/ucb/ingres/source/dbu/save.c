begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|<pv.h>
end_include

begin_include
include|#
directive|include
file|<ingres.h>
end_include

begin_include
include|#
directive|include
file|<aux.h>
end_include

begin_include
include|#
directive|include
file|<func.h>
end_include

begin_include
include|#
directive|include
file|<opsys.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|xV7_UNIX
end_ifdef

begin_include
include|#
directive|include
file|<sys/timeb.h>
end_include

begin_endif
endif|#
directive|endif
endif|xV7_UNIX
end_endif

begin_include
include|#
directive|include
file|<sccs.h>
end_include

begin_macro
name|SCCSID
argument_list|(
argument|@(#)save.c
literal|7.1
literal|2
argument|/
literal|5
argument|/
literal|81
argument_list|)
end_macro

begin_decl_stmt
specifier|extern
name|short
name|tTdbu
index|[]
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|int
name|save
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|null_fn
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|fn_def
name|SaveFn
init|=
block|{
literal|"SAVE"
block|,
name|save
block|,
name|null_fn
block|,
comment|/* initialization function */
name|null_fn
block|,
name|NULL
block|,
literal|0
block|,
name|tTdbu
block|,
literal|100
block|,
literal|'Z'
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* **  SAVE RELATION UNTIL DATE ** **	This function arranges to save a named relation until a **	specified date. ** **	Parameters:		(pv_type is PV_STR for all of them) **	0 -- relation name **	1 -- month (1 -> 12 or "jan" -> "dec" or a variety of other codes) **	2 -- day (1 -> 31) **	3 -- year (1970 -> ?) ** **	Uses trace flag 44 **	Uses error messages 56xx */
end_comment

begin_decl_stmt
name|int
name|DmSize
index|[
literal|12
index|]
init|=
block|{
literal|31
block|,
literal|28
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|}
decl_stmt|;
end_decl_stmt

begin_macro
name|save
argument_list|(
argument|parmc
argument_list|,
argument|parmv
argument_list|)
end_macro

begin_decl_stmt
name|int
name|parmc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|PARM
name|parmv
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|long
name|date
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|extern
name|DESC
name|Reldes
decl_stmt|;
name|TID
name|tid
decl_stmt|;
specifier|extern
name|char
modifier|*
name|Usercode
decl_stmt|;
name|struct
name|relation
name|relk
decl_stmt|,
name|relt
decl_stmt|;
name|int
name|day
decl_stmt|,
name|month
decl_stmt|,
name|year
decl_stmt|;
ifdef|#
directive|ifdef
name|xV7_UNIX
name|struct
name|timeb
name|timeb
decl_stmt|;
else|#
directive|else
else|xV7_UNIX
specifier|extern
name|int
name|timezone
decl_stmt|;
comment|/* defined by ctime(3) */
endif|#
directive|endif
endif|xV7_UNIX
specifier|extern
name|int
name|dysize
parameter_list|()
function_decl|;
comment|/* ditto */
comment|/* 	**  Validate parameters. 	** 	**	According to my pocket calculator, a 31 bit number will 	**	hold 70 years of accuracy -- hence the 2035 cutoff.  If 	**	this code is still around in 2035, I apologize in 	**	advance. 	*/
if|if
condition|(
name|atoi
argument_list|(
name|parmv
index|[
literal|3
index|]
operator|.
name|pv_val
operator|.
name|pv_str
argument_list|,
operator|&
name|year
argument_list|)
operator|||
name|year
operator|<
literal|1970
operator|||
name|year
operator|>
literal|2035
condition|)
return|return
operator|(
name|error
argument_list|(
literal|5603
argument_list|,
name|parmv
index|[
literal|3
index|]
operator|.
name|pv_val
operator|.
name|pv_str
argument_list|,
literal|0
argument_list|)
operator|)
return|;
comment|/* bad year */
if|if
condition|(
name|monthcheck
argument_list|(
name|parmv
index|[
literal|1
index|]
operator|.
name|pv_val
operator|.
name|pv_str
argument_list|,
operator|&
name|month
argument_list|)
condition|)
return|return
operator|(
name|error
argument_list|(
literal|5601
argument_list|,
name|parmv
index|[
literal|1
index|]
operator|.
name|pv_val
operator|.
name|pv_str
argument_list|,
literal|0
argument_list|)
operator|)
return|;
comment|/* bad month */
if|if
condition|(
name|atoi
argument_list|(
name|parmv
index|[
literal|2
index|]
operator|.
name|pv_val
operator|.
name|pv_str
argument_list|,
operator|&
name|day
argument_list|)
operator|||
name|day
operator|<
literal|1
operator|||
name|day
operator|>
name|monthsize
argument_list|(
operator|--
name|month
argument_list|,
name|year
argument_list|)
condition|)
return|return
operator|(
name|error
argument_list|(
literal|5602
argument_list|,
name|parmv
index|[
literal|2
index|]
operator|.
name|pv_val
operator|.
name|pv_str
argument_list|,
literal|0
argument_list|)
operator|)
return|;
comment|/* bad day */
comment|/* convert date */
comment|/* "date" will be # of days from 1970 for a while */
name|date
operator|=
literal|0
expr_stmt|;
comment|/* do year conversion */
for|for
control|(
name|i
operator|=
literal|1970
init|;
name|i
operator|<
name|year
condition|;
name|i
operator|++
control|)
block|{
name|date
operator|+=
name|dysize
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
comment|/* do month conversion */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|month
condition|;
name|i
operator|++
control|)
name|date
operator|+=
name|DmSize
index|[
name|i
index|]
expr_stmt|;
comment|/* once again, allow for leapyears */
if|if
condition|(
name|month
operator|>=
literal|2
operator|&&
name|year
operator|%
literal|4
operator|==
literal|0
operator|&&
name|year
operator|%
literal|100
operator|!=
literal|0
condition|)
name|date
operator|+=
literal|1
expr_stmt|;
comment|/* do day conversion */
name|date
operator|+=
name|day
operator|-
literal|1
expr_stmt|;
comment|/* we now convert date to be the # of hours since 1970 */
name|date
operator|*=
literal|24
expr_stmt|;
comment|/* do daylight savings computations */
comment|/*<<<<< none now>>>>> */
comment|/* convert to seconds */
name|date
operator|*=
literal|60
operator|*
literal|60
expr_stmt|;
comment|/* adjust to local time */
ifdef|#
directive|ifdef
name|xV7_UNIX
name|ftime
argument_list|(
operator|&
name|timeb
argument_list|)
expr_stmt|;
name|date
operator|+=
operator|(
operator|(
name|long
operator|)
name|timeb
operator|.
name|timezone
operator|)
operator|*
literal|60
expr_stmt|;
else|#
directive|else
else|xV7_UNIX
name|date
operator|+=
name|timezone
expr_stmt|;
endif|#
directive|endif
endif|xV7_UNIX
ifdef|#
directive|ifdef
name|xZTR1
if|if
condition|(
name|tTf
argument_list|(
literal|45
argument_list|,
literal|1
argument_list|)
condition|)
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|ctime
argument_list|(
operator|&
name|date
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* let's check and see if the relation exists */
name|opencatalog
argument_list|(
literal|"relation"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|clearkeys
argument_list|(
operator|&
name|Reldes
argument_list|)
expr_stmt|;
name|setkey
argument_list|(
operator|&
name|Reldes
argument_list|,
operator|&
name|relk
argument_list|,
name|parmv
index|[
literal|0
index|]
operator|.
name|pv_val
operator|.
name|pv_str
argument_list|,
name|RELID
argument_list|)
expr_stmt|;
name|setkey
argument_list|(
operator|&
name|Reldes
argument_list|,
operator|&
name|relk
argument_list|,
name|Usercode
argument_list|,
name|RELOWNER
argument_list|)
expr_stmt|;
if|if
condition|(
name|getequal
argument_list|(
operator|&
name|Reldes
argument_list|,
operator|&
name|relk
argument_list|,
operator|&
name|relt
argument_list|,
operator|&
name|tid
argument_list|)
condition|)
block|{
return|return
operator|(
name|error
argument_list|(
literal|5604
argument_list|,
name|parmv
index|[
literal|0
index|]
operator|.
name|pv_val
operator|.
name|pv_str
argument_list|,
literal|0
argument_list|)
operator|)
return|;
comment|/* relation not found */
block|}
comment|/* check that it is not a system catalog */
if|if
condition|(
name|relt
operator|.
name|relstat
operator|&
name|S_CATALOG
condition|)
return|return
operator|(
name|error
argument_list|(
literal|5600
argument_list|,
name|parmv
index|[
literal|0
index|]
operator|.
name|pv_val
operator|.
name|pv_str
argument_list|,
literal|0
argument_list|)
operator|)
return|;
comment|/* cannot save sys rel */
comment|/* got it; lets change the date */
name|relt
operator|.
name|relsave
operator|=
name|date
expr_stmt|;
ifdef|#
directive|ifdef
name|xZTR2
if|if
condition|(
name|tTf
argument_list|(
literal|45
argument_list|,
literal|2
argument_list|)
condition|)
block|{
name|printup
argument_list|(
operator|&
name|Reldes
argument_list|,
operator|&
name|relt
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|(
name|i
operator|=
name|replace
argument_list|(
operator|&
name|Reldes
argument_list|,
operator|&
name|tid
argument_list|,
operator|&
name|relt
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|syserr
argument_list|(
literal|"SAVE: replace %d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* that's all folks.... */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  MONTHCHECK */
end_comment

begin_struct
struct|struct
name|monthtab
block|{
name|char
modifier|*
name|code
decl_stmt|;
name|int
name|month
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|monthtab
name|Monthtab
index|[]
init|=
block|{
literal|"jan"
block|,
literal|1
block|,
literal|"feb"
block|,
literal|2
block|,
literal|"mar"
block|,
literal|3
block|,
literal|"apr"
block|,
literal|4
block|,
literal|"may"
block|,
literal|5
block|,
literal|"jun"
block|,
literal|6
block|,
literal|"jul"
block|,
literal|7
block|,
literal|"aug"
block|,
literal|8
block|,
literal|"sep"
block|,
literal|9
block|,
literal|"oct"
block|,
literal|10
block|,
literal|"nov"
block|,
literal|11
block|,
literal|"dec"
block|,
literal|12
block|,
literal|"january"
block|,
literal|1
block|,
literal|"february"
block|,
literal|2
block|,
literal|"march"
block|,
literal|3
block|,
literal|"april"
block|,
literal|4
block|,
literal|"june"
block|,
literal|6
block|,
literal|"july"
block|,
literal|7
block|,
literal|"august"
block|,
literal|8
block|,
literal|"september"
block|,
literal|9
block|,
literal|"october"
block|,
literal|10
block|,
literal|"november"
block|,
literal|11
block|,
literal|"december"
block|,
literal|12
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_macro
name|monthcheck
argument_list|(
argument|input
argument_list|,
argument|output
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|input
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|output
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|monthtab
modifier|*
name|p
decl_stmt|;
name|int
name|month
decl_stmt|;
comment|/* month can be an integer, or an alphanumeric code */
if|if
condition|(
name|atoi
argument_list|(
name|input
argument_list|,
operator|&
name|month
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|output
operator|=
name|month
expr_stmt|;
return|return
operator|(
name|month
operator|<
literal|1
operator|||
name|month
operator|>
literal|12
operator|)
return|;
block|}
for|for
control|(
name|p
operator|=
name|Monthtab
init|;
name|p
operator|->
name|code
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
name|sequal
argument_list|(
name|input
argument_list|,
name|p
operator|->
name|code
argument_list|)
condition|)
block|{
operator|*
name|output
operator|=
name|p
operator|->
name|month
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  MONTHSIZE -- determine size of a particular month */
end_comment

begin_macro
name|monthsize
argument_list|(
argument|month
argument_list|,
argument|year
argument_list|)
end_macro

begin_decl_stmt
name|int
name|month
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|year
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|size
decl_stmt|;
specifier|extern
name|int
name|dysize
parameter_list|()
function_decl|;
comment|/* defined in ctime */
name|size
operator|=
name|DmSize
index|[
name|month
index|]
expr_stmt|;
if|if
condition|(
name|month
operator|==
literal|1
operator|&&
name|dysize
argument_list|(
name|year
argument_list|)
operator|==
literal|366
condition|)
comment|/* This is February of a leap year */
name|size
operator|++
expr_stmt|;
return|return
operator|(
name|size
operator|)
return|;
block|}
end_block

end_unit

