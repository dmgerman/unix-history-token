begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"constants.h"
end_include

begin_include
include|#
directive|include
file|"globals.h"
end_include

begin_include
include|#
directive|include
file|<sccs.h>
end_include

begin_macro
name|SCCSID
argument_list|(
argument|@(#)cvar.c
literal|7.1
literal|2
argument|/
literal|5
argument|/
literal|81
argument_list|)
end_macro

begin_comment
comment|/* **  CVAR -- routines to manipulate the c variable trees ** **	C variable trees are binary trees of cvar structs, **	with the c_left< c_right with respect to c_id. */
end_comment

begin_escape
end_escape

begin_comment
comment|/* **  DECL_CVAR -- Declare a C variable ** **	Parameters: **		name -- identifier string (makes its own copy for the tree) **		type  **		indir_level -- level of indirection of declaration **			(- 1 if string) **		block_level -- 0 - global, else local var ** **	Returns: **		none ** **	Side Effects: **		allocates a cvar node, and a copy of name, may put a node **		in a cvar tree (if not previously declared). ** **	Called By: **		the c_variable productions of the parser [grammar.y] */
end_comment

begin_macro
name|decl_cvar
argument_list|(
argument|name
argument_list|,
argument|type
argument_list|,
argument|indir_level
argument_list|,
argument|block_level
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|indir_level
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|block_level
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|cvar
modifier|*
name|bad_node
decl_stmt|;
name|struct
name|cvar
modifier|*
name|dec_var
parameter_list|()
function_decl|;
if|if
condition|(
name|bad_node
operator|=
name|dec_var
argument_list|(
name|name
argument_list|,
name|type
argument_list|,
name|indir_level
argument_list|,
name|block_level
argument_list|,
operator|&
name|C_locals
argument_list|,
operator|&
name|C_globals
argument_list|)
condition|)
block|{
name|yysemerr
argument_list|(
literal|"re-declared identifier"
argument_list|,
name|bad_node
operator|->
name|c_id
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|bad_node
operator|->
name|c_id
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|bad_node
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  DECL_FIELD -- Declare a structures field ** **	Same as decl_cvar() for fields within C records (structs). **	NOTE : if a !0 is returned from dec_var() (i.e. the field **	was already declared) the storage for that node is freed **	but no error has been comitted, as fields may be re-declared. */
end_comment

begin_macro
name|decl_field
argument_list|(
argument|name
argument_list|,
argument|type
argument_list|,
argument|indir_level
argument_list|,
argument|block_level
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|indir_level
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|block_level
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|cvar
modifier|*
name|bad_node
decl_stmt|;
name|struct
name|cvar
modifier|*
name|dec_var
parameter_list|()
function_decl|;
if|if
condition|(
name|bad_node
operator|=
name|dec_var
argument_list|(
name|name
argument_list|,
name|type
argument_list|,
name|indir_level
argument_list|,
name|block_level
argument_list|,
operator|&
name|F_locals
argument_list|,
operator|&
name|F_globals
argument_list|)
condition|)
block|{
name|xfree
argument_list|(
name|bad_node
operator|->
name|c_id
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|bad_node
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  DEC_VAR -- declare a C var or field. ** **	Parameters: **		same as decl_cvar()& decl_field plus **		the local and global tree variables. ** **	Returns: **		0 -- successful **		other -- cvar node pointer that couldn't be entered **			to tree */
end_comment

begin_function
name|struct
name|cvar
modifier|*
name|dec_var
parameter_list|(
name|name
parameter_list|,
name|type
parameter_list|,
name|indir_level
parameter_list|,
name|block_level
parameter_list|,
name|local_tree
parameter_list|,
name|global_tree
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|type
decl_stmt|,
name|indir_level
decl_stmt|,
name|block_level
decl_stmt|;
name|struct
name|cvar
modifier|*
modifier|*
name|local_tree
decl_stmt|,
decl|*
modifier|*
name|global_tree
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|struct
name|cvar
modifier|*
name|cvarp
decl_stmt|;
specifier|register
name|i
expr_stmt|;
name|char
modifier|*
name|salloc
parameter_list|()
function_decl|;
name|cvarp
operator|=
operator|(
expr|struct
name|cvar
operator|*
operator|)
name|nalloc
argument_list|(
sizeof|sizeof
expr|*
name|cvarp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cvarp
condition|)
block|{
name|yysemerr
argument_list|(
literal|"unable to allocate space for a variable"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|cvarp
operator|->
name|c_id
operator|=
name|salloc
argument_list|(
name|name
argument_list|)
operator|)
condition|)
block|{
name|yysemerr
argument_list|(
literal|"no space for variable name"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|cvarp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|cvarp
operator|->
name|c_type
operator|=
name|type
expr_stmt|;
name|cvarp
operator|->
name|c_indir
operator|=
name|indir_level
expr_stmt|;
name|cvarp
operator|->
name|c_left
operator|=
name|cvarp
operator|->
name|c_right
operator|=
literal|0
expr_stmt|;
name|i
operator|=
name|c_enter
argument_list|(
name|cvarp
argument_list|,
name|block_level
operator|>
literal|0
condition|?
name|local_tree
else|:
name|global_tree
argument_list|)
expr_stmt|;
return|return
operator|(
name|i
condition|?
literal|0
else|:
name|cvarp
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **   C_ENTER -- Enter a cvar node in a cvar tree ** **	Parameters: **		node -- the cvar node to insert **		root -- a pointer to the root pointer ** **	Returns: **		1 -- if successful **		0 -- otherwise (node of same name existed ** **	Side Effects: **		If a node of that name didn't exist one is inserted ** **	Called By: **		dec_var() */
end_comment

begin_macro
name|c_enter
argument_list|(
argument|node
argument_list|,
argument|root
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|cvar
modifier|*
name|node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|cvar
modifier|*
modifier|*
name|root
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|name
decl_stmt|;
specifier|register
name|struct
name|cvar
modifier|*
name|n
decl_stmt|,
modifier|*
name|r
decl_stmt|;
name|r
operator|=
operator|*
name|root
expr_stmt|;
name|n
operator|=
name|node
expr_stmt|;
name|name
operator|=
name|n
operator|->
name|c_id
expr_stmt|;
if|if
condition|(
operator|!
name|r
condition|)
block|{
operator|*
name|root
operator|=
name|n
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
switch|switch
condition|(
name|scompare
argument_list|(
name|name
argument_list|,
literal|0
argument_list|,
name|r
operator|->
name|c_id
argument_list|,
literal|0
argument_list|)
condition|)
block|{
case|case
operator|-
literal|1
case|:
if|if
condition|(
operator|!
name|r
operator|->
name|c_left
condition|)
block|{
name|r
operator|->
name|c_left
operator|=
name|n
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|r
operator|=
name|r
operator|->
name|c_left
expr_stmt|;
break|break;
case|case
literal|0
case|:
name|yysemerr
argument_list|(
literal|"identifier re-declared"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|n
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|1
case|:
if|if
condition|(
operator|!
name|r
operator|->
name|c_right
condition|)
block|{
name|r
operator|->
name|c_right
operator|=
name|n
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|r
operator|=
name|r
operator|->
name|c_right
expr_stmt|;
break|break;
block|}
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  GET_VAR -- get a cvar node from a local_tree, global_tree pair **	searching first through the local then the global. ** **	Parameters: **		id -- c_id key **		local_tree -- first tree **		global_tree -- secomd tree to search ** **	Returns: **		0 -- if no node by that name **		otherwise -- pointer to the node */
end_comment

begin_function
name|struct
name|cvar
modifier|*
name|get_var
parameter_list|(
name|id
parameter_list|,
name|local_tree
parameter_list|,
name|global_tree
parameter_list|)
name|char
modifier|*
name|id
decl_stmt|;
name|struct
name|cvar
modifier|*
name|local_tree
decl_stmt|,
decl|*
name|global_tree
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|char
modifier|*
name|name
decl_stmt|;
specifier|register
name|struct
name|cvar
modifier|*
name|tree
decl_stmt|,
modifier|*
name|node
decl_stmt|;
name|char
name|flag
decl_stmt|;
name|flag
operator|=
literal|0
expr_stmt|;
name|name
operator|=
name|id
expr_stmt|;
name|tree
operator|=
name|local_tree
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
for|for
control|(
name|node
operator|=
name|tree
init|;
name|node
condition|;
control|)
block|{
switch|switch
condition|(
name|scompare
argument_list|(
name|name
argument_list|,
literal|0
argument_list|,
name|node
operator|->
name|c_id
argument_list|,
literal|0
argument_list|)
condition|)
block|{
case|case
operator|-
literal|1
case|:
if|if
condition|(
operator|!
name|node
operator|->
name|c_left
condition|)
break|break;
else|else
name|node
operator|=
name|node
operator|->
name|c_left
expr_stmt|;
continue|continue;
case|case
literal|0
case|:
return|return
operator|(
name|node
operator|)
return|;
case|case
literal|1
case|:
if|if
condition|(
operator|!
name|node
operator|->
name|c_right
condition|)
break|break;
else|else
name|node
operator|=
name|node
operator|->
name|c_right
expr_stmt|;
continue|continue;
block|}
break|break;
block|}
if|if
condition|(
operator|!
name|flag
condition|)
block|{
name|flag
operator|+=
literal|1
expr_stmt|;
name|tree
operator|=
name|global_tree
expr_stmt|;
block|}
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  GETCVAR -- get the cvar node for a given identifier **	Looks first in C_locals, then in C_globals. ** **	Parameters: **		id -- name of cvar to look for ** **	Returns: **		adress of cvar node if found **		0 -- otherwise ** **	Requires: **		C_locals& C_globals -- to search them */
end_comment

begin_function
name|struct
name|cvar
modifier|*
name|getcvar
parameter_list|(
name|id
parameter_list|)
name|char
modifier|*
name|id
decl_stmt|;
block|{
return|return
operator|(
name|get_var
argument_list|(
name|id
argument_list|,
name|C_locals
argument_list|,
name|C_globals
argument_list|)
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  GETFIELD -- Same as getcvar() for structure fields */
end_comment

begin_function
name|struct
name|cvar
modifier|*
name|getfield
parameter_list|(
name|id
parameter_list|)
name|char
modifier|*
name|id
decl_stmt|;
block|{
return|return
operator|(
name|get_var
argument_list|(
name|id
argument_list|,
name|F_locals
argument_list|,
name|F_globals
argument_list|)
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  FREECVAR& F_CVAR -- Free up storage in a cvar tree ** **	Freecvar calls f_cvar to free storage for a tree, then **	0's out the root pointer passed it. */
end_comment

begin_macro
name|freecvar
argument_list|(
argument|rootp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|cvar
modifier|*
modifier|*
name|rootp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|f_cvar
argument_list|(
operator|*
name|rootp
argument_list|)
expr_stmt|;
operator|*
name|rootp
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_macro
name|f_cvar
argument_list|(
argument|root
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|cvar
modifier|*
name|root
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|root
condition|)
block|{
name|f_cvar
argument_list|(
name|root
operator|->
name|c_left
argument_list|)
expr_stmt|;
name|f_cvar
argument_list|(
name|root
operator|->
name|c_right
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|root
operator|->
name|c_id
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|root
argument_list|)
expr_stmt|;
block|}
block|}
end_block

end_unit

