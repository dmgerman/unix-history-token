begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|<ingres.h>
end_include

begin_include
include|#
directive|include
file|<aux.h>
end_include

begin_include
include|#
directive|include
file|<symbol.h>
end_include

begin_include
include|#
directive|include
file|<tree.h>
end_include

begin_include
include|#
directive|include
file|"qrymod.h"
end_include

begin_include
include|#
directive|include
file|<sccs.h>
end_include

begin_macro
name|SCCSID
argument_list|(
argument|@(#)view.c
literal|7.1
literal|2
argument|/
literal|5
argument|/
literal|81
argument_list|)
end_macro

begin_comment
comment|/* **  VIEW.C -- view processing ** **	This module does the view processing.  Basically, it operates **	by detecting all references to views and replacing them by **	references to real relations.  There are a number of cases **	when it cannot do this, to whit: ** **	Syntactic problems:  the view may have a domain defined as **	a non-simple value (that is, not a simple attribute), which **	is then required to take on a value.  For example, if the **	view is defined as **		range of x is baserel **		define v (d = x.a / 3) **	and then referenced as **		append to v (d = 7) **	would result after query modification as **		range of x is baserel **		append to baserel (a / 3 = 7) **	which is not acceptable.  Of course, there is a range of cases **	where this can be fixed, but (for the time being) we will just **	throw them all out. ** **	Disappearing tuple anomaly:  the implicit qualification on **	a view allows tuples to disappear even when not a duplicate. **	For example, take a view defined as: **		range of x is baserel **		define v (d = x.a) where x.a = 4 **	and issue the query **		append to v (d = 5) **	The tuple will be inserted into the base relation, but will not **	be included in the view.  To solve that problem, we disallow **	updates to domains included in the qualification of the query. **	Note that this includes implicit updates, that is, an append **	with the domain missing (which implicitly appends a zero or **	blank domain). ** **	Cross product problem:  a view which is defined as a cross **	product of two relations has several update anomalies.  For **	example, take R1 and R2 as: **              R1 | a | b      R2 | b | c **              ---|---|---     ---|---|--- **                 | 7 | 0         | 0 | 3 **                 | 8 | 0         | 0 | 4 **	and issue the view definition **		range of m is R1 **		range of n is R2 **		define v (m.a, m.b, n.c) where m.b = n.b **	which will define a view which looks like **              view | a | b | c **              -----|---|---|--- **                   | 7 | 0 | 3 **                   | 7 | 0 | 4 **                   | 8 | 0 | 3 **                   | 8 | 0 | 4 **	Now try issuing **		range of v is v **		delete v where v.a = 8 and v.c = 4 **	which will try to give a view which looks like: **              view | a | b | c **              -----|---|---|--- **                   | 7 | 0 | 3 **                   | 7 | 0 | 4 **                   | 8 | 0 | 3 **	which is of course unexpressible in R1 and R2. ** **	Multiple query problem:  certain updates will require gener- **	ating multiple queries to satisfy the update on the view. **	Although this can be made to work, it won't now.  Cases are **	replaces where the target list contains more than one **	relation, and appends to a view over more than one relation. ** **	To solve these problems, we dissallow the following cases: ** **	I.  In a REPLACE or APPEND statement, if a 'v.d' appears **		on the LHS in the target list of the query and **		the a-fcn for 'v.d' is not a simple attribute. **	II.  In REPLACE or APPEND statements, if a 'v.d' appears **		on the LHS in a target list of the query and in **		the qualification of the view. **	III.  In a DELETE or APPEND statement, if the view ranges **		over more than one relation. **	IV.  In a REPLACE statement, if the query resulting after **		modification of the tree, but before appending the **		view qualification Qv, has more than one variable. **	V.  In any update, if an aggregate or aggregate function **		appears anywhere in the target list of the view. ** **	Note the assumption that the definition of a consistant update **	is: **		"An update is consistant if the result of **		 performing the update on the view and then **		 materializing that view is the same as the **		 result of materializing the view and then **		 performing the update." ** **	Trace Flags: **		30 -> 39 */
end_comment

begin_escape
end_escape

begin_comment
comment|/* **  VIEW -- driver for view processing ** **	This routine does the view processing portion of qrymod. **	Since the 'tree' catalog can contain relations which are **	themselves views, it iterates over itself until no views **	are found.  Presumably this cannot result in an infinite **	loop, although in fact it probably can; this should be **	dealt with at some time. ** **	For each range variable declared, it is checked whether **	that variable is a view.  If not, it is ignored. **	Then the tree which defines **	this view is fetched from the "tree" catalog by 'gettree', **	which also defines any variables required by this tree **	and adjusts the tree so that the varno's contained in the **	tree correspond to the varno's in the range table. ** **	'Subsvars' and 'vrscan' really do it.  Given the root of the tree **	to be modified, the variable number to be eliminated, and the **	target list for a replacement tree, they actually do the **	tacking of 'new tree' onto 'old tree'.  After it is done, **	there should be no references to the old variable at all **	in the tree.  'Subsvars' scans for VAR nodes (which are **	retrieve-only, and hence are always alright); 'vrscan' scans **	the left hand branch of the tree (the RESDOM nodes) and **	substitutes them. ** **	'Appqual' appends the qualification for the view (if any) **	onto the tree.  Finally, the variable for the view (which **	had all references to it eliminated by 'subsvars') is un- **	defined, so that that slot in the range table can be re- **	used by later scans. ** **	Parameters: **		root -- root of the tree to be modified. ** **	Returns: **		Root of modified tree. ** **	Side Effects: **		The range table is updated to delete any views and **			add any base relations needed to support them. **		Activity occurs in the 'tree' catalog to get the trees **			needed to define the views. **		The tree pointed to by 'root' is modified. ** **	Trace Flags: **		30 */
end_comment

begin_function
name|QTREE
modifier|*
name|view
parameter_list|(
name|root
parameter_list|)
name|QTREE
modifier|*
name|root
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|DESC
name|desc
decl_stmt|;
specifier|register
name|int
name|vn
decl_stmt|;
specifier|register
name|QTREE
modifier|*
name|vtree
decl_stmt|;
name|int
name|viewfound
decl_stmt|;
specifier|extern
name|QTREE
modifier|*
name|gettree
parameter_list|()
function_decl|;
specifier|extern
name|QTREE
modifier|*
name|norml
parameter_list|()
function_decl|;
specifier|auto
name|QTREE
modifier|*
name|r
decl_stmt|;
ifdef|#
directive|ifdef
name|xQTR1
name|tTfp
argument_list|(
literal|30
argument_list|,
operator|-
literal|1
argument_list|,
literal|"\n->VIEW\n\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|r
operator|=
name|root
expr_stmt|;
comment|/* scan range table until no views */
name|viewfound
operator|=
name|TRUE
expr_stmt|;
while|while
condition|(
name|viewfound
condition|)
block|{
ifdef|#
directive|ifdef
name|xQTR2
name|tTfp
argument_list|(
literal|30
argument_list|,
literal|1
argument_list|,
literal|"scanning Qt.qt_rangev\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* scan range table for views */
name|viewfound
operator|=
name|FALSE
expr_stmt|;
comment|/* make new resultvar old resultvar for non-update */
name|Qm
operator|.
name|qm_newresvar
operator|=
name|Qt
operator|.
name|qt_resvar
expr_stmt|;
comment|/* scan all variables in range table */
for|for
control|(
name|vn
operator|=
literal|0
init|;
name|vn
operator|<
name|MAXVAR
operator|+
literal|1
condition|;
name|vn
operator|++
control|)
block|{
comment|/* check for empty entry in range table */
if|if
condition|(
name|Qt
operator|.
name|qt_rangev
index|[
name|vn
index|]
operator|.
name|rngvdesc
operator|==
name|NULL
condition|)
continue|continue;
comment|/* see if it is a view or base relation */
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|S_VIEW
argument_list|,
name|Qt
operator|.
name|qt_rangev
index|[
name|vn
index|]
operator|.
name|rngvdesc
operator|->
name|reldum
operator|.
name|relstat
argument_list|)
condition|)
continue|continue;
ifdef|#
directive|ifdef
name|xQTR1
if|if
condition|(
name|tTf
argument_list|(
literal|30
argument_list|,
literal|3
argument_list|)
condition|)
name|printf
argument_list|(
literal|"view vn %d: %.12s\n"
argument_list|,
name|vn
argument_list|,
name|Qt
operator|.
name|qt_rangev
index|[
name|vn
index|]
operator|.
name|rngvdesc
operator|->
name|reldum
operator|.
name|relid
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|vtree
operator|=
name|gettree
argument_list|(
name|Qt
operator|.
name|qt_rangev
index|[
name|vn
index|]
operator|.
name|rngvdesc
operator|->
name|reldum
operator|.
name|relid
argument_list|,
name|Qt
operator|.
name|qt_rangev
index|[
name|vn
index|]
operator|.
name|rngvdesc
operator|->
name|reldum
operator|.
name|relowner
argument_list|,
name|mdVIEW
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|xQTR3
if|if
condition|(
name|tTf
argument_list|(
literal|30
argument_list|,
literal|5
argument_list|)
condition|)
name|treepr
argument_list|(
name|vtree
argument_list|,
literal|"Viewdef"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* check for updating with aggregates */
if|if
condition|(
name|Qt
operator|.
name|qt_qmode
operator|!=
name|mdRETR
operator|&&
name|aggcheck
argument_list|(
name|vtree
argument_list|)
condition|)
name|qmerror
argument_list|(
literal|3350
argument_list|,
name|Qt
operator|.
name|qt_qmode
argument_list|,
name|Qt
operator|.
name|qt_resvar
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* cannot update views with aggregates */
comment|/* scan view replacing RESDOM nodes */
if|if
condition|(
name|Qt
operator|.
name|qt_qmode
operator|!=
name|mdRETR
operator|&&
name|vn
operator|==
name|Qt
operator|.
name|qt_resvar
condition|)
name|vrscan
argument_list|(
operator|&
name|r
operator|->
name|left
argument_list|,
name|vtree
argument_list|)
expr_stmt|;
comment|/* scan view replacing VAR nodes */
name|subsvars
argument_list|(
operator|&
name|r
argument_list|,
name|vn
argument_list|,
name|vtree
operator|->
name|left
argument_list|,
name|mdVIEW
argument_list|)
expr_stmt|;
comment|/* test for non-functional replace */
if|if
condition|(
name|Qt
operator|.
name|qt_qmode
operator|==
name|mdREPL
operator|&&
name|bitcnt
argument_list|(
name|varset
argument_list|(
name|r
argument_list|)
operator||
operator|(
literal|1
operator|<<
name|Qm
operator|.
name|qm_newresvar
operator|)
argument_list|)
operator|>
literal|1
condition|)
name|qmerror
argument_list|(
literal|3360
argument_list|,
name|Qt
operator|.
name|qt_qmode
argument_list|,
name|Qt
operator|.
name|qt_resvar
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* non-functional update */
comment|/* append new qualification */
name|appqual
argument_list|(
name|vtree
operator|->
name|right
argument_list|,
name|r
argument_list|)
expr_stmt|;
comment|/* delete view range variable */
name|declare
argument_list|(
name|vn
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* mark the view as having been processed */
name|viewfound
operator|=
name|TRUE
expr_stmt|;
comment|/* change 'Qt.qt_resvar' to be the base rel var */
name|Qt
operator|.
name|qt_resvar
operator|=
name|Qm
operator|.
name|qm_newresvar
expr_stmt|;
block|}
block|}
comment|/* renormalize the tree (just in case) */
name|r
operator|->
name|right
operator|=
name|norml
argument_list|(
name|trimqlend
argument_list|(
name|r
operator|->
name|right
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|xQTR1
if|if
condition|(
name|tTf
argument_list|(
literal|30
argument_list|,
literal|15
argument_list|)
condition|)
name|treepr
argument_list|(
name|r
argument_list|,
literal|"VIEW->"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  VRSCAN -- scan query tree and replace RESDOM nodes ** **	The query tree issued is scanned and RESDOM nodes are **	converted to conform to the underlying base relations. **	There are many checks in here, and things can fail **	easily. ** **	The first check is for more than one relation in a **	DELETE or APPEND command.  This would require expanding **	the query into at least two queries.  For DELETE commands, **	this is the only check.  (Note that by this time 'aggcheck' **	has aborted anything which would cause problems with **	aggregates.) ** **	For append commands, we abort immediately if there is **	a qualification on the view, since the inserted tuple(s) **	might not (all) appear in the view. ** **	For all other queries, the target list of the query submitted **	is scanned down the left hand side (the RESDOM list). **	For each RESDOM, that variable is looked up in the view **	definition.  If the definition of it is not a simple **	attribute, the query is aborted. ** **	Then, if the variable appears anywhere in the qualification **	of the view, the query is aborted. ** **	Finally, we keep track of the varno which should become the **	new number two (that is, the Qt.qt_resvar).  If there are two **	candidates for this position, we promptly abort. ** **	And as the last step, we actually change the 'resno' for **	this RESDOM. ** **	When we exit the loop which scans RESDOM's, we change the **	'Qt.qt_resvar' to be the new variable which we have selected. ** **	Notice that there are a number of overly restrictive **	conditions on runability.  Notably, there are large classes **	of queries which can run consistantly but which violate **	either the not-in-qualification condition or the aggregate- **	free condition. ** **	Parameters: **		root -- the root of the tree to be updated. **		vtree -- the tree which defines the view. ** **	Returns: **		none (maybe non-local on error) ** **	Side Effects: **		The tree pointed to by 'root' is modified. ** **	Trace Flags: **		33 */
end_comment

begin_macro
name|vrscan
argument_list|(
argument|root
argument_list|,
argument|vtree
argument_list|)
end_macro

begin_decl_stmt
name|QTREE
modifier|*
name|root
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|QTREE
modifier|*
name|vtree
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|QTREE
modifier|*
name|t
decl_stmt|;
specifier|register
name|QTREE
modifier|*
name|v
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|extern
name|QTREE
modifier|*
name|qscan
parameter_list|()
function_decl|;
specifier|extern
name|QTREE
modifier|*
name|vfind
parameter_list|()
function_decl|;
specifier|register
name|QTREE
modifier|*
name|p
decl_stmt|;
name|t
operator|=
name|root
expr_stmt|;
name|v
operator|=
name|vtree
expr_stmt|;
comment|/* check DELETE and APPEND cases of> 1 relation */
if|if
condition|(
name|Qt
operator|.
name|qt_qmode
operator|==
name|mdDEL
operator|||
name|Qt
operator|.
name|qt_qmode
operator|==
name|mdAPP
condition|)
block|{
comment|/* scan target list of view for> 1 relation */
if|if
condition|(
name|bitcnt
argument_list|(
name|i
operator|=
name|varset
argument_list|(
name|v
operator|->
name|left
argument_list|)
argument_list|)
operator|!=
literal|1
condition|)
name|qmerror
argument_list|(
literal|3330
argument_list|,
name|Qt
operator|.
name|qt_qmode
argument_list|,
name|Qt
operator|.
name|qt_resvar
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* query would result in> 1 query */
comment|/* this is the only check in this module for DELETES */
if|if
condition|(
name|Qt
operator|.
name|qt_qmode
operator|==
name|mdDEL
condition|)
block|{
comment|/* set Qt.qt_resvar to underlying (single) relation */
name|Qm
operator|.
name|qm_newresvar
operator|=
name|bitpos
argument_list|(
name|i
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* check for a qualification on an append */
if|if
condition|(
name|v
operator|->
name|right
operator|->
name|sym
operator|.
name|type
operator|!=
name|QLEND
condition|)
name|qmerror
argument_list|(
literal|3320
argument_list|,
name|Qt
operator|.
name|qt_qmode
argument_list|,
name|Qt
operator|.
name|qt_resvar
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* attribute in qualification of view */
block|}
comment|/* scan target list of query */
name|i
operator|=
operator|-
literal|1
expr_stmt|;
while|while
condition|(
operator|(
name|t
operator|=
name|t
operator|->
name|left
operator|)
operator|->
name|sym
operator|.
name|type
operator|!=
name|TREE
condition|)
block|{
if|if
condition|(
name|t
operator|->
name|sym
operator|.
name|type
operator|!=
name|RESDOM
condition|)
name|syserr
argument_list|(
literal|"vrscan: bad TL node %d"
argument_list|,
name|t
operator|->
name|sym
operator|.
name|type
argument_list|)
expr_stmt|;
comment|/* check for 'tid' attribute (stuck in by DEL and REPL) */
if|if
condition|(
name|t
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_resdom
operator|.
name|resno
operator|==
literal|0
condition|)
continue|continue;
comment|/* find definition for this domain in the view */
name|p
operator|=
name|vfind
argument_list|(
name|t
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_resdom
operator|.
name|resno
argument_list|,
name|v
operator|->
name|left
argument_list|)
expr_stmt|;
comment|/* check for simple attribute */
if|if
condition|(
name|p
operator|->
name|sym
operator|.
name|type
operator|!=
name|VAR
condition|)
name|qmerror
argument_list|(
literal|3310
argument_list|,
name|Qt
operator|.
name|qt_qmode
argument_list|,
name|Qt
operator|.
name|qt_resvar
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* non-simple attribute */
comment|/* scan qualification of view for this attribute */
if|if
condition|(
name|qscan
argument_list|(
name|v
operator|->
name|right
argument_list|,
name|p
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_var
operator|.
name|varno
argument_list|,
name|p
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_var
operator|.
name|attno
argument_list|)
operator|!=
name|NULL
condition|)
name|qmerror
argument_list|(
literal|3320
argument_list|,
name|Qt
operator|.
name|qt_qmode
argument_list|,
name|Qt
operator|.
name|qt_resvar
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* attribute in qualification of view */
comment|/* check for trying to do update on two relations again */
comment|/* this test should only be true for REPLACE commands */
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|i
operator|=
name|p
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_var
operator|.
name|varno
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|!=
name|p
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_var
operator|.
name|varno
condition|)
name|qmerror
argument_list|(
literal|3330
argument_list|,
name|Qt
operator|.
name|qt_qmode
argument_list|,
name|Qt
operator|.
name|qt_resvar
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* query on two relations */
comment|/* finally, do the substitution of resno's */
name|t
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_resdom
operator|.
name|resno
operator|=
name|p
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_var
operator|.
name|attno
expr_stmt|;
block|}
comment|/* change the result variable for the query to the underlying */
name|Qm
operator|.
name|qm_newresvar
operator|=
name|i
expr_stmt|;
block|}
end_block

end_unit

