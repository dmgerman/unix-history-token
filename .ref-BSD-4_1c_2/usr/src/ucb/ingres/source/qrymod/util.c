begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|<ingres.h>
end_include

begin_include
include|#
directive|include
file|<aux.h>
end_include

begin_include
include|#
directive|include
file|<symbol.h>
end_include

begin_include
include|#
directive|include
file|<tree.h>
end_include

begin_include
include|#
directive|include
file|"qrymod.h"
end_include

begin_include
include|#
directive|include
file|<sccs.h>
end_include

begin_macro
name|SCCSID
argument_list|(
argument|@(#)util.c
literal|7.1
literal|2
argument|/
literal|5
argument|/
literal|81
argument_list|)
end_macro

begin_comment
comment|/* **  TRIMQLEND -- trim QLEND node off of qualification ** **	The QLEND node, and possible the AND node preceeding it, **	are trimmed off.  The result of this routine should be **	a very ordinary tree like you might see in some textbook. ** **	A fast not on the algorithm: the pointer 't' points to the **	current node (the one which we are checking for a QLEND). **	's' points to 't's parent, and 'r' points to 's's parent; **	'r' is NULL at the top of the tree. ** **	This routine works correctly on trees with no QLEND in **	the first place, returning the original tree. ** **	If there is a QLEND, it must be on the far right branch **	of the tree, that is, the tree must be INGRES-canonical. ** **	Parameters: **		qual -- the qualification to be trimmed. ** **	Returns: **		A pointer to the new qualification. **		NULL if the qualification was null once the **			QLEND is stripped. ** **	Side Effects: **		The tree pointed to by 'qual' may be modified. ** **	Trace Flags: **		none */
end_comment

begin_function
name|QTREE
modifier|*
name|trimqlend
parameter_list|(
name|qual
parameter_list|)
name|QTREE
modifier|*
name|qual
decl_stmt|;
block|{
specifier|register
name|QTREE
modifier|*
name|t
decl_stmt|;
specifier|register
name|QTREE
modifier|*
name|s
decl_stmt|;
specifier|register
name|QTREE
modifier|*
name|r
decl_stmt|;
name|t
operator|=
name|qual
expr_stmt|;
comment|/* check for the simple null qualification case */
if|if
condition|(
name|t
operator|==
name|NULL
operator|||
name|t
operator|->
name|sym
operator|.
name|type
operator|==
name|QLEND
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* scan tree for QLEND node */
for|for
control|(
name|r
operator|=
name|NULL
operator|,
name|s
operator|=
name|t
init|;
operator|(
name|t
operator|=
name|t
operator|->
name|right
operator|)
operator|!=
name|NULL
condition|;
name|r
operator|=
name|s
operator|,
name|s
operator|=
name|t
control|)
block|{
if|if
condition|(
name|t
operator|->
name|sym
operator|.
name|type
operator|==
name|QLEND
condition|)
block|{
comment|/* trim of QLEND and AND node */
if|if
condition|(
name|r
operator|==
name|NULL
condition|)
block|{
comment|/* only one AND -- return its operand */
return|return
operator|(
name|s
operator|->
name|left
operator|)
return|;
block|}
name|r
operator|->
name|right
operator|=
name|s
operator|->
name|left
expr_stmt|;
break|break;
block|}
block|}
comment|/* return tree with final AND node and QLEND node pruned */
return|return
operator|(
name|qual
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  APPQUAL -- append qualification to tree ** **	The qualification is conjoined to the qualificaion of the **	tree which is passed. ** **	Parameters: **		qual -- a pointer to the qualification to be appended. **		root -- a pointer to the tree to be appended to. ** **	Returns: **		none ** **	Side Effects: **		Both 'qual' ad 'root' may be modified.  Note that **			'qual' is linked into 'root', and must be **			retained. ** **	Trace Flags: **		13 */
end_comment

begin_macro
name|appqual
argument_list|(
argument|qual
argument_list|,
argument|root
argument_list|)
end_macro

begin_decl_stmt
name|QTREE
modifier|*
name|qual
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|QTREE
modifier|*
name|root
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|QTREE
modifier|*
name|p
decl_stmt|;
specifier|register
name|QTREE
modifier|*
name|r
decl_stmt|;
name|r
operator|=
name|root
expr_stmt|;
ifdef|#
directive|ifdef
name|xQTR3
if|if
condition|(
name|r
operator|==
name|NULL
condition|)
name|syserr
argument_list|(
literal|"appqual: NULL root"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	**  Find node before QLEND node 	**	p points the node we are examining, r points to 	**	it's parent. 	*/
while|while
condition|(
operator|(
name|p
operator|=
name|r
operator|->
name|right
operator|)
operator|!=
name|NULL
operator|&&
name|p
operator|->
name|sym
operator|.
name|type
operator|!=
name|QLEND
condition|)
block|{
ifdef|#
directive|ifdef
name|xQTR3
if|if
condition|(
name|p
operator|->
name|sym
operator|.
name|type
operator|!=
name|AND
condition|)
name|syserr
argument_list|(
literal|"appqual: node %d"
argument_list|,
name|p
operator|->
name|sym
operator|.
name|type
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|r
operator|=
name|p
expr_stmt|;
block|}
comment|/* link in qualification */
name|r
operator|->
name|right
operator|=
name|qual
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  QMERROR -- issue fatal error message and abort query ** **	This call is almost exactly like 'error' (which is called), **	but never returns: the return is done by 'reset'.  Also, the **	R_up pipe is flushed. ** **	Parameters: **		errno -- the error number. **		qmode -- the query mode to pass as $0, -1 if none. **		vn -- the varno of the relation name to pass as **			$1, -1 if none. **		p1 to p5 -- the parameters $2 through $6 ** **	Returns: **		non-local (via reset()) ** **	Side Effects: **		The error message is generated. ** **	Trace Flags: **		none */
end_comment

begin_decl_stmt
name|char
modifier|*
name|QmdName
index|[]
init|=
block|{
literal|"[ERROR]"
block|,
comment|/* 0 = mdRETTERM */
literal|"RETRIEVE"
block|,
comment|/* 1 = mdRETR */
literal|"APPEND"
block|,
comment|/* 2 = mdAPP */
literal|"REPLACE"
block|,
comment|/* 3 = mdREPL */
literal|"DELETE"
block|,
comment|/* 4 = mdDEL */
literal|""
block|,
comment|/* 5 = mdCOPY */
literal|""
block|,
comment|/* 6 = mdCREATE */
literal|""
block|,
comment|/* 7 = mdDESTROY */
literal|""
block|,
comment|/* 8 = mdHELP */
literal|""
block|,
comment|/* 9 = mdINDEX */
literal|""
block|,
comment|/* 10 = mdMODIFY */
literal|""
block|,
comment|/* 11 = mdPRINT */
literal|""
block|,
comment|/* 12 = mdRANGE */
literal|""
block|,
comment|/* 13 = mdSAVE */
literal|"DEFINE"
block|,
comment|/* 14 = mdDEFINE */
literal|"RET_UNIQUE"
block|,
comment|/* 15 = mdRET_UNI */
literal|""
block|,
comment|/* 16 = mdVIEW */
literal|""
block|,
comment|/* 17 = mdUPDATE */
literal|""
block|,
comment|/* 18 = mdRESETREL */
literal|""
block|,
comment|/* 19 = mdERIC */
literal|""
block|,
comment|/* 20 = mdNETQRY */
literal|""
block|,
comment|/* 21 = mdMOVEREL */
literal|""
block|,
comment|/* 22 = mdPROT */
literal|""
block|,
comment|/* 23 = mdINTEG */
literal|""
block|,
comment|/* 24 = mdDCREATE */
block|}
decl_stmt|;
end_decl_stmt

begin_macro
name|qmerror
argument_list|(
argument|errno
argument_list|,
argument|qmode
argument_list|,
argument|vn
argument_list|,
argument|p1
argument_list|,
argument|p2
argument_list|,
argument|p3
argument_list|,
argument|p4
argument_list|,
argument|p5
argument_list|,
argument|p6
argument_list|)
end_macro

begin_decl_stmt
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|qmode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|vn
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|,
modifier|*
name|p3
decl_stmt|,
modifier|*
name|p4
decl_stmt|,
modifier|*
name|p5
decl_stmt|,
modifier|*
name|p6
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|x1
decl_stmt|;
specifier|register
name|char
modifier|*
name|x2
decl_stmt|;
name|char
name|xbuf
index|[
name|MAXNAME
operator|+
literal|1
index|]
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|extern
name|char
modifier|*
name|trim_relname
parameter_list|()
function_decl|;
comment|/* set up qmode and varno parameters */
name|x1
operator|=
name|x2
operator|=
literal|""
expr_stmt|;
name|i
operator|=
name|qmode
expr_stmt|;
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
name|x1
operator|=
name|QmdName
index|[
name|i
index|]
expr_stmt|;
name|i
operator|=
name|vn
expr_stmt|;
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
name|smove
argument_list|(
name|trim_relname
argument_list|(
name|Qt
operator|.
name|qt_rangev
index|[
name|i
index|]
operator|.
name|rngvdesc
operator|->
name|reldum
operator|.
name|relid
argument_list|)
argument_list|,
name|x2
operator|=
name|xbuf
argument_list|)
expr_stmt|;
comment|/* issue the error message and exit */
name|error
argument_list|(
name|errno
argument_list|,
name|x1
argument_list|,
name|x2
argument_list|,
name|p1
argument_list|,
name|p2
argument_list|,
name|p3
argument_list|,
name|p4
argument_list|,
name|p5
argument_list|,
name|p6
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|syserr
argument_list|(
literal|"qmerror"
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  LSETBIT -- set a bit in a domain set ** **	Parameters: **		bitno -- the bit number to set (0 -> 127) **		xset -- the set to set it in. ** **	Returns: **		none ** **	Side Effects: **		none */
end_comment

begin_macro
name|lsetbit
argument_list|(
argument|bitno
argument_list|,
argument|xset
argument_list|)
end_macro

begin_decl_stmt
name|int
name|bitno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|xset
index|[
literal|8
index|]
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|b
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
specifier|register
name|int
modifier|*
name|x
decl_stmt|;
name|x
operator|=
name|xset
expr_stmt|;
name|b
operator|=
name|bitno
expr_stmt|;
name|n
operator|=
name|b
operator|>>
name|LOG2WORDSIZE
expr_stmt|;
name|b
operator|&=
name|WORDSIZE
operator|-
literal|1
expr_stmt|;
name|x
index|[
name|n
index|]
operator||=
literal|1
operator|<<
name|b
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  MERGEVAR -- merge variable numbers to link terms ** **	One specified variable gets mapped into another, effectively **	merging those two variables.  This is used for protection **	and integrity, since the constraint read from the tree **	must coincide with one of the variables in the query tree. ** **	Parameters: **		va -- the variable which will dissappear. **		vb -- the variable which 'va' gets mapped into. **		root -- the root of the tree to map. ** **	Returns: **		none ** **	Side Effects: **		The tree pointed at by 'root' gets VAR and RESDOM **			nodes mapped. **		Range table entry for 'va' is deallocated. **		The 'Qt.qt_remap' vector gets reset and left in an **			undefined state. ** **	Trace Flags: **		72 */
end_comment

begin_expr_stmt
name|mergevar
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|root
argument_list|)
specifier|register
name|int
name|a
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|b
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|QTREE
modifier|*
name|root
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|xQTR1
if|if
condition|(
name|tTf
argument_list|(
literal|72
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"\nmergevar(%d->%d)"
argument_list|,
name|a
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|treepr
argument_list|(
name|root
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 	**  Insure that 'a' and 'b' are consistant, that is, 	**  that they both are in range, are defined, and range over 	**  the same relation. 	*/
if|if
condition|(
name|a
operator|<
literal|0
operator|||
name|b
operator|<
literal|0
operator|||
name|a
operator|>=
name|MAXVAR
operator|+
literal|1
operator|||
name|b
operator|>=
name|MAXVAR
operator|+
literal|1
condition|)
name|syserr
argument_list|(
literal|"mergevar: range %d %d"
argument_list|,
name|a
argument_list|,
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|Qt
operator|.
name|qt_rangev
index|[
name|a
index|]
operator|.
name|rngvdesc
operator|==
name|NULL
operator|||
name|Qt
operator|.
name|qt_rangev
index|[
name|b
index|]
operator|.
name|rngvdesc
operator|==
name|NULL
condition|)
name|syserr
argument_list|(
literal|"mergevar: undef %d %d"
argument_list|,
name|a
argument_list|,
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bequal
argument_list|(
name|Qt
operator|.
name|qt_rangev
index|[
name|a
index|]
operator|.
name|rngvdesc
operator|->
name|reldum
operator|.
name|relid
argument_list|,
name|Qt
operator|.
name|qt_rangev
index|[
name|b
index|]
operator|.
name|rngvdesc
operator|->
name|reldum
operator|.
name|relid
argument_list|,
name|MAXNAME
argument_list|)
operator|||
operator|!
name|bequal
argument_list|(
name|Qt
operator|.
name|qt_rangev
index|[
name|a
index|]
operator|.
name|rngvdesc
operator|->
name|reldum
operator|.
name|relowner
argument_list|,
name|Qt
operator|.
name|qt_rangev
index|[
name|b
index|]
operator|.
name|rngvdesc
operator|->
name|reldum
operator|.
name|relowner
argument_list|,
literal|2
argument_list|)
condition|)
block|{
name|syserr
argument_list|(
literal|"mergevar: incon %.14s %.14s"
argument_list|,
name|Qt
operator|.
name|qt_rangev
index|[
name|a
index|]
operator|.
name|rngvdesc
operator|->
name|reldum
operator|.
name|relid
argument_list|,
name|Qt
operator|.
name|qt_rangev
index|[
name|b
index|]
operator|.
name|rngvdesc
operator|->
name|reldum
operator|.
name|relid
argument_list|)
expr_stmt|;
block|}
comment|/* 	**  To do the actual mapping, we will set up 'Qt.qt_remap' and 	**  call 'mapvars()'.  This is because I am too lazy to 	**  do it myself. 	*/
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXRANGE
condition|;
name|i
operator|++
control|)
name|Qt
operator|.
name|qt_remap
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
name|Qt
operator|.
name|qt_remap
index|[
name|a
index|]
operator|=
name|b
expr_stmt|;
name|mapvars
argument_list|(
name|root
argument_list|)
expr_stmt|;
comment|/* delete a from the range table */
name|declare
argument_list|(
name|a
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  MAKEZERO -- make a node with value 'zero' ** **	A node is created with value representing the zero value **	for the specified type, that is, 0 for integers, 0.0 for **	floats, and the blank string for chars. ** **	Parameters: **		typ -- the node type. ** **	Returns: **		a pointer to the zero node. ** **	Side Effects: **		space is grabbed from Qbuf */
end_comment

begin_function
name|QTREE
modifier|*
name|makezero
parameter_list|(
name|typ
parameter_list|)
name|int
name|typ
decl_stmt|;
block|{
specifier|register
name|int
name|l
decl_stmt|;
specifier|register
name|QTREE
modifier|*
name|s
decl_stmt|;
name|int
name|symbuf
index|[
operator|(
sizeof|sizeof
expr|*
name|s
block|)
function|/ sizeof l];
end_function

begin_comment
comment|/*word aligned*/
end_comment

begin_function_decl
specifier|extern
name|char
modifier|*
name|need
parameter_list|()
function_decl|;
end_function_decl

begin_expr_stmt
name|s
operator|=
operator|(
name|QTREE
operator|*
operator|)
name|symbuf
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|s
operator|->
name|sym
operator|.
name|type
operator|=
name|typ
expr_stmt|;
end_expr_stmt

begin_switch
switch|switch
condition|(
name|typ
condition|)
block|{
case|case
name|INT
case|:
name|s
operator|->
name|sym
operator|.
name|len
operator|=
name|l
operator|=
literal|2
expr_stmt|;
name|s
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_data
operator|.
name|i2type
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|FLOAT
case|:
name|s
operator|->
name|sym
operator|.
name|len
operator|=
name|l
operator|=
literal|4
expr_stmt|;
name|s
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_data
operator|.
name|f4type
operator|=
literal|0.0
expr_stmt|;
break|break;
case|case
name|CHAR
case|:
name|s
operator|->
name|sym
operator|.
name|len
operator|=
name|l
operator|=
literal|2
expr_stmt|;
name|s
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_data
operator|.
name|i2type
operator|=
literal|'  '
expr_stmt|;
comment|/* (two spaces) */
break|break;
default|default:
name|syserr
argument_list|(
literal|"makezero: typ %d"
argument_list|,
name|typ
argument_list|)
expr_stmt|;
block|}
end_switch

begin_comment
comment|/* duplicate the node into Qbuf */
end_comment

begin_expr_stmt
name|l
operator|+=
literal|2
operator|+
literal|2
operator|*
name|QT_HDR_SIZ
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* size of type + len + left + right */
end_comment

begin_expr_stmt
name|s
operator|=
operator|(
name|QTREE
operator|*
operator|)
name|need
argument_list|(
name|Qbuf
argument_list|,
name|l
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|bmove
argument_list|(
name|symbuf
argument_list|,
name|s
argument_list|,
name|l
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
operator|(
name|s
operator|)
return|;
end_return

unit|}
end_unit

