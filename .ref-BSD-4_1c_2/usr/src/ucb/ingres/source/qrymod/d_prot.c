begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|<ingres.h>
end_include

begin_include
include|#
directive|include
file|<aux.h>
end_include

begin_include
include|#
directive|include
file|<catalog.h>
end_include

begin_include
include|#
directive|include
file|<access.h>
end_include

begin_include
include|#
directive|include
file|<tree.h>
end_include

begin_include
include|#
directive|include
file|<symbol.h>
end_include

begin_include
include|#
directive|include
file|<lock.h>
end_include

begin_include
include|#
directive|include
file|<pv.h>
end_include

begin_include
include|#
directive|include
file|<func.h>
end_include

begin_include
include|#
directive|include
file|"qrymod.h"
end_include

begin_include
include|#
directive|include
file|<sccs.h>
end_include

begin_macro
name|SCCSID
argument_list|(
argument|@(#)d_prot.c
literal|7.1
literal|2
argument|/
literal|5
argument|/
literal|81
argument_list|)
end_macro

begin_comment
comment|/* **  D_PROT -- define protection constraint ** **	A protection constraint as partially defined by the last tree **	defined by d_tree is defined. ** **	The stuff that comes through the pipe as parameters is complex. **	It comes as a sequence of strings: **	 # The operation set, already encoded in the parser into a **	   bit map.  If the PRO_RETR permission is set, the PRO_TEST **	   and PRO_AGGR permissions will also be set. **	 # The relation name. **	 # The relation owner. **	 # The user name.  This must be a user name as specified in **	   the 'users' file, or the keyword 'all', meaning all users. **	 # The terminal id.  Must be a string of the form 'ttyx' or **	   the keyword 'all'. **	 # The starting time of day, as minutes-since-midnight. **	 # The ending time of day. **	 # The starting day-of-week, with 0 = Sunday. **	 # The ending dow. ** **	The domain reference set is build automatically from the **	target list of the tree.  Thus, the target list must exist, **	but it is not inserted into the tree.  The target list must **	be a flat sequence of RESDOM nodes with VAR nodes hanging **	of the rhs; also, the VAR nodes must all be for Qt.qt_resvar. **	If there is no target list on the tree, the set of all var- **	iables is assumed. ** **	The relstat field in the relation relation is updated to **	reflect any changes. ** **	It only makes sense for the DBA to execute this command. ** **	If there is one of the special cases **		permit all to all **		permit retrieve to all **	it is caught, and the effect is achieved by diddling **	relstat bits instead of inserting into the protect catalog. ** **	Parameters: **		none ** **	Returns: **		none ** **	Side Effects: **		Activity in 'protect' and 'relation' catalogs. ** **	Trace Flags: **		59 */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|admin
name|Admin
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|DESC
name|Prodes
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|DESC
name|Reldes
decl_stmt|;
end_decl_stmt

begin_extern
extern|extern		d_prot(
end_extern

begin_operator
unit|)
operator|,
end_operator

begin_expr_stmt
name|null_fn
argument_list|()
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|extern
name|short
name|tTqm
index|[
literal|80
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|fn_def
name|DefProFn
init|=
block|{
literal|"DPROT"
block|,
name|d_prot
block|,
name|null_fn
block|,
name|null_fn
block|,
name|NULL
block|,
literal|0
block|,
name|tTqm
block|,
literal|80
block|,
literal|'Q'
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_macro
name|d_prot
argument_list|(
argument|pc
argument_list|,
argument|pv
argument_list|)
end_macro

begin_decl_stmt
name|int
name|pc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|PARM
modifier|*
name|pv
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|protect
name|protup
decl_stmt|;
name|struct
name|tup_id
name|protid
decl_stmt|;
name|struct
name|protect
name|prokey
decl_stmt|;
name|struct
name|protect
name|proxtup
decl_stmt|;
name|char
name|buf
index|[
literal|30
index|]
decl_stmt|;
name|char
name|ubuf
index|[
name|MAXLINE
operator|+
literal|1
index|]
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|auto
name|int
name|ix
decl_stmt|;
name|int
name|treeid
decl_stmt|;
specifier|register
name|QTREE
modifier|*
name|t
decl_stmt|;
name|QTREE
modifier|*
name|root
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|struct
name|relation
name|reltup
decl_stmt|;
name|struct
name|relation
name|relkey
decl_stmt|;
name|struct
name|tup_id
name|reltid
decl_stmt|;
name|int
name|relstat
decl_stmt|;
name|int
name|all_pro
decl_stmt|;
comment|/* 	**  Fill in the protection tuple with the information 	**	from the parser, validating as we go. 	** 	**	Also, determine if we have a PERMIT xx to ALL 	**	with no further qualification case.  The variable 	**	'all_pro' is set to reflect this. 	*/
name|clr_tuple
argument_list|(
operator|&
name|Prodes
argument_list|,
operator|&
name|protup
argument_list|)
expr_stmt|;
name|all_pro
operator|=
name|TRUE
expr_stmt|;
comment|/* read operation set */
if|if
condition|(
name|pv
operator|->
name|pv_type
operator|!=
name|PV_INT
condition|)
name|syserr
argument_list|(
literal|"d_prot: opset"
argument_list|)
expr_stmt|;
name|protup
operator|.
name|proopset
operator|=
name|pv
operator|->
name|pv_val
operator|.
name|pv_int
expr_stmt|;
if|if
condition|(
operator|(
name|protup
operator|.
name|proopset
operator|&
name|PRO_RETR
operator|)
operator|!=
literal|0
condition|)
name|protup
operator|.
name|proopset
operator||=
name|PRO_TEST
operator||
name|PRO_AGGR
expr_stmt|;
name|pv
operator|++
expr_stmt|;
comment|/* read relation name */
if|if
condition|(
name|pv
operator|->
name|pv_type
operator|!=
name|PV_STR
condition|)
name|syserr
argument_list|(
literal|"d_prot: relid"
argument_list|)
expr_stmt|;
name|pmove
argument_list|(
name|pv
operator|->
name|pv_val
operator|.
name|pv_str
argument_list|,
name|protup
operator|.
name|prorelid
argument_list|,
name|MAXNAME
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|pv
operator|++
expr_stmt|;
comment|/* read relation owner */
if|if
condition|(
name|pv
operator|->
name|pv_type
operator|!=
name|PV_STR
condition|)
name|syserr
argument_list|(
literal|"d_prot: relid"
argument_list|)
expr_stmt|;
name|bmove
argument_list|(
name|pv
operator|->
name|pv_val
operator|.
name|pv_str
argument_list|,
name|protup
operator|.
name|prorelown
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|pv
operator|++
expr_stmt|;
comment|/* read user name */
if|if
condition|(
name|pv
operator|->
name|pv_type
operator|!=
name|PV_STR
condition|)
name|syserr
argument_list|(
literal|"d_prot: user"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sequal
argument_list|(
name|pv
operator|->
name|pv_val
operator|.
name|pv_str
argument_list|,
literal|"all"
argument_list|)
condition|)
name|bmove
argument_list|(
literal|"  "
argument_list|,
name|protup
operator|.
name|prouser
argument_list|,
literal|2
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* look up user in 'users' file */
if|if
condition|(
name|getnuser
argument_list|(
name|pv
operator|->
name|pv_val
operator|.
name|pv_str
argument_list|,
name|ubuf
argument_list|)
condition|)
name|qmerror
argument_list|(
literal|3591
argument_list|,
operator|-
literal|1
argument_list|,
name|Qt
operator|.
name|qt_resvar
argument_list|,
name|pv
operator|->
name|pv_val
operator|.
name|pv_str
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|ubuf
init|;
operator|*
name|p
operator|!=
literal|':'
operator|&&
operator|*
name|p
operator|!=
literal|0
condition|;
name|p
operator|++
control|)
continue|continue;
name|bmove
argument_list|(
operator|++
name|p
argument_list|,
name|protup
operator|.
name|prouser
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|':'
operator|||
name|p
index|[
literal|1
index|]
operator|==
literal|':'
operator|||
name|p
index|[
literal|2
index|]
operator|!=
literal|':'
condition|)
name|syserr
argument_list|(
literal|"d_prot: users %s"
argument_list|,
name|ubuf
argument_list|)
expr_stmt|;
name|all_pro
operator|=
name|FALSE
expr_stmt|;
block|}
name|pv
operator|++
expr_stmt|;
comment|/* read terminal id */
if|if
condition|(
name|pv
operator|->
name|pv_type
operator|!=
name|PV_STR
condition|)
name|syserr
argument_list|(
literal|"d_prot: user"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sequal
argument_list|(
name|pv
operator|->
name|pv_val
operator|.
name|pv_str
argument_list|,
literal|"all"
argument_list|)
condition|)
name|pmove
argument_list|(
literal|""
argument_list|,
name|protup
operator|.
name|proterm
argument_list|,
sizeof|sizeof
name|protup
operator|.
name|proterm
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
else|else
block|{
name|pmove
argument_list|(
name|pv
operator|->
name|pv_val
operator|.
name|pv_str
argument_list|,
name|protup
operator|.
name|proterm
argument_list|,
sizeof|sizeof
name|protup
operator|.
name|proterm
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isttyname
argument_list|(
name|pv
operator|->
name|pv_val
operator|.
name|pv_str
argument_list|)
condition|)
name|qmerror
argument_list|(
literal|3590
argument_list|,
operator|-
literal|1
argument_list|,
name|Qt
operator|.
name|qt_resvar
argument_list|,
name|pv
operator|->
name|pv_val
operator|.
name|pv_str
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|all_pro
operator|=
name|FALSE
expr_stmt|;
block|}
name|pv
operator|++
expr_stmt|;
comment|/* read starting time of day */
if|if
condition|(
name|pv
operator|->
name|pv_type
operator|!=
name|PV_INT
condition|)
name|syserr
argument_list|(
literal|"d_prot: btod"
argument_list|)
expr_stmt|;
name|protup
operator|.
name|protodbgn
operator|=
name|pv
operator|->
name|pv_val
operator|.
name|pv_int
expr_stmt|;
if|if
condition|(
name|pv
operator|->
name|pv_val
operator|.
name|pv_int
operator|>
literal|0
condition|)
name|all_pro
operator|=
name|FALSE
expr_stmt|;
name|pv
operator|++
expr_stmt|;
comment|/* read ending time of day */
if|if
condition|(
name|pv
operator|->
name|pv_type
operator|!=
name|PV_INT
condition|)
name|syserr
argument_list|(
literal|"d_prot: etod"
argument_list|)
expr_stmt|;
name|protup
operator|.
name|protodend
operator|=
name|pv
operator|->
name|pv_val
operator|.
name|pv_int
expr_stmt|;
if|if
condition|(
name|pv
operator|->
name|pv_val
operator|.
name|pv_int
operator|<
literal|24
operator|*
literal|60
operator|-
literal|1
condition|)
name|all_pro
operator|=
name|FALSE
expr_stmt|;
name|pv
operator|++
expr_stmt|;
comment|/* read beginning day of week */
if|if
condition|(
name|pv
operator|->
name|pv_type
operator|!=
name|PV_STR
condition|)
name|syserr
argument_list|(
literal|"d_prot: bdow"
argument_list|)
expr_stmt|;
name|i
operator|=
name|cvt_dow
argument_list|(
name|pv
operator|->
name|pv_val
operator|.
name|pv_str
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|qmerror
argument_list|(
literal|3594
argument_list|,
operator|-
literal|1
argument_list|,
name|Qt
operator|.
name|qt_resvar
argument_list|,
name|pv
operator|->
name|pv_val
operator|.
name|pv_str
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* bad dow */
name|protup
operator|.
name|prodowbgn
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
name|all_pro
operator|=
name|FALSE
expr_stmt|;
name|pv
operator|++
expr_stmt|;
comment|/* read ending day of week */
if|if
condition|(
name|pv
operator|->
name|pv_type
operator|!=
name|PV_STR
condition|)
name|syserr
argument_list|(
literal|"d_prot: edow"
argument_list|)
expr_stmt|;
name|i
operator|=
name|cvt_dow
argument_list|(
name|pv
operator|->
name|pv_val
operator|.
name|pv_str
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|qmerror
argument_list|(
literal|3594
argument_list|,
operator|-
literal|1
argument_list|,
name|Qt
operator|.
name|qt_resvar
argument_list|,
name|pv
operator|->
name|pv_val
operator|.
name|pv_str
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* bad dow */
name|protup
operator|.
name|prodowend
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|6
condition|)
name|all_pro
operator|=
name|FALSE
expr_stmt|;
name|pv
operator|++
expr_stmt|;
comment|/* 	**  Check for valid tree: 	**	There must be a tree defined, and all variables 	**	referenced must be owned by the current user; this 	**	is because you could otherwise get at data by 	**	mentioning it in a permit statement; see protect.c 	**	for a better explanation of this. 	*/
if|if
condition|(
name|pv
operator|->
name|pv_type
operator|!=
name|PV_QTREE
condition|)
name|syserr
argument_list|(
literal|"d_prot: tree"
argument_list|)
expr_stmt|;
name|root
operator|=
operator|(
name|QTREE
operator|*
operator|)
name|pv
operator|->
name|pv_val
operator|.
name|pv_qtree
expr_stmt|;
name|pv
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXVAR
operator|+
literal|1
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|Qt
operator|.
name|qt_rangev
index|[
name|i
index|]
operator|.
name|rngvdesc
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
operator|!
name|bequal
argument_list|(
name|Qt
operator|.
name|qt_rangev
index|[
name|i
index|]
operator|.
name|rngvdesc
operator|->
name|reldum
operator|.
name|relowner
argument_list|,
name|Usercode
argument_list|,
literal|2
argument_list|)
condition|)
name|qmerror
argument_list|(
literal|3592
argument_list|,
operator|-
literal|1
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* test for dba */
if|if
condition|(
operator|!
name|bequal
argument_list|(
name|Usercode
argument_list|,
name|Admin
operator|.
name|adhdr
operator|.
name|adowner
argument_list|,
literal|2
argument_list|)
condition|)
name|qmerror
argument_list|(
literal|3595
argument_list|,
operator|-
literal|1
argument_list|,
name|Qt
operator|.
name|qt_resvar
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* get domain reference set from target list */
comment|/* (also, find the TREE node) */
name|t
operator|=
name|root
operator|->
name|left
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|sym
operator|.
name|type
operator|==
name|TREE
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
name|protup
operator|.
name|prodomset
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
name|protup
operator|.
name|prodomset
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
name|t
operator|->
name|sym
operator|.
name|type
operator|!=
name|TREE
condition|;
name|t
operator|=
name|t
operator|->
name|left
control|)
block|{
if|if
condition|(
name|t
operator|->
name|right
operator|->
name|sym
operator|.
name|type
operator|!=
name|VAR
operator|||
name|t
operator|->
name|sym
operator|.
name|type
operator|!=
name|RESDOM
operator|||
name|t
operator|->
name|right
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_var
operator|.
name|varno
operator|!=
name|Qt
operator|.
name|qt_resvar
condition|)
name|syserr
argument_list|(
literal|"d_prot: garbage tree"
argument_list|)
expr_stmt|;
name|lsetbit
argument_list|(
name|t
operator|->
name|right
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_var
operator|.
name|attno
argument_list|,
name|protup
operator|.
name|prodomset
argument_list|)
expr_stmt|;
block|}
name|all_pro
operator|=
name|FALSE
expr_stmt|;
block|}
comment|/* trim off the target list, since it isn't used again */
name|root
operator|->
name|left
operator|=
name|t
expr_stmt|;
comment|/* 	**  Check out the target relation. 	**	We first save the varno of the relation which is 	**	getting the permit stuff.  Also, we check to see 	**	that the relation mentioned is a base relation, 	**	and not a view, since that tuple would never do 	**	anything anyway.  Finally, we clear the Qt.qt_resvar 	**	so that it does not get output to the tree catalog. 	**	This would result in a 'syserr' when we tried to 	**	read it. 	*/
name|protup
operator|.
name|proresvar
operator|=
name|Qt
operator|.
name|qt_resvar
expr_stmt|;
ifdef|#
directive|ifdef
name|xQTR3
if|if
condition|(
name|Qt
operator|.
name|qt_resvar
operator|<
literal|0
condition|)
name|syserr
argument_list|(
literal|"d_prot: Rv %d"
argument_list|,
name|Qt
operator|.
name|qt_resvar
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|bitset
argument_list|(
name|S_VIEW
argument_list|,
name|Qt
operator|.
name|qt_rangev
index|[
name|Qt
operator|.
name|qt_resvar
index|]
operator|.
name|rngvdesc
operator|->
name|reldum
operator|.
name|relstat
argument_list|)
condition|)
name|qmerror
argument_list|(
literal|3593
argument_list|,
operator|-
literal|1
argument_list|,
name|Qt
operator|.
name|qt_resvar
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* is a view */
comment|/* clear the (unused) Qt.qt_qmode */
ifdef|#
directive|ifdef
name|xQTR3
if|if
condition|(
name|Qt
operator|.
name|qt_qmode
operator|!=
name|mdPROT
condition|)
name|syserr
argument_list|(
literal|"d_prot: Qt.qt_qmode %d"
argument_list|,
name|Qt
operator|.
name|qt_qmode
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|Qt
operator|.
name|qt_qmode
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* 	**  Check for PERMIT xx to ALL case. 	**	The relstat bits will be adjusted as necessary 	**	to reflect these special cases. 	** 	**	This is actually a little tricky, since we cannot 	**	afford to turn off any permissions.  If we already 	**	have some form of PERMIT xx to ALL access, we must 	**	leave it. 	*/
name|relstat
operator|=
name|Qt
operator|.
name|qt_rangev
index|[
name|Qt
operator|.
name|qt_resvar
index|]
operator|.
name|rngvdesc
operator|->
name|reldum
operator|.
name|relstat
expr_stmt|;
if|if
condition|(
name|all_pro
operator|&&
operator|(
name|protup
operator|.
name|proopset
operator|&
name|PRO_RETR
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|protup
operator|.
name|proopset
operator|==
operator|-
literal|1
condition|)
name|relstat
operator|&=
operator|~
name|S_PROTALL
expr_stmt|;
else|else
block|{
name|relstat
operator|&=
operator|~
name|S_PROTRET
expr_stmt|;
if|if
condition|(
operator|(
name|protup
operator|.
name|proopset
operator|&
operator|~
operator|(
name|PRO_RETR
operator||
name|PRO_AGGR
operator||
name|PRO_TEST
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* some special case: still insert prot tuple */
name|all_pro
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
block|}
comment|/* see if we are adding any tuples */
if|if
condition|(
operator|!
name|all_pro
condition|)
name|relstat
operator||=
name|S_PROTUPS
expr_stmt|;
comment|/* 	**  Change relstat field in relation catalog if changed 	*/
if|if
condition|(
name|relstat
operator|!=
name|Qt
operator|.
name|qt_rangev
index|[
name|Qt
operator|.
name|qt_resvar
index|]
operator|.
name|rngvdesc
operator|->
name|reldum
operator|.
name|relstat
condition|)
block|{
name|opencatalog
argument_list|(
literal|"relation"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|setkey
argument_list|(
operator|&
name|Reldes
argument_list|,
operator|&
name|relkey
argument_list|,
name|Qt
operator|.
name|qt_rangev
index|[
name|Qt
operator|.
name|qt_resvar
index|]
operator|.
name|rngvdesc
operator|->
name|reldum
operator|.
name|relid
argument_list|,
name|RELID
argument_list|)
expr_stmt|;
name|setkey
argument_list|(
operator|&
name|Reldes
argument_list|,
operator|&
name|relkey
argument_list|,
name|Qt
operator|.
name|qt_rangev
index|[
name|Qt
operator|.
name|qt_resvar
index|]
operator|.
name|rngvdesc
operator|->
name|reldum
operator|.
name|relowner
argument_list|,
name|RELOWNER
argument_list|)
expr_stmt|;
name|i
operator|=
name|getequal
argument_list|(
operator|&
name|Reldes
argument_list|,
operator|&
name|relkey
argument_list|,
operator|&
name|reltup
argument_list|,
operator|&
name|reltid
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
name|syserr
argument_list|(
literal|"d_prot: geteq %d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|reltup
operator|.
name|relstat
operator|=
name|relstat
expr_stmt|;
name|i
operator|=
name|replace
argument_list|(
operator|&
name|Reldes
argument_list|,
operator|&
name|reltid
argument_list|,
operator|&
name|reltup
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
name|syserr
argument_list|(
literal|"d_prot: repl %d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|noclose
argument_list|(
operator|&
name|Reldes
argument_list|)
operator|!=
literal|0
condition|)
name|syserr
argument_list|(
literal|"d_prot: noclose(rel)"
argument_list|)
expr_stmt|;
block|}
name|Qt
operator|.
name|qt_resvar
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|all_pro
condition|)
block|{
comment|/* 		**  Output the created tuple to the protection catalog 		**  after making other internal adjustments and deter- 		**  mining a unique sequence number (with the protect 		**  catalog locked). 		*/
if|if
condition|(
name|root
operator|->
name|right
operator|->
name|sym
operator|.
name|type
operator|!=
name|QLEND
condition|)
name|protup
operator|.
name|protree
operator|=
name|puttree
argument_list|(
name|root
argument_list|,
name|protup
operator|.
name|prorelid
argument_list|,
name|protup
operator|.
name|prorelown
argument_list|,
name|mdPROT
argument_list|)
expr_stmt|;
else|else
name|protup
operator|.
name|protree
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* compute unique permission id */
name|opencatalog
argument_list|(
literal|"protect"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|setrll
argument_list|(
name|A_SLP
argument_list|,
name|Prodes
operator|.
name|reltid
operator|.
name|ltid
argument_list|,
name|M_EXCL
argument_list|)
expr_stmt|;
name|setkey
argument_list|(
operator|&
name|Prodes
argument_list|,
operator|&
name|prokey
argument_list|,
name|protup
operator|.
name|prorelid
argument_list|,
name|PRORELID
argument_list|)
expr_stmt|;
name|setkey
argument_list|(
operator|&
name|Prodes
argument_list|,
operator|&
name|prokey
argument_list|,
name|protup
operator|.
name|prorelown
argument_list|,
name|PRORELOWN
argument_list|)
expr_stmt|;
for|for
control|(
name|ix
operator|=
literal|2
init|;
condition|;
name|ix
operator|++
control|)
block|{
name|setkey
argument_list|(
operator|&
name|Prodes
argument_list|,
operator|&
name|prokey
argument_list|,
operator|&
name|ix
argument_list|,
name|PROPERMID
argument_list|)
expr_stmt|;
name|i
operator|=
name|getequal
argument_list|(
operator|&
name|Prodes
argument_list|,
operator|&
name|prokey
argument_list|,
operator|&
name|proxtup
argument_list|,
operator|&
name|protid
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|syserr
argument_list|(
literal|"d_prot: geteq"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|>
literal|0
condition|)
break|break;
block|}
name|protup
operator|.
name|propermid
operator|=
name|ix
expr_stmt|;
comment|/* do actual insert */
name|i
operator|=
name|insert
argument_list|(
operator|&
name|Prodes
argument_list|,
operator|&
name|protid
argument_list|,
operator|&
name|protup
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|syserr
argument_list|(
literal|"d_prot: insert"
argument_list|)
expr_stmt|;
if|if
condition|(
name|noclose
argument_list|(
operator|&
name|Prodes
argument_list|)
operator|!=
literal|0
condition|)
name|syserr
argument_list|(
literal|"d_prot: noclose(pro)"
argument_list|)
expr_stmt|;
comment|/* clear the lock */
name|unlrl
argument_list|(
name|Prodes
operator|.
name|reltid
operator|.
name|ltid
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  CVT_DOW -- convert day of week ** **	Converts the day of the week from string form to a number. ** **	Parameters: **		sdow -- dow in string form. ** **	Returns: **		0 -> 6 -- the encoded day of the week. **		-1 -- error. ** **	Side Effects: **		none ** **	Defines: **		Dowlist -- a mapping from day of week to number. **		cvt_dow ** **	Called By: **		d_prot */
end_comment

begin_struct
struct|struct
name|downame
block|{
name|char
modifier|*
name|dow_name
decl_stmt|;
name|int
name|dow_num
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|downame
name|Dowlist
index|[]
init|=
block|{
literal|"sun"
block|,
literal|0
block|,
literal|"sunday"
block|,
literal|0
block|,
literal|"mon"
block|,
literal|1
block|,
literal|"monday"
block|,
literal|1
block|,
literal|"tue"
block|,
literal|2
block|,
literal|"tues"
block|,
literal|2
block|,
literal|"tuesday"
block|,
literal|2
block|,
literal|"wed"
block|,
literal|3
block|,
literal|"wednesday"
block|,
literal|3
block|,
literal|"thu"
block|,
literal|4
block|,
literal|"thurs"
block|,
literal|4
block|,
literal|"thursday"
block|,
literal|4
block|,
literal|"fri"
block|,
literal|5
block|,
literal|"friday"
block|,
literal|5
block|,
literal|"sat"
block|,
literal|6
block|,
literal|"saturday"
block|,
literal|6
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_macro
name|cvt_dow
argument_list|(
argument|sdow
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|sdow
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|downame
modifier|*
name|d
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
name|s
operator|=
name|sdow
expr_stmt|;
for|for
control|(
name|d
operator|=
name|Dowlist
init|;
name|d
operator|->
name|dow_name
operator|!=
name|NULL
condition|;
name|d
operator|++
control|)
if|if
condition|(
name|sequal
argument_list|(
name|d
operator|->
name|dow_name
argument_list|,
name|s
argument_list|)
condition|)
return|return
operator|(
name|d
operator|->
name|dow_num
operator|)
return|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  ISTTYNAME -- "is a legal terminal name" predicate ** **	Returns TRUE if the argument is a legal terminal name, **	otherwise FALSE. ** **	It may make sense to have this routine check if the given **	file name really exists. ** **	WARNING: **		This routine may be installation-dependent! ** **	Parameters: **		n -- the name to check. ** **	Returns: **		TRUE -- n is a legal tty name at this installation. **		FALSE -- otherwise. ** **	Side Effects: **		none ** **	History: **		8/1/79 (eric) -- written. */
end_comment

begin_expr_stmt
name|isttyname
argument_list|(
name|n
argument_list|)
specifier|register
name|char
operator|*
name|n
expr_stmt|;
end_expr_stmt

begin_block
block|{
return|return
operator|(
name|sequal
argument_list|(
name|n
argument_list|,
literal|"console"
argument_list|)
operator|||
name|bequal
argument_list|(
name|n
argument_list|,
literal|"tty"
argument_list|,
literal|3
argument_list|)
operator|)
return|;
block|}
end_block

end_unit

