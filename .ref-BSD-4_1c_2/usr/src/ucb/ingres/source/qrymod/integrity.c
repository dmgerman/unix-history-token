begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|<ingres.h>
end_include

begin_include
include|#
directive|include
file|<aux.h>
end_include

begin_include
include|#
directive|include
file|<catalog.h>
end_include

begin_include
include|#
directive|include
file|<access.h>
end_include

begin_include
include|#
directive|include
file|<tree.h>
end_include

begin_include
include|#
directive|include
file|<symbol.h>
end_include

begin_include
include|#
directive|include
file|"qrymod.h"
end_include

begin_include
include|#
directive|include
file|<sccs.h>
end_include

begin_macro
name|SCCSID
argument_list|(
argument|@(#)integrity.c
literal|7.1
literal|2
argument|/
literal|5
argument|/
literal|81
argument_list|)
end_macro

begin_comment
comment|/* **  INTEGRITY.C -- Integrity Constraint Processor ** **	This module contains the integrity constraint processor.  This **	processor modifies the query to add integrity constraints. ** **	Currently only single-variable aggregate-free constraints are **	handled.  Thus the algorithm is reduced to scanning the tree **	for each variable modified and appending the constraints for **	that variable to the tree. ** **	Parameters: **		none ** **	Returns: **		The root of the modified tree. ** **	Side Effects: **		Much relation I/O. **		Modifies the tree in place, so the previous one is **			lost. ** **	Trace Flags: **		40 -> 49 */
end_comment

begin_decl_stmt
specifier|extern
name|DESC
name|Intdes
decl_stmt|;
end_decl_stmt

begin_function
name|QTREE
modifier|*
name|integrity
parameter_list|(
name|root
parameter_list|)
name|QTREE
modifier|*
name|root
decl_stmt|;
block|{
specifier|register
name|QTREE
modifier|*
name|r
decl_stmt|;
name|int
name|dset
index|[
literal|8
index|]
decl_stmt|;
specifier|register
name|QTREE
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|auto
name|QTREE
modifier|*
name|iqual
decl_stmt|;
name|struct
name|integrity
name|inttup
decl_stmt|,
name|intkey
decl_stmt|;
name|struct
name|tup_id
name|hitid
decl_stmt|,
name|lotid
decl_stmt|;
specifier|extern
name|QTREE
modifier|*
name|gettree
parameter_list|()
function_decl|;
specifier|extern
name|QTREE
modifier|*
name|norml
parameter_list|()
function_decl|;
ifdef|#
directive|ifdef
name|xQTR1
name|tTfp
argument_list|(
literal|40
argument_list|,
operator|-
literal|1
argument_list|,
literal|"\n->INTEGRITY\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|r
operator|=
name|root
expr_stmt|;
comment|/* 	**  Check to see if we should apply the integrity 	**  algorithm. 	** 	**  This means checking to insure that we have an update 	**  and seeing if any integrity constraints apply. 	*/
if|if
condition|(
name|Qt
operator|.
name|qt_qmode
operator|==
name|mdRETR
operator|||
operator|(
name|Qt
operator|.
name|qt_rangev
index|[
name|Qt
operator|.
name|qt_resvar
index|]
operator|.
name|rngvdesc
operator|->
name|reldum
operator|.
name|relstat
operator|&
name|S_INTEG
operator|)
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|xQTR2
name|tTfp
argument_list|(
literal|40
argument_list|,
literal|0
argument_list|,
literal|"->INTEGRITY: no integ\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|r
operator|)
return|;
block|}
comment|/* 	**  Create a set of the domains updated in this query. 	*/
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
name|dset
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
name|r
operator|->
name|left
init|;
name|p
operator|!=
name|NULL
operator|&&
name|p
operator|->
name|sym
operator|.
name|type
operator|!=
name|TREE
condition|;
name|p
operator|=
name|p
operator|->
name|left
control|)
block|{
ifdef|#
directive|ifdef
name|xQTR3
if|if
condition|(
name|p
operator|->
name|sym
operator|.
name|type
operator|!=
name|RESDOM
condition|)
name|syserr
argument_list|(
literal|"integrity: RESDOM %d"
argument_list|,
name|p
operator|->
name|sym
operator|.
name|type
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|lsetbit
argument_list|(
name|p
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_resdom
operator|.
name|resno
argument_list|,
name|dset
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|xQTR3
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
name|syserr
argument_list|(
literal|"integrity: NULL LHS"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|xQTR1
if|if
condition|(
name|tTf
argument_list|(
literal|40
argument_list|,
literal|1
argument_list|)
condition|)
name|pr_set
argument_list|(
name|dset
argument_list|,
literal|"dset"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	**  Scan integrity catalog for possible tuples.  If found, 	**  include them in the integrity qualification. 	*/
name|iqual
operator|=
name|NULL
expr_stmt|;
name|opencatalog
argument_list|(
literal|"integrities"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|setkey
argument_list|(
operator|&
name|Intdes
argument_list|,
operator|&
name|intkey
argument_list|,
name|Qt
operator|.
name|qt_rangev
index|[
name|Qt
operator|.
name|qt_resvar
index|]
operator|.
name|rngvdesc
operator|->
name|reldum
operator|.
name|relid
argument_list|,
name|INTRELID
argument_list|)
expr_stmt|;
name|setkey
argument_list|(
operator|&
name|Intdes
argument_list|,
operator|&
name|intkey
argument_list|,
name|Qt
operator|.
name|qt_rangev
index|[
name|Qt
operator|.
name|qt_resvar
index|]
operator|.
name|rngvdesc
operator|->
name|reldum
operator|.
name|relowner
argument_list|,
name|INTRELOWNER
argument_list|)
expr_stmt|;
name|find
argument_list|(
operator|&
name|Intdes
argument_list|,
name|EXACTKEY
argument_list|,
operator|&
name|lotid
argument_list|,
operator|&
name|hitid
argument_list|,
operator|&
name|intkey
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|i
operator|=
name|get
argument_list|(
operator|&
name|Intdes
argument_list|,
operator|&
name|lotid
argument_list|,
operator|&
name|hitid
argument_list|,
operator|&
name|inttup
argument_list|,
name|TRUE
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|kcompare
argument_list|(
operator|&
name|Intdes
argument_list|,
operator|&
name|intkey
argument_list|,
operator|&
name|inttup
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
ifdef|#
directive|ifdef
name|xQTR1
if|if
condition|(
name|tTf
argument_list|(
literal|40
argument_list|,
literal|2
argument_list|)
condition|)
name|printup
argument_list|(
operator|&
name|Intdes
argument_list|,
operator|&
name|inttup
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* check for some domain set overlap */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|dset
index|[
name|i
index|]
operator|&
name|inttup
operator|.
name|intdomset
index|[
name|i
index|]
operator|)
operator|!=
literal|0
condition|)
break|break;
if|if
condition|(
name|i
operator|>=
literal|8
condition|)
continue|continue;
comment|/* some domain matches, include in integrity qual */
name|i
operator|=
name|Qt
operator|.
name|qt_resvar
expr_stmt|;
name|p
operator|=
name|gettree
argument_list|(
name|Qt
operator|.
name|qt_rangev
index|[
name|i
index|]
operator|.
name|rngvdesc
operator|->
name|reldum
operator|.
name|relid
argument_list|,
name|Qt
operator|.
name|qt_rangev
index|[
name|i
index|]
operator|.
name|rngvdesc
operator|->
name|reldum
operator|.
name|relowner
argument_list|,
name|mdINTEG
argument_list|,
name|inttup
operator|.
name|inttree
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|xQTR1
if|if
condition|(
name|tTf
argument_list|(
literal|40
argument_list|,
literal|3
argument_list|)
condition|)
name|treepr
argument_list|(
name|p
argument_list|,
literal|"int_qual"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* trim off (null) target list */
name|p
operator|=
name|p
operator|->
name|right
expr_stmt|;
comment|/* merge the 'integrity' var into the Qt.qt_resvar */
name|i
operator|=
name|inttup
operator|.
name|intresvar
expr_stmt|;
if|if
condition|(
name|Qt
operator|.
name|qt_remap
index|[
name|i
index|]
operator|>=
literal|0
condition|)
name|i
operator|=
name|Qt
operator|.
name|qt_remap
index|[
name|i
index|]
expr_stmt|;
name|mergevar
argument_list|(
name|i
argument_list|,
name|Qt
operator|.
name|qt_resvar
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* add to integrity qual */
if|if
condition|(
name|iqual
operator|==
name|NULL
condition|)
name|iqual
operator|=
name|p
expr_stmt|;
else|else
name|appqual
argument_list|(
name|p
argument_list|,
name|iqual
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|syserr
argument_list|(
literal|"integrity: get %d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* 	**  Clean up the integrity qualification so that it will merge 	**  nicely into the tree, and then append it to the user's 	**  qualification. 	*/
if|if
condition|(
name|iqual
operator|!=
name|NULL
condition|)
block|{
comment|/* replace VAR nodes by corresponding user afcn */
name|subsvars
argument_list|(
operator|&
name|iqual
argument_list|,
name|Qt
operator|.
name|qt_resvar
argument_list|,
name|r
operator|->
name|left
argument_list|,
name|Qt
operator|.
name|qt_qmode
argument_list|)
expr_stmt|;
comment|/* append to tree and normalize */
name|appqual
argument_list|(
name|iqual
argument_list|,
name|r
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|xQTR3
if|if
condition|(
name|tTf
argument_list|(
literal|40
argument_list|,
literal|8
argument_list|)
condition|)
name|treepr
argument_list|(
name|r
argument_list|,
literal|"Unnormalized tree"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|r
operator|->
name|right
operator|=
name|norml
argument_list|(
name|trimqlend
argument_list|(
name|r
operator|->
name|right
argument_list|)
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|xQTR1
if|if
condition|(
name|tTf
argument_list|(
literal|40
argument_list|,
literal|15
argument_list|)
condition|)
name|treepr
argument_list|(
name|r
argument_list|,
literal|"INTEGRITY->"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

end_unit

