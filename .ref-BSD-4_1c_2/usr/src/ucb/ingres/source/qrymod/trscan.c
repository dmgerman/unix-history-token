begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|<ingres.h>
end_include

begin_include
include|#
directive|include
file|<symbol.h>
end_include

begin_include
include|#
directive|include
file|<tree.h>
end_include

begin_include
include|#
directive|include
file|"qrymod.h"
end_include

begin_include
include|#
directive|include
file|<sccs.h>
end_include

begin_macro
name|SCCSID
argument_list|(
argument|@(#)trscan.c
literal|7.1
literal|2
argument|/
literal|5
argument|/
literal|81
argument_list|)
end_macro

begin_comment
comment|/* **  AGGCHECK -- check for any aggregate in subtree. ** **	This routine checks to insure that the view algorithm can **	proceed safely by checking for aggregates in the view tree. ** **	Parameters: **		root -- the root of the tree to check. ** **	Returns: **		TRUE -- an aggregate found. **		FALSE -- no aggregates in tree. ** **	Side Effects: **		none ** **	Trace Flags: **		none. */
end_comment

begin_macro
name|aggcheck
argument_list|(
argument|root
argument_list|)
end_macro

begin_decl_stmt
name|QTREE
modifier|*
name|root
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|QTREE
modifier|*
name|t
decl_stmt|;
name|t
operator|=
name|root
expr_stmt|;
comment|/* check for no pointer */
while|while
condition|(
name|t
operator|!=
name|NULL
condition|)
block|{
comment|/* check for this node an AGHEAD */
if|if
condition|(
name|t
operator|->
name|sym
operator|.
name|type
operator|==
name|AGHEAD
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
comment|/* check left subtree recursively */
if|if
condition|(
name|aggcheck
argument_list|(
name|t
operator|->
name|left
argument_list|)
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
comment|/* check right subtree iteratively */
name|t
operator|=
name|t
operator|->
name|right
expr_stmt|;
block|}
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  VFIND -- find definition for attribute in view tree ** **	The view tree is scanned for a specified RESDOM; a pointer **	to the value is returned. ** **	Parameters: **		vn -- the variable number to dig out. **		vtree -- a pointer to the target list of the **			view definition tree. ** **	Returns: **		a pointer to the substitution value for the specified **			'vn'. **		NULL -- if not found. ** **	Side Effects: **		none ** **	Trace Flags: **		none. */
end_comment

begin_function
name|QTREE
modifier|*
name|vfind
parameter_list|(
name|vn
parameter_list|,
name|vtree
parameter_list|)
name|int
name|vn
decl_stmt|;
name|QTREE
modifier|*
name|vtree
decl_stmt|;
block|{
specifier|register
name|int
name|n
decl_stmt|;
specifier|register
name|QTREE
modifier|*
name|v
decl_stmt|;
name|n
operator|=
name|vn
expr_stmt|;
for|for
control|(
name|v
operator|=
name|vtree
init|;
name|v
operator|->
name|sym
operator|.
name|type
operator|==
name|RESDOM
condition|;
name|v
operator|=
name|v
operator|->
name|left
control|)
block|{
if|if
condition|(
name|v
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_resdom
operator|.
name|resno
operator|!=
name|n
condition|)
continue|continue;
comment|/* found the correct replacement */
return|return
operator|(
name|v
operator|->
name|right
operator|)
return|;
block|}
if|if
condition|(
name|v
operator|->
name|sym
operator|.
name|type
operator|!=
name|TREE
condition|)
name|syserr
argument_list|(
literal|"vfind: bad RESDOM node %d"
argument_list|,
name|v
operator|->
name|sym
operator|.
name|type
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  QSCAN -- find specified VAR node in subtree ** **	Intended for finding a variable in a qualification, this **	routine just scans a tree recursively looking for a node **	with the specified VAR (varno.attno) node. ** **	Parameters: **		root -- the root of the tree to scan. **		vn -- the varno to scan for. **		an -- the attno to scan for. ** **	Returns: **		A pointer to the first found VAR node which matches. **			Scan is prefix. **		NULL if not found at all. ** **	Side Effects: **		none ** **	Trace Flags: **		none. */
end_comment

begin_function
name|QTREE
modifier|*
name|qscan
parameter_list|(
name|root
parameter_list|,
name|vn
parameter_list|,
name|an
parameter_list|)
name|QTREE
modifier|*
name|root
decl_stmt|;
name|int
name|vn
decl_stmt|;
name|int
name|an
decl_stmt|;
block|{
specifier|register
name|QTREE
modifier|*
name|t
decl_stmt|;
specifier|register
name|QTREE
modifier|*
name|u
decl_stmt|;
name|t
operator|=
name|root
expr_stmt|;
comment|/* check for null node */
if|if
condition|(
name|t
operator|==
name|NULL
condition|)
return|return
operator|(
name|t
operator|)
return|;
comment|/* check to see if this node qualifies */
if|if
condition|(
name|t
operator|->
name|sym
operator|.
name|type
operator|==
name|VAR
operator|&&
name|t
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_var
operator|.
name|varno
operator|==
name|vn
operator|&&
name|t
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_var
operator|.
name|attno
operator|==
name|an
condition|)
return|return
operator|(
name|t
operator|)
return|;
comment|/* check other nodes */
if|if
condition|(
operator|(
name|u
operator|=
name|qscan
argument_list|(
name|t
operator|->
name|left
argument_list|,
name|vn
argument_list|,
name|an
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
return|return
operator|(
name|u
operator|)
return|;
return|return
operator|(
name|qscan
argument_list|(
name|t
operator|->
name|right
argument_list|,
name|vn
argument_list|,
name|an
argument_list|)
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  VARSET -- scan tree and set a bit vector of variables ** **	The return value is a bit vector representing the set of **	variables used in that subtree. ** **	Parameters: **		root -- the root of the tree to check. ** **	Returns: **		A bit vector, such that bit zero (on the low order, **			right-hand end) means var zero. ** **	Side Effects: **		none ** **	Trace Flags: **		none */
end_comment

begin_macro
name|varset
argument_list|(
argument|root
argument_list|)
end_macro

begin_decl_stmt
name|QTREE
modifier|*
name|root
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|QTREE
modifier|*
name|t
decl_stmt|;
specifier|register
name|int
name|s
decl_stmt|;
name|t
operator|=
name|root
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* scan left and right branches */
name|s
operator|=
name|varset
argument_list|(
name|t
operator|->
name|left
argument_list|)
expr_stmt|;
name|s
operator||=
name|varset
argument_list|(
name|t
operator|->
name|right
argument_list|)
expr_stmt|;
comment|/* check out this node */
if|if
condition|(
name|t
operator|->
name|sym
operator|.
name|type
operator|==
name|VAR
condition|)
block|{
comment|/* or in bit corresponding to this varno */
name|s
operator||=
literal|1
operator|<<
name|t
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_var
operator|.
name|varno
expr_stmt|;
block|}
return|return
operator|(
name|s
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  SUBSVARS -- scan query tree and replace VAR nodes ** **	Scans a tree and finds all VAR nodes for this variable. **	These nodes are looked up in the translation tree and **	replaced by the value found there.  If this is for a **	view, the corresponding node must exist in the translation **	tree, otherwise, a 'zero' node (of a type appropriate based **	on the context) is created and inserted. ** **	This routine is one half of the guts of the whole view **	algorithm. ** **	VAR nodes are detached and replaced with the replacement **	as defined by the view.  Note that there can never be any **	problems here, since VAR nodes are only used in retrieve **	contexts. ** **	It does some extra processing with RESDOM nodes with **	resno = 0.  These nodes specify a 'tid' domain, and are **	included by the parser on REPLACE and DELETE commands **	(for some reason decomp wants them).  Subsvars will allow **	this construct iff the right hand pointer is a VAR node **	with attno = 0.  In this case it just changes the varno **	of the VAR node to be the Qt.qt_resvar number.  This is be- **	cause the Qt.qt_resvar is the variable number of the one and **	only underlying base relation of the view on an update **	(which is presumably the only case where this can come **	up).  Vrscan has already insured that there can only be **	a single base relation in this case. ** **	This whole messy thing is only done with view substitutions. ** **	Parameters: **		proot -- a pointer to the pointer to the root of the **			tree to be updated. **		vn -- the varno of the view variable.  This is the **			varno which will be scanned for. **		transtree -- a pointer to the left branch (target list) **			of the translation tree. **		vmode -- mdVIEW if called from view processor, mdAPP **			if called from the integrity processor with **			an APPEND command, else something else. **			Mostly, changes the handling of TID type **			nodes, and forces an error on a view if the **			VAR node in the scanned tree does not exist **			in the vtree. ** **	Returns: **		none **		(non-local on error). ** **	Side Effects: **		The tree pointed to by *proot is updated in possibly **			very exciting ways. ** **	Trace Flags: **		32 */
end_comment

begin_macro
name|subsvars
argument_list|(
argument|proot
argument_list|,
argument|vn
argument_list|,
argument|transtree
argument_list|,
argument|vmode
argument_list|)
end_macro

begin_decl_stmt
name|QTREE
modifier|*
modifier|*
name|proot
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|vn
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|QTREE
modifier|*
name|transtree
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|vmode
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|QTREE
modifier|*
name|t
decl_stmt|;
specifier|register
name|QTREE
modifier|*
name|v
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|extern
name|QTREE
modifier|*
name|vfind
parameter_list|()
function_decl|;
specifier|extern
name|QTREE
modifier|*
name|makezero
parameter_list|()
function_decl|;
specifier|extern
name|QTREE
modifier|*
name|treedup
parameter_list|()
function_decl|;
name|t
operator|=
operator|*
name|proot
expr_stmt|;
name|v
operator|=
name|transtree
expr_stmt|;
ifdef|#
directive|ifdef
name|xQTR3
if|if
condition|(
name|tTf
argument_list|(
literal|32
argument_list|,
literal|0
argument_list|)
condition|)
name|printf
argument_list|(
literal|"subsvars: vn %d root %u transtree %u\n"
argument_list|,
name|vn
argument_list|,
name|t
argument_list|,
name|v
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|t
operator|==
name|NULL
condition|)
return|return;
comment|/* check left branch of the tree */
name|subsvars
argument_list|(
operator|&
name|t
operator|->
name|left
argument_list|,
name|vn
argument_list|,
name|v
argument_list|,
name|vmode
argument_list|)
expr_stmt|;
comment|/* check for special 'tid' RESDOM (used by DEL and REPL) */
if|if
condition|(
name|t
operator|->
name|sym
operator|.
name|type
operator|==
name|RESDOM
operator|&&
name|t
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_resdom
operator|.
name|resno
operator|==
literal|0
condition|)
block|{
comment|/* test for not Qt.qt_resvar, in which case we ignore leaf */
if|if
condition|(
name|vn
operator|!=
name|Qt
operator|.
name|qt_resvar
condition|)
return|return;
comment|/* t->right better be VAR node, attno 0 */
name|t
operator|=
name|t
operator|->
name|right
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|sym
operator|.
name|type
operator|!=
name|VAR
operator|||
name|t
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_var
operator|.
name|attno
operator|!=
literal|0
operator|||
name|t
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_var
operator|.
name|varno
operator|!=
name|vn
condition|)
name|syserr
argument_list|(
literal|"subsvars: RESDOM 0 not VAR 0 %d, %d, %d"
argument_list|,
name|vn
argument_list|,
name|t
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_var
operator|.
name|attno
argument_list|,
name|t
operator|->
name|sym
operator|.
name|type
argument_list|)
expr_stmt|;
comment|/* change varno to new Qm.qm_newresvar (set by vrscan) */
ifdef|#
directive|ifdef
name|xQTR3
if|if
condition|(
name|tTf
argument_list|(
literal|32
argument_list|,
literal|1
argument_list|)
condition|)
name|printf
argument_list|(
literal|"RESDOM 0: Qm.qm_newresvar %d\n"
argument_list|,
name|Qm
operator|.
name|qm_newresvar
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|t
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_var
operator|.
name|varno
operator|=
name|Qm
operator|.
name|qm_newresvar
expr_stmt|;
return|return;
block|}
comment|/* scan right branch */
name|subsvars
argument_list|(
operator|&
name|t
operator|->
name|right
argument_list|,
name|vn
argument_list|,
name|v
argument_list|,
name|vmode
argument_list|)
expr_stmt|;
comment|/* check for interesting node */
if|if
condition|(
name|t
operator|->
name|sym
operator|.
name|type
operator|!=
name|VAR
operator|||
name|t
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_var
operator|.
name|varno
operator|!=
name|vn
condition|)
return|return;
comment|/* test for special 'tid' attribute case */
if|if
condition|(
name|t
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_var
operator|.
name|attno
operator|==
literal|0
operator|&&
name|vmode
operator|==
name|mdVIEW
condition|)
block|{
name|qmerror
argument_list|(
literal|3340
argument_list|,
name|Qt
operator|.
name|qt_qmode
argument_list|,
name|vn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* views do not have tids */
block|}
comment|/* find var in vtree */
name|v
operator|=
name|vfind
argument_list|(
name|t
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_var
operator|.
name|attno
argument_list|,
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|vmode
operator|==
name|mdVIEW
condition|)
name|syserr
argument_list|(
literal|"subsvars: attno %d"
argument_list|,
name|t
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_var
operator|.
name|attno
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|vmode
operator|==
name|mdAPP
condition|)
name|v
operator|=
name|makezero
argument_list|()
expr_stmt|;
block|}
else|else
name|v
operator|=
name|treedup
argument_list|(
name|v
argument_list|)
expr_stmt|;
comment|/* replace VAR node */
if|if
condition|(
name|v
operator|!=
name|NULL
condition|)
operator|*
name|proot
operator|=
name|v
expr_stmt|;
block|}
end_block

end_unit

