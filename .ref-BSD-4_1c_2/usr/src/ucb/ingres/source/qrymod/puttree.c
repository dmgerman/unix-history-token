begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|<ingres.h>
end_include

begin_include
include|#
directive|include
file|<catalog.h>
end_include

begin_include
include|#
directive|include
file|<symbol.h>
end_include

begin_include
include|#
directive|include
file|<lock.h>
end_include

begin_include
include|#
directive|include
file|<tree.h>
end_include

begin_include
include|#
directive|include
file|"qrymod.h"
end_include

begin_include
include|#
directive|include
file|<sccs.h>
end_include

begin_macro
name|SCCSID
argument_list|(
argument|@(#)puttree.c
literal|7.1
literal|2
argument|/
literal|5
argument|/
literal|81
argument_list|)
end_macro

begin_comment
comment|/* **  PUTTREE -- put tree into 'tree' catalog ** **	The named tree is inserted into the 'tree' catalog. ** **	The algorithm is to lock up the entire catalog and try to **	find the smallest unique id possible for the named relation. ** **	Parameters: **		root -- the root of the tree to insert. **		treerelid -- the relid of the relation for which **			this tree applies. **		treeowner -- the owner of the above relation. **		treetype -- the type of this tree; uses the mdXXX **			type (as mdPROT, mdINTEG, mdDISTR, etc.). ** **	Returns: **		The treeid that was assigned to this tree. ** **	Side Effects: **		The tree catalog gets locked, and information is **		inserted. ** **	Trace Flags: **		10 */
end_comment

begin_macro
name|puttree
argument_list|(
argument|root
argument_list|,
argument|trelid
argument_list|,
argument|towner
argument_list|,
argument|ttype
argument_list|)
end_macro

begin_decl_stmt
name|QTREE
modifier|*
name|root
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|trelid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|towner
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ttype
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|tree
name|treekey
decl_stmt|;
name|struct
name|tree
name|treetup
decl_stmt|;
name|struct
name|tup_id
name|treetid
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|auto
name|int
name|treeid
decl_stmt|;
name|opencatalog
argument_list|(
literal|"tree"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* 	**  Find a unique tree identifier. 	**	Lock the tree catalog, and scan until we find a 	**	tuple which does not match. 	*/
name|setrll
argument_list|(
name|A_SLP
argument_list|,
name|Treedes
operator|.
name|reltid
operator|.
name|ltid
argument_list|,
name|M_EXCL
argument_list|)
expr_stmt|;
name|setkey
argument_list|(
operator|&
name|Treedes
argument_list|,
operator|&
name|treekey
argument_list|,
name|trelid
argument_list|,
name|TREERELID
argument_list|)
expr_stmt|;
name|setkey
argument_list|(
operator|&
name|Treedes
argument_list|,
operator|&
name|treekey
argument_list|,
name|towner
argument_list|,
name|TREEOWNER
argument_list|)
expr_stmt|;
name|setkey
argument_list|(
operator|&
name|Treedes
argument_list|,
operator|&
name|treekey
argument_list|,
operator|&
name|ttype
argument_list|,
name|TREETYPE
argument_list|)
expr_stmt|;
for|for
control|(
name|treeid
operator|=
literal|0
init|;
condition|;
name|treeid
operator|++
control|)
block|{
name|setkey
argument_list|(
operator|&
name|Treedes
argument_list|,
operator|&
name|treekey
argument_list|,
operator|&
name|treeid
argument_list|,
name|TREEID
argument_list|)
expr_stmt|;
name|i
operator|=
name|getequal
argument_list|(
operator|&
name|Treedes
argument_list|,
operator|&
name|treekey
argument_list|,
operator|&
name|treetup
argument_list|,
operator|&
name|treetid
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|syserr
argument_list|(
literal|"d_tree: getequal"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|>
literal|0
condition|)
break|break;
block|}
comment|/* 	**  We have a unique tree id. 	**	Insert the new tuple and the tree into the 	**	tree catalog. 	*/
name|relntrwr
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
name|trelid
argument_list|,
name|towner
argument_list|,
name|ttype
argument_list|,
name|treeid
argument_list|)
expr_stmt|;
name|writeqry
argument_list|(
name|root
argument_list|,
name|relntrwr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|relntrwr
argument_list|(
name|NULL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* all inserted -- flush pages and unlock */
if|if
condition|(
name|noclose
argument_list|(
operator|&
name|Treedes
argument_list|)
operator|!=
literal|0
condition|)
name|syserr
argument_list|(
literal|"d_tree: noclose"
argument_list|)
expr_stmt|;
name|unlrl
argument_list|(
name|Treedes
operator|.
name|reltid
operator|.
name|ltid
argument_list|)
expr_stmt|;
return|return
operator|(
name|treeid
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  RELNTRWR -- physical tree write to relation ** **	This is the routine called from writeqry to write trees **	to the 'tree' relation (rather than the W_down pipe). ** **	It is assumed that the (treerelid, treeowner, treetype, **	treeid) combination is unique in the tree catalog, and that **	the tree catalog is locked. ** **	Parameters: **		ptr -- a pointer to the data.  If NULL, this is **			a control call. **		len -- the length of the data.  If ptr == NULL, this **			field is a control code:  zero means **			initialize (thus taking the next two param- **			eters); one means flush. **		treerelid -- the name of the relation for which this **			tree applies (init only). **		treeowner -- the owner of this relation (init only). **		treetype -- on initialization, this tells what the **			tree is used for. **		treeid -- on initialization, this is the tree id we **			want to use. ** **	Returns: **		The number of bytes written ('len'). ** **	Side Effects: **		Well, yes.  Activity occurs in the tree catalog. ** **	Trace Flags: **		none */
end_comment

begin_macro
name|relntrwr
argument_list|(
argument|ptr
argument_list|,
argument|len
argument_list|,
argument|treerelid
argument_list|,
argument|treeowner
argument_list|,
argument|treetype
argument_list|,
argument|treeid
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|ptr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|len
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|treerelid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|treeowner
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|treetype
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|treeid
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|static
name|struct
name|tree
name|treetup
decl_stmt|;
name|struct
name|tup_id
name|treetid
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|l
decl_stmt|;
specifier|static
name|char
modifier|*
name|tptr
decl_stmt|;
name|p
operator|=
name|ptr
expr_stmt|;
name|l
operator|=
name|len
expr_stmt|;
comment|/* check for special function */
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
switch|switch
condition|(
name|l
condition|)
block|{
case|case
literal|0
case|:
name|clr_tuple
argument_list|(
operator|&
name|Treedes
argument_list|,
operator|&
name|treetup
argument_list|)
expr_stmt|;
name|bmove
argument_list|(
name|treerelid
argument_list|,
name|treetup
operator|.
name|treerelid
argument_list|,
name|MAXNAME
argument_list|)
expr_stmt|;
name|bmove
argument_list|(
name|treeowner
argument_list|,
name|treetup
operator|.
name|treeowner
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|treetup
operator|.
name|treetype
operator|=
name|treetype
expr_stmt|;
name|treetup
operator|.
name|treeid
operator|=
name|treeid
expr_stmt|;
name|tptr
operator|=
name|treetup
operator|.
name|treetree
expr_stmt|;
break|break;
case|case
literal|1
case|:
if|if
condition|(
name|tptr
operator|!=
name|treetup
operator|.
name|treetree
condition|)
block|{
if|if
condition|(
name|insert
argument_list|(
operator|&
name|Treedes
argument_list|,
operator|&
name|treetid
argument_list|,
operator|&
name|treetup
argument_list|,
name|FALSE
argument_list|)
operator|<
literal|0
condition|)
name|syserr
argument_list|(
literal|"relntrwr: insert 1"
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|syserr
argument_list|(
literal|"relntrwr: ctl %d"
argument_list|,
name|l
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
comment|/* output bytes */
while|while
condition|(
name|l
operator|--
operator|>
literal|0
condition|)
block|{
operator|*
name|tptr
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
comment|/* check for buffer overflow */
if|if
condition|(
name|tptr
operator|<
operator|&
name|treetup
operator|.
name|treetree
index|[
sizeof|sizeof
name|treetup
operator|.
name|treetree
index|]
condition|)
continue|continue;
comment|/* yep, flush buffer to relation */
if|if
condition|(
name|insert
argument_list|(
operator|&
name|Treedes
argument_list|,
operator|&
name|treetid
argument_list|,
operator|&
name|treetup
argument_list|,
name|FALSE
argument_list|)
operator|<
literal|0
condition|)
name|syserr
argument_list|(
literal|"relntrwr: insert 2"
argument_list|)
expr_stmt|;
name|treetup
operator|.
name|treeseq
operator|++
expr_stmt|;
name|tptr
operator|=
name|treetup
operator|.
name|treetree
expr_stmt|;
comment|/* clear out the rest of the tuple for aesthetic reasons */
operator|*
name|tptr
operator|=
literal|' '
expr_stmt|;
name|bmove
argument_list|(
name|tptr
argument_list|,
name|tptr
operator|+
literal|1
argument_list|,
sizeof|sizeof
name|treetup
operator|.
name|treetree
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|len
operator|)
return|;
block|}
end_block

end_unit

