begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|<ingres.h>
end_include

begin_include
include|#
directive|include
file|<aux.h>
end_include

begin_include
include|#
directive|include
file|<tree.h>
end_include

begin_include
include|#
directive|include
file|"globs.h"
end_include

begin_include
include|#
directive|include
file|<lock.h>
end_include

begin_include
include|#
directive|include
file|<sccs.h>
end_include

begin_macro
name|SCCSID
argument_list|(
argument|@(#)lockit.c
literal|7.1
literal|2
argument|/
literal|5
argument|/
literal|81
argument_list|)
end_macro

begin_comment
comment|/* **  LOCKIT -- sets relation locks for integrity locking ** **	Parameters: **		root- the root of a query tree; **		resvar- index of variable to be updated. ** */
end_comment

begin_macro
name|lockit
argument_list|(
argument|root
argument_list|,
argument|resvar
argument_list|)
end_macro

begin_decl_stmt
name|QTREE
modifier|*
name|root
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|resvar
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|QTREE
modifier|*
name|r
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|long
name|vlist
index|[
name|MAXRANGE
index|]
decl_stmt|;
name|int
name|bmap
decl_stmt|,
name|cv
decl_stmt|;
name|char
name|mode
decl_stmt|;
name|int
name|skvr
decl_stmt|;
name|int
name|redo
decl_stmt|;
name|DESC
modifier|*
name|d
decl_stmt|,
modifier|*
name|openr1
argument_list|()
decl_stmt|;
name|long
name|restid
decl_stmt|;
name|int
name|k
decl_stmt|;
name|r
operator|=
name|root
expr_stmt|;
name|bmap
operator|=
name|r
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_root
operator|.
name|lvarm
operator||
name|r
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_root
operator|.
name|rvarm
expr_stmt|;
if|if
condition|(
name|resvar
operator|>=
literal|0
condition|)
name|bmap
operator||=
literal|01
operator|<<
name|resvar
expr_stmt|;
else|else
name|restid
operator|=
operator|-
literal|1
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
comment|/* put relids of relations to be locked into vlist 	   check for and remove duplicates */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|MAXRANGE
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|bmap
operator|&
operator|(
literal|01
operator|<<
name|j
operator|)
condition|)
block|{
name|d
operator|=
name|openr1
argument_list|(
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|==
name|resvar
condition|)
name|restid
operator|=
name|d
operator|->
name|reltid
operator|.
name|ltid
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|i
condition|;
name|k
operator|++
control|)
if|if
condition|(
name|vlist
index|[
name|k
index|]
operator|==
name|d
operator|->
name|reltid
operator|.
name|ltid
condition|)
break|break;
if|if
condition|(
name|k
operator|==
name|i
condition|)
name|vlist
index|[
name|i
operator|++
index|]
operator|=
name|d
operator|->
name|reltid
operator|.
name|ltid
expr_stmt|;
block|}
name|cv
operator|=
name|i
expr_stmt|;
comment|/*  *	set the locks: set the first lock with the sleep option  *			set other locks checking for failure;  *			if failure, release all locks, sleep on blocking  *			lock.  */
name|skvr
operator|=
operator|-
literal|1
expr_stmt|;
do|do
block|{
comment|/* skvr is the index of the relation already locked 		   try to lock the remaining relations */
name|redo
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cv
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|i
operator|!=
name|skvr
condition|)
block|{
if|if
condition|(
name|restid
operator|==
name|vlist
index|[
name|i
index|]
condition|)
name|mode
operator|=
name|M_EXCL
expr_stmt|;
else|else
name|mode
operator|=
name|M_SHARE
expr_stmt|;
if|if
condition|(
name|setrll
argument_list|(
name|A_RTN
argument_list|,
name|vlist
index|[
name|i
index|]
argument_list|,
name|mode
argument_list|)
operator|<
literal|0
condition|)
comment|/* a lock request failed */
block|{
name|unlall
argument_list|()
expr_stmt|;
comment|/* release all locks */
name|setrll
argument_list|(
name|A_SLP
argument_list|,
name|vlist
index|[
name|i
index|]
argument_list|,
name|mode
argument_list|)
expr_stmt|;
comment|/* wait on problem lock*/
name|skvr
operator|=
name|i
expr_stmt|;
name|redo
operator|=
name|TRUE
expr_stmt|;
break|break;
comment|/* reset the other locks */
block|}
block|}
block|}
do|while
condition|(
name|redo
condition|)
do|;
block|}
end_block

end_unit

