begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|<ingres.h>
end_include

begin_include
include|#
directive|include
file|<tree.h>
end_include

begin_include
include|#
directive|include
file|<symbol.h>
end_include

begin_include
include|#
directive|include
file|<pv.h>
end_include

begin_include
include|#
directive|include
file|"globs.h"
end_include

begin_include
include|#
directive|include
file|<sccs.h>
end_include

begin_macro
name|SCCSID
argument_list|(
argument|@(#)byeval.c
literal|7.1
literal|2
argument|/
literal|5
argument|/
literal|81
argument_list|)
end_macro

begin_comment
comment|/* **	BYEVAL - process aggregate function ** **	Byeval is passed the root of the original query **	tree and the root of the aggregate function to **	be processed. ** **	It first creates a temporary relation which will **	hold the aggregate result. The format of the relation **	is: **	_SYSxxxxxaa(count, by-dom1, ... , by-domn, ag1, ... , agm) ** **	The relation is moved into the range table and will become **	a part of the query. ** **	If there are any occurences of the variables **	from the by-domains, anywhere in the original query tree, **	the aggregate relation is linked on all by-domains in the **	original query tree. ** **	If the aggregate is unique, multivariable, or has a **	qualification, then special processing is done. ** **	If the aggregate is qualified then the by-domains are **	projected into the result relation. This guarantees that **	every value of the by-domains will be represented in the **	aggregate result. ** **	If the aggregate is unique or multivariable, then another **	temporary relation is created and the values which will be **	aggregated; along with the by-domains, are retrieved into **	the temporary relation. ** **	If unique, then duplicates are removed from the temporary relation. ** **	Next the result relation for the aggregate is modified **	to hash in order to speed up the processing of the aggregate **	and guarantee that there are no duplicates in the bylist. ** **	The aggregate is then run, and if a temporary relation was **	created (eg. unique or multivar aggregate) then it is destroyed. ** **	Trace Flags: **		42 */
end_comment

begin_function
name|QTREE
modifier|*
name|byeval
parameter_list|(
name|root
parameter_list|,
name|aghead
parameter_list|,
name|agvar
parameter_list|)
name|QTREE
modifier|*
name|root
decl_stmt|;
comment|/* root of orig query */
name|QTREE
modifier|*
name|aghead
decl_stmt|;
comment|/* root of ag fcn sub-tree */
name|int
name|agvar
decl_stmt|;
comment|/* variable number assigned to this aggregate */
block|{
specifier|register
name|QTREE
modifier|*
name|q
decl_stmt|,
modifier|*
name|ag
decl_stmt|,
modifier|*
name|resdom
decl_stmt|;
name|QTREE
modifier|*
name|r
decl_stmt|;
name|int
name|temp_relnum
decl_stmt|,
name|i
decl_stmt|,
name|filled
decl_stmt|;
name|QTREE
modifier|*
name|lnodv
index|[
name|MAXDOM
operator|+
literal|2
index|]
decl_stmt|,
modifier|*
name|save_node
index|[
name|MAXDOM
operator|+
literal|2
index|]
decl_stmt|;
name|char
name|agbuf
index|[
name|AGBUFSIZ
index|]
decl_stmt|;
name|char
name|nums
index|[
literal|2
index|]
decl_stmt|;
name|int
name|relnum
decl_stmt|;
name|QTREE
modifier|*
name|byhead
decl_stmt|,
modifier|*
modifier|*
name|alnp
decl_stmt|;
name|int
name|bydoms
decl_stmt|,
name|bymap
decl_stmt|,
name|primeag
decl_stmt|,
name|srcmap
decl_stmt|;
specifier|extern
name|int
name|derror
parameter_list|()
function_decl|;
specifier|extern
name|QTREE
modifier|*
name|makroot
argument_list|()
decl_stmt|,
modifier|*
name|makavar
argument_list|()
decl_stmt|,
modifier|*
name|makresdom
argument_list|()
decl_stmt|,
modifier|*
name|copytree
argument_list|()
decl_stmt|;
specifier|extern
name|char
modifier|*
name|rnum_convert
parameter_list|()
function_decl|;
ifdef|#
directive|ifdef
name|xDTR1
if|if
condition|(
name|tTf
argument_list|(
literal|42
argument_list|,
operator|-
literal|1
argument_list|)
condition|)
name|printf
argument_list|(
literal|"BYEVAL\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ag
operator|=
name|aghead
expr_stmt|;
name|byhead
operator|=
name|ag
operator|->
name|left
expr_stmt|;
comment|/* first create the aggregate result relation */
comment|/* params for create */
name|initp
argument_list|()
expr_stmt|;
comment|/* init globals for setp */
name|setp
argument_list|(
name|PV_STR
argument_list|,
literal|"0"
argument_list|)
expr_stmt|;
comment|/* initial relstat field */
name|relnum
operator|=
name|rnum_alloc
argument_list|()
expr_stmt|;
name|setp
argument_list|(
name|PV_STR
argument_list|,
name|rnum_convert
argument_list|(
name|relnum
argument_list|)
argument_list|)
expr_stmt|;
name|setp
argument_list|(
name|PV_STR
argument_list|,
literal|"count"
argument_list|)
expr_stmt|;
comment|/* domain 1 - count field per BY value */
name|setp
argument_list|(
name|PV_STR
argument_list|,
literal|"i4"
argument_list|)
expr_stmt|;
comment|/* format of count field */
name|i
operator|=
name|bydoms
operator|=
name|lnode
argument_list|(
name|byhead
operator|->
name|left
argument_list|,
name|lnodv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|lnodv
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|alnp
operator|=
operator|&
name|lnodv
index|[
operator|++
name|i
index|]
expr_stmt|;
name|i
operator|=
name|lnode
argument_list|(
name|byhead
operator|->
name|right
argument_list|,
name|lnodv
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|lnodv
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|domnam
argument_list|(
name|lnodv
argument_list|,
literal|"by"
argument_list|)
expr_stmt|;
comment|/* BY list domains */
name|domnam
argument_list|(
name|alnp
argument_list|,
literal|"ag"
argument_list|)
expr_stmt|;
comment|/* aggregate value domains */
name|call_dbu
argument_list|(
name|mdCREATE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|De
operator|.
name|de_rangev
index|[
name|agvar
index|]
operator|.
name|relnum
operator|=
name|relnum
expr_stmt|;
ifdef|#
directive|ifdef
name|xDTR1
if|if
condition|(
name|tTf
argument_list|(
literal|42
argument_list|,
literal|7
argument_list|)
condition|)
name|printf
argument_list|(
literal|"agvar=%d,rel=%s\n"
argument_list|,
name|agvar
argument_list|,
name|rnum_convert
argument_list|(
name|relnum
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bymap
operator|=
name|varfind
argument_list|(
name|byhead
operator|->
name|left
argument_list|,
operator|(
name|QTREE
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	** Find all variables in the tree in which you are nested. 	** Do not look at any other aggregates in the tree. Just in 	** case the root is an aggregate, explicitly look at its 	** two descendents. 	*/
name|srcmap
operator|=
name|varfind
argument_list|(
name|root
operator|->
name|left
argument_list|,
name|ag
argument_list|)
operator||
name|varfind
argument_list|(
name|root
operator|->
name|right
argument_list|,
name|ag
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|xDTR1
if|if
condition|(
name|tTf
argument_list|(
literal|42
argument_list|,
literal|8
argument_list|)
condition|)
name|printf
argument_list|(
literal|"bymap=%o,srcmap=%o\n"
argument_list|,
name|bymap
argument_list|,
name|srcmap
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|bymap
operator|&
name|srcmap
condition|)
name|modqual
argument_list|(
name|root
argument_list|,
name|lnodv
argument_list|,
name|srcmap
argument_list|,
name|agvar
argument_list|)
expr_stmt|;
comment|/* if aggregate is unique or there is a qualification 	** or aggregate is multi-var, then special processing is done */
name|temp_relnum
operator|=
name|NORESULT
expr_stmt|;
name|filled
operator|=
name|FALSE
expr_stmt|;
name|primeag
operator|=
name|prime
argument_list|(
name|byhead
operator|->
name|right
argument_list|)
expr_stmt|;
if|if
condition|(
name|ag
operator|->
name|right
operator|->
name|sym
operator|.
name|type
operator|!=
name|QLEND
operator|||
name|ag
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_root
operator|.
name|tvarc
operator|>
literal|1
operator|||
name|primeag
condition|)
block|{
comment|/* init a buffer for new tree components */
name|initbuf
argument_list|(
name|agbuf
argument_list|,
name|AGBUFSIZ
argument_list|,
name|AGBUFFULL
argument_list|,
name|derror
argument_list|)
expr_stmt|;
comment|/* make a root for a new tree */
name|q
operator|=
name|makroot
argument_list|(
name|agbuf
argument_list|)
expr_stmt|;
comment|/* 		** Create a RESDOM for each by-domain in the original 		** aggregate. Rather than using the existing by-domain 		** function, a copy is used instead. This is necessary 		** since that subtree might be needed later (if modqual()) 		** decided to use it. Decomp does not restore the trees 		** it uses and thus the by-domains might be altered. 		*/
for|for
control|(
name|i
operator|=
literal|0
init|;
name|r
operator|=
name|lnodv
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|resdom
operator|=
name|makresdom
argument_list|(
name|agbuf
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|resdom
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_resdom
operator|.
name|resno
operator|=
name|i
operator|+
literal|2
expr_stmt|;
name|resdom
operator|->
name|right
operator|=
name|copytree
argument_list|(
name|r
operator|->
name|right
argument_list|,
name|agbuf
argument_list|)
expr_stmt|;
name|resdom
operator|->
name|left
operator|=
name|q
operator|->
name|left
expr_stmt|;
name|q
operator|->
name|left
operator|=
name|resdom
expr_stmt|;
block|}
name|mapvar
argument_list|(
name|q
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* make maps on root */
ifdef|#
directive|ifdef
name|xDTR1
if|if
condition|(
name|tTf
argument_list|(
literal|42
argument_list|,
literal|2
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"byedomains\n"
argument_list|)
expr_stmt|;
name|treepr
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* if agg is qualified, project by-domains into result */
if|if
condition|(
name|ag
operator|->
name|right
operator|->
name|sym
operator|.
name|type
operator|!=
name|QLEND
condition|)
block|{
name|filled
operator|=
name|TRUE
expr_stmt|;
name|i
operator|=
name|De
operator|.
name|de_sourcevar
expr_stmt|;
comment|/* save value */
name|decomp
argument_list|(
name|q
argument_list|,
name|mdRETR
argument_list|,
name|relnum
argument_list|)
expr_stmt|;
name|De
operator|.
name|de_sourcevar
operator|=
name|i
expr_stmt|;
comment|/* restore value */
block|}
comment|/* if agg is prime or multivar, compute into temp rel */
if|if
condition|(
name|ag
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_root
operator|.
name|tvarc
operator|>
literal|1
operator|||
name|primeag
condition|)
block|{
name|q
operator|->
name|right
operator|=
name|ag
operator|->
name|right
expr_stmt|;
comment|/* give q the qualification */
name|ag
operator|->
name|right
operator|=
name|De
operator|.
name|de_qle
expr_stmt|;
comment|/* remove qualification from ag */
comment|/* put aop resdoms on tree */
for|for
control|(
name|i
operator|=
name|bydoms
operator|+
literal|1
init|;
name|r
operator|=
name|lnodv
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|resdom
operator|=
name|makresdom
argument_list|(
name|agbuf
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|resdom
operator|->
name|right
operator|=
name|r
operator|->
name|right
expr_stmt|;
name|resdom
operator|->
name|left
operator|=
name|q
operator|->
name|left
expr_stmt|;
name|q
operator|->
name|left
operator|=
name|resdom
expr_stmt|;
comment|/* make aop refer to temp relation */
name|r
operator|->
name|right
operator|=
name|makavar
argument_list|(
name|resdom
argument_list|,
name|FREEVAR
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
comment|/* assign result domain numbers */
for|for
control|(
name|resdom
operator|=
name|q
operator|->
name|left
init|;
name|resdom
operator|->
name|sym
operator|.
name|type
operator|!=
name|TREE
condition|;
name|resdom
operator|=
name|resdom
operator|->
name|left
control|)
name|resdom
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_resdom
operator|.
name|resno
operator|=
operator|--
name|i
expr_stmt|;
comment|/* 			** change by-list in agg to reference new source rel. 			** Save the old bylist to be restored at the end of 			** this aggregate. 			*/
for|for
control|(
name|i
operator|=
literal|0
init|;
name|resdom
operator|=
name|lnodv
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|save_node
index|[
name|i
index|]
operator|=
name|resdom
operator|->
name|right
expr_stmt|;
name|resdom
operator|->
name|right
operator|=
name|makavar
argument_list|(
name|resdom
argument_list|,
name|FREEVAR
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|mapvar
argument_list|(
name|q
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|xDTR1
if|if
condition|(
name|tTf
argument_list|(
literal|42
argument_list|,
literal|3
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"new ag src\n"
argument_list|)
expr_stmt|;
name|treepr
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* create temp relation */
name|temp_relnum
operator|=
name|mak_t_rel
argument_list|(
name|q
argument_list|,
literal|"a"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|decomp
argument_list|(
name|q
argument_list|,
name|mdRETR
argument_list|,
name|temp_relnum
argument_list|)
expr_stmt|;
name|De
operator|.
name|de_rangev
index|[
name|FREEVAR
index|]
operator|.
name|relnum
operator|=
name|temp_relnum
expr_stmt|;
name|De
operator|.
name|de_sourcevar
operator|=
name|FREEVAR
expr_stmt|;
if|if
condition|(
name|primeag
condition|)
name|removedups
argument_list|(
name|FREEVAR
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|xDTR1
if|if
condition|(
name|tTf
argument_list|(
literal|42
argument_list|,
literal|4
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"new agg\n"
argument_list|)
expr_stmt|;
name|treepr
argument_list|(
name|ag
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
block|}
comment|/* set up parameters for modify to hash */
name|initp
argument_list|()
expr_stmt|;
name|setp
argument_list|(
name|PV_STR
argument_list|,
name|rnum_convert
argument_list|(
name|relnum
argument_list|)
argument_list|)
expr_stmt|;
name|setp
argument_list|(
name|PV_STR
argument_list|,
literal|"hash"
argument_list|)
expr_stmt|;
comment|/* modify the empty rel to hash */
name|setp
argument_list|(
name|PV_STR
argument_list|,
literal|"num"
argument_list|)
expr_stmt|;
comment|/* code to indicate numeric domain names */
name|nums
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bydoms
condition|;
name|i
operator|++
control|)
block|{
name|nums
index|[
literal|0
index|]
operator|=
name|i
operator|+
literal|2
expr_stmt|;
name|setp
argument_list|(
name|PV_STR
argument_list|,
name|nums
argument_list|)
expr_stmt|;
block|}
name|setp
argument_list|(
name|PV_STR
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|/* set up fill factor information */
name|setp
argument_list|(
name|PV_STR
argument_list|,
literal|"minpages"
argument_list|)
expr_stmt|;
if|if
condition|(
name|filled
condition|)
block|{
name|setp
argument_list|(
name|PV_STR
argument_list|,
literal|"1"
argument_list|)
expr_stmt|;
name|setp
argument_list|(
name|PV_STR
argument_list|,
literal|"fillfactor"
argument_list|)
expr_stmt|;
name|setp
argument_list|(
name|PV_STR
argument_list|,
literal|"100"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|setp
argument_list|(
name|PV_STR
argument_list|,
literal|"10"
argument_list|)
expr_stmt|;
block|}
name|specclose
argument_list|(
name|relnum
argument_list|)
expr_stmt|;
name|call_dbu
argument_list|(
name|mdMODIFY
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|De
operator|.
name|de_newq
operator|=
literal|1
expr_stmt|;
name|De
operator|.
name|de_newr
operator|=
name|TRUE
expr_stmt|;
name|call_ovqp
argument_list|(
name|ag
argument_list|,
name|mdRETR
argument_list|,
name|relnum
argument_list|)
expr_stmt|;
name|De
operator|.
name|de_newq
operator|=
literal|0
expr_stmt|;
comment|/* if temp relation was used, destroy it */
if|if
condition|(
name|temp_relnum
operator|!=
name|NORESULT
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|resdom
operator|=
name|lnodv
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
name|resdom
operator|->
name|right
operator|=
name|save_node
index|[
name|i
index|]
expr_stmt|;
name|dstr_rel
argument_list|(
name|temp_relnum
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_macro
name|modqual
argument_list|(
argument|root
argument_list|,
argument|lnodv
argument_list|,
argument|srcmap
argument_list|,
argument|agvar
argument_list|)
end_macro

begin_decl_stmt
name|QTREE
modifier|*
name|root
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|QTREE
modifier|*
name|lnodv
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|srcmap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|agvar
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|QTREE
modifier|*
name|and_eq
decl_stmt|,
modifier|*
name|afcn
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|extern
name|QTREE
modifier|*
name|copytree
parameter_list|()
function_decl|;
specifier|extern
name|char
modifier|*
name|need
parameter_list|()
function_decl|;
specifier|register
name|int
name|len
decl_stmt|;
ifdef|#
directive|ifdef
name|xDTR1
if|if
condition|(
name|tTf
argument_list|(
literal|42
argument_list|,
literal|12
argument_list|)
condition|)
name|printf
argument_list|(
literal|"modqual %o\n"
argument_list|,
name|srcmap
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|afcn
operator|=
name|lnodv
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
comment|/*  `AND' node  */
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|rootnode
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|short
argument_list|)
expr_stmt|;
name|and_eq
operator|=
operator|(
name|QTREE
operator|*
operator|)
name|need
argument_list|(
name|De
operator|.
name|de_qbuf
argument_list|,
name|QT_HDR_SIZ
operator|+
name|len
argument_list|)
expr_stmt|;
name|and_eq
operator|->
name|sym
operator|.
name|type
operator|=
name|AND
expr_stmt|;
name|and_eq
operator|->
name|sym
operator|.
name|len
operator|=
name|len
expr_stmt|;
name|and_eq
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_root
operator|.
name|tvarc
operator|=
literal|0
expr_stmt|;
name|and_eq
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_root
operator|.
name|lvarc
operator|=
literal|0
expr_stmt|;
name|and_eq
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_root
operator|.
name|lvarm
operator|=
literal|0
expr_stmt|;
name|and_eq
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_root
operator|.
name|rvarm
operator|=
literal|0
expr_stmt|;
name|and_eq
operator|->
name|right
operator|=
name|root
operator|->
name|right
expr_stmt|;
name|root
operator|->
name|right
operator|=
name|and_eq
expr_stmt|;
comment|/* `EQ' node  */
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|opnode
argument_list|)
expr_stmt|;
name|and_eq
operator|->
name|left
operator|=
operator|(
name|QTREE
operator|*
operator|)
name|need
argument_list|(
name|De
operator|.
name|de_qbuf
argument_list|,
name|QT_HDR_SIZ
operator|+
name|len
argument_list|)
expr_stmt|;
name|and_eq
operator|=
name|and_eq
operator|->
name|left
expr_stmt|;
name|and_eq
operator|->
name|sym
operator|.
name|type
operator|=
name|BOP
expr_stmt|;
name|and_eq
operator|->
name|sym
operator|.
name|len
operator|=
name|len
expr_stmt|;
name|and_eq
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_op
operator|.
name|opno
operator|=
name|opEQ
expr_stmt|;
comment|/* bydomain opEQ var */
name|and_eq
operator|->
name|right
operator|=
name|copytree
argument_list|(
name|afcn
operator|->
name|right
argument_list|,
name|De
operator|.
name|de_qbuf
argument_list|)
expr_stmt|;
comment|/* a-fcn (in Source) specifying BY domain */
name|and_eq
operator|->
name|left
operator|=
name|makavar
argument_list|(
name|afcn
argument_list|,
name|agvar
argument_list|,
name|i
operator|+
literal|2
argument_list|)
expr_stmt|;
comment|/* VAR ref BY domain */
block|}
block|}
end_block

end_unit

