begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|<ingres.h>
end_include

begin_include
include|#
directive|include
file|<aux.h>
end_include

begin_include
include|#
directive|include
file|<tree.h>
end_include

begin_include
include|#
directive|include
file|<symbol.h>
end_include

begin_include
include|#
directive|include
file|"globs.h"
end_include

begin_include
include|#
directive|include
file|<sccs.h>
end_include

begin_macro
name|SCCSID
argument_list|(
argument|@(#)pull_sq.c
literal|7.1
literal|2
argument|/
literal|5
argument|/
literal|81
argument_list|)
end_macro

begin_comment
comment|/* ** DECOMP1.C ** **	contains routines associated with setting up  **	detachable 1-variable sub-queries. **	ptrs to these sq's are kept in the  **	array 'sqlist' declared in the main decomp routine. ** **	Trace Flags: **		34 */
end_comment

begin_macro
name|pull_sq
argument_list|(
argument|tree1
argument_list|,
argument|sqlist
argument_list|,
argument|locrang
argument_list|,
argument|sqrange
argument_list|,
argument|buf
argument_list|)
end_macro

begin_decl_stmt
name|QTREE
modifier|*
name|tree1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|QTREE
modifier|*
name|sqlist
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|locrang
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|sqrange
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|buf
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|QTREE
modifier|*
name|q
decl_stmt|,
modifier|*
name|tree
decl_stmt|,
modifier|*
name|r
decl_stmt|;
name|QTREE
modifier|*
name|s
decl_stmt|;
name|int
name|anysq
decl_stmt|,
name|j
decl_stmt|,
name|badvar
decl_stmt|;
specifier|extern
name|QTREE
modifier|*
name|makroot
parameter_list|()
function_decl|;
name|tree
operator|=
name|tree1
expr_stmt|;
ifdef|#
directive|ifdef
name|xDTR1
if|if
condition|(
name|tTf
argument_list|(
literal|34
argument_list|,
literal|0
argument_list|)
condition|)
name|printf
argument_list|(
literal|"PULL_SQ:tree=%x\n"
argument_list|,
name|tree
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|anysq
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|MAXRANGE
condition|;
name|j
operator|++
control|)
name|sqlist
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tree
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_root
operator|.
name|tvarc
operator|==
literal|1
condition|)
return|return;
comment|/* detach all one variable clauses except: 	** if the target list is one variable and 	** that variable is disjoint from the other 	** variables, then don't pull it. 	** 	** It will be more efficient to process it 	** all at once in decompy 	*/
name|badvar
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tree
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_root
operator|.
name|lvarc
operator|==
literal|1
condition|)
block|{
name|badvar
operator|=
name|tree
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_root
operator|.
name|lvarm
expr_stmt|;
comment|/* get bit position of var */
comment|/* look for a two variable clause involving badvar */
for|for
control|(
name|r
operator|=
name|tree
operator|->
name|right
init|;
name|r
operator|->
name|sym
operator|.
name|type
operator|!=
name|QLEND
condition|;
name|r
operator|=
name|r
operator|->
name|right
control|)
block|{
if|if
condition|(
name|r
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_root
operator|.
name|lvarc
operator|>
literal|1
operator|&&
operator|(
name|r
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_root
operator|.
name|lvarm
operator|&
name|badvar
operator|)
condition|)
block|{
name|badvar
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
block|}
ifdef|#
directive|ifdef
name|xDTR1
if|if
condition|(
name|tTf
argument_list|(
literal|34
argument_list|,
literal|2
argument_list|)
condition|)
name|printf
argument_list|(
literal|"Detachable clauses: (badvar=%o)\n"
argument_list|,
name|badvar
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|r
operator|=
name|tree
init|;
name|r
operator|->
name|right
operator|->
name|sym
operator|.
name|type
operator|!=
name|QLEND
condition|;
control|)
block|{
ifdef|#
directive|ifdef
name|xDTR1
if|if
condition|(
name|tTf
argument_list|(
literal|34
argument_list|,
literal|3
argument_list|)
condition|)
name|nodepr
argument_list|(
name|r
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|q
operator|=
name|r
expr_stmt|;
name|r
operator|=
name|r
operator|->
name|right
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_root
operator|.
name|lvarc
operator|==
literal|1
condition|)
block|{
name|j
operator|=
name|bitpos
argument_list|(
name|r
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_root
operator|.
name|lvarm
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|xDTR1
if|if
condition|(
name|tTf
argument_list|(
literal|34
argument_list|,
literal|4
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"\nvar=%d, clause\n"
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|treepr
argument_list|(
name|r
operator|->
name|left
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|r
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_root
operator|.
name|lvarm
operator|==
name|badvar
condition|)
block|{
ifdef|#
directive|ifdef
name|xDTR1
if|if
condition|(
name|tTf
argument_list|(
literal|34
argument_list|,
literal|5
argument_list|)
condition|)
name|printf
argument_list|(
literal|"not detaching \n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
continue|continue;
block|}
name|anysq
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|sqlist
index|[
name|j
index|]
condition|)
comment|/* MAKE ROOT NODE FOR SUBQUERY */
name|sqlist
index|[
name|j
index|]
operator|=
name|makroot
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|s
operator|=
name|sqlist
index|[
name|j
index|]
expr_stmt|;
comment|/* MODIFY MAIN QUERY */
name|q
operator|->
name|right
operator|=
name|r
operator|->
name|right
expr_stmt|;
comment|/* MODIFY `AND` NODE OF DETACHED CLAUSE */
name|r
operator|->
name|right
operator|=
name|s
operator|->
name|right
expr_stmt|;
name|r
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_root
operator|.
name|rvarm
operator|=
name|s
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_root
operator|.
name|rvarm
expr_stmt|;
name|r
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_root
operator|.
name|tvarc
operator|=
literal|1
expr_stmt|;
comment|/* ADD CLAUSE TO SUB-QUERY */
name|s
operator|->
name|right
operator|=
name|r
expr_stmt|;
name|s
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_root
operator|.
name|rvarm
operator|=
name|r
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_root
operator|.
name|lvarm
expr_stmt|;
name|s
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_root
operator|.
name|tvarc
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|xDTR1
if|if
condition|(
name|tTf
argument_list|(
literal|34
argument_list|,
literal|6
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"SQ\n"
argument_list|)
expr_stmt|;
name|treepr
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|r
operator|=
name|q
expr_stmt|;
block|}
block|}
comment|/* NOW SET UP TARGET LIST FOR EACH SUBQUERY IN SQLIST */
ifdef|#
directive|ifdef
name|xDTR1
if|if
condition|(
name|tTf
argument_list|(
literal|34
argument_list|,
literal|7
argument_list|)
condition|)
name|printf
argument_list|(
literal|"# sq clauses=%d\n"
argument_list|,
name|anysq
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|anysq
condition|)
block|{
ifdef|#
directive|ifdef
name|xDTR1
if|if
condition|(
name|tTf
argument_list|(
literal|34
argument_list|,
literal|8
argument_list|)
condition|)
name|printf
argument_list|(
literal|"Dfind--\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|dfind
argument_list|(
name|tree
argument_list|,
name|buf
argument_list|,
name|sqlist
argument_list|)
expr_stmt|;
name|mapvar
argument_list|(
name|tree
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* create the result relations */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|MAXRANGE
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|q
operator|=
name|sqlist
index|[
name|j
index|]
condition|)
block|{
if|if
condition|(
name|q
operator|->
name|left
operator|->
name|sym
operator|.
name|type
operator|!=
name|TREE
condition|)
block|{
name|savrang
argument_list|(
name|locrang
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|sqrange
index|[
name|j
index|]
operator|=
name|mak_t_rel
argument_list|(
name|q
argument_list|,
literal|"d"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|sqrange
index|[
name|j
index|]
operator|=
name|NORESULT
expr_stmt|;
block|}
block|}
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  DFIND */
end_comment

begin_expr_stmt
name|dfind
argument_list|(
name|tree
argument_list|,
name|buf
argument_list|,
name|sqlist
argument_list|)
specifier|register
name|QTREE
operator|*
name|tree
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
modifier|*
name|buf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|QTREE
modifier|*
name|sqlist
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
name|varno
decl_stmt|;
specifier|register
name|QTREE
modifier|*
name|sq
decl_stmt|;
specifier|extern
name|QTREE
modifier|*
name|ckvar
parameter_list|()
function_decl|;
if|if
condition|(
name|tree
operator|==
name|NULL
condition|)
return|return;
ifdef|#
directive|ifdef
name|xDTR1
if|if
condition|(
name|tTf
argument_list|(
literal|34
argument_list|,
literal|9
argument_list|)
condition|)
name|nodepr
argument_list|(
name|tree
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|tree
operator|->
name|sym
operator|.
name|type
operator|==
name|VAR
condition|)
block|{
name|tree
operator|=
name|ckvar
argument_list|(
name|tree
argument_list|)
expr_stmt|;
name|varno
operator|=
name|tree
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_var
operator|.
name|varno
expr_stmt|;
if|if
condition|(
name|sq
operator|=
name|sqlist
index|[
name|varno
index|]
condition|)
name|maktl
argument_list|(
name|tree
argument_list|,
name|buf
argument_list|,
name|sq
argument_list|,
name|varno
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* IF CURRENT NODE NOT A `VAR` WITH SQ, RECURSE THRU REST OF TREE */
name|dfind
argument_list|(
name|tree
operator|->
name|left
argument_list|,
name|buf
argument_list|,
name|sqlist
argument_list|)
expr_stmt|;
name|dfind
argument_list|(
name|tree
operator|->
name|right
argument_list|,
name|buf
argument_list|,
name|sqlist
argument_list|)
expr_stmt|;
return|return;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  MAKTL */
end_comment

begin_macro
name|maktl
argument_list|(
argument|node
argument_list|,
argument|buf
argument_list|,
argument|sq1
argument_list|,
argument|varno
argument_list|)
end_macro

begin_decl_stmt
name|QTREE
modifier|*
name|node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|buf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|QTREE
modifier|*
name|sq1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|varno
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|QTREE
modifier|*
name|resdom
decl_stmt|,
modifier|*
name|tree
decl_stmt|,
modifier|*
name|sq
decl_stmt|;
name|int
name|domno
decl_stmt|,
name|map
decl_stmt|;
specifier|extern
name|QTREE
modifier|*
name|makresdom
parameter_list|()
function_decl|;
specifier|extern
name|QTREE
modifier|*
name|copytree
parameter_list|()
function_decl|;
name|sq
operator|=
name|sq1
expr_stmt|;
name|domno
operator|=
name|node
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_var
operator|.
name|attno
expr_stmt|;
ifdef|#
directive|ifdef
name|xDTR1
if|if
condition|(
name|tTf
argument_list|(
literal|34
argument_list|,
literal|12
argument_list|)
condition|)
name|printf
argument_list|(
literal|"\tVar=%d,Dom=%d "
argument_list|,
name|varno
argument_list|,
name|domno
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* CHECK IF NODE ALREADY CREATED FOR THIS DOMAIN */
for|for
control|(
name|tree
operator|=
name|sq
operator|->
name|left
init|;
name|tree
operator|->
name|sym
operator|.
name|type
operator|!=
name|TREE
condition|;
name|tree
operator|=
name|tree
operator|->
name|left
control|)
if|if
condition|(
name|tree
operator|->
name|right
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_var
operator|.
name|attno
operator|==
name|domno
condition|)
block|{
ifdef|#
directive|ifdef
name|xDTR1
if|if
condition|(
name|tTf
argument_list|(
literal|34
argument_list|,
literal|13
argument_list|)
condition|)
name|printf
argument_list|(
literal|"Domain found\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
comment|/* create a new resdom for domain */
name|resdom
operator|=
name|makresdom
argument_list|(
name|buf
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|resdom
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_resdom
operator|.
name|resno
operator|=
name|sq
operator|->
name|left
operator|->
name|sym
operator|.
name|type
operator|==
name|TREE
condition|?
literal|1
else|:
name|sq
operator|->
name|left
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_resdom
operator|.
name|resno
operator|+
literal|1
expr_stmt|;
comment|/* resdom->right is a copy of the var node in order to 	** protect against tempvar() changing the var node. 	*/
name|resdom
operator|->
name|left
operator|=
name|sq
operator|->
name|left
expr_stmt|;
name|resdom
operator|->
name|right
operator|=
name|copytree
argument_list|(
name|node
argument_list|,
name|buf
argument_list|)
expr_stmt|;
comment|/* update ROOT node if necessary */
name|sq
operator|->
name|left
operator|=
name|resdom
expr_stmt|;
name|map
operator|=
literal|1
operator|<<
name|varno
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|sq
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_root
operator|.
name|lvarm
operator|&
name|map
operator|)
condition|)
block|{
comment|/* var not currently in tl */
name|sq
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_root
operator|.
name|lvarm
operator||=
name|map
expr_stmt|;
name|sq
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_root
operator|.
name|lvarc
operator|++
expr_stmt|;
comment|/* if var is not in qualification then update total count */
if|if
condition|(
operator|!
operator|(
name|sq
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_root
operator|.
name|rvarm
operator|&
name|map
operator|)
condition|)
name|sq
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_root
operator|.
name|tvarc
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|xDTR1
if|if
condition|(
name|tTf
argument_list|(
literal|34
argument_list|,
literal|15
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"new root "
argument_list|)
expr_stmt|;
name|nodepr
argument_list|(
name|sq
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|xDTR1
if|if
condition|(
name|tTf
argument_list|(
literal|34
argument_list|,
literal|14
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"new dom "
argument_list|)
expr_stmt|;
name|nodepr
argument_list|(
name|resdom
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return;
block|}
end_block

end_unit

