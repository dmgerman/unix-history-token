begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|<ingres.h>
end_include

begin_include
include|#
directive|include
file|<sccs.h>
end_include

begin_macro
name|SCCSID
argument_list|(
argument|@(#)expr.c
literal|7.1
literal|2
argument|/
literal|5
argument|/
literal|81
argument_list|)
end_macro

begin_comment
comment|/* **  EXPR -- evaluate expression ** **	This module evaluates an expression in somewhat standard **	infix notation.  Several restrictions apply.  There are **	no variables, since this can be simulated with the macro **	processor.  No numeric overflow is checked.  There may be **	no spaces, tabs, or newlines in the expression. ** **	The text of the expression is read from 'macgetch', so **	that must be initialized before calling this routine. ** **	Operators accepted are + - * /<>>=<= = != % ( ) **& |. **	Operands may be signed integers. **	Standard precedence applies. ** **	An expression can be viewed as a sequence of operands, **	and operators.  If the terminator is considered to be **	an operator, then the sequence must be composed ** 	of n matched pairs of operators and operands.  NOT and **	Negation are considered to be part of the operand and **	are treated as such.  Thus to evaluate an expression, **	n pairs are read until the terminator is found as the **	last operator. ** **	Parameters: **		none ** **	Returns: **		value of the expression.  Undetermined value **		on error. ** **	Side Effects: **		Macro processing can occur. ** **	Trace Flags: **		none */
end_comment

begin_undef
undef|#
directive|undef
name|STACKSIZE
end_undef

begin_define
define|#
directive|define
name|STACKSIZE
value|50
end_define

begin_define
define|#
directive|define
name|RIGHTP
value|21
end_define

begin_define
define|#
directive|define
name|END
value|22
end_define

begin_define
define|#
directive|define
name|SEPERATOR
value|0
end_define

begin_define
define|#
directive|define
name|OR
value|1
end_define

begin_define
define|#
directive|define
name|AND
value|2
end_define

begin_define
define|#
directive|define
name|EQUALS
value|3
end_define

begin_define
define|#
directive|define
name|NEQ
value|4
end_define

begin_define
define|#
directive|define
name|LESS
value|5
end_define

begin_define
define|#
directive|define
name|LEQ
value|6
end_define

begin_define
define|#
directive|define
name|GREATER
value|7
end_define

begin_define
define|#
directive|define
name|GEQ
value|8
end_define

begin_define
define|#
directive|define
name|ADD
value|9
end_define

begin_define
define|#
directive|define
name|SUBTRACT
value|10
end_define

begin_define
define|#
directive|define
name|MULTIPLY
value|11
end_define

begin_define
define|#
directive|define
name|DIVIDE
value|12
end_define

begin_define
define|#
directive|define
name|MOD
value|13
end_define

begin_decl_stmt
name|int
name|ExprPrec
index|[]
init|=
comment|/* Precedence table */
block|{
literal|0
block|,
comment|/* filler */
literal|1
block|,
comment|/* 1 -- OR */
literal|2
block|,
comment|/* 2 -- AND */
literal|3
block|,
comment|/* 3 -- EQUALS */
literal|3
block|,
comment|/* 4 -- NEQ */
literal|4
block|,
comment|/* 5 -- LESS */
literal|4
block|,
comment|/* 6 -- LEQ */
literal|4
block|,
comment|/* 7 -- GREATER */
literal|4
block|,
comment|/* 8 -- GEQ */
literal|5
block|,
comment|/* 9 -- ADD */
literal|5
block|,
comment|/* 10 -- SUBTRACT */
literal|6
block|,
comment|/* 11 -- MULTIPLY */
literal|6
block|,
comment|/* 12 -- DIVIDE */
literal|6
comment|/* 13 -- MOD */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ExprNstack
index|[
name|STACKSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|ExprNptr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ExprOstack
index|[
name|STACKSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|ExprOptr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ExprError
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|ExprPeek
decl_stmt|;
end_decl_stmt

begin_macro
name|expr
argument_list|()
end_macro

begin_block
block|{
name|ExprNptr
operator|=
name|ExprNstack
expr_stmt|;
name|ExprOptr
operator|=
name|ExprOstack
expr_stmt|;
name|ExprError
operator|=
name|FALSE
expr_stmt|;
name|ExprPeek
operator|=
operator|-
literal|1
expr_stmt|;
return|return
operator|(
name|valof
argument_list|(
name|END
argument_list|)
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  VALOF -- compute value of expression ** **	This is the real expression processor.  It handles sequencing **	and precedence. ** **	Parameters: **		terminator -- the symbol which should terminate **			the expression. ** **	Returns: **		The value of the expression. ** **	Side Effects: **		Gobbles input. ** **	Requires: **		exprfind -- to read operands. **		opfind -- to read operators. **		exp_op -- to perform operations. ** **	Called By: **		expr ** **	Diagnostics: **		Extra Parenthesis found: assumed typo **			An unmatched right parenthesis was read. **			It was thrown away. **		Insufficient parenthesis found: assumed zero. **			An unmatched left parenthesis was left **			in the operator stack at the end of the **			expression.  The value zero was taken **			for the expression. ** **	Syserrs: **		none */
end_comment

begin_macro
name|valof
argument_list|(
argument|terminator
argument_list|)
end_macro

begin_decl_stmt
name|int
name|terminator
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|number
decl_stmt|;
specifier|register
name|int
name|operator
decl_stmt|;
name|pushop
argument_list|(
name|SEPERATOR
argument_list|)
expr_stmt|;
comment|/* initialize the stack */
for|for
control|(
init|;
condition|;
control|)
block|{
name|number
operator|=
name|exprfind
argument_list|()
expr_stmt|;
if|if
condition|(
name|ExprError
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|operator
operator|=
name|opfind
argument_list|()
expr_stmt|;
if|if
condition|(
name|ExprError
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|operator
operator|==
name|RIGHTP
operator|||
name|operator
operator|==
name|END
condition|)
break|break;
comment|/* Do all previous operations with a higher precedence */
while|while
condition|(
name|ExprPrec
index|[
name|operator
index|]
operator|<=
name|ExprPrec
index|[
name|ExprOptr
index|[
operator|-
literal|1
index|]
index|]
condition|)
name|number
operator|=
name|exp_op
argument_list|(
name|popop
argument_list|()
argument_list|,
name|popnum
argument_list|()
argument_list|,
name|number
argument_list|)
expr_stmt|;
name|pushop
argument_list|(
name|operator
argument_list|)
expr_stmt|;
name|pushnum
argument_list|(
name|number
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|operator
operator|!=
name|terminator
condition|)
comment|/* ExprError in operators */
if|if
condition|(
name|operator
operator|==
name|RIGHTP
condition|)
name|printf
argument_list|(
literal|"Extra parenthesis found: assumed typo.\n"
argument_list|)
expr_stmt|;
else|else
block|{
name|ExprError
operator|=
name|TRUE
expr_stmt|;
name|printf
argument_list|(
literal|"Insufficient parenthesis found: Assumed zero.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Empty stack for this call of valof */
while|while
condition|(
operator|(
name|operator
operator|=
name|popop
argument_list|()
operator|)
operator|!=
name|SEPERATOR
condition|)
name|number
operator|=
name|exp_op
argument_list|(
name|operator
argument_list|,
name|popnum
argument_list|()
argument_list|,
name|number
argument_list|)
expr_stmt|;
return|return
operator|(
name|number
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  EXPRFIND -- find and chomp operand ** **	This routine reads the next operand.  It generally just **	reads numbers, except it also knows about unary operators **	! and - (where it calls itself recursively), and paren- **	theses (where it calls valof recursively). ** **	Parameters: **		none ** **	Returns: **		value of operand. ** **	Side Effects: **		Gobbles input. ** **	Requires: **		numberget -- to read numbers. **		exprgch. ** **	Called By: **		valof **		exprfind (recursively) ** **	Trace Flags: **		none ** **	Diagnostics: **		Expression expected: end of expression found. **			Nothing was found.  Zero is returned. **		Expression expected: %c found; assumed zero. **			A syntax error -- nothing was found **			which was acceptable. */
end_comment

begin_macro
name|exprfind
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|result
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
name|c
operator|=
name|exprgch
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
return|return
operator|(
name|numberget
argument_list|(
name|c
argument_list|)
operator|)
return|;
case|case
literal|'!'
case|:
name|result
operator|=
name|exprfind
argument_list|()
expr_stmt|;
return|return
operator|(
name|ExprError
condition|?
literal|0
else|:
operator|(
name|result
operator|<=
literal|0
operator|)
operator|)
return|;
case|case
literal|'-'
case|:
name|result
operator|=
name|exprfind
argument_list|()
expr_stmt|;
return|return
operator|(
name|ExprError
condition|?
literal|0
else|:
operator|-
name|result
operator|)
return|;
case|case
literal|'('
case|:
return|return
operator|(
name|valof
argument_list|(
name|RIGHTP
argument_list|)
operator|)
return|;
case|case
literal|' '
case|:
case|case
literal|'\n'
case|:
case|case
literal|'/t'
case|:
case|case
literal|'\0'
case|:
name|printf
argument_list|(
literal|"Expression expected: end of expression found.\n"
argument_list|)
expr_stmt|;
name|ExprError
operator|=
name|TRUE
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
default|default:
name|printf
argument_list|(
literal|"Expression expected; '%c' found: Assumed zero.\n"
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|ExprError
operator|=
name|TRUE
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  OPFIND -- find and translate operator ** **	This reads the next operator from the input stream and **	returns the internal code for it. ** **	Parameters: **		none ** **	Returns: **		The code for the next operator. **		Zero on error. ** **	Side Effects: **		Gobbles input. ** **	Requires: **		exprgch. ** **	Called By: **		valof ** **	Trace Flags: **		none ** **	Diagnostics: **		Operator expected: '%c' found. **			Gibberish in input. */
end_comment

begin_macro
name|opfind
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|c
decl_stmt|;
name|c
operator|=
name|exprgch
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'/'
case|:
return|return
operator|(
name|DIVIDE
operator|)
return|;
case|case
literal|'='
case|:
return|return
operator|(
name|EQUALS
operator|)
return|;
case|case
literal|'&'
case|:
return|return
operator|(
name|AND
operator|)
return|;
case|case
literal|'|'
case|:
return|return
operator|(
name|OR
operator|)
return|;
case|case
literal|'+'
case|:
return|return
operator|(
name|ADD
operator|)
return|;
case|case
literal|'-'
case|:
return|return
operator|(
name|SUBTRACT
operator|)
return|;
case|case
literal|'*'
case|:
return|return
operator|(
name|MULTIPLY
operator|)
return|;
case|case
literal|'<'
case|:
name|c
operator|=
name|exprgch
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'='
condition|)
block|{
return|return
operator|(
name|LEQ
operator|)
return|;
block|}
name|ExprPeek
operator|=
name|c
expr_stmt|;
return|return
operator|(
name|LESS
operator|)
return|;
case|case
literal|'>'
case|:
name|c
operator|=
name|exprgch
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'='
condition|)
block|{
return|return
operator|(
name|GEQ
operator|)
return|;
block|}
name|ExprPeek
operator|=
name|c
expr_stmt|;
return|return
operator|(
name|GREATER
operator|)
return|;
case|case
literal|'%'
case|:
return|return
operator|(
name|MOD
operator|)
return|;
case|case
literal|'!'
case|:
name|c
operator|=
name|exprgch
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'='
condition|)
block|{
return|return
operator|(
name|NEQ
operator|)
return|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"Operator expected: '!%c' found.\n"
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|ExprError
operator|=
name|TRUE
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
case|case
literal|')'
case|:
return|return
operator|(
name|RIGHTP
operator|)
return|;
case|case
literal|' '
case|:
case|case
literal|'\t'
case|:
case|case
literal|'\n'
case|:
case|case
literal|'\0'
case|:
return|return
operator|(
name|END
operator|)
return|;
default|default:
name|printf
argument_list|(
literal|"Operator expected: '%c' found.\n"
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|ExprError
operator|=
name|TRUE
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  EXP_OP -- perform operation ** **	Performs an operation between two values. ** **	Parameters: **		op -- the operation to perform. **		lv -- the left operand. **		rv -- the right operand. ** **	Returns: **		The value of the operation. ** **	Side Effects: **		none ** **	Requires: **		none ** **	Called By: **		valof. ** **	Trace Flags: **		none ** **	Diagnostics: **		none */
end_comment

begin_macro
name|exp_op
argument_list|(
argument|op
argument_list|,
argument|lv
argument_list|,
argument|rv
argument_list|)
end_macro

begin_decl_stmt
name|int
name|op
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|lv
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|rv
decl_stmt|;
end_decl_stmt

begin_block
block|{
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|OR
case|:
return|return
operator|(
operator|(
name|lv
operator|>
literal|0
operator|)
operator|||
operator|(
name|rv
operator|>
literal|0
operator|)
operator|)
return|;
case|case
name|AND
case|:
return|return
operator|(
operator|(
name|lv
operator|>
literal|0
operator|)
operator|&&
operator|(
name|rv
operator|>
literal|0
operator|)
operator|)
return|;
case|case
name|EQUALS
case|:
return|return
operator|(
name|lv
operator|==
name|rv
operator|)
return|;
case|case
name|NEQ
case|:
return|return
operator|(
name|lv
operator|!=
name|rv
operator|)
return|;
case|case
name|LESS
case|:
return|return
operator|(
name|lv
operator|<
name|rv
operator|)
return|;
case|case
name|LEQ
case|:
return|return
operator|(
name|lv
operator|<=
name|rv
operator|)
return|;
case|case
name|GREATER
case|:
return|return
operator|(
name|lv
operator|>
name|rv
operator|)
return|;
case|case
name|GEQ
case|:
return|return
operator|(
name|lv
operator|>=
name|rv
operator|)
return|;
case|case
name|ADD
case|:
return|return
operator|(
name|lv
operator|+
name|rv
operator|)
return|;
case|case
name|SUBTRACT
case|:
return|return
operator|(
name|lv
operator|-
name|rv
operator|)
return|;
case|case
name|MULTIPLY
case|:
return|return
operator|(
name|lv
operator|*
name|rv
operator|)
return|;
case|case
name|DIVIDE
case|:
if|if
condition|(
name|rv
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Divide by zero: zero assumed.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
return|return
operator|(
name|lv
operator|/
name|rv
operator|)
return|;
case|case
name|MOD
case|:
return|return
operator|(
name|lv
operator|%
name|rv
operator|)
return|;
default|default:
name|syserr
argument_list|(
literal|"exp_op: bad op %d"
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  NUMBERGET -- read and convert a number ** **	Reads and converts a signed integer. ** **	Parameters: **		none ** **	Returns: **		The next number in the input stream. ** **	Side Effects: **		Gobbles input. ** **	Requires: **		exprgch. ** **	Called By: **		exprfind. */
end_comment

begin_macro
name|numberget
argument_list|(
argument|cx
argument_list|)
end_macro

begin_decl_stmt
name|char
name|cx
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|result
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
name|c
operator|=
name|cx
expr_stmt|;
name|result
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|result
operator|=
name|result
operator|*
literal|10
operator|+
name|c
operator|-
literal|'0'
expr_stmt|;
name|c
operator|=
name|exprgch
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
condition|)
do|;
name|ExprPeek
operator|=
name|c
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  EXPRGCH -- expression character get ** **	Gets the next character from the expression input.  Takes **	a character out of ExprPeek first.  Also maps spaces, tabs, **	and newlines into zero bytes. ** **	Parameters: **		none ** **	Returns: **		Next character. ** **	Side Effects: **		Gobbles input. **		Clears ExprPeek if set. ** **	Requires: **		ExprPeek -- the peek character. **		macgetch -- to get the next character if ExprPeek **			is not set. */
end_comment

begin_macro
name|exprgch
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|c
decl_stmt|;
name|c
operator|=
name|ExprPeek
expr_stmt|;
if|if
condition|(
name|c
operator|<
literal|0
condition|)
name|c
operator|=
name|macgetch
argument_list|()
expr_stmt|;
name|ExprPeek
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\n'
operator|||
name|c
operator|==
literal|'\t'
condition|)
name|c
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|c
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  Stack operations. */
end_comment

begin_comment
comment|/* Popop returns the top of the operator stack and decrements this stack. */
end_comment

begin_macro
name|popop
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|ExprOptr
operator|<=
name|ExprOstack
condition|)
name|syserr
argument_list|(
literal|"popop: underflow"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|*
operator|--
name|ExprOptr
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Pushop increments the stack pointer and pushes op on the stack. */
end_comment

begin_macro
name|pushop
argument_list|(
argument|op
argument_list|)
end_macro

begin_decl_stmt
name|int
name|op
decl_stmt|;
end_decl_stmt

begin_block
block|{
operator|*
name|ExprOptr
operator|++
operator|=
name|op
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Popnum returns the top of the number stack and decrements the stack pointer. */
end_comment

begin_macro
name|popnum
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|ExprNptr
operator|<=
name|ExprNstack
condition|)
name|syserr
argument_list|(
literal|"popnum: underflow"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|*
operator|--
name|ExprNptr
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Pushnum increments the stack pointer and pushes num onto the stack */
end_comment

begin_macro
name|pushnum
argument_list|(
argument|num
argument_list|)
end_macro

begin_decl_stmt
name|int
name|num
decl_stmt|;
end_decl_stmt

begin_block
block|{
operator|*
name|ExprNptr
operator|++
operator|=
name|num
expr_stmt|;
block|}
end_block

end_unit

