begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|"monitor.h"
end_include

begin_include
include|#
directive|include
file|<ingres.h>
end_include

begin_include
include|#
directive|include
file|<aux.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<ctlmod.h>
end_include

begin_include
include|#
directive|include
file|<sccs.h>
end_include

begin_macro
name|SCCSID
argument_list|(
argument|@(#)monitor.c
literal|7.1
literal|2
argument|/
literal|5
argument|/
literal|81
argument_list|)
end_macro

begin_comment
comment|/* **  MONITOR ** **	This routine maintains the logical query buffer in **	/tmp/INGQxxxx.  It in general just does a copy from input **	to query buffer, unless it gets a backslash escape character **	or dollarsign escape character. **	It recognizes the following escapes: ** **	\a -- force append mode (no autoclear) **	\b -- branch (within an include file only) **	\c -- reserved for screen clear in geoquel **	\d -- change working directory **	\e -- enter editor **	\g -- "GO": submit query to INGRES **	\i -- include (switch input to external file) **	\k -- mark (for \b) **	\l -- list: print query buffer after macro evaluation **	\p -- print query buffer (before macro evaluation) **	\q -- quit ingres **	\r -- force reset (clear) of query buffer **	\s -- call shell **	\t -- print current time **	\v -- evaluate macros, but throw away result (for side effects) **	\w -- write query buffer to external file **	\$t -- change setting of trace flags **	\$r -- reset system **	\\ -- produce a single backslash in query buffer ** **	Uses trace flag 2 */
end_comment

begin_comment
comment|/* **  COMMAND TABLE **	To add synonyms for commands, add entries to this table */
end_comment

begin_struct
struct|struct
name|cntrlwd
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|code
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|cntrlwd
name|Controlwords
index|[]
init|=
block|{
literal|"a"
block|,
name|C_APPEND
block|,
literal|"append"
block|,
name|C_APPEND
block|,
literal|"b"
block|,
name|C_BRANCH
block|,
literal|"branch"
block|,
name|C_BRANCH
block|,
literal|"cd"
block|,
name|C_CHDIR
block|,
literal|"chdir"
block|,
name|C_CHDIR
block|,
literal|"e"
block|,
name|C_EDIT
block|,
literal|"ed"
block|,
name|C_EDIT
block|,
literal|"edit"
block|,
name|C_EDIT
block|,
literal|"editor"
block|,
name|C_EDIT
block|,
literal|"g"
block|,
name|C_GO
block|,
literal|"go"
block|,
name|C_GO
block|,
literal|"i"
block|,
name|C_INCLUDE
block|,
literal|"include"
block|,
name|C_INCLUDE
block|,
literal|"read"
block|,
name|C_INCLUDE
block|,
literal|"k"
block|,
name|C_MARK
block|,
literal|"mark"
block|,
name|C_MARK
block|,
literal|"l"
block|,
name|C_LIST
block|,
literal|"list"
block|,
name|C_LIST
block|,
literal|"p"
block|,
name|C_PRINT
block|,
literal|"print"
block|,
name|C_PRINT
block|,
literal|"q"
block|,
name|C_QUIT
block|,
literal|"quit"
block|,
name|C_QUIT
block|,
literal|"r"
block|,
name|C_RESET
block|,
literal|"reset"
block|,
name|C_RESET
block|,
literal|"s"
block|,
name|C_SHELL
block|,
literal|"sh"
block|,
name|C_SHELL
block|,
literal|"shell"
block|,
name|C_SHELL
block|,
literal|"t"
block|,
name|C_TIME
block|,
literal|"time"
block|,
name|C_TIME
block|,
literal|"date"
block|,
name|C_TIME
block|,
literal|"v"
block|,
name|C_EVAL
block|,
literal|"eval"
block|,
name|C_EVAL
block|,
literal|"w"
block|,
name|C_WRITE
block|,
literal|"write"
block|,
name|C_WRITE
block|,
literal|"$t"
block|,
name|C_SYSTRACE
block|,
literal|"$trace"
block|,
name|C_SYSTRACE
block|,
literal|"$r"
block|,
name|C_SYSRESET
block|,
literal|"$reset"
block|,
name|C_SYSRESET
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_macro
name|monitor
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|char
name|chr
decl_stmt|;
name|int
name|timevec
index|[
literal|2
index|]
decl_stmt|;
specifier|register
name|int
name|controlno
decl_stmt|;
specifier|extern
name|jmp_buf
name|CmReset
decl_stmt|;
extern|extern		error(
block|)
end_block

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|Proc_name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|RubLevel
decl_stmt|;
end_decl_stmt

begin_extern
extern|extern		rubcatch(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|setjmp
argument_list|(
name|CmReset
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|initbuf
argument_list|(
name|Qbuf
argument_list|,
name|QbufSize
argument_list|,
name|ERR_QBUF
argument_list|,
name|error
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|clrmem
argument_list|(
operator|&
name|Ctx
argument_list|,
sizeof|sizeof
name|Ctx
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|Ctx
operator|.
name|ctx_cmark
operator|=
name|Ctx
operator|.
name|ctx_pmark
operator|=
name|markbuf
argument_list|(
name|Qbuf
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|Ctx
operator|.
name|ctx_name
operator|=
name|Proc_name
operator|=
name|Cm
operator|.
name|cm_myname
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|Ctx
operator|.
name|ctx_tvect
operator|=
name|tT
operator|=
name|FuncVect
index|[
literal|0
index|]
operator|->
name|fn_tvect
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|xwait
argument_list|()
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|RubLevel
operator|>=
literal|0
condition|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|rubcatch
argument_list|)
expr_stmt|;
end_if

begin_while
while|while
condition|(
name|chr
operator|=
name|getch
argument_list|()
condition|)
block|{
if|if
condition|(
name|chr
operator|==
literal|'\\'
condition|)
block|{
comment|/* process control sequence */
if|if
condition|(
operator|(
name|controlno
operator|=
name|getescape
argument_list|(
literal|1
argument_list|)
operator|)
operator|==
literal|0
condition|)
continue|continue;
switch|switch
condition|(
name|controlno
condition|)
block|{
case|case
name|C_EDIT
case|:
name|edit
argument_list|()
expr_stmt|;
continue|continue;
case|case
name|C_PRINT
case|:
name|print
argument_list|()
expr_stmt|;
continue|continue;
case|case
name|C_LIST
case|:
name|eval
argument_list|(
literal|1
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|C_EVAL
case|:
name|eval
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|Autoclear
operator|=
name|TRUE
expr_stmt|;
continue|continue;
case|case
name|C_INCLUDE
case|:
name|include
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|cgprompt
argument_list|()
expr_stmt|;
continue|continue;
case|case
name|C_WRITE
case|:
name|writeout
argument_list|()
expr_stmt|;
name|cgprompt
argument_list|()
expr_stmt|;
continue|continue;
case|case
name|C_CHDIR
case|:
name|newdirec
argument_list|()
expr_stmt|;
name|cgprompt
argument_list|()
expr_stmt|;
continue|continue;
case|case
name|C_RESET
case|:
name|clear
argument_list|(
literal|1
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|C_GO
case|:
name|go
argument_list|()
expr_stmt|;
continue|continue;
case|case
name|C_QUIT
case|:
name|clrline
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|quit
argument_list|()
expr_stmt|;
case|case
name|C_SHELL
case|:
name|shell
argument_list|()
expr_stmt|;
continue|continue;
case|case
name|C_TIME
case|:
name|time
argument_list|(
name|timevec
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|ctime
argument_list|(
name|timevec
argument_list|)
argument_list|)
expr_stmt|;
name|clrline
argument_list|(
literal|0
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|C_APPEND
case|:
name|Autoclear
operator|=
literal|0
expr_stmt|;
name|clrline
argument_list|(
literal|0
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|C_MARK
case|:
name|getfilenm
argument_list|()
expr_stmt|;
name|prompt
argument_list|(
literal|0
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|C_BRANCH
case|:
name|branch
argument_list|()
expr_stmt|;
name|prompt
argument_list|(
literal|0
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|C_SYSTRACE
case|:
name|trace
argument_list|()
expr_stmt|;
name|prompt
argument_list|(
literal|0
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|C_SYSRESET
case|:
name|reset
argument_list|()
expr_stmt|;
name|clrline
argument_list|(
literal|0
argument_list|)
expr_stmt|;
continue|continue;
default|default:
name|syserr
argument_list|(
literal|"monitor: bad code %d"
argument_list|,
name|controlno
argument_list|)
expr_stmt|;
block|}
block|}
name|putch
argument_list|(
name|chr
argument_list|)
expr_stmt|;
block|}
end_while

begin_if
if|if
condition|(
name|Input
operator|==
name|stdin
condition|)
block|{
if|if
condition|(
name|Nodayfile
operator|>=
literal|0
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
else|else
name|fclose
argument_list|(
name|Input
argument_list|)
expr_stmt|;
end_if

begin_escape
unit|}
end_escape

begin_expr_stmt
unit|getescape
operator|(
name|copy
operator|)
name|int
name|copy
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|cntrlwd
modifier|*
name|cw
decl_stmt|;
specifier|register
name|char
modifier|*
name|word
decl_stmt|;
name|char
modifier|*
name|getname
parameter_list|()
function_decl|;
name|word
operator|=
name|getname
argument_list|()
expr_stmt|;
for|for
control|(
name|cw
operator|=
name|Controlwords
init|;
name|cw
operator|->
name|name
condition|;
name|cw
operator|++
control|)
block|{
if|if
condition|(
name|sequal
argument_list|(
name|cw
operator|->
name|name
argument_list|,
name|word
argument_list|)
condition|)
return|return
operator|(
name|cw
operator|->
name|code
operator|)
return|;
block|}
comment|/* not found -- pass symbol through and return failure */
if|if
condition|(
name|copy
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|putch
argument_list|(
literal|'\\'
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|word
operator|!=
literal|0
condition|)
block|{
name|putch
argument_list|(
operator|*
name|word
operator|++
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_function
name|char
modifier|*
name|getname
parameter_list|()
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|static
name|char
name|buf
index|[
literal|41
index|]
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
specifier|register
name|char
name|c
decl_stmt|;
name|p
operator|=
name|buf
expr_stmt|;
for|for
control|(
name|len
operator|=
literal|0
init|;
name|len
operator|<
literal|40
condition|;
name|len
operator|++
control|)
block|{
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|>=
literal|'a'
operator|&&
name|c
operator|<=
literal|'z'
operator|)
operator|||
operator|(
name|c
operator|>=
literal|'A'
operator|&&
name|c
operator|<=
literal|'Z'
operator|)
condition|)
block|{
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|len
operator|==
literal|0
operator|)
operator|&&
operator|(
name|c
operator|==
literal|'$'
operator|)
condition|)
comment|/* system control command */
block|{
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
block|}
else|else
block|{
name|ungetc
argument_list|(
name|c
argument_list|,
name|Input
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
operator|*
name|p
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
block|}
end_function

begin_macro
name|putch
argument_list|(
argument|ch
argument_list|)
end_macro

begin_decl_stmt
name|char
name|ch
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
name|c
decl_stmt|;
name|c
operator|=
name|ch
expr_stmt|;
name|Prompt
operator|=
name|Newline
operator|=
operator|(
name|c
operator|==
literal|'\n'
operator|)
expr_stmt|;
if|if
condition|(
name|c
operator|<
literal|040
operator|&&
name|c
operator|!=
literal|'\n'
operator|&&
name|c
operator|!=
literal|'\t'
condition|)
block|{
name|printf
argument_list|(
literal|"Funny character 0%o converted to blank\n"
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|c
operator|=
literal|' '
expr_stmt|;
block|}
name|prompt
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|Autoclear
condition|)
name|clear
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|putc
argument_list|(
name|c
argument_list|,
name|Qryiop
argument_list|)
expr_stmt|;
name|Notnull
operator|++
expr_stmt|;
block|}
end_block

end_unit

