begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|"buf.h"
end_include

begin_include
include|#
directive|include
file|<sccs.h>
end_include

begin_macro
name|SCCSID
argument_list|(
argument|@(#)buf.c
literal|7.1
literal|2
argument|/
literal|5
argument|/
literal|81
argument_list|)
end_macro

begin_comment
comment|/* **  BUFFER MANIPULATION ROUTINES */
end_comment

begin_comment
comment|/* **  BUFPUT -- put character onto buffer ** **	The character 'c' is put onto the buffer 'bp'.  If the buffer **	need be extended it is. */
end_comment

begin_macro
name|bufput
argument_list|(
argument|c
argument_list|,
argument|buffer
argument_list|)
end_macro

begin_decl_stmt
name|char
name|c
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|buf
modifier|*
modifier|*
name|buffer
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|buf
modifier|*
name|b
decl_stmt|;
specifier|register
name|struct
name|buf
modifier|*
name|a
decl_stmt|;
specifier|register
name|struct
name|buf
modifier|*
modifier|*
name|bp
decl_stmt|;
name|char
modifier|*
name|bufalloc
parameter_list|()
function_decl|;
name|bp
operator|=
name|buffer
expr_stmt|;
name|b
operator|=
operator|*
name|bp
expr_stmt|;
if|if
condition|(
name|b
operator|==
literal|0
operator|||
name|b
operator|->
name|ptr
operator|>=
operator|&
name|b
operator|->
name|buffer
index|[
name|BUFSIZE
index|]
condition|)
block|{
comment|/* allocate new buffer segment */
name|a
operator|=
operator|(
expr|struct
name|buf
operator|*
operator|)
name|bufalloc
argument_list|(
sizeof|sizeof
expr|*
name|a
argument_list|)
expr_stmt|;
name|a
operator|->
name|nextb
operator|=
name|b
expr_stmt|;
name|a
operator|->
name|ptr
operator|=
name|a
operator|->
name|buffer
expr_stmt|;
operator|*
name|bp
operator|=
name|b
operator|=
name|a
expr_stmt|;
block|}
operator|*
name|b
operator|->
name|ptr
operator|++
operator|=
name|c
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  BUFGET -- get character off of buffer ** **	The buffer is popped and the character is returned.  If the **	segment is then empty, it is returned to the free list. */
end_comment

begin_macro
name|bufget
argument_list|(
argument|buffer
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|buf
modifier|*
modifier|*
name|buffer
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|buf
modifier|*
name|b
decl_stmt|;
specifier|register
name|char
name|c
decl_stmt|;
specifier|register
name|struct
name|buf
modifier|*
modifier|*
name|bp
decl_stmt|;
name|bp
operator|=
name|buffer
expr_stmt|;
name|b
operator|=
operator|*
name|bp
expr_stmt|;
if|if
condition|(
name|b
operator|==
literal|0
operator|||
name|b
operator|->
name|ptr
operator|==
name|b
operator|->
name|buffer
condition|)
block|{
comment|/* buffer is empty -- return end of file */
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|c
operator|=
operator|*
operator|--
operator|(
name|b
operator|->
name|ptr
operator|)
expr_stmt|;
comment|/* check to see if we have emptied the (non-initial) segment */
if|if
condition|(
name|b
operator|->
name|ptr
operator|==
name|b
operator|->
name|buffer
operator|&&
name|b
operator|->
name|nextb
operator|!=
literal|0
condition|)
block|{
comment|/* deallocate segment */
operator|*
name|bp
operator|=
name|b
operator|->
name|nextb
expr_stmt|;
name|buffree
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|c
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  BUFPURGE -- return an entire buffer to the free list ** **	The buffer is emptied and returned to the free list.  This **	routine should be called when the buffer is to no longer **	be used. */
end_comment

begin_macro
name|bufpurge
argument_list|(
argument|buffer
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|buf
modifier|*
modifier|*
name|buffer
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|buf
modifier|*
modifier|*
name|bp
decl_stmt|;
specifier|register
name|struct
name|buf
modifier|*
name|a
decl_stmt|;
specifier|register
name|struct
name|buf
modifier|*
name|b
decl_stmt|;
name|bp
operator|=
name|buffer
expr_stmt|;
name|b
operator|=
operator|*
name|bp
expr_stmt|;
operator|*
name|bp
operator|=
literal|0
expr_stmt|;
comment|/* return the segments to the free list */
while|while
condition|(
name|b
operator|!=
literal|0
condition|)
block|{
name|a
operator|=
name|b
operator|->
name|nextb
expr_stmt|;
name|buffree
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|b
operator|=
name|a
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  BUFFLUSH -- flush a buffer ** **	The named buffer is truncated to zero length.  However, the **	segments of the buffer are not returned to the system. */
end_comment

begin_macro
name|bufflush
argument_list|(
argument|buffer
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|buf
modifier|*
modifier|*
name|buffer
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|buf
modifier|*
name|b
decl_stmt|;
specifier|register
name|struct
name|buf
modifier|*
modifier|*
name|bp
decl_stmt|;
name|bp
operator|=
name|buffer
expr_stmt|;
name|b
operator|=
operator|*
name|bp
expr_stmt|;
if|if
condition|(
name|b
operator|==
literal|0
condition|)
return|return;
comment|/* return second and subsequent segments to the system */
name|bufpurge
argument_list|(
operator|&
name|b
operator|->
name|nextb
argument_list|)
expr_stmt|;
comment|/* truncate this buffer to zero length */
name|b
operator|->
name|ptr
operator|=
name|b
operator|->
name|buffer
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  BUFCRUNCH -- flatten a series of buffers to a string ** **	The named buffer is flattenned to a conventional C string, **	null terminated.  The buffer is deallocated.  The string is **	allocated "somewhere" off in memory, and a pointer to it **	is returned. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|Buf_flat
decl_stmt|;
end_decl_stmt

begin_function
name|char
modifier|*
name|bufcrunch
parameter_list|(
name|buffer
parameter_list|)
name|struct
name|buf
modifier|*
modifier|*
name|buffer
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|bufflatten
parameter_list|()
function_decl|;
name|p
operator|=
name|bufflatten
argument_list|(
operator|*
name|buffer
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
operator|*
name|buffer
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|Buf_flat
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|bufflatten
parameter_list|(
name|buf
parameter_list|,
name|length
parameter_list|)
name|struct
name|buf
modifier|*
name|buf
decl_stmt|;
name|int
name|length
decl_stmt|;
block|{
specifier|register
name|struct
name|buf
modifier|*
name|b
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|char
modifier|*
name|q
decl_stmt|;
name|char
modifier|*
name|bufalloc
parameter_list|()
function_decl|;
name|b
operator|=
name|buf
expr_stmt|;
comment|/* see if we have advanced to beginning of buffer */
if|if
condition|(
name|b
operator|!=
literal|0
condition|)
block|{
comment|/* no, keep moving back */
name|p
operator|=
name|bufflatten
argument_list|(
name|b
operator|->
name|nextb
argument_list|,
name|length
operator|+
operator|(
name|b
operator|->
name|ptr
operator|-
name|b
operator|->
name|buffer
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* yes, allocate the string */
name|Buf_flat
operator|=
name|p
operator|=
name|bufalloc
argument_list|(
name|length
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
comment|/* copy buffer into string */
for|for
control|(
name|q
operator|=
name|b
operator|->
name|buffer
init|;
name|q
operator|<
name|b
operator|->
name|ptr
condition|;
control|)
operator|*
name|p
operator|++
operator|=
operator|*
name|q
operator|++
expr_stmt|;
comment|/* deallocate the segment */
name|buffree
argument_list|(
name|b
argument_list|)
expr_stmt|;
comment|/* process next segment */
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  BUFALLOC -- allocate clear memory ** **	This is similar to the system malloc routine except that **	it has no error return, and memory is guaranteed to be clear **	when you return. ** **	It might be nice to rewrite this later to avoid the nasty **	memory fragmentation that malloc() tends toward. ** **	The error processing might have to be modified if used anywhere **	other than INGRES. */
end_comment

begin_function
name|char
modifier|*
name|bufalloc
parameter_list|(
name|size
parameter_list|)
name|int
name|size
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|extern
name|int
function_decl|(
modifier|*
name|ExitFn
function_decl|)
parameter_list|()
function_decl|;
comment|/* defined in syserr.c */
specifier|extern
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
name|p
operator|=
name|malloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"Out of memory in macro processor\n"
argument_list|)
expr_stmt|;
call|(
modifier|*
name|ExitFn
call|)
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|clrmem
argument_list|(
name|p
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  BUFFREE -- free memory */
end_comment

begin_macro
name|buffree
argument_list|(
argument|ptr
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|ptr
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|ptr
expr_stmt|;
if|if
condition|(
name|p
operator|==
literal|0
condition|)
name|syserr
argument_list|(
literal|"buffree: 0 ptr"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

