begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|<ingres.h>
end_include

begin_include
include|#
directive|include
file|<aux.h>
end_include

begin_include
include|#
directive|include
file|<symbol.h>
end_include

begin_include
include|#
directive|include
file|<tree.h>
end_include

begin_include
include|#
directive|include
file|"../decomp/globs.h"
end_include

begin_include
include|#
directive|include
file|"strategy.h"
end_include

begin_include
include|#
directive|include
file|<sccs.h>
end_include

begin_macro
name|SCCSID
argument_list|(
argument|@(#)key.c
literal|7.1
literal|2
argument|/
literal|5
argument|/
literal|81
argument_list|)
end_macro

begin_comment
comment|/* **	Exactkey checks to see if the relation described **	by "ap" can be used in a hashed scan. **	All the key domains of the relation must **	have simple clauses of equality associated **	with them in the qualification. ** **	Returns 0 if the relation can't be used. ** **	Returns> 0 if it can. */
end_comment

begin_macro
name|exactkey
argument_list|(
argument|ap
argument_list|,
argument|key
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|accessparam
modifier|*
name|ap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|key
modifier|*
name|key
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|accessparam
modifier|*
name|a
decl_stmt|;
specifier|register
name|struct
name|key
modifier|*
name|k
decl_stmt|;
specifier|register
name|struct
name|simp
modifier|*
name|s
decl_stmt|;
name|int
name|d
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
ifdef|#
directive|ifdef
name|xOTR1
if|if
condition|(
name|tTf
argument_list|(
literal|85
argument_list|,
operator|-
literal|1
argument_list|)
condition|)
name|printf
argument_list|(
literal|"Exactkey\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|a
operator|=
name|ap
expr_stmt|;
name|k
operator|=
name|key
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|a
operator|->
name|mode
operator|==
name|EXACTKEY
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|d
operator|=
name|a
operator|->
name|keydno
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|s
operator|=
name|De
operator|.
name|ov_simp
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|De
operator|.
name|ov_nsimp
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|s
operator|->
name|relop
operator|==
name|opEQ
operator|&&
name|s
operator|->
name|att
operator|==
name|d
condition|)
block|{
name|k
operator|->
name|keysym
operator|=
name|s
operator|->
expr|const
expr_stmt|;
name|k
operator|->
name|dnumber
operator|=
operator|(
name|a
operator|->
name|sec_index
operator|==
name|TRUE
operator|)
condition|?
name|i
operator|+
literal|1
else|:
name|d
expr_stmt|;
name|k
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|xOTR1
if|if
condition|(
name|tTf
argument_list|(
literal|85
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"exact key on dom %d\tvalue="
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|prsym
argument_list|(
name|s
operator|->
expr|const
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
break|break;
block|}
name|s
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|j
operator|==
name|De
operator|.
name|ov_nsimp
condition|)
block|{
name|i
operator|=
literal|0
expr_stmt|;
comment|/* failure. at lease one key isn't used */
break|break;
block|}
block|}
name|k
operator|->
name|dnumber
operator|=
literal|0
expr_stmt|;
comment|/* mark end of list */
block|}
ifdef|#
directive|ifdef
name|xOTR1
if|if
condition|(
name|tTf
argument_list|(
literal|85
argument_list|,
literal|9
argument_list|)
condition|)
name|printf
argument_list|(
literal|"exactkey returning %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|i
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **	Range key checks if the relation described by **	"ap" is ISAM and there are simple clauses **	on the first key and any additional keys. ** **	Rangekey accumulates both high and low keys, **	which are not necessary the same. If it **	every finds a high or a low key on the first **	domain of the relation then success=TRUE. ** **	Returns  1 if Rangekey ok **		 0 if Rangekey is not ok **		-1 if Rangekey ok and all clauses are equality clauses */
end_comment

begin_macro
name|rangekey
argument_list|(
argument|ap
argument_list|,
argument|l
argument_list|,
argument|h
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|accessparam
modifier|*
name|ap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|key
modifier|*
name|l
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|key
modifier|*
name|h
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|key
modifier|*
name|low
decl_stmt|,
modifier|*
name|high
decl_stmt|;
specifier|register
name|struct
name|simp
modifier|*
name|s
decl_stmt|;
name|struct
name|accessparam
modifier|*
name|a
decl_stmt|;
name|int
name|sec_indx
decl_stmt|,
name|d
decl_stmt|,
name|i
decl_stmt|;
name|int
name|rel
decl_stmt|,
name|success
decl_stmt|,
name|ns
decl_stmt|,
name|lowkey
decl_stmt|,
name|allexact
decl_stmt|;
ifdef|#
directive|ifdef
name|xOTR1
if|if
condition|(
name|tTf
argument_list|(
literal|85
argument_list|,
literal|5
argument_list|)
condition|)
name|printf
argument_list|(
literal|"Rangekey\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|a
operator|=
name|ap
expr_stmt|;
name|sec_indx
operator|=
name|a
operator|->
name|sec_index
operator|==
name|TRUE
expr_stmt|;
name|low
operator|=
name|l
expr_stmt|;
name|high
operator|=
name|h
expr_stmt|;
name|allexact
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* assume all clauses equality clauses */
name|s
operator|=
name|De
operator|.
name|ov_simp
expr_stmt|;
name|success
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|a
operator|->
name|mode
operator|==
name|LRANGEKEY
condition|)
block|{
for|for
control|(
name|ns
operator|=
literal|0
init|;
name|ns
operator|<
name|De
operator|.
name|ov_nsimp
condition|;
name|ns
operator|++
control|)
block|{
name|rel
operator|=
name|s
operator|->
name|relop
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|d
operator|=
name|a
operator|->
name|keydno
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|d
operator|==
name|s
operator|->
name|att
condition|)
block|{
comment|/* this is either a high range value or low range value */
name|lowkey
operator|=
operator|(
name|rel
operator|==
name|opGTGE
operator|)
expr_stmt|;
if|if
condition|(
name|lowkey
operator|||
name|rel
operator|==
name|opEQ
condition|)
block|{
comment|/* low range key */
ifdef|#
directive|ifdef
name|xOTR1
if|if
condition|(
name|tTf
argument_list|(
literal|85
argument_list|,
literal|6
argument_list|)
condition|)
name|printf
argument_list|(
literal|"low key on dom %d\t"
argument_list|,
name|d
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|low
operator|->
name|keysym
operator|=
name|s
operator|->
expr|const
expr_stmt|;
name|low
operator|->
name|dnumber
operator|=
name|sec_indx
condition|?
name|i
operator|+
literal|1
else|:
name|d
expr_stmt|;
name|low
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|lowkey
operator|||
name|rel
operator|==
name|opEQ
condition|)
block|{
comment|/* high range key */
ifdef|#
directive|ifdef
name|xOTR1
if|if
condition|(
name|tTf
argument_list|(
literal|85
argument_list|,
literal|6
argument_list|)
condition|)
name|printf
argument_list|(
literal|"high key on dom %d\t"
argument_list|,
name|d
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|high
operator|->
name|keysym
operator|=
name|s
operator|->
expr|const
expr_stmt|;
name|high
operator|->
name|dnumber
operator|=
name|sec_indx
condition|?
name|i
operator|+
literal|1
else|:
name|d
expr_stmt|;
name|high
operator|++
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|xOTR1
if|if
condition|(
name|tTf
argument_list|(
literal|85
argument_list|,
literal|6
argument_list|)
condition|)
name|prsym
argument_list|(
name|s
operator|->
expr|const
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|success
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|rel
operator|!=
name|opEQ
condition|)
name|allexact
operator|=
literal|1
expr_stmt|;
comment|/* at least one inequality */
break|break;
block|}
block|}
name|s
operator|++
expr_stmt|;
comment|/* try next simple clause */
block|}
block|}
name|high
operator|->
name|dnumber
operator|=
literal|0
expr_stmt|;
comment|/* mark end of list */
name|low
operator|->
name|dnumber
operator|=
literal|0
expr_stmt|;
comment|/* mask end of list */
comment|/* if success then return whether all clauses were equality */
if|if
condition|(
name|success
condition|)
name|success
operator|=
name|allexact
expr_stmt|;
ifdef|#
directive|ifdef
name|xOTR1
if|if
condition|(
name|tTf
argument_list|(
literal|85
argument_list|,
literal|5
argument_list|)
condition|)
name|printf
argument_list|(
literal|"rangekey returning %d\n"
argument_list|,
name|success
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|success
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **	Setallkey takes a key struct, decodes it and **	calls setkey with each value. ** **	Called from strategy(). ** **	returns 0 if ok. **	returns -1 in the special case of a deblanked hashkey **	being bigger than the corresponding domain. */
end_comment

begin_macro
name|setallkey
argument_list|(
argument|relkey
argument_list|,
argument|keytuple
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|key
modifier|*
name|relkey
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|keytuple
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|key
modifier|*
name|k
decl_stmt|;
specifier|register
name|SYMBOL
modifier|*
name|sk
decl_stmt|;
specifier|register
name|int
name|dnum
decl_stmt|;
name|struct
name|symbol
modifier|*
modifier|*
name|s
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
name|temp
index|[
literal|256
index|]
decl_stmt|;
name|int
name|l
decl_stmt|;
name|clearkeys
argument_list|(
name|De
operator|.
name|ov_scanr
argument_list|)
expr_stmt|;
name|k
operator|=
name|relkey
expr_stmt|;
while|while
condition|(
name|dnum
operator|=
name|k
operator|->
name|dnumber
condition|)
block|{
name|s
operator|=
operator|&
name|k
operator|->
name|keysym
expr_stmt|;
name|sk
operator|=
operator|(
name|SYMBOL
operator|*
operator|)
name|De
operator|.
name|ov_stack
expr_stmt|;
name|getsymbol
argument_list|(
name|sk
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
comment|/* copy symbol to stack. caution:getsym changes the value of s. */
name|rcvt
argument_list|(
name|sk
argument_list|,
name|De
operator|.
name|ov_scanr
operator|->
name|relfrmt
index|[
name|dnum
index|]
argument_list|,
name|De
operator|.
name|ov_scanr
operator|->
name|relfrml
index|[
name|dnum
index|]
argument_list|)
expr_stmt|;
comment|/* convert key to correct type */
name|p
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|sk
operator|->
name|value
expr_stmt|;
if|if
condition|(
name|sk
operator|->
name|type
operator|==
name|CHAR
condition|)
block|{
comment|/* 			** The length of a character key must 			** be made equal to the domain length. 			** The key is copied to a temp place 			** and a null byte is inserted at the 			** end. In addition, if the key without 			** blanks is longer than the domain and 			** this is an exactkey, then the query 			** is false. 			*/
name|p
operator|=
name|temp
expr_stmt|;
name|l
operator|=
name|cmove
argument_list|(
name|sk
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* copy symbol to temp removing blanks& nulls */
ifdef|#
directive|ifdef
name|xOTR1
if|if
condition|(
name|tTf
argument_list|(
literal|86
argument_list|,
literal|9
argument_list|)
condition|)
name|printf
argument_list|(
literal|"length is %d\n"
argument_list|,
name|l
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|De
operator|.
name|ov_fmode
operator|==
name|EXACTKEY
operator|&&
name|l
operator|>
operator|(
name|De
operator|.
name|ov_scanr
operator|->
name|relfrml
index|[
name|dnum
index|]
operator|&
literal|0377
operator|)
condition|)
comment|/* key too large. qualification is false */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|setkey
argument_list|(
name|De
operator|.
name|ov_scanr
argument_list|,
name|keytuple
argument_list|,
name|p
argument_list|,
name|dnum
argument_list|)
expr_stmt|;
comment|/* set the key */
name|k
operator|++
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|xOTR1
if|if
condition|(
name|tTf
argument_list|(
literal|86
argument_list|,
literal|8
argument_list|)
condition|)
name|printup
argument_list|(
name|De
operator|.
name|ov_scanr
argument_list|,
name|keytuple
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **	Cmove copies a char symbol into "dest". **	It stops when the length is reached or **	when a null byte is found. ** **	returns the number of non-blank chars **	in the string. */
end_comment

begin_macro
name|cmove
argument_list|(
argument|sym
argument_list|,
argument|dest
argument_list|)
end_macro

begin_decl_stmt
name|SYMBOL
modifier|*
name|sym
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|dest
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|d
decl_stmt|,
modifier|*
name|s
decl_stmt|;
specifier|register
name|int
name|l
decl_stmt|;
name|int
name|blank
decl_stmt|;
name|s
operator|=
name|sym
operator|->
name|value
operator|.
name|sym_data
operator|.
name|cptype
expr_stmt|;
comment|/* s points to the char string */
name|d
operator|=
name|dest
expr_stmt|;
name|blank
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|l
operator|=
operator|(
name|sym
operator|->
name|len
operator|&
literal|0377
operator|)
init|;
name|l
operator|--
condition|;
name|s
operator|++
control|)
block|{
operator|*
name|d
operator|++
operator|=
operator|*
name|s
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|' '
condition|)
name|blank
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'\0'
condition|)
block|{
name|d
operator|--
expr_stmt|;
break|break;
block|}
block|}
operator|*
name|d
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
operator|(
name|d
operator|-
name|dest
operator|)
operator|-
name|blank
operator|)
return|;
comment|/* return length of string */
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **	Indexcheck is called by scan() to check whether **	a secondary index tuple satisfies the simple **	clauses under which it was scanned. ** **	Returns 1 if the tuple is ok, **		0 otherwise. */
end_comment

begin_macro
name|indexcheck
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|De
operator|.
name|ov_fmode
operator|==
name|EXACTKEY
condition|)
name|i
operator|=
name|keycheck
argument_list|(
name|De
operator|.
name|ov_lkey_struct
argument_list|,
name|De
operator|.
name|ov_keyl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* check for equality */
else|else
block|{
name|i
operator|=
name|keycheck
argument_list|(
name|De
operator|.
name|ov_lkey_struct
argument_list|,
name|De
operator|.
name|ov_keyl
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* check for>= */
comment|/* If the lowkey passed, check the highkey also */
if|if
condition|(
name|i
condition|)
name|i
operator|=
name|keycheck
argument_list|(
name|De
operator|.
name|ov_hkey_struct
argument_list|,
name|De
operator|.
name|ov_keyh
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* check for<= */
block|}
ifdef|#
directive|ifdef
name|xOTR1
if|if
condition|(
name|tTf
argument_list|(
literal|86
argument_list|,
literal|10
argument_list|)
condition|)
name|printf
argument_list|(
literal|"indexcheck ret %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|i
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **	Keycheck compares De.ov_intup with keytuple **	according to the domains specified in the **	"keys" struct. ** **	mode is either>0, =0,<0 depending on **	whether check is for De.ov_intup>= keytuple, **	De.ov_intup == keytuple, De.ov_intup<= keytuple respectively ** **	returns TRUE or FALSE accordingly. */
end_comment

begin_macro
name|keycheck
argument_list|(
argument|keys
argument_list|,
argument|keytuple
argument_list|,
argument|mode
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|key
modifier|*
name|keys
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|keytuple
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|mode
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|key
modifier|*
name|k
decl_stmt|;
specifier|register
name|char
modifier|*
name|kp
decl_stmt|;
specifier|register
name|int
name|dnum
decl_stmt|;
name|int
name|offset
decl_stmt|,
name|i
decl_stmt|,
name|success
decl_stmt|;
name|kp
operator|=
name|keytuple
expr_stmt|;
name|success
operator|=
name|TRUE
expr_stmt|;
for|for
control|(
name|k
operator|=
name|keys
init|;
name|dnum
operator|=
name|k
operator|->
name|dnumber
condition|;
name|k
operator|++
control|)
block|{
name|offset
operator|=
name|De
operator|.
name|ov_scanr
operator|->
name|reloff
index|[
name|dnum
index|]
expr_stmt|;
if|if
condition|(
name|i
operator|=
name|icompare
argument_list|(
operator|&
name|De
operator|.
name|ov_intup
index|[
name|offset
index|]
argument_list|,
operator|&
name|kp
index|[
name|offset
index|]
argument_list|,
name|De
operator|.
name|ov_scanr
operator|->
name|relfrmt
index|[
name|dnum
index|]
argument_list|,
name|De
operator|.
name|ov_scanr
operator|->
name|relfrml
index|[
name|dnum
index|]
operator|&
name|I1MASK
argument_list|)
condition|)
block|{
if|if
condition|(
name|i
operator|<
literal|0
operator|&&
name|mode
operator|<
literal|0
operator|||
name|i
operator|>
literal|0
operator|&&
name|mode
operator|>
literal|0
condition|)
continue|continue;
name|success
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
block|}
return|return
operator|(
name|success
operator|)
return|;
block|}
end_block

end_unit

