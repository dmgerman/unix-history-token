begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (c) 1982 Regents of the University of California */
end_comment

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)unifdef.c	4.1	(Berkeley)	10/22/82"
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|COMMENT
end_ifdef

begin_expr_stmt
name|unifdef
operator|-
name|remove
name|ifdef
literal|'ed lines  #endif  #include<stdio.h> #include<ctype.h> #define BSS FILE *input; #ifndef YES #define YES 1 #define NO  0 #endif  char *progname BSS; char *filename BSS; char text BSS;          /* -t option in effect: this is a text file */ char lnblank BSS;       /* -l option in effect: blank deleted lines */ char complement BSS;    /* -c option in effect: complement the operation */ #define MAXSYMS 100 char true[MAXSYMS] BSS; char ignore[MAXSYMS] BSS; char *sym[MAXSYMS] BSS; char insym[MAXSYMS] BSS; char nsyms BSS; char incomment BSS; #define QUOTE1 0 #define QUOTE2 1 char inquote[2] BSS; int exitstat BSS; char *skipcomment (); char *skipquote ();  main (argc, argv) int argc; char **argv; {     char **curarg;     register char *cp;     register char *cp1;     char ignorethis;      progname = argv[0][0] ? argv[0] : "unifdef";      for (curarg =&argv[1]; --argc> 0; curarg++) { 	if (*(cp1 = cp = *curarg) != '
operator|-
literal|') 	    break; 	if (*++cp1 == '
name|i
literal|') { 	    ignorethis = YES; 	    cp1++; 	} 	else 	    ignorethis = NO; 	if (   (   *cp1 == '
name|d
literal|' 		|| *cp1 == '
literal|u'
expr|)&& cp1[1] != '
operator|\
literal|0
literal|' 	   ) { 	    if (nsyms>= MAXSYMS) { 		prname (); 		fprintf (stderr, "too many symbols.\n"); 		exit (2); 	    } 	    ignore[nsyms] = ignorethis; 	    true[nsyms] = *cp1 == '
name|d
literal|' ? YES : NO; 	    sym[nsyms++] =&cp1[1]; 	} 	else if (ignorethis) 	    goto unrec; 	else if (strcmp (&cp[1], "t") == 0) 	    text = YES; 	else if (strcmp (&cp[1], "l") == 0) 	    lnblank = YES; 	else if (strcmp (&cp[1], "c") == 0) 	    complement = YES; 	else {  unrec: 	    prname (); 	    fprintf (stderr, "unrecognized option: %s\n", cp); 	    goto usage; 	}     }     if (nsyms == 0) {  usage: 	fprintf (stderr, "\ Usage: %s [-l] [-t] [-c] [[-dsym] [-usym] [-idsym] [-iusym]]... [file]\n\     At least one arg from [-d -u -id -iu] is required\n", progname); 	exit (2);     }      if (argc> 1) { 	prname (); 	fprintf (stderr, "can only do one file.\n");     }     else if (argc == 1) { 	filename = *curarg; 	if ((input = fopen (filename, "r")) != NULL) { 	    pfile(); 	    fclose (input); 	} 	else { 	    prname (); 	    fprintf (stderr, "can'
name|t
name|open
operator|%
name|s
operator|\
name|n
literal|", *curarg); 	}     }     else { 	filename = "
index|[
name|stdin
index|]
literal|"; 	input = stdin; 	pfile();     }      fflush (stdout);     exit (exitstat); }  /* types of input lines: */ #define PLAIN       0   /* ordinary line */ #define TRUE        1   /* a true  #ifdef of a symbol known to us */ #define FALSE       2   /* a false #ifdef of a symbol known to us */ #define OTHER       3   /* an #ifdef of a symbol not known to us */ #define ELSE        4   /* #else */ #define ENDIF       5   /* #endif */ #define LEOF        6   /* end of file */  char reject BSS;    /* 0 or 1: pass thru; 1 or 2: ignore comments */ int linenum BSS;    /* current line number */ int stqcline BSS;   /* start of current coment or quote */ char *errs[] = { #define NO_ERR      0 			"
literal|", #define END_ERR     1 			"
literal|", #define ELSE_ERR    2 			"
name|Inappropriate
end_expr_stmt

begin_else
else|else
literal|", #define ENDIF_ERR   3 			"
name|Inappropriate
name|endif
literal|", #define IEOF_ERR    4 			"
name|Premature
name|EOF
name|in
name|ifdef
literal|", #define CEOF_ERR    5 			"
name|Premature
name|EOF
name|in
name|comment
literal|", #define Q1EOF_ERR   6 			"
name|Premature
name|EOF
name|in
name|quoted
name|character
literal|", #define Q2EOF_ERR   7 			"
name|Premature
name|EOF
name|in
name|quoted
name|string
literal|" };  pfile () {     reject = 0;     doif (-1, NO, reject, 0);     return; }  doif (thissym, inif, prevreject, depth) register int thissym;   /* index of the symbol who was last ifdef'ed */ int inif;               /* YES or NO we are inside an ifdef */ int prevreject;         /* previous value of reject */ int depth;              /* depth of ifdef's */ {     register int lineval;     register int thisreject;     int doret;          /* tmp return valud]e of doif */     int cursym;         /* index of the symbol returned by checkline */     int stline;         /* line number when called this time */      stline = linenum;     for (;;) { 	switch (lineval = checkline (&cursym)) { 	case PLAIN: 	    flushline (YES); 	    break;  	case TRUE: 	case FALSE: 	    thisreject = reject; 	    if (lineval == TRUE) 		insym[cursym] = 1; 	    else { 		if (reject< 2) 		    reject = ignore[cursym] ? 1 : 2; 		insym[cursym] = -1; 	    } 	    if (ignore[cursym]) 		flushline (YES); 	    else { 		exitstat = 1; 		flushline (NO); 	    } 	    if ((doret = doif (cursym, YES, thisreject, depth + 1)) != NO_ERR) 		return error (doret, stline, depth);     	    break;  	case OTHER: 	    flushline (YES); 	    if ((doret = doif (-1, YES, reject, depth + 1)) != NO_ERR) 		return error (doret, stline, depth); 	    break;  	case ELSE: 	    if (inif != 1) 		return error (ELSE_ERR, linenum, depth); 	    inif = 2; 	    if (thissym>= 0) { 		if ((insym[thissym] = -insym[thissym])< 0) 		    reject = ignore[thissym] ? 1 : 2; 		else 		    reject = prevreject; 		if (!ignore[thissym]) { 		    flushline (NO); 		    break; 		} 	    } 	    flushline (YES); 	    break;  	case ENDIF: 	    if (inif == 0) 		return error (ENDIF_ERR, linenum, depth); 	    if (thissym>= 0) { 		insym[thissym] = 0; 		reject = prevreject; 		if (!ignore[thissym]) { 		    flushline (NO); 		    return NO_ERR; 		} 	    } 	    flushline (YES); 	    return NO_ERR;  	case LEOF: { 	    int err; 	    err =   incomment 		  ? CEOF_ERR 		  : inquote[QUOTE1] 		  ? Q1EOF_ERR 		  : inquote[QUOTE2] 		  ? Q2EOF_ERR 		  : NO_ERR; 	    if (inif) { 		if (err != NO_ERR) 		    error (err, stqcline, depth); 		return error (IEOF_ERR, stline, depth); 	    } 	    else if (err != NO_ERR) 		return error (err, stqcline, depth); 	    else 		return NO_ERR; 	    } 	}     } }  #define endsym(c) (!isalpha (c)&& !isdigit (c)&& c != '_')  #define MAXLINE 256 char tline[MAXLINE] BSS;  checkline (cursym) int *cursym; {     register char *cp;     register char *symp;     register char chr;     char *scp;     int retval;     int symind; #   define KWSIZE 8     char keyword[KWSIZE];      linenum++;     if (getlin (tline, sizeof tline, input, NO) == EOF)         return LEOF;      retval = PLAIN;     if (   *(cp = tline) != '#' 	|| incomment 	|| inquote[QUOTE1] 	|| inquote[QUOTE2]        ) 	goto eol;      cp = skipcomment (++cp);     symp = keyword;     while (!endsym (*cp)) { 	*symp = *cp++; 	if (++symp>=&keyword[KWSIZE]) 	    goto eol;     }     *symp = '\0';      if (strcmp (keyword, "
name|ifdef
literal|") == 0) { 	retval = YES; 	goto ifdef;     }     else if (strcmp (keyword, "
name|ifndef
literal|") == 0) { 	retval = NO;  ifdef: 	scp = cp = skipcomment (++cp); 	if (incomment) { 	    retval = PLAIN; 	    goto eol; 	} 	for (symind = 0; ; ) { 	    if (insym[symind] == 0) { 		for ( symp = sym[symind], cp = scp 		    ; *symp&& *cp == *symp 		    ; cp++, symp++ 		    ) 		    {} 		chr = *cp; 		if (*symp == '\0'&& endsym (chr)) { 		    *cursym = symind; 		    retval = (retval ^ true[symind]) ? FALSE : TRUE; 		    break; 		} 	    } 	    if (++symind>= nsyms) { 		retval = OTHER; 		break; 	    } 	}     }     else if (strcmp (keyword, "
end_else

begin_if
if|if") == 0) 	retval = OTHER;     else if (strcmp (keyword, "else") == 0) 	retval = ELSE;     else if (strcmp (keyword, "endif") == 0) 	retval = ENDIF;   eol:     if (!text&& !reject) 	for (; *cp; ) { 	    if (incomment) 		cp = skipcomment (cp); 	    else if (inquote[QUOTE1]) 		cp = skipquote (cp, QUOTE1); 	    else if (inquote[QUOTE2]) 		cp = skipquote (cp, QUOTE2); 	    else if (*cp == '/'&& cp[1] == '*') 		cp = skipcomment (cp); 	    else if (*cp == '\'') 		cp = skipquote (cp, QUOTE1); 	    else if (*cp == '"') 		cp = skipquote (cp, QUOTE2); 	    else 		cp++; 	}     return retval; }  /*  Skip over comments and stop at the next charaacter /*  position that is not whitespace. /**/ char * skipcomment (cp) register char *cp; {     if (incomment) 	goto inside;     for (;; cp++) {         while (*cp == ' ' || *cp == '\t')             cp++; 	if (text)             return cp; 	if (   cp[0] != '/' 	    || cp[1] != '*' 	   )             return cp; 	cp += 2; 	if (!incomment) { 	    incomment = YES; 	    stqcline = linenum; 	}  inside: 	for (;;) { 	    for (; *cp != '*'; cp++) 		if (*cp == '\0') 		    return cp; 	    if (*++cp == '/') 		break; 	} 	incomment = NO;     } }  /*  Skip over a quoted string or character and stop at the next charaacter /*  position that is not whitespace. /**/ char * skipquote (cp, type) register char *cp; register int type; {     register char qchar;      qchar = type == QUOTE1 ? '\'' : '"'
empty_stmt|;
end_if

begin_if
if|if
condition|(
name|inquote
index|[
name|type
index|]
condition|)
goto|goto
name|inside
goto|;
end_if

begin_for
for|for
control|(
init|;
condition|;
name|cp
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|cp
operator|!=
name|qchar
condition|)
return|return
name|cp
return|;
name|cp
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|inquote
index|[
name|type
index|]
condition|)
block|{
name|inquote
index|[
name|type
index|]
operator|=
name|YES
expr_stmt|;
name|stqcline
operator|=
name|linenum
expr_stmt|;
block|}
name|inside
label|:
for|for
control|(
init|;
condition|;
name|cp
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
name|qchar
condition|)
break|break;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\0'
operator|||
operator|*
name|cp
operator|==
literal|'\\'
operator|&&
operator|*
operator|++
name|cp
operator|==
literal|'\0'
condition|)
return|return
name|cp
return|;
block|}
name|inquote
index|[
name|type
index|]
operator|=
name|NO
expr_stmt|;
block|}
end_for

begin_comment
unit|}
comment|/* /*   special getlin - treats form-feed as an end-of-line /*                    and expands tabs if asked for /* /**/
end_comment

begin_expr_stmt
unit|getlin
operator|(
name|line
operator|,
name|maxline
operator|,
name|inp
operator|,
name|expandtabs
operator|)
specifier|register
name|char
operator|*
name|line
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|maxline
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|inp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|expandtabs
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|tmp
decl_stmt|;
specifier|register
name|int
name|num
decl_stmt|;
specifier|register
name|int
name|chr
decl_stmt|;
ifdef|#
directive|ifdef
name|FFSPECIAL
specifier|static
name|char
name|havechar
init|=
name|NO
decl_stmt|;
comment|/* have leftover char from last time */
specifier|static
name|char
name|svchar
name|BSS
decl_stmt|;
endif|#
directive|endif
name|num
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|FFSPECIAL
if|if
condition|(
name|havechar
condition|)
block|{
name|havechar
operator|=
name|NO
expr_stmt|;
name|chr
operator|=
name|svchar
expr_stmt|;
goto|goto
name|ent
goto|;
block|}
endif|#
directive|endif
while|while
condition|(
name|num
operator|+
literal|8
operator|<
name|maxline
condition|)
block|{
comment|/* leave room for tab */
name|chr
operator|=
name|getc
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|isprint
argument_list|(
name|chr
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|FFSPECIAL
name|ent
label|:
endif|#
directive|endif
operator|*
name|line
operator|++
operator|=
name|chr
expr_stmt|;
name|num
operator|++
expr_stmt|;
block|}
else|else
switch|switch
condition|(
name|chr
condition|)
block|{
case|case
name|EOF
case|:
return|return
name|EOF
return|;
case|case
literal|'\t'
case|:
if|if
condition|(
name|expandtabs
condition|)
block|{
name|num
operator|+=
name|tmp
operator|=
literal|8
operator|-
operator|(
name|num
operator|&
literal|7
operator|)
expr_stmt|;
do|do
operator|*
name|line
operator|++
operator|=
literal|' '
expr_stmt|;
do|while
condition|(
operator|--
name|tmp
condition|)
do|;
break|break;
block|}
default|default:
operator|*
name|line
operator|++
operator|=
name|chr
expr_stmt|;
name|num
operator|++
expr_stmt|;
break|break;
case|case
literal|'\n'
case|:
operator|*
name|line
operator|=
literal|'\n'
expr_stmt|;
name|num
operator|++
expr_stmt|;
goto|goto
name|end
goto|;
ifdef|#
directive|ifdef
name|FFSPECIAL
case|case
literal|'\f'
case|:
if|if
condition|(
operator|++
name|num
operator|==
literal|1
condition|)
operator|*
name|line
operator|=
literal|'\f'
expr_stmt|;
else|else
block|{
operator|*
name|line
operator|=
literal|'\n'
expr_stmt|;
name|havechar
operator|=
name|YES
expr_stmt|;
name|svchar
operator|=
name|chr
expr_stmt|;
block|}
goto|goto
name|end
goto|;
endif|#
directive|endif
block|}
block|}
name|end
label|:
operator|*
operator|++
name|line
operator|=
literal|'\0'
expr_stmt|;
return|return
name|num
return|;
block|}
end_block

begin_macro
name|flushline
argument_list|(
argument|keep
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
operator|(
name|keep
operator|&&
name|reject
operator|<
literal|2
operator|)
operator|^
name|complement
condition|)
name|putlin
argument_list|(
name|tline
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|lnblank
condition|)
name|putlin
argument_list|(
literal|"\n"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
return|return;
block|}
end_block

begin_comment
comment|/* /*  putlin - for tools /* /**/
end_comment

begin_expr_stmt
name|putlin
argument_list|(
name|line
argument_list|,
name|fio
argument_list|)
specifier|register
name|char
operator|*
name|line
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|FILE
modifier|*
name|fio
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
name|chr
decl_stmt|;
while|while
condition|(
name|chr
operator|=
operator|*
name|line
operator|++
condition|)
name|putc
argument_list|(
name|chr
argument_list|,
name|fio
argument_list|)
expr_stmt|;
return|return;
block|}
end_block

begin_macro
name|prname
argument_list|()
end_macro

begin_block
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|progname
argument_list|)
expr_stmt|;
return|return;
block|}
end_block

begin_macro
name|error
argument_list|(
argument|err
argument_list|,
argument|line
argument_list|,
argument|depth
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
name|err
operator|==
name|END_ERR
condition|)
return|return
name|err
return|;
name|prname
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|TESTING
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error in %s line %d: %s.\n"
argument_list|,
name|filename
argument_list|,
name|line
argument_list|,
name|errs
index|[
name|err
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TESTING
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error in %s line %d: %s. "
argument_list|,
name|filename
argument_list|,
name|line
argument_list|,
name|errs
index|[
name|err
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ifdef depth: %d\n"
argument_list|,
name|depth
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|exitstat
operator|=
literal|2
expr_stmt|;
return|return
name|depth
operator|>
literal|1
condition|?
name|IEOF_ERR
else|:
name|END_ERR
return|;
block|}
end_block

end_unit

