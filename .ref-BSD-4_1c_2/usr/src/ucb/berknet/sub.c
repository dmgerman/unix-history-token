begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)sub.c	4.5	(Berkeley)	1/5/83"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 	sub.c  	support procedures  	the following procedures end up reading the passwd file 	or the passwdf file and are to be avoided.  	getpwuid(uid) 	getpwnam(sn) 	PwdCurrent() 	getenv("HOME")		maybe if hget, hgethome don't work 	SnFromUid(uid)		maybe if hashed passwd stuff doesn't work 	SnCurrent()		maybe if getlogin fails calls SnFromUid(uid) 	getpwf() 	passwdent(uid,sn) */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<varargs.h>
end_include

begin_comment
comment|/* global variables */
end_comment

begin_decl_stmt
name|int
name|debugflg
init|=
name|DBV
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* debug flag */
end_comment

begin_decl_stmt
name|char
name|local
init|=
name|LOCAL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the machine we're on */
end_comment

begin_decl_stmt
name|struct
name|userinfo
name|status
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|netcmd
index|[]
init|=
name|NETCMD
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|resfile
index|[]
init|=
name|RESFILE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|senddir
index|[]
init|=
name|SENDDIR
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|Bsh
index|[]
init|=
name|BINSH
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|shomedir
index|[
literal|100
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 	passwdent()  	Read the password file looking for current user's entry. 	Fill in the status structure. 	Has the (dangerous) side effect of giving a value to getenv("HOME"). */
end_comment

begin_macro
name|passwdent
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|char
modifier|*
name|u
decl_stmt|;
specifier|register
name|struct
name|passwd
modifier|*
name|pwd
decl_stmt|;
ifdef|#
directive|ifdef
name|CRN
specifier|register
name|struct
name|gecos
modifier|*
name|gcos
decl_stmt|;
endif|#
directive|endif
name|pwd
operator|=
name|PwdCurrent
argument_list|()
expr_stmt|;
if|if
condition|(
name|pwd
operator|==
name|NULL
condition|)
block|{
name|err
argument_list|(
literal|"Bad uid/username\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|strcpy
argument_list|(
name|status
operator|.
name|localname
argument_list|,
name|pwd
operator|->
name|pw_name
argument_list|)
expr_stmt|;
name|status
operator|.
name|muid
operator|=
name|guid
argument_list|(
name|pwd
operator|->
name|pw_uid
argument_list|,
name|pwd
operator|->
name|pw_gid
argument_list|)
expr_stmt|;
name|status
operator|.
name|mgid
operator|=
name|pwd
operator|->
name|pw_gid
expr_stmt|;
ifdef|#
directive|ifdef
name|CRN
if|if
condition|(
operator|(
name|gcos
operator|=
name|pwgecos
argument_list|(
name|pwd
operator|->
name|pw_gecos
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|strcpy
argument_list|(
name|status
operator|.
name|jobno
argument_list|,
name|MAGICCRN
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|debugflg
condition|)
name|debug
argument_list|(
literal|"crn found = %s\n"
argument_list|,
name|gcos
operator|->
name|gc_crn
argument_list|)
expr_stmt|;
if|if
condition|(
name|isalpha
argument_list|(
name|gcos
operator|->
name|gc_crn
index|[
literal|0
index|]
argument_list|)
operator|||
name|isdigit
argument_list|(
name|gcos
operator|->
name|gc_crn
index|[
literal|0
index|]
argument_list|)
condition|)
name|strcpy
argument_list|(
name|status
operator|.
name|jobno
argument_list|,
name|gcos
operator|->
name|gc_crn
argument_list|)
expr_stmt|;
else|else
name|strcpy
argument_list|(
name|status
operator|.
name|jobno
argument_list|,
name|MAGICCRN
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|strcpy
argument_list|(
name|status
operator|.
name|jobno
argument_list|,
literal|"XYZZ"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|strcpy
argument_list|(
name|status
operator|.
name|dir
argument_list|,
name|pwd
operator|->
name|pw_dir
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|shomedir
argument_list|,
name|pwd
operator|->
name|pw_dir
argument_list|)
expr_stmt|;
comment|/* side effect */
name|u
operator|=
name|pwd
operator|->
name|pw_shell
expr_stmt|;
if|if
condition|(
name|u
index|[
literal|0
index|]
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|u
argument_list|,
literal|"/bin/sbash"
argument_list|)
operator|==
literal|0
condition|)
name|u
operator|=
name|Bsh
expr_stmt|;
name|strcpy
argument_list|(
name|status
operator|.
name|loginshell
argument_list|,
name|u
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* 	promptlogin(mchto)  	ask user for login and passwd on mchto. 	make sure status.localname has a value before calling 	this.  One way is to call passwdent(). */
end_comment

begin_macro
name|promptlogin
argument_list|(
argument|mchto
argument_list|)
end_macro

begin_decl_stmt
name|char
name|mchto
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|,
name|mch
decl_stmt|;
name|FILE
modifier|*
name|wf
decl_stmt|;
name|int
name|c
decl_stmt|;
if|if
condition|(
name|status
operator|.
name|login
index|[
literal|0
index|]
operator|==
literal|0
operator|||
name|status
operator|.
name|force
condition|)
block|{
name|buf
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|wf
operator|=
name|fopen
argument_list|(
literal|"/dev/tty"
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|wf
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Name (%s:%s): "
argument_list|,
name|longname
argument_list|(
name|mchto
argument_list|)
argument_list|,
name|status
operator|.
name|localname
argument_list|)
expr_stmt|;
if|if
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
name|BUFSIZ
argument_list|,
name|wf
argument_list|)
operator|!=
name|buf
condition|)
block|{
name|perror
argument_list|(
literal|"fgets"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_OSERR
argument_list|)
expr_stmt|;
block|}
name|c
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|buf
index|[
name|c
operator|>
literal|0
condition|?
name|c
operator|-
literal|1
else|:
literal|0
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|c
operator|>
literal|10
condition|)
block|{
name|err
argument_list|(
literal|"Login name too long.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_USAGE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|FMemberSCh
argument_list|(
name|buf
argument_list|,
literal|' '
argument_list|)
condition|)
block|{
name|err
argument_list|(
literal|"Login names don't have blanks in them.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_USAGE
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|wf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|0
condition|)
name|strcpy
argument_list|(
name|buf
argument_list|,
name|status
operator|.
name|localname
argument_list|)
expr_stmt|;
name|mch
operator|=
name|MchSFromAddr
argument_list|(
name|status
operator|.
name|login
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|mch
operator|!=
name|local
operator|&&
name|mch
operator|!=
name|mchto
condition|)
block|{
name|err
argument_list|(
literal|"Must specify login name on %s machine\n"
argument_list|,
name|longname
argument_list|(
name|mchto
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_USAGE
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|status
operator|.
name|login
argument_list|,
literal|"network"
argument_list|)
operator|!=
literal|0
operator|&&
operator|(
name|status
operator|.
name|mpasswd
index|[
literal|0
index|]
operator|==
literal|0
operator|||
name|status
operator|.
name|force
operator|)
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"Password (%s:%s):"
argument_list|,
name|longname
argument_list|(
name|mchto
argument_list|)
argument_list|,
name|status
operator|.
name|login
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|status
operator|.
name|mpasswd
argument_list|,
name|getpass
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|.
name|login
index|[
literal|0
index|]
operator|==
literal|0
condition|)
name|strcpy
argument_list|(
name|status
operator|.
name|login
argument_list|,
name|status
operator|.
name|localname
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|.
name|mpasswd
index|[
literal|0
index|]
operator|==
literal|0
condition|)
name|strcpy
argument_list|(
name|status
operator|.
name|mpasswd
argument_list|,
literal|"\"\""
argument_list|)
expr_stmt|;
name|status
operator|.
name|force
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_define
define|#
directive|define
name|tst
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(*mode == 'r'? (b) : (a))
end_define

begin_define
define|#
directive|define
name|RDR
value|0
end_define

begin_define
define|#
directive|define
name|WTR
value|1
end_define

begin_decl_stmt
specifier|static
name|int
name|popen_pid
index|[
literal|20
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* return a file descriptor suitable for writing, send to    user toaddress from fromaddress,   if cautious != 0 then don't do any forwarding   hopcnt is passed thru the mail program. 	  normal value is 0   */
end_comment

begin_function
name|FILE
modifier|*
name|mailopen
parameter_list|(
name|toaddress
parameter_list|,
name|fromaddress
parameter_list|,
name|cautious
parameter_list|,
name|hopcnt
parameter_list|)
name|char
modifier|*
name|toaddress
decl_stmt|,
decl|*
name|fromaddress
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|cautious
decl_stmt|,
name|hopcnt
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|cmd
index|[
literal|100
index|]
decl_stmt|;
name|char
modifier|*
name|mode
init|=
literal|"w"
decl_stmt|;
name|int
name|p
index|[
literal|2
index|]
decl_stmt|;
specifier|register
name|myside
operator|,
name|hisside
operator|,
name|pid
expr_stmt|;
name|char
name|shopcnt
index|[
literal|20
index|]
decl_stmt|;
if|if
condition|(
name|pipe
argument_list|(
name|p
argument_list|)
operator|<
literal|0
condition|)
return|return
name|NULL
return|;
name|myside
operator|=
name|tst
argument_list|(
name|p
index|[
name|WTR
index|]
argument_list|,
name|p
index|[
name|RDR
index|]
argument_list|)
expr_stmt|;
name|hisside
operator|=
name|tst
argument_list|(
name|p
index|[
name|RDR
index|]
argument_list|,
name|p
index|[
name|WTR
index|]
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|pid
operator|=
name|fork
argument_list|()
operator|)
operator|==
operator|-
literal|1
condition|)
name|sleep
argument_list|(
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|pid
operator|==
literal|0
condition|)
block|{
comment|/* myside and hisside reverse roles in child */
name|close
argument_list|(
name|myside
argument_list|)
expr_stmt|;
comment|/* 		dup2(hisside, tst(0, 1)); 		*/
name|close
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|dup
argument_list|(
name|hisside
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|hisside
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|shopcnt
argument_list|,
literal|"%d"
argument_list|,
name|hopcnt
argument_list|)
expr_stmt|;
if|if
condition|(
name|fromaddress
operator|!=
name|NULL
condition|)
block|{
comment|/* by convention, MAILFWD1 may forward this mail 			   and response messages shouldn't be forwarded */
if|if
condition|(
operator|!
name|cautious
operator|&&
operator|!
name|FMemberSCh
argument_list|(
name|toaddress
argument_list|,
literal|'/'
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|SENDMAIL
name|mexecl
argument_list|(
literal|"/usr/lib/sendmail"
argument_list|,
literal|"sendmail"
argument_list|,
literal|"-oee"
argument_list|,
literal|"-r"
argument_list|,
name|fromaddress
argument_list|,
literal|"-h"
argument_list|,
name|shopcnt
argument_list|,
name|toaddress
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|SENDMAIL
name|mexecl
argument_list|(
name|MAILFWD1
argument_list|,
literal|"mail"
argument_list|,
literal|"-r"
argument_list|,
name|fromaddress
argument_list|,
literal|"-h"
argument_list|,
name|shopcnt
argument_list|,
name|toaddress
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|mexecl
argument_list|(
name|SYSMAIL2
argument_list|,
literal|"mail"
argument_list|,
literal|"-d"
argument_list|,
literal|"-r"
argument_list|,
name|fromaddress
argument_list|,
literal|"-h"
argument_list|,
name|shopcnt
argument_list|,
name|toaddress
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|cautious
operator|&&
operator|!
name|FMemberSCh
argument_list|(
name|toaddress
argument_list|,
literal|'/'
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|SENDMAIL
name|mexecl
argument_list|(
literal|"/usr/lib/sendmail"
argument_list|,
literal|"sendmail"
argument_list|,
literal|"-ee"
argument_list|,
literal|"-h"
argument_list|,
name|shopcnt
argument_list|,
name|toaddress
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mexecl
argument_list|(
name|MAILFWD1
argument_list|,
literal|"mail"
argument_list|,
literal|"-h"
argument_list|,
name|shopcnt
argument_list|,
name|toaddress
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|mexecl
argument_list|(
name|SYSMAIL2
argument_list|,
literal|"mail"
argument_list|,
literal|"-d"
argument_list|,
literal|"-h"
argument_list|,
name|shopcnt
argument_list|,
name|toaddress
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|perror
argument_list|(
name|SYSMAIL2
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_UNAVAILABLE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pid
operator|==
operator|-
literal|1
condition|)
return|return
name|NULL
return|;
name|popen_pid
index|[
name|myside
index|]
operator|=
name|pid
expr_stmt|;
name|close
argument_list|(
name|hisside
argument_list|)
expr_stmt|;
return|return
operator|(
name|fdopen
argument_list|(
name|myside
argument_list|,
name|mode
argument_list|)
operator|)
return|;
block|}
end_block

begin_macro
name|mailclose
argument_list|(
argument|ptr
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|ptr
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|f
operator|,
name|r
operator|,
call|(
modifier|*
name|hstat
call|)
argument_list|()
operator|,
call|(
modifier|*
name|istat
call|)
argument_list|()
operator|,
call|(
modifier|*
name|qstat
call|)
argument_list|()
expr_stmt|;
name|int
name|status
decl_stmt|;
name|f
operator|=
name|fileno
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|istat
operator|=
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|qstat
operator|=
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|hstat
operator|=
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|r
operator|=
name|wait
argument_list|(
operator|&
name|status
argument_list|)
operator|)
operator|!=
name|popen_pid
index|[
name|f
index|]
operator|&&
name|r
operator|!=
operator|-
literal|1
condition|)
empty_stmt|;
if|if
condition|(
name|r
operator|==
operator|-
literal|1
condition|)
name|status
operator|=
operator|-
literal|1
expr_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|istat
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|qstat
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|hstat
argument_list|)
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  	ch means 'a'-'z', inx in 0..25 	ch means '0'-'9', inx in 26..35 */
end_comment

begin_macro
name|chtoinx
argument_list|(
argument|ch
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
literal|'a'
operator|<=
name|ch
operator|&&
name|ch
operator|<=
literal|'z'
condition|)
return|return
operator|(
name|ch
operator|-
literal|'a'
operator|)
return|;
if|if
condition|(
literal|'0'
operator|<=
name|ch
operator|&&
name|ch
operator|<=
literal|'9'
condition|)
return|return
operator|(
operator|(
name|ch
operator|-
literal|'0'
operator|)
operator|+
literal|26
operator|)
return|;
name|err
argument_list|(
literal|"bad ch"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  	inx is 0..25 means 'a'-'z' 	inx is 26..35 means '0'-'9' */
end_comment

begin_macro
name|inxtoch
argument_list|(
argument|inx
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
literal|0
operator|<=
name|inx
operator|&&
name|inx
operator|<=
literal|25
condition|)
return|return
operator|(
name|inx
operator|+
literal|'a'
operator|)
return|;
if|if
condition|(
literal|26
operator|<=
name|inx
operator|&&
name|inx
operator|<=
literal|35
condition|)
return|return
operator|(
literal|'0'
operator|+
operator|(
name|inx
operator|-
literal|26
operator|)
operator|)
return|;
name|err
argument_list|(
literal|"bad ch"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* determine through machine */
end_comment

begin_macro
name|gothru
argument_list|(
argument|from
argument_list|,
argument|to
argument_list|)
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
switch|switch
condition|(
name|from
condition|)
block|{
ifdef|#
directive|ifdef
name|RAND
case|case
literal|'a'
case|:
name|i
operator|=
name|configA
index|[
name|chtoinx
argument_list|(
name|to
argument_list|)
index|]
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|i
operator|=
name|configB
index|[
name|chtoinx
argument_list|(
name|to
argument_list|)
index|]
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|i
operator|=
name|configC
index|[
name|chtoinx
argument_list|(
name|to
argument_list|)
index|]
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|NOSC
case|case
literal|'a'
case|:
name|i
operator|=
name|configA
index|[
name|chtoinx
argument_list|(
name|to
argument_list|)
index|]
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|i
operator|=
name|configC
index|[
name|chtoinx
argument_list|(
name|to
argument_list|)
index|]
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
name|i
operator|=
name|configM
index|[
name|chtoinx
argument_list|(
name|to
argument_list|)
index|]
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|BERKELEY
comment|/* for Berkeley */
case|case
literal|'a'
case|:
name|i
operator|=
name|configA
index|[
name|chtoinx
argument_list|(
name|to
argument_list|)
index|]
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|i
operator|=
name|configB
index|[
name|chtoinx
argument_list|(
name|to
argument_list|)
index|]
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|i
operator|=
name|configC
index|[
name|chtoinx
argument_list|(
name|to
argument_list|)
index|]
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|i
operator|=
name|configD
index|[
name|chtoinx
argument_list|(
name|to
argument_list|)
index|]
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|i
operator|=
name|configE
index|[
name|chtoinx
argument_list|(
name|to
argument_list|)
index|]
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|i
operator|=
name|configF
index|[
name|chtoinx
argument_list|(
name|to
argument_list|)
index|]
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
name|i
operator|=
name|configG
index|[
name|chtoinx
argument_list|(
name|to
argument_list|)
index|]
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
name|i
operator|=
name|configH
index|[
name|chtoinx
argument_list|(
name|to
argument_list|)
index|]
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|i
operator|=
name|configI
index|[
name|chtoinx
argument_list|(
name|to
argument_list|)
index|]
expr_stmt|;
break|break;
case|case
literal|'j'
case|:
name|i
operator|=
name|configJ
index|[
name|chtoinx
argument_list|(
name|to
argument_list|)
index|]
expr_stmt|;
break|break;
case|case
literal|'k'
case|:
name|i
operator|=
name|configK
index|[
name|chtoinx
argument_list|(
name|to
argument_list|)
index|]
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|i
operator|=
name|configL
index|[
name|chtoinx
argument_list|(
name|to
argument_list|)
index|]
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
name|i
operator|=
name|configM
index|[
name|chtoinx
argument_list|(
name|to
argument_list|)
index|]
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|i
operator|=
name|configN
index|[
name|chtoinx
argument_list|(
name|to
argument_list|)
index|]
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
name|i
operator|=
name|configO
index|[
name|chtoinx
argument_list|(
name|to
argument_list|)
index|]
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|i
operator|=
name|configP
index|[
name|chtoinx
argument_list|(
name|to
argument_list|)
index|]
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|i
operator|=
name|configR
index|[
name|chtoinx
argument_list|(
name|to
argument_list|)
index|]
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|i
operator|=
name|configS
index|[
name|chtoinx
argument_list|(
name|to
argument_list|)
index|]
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|i
operator|=
name|configT
index|[
name|chtoinx
argument_list|(
name|to
argument_list|)
index|]
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
name|i
operator|=
name|configU
index|[
name|chtoinx
argument_list|(
name|to
argument_list|)
index|]
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|i
operator|=
name|configV
index|[
name|chtoinx
argument_list|(
name|to
argument_list|)
index|]
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|i
operator|=
name|configW
index|[
name|chtoinx
argument_list|(
name|to
argument_list|)
index|]
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|i
operator|=
name|configX
index|[
name|chtoinx
argument_list|(
name|to
argument_list|)
index|]
expr_stmt|;
break|break;
case|case
literal|'y'
case|:
name|i
operator|=
name|configY
index|[
name|chtoinx
argument_list|(
name|to
argument_list|)
index|]
expr_stmt|;
break|break;
case|case
literal|'z'
case|:
name|i
operator|=
name|configZ
index|[
name|chtoinx
argument_list|(
name|to
argument_list|)
index|]
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|i
operator|=
literal|0
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|i
operator|)
return|;
block|}
end_block

begin_define
define|#
directive|define
name|NPARMS
value|20
end_define

begin_comment
comment|/* prints out commands before executing them */
end_comment

begin_comment
comment|/*VARARGS0*/
end_comment

begin_macro
name|mexecl
argument_list|(
argument|va_alist
argument_list|)
end_macro

begin_macro
name|va_dcl
end_macro

begin_block
block|{
name|char
modifier|*
name|arr
index|[
name|NPARMS
index|]
decl_stmt|,
modifier|*
name|file
decl_stmt|,
modifier|*
name|f
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|file
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|f
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|char
operator|*
argument_list|)
condition|)
block|{
if|if
condition|(
name|i
operator|>=
name|NPARMS
condition|)
block|{
name|err
argument_list|(
literal|"too many args"
argument_list|)
expr_stmt|;
name|arr
index|[
name|NPARMS
operator|-
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|debugflg
condition|)
name|err
argument_list|(
literal|"'%s' "
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|arr
index|[
name|i
operator|++
index|]
operator|=
name|f
expr_stmt|;
block|}
name|arr
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
name|debugflg
condition|)
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|execv
argument_list|(
name|file
argument_list|,
name|arr
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* prints out commands before executing them */
end_comment

begin_expr_stmt
name|mexecv
argument_list|(
name|s
argument_list|,
name|p
argument_list|)
specifier|register
name|char
operator|*
name|s
operator|,
operator|*
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|debugflg
condition|)
block|{
name|err
argument_list|(
literal|"'%s' "
argument_list|,
name|s
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|p
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
name|err
argument_list|(
literal|"'%s' "
argument_list|,
name|p
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
name|execv
argument_list|(
name|s
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*VARARGS0*/
end_comment

begin_comment
comment|/* fills in -l - -p from commands like rcp */
end_comment

begin_comment
comment|/* must be called with at least two arguments */
end_comment

begin_macro
name|kexecl
argument_list|(
argument|va_alist
argument_list|)
end_macro

begin_macro
name|va_dcl
end_macro

begin_block
block|{
name|char
modifier|*
name|a
index|[
name|NPARMS
index|]
decl_stmt|,
name|i
init|=
literal|1
decl_stmt|,
modifier|*
name|file
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|file
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
name|a
index|[
literal|0
index|]
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|.
name|login
index|[
literal|0
index|]
condition|)
block|{
name|a
index|[
name|i
operator|++
index|]
operator|=
literal|"-l"
expr_stmt|;
name|a
index|[
name|i
operator|++
index|]
operator|=
name|status
operator|.
name|login
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|.
name|mpasswd
index|[
literal|0
index|]
condition|)
block|{
name|a
index|[
name|i
operator|++
index|]
operator|=
literal|"-p"
expr_stmt|;
name|a
index|[
name|i
operator|++
index|]
operator|=
name|status
operator|.
name|mpasswd
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|.
name|nonotify
condition|)
name|a
index|[
name|i
operator|++
index|]
operator|=
literal|"-b"
expr_stmt|;
if|if
condition|(
name|status
operator|.
name|force
condition|)
name|a
index|[
name|i
operator|++
index|]
operator|=
literal|"-f"
expr_stmt|;
if|if
condition|(
name|status
operator|.
name|quiet
condition|)
name|a
index|[
name|i
operator|++
index|]
operator|=
literal|"-q"
expr_stmt|;
if|if
condition|(
name|status
operator|.
name|nowrite
condition|)
name|a
index|[
name|i
operator|++
index|]
operator|=
literal|"-n"
expr_stmt|;
while|while
condition|(
name|a
index|[
name|i
operator|++
index|]
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|char
operator|*
argument_list|)
condition|)
block|{
if|if
condition|(
name|i
operator|>=
name|NPARMS
condition|)
block|{
name|err
argument_list|(
literal|"too many args"
argument_list|)
expr_stmt|;
name|a
index|[
name|NPARMS
operator|-
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
block|}
empty_stmt|;
name|mexecv
argument_list|(
name|file
argument_list|,
name|a
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* 	MchSFromAddr(sn,addr)  	take an address of the form "mach:username" 	and return mch as the 1 char code of "mach" and 	in sn put "username". 	If addr has no colon in it, return mch==local, sn==addr. 	Return 0 for mch if host unknown. */
end_comment

begin_macro
name|MchSFromAddr
argument_list|(
argument|sn
argument_list|,
argument|addr
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|sn
decl_stmt|,
modifier|*
name|addr
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|fcolon
init|=
literal|0
decl_stmt|,
modifier|*
name|s
decl_stmt|,
name|mch
decl_stmt|,
name|stemp
index|[
name|BUFSIZ
index|]
decl_stmt|;
comment|/* assume addr is a local address */
name|strcpy
argument_list|(
name|stemp
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|s
operator|=
name|stemp
expr_stmt|;
while|while
condition|(
operator|*
name|s
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|':'
condition|)
block|{
name|fcolon
operator|=
literal|1
expr_stmt|;
operator|*
name|s
operator|++
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|s
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|fcolon
operator|!=
literal|1
condition|)
block|{
comment|/* sn better be the right size for addr */
name|mch
operator|=
name|local
expr_stmt|;
name|strcpy
argument_list|(
name|sn
argument_list|,
name|addr
argument_list|)
expr_stmt|;
return|return
operator|(
name|mch
operator|)
return|;
block|}
comment|/* addr has a colon in it, s pts to name */
name|mch
operator|=
name|lookup
argument_list|(
name|stemp
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|sn
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|mch
operator|)
return|;
block|}
end_block

begin_comment
comment|/* returns a single character for machine S */
end_comment

begin_comment
comment|/* returns 0 for unknown host */
end_comment

begin_expr_stmt
name|lookup
argument_list|(
name|s
argument_list|)
specifier|register
name|char
operator|*
name|s
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|tt
modifier|*
name|t
decl_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|s
argument_list|)
operator|==
literal|1
condition|)
return|return
operator|(
name|isupper
argument_list|(
operator|*
name|s
argument_list|)
condition|?
name|tolower
argument_list|(
operator|*
name|s
argument_list|)
else|:
operator|*
name|s
operator|)
return|;
for|for
control|(
name|t
operator|=
name|table
init|;
name|t
operator|->
name|bigname
condition|;
name|t
operator|++
control|)
if|if
condition|(
name|streql
argument_list|(
name|s
argument_list|,
name|t
operator|->
name|bigname
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|t
operator|->
name|lname
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/* returns a long name (string) for single character machine c */
end_comment

begin_function
name|char
modifier|*
name|longname
parameter_list|(
name|c
parameter_list|)
specifier|register
name|char
name|c
decl_stmt|;
block|{
specifier|register
name|struct
name|tt
modifier|*
name|t
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
return|return
operator|(
literal|"UNKNOWN"
operator|)
return|;
for|for
control|(
name|t
operator|=
name|table
init|;
name|t
operator|->
name|bigname
condition|;
name|t
operator|++
control|)
if|if
condition|(
name|c
operator|==
name|t
operator|->
name|lname
condition|)
return|return
operator|(
name|t
operator|->
name|bigname
operator|)
return|;
return|return
operator|(
literal|"UNKNOWN"
operator|)
return|;
block|}
end_function

begin_comment
comment|/* 	FMemberSCh(s,ch)  	return 1 if ch is a character in string s. 	0 otherwise. */
end_comment

begin_expr_stmt
name|FMemberSCh
argument_list|(
name|s
argument_list|,
name|ch
argument_list|)
specifier|register
name|char
operator|*
name|s
operator|,
name|ch
expr_stmt|;
end_expr_stmt

begin_block
block|{
while|while
condition|(
operator|*
name|s
condition|)
if|if
condition|(
operator|*
name|s
operator|++
operator|==
name|ch
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/* return a static string with the form "X hrs X mins X secs" */
end_comment

begin_comment
comment|/* t is # of secs */
end_comment

begin_function
name|char
modifier|*
name|comptime
parameter_list|(
name|t
parameter_list|)
name|long
name|t
decl_stmt|;
block|{
specifier|static
name|char
name|str
index|[
literal|30
index|]
decl_stmt|;
name|char
name|buf
index|[
literal|20
index|]
decl_stmt|;
name|long
name|w
decl_stmt|;
name|str
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|w
operator|=
name|t
operator|/
literal|3600L
expr_stmt|;
if|if
condition|(
name|w
operator|>
literal|0L
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%ld hr "
argument_list|,
name|w
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|str
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
name|t
operator|=
name|t
operator|%
literal|3600L
expr_stmt|;
name|w
operator|=
name|t
operator|/
literal|60L
expr_stmt|;
if|if
condition|(
name|w
operator|>
literal|0L
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%ld min "
argument_list|,
name|w
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|str
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
name|t
operator|=
name|t
operator|%
literal|60L
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%ld sec"
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|str
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|str
operator|)
return|;
block|}
end_function

begin_comment
comment|/* 	parseparmlist(string)  	parses variable parameter lists in string, 	as defined in genparmlist in net.c */
end_comment

begin_macro
name|parseparmlist
argument_list|(
argument|parmlist
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|parmlist
decl_stmt|;
end_decl_stmt

begin_block
block|{
while|while
condition|(
operator|*
name|parmlist
operator|&&
operator|*
name|parmlist
operator|!=
literal|'('
condition|)
name|parmlist
operator|++
expr_stmt|;
block|}
end_block

begin_comment
comment|/* just like strcmp except upper- and lower-case are ignored */
end_comment

begin_macro
name|streql
argument_list|(
argument|s1
argument_list|,
argument|s2
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s1
decl_stmt|,
modifier|*
name|s2
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|a
decl_stmt|,
name|b
decl_stmt|;
while|while
condition|(
operator|*
name|s1
operator|&&
operator|*
name|s2
condition|)
block|{
name|a
operator|=
name|isupper
argument_list|(
operator|*
name|s1
argument_list|)
condition|?
name|tolower
argument_list|(
operator|*
name|s1
argument_list|)
else|:
operator|*
name|s1
expr_stmt|;
name|b
operator|=
name|isupper
argument_list|(
operator|*
name|s2
argument_list|)
condition|?
name|tolower
argument_list|(
operator|*
name|s2
argument_list|)
else|:
operator|*
name|s2
expr_stmt|;
if|if
condition|(
name|a
operator|<
name|b
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|a
operator|>
name|b
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|s1
operator|++
operator|,
name|s2
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|s2
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
operator|*
name|s1
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/* VARARGS0 */
end_comment

begin_macro
name|err
argument_list|(
argument|s
argument_list|,
argument|a
argument_list|,
argument|b
argument_list|,
argument|c
argument_list|,
argument|d
argument_list|,
argument|e
argument_list|,
argument|f
argument_list|,
argument|g
argument_list|,
argument|h
argument_list|,
argument|i
argument_list|,
argument|j
argument_list|,
argument|k
argument_list|,
argument|l
argument_list|,
argument|m
argument_list|,
argument|n
argument_list|,
argument|o
argument_list|,
argument|p
argument_list|,
argument|q
argument_list|,
argument|r
argument_list|)
end_macro

begin_block
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|s
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|,
name|e
argument_list|,
name|f
argument_list|,
name|g
argument_list|,
name|h
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|l
argument_list|,
name|m
argument_list|,
name|n
argument_list|,
name|o
argument_list|,
name|p
argument_list|,
name|q
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

