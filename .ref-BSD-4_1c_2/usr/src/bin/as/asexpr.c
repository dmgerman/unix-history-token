begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *	Copyright (c) 1982 Regents of the University of California  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)asexpr.c 4.3 2/14/82"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|not lint
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|"asscan.h"
end_include

begin_include
include|#
directive|include
file|"asexpr.h"
end_include

begin_comment
comment|/*  * Tables for combination of operands.  */
end_comment

begin_define
define|#
directive|define
name|XTXRN
value|5<<1
end_define

begin_comment
comment|/* indexes last row/column when right shifted */
end_comment

begin_comment
comment|/*  *	table for +  */
end_comment

begin_decl_stmt
name|readonly
name|char
name|pltab
index|[
literal|6
index|]
index|[
literal|6
index|]
init|=
block|{
comment|/*		UND	ABS	TXT	DAT	BSS	EXT */
comment|/*UND*/
name|XUNDEF
block|,
name|XUNDEF
block|,
name|XUNDEF
block|,
name|XUNDEF
block|,
name|XUNDEF
block|,
name|XUNDEF
block|,
comment|/*ABS*/
name|XUNDEF
block|,
name|XABS
block|,
name|XTEXT
block|,
name|XDATA
block|,
name|XBSS
block|,
name|XXTRN
block|,
comment|/*TXT*/
name|XUNDEF
block|,
name|XTEXT
block|,
name|ERR
block|,
name|ERR
block|,
name|ERR
block|,
name|ERR
block|,
comment|/*DAT*/
name|XUNDEF
block|,
name|XDATA
block|,
name|ERR
block|,
name|ERR
block|,
name|ERR
block|,
name|ERR
block|,
comment|/*BSS*/
name|XUNDEF
block|,
name|XBSS
block|,
name|ERR
block|,
name|ERR
block|,
name|ERR
block|,
name|ERR
block|,
comment|/*EXT*/
name|XUNDEF
block|,
name|XXTRN
block|,
name|ERR
block|,
name|ERR
block|,
name|ERR
block|,
name|ERR
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *	table for -  */
end_comment

begin_decl_stmt
name|readonly
name|char
name|mintab
index|[
literal|6
index|]
index|[
literal|6
index|]
init|=
block|{
comment|/*		UND	ABS	TXT	DAT	BSS	EXT */
comment|/*UND*/
name|XUNDEF
block|,
name|XUNDEF
block|,
name|XUNDEF
block|,
name|XUNDEF
block|,
name|XUNDEF
block|,
name|XUNDEF
block|,
comment|/*ABS*/
name|XUNDEF
block|,
name|XABS
block|,
name|ERR
block|,
name|ERR
block|,
name|ERR
block|,
name|ERR
block|,
comment|/*TXT*/
name|XUNDEF
block|,
name|XTEXT
block|,
name|XABS
block|,
name|ERR
block|,
name|ERR
block|,
name|ERR
block|,
comment|/*DAT*/
name|XUNDEF
block|,
name|XDATA
block|,
name|ERR
block|,
name|XABS
block|,
name|ERR
block|,
name|ERR
block|,
comment|/*BSS*/
name|XUNDEF
block|,
name|XBSS
block|,
name|ERR
block|,
name|ERR
block|,
name|XABS
block|,
name|ERR
block|,
comment|/*EXT*/
name|XUNDEF
block|,
name|XXTRN
block|,
name|ERR
block|,
name|ERR
block|,
name|ERR
block|,
name|ERR
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*   *	table for other operators  */
end_comment

begin_decl_stmt
name|readonly
name|char
name|othtab
index|[
literal|6
index|]
index|[
literal|6
index|]
init|=
block|{
comment|/*		UND	ABS	TXT	DAT	BSS	EXT */
comment|/*UND*/
name|XUNDEF
block|,
name|XUNDEF
block|,
name|XUNDEF
block|,
name|XUNDEF
block|,
name|XUNDEF
block|,
name|XUNDEF
block|,
comment|/*ABS*/
name|XUNDEF
block|,
name|XABS
block|,
name|ERR
block|,
name|ERR
block|,
name|ERR
block|,
name|ERR
block|,
comment|/*TXT*/
name|XUNDEF
block|,
name|ERR
block|,
name|ERR
block|,
name|ERR
block|,
name|ERR
block|,
name|ERR
block|,
comment|/*DAT*/
name|XUNDEF
block|,
name|ERR
block|,
name|ERR
block|,
name|ERR
block|,
name|ERR
block|,
name|ERR
block|,
comment|/*BSS*/
name|XUNDEF
block|,
name|ERR
block|,
name|ERR
block|,
name|ERR
block|,
name|ERR
block|,
name|ERR
block|,
comment|/*EXT*/
name|XUNDEF
block|,
name|ERR
block|,
name|ERR
block|,
name|ERR
block|,
name|ERR
block|,
name|ERR
block|, }
decl_stmt|;
end_decl_stmt

begin_function
name|struct
name|exp
modifier|*
name|combine
parameter_list|(
name|op
parameter_list|,
name|exp1
parameter_list|,
name|exp2
parameter_list|)
name|reg
name|struct
name|exp
modifier|*
name|exp1
decl_stmt|,
decl|*
name|exp2
decl_stmt|;
end_function

begin_block
block|{
name|reg
name|e1_type
decl_stmt|,
name|e2_type
decl_stmt|;
name|reg
name|back_type
decl_stmt|;
name|char
modifier|*
name|btype
init|=
literal|"The assembler can only do arithmetic on 1,2, or 4 byte integers"
decl_stmt|;
name|lastnam
operator|=
literal|0
expr_stmt|;
comment|/* kludge for jxxx instructions */
name|e1_type
operator|=
name|exp1
operator|->
name|e_xtype
operator|&
name|XTYPE
expr_stmt|;
name|e2_type
operator|=
name|exp2
operator|->
name|e_xtype
operator|&
name|XTYPE
expr_stmt|;
if|if
condition|(
name|exp1
operator|->
name|e_xtype
operator|==
name|XXTRN
operator|+
name|XUNDEF
condition|)
name|e1_type
operator|=
name|XTXRN
expr_stmt|;
if|if
condition|(
name|exp2
operator|->
name|e_xtype
operator|==
name|XXTRN
operator|+
name|XUNDEF
condition|)
name|e2_type
operator|=
name|XTXRN
expr_stmt|;
if|if
condition|(
name|passno
operator|==
literal|1
condition|)
if|if
condition|(
name|exp1
operator|->
name|e_xloc
operator|!=
name|exp2
operator|->
name|e_xloc
operator|&&
name|e1_type
operator|==
name|e2_type
condition|)
name|e1_type
operator|=
name|e2_type
operator|=
name|XTXRN
expr_stmt|;
comment|/* error on != loc ctrs */
name|e1_type
operator|>>=
literal|1
expr_stmt|;
comment|/*dispose of the external (XXTRN) bit*/
name|e2_type
operator|>>=
literal|1
expr_stmt|;
switch|switch
condition|(
name|exp1
operator|->
name|e_number
operator|.
name|num_tag
condition|)
block|{
case|case
name|TYPB
case|:
case|case
name|TYPW
case|:
case|case
name|TYPL
case|:
break|break;
default|default:
name|yyerror
argument_list|(
name|btype
argument_list|)
expr_stmt|;
return|return
operator|(
name|exp1
operator|)
return|;
block|}
switch|switch
condition|(
name|exp2
operator|->
name|e_number
operator|.
name|num_tag
condition|)
block|{
case|case
name|TYPB
case|:
case|case
name|TYPW
case|:
case|case
name|TYPL
case|:
break|break;
default|default:
name|yyerror
argument_list|(
name|btype
argument_list|)
expr_stmt|;
return|return
operator|(
name|exp1
operator|)
return|;
block|}
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|PLUS
case|:
name|exp1
operator|->
name|e_xvalue
operator|+=
name|exp2
operator|->
name|e_xvalue
expr_stmt|;
name|back_type
operator|=
name|pltab
index|[
name|e1_type
index|]
index|[
name|e2_type
index|]
expr_stmt|;
break|break;
case|case
name|MINUS
case|:
name|exp1
operator|->
name|e_xvalue
operator|-=
name|exp2
operator|->
name|e_xvalue
expr_stmt|;
name|back_type
operator|=
name|mintab
index|[
name|e1_type
index|]
index|[
name|e2_type
index|]
expr_stmt|;
break|break;
case|case
name|IOR
case|:
name|exp1
operator|->
name|e_xvalue
operator||=
name|exp2
operator|->
name|e_xvalue
expr_stmt|;
goto|goto
name|comm
goto|;
case|case
name|XOR
case|:
name|exp1
operator|->
name|e_xvalue
operator|^=
name|exp2
operator|->
name|e_xvalue
expr_stmt|;
goto|goto
name|comm
goto|;
case|case
name|AND
case|:
name|exp1
operator|->
name|e_xvalue
operator|&=
name|exp2
operator|->
name|e_xvalue
expr_stmt|;
goto|goto
name|comm
goto|;
case|case
name|ORNOT
case|:
name|exp1
operator|->
name|e_xvalue
operator||=
operator|~
name|exp2
operator|->
name|e_xvalue
expr_stmt|;
goto|goto
name|comm
goto|;
case|case
name|LSH
case|:
name|exp1
operator|->
name|e_xvalue
operator|<<=
name|exp2
operator|->
name|e_xvalue
expr_stmt|;
goto|goto
name|comm
goto|;
case|case
name|RSH
case|:
name|exp1
operator|->
name|e_xvalue
operator|>>=
name|exp2
operator|->
name|e_xvalue
expr_stmt|;
goto|goto
name|comm
goto|;
case|case
name|TILDE
case|:
name|exp1
operator|->
name|e_xvalue
operator||=
operator|~
name|exp2
operator|->
name|e_xvalue
expr_stmt|;
goto|goto
name|comm
goto|;
case|case
name|MUL
case|:
name|exp1
operator|->
name|e_xvalue
operator|*=
name|exp2
operator|->
name|e_xvalue
expr_stmt|;
goto|goto
name|comm
goto|;
case|case
name|DIV
case|:
if|if
condition|(
name|exp2
operator|->
name|e_xvalue
operator|==
literal|0
condition|)
name|yyerror
argument_list|(
literal|"Divide check"
argument_list|)
expr_stmt|;
else|else
name|exp1
operator|->
name|e_xvalue
operator|/=
name|exp2
operator|->
name|e_xvalue
expr_stmt|;
goto|goto
name|comm
goto|;
case|case
name|REGOP
case|:
if|if
condition|(
name|exp2
operator|->
name|e_xvalue
operator|==
literal|0
condition|)
name|yyerror
argument_list|(
literal|"Divide check (modulo)"
argument_list|)
expr_stmt|;
else|else
name|exp1
operator|->
name|e_xvalue
operator|%=
name|exp2
operator|->
name|e_xvalue
expr_stmt|;
goto|goto
name|comm
goto|;
name|comm
label|:
name|back_type
operator|=
name|othtab
index|[
name|e1_type
index|]
index|[
name|e2_type
index|]
expr_stmt|;
break|break;
default|default:
name|yyerror
argument_list|(
literal|"Internal error: unknown operator"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|e2_type
operator|==
operator|(
name|XTXRN
operator|>>
literal|1
operator|)
condition|)
name|exp1
operator|->
name|e_xname
operator|=
name|exp2
operator|->
name|e_xname
expr_stmt|;
name|exp1
operator|->
name|e_xtype
operator|=
name|back_type
operator||
operator|(
operator|(
name|exp1
operator|->
name|e_xtype
operator||
name|exp2
operator|->
name|e_xtype
operator|)
operator|&
operator|(
name|XFORW
operator||
name|XXTRN
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|back_type
operator|==
name|ERR
condition|)
name|yyerror
argument_list|(
literal|"Relocation error"
argument_list|)
expr_stmt|;
return|return
operator|(
name|exp1
operator|)
return|;
block|}
end_block

begin_macro
name|buildtokensets
argument_list|()
end_macro

begin_block
block|{
define|#
directive|define
name|clobber
parameter_list|(
name|val
parameter_list|,
name|set
parameter_list|)
value|tokensets[(val)] |= (set)
name|clobber
argument_list|(
name|SEMI
argument_list|,
name|LINSTBEGIN
argument_list|)
expr_stmt|;
name|clobber
argument_list|(
name|NL
argument_list|,
name|LINSTBEGIN
argument_list|)
expr_stmt|;
name|clobber
argument_list|(
name|INT
argument_list|,
name|LINSTBEGIN
argument_list|)
expr_stmt|;
name|clobber
argument_list|(
name|NAME
argument_list|,
name|YUKKYEXPRBEG
operator|+
name|LINSTBEGIN
argument_list|)
expr_stmt|;
name|clobber
argument_list|(
name|INSTn
argument_list|,
name|YUKKYEXPRBEG
argument_list|)
expr_stmt|;
name|clobber
argument_list|(
name|INST0
argument_list|,
name|YUKKYEXPRBEG
argument_list|)
expr_stmt|;
name|clobber
argument_list|(
name|REG
argument_list|,
name|YUKKYEXPRBEG
argument_list|)
expr_stmt|;
name|clobber
argument_list|(
name|BFINT
argument_list|,
name|YUKKYEXPRBEG
argument_list|)
expr_stmt|;
name|clobber
argument_list|(
name|INT
argument_list|,
name|SAFEEXPRBEG
argument_list|)
expr_stmt|;
name|clobber
argument_list|(
name|BIGNUM
argument_list|,
name|SAFEEXPRBEG
argument_list|)
expr_stmt|;
name|clobber
argument_list|(
name|PLUS
argument_list|,
name|ADDOPS
argument_list|)
expr_stmt|;
name|clobber
argument_list|(
name|MINUS
argument_list|,
name|ADDOPS
operator|+
name|EBEGOPS
argument_list|)
expr_stmt|;
name|clobber
argument_list|(
name|LP
argument_list|,
name|EBEGOPS
argument_list|)
expr_stmt|;
name|clobber
argument_list|(
name|IOR
argument_list|,
name|BOOLOPS
argument_list|)
expr_stmt|;
name|clobber
argument_list|(
name|XOR
argument_list|,
name|BOOLOPS
argument_list|)
expr_stmt|;
name|clobber
argument_list|(
name|AND
argument_list|,
name|BOOLOPS
argument_list|)
expr_stmt|;
name|clobber
argument_list|(
name|ORNOT
argument_list|,
name|BOOLOPS
argument_list|)
expr_stmt|;
name|clobber
argument_list|(
name|TILDE
argument_list|,
name|MULOPS
operator|+
name|EBEGOPS
argument_list|)
expr_stmt|;
name|clobber
argument_list|(
name|LSH
argument_list|,
name|MULOPS
argument_list|)
expr_stmt|;
name|clobber
argument_list|(
name|RSH
argument_list|,
name|MULOPS
argument_list|)
expr_stmt|;
name|clobber
argument_list|(
name|MUL
argument_list|,
name|MULOPS
argument_list|)
expr_stmt|;
name|clobber
argument_list|(
name|DIV
argument_list|,
name|MULOPS
argument_list|)
expr_stmt|;
name|clobber
argument_list|(
name|REGOP
argument_list|,
name|MULOPS
argument_list|)
expr_stmt|;
comment|/* % */
block|}
end_block

begin_comment
comment|/*  *	We keep the current token class in this global variable, so   *	the recursive descent expression analyzers can talk amongst  *	themselves, and so that we may use the macros shift and shift over  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|yylval
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*the value of the lexical value*/
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|exp
modifier|*
name|xp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*the next free expression slot*/
end_comment

begin_decl_stmt
specifier|static
name|inttoktype
name|val
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *	return the value the read head is sitting on  */
end_comment

begin_function
name|inttoktype
name|exprparse
parameter_list|(
name|inval
parameter_list|,
name|backexpr
parameter_list|)
name|inttoktype
name|inval
decl_stmt|;
name|struct
name|exp
modifier|*
modifier|*
name|backexpr
decl_stmt|;
block|{
name|reg
name|struct
name|exp
modifier|*
name|lexpr
decl_stmt|;
name|inttoktype
name|op
decl_stmt|;
name|val
operator|=
name|inval
expr_stmt|;
name|lexpr
operator|=
name|boolterm
argument_list|()
expr_stmt|;
while|while
condition|(
name|INTOKSET
argument_list|(
name|val
argument_list|,
name|ADDOPS
argument_list|)
condition|)
block|{
name|op
operator|=
name|val
expr_stmt|;
name|shift
expr_stmt|;
name|lexpr
operator|=
name|combine
argument_list|(
name|op
argument_list|,
name|lexpr
argument_list|,
name|boolterm
argument_list|()
argument_list|)
expr_stmt|;
block|}
operator|*
name|backexpr
operator|=
name|lexpr
expr_stmt|;
return|return
operator|(
name|val
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|exp
modifier|*
name|boolterm
parameter_list|()
block|{
name|reg
name|struct
name|exp
modifier|*
name|lexpr
decl_stmt|;
name|inttoktype
name|op
decl_stmt|;
name|lexpr
operator|=
name|term
argument_list|()
expr_stmt|;
while|while
condition|(
name|INTOKSET
argument_list|(
name|val
argument_list|,
name|BOOLOPS
argument_list|)
condition|)
block|{
name|op
operator|=
name|val
expr_stmt|;
name|shift
expr_stmt|;
name|lexpr
operator|=
name|combine
argument_list|(
name|op
argument_list|,
name|lexpr
argument_list|,
name|term
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|lexpr
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|exp
modifier|*
name|term
parameter_list|()
block|{
name|reg
name|struct
name|exp
modifier|*
name|lexpr
decl_stmt|;
name|inttoktype
name|op
decl_stmt|;
name|lexpr
operator|=
name|factor
argument_list|()
expr_stmt|;
while|while
condition|(
name|INTOKSET
argument_list|(
name|val
argument_list|,
name|MULOPS
argument_list|)
condition|)
block|{
name|op
operator|=
name|val
expr_stmt|;
name|shift
expr_stmt|;
name|lexpr
operator|=
name|combine
argument_list|(
name|op
argument_list|,
name|lexpr
argument_list|,
name|factor
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|lexpr
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|exp
modifier|*
name|factor
parameter_list|()
block|{
name|struct
name|exp
modifier|*
name|lexpr
decl_stmt|;
name|inttoktype
name|op
decl_stmt|;
specifier|extern
name|int
name|droppedLP
decl_stmt|;
comment|/*called exprparse after consuming an LP*/
if|if
condition|(
name|val
operator|==
name|LP
operator|||
name|droppedLP
condition|)
block|{
if|if
condition|(
name|droppedLP
condition|)
name|droppedLP
operator|=
literal|0
expr_stmt|;
else|else
name|shift
expr_stmt|;
comment|/*the LP*/
name|val
operator|=
name|exprparse
argument_list|(
name|val
argument_list|,
operator|&
name|lexpr
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
name|RP
condition|)
name|yyerror
argument_list|(
literal|"right parenthesis expected"
argument_list|)
expr_stmt|;
else|else
name|shift
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|INTOKSET
argument_list|(
name|val
argument_list|,
name|YUKKYEXPRBEG
argument_list|)
condition|)
block|{
name|lexpr
operator|=
name|yukkyexpr
argument_list|(
name|val
argument_list|,
name|yylval
argument_list|)
expr_stmt|;
name|shift
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|INTOKSET
argument_list|(
name|val
argument_list|,
name|SAFEEXPRBEG
argument_list|)
condition|)
block|{
name|lexpr
operator|=
operator|(
expr|struct
name|exp
operator|*
operator|)
name|yylval
expr_stmt|;
name|shift
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|val
operator|==
name|TILDE
operator|)
operator|||
operator|(
name|val
operator|==
name|MINUS
operator|)
condition|)
block|{
name|op
operator|=
name|val
expr_stmt|;
name|shift
expr_stmt|;
name|lexpr
operator|=
name|xp
operator|++
expr_stmt|;
name|lexpr
operator|->
name|e_xtype
operator|=
name|XABS
expr_stmt|;
name|lexpr
operator|->
name|e_number
operator|=
name|Znumber
expr_stmt|;
name|lexpr
operator|->
name|e_number
operator|.
name|num_tag
operator|=
name|TYPL
expr_stmt|;
name|lexpr
operator|=
name|combine
argument_list|(
name|op
argument_list|,
name|lexpr
argument_list|,
name|factor
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|yyerror
argument_list|(
literal|"Bad expression syntax"
argument_list|)
expr_stmt|;
name|lexpr
operator|=
name|xp
operator|++
expr_stmt|;
name|lexpr
operator|->
name|e_xtype
operator|=
name|XABS
expr_stmt|;
name|lexpr
operator|->
name|e_number
operator|=
name|Znumber
expr_stmt|;
name|lexpr
operator|->
name|e_number
operator|.
name|num_tag
operator|=
name|TYPL
expr_stmt|;
block|}
return|return
operator|(
name|lexpr
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|exp
modifier|*
name|yukkyexpr
parameter_list|(
name|val
parameter_list|,
name|np
parameter_list|)
name|int
name|val
decl_stmt|;
name|reg
name|np
decl_stmt|;
block|{
name|reg
name|struct
name|exp
modifier|*
name|locxp
decl_stmt|;
specifier|extern
name|int
name|exprisname
decl_stmt|;
comment|/*last factor is a name*/
name|int
name|off
init|=
literal|0
decl_stmt|;
name|exprisname
operator|=
literal|0
expr_stmt|;
name|locxp
operator|=
name|xp
operator|++
expr_stmt|;
name|locxp
operator|->
name|e_number
operator|=
name|Znumber
expr_stmt|;
name|locxp
operator|->
name|e_number
operator|.
name|num_tag
operator|=
name|TYPL
expr_stmt|;
switch|switch
condition|(
name|val
condition|)
block|{
case|case
name|BFINT
case|:
name|yylval
operator|=
operator|(
operator|(
expr|struct
name|exp
operator|*
operator|)
name|np
operator|)
operator|->
name|e_xvalue
expr_stmt|;
if|if
condition|(
name|yylval
operator|<
literal|0
condition|)
block|{
name|yylval
operator|=
operator|-
name|yylval
expr_stmt|;
name|yylval
operator|--
expr_stmt|;
name|off
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|lgensym
index|[
name|yylval
index|]
operator|==
literal|1
condition|)
name|yyerror
argument_list|(
literal|"Reference to undefined local label %db"
argument_list|,
name|yylval
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|yylval
operator|--
expr_stmt|;
name|genref
index|[
name|yylval
index|]
operator|=
literal|1
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|yytext
argument_list|,
literal|"L%d\001%d"
argument_list|,
name|yylval
argument_list|,
name|lgensym
index|[
name|yylval
index|]
operator|+
name|off
argument_list|)
expr_stmt|;
name|yylval
operator|=
name|np
operator|=
operator|(
name|int
operator|)
operator|*
name|lookup
argument_list|(
name|passno
operator|==
literal|1
argument_list|)
expr_stmt|;
name|lastnam
operator|=
operator|(
expr|struct
name|symtab
operator|*
operator|)
name|np
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|NAME
case|:
name|exprisname
operator|++
expr_stmt|;
name|locxp
operator|->
name|e_xtype
operator|=
operator|(
operator|(
expr|struct
name|symtab
operator|*
operator|)
name|np
operator|)
operator|->
name|s_type
expr_stmt|;
if|if
condition|(
operator|(
operator|(
operator|(
expr|struct
name|symtab
operator|*
operator|)
name|np
operator|)
operator|->
name|s_type
operator|&
name|XTYPE
operator|)
operator|==
name|XUNDEF
condition|)
block|{
comment|/*forward*/
name|locxp
operator|->
name|e_xname
operator|=
operator|(
expr|struct
name|symtab
operator|*
operator|)
name|np
expr_stmt|;
name|locxp
operator|->
name|e_xvalue
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|passno
operator|==
literal|1
condition|)
operator|(
operator|(
expr|struct
name|symtab
operator|*
operator|)
name|np
operator|)
operator|->
name|s_type
operator||=
name|XFORW
expr_stmt|;
block|}
else|else
block|{
comment|/*otherwise, just get the value*/
name|locxp
operator|->
name|e_xvalue
operator|=
operator|(
operator|(
expr|struct
name|symtab
operator|*
operator|)
name|np
operator|)
operator|->
name|s_value
expr_stmt|;
name|locxp
operator|->
name|e_xname
operator|=
name|NULL
expr_stmt|;
block|}
break|break;
default|default:
name|yyerror
argument_list|(
literal|"Internal Error in yukkyexpr"
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|INSTn
case|:
case|case
name|INST0
case|:
case|case
name|REG
case|:
name|locxp
operator|->
name|e_xtype
operator|=
name|XABS
expr_stmt|;
name|locxp
operator|->
name|e_xvalue
operator|=
operator|(
operator|(
name|int
operator|)
name|np
operator|)
operator|&
literal|0xFF
expr_stmt|;
name|locxp
operator|->
name|e_xloc
operator|=
literal|0
expr_stmt|;
name|locxp
operator|->
name|e_xname
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|locxp
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_decl_stmt
name|char
modifier|*
name|tok_name
index|[
name|LASTTOKEN
operator|-
name|FIRSTTOKEN
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|Tok_Desc
block|{
name|int
name|tok_which
decl_stmt|;
name|char
modifier|*
name|tok_name
decl_stmt|;
block|}
name|tok_desc
index|[]
init|=
block|{
name|FIRSTTOKEN
block|,
literal|"firsttoken"
block|,
name|ISPACE
block|,
literal|"ispace"
block|,
name|IBYTE
block|,
literal|"ibyte"
block|,
name|IWORD
block|,
literal|"iword"
block|,
name|IINT
block|,
literal|"iint"
block|,
name|ILONG
block|,
literal|"ilong"
block|,
name|IQUAD
block|,
literal|"quad"
block|,
name|IOCTA
block|,
literal|"octa"
block|,
name|IDATA
block|,
literal|"idata"
block|,
name|IGLOBAL
block|,
literal|"iglobal"
block|,
name|ISET
block|,
literal|"iset"
block|,
name|ITEXT
block|,
literal|"itext"
block|,
name|ICOMM
block|,
literal|"icomm"
block|,
name|ILCOMM
block|,
literal|"ilcomm"
block|,
name|IFFLOAT
block|,
literal|"iffloat"
block|,
name|IDFLOAT
block|,
literal|"idfloat"
block|,
name|IGFLOAT
block|,
literal|"igfloat"
block|,
name|IHFLOAT
block|,
literal|"ihfloat"
block|,
name|IORG
block|,
literal|"iorg"
block|,
name|IASCII
block|,
literal|"iascii"
block|,
name|IASCIZ
block|,
literal|"iasciz"
block|,
name|ILSYM
block|,
literal|"ilsym"
block|,
name|IFILE
block|,
literal|"ifile"
block|,
name|ILINENO
block|,
literal|"ilineno"
block|,
name|IABORT
block|,
literal|"iabort"
block|,
name|ISTAB
block|,
literal|"istab"
block|,
name|ISTABSTR
block|,
literal|"istabstr"
block|,
name|ISTABNONE
block|,
literal|"istabnone"
block|,
name|ISTABDOT
block|,
literal|"istabdot"
block|,
name|IJXXX
block|,
literal|"ijxxx"
block|,
name|IALIGN
block|,
literal|"ialign"
block|,
name|INST0
block|,
literal|"inst0"
block|,
name|INSTn
block|,
literal|"instn"
block|,
name|BFINT
block|,
literal|"bfint"
block|,
name|PARSEEOF
block|,
literal|"parseeof"
block|,
name|ILINESKIP
block|,
literal|"ilineskip"
block|,
name|VOID
block|,
literal|"void"
block|,
name|SKIP
block|,
literal|"skip"
block|,
name|INT
block|,
literal|"int"
block|,
name|BIGNUM
block|,
literal|"bignum"
block|,
name|NAME
block|,
literal|"name"
block|,
name|STRING
block|,
literal|"string"
block|,
name|SIZESPEC
block|,
literal|"sizespec"
block|,
name|REG
block|,
literal|"reg"
block|,
name|MUL
block|,
literal|"mul"
block|,
name|LITOP
block|,
literal|"litop"
block|,
name|LP
block|,
literal|"lp"
block|,
name|MP
block|,
literal|"mp"
block|,
name|NEEDSBUF
block|,
literal|"needsbuf"
block|,
name|REGOP
block|,
literal|"regop"
block|,
name|NL
block|,
literal|"nl"
block|,
name|SCANEOF
block|,
literal|"scaneof"
block|,
name|BADCHAR
block|,
literal|"badchar"
block|,
name|SP
block|,
literal|"sp"
block|,
name|ALPH
block|,
literal|"alph"
block|,
name|DIG
block|,
literal|"dig"
block|,
name|SQ
block|,
literal|"sq"
block|,
name|DQ
block|,
literal|"dq"
block|,
name|SH
block|,
literal|"sh"
block|,
name|LSH
block|,
literal|"lsh"
block|,
name|RSH
block|,
literal|"rsh"
block|,
name|MINUS
block|,
literal|"minus"
block|,
name|SIZEQUOTE
block|,
literal|"sizequote"
block|,
name|XOR
block|,
literal|"xor"
block|,
name|DIV
block|,
literal|"div"
block|,
name|SEMI
block|,
literal|"semi"
block|,
name|COLON
block|,
literal|"colon"
block|,
name|PLUS
block|,
literal|"plus"
block|,
name|IOR
block|,
literal|"ior"
block|,
name|AND
block|,
literal|"and"
block|,
name|TILDE
block|,
literal|"tilde"
block|,
name|ORNOT
block|,
literal|"ornot"
block|,
name|CM
block|,
literal|"cm"
block|,
name|LB
block|,
literal|"lb"
block|,
name|RB
block|,
literal|"rb"
block|,
name|RP
block|,
literal|"rp"
block|,
name|LASTTOKEN
block|,
literal|"lasttoken"
block|}
struct|;
end_struct

begin_comment
comment|/*  *	turn a token type into a string  */
end_comment

begin_function
name|char
modifier|*
name|tok_to_name
parameter_list|(
name|token
parameter_list|)
block|{
specifier|static
name|int
name|fixed
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|fixed
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|FIRSTTOKEN
init|;
name|i
operator|<=
name|LASTTOKEN
condition|;
name|i
operator|++
control|)
name|tok_name
index|[
name|i
index|]
operator|=
literal|"NOT ASSIGNED"
expr_stmt|;
for|for
control|(
name|i
operator|=
name|FIRSTTOKEN
init|;
name|i
operator|<=
sizeof|sizeof
argument_list|(
name|tok_desc
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|Tok_Desc
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|tok_name
index|[
name|tok_desc
index|[
name|i
index|]
operator|.
name|tok_which
index|]
operator|=
name|tok_desc
index|[
name|i
index|]
operator|.
name|tok_name
expr_stmt|;
block|}
name|fixed
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|FIRSTTOKEN
operator|<=
name|token
operator|&&
name|token
operator|<=
name|LASTTOKEN
condition|)
return|return
operator|(
name|tok_name
index|[
name|token
index|]
operator|)
return|;
else|else
name|panic
argument_list|(
literal|"Unknown token number, %d\n"
argument_list|,
name|token
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
end_function

begin_endif
endif|#
directive|endif
endif|DEBUG
end_endif

end_unit

