begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * /src/NTP/ntp4-dev/libparse/parsesolaris.c,v 4.11 2005/04/16 17:32:10 kardel RELEASE_20050508_A  *    * parsesolaris.c,v 4.11 2005/04/16 17:32:10 kardel RELEASE_20050508_A  *  * STREAMS module for reference clocks  *  * Copyright (c) 1995-2005 by Frank Kardel<kardel<AT> ntp.org>  * Copyright (c) 1989-1994 by Frank Kardel, Friedrich-Alexander Universität Erlangen-Nürnberg, Germany  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of the author nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  */
end_comment

begin_define
define|#
directive|define
name|_KERNEL
end_define

begin_comment
comment|/* it is a _KERNEL module */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"parsesolaris.c,v 4.11 2005/04/16 17:32:10 kardel RELEASE_20050508_A"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/termios.h>
end_include

begin_include
include|#
directive|include
file|<sys/stream.h>
end_include

begin_include
include|#
directive|include
file|<sys/strtty.h>
end_include

begin_include
include|#
directive|include
file|<sys/stropts.h>
end_include

begin_include
include|#
directive|include
file|<sys/modctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/ddi.h>
end_include

begin_include
include|#
directive|include
file|<sys/sunddi.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__GNUC__
end_ifdef

begin_comment
comment|/* makes it compile on Solaris 2.6 - acc doesn't like it -- GREAT! */
end_comment

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"ntp_fp.h"
end_include

begin_include
include|#
directive|include
file|"parse.h"
end_include

begin_include
include|#
directive|include
file|<sys/parsestreams.h>
end_include

begin_comment
comment|/*--------------- loadable driver section -----------------------------*/
end_comment

begin_decl_stmt
specifier|static
name|struct
name|streamtab
name|parseinfo
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|fmodsw
name|fmod_templ
init|=
block|{
literal|"parse"
block|,
comment|/* module name */
operator|&
name|parseinfo
block|,
comment|/* module information */
name|D_NEW
operator||
name|D_MP
operator||
name|D_MTQPAIR
block|,
comment|/* exclusive for q pair */
comment|/* lock ptr */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|mod_ops
name|mod_strmodops
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|modlstrmod
name|modlstrmod
init|=
block|{
operator|&
name|mod_strmodops
block|,
comment|/* a STREAMS module */
literal|"PARSE      - NTP reference"
block|,
comment|/* name this baby - keep room for revision number */
operator|&
name|fmod_templ
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|modlinkage
name|modlinkage
init|=
block|{
name|MODREV_1
block|,
block|{
operator|&
name|modlstrmod
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * module management routines  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|int
name|_init
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|char
name|revision
index|[]
init|=
literal|"4.6"
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|S
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|;
ifndef|#
directive|ifndef
name|lint
name|t
operator|=
name|rcsid
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * copy RCS revision into Drv_name 	 * 	 * are we forcing RCS here to do things it was not built for ? 	 */
name|s
operator|=
name|revision
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'$'
condition|)
block|{
comment|/* 		 * skip "$Revision: " 		 * if present. - not necessary on a -kv co (cvs export) 		 */
while|while
condition|(
operator|*
name|s
operator|&&
operator|(
operator|*
name|s
operator|!=
literal|' '
operator|)
condition|)
block|{
name|s
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|s
operator|==
literal|' '
condition|)
name|s
operator|++
expr_stmt|;
block|}
name|t
operator|=
name|modlstrmod
operator|.
name|strmod_linkinfo
expr_stmt|;
while|while
condition|(
operator|*
name|t
operator|&&
operator|(
operator|*
name|t
operator|!=
literal|' '
operator|)
condition|)
block|{
name|t
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|t
operator|==
literal|' '
condition|)
name|t
operator|++
expr_stmt|;
name|S
operator|=
name|s
expr_stmt|;
while|while
condition|(
operator|*
name|S
operator|&&
operator|(
operator|(
operator|(
operator|*
name|S
operator|>=
literal|'0'
operator|)
operator|&&
operator|(
operator|*
name|S
operator|<=
literal|'9'
operator|)
operator|)
operator|||
operator|(
operator|*
name|S
operator|==
literal|'.'
operator|)
operator|)
condition|)
block|{
name|S
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|s
operator|&&
operator|*
name|t
operator|&&
operator|(
name|S
operator|>
name|s
operator|)
condition|)
block|{
if|if
condition|(
name|strlen
argument_list|(
name|t
argument_list|)
operator|>=
operator|(
name|S
operator|-
name|s
operator|)
condition|)
block|{
name|strlcpy
argument_list|(
name|t
argument_list|,
name|s
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
name|S
operator|-
name|s
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|mod_install
argument_list|(
operator|&
name|modlinkage
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|int
name|_info
parameter_list|(
name|struct
name|modinfo
modifier|*
name|modinfop
parameter_list|)
block|{
return|return
operator|(
name|mod_info
argument_list|(
operator|&
name|modlinkage
argument_list|,
name|modinfop
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|int
name|_fini
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|mod_remove
argument_list|(
operator|&
name|modlinkage
argument_list|)
operator|!=
name|DDI_SUCCESS
condition|)
block|{
return|return
name|EBUSY
return|;
block|}
else|else
return|return
name|DDI_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/*--------------- stream module definition ----------------------------*/
end_comment

begin_function_decl
specifier|static
name|int
name|parseopen
parameter_list|(
name|queue_t
modifier|*
parameter_list|,
name|dev_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|cred_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|parseclose
parameter_list|(
name|queue_t
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|parsewput
parameter_list|(
name|queue_t
modifier|*
parameter_list|,
name|mblk_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|parserput
parameter_list|(
name|queue_t
modifier|*
parameter_list|,
name|mblk_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|parsersvc
parameter_list|(
name|queue_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|module_info
name|driverinfo
init|=
block|{
literal|0
block|,
comment|/* module ID number */
name|fmod_templ
operator|.
name|f_name
block|,
comment|/* module name - why repeated here ? compat ?*/
literal|0
block|,
comment|/* minimum accepted packet size */
name|INFPSZ
block|,
comment|/* maximum accepted packet size */
literal|1
block|,
comment|/* high water mark - flow control */
literal|0
comment|/* low water mark - flow control */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|qinit
name|rinit
init|=
comment|/* read queue definition */
block|{
name|parserput
block|,
comment|/* put procedure */
name|parsersvc
block|,
comment|/* service procedure */
name|parseopen
block|,
comment|/* open procedure */
name|parseclose
block|,
comment|/* close procedure */
name|NULL
block|,
comment|/* admin procedure - NOT USED FOR NOW */
operator|&
name|driverinfo
block|,
comment|/* information structure */
name|NULL
comment|/* statistics */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|qinit
name|winit
init|=
comment|/* write queue definition */
block|{
name|parsewput
block|,
comment|/* put procedure */
name|NULL
block|,
comment|/* service procedure */
name|NULL
block|,
comment|/* open procedure */
name|NULL
block|,
comment|/* close procedure */
name|NULL
block|,
comment|/* admin procedure - NOT USED FOR NOW */
operator|&
name|driverinfo
block|,
comment|/* information structure */
name|NULL
comment|/* statistics */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|streamtab
name|parseinfo
init|=
comment|/* stream info element for parse driver */
block|{
operator|&
name|rinit
block|,
comment|/* read queue */
operator|&
name|winit
block|,
comment|/* write queue */
name|NULL
block|,
comment|/* read mux */
name|NULL
comment|/* write mux */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*--------------- driver data structures ----------------------------*/
end_comment

begin_comment
comment|/*  * we usually have an inverted signal - but you  * can change this to suit your needs  */
end_comment

begin_decl_stmt
name|int
name|cd_invert
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* invert status of CD line - PPS support via CD input */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|PARSEDEBUG
end_ifdef

begin_decl_stmt
name|int
name|parsedebug
init|=
operator|~
literal|0
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|int
name|parsedebug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*--------------- module implementation -----------------------------*/
end_comment

begin_define
define|#
directive|define
name|TIMEVAL_USADD
parameter_list|(
name|_X_
parameter_list|,
name|_US_
parameter_list|)
value|do {\ 	(_X_)->tv_usec += (_US_);\ 	if ((_X_)->tv_usec>= 1000000)\ 	{\ 	    (_X_)->tv_sec++;\ 	    (_X_)->tv_usec -= 1000000;\ 	}\      } while (0)
end_define

begin_function_decl
specifier|static
name|int
name|init_linemon
parameter_list|(
name|queue_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|close_linemon
parameter_list|(
name|queue_t
modifier|*
parameter_list|,
name|queue_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|M_PARSE
value|0x0001
end_define

begin_define
define|#
directive|define
name|M_NOPARSE
value|0x0002
end_define

begin_function
name|void
name|ntp_memset
parameter_list|(
name|char
modifier|*
name|a
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|c
parameter_list|)
block|{
while|while
condition|(
name|c
operator|--
operator|>
literal|0
condition|)
operator|*
name|a
operator|++
operator|=
name|x
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|pprintf
parameter_list|(
name|int
name|lev
parameter_list|,
name|char
modifier|*
name|form
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|form
argument_list|)
expr_stmt|;
if|if
condition|(
name|lev
operator|&
name|parsedebug
condition|)
name|vcmn_err
argument_list|(
name|CE_CONT
argument_list|,
name|form
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|setup_stream
parameter_list|(
name|queue_t
modifier|*
name|q
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
specifier|register
name|mblk_t
modifier|*
name|mp
decl_stmt|;
name|pprintf
argument_list|(
name|DD_OPEN
argument_list|,
literal|"parse: SETUP_STREAM - setting up stream for q=%x\n"
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|mp
operator|=
name|allocb
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|stroptions
argument_list|)
argument_list|,
name|BPRI_MED
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
condition|)
block|{
name|struct
name|stroptions
modifier|*
name|str
init|=
operator|(
name|void
operator|*
operator|)
name|mp
operator|->
name|b_wptr
decl_stmt|;
name|str
operator|->
name|so_flags
operator|=
name|SO_READOPT
operator||
name|SO_HIWAT
operator||
name|SO_LOWAT
operator||
name|SO_ISNTTY
expr_stmt|;
name|str
operator|->
name|so_readopt
operator|=
operator|(
name|mode
operator|==
name|M_PARSE
operator|)
condition|?
name|RMSGD
else|:
name|RNORM
expr_stmt|;
name|str
operator|->
name|so_hiwat
operator|=
operator|(
name|mode
operator|==
name|M_PARSE
operator|)
condition|?
sizeof|sizeof
argument_list|(
name|parsetime_t
argument_list|)
else|:
literal|256
expr_stmt|;
name|str
operator|->
name|so_lowat
operator|=
literal|0
expr_stmt|;
name|mp
operator|->
name|b_datap
operator|->
name|db_type
operator|=
name|M_SETOPTS
expr_stmt|;
name|mp
operator|->
name|b_wptr
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|stroptions
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|q
condition|)
name|panic
argument_list|(
literal|"NULL q - strange"
argument_list|)
expr_stmt|;
name|putnext
argument_list|(
name|q
argument_list|,
name|mp
argument_list|)
expr_stmt|;
return|return
name|putctl1
argument_list|(
name|WR
argument_list|(
name|q
argument_list|)
operator|->
name|q_next
argument_list|,
name|M_CTL
argument_list|,
operator|(
name|mode
operator|==
name|M_PARSE
operator|)
condition|?
name|MC_SERVICEIMM
else|:
name|MC_SERVICEDEF
argument_list|)
return|;
block|}
else|else
block|{
name|pprintf
argument_list|(
name|DD_OPEN
argument_list|,
literal|"parse: setup_stream - FAILED - no MEMORY for allocb\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|parseopen
parameter_list|(
name|queue_t
modifier|*
name|q
parameter_list|,
name|dev_t
modifier|*
name|dev
parameter_list|,
name|int
name|flag
parameter_list|,
name|int
name|sflag
parameter_list|,
name|cred_t
modifier|*
name|credp
parameter_list|)
block|{
specifier|register
name|parsestream_t
modifier|*
name|parse
decl_stmt|;
specifier|static
name|int
name|notice
init|=
literal|0
decl_stmt|;
name|pprintf
argument_list|(
name|DD_OPEN
argument_list|,
literal|"parse: OPEN - q=%x\n"
argument_list|,
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
name|sflag
operator|!=
name|MODOPEN
condition|)
block|{
comment|/* open only for modules */
name|pprintf
argument_list|(
name|DD_OPEN
argument_list|,
literal|"parse: OPEN - FAILED - not MODOPEN\n"
argument_list|)
expr_stmt|;
return|return
name|EIO
return|;
block|}
if|if
condition|(
name|q
operator|->
name|q_ptr
operator|!=
operator|(
name|caddr_t
operator|)
name|NULL
condition|)
block|{
name|pprintf
argument_list|(
name|DD_OPEN
argument_list|,
literal|"parse: OPEN - FAILED - EXCLUSIVE ONLY\n"
argument_list|)
expr_stmt|;
return|return
name|EBUSY
return|;
block|}
name|q
operator|->
name|q_ptr
operator|=
operator|(
name|caddr_t
operator|)
name|kmem_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|parsestream_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|q_ptr
operator|==
operator|(
name|caddr_t
operator|)
literal|0
condition|)
block|{
return|return
name|ENOMEM
return|;
block|}
name|pprintf
argument_list|(
name|DD_OPEN
argument_list|,
literal|"parse: OPEN - parse area q=%x, q->q_ptr=%x\n"
argument_list|,
name|q
argument_list|,
name|q
operator|->
name|q_ptr
argument_list|)
expr_stmt|;
name|WR
argument_list|(
name|q
argument_list|)
operator|->
name|q_ptr
operator|=
name|q
operator|->
name|q_ptr
expr_stmt|;
name|pprintf
argument_list|(
name|DD_OPEN
argument_list|,
literal|"parse: OPEN - WQ parse area q=%x, q->q_ptr=%x\n"
argument_list|,
name|WR
argument_list|(
name|q
argument_list|)
argument_list|,
name|WR
argument_list|(
name|q
argument_list|)
operator|->
name|q_ptr
argument_list|)
expr_stmt|;
name|parse
operator|=
operator|(
name|parsestream_t
operator|*
operator|)
name|q
operator|->
name|q_ptr
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|parse
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|parse
argument_list|)
argument_list|)
expr_stmt|;
name|parse
operator|->
name|parse_queue
operator|=
name|q
expr_stmt|;
name|parse
operator|->
name|parse_status
operator|=
name|PARSE_ENABLE
expr_stmt|;
name|parse
operator|->
name|parse_ppsclockev
operator|.
name|tv
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|parse
operator|->
name|parse_ppsclockev
operator|.
name|tv
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|parse
operator|->
name|parse_ppsclockev
operator|.
name|serial
operator|=
literal|0
expr_stmt|;
name|qprocson
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|pprintf
argument_list|(
name|DD_OPEN
argument_list|,
literal|"parse: OPEN - initializing io subsystem q=%x\n"
argument_list|,
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|parse_ioinit
argument_list|(
operator|&
name|parse
operator|->
name|parse_io
argument_list|)
condition|)
block|{
comment|/* 		 * ok guys - beat it 		 */
name|qprocsoff
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
operator|(
name|caddr_t
operator|)
name|parse
argument_list|,
sizeof|sizeof
argument_list|(
name|parsestream_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|EIO
return|;
block|}
name|pprintf
argument_list|(
name|DD_OPEN
argument_list|,
literal|"parse: OPEN - initializing stream q=%x\n"
argument_list|,
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
name|setup_stream
argument_list|(
name|q
argument_list|,
name|M_PARSE
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|init_linemon
argument_list|(
name|q
argument_list|)
expr_stmt|;
comment|/* hook up PPS ISR routines if possible */
name|pprintf
argument_list|(
name|DD_OPEN
argument_list|,
literal|"parse: OPEN - SUCCEEDED\n"
argument_list|)
expr_stmt|;
comment|/* 		 * I know that you know the delete key, but you didn't write this 		 * code, did you ? - So, keep the message in here. 		 */
if|if
condition|(
operator|!
name|notice
condition|)
block|{
name|cmn_err
argument_list|(
name|CE_CONT
argument_list|,
literal|"?%s: Copyright (c) 1993-2005, Frank Kardel\n"
argument_list|,
name|modlstrmod
operator|.
name|strmod_linkinfo
argument_list|)
expr_stmt|;
name|notice
operator|=
literal|1
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
else|else
block|{
name|qprocsoff
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
operator|(
name|caddr_t
operator|)
name|parse
argument_list|,
sizeof|sizeof
argument_list|(
name|parsestream_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|EIO
return|;
block|}
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|parseclose
parameter_list|(
name|queue_t
modifier|*
name|q
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
specifier|register
name|parsestream_t
modifier|*
name|parse
init|=
operator|(
name|parsestream_t
operator|*
operator|)
name|q
operator|->
name|q_ptr
decl_stmt|;
specifier|register
name|unsigned
name|long
name|s
decl_stmt|;
name|pprintf
argument_list|(
name|DD_CLOSE
argument_list|,
literal|"parse: CLOSE\n"
argument_list|)
expr_stmt|;
name|qprocsoff
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
if|if
condition|(
name|parse
operator|->
name|parse_dqueue
condition|)
name|close_linemon
argument_list|(
name|parse
operator|->
name|parse_dqueue
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|parse
operator|->
name|parse_dqueue
operator|=
operator|(
name|queue_t
operator|*
operator|)
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|parse_ioend
argument_list|(
operator|&
name|parse
operator|->
name|parse_io
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
operator|(
name|caddr_t
operator|)
name|parse
argument_list|,
sizeof|sizeof
argument_list|(
name|parsestream_t
argument_list|)
argument_list|)
expr_stmt|;
name|q
operator|->
name|q_ptr
operator|=
operator|(
name|caddr_t
operator|)
name|NULL
expr_stmt|;
name|WR
argument_list|(
name|q
argument_list|)
operator|->
name|q_ptr
operator|=
operator|(
name|caddr_t
operator|)
name|NULL
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * move unrecognized stuff upward  */
end_comment

begin_function
specifier|static
name|int
name|parsersvc
parameter_list|(
name|queue_t
modifier|*
name|q
parameter_list|)
block|{
name|mblk_t
modifier|*
name|mp
decl_stmt|;
while|while
condition|(
operator|(
name|mp
operator|=
name|getq
argument_list|(
name|q
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|canputnext
argument_list|(
name|q
argument_list|)
operator|||
operator|(
name|mp
operator|->
name|b_datap
operator|->
name|db_type
operator|>
name|QPCTL
operator|)
condition|)
block|{
name|putnext
argument_list|(
name|q
argument_list|,
name|mp
argument_list|)
expr_stmt|;
name|pprintf
argument_list|(
name|DD_RSVC
argument_list|,
literal|"parse: RSVC - putnext\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|putbq
argument_list|(
name|q
argument_list|,
name|mp
argument_list|)
expr_stmt|;
name|pprintf
argument_list|(
name|DD_RSVC
argument_list|,
literal|"parse: RSVC - flow control wait\n"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * do ioctls and  * send stuff down - dont care about  * flow control  */
end_comment

begin_function
specifier|static
name|int
name|parsewput
parameter_list|(
name|queue_t
modifier|*
name|q
parameter_list|,
name|mblk_t
modifier|*
name|mp
parameter_list|)
block|{
specifier|register
name|int
name|ok
init|=
literal|1
decl_stmt|;
specifier|register
name|mblk_t
modifier|*
name|datap
decl_stmt|;
specifier|register
name|struct
name|iocblk
modifier|*
name|iocp
decl_stmt|;
name|parsestream_t
modifier|*
name|parse
init|=
operator|(
name|parsestream_t
operator|*
operator|)
name|q
operator|->
name|q_ptr
decl_stmt|;
name|pprintf
argument_list|(
name|DD_WPUT
argument_list|,
literal|"parse: parsewput\n"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|mp
operator|->
name|b_datap
operator|->
name|db_type
condition|)
block|{
default|default:
name|putnext
argument_list|(
name|q
argument_list|,
name|mp
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_IOCTL
case|:
name|iocp
operator|=
operator|(
name|void
operator|*
operator|)
name|mp
operator|->
name|b_rptr
expr_stmt|;
switch|switch
condition|(
name|iocp
operator|->
name|ioc_cmd
condition|)
block|{
default|default:
name|pprintf
argument_list|(
name|DD_WPUT
argument_list|,
literal|"parse: parsewput - forward M_IOCTL\n"
argument_list|)
expr_stmt|;
name|putnext
argument_list|(
name|q
argument_list|,
name|mp
argument_list|)
expr_stmt|;
break|break;
case|case
name|CIOGETEV
case|:
comment|/* 			 * taken from Craig Leres ppsclock module (and modified) 			 */
name|datap
operator|=
name|allocb
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ppsclockev
argument_list|)
argument_list|,
name|BPRI_MED
argument_list|)
expr_stmt|;
if|if
condition|(
name|datap
operator|==
name|NULL
operator|||
name|mp
operator|->
name|b_cont
condition|)
block|{
name|mp
operator|->
name|b_datap
operator|->
name|db_type
operator|=
name|M_IOCNAK
expr_stmt|;
name|iocp
operator|->
name|ioc_error
operator|=
operator|(
name|datap
operator|==
name|NULL
operator|)
condition|?
name|ENOMEM
else|:
name|EINVAL
expr_stmt|;
if|if
condition|(
name|datap
operator|!=
name|NULL
condition|)
name|freeb
argument_list|(
name|datap
argument_list|)
expr_stmt|;
name|qreply
argument_list|(
name|q
argument_list|,
name|mp
argument_list|)
expr_stmt|;
break|break;
block|}
name|mp
operator|->
name|b_cont
operator|=
name|datap
expr_stmt|;
comment|/* (void *) quiets cast alignment warning */
operator|*
operator|(
expr|struct
name|ppsclockev
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
name|datap
operator|->
name|b_wptr
operator|=
name|parse
operator|->
name|parse_ppsclockev
expr_stmt|;
name|datap
operator|->
name|b_wptr
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|ppsclockev
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|datap
operator|->
name|b_wptr
argument_list|)
expr_stmt|;
name|mp
operator|->
name|b_datap
operator|->
name|db_type
operator|=
name|M_IOCACK
expr_stmt|;
name|iocp
operator|->
name|ioc_count
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ppsclockev
argument_list|)
expr_stmt|;
name|qreply
argument_list|(
name|q
argument_list|,
name|mp
argument_list|)
expr_stmt|;
break|break;
case|case
name|PARSEIOC_ENABLE
case|:
case|case
name|PARSEIOC_DISABLE
case|:
block|{
name|parse
operator|->
name|parse_status
operator|=
operator|(
name|parse
operator|->
name|parse_status
operator|&
operator|(
name|unsigned
operator|)
operator|~
name|PARSE_ENABLE
operator|)
operator||
operator|(
name|iocp
operator|->
name|ioc_cmd
operator|==
name|PARSEIOC_ENABLE
operator|)
condition|?
name|PARSE_ENABLE
else|:
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|setup_stream
argument_list|(
name|RD
argument_list|(
name|q
argument_list|)
argument_list|,
operator|(
name|parse
operator|->
name|parse_status
operator|&
name|PARSE_ENABLE
operator|)
condition|?
name|M_PARSE
else|:
name|M_NOPARSE
argument_list|)
condition|)
block|{
name|mp
operator|->
name|b_datap
operator|->
name|db_type
operator|=
name|M_IOCNAK
expr_stmt|;
block|}
else|else
block|{
name|mp
operator|->
name|b_datap
operator|->
name|db_type
operator|=
name|M_IOCACK
expr_stmt|;
block|}
name|qreply
argument_list|(
name|q
argument_list|,
name|mp
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|PARSEIOC_TIMECODE
case|:
case|case
name|PARSEIOC_SETFMT
case|:
case|case
name|PARSEIOC_GETFMT
case|:
case|case
name|PARSEIOC_SETCS
case|:
if|if
condition|(
name|iocp
operator|->
name|ioc_count
operator|==
sizeof|sizeof
argument_list|(
name|parsectl_t
argument_list|)
condition|)
block|{
name|parsectl_t
modifier|*
name|dct
init|=
operator|(
name|void
operator|*
operator|)
name|mp
operator|->
name|b_cont
operator|->
name|b_rptr
decl_stmt|;
switch|switch
condition|(
name|iocp
operator|->
name|ioc_cmd
condition|)
block|{
case|case
name|PARSEIOC_TIMECODE
case|:
name|pprintf
argument_list|(
name|DD_WPUT
argument_list|,
literal|"parse: parsewput - PARSEIOC_TIMECODE\n"
argument_list|)
expr_stmt|;
name|ok
operator|=
name|parse_timecode
argument_list|(
name|dct
argument_list|,
operator|&
name|parse
operator|->
name|parse_io
argument_list|)
expr_stmt|;
break|break;
case|case
name|PARSEIOC_SETFMT
case|:
name|pprintf
argument_list|(
name|DD_WPUT
argument_list|,
literal|"parse: parsewput - PARSEIOC_SETFMT\n"
argument_list|)
expr_stmt|;
name|ok
operator|=
name|parse_setfmt
argument_list|(
name|dct
argument_list|,
operator|&
name|parse
operator|->
name|parse_io
argument_list|)
expr_stmt|;
break|break;
case|case
name|PARSEIOC_GETFMT
case|:
name|pprintf
argument_list|(
name|DD_WPUT
argument_list|,
literal|"parse: parsewput - PARSEIOC_GETFMT\n"
argument_list|)
expr_stmt|;
name|ok
operator|=
name|parse_getfmt
argument_list|(
name|dct
argument_list|,
operator|&
name|parse
operator|->
name|parse_io
argument_list|)
expr_stmt|;
break|break;
case|case
name|PARSEIOC_SETCS
case|:
name|pprintf
argument_list|(
name|DD_WPUT
argument_list|,
literal|"parse: parsewput - PARSEIOC_SETCS\n"
argument_list|)
expr_stmt|;
name|ok
operator|=
name|parse_setcs
argument_list|(
name|dct
argument_list|,
operator|&
name|parse
operator|->
name|parse_io
argument_list|)
expr_stmt|;
break|break;
block|}
name|mp
operator|->
name|b_datap
operator|->
name|db_type
operator|=
name|ok
condition|?
name|M_IOCACK
else|:
name|M_IOCNAK
expr_stmt|;
block|}
else|else
block|{
name|mp
operator|->
name|b_datap
operator|->
name|db_type
operator|=
name|M_IOCNAK
expr_stmt|;
block|}
name|pprintf
argument_list|(
name|DD_WPUT
argument_list|,
literal|"parse: parsewput qreply - %s\n"
argument_list|,
operator|(
name|mp
operator|->
name|b_datap
operator|->
name|db_type
operator|==
name|M_IOCNAK
operator|)
condition|?
literal|"M_IOCNAK"
else|:
literal|"M_IOCACK"
argument_list|)
expr_stmt|;
name|qreply
argument_list|(
name|q
argument_list|,
name|mp
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * read characters from streams buffers  */
end_comment

begin_function
specifier|static
name|unsigned
name|long
name|rdchar
parameter_list|(
name|mblk_t
modifier|*
modifier|*
name|mp
parameter_list|)
block|{
while|while
condition|(
operator|*
name|mp
operator|!=
operator|(
name|mblk_t
operator|*
operator|)
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|mp
operator|)
operator|->
name|b_wptr
operator|-
operator|(
operator|*
name|mp
operator|)
operator|->
name|b_rptr
condition|)
block|{
return|return
call|(
name|unsigned
name|long
call|)
argument_list|(
operator|*
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|(
operator|(
operator|*
name|mp
operator|)
operator|->
name|b_rptr
operator|++
operator|)
argument_list|)
return|;
block|}
else|else
block|{
specifier|register
name|mblk_t
modifier|*
name|mmp
init|=
operator|*
name|mp
decl_stmt|;
operator|*
name|mp
operator|=
operator|(
operator|*
name|mp
operator|)
operator|->
name|b_cont
expr_stmt|;
name|freeb
argument_list|(
name|mmp
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|unsigned
name|long
operator|)
operator|~
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * convert incoming data  */
end_comment

begin_function
specifier|static
name|int
name|parserput
parameter_list|(
name|queue_t
modifier|*
name|q
parameter_list|,
name|mblk_t
modifier|*
name|imp
parameter_list|)
block|{
specifier|register
name|unsigned
name|char
name|type
decl_stmt|;
name|mblk_t
modifier|*
name|mp
init|=
name|imp
decl_stmt|;
switch|switch
condition|(
name|type
operator|=
name|mp
operator|->
name|b_datap
operator|->
name|db_type
condition|)
block|{
default|default:
comment|/* 		 * anything we don't know will be put on queue 		 * the service routine will move it to the next one 		 */
name|pprintf
argument_list|(
name|DD_RPUT
argument_list|,
literal|"parse: parserput - forward type 0x%x\n"
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|canputnext
argument_list|(
name|q
argument_list|)
operator|||
operator|(
name|mp
operator|->
name|b_datap
operator|->
name|db_type
operator|>
name|QPCTL
operator|)
condition|)
block|{
name|putnext
argument_list|(
name|q
argument_list|,
name|mp
argument_list|)
expr_stmt|;
block|}
else|else
name|putq
argument_list|(
name|q
argument_list|,
name|mp
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_BREAK
case|:
case|case
name|M_DATA
case|:
block|{
specifier|register
name|parsestream_t
modifier|*
name|parse
init|=
operator|(
name|parsestream_t
operator|*
operator|)
name|q
operator|->
name|q_ptr
decl_stmt|;
specifier|register
name|mblk_t
modifier|*
name|nmp
decl_stmt|;
specifier|register
name|unsigned
name|long
name|ch
decl_stmt|;
name|timestamp_t
name|c_time
decl_stmt|;
name|timespec_t
name|hres_time
decl_stmt|;
comment|/* 			     * get time on packet delivery 			     */
name|gethrestime
argument_list|(
operator|&
name|hres_time
argument_list|)
expr_stmt|;
name|c_time
operator|.
name|tv
operator|.
name|tv_sec
operator|=
name|hres_time
operator|.
name|tv_sec
expr_stmt|;
name|c_time
operator|.
name|tv
operator|.
name|tv_usec
operator|=
name|hres_time
operator|.
name|tv_nsec
operator|/
literal|1000
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|parse
operator|->
name|parse_status
operator|&
name|PARSE_ENABLE
operator|)
condition|)
block|{
name|pprintf
argument_list|(
name|DD_RPUT
argument_list|,
literal|"parse: parserput - parser disabled - forward type 0x%x\n"
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|canputnext
argument_list|(
name|q
argument_list|)
operator|||
operator|(
name|mp
operator|->
name|b_datap
operator|->
name|db_type
operator|>
name|QPCTL
operator|)
condition|)
block|{
name|putnext
argument_list|(
name|q
argument_list|,
name|mp
argument_list|)
expr_stmt|;
block|}
else|else
name|putq
argument_list|(
name|q
argument_list|,
name|mp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pprintf
argument_list|(
name|DD_RPUT
argument_list|,
literal|"parse: parserput - M_%s\n"
argument_list|,
operator|(
name|type
operator|==
name|M_DATA
operator|)
condition|?
literal|"DATA"
else|:
literal|"BREAK"
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|M_DATA
condition|)
block|{
comment|/* 					     * parse packet looking for start an end characters 					     */
while|while
condition|(
name|mp
operator|!=
operator|(
name|mblk_t
operator|*
operator|)
name|NULL
condition|)
block|{
name|ch
operator|=
name|rdchar
argument_list|(
operator|&
name|mp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|!=
operator|~
literal|0
operator|&&
name|parse_ioread
argument_list|(
operator|&
name|parse
operator|->
name|parse_io
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|ch
argument_list|,
operator|&
name|c_time
argument_list|)
condition|)
block|{
comment|/* 							     * up up and away (hopefully ...) 							     * don't press it if resources are tight or nobody wants it 							     */
name|nmp
operator|=
operator|(
name|mblk_t
operator|*
operator|)
name|NULL
expr_stmt|;
if|if
condition|(
name|canputnext
argument_list|(
name|parse
operator|->
name|parse_queue
argument_list|)
operator|&&
operator|(
name|nmp
operator|=
name|allocb
argument_list|(
sizeof|sizeof
argument_list|(
name|parsetime_t
argument_list|)
argument_list|,
name|BPRI_MED
argument_list|)
operator|)
condition|)
block|{
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|parse
operator|->
name|parse_io
operator|.
name|parse_dtime
argument_list|,
operator|(
name|caddr_t
operator|)
name|nmp
operator|->
name|b_rptr
argument_list|,
sizeof|sizeof
argument_list|(
name|parsetime_t
argument_list|)
argument_list|)
expr_stmt|;
name|nmp
operator|->
name|b_wptr
operator|+=
sizeof|sizeof
argument_list|(
name|parsetime_t
argument_list|)
expr_stmt|;
name|putnext
argument_list|(
name|parse
operator|->
name|parse_queue
argument_list|,
name|nmp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nmp
condition|)
name|freemsg
argument_list|(
name|nmp
argument_list|)
expr_stmt|;
name|parse_iodone
argument_list|(
operator|&
name|parse
operator|->
name|parse_io
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|parse_ioread
argument_list|(
operator|&
name|parse
operator|->
name|parse_io
argument_list|,
operator|(
name|unsigned
name|int
operator|)
literal|0
argument_list|,
operator|&
name|c_time
argument_list|)
condition|)
block|{
comment|/* 						     * up up and away (hopefully ...) 						     * don't press it if resources are tight or nobody wants it 						     */
name|nmp
operator|=
operator|(
name|mblk_t
operator|*
operator|)
name|NULL
expr_stmt|;
if|if
condition|(
name|canputnext
argument_list|(
name|parse
operator|->
name|parse_queue
argument_list|)
operator|&&
operator|(
name|nmp
operator|=
name|allocb
argument_list|(
sizeof|sizeof
argument_list|(
name|parsetime_t
argument_list|)
argument_list|,
name|BPRI_MED
argument_list|)
operator|)
condition|)
block|{
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|parse
operator|->
name|parse_io
operator|.
name|parse_dtime
argument_list|,
operator|(
name|caddr_t
operator|)
name|nmp
operator|->
name|b_rptr
argument_list|,
sizeof|sizeof
argument_list|(
name|parsetime_t
argument_list|)
argument_list|)
expr_stmt|;
name|nmp
operator|->
name|b_wptr
operator|+=
sizeof|sizeof
argument_list|(
name|parsetime_t
argument_list|)
expr_stmt|;
name|putnext
argument_list|(
name|parse
operator|->
name|parse_queue
argument_list|,
name|nmp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nmp
condition|)
name|freemsg
argument_list|(
name|nmp
argument_list|)
expr_stmt|;
name|parse_iodone
argument_list|(
operator|&
name|parse
operator|->
name|parse_io
argument_list|)
expr_stmt|;
block|}
name|freemsg
argument_list|(
name|mp
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
comment|/* 		     * CD PPS support for non direct ISR hack 		     */
case|case
name|M_HANGUP
case|:
case|case
name|M_UNHANGUP
case|:
block|{
specifier|register
name|parsestream_t
modifier|*
name|parse
init|=
operator|(
name|parsestream_t
operator|*
operator|)
name|q
operator|->
name|q_ptr
decl_stmt|;
name|timestamp_t
name|c_time
decl_stmt|;
name|timespec_t
name|hres_time
decl_stmt|;
specifier|register
name|mblk_t
modifier|*
name|nmp
decl_stmt|;
specifier|register
name|int
name|status
init|=
name|cd_invert
operator|^
operator|(
name|type
operator|==
name|M_UNHANGUP
operator|)
decl_stmt|;
name|gethrestime
argument_list|(
operator|&
name|hres_time
argument_list|)
expr_stmt|;
name|c_time
operator|.
name|tv
operator|.
name|tv_sec
operator|=
name|hres_time
operator|.
name|tv_sec
expr_stmt|;
name|c_time
operator|.
name|tv
operator|.
name|tv_usec
operator|=
name|hres_time
operator|.
name|tv_nsec
operator|/
literal|1000
expr_stmt|;
name|pprintf
argument_list|(
name|DD_RPUT
argument_list|,
literal|"parse: parserput - M_%sHANGUP\n"
argument_list|,
operator|(
name|type
operator|==
name|M_HANGUP
operator|)
condition|?
literal|""
else|:
literal|"UN"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|parse
operator|->
name|parse_status
operator|&
name|PARSE_ENABLE
operator|)
operator|&&
name|parse_iopps
argument_list|(
operator|&
name|parse
operator|->
name|parse_io
argument_list|,
name|status
condition|?
name|SYNC_ONE
else|:
name|SYNC_ZERO
argument_list|,
operator|&
name|c_time
argument_list|)
condition|)
block|{
name|nmp
operator|=
operator|(
name|mblk_t
operator|*
operator|)
name|NULL
expr_stmt|;
if|if
condition|(
name|canputnext
argument_list|(
name|parse
operator|->
name|parse_queue
argument_list|)
operator|&&
operator|(
name|nmp
operator|=
name|allocb
argument_list|(
sizeof|sizeof
argument_list|(
name|parsetime_t
argument_list|)
argument_list|,
name|BPRI_MED
argument_list|)
operator|)
condition|)
block|{
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|parse
operator|->
name|parse_io
operator|.
name|parse_dtime
argument_list|,
operator|(
name|caddr_t
operator|)
name|nmp
operator|->
name|b_rptr
argument_list|,
sizeof|sizeof
argument_list|(
name|parsetime_t
argument_list|)
argument_list|)
expr_stmt|;
name|nmp
operator|->
name|b_wptr
operator|+=
sizeof|sizeof
argument_list|(
name|parsetime_t
argument_list|)
expr_stmt|;
name|putnext
argument_list|(
name|parse
operator|->
name|parse_queue
argument_list|,
name|nmp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nmp
condition|)
name|freemsg
argument_list|(
name|nmp
argument_list|)
expr_stmt|;
name|parse_iodone
argument_list|(
operator|&
name|parse
operator|->
name|parse_io
argument_list|)
expr_stmt|;
name|freemsg
argument_list|(
name|mp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|canputnext
argument_list|(
name|q
argument_list|)
operator|||
operator|(
name|mp
operator|->
name|b_datap
operator|->
name|db_type
operator|>
name|QPCTL
operator|)
condition|)
block|{
name|putnext
argument_list|(
name|q
argument_list|,
name|mp
argument_list|)
expr_stmt|;
block|}
else|else
name|putq
argument_list|(
name|q
argument_list|,
name|mp
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
name|parse
operator|->
name|parse_ppsclockev
operator|.
name|tv
operator|=
name|c_time
operator|.
name|tv
expr_stmt|;
operator|++
operator|(
name|parse
operator|->
name|parse_ppsclockev
operator|.
name|serial
operator|)
expr_stmt|;
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function_decl
specifier|static
name|int
name|init_zs_linemon
parameter_list|(
name|queue_t
modifier|*
parameter_list|,
name|queue_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* handle line monitor for "zs" driver */
end_comment

begin_function_decl
specifier|static
name|void
name|close_zs_linemon
parameter_list|(
name|queue_t
modifier|*
parameter_list|,
name|queue_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*-------------------- CD isr status monitor ---------------*/
end_comment

begin_function
specifier|static
name|int
name|init_linemon
parameter_list|(
name|queue_t
modifier|*
name|q
parameter_list|)
block|{
specifier|register
name|queue_t
modifier|*
name|dq
decl_stmt|;
name|dq
operator|=
name|WR
argument_list|(
name|q
argument_list|)
expr_stmt|;
comment|/* 	 * we ARE doing very bad things down here (basically stealing ISR 	 * hooks) 	 * 	 * so we chase down the STREAMS stack searching for the driver 	 * and if this is a known driver we insert our ISR routine for 	 * status changes in to the ExternalStatus handling hook 	 */
while|while
condition|(
name|dq
operator|->
name|q_next
condition|)
block|{
name|dq
operator|=
name|dq
operator|->
name|q_next
expr_stmt|;
comment|/* skip down to driver */
block|}
comment|/* 	 * find appropriate driver dependent routine 	 */
if|if
condition|(
name|dq
operator|->
name|q_qinfo
operator|&&
name|dq
operator|->
name|q_qinfo
operator|->
name|qi_minfo
condition|)
block|{
specifier|register
name|char
modifier|*
name|dname
init|=
name|dq
operator|->
name|q_qinfo
operator|->
name|qi_minfo
operator|->
name|mi_idname
decl_stmt|;
name|pprintf
argument_list|(
name|DD_INSTALL
argument_list|,
literal|"init_linemon: driver is \"%s\"\n"
argument_list|,
name|dname
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|sun
if|if
condition|(
name|dname
operator|&&
operator|!
name|strcmp
argument_list|(
name|dname
argument_list|,
literal|"zs"
argument_list|)
condition|)
block|{
return|return
name|init_zs_linemon
argument_list|(
name|dq
argument_list|,
name|q
argument_list|)
return|;
block|}
else|else
endif|#
directive|endif
block|{
name|pprintf
argument_list|(
name|DD_INSTALL
argument_list|,
literal|"init_linemon: driver \"%s\" not suitable for CD monitoring\n"
argument_list|,
name|dname
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
name|pprintf
argument_list|(
name|DD_INSTALL
argument_list|,
literal|"init_linemon: cannot find driver\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|close_linemon
parameter_list|(
name|queue_t
modifier|*
name|q
parameter_list|,
name|queue_t
modifier|*
name|my_q
parameter_list|)
block|{
comment|/* 	 * find appropriate driver dependent routine 	 */
if|if
condition|(
name|q
operator|->
name|q_qinfo
operator|&&
name|q
operator|->
name|q_qinfo
operator|->
name|qi_minfo
condition|)
block|{
specifier|register
name|char
modifier|*
name|dname
init|=
name|q
operator|->
name|q_qinfo
operator|->
name|qi_minfo
operator|->
name|mi_idname
decl_stmt|;
ifdef|#
directive|ifdef
name|sun
if|if
condition|(
name|dname
operator|&&
operator|!
name|strcmp
argument_list|(
name|dname
argument_list|,
literal|"zs"
argument_list|)
condition|)
block|{
name|close_zs_linemon
argument_list|(
name|q
argument_list|,
name|my_q
argument_list|)
expr_stmt|;
return|return;
block|}
name|pprintf
argument_list|(
name|DD_INSTALL
argument_list|,
literal|"close_linemon: cannot find driver close routine for \"%s\"\n"
argument_list|,
name|dname
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|pprintf
argument_list|(
name|DD_INSTALL
argument_list|,
literal|"close_linemon: cannot find driver name\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|sun
end_ifdef

begin_include
include|#
directive|include
file|<sys/tty.h>
end_include

begin_include
include|#
directive|include
file|<sys/zsdev.h>
end_include

begin_include
include|#
directive|include
file|<sys/ser_async.h>
end_include

begin_include
include|#
directive|include
file|<sys/ser_zscc.h>
end_include

begin_function_decl
specifier|static
name|void
name|zs_xsisr
parameter_list|(
name|struct
name|zscom
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* zs external status interupt handler */
end_comment

begin_comment
comment|/*  * there should be some docs telling how to get to  * sz:zs_usec_delay and zs:initzsops()  */
end_comment

begin_define
define|#
directive|define
name|zs_usec_delay
value|5
end_define

begin_struct
struct|struct
name|savedzsops
block|{
name|struct
name|zsops
name|zsops
decl_stmt|;
name|struct
name|zsops
modifier|*
name|oldzsops
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|zsops
modifier|*
name|emergencyzs
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|init_zs_linemon
parameter_list|(
name|queue_t
modifier|*
name|q
parameter_list|,
name|queue_t
modifier|*
name|my_q
parameter_list|)
block|{
specifier|register
name|struct
name|zscom
modifier|*
name|zs
decl_stmt|;
specifier|register
name|struct
name|savedzsops
modifier|*
name|szs
decl_stmt|;
specifier|register
name|parsestream_t
modifier|*
name|parsestream
init|=
operator|(
name|parsestream_t
operator|*
operator|)
name|my_q
operator|->
name|q_ptr
decl_stmt|;
comment|/* 	 * we expect the zsaline pointer in the q_data pointer 	 * from there on we insert our on EXTERNAL/STATUS ISR routine 	 * into the interrupt path, before the standard handler 	 */
name|zs
operator|=
operator|(
operator|(
expr|struct
name|asyncline
operator|*
operator|)
name|q
operator|->
name|q_ptr
operator|)
operator|->
name|za_common
expr_stmt|;
if|if
condition|(
operator|!
name|zs
condition|)
block|{
comment|/* 		 * well - not found on startup - just say no (shouldn't happen though) 		 */
return|return
literal|0
return|;
block|}
else|else
block|{
comment|/* 		 * we do a direct replacement, in case others fiddle also 		 * if somebody else grabs our hook and we disconnect 		 * we are in DEEP trouble - panic is likely to be next, sorry 		 */
name|szs
operator|=
operator|(
expr|struct
name|savedzsops
operator|*
operator|)
name|kmem_alloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|savedzsops
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
if|if
condition|(
name|szs
operator|==
operator|(
expr|struct
name|savedzsops
operator|*
operator|)
literal|0
condition|)
block|{
name|pprintf
argument_list|(
name|DD_INSTALL
argument_list|,
literal|"init_zs_linemon: CD monitor NOT installed - no memory\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
name|parsestream
operator|->
name|parse_data
operator|=
operator|(
name|void
operator|*
operator|)
name|szs
expr_stmt|;
name|mutex_enter
argument_list|(
name|zs
operator|->
name|zs_excl
argument_list|)
expr_stmt|;
name|parsestream
operator|->
name|parse_dqueue
operator|=
name|q
expr_stmt|;
comment|/* remember driver */
name|szs
operator|->
name|zsops
operator|=
operator|*
name|zs
operator|->
name|zs_ops
expr_stmt|;
name|szs
operator|->
name|zsops
operator|.
name|zsop_xsint
operator|=
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
expr|struct
name|zscom
operator|*
argument_list|)
operator|)
name|zs_xsisr
expr_stmt|;
comment|/* place our bastard */
name|szs
operator|->
name|oldzsops
operator|=
name|zs
operator|->
name|zs_ops
expr_stmt|;
name|emergencyzs
operator|=
name|zs
operator|->
name|zs_ops
expr_stmt|;
name|zs
operator|->
name|zs_ops
operator|=
operator|&
name|szs
operator|->
name|zsops
expr_stmt|;
comment|/* hook it up */
comment|/* 			 * XXX: this is usually done via zsopinit()  			 * - have yet to find a way to call that routine 			 */
name|zs
operator|->
name|zs_xsint
operator|=
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
expr|struct
name|zscom
operator|*
argument_list|)
operator|)
name|zs_xsisr
expr_stmt|;
name|mutex_exit
argument_list|(
name|zs
operator|->
name|zs_excl
argument_list|)
expr_stmt|;
name|pprintf
argument_list|(
name|DD_INSTALL
argument_list|,
literal|"init_zs_linemon: CD monitor installed\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * unregister our ISR routine - must call under splhigh() (or   * whatever block ZS status interrupts)  */
end_comment

begin_function
specifier|static
name|void
name|close_zs_linemon
parameter_list|(
name|queue_t
modifier|*
name|q
parameter_list|,
name|queue_t
modifier|*
name|my_q
parameter_list|)
block|{
specifier|register
name|struct
name|zscom
modifier|*
name|zs
decl_stmt|;
specifier|register
name|parsestream_t
modifier|*
name|parsestream
init|=
operator|(
name|parsestream_t
operator|*
operator|)
name|my_q
operator|->
name|q_ptr
decl_stmt|;
name|zs
operator|=
operator|(
operator|(
expr|struct
name|asyncline
operator|*
operator|)
name|q
operator|->
name|q_ptr
operator|)
operator|->
name|za_common
expr_stmt|;
if|if
condition|(
operator|!
name|zs
condition|)
block|{
comment|/* 		 * well - not found on startup - just say no (shouldn't happen though) 		 */
return|return;
block|}
else|else
block|{
specifier|register
name|struct
name|savedzsops
modifier|*
name|szs
init|=
operator|(
expr|struct
name|savedzsops
operator|*
operator|)
name|parsestream
operator|->
name|parse_data
decl_stmt|;
name|mutex_enter
argument_list|(
name|zs
operator|->
name|zs_excl
argument_list|)
expr_stmt|;
name|zs
operator|->
name|zs_ops
operator|=
name|szs
operator|->
name|oldzsops
expr_stmt|;
comment|/* reset to previous handler functions */
comment|/* 		 * XXX: revert xsint (usually done via zsopinit() - have still to find 		 * a way to call that bugger 		 */
name|zs
operator|->
name|zs_xsint
operator|=
name|zs
operator|->
name|zs_ops
operator|->
name|zsop_xsint
expr_stmt|;
name|mutex_exit
argument_list|(
name|zs
operator|->
name|zs_excl
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
operator|(
name|caddr_t
operator|)
name|szs
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|savedzsops
argument_list|)
argument_list|)
expr_stmt|;
name|pprintf
argument_list|(
name|DD_INSTALL
argument_list|,
literal|"close_zs_linemon: CD monitor deleted\n"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|ZSRR0_IGNORE
value|(ZSRR0_CD|ZSRR0_SYNC|ZSRR0_CTS)
end_define

begin_define
define|#
directive|define
name|MAXDEPTH
value|50
end_define

begin_comment
comment|/* maximum allowed stream crawl */
end_comment

begin_comment
comment|/*  * take external status interrupt (only CD interests us)  */
end_comment

begin_function
specifier|static
name|void
name|zs_xsisr
parameter_list|(
name|struct
name|zscom
modifier|*
name|zs
parameter_list|)
block|{
specifier|register
name|struct
name|asyncline
modifier|*
name|za
init|=
operator|(
name|void
operator|*
operator|)
name|zs
operator|->
name|zs_priv
decl_stmt|;
specifier|register
name|queue_t
modifier|*
name|q
decl_stmt|;
specifier|register
name|unsigned
name|char
name|zsstatus
decl_stmt|;
specifier|register
name|int
name|loopcheck
decl_stmt|;
specifier|register
name|unsigned
name|char
name|cdstate
decl_stmt|;
specifier|register
specifier|const
name|char
modifier|*
name|dname
init|=
literal|"-UNKNOWN-"
decl_stmt|;
name|timespec_t
name|hres_time
decl_stmt|;
comment|/* 	 * pick up current state 	 */
name|zsstatus
operator|=
name|SCC_READ0
argument_list|()
expr_stmt|;
if|if
condition|(
name|za
operator|->
name|za_rr0
operator|^
operator|(
name|cdstate
operator|=
name|zsstatus
operator|&
name|ZSRR0_CD
operator|)
condition|)
block|{
name|timestamp_t
name|cdevent
decl_stmt|;
specifier|register
name|int
name|status
decl_stmt|;
comment|/* 		 * time stamp 		 */
name|gethrestime
argument_list|(
operator|&
name|hres_time
argument_list|)
expr_stmt|;
name|cdevent
operator|.
name|tv
operator|.
name|tv_sec
operator|=
name|hres_time
operator|.
name|tv_sec
expr_stmt|;
name|cdevent
operator|.
name|tv
operator|.
name|tv_usec
operator|=
name|hres_time
operator|.
name|tv_nsec
operator|/
literal|1000
expr_stmt|;
name|q
operator|=
name|za
operator|->
name|za_ttycommon
operator|.
name|t_readq
expr_stmt|;
comment|/* 		 * logical state 		 */
name|status
operator|=
name|cd_invert
condition|?
name|cdstate
operator|==
literal|0
else|:
name|cdstate
operator|!=
literal|0
expr_stmt|;
comment|/* 		 * ok - now the hard part - find ourself 		 */
name|loopcheck
operator|=
name|MAXDEPTH
expr_stmt|;
while|while
condition|(
name|q
condition|)
block|{
if|if
condition|(
name|q
operator|->
name|q_qinfo
operator|&&
name|q
operator|->
name|q_qinfo
operator|->
name|qi_minfo
condition|)
block|{
name|dname
operator|=
name|q
operator|->
name|q_qinfo
operator|->
name|qi_minfo
operator|->
name|mi_idname
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|dname
argument_list|,
name|parseinfo
operator|.
name|st_rdinit
operator|->
name|qi_minfo
operator|->
name|mi_idname
argument_list|)
condition|)
block|{
comment|/* 					 * back home - phew (hopping along stream queues might 					 * prove dangerous to your health) 					 */
if|if
condition|(
operator|(
operator|(
operator|(
name|parsestream_t
operator|*
operator|)
name|q
operator|->
name|q_ptr
operator|)
operator|->
name|parse_status
operator|&
name|PARSE_ENABLE
operator|)
operator|&&
name|parse_iopps
argument_list|(
operator|&
operator|(
operator|(
name|parsestream_t
operator|*
operator|)
name|q
operator|->
name|q_ptr
operator|)
operator|->
name|parse_io
argument_list|,
name|status
condition|?
name|SYNC_ONE
else|:
name|SYNC_ZERO
argument_list|,
operator|&
name|cdevent
argument_list|)
condition|)
block|{
comment|/* 						 * XXX - currently we do not pass up the message, as 						 * we should. 						 * for a correct behaviour wee need to block out 						 * processing until parse_iodone has been posted via 						 * a softcall-ed routine which does the message pass-up 						 * right now PPS information relies on input being 						 * received 						 */
name|parse_iodone
argument_list|(
operator|&
operator|(
operator|(
name|parsestream_t
operator|*
operator|)
name|q
operator|->
name|q_ptr
operator|)
operator|->
name|parse_io
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status
condition|)
block|{
operator|(
operator|(
name|parsestream_t
operator|*
operator|)
name|q
operator|->
name|q_ptr
operator|)
operator|->
name|parse_ppsclockev
operator|.
name|tv
operator|=
name|cdevent
operator|.
name|tv
expr_stmt|;
operator|++
operator|(
operator|(
operator|(
name|parsestream_t
operator|*
operator|)
name|q
operator|->
name|q_ptr
operator|)
operator|->
name|parse_ppsclockev
operator|.
name|serial
operator|)
expr_stmt|;
block|}
name|pprintf
argument_list|(
name|DD_ISR
argument_list|,
literal|"zs_xsisr: CD event %s has been posted for \"%s\"\n"
argument_list|,
name|status
condition|?
literal|"ONE"
else|:
literal|"ZERO"
argument_list|,
name|dname
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|q
operator|=
name|q
operator|->
name|q_next
expr_stmt|;
if|if
condition|(
operator|!
name|loopcheck
operator|--
condition|)
block|{
name|panic
argument_list|(
literal|"zs_xsisr: STREAMS Queue corrupted - CD event"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cdstate
condition|)
comment|/* fake CARRIER status - XXX currently not coordinated */
name|za
operator|->
name|za_flags
operator||=
name|ZAS_CARR_ON
expr_stmt|;
else|else
name|za
operator|->
name|za_flags
operator|&=
operator|~
name|ZAS_CARR_ON
expr_stmt|;
comment|/* 		 * only pretend that CD and ignored transistion (SYNC,CTS) 		 * have been handled 		 */
name|za
operator|->
name|za_rr0
operator|=
operator|(
name|za
operator|->
name|za_rr0
operator|&
operator|~
name|ZSRR0_IGNORE
operator|)
operator||
operator|(
name|zsstatus
operator|&
name|ZSRR0_IGNORE
operator|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|za
operator|->
name|za_rr0
operator|^
name|zsstatus
operator|)
operator|&
operator|~
name|ZSRR0_IGNORE
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 			 * all done - kill status indication and return 			 */
name|SCC_WRITE0
argument_list|(
name|ZSWR0_RESET_STATUS
argument_list|)
expr_stmt|;
comment|/* might kill other conditions here */
return|return;
block|}
block|}
name|pprintf
argument_list|(
name|DD_ISR
argument_list|,
literal|"zs_xsisr: non CD event 0x%x for \"%s\"\n"
argument_list|,
operator|(
name|za
operator|->
name|za_rr0
operator|^
name|zsstatus
operator|)
operator|&
operator|~
name|ZSRR0_CD
argument_list|,
name|dname
argument_list|)
expr_stmt|;
comment|/* 	 * we are now gathered here to process some unusual external status 	 * interrupts. 	 * any CD events have also been handled and shouldn't be processed 	 * by the original routine (unless we have a VERY busy port pin) 	 * some initializations are done here, which could have been done before for 	 * both code paths but have been avioded for minimum path length to 	 * the uniq_time routine 	 */
name|dname
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
name|q
operator|=
name|za
operator|->
name|za_ttycommon
operator|.
name|t_readq
expr_stmt|;
name|loopcheck
operator|=
name|MAXDEPTH
expr_stmt|;
comment|/* 	 * the real thing for everything else ... 	 */
while|while
condition|(
name|q
condition|)
block|{
if|if
condition|(
name|q
operator|->
name|q_qinfo
operator|&&
name|q
operator|->
name|q_qinfo
operator|->
name|qi_minfo
condition|)
block|{
name|dname
operator|=
name|q
operator|->
name|q_qinfo
operator|->
name|qi_minfo
operator|->
name|mi_idname
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|dname
argument_list|,
name|parseinfo
operator|.
name|st_rdinit
operator|->
name|qi_minfo
operator|->
name|mi_idname
argument_list|)
condition|)
block|{
specifier|register
name|void
function_decl|(
modifier|*
name|zsisr
function_decl|)
parameter_list|(
name|struct
name|zscom
modifier|*
parameter_list|)
function_decl|;
comment|/* 				 * back home - phew (hopping along stream queues might 				 * prove dangerous to your health) 				 */
if|if
condition|(
operator|(
name|zsisr
operator|=
operator|(
operator|(
expr|struct
name|savedzsops
operator|*
operator|)
operator|(
operator|(
name|parsestream_t
operator|*
operator|)
name|q
operator|->
name|q_ptr
operator|)
operator|->
name|parse_data
operator|)
operator|->
name|oldzsops
operator|->
name|zsop_xsint
operator|)
condition|)
name|zsisr
argument_list|(
name|zs
argument_list|)
expr_stmt|;
else|else
name|panic
argument_list|(
literal|"zs_xsisr: unable to locate original ISR"
argument_list|)
expr_stmt|;
name|pprintf
argument_list|(
name|DD_ISR
argument_list|,
literal|"zs_xsisr: non CD event was processed for \"%s\"\n"
argument_list|,
name|dname
argument_list|)
expr_stmt|;
comment|/* 				 * now back to our program ... 				 */
return|return;
block|}
block|}
name|q
operator|=
name|q
operator|->
name|q_next
expr_stmt|;
if|if
condition|(
operator|!
name|loopcheck
operator|--
condition|)
block|{
name|panic
argument_list|(
literal|"zs_xsisr: STREAMS Queue corrupted - non CD event"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * last resort - shouldn't even come here as it indicates 	 * corrupted TTY structures 	 */
name|printf
argument_list|(
literal|"zs_zsisr: looking for \"%s\" - found \"%s\" - taking EMERGENCY path\n"
argument_list|,
name|parseinfo
operator|.
name|st_rdinit
operator|->
name|qi_minfo
operator|->
name|mi_idname
argument_list|,
name|dname
condition|?
name|dname
else|:
literal|"-NIL-"
argument_list|)
expr_stmt|;
if|if
condition|(
name|emergencyzs
operator|&&
name|emergencyzs
operator|->
name|zsop_xsint
condition|)
name|emergencyzs
operator|->
name|zsop_xsint
argument_list|(
name|zs
argument_list|)
expr_stmt|;
else|else
name|panic
argument_list|(
literal|"zs_xsisr: no emergency ISR handler"
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* sun */
end_comment

begin_comment
comment|/*  * History:  *  * parsesolaris.c,v  * Revision 4.11  2005/04/16 17:32:10  kardel  * update copyright  *  * Revision 4.10  2004/11/14 16:06:08  kardel  * update Id tags  *  * Revision 4.9  2004/11/14 15:29:41  kardel  * support PPSAPI, upgrade Copyright to Berkeley style  *  * Revision 4.6  1998/11/15 21:56:08  kardel  * ntp_memset not necessary  *  * Revision 4.5  1998/11/15 21:23:37  kardel  * ntp_memset() replicated in Sun kernel files  *  * Revision 4.4  1998/06/14 21:09:40  kardel  * Sun acc cleanup  *  * Revision 4.3  1998/06/13 12:14:59  kardel  * more prototypes  * fix name clashes  * allow for ansi2knr  *  * Revision 4.2  1998/06/12 15:23:08  kardel  * fix prototypes  * adjust for ansi2knr  *  * Revision 4.1  1998/05/24 09:38:46  kardel  * streams initiated iopps calls (M_xHANGUP) are now consistent with the  * respective calls from zs_xsisr()  * simulation of CARRIER status to avoid unecessary M_xHANGUP messages  *  * Revision 4.0  1998/04/10 19:45:38  kardel  * Start 4.0 release version numbering  *  * from V3 3.28 log info deleted 1998/04/11 kardel  */
end_comment

end_unit

