begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$NetBSD: readline.c,v 1.19 2001/01/10 08:10:45 jdolecek Exp $	*/
end_comment

begin_comment
comment|/*-  * Copyright (c) 1997 The NetBSD Foundation, Inc.  * All rights reserved.  *  * This code is derived from software contributed to The NetBSD Foundation  * by Jaromir Dolecek.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the NetBSD  *	Foundation, Inc. and its contributors.  * 4. Neither the name of The NetBSD Foundation nor the names of its  *    contributors may be used to endorse or promote products derived  *    from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS  * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED  * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|lint
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|SCCSID
argument_list|)
end_if

begin_expr_stmt
name|__RCSID
argument_list|(
literal|"$NetBSD: readline.c,v 1.19 2001/01/10 08:10:45 jdolecek Exp $"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint&& not SCCSID */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<dirent.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|"histedit.h"
end_include

begin_include
include|#
directive|include
file|"readline/readline.h"
end_include

begin_include
include|#
directive|include
file|"sys.h"
end_include

begin_include
include|#
directive|include
file|"el.h"
end_include

begin_include
include|#
directive|include
file|"fcns.h"
end_include

begin_comment
comment|/* for EL_NUM_FCNS */
end_comment

begin_comment
comment|/* for rl_complete() */
end_comment

begin_define
define|#
directive|define
name|TAB
value|'\r'
end_define

begin_comment
comment|/* see comment at the #ifdef for sense of this */
end_comment

begin_define
define|#
directive|define
name|GDB_411_HACK
end_define

begin_comment
comment|/* readline compatibility stuff - look at readline sources/documentation */
end_comment

begin_comment
comment|/* to see what these variables mean */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|rl_library_version
init|=
literal|"EditLine wrapper"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|rl_readline_name
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|rl_instream
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|rl_outstream
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|rl_point
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|rl_end
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|rl_line_buffer
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|history_base
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* probably never subject to change */
end_comment

begin_decl_stmt
name|int
name|history_length
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|max_input_history
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|history_expansion_char
init|=
literal|'!'
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|history_subst_char
init|=
literal|'^'
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|history_no_expand_chars
init|=
literal|" \t\n=("
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Function
modifier|*
name|history_inhibit_expansion_function
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|rl_inhibit_completion
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|rl_attempted_completion_over
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|rl_basic_word_break_characters
init|=
literal|" \t\n\"\\'`@$><=;|&{("
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|rl_completer_word_break_characters
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|rl_completer_quote_characters
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|CPFunction
modifier|*
name|rl_completion_entry_function
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|CPPFunction
modifier|*
name|rl_attempted_completion_function
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * This is set to character indicating type of completion being done by  * rl_complete_internal(); this is available for application completion  * functions.  */
end_comment

begin_decl_stmt
name|int
name|rl_completion_type
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * If more than this number of items results from query for possible  * completions, we ask user if they are sure to really display the list.  */
end_comment

begin_decl_stmt
name|int
name|rl_completion_query_items
init|=
literal|100
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * List of characters which are word break characters, but should be left  * in the parsed text when it is passed to the completion function.  * Shell uses this to help determine what kind of completing to do.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|rl_special_prefixes
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * This is the character appended to the completed words if at the end of  * the line. Default is ' ' (a space).  */
end_comment

begin_decl_stmt
name|int
name|rl_completion_append_character
init|=
literal|' '
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* stuff below is used internally by libedit for readline emulation */
end_comment

begin_comment
comment|/* if not zero, non-unique completions always show list of possible matches */
end_comment

begin_decl_stmt
specifier|static
name|int
name|_rl_complete_show_all
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|History
modifier|*
name|h
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|EditLine
modifier|*
name|e
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|el_rl_complete_cmdnum
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* internal functions */
end_comment

begin_function_decl
specifier|static
name|unsigned
name|char
name|_el_rl_complete
parameter_list|(
name|EditLine
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|_get_prompt
parameter_list|(
name|EditLine
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|HIST_ENTRY
modifier|*
name|_move_history
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|_history_search_gen
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|_history_expand_command
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|_rl_compat_sub
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|rl_complete_internal
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|_rl_qsort_string_compare
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * needed for prompt switching in readline()  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|el_rl_prompt
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|_get_prompt
parameter_list|(
name|EditLine
modifier|*
name|el
parameter_list|)
block|{
return|return
operator|(
name|el_rl_prompt
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * generic function for moving around history  */
end_comment

begin_function
specifier|static
name|HIST_ENTRY
modifier|*
name|_move_history
parameter_list|(
name|int
name|op
parameter_list|)
block|{
name|HistEvent
name|ev
decl_stmt|;
specifier|static
name|HIST_ENTRY
name|rl_he
decl_stmt|;
if|if
condition|(
name|history
argument_list|(
name|h
argument_list|,
operator|&
name|ev
argument_list|,
name|op
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|HIST_ENTRY
operator|*
operator|)
name|NULL
return|;
name|rl_he
operator|.
name|line
operator|=
name|ev
operator|.
name|str
expr_stmt|;
name|rl_he
operator|.
name|data
operator|=
literal|""
expr_stmt|;
return|return
operator|(
operator|&
name|rl_he
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * READLINE compatibility stuff  */
end_comment

begin_comment
comment|/*  * initialize rl compat stuff  */
end_comment

begin_function
name|int
name|rl_initialize
parameter_list|(
name|void
parameter_list|)
block|{
name|HistEvent
name|ev
decl_stmt|;
specifier|const
name|LineInfo
modifier|*
name|li
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|editmode
init|=
literal|1
decl_stmt|;
name|struct
name|termios
name|t
decl_stmt|;
if|if
condition|(
name|e
operator|!=
name|NULL
condition|)
name|el_end
argument_list|(
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
name|history_end
argument_list|(
name|h
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rl_instream
condition|)
name|rl_instream
operator|=
name|stdin
expr_stmt|;
if|if
condition|(
operator|!
name|rl_outstream
condition|)
name|rl_outstream
operator|=
name|stdout
expr_stmt|;
comment|/* 	 * See if we don't really want to run the editor 	 */
if|if
condition|(
name|tcgetattr
argument_list|(
name|fileno
argument_list|(
name|rl_instream
argument_list|)
argument_list|,
operator|&
name|t
argument_list|)
operator|!=
operator|-
literal|1
operator|&&
operator|(
name|t
operator|.
name|c_lflag
operator|&
name|ECHO
operator|)
operator|==
literal|0
condition|)
name|editmode
operator|=
literal|0
expr_stmt|;
name|e
operator|=
name|el_init
argument_list|(
name|rl_readline_name
argument_list|,
name|rl_instream
argument_list|,
name|rl_outstream
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|editmode
condition|)
name|el_set
argument_list|(
name|e
argument_list|,
name|EL_EDITMODE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|h
operator|=
name|history_init
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|e
operator|||
operator|!
name|h
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|history
argument_list|(
name|h
argument_list|,
operator|&
name|ev
argument_list|,
name|H_SETSIZE
argument_list|,
name|INT_MAX
argument_list|)
expr_stmt|;
comment|/* unlimited */
name|history_length
operator|=
literal|0
expr_stmt|;
name|max_input_history
operator|=
name|INT_MAX
expr_stmt|;
name|el_set
argument_list|(
name|e
argument_list|,
name|EL_HIST
argument_list|,
name|history
argument_list|,
name|h
argument_list|)
expr_stmt|;
comment|/* for proper prompt printing in readline() */
name|el_rl_prompt
operator|=
name|strdup
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|el_set
argument_list|(
name|e
argument_list|,
name|EL_PROMPT
argument_list|,
name|_get_prompt
argument_list|)
expr_stmt|;
name|el_set
argument_list|(
name|e
argument_list|,
name|EL_SIGNAL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* set default mode to "emacs"-style and read setting afterwards */
comment|/* so this can be overriden */
name|el_set
argument_list|(
name|e
argument_list|,
name|EL_EDITOR
argument_list|,
literal|"emacs"
argument_list|)
expr_stmt|;
comment|/* 	 * Word completition - this has to go AFTER rebinding keys 	 * to emacs-style. 	 */
name|el_set
argument_list|(
name|e
argument_list|,
name|EL_ADDFN
argument_list|,
literal|"rl_complete"
argument_list|,
literal|"ReadLine compatible completition function"
argument_list|,
name|_el_rl_complete
argument_list|)
expr_stmt|;
name|el_set
argument_list|(
name|e
argument_list|,
name|EL_BIND
argument_list|,
literal|"^I"
argument_list|,
literal|"rl_complete"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * Find out where the rl_complete function was added; this is 	 * used later to detect that lastcmd was also rl_complete. 	 */
for|for
control|(
name|i
operator|=
name|EL_NUM_FCNS
init|;
name|i
operator|<
name|e
operator|->
name|el_map
operator|.
name|nfunc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|e
operator|->
name|el_map
operator|.
name|func
index|[
name|i
index|]
operator|==
name|_el_rl_complete
condition|)
block|{
name|el_rl_complete_cmdnum
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
comment|/* read settings from configuration file */
name|el_source
argument_list|(
name|e
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * Unfortunately, some applications really do use rl_point 	 * and rl_line_buffer directly. 	 */
name|li
operator|=
name|el_line
argument_list|(
name|e
argument_list|)
expr_stmt|;
comment|/* LINTED const cast */
name|rl_line_buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|li
operator|->
name|buffer
expr_stmt|;
name|rl_point
operator|=
name|rl_end
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * read one line from input stream and return it, chomping  * trailing newline (if there is any)  */
end_comment

begin_function
name|char
modifier|*
name|readline
parameter_list|(
specifier|const
name|char
modifier|*
name|prompt
parameter_list|)
block|{
name|HistEvent
name|ev
decl_stmt|;
name|int
name|count
decl_stmt|;
specifier|const
name|char
modifier|*
name|ret
decl_stmt|;
if|if
condition|(
name|e
operator|==
name|NULL
operator|||
name|h
operator|==
name|NULL
condition|)
name|rl_initialize
argument_list|()
expr_stmt|;
comment|/* update prompt accordingly to what has been passed */
if|if
condition|(
operator|!
name|prompt
condition|)
name|prompt
operator|=
literal|""
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|el_rl_prompt
argument_list|,
name|prompt
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|el_rl_prompt
argument_list|)
expr_stmt|;
name|el_rl_prompt
operator|=
name|strdup
argument_list|(
name|prompt
argument_list|)
expr_stmt|;
block|}
comment|/* get one line from input stream */
name|ret
operator|=
name|el_gets
argument_list|(
name|e
argument_list|,
operator|&
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|&&
name|count
operator|>
literal|0
condition|)
block|{
name|char
modifier|*
name|foo
decl_stmt|;
name|int
name|lastidx
decl_stmt|;
name|foo
operator|=
name|strdup
argument_list|(
name|ret
argument_list|)
expr_stmt|;
name|lastidx
operator|=
name|count
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|foo
index|[
name|lastidx
index|]
operator|==
literal|'\n'
condition|)
name|foo
index|[
name|lastidx
index|]
operator|=
literal|'\0'
expr_stmt|;
name|ret
operator|=
name|foo
expr_stmt|;
block|}
else|else
name|ret
operator|=
name|NULL
expr_stmt|;
name|history
argument_list|(
name|h
argument_list|,
operator|&
name|ev
argument_list|,
name|H_GETSIZE
argument_list|)
expr_stmt|;
name|history_length
operator|=
name|ev
operator|.
name|num
expr_stmt|;
comment|/* LINTED const cast */
return|return
operator|(
name|char
operator|*
operator|)
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * history functions  */
end_comment

begin_comment
comment|/*  * is normally called before application starts to use  * history expansion functions  */
end_comment

begin_function
name|void
name|using_history
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|h
operator|==
name|NULL
operator|||
name|e
operator|==
name|NULL
condition|)
name|rl_initialize
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * substitute ``what'' with ``with'', returning resulting string; if  * globally == 1, substitutes all occurences of what, otherwise only the  * first one  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|_rl_compat_sub
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|,
specifier|const
name|char
modifier|*
name|what
parameter_list|,
specifier|const
name|char
modifier|*
name|with
parameter_list|,
name|int
name|globally
parameter_list|)
block|{
name|char
modifier|*
name|result
decl_stmt|;
specifier|const
name|char
modifier|*
name|temp
decl_stmt|,
modifier|*
name|new
decl_stmt|;
name|int
name|len
decl_stmt|,
name|with_len
decl_stmt|,
name|what_len
decl_stmt|,
name|add
decl_stmt|;
name|size_t
name|size
decl_stmt|,
name|i
decl_stmt|;
name|result
operator|=
name|malloc
argument_list|(
operator|(
name|size
operator|=
literal|16
operator|)
argument_list|)
expr_stmt|;
name|temp
operator|=
name|str
expr_stmt|;
name|with_len
operator|=
name|strlen
argument_list|(
name|with
argument_list|)
expr_stmt|;
name|what_len
operator|=
name|strlen
argument_list|(
name|what
argument_list|)
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|new
operator|=
name|strstr
argument_list|(
name|temp
argument_list|,
name|what
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
condition|)
block|{
name|i
operator|=
name|new
operator|-
name|temp
expr_stmt|;
name|add
operator|=
name|i
operator|+
name|with_len
expr_stmt|;
if|if
condition|(
name|i
operator|+
name|add
operator|+
literal|1
operator|>=
name|size
condition|)
block|{
name|size
operator|+=
name|add
operator|+
literal|1
expr_stmt|;
name|result
operator|=
name|realloc
argument_list|(
name|result
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|strncpy
argument_list|(
operator|&
name|result
index|[
name|len
index|]
argument_list|,
name|temp
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|len
operator|+=
name|i
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
operator|&
name|result
index|[
name|len
index|]
argument_list|,
name|with
argument_list|)
expr_stmt|;
comment|/* safe */
name|len
operator|+=
name|with_len
expr_stmt|;
name|temp
operator|=
name|new
operator|+
name|what_len
expr_stmt|;
block|}
else|else
block|{
name|add
operator|=
name|strlen
argument_list|(
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|+
name|add
operator|+
literal|1
operator|>=
name|size
condition|)
block|{
name|size
operator|+=
name|add
operator|+
literal|1
expr_stmt|;
name|result
operator|=
name|realloc
argument_list|(
name|result
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|strcpy
argument_list|(
operator|&
name|result
index|[
name|len
index|]
argument_list|,
name|temp
argument_list|)
expr_stmt|;
comment|/* safe */
name|len
operator|+=
name|add
expr_stmt|;
name|temp
operator|=
name|NULL
expr_stmt|;
block|}
block|}
do|while
condition|(
name|temp
operator|&&
name|globally
condition|)
do|;
name|result
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * the real function doing history expansion - takes as argument command  * to do and data upon which the command should be executed  * does expansion the way I've understood readline documentation  * word designator ``%'' isn't supported (yet ?)  *  * returns 0 if data was not modified, 1 if it was and 2 if the string  * should be only printed and not executed; in case of error,  * returns -1 and *result points to NULL  * it's callers responsibility to free() string returned in *result  */
end_comment

begin_function
specifier|static
name|int
name|_history_expand_command
parameter_list|(
specifier|const
name|char
modifier|*
name|command
parameter_list|,
name|size_t
name|cmdlen
parameter_list|,
name|char
modifier|*
modifier|*
name|result
parameter_list|)
block|{
name|char
modifier|*
modifier|*
name|arr
decl_stmt|,
modifier|*
name|tempcmd
decl_stmt|,
modifier|*
name|line
decl_stmt|,
modifier|*
name|search
init|=
name|NULL
decl_stmt|,
modifier|*
name|cmd
decl_stmt|;
specifier|const
name|char
modifier|*
name|event_data
init|=
name|NULL
decl_stmt|;
specifier|static
name|char
modifier|*
name|from
init|=
name|NULL
decl_stmt|,
modifier|*
name|to
init|=
name|NULL
decl_stmt|;
name|int
name|start
init|=
operator|-
literal|1
decl_stmt|,
name|end
init|=
operator|-
literal|1
decl_stmt|,
name|max
decl_stmt|,
name|i
decl_stmt|,
name|idx
decl_stmt|;
name|int
name|h_on
init|=
literal|0
decl_stmt|,
name|t_on
init|=
literal|0
decl_stmt|,
name|r_on
init|=
literal|0
decl_stmt|,
name|e_on
init|=
literal|0
decl_stmt|,
name|p_on
init|=
literal|0
decl_stmt|,
name|g_on
init|=
literal|0
decl_stmt|;
name|int
name|event_num
init|=
literal|0
decl_stmt|,
name|retval
decl_stmt|;
name|size_t
name|cmdsize
decl_stmt|;
operator|*
name|result
operator|=
name|NULL
expr_stmt|;
name|cmd
operator|=
name|alloca
argument_list|(
name|cmdlen
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|cmd
argument_list|,
name|command
argument_list|,
name|cmdlen
argument_list|)
expr_stmt|;
name|cmd
index|[
name|cmdlen
index|]
operator|=
literal|0
expr_stmt|;
name|idx
operator|=
literal|1
expr_stmt|;
comment|/* find out which event to take */
if|if
condition|(
name|cmd
index|[
name|idx
index|]
operator|==
name|history_expansion_char
condition|)
block|{
name|event_num
operator|=
name|history_length
expr_stmt|;
name|idx
operator|++
expr_stmt|;
block|}
else|else
block|{
name|int
name|off
decl_stmt|,
name|num
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|off
operator|=
name|idx
expr_stmt|;
while|while
condition|(
name|cmd
index|[
name|off
index|]
operator|&&
operator|!
name|strchr
argument_list|(
literal|":^$*-%"
argument_list|,
name|cmd
index|[
name|off
index|]
argument_list|)
condition|)
name|off
operator|++
expr_stmt|;
name|num
operator|=
name|atoi
argument_list|(
operator|&
name|cmd
index|[
name|idx
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|num
operator|!=
literal|0
condition|)
block|{
name|event_num
operator|=
name|num
expr_stmt|;
if|if
condition|(
name|num
operator|<
literal|0
condition|)
name|event_num
operator|+=
name|history_length
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|int
name|prefix
init|=
literal|1
decl_stmt|,
name|curr_num
decl_stmt|;
name|HistEvent
name|ev
decl_stmt|;
name|len
operator|=
name|off
operator|-
name|idx
expr_stmt|;
if|if
condition|(
name|cmd
index|[
name|idx
index|]
operator|==
literal|'?'
condition|)
block|{
name|idx
operator|++
operator|,
name|len
operator|--
expr_stmt|;
if|if
condition|(
name|cmd
index|[
name|off
operator|-
literal|1
index|]
operator|==
literal|'?'
condition|)
name|len
operator|--
expr_stmt|;
elseif|else
if|if
condition|(
name|cmd
index|[
name|off
index|]
operator|!=
literal|'\n'
operator|&&
name|cmd
index|[
name|off
index|]
operator|!=
literal|'\0'
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|prefix
operator|=
literal|0
expr_stmt|;
block|}
name|search
operator|=
name|alloca
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|search
argument_list|,
operator|&
name|cmd
index|[
name|idx
index|]
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|search
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|history
argument_list|(
name|h
argument_list|,
operator|&
name|ev
argument_list|,
name|H_CURR
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|curr_num
operator|=
name|ev
operator|.
name|num
expr_stmt|;
if|if
condition|(
name|prefix
condition|)
name|retval
operator|=
name|history_search_prefix
argument_list|(
name|search
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
else|else
name|retval
operator|=
name|history_search
argument_list|(
name|search
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|==
operator|-
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|rl_outstream
argument_list|,
literal|"%s: Event not found\n"
argument_list|,
name|search
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|history
argument_list|(
name|h
argument_list|,
operator|&
name|ev
argument_list|,
name|H_CURR
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|event_data
operator|=
name|ev
operator|.
name|str
expr_stmt|;
comment|/* roll back to original position */
name|history
argument_list|(
name|h
argument_list|,
operator|&
name|ev
argument_list|,
name|H_NEXT_EVENT
argument_list|,
name|curr_num
argument_list|)
expr_stmt|;
block|}
name|idx
operator|=
name|off
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|event_data
operator|&&
name|event_num
operator|>=
literal|0
condition|)
block|{
name|HIST_ENTRY
modifier|*
name|rl_he
decl_stmt|;
name|rl_he
operator|=
name|history_get
argument_list|(
name|event_num
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rl_he
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|event_data
operator|=
name|rl_he
operator|->
name|line
expr_stmt|;
block|}
else|else
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|cmd
index|[
name|idx
index|]
operator|!=
literal|':'
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|cmd
operator|+=
name|idx
operator|+
literal|1
expr_stmt|;
comment|/* recognize cmd */
if|if
condition|(
operator|*
name|cmd
operator|==
literal|'^'
condition|)
name|start
operator|=
name|end
operator|=
literal|1
operator|,
name|cmd
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|cmd
operator|==
literal|'$'
condition|)
name|start
operator|=
name|end
operator|=
operator|-
literal|1
operator|,
name|cmd
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|cmd
operator|==
literal|'*'
condition|)
name|start
operator|=
literal|1
operator|,
name|end
operator|=
operator|-
literal|1
operator|,
name|cmd
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|cmd
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|temp
decl_stmt|;
name|int
name|shifted
init|=
literal|0
decl_stmt|;
name|start
operator|=
name|atoi
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|temp
operator|=
name|cmd
expr_stmt|;
for|for
control|(
init|;
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|cmd
argument_list|)
condition|;
name|cmd
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|temp
operator|!=
name|cmd
condition|)
name|shifted
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|shifted
operator|&&
operator|*
name|cmd
operator|==
literal|'-'
condition|)
block|{
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
operator|(
name|cmd
operator|+
literal|1
operator|)
argument_list|)
condition|)
name|end
operator|=
operator|-
literal|2
expr_stmt|;
else|else
block|{
name|end
operator|=
name|atoi
argument_list|(
name|cmd
operator|+
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|cmd
argument_list|)
condition|;
name|cmd
operator|++
control|)
empty_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|shifted
operator|&&
operator|*
name|cmd
operator|==
literal|'*'
condition|)
name|end
operator|=
operator|-
literal|1
operator|,
name|cmd
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|shifted
condition|)
name|end
operator|=
name|start
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|cmd
operator|==
literal|':'
condition|)
name|cmd
operator|++
expr_stmt|;
name|line
operator|=
name|strdup
argument_list|(
name|event_data
argument_list|)
expr_stmt|;
for|for
control|(
init|;
operator|*
name|cmd
condition|;
name|cmd
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|cmd
operator|==
literal|':'
condition|)
continue|continue;
elseif|else
if|if
condition|(
operator|*
name|cmd
operator|==
literal|'h'
condition|)
name|h_on
operator|=
literal|1
operator||
name|g_on
operator|,
name|g_on
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|cmd
operator|==
literal|'t'
condition|)
name|t_on
operator|=
literal|1
operator||
name|g_on
operator|,
name|g_on
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|cmd
operator|==
literal|'r'
condition|)
name|r_on
operator|=
literal|1
operator||
name|g_on
operator|,
name|g_on
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|cmd
operator|==
literal|'e'
condition|)
name|e_on
operator|=
literal|1
operator||
name|g_on
operator|,
name|g_on
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|cmd
operator|==
literal|'p'
condition|)
name|p_on
operator|=
literal|1
operator||
name|g_on
operator|,
name|g_on
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|cmd
operator|==
literal|'g'
condition|)
name|g_on
operator|=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|cmd
operator|==
literal|'s'
operator|||
operator|*
name|cmd
operator|==
literal|'&'
condition|)
block|{
name|char
modifier|*
name|what
decl_stmt|,
modifier|*
name|with
decl_stmt|,
name|delim
decl_stmt|;
name|int
name|len
decl_stmt|,
name|from_len
decl_stmt|;
name|size_t
name|size
decl_stmt|;
if|if
condition|(
operator|*
name|cmd
operator|==
literal|'&'
operator|&&
operator|(
name|from
operator|==
name|NULL
operator|||
name|to
operator|==
name|NULL
operator|)
condition|)
continue|continue;
elseif|else
if|if
condition|(
operator|*
name|cmd
operator|==
literal|'s'
condition|)
block|{
name|delim
operator|=
operator|*
operator|(
operator|++
name|cmd
operator|)
operator|,
name|cmd
operator|++
expr_stmt|;
name|size
operator|=
literal|16
expr_stmt|;
name|what
operator|=
name|realloc
argument_list|(
name|from
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
operator|*
name|cmd
operator|&&
operator|*
name|cmd
operator|!=
name|delim
condition|;
name|cmd
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|cmd
operator|==
literal|'\\'
operator|&&
operator|*
operator|(
name|cmd
operator|+
literal|1
operator|)
operator|==
name|delim
condition|)
name|cmd
operator|++
expr_stmt|;
if|if
condition|(
name|len
operator|>=
name|size
condition|)
name|what
operator|=
name|realloc
argument_list|(
name|what
argument_list|,
operator|(
name|size
operator|<<=
literal|1
operator|)
argument_list|)
expr_stmt|;
name|what
index|[
name|len
operator|++
index|]
operator|=
operator|*
name|cmd
expr_stmt|;
block|}
name|what
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|from
operator|=
name|what
expr_stmt|;
if|if
condition|(
operator|*
name|what
operator|==
literal|'\0'
condition|)
block|{
name|free
argument_list|(
name|what
argument_list|)
expr_stmt|;
if|if
condition|(
name|search
condition|)
name|from
operator|=
name|strdup
argument_list|(
name|search
argument_list|)
expr_stmt|;
else|else
block|{
name|from
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
name|cmd
operator|++
expr_stmt|;
comment|/* shift after delim */
if|if
condition|(
operator|!
operator|*
name|cmd
condition|)
continue|continue;
name|size
operator|=
literal|16
expr_stmt|;
name|with
operator|=
name|realloc
argument_list|(
name|to
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
name|from_len
operator|=
name|strlen
argument_list|(
name|from
argument_list|)
expr_stmt|;
for|for
control|(
init|;
operator|*
name|cmd
operator|&&
operator|*
name|cmd
operator|!=
name|delim
condition|;
name|cmd
operator|++
control|)
block|{
if|if
condition|(
name|len
operator|+
name|from_len
operator|+
literal|1
operator|>=
name|size
condition|)
block|{
name|size
operator|+=
name|from_len
operator|+
literal|1
expr_stmt|;
name|with
operator|=
name|realloc
argument_list|(
name|with
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|cmd
operator|==
literal|'&'
condition|)
block|{
comment|/* safe */
operator|(
name|void
operator|)
name|strcpy
argument_list|(
operator|&
name|with
index|[
name|len
index|]
argument_list|,
name|from
argument_list|)
expr_stmt|;
name|len
operator|+=
name|from_len
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|*
name|cmd
operator|==
literal|'\\'
operator|&&
operator|(
operator|*
operator|(
name|cmd
operator|+
literal|1
operator|)
operator|==
name|delim
operator|||
operator|*
operator|(
name|cmd
operator|+
literal|1
operator|)
operator|==
literal|'&'
operator|)
condition|)
name|cmd
operator|++
expr_stmt|;
name|with
index|[
name|len
operator|++
index|]
operator|=
operator|*
name|cmd
expr_stmt|;
block|}
name|with
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|to
operator|=
name|with
expr_stmt|;
name|tempcmd
operator|=
name|_rl_compat_sub
argument_list|(
name|line
argument_list|,
name|from
argument_list|,
name|to
argument_list|,
operator|(
name|g_on
operator|)
condition|?
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|line
operator|=
name|tempcmd
expr_stmt|;
name|g_on
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
name|arr
operator|=
name|history_tokenize
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|line
argument_list|)
expr_stmt|;
comment|/* no more needed */
if|if
condition|(
name|arr
operator|&&
operator|*
name|arr
operator|==
name|NULL
condition|)
name|free
argument_list|(
name|arr
argument_list|)
operator|,
name|arr
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|arr
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* find out max valid idx to array of array */
name|max
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|arr
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
name|max
operator|++
expr_stmt|;
name|max
operator|--
expr_stmt|;
comment|/* set boundaries to something relevant */
if|if
condition|(
name|start
operator|<
literal|0
condition|)
name|start
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|end
operator|<
literal|0
condition|)
name|end
operator|=
name|max
operator|-
operator|(
operator|(
name|end
operator|<
operator|-
literal|1
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
expr_stmt|;
comment|/* check boundaries ... */
if|if
condition|(
name|start
operator|>
name|max
operator|||
name|end
operator|>
name|max
operator|||
name|start
operator|>
name|end
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|max
condition|;
name|i
operator|++
control|)
block|{
name|char
modifier|*
name|temp
decl_stmt|;
if|if
condition|(
name|h_on
operator|&&
operator|(
name|i
operator|==
literal|1
operator|||
name|h_on
operator|>
literal|1
operator|)
operator|&&
operator|(
name|temp
operator|=
name|strrchr
argument_list|(
name|arr
index|[
name|i
index|]
argument_list|,
literal|'/'
argument_list|)
operator|)
condition|)
operator|*
operator|(
name|temp
operator|+
literal|1
operator|)
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|t_on
operator|&&
operator|(
name|i
operator|==
literal|1
operator|||
name|t_on
operator|>
literal|1
operator|)
operator|&&
operator|(
name|temp
operator|=
name|strrchr
argument_list|(
name|arr
index|[
name|i
index|]
argument_list|,
literal|'/'
argument_list|)
operator|)
condition|)
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|arr
index|[
name|i
index|]
argument_list|,
name|temp
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_on
operator|&&
operator|(
name|i
operator|==
literal|1
operator|||
name|r_on
operator|>
literal|1
operator|)
operator|&&
operator|(
name|temp
operator|=
name|strrchr
argument_list|(
name|arr
index|[
name|i
index|]
argument_list|,
literal|'.'
argument_list|)
operator|)
condition|)
operator|*
name|temp
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|e_on
operator|&&
operator|(
name|i
operator|==
literal|1
operator|||
name|e_on
operator|>
literal|1
operator|)
operator|&&
operator|(
name|temp
operator|=
name|strrchr
argument_list|(
name|arr
index|[
name|i
index|]
argument_list|,
literal|'.'
argument_list|)
operator|)
condition|)
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|arr
index|[
name|i
index|]
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
name|cmdsize
operator|=
literal|1
operator|,
name|cmdlen
operator|=
literal|0
expr_stmt|;
name|tempcmd
operator|=
name|malloc
argument_list|(
name|cmdsize
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|start
init|;
name|start
operator|<=
name|i
operator|&&
name|i
operator|<=
name|end
condition|;
name|i
operator|++
control|)
block|{
name|int
name|arr_len
decl_stmt|;
name|arr_len
operator|=
name|strlen
argument_list|(
name|arr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmdlen
operator|+
name|arr_len
operator|+
literal|1
operator|>=
name|cmdsize
condition|)
block|{
name|cmdsize
operator|+=
name|arr_len
operator|+
literal|1
expr_stmt|;
name|tempcmd
operator|=
name|realloc
argument_list|(
name|tempcmd
argument_list|,
name|cmdsize
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|strcpy
argument_list|(
operator|&
name|tempcmd
index|[
name|cmdlen
index|]
argument_list|,
name|arr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* safe */
name|cmdlen
operator|+=
name|arr_len
expr_stmt|;
name|tempcmd
index|[
name|cmdlen
operator|++
index|]
operator|=
literal|' '
expr_stmt|;
comment|/* add a space */
block|}
while|while
condition|(
name|cmdlen
operator|>
literal|0
operator|&&
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|tempcmd
index|[
name|cmdlen
operator|-
literal|1
index|]
argument_list|)
condition|)
name|cmdlen
operator|--
expr_stmt|;
name|tempcmd
index|[
name|cmdlen
index|]
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|result
operator|=
name|tempcmd
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|max
condition|;
name|i
operator|++
control|)
name|free
argument_list|(
name|arr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|arr
argument_list|)
operator|,
name|arr
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
expr_stmt|;
return|return
operator|(
name|p_on
operator|)
condition|?
literal|2
else|:
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * csh-style history expansion  */
end_comment

begin_function
name|int
name|history_expand
parameter_list|(
name|char
modifier|*
name|str
parameter_list|,
name|char
modifier|*
modifier|*
name|output
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|retval
init|=
literal|0
decl_stmt|,
name|idx
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|char
modifier|*
name|temp
decl_stmt|,
modifier|*
name|result
decl_stmt|;
if|if
condition|(
name|h
operator|==
name|NULL
operator|||
name|e
operator|==
name|NULL
condition|)
name|rl_initialize
argument_list|()
expr_stmt|;
operator|*
name|output
operator|=
name|strdup
argument_list|(
name|str
argument_list|)
expr_stmt|;
comment|/* do it early */
if|if
condition|(
name|str
index|[
literal|0
index|]
operator|==
name|history_subst_char
condition|)
block|{
comment|/* ^foo^foo2^ is equivalent to !!:s^foo^foo2^ */
name|temp
operator|=
name|alloca
argument_list|(
literal|4
operator|+
name|strlen
argument_list|(
name|str
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|temp
index|[
literal|0
index|]
operator|=
name|temp
index|[
literal|1
index|]
operator|=
name|history_expansion_char
expr_stmt|;
name|temp
index|[
literal|2
index|]
operator|=
literal|':'
expr_stmt|;
name|temp
index|[
literal|3
index|]
operator|=
literal|'s'
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|temp
operator|+
literal|4
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|str
operator|=
name|temp
expr_stmt|;
block|}
define|#
directive|define
name|ADD_STRING
parameter_list|(
name|what
parameter_list|,
name|len
parameter_list|)
define|\
value|{								\ 		if (idx + len + 1> size)				\ 			result = realloc(result, (size += len + 1));	\ 		(void)strncpy(&result[idx], what, len);			\ 		idx += len;						\ 		result[idx] = '\0';					\ 	}
name|result
operator|=
name|NULL
expr_stmt|;
name|size
operator|=
name|idx
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|str
index|[
name|i
index|]
condition|;
control|)
block|{
name|int
name|start
decl_stmt|,
name|j
decl_stmt|,
name|loop_again
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|loop_again
operator|=
literal|1
expr_stmt|;
name|start
operator|=
name|j
operator|=
name|i
expr_stmt|;
name|loop
label|:
for|for
control|(
init|;
name|str
index|[
name|j
index|]
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|str
index|[
name|j
index|]
operator|==
literal|'\\'
operator|&&
name|str
index|[
name|j
operator|+
literal|1
index|]
operator|==
name|history_expansion_char
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
operator|&
name|str
index|[
name|j
index|]
argument_list|,
operator|&
name|str
index|[
name|j
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|loop_again
condition|)
block|{
if|if
condition|(
name|str
index|[
name|j
index|]
operator|==
literal|'?'
condition|)
block|{
while|while
condition|(
name|str
index|[
name|j
index|]
operator|&&
name|str
index|[
operator|++
name|j
index|]
operator|!=
literal|'?'
condition|)
empty_stmt|;
if|if
condition|(
name|str
index|[
name|j
index|]
operator|==
literal|'?'
condition|)
name|j
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|str
index|[
name|j
index|]
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|str
index|[
name|j
index|]
operator|==
name|history_expansion_char
operator|&&
operator|!
name|strchr
argument_list|(
name|history_no_expand_chars
argument_list|,
name|str
index|[
name|j
operator|+
literal|1
index|]
argument_list|)
operator|&&
operator|(
operator|!
name|history_inhibit_expansion_function
operator|||
call|(
modifier|*
name|history_inhibit_expansion_function
call|)
argument_list|(
name|str
argument_list|,
name|j
argument_list|)
operator|==
literal|0
operator|)
condition|)
break|break;
block|}
if|if
condition|(
name|str
index|[
name|j
index|]
operator|&&
name|str
index|[
name|j
operator|+
literal|1
index|]
operator|!=
literal|'#'
operator|&&
name|loop_again
condition|)
block|{
name|i
operator|=
name|j
expr_stmt|;
name|j
operator|++
expr_stmt|;
if|if
condition|(
name|str
index|[
name|j
index|]
operator|==
name|history_expansion_char
condition|)
name|j
operator|++
expr_stmt|;
name|loop_again
operator|=
literal|0
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
name|len
operator|=
name|i
operator|-
name|start
expr_stmt|;
name|temp
operator|=
operator|&
name|str
index|[
name|start
index|]
expr_stmt|;
name|ADD_STRING
argument_list|(
name|temp
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|str
index|[
name|i
index|]
operator|==
literal|'\0'
operator|||
name|str
index|[
name|i
index|]
operator|!=
name|history_expansion_char
operator|||
name|str
index|[
name|i
operator|+
literal|1
index|]
operator|==
literal|'#'
condition|)
block|{
name|len
operator|=
name|j
operator|-
name|i
expr_stmt|;
name|temp
operator|=
operator|&
name|str
index|[
name|i
index|]
expr_stmt|;
name|ADD_STRING
argument_list|(
name|temp
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|start
operator|==
literal|0
condition|)
name|retval
operator|=
literal|0
expr_stmt|;
else|else
name|retval
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|retval
operator|=
name|_history_expand_command
argument_list|(
operator|&
name|str
index|[
name|i
index|]
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|j
operator|-
name|i
argument_list|)
argument_list|,
operator|&
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
operator|-
literal|1
condition|)
block|{
name|len
operator|=
name|strlen
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|ADD_STRING
argument_list|(
name|temp
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
name|i
operator|=
name|j
expr_stmt|;
block|}
comment|/* for(i ...) */
if|if
condition|(
name|retval
operator|==
literal|2
condition|)
block|{
name|add_history
argument_list|(
name|temp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|GDB_411_HACK
comment|/* gdb 4.11 has been shipped with readline, where */
comment|/* history_expand() returned -1 when the line	  */
comment|/* should not be executed; in readline 2.1+	  */
comment|/* it should return 2 in such a case		  */
name|retval
operator|=
operator|-
literal|1
expr_stmt|;
endif|#
directive|endif
block|}
name|free
argument_list|(
operator|*
name|output
argument_list|)
expr_stmt|;
operator|*
name|output
operator|=
name|result
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Parse the string into individual tokens, similarily to how shell would do it.  */
end_comment

begin_function
name|char
modifier|*
modifier|*
name|history_tokenize
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
name|int
name|size
init|=
literal|1
decl_stmt|,
name|result_idx
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|,
name|start
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|char
modifier|*
modifier|*
name|result
init|=
name|NULL
decl_stmt|,
modifier|*
name|temp
decl_stmt|,
name|delim
init|=
literal|'\0'
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|str
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
while|while
condition|(
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|str
index|[
name|i
index|]
argument_list|)
condition|)
name|i
operator|++
expr_stmt|;
name|start
operator|=
name|i
expr_stmt|;
for|for
control|(
init|;
name|str
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|str
index|[
name|i
index|]
operator|==
literal|'\\'
condition|)
block|{
if|if
condition|(
name|str
index|[
name|i
operator|+
literal|1
index|]
operator|!=
literal|'\0'
condition|)
name|i
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|str
index|[
name|i
index|]
operator|==
name|delim
condition|)
name|delim
operator|=
literal|'\0'
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|delim
operator|&&
operator|(
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|str
index|[
name|i
index|]
argument_list|)
operator|||
name|strchr
argument_list|(
literal|"()<>;&|$"
argument_list|,
name|str
index|[
name|i
index|]
argument_list|)
operator|)
condition|)
break|break;
elseif|else
if|if
condition|(
operator|!
name|delim
operator|&&
name|strchr
argument_list|(
literal|"'`\""
argument_list|,
name|str
index|[
name|i
index|]
argument_list|)
condition|)
name|delim
operator|=
name|str
index|[
name|i
index|]
expr_stmt|;
block|}
if|if
condition|(
name|result_idx
operator|+
literal|2
operator|>=
name|size
condition|)
block|{
name|size
operator|<<=
literal|1
expr_stmt|;
name|result
operator|=
name|realloc
argument_list|(
name|result
argument_list|,
name|size
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|len
operator|=
name|i
operator|-
name|start
expr_stmt|;
name|temp
operator|=
name|malloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|temp
argument_list|,
operator|&
name|str
index|[
name|start
index|]
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|temp
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|result
index|[
name|result_idx
operator|++
index|]
operator|=
name|temp
expr_stmt|;
name|result
index|[
name|result_idx
index|]
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * limit size of history record to ``max'' events  */
end_comment

begin_function
name|void
name|stifle_history
parameter_list|(
name|int
name|max
parameter_list|)
block|{
name|HistEvent
name|ev
decl_stmt|;
if|if
condition|(
name|h
operator|==
name|NULL
operator|||
name|e
operator|==
name|NULL
condition|)
name|rl_initialize
argument_list|()
expr_stmt|;
if|if
condition|(
name|history
argument_list|(
name|h
argument_list|,
operator|&
name|ev
argument_list|,
name|H_SETSIZE
argument_list|,
name|max
argument_list|)
operator|==
literal|0
condition|)
name|max_input_history
operator|=
name|max
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * "unlimit" size of history - set the limit to maximum allowed int value  */
end_comment

begin_function
name|int
name|unstifle_history
parameter_list|(
name|void
parameter_list|)
block|{
name|HistEvent
name|ev
decl_stmt|;
name|int
name|omax
decl_stmt|;
name|history
argument_list|(
name|h
argument_list|,
operator|&
name|ev
argument_list|,
name|H_SETSIZE
argument_list|,
name|INT_MAX
argument_list|)
expr_stmt|;
name|omax
operator|=
name|max_input_history
expr_stmt|;
name|max_input_history
operator|=
name|INT_MAX
expr_stmt|;
return|return
operator|(
name|omax
operator|)
return|;
comment|/* some value _must_ be returned */
block|}
end_function

begin_function
name|int
name|history_is_stifled
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* cannot return true answer */
return|return
operator|(
name|max_input_history
operator|!=
name|INT_MAX
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * read history from a file given  */
end_comment

begin_function
name|int
name|read_history
parameter_list|(
specifier|const
name|char
modifier|*
name|filename
parameter_list|)
block|{
name|HistEvent
name|ev
decl_stmt|;
if|if
condition|(
name|h
operator|==
name|NULL
operator|||
name|e
operator|==
name|NULL
condition|)
name|rl_initialize
argument_list|()
expr_stmt|;
return|return
operator|(
name|history
argument_list|(
name|h
argument_list|,
operator|&
name|ev
argument_list|,
name|H_LOAD
argument_list|,
name|filename
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * write history to a file given  */
end_comment

begin_function
name|int
name|write_history
parameter_list|(
specifier|const
name|char
modifier|*
name|filename
parameter_list|)
block|{
name|HistEvent
name|ev
decl_stmt|;
if|if
condition|(
name|h
operator|==
name|NULL
operator|||
name|e
operator|==
name|NULL
condition|)
name|rl_initialize
argument_list|()
expr_stmt|;
return|return
operator|(
name|history
argument_list|(
name|h
argument_list|,
operator|&
name|ev
argument_list|,
name|H_SAVE
argument_list|,
name|filename
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * returns history ``num''th event  *  * returned pointer points to static variable  */
end_comment

begin_function
name|HIST_ENTRY
modifier|*
name|history_get
parameter_list|(
name|int
name|num
parameter_list|)
block|{
specifier|static
name|HIST_ENTRY
name|she
decl_stmt|;
name|HistEvent
name|ev
decl_stmt|;
name|int
name|i
init|=
literal|1
decl_stmt|,
name|curr_num
decl_stmt|;
if|if
condition|(
name|h
operator|==
name|NULL
operator|||
name|e
operator|==
name|NULL
condition|)
name|rl_initialize
argument_list|()
expr_stmt|;
comment|/* rewind to beginning */
if|if
condition|(
name|history
argument_list|(
name|h
argument_list|,
operator|&
name|ev
argument_list|,
name|H_CURR
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|curr_num
operator|=
name|ev
operator|.
name|num
expr_stmt|;
if|if
condition|(
name|history
argument_list|(
name|h
argument_list|,
operator|&
name|ev
argument_list|,
name|H_LAST
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* error */
while|while
condition|(
name|i
operator|<
name|num
operator|&&
name|history
argument_list|(
name|h
argument_list|,
operator|&
name|ev
argument_list|,
name|H_PREV
argument_list|)
operator|==
literal|0
condition|)
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|num
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* not so many entries */
name|she
operator|.
name|line
operator|=
name|ev
operator|.
name|str
expr_stmt|;
name|she
operator|.
name|data
operator|=
name|NULL
expr_stmt|;
comment|/* rewind history to the same event it was before */
operator|(
name|void
operator|)
name|history
argument_list|(
name|h
argument_list|,
operator|&
name|ev
argument_list|,
name|H_FIRST
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|history
argument_list|(
name|h
argument_list|,
operator|&
name|ev
argument_list|,
name|H_NEXT_EVENT
argument_list|,
name|curr_num
argument_list|)
expr_stmt|;
return|return
operator|(
operator|&
name|she
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * add the line to history table  */
end_comment

begin_function
name|int
name|add_history
parameter_list|(
specifier|const
name|char
modifier|*
name|line
parameter_list|)
block|{
name|HistEvent
name|ev
decl_stmt|;
if|if
condition|(
name|h
operator|==
name|NULL
operator|||
name|e
operator|==
name|NULL
condition|)
name|rl_initialize
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|history
argument_list|(
name|h
argument_list|,
operator|&
name|ev
argument_list|,
name|H_ENTER
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|history
argument_list|(
name|h
argument_list|,
operator|&
name|ev
argument_list|,
name|H_GETSIZE
argument_list|)
operator|==
literal|0
condition|)
name|history_length
operator|=
name|ev
operator|.
name|num
expr_stmt|;
return|return
operator|(
operator|!
operator|(
name|history_length
operator|>
literal|0
operator|)
operator|)
return|;
comment|/* return 0 if all is okay */
block|}
end_function

begin_comment
comment|/*  * clear the history list - delete all entries  */
end_comment

begin_function
name|void
name|clear_history
parameter_list|(
name|void
parameter_list|)
block|{
name|HistEvent
name|ev
decl_stmt|;
name|history
argument_list|(
name|h
argument_list|,
operator|&
name|ev
argument_list|,
name|H_CLEAR
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * returns offset of the current history event  */
end_comment

begin_function
name|int
name|where_history
parameter_list|(
name|void
parameter_list|)
block|{
name|HistEvent
name|ev
decl_stmt|;
name|int
name|curr_num
decl_stmt|,
name|off
decl_stmt|;
if|if
condition|(
name|history
argument_list|(
name|h
argument_list|,
operator|&
name|ev
argument_list|,
name|H_CURR
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|curr_num
operator|=
name|ev
operator|.
name|num
expr_stmt|;
name|history
argument_list|(
name|h
argument_list|,
operator|&
name|ev
argument_list|,
name|H_FIRST
argument_list|)
expr_stmt|;
name|off
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|ev
operator|.
name|num
operator|!=
name|curr_num
operator|&&
name|history
argument_list|(
name|h
argument_list|,
operator|&
name|ev
argument_list|,
name|H_NEXT
argument_list|)
operator|==
literal|0
condition|)
name|off
operator|++
expr_stmt|;
return|return
operator|(
name|off
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * returns current history event or NULL if there is no such event  */
end_comment

begin_function
name|HIST_ENTRY
modifier|*
name|current_history
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|_move_history
argument_list|(
name|H_CURR
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * returns total number of bytes history events' data are using  */
end_comment

begin_function
name|int
name|history_total_bytes
parameter_list|(
name|void
parameter_list|)
block|{
name|HistEvent
name|ev
decl_stmt|;
name|int
name|curr_num
decl_stmt|,
name|size
decl_stmt|;
if|if
condition|(
name|history
argument_list|(
name|h
argument_list|,
operator|&
name|ev
argument_list|,
name|H_CURR
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|curr_num
operator|=
name|ev
operator|.
name|num
expr_stmt|;
name|history
argument_list|(
name|h
argument_list|,
operator|&
name|ev
argument_list|,
name|H_FIRST
argument_list|)
expr_stmt|;
name|size
operator|=
literal|0
expr_stmt|;
do|do
name|size
operator|+=
name|strlen
argument_list|(
name|ev
operator|.
name|str
argument_list|)
expr_stmt|;
do|while
condition|(
name|history
argument_list|(
name|h
argument_list|,
operator|&
name|ev
argument_list|,
name|H_NEXT
argument_list|)
operator|==
literal|0
condition|)
do|;
comment|/* get to the same position as before */
name|history
argument_list|(
name|h
argument_list|,
operator|&
name|ev
argument_list|,
name|H_PREV_EVENT
argument_list|,
name|curr_num
argument_list|)
expr_stmt|;
return|return
operator|(
name|size
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * sets the position in the history list to ``pos''  */
end_comment

begin_function
name|int
name|history_set_pos
parameter_list|(
name|int
name|pos
parameter_list|)
block|{
name|HistEvent
name|ev
decl_stmt|;
name|int
name|off
decl_stmt|,
name|curr_num
decl_stmt|;
if|if
condition|(
name|pos
operator|>
name|history_length
operator|||
name|pos
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|history
argument_list|(
name|h
argument_list|,
operator|&
name|ev
argument_list|,
name|H_CURR
argument_list|)
expr_stmt|;
name|curr_num
operator|=
name|ev
operator|.
name|num
expr_stmt|;
name|history
argument_list|(
name|h
argument_list|,
operator|&
name|ev
argument_list|,
name|H_FIRST
argument_list|)
expr_stmt|;
name|off
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|off
operator|<
name|pos
operator|&&
name|history
argument_list|(
name|h
argument_list|,
operator|&
name|ev
argument_list|,
name|H_NEXT
argument_list|)
operator|==
literal|0
condition|)
name|off
operator|++
expr_stmt|;
if|if
condition|(
name|off
operator|!=
name|pos
condition|)
block|{
comment|/* do a rollback in case of error */
name|history
argument_list|(
name|h
argument_list|,
operator|&
name|ev
argument_list|,
name|H_FIRST
argument_list|)
expr_stmt|;
name|history
argument_list|(
name|h
argument_list|,
operator|&
name|ev
argument_list|,
name|H_NEXT_EVENT
argument_list|,
name|curr_num
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * returns previous event in history and shifts pointer accordingly  */
end_comment

begin_function
name|HIST_ENTRY
modifier|*
name|previous_history
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|_move_history
argument_list|(
name|H_PREV
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * returns next event in history and shifts pointer accordingly  */
end_comment

begin_function
name|HIST_ENTRY
modifier|*
name|next_history
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|_move_history
argument_list|(
name|H_NEXT
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * generic history search function  */
end_comment

begin_function
specifier|static
name|int
name|_history_search_gen
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|int
name|direction
parameter_list|,
name|int
name|pos
parameter_list|)
block|{
name|HistEvent
name|ev
decl_stmt|;
specifier|const
name|char
modifier|*
name|strp
decl_stmt|;
name|int
name|curr_num
decl_stmt|;
if|if
condition|(
name|history
argument_list|(
name|h
argument_list|,
operator|&
name|ev
argument_list|,
name|H_CURR
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|curr_num
operator|=
name|ev
operator|.
name|num
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|strp
operator|=
name|strstr
argument_list|(
name|ev
operator|.
name|str
argument_list|,
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|strp
operator|&&
operator|(
name|pos
operator|<
literal|0
operator|||
operator|&
name|ev
operator|.
name|str
index|[
name|pos
index|]
operator|==
name|strp
operator|)
condition|)
return|return
call|(
name|int
call|)
argument_list|(
name|strp
operator|-
name|ev
operator|.
name|str
argument_list|)
return|;
if|if
condition|(
name|history
argument_list|(
name|h
argument_list|,
operator|&
name|ev
argument_list|,
name|direction
operator|<
literal|0
condition|?
name|H_PREV
else|:
name|H_NEXT
argument_list|)
operator|!=
literal|0
condition|)
break|break;
block|}
name|history
argument_list|(
name|h
argument_list|,
operator|&
name|ev
argument_list|,
name|direction
operator|<
literal|0
condition|?
name|H_NEXT_EVENT
else|:
name|H_PREV_EVENT
argument_list|,
name|curr_num
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * searches for first history event containing the str  */
end_comment

begin_function
name|int
name|history_search
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|int
name|direction
parameter_list|)
block|{
return|return
operator|(
name|_history_search_gen
argument_list|(
name|str
argument_list|,
name|direction
argument_list|,
operator|-
literal|1
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * searches for first history event beginning with str  */
end_comment

begin_function
name|int
name|history_search_prefix
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|int
name|direction
parameter_list|)
block|{
return|return
operator|(
name|_history_search_gen
argument_list|(
name|str
argument_list|,
name|direction
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * search for event in history containing str, starting at offset  * abs(pos); continue backward, if pos<0, forward otherwise  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|history_search_pos
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|int
name|direction
parameter_list|,
name|int
name|pos
parameter_list|)
block|{
name|HistEvent
name|ev
decl_stmt|;
name|int
name|curr_num
decl_stmt|,
name|off
decl_stmt|;
name|off
operator|=
operator|(
name|pos
operator|>
literal|0
operator|)
condition|?
name|pos
else|:
operator|-
name|pos
expr_stmt|;
name|pos
operator|=
operator|(
name|pos
operator|>
literal|0
operator|)
condition|?
literal|1
else|:
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|history
argument_list|(
name|h
argument_list|,
operator|&
name|ev
argument_list|,
name|H_CURR
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|curr_num
operator|=
name|ev
operator|.
name|num
expr_stmt|;
if|if
condition|(
name|history_set_pos
argument_list|(
name|off
argument_list|)
operator|!=
literal|0
operator|||
name|history
argument_list|(
name|h
argument_list|,
operator|&
name|ev
argument_list|,
name|H_CURR
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|strstr
argument_list|(
name|ev
operator|.
name|str
argument_list|,
name|str
argument_list|)
condition|)
return|return
operator|(
name|off
operator|)
return|;
if|if
condition|(
name|history
argument_list|(
name|h
argument_list|,
operator|&
name|ev
argument_list|,
operator|(
name|pos
operator|<
literal|0
operator|)
condition|?
name|H_PREV
else|:
name|H_NEXT
argument_list|)
operator|!=
literal|0
condition|)
break|break;
block|}
comment|/* set "current" pointer back to previous state */
name|history
argument_list|(
name|h
argument_list|,
operator|&
name|ev
argument_list|,
operator|(
name|pos
operator|<
literal|0
operator|)
condition|?
name|H_NEXT_EVENT
else|:
name|H_PREV_EVENT
argument_list|,
name|curr_num
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/********************************/
end_comment

begin_comment
comment|/* completition functions	*/
end_comment

begin_comment
comment|/*  * does tilde expansion of strings of type ``~user/foo''  * if ``user'' isn't valid user name or ``txt'' doesn't start  * w/ '~', returns pointer to strdup()ed copy of ``txt''  *  * it's callers's responsibility to free() returned string  */
end_comment

begin_function
name|char
modifier|*
name|tilde_expand
parameter_list|(
name|char
modifier|*
name|txt
parameter_list|)
block|{
name|struct
name|passwd
modifier|*
name|pass
decl_stmt|;
name|char
modifier|*
name|temp
decl_stmt|;
name|size_t
name|len
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|txt
index|[
literal|0
index|]
operator|!=
literal|'~'
condition|)
return|return
operator|(
name|strdup
argument_list|(
name|txt
argument_list|)
operator|)
return|;
name|temp
operator|=
name|strchr
argument_list|(
name|txt
operator|+
literal|1
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|==
name|NULL
condition|)
name|temp
operator|=
name|strdup
argument_list|(
name|txt
operator|+
literal|1
argument_list|)
expr_stmt|;
else|else
block|{
name|len
operator|=
name|temp
operator|-
name|txt
operator|+
literal|1
expr_stmt|;
comment|/* text until string after slash */
name|temp
operator|=
name|malloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|temp
argument_list|,
name|txt
operator|+
literal|1
argument_list|,
name|len
operator|-
literal|2
argument_list|)
expr_stmt|;
name|temp
index|[
name|len
operator|-
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
name|pass
operator|=
name|getpwnam
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
comment|/* value no more needed */
if|if
condition|(
name|pass
operator|==
name|NULL
condition|)
return|return
operator|(
name|strdup
argument_list|(
name|txt
argument_list|)
operator|)
return|;
comment|/* update pointer txt to point at string immedially following */
comment|/* first slash */
name|txt
operator|+=
name|len
expr_stmt|;
name|temp
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|pass
operator|->
name|pw_dir
argument_list|)
operator|+
literal|1
operator|+
name|strlen
argument_list|(
name|txt
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"%s/%s"
argument_list|,
name|pass
operator|->
name|pw_dir
argument_list|,
name|txt
argument_list|)
expr_stmt|;
return|return
operator|(
name|temp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * return first found file name starting by the ``text'' or NULL if no  * such file can be found  * value of ``state'' is ignored  *  * it's caller's responsibility to free returned string  */
end_comment

begin_function
name|char
modifier|*
name|filename_completion_function
parameter_list|(
specifier|const
name|char
modifier|*
name|text
parameter_list|,
name|int
name|state
parameter_list|)
block|{
specifier|static
name|DIR
modifier|*
name|dir
init|=
name|NULL
decl_stmt|;
specifier|static
name|char
modifier|*
name|filename
init|=
name|NULL
decl_stmt|,
modifier|*
name|dirname
init|=
name|NULL
decl_stmt|;
specifier|static
name|size_t
name|filename_len
init|=
literal|0
decl_stmt|;
name|struct
name|dirent
modifier|*
name|entry
decl_stmt|;
name|char
modifier|*
name|temp
decl_stmt|;
name|size_t
name|len
decl_stmt|;
if|if
condition|(
name|state
operator|==
literal|0
operator|||
name|dir
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|dir
operator|!=
name|NULL
condition|)
block|{
name|closedir
argument_list|(
name|dir
argument_list|)
expr_stmt|;
name|dir
operator|=
name|NULL
expr_stmt|;
block|}
name|temp
operator|=
name|strrchr
argument_list|(
name|text
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
condition|)
block|{
name|temp
operator|++
expr_stmt|;
name|filename
operator|=
name|realloc
argument_list|(
name|filename
argument_list|,
name|strlen
argument_list|(
name|temp
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|filename
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|len
operator|=
name|temp
operator|-
name|text
expr_stmt|;
comment|/* including last slash */
name|dirname
operator|=
name|realloc
argument_list|(
name|dirname
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|dirname
argument_list|,
name|text
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|dirname
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
block|{
name|filename
operator|=
name|strdup
argument_list|(
name|text
argument_list|)
expr_stmt|;
name|dirname
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* support for ``~user'' syntax */
if|if
condition|(
name|dirname
operator|&&
operator|*
name|dirname
operator|==
literal|'~'
condition|)
block|{
name|temp
operator|=
name|tilde_expand
argument_list|(
name|dirname
argument_list|)
expr_stmt|;
name|dirname
operator|=
name|realloc
argument_list|(
name|dirname
argument_list|,
name|strlen
argument_list|(
name|temp
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|dirname
argument_list|,
name|temp
argument_list|)
expr_stmt|;
comment|/* safe */
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
comment|/* no longer needed */
block|}
comment|/* will be used in cycle */
name|filename_len
operator|=
name|strlen
argument_list|(
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|filename_len
operator|==
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* no expansion possible */
name|dir
operator|=
name|opendir
argument_list|(
name|dirname
condition|?
name|dirname
else|:
literal|"."
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dir
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* cannot open the directory */
block|}
comment|/* find the match */
while|while
condition|(
operator|(
name|entry
operator|=
name|readdir
argument_list|(
name|dir
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* otherwise, get first entry where first */
comment|/* filename_len characters are equal	  */
if|if
condition|(
name|entry
operator|->
name|d_name
index|[
literal|0
index|]
operator|==
name|filename
index|[
literal|0
index|]
if|#
directive|if
name|defined
argument_list|(
name|__SVR4
argument_list|)
operator|||
name|defined
argument_list|(
name|__linux__
argument_list|)
operator|&&
name|strlen
argument_list|(
name|entry
operator|->
name|d_name
argument_list|)
operator|>=
name|filename_len
else|#
directive|else
operator|&&
name|entry
operator|->
name|d_namlen
operator|>=
name|filename_len
endif|#
directive|endif
operator|&&
name|strncmp
argument_list|(
name|entry
operator|->
name|d_name
argument_list|,
name|filename
argument_list|,
name|filename_len
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|entry
condition|)
block|{
comment|/* match found */
name|struct
name|stat
name|stbuf
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__SVR4
argument_list|)
operator|||
name|defined
argument_list|(
name|__linux__
argument_list|)
name|len
operator|=
name|strlen
argument_list|(
name|entry
operator|->
name|d_name
argument_list|)
operator|+
else|#
directive|else
name|len
operator|=
name|entry
operator|->
name|d_namlen
operator|+
endif|#
directive|endif
operator|(
operator|(
name|dirname
operator|)
condition|?
name|strlen
argument_list|(
name|dirname
argument_list|)
else|:
literal|0
operator|)
operator|+
literal|1
operator|+
literal|1
expr_stmt|;
name|temp
operator|=
name|malloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"%s%s"
argument_list|,
name|dirname
condition|?
name|dirname
else|:
literal|""
argument_list|,
name|entry
operator|->
name|d_name
argument_list|)
expr_stmt|;
comment|/* safe */
comment|/* test, if it's directory */
if|if
condition|(
name|stat
argument_list|(
name|temp
argument_list|,
operator|&
name|stbuf
argument_list|)
operator|==
literal|0
operator|&&
name|S_ISDIR
argument_list|(
name|stbuf
operator|.
name|st_mode
argument_list|)
condition|)
name|strcat
argument_list|(
name|temp
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
comment|/* safe */
block|}
else|else
name|temp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|temp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * a completion generator for usernames; returns _first_ username  * which starts with supplied text  * text contains a partial username preceded by random character  * (usually '~'); state is ignored  * it's callers responsibility to free returned value  */
end_comment

begin_function
name|char
modifier|*
name|username_completion_function
parameter_list|(
specifier|const
name|char
modifier|*
name|text
parameter_list|,
name|int
name|state
parameter_list|)
block|{
name|struct
name|passwd
modifier|*
name|pwd
decl_stmt|;
if|if
condition|(
name|text
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
operator|*
name|text
operator|==
literal|'~'
condition|)
name|text
operator|++
expr_stmt|;
if|if
condition|(
name|state
operator|==
literal|0
condition|)
name|setpwent
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
name|pwd
operator|=
name|getpwent
argument_list|()
operator|)
operator|&&
name|text
index|[
literal|0
index|]
operator|==
name|pwd
operator|->
name|pw_name
index|[
literal|0
index|]
operator|&&
name|strcmp
argument_list|(
name|text
argument_list|,
name|pwd
operator|->
name|pw_name
argument_list|)
operator|==
literal|0
condition|)
empty_stmt|;
if|if
condition|(
name|pwd
operator|==
name|NULL
condition|)
block|{
name|endpwent
argument_list|()
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
return|return
operator|(
name|strdup
argument_list|(
name|pwd
operator|->
name|pw_name
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * el-compatible wrapper around rl_complete; needed for key binding  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|unsigned
name|char
name|_el_rl_complete
parameter_list|(
name|EditLine
modifier|*
name|el
parameter_list|,
name|int
name|ch
parameter_list|)
block|{
return|return
operator|(
name|unsigned
name|char
operator|)
name|rl_complete
argument_list|(
literal|0
argument_list|,
name|ch
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * returns list of completitions for text given  */
end_comment

begin_function
name|char
modifier|*
modifier|*
name|completion_matches
parameter_list|(
specifier|const
name|char
modifier|*
name|text
parameter_list|,
name|CPFunction
modifier|*
name|genfunc
parameter_list|)
block|{
name|char
modifier|*
modifier|*
name|match_list
init|=
name|NULL
decl_stmt|,
modifier|*
name|retstr
decl_stmt|,
modifier|*
name|prevstr
decl_stmt|;
name|size_t
name|match_list_len
decl_stmt|,
name|max_equal
decl_stmt|,
name|which
decl_stmt|,
name|i
decl_stmt|;
name|int
name|matches
decl_stmt|;
if|if
condition|(
name|h
operator|==
name|NULL
operator|||
name|e
operator|==
name|NULL
condition|)
name|rl_initialize
argument_list|()
expr_stmt|;
name|matches
operator|=
literal|0
expr_stmt|;
name|match_list_len
operator|=
literal|1
expr_stmt|;
while|while
condition|(
operator|(
name|retstr
operator|=
call|(
modifier|*
name|genfunc
call|)
argument_list|(
name|text
argument_list|,
name|matches
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|matches
operator|+
literal|1
operator|>=
name|match_list_len
condition|)
block|{
name|match_list_len
operator|<<=
literal|1
expr_stmt|;
name|match_list
operator|=
name|realloc
argument_list|(
name|match_list
argument_list|,
name|match_list_len
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|match_list
index|[
operator|++
name|matches
index|]
operator|=
name|retstr
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|match_list
condition|)
return|return
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
return|;
comment|/* nothing found */
comment|/* find least denominator and insert it to match_list[0] */
name|which
operator|=
literal|2
expr_stmt|;
name|prevstr
operator|=
name|match_list
index|[
literal|1
index|]
expr_stmt|;
name|max_equal
operator|=
name|strlen
argument_list|(
name|prevstr
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|which
operator|<=
name|matches
condition|;
name|which
operator|++
control|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max_equal
operator|&&
name|prevstr
index|[
name|i
index|]
operator|==
name|match_list
index|[
name|which
index|]
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
continue|continue;
name|max_equal
operator|=
name|i
expr_stmt|;
block|}
name|retstr
operator|=
name|malloc
argument_list|(
name|max_equal
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|retstr
argument_list|,
name|match_list
index|[
literal|1
index|]
argument_list|,
name|max_equal
argument_list|)
expr_stmt|;
name|retstr
index|[
name|max_equal
index|]
operator|=
literal|'\0'
expr_stmt|;
name|match_list
index|[
literal|0
index|]
operator|=
name|retstr
expr_stmt|;
comment|/* add NULL as last pointer to the array */
if|if
condition|(
name|matches
operator|+
literal|1
operator|>=
name|match_list_len
condition|)
name|match_list
operator|=
name|realloc
argument_list|(
name|match_list
argument_list|,
operator|(
name|match_list_len
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|match_list
index|[
name|matches
operator|+
literal|1
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
return|return
operator|(
name|match_list
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Sort function for qsort(). Just wrapper around strcasecmp().  */
end_comment

begin_function
specifier|static
name|int
name|_rl_qsort_string_compare
parameter_list|(
name|i1
parameter_list|,
name|i2
parameter_list|)
specifier|const
name|void
modifier|*
name|i1
decl_stmt|,
decl|*
name|i2
decl_stmt|;
end_function

begin_block
block|{
comment|/*LINTED const castaway*/
specifier|const
name|char
modifier|*
name|s1
init|=
operator|(
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
name|i1
operator|)
index|[
literal|0
index|]
decl_stmt|;
comment|/*LINTED const castaway*/
specifier|const
name|char
modifier|*
name|s2
init|=
operator|(
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
name|i2
operator|)
index|[
literal|0
index|]
decl_stmt|;
return|return
name|strcasecmp
argument_list|(
name|s1
argument_list|,
name|s2
argument_list|)
return|;
block|}
end_block

begin_comment
comment|/*  * Display list of strings in columnar format on readline's output stream.  * 'matches' is list of strings, 'len' is number of strings in 'matches',  * 'max' is maximum length of string in 'matches'.  */
end_comment

begin_function
name|void
name|rl_display_match_list
parameter_list|(
name|matches
parameter_list|,
name|len
parameter_list|,
name|max
parameter_list|)
name|char
modifier|*
modifier|*
name|matches
decl_stmt|;
name|int
name|len
decl_stmt|,
name|max
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|idx
decl_stmt|,
name|limit
decl_stmt|,
name|count
decl_stmt|;
name|int
name|screenwidth
init|=
name|e
operator|->
name|el_term
operator|.
name|t_size
operator|.
name|h
decl_stmt|;
comment|/* 	 * Find out how many entries can be put on one line, count 	 * with two spaces between strings. 	 */
name|limit
operator|=
name|screenwidth
operator|/
operator|(
name|max
operator|+
literal|2
operator|)
expr_stmt|;
if|if
condition|(
name|limit
operator|==
literal|0
condition|)
name|limit
operator|=
literal|1
expr_stmt|;
comment|/* how many lines of output */
name|count
operator|=
name|len
operator|/
name|limit
expr_stmt|;
if|if
condition|(
name|count
operator|*
name|limit
operator|<
name|len
condition|)
name|count
operator|++
expr_stmt|;
comment|/* Sort the items if they are not already sorted. */
name|qsort
argument_list|(
operator|&
name|matches
index|[
literal|1
index|]
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|len
operator|-
literal|1
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|,
name|_rl_qsort_string_compare
argument_list|)
expr_stmt|;
name|idx
operator|=
literal|1
expr_stmt|;
for|for
control|(
init|;
name|count
operator|>
literal|0
condition|;
name|count
operator|--
control|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|limit
operator|&&
name|matches
index|[
name|idx
index|]
condition|;
name|i
operator|++
operator|,
name|idx
operator|++
control|)
name|fprintf
argument_list|(
name|e
operator|->
name|el_outfile
argument_list|,
literal|"%-*s  "
argument_list|,
name|max
argument_list|,
name|matches
index|[
name|idx
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|e
operator|->
name|el_outfile
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Complete the word at or before point, called by rl_complete()  * 'what_to_do' says what to do with the completion.  * `?' means list the possible completions.  * TAB means do standard completion.  * `*' means insert all of the possible completions.  * `!' means to do standard completion, and list all possible completions if  * there is more than one.  *  * Note: '*' support is not implemented  */
end_comment

begin_function
specifier|static
name|int
name|rl_complete_internal
parameter_list|(
name|int
name|what_to_do
parameter_list|)
block|{
name|CPFunction
modifier|*
name|complet_func
decl_stmt|;
specifier|const
name|LineInfo
modifier|*
name|li
decl_stmt|;
name|char
modifier|*
name|temp
decl_stmt|,
modifier|*
modifier|*
name|matches
decl_stmt|;
specifier|const
name|char
modifier|*
name|ctemp
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|rl_completion_type
operator|=
name|what_to_do
expr_stmt|;
if|if
condition|(
name|h
operator|==
name|NULL
operator|||
name|e
operator|==
name|NULL
condition|)
name|rl_initialize
argument_list|()
expr_stmt|;
name|complet_func
operator|=
name|rl_completion_entry_function
expr_stmt|;
if|if
condition|(
operator|!
name|complet_func
condition|)
name|complet_func
operator|=
name|filename_completion_function
expr_stmt|;
comment|/* We now look backwards for the start of a filename/variable word */
name|li
operator|=
name|el_line
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|ctemp
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|li
operator|->
name|cursor
expr_stmt|;
while|while
condition|(
name|ctemp
operator|>
name|li
operator|->
name|buffer
operator|&&
operator|!
name|strchr
argument_list|(
name|rl_basic_word_break_characters
argument_list|,
name|ctemp
index|[
operator|-
literal|1
index|]
argument_list|)
operator|&&
operator|(
operator|!
name|rl_special_prefixes
operator|||
operator|!
name|strchr
argument_list|(
name|rl_special_prefixes
argument_list|,
name|ctemp
index|[
operator|-
literal|1
index|]
argument_list|)
operator|)
condition|)
name|ctemp
operator|--
expr_stmt|;
name|len
operator|=
name|li
operator|->
name|cursor
operator|-
name|ctemp
expr_stmt|;
name|temp
operator|=
name|alloca
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|temp
argument_list|,
name|ctemp
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|temp
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* these can be used by function called in completion_matches() */
comment|/* or (*rl_attempted_completion_function)() */
name|rl_point
operator|=
name|li
operator|->
name|cursor
operator|-
name|li
operator|->
name|buffer
expr_stmt|;
name|rl_end
operator|=
name|li
operator|->
name|lastchar
operator|-
name|li
operator|->
name|buffer
expr_stmt|;
if|if
condition|(
operator|!
name|rl_attempted_completion_function
condition|)
name|matches
operator|=
name|completion_matches
argument_list|(
name|temp
argument_list|,
name|complet_func
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|end
init|=
name|li
operator|->
name|cursor
operator|-
name|li
operator|->
name|buffer
decl_stmt|;
name|matches
operator|=
call|(
modifier|*
name|rl_attempted_completion_function
call|)
argument_list|(
name|temp
argument_list|,
call|(
name|int
call|)
argument_list|(
name|end
operator|-
name|len
argument_list|)
argument_list|,
name|end
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|matches
condition|)
block|{
name|int
name|i
decl_stmt|,
name|retval
init|=
name|CC_REFRESH
decl_stmt|;
name|int
name|matches_num
decl_stmt|,
name|maxlen
decl_stmt|,
name|match_len
decl_stmt|,
name|match_display
init|=
literal|1
decl_stmt|;
comment|/* 		 * Only replace the completed string with common part of 		 * possible matches if there is possible completion. 		 */
if|if
condition|(
name|matches
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|el_deletestr
argument_list|(
name|e
argument_list|,
operator|(
name|int
operator|)
name|len
argument_list|)
expr_stmt|;
name|el_insertstr
argument_list|(
name|e
argument_list|,
name|matches
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|what_to_do
operator|==
literal|'?'
condition|)
goto|goto
name|display_matches
goto|;
if|if
condition|(
name|matches
index|[
literal|2
index|]
operator|==
name|NULL
operator|&&
name|strcmp
argument_list|(
name|matches
index|[
literal|0
index|]
argument_list|,
name|matches
index|[
literal|1
index|]
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 			 * We found exact match. Add a space after 			 * it, unless we do filename completition and the 			 * object is a directory. 			 */
name|size_t
name|alen
init|=
name|strlen
argument_list|(
name|matches
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|complet_func
operator|!=
name|filename_completion_function
operator|||
operator|(
name|alen
operator|>
literal|0
operator|&&
operator|(
name|matches
index|[
literal|0
index|]
operator|)
index|[
name|alen
operator|-
literal|1
index|]
operator|!=
literal|'/'
operator|)
operator|)
operator|&&
name|rl_completion_append_character
condition|)
block|{
name|char
name|buf
index|[
literal|2
index|]
decl_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
name|rl_completion_append_character
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|el_insertstr
argument_list|(
name|e
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|what_to_do
operator|==
literal|'!'
condition|)
block|{
name|display_matches
label|:
comment|/* 			 * More than one match and requested to list possible 			 * matches. 			 */
for|for
control|(
name|i
operator|=
literal|1
operator|,
name|maxlen
operator|=
literal|0
init|;
name|matches
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|match_len
operator|=
name|strlen
argument_list|(
name|matches
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|match_len
operator|>
name|maxlen
condition|)
name|maxlen
operator|=
name|match_len
expr_stmt|;
block|}
name|matches_num
operator|=
name|i
operator|-
literal|1
expr_stmt|;
comment|/* newline to get on next line from command line */
name|fprintf
argument_list|(
name|e
operator|->
name|el_outfile
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* 			 * If there are too many items, ask user for display 			 * confirmation. 			 */
if|if
condition|(
name|matches_num
operator|>
name|rl_completion_query_items
condition|)
block|{
name|fprintf
argument_list|(
name|e
operator|->
name|el_outfile
argument_list|,
literal|"Display all %d possibilities? (y or n) "
argument_list|,
name|matches_num
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|e
operator|->
name|el_outfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|getc
argument_list|(
name|stdin
argument_list|)
operator|!=
literal|'y'
condition|)
name|match_display
operator|=
literal|0
expr_stmt|;
name|fprintf
argument_list|(
name|e
operator|->
name|el_outfile
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|match_display
condition|)
name|rl_display_match_list
argument_list|(
name|matches
argument_list|,
name|matches_num
argument_list|,
name|maxlen
argument_list|)
expr_stmt|;
name|retval
operator|=
name|CC_REDISPLAY
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|matches
index|[
literal|0
index|]
index|[
literal|0
index|]
condition|)
block|{
comment|/* 			 * There was some common match, but the name was 			 * not complete enough. Next tab will print possible 			 * completions. 			 */
name|el_beep
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* lcd is not a valid object - further specification */
comment|/* is needed */
name|el_beep
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|retval
operator|=
name|CC_NORM
expr_stmt|;
block|}
comment|/* free elements of array and the array itself */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|matches
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
name|free
argument_list|(
name|matches
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|matches
argument_list|)
operator|,
name|matches
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
return|return
operator|(
name|CC_NORM
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * complete word at current point  */
end_comment

begin_function
name|int
name|rl_complete
parameter_list|(
name|int
name|ignore
parameter_list|,
name|int
name|invoking_key
parameter_list|)
block|{
if|if
condition|(
name|h
operator|==
name|NULL
operator|||
name|e
operator|==
name|NULL
condition|)
name|rl_initialize
argument_list|()
expr_stmt|;
if|if
condition|(
name|rl_inhibit_completion
condition|)
block|{
name|rl_insert
argument_list|(
name|ignore
argument_list|,
name|invoking_key
argument_list|)
expr_stmt|;
return|return
operator|(
name|CC_REFRESH
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|e
operator|->
name|el_state
operator|.
name|lastcmd
operator|==
name|el_rl_complete_cmdnum
condition|)
return|return
name|rl_complete_internal
argument_list|(
literal|'?'
argument_list|)
return|;
elseif|else
if|if
condition|(
name|_rl_complete_show_all
condition|)
return|return
name|rl_complete_internal
argument_list|(
literal|'!'
argument_list|)
return|;
else|else
return|return
operator|(
name|rl_complete_internal
argument_list|(
name|TAB
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * misc other functions  */
end_comment

begin_comment
comment|/*  * bind key c to readline-type function func  */
end_comment

begin_function
name|int
name|rl_bind_key
parameter_list|(
name|int
name|c
parameter_list|,
name|int
name|func
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|)
parameter_list|)
block|{
name|int
name|retval
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|h
operator|==
name|NULL
operator|||
name|e
operator|==
name|NULL
condition|)
name|rl_initialize
argument_list|()
expr_stmt|;
if|if
condition|(
name|func
operator|==
name|rl_insert
condition|)
block|{
comment|/* XXX notice there is no range checking of ``c'' */
name|e
operator|->
name|el_map
operator|.
name|key
index|[
name|c
index|]
operator|=
name|ED_INSERT
expr_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * read one key from input - handles chars pushed back  * to input stream also  */
end_comment

begin_function
name|int
name|rl_read_key
parameter_list|(
name|void
parameter_list|)
block|{
name|char
name|fooarr
index|[
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
index|]
decl_stmt|;
if|if
condition|(
name|e
operator|==
name|NULL
operator|||
name|h
operator|==
name|NULL
condition|)
name|rl_initialize
argument_list|()
expr_stmt|;
return|return
operator|(
name|el_getc
argument_list|(
name|e
argument_list|,
name|fooarr
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * reset the terminal  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|void
name|rl_reset_terminal
parameter_list|(
specifier|const
name|char
modifier|*
name|p
parameter_list|)
block|{
if|if
condition|(
name|h
operator|==
name|NULL
operator|||
name|e
operator|==
name|NULL
condition|)
name|rl_initialize
argument_list|()
expr_stmt|;
name|el_reset
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * insert character ``c'' back into input stream, ``count'' times  */
end_comment

begin_function
name|int
name|rl_insert
parameter_list|(
name|int
name|count
parameter_list|,
name|int
name|c
parameter_list|)
block|{
name|char
name|arr
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
name|h
operator|==
name|NULL
operator|||
name|e
operator|==
name|NULL
condition|)
name|rl_initialize
argument_list|()
expr_stmt|;
comment|/* XXX - int -> char conversion can lose on multichars */
name|arr
index|[
literal|0
index|]
operator|=
name|c
expr_stmt|;
name|arr
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
init|;
name|count
operator|>
literal|0
condition|;
name|count
operator|--
control|)
name|el_push
argument_list|(
name|e
argument_list|,
name|arr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

