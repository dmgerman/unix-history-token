begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1991, 1993  *	The Regents of the University of California.  All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Matt Bishop of Dartmouth College.  *  * The United States Government has rights in this work pursuant  * to contract no. NAG 2-680 between the National Aeronautics and  * Space Administration and Dartmouth College.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
specifier|const
name|char
name|copyright
index|[]
init|=
literal|"@(#) Copyright (c) 1991, 1993\n\ 	The Regents of the University of California.  All rights reserved.\n"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static char sccsid[] = "@(#)bdes.c	8.1 (Berkeley) 6/6/93";
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/*  * BDES -- DES encryption package for Berkeley Software Distribution 4.4  * options:  *	-a	key is in ASCII  *	-b	use ECB (electronic code book) mode  *	-d	invert (decrypt) input  *	-f b	use b-bit CFB (cipher feedback) mode  *	-F b	use b-bit CFB (cipher feedback) alternative mode  *	-k key	use key as the cryptographic key  *	-m b	generate a MAC of length b  *	-o b	use b-bit OFB (output feedback) mode  *	-p	don't reset the parity bit  *	-v v	use v as the initialization vector (ignored for ECB)  * note: the last character of the last block is the integer indicating  * how many characters of that block are to be output  *  * Author: Matt Bishop  *	   Department of Mathematics and Computer Science  *	   Dartmouth College  *	   Hanover, NH  03755  * Email:  Matt.Bishop@dartmouth.edu  *	   ...!decvax!dartvax!Matt.Bishop  *  * See Technical Report PCS-TR91-158, Department of Mathematics and Computer  * Science, Dartmouth College, for a detailed description of the implemen-  * tation and differences between it and Sun's.  The DES is described in  * FIPS PUB 46, and the modes in FIPS PUB 81 (see either the manual page  * or the technical report for a complete reference).  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<openssl/des.h>
end_include

begin_comment
comment|/*  * BSD and System V systems offer special library calls that do  * block moves and fills, so if possible we take advantage of them  */
end_comment

begin_define
define|#
directive|define
name|MEMCPY
parameter_list|(
name|dest
parameter_list|,
name|src
parameter_list|,
name|len
parameter_list|)
value|bcopy((src),(dest),(len))
end_define

begin_define
define|#
directive|define
name|MEMZERO
parameter_list|(
name|dest
parameter_list|,
name|len
parameter_list|)
value|bzero((dest),(len))
end_define

begin_define
define|#
directive|define
name|DES_XFORM
parameter_list|(
name|buf
parameter_list|)
define|\
value|DES_ecb_encrypt(buf, buf,&schedule, 			\ 		    mode == MODE_ENCRYPT ? DES_ENCRYPT : DES_DECRYPT);
end_define

begin_comment
comment|/*  * this does an error-checking write  */
end_comment

begin_define
define|#
directive|define
name|READ
parameter_list|(
name|buf
parameter_list|,
name|n
parameter_list|)
value|fread(buf, sizeof(char), n, stdin)
end_define

begin_define
define|#
directive|define
name|WRITE
parameter_list|(
name|buf
parameter_list|,
name|n
parameter_list|)
define|\
value|if (fwrite(buf, sizeof(char), n, stdout) != n)	\ 			warnx("fwrite error at %d", n);
end_define

begin_comment
comment|/*  * global variables and related macros  */
end_comment

begin_define
define|#
directive|define
name|KEY_DEFAULT
value|0
end_define

begin_comment
comment|/* interpret radix of key from key */
end_comment

begin_define
define|#
directive|define
name|KEY_ASCII
value|1
end_define

begin_comment
comment|/* key is in ASCII characters */
end_comment

begin_decl_stmt
name|int
name|keybase
init|=
name|KEY_DEFAULT
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* how to interpret the key */
end_comment

begin_enum
enum|enum
block|{
comment|/* encrypt, decrypt, authenticate */
name|MODE_ENCRYPT
block|,
name|MODE_DECRYPT
block|,
name|MODE_AUTHENTICATE
block|}
name|mode
init|=
name|MODE_ENCRYPT
enum|;
end_enum

begin_enum
enum|enum
block|{
comment|/* ecb, cbc, cfb, cfba, ofb? */
name|ALG_ECB
block|,
name|ALG_CBC
block|,
name|ALG_CFB
block|,
name|ALG_OFB
block|,
name|ALG_CFBA
block|}
name|alg
init|=
name|ALG_CBC
enum|;
end_enum

begin_decl_stmt
name|DES_cblock
name|ivec
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* initialization vector */
end_comment

begin_decl_stmt
name|char
name|bits
index|[]
init|=
block|{
comment|/* used to extract bits from a char */
literal|'\200'
block|,
literal|'\100'
block|,
literal|'\040'
block|,
literal|'\020'
block|,
literal|'\010'
block|,
literal|'\004'
block|,
literal|'\002'
block|,
literal|'\001'
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|inverse
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 0 to encrypt, 1 to decrypt */
end_comment

begin_decl_stmt
name|int
name|macbits
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of bits in authentication */
end_comment

begin_decl_stmt
name|int
name|fbbits
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of feedback bits */
end_comment

begin_decl_stmt
name|int
name|pflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1 to preserve parity bits */
end_comment

begin_decl_stmt
name|DES_key_schedule
name|schedule
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* expanded DES key */
end_comment

begin_function_decl
specifier|static
name|void
name|ecbenc
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ecbdec
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cbcenc
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cbcdec
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cfbenc
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cfbdec
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cfbaenc
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cfbadec
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ofbenc
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ofbdec
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cbcauth
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cfbauth
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cvtkey
parameter_list|(
name|DES_cblock
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|setbits
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|makekey
parameter_list|(
name|DES_cblock
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|tobinhex
parameter_list|(
name|char
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
specifier|extern
name|char
modifier|*
name|optarg
decl_stmt|;
comment|/* argument to option if any */
name|int
name|i
decl_stmt|;
comment|/* counter in a for loop */
name|char
modifier|*
name|p
decl_stmt|;
comment|/* used to obtain the key */
name|DES_cblock
name|msgbuf
decl_stmt|;
comment|/* I/O buffer */
name|int
name|kflag
decl_stmt|;
comment|/* command-line encryption key */
name|setproctitle
argument_list|(
literal|"-"
argument_list|)
expr_stmt|;
comment|/* Hide command-line arguments */
comment|/* initialize the initialization vector */
name|MEMZERO
argument_list|(
name|ivec
argument_list|,
literal|8
argument_list|)
expr_stmt|;
comment|/* process the argument list */
name|kflag
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|i
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"abdF:f:k:m:o:pv:"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
switch|switch
condition|(
name|i
condition|)
block|{
case|case
literal|'a'
case|:
comment|/* key is ASCII */
name|keybase
operator|=
name|KEY_ASCII
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
comment|/* use ECB mode */
name|alg
operator|=
name|ALG_ECB
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
comment|/* decrypt */
name|mode
operator|=
name|MODE_DECRYPT
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
comment|/* use alternative CFB mode */
name|alg
operator|=
name|ALG_CFBA
expr_stmt|;
if|if
condition|(
operator|(
name|fbbits
operator|=
name|setbits
argument_list|(
name|optarg
argument_list|,
literal|7
argument_list|)
operator|)
operator|>
literal|56
operator|||
name|fbbits
operator|==
literal|0
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"-F: number must be 1-56 inclusive"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fbbits
operator|==
operator|-
literal|1
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"-F: number must be a multiple of 7"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
comment|/* use CFB mode */
name|alg
operator|=
name|ALG_CFB
expr_stmt|;
if|if
condition|(
operator|(
name|fbbits
operator|=
name|setbits
argument_list|(
name|optarg
argument_list|,
literal|8
argument_list|)
operator|)
operator|>
literal|64
operator|||
name|fbbits
operator|==
literal|0
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"-f: number must be 1-64 inclusive"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fbbits
operator|==
operator|-
literal|1
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"-f: number must be a multiple of 8"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'k'
case|:
comment|/* encryption key */
name|kflag
operator|=
literal|1
expr_stmt|;
name|cvtkey
argument_list|(
name|msgbuf
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
comment|/* number of bits for MACing */
name|mode
operator|=
name|MODE_AUTHENTICATE
expr_stmt|;
if|if
condition|(
operator|(
name|macbits
operator|=
name|setbits
argument_list|(
name|optarg
argument_list|,
literal|1
argument_list|)
operator|)
operator|>
literal|64
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"-m: number must be 0-64 inclusive"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
comment|/* use OFB mode */
name|alg
operator|=
name|ALG_OFB
expr_stmt|;
if|if
condition|(
operator|(
name|fbbits
operator|=
name|setbits
argument_list|(
name|optarg
argument_list|,
literal|8
argument_list|)
operator|)
operator|>
literal|64
operator|||
name|fbbits
operator|==
literal|0
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"-o: number must be 1-64 inclusive"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fbbits
operator|==
operator|-
literal|1
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"-o: number must be a multiple of 8"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
comment|/* preserve parity bits */
name|pflag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
comment|/* set initialization vector */
name|cvtkey
argument_list|(
name|ivec
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* error */
name|usage
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|kflag
condition|)
block|{
comment|/* 		 * if the key's not ASCII, assume it is 		 */
name|keybase
operator|=
name|KEY_ASCII
expr_stmt|;
comment|/* 		 * get the key 		 */
name|p
operator|=
name|getpass
argument_list|(
literal|"Enter key: "
argument_list|)
expr_stmt|;
comment|/* 		 * copy it, nul-padded, into the key area 		 */
name|cvtkey
argument_list|(
name|msgbuf
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
name|makekey
argument_list|(
operator|&
name|msgbuf
argument_list|)
expr_stmt|;
name|inverse
operator|=
operator|(
name|alg
operator|==
name|ALG_CBC
operator|||
name|alg
operator|==
name|ALG_ECB
operator|)
operator|&&
name|mode
operator|==
name|MODE_DECRYPT
expr_stmt|;
switch|switch
condition|(
name|alg
condition|)
block|{
case|case
name|ALG_CBC
case|:
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|MODE_AUTHENTICATE
case|:
comment|/* authenticate using CBC mode */
name|cbcauth
argument_list|()
expr_stmt|;
break|break;
case|case
name|MODE_DECRYPT
case|:
comment|/* decrypt using CBC mode */
name|cbcdec
argument_list|()
expr_stmt|;
break|break;
case|case
name|MODE_ENCRYPT
case|:
comment|/* encrypt using CBC mode */
name|cbcenc
argument_list|()
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|ALG_CFB
case|:
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|MODE_AUTHENTICATE
case|:
comment|/* authenticate using CFB mode */
name|cfbauth
argument_list|()
expr_stmt|;
break|break;
case|case
name|MODE_DECRYPT
case|:
comment|/* decrypt using CFB mode */
name|cfbdec
argument_list|()
expr_stmt|;
break|break;
case|case
name|MODE_ENCRYPT
case|:
comment|/* encrypt using CFB mode */
name|cfbenc
argument_list|()
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|ALG_CFBA
case|:
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|MODE_AUTHENTICATE
case|:
comment|/* authenticate using CFBA mode */
name|errx
argument_list|(
literal|1
argument_list|,
literal|"can't authenticate with CFBA mode"
argument_list|)
expr_stmt|;
break|break;
case|case
name|MODE_DECRYPT
case|:
comment|/* decrypt using CFBA mode */
name|cfbadec
argument_list|()
expr_stmt|;
break|break;
case|case
name|MODE_ENCRYPT
case|:
comment|/* encrypt using CFBA mode */
name|cfbaenc
argument_list|()
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|ALG_ECB
case|:
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|MODE_AUTHENTICATE
case|:
comment|/* authenticate using ECB mode */
name|errx
argument_list|(
literal|1
argument_list|,
literal|"can't authenticate with ECB mode"
argument_list|)
expr_stmt|;
break|break;
case|case
name|MODE_DECRYPT
case|:
comment|/* decrypt using ECB mode */
name|ecbdec
argument_list|()
expr_stmt|;
break|break;
case|case
name|MODE_ENCRYPT
case|:
comment|/* encrypt using ECB mode */
name|ecbenc
argument_list|()
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|ALG_OFB
case|:
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|MODE_AUTHENTICATE
case|:
comment|/* authenticate using OFB mode */
name|errx
argument_list|(
literal|1
argument_list|,
literal|"can't authenticate with OFB mode"
argument_list|)
expr_stmt|;
break|break;
case|case
name|MODE_DECRYPT
case|:
comment|/* decrypt using OFB mode */
name|ofbdec
argument_list|()
expr_stmt|;
break|break;
case|case
name|MODE_ENCRYPT
case|:
comment|/* encrypt using OFB mode */
name|ofbenc
argument_list|()
expr_stmt|;
break|break;
block|}
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * map a hex character to an integer  */
end_comment

begin_function
specifier|static
name|int
name|tobinhex
parameter_list|(
name|char
name|c
parameter_list|,
name|int
name|radix
parameter_list|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'0'
case|:
return|return
operator|(
literal|0x0
operator|)
return|;
case|case
literal|'1'
case|:
return|return
operator|(
literal|0x1
operator|)
return|;
case|case
literal|'2'
case|:
return|return
operator|(
name|radix
operator|>
literal|2
condition|?
literal|0x2
else|:
operator|-
literal|1
operator|)
return|;
case|case
literal|'3'
case|:
return|return
operator|(
name|radix
operator|>
literal|3
condition|?
literal|0x3
else|:
operator|-
literal|1
operator|)
return|;
case|case
literal|'4'
case|:
return|return
operator|(
name|radix
operator|>
literal|4
condition|?
literal|0x4
else|:
operator|-
literal|1
operator|)
return|;
case|case
literal|'5'
case|:
return|return
operator|(
name|radix
operator|>
literal|5
condition|?
literal|0x5
else|:
operator|-
literal|1
operator|)
return|;
case|case
literal|'6'
case|:
return|return
operator|(
name|radix
operator|>
literal|6
condition|?
literal|0x6
else|:
operator|-
literal|1
operator|)
return|;
case|case
literal|'7'
case|:
return|return
operator|(
name|radix
operator|>
literal|7
condition|?
literal|0x7
else|:
operator|-
literal|1
operator|)
return|;
case|case
literal|'8'
case|:
return|return
operator|(
name|radix
operator|>
literal|8
condition|?
literal|0x8
else|:
operator|-
literal|1
operator|)
return|;
case|case
literal|'9'
case|:
return|return
operator|(
name|radix
operator|>
literal|9
condition|?
literal|0x9
else|:
operator|-
literal|1
operator|)
return|;
case|case
literal|'A'
case|:
case|case
literal|'a'
case|:
return|return
operator|(
name|radix
operator|>
literal|10
condition|?
literal|0xa
else|:
operator|-
literal|1
operator|)
return|;
case|case
literal|'B'
case|:
case|case
literal|'b'
case|:
return|return
operator|(
name|radix
operator|>
literal|11
condition|?
literal|0xb
else|:
operator|-
literal|1
operator|)
return|;
case|case
literal|'C'
case|:
case|case
literal|'c'
case|:
return|return
operator|(
name|radix
operator|>
literal|12
condition|?
literal|0xc
else|:
operator|-
literal|1
operator|)
return|;
case|case
literal|'D'
case|:
case|case
literal|'d'
case|:
return|return
operator|(
name|radix
operator|>
literal|13
condition|?
literal|0xd
else|:
operator|-
literal|1
operator|)
return|;
case|case
literal|'E'
case|:
case|case
literal|'e'
case|:
return|return
operator|(
name|radix
operator|>
literal|14
condition|?
literal|0xe
else|:
operator|-
literal|1
operator|)
return|;
case|case
literal|'F'
case|:
case|case
literal|'f'
case|:
return|return
operator|(
name|radix
operator|>
literal|15
condition|?
literal|0xf
else|:
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 	 * invalid character 	 */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * convert the key to a bit pattern  */
end_comment

begin_function
specifier|static
name|void
name|cvtkey
parameter_list|(
name|DES_cblock
name|obuf
parameter_list|,
name|char
modifier|*
name|ibuf
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
comment|/* counter in a for loop */
name|int
name|nbuf
index|[
literal|64
index|]
decl_stmt|;
comment|/* used for hex/key translation */
comment|/* 	 * just switch on the key base 	 */
switch|switch
condition|(
name|keybase
condition|)
block|{
case|case
name|KEY_ASCII
case|:
comment|/* ascii to integer */
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|obuf
argument_list|,
name|ibuf
argument_list|,
literal|8
argument_list|)
expr_stmt|;
return|return;
case|case
name|KEY_DEFAULT
case|:
comment|/* tell from context */
comment|/* 		 * leading '0x' or '0X' == hex key 		 */
if|if
condition|(
name|ibuf
index|[
literal|0
index|]
operator|==
literal|'0'
operator|&&
operator|(
name|ibuf
index|[
literal|1
index|]
operator|==
literal|'x'
operator|||
name|ibuf
index|[
literal|1
index|]
operator|==
literal|'X'
operator|)
condition|)
block|{
name|ibuf
operator|=
operator|&
name|ibuf
index|[
literal|2
index|]
expr_stmt|;
comment|/* 			 * now translate it, bombing on any illegal hex digit 			 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|ibuf
index|[
name|i
index|]
operator|&&
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|nbuf
index|[
name|i
index|]
operator|=
name|tobinhex
argument_list|(
name|ibuf
index|[
name|i
index|]
argument_list|,
literal|16
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
name|warnx
argument_list|(
literal|"bad hex digit in key"
argument_list|)
expr_stmt|;
while|while
condition|(
name|i
operator|<
literal|16
condition|)
name|nbuf
index|[
name|i
operator|++
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
name|obuf
index|[
name|i
index|]
operator|=
operator|(
operator|(
name|nbuf
index|[
literal|2
operator|*
name|i
index|]
operator|&
literal|0xf
operator|)
operator|<<
literal|4
operator|)
operator||
operator|(
name|nbuf
index|[
literal|2
operator|*
name|i
operator|+
literal|1
index|]
operator|&
literal|0xf
operator|)
expr_stmt|;
comment|/* preserve parity bits */
name|pflag
operator|=
literal|1
expr_stmt|;
return|return;
block|}
comment|/* 		 * leading '0b' or '0B' == binary key 		 */
if|if
condition|(
name|ibuf
index|[
literal|0
index|]
operator|==
literal|'0'
operator|&&
operator|(
name|ibuf
index|[
literal|1
index|]
operator|==
literal|'b'
operator|||
name|ibuf
index|[
literal|1
index|]
operator|==
literal|'B'
operator|)
condition|)
block|{
name|ibuf
operator|=
operator|&
name|ibuf
index|[
literal|2
index|]
expr_stmt|;
comment|/* 			 * now translate it, bombing on any illegal binary digit 			 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|ibuf
index|[
name|i
index|]
operator|&&
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|nbuf
index|[
name|i
index|]
operator|=
name|tobinhex
argument_list|(
name|ibuf
index|[
name|i
index|]
argument_list|,
literal|2
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
name|warnx
argument_list|(
literal|"bad binary digit in key"
argument_list|)
expr_stmt|;
while|while
condition|(
name|i
operator|<
literal|64
condition|)
name|nbuf
index|[
name|i
operator|++
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|8
condition|;
name|j
operator|++
control|)
name|obuf
index|[
name|i
index|]
operator|=
operator|(
name|obuf
index|[
name|i
index|]
operator|<<
literal|1
operator|)
operator||
name|nbuf
index|[
literal|8
operator|*
name|i
operator|+
name|j
index|]
expr_stmt|;
comment|/* preserve parity bits */
name|pflag
operator|=
literal|1
expr_stmt|;
return|return;
block|}
comment|/* 		 * no special leader -- ASCII 		 */
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|obuf
argument_list|,
name|ibuf
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * convert an ASCII string into a decimal number:  * 1. must be between 0 and 64 inclusive  * 2. must be a valid decimal number  * 3. must be a multiple of mult  */
end_comment

begin_function
specifier|static
name|int
name|setbits
parameter_list|(
name|char
modifier|*
name|s
parameter_list|,
name|int
name|mult
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
comment|/* pointer in a for loop */
name|int
name|n
init|=
literal|0
decl_stmt|;
comment|/* the integer collected */
comment|/* 	 * skip white space 	 */
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
comment|/* 	 * get the integer 	 */
for|for
control|(
name|p
operator|=
name|s
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|n
operator|=
name|n
operator|*
literal|10
operator|+
operator|*
name|p
operator|-
literal|'0'
expr_stmt|;
else|else
block|{
name|warnx
argument_list|(
literal|"bad decimal digit in MAC length"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * be sure it's a multiple of mult 	 */
return|return
operator|(
operator|(
name|n
operator|%
name|mult
operator|!=
literal|0
operator|)
condition|?
operator|-
literal|1
else|:
name|n
operator|)
return|;
block|}
end_function

begin_comment
comment|/*****************  * DES FUNCTIONS *  *****************/
end_comment

begin_comment
comment|/*  * This sets the DES key and (if you're using the deszip version)  * the direction of the transformation.  This uses the Sun  * to map the 64-bit key onto the 56 bits that the key schedule  * generation routines use: the old way, which just uses the user-  * supplied 64 bits as is, and the new way, which resets the parity  * bit to be the same as the low-order bit in each character.  The  * new way generates a greater variety of key schedules, since many  * systems set the parity (high) bit of each character to 0, and the  * DES ignores the low order bit of each character.  */
end_comment

begin_function
specifier|static
name|void
name|makekey
parameter_list|(
name|DES_cblock
modifier|*
name|buf
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
comment|/* counter in a for loop */
name|int
name|par
decl_stmt|;
comment|/* parity counter */
comment|/* 	 * if the parity is not preserved, flip it 	 */
if|if
condition|(
operator|!
name|pflag
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
name|par
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
literal|8
condition|;
name|j
operator|++
control|)
if|if
condition|(
operator|(
name|bits
index|[
name|j
index|]
operator|&
operator|(
operator|*
name|buf
operator|)
index|[
name|i
index|]
operator|)
operator|!=
literal|0
condition|)
name|par
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|par
operator|&
literal|0x01
operator|)
operator|==
literal|0x01
condition|)
operator|(
operator|*
name|buf
operator|)
index|[
name|i
index|]
operator|&=
literal|0x7f
expr_stmt|;
else|else
operator|(
operator|*
name|buf
operator|)
index|[
name|i
index|]
operator|=
operator|(
operator|(
operator|*
name|buf
operator|)
index|[
name|i
index|]
operator|&
literal|0x7f
operator|)
operator||
literal|0x80
expr_stmt|;
block|}
block|}
name|DES_set_odd_parity
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|DES_set_key
argument_list|(
name|buf
argument_list|,
operator|&
name|schedule
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This encrypts using the Electronic Code Book mode of DES  */
end_comment

begin_function
specifier|static
name|void
name|ecbenc
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|n
decl_stmt|;
comment|/* number of bytes actually read */
name|int
name|bn
decl_stmt|;
comment|/* block number */
name|DES_cblock
name|msgbuf
decl_stmt|;
comment|/* I/O buffer */
for|for
control|(
name|bn
operator|=
literal|0
init|;
operator|(
name|n
operator|=
name|READ
argument_list|(
name|msgbuf
argument_list|,
literal|8
argument_list|)
operator|)
operator|==
literal|8
condition|;
name|bn
operator|++
control|)
block|{
comment|/* 		 * do the transformation 		 */
name|DES_XFORM
argument_list|(
operator|&
name|msgbuf
argument_list|)
expr_stmt|;
name|WRITE
argument_list|(
operator|&
name|msgbuf
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * at EOF or last block -- in either case, the last byte contains 	 * the character representation of the number of bytes in it 	 */
name|bn
operator|++
expr_stmt|;
name|MEMZERO
argument_list|(
operator|&
name|msgbuf
index|[
name|n
index|]
argument_list|,
literal|8
operator|-
name|n
argument_list|)
expr_stmt|;
name|msgbuf
index|[
literal|7
index|]
operator|=
name|n
expr_stmt|;
name|DES_XFORM
argument_list|(
operator|&
name|msgbuf
argument_list|)
expr_stmt|;
name|WRITE
argument_list|(
operator|&
name|msgbuf
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This decrypts using the Electronic Code Book mode of DES  */
end_comment

begin_function
specifier|static
name|void
name|ecbdec
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|n
decl_stmt|;
comment|/* number of bytes actually read */
name|int
name|c
decl_stmt|;
comment|/* used to test for EOF */
name|int
name|bn
decl_stmt|;
comment|/* block number */
name|DES_cblock
name|msgbuf
decl_stmt|;
comment|/* I/O buffer */
for|for
control|(
name|bn
operator|=
literal|1
init|;
operator|(
name|n
operator|=
name|READ
argument_list|(
name|msgbuf
argument_list|,
literal|8
argument_list|)
operator|)
operator|==
literal|8
condition|;
name|bn
operator|++
control|)
block|{
comment|/* 		 * do the transformation 		 */
name|DES_XFORM
argument_list|(
operator|&
name|msgbuf
argument_list|)
expr_stmt|;
comment|/* 		 * if the last one, handle it specially 		 */
if|if
condition|(
operator|(
name|c
operator|=
name|getchar
argument_list|()
operator|)
operator|==
name|EOF
condition|)
block|{
name|n
operator|=
name|msgbuf
index|[
literal|7
index|]
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
operator|||
name|n
operator|>
literal|7
condition|)
name|warnx
argument_list|(
literal|"decryption failed (block corrupt) at %d"
argument_list|,
name|bn
argument_list|)
expr_stmt|;
block|}
else|else
operator|(
name|void
operator|)
name|ungetc
argument_list|(
name|c
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
name|WRITE
argument_list|(
name|msgbuf
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|>
literal|0
condition|)
name|warnx
argument_list|(
literal|"decryption failed (incomplete block) at %d"
argument_list|,
name|bn
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This encrypts using the Cipher Block Chaining mode of DES  */
end_comment

begin_function
specifier|static
name|void
name|cbcenc
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|n
decl_stmt|;
comment|/* number of bytes actually read */
name|int
name|bn
decl_stmt|;
comment|/* block number */
name|DES_cblock
name|msgbuf
decl_stmt|;
comment|/* I/O buffer */
comment|/* 	 * do the transformation 	 */
for|for
control|(
name|bn
operator|=
literal|1
init|;
operator|(
name|n
operator|=
name|READ
argument_list|(
name|msgbuf
argument_list|,
literal|8
argument_list|)
operator|)
operator|==
literal|8
condition|;
name|bn
operator|++
control|)
block|{
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
literal|8
condition|;
name|n
operator|++
control|)
name|msgbuf
index|[
name|n
index|]
operator|^=
name|ivec
index|[
name|n
index|]
expr_stmt|;
name|DES_XFORM
argument_list|(
operator|&
name|msgbuf
argument_list|)
expr_stmt|;
name|MEMCPY
argument_list|(
name|ivec
argument_list|,
name|msgbuf
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|WRITE
argument_list|(
name|msgbuf
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * at EOF or last block -- in either case, the last byte contains 	 * the character representation of the number of bytes in it 	 */
name|bn
operator|++
expr_stmt|;
name|MEMZERO
argument_list|(
operator|&
name|msgbuf
index|[
name|n
index|]
argument_list|,
literal|8
operator|-
name|n
argument_list|)
expr_stmt|;
name|msgbuf
index|[
literal|7
index|]
operator|=
name|n
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
literal|8
condition|;
name|n
operator|++
control|)
name|msgbuf
index|[
name|n
index|]
operator|^=
name|ivec
index|[
name|n
index|]
expr_stmt|;
name|DES_XFORM
argument_list|(
operator|&
name|msgbuf
argument_list|)
expr_stmt|;
name|WRITE
argument_list|(
name|msgbuf
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This decrypts using the Cipher Block Chaining mode of DES  */
end_comment

begin_function
specifier|static
name|void
name|cbcdec
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|n
decl_stmt|;
comment|/* number of bytes actually read */
name|DES_cblock
name|msgbuf
decl_stmt|;
comment|/* I/O buffer */
name|DES_cblock
name|ibuf
decl_stmt|;
comment|/* temp buffer for initialization vector */
name|int
name|c
decl_stmt|;
comment|/* used to test for EOF */
name|int
name|bn
decl_stmt|;
comment|/* block number */
for|for
control|(
name|bn
operator|=
literal|0
init|;
operator|(
name|n
operator|=
name|READ
argument_list|(
name|msgbuf
argument_list|,
literal|8
argument_list|)
operator|)
operator|==
literal|8
condition|;
name|bn
operator|++
control|)
block|{
comment|/* 		 * do the transformation 		 */
name|MEMCPY
argument_list|(
name|ibuf
argument_list|,
name|msgbuf
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|DES_XFORM
argument_list|(
operator|&
name|msgbuf
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
literal|8
condition|;
name|c
operator|++
control|)
name|msgbuf
index|[
name|c
index|]
operator|^=
name|ivec
index|[
name|c
index|]
expr_stmt|;
name|MEMCPY
argument_list|(
name|ivec
argument_list|,
name|ibuf
argument_list|,
literal|8
argument_list|)
expr_stmt|;
comment|/* 		 * if the last one, handle it specially 		 */
if|if
condition|(
operator|(
name|c
operator|=
name|getchar
argument_list|()
operator|)
operator|==
name|EOF
condition|)
block|{
name|n
operator|=
name|msgbuf
index|[
literal|7
index|]
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
operator|||
name|n
operator|>
literal|7
condition|)
name|warnx
argument_list|(
literal|"decryption failed (block corrupt) at %d"
argument_list|,
name|bn
argument_list|)
expr_stmt|;
block|}
else|else
operator|(
name|void
operator|)
name|ungetc
argument_list|(
name|c
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
name|WRITE
argument_list|(
name|msgbuf
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|>
literal|0
condition|)
name|warnx
argument_list|(
literal|"decryption failed (incomplete block) at %d"
argument_list|,
name|bn
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This authenticates using the Cipher Block Chaining mode of DES  */
end_comment

begin_function
specifier|static
name|void
name|cbcauth
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|n
decl_stmt|,
name|j
decl_stmt|;
comment|/* number of bytes actually read */
name|DES_cblock
name|msgbuf
decl_stmt|;
comment|/* I/O buffer */
name|DES_cblock
name|encbuf
decl_stmt|;
comment|/* encryption buffer */
comment|/* 	 * do the transformation 	 * note we DISCARD the encrypted block; 	 * we only care about the last one 	 */
while|while
condition|(
operator|(
name|n
operator|=
name|READ
argument_list|(
name|msgbuf
argument_list|,
literal|8
argument_list|)
operator|)
operator|==
literal|8
condition|)
block|{
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
literal|8
condition|;
name|n
operator|++
control|)
name|encbuf
index|[
name|n
index|]
operator|=
name|msgbuf
index|[
name|n
index|]
operator|^
name|ivec
index|[
name|n
index|]
expr_stmt|;
name|DES_XFORM
argument_list|(
operator|&
name|encbuf
argument_list|)
expr_stmt|;
name|MEMCPY
argument_list|(
name|ivec
argument_list|,
name|encbuf
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * now compute the last one, right padding with '\0' if need be 	 */
if|if
condition|(
name|n
operator|>
literal|0
condition|)
block|{
name|MEMZERO
argument_list|(
operator|&
name|msgbuf
index|[
name|n
index|]
argument_list|,
literal|8
operator|-
name|n
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
literal|8
condition|;
name|n
operator|++
control|)
name|encbuf
index|[
name|n
index|]
operator|=
name|msgbuf
index|[
name|n
index|]
operator|^
name|ivec
index|[
name|n
index|]
expr_stmt|;
name|DES_XFORM
argument_list|(
operator|&
name|encbuf
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * drop the bits 	 * we write chars until fewer than 7 bits, 	 * and then pad the last one with 0 bits 	 */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|macbits
operator|>
literal|7
condition|;
name|n
operator|++
operator|,
name|macbits
operator|-=
literal|8
control|)
operator|(
name|void
operator|)
name|putchar
argument_list|(
name|encbuf
index|[
name|n
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|macbits
operator|>
literal|0
condition|)
block|{
name|msgbuf
index|[
literal|0
index|]
operator|=
literal|0x00
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|macbits
condition|;
name|j
operator|++
control|)
name|msgbuf
index|[
literal|0
index|]
operator||=
name|encbuf
index|[
name|n
index|]
operator|&
name|bits
index|[
name|j
index|]
expr_stmt|;
operator|(
name|void
operator|)
name|putchar
argument_list|(
name|msgbuf
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * This encrypts using the Cipher FeedBack mode of DES  */
end_comment

begin_function
specifier|static
name|void
name|cfbenc
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|n
decl_stmt|;
comment|/* number of bytes actually read */
name|int
name|nbytes
decl_stmt|;
comment|/* number of bytes to read */
name|int
name|bn
decl_stmt|;
comment|/* block number */
name|char
name|ibuf
index|[
literal|8
index|]
decl_stmt|;
comment|/* input buffer */
name|DES_cblock
name|msgbuf
decl_stmt|;
comment|/* encryption buffer */
comment|/* 	 * do things in bytes, not bits 	 */
name|nbytes
operator|=
name|fbbits
operator|/
literal|8
expr_stmt|;
comment|/* 	 * do the transformation 	 */
for|for
control|(
name|bn
operator|=
literal|1
init|;
operator|(
name|n
operator|=
name|READ
argument_list|(
name|ibuf
argument_list|,
name|nbytes
argument_list|)
operator|)
operator|==
name|nbytes
condition|;
name|bn
operator|++
control|)
block|{
name|MEMCPY
argument_list|(
name|msgbuf
argument_list|,
name|ivec
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|DES_XFORM
argument_list|(
operator|&
name|msgbuf
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
literal|8
operator|-
name|nbytes
condition|;
name|n
operator|++
control|)
name|ivec
index|[
name|n
index|]
operator|=
name|ivec
index|[
name|n
operator|+
name|nbytes
index|]
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|nbytes
condition|;
name|n
operator|++
control|)
name|ivec
index|[
literal|8
operator|-
name|nbytes
operator|+
name|n
index|]
operator|=
name|ibuf
index|[
name|n
index|]
operator|^
name|msgbuf
index|[
name|n
index|]
expr_stmt|;
name|WRITE
argument_list|(
operator|&
name|ivec
index|[
literal|8
operator|-
name|nbytes
index|]
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * at EOF or last block -- in either case, the last byte contains 	 * the character representation of the number of bytes in it 	 */
name|bn
operator|++
expr_stmt|;
name|MEMZERO
argument_list|(
operator|&
name|ibuf
index|[
name|n
index|]
argument_list|,
name|nbytes
operator|-
name|n
argument_list|)
expr_stmt|;
name|ibuf
index|[
name|nbytes
operator|-
literal|1
index|]
operator|=
name|n
expr_stmt|;
name|MEMCPY
argument_list|(
name|msgbuf
argument_list|,
name|ivec
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|DES_XFORM
argument_list|(
operator|&
name|msgbuf
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|nbytes
condition|;
name|n
operator|++
control|)
name|ibuf
index|[
name|n
index|]
operator|^=
name|msgbuf
index|[
name|n
index|]
expr_stmt|;
name|WRITE
argument_list|(
name|ibuf
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This decrypts using the Cipher Block Chaining mode of DES  */
end_comment

begin_function
specifier|static
name|void
name|cfbdec
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|n
decl_stmt|;
comment|/* number of bytes actually read */
name|int
name|c
decl_stmt|;
comment|/* used to test for EOF */
name|int
name|nbytes
decl_stmt|;
comment|/* number of bytes to read */
name|int
name|bn
decl_stmt|;
comment|/* block number */
name|char
name|ibuf
index|[
literal|8
index|]
decl_stmt|;
comment|/* input buffer */
name|char
name|obuf
index|[
literal|8
index|]
decl_stmt|;
comment|/* output buffer */
name|DES_cblock
name|msgbuf
decl_stmt|;
comment|/* encryption buffer */
comment|/* 	 * do things in bytes, not bits 	 */
name|nbytes
operator|=
name|fbbits
operator|/
literal|8
expr_stmt|;
comment|/* 	 * do the transformation 	 */
for|for
control|(
name|bn
operator|=
literal|1
init|;
operator|(
name|n
operator|=
name|READ
argument_list|(
name|ibuf
argument_list|,
name|nbytes
argument_list|)
operator|)
operator|==
name|nbytes
condition|;
name|bn
operator|++
control|)
block|{
name|MEMCPY
argument_list|(
name|msgbuf
argument_list|,
name|ivec
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|DES_XFORM
argument_list|(
operator|&
name|msgbuf
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
literal|8
operator|-
name|nbytes
condition|;
name|c
operator|++
control|)
name|ivec
index|[
name|c
index|]
operator|=
name|ivec
index|[
name|c
operator|+
name|nbytes
index|]
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|nbytes
condition|;
name|c
operator|++
control|)
block|{
name|ivec
index|[
literal|8
operator|-
name|nbytes
operator|+
name|c
index|]
operator|=
name|ibuf
index|[
name|c
index|]
expr_stmt|;
name|obuf
index|[
name|c
index|]
operator|=
name|ibuf
index|[
name|c
index|]
operator|^
name|msgbuf
index|[
name|c
index|]
expr_stmt|;
block|}
comment|/* 		 * if the last one, handle it specially 		 */
if|if
condition|(
operator|(
name|c
operator|=
name|getchar
argument_list|()
operator|)
operator|==
name|EOF
condition|)
block|{
name|n
operator|=
name|obuf
index|[
name|nbytes
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
operator|||
name|n
operator|>
name|nbytes
operator|-
literal|1
condition|)
name|warnx
argument_list|(
literal|"decryption failed (block corrupt) at %d"
argument_list|,
name|bn
argument_list|)
expr_stmt|;
block|}
else|else
operator|(
name|void
operator|)
name|ungetc
argument_list|(
name|c
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
name|WRITE
argument_list|(
name|obuf
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|>
literal|0
condition|)
name|warnx
argument_list|(
literal|"decryption failed (incomplete block) at %d"
argument_list|,
name|bn
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This encrypts using the alternative Cipher FeedBack mode of DES  */
end_comment

begin_function
specifier|static
name|void
name|cfbaenc
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|n
decl_stmt|;
comment|/* number of bytes actually read */
name|int
name|nbytes
decl_stmt|;
comment|/* number of bytes to read */
name|int
name|bn
decl_stmt|;
comment|/* block number */
name|char
name|ibuf
index|[
literal|8
index|]
decl_stmt|;
comment|/* input buffer */
name|char
name|obuf
index|[
literal|8
index|]
decl_stmt|;
comment|/* output buffer */
name|DES_cblock
name|msgbuf
decl_stmt|;
comment|/* encryption buffer */
comment|/* 	 * do things in bytes, not bits 	 */
name|nbytes
operator|=
name|fbbits
operator|/
literal|7
expr_stmt|;
comment|/* 	 * do the transformation 	 */
for|for
control|(
name|bn
operator|=
literal|1
init|;
operator|(
name|n
operator|=
name|READ
argument_list|(
name|ibuf
argument_list|,
name|nbytes
argument_list|)
operator|)
operator|==
name|nbytes
condition|;
name|bn
operator|++
control|)
block|{
name|MEMCPY
argument_list|(
name|msgbuf
argument_list|,
name|ivec
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|DES_XFORM
argument_list|(
operator|&
name|msgbuf
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
literal|8
operator|-
name|nbytes
condition|;
name|n
operator|++
control|)
name|ivec
index|[
name|n
index|]
operator|=
name|ivec
index|[
name|n
operator|+
name|nbytes
index|]
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|nbytes
condition|;
name|n
operator|++
control|)
name|ivec
index|[
literal|8
operator|-
name|nbytes
operator|+
name|n
index|]
operator|=
operator|(
name|ibuf
index|[
name|n
index|]
operator|^
name|msgbuf
index|[
name|n
index|]
operator|)
operator||
literal|0x80
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|nbytes
condition|;
name|n
operator|++
control|)
name|obuf
index|[
name|n
index|]
operator|=
name|ivec
index|[
literal|8
operator|-
name|nbytes
operator|+
name|n
index|]
operator|&
literal|0x7f
expr_stmt|;
name|WRITE
argument_list|(
name|obuf
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * at EOF or last block -- in either case, the last byte contains 	 * the character representation of the number of bytes in it 	 */
name|bn
operator|++
expr_stmt|;
name|MEMZERO
argument_list|(
operator|&
name|ibuf
index|[
name|n
index|]
argument_list|,
name|nbytes
operator|-
name|n
argument_list|)
expr_stmt|;
name|ibuf
index|[
name|nbytes
operator|-
literal|1
index|]
operator|=
operator|(
literal|'0'
operator|+
name|n
operator|)
operator||
literal|0200
expr_stmt|;
name|MEMCPY
argument_list|(
name|msgbuf
argument_list|,
name|ivec
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|DES_XFORM
argument_list|(
operator|&
name|msgbuf
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|nbytes
condition|;
name|n
operator|++
control|)
name|ibuf
index|[
name|n
index|]
operator|^=
name|msgbuf
index|[
name|n
index|]
expr_stmt|;
name|WRITE
argument_list|(
name|ibuf
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This decrypts using the alternative Cipher Block Chaining mode of DES  */
end_comment

begin_function
specifier|static
name|void
name|cfbadec
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|n
decl_stmt|;
comment|/* number of bytes actually read */
name|int
name|c
decl_stmt|;
comment|/* used to test for EOF */
name|int
name|nbytes
decl_stmt|;
comment|/* number of bytes to read */
name|int
name|bn
decl_stmt|;
comment|/* block number */
name|char
name|ibuf
index|[
literal|8
index|]
decl_stmt|;
comment|/* input buffer */
name|char
name|obuf
index|[
literal|8
index|]
decl_stmt|;
comment|/* output buffer */
name|DES_cblock
name|msgbuf
decl_stmt|;
comment|/* encryption buffer */
comment|/* 	 * do things in bytes, not bits 	 */
name|nbytes
operator|=
name|fbbits
operator|/
literal|7
expr_stmt|;
comment|/* 	 * do the transformation 	 */
for|for
control|(
name|bn
operator|=
literal|1
init|;
operator|(
name|n
operator|=
name|READ
argument_list|(
name|ibuf
argument_list|,
name|nbytes
argument_list|)
operator|)
operator|==
name|nbytes
condition|;
name|bn
operator|++
control|)
block|{
name|MEMCPY
argument_list|(
name|msgbuf
argument_list|,
name|ivec
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|DES_XFORM
argument_list|(
operator|&
name|msgbuf
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
literal|8
operator|-
name|nbytes
condition|;
name|c
operator|++
control|)
name|ivec
index|[
name|c
index|]
operator|=
name|ivec
index|[
name|c
operator|+
name|nbytes
index|]
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|nbytes
condition|;
name|c
operator|++
control|)
block|{
name|ivec
index|[
literal|8
operator|-
name|nbytes
operator|+
name|c
index|]
operator|=
name|ibuf
index|[
name|c
index|]
operator||
literal|0x80
expr_stmt|;
name|obuf
index|[
name|c
index|]
operator|=
operator|(
name|ibuf
index|[
name|c
index|]
operator|^
name|msgbuf
index|[
name|c
index|]
operator|)
operator|&
literal|0x7f
expr_stmt|;
block|}
comment|/* 		 * if the last one, handle it specially 		 */
if|if
condition|(
operator|(
name|c
operator|=
name|getchar
argument_list|()
operator|)
operator|==
name|EOF
condition|)
block|{
if|if
condition|(
operator|(
name|n
operator|=
operator|(
name|obuf
index|[
name|nbytes
operator|-
literal|1
index|]
operator|-
literal|'0'
operator|)
operator|)
operator|<
literal|0
operator|||
name|n
operator|>
name|nbytes
operator|-
literal|1
condition|)
name|warnx
argument_list|(
literal|"decryption failed (block corrupt) at %d"
argument_list|,
name|bn
argument_list|)
expr_stmt|;
block|}
else|else
operator|(
name|void
operator|)
name|ungetc
argument_list|(
name|c
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
name|WRITE
argument_list|(
name|obuf
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|>
literal|0
condition|)
name|warnx
argument_list|(
literal|"decryption failed (incomplete block) at %d"
argument_list|,
name|bn
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This encrypts using the Output FeedBack mode of DES  */
end_comment

begin_function
specifier|static
name|void
name|ofbenc
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|n
decl_stmt|;
comment|/* number of bytes actually read */
name|int
name|c
decl_stmt|;
comment|/* used to test for EOF */
name|int
name|nbytes
decl_stmt|;
comment|/* number of bytes to read */
name|int
name|bn
decl_stmt|;
comment|/* block number */
name|char
name|ibuf
index|[
literal|8
index|]
decl_stmt|;
comment|/* input buffer */
name|char
name|obuf
index|[
literal|8
index|]
decl_stmt|;
comment|/* output buffer */
name|DES_cblock
name|msgbuf
decl_stmt|;
comment|/* encryption buffer */
comment|/* 	 * do things in bytes, not bits 	 */
name|nbytes
operator|=
name|fbbits
operator|/
literal|8
expr_stmt|;
comment|/* 	 * do the transformation 	 */
for|for
control|(
name|bn
operator|=
literal|1
init|;
operator|(
name|n
operator|=
name|READ
argument_list|(
name|ibuf
argument_list|,
name|nbytes
argument_list|)
operator|)
operator|==
name|nbytes
condition|;
name|bn
operator|++
control|)
block|{
name|MEMCPY
argument_list|(
name|msgbuf
argument_list|,
name|ivec
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|DES_XFORM
argument_list|(
operator|&
name|msgbuf
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
literal|8
operator|-
name|nbytes
condition|;
name|n
operator|++
control|)
name|ivec
index|[
name|n
index|]
operator|=
name|ivec
index|[
name|n
operator|+
name|nbytes
index|]
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|nbytes
condition|;
name|n
operator|++
control|)
block|{
name|ivec
index|[
literal|8
operator|-
name|nbytes
operator|+
name|n
index|]
operator|=
name|msgbuf
index|[
name|n
index|]
expr_stmt|;
name|obuf
index|[
name|n
index|]
operator|=
name|ibuf
index|[
name|n
index|]
operator|^
name|msgbuf
index|[
name|n
index|]
expr_stmt|;
block|}
name|WRITE
argument_list|(
name|obuf
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * at EOF or last block -- in either case, the last byte contains 	 * the character representation of the number of bytes in it 	 */
name|bn
operator|++
expr_stmt|;
name|MEMZERO
argument_list|(
operator|&
name|ibuf
index|[
name|n
index|]
argument_list|,
name|nbytes
operator|-
name|n
argument_list|)
expr_stmt|;
name|ibuf
index|[
name|nbytes
operator|-
literal|1
index|]
operator|=
name|n
expr_stmt|;
name|MEMCPY
argument_list|(
name|msgbuf
argument_list|,
name|ivec
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|DES_XFORM
argument_list|(
operator|&
name|msgbuf
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|nbytes
condition|;
name|c
operator|++
control|)
name|ibuf
index|[
name|c
index|]
operator|^=
name|msgbuf
index|[
name|c
index|]
expr_stmt|;
name|WRITE
argument_list|(
name|ibuf
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This decrypts using the Output Block Chaining mode of DES  */
end_comment

begin_function
specifier|static
name|void
name|ofbdec
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|n
decl_stmt|;
comment|/* number of bytes actually read */
name|int
name|c
decl_stmt|;
comment|/* used to test for EOF */
name|int
name|nbytes
decl_stmt|;
comment|/* number of bytes to read */
name|int
name|bn
decl_stmt|;
comment|/* block number */
name|char
name|ibuf
index|[
literal|8
index|]
decl_stmt|;
comment|/* input buffer */
name|char
name|obuf
index|[
literal|8
index|]
decl_stmt|;
comment|/* output buffer */
name|DES_cblock
name|msgbuf
decl_stmt|;
comment|/* encryption buffer */
comment|/* 	 * do things in bytes, not bits 	 */
name|nbytes
operator|=
name|fbbits
operator|/
literal|8
expr_stmt|;
comment|/* 	 * do the transformation 	 */
for|for
control|(
name|bn
operator|=
literal|1
init|;
operator|(
name|n
operator|=
name|READ
argument_list|(
name|ibuf
argument_list|,
name|nbytes
argument_list|)
operator|)
operator|==
name|nbytes
condition|;
name|bn
operator|++
control|)
block|{
name|MEMCPY
argument_list|(
name|msgbuf
argument_list|,
name|ivec
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|DES_XFORM
argument_list|(
operator|&
name|msgbuf
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
literal|8
operator|-
name|nbytes
condition|;
name|c
operator|++
control|)
name|ivec
index|[
name|c
index|]
operator|=
name|ivec
index|[
name|c
operator|+
name|nbytes
index|]
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|nbytes
condition|;
name|c
operator|++
control|)
block|{
name|ivec
index|[
literal|8
operator|-
name|nbytes
operator|+
name|c
index|]
operator|=
name|msgbuf
index|[
name|c
index|]
expr_stmt|;
name|obuf
index|[
name|c
index|]
operator|=
name|ibuf
index|[
name|c
index|]
operator|^
name|msgbuf
index|[
name|c
index|]
expr_stmt|;
block|}
comment|/* 		 * if the last one, handle it specially 		 */
if|if
condition|(
operator|(
name|c
operator|=
name|getchar
argument_list|()
operator|)
operator|==
name|EOF
condition|)
block|{
name|n
operator|=
name|obuf
index|[
name|nbytes
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
operator|||
name|n
operator|>
name|nbytes
operator|-
literal|1
condition|)
name|warnx
argument_list|(
literal|"decryption failed (block corrupt) at %d"
argument_list|,
name|bn
argument_list|)
expr_stmt|;
block|}
else|else
operator|(
name|void
operator|)
name|ungetc
argument_list|(
name|c
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
comment|/* 		 * dump it 		 */
name|WRITE
argument_list|(
name|obuf
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|>
literal|0
condition|)
name|warnx
argument_list|(
literal|"decryption failed (incomplete block) at %d"
argument_list|,
name|bn
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This authenticates using the Cipher FeedBack mode of DES  */
end_comment

begin_function
specifier|static
name|void
name|cfbauth
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|n
decl_stmt|,
name|j
decl_stmt|;
comment|/* number of bytes actually read */
name|int
name|nbytes
decl_stmt|;
comment|/* number of bytes to read */
name|char
name|ibuf
index|[
literal|8
index|]
decl_stmt|;
comment|/* input buffer */
name|DES_cblock
name|msgbuf
decl_stmt|;
comment|/* encryption buffer */
comment|/* 	 * do things in bytes, not bits 	 */
name|nbytes
operator|=
name|fbbits
operator|/
literal|8
expr_stmt|;
comment|/* 	 * do the transformation 	 */
while|while
condition|(
operator|(
name|n
operator|=
name|READ
argument_list|(
name|ibuf
argument_list|,
name|nbytes
argument_list|)
operator|)
operator|==
name|nbytes
condition|)
block|{
name|MEMCPY
argument_list|(
name|msgbuf
argument_list|,
name|ivec
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|DES_XFORM
argument_list|(
operator|&
name|msgbuf
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
literal|8
operator|-
name|nbytes
condition|;
name|n
operator|++
control|)
name|ivec
index|[
name|n
index|]
operator|=
name|ivec
index|[
name|n
operator|+
name|nbytes
index|]
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|nbytes
condition|;
name|n
operator|++
control|)
name|ivec
index|[
literal|8
operator|-
name|nbytes
operator|+
name|n
index|]
operator|=
name|ibuf
index|[
name|n
index|]
operator|^
name|msgbuf
index|[
name|n
index|]
expr_stmt|;
block|}
comment|/* 	 * at EOF or last block -- in either case, the last byte contains 	 * the character representation of the number of bytes in it 	 */
name|MEMZERO
argument_list|(
operator|&
name|ibuf
index|[
name|n
index|]
argument_list|,
name|nbytes
operator|-
name|n
argument_list|)
expr_stmt|;
name|ibuf
index|[
name|nbytes
operator|-
literal|1
index|]
operator|=
literal|'0'
operator|+
name|n
expr_stmt|;
name|MEMCPY
argument_list|(
name|msgbuf
argument_list|,
name|ivec
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|DES_XFORM
argument_list|(
operator|&
name|msgbuf
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|nbytes
condition|;
name|n
operator|++
control|)
name|ibuf
index|[
name|n
index|]
operator|^=
name|msgbuf
index|[
name|n
index|]
expr_stmt|;
comment|/* 	 * drop the bits 	 * we write chars until fewer than 7 bits, 	 * and then pad the last one with 0 bits 	 */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|macbits
operator|>
literal|7
condition|;
name|n
operator|++
operator|,
name|macbits
operator|-=
literal|8
control|)
operator|(
name|void
operator|)
name|putchar
argument_list|(
name|msgbuf
index|[
name|n
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|macbits
operator|>
literal|0
condition|)
block|{
name|msgbuf
index|[
literal|0
index|]
operator|=
literal|0x00
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|macbits
condition|;
name|j
operator|++
control|)
name|msgbuf
index|[
literal|0
index|]
operator||=
name|msgbuf
index|[
name|n
index|]
operator|&
name|bits
index|[
name|j
index|]
expr_stmt|;
operator|(
name|void
operator|)
name|putchar
argument_list|(
name|msgbuf
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * message about usage  */
end_comment

begin_function
specifier|static
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
literal|"usage: bdes [-abdp] [-F N] [-f N] [-k key] [-m N] [-o N] [-v vector]"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

