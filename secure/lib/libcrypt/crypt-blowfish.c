begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright 1997 Niels Provos<provos@physnet.uni-hamburg.de>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *      This product includes software developed by Niels Provos.  * 4. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* This password hashing algorithm was designed by David Mazieres  *<dm@lcs.mit.edu> and works as follows:  *  * 1. state := InitState ()  * 2. state := ExpandKey (state, salt, password) 3.  * REPEAT rounds:  *	state := ExpandKey (state, 0, salt)  *      state := ExpandKey(state, 0, password)  * 4. ctext := "OrpheanBeholderScryDoubt"  * 5. REPEAT 64:  * 	ctext := Encrypt_ECB (state, ctext);  * 6. RETURN Concatenate (salt, ctext);  *  */
end_comment

begin_comment
comment|/*  * FreeBSD implementation by Paul Herman<pherman@frenchfries.net>  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|"blowfish.h"
end_include

begin_include
include|#
directive|include
file|"crypt.h"
end_include

begin_comment
comment|/* This implementation is adaptable to current computing power.  * You can have up to 2^31 rounds which should be enough for some  * time to come.  */
end_comment

begin_define
define|#
directive|define
name|BCRYPT_VERSION
value|'2'
end_define

begin_define
define|#
directive|define
name|BCRYPT_MAXSALT
value|16
end_define

begin_comment
comment|/* Precomputation is just so nice */
end_comment

begin_define
define|#
directive|define
name|BCRYPT_BLOCKS
value|6
end_define

begin_comment
comment|/* Ciphertext blocks */
end_comment

begin_define
define|#
directive|define
name|BCRYPT_MINROUNDS
value|16
end_define

begin_comment
comment|/* we have log2(rounds) in salt */
end_comment

begin_function_decl
name|char
modifier|*
name|bcrypt_gensalt
parameter_list|(
name|u_int8_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|encode_salt
parameter_list|(
name|char
modifier|*
parameter_list|,
name|u_int8_t
modifier|*
parameter_list|,
name|u_int16_t
parameter_list|,
name|u_int8_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|encode_base64
parameter_list|(
name|u_int8_t
modifier|*
parameter_list|,
name|u_int8_t
modifier|*
parameter_list|,
name|u_int16_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|decode_base64
parameter_list|(
name|u_int8_t
modifier|*
parameter_list|,
name|u_int16_t
parameter_list|,
specifier|const
name|u_int8_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|char
name|encrypted
index|[
name|_PASSWORD_LEN
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|gsalt
index|[
name|BCRYPT_MAXSALT
operator|*
literal|4
operator|/
literal|3
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|error
index|[]
init|=
literal|":"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|u_int8_t
name|Base64Code
index|[]
init|=
literal|"./ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|u_int8_t
name|index_64
index|[
literal|128
index|]
init|=
block|{
literal|255
block|,
literal|255
block|,
literal|255
block|,
literal|255
block|,
literal|255
block|,
literal|255
block|,
literal|255
block|,
literal|255
block|,
literal|255
block|,
literal|255
block|,
literal|255
block|,
literal|255
block|,
literal|255
block|,
literal|255
block|,
literal|255
block|,
literal|255
block|,
literal|255
block|,
literal|255
block|,
literal|255
block|,
literal|255
block|,
literal|255
block|,
literal|255
block|,
literal|255
block|,
literal|255
block|,
literal|255
block|,
literal|255
block|,
literal|255
block|,
literal|255
block|,
literal|255
block|,
literal|255
block|,
literal|255
block|,
literal|255
block|,
literal|255
block|,
literal|255
block|,
literal|255
block|,
literal|255
block|,
literal|255
block|,
literal|255
block|,
literal|255
block|,
literal|255
block|,
literal|255
block|,
literal|255
block|,
literal|255
block|,
literal|255
block|,
literal|255
block|,
literal|255
block|,
literal|0
block|,
literal|1
block|,
literal|54
block|,
literal|55
block|,
literal|56
block|,
literal|57
block|,
literal|58
block|,
literal|59
block|,
literal|60
block|,
literal|61
block|,
literal|62
block|,
literal|63
block|,
literal|255
block|,
literal|255
block|,
literal|255
block|,
literal|255
block|,
literal|255
block|,
literal|255
block|,
literal|255
block|,
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|7
block|,
literal|8
block|,
literal|9
block|,
literal|10
block|,
literal|11
block|,
literal|12
block|,
literal|13
block|,
literal|14
block|,
literal|15
block|,
literal|16
block|,
literal|17
block|,
literal|18
block|,
literal|19
block|,
literal|20
block|,
literal|21
block|,
literal|22
block|,
literal|23
block|,
literal|24
block|,
literal|25
block|,
literal|26
block|,
literal|27
block|,
literal|255
block|,
literal|255
block|,
literal|255
block|,
literal|255
block|,
literal|255
block|,
literal|255
block|,
literal|28
block|,
literal|29
block|,
literal|30
block|,
literal|31
block|,
literal|32
block|,
literal|33
block|,
literal|34
block|,
literal|35
block|,
literal|36
block|,
literal|37
block|,
literal|38
block|,
literal|39
block|,
literal|40
block|,
literal|41
block|,
literal|42
block|,
literal|43
block|,
literal|44
block|,
literal|45
block|,
literal|46
block|,
literal|47
block|,
literal|48
block|,
literal|49
block|,
literal|50
block|,
literal|51
block|,
literal|52
block|,
literal|53
block|,
literal|255
block|,
literal|255
block|,
literal|255
block|,
literal|255
block|,
literal|255
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|CHAR64
parameter_list|(
name|c
parameter_list|)
value|( (c)> 127 ? 255 : index_64[(c)])
end_define

begin_function
specifier|static
name|void
name|decode_base64
parameter_list|(
name|u_int8_t
modifier|*
name|buffer
parameter_list|,
name|u_int16_t
name|len
parameter_list|,
specifier|const
name|u_int8_t
modifier|*
name|data
parameter_list|)
block|{
name|u_int8_t
modifier|*
name|bp
init|=
name|buffer
decl_stmt|;
specifier|const
name|u_int8_t
modifier|*
name|p
init|=
name|data
decl_stmt|;
name|u_int8_t
name|c1
decl_stmt|,
name|c2
decl_stmt|,
name|c3
decl_stmt|,
name|c4
decl_stmt|;
while|while
condition|(
name|bp
operator|<
name|buffer
operator|+
name|len
condition|)
block|{
name|c1
operator|=
name|CHAR64
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
name|c2
operator|=
name|CHAR64
argument_list|(
operator|*
operator|(
name|p
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
comment|/* Invalid data */
if|if
condition|(
name|c1
operator|==
literal|255
operator|||
name|c2
operator|==
literal|255
condition|)
break|break;
operator|*
name|bp
operator|++
operator|=
call|(
name|u_int8_t
call|)
argument_list|(
operator|(
name|c1
operator|<<
literal|2
operator|)
operator||
operator|(
operator|(
name|c2
operator|&
literal|0x30
operator|)
operator|>>
literal|4
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|>=
name|buffer
operator|+
name|len
condition|)
break|break;
name|c3
operator|=
name|CHAR64
argument_list|(
operator|*
operator|(
name|p
operator|+
literal|2
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|c3
operator|==
literal|255
condition|)
break|break;
operator|*
name|bp
operator|++
operator|=
operator|(
operator|(
name|c2
operator|&
literal|0x0f
operator|)
operator|<<
literal|4
operator|)
operator||
operator|(
operator|(
name|c3
operator|&
literal|0x3c
operator|)
operator|>>
literal|2
operator|)
expr_stmt|;
if|if
condition|(
name|bp
operator|>=
name|buffer
operator|+
name|len
condition|)
break|break;
name|c4
operator|=
name|CHAR64
argument_list|(
operator|*
operator|(
name|p
operator|+
literal|3
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|c4
operator|==
literal|255
condition|)
break|break;
operator|*
name|bp
operator|++
operator|=
operator|(
operator|(
name|c3
operator|&
literal|0x03
operator|)
operator|<<
literal|6
operator|)
operator||
name|c4
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|encode_salt
parameter_list|(
name|char
modifier|*
name|salt
parameter_list|,
name|u_int8_t
modifier|*
name|csalt
parameter_list|,
name|u_int16_t
name|clen
parameter_list|,
name|u_int8_t
name|logr
parameter_list|)
block|{
name|salt
index|[
literal|0
index|]
operator|=
literal|'$'
expr_stmt|;
name|salt
index|[
literal|1
index|]
operator|=
name|BCRYPT_VERSION
expr_stmt|;
name|salt
index|[
literal|2
index|]
operator|=
literal|'a'
expr_stmt|;
name|salt
index|[
literal|3
index|]
operator|=
literal|'$'
expr_stmt|;
name|snprintf
argument_list|(
name|salt
operator|+
literal|4
argument_list|,
literal|4
argument_list|,
literal|"%2.2u$"
argument_list|,
name|logr
argument_list|)
expr_stmt|;
name|encode_base64
argument_list|(
operator|(
name|u_int8_t
operator|*
operator|)
name|salt
operator|+
literal|7
argument_list|,
name|csalt
argument_list|,
name|clen
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generates a salt for this version of crypt.    Since versions may change. Keeping this here    seems sensible.  */
end_comment

begin_function
name|char
modifier|*
name|bcrypt_gensalt
parameter_list|(
name|u_int8_t
name|log_rounds
parameter_list|)
block|{
name|u_int8_t
name|csalt
index|[
name|BCRYPT_MAXSALT
index|]
decl_stmt|;
name|u_int16_t
name|i
decl_stmt|;
name|u_int32_t
name|seed
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BCRYPT_MAXSALT
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|%
literal|4
operator|==
literal|0
condition|)
name|seed
operator|=
name|arc4random
argument_list|()
expr_stmt|;
name|csalt
index|[
name|i
index|]
operator|=
name|seed
operator|&
literal|0xff
expr_stmt|;
name|seed
operator|=
name|seed
operator|>>
literal|8
expr_stmt|;
block|}
if|if
condition|(
name|log_rounds
operator|<
literal|4
condition|)
name|log_rounds
operator|=
literal|4
expr_stmt|;
name|encode_salt
argument_list|(
name|gsalt
argument_list|,
name|csalt
argument_list|,
name|BCRYPT_MAXSALT
argument_list|,
name|log_rounds
argument_list|)
expr_stmt|;
return|return
name|gsalt
return|;
block|}
end_function

begin_comment
comment|/* We handle $Vers$log2(NumRounds)$salt+passwd$    i.e. $2$04$iwouldntknowwhattosayetKdJ6iFtacBqJdKe6aW7ou */
end_comment

begin_function
name|char
modifier|*
name|crypt_blowfish
parameter_list|(
specifier|const
name|char
modifier|*
name|key
parameter_list|,
specifier|const
name|char
modifier|*
name|salt
parameter_list|)
block|{
name|blf_ctx
name|state
decl_stmt|;
name|u_int32_t
name|rounds
decl_stmt|,
name|i
decl_stmt|,
name|k
decl_stmt|;
name|u_int16_t
name|j
decl_stmt|;
name|u_int8_t
name|key_len
decl_stmt|,
name|salt_len
decl_stmt|,
name|logr
decl_stmt|,
name|minr
decl_stmt|;
name|u_int8_t
name|ciphertext
index|[
literal|4
operator|*
name|BCRYPT_BLOCKS
index|]
init|=
literal|"OrpheanBeholderScryDoubt"
decl_stmt|;
name|u_int8_t
name|csalt
index|[
name|BCRYPT_MAXSALT
index|]
decl_stmt|;
name|u_int32_t
name|cdata
index|[
name|BCRYPT_BLOCKS
index|]
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
name|magic
init|=
literal|"$2a$04$"
decl_stmt|;
comment|/* Defaults */
name|minr
operator|=
literal|'a'
expr_stmt|;
name|logr
operator|=
literal|4
expr_stmt|;
name|rounds
operator|=
literal|1
operator|<<
name|logr
expr_stmt|;
comment|/* If it starts with the magic string, then skip that */
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|salt
argument_list|,
name|magic
argument_list|,
name|strlen
argument_list|(
name|magic
argument_list|)
argument_list|)
condition|)
block|{
name|salt
operator|+=
name|strlen
argument_list|(
name|magic
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|salt
operator|==
literal|'$'
condition|)
block|{
comment|/* Discard "$" identifier */
name|salt
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|salt
operator|>
name|BCRYPT_VERSION
condition|)
block|{
comment|/* How do I handle errors ? Return ':' */
return|return
name|error
return|;
block|}
comment|/* Check for minor versions */
if|if
condition|(
name|salt
index|[
literal|1
index|]
operator|!=
literal|'$'
condition|)
block|{
switch|switch
condition|(
name|salt
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'a'
case|:
comment|/* 'ab' should not yield the same as 'abab' */
name|minr
operator|=
operator|(
name|u_int8_t
operator|)
name|salt
index|[
literal|1
index|]
expr_stmt|;
name|salt
operator|++
expr_stmt|;
break|break;
default|default:
return|return
name|error
return|;
block|}
block|}
else|else
name|minr
operator|=
literal|0
expr_stmt|;
comment|/* Discard version + "$" identifier */
name|salt
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|salt
index|[
literal|2
index|]
operator|!=
literal|'$'
condition|)
comment|/* Out of sync with passwd entry */
return|return
name|error
return|;
comment|/* Computer power doesnt increase linear, 2^x should be fine */
name|logr
operator|=
operator|(
name|u_int8_t
operator|)
name|atoi
argument_list|(
name|salt
argument_list|)
expr_stmt|;
name|rounds
operator|=
literal|1
operator|<<
name|logr
expr_stmt|;
if|if
condition|(
name|rounds
operator|<
name|BCRYPT_MINROUNDS
condition|)
return|return
name|error
return|;
comment|/* Discard num rounds + "$" identifier */
name|salt
operator|+=
literal|3
expr_stmt|;
block|}
comment|/* We dont want the base64 salt but the raw data */
name|decode_base64
argument_list|(
name|csalt
argument_list|,
name|BCRYPT_MAXSALT
argument_list|,
name|salt
argument_list|)
expr_stmt|;
name|salt_len
operator|=
name|BCRYPT_MAXSALT
expr_stmt|;
name|key_len
operator|=
call|(
name|u_int8_t
call|)
argument_list|(
name|strlen
argument_list|(
name|key
argument_list|)
operator|+
operator|(
name|minr
operator|>=
literal|'a'
condition|?
literal|1
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
comment|/* Setting up S-Boxes and Subkeys */
name|Blowfish_initstate
argument_list|(
operator|&
name|state
argument_list|)
expr_stmt|;
name|Blowfish_expandstate
argument_list|(
operator|&
name|state
argument_list|,
name|csalt
argument_list|,
name|salt_len
argument_list|,
operator|(
specifier|const
name|u_int8_t
operator|*
operator|)
name|key
argument_list|,
name|key_len
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|rounds
condition|;
name|k
operator|++
control|)
block|{
name|Blowfish_expand0state
argument_list|(
operator|&
name|state
argument_list|,
operator|(
specifier|const
name|u_int8_t
operator|*
operator|)
name|key
argument_list|,
name|key_len
argument_list|)
expr_stmt|;
name|Blowfish_expand0state
argument_list|(
operator|&
name|state
argument_list|,
name|csalt
argument_list|,
name|salt_len
argument_list|)
expr_stmt|;
block|}
comment|/* This can be precomputed later */
name|j
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BCRYPT_BLOCKS
condition|;
name|i
operator|++
control|)
name|cdata
index|[
name|i
index|]
operator|=
name|Blowfish_stream2word
argument_list|(
name|ciphertext
argument_list|,
literal|4
operator|*
name|BCRYPT_BLOCKS
argument_list|,
operator|&
name|j
argument_list|)
expr_stmt|;
comment|/* Now do the encryption */
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
literal|64
condition|;
name|k
operator|++
control|)
name|blf_enc
argument_list|(
operator|&
name|state
argument_list|,
name|cdata
argument_list|,
name|BCRYPT_BLOCKS
operator|/
literal|2
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BCRYPT_BLOCKS
condition|;
name|i
operator|++
control|)
block|{
name|ciphertext
index|[
literal|4
operator|*
name|i
operator|+
literal|3
index|]
operator|=
name|cdata
index|[
name|i
index|]
operator|&
literal|0xff
expr_stmt|;
name|cdata
index|[
name|i
index|]
operator|=
name|cdata
index|[
name|i
index|]
operator|>>
literal|8
expr_stmt|;
name|ciphertext
index|[
literal|4
operator|*
name|i
operator|+
literal|2
index|]
operator|=
name|cdata
index|[
name|i
index|]
operator|&
literal|0xff
expr_stmt|;
name|cdata
index|[
name|i
index|]
operator|=
name|cdata
index|[
name|i
index|]
operator|>>
literal|8
expr_stmt|;
name|ciphertext
index|[
literal|4
operator|*
name|i
operator|+
literal|1
index|]
operator|=
name|cdata
index|[
name|i
index|]
operator|&
literal|0xff
expr_stmt|;
name|cdata
index|[
name|i
index|]
operator|=
name|cdata
index|[
name|i
index|]
operator|>>
literal|8
expr_stmt|;
name|ciphertext
index|[
literal|4
operator|*
name|i
operator|+
literal|0
index|]
operator|=
name|cdata
index|[
name|i
index|]
operator|&
literal|0xff
expr_stmt|;
block|}
name|i
operator|=
literal|0
expr_stmt|;
name|encrypted
index|[
name|i
operator|++
index|]
operator|=
literal|'$'
expr_stmt|;
name|encrypted
index|[
name|i
operator|++
index|]
operator|=
name|BCRYPT_VERSION
expr_stmt|;
if|if
condition|(
name|minr
condition|)
name|encrypted
index|[
name|i
operator|++
index|]
operator|=
operator|(
name|int8_t
operator|)
name|minr
expr_stmt|;
name|encrypted
index|[
name|i
operator|++
index|]
operator|=
literal|'$'
expr_stmt|;
name|snprintf
argument_list|(
name|encrypted
operator|+
name|i
argument_list|,
literal|4
argument_list|,
literal|"%2.2u$"
argument_list|,
name|logr
argument_list|)
expr_stmt|;
name|encode_base64
argument_list|(
operator|(
name|u_int8_t
operator|*
operator|)
name|encrypted
operator|+
name|i
operator|+
literal|3
argument_list|,
name|csalt
argument_list|,
name|BCRYPT_MAXSALT
argument_list|)
expr_stmt|;
name|encode_base64
argument_list|(
operator|(
name|u_int8_t
operator|*
operator|)
name|encrypted
operator|+
name|strlen
argument_list|(
name|encrypted
argument_list|)
argument_list|,
name|ciphertext
argument_list|,
literal|4
operator|*
name|BCRYPT_BLOCKS
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|encrypted
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|encode_base64
parameter_list|(
name|u_int8_t
modifier|*
name|buffer
parameter_list|,
name|u_int8_t
modifier|*
name|data
parameter_list|,
name|u_int16_t
name|len
parameter_list|)
block|{
name|u_int8_t
modifier|*
name|bp
init|=
name|buffer
decl_stmt|;
name|u_int8_t
modifier|*
name|p
init|=
name|data
decl_stmt|;
name|u_int8_t
name|c1
decl_stmt|,
name|c2
decl_stmt|;
while|while
condition|(
name|p
operator|<
name|data
operator|+
name|len
condition|)
block|{
name|c1
operator|=
operator|*
name|p
operator|++
expr_stmt|;
operator|*
name|bp
operator|++
operator|=
name|Base64Code
index|[
operator|(
name|c1
operator|>>
literal|2
operator|)
index|]
expr_stmt|;
name|c1
operator|=
operator|(
name|c1
operator|&
literal|0x03
operator|)
operator|<<
literal|4
expr_stmt|;
if|if
condition|(
name|p
operator|>=
name|data
operator|+
name|len
condition|)
block|{
operator|*
name|bp
operator|++
operator|=
name|Base64Code
index|[
name|c1
index|]
expr_stmt|;
break|break;
block|}
name|c2
operator|=
operator|*
name|p
operator|++
expr_stmt|;
name|c1
operator||=
operator|(
name|c2
operator|>>
literal|4
operator|)
operator|&
literal|0x0f
expr_stmt|;
operator|*
name|bp
operator|++
operator|=
name|Base64Code
index|[
name|c1
index|]
expr_stmt|;
name|c1
operator|=
operator|(
name|c2
operator|&
literal|0x0f
operator|)
operator|<<
literal|2
expr_stmt|;
if|if
condition|(
name|p
operator|>=
name|data
operator|+
name|len
condition|)
block|{
operator|*
name|bp
operator|++
operator|=
name|Base64Code
index|[
name|c1
index|]
expr_stmt|;
break|break;
block|}
name|c2
operator|=
operator|*
name|p
operator|++
expr_stmt|;
name|c1
operator||=
operator|(
name|c2
operator|>>
literal|6
operator|)
operator|&
literal|0x03
expr_stmt|;
operator|*
name|bp
operator|++
operator|=
name|Base64Code
index|[
name|c1
index|]
expr_stmt|;
operator|*
name|bp
operator|++
operator|=
name|Base64Code
index|[
name|c2
operator|&
literal|0x3f
index|]
expr_stmt|;
block|}
operator|*
name|bp
operator|=
literal|'\0'
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|void main() { 	char    blubber[73]; 	char    salt[100]; 	char   *p; 	salt[0] = '$'; 	salt[1] = BCRYPT_VERSION; 	salt[2] = '$';  	snprintf(salt + 3, 4, "%2.2u$", 5);  	printf("24 bytes of salt: "); 	fgets(salt + 6, 94, stdin); 	salt[99] = 0; 	printf("72 bytes of password: "); 	fpurge(stdin); 	fgets(blubber, 73, stdin); 	blubber[72] = 0;  	p = crypt(blubber, salt); 	printf("Passwd entry: %s\n\n", p);  	p = bcrypt_gensalt(5); 	printf("Generated salt: %s\n", p); 	p = crypt(blubber, p); 	printf("Passwd entry: %s\n", p); }
endif|#
directive|endif
end_endif

end_unit

