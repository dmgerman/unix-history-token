begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * FreeSec: libcrypt for NetBSD  *  * Copyright (c) 1994 David Burren  * All rights reserved.  *  * Adapted for FreeBSD-2.0 by Geoffrey M. Rehmet  *	this file should now *only* export crypt(), in order to make  *	binaries of libcrypt exportable from the USA  *  * Adapted for FreeBSD-4.0 by Mark R V Murray  *	this file should now *only* export crypt_des(), in order to make  *	a module that can be optionally included in libcrypt.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of the author nor the names of other contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * This is an original implementation of the DES and the crypt(3) interfaces  * by David Burren<davidb@werj.com.au>.  *  * An excellent reference on the underlying algorithm (and related  * algorithms) is:  *  *	B. Schneier, Applied Cryptography: protocols, algorithms,  *	and source code in C, John Wiley& Sons, 1994.  *  * Note that in that book's description of DES the lookups for the initial,  * pbox, and final permutations are inverted (this has been brought to the  * attention of the author).  A list of errata for this book has been  * posted to the sci.crypt newsgroup by the author and is available for FTP.  *  * ARCHITECTURE ASSUMPTIONS:  *	It is assumed that the 8-byte arrays passed by reference can be  *	addressed as arrays of u_int32_t's (ie. the CPU is not picky about  *	alignment).  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"crypt.h"
end_include

begin_comment
comment|/* We can't always assume gcc */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__GNUC__
end_ifdef

begin_define
define|#
directive|define
name|INLINE
value|inline
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|u_char
name|IP
index|[
literal|64
index|]
init|=
block|{
literal|58
block|,
literal|50
block|,
literal|42
block|,
literal|34
block|,
literal|26
block|,
literal|18
block|,
literal|10
block|,
literal|2
block|,
literal|60
block|,
literal|52
block|,
literal|44
block|,
literal|36
block|,
literal|28
block|,
literal|20
block|,
literal|12
block|,
literal|4
block|,
literal|62
block|,
literal|54
block|,
literal|46
block|,
literal|38
block|,
literal|30
block|,
literal|22
block|,
literal|14
block|,
literal|6
block|,
literal|64
block|,
literal|56
block|,
literal|48
block|,
literal|40
block|,
literal|32
block|,
literal|24
block|,
literal|16
block|,
literal|8
block|,
literal|57
block|,
literal|49
block|,
literal|41
block|,
literal|33
block|,
literal|25
block|,
literal|17
block|,
literal|9
block|,
literal|1
block|,
literal|59
block|,
literal|51
block|,
literal|43
block|,
literal|35
block|,
literal|27
block|,
literal|19
block|,
literal|11
block|,
literal|3
block|,
literal|61
block|,
literal|53
block|,
literal|45
block|,
literal|37
block|,
literal|29
block|,
literal|21
block|,
literal|13
block|,
literal|5
block|,
literal|63
block|,
literal|55
block|,
literal|47
block|,
literal|39
block|,
literal|31
block|,
literal|23
block|,
literal|15
block|,
literal|7
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_char
name|inv_key_perm
index|[
literal|64
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_char
name|u_key_perm
index|[
literal|56
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_char
name|key_perm
index|[
literal|56
index|]
init|=
block|{
literal|57
block|,
literal|49
block|,
literal|41
block|,
literal|33
block|,
literal|25
block|,
literal|17
block|,
literal|9
block|,
literal|1
block|,
literal|58
block|,
literal|50
block|,
literal|42
block|,
literal|34
block|,
literal|26
block|,
literal|18
block|,
literal|10
block|,
literal|2
block|,
literal|59
block|,
literal|51
block|,
literal|43
block|,
literal|35
block|,
literal|27
block|,
literal|19
block|,
literal|11
block|,
literal|3
block|,
literal|60
block|,
literal|52
block|,
literal|44
block|,
literal|36
block|,
literal|63
block|,
literal|55
block|,
literal|47
block|,
literal|39
block|,
literal|31
block|,
literal|23
block|,
literal|15
block|,
literal|7
block|,
literal|62
block|,
literal|54
block|,
literal|46
block|,
literal|38
block|,
literal|30
block|,
literal|22
block|,
literal|14
block|,
literal|6
block|,
literal|61
block|,
literal|53
block|,
literal|45
block|,
literal|37
block|,
literal|29
block|,
literal|21
block|,
literal|13
block|,
literal|5
block|,
literal|28
block|,
literal|20
block|,
literal|12
block|,
literal|4
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_char
name|key_shifts
index|[
literal|16
index|]
init|=
block|{
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_char
name|inv_comp_perm
index|[
literal|56
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_char
name|comp_perm
index|[
literal|48
index|]
init|=
block|{
literal|14
block|,
literal|17
block|,
literal|11
block|,
literal|24
block|,
literal|1
block|,
literal|5
block|,
literal|3
block|,
literal|28
block|,
literal|15
block|,
literal|6
block|,
literal|21
block|,
literal|10
block|,
literal|23
block|,
literal|19
block|,
literal|12
block|,
literal|4
block|,
literal|26
block|,
literal|8
block|,
literal|16
block|,
literal|7
block|,
literal|27
block|,
literal|20
block|,
literal|13
block|,
literal|2
block|,
literal|41
block|,
literal|52
block|,
literal|31
block|,
literal|37
block|,
literal|47
block|,
literal|55
block|,
literal|30
block|,
literal|40
block|,
literal|51
block|,
literal|45
block|,
literal|33
block|,
literal|48
block|,
literal|44
block|,
literal|49
block|,
literal|39
block|,
literal|56
block|,
literal|34
block|,
literal|53
block|,
literal|46
block|,
literal|42
block|,
literal|50
block|,
literal|36
block|,
literal|29
block|,
literal|32
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *	No E box is used, as it's replaced by some ANDs, shifts, and ORs.  */
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|u_sbox
index|[
literal|8
index|]
index|[
literal|64
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_char
name|sbox
index|[
literal|8
index|]
index|[
literal|64
index|]
init|=
block|{
block|{
literal|14
block|,
literal|4
block|,
literal|13
block|,
literal|1
block|,
literal|2
block|,
literal|15
block|,
literal|11
block|,
literal|8
block|,
literal|3
block|,
literal|10
block|,
literal|6
block|,
literal|12
block|,
literal|5
block|,
literal|9
block|,
literal|0
block|,
literal|7
block|,
literal|0
block|,
literal|15
block|,
literal|7
block|,
literal|4
block|,
literal|14
block|,
literal|2
block|,
literal|13
block|,
literal|1
block|,
literal|10
block|,
literal|6
block|,
literal|12
block|,
literal|11
block|,
literal|9
block|,
literal|5
block|,
literal|3
block|,
literal|8
block|,
literal|4
block|,
literal|1
block|,
literal|14
block|,
literal|8
block|,
literal|13
block|,
literal|6
block|,
literal|2
block|,
literal|11
block|,
literal|15
block|,
literal|12
block|,
literal|9
block|,
literal|7
block|,
literal|3
block|,
literal|10
block|,
literal|5
block|,
literal|0
block|,
literal|15
block|,
literal|12
block|,
literal|8
block|,
literal|2
block|,
literal|4
block|,
literal|9
block|,
literal|1
block|,
literal|7
block|,
literal|5
block|,
literal|11
block|,
literal|3
block|,
literal|14
block|,
literal|10
block|,
literal|0
block|,
literal|6
block|,
literal|13
block|}
block|,
block|{
literal|15
block|,
literal|1
block|,
literal|8
block|,
literal|14
block|,
literal|6
block|,
literal|11
block|,
literal|3
block|,
literal|4
block|,
literal|9
block|,
literal|7
block|,
literal|2
block|,
literal|13
block|,
literal|12
block|,
literal|0
block|,
literal|5
block|,
literal|10
block|,
literal|3
block|,
literal|13
block|,
literal|4
block|,
literal|7
block|,
literal|15
block|,
literal|2
block|,
literal|8
block|,
literal|14
block|,
literal|12
block|,
literal|0
block|,
literal|1
block|,
literal|10
block|,
literal|6
block|,
literal|9
block|,
literal|11
block|,
literal|5
block|,
literal|0
block|,
literal|14
block|,
literal|7
block|,
literal|11
block|,
literal|10
block|,
literal|4
block|,
literal|13
block|,
literal|1
block|,
literal|5
block|,
literal|8
block|,
literal|12
block|,
literal|6
block|,
literal|9
block|,
literal|3
block|,
literal|2
block|,
literal|15
block|,
literal|13
block|,
literal|8
block|,
literal|10
block|,
literal|1
block|,
literal|3
block|,
literal|15
block|,
literal|4
block|,
literal|2
block|,
literal|11
block|,
literal|6
block|,
literal|7
block|,
literal|12
block|,
literal|0
block|,
literal|5
block|,
literal|14
block|,
literal|9
block|}
block|,
block|{
literal|10
block|,
literal|0
block|,
literal|9
block|,
literal|14
block|,
literal|6
block|,
literal|3
block|,
literal|15
block|,
literal|5
block|,
literal|1
block|,
literal|13
block|,
literal|12
block|,
literal|7
block|,
literal|11
block|,
literal|4
block|,
literal|2
block|,
literal|8
block|,
literal|13
block|,
literal|7
block|,
literal|0
block|,
literal|9
block|,
literal|3
block|,
literal|4
block|,
literal|6
block|,
literal|10
block|,
literal|2
block|,
literal|8
block|,
literal|5
block|,
literal|14
block|,
literal|12
block|,
literal|11
block|,
literal|15
block|,
literal|1
block|,
literal|13
block|,
literal|6
block|,
literal|4
block|,
literal|9
block|,
literal|8
block|,
literal|15
block|,
literal|3
block|,
literal|0
block|,
literal|11
block|,
literal|1
block|,
literal|2
block|,
literal|12
block|,
literal|5
block|,
literal|10
block|,
literal|14
block|,
literal|7
block|,
literal|1
block|,
literal|10
block|,
literal|13
block|,
literal|0
block|,
literal|6
block|,
literal|9
block|,
literal|8
block|,
literal|7
block|,
literal|4
block|,
literal|15
block|,
literal|14
block|,
literal|3
block|,
literal|11
block|,
literal|5
block|,
literal|2
block|,
literal|12
block|}
block|,
block|{
literal|7
block|,
literal|13
block|,
literal|14
block|,
literal|3
block|,
literal|0
block|,
literal|6
block|,
literal|9
block|,
literal|10
block|,
literal|1
block|,
literal|2
block|,
literal|8
block|,
literal|5
block|,
literal|11
block|,
literal|12
block|,
literal|4
block|,
literal|15
block|,
literal|13
block|,
literal|8
block|,
literal|11
block|,
literal|5
block|,
literal|6
block|,
literal|15
block|,
literal|0
block|,
literal|3
block|,
literal|4
block|,
literal|7
block|,
literal|2
block|,
literal|12
block|,
literal|1
block|,
literal|10
block|,
literal|14
block|,
literal|9
block|,
literal|10
block|,
literal|6
block|,
literal|9
block|,
literal|0
block|,
literal|12
block|,
literal|11
block|,
literal|7
block|,
literal|13
block|,
literal|15
block|,
literal|1
block|,
literal|3
block|,
literal|14
block|,
literal|5
block|,
literal|2
block|,
literal|8
block|,
literal|4
block|,
literal|3
block|,
literal|15
block|,
literal|0
block|,
literal|6
block|,
literal|10
block|,
literal|1
block|,
literal|13
block|,
literal|8
block|,
literal|9
block|,
literal|4
block|,
literal|5
block|,
literal|11
block|,
literal|12
block|,
literal|7
block|,
literal|2
block|,
literal|14
block|}
block|,
block|{
literal|2
block|,
literal|12
block|,
literal|4
block|,
literal|1
block|,
literal|7
block|,
literal|10
block|,
literal|11
block|,
literal|6
block|,
literal|8
block|,
literal|5
block|,
literal|3
block|,
literal|15
block|,
literal|13
block|,
literal|0
block|,
literal|14
block|,
literal|9
block|,
literal|14
block|,
literal|11
block|,
literal|2
block|,
literal|12
block|,
literal|4
block|,
literal|7
block|,
literal|13
block|,
literal|1
block|,
literal|5
block|,
literal|0
block|,
literal|15
block|,
literal|10
block|,
literal|3
block|,
literal|9
block|,
literal|8
block|,
literal|6
block|,
literal|4
block|,
literal|2
block|,
literal|1
block|,
literal|11
block|,
literal|10
block|,
literal|13
block|,
literal|7
block|,
literal|8
block|,
literal|15
block|,
literal|9
block|,
literal|12
block|,
literal|5
block|,
literal|6
block|,
literal|3
block|,
literal|0
block|,
literal|14
block|,
literal|11
block|,
literal|8
block|,
literal|12
block|,
literal|7
block|,
literal|1
block|,
literal|14
block|,
literal|2
block|,
literal|13
block|,
literal|6
block|,
literal|15
block|,
literal|0
block|,
literal|9
block|,
literal|10
block|,
literal|4
block|,
literal|5
block|,
literal|3
block|}
block|,
block|{
literal|12
block|,
literal|1
block|,
literal|10
block|,
literal|15
block|,
literal|9
block|,
literal|2
block|,
literal|6
block|,
literal|8
block|,
literal|0
block|,
literal|13
block|,
literal|3
block|,
literal|4
block|,
literal|14
block|,
literal|7
block|,
literal|5
block|,
literal|11
block|,
literal|10
block|,
literal|15
block|,
literal|4
block|,
literal|2
block|,
literal|7
block|,
literal|12
block|,
literal|9
block|,
literal|5
block|,
literal|6
block|,
literal|1
block|,
literal|13
block|,
literal|14
block|,
literal|0
block|,
literal|11
block|,
literal|3
block|,
literal|8
block|,
literal|9
block|,
literal|14
block|,
literal|15
block|,
literal|5
block|,
literal|2
block|,
literal|8
block|,
literal|12
block|,
literal|3
block|,
literal|7
block|,
literal|0
block|,
literal|4
block|,
literal|10
block|,
literal|1
block|,
literal|13
block|,
literal|11
block|,
literal|6
block|,
literal|4
block|,
literal|3
block|,
literal|2
block|,
literal|12
block|,
literal|9
block|,
literal|5
block|,
literal|15
block|,
literal|10
block|,
literal|11
block|,
literal|14
block|,
literal|1
block|,
literal|7
block|,
literal|6
block|,
literal|0
block|,
literal|8
block|,
literal|13
block|}
block|,
block|{
literal|4
block|,
literal|11
block|,
literal|2
block|,
literal|14
block|,
literal|15
block|,
literal|0
block|,
literal|8
block|,
literal|13
block|,
literal|3
block|,
literal|12
block|,
literal|9
block|,
literal|7
block|,
literal|5
block|,
literal|10
block|,
literal|6
block|,
literal|1
block|,
literal|13
block|,
literal|0
block|,
literal|11
block|,
literal|7
block|,
literal|4
block|,
literal|9
block|,
literal|1
block|,
literal|10
block|,
literal|14
block|,
literal|3
block|,
literal|5
block|,
literal|12
block|,
literal|2
block|,
literal|15
block|,
literal|8
block|,
literal|6
block|,
literal|1
block|,
literal|4
block|,
literal|11
block|,
literal|13
block|,
literal|12
block|,
literal|3
block|,
literal|7
block|,
literal|14
block|,
literal|10
block|,
literal|15
block|,
literal|6
block|,
literal|8
block|,
literal|0
block|,
literal|5
block|,
literal|9
block|,
literal|2
block|,
literal|6
block|,
literal|11
block|,
literal|13
block|,
literal|8
block|,
literal|1
block|,
literal|4
block|,
literal|10
block|,
literal|7
block|,
literal|9
block|,
literal|5
block|,
literal|0
block|,
literal|15
block|,
literal|14
block|,
literal|2
block|,
literal|3
block|,
literal|12
block|}
block|,
block|{
literal|13
block|,
literal|2
block|,
literal|8
block|,
literal|4
block|,
literal|6
block|,
literal|15
block|,
literal|11
block|,
literal|1
block|,
literal|10
block|,
literal|9
block|,
literal|3
block|,
literal|14
block|,
literal|5
block|,
literal|0
block|,
literal|12
block|,
literal|7
block|,
literal|1
block|,
literal|15
block|,
literal|13
block|,
literal|8
block|,
literal|10
block|,
literal|3
block|,
literal|7
block|,
literal|4
block|,
literal|12
block|,
literal|5
block|,
literal|6
block|,
literal|11
block|,
literal|0
block|,
literal|14
block|,
literal|9
block|,
literal|2
block|,
literal|7
block|,
literal|11
block|,
literal|4
block|,
literal|1
block|,
literal|9
block|,
literal|12
block|,
literal|14
block|,
literal|2
block|,
literal|0
block|,
literal|6
block|,
literal|10
block|,
literal|13
block|,
literal|15
block|,
literal|3
block|,
literal|5
block|,
literal|8
block|,
literal|2
block|,
literal|1
block|,
literal|14
block|,
literal|7
block|,
literal|4
block|,
literal|10
block|,
literal|8
block|,
literal|13
block|,
literal|15
block|,
literal|12
block|,
literal|9
block|,
literal|0
block|,
literal|3
block|,
literal|5
block|,
literal|6
block|,
literal|11
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_char
name|un_pbox
index|[
literal|32
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_char
name|pbox
index|[
literal|32
index|]
init|=
block|{
literal|16
block|,
literal|7
block|,
literal|20
block|,
literal|21
block|,
literal|29
block|,
literal|12
block|,
literal|28
block|,
literal|17
block|,
literal|1
block|,
literal|15
block|,
literal|23
block|,
literal|26
block|,
literal|5
block|,
literal|18
block|,
literal|31
block|,
literal|10
block|,
literal|2
block|,
literal|8
block|,
literal|24
block|,
literal|14
block|,
literal|32
block|,
literal|27
block|,
literal|3
block|,
literal|9
block|,
literal|19
block|,
literal|13
block|,
literal|30
block|,
literal|6
block|,
literal|22
block|,
literal|11
block|,
literal|4
block|,
literal|25
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int32_t
name|bits32
index|[
literal|32
index|]
init|=
block|{
literal|0x80000000
block|,
literal|0x40000000
block|,
literal|0x20000000
block|,
literal|0x10000000
block|,
literal|0x08000000
block|,
literal|0x04000000
block|,
literal|0x02000000
block|,
literal|0x01000000
block|,
literal|0x00800000
block|,
literal|0x00400000
block|,
literal|0x00200000
block|,
literal|0x00100000
block|,
literal|0x00080000
block|,
literal|0x00040000
block|,
literal|0x00020000
block|,
literal|0x00010000
block|,
literal|0x00008000
block|,
literal|0x00004000
block|,
literal|0x00002000
block|,
literal|0x00001000
block|,
literal|0x00000800
block|,
literal|0x00000400
block|,
literal|0x00000200
block|,
literal|0x00000100
block|,
literal|0x00000080
block|,
literal|0x00000040
block|,
literal|0x00000020
block|,
literal|0x00000010
block|,
literal|0x00000008
block|,
literal|0x00000004
block|,
literal|0x00000002
block|,
literal|0x00000001
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_char
name|bits8
index|[
literal|8
index|]
init|=
block|{
literal|0x80
block|,
literal|0x40
block|,
literal|0x20
block|,
literal|0x10
block|,
literal|0x08
block|,
literal|0x04
block|,
literal|0x02
block|,
literal|0x01
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int32_t
name|saltbits
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|old_salt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int32_t
modifier|*
name|bits28
decl_stmt|,
modifier|*
name|bits24
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_char
name|init_perm
index|[
literal|64
index|]
decl_stmt|,
name|final_perm
index|[
literal|64
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int32_t
name|en_keysl
index|[
literal|16
index|]
decl_stmt|,
name|en_keysr
index|[
literal|16
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int32_t
name|de_keysl
index|[
literal|16
index|]
decl_stmt|,
name|de_keysr
index|[
literal|16
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|des_initialised
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_char
name|m_sbox
index|[
literal|4
index|]
index|[
literal|4096
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int32_t
name|psbox
index|[
literal|4
index|]
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int32_t
name|ip_maskl
index|[
literal|8
index|]
index|[
literal|256
index|]
decl_stmt|,
name|ip_maskr
index|[
literal|8
index|]
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int32_t
name|fp_maskl
index|[
literal|8
index|]
index|[
literal|256
index|]
decl_stmt|,
name|fp_maskr
index|[
literal|8
index|]
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int32_t
name|key_perm_maskl
index|[
literal|8
index|]
index|[
literal|128
index|]
decl_stmt|,
name|key_perm_maskr
index|[
literal|8
index|]
index|[
literal|128
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int32_t
name|comp_maskl
index|[
literal|8
index|]
index|[
literal|128
index|]
decl_stmt|,
name|comp_maskr
index|[
literal|8
index|]
index|[
literal|128
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int32_t
name|old_rawkey0
decl_stmt|,
name|old_rawkey1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_char
name|ascii64
index|[]
init|=
literal|"./0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*	  0000000000111111111122222222223333333333444444444455555555556666 */
end_comment

begin_comment
comment|/*	  0123456789012345678901234567890123456789012345678901234567890123 */
end_comment

begin_function
specifier|static
name|INLINE
name|int
name|ascii_to_bin
parameter_list|(
name|char
name|ch
parameter_list|)
block|{
if|if
condition|(
name|ch
operator|>
literal|'z'
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|ch
operator|>=
literal|'a'
condition|)
return|return
operator|(
name|ch
operator|-
literal|'a'
operator|+
literal|38
operator|)
return|;
if|if
condition|(
name|ch
operator|>
literal|'Z'
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|ch
operator|>=
literal|'A'
condition|)
return|return
operator|(
name|ch
operator|-
literal|'A'
operator|+
literal|12
operator|)
return|;
if|if
condition|(
name|ch
operator|>
literal|'9'
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|ch
operator|>=
literal|'.'
condition|)
return|return
operator|(
name|ch
operator|-
literal|'.'
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|des_init
parameter_list|()
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|b
decl_stmt|,
name|k
decl_stmt|,
name|inbit
decl_stmt|,
name|obit
decl_stmt|;
name|u_int32_t
modifier|*
name|p
decl_stmt|,
modifier|*
name|il
decl_stmt|,
modifier|*
name|ir
decl_stmt|,
modifier|*
name|fl
decl_stmt|,
modifier|*
name|fr
decl_stmt|;
name|old_rawkey0
operator|=
name|old_rawkey1
operator|=
literal|0L
expr_stmt|;
name|saltbits
operator|=
literal|0L
expr_stmt|;
name|old_salt
operator|=
literal|0L
expr_stmt|;
name|bits24
operator|=
operator|(
name|bits28
operator|=
name|bits32
operator|+
literal|4
operator|)
operator|+
literal|4
expr_stmt|;
comment|/* 	 * Invert the S-boxes, reordering the input bits. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|64
condition|;
name|j
operator|++
control|)
block|{
name|b
operator|=
operator|(
name|j
operator|&
literal|0x20
operator|)
operator||
operator|(
operator|(
name|j
operator|&
literal|1
operator|)
operator|<<
literal|4
operator|)
operator||
operator|(
operator|(
name|j
operator|>>
literal|1
operator|)
operator|&
literal|0xf
operator|)
expr_stmt|;
name|u_sbox
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
name|sbox
index|[
name|i
index|]
index|[
name|b
index|]
expr_stmt|;
block|}
comment|/* 	 * Convert the inverted S-boxes into 4 arrays of 8 bits. 	 * Each will handle 12 bits of the S-box input. 	 */
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
literal|4
condition|;
name|b
operator|++
control|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|64
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|64
condition|;
name|j
operator|++
control|)
name|m_sbox
index|[
name|b
index|]
index|[
operator|(
name|i
operator|<<
literal|6
operator|)
operator||
name|j
index|]
operator|=
operator|(
name|u_sbox
index|[
operator|(
name|b
operator|<<
literal|1
operator|)
index|]
index|[
name|i
index|]
operator|<<
literal|4
operator|)
operator||
name|u_sbox
index|[
operator|(
name|b
operator|<<
literal|1
operator|)
operator|+
literal|1
index|]
index|[
name|j
index|]
expr_stmt|;
comment|/* 	 * Set up the initial& final permutations into a useful form, and 	 * initialise the inverted key permutation. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|64
condition|;
name|i
operator|++
control|)
block|{
name|init_perm
index|[
name|final_perm
index|[
name|i
index|]
operator|=
name|IP
index|[
name|i
index|]
operator|-
literal|1
index|]
operator|=
name|i
expr_stmt|;
name|inv_key_perm
index|[
name|i
index|]
operator|=
literal|255
expr_stmt|;
block|}
comment|/* 	 * Invert the key permutation and initialise the inverted key 	 * compression permutation. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|56
condition|;
name|i
operator|++
control|)
block|{
name|u_key_perm
index|[
name|i
index|]
operator|=
name|key_perm
index|[
name|i
index|]
operator|-
literal|1
expr_stmt|;
name|inv_key_perm
index|[
name|key_perm
index|[
name|i
index|]
operator|-
literal|1
index|]
operator|=
name|i
expr_stmt|;
name|inv_comp_perm
index|[
name|i
index|]
operator|=
literal|255
expr_stmt|;
block|}
comment|/* 	 * Invert the key compression permutation. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|48
condition|;
name|i
operator|++
control|)
block|{
name|inv_comp_perm
index|[
name|comp_perm
index|[
name|i
index|]
operator|-
literal|1
index|]
operator|=
name|i
expr_stmt|;
block|}
comment|/* 	 * Set up the OR-mask arrays for the initial and final permutations, 	 * and for the key initial and compression permutations. 	 */
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
literal|8
condition|;
name|k
operator|++
control|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
block|{
operator|*
operator|(
name|il
operator|=
operator|&
name|ip_maskl
index|[
name|k
index|]
index|[
name|i
index|]
operator|)
operator|=
literal|0L
expr_stmt|;
operator|*
operator|(
name|ir
operator|=
operator|&
name|ip_maskr
index|[
name|k
index|]
index|[
name|i
index|]
operator|)
operator|=
literal|0L
expr_stmt|;
operator|*
operator|(
name|fl
operator|=
operator|&
name|fp_maskl
index|[
name|k
index|]
index|[
name|i
index|]
operator|)
operator|=
literal|0L
expr_stmt|;
operator|*
operator|(
name|fr
operator|=
operator|&
name|fp_maskr
index|[
name|k
index|]
index|[
name|i
index|]
operator|)
operator|=
literal|0L
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|8
condition|;
name|j
operator|++
control|)
block|{
name|inbit
operator|=
literal|8
operator|*
name|k
operator|+
name|j
expr_stmt|;
if|if
condition|(
name|i
operator|&
name|bits8
index|[
name|j
index|]
condition|)
block|{
if|if
condition|(
operator|(
name|obit
operator|=
name|init_perm
index|[
name|inbit
index|]
operator|)
operator|<
literal|32
condition|)
operator|*
name|il
operator||=
name|bits32
index|[
name|obit
index|]
expr_stmt|;
else|else
operator|*
name|ir
operator||=
name|bits32
index|[
name|obit
operator|-
literal|32
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|obit
operator|=
name|final_perm
index|[
name|inbit
index|]
operator|)
operator|<
literal|32
condition|)
operator|*
name|fl
operator||=
name|bits32
index|[
name|obit
index|]
expr_stmt|;
else|else
operator|*
name|fr
operator||=
name|bits32
index|[
name|obit
operator|-
literal|32
index|]
expr_stmt|;
block|}
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|128
condition|;
name|i
operator|++
control|)
block|{
operator|*
operator|(
name|il
operator|=
operator|&
name|key_perm_maskl
index|[
name|k
index|]
index|[
name|i
index|]
operator|)
operator|=
literal|0L
expr_stmt|;
operator|*
operator|(
name|ir
operator|=
operator|&
name|key_perm_maskr
index|[
name|k
index|]
index|[
name|i
index|]
operator|)
operator|=
literal|0L
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|7
condition|;
name|j
operator|++
control|)
block|{
name|inbit
operator|=
literal|8
operator|*
name|k
operator|+
name|j
expr_stmt|;
if|if
condition|(
name|i
operator|&
name|bits8
index|[
name|j
operator|+
literal|1
index|]
condition|)
block|{
if|if
condition|(
operator|(
name|obit
operator|=
name|inv_key_perm
index|[
name|inbit
index|]
operator|)
operator|==
literal|255
condition|)
continue|continue;
if|if
condition|(
name|obit
operator|<
literal|28
condition|)
operator|*
name|il
operator||=
name|bits28
index|[
name|obit
index|]
expr_stmt|;
else|else
operator|*
name|ir
operator||=
name|bits28
index|[
name|obit
operator|-
literal|28
index|]
expr_stmt|;
block|}
block|}
operator|*
operator|(
name|il
operator|=
operator|&
name|comp_maskl
index|[
name|k
index|]
index|[
name|i
index|]
operator|)
operator|=
literal|0L
expr_stmt|;
operator|*
operator|(
name|ir
operator|=
operator|&
name|comp_maskr
index|[
name|k
index|]
index|[
name|i
index|]
operator|)
operator|=
literal|0L
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|7
condition|;
name|j
operator|++
control|)
block|{
name|inbit
operator|=
literal|7
operator|*
name|k
operator|+
name|j
expr_stmt|;
if|if
condition|(
name|i
operator|&
name|bits8
index|[
name|j
operator|+
literal|1
index|]
condition|)
block|{
if|if
condition|(
operator|(
name|obit
operator|=
name|inv_comp_perm
index|[
name|inbit
index|]
operator|)
operator|==
literal|255
condition|)
continue|continue;
if|if
condition|(
name|obit
operator|<
literal|24
condition|)
operator|*
name|il
operator||=
name|bits24
index|[
name|obit
index|]
expr_stmt|;
else|else
operator|*
name|ir
operator||=
name|bits24
index|[
name|obit
operator|-
literal|24
index|]
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* 	 * Invert the P-box permutation, and convert into OR-masks for 	 * handling the output of the S-box arrays setup above. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
name|un_pbox
index|[
name|pbox
index|[
name|i
index|]
operator|-
literal|1
index|]
operator|=
name|i
expr_stmt|;
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
literal|4
condition|;
name|b
operator|++
control|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
block|{
operator|*
operator|(
name|p
operator|=
operator|&
name|psbox
index|[
name|b
index|]
index|[
name|i
index|]
operator|)
operator|=
literal|0L
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|8
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|&
name|bits8
index|[
name|j
index|]
condition|)
operator|*
name|p
operator||=
name|bits32
index|[
name|un_pbox
index|[
literal|8
operator|*
name|b
operator|+
name|j
index|]
index|]
expr_stmt|;
block|}
block|}
name|des_initialised
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|setup_salt
parameter_list|(
name|long
name|salt
parameter_list|)
block|{
name|u_int32_t
name|obit
decl_stmt|,
name|saltbit
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|salt
operator|==
name|old_salt
condition|)
return|return;
name|old_salt
operator|=
name|salt
expr_stmt|;
name|saltbits
operator|=
literal|0L
expr_stmt|;
name|saltbit
operator|=
literal|1
expr_stmt|;
name|obit
operator|=
literal|0x800000
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|24
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|salt
operator|&
name|saltbit
condition|)
name|saltbits
operator||=
name|obit
expr_stmt|;
name|saltbit
operator|<<=
literal|1
expr_stmt|;
name|obit
operator|>>=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|des_setkey
parameter_list|(
specifier|const
name|char
modifier|*
name|key
parameter_list|)
block|{
name|u_int32_t
name|k0
decl_stmt|,
name|k1
decl_stmt|,
name|rawkey0
decl_stmt|,
name|rawkey1
decl_stmt|;
name|int
name|shifts
decl_stmt|,
name|round
decl_stmt|;
if|if
condition|(
operator|!
name|des_initialised
condition|)
name|des_init
argument_list|()
expr_stmt|;
name|rawkey0
operator|=
name|ntohl
argument_list|(
operator|*
operator|(
name|u_int32_t
operator|*
operator|)
name|key
argument_list|)
expr_stmt|;
name|rawkey1
operator|=
name|ntohl
argument_list|(
operator|*
operator|(
name|u_int32_t
operator|*
operator|)
operator|(
name|key
operator|+
literal|4
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rawkey0
operator||
name|rawkey1
operator|)
operator|&&
name|rawkey0
operator|==
name|old_rawkey0
operator|&&
name|rawkey1
operator|==
name|old_rawkey1
condition|)
block|{
comment|/* 		 * Already setup for this key. 		 * This optimisation fails on a zero key (which is weak and 		 * has bad parity anyway) in order to simplify the starting 		 * conditions. 		 */
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|old_rawkey0
operator|=
name|rawkey0
expr_stmt|;
name|old_rawkey1
operator|=
name|rawkey1
expr_stmt|;
comment|/* 	 *	Do key permutation and split into two 28-bit subkeys. 	 */
name|k0
operator|=
name|key_perm_maskl
index|[
literal|0
index|]
index|[
name|rawkey0
operator|>>
literal|25
index|]
operator||
name|key_perm_maskl
index|[
literal|1
index|]
index|[
operator|(
name|rawkey0
operator|>>
literal|17
operator|)
operator|&
literal|0x7f
index|]
operator||
name|key_perm_maskl
index|[
literal|2
index|]
index|[
operator|(
name|rawkey0
operator|>>
literal|9
operator|)
operator|&
literal|0x7f
index|]
operator||
name|key_perm_maskl
index|[
literal|3
index|]
index|[
operator|(
name|rawkey0
operator|>>
literal|1
operator|)
operator|&
literal|0x7f
index|]
operator||
name|key_perm_maskl
index|[
literal|4
index|]
index|[
name|rawkey1
operator|>>
literal|25
index|]
operator||
name|key_perm_maskl
index|[
literal|5
index|]
index|[
operator|(
name|rawkey1
operator|>>
literal|17
operator|)
operator|&
literal|0x7f
index|]
operator||
name|key_perm_maskl
index|[
literal|6
index|]
index|[
operator|(
name|rawkey1
operator|>>
literal|9
operator|)
operator|&
literal|0x7f
index|]
operator||
name|key_perm_maskl
index|[
literal|7
index|]
index|[
operator|(
name|rawkey1
operator|>>
literal|1
operator|)
operator|&
literal|0x7f
index|]
expr_stmt|;
name|k1
operator|=
name|key_perm_maskr
index|[
literal|0
index|]
index|[
name|rawkey0
operator|>>
literal|25
index|]
operator||
name|key_perm_maskr
index|[
literal|1
index|]
index|[
operator|(
name|rawkey0
operator|>>
literal|17
operator|)
operator|&
literal|0x7f
index|]
operator||
name|key_perm_maskr
index|[
literal|2
index|]
index|[
operator|(
name|rawkey0
operator|>>
literal|9
operator|)
operator|&
literal|0x7f
index|]
operator||
name|key_perm_maskr
index|[
literal|3
index|]
index|[
operator|(
name|rawkey0
operator|>>
literal|1
operator|)
operator|&
literal|0x7f
index|]
operator||
name|key_perm_maskr
index|[
literal|4
index|]
index|[
name|rawkey1
operator|>>
literal|25
index|]
operator||
name|key_perm_maskr
index|[
literal|5
index|]
index|[
operator|(
name|rawkey1
operator|>>
literal|17
operator|)
operator|&
literal|0x7f
index|]
operator||
name|key_perm_maskr
index|[
literal|6
index|]
index|[
operator|(
name|rawkey1
operator|>>
literal|9
operator|)
operator|&
literal|0x7f
index|]
operator||
name|key_perm_maskr
index|[
literal|7
index|]
index|[
operator|(
name|rawkey1
operator|>>
literal|1
operator|)
operator|&
literal|0x7f
index|]
expr_stmt|;
comment|/* 	 *	Rotate subkeys and do compression permutation. 	 */
name|shifts
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|round
operator|=
literal|0
init|;
name|round
operator|<
literal|16
condition|;
name|round
operator|++
control|)
block|{
name|u_int32_t
name|t0
decl_stmt|,
name|t1
decl_stmt|;
name|shifts
operator|+=
name|key_shifts
index|[
name|round
index|]
expr_stmt|;
name|t0
operator|=
operator|(
name|k0
operator|<<
name|shifts
operator|)
operator||
operator|(
name|k0
operator|>>
operator|(
literal|28
operator|-
name|shifts
operator|)
operator|)
expr_stmt|;
name|t1
operator|=
operator|(
name|k1
operator|<<
name|shifts
operator|)
operator||
operator|(
name|k1
operator|>>
operator|(
literal|28
operator|-
name|shifts
operator|)
operator|)
expr_stmt|;
name|de_keysl
index|[
literal|15
operator|-
name|round
index|]
operator|=
name|en_keysl
index|[
name|round
index|]
operator|=
name|comp_maskl
index|[
literal|0
index|]
index|[
operator|(
name|t0
operator|>>
literal|21
operator|)
operator|&
literal|0x7f
index|]
operator||
name|comp_maskl
index|[
literal|1
index|]
index|[
operator|(
name|t0
operator|>>
literal|14
operator|)
operator|&
literal|0x7f
index|]
operator||
name|comp_maskl
index|[
literal|2
index|]
index|[
operator|(
name|t0
operator|>>
literal|7
operator|)
operator|&
literal|0x7f
index|]
operator||
name|comp_maskl
index|[
literal|3
index|]
index|[
name|t0
operator|&
literal|0x7f
index|]
operator||
name|comp_maskl
index|[
literal|4
index|]
index|[
operator|(
name|t1
operator|>>
literal|21
operator|)
operator|&
literal|0x7f
index|]
operator||
name|comp_maskl
index|[
literal|5
index|]
index|[
operator|(
name|t1
operator|>>
literal|14
operator|)
operator|&
literal|0x7f
index|]
operator||
name|comp_maskl
index|[
literal|6
index|]
index|[
operator|(
name|t1
operator|>>
literal|7
operator|)
operator|&
literal|0x7f
index|]
operator||
name|comp_maskl
index|[
literal|7
index|]
index|[
name|t1
operator|&
literal|0x7f
index|]
expr_stmt|;
name|de_keysr
index|[
literal|15
operator|-
name|round
index|]
operator|=
name|en_keysr
index|[
name|round
index|]
operator|=
name|comp_maskr
index|[
literal|0
index|]
index|[
operator|(
name|t0
operator|>>
literal|21
operator|)
operator|&
literal|0x7f
index|]
operator||
name|comp_maskr
index|[
literal|1
index|]
index|[
operator|(
name|t0
operator|>>
literal|14
operator|)
operator|&
literal|0x7f
index|]
operator||
name|comp_maskr
index|[
literal|2
index|]
index|[
operator|(
name|t0
operator|>>
literal|7
operator|)
operator|&
literal|0x7f
index|]
operator||
name|comp_maskr
index|[
literal|3
index|]
index|[
name|t0
operator|&
literal|0x7f
index|]
operator||
name|comp_maskr
index|[
literal|4
index|]
index|[
operator|(
name|t1
operator|>>
literal|21
operator|)
operator|&
literal|0x7f
index|]
operator||
name|comp_maskr
index|[
literal|5
index|]
index|[
operator|(
name|t1
operator|>>
literal|14
operator|)
operator|&
literal|0x7f
index|]
operator||
name|comp_maskr
index|[
literal|6
index|]
index|[
operator|(
name|t1
operator|>>
literal|7
operator|)
operator|&
literal|0x7f
index|]
operator||
name|comp_maskr
index|[
literal|7
index|]
index|[
name|t1
operator|&
literal|0x7f
index|]
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|do_des
parameter_list|(
name|u_int32_t
name|l_in
parameter_list|,
name|u_int32_t
name|r_in
parameter_list|,
name|u_int32_t
modifier|*
name|l_out
parameter_list|,
name|u_int32_t
modifier|*
name|r_out
parameter_list|,
name|int
name|count
parameter_list|)
block|{
comment|/* 	 *	l_in, r_in, l_out, and r_out are in pseudo-"big-endian" format. 	 */
name|u_int32_t
name|l
decl_stmt|,
name|r
decl_stmt|,
modifier|*
name|kl
decl_stmt|,
modifier|*
name|kr
decl_stmt|,
modifier|*
name|kl1
decl_stmt|,
modifier|*
name|kr1
decl_stmt|;
name|u_int32_t
name|f
decl_stmt|,
name|r48l
decl_stmt|,
name|r48r
decl_stmt|;
name|int
name|round
decl_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|count
operator|>
literal|0
condition|)
block|{
comment|/* 		 * Encrypting 		 */
name|kl1
operator|=
name|en_keysl
expr_stmt|;
name|kr1
operator|=
name|en_keysr
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Decrypting 		 */
name|count
operator|=
operator|-
name|count
expr_stmt|;
name|kl1
operator|=
name|de_keysl
expr_stmt|;
name|kr1
operator|=
name|de_keysr
expr_stmt|;
block|}
comment|/* 	 *	Do initial permutation (IP). 	 */
name|l
operator|=
name|ip_maskl
index|[
literal|0
index|]
index|[
name|l_in
operator|>>
literal|24
index|]
operator||
name|ip_maskl
index|[
literal|1
index|]
index|[
operator|(
name|l_in
operator|>>
literal|16
operator|)
operator|&
literal|0xff
index|]
operator||
name|ip_maskl
index|[
literal|2
index|]
index|[
operator|(
name|l_in
operator|>>
literal|8
operator|)
operator|&
literal|0xff
index|]
operator||
name|ip_maskl
index|[
literal|3
index|]
index|[
name|l_in
operator|&
literal|0xff
index|]
operator||
name|ip_maskl
index|[
literal|4
index|]
index|[
name|r_in
operator|>>
literal|24
index|]
operator||
name|ip_maskl
index|[
literal|5
index|]
index|[
operator|(
name|r_in
operator|>>
literal|16
operator|)
operator|&
literal|0xff
index|]
operator||
name|ip_maskl
index|[
literal|6
index|]
index|[
operator|(
name|r_in
operator|>>
literal|8
operator|)
operator|&
literal|0xff
index|]
operator||
name|ip_maskl
index|[
literal|7
index|]
index|[
name|r_in
operator|&
literal|0xff
index|]
expr_stmt|;
name|r
operator|=
name|ip_maskr
index|[
literal|0
index|]
index|[
name|l_in
operator|>>
literal|24
index|]
operator||
name|ip_maskr
index|[
literal|1
index|]
index|[
operator|(
name|l_in
operator|>>
literal|16
operator|)
operator|&
literal|0xff
index|]
operator||
name|ip_maskr
index|[
literal|2
index|]
index|[
operator|(
name|l_in
operator|>>
literal|8
operator|)
operator|&
literal|0xff
index|]
operator||
name|ip_maskr
index|[
literal|3
index|]
index|[
name|l_in
operator|&
literal|0xff
index|]
operator||
name|ip_maskr
index|[
literal|4
index|]
index|[
name|r_in
operator|>>
literal|24
index|]
operator||
name|ip_maskr
index|[
literal|5
index|]
index|[
operator|(
name|r_in
operator|>>
literal|16
operator|)
operator|&
literal|0xff
index|]
operator||
name|ip_maskr
index|[
literal|6
index|]
index|[
operator|(
name|r_in
operator|>>
literal|8
operator|)
operator|&
literal|0xff
index|]
operator||
name|ip_maskr
index|[
literal|7
index|]
index|[
name|r_in
operator|&
literal|0xff
index|]
expr_stmt|;
while|while
condition|(
name|count
operator|--
condition|)
block|{
comment|/* 		 * Do each round. 		 */
name|kl
operator|=
name|kl1
expr_stmt|;
name|kr
operator|=
name|kr1
expr_stmt|;
name|round
operator|=
literal|16
expr_stmt|;
while|while
condition|(
name|round
operator|--
condition|)
block|{
comment|/* 			 * Expand R to 48 bits (simulate the E-box). 			 */
name|r48l
operator|=
operator|(
operator|(
name|r
operator|&
literal|0x00000001
operator|)
operator|<<
literal|23
operator|)
operator||
operator|(
operator|(
name|r
operator|&
literal|0xf8000000
operator|)
operator|>>
literal|9
operator|)
operator||
operator|(
operator|(
name|r
operator|&
literal|0x1f800000
operator|)
operator|>>
literal|11
operator|)
operator||
operator|(
operator|(
name|r
operator|&
literal|0x01f80000
operator|)
operator|>>
literal|13
operator|)
operator||
operator|(
operator|(
name|r
operator|&
literal|0x001f8000
operator|)
operator|>>
literal|15
operator|)
expr_stmt|;
name|r48r
operator|=
operator|(
operator|(
name|r
operator|&
literal|0x0001f800
operator|)
operator|<<
literal|7
operator|)
operator||
operator|(
operator|(
name|r
operator|&
literal|0x00001f80
operator|)
operator|<<
literal|5
operator|)
operator||
operator|(
operator|(
name|r
operator|&
literal|0x000001f8
operator|)
operator|<<
literal|3
operator|)
operator||
operator|(
operator|(
name|r
operator|&
literal|0x0000001f
operator|)
operator|<<
literal|1
operator|)
operator||
operator|(
operator|(
name|r
operator|&
literal|0x80000000
operator|)
operator|>>
literal|31
operator|)
expr_stmt|;
comment|/* 			 * Do salting for crypt() and friends, and 			 * XOR with the permuted key. 			 */
name|f
operator|=
operator|(
name|r48l
operator|^
name|r48r
operator|)
operator|&
name|saltbits
expr_stmt|;
name|r48l
operator|^=
name|f
operator|^
operator|*
name|kl
operator|++
expr_stmt|;
name|r48r
operator|^=
name|f
operator|^
operator|*
name|kr
operator|++
expr_stmt|;
comment|/* 			 * Do sbox lookups (which shrink it back to 32 bits) 			 * and do the pbox permutation at the same time. 			 */
name|f
operator|=
name|psbox
index|[
literal|0
index|]
index|[
name|m_sbox
index|[
literal|0
index|]
index|[
name|r48l
operator|>>
literal|12
index|]
index|]
operator||
name|psbox
index|[
literal|1
index|]
index|[
name|m_sbox
index|[
literal|1
index|]
index|[
name|r48l
operator|&
literal|0xfff
index|]
index|]
operator||
name|psbox
index|[
literal|2
index|]
index|[
name|m_sbox
index|[
literal|2
index|]
index|[
name|r48r
operator|>>
literal|12
index|]
index|]
operator||
name|psbox
index|[
literal|3
index|]
index|[
name|m_sbox
index|[
literal|3
index|]
index|[
name|r48r
operator|&
literal|0xfff
index|]
index|]
expr_stmt|;
comment|/* 			 * Now that we've permuted things, complete f(). 			 */
name|f
operator|^=
name|l
expr_stmt|;
name|l
operator|=
name|r
expr_stmt|;
name|r
operator|=
name|f
expr_stmt|;
block|}
name|r
operator|=
name|l
expr_stmt|;
name|l
operator|=
name|f
expr_stmt|;
block|}
comment|/* 	 * Do final permutation (inverse of IP). 	 */
operator|*
name|l_out
operator|=
name|fp_maskl
index|[
literal|0
index|]
index|[
name|l
operator|>>
literal|24
index|]
operator||
name|fp_maskl
index|[
literal|1
index|]
index|[
operator|(
name|l
operator|>>
literal|16
operator|)
operator|&
literal|0xff
index|]
operator||
name|fp_maskl
index|[
literal|2
index|]
index|[
operator|(
name|l
operator|>>
literal|8
operator|)
operator|&
literal|0xff
index|]
operator||
name|fp_maskl
index|[
literal|3
index|]
index|[
name|l
operator|&
literal|0xff
index|]
operator||
name|fp_maskl
index|[
literal|4
index|]
index|[
name|r
operator|>>
literal|24
index|]
operator||
name|fp_maskl
index|[
literal|5
index|]
index|[
operator|(
name|r
operator|>>
literal|16
operator|)
operator|&
literal|0xff
index|]
operator||
name|fp_maskl
index|[
literal|6
index|]
index|[
operator|(
name|r
operator|>>
literal|8
operator|)
operator|&
literal|0xff
index|]
operator||
name|fp_maskl
index|[
literal|7
index|]
index|[
name|r
operator|&
literal|0xff
index|]
expr_stmt|;
operator|*
name|r_out
operator|=
name|fp_maskr
index|[
literal|0
index|]
index|[
name|l
operator|>>
literal|24
index|]
operator||
name|fp_maskr
index|[
literal|1
index|]
index|[
operator|(
name|l
operator|>>
literal|16
operator|)
operator|&
literal|0xff
index|]
operator||
name|fp_maskr
index|[
literal|2
index|]
index|[
operator|(
name|l
operator|>>
literal|8
operator|)
operator|&
literal|0xff
index|]
operator||
name|fp_maskr
index|[
literal|3
index|]
index|[
name|l
operator|&
literal|0xff
index|]
operator||
name|fp_maskr
index|[
literal|4
index|]
index|[
name|r
operator|>>
literal|24
index|]
operator||
name|fp_maskr
index|[
literal|5
index|]
index|[
operator|(
name|r
operator|>>
literal|16
operator|)
operator|&
literal|0xff
index|]
operator||
name|fp_maskr
index|[
literal|6
index|]
index|[
operator|(
name|r
operator|>>
literal|8
operator|)
operator|&
literal|0xff
index|]
operator||
name|fp_maskr
index|[
literal|7
index|]
index|[
name|r
operator|&
literal|0xff
index|]
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|des_cipher
parameter_list|(
specifier|const
name|char
modifier|*
name|in
parameter_list|,
name|char
modifier|*
name|out
parameter_list|,
name|long
name|salt
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|u_int32_t
name|l_out
decl_stmt|,
name|r_out
decl_stmt|,
name|rawl
decl_stmt|,
name|rawr
decl_stmt|;
name|int
name|retval
decl_stmt|;
if|if
condition|(
operator|!
name|des_initialised
condition|)
name|des_init
argument_list|()
expr_stmt|;
name|setup_salt
argument_list|(
name|salt
argument_list|)
expr_stmt|;
name|rawl
operator|=
name|ntohl
argument_list|(
operator|*
operator|(
operator|(
name|u_int32_t
operator|*
operator|)
name|in
operator|)
operator|++
argument_list|)
expr_stmt|;
name|rawr
operator|=
name|ntohl
argument_list|(
operator|*
operator|(
operator|(
name|u_int32_t
operator|*
operator|)
name|in
operator|)
argument_list|)
expr_stmt|;
name|retval
operator|=
name|do_des
argument_list|(
name|rawl
argument_list|,
name|rawr
argument_list|,
operator|&
name|l_out
argument_list|,
operator|&
name|r_out
argument_list|,
name|count
argument_list|)
expr_stmt|;
operator|*
operator|(
operator|(
name|u_int32_t
operator|*
operator|)
name|out
operator|)
operator|++
operator|=
name|htonl
argument_list|(
name|l_out
argument_list|)
expr_stmt|;
operator|*
operator|(
operator|(
name|u_int32_t
operator|*
operator|)
name|out
operator|)
operator|=
name|htonl
argument_list|(
name|r_out
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|crypt_des
parameter_list|(
specifier|const
name|char
modifier|*
name|key
parameter_list|,
specifier|const
name|char
modifier|*
name|setting
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|u_int32_t
name|count
decl_stmt|,
name|salt
decl_stmt|,
name|l
decl_stmt|,
name|r0
decl_stmt|,
name|r1
decl_stmt|,
name|keybuf
index|[
literal|2
index|]
decl_stmt|;
name|u_char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
specifier|static
name|u_char
name|output
index|[
literal|21
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|des_initialised
condition|)
name|des_init
argument_list|()
expr_stmt|;
comment|/* 	 * Copy the key, shifting each character up by one bit 	 * and padding with zeros. 	 */
name|q
operator|=
operator|(
name|u_char
operator|*
operator|)
name|keybuf
expr_stmt|;
while|while
condition|(
name|q
operator|-
operator|(
name|u_char
operator|*
operator|)
name|keybuf
operator|-
literal|8
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|q
operator|++
operator|=
operator|*
name|key
operator|<<
literal|1
operator|)
condition|)
name|key
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|des_setkey
argument_list|(
operator|(
name|u_char
operator|*
operator|)
name|keybuf
argument_list|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
operator|*
name|setting
operator|==
name|_PASSWORD_EFMT1
condition|)
block|{
comment|/* 		 * "new"-style: 		 *	setting - underscore, 4 bytes of count, 4 bytes of salt 		 *	key - unlimited characters 		 */
for|for
control|(
name|i
operator|=
literal|1
operator|,
name|count
operator|=
literal|0L
init|;
name|i
operator|<
literal|5
condition|;
name|i
operator|++
control|)
name|count
operator||=
name|ascii_to_bin
argument_list|(
name|setting
index|[
name|i
index|]
argument_list|)
operator|<<
operator|(
name|i
operator|-
literal|1
operator|)
operator|*
literal|6
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|5
operator|,
name|salt
operator|=
literal|0L
init|;
name|i
operator|<
literal|9
condition|;
name|i
operator|++
control|)
name|salt
operator||=
name|ascii_to_bin
argument_list|(
name|setting
index|[
name|i
index|]
argument_list|)
operator|<<
operator|(
name|i
operator|-
literal|5
operator|)
operator|*
literal|6
expr_stmt|;
while|while
condition|(
operator|*
name|key
condition|)
block|{
comment|/* 			 * Encrypt the key with itself. 			 */
if|if
condition|(
name|des_cipher
argument_list|(
operator|(
name|u_char
operator|*
operator|)
name|keybuf
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|keybuf
argument_list|,
literal|0L
argument_list|,
literal|1
argument_list|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* 			 * And XOR with the next 8 characters of the key. 			 */
name|q
operator|=
operator|(
name|u_char
operator|*
operator|)
name|keybuf
expr_stmt|;
while|while
condition|(
name|q
operator|-
operator|(
name|u_char
operator|*
operator|)
name|keybuf
operator|-
literal|8
operator|&&
operator|*
name|key
condition|)
operator|*
name|q
operator|++
operator|^=
operator|*
name|key
operator|++
operator|<<
literal|1
expr_stmt|;
if|if
condition|(
name|des_setkey
argument_list|(
operator|(
name|u_char
operator|*
operator|)
name|keybuf
argument_list|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|strncpy
argument_list|(
name|output
argument_list|,
name|setting
argument_list|,
literal|9
argument_list|)
expr_stmt|;
comment|/* 		 * Double check that we weren't given a short setting. 		 * If we were, the above code will probably have created 		 * wierd values for count and salt, but we don't really care. 		 * Just make sure the output string doesn't have an extra 		 * NUL in it. 		 */
name|output
index|[
literal|9
index|]
operator|=
literal|'\0'
expr_stmt|;
name|p
operator|=
name|output
operator|+
name|strlen
argument_list|(
name|output
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * "old"-style: 		 *	setting - 2 bytes of salt 		 *	key - up to 8 characters 		 */
name|count
operator|=
literal|25
expr_stmt|;
name|salt
operator|=
operator|(
name|ascii_to_bin
argument_list|(
name|setting
index|[
literal|1
index|]
argument_list|)
operator|<<
literal|6
operator|)
operator||
name|ascii_to_bin
argument_list|(
name|setting
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|output
index|[
literal|0
index|]
operator|=
name|setting
index|[
literal|0
index|]
expr_stmt|;
comment|/* 		 * If the encrypted password that the salt was extracted from 		 * is only 1 character long, the salt will be corrupted.  We 		 * need to ensure that the output string doesn't have an extra 		 * NUL in it! 		 */
name|output
index|[
literal|1
index|]
operator|=
name|setting
index|[
literal|1
index|]
condition|?
name|setting
index|[
literal|1
index|]
else|:
name|output
index|[
literal|0
index|]
expr_stmt|;
name|p
operator|=
name|output
operator|+
literal|2
expr_stmt|;
block|}
name|setup_salt
argument_list|(
name|salt
argument_list|)
expr_stmt|;
comment|/* 	 * Do it. 	 */
if|if
condition|(
name|do_des
argument_list|(
literal|0L
argument_list|,
literal|0L
argument_list|,
operator|&
name|r0
argument_list|,
operator|&
name|r1
argument_list|,
name|count
argument_list|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* 	 * Now encode the result... 	 */
name|l
operator|=
operator|(
name|r0
operator|>>
literal|8
operator|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|ascii64
index|[
operator|(
name|l
operator|>>
literal|18
operator|)
operator|&
literal|0x3f
index|]
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|ascii64
index|[
operator|(
name|l
operator|>>
literal|12
operator|)
operator|&
literal|0x3f
index|]
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|ascii64
index|[
operator|(
name|l
operator|>>
literal|6
operator|)
operator|&
literal|0x3f
index|]
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|ascii64
index|[
name|l
operator|&
literal|0x3f
index|]
expr_stmt|;
name|l
operator|=
operator|(
name|r0
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
name|r1
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
operator|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|ascii64
index|[
operator|(
name|l
operator|>>
literal|18
operator|)
operator|&
literal|0x3f
index|]
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|ascii64
index|[
operator|(
name|l
operator|>>
literal|12
operator|)
operator|&
literal|0x3f
index|]
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|ascii64
index|[
operator|(
name|l
operator|>>
literal|6
operator|)
operator|&
literal|0x3f
index|]
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|ascii64
index|[
name|l
operator|&
literal|0x3f
index|]
expr_stmt|;
name|l
operator|=
name|r1
operator|<<
literal|2
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|ascii64
index|[
operator|(
name|l
operator|>>
literal|12
operator|)
operator|&
literal|0x3f
index|]
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|ascii64
index|[
operator|(
name|l
operator|>>
literal|6
operator|)
operator|&
literal|0x3f
index|]
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|ascii64
index|[
name|l
operator|&
literal|0x3f
index|]
expr_stmt|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|output
operator|)
return|;
block|}
end_function

end_unit

