begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * EAP peer state machines (RFC 4137)  * Copyright (c) 2004-2014, Jouni Malinen<j@w1.fi>  *  * This software may be distributed under the terms of the BSD license.  * See README for more details.  *  * This file implements the Peer State Machine as defined in RFC 4137. The used  * states and state transitions match mostly with the RFC. However, there are  * couple of additional transitions for working around small issues noticed  * during testing. These exceptions are explained in comments within the  * functions in this file. The method functions, m.func(), are similar to the  * ones used in RFC 4137, but some small changes have used here to optimize  * operations and to add functionality needed for fast re-authentication  * (session resumption).  */
end_comment

begin_include
include|#
directive|include
file|"includes.h"
end_include

begin_include
include|#
directive|include
file|"common.h"
end_include

begin_include
include|#
directive|include
file|"pcsc_funcs.h"
end_include

begin_include
include|#
directive|include
file|"state_machine.h"
end_include

begin_include
include|#
directive|include
file|"ext_password.h"
end_include

begin_include
include|#
directive|include
file|"crypto/crypto.h"
end_include

begin_include
include|#
directive|include
file|"crypto/tls.h"
end_include

begin_include
include|#
directive|include
file|"crypto/sha256.h"
end_include

begin_include
include|#
directive|include
file|"common/wpa_ctrl.h"
end_include

begin_include
include|#
directive|include
file|"eap_common/eap_wsc_common.h"
end_include

begin_include
include|#
directive|include
file|"eap_i.h"
end_include

begin_include
include|#
directive|include
file|"eap_config.h"
end_include

begin_define
define|#
directive|define
name|STATE_MACHINE_DATA
value|struct eap_sm
end_define

begin_define
define|#
directive|define
name|STATE_MACHINE_DEBUG_PREFIX
value|"EAP"
end_define

begin_define
define|#
directive|define
name|EAP_MAX_AUTH_ROUNDS
value|50
end_define

begin_define
define|#
directive|define
name|EAP_CLIENT_TIMEOUT_DEFAULT
value|60
end_define

begin_function_decl
specifier|static
name|Boolean
name|eap_sm_allowMethod
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|int
name|vendor
parameter_list|,
name|EapType
name|method
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|wpabuf
modifier|*
name|eap_sm_buildNak
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|int
name|id
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|eap_sm_processIdentity
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
specifier|const
name|struct
name|wpabuf
modifier|*
name|req
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|eap_sm_processNotify
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
specifier|const
name|struct
name|wpabuf
modifier|*
name|req
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|wpabuf
modifier|*
name|eap_sm_buildNotify
parameter_list|(
name|int
name|id
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|eap_sm_parseEapReq
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
specifier|const
name|struct
name|wpabuf
modifier|*
name|req
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|defined
argument_list|(
name|CONFIG_CTRL_IFACE
argument_list|)
operator|||
operator|!
name|defined
argument_list|(
name|CONFIG_NO_STDOUT_DEBUG
argument_list|)
end_if

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|eap_sm_method_state_txt
parameter_list|(
name|EapMethodState
name|state
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|eap_sm_decision_txt
parameter_list|(
name|EapDecision
name|decision
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CONFIG_CTRL_IFACE || !CONFIG_NO_STDOUT_DEBUG */
end_comment

begin_function
specifier|static
name|Boolean
name|eapol_get_bool
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|enum
name|eapol_bool_var
name|var
parameter_list|)
block|{
return|return
name|sm
operator|->
name|eapol_cb
operator|->
name|get_bool
argument_list|(
name|sm
operator|->
name|eapol_ctx
argument_list|,
name|var
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|eapol_set_bool
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|enum
name|eapol_bool_var
name|var
parameter_list|,
name|Boolean
name|value
parameter_list|)
block|{
name|sm
operator|->
name|eapol_cb
operator|->
name|set_bool
argument_list|(
name|sm
operator|->
name|eapol_ctx
argument_list|,
name|var
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|int
name|eapol_get_int
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|enum
name|eapol_int_var
name|var
parameter_list|)
block|{
return|return
name|sm
operator|->
name|eapol_cb
operator|->
name|get_int
argument_list|(
name|sm
operator|->
name|eapol_ctx
argument_list|,
name|var
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|eapol_set_int
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|enum
name|eapol_int_var
name|var
parameter_list|,
name|unsigned
name|int
name|value
parameter_list|)
block|{
name|sm
operator|->
name|eapol_cb
operator|->
name|set_int
argument_list|(
name|sm
operator|->
name|eapol_ctx
argument_list|,
name|var
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|wpabuf
modifier|*
name|eapol_get_eapReqData
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|)
block|{
return|return
name|sm
operator|->
name|eapol_cb
operator|->
name|get_eapReqData
argument_list|(
name|sm
operator|->
name|eapol_ctx
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|eap_notify_status
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
specifier|const
name|char
modifier|*
name|status
parameter_list|,
specifier|const
name|char
modifier|*
name|parameter
parameter_list|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: Status notification: %s (param=%s)"
argument_list|,
name|status
argument_list|,
name|parameter
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|eapol_cb
operator|->
name|notify_status
condition|)
name|sm
operator|->
name|eapol_cb
operator|->
name|notify_status
argument_list|(
name|sm
operator|->
name|eapol_ctx
argument_list|,
name|status
argument_list|,
name|parameter
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|eap_sm_free_key
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|)
block|{
if|if
condition|(
name|sm
operator|->
name|eapKeyData
condition|)
block|{
name|bin_clear_free
argument_list|(
name|sm
operator|->
name|eapKeyData
argument_list|,
name|sm
operator|->
name|eapKeyDataLen
argument_list|)
expr_stmt|;
name|sm
operator|->
name|eapKeyData
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|eap_deinit_prev_method
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
specifier|const
name|char
modifier|*
name|txt
parameter_list|)
block|{
name|ext_password_free
argument_list|(
name|sm
operator|->
name|ext_pw_buf
argument_list|)
expr_stmt|;
name|sm
operator|->
name|ext_pw_buf
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|m
operator|==
name|NULL
operator|||
name|sm
operator|->
name|eap_method_priv
operator|==
name|NULL
condition|)
return|return;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: deinitialize previously used EAP method "
literal|"(%d, %s) at %s"
argument_list|,
name|sm
operator|->
name|selectedMethod
argument_list|,
name|sm
operator|->
name|m
operator|->
name|name
argument_list|,
name|txt
argument_list|)
expr_stmt|;
name|sm
operator|->
name|m
operator|->
name|deinit
argument_list|(
name|sm
argument_list|,
name|sm
operator|->
name|eap_method_priv
argument_list|)
expr_stmt|;
name|sm
operator|->
name|eap_method_priv
operator|=
name|NULL
expr_stmt|;
name|sm
operator|->
name|m
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * eap_allowed_method - Check whether EAP method is allowed  * @sm: Pointer to EAP state machine allocated with eap_peer_sm_init()  * @vendor: Vendor-Id for expanded types or 0 = IETF for legacy types  * @method: EAP type  * Returns: 1 = allowed EAP method, 0 = not allowed  */
end_comment

begin_function
name|int
name|eap_allowed_method
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|int
name|vendor
parameter_list|,
name|u32
name|method
parameter_list|)
block|{
name|struct
name|eap_peer_config
modifier|*
name|config
init|=
name|eap_get_config
argument_list|(
name|sm
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|eap_method_type
modifier|*
name|m
decl_stmt|;
if|if
condition|(
name|config
operator|==
name|NULL
operator|||
name|config
operator|->
name|eap_methods
operator|==
name|NULL
condition|)
return|return
literal|1
return|;
name|m
operator|=
name|config
operator|->
name|eap_methods
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|m
index|[
name|i
index|]
operator|.
name|vendor
operator|!=
name|EAP_VENDOR_IETF
operator|||
name|m
index|[
name|i
index|]
operator|.
name|method
operator|!=
name|EAP_TYPE_NONE
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|m
index|[
name|i
index|]
operator|.
name|vendor
operator|==
name|vendor
operator|&&
name|m
index|[
name|i
index|]
operator|.
name|method
operator|==
name|method
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * This state initializes state machine variables when the machine is  * activated (portEnabled = TRUE). This is also used when re-starting  * authentication (eapRestart == TRUE).  */
end_comment

begin_macro
name|SM_STATE
argument_list|(
argument|EAP
argument_list|,
argument|INITIALIZE
argument_list|)
end_macro

begin_block
block|{
name|SM_ENTRY
argument_list|(
name|EAP
argument_list|,
name|INITIALIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|fast_reauth
operator|&&
name|sm
operator|->
name|m
operator|&&
name|sm
operator|->
name|m
operator|->
name|has_reauth_data
operator|&&
name|sm
operator|->
name|m
operator|->
name|has_reauth_data
argument_list|(
name|sm
argument_list|,
name|sm
operator|->
name|eap_method_priv
argument_list|)
operator|&&
operator|!
name|sm
operator|->
name|prev_failure
operator|&&
name|sm
operator|->
name|last_config
operator|==
name|eap_get_config
argument_list|(
name|sm
argument_list|)
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: maintaining EAP method data for "
literal|"fast reauthentication"
argument_list|)
expr_stmt|;
name|sm
operator|->
name|m
operator|->
name|deinit_for_reauth
argument_list|(
name|sm
argument_list|,
name|sm
operator|->
name|eap_method_priv
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sm
operator|->
name|last_config
operator|=
name|eap_get_config
argument_list|(
name|sm
argument_list|)
expr_stmt|;
name|eap_deinit_prev_method
argument_list|(
name|sm
argument_list|,
literal|"INITIALIZE"
argument_list|)
expr_stmt|;
block|}
name|sm
operator|->
name|selectedMethod
operator|=
name|EAP_TYPE_NONE
expr_stmt|;
name|sm
operator|->
name|methodState
operator|=
name|METHOD_NONE
expr_stmt|;
name|sm
operator|->
name|allowNotifications
operator|=
name|TRUE
expr_stmt|;
name|sm
operator|->
name|decision
operator|=
name|DECISION_FAIL
expr_stmt|;
name|sm
operator|->
name|ClientTimeout
operator|=
name|EAP_CLIENT_TIMEOUT_DEFAULT
expr_stmt|;
name|eapol_set_int
argument_list|(
name|sm
argument_list|,
name|EAPOL_idleWhile
argument_list|,
name|sm
operator|->
name|ClientTimeout
argument_list|)
expr_stmt|;
name|eapol_set_bool
argument_list|(
name|sm
argument_list|,
name|EAPOL_eapSuccess
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|eapol_set_bool
argument_list|(
name|sm
argument_list|,
name|EAPOL_eapFail
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|eap_sm_free_key
argument_list|(
name|sm
argument_list|)
expr_stmt|;
name|os_free
argument_list|(
name|sm
operator|->
name|eapSessionId
argument_list|)
expr_stmt|;
name|sm
operator|->
name|eapSessionId
operator|=
name|NULL
expr_stmt|;
name|sm
operator|->
name|eapKeyAvailable
operator|=
name|FALSE
expr_stmt|;
name|eapol_set_bool
argument_list|(
name|sm
argument_list|,
name|EAPOL_eapRestart
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|sm
operator|->
name|lastId
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* new session - make sure this does not match with 			  * the first EAP-Packet */
comment|/* 	 * RFC 4137 does not reset eapResp and eapNoResp here. However, this 	 * seemed to be able to trigger cases where both were set and if EAPOL 	 * state machine uses eapNoResp first, it may end up not sending a real 	 * reply correctly. This occurred when the workaround in FAIL state set 	 * eapNoResp = TRUE.. Maybe that workaround needs to be fixed to do 	 * something else(?) 	 */
name|eapol_set_bool
argument_list|(
name|sm
argument_list|,
name|EAPOL_eapResp
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|eapol_set_bool
argument_list|(
name|sm
argument_list|,
name|EAPOL_eapNoResp
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|sm
operator|->
name|num_rounds
operator|=
literal|0
expr_stmt|;
name|sm
operator|->
name|prev_failure
operator|=
literal|0
expr_stmt|;
name|sm
operator|->
name|expected_failure
operator|=
literal|0
expr_stmt|;
name|sm
operator|->
name|reauthInit
operator|=
name|FALSE
expr_stmt|;
name|sm
operator|->
name|erp_seq
operator|=
operator|(
name|u32
operator|)
operator|-
literal|1
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * This state is reached whenever service from the lower layer is interrupted  * or unavailable (portEnabled == FALSE). Immediate transition to INITIALIZE  * occurs when the port becomes enabled.  */
end_comment

begin_macro
name|SM_STATE
argument_list|(
argument|EAP
argument_list|,
argument|DISABLED
argument_list|)
end_macro

begin_block
block|{
name|SM_ENTRY
argument_list|(
name|EAP
argument_list|,
name|DISABLED
argument_list|)
expr_stmt|;
name|sm
operator|->
name|num_rounds
operator|=
literal|0
expr_stmt|;
comment|/* 	 * RFC 4137 does not describe clearing of idleWhile here, but doing so 	 * allows the timer tick to be stopped more quickly when EAP is not in 	 * use. 	 */
name|eapol_set_int
argument_list|(
name|sm
argument_list|,
name|EAPOL_idleWhile
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * The state machine spends most of its time here, waiting for something to  * happen. This state is entered unconditionally from INITIALIZE, DISCARD, and  * SEND_RESPONSE states.  */
end_comment

begin_macro
name|SM_STATE
argument_list|(
argument|EAP
argument_list|,
argument|IDLE
argument_list|)
end_macro

begin_block
block|{
name|SM_ENTRY
argument_list|(
name|EAP
argument_list|,
name|IDLE
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * This state is entered when an EAP packet is received (eapReq == TRUE) to  * parse the packet header.  */
end_comment

begin_macro
name|SM_STATE
argument_list|(
argument|EAP
argument_list|,
argument|RECEIVED
argument_list|)
end_macro

begin_block
block|{
specifier|const
name|struct
name|wpabuf
modifier|*
name|eapReqData
decl_stmt|;
name|SM_ENTRY
argument_list|(
name|EAP
argument_list|,
name|RECEIVED
argument_list|)
expr_stmt|;
name|eapReqData
operator|=
name|eapol_get_eapReqData
argument_list|(
name|sm
argument_list|)
expr_stmt|;
comment|/* parse rxReq, rxSuccess, rxFailure, reqId, reqMethod */
name|eap_sm_parseEapReq
argument_list|(
name|sm
argument_list|,
name|eapReqData
argument_list|)
expr_stmt|;
name|sm
operator|->
name|num_rounds
operator|++
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * This state is entered when a request for a new type comes in. Either the  * correct method is started, or a Nak response is built.  */
end_comment

begin_macro
name|SM_STATE
argument_list|(
argument|EAP
argument_list|,
argument|GET_METHOD
argument_list|)
end_macro

begin_block
block|{
name|int
name|reinit
decl_stmt|;
name|EapType
name|method
decl_stmt|;
specifier|const
name|struct
name|eap_method
modifier|*
name|eap_method
decl_stmt|;
name|SM_ENTRY
argument_list|(
name|EAP
argument_list|,
name|GET_METHOD
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|reqMethod
operator|==
name|EAP_TYPE_EXPANDED
condition|)
name|method
operator|=
name|sm
operator|->
name|reqVendorMethod
expr_stmt|;
else|else
name|method
operator|=
name|sm
operator|->
name|reqMethod
expr_stmt|;
name|eap_method
operator|=
name|eap_peer_get_eap_method
argument_list|(
name|sm
operator|->
name|reqVendor
argument_list|,
name|method
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|eap_sm_allowMethod
argument_list|(
name|sm
argument_list|,
name|sm
operator|->
name|reqVendor
argument_list|,
name|method
argument_list|)
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: vendor %u method %u not allowed"
argument_list|,
name|sm
operator|->
name|reqVendor
argument_list|,
name|method
argument_list|)
expr_stmt|;
name|wpa_msg
argument_list|(
name|sm
operator|->
name|msg_ctx
argument_list|,
name|MSG_INFO
argument_list|,
name|WPA_EVENT_EAP_PROPOSED_METHOD
literal|"vendor=%u method=%u -> NAK"
argument_list|,
name|sm
operator|->
name|reqVendor
argument_list|,
name|method
argument_list|)
expr_stmt|;
name|eap_notify_status
argument_list|(
name|sm
argument_list|,
literal|"refuse proposed method"
argument_list|,
name|eap_method
condition|?
name|eap_method
operator|->
name|name
else|:
literal|"unknown"
argument_list|)
expr_stmt|;
goto|goto
name|nak
goto|;
block|}
name|wpa_msg
argument_list|(
name|sm
operator|->
name|msg_ctx
argument_list|,
name|MSG_INFO
argument_list|,
name|WPA_EVENT_EAP_PROPOSED_METHOD
literal|"vendor=%u method=%u"
argument_list|,
name|sm
operator|->
name|reqVendor
argument_list|,
name|method
argument_list|)
expr_stmt|;
name|eap_notify_status
argument_list|(
name|sm
argument_list|,
literal|"accept proposed method"
argument_list|,
name|eap_method
condition|?
name|eap_method
operator|->
name|name
else|:
literal|"unknown"
argument_list|)
expr_stmt|;
comment|/* 	 * RFC 4137 does not define specific operation for fast 	 * re-authentication (session resumption). The design here is to allow 	 * the previously used method data to be maintained for 	 * re-authentication if the method support session resumption. 	 * Otherwise, the previously used method data is freed and a new method 	 * is allocated here. 	 */
if|if
condition|(
name|sm
operator|->
name|fast_reauth
operator|&&
name|sm
operator|->
name|m
operator|&&
name|sm
operator|->
name|m
operator|->
name|vendor
operator|==
name|sm
operator|->
name|reqVendor
operator|&&
name|sm
operator|->
name|m
operator|->
name|method
operator|==
name|method
operator|&&
name|sm
operator|->
name|m
operator|->
name|has_reauth_data
operator|&&
name|sm
operator|->
name|m
operator|->
name|has_reauth_data
argument_list|(
name|sm
argument_list|,
name|sm
operator|->
name|eap_method_priv
argument_list|)
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: Using previous method data"
literal|" for fast re-authentication"
argument_list|)
expr_stmt|;
name|reinit
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|eap_deinit_prev_method
argument_list|(
name|sm
argument_list|,
literal|"GET_METHOD"
argument_list|)
expr_stmt|;
name|reinit
operator|=
literal|0
expr_stmt|;
block|}
name|sm
operator|->
name|selectedMethod
operator|=
name|sm
operator|->
name|reqMethod
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|m
operator|==
name|NULL
condition|)
name|sm
operator|->
name|m
operator|=
name|eap_method
expr_stmt|;
if|if
condition|(
operator|!
name|sm
operator|->
name|m
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: Could not find selected method: "
literal|"vendor %d method %d"
argument_list|,
name|sm
operator|->
name|reqVendor
argument_list|,
name|method
argument_list|)
expr_stmt|;
goto|goto
name|nak
goto|;
block|}
name|sm
operator|->
name|ClientTimeout
operator|=
name|EAP_CLIENT_TIMEOUT_DEFAULT
expr_stmt|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: Initialize selected EAP method: "
literal|"vendor %u method %u (%s)"
argument_list|,
name|sm
operator|->
name|reqVendor
argument_list|,
name|method
argument_list|,
name|sm
operator|->
name|m
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|reinit
condition|)
name|sm
operator|->
name|eap_method_priv
operator|=
name|sm
operator|->
name|m
operator|->
name|init_for_reauth
argument_list|(
name|sm
argument_list|,
name|sm
operator|->
name|eap_method_priv
argument_list|)
expr_stmt|;
else|else
name|sm
operator|->
name|eap_method_priv
operator|=
name|sm
operator|->
name|m
operator|->
name|init
argument_list|(
name|sm
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|eap_method_priv
operator|==
name|NULL
condition|)
block|{
name|struct
name|eap_peer_config
modifier|*
name|config
init|=
name|eap_get_config
argument_list|(
name|sm
argument_list|)
decl_stmt|;
name|wpa_msg
argument_list|(
name|sm
operator|->
name|msg_ctx
argument_list|,
name|MSG_INFO
argument_list|,
literal|"EAP: Failed to initialize EAP method: vendor %u "
literal|"method %u (%s)"
argument_list|,
name|sm
operator|->
name|reqVendor
argument_list|,
name|method
argument_list|,
name|sm
operator|->
name|m
operator|->
name|name
argument_list|)
expr_stmt|;
name|sm
operator|->
name|m
operator|=
name|NULL
expr_stmt|;
name|sm
operator|->
name|methodState
operator|=
name|METHOD_NONE
expr_stmt|;
name|sm
operator|->
name|selectedMethod
operator|=
name|EAP_TYPE_NONE
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|reqMethod
operator|==
name|EAP_TYPE_TLS
operator|&&
name|config
operator|&&
operator|(
name|config
operator|->
name|pending_req_pin
operator|||
name|config
operator|->
name|pending_req_passphrase
operator|)
condition|)
block|{
comment|/* 			 * Return without generating Nak in order to allow 			 * entering of PIN code or passphrase to retry the 			 * current EAP packet. 			 */
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: Pending PIN/passphrase "
literal|"request - skip Nak"
argument_list|)
expr_stmt|;
return|return;
block|}
goto|goto
name|nak
goto|;
block|}
name|sm
operator|->
name|methodState
operator|=
name|METHOD_INIT
expr_stmt|;
name|wpa_msg
argument_list|(
name|sm
operator|->
name|msg_ctx
argument_list|,
name|MSG_INFO
argument_list|,
name|WPA_EVENT_EAP_METHOD
literal|"EAP vendor %u method %u (%s) selected"
argument_list|,
name|sm
operator|->
name|reqVendor
argument_list|,
name|method
argument_list|,
name|sm
operator|->
name|m
operator|->
name|name
argument_list|)
expr_stmt|;
return|return;
name|nak
label|:
name|wpabuf_free
argument_list|(
name|sm
operator|->
name|eapRespData
argument_list|)
expr_stmt|;
name|sm
operator|->
name|eapRespData
operator|=
name|NULL
expr_stmt|;
name|sm
operator|->
name|eapRespData
operator|=
name|eap_sm_buildNak
argument_list|(
name|sm
argument_list|,
name|sm
operator|->
name|reqId
argument_list|)
expr_stmt|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|CONFIG_ERP
end_ifdef

begin_function
specifier|static
name|char
modifier|*
name|eap_home_realm
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|)
block|{
name|struct
name|eap_peer_config
modifier|*
name|config
init|=
name|eap_get_config
argument_list|(
name|sm
argument_list|)
decl_stmt|;
name|char
modifier|*
name|realm
decl_stmt|;
name|size_t
name|i
decl_stmt|,
name|realm_len
decl_stmt|;
if|if
condition|(
operator|!
name|config
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|config
operator|->
name|identity
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|config
operator|->
name|identity_len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|config
operator|->
name|identity
index|[
name|i
index|]
operator|==
literal|'@'
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|<
name|config
operator|->
name|identity_len
condition|)
block|{
name|realm_len
operator|=
name|config
operator|->
name|identity_len
operator|-
name|i
operator|-
literal|1
expr_stmt|;
name|realm
operator|=
name|os_malloc
argument_list|(
name|realm_len
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|realm
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|os_memcpy
argument_list|(
name|realm
argument_list|,
operator|&
name|config
operator|->
name|identity
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
name|realm_len
argument_list|)
expr_stmt|;
name|realm
index|[
name|realm_len
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|realm
return|;
block|}
block|}
if|if
condition|(
name|config
operator|->
name|anonymous_identity
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|config
operator|->
name|anonymous_identity_len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|config
operator|->
name|anonymous_identity
index|[
name|i
index|]
operator|==
literal|'@'
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|<
name|config
operator|->
name|anonymous_identity_len
condition|)
block|{
name|realm_len
operator|=
name|config
operator|->
name|anonymous_identity_len
operator|-
name|i
operator|-
literal|1
expr_stmt|;
name|realm
operator|=
name|os_malloc
argument_list|(
name|realm_len
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|realm
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|os_memcpy
argument_list|(
name|realm
argument_list|,
operator|&
name|config
operator|->
name|anonymous_identity
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
name|realm_len
argument_list|)
expr_stmt|;
name|realm
index|[
name|realm_len
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|realm
return|;
block|}
block|}
return|return
name|os_strdup
argument_list|(
literal|""
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|eap_erp_key
modifier|*
name|eap_erp_get_key
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
specifier|const
name|char
modifier|*
name|realm
parameter_list|)
block|{
name|struct
name|eap_erp_key
modifier|*
name|erp
decl_stmt|;
name|dl_list_for_each
argument_list|(
argument|erp
argument_list|,
argument|&sm->erp_keys
argument_list|,
argument|struct eap_erp_key
argument_list|,
argument|list
argument_list|)
block|{
name|char
modifier|*
name|pos
decl_stmt|;
name|pos
operator|=
name|os_strchr
argument_list|(
name|erp
operator|->
name|keyname_nai
argument_list|,
literal|'@'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pos
condition|)
continue|continue;
name|pos
operator|++
expr_stmt|;
if|if
condition|(
name|os_strcmp
argument_list|(
name|pos
argument_list|,
name|realm
argument_list|)
operator|==
literal|0
condition|)
return|return
name|erp
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|eap_erp_key
modifier|*
name|eap_erp_get_key_nai
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
specifier|const
name|char
modifier|*
name|nai
parameter_list|)
block|{
name|struct
name|eap_erp_key
modifier|*
name|erp
decl_stmt|;
name|dl_list_for_each
argument_list|(
argument|erp
argument_list|,
argument|&sm->erp_keys
argument_list|,
argument|struct eap_erp_key
argument_list|,
argument|list
argument_list|)
block|{
if|if
condition|(
name|os_strcmp
argument_list|(
name|erp
operator|->
name|keyname_nai
argument_list|,
name|nai
argument_list|)
operator|==
literal|0
condition|)
return|return
name|erp
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|eap_peer_erp_free_key
parameter_list|(
name|struct
name|eap_erp_key
modifier|*
name|erp
parameter_list|)
block|{
name|dl_list_del
argument_list|(
operator|&
name|erp
operator|->
name|list
argument_list|)
expr_stmt|;
name|bin_clear_free
argument_list|(
name|erp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|erp
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|eap_erp_remove_keys_realm
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
specifier|const
name|char
modifier|*
name|realm
parameter_list|)
block|{
name|struct
name|eap_erp_key
modifier|*
name|erp
decl_stmt|;
while|while
condition|(
operator|(
name|erp
operator|=
name|eap_erp_get_key
argument_list|(
name|sm
argument_list|,
name|realm
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: Delete old ERP key %s"
argument_list|,
name|erp
operator|->
name|keyname_nai
argument_list|)
expr_stmt|;
name|eap_peer_erp_free_key
argument_list|(
name|erp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CONFIG_ERP */
end_comment

begin_function
name|void
name|eap_peer_erp_free_keys
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|CONFIG_ERP
name|struct
name|eap_erp_key
modifier|*
name|erp
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
name|dl_list_for_each_safe
argument_list|(
argument|erp
argument_list|,
argument|tmp
argument_list|,
argument|&sm->erp_keys
argument_list|,
argument|struct eap_erp_key
argument_list|,
argument|list
argument_list|)
name|eap_peer_erp_free_key
argument_list|(
name|erp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* CONFIG_ERP */
block|}
end_function

begin_function
specifier|static
name|void
name|eap_peer_erp_init
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|CONFIG_ERP
name|u8
modifier|*
name|emsk
init|=
name|NULL
decl_stmt|;
name|size_t
name|emsk_len
init|=
literal|0
decl_stmt|;
name|u8
name|EMSKname
index|[
name|EAP_EMSK_NAME_LEN
index|]
decl_stmt|;
name|u8
name|len
index|[
literal|2
index|]
decl_stmt|;
name|char
modifier|*
name|realm
decl_stmt|;
name|size_t
name|realm_len
decl_stmt|,
name|nai_buf_len
decl_stmt|;
name|struct
name|eap_erp_key
modifier|*
name|erp
init|=
name|NULL
decl_stmt|;
name|int
name|pos
decl_stmt|;
name|realm
operator|=
name|eap_home_realm
argument_list|(
name|sm
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|realm
condition|)
return|return;
name|realm_len
operator|=
name|os_strlen
argument_list|(
name|realm
argument_list|)
expr_stmt|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: Realm for ERP keyName-NAI: %s"
argument_list|,
name|realm
argument_list|)
expr_stmt|;
name|eap_erp_remove_keys_realm
argument_list|(
name|sm
argument_list|,
name|realm
argument_list|)
expr_stmt|;
name|nai_buf_len
operator|=
literal|2
operator|*
name|EAP_EMSK_NAME_LEN
operator|+
literal|1
operator|+
name|realm_len
expr_stmt|;
if|if
condition|(
name|nai_buf_len
operator|>
literal|253
condition|)
block|{
comment|/* 		 * keyName-NAI has a maximum length of 253 octet to fit in 		 * RADIUS attributes. 		 */
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: Too long realm for ERP keyName-NAI maximum length"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|nai_buf_len
operator|++
expr_stmt|;
comment|/* null termination */
name|erp
operator|=
name|os_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|erp
argument_list|)
operator|+
name|nai_buf_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|erp
operator|==
name|NULL
condition|)
goto|goto
name|fail
goto|;
name|emsk
operator|=
name|sm
operator|->
name|m
operator|->
name|get_emsk
argument_list|(
name|sm
argument_list|,
name|sm
operator|->
name|eap_method_priv
argument_list|,
operator|&
name|emsk_len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|emsk
operator|||
name|emsk_len
operator|==
literal|0
operator|||
name|emsk_len
operator|>
name|ERP_MAX_KEY_LEN
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: No suitable EMSK available for ERP"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|wpa_hexdump_key
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: EMSK"
argument_list|,
name|emsk
argument_list|,
name|emsk_len
argument_list|)
expr_stmt|;
name|WPA_PUT_BE16
argument_list|(
name|len
argument_list|,
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|hmac_sha256_kdf
argument_list|(
name|sm
operator|->
name|eapSessionId
argument_list|,
name|sm
operator|->
name|eapSessionIdLen
argument_list|,
literal|"EMSK"
argument_list|,
name|len
argument_list|,
sizeof|sizeof
argument_list|(
name|len
argument_list|)
argument_list|,
name|EMSKname
argument_list|,
name|EAP_EMSK_NAME_LEN
argument_list|)
operator|<
literal|0
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: Could not derive EMSKname"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|wpa_hexdump
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: EMSKname"
argument_list|,
name|EMSKname
argument_list|,
name|EAP_EMSK_NAME_LEN
argument_list|)
expr_stmt|;
name|pos
operator|=
name|wpa_snprintf_hex
argument_list|(
name|erp
operator|->
name|keyname_nai
argument_list|,
name|nai_buf_len
argument_list|,
name|EMSKname
argument_list|,
name|EAP_EMSK_NAME_LEN
argument_list|)
expr_stmt|;
name|erp
operator|->
name|keyname_nai
index|[
name|pos
index|]
operator|=
literal|'@'
expr_stmt|;
name|os_memcpy
argument_list|(
operator|&
name|erp
operator|->
name|keyname_nai
index|[
name|pos
operator|+
literal|1
index|]
argument_list|,
name|realm
argument_list|,
name|realm_len
argument_list|)
expr_stmt|;
name|WPA_PUT_BE16
argument_list|(
name|len
argument_list|,
name|emsk_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|hmac_sha256_kdf
argument_list|(
name|emsk
argument_list|,
name|emsk_len
argument_list|,
literal|"EAP Re-authentication Root Key@ietf.org"
argument_list|,
name|len
argument_list|,
sizeof|sizeof
argument_list|(
name|len
argument_list|)
argument_list|,
name|erp
operator|->
name|rRK
argument_list|,
name|emsk_len
argument_list|)
operator|<
literal|0
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: Could not derive rRK for ERP"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|erp
operator|->
name|rRK_len
operator|=
name|emsk_len
expr_stmt|;
name|wpa_hexdump_key
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: ERP rRK"
argument_list|,
name|erp
operator|->
name|rRK
argument_list|,
name|erp
operator|->
name|rRK_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|hmac_sha256_kdf
argument_list|(
name|erp
operator|->
name|rRK
argument_list|,
name|erp
operator|->
name|rRK_len
argument_list|,
literal|"EAP Re-authentication Integrity Key@ietf.org"
argument_list|,
name|len
argument_list|,
sizeof|sizeof
argument_list|(
name|len
argument_list|)
argument_list|,
name|erp
operator|->
name|rIK
argument_list|,
name|erp
operator|->
name|rRK_len
argument_list|)
operator|<
literal|0
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: Could not derive rIK for ERP"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|erp
operator|->
name|rIK_len
operator|=
name|erp
operator|->
name|rRK_len
expr_stmt|;
name|wpa_hexdump_key
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: ERP rIK"
argument_list|,
name|erp
operator|->
name|rIK
argument_list|,
name|erp
operator|->
name|rIK_len
argument_list|)
expr_stmt|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: Stored ERP keys %s"
argument_list|,
name|erp
operator|->
name|keyname_nai
argument_list|)
expr_stmt|;
name|dl_list_add
argument_list|(
operator|&
name|sm
operator|->
name|erp_keys
argument_list|,
operator|&
name|erp
operator|->
name|list
argument_list|)
expr_stmt|;
name|erp
operator|=
name|NULL
expr_stmt|;
name|fail
label|:
name|bin_clear_free
argument_list|(
name|emsk
argument_list|,
name|emsk_len
argument_list|)
expr_stmt|;
name|bin_clear_free
argument_list|(
name|erp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|erp
argument_list|)
argument_list|)
expr_stmt|;
name|os_free
argument_list|(
name|realm
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* CONFIG_ERP */
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|CONFIG_ERP
end_ifdef

begin_function
specifier|static
name|int
name|eap_peer_erp_reauth_start
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
specifier|const
name|struct
name|eap_hdr
modifier|*
name|hdr
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|char
modifier|*
name|realm
decl_stmt|;
name|struct
name|eap_erp_key
modifier|*
name|erp
decl_stmt|;
name|struct
name|wpabuf
modifier|*
name|msg
decl_stmt|;
name|u8
name|hash
index|[
name|SHA256_MAC_LEN
index|]
decl_stmt|;
name|realm
operator|=
name|eap_home_realm
argument_list|(
name|sm
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|realm
condition|)
return|return
operator|-
literal|1
return|;
name|erp
operator|=
name|eap_erp_get_key
argument_list|(
name|sm
argument_list|,
name|realm
argument_list|)
expr_stmt|;
name|os_free
argument_list|(
name|realm
argument_list|)
expr_stmt|;
name|realm
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|erp
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|erp
operator|->
name|next_seq
operator|>=
literal|65536
condition|)
return|return
operator|-
literal|1
return|;
comment|/* SEQ has range of 0..65535 */
comment|/* TODO: check rRK lifetime expiration */
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: Valid ERP key found %s (SEQ=%u)"
argument_list|,
name|erp
operator|->
name|keyname_nai
argument_list|,
name|erp
operator|->
name|next_seq
argument_list|)
expr_stmt|;
name|msg
operator|=
name|eap_msg_alloc
argument_list|(
name|EAP_VENDOR_IETF
argument_list|,
operator|(
name|EapType
operator|)
name|EAP_ERP_TYPE_REAUTH
argument_list|,
literal|1
operator|+
literal|2
operator|+
literal|2
operator|+
name|os_strlen
argument_list|(
name|erp
operator|->
name|keyname_nai
argument_list|)
operator|+
literal|1
operator|+
literal|16
argument_list|,
name|EAP_CODE_INITIATE
argument_list|,
name|hdr
operator|->
name|identifier
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|wpabuf_put_u8
argument_list|(
name|msg
argument_list|,
literal|0x20
argument_list|)
expr_stmt|;
comment|/* Flags: R=0 B=0 L=1 */
name|wpabuf_put_be16
argument_list|(
name|msg
argument_list|,
name|erp
operator|->
name|next_seq
argument_list|)
expr_stmt|;
name|wpabuf_put_u8
argument_list|(
name|msg
argument_list|,
name|EAP_ERP_TLV_KEYNAME_NAI
argument_list|)
expr_stmt|;
name|wpabuf_put_u8
argument_list|(
name|msg
argument_list|,
name|os_strlen
argument_list|(
name|erp
operator|->
name|keyname_nai
argument_list|)
argument_list|)
expr_stmt|;
name|wpabuf_put_str
argument_list|(
name|msg
argument_list|,
name|erp
operator|->
name|keyname_nai
argument_list|)
expr_stmt|;
name|wpabuf_put_u8
argument_list|(
name|msg
argument_list|,
name|EAP_ERP_CS_HMAC_SHA256_128
argument_list|)
expr_stmt|;
comment|/* Cryptosuite */
if|if
condition|(
name|hmac_sha256
argument_list|(
name|erp
operator|->
name|rIK
argument_list|,
name|erp
operator|->
name|rIK_len
argument_list|,
name|wpabuf_head
argument_list|(
name|msg
argument_list|)
argument_list|,
name|wpabuf_len
argument_list|(
name|msg
argument_list|)
argument_list|,
name|hash
argument_list|)
operator|<
literal|0
condition|)
block|{
name|wpabuf_free
argument_list|(
name|msg
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|wpabuf_put_data
argument_list|(
name|msg
argument_list|,
name|hash
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: Sending EAP-Initiate/Re-auth"
argument_list|)
expr_stmt|;
name|sm
operator|->
name|erp_seq
operator|=
name|erp
operator|->
name|next_seq
expr_stmt|;
name|erp
operator|->
name|next_seq
operator|++
expr_stmt|;
name|wpabuf_free
argument_list|(
name|sm
operator|->
name|eapRespData
argument_list|)
expr_stmt|;
name|sm
operator|->
name|eapRespData
operator|=
name|msg
expr_stmt|;
name|sm
operator|->
name|reauthInit
operator|=
name|TRUE
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CONFIG_ERP */
end_comment

begin_comment
comment|/*  * The method processing happens here. The request from the authenticator is  * processed, and an appropriate response packet is built.  */
end_comment

begin_macro
name|SM_STATE
argument_list|(
argument|EAP
argument_list|,
argument|METHOD
argument_list|)
end_macro

begin_block
block|{
name|struct
name|wpabuf
modifier|*
name|eapReqData
decl_stmt|;
name|struct
name|eap_method_ret
name|ret
decl_stmt|;
name|int
name|min_len
init|=
literal|1
decl_stmt|;
name|SM_ENTRY
argument_list|(
name|EAP
argument_list|,
name|METHOD
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|m
operator|==
name|NULL
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_WARNING
argument_list|,
literal|"EAP::METHOD - method not selected"
argument_list|)
expr_stmt|;
return|return;
block|}
name|eapReqData
operator|=
name|eapol_get_eapReqData
argument_list|(
name|sm
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|m
operator|->
name|vendor
operator|==
name|EAP_VENDOR_IETF
operator|&&
name|sm
operator|->
name|m
operator|->
name|method
operator|==
name|EAP_TYPE_LEAP
condition|)
name|min_len
operator|=
literal|0
expr_stmt|;
comment|/* LEAP uses EAP-Success without payload */
if|if
condition|(
operator|!
name|eap_hdr_len_valid
argument_list|(
name|eapReqData
argument_list|,
name|min_len
argument_list|)
condition|)
return|return;
comment|/* 	 * Get ignore, methodState, decision, allowNotifications, and 	 * eapRespData. RFC 4137 uses three separate method procedure (check, 	 * process, and buildResp) in this state. These have been combined into 	 * a single function call to m->process() in order to optimize EAP 	 * method implementation interface a bit. These procedures are only 	 * used from within this METHOD state, so there is no need to keep 	 * these as separate C functions. 	 * 	 * The RFC 4137 procedures return values as follows: 	 * ignore = m.check(eapReqData) 	 * (methodState, decision, allowNotifications) = m.process(eapReqData) 	 * eapRespData = m.buildResp(reqId) 	 */
name|os_memset
argument_list|(
operator|&
name|ret
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ret
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|.
name|ignore
operator|=
name|sm
operator|->
name|ignore
expr_stmt|;
name|ret
operator|.
name|methodState
operator|=
name|sm
operator|->
name|methodState
expr_stmt|;
name|ret
operator|.
name|decision
operator|=
name|sm
operator|->
name|decision
expr_stmt|;
name|ret
operator|.
name|allowNotifications
operator|=
name|sm
operator|->
name|allowNotifications
expr_stmt|;
name|wpabuf_free
argument_list|(
name|sm
operator|->
name|eapRespData
argument_list|)
expr_stmt|;
name|sm
operator|->
name|eapRespData
operator|=
name|NULL
expr_stmt|;
name|sm
operator|->
name|eapRespData
operator|=
name|sm
operator|->
name|m
operator|->
name|process
argument_list|(
name|sm
argument_list|,
name|sm
operator|->
name|eap_method_priv
argument_list|,
operator|&
name|ret
argument_list|,
name|eapReqData
argument_list|)
expr_stmt|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: method process -> ignore=%s "
literal|"methodState=%s decision=%s eapRespData=%p"
argument_list|,
name|ret
operator|.
name|ignore
condition|?
literal|"TRUE"
else|:
literal|"FALSE"
argument_list|,
name|eap_sm_method_state_txt
argument_list|(
name|ret
operator|.
name|methodState
argument_list|)
argument_list|,
name|eap_sm_decision_txt
argument_list|(
name|ret
operator|.
name|decision
argument_list|)
argument_list|,
name|sm
operator|->
name|eapRespData
argument_list|)
expr_stmt|;
name|sm
operator|->
name|ignore
operator|=
name|ret
operator|.
name|ignore
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|ignore
condition|)
return|return;
name|sm
operator|->
name|methodState
operator|=
name|ret
operator|.
name|methodState
expr_stmt|;
name|sm
operator|->
name|decision
operator|=
name|ret
operator|.
name|decision
expr_stmt|;
name|sm
operator|->
name|allowNotifications
operator|=
name|ret
operator|.
name|allowNotifications
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|m
operator|->
name|isKeyAvailable
operator|&&
name|sm
operator|->
name|m
operator|->
name|getKey
operator|&&
name|sm
operator|->
name|m
operator|->
name|isKeyAvailable
argument_list|(
name|sm
argument_list|,
name|sm
operator|->
name|eap_method_priv
argument_list|)
condition|)
block|{
name|struct
name|eap_peer_config
modifier|*
name|config
init|=
name|eap_get_config
argument_list|(
name|sm
argument_list|)
decl_stmt|;
name|eap_sm_free_key
argument_list|(
name|sm
argument_list|)
expr_stmt|;
name|sm
operator|->
name|eapKeyData
operator|=
name|sm
operator|->
name|m
operator|->
name|getKey
argument_list|(
name|sm
argument_list|,
name|sm
operator|->
name|eap_method_priv
argument_list|,
operator|&
name|sm
operator|->
name|eapKeyDataLen
argument_list|)
expr_stmt|;
name|os_free
argument_list|(
name|sm
operator|->
name|eapSessionId
argument_list|)
expr_stmt|;
name|sm
operator|->
name|eapSessionId
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|m
operator|->
name|getSessionId
condition|)
block|{
name|sm
operator|->
name|eapSessionId
operator|=
name|sm
operator|->
name|m
operator|->
name|getSessionId
argument_list|(
name|sm
argument_list|,
name|sm
operator|->
name|eap_method_priv
argument_list|,
operator|&
name|sm
operator|->
name|eapSessionIdLen
argument_list|)
expr_stmt|;
name|wpa_hexdump
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: Session-Id"
argument_list|,
name|sm
operator|->
name|eapSessionId
argument_list|,
name|sm
operator|->
name|eapSessionIdLen
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|config
operator|->
name|erp
operator|&&
name|sm
operator|->
name|m
operator|->
name|get_emsk
operator|&&
name|sm
operator|->
name|eapSessionId
condition|)
name|eap_peer_erp_init
argument_list|(
name|sm
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * This state signals the lower layer that a response packet is ready to be  * sent.  */
end_comment

begin_macro
name|SM_STATE
argument_list|(
argument|EAP
argument_list|,
argument|SEND_RESPONSE
argument_list|)
end_macro

begin_block
block|{
name|SM_ENTRY
argument_list|(
name|EAP
argument_list|,
name|SEND_RESPONSE
argument_list|)
expr_stmt|;
name|wpabuf_free
argument_list|(
name|sm
operator|->
name|lastRespData
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|eapRespData
condition|)
block|{
if|if
condition|(
name|sm
operator|->
name|workaround
condition|)
name|os_memcpy
argument_list|(
name|sm
operator|->
name|last_sha1
argument_list|,
name|sm
operator|->
name|req_sha1
argument_list|,
literal|20
argument_list|)
expr_stmt|;
name|sm
operator|->
name|lastId
operator|=
name|sm
operator|->
name|reqId
expr_stmt|;
name|sm
operator|->
name|lastRespData
operator|=
name|wpabuf_dup
argument_list|(
name|sm
operator|->
name|eapRespData
argument_list|)
expr_stmt|;
name|eapol_set_bool
argument_list|(
name|sm
argument_list|,
name|EAPOL_eapResp
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: No eapRespData available"
argument_list|)
expr_stmt|;
name|sm
operator|->
name|lastRespData
operator|=
name|NULL
expr_stmt|;
block|}
name|eapol_set_bool
argument_list|(
name|sm
argument_list|,
name|EAPOL_eapReq
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|eapol_set_int
argument_list|(
name|sm
argument_list|,
name|EAPOL_idleWhile
argument_list|,
name|sm
operator|->
name|ClientTimeout
argument_list|)
expr_stmt|;
name|sm
operator|->
name|reauthInit
operator|=
name|FALSE
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * This state signals the lower layer that the request was discarded, and no  * response packet will be sent at this time.  */
end_comment

begin_macro
name|SM_STATE
argument_list|(
argument|EAP
argument_list|,
argument|DISCARD
argument_list|)
end_macro

begin_block
block|{
name|SM_ENTRY
argument_list|(
name|EAP
argument_list|,
name|DISCARD
argument_list|)
expr_stmt|;
name|eapol_set_bool
argument_list|(
name|sm
argument_list|,
name|EAPOL_eapReq
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|eapol_set_bool
argument_list|(
name|sm
argument_list|,
name|EAPOL_eapNoResp
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Handles requests for Identity method and builds a response.  */
end_comment

begin_macro
name|SM_STATE
argument_list|(
argument|EAP
argument_list|,
argument|IDENTITY
argument_list|)
end_macro

begin_block
block|{
specifier|const
name|struct
name|wpabuf
modifier|*
name|eapReqData
decl_stmt|;
name|SM_ENTRY
argument_list|(
name|EAP
argument_list|,
name|IDENTITY
argument_list|)
expr_stmt|;
name|eapReqData
operator|=
name|eapol_get_eapReqData
argument_list|(
name|sm
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|eap_hdr_len_valid
argument_list|(
name|eapReqData
argument_list|,
literal|1
argument_list|)
condition|)
return|return;
name|eap_sm_processIdentity
argument_list|(
name|sm
argument_list|,
name|eapReqData
argument_list|)
expr_stmt|;
name|wpabuf_free
argument_list|(
name|sm
operator|->
name|eapRespData
argument_list|)
expr_stmt|;
name|sm
operator|->
name|eapRespData
operator|=
name|NULL
expr_stmt|;
name|sm
operator|->
name|eapRespData
operator|=
name|eap_sm_buildIdentity
argument_list|(
name|sm
argument_list|,
name|sm
operator|->
name|reqId
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Handles requests for Notification method and builds a response.  */
end_comment

begin_macro
name|SM_STATE
argument_list|(
argument|EAP
argument_list|,
argument|NOTIFICATION
argument_list|)
end_macro

begin_block
block|{
specifier|const
name|struct
name|wpabuf
modifier|*
name|eapReqData
decl_stmt|;
name|SM_ENTRY
argument_list|(
name|EAP
argument_list|,
name|NOTIFICATION
argument_list|)
expr_stmt|;
name|eapReqData
operator|=
name|eapol_get_eapReqData
argument_list|(
name|sm
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|eap_hdr_len_valid
argument_list|(
name|eapReqData
argument_list|,
literal|1
argument_list|)
condition|)
return|return;
name|eap_sm_processNotify
argument_list|(
name|sm
argument_list|,
name|eapReqData
argument_list|)
expr_stmt|;
name|wpabuf_free
argument_list|(
name|sm
operator|->
name|eapRespData
argument_list|)
expr_stmt|;
name|sm
operator|->
name|eapRespData
operator|=
name|NULL
expr_stmt|;
name|sm
operator|->
name|eapRespData
operator|=
name|eap_sm_buildNotify
argument_list|(
name|sm
operator|->
name|reqId
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * This state retransmits the previous response packet.  */
end_comment

begin_macro
name|SM_STATE
argument_list|(
argument|EAP
argument_list|,
argument|RETRANSMIT
argument_list|)
end_macro

begin_block
block|{
name|SM_ENTRY
argument_list|(
name|EAP
argument_list|,
name|RETRANSMIT
argument_list|)
expr_stmt|;
name|wpabuf_free
argument_list|(
name|sm
operator|->
name|eapRespData
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|lastRespData
condition|)
name|sm
operator|->
name|eapRespData
operator|=
name|wpabuf_dup
argument_list|(
name|sm
operator|->
name|lastRespData
argument_list|)
expr_stmt|;
else|else
name|sm
operator|->
name|eapRespData
operator|=
name|NULL
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * This state is entered in case of a successful completion of authentication  * and state machine waits here until port is disabled or EAP authentication is  * restarted.  */
end_comment

begin_macro
name|SM_STATE
argument_list|(
argument|EAP
argument_list|,
argument|SUCCESS
argument_list|)
end_macro

begin_block
block|{
name|SM_ENTRY
argument_list|(
name|EAP
argument_list|,
name|SUCCESS
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|eapKeyData
operator|!=
name|NULL
condition|)
name|sm
operator|->
name|eapKeyAvailable
operator|=
name|TRUE
expr_stmt|;
name|eapol_set_bool
argument_list|(
name|sm
argument_list|,
name|EAPOL_eapSuccess
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* 	 * RFC 4137 does not clear eapReq here, but this seems to be required 	 * to avoid processing the same request twice when state machine is 	 * initialized. 	 */
name|eapol_set_bool
argument_list|(
name|sm
argument_list|,
name|EAPOL_eapReq
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* 	 * RFC 4137 does not set eapNoResp here, but this seems to be required 	 * to get EAPOL Supplicant backend state machine into SUCCESS state. In 	 * addition, either eapResp or eapNoResp is required to be set after 	 * processing the received EAP frame. 	 */
name|eapol_set_bool
argument_list|(
name|sm
argument_list|,
name|EAPOL_eapNoResp
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|wpa_msg
argument_list|(
name|sm
operator|->
name|msg_ctx
argument_list|,
name|MSG_INFO
argument_list|,
name|WPA_EVENT_EAP_SUCCESS
literal|"EAP authentication completed successfully"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * This state is entered in case of a failure and state machine waits here  * until port is disabled or EAP authentication is restarted.  */
end_comment

begin_macro
name|SM_STATE
argument_list|(
argument|EAP
argument_list|,
argument|FAILURE
argument_list|)
end_macro

begin_block
block|{
name|SM_ENTRY
argument_list|(
name|EAP
argument_list|,
name|FAILURE
argument_list|)
expr_stmt|;
name|eapol_set_bool
argument_list|(
name|sm
argument_list|,
name|EAPOL_eapFail
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* 	 * RFC 4137 does not clear eapReq here, but this seems to be required 	 * to avoid processing the same request twice when state machine is 	 * initialized. 	 */
name|eapol_set_bool
argument_list|(
name|sm
argument_list|,
name|EAPOL_eapReq
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* 	 * RFC 4137 does not set eapNoResp here. However, either eapResp or 	 * eapNoResp is required to be set after processing the received EAP 	 * frame. 	 */
name|eapol_set_bool
argument_list|(
name|sm
argument_list|,
name|EAPOL_eapNoResp
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|wpa_msg
argument_list|(
name|sm
operator|->
name|msg_ctx
argument_list|,
name|MSG_INFO
argument_list|,
name|WPA_EVENT_EAP_FAILURE
literal|"EAP authentication failed"
argument_list|)
expr_stmt|;
name|sm
operator|->
name|prev_failure
operator|=
literal|1
expr_stmt|;
block|}
end_block

begin_function
specifier|static
name|int
name|eap_success_workaround
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|int
name|reqId
parameter_list|,
name|int
name|lastId
parameter_list|)
block|{
comment|/* 	 * At least Microsoft IAS and Meetinghouse Aegis seem to be sending 	 * EAP-Success/Failure with lastId + 1 even though RFC 3748 and 	 * RFC 4137 require that reqId == lastId. In addition, it looks like 	 * Ringmaster v2.1.2.0 would be using lastId + 2 in EAP-Success. 	 * 	 * Accept this kind of Id if EAP workarounds are enabled. These are 	 * unauthenticated plaintext messages, so this should have minimal 	 * security implications (bit easier to fake EAP-Success/Failure). 	 */
if|if
condition|(
name|sm
operator|->
name|workaround
operator|&&
operator|(
name|reqId
operator|==
operator|(
operator|(
name|lastId
operator|+
literal|1
operator|)
operator|&
literal|0xff
operator|)
operator|||
name|reqId
operator|==
operator|(
operator|(
name|lastId
operator|+
literal|2
operator|)
operator|&
literal|0xff
operator|)
operator|)
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: Workaround for unexpected "
literal|"identifier field in EAP Success: "
literal|"reqId=%d lastId=%d (these are supposed to be "
literal|"same)"
argument_list|,
name|reqId
argument_list|,
name|lastId
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: EAP-Success Id mismatch - reqId=%d "
literal|"lastId=%d"
argument_list|,
name|reqId
argument_list|,
name|lastId
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * RFC 4137 - Appendix A.1: EAP Peer State Machine - State transitions  */
end_comment

begin_function
specifier|static
name|void
name|eap_peer_sm_step_idle
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|)
block|{
comment|/* 	 * The first three transitions are from RFC 4137. The last two are 	 * local additions to handle special cases with LEAP and PEAP server 	 * not sending EAP-Success in some cases. 	 */
if|if
condition|(
name|eapol_get_bool
argument_list|(
name|sm
argument_list|,
name|EAPOL_eapReq
argument_list|)
condition|)
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|RECEIVED
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|eapol_get_bool
argument_list|(
name|sm
argument_list|,
name|EAPOL_altAccept
argument_list|)
operator|&&
name|sm
operator|->
name|decision
operator|!=
name|DECISION_FAIL
operator|)
operator|||
operator|(
name|eapol_get_int
argument_list|(
name|sm
argument_list|,
name|EAPOL_idleWhile
argument_list|)
operator|==
literal|0
operator|&&
name|sm
operator|->
name|decision
operator|==
name|DECISION_UNCOND_SUCC
operator|)
condition|)
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|SUCCESS
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|eapol_get_bool
argument_list|(
name|sm
argument_list|,
name|EAPOL_altReject
argument_list|)
operator|||
operator|(
name|eapol_get_int
argument_list|(
name|sm
argument_list|,
name|EAPOL_idleWhile
argument_list|)
operator|==
literal|0
operator|&&
name|sm
operator|->
name|decision
operator|!=
name|DECISION_UNCOND_SUCC
operator|)
operator|||
operator|(
name|eapol_get_bool
argument_list|(
name|sm
argument_list|,
name|EAPOL_altAccept
argument_list|)
operator|&&
name|sm
operator|->
name|methodState
operator|!=
name|METHOD_CONT
operator|&&
name|sm
operator|->
name|decision
operator|==
name|DECISION_FAIL
operator|)
condition|)
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|FAILURE
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sm
operator|->
name|selectedMethod
operator|==
name|EAP_TYPE_LEAP
operator|&&
name|sm
operator|->
name|leap_done
operator|&&
name|sm
operator|->
name|decision
operator|!=
name|DECISION_FAIL
operator|&&
name|sm
operator|->
name|methodState
operator|==
name|METHOD_DONE
condition|)
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|SUCCESS
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sm
operator|->
name|selectedMethod
operator|==
name|EAP_TYPE_PEAP
operator|&&
name|sm
operator|->
name|peap_done
operator|&&
name|sm
operator|->
name|decision
operator|!=
name|DECISION_FAIL
operator|&&
name|sm
operator|->
name|methodState
operator|==
name|METHOD_DONE
condition|)
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|SUCCESS
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|eap_peer_req_is_duplicate
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|)
block|{
name|int
name|duplicate
decl_stmt|;
name|duplicate
operator|=
operator|(
name|sm
operator|->
name|reqId
operator|==
name|sm
operator|->
name|lastId
operator|)
operator|&&
name|sm
operator|->
name|rxReq
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|workaround
operator|&&
name|duplicate
operator|&&
name|os_memcmp
argument_list|(
name|sm
operator|->
name|req_sha1
argument_list|,
name|sm
operator|->
name|last_sha1
argument_list|,
literal|20
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * RFC 4137 uses (reqId == lastId) as the only verification for 		 * duplicate EAP requests. However, this misses cases where the 		 * AS is incorrectly using the same id again; and 		 * unfortunately, such implementations exist. Use SHA1 hash as 		 * an extra verification for the packets being duplicate to 		 * workaround these issues. 		 */
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: AS used the same Id again, but "
literal|"EAP packets were not identical"
argument_list|)
expr_stmt|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: workaround - assume this is not a "
literal|"duplicate packet"
argument_list|)
expr_stmt|;
name|duplicate
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|duplicate
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|eap_peer_sm_allow_canned
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|)
block|{
name|struct
name|eap_peer_config
modifier|*
name|config
init|=
name|eap_get_config
argument_list|(
name|sm
argument_list|)
decl_stmt|;
return|return
name|config
operator|&&
name|config
operator|->
name|phase1
operator|&&
name|os_strstr
argument_list|(
name|config
operator|->
name|phase1
argument_list|,
literal|"allow_canned_success=1"
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|eap_peer_sm_step_received
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|)
block|{
name|int
name|duplicate
init|=
name|eap_peer_req_is_duplicate
argument_list|(
name|sm
argument_list|)
decl_stmt|;
comment|/* 	 * Two special cases below for LEAP are local additions to work around 	 * odd LEAP behavior (EAP-Success in the middle of authentication and 	 * then swapped roles). Other transitions are based on RFC 4137. 	 */
if|if
condition|(
name|sm
operator|->
name|rxSuccess
operator|&&
name|sm
operator|->
name|decision
operator|!=
name|DECISION_FAIL
operator|&&
operator|(
name|sm
operator|->
name|reqId
operator|==
name|sm
operator|->
name|lastId
operator|||
name|eap_success_workaround
argument_list|(
name|sm
argument_list|,
name|sm
operator|->
name|reqId
argument_list|,
name|sm
operator|->
name|lastId
argument_list|)
operator|)
condition|)
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|SUCCESS
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sm
operator|->
name|workaround
operator|&&
name|sm
operator|->
name|lastId
operator|==
operator|-
literal|1
operator|&&
name|sm
operator|->
name|rxSuccess
operator|&&
operator|!
name|sm
operator|->
name|rxFailure
operator|&&
operator|!
name|sm
operator|->
name|rxReq
operator|&&
name|eap_peer_sm_allow_canned
argument_list|(
name|sm
argument_list|)
condition|)
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|SUCCESS
argument_list|)
expr_stmt|;
comment|/* EAP-Success prior any EAP method */
elseif|else
if|if
condition|(
name|sm
operator|->
name|workaround
operator|&&
name|sm
operator|->
name|lastId
operator|==
operator|-
literal|1
operator|&&
name|sm
operator|->
name|rxFailure
operator|&&
operator|!
name|sm
operator|->
name|rxReq
operator|&&
name|sm
operator|->
name|methodState
operator|!=
name|METHOD_CONT
operator|&&
name|eap_peer_sm_allow_canned
argument_list|(
name|sm
argument_list|)
condition|)
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|FAILURE
argument_list|)
expr_stmt|;
comment|/* EAP-Failure prior any EAP method */
elseif|else
if|if
condition|(
name|sm
operator|->
name|workaround
operator|&&
name|sm
operator|->
name|rxSuccess
operator|&&
operator|!
name|sm
operator|->
name|rxFailure
operator|&&
operator|!
name|sm
operator|->
name|rxReq
operator|&&
name|sm
operator|->
name|methodState
operator|!=
name|METHOD_CONT
operator|&&
name|eap_peer_sm_allow_canned
argument_list|(
name|sm
argument_list|)
condition|)
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|SUCCESS
argument_list|)
expr_stmt|;
comment|/* EAP-Success after Identity */
elseif|else
if|if
condition|(
name|sm
operator|->
name|methodState
operator|!=
name|METHOD_CONT
operator|&&
operator|(
operator|(
name|sm
operator|->
name|rxFailure
operator|&&
name|sm
operator|->
name|decision
operator|!=
name|DECISION_UNCOND_SUCC
operator|)
operator|||
operator|(
name|sm
operator|->
name|rxSuccess
operator|&&
name|sm
operator|->
name|decision
operator|==
name|DECISION_FAIL
operator|&&
operator|(
name|sm
operator|->
name|selectedMethod
operator|!=
name|EAP_TYPE_LEAP
operator|||
name|sm
operator|->
name|methodState
operator|!=
name|METHOD_MAY_CONT
operator|)
operator|)
operator|)
operator|&&
operator|(
name|sm
operator|->
name|reqId
operator|==
name|sm
operator|->
name|lastId
operator|||
name|eap_success_workaround
argument_list|(
name|sm
argument_list|,
name|sm
operator|->
name|reqId
argument_list|,
name|sm
operator|->
name|lastId
argument_list|)
operator|)
condition|)
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|FAILURE
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sm
operator|->
name|rxReq
operator|&&
name|duplicate
condition|)
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|RETRANSMIT
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sm
operator|->
name|rxReq
operator|&&
operator|!
name|duplicate
operator|&&
name|sm
operator|->
name|reqMethod
operator|==
name|EAP_TYPE_NOTIFICATION
operator|&&
name|sm
operator|->
name|allowNotifications
condition|)
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|NOTIFICATION
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sm
operator|->
name|rxReq
operator|&&
operator|!
name|duplicate
operator|&&
name|sm
operator|->
name|selectedMethod
operator|==
name|EAP_TYPE_NONE
operator|&&
name|sm
operator|->
name|reqMethod
operator|==
name|EAP_TYPE_IDENTITY
condition|)
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|IDENTITY
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sm
operator|->
name|rxReq
operator|&&
operator|!
name|duplicate
operator|&&
name|sm
operator|->
name|selectedMethod
operator|==
name|EAP_TYPE_NONE
operator|&&
name|sm
operator|->
name|reqMethod
operator|!=
name|EAP_TYPE_IDENTITY
operator|&&
name|sm
operator|->
name|reqMethod
operator|!=
name|EAP_TYPE_NOTIFICATION
condition|)
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|GET_METHOD
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sm
operator|->
name|rxReq
operator|&&
operator|!
name|duplicate
operator|&&
name|sm
operator|->
name|reqMethod
operator|==
name|sm
operator|->
name|selectedMethod
operator|&&
name|sm
operator|->
name|methodState
operator|!=
name|METHOD_DONE
condition|)
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|METHOD
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sm
operator|->
name|selectedMethod
operator|==
name|EAP_TYPE_LEAP
operator|&&
operator|(
name|sm
operator|->
name|rxSuccess
operator|||
name|sm
operator|->
name|rxResp
operator|)
condition|)
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|METHOD
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sm
operator|->
name|reauthInit
condition|)
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|SEND_RESPONSE
argument_list|)
expr_stmt|;
else|else
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|DISCARD
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|eap_peer_sm_step_local
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|)
block|{
switch|switch
condition|(
name|sm
operator|->
name|EAP_state
condition|)
block|{
case|case
name|EAP_INITIALIZE
case|:
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|IDLE
argument_list|)
expr_stmt|;
break|break;
case|case
name|EAP_DISABLED
case|:
if|if
condition|(
name|eapol_get_bool
argument_list|(
name|sm
argument_list|,
name|EAPOL_portEnabled
argument_list|)
operator|&&
operator|!
name|sm
operator|->
name|force_disabled
condition|)
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|INITIALIZE
argument_list|)
expr_stmt|;
break|break;
case|case
name|EAP_IDLE
case|:
name|eap_peer_sm_step_idle
argument_list|(
name|sm
argument_list|)
expr_stmt|;
break|break;
case|case
name|EAP_RECEIVED
case|:
name|eap_peer_sm_step_received
argument_list|(
name|sm
argument_list|)
expr_stmt|;
break|break;
case|case
name|EAP_GET_METHOD
case|:
if|if
condition|(
name|sm
operator|->
name|selectedMethod
operator|==
name|sm
operator|->
name|reqMethod
condition|)
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|METHOD
argument_list|)
expr_stmt|;
else|else
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|SEND_RESPONSE
argument_list|)
expr_stmt|;
break|break;
case|case
name|EAP_METHOD
case|:
comment|/* 		 * Note: RFC 4137 uses methodState == DONE&& decision == FAIL 		 * as the condition. eapRespData == NULL here is used to allow 		 * final EAP method response to be sent without having to change 		 * all methods to either use methodState MAY_CONT or leaving 		 * decision to something else than FAIL in cases where the only 		 * expected response is EAP-Failure. 		 */
if|if
condition|(
name|sm
operator|->
name|ignore
condition|)
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|DISCARD
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sm
operator|->
name|methodState
operator|==
name|METHOD_DONE
operator|&&
name|sm
operator|->
name|decision
operator|==
name|DECISION_FAIL
operator|&&
operator|!
name|sm
operator|->
name|eapRespData
condition|)
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|FAILURE
argument_list|)
expr_stmt|;
else|else
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|SEND_RESPONSE
argument_list|)
expr_stmt|;
break|break;
case|case
name|EAP_SEND_RESPONSE
case|:
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|IDLE
argument_list|)
expr_stmt|;
break|break;
case|case
name|EAP_DISCARD
case|:
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|IDLE
argument_list|)
expr_stmt|;
break|break;
case|case
name|EAP_IDENTITY
case|:
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|SEND_RESPONSE
argument_list|)
expr_stmt|;
break|break;
case|case
name|EAP_NOTIFICATION
case|:
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|SEND_RESPONSE
argument_list|)
expr_stmt|;
break|break;
case|case
name|EAP_RETRANSMIT
case|:
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|SEND_RESPONSE
argument_list|)
expr_stmt|;
break|break;
case|case
name|EAP_SUCCESS
case|:
break|break;
case|case
name|EAP_FAILURE
case|:
break|break;
block|}
block|}
end_function

begin_macro
name|SM_STEP
argument_list|(
argument|EAP
argument_list|)
end_macro

begin_block
block|{
comment|/* Global transitions */
if|if
condition|(
name|eapol_get_bool
argument_list|(
name|sm
argument_list|,
name|EAPOL_eapRestart
argument_list|)
operator|&&
name|eapol_get_bool
argument_list|(
name|sm
argument_list|,
name|EAPOL_portEnabled
argument_list|)
condition|)
name|SM_ENTER_GLOBAL
argument_list|(
name|EAP
argument_list|,
name|INITIALIZE
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|eapol_get_bool
argument_list|(
name|sm
argument_list|,
name|EAPOL_portEnabled
argument_list|)
operator|||
name|sm
operator|->
name|force_disabled
condition|)
name|SM_ENTER_GLOBAL
argument_list|(
name|EAP
argument_list|,
name|DISABLED
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sm
operator|->
name|num_rounds
operator|>
name|EAP_MAX_AUTH_ROUNDS
condition|)
block|{
comment|/* RFC 4137 does not place any limit on number of EAP messages 		 * in an authentication session. However, some error cases have 		 * ended up in a state were EAP messages were sent between the 		 * peer and server in a loop (e.g., TLS ACK frame in both 		 * direction). Since this is quite undesired outcome, limit the 		 * total number of EAP round-trips and abort authentication if 		 * this limit is exceeded. 		 */
if|if
condition|(
name|sm
operator|->
name|num_rounds
operator|==
name|EAP_MAX_AUTH_ROUNDS
operator|+
literal|1
condition|)
block|{
name|wpa_msg
argument_list|(
name|sm
operator|->
name|msg_ctx
argument_list|,
name|MSG_INFO
argument_list|,
literal|"EAP: more than %d "
literal|"authentication rounds - abort"
argument_list|,
name|EAP_MAX_AUTH_ROUNDS
argument_list|)
expr_stmt|;
name|sm
operator|->
name|num_rounds
operator|++
expr_stmt|;
name|SM_ENTER_GLOBAL
argument_list|(
name|EAP
argument_list|,
name|FAILURE
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Local transitions */
name|eap_peer_sm_step_local
argument_list|(
name|sm
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_function
specifier|static
name|Boolean
name|eap_sm_allowMethod
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|int
name|vendor
parameter_list|,
name|EapType
name|method
parameter_list|)
block|{
if|if
condition|(
operator|!
name|eap_allowed_method
argument_list|(
name|sm
argument_list|,
name|vendor
argument_list|,
name|method
argument_list|)
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: configuration does not allow: "
literal|"vendor %u method %u"
argument_list|,
name|vendor
argument_list|,
name|method
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|eap_peer_get_eap_method
argument_list|(
name|vendor
argument_list|,
name|method
argument_list|)
condition|)
return|return
name|TRUE
return|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: not included in build: "
literal|"vendor %u method %u"
argument_list|,
name|vendor
argument_list|,
name|method
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|wpabuf
modifier|*
name|eap_sm_build_expanded_nak
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|int
name|id
parameter_list|,
specifier|const
name|struct
name|eap_method
modifier|*
name|methods
parameter_list|,
name|size_t
name|count
parameter_list|)
block|{
name|struct
name|wpabuf
modifier|*
name|resp
decl_stmt|;
name|int
name|found
init|=
literal|0
decl_stmt|;
specifier|const
name|struct
name|eap_method
modifier|*
name|m
decl_stmt|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: Building expanded EAP-Nak"
argument_list|)
expr_stmt|;
comment|/* RFC 3748 - 5.3.2: Expanded Nak */
name|resp
operator|=
name|eap_msg_alloc
argument_list|(
name|EAP_VENDOR_IETF
argument_list|,
name|EAP_TYPE_EXPANDED
argument_list|,
literal|8
operator|+
literal|8
operator|*
operator|(
name|count
operator|+
literal|1
operator|)
argument_list|,
name|EAP_CODE_RESPONSE
argument_list|,
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|resp
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|wpabuf_put_be24
argument_list|(
name|resp
argument_list|,
name|EAP_VENDOR_IETF
argument_list|)
expr_stmt|;
name|wpabuf_put_be32
argument_list|(
name|resp
argument_list|,
name|EAP_TYPE_NAK
argument_list|)
expr_stmt|;
for|for
control|(
name|m
operator|=
name|methods
init|;
name|m
condition|;
name|m
operator|=
name|m
operator|->
name|next
control|)
block|{
if|if
condition|(
name|sm
operator|->
name|reqVendor
operator|==
name|m
operator|->
name|vendor
operator|&&
name|sm
operator|->
name|reqVendorMethod
operator|==
name|m
operator|->
name|method
condition|)
continue|continue;
comment|/* do not allow the current method again */
if|if
condition|(
name|eap_allowed_method
argument_list|(
name|sm
argument_list|,
name|m
operator|->
name|vendor
argument_list|,
name|m
operator|->
name|method
argument_list|)
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: allowed type: "
literal|"vendor=%u method=%u"
argument_list|,
name|m
operator|->
name|vendor
argument_list|,
name|m
operator|->
name|method
argument_list|)
expr_stmt|;
name|wpabuf_put_u8
argument_list|(
name|resp
argument_list|,
name|EAP_TYPE_EXPANDED
argument_list|)
expr_stmt|;
name|wpabuf_put_be24
argument_list|(
name|resp
argument_list|,
name|m
operator|->
name|vendor
argument_list|)
expr_stmt|;
name|wpabuf_put_be32
argument_list|(
name|resp
argument_list|,
name|m
operator|->
name|method
argument_list|)
expr_stmt|;
name|found
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|found
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: no more allowed methods"
argument_list|)
expr_stmt|;
name|wpabuf_put_u8
argument_list|(
name|resp
argument_list|,
name|EAP_TYPE_EXPANDED
argument_list|)
expr_stmt|;
name|wpabuf_put_be24
argument_list|(
name|resp
argument_list|,
name|EAP_VENDOR_IETF
argument_list|)
expr_stmt|;
name|wpabuf_put_be32
argument_list|(
name|resp
argument_list|,
name|EAP_TYPE_NONE
argument_list|)
expr_stmt|;
block|}
name|eap_update_len
argument_list|(
name|resp
argument_list|)
expr_stmt|;
return|return
name|resp
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|wpabuf
modifier|*
name|eap_sm_buildNak
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|int
name|id
parameter_list|)
block|{
name|struct
name|wpabuf
modifier|*
name|resp
decl_stmt|;
name|u8
modifier|*
name|start
decl_stmt|;
name|int
name|found
init|=
literal|0
decl_stmt|,
name|expanded_found
init|=
literal|0
decl_stmt|;
name|size_t
name|count
decl_stmt|;
specifier|const
name|struct
name|eap_method
modifier|*
name|methods
decl_stmt|,
modifier|*
name|m
decl_stmt|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: Building EAP-Nak (requested type %u "
literal|"vendor=%u method=%u not allowed)"
argument_list|,
name|sm
operator|->
name|reqMethod
argument_list|,
name|sm
operator|->
name|reqVendor
argument_list|,
name|sm
operator|->
name|reqVendorMethod
argument_list|)
expr_stmt|;
name|methods
operator|=
name|eap_peer_get_methods
argument_list|(
operator|&
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|methods
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|sm
operator|->
name|reqMethod
operator|==
name|EAP_TYPE_EXPANDED
condition|)
return|return
name|eap_sm_build_expanded_nak
argument_list|(
name|sm
argument_list|,
name|id
argument_list|,
name|methods
argument_list|,
name|count
argument_list|)
return|;
comment|/* RFC 3748 - 5.3.1: Legacy Nak */
name|resp
operator|=
name|eap_msg_alloc
argument_list|(
name|EAP_VENDOR_IETF
argument_list|,
name|EAP_TYPE_NAK
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|eap_hdr
argument_list|)
operator|+
literal|1
operator|+
name|count
operator|+
literal|1
argument_list|,
name|EAP_CODE_RESPONSE
argument_list|,
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|resp
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|start
operator|=
name|wpabuf_put
argument_list|(
name|resp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|m
operator|=
name|methods
init|;
name|m
condition|;
name|m
operator|=
name|m
operator|->
name|next
control|)
block|{
if|if
condition|(
name|m
operator|->
name|vendor
operator|==
name|EAP_VENDOR_IETF
operator|&&
name|m
operator|->
name|method
operator|==
name|sm
operator|->
name|reqMethod
condition|)
continue|continue;
comment|/* do not allow the current method again */
if|if
condition|(
name|eap_allowed_method
argument_list|(
name|sm
argument_list|,
name|m
operator|->
name|vendor
argument_list|,
name|m
operator|->
name|method
argument_list|)
condition|)
block|{
if|if
condition|(
name|m
operator|->
name|vendor
operator|!=
name|EAP_VENDOR_IETF
condition|)
block|{
if|if
condition|(
name|expanded_found
condition|)
continue|continue;
name|expanded_found
operator|=
literal|1
expr_stmt|;
name|wpabuf_put_u8
argument_list|(
name|resp
argument_list|,
name|EAP_TYPE_EXPANDED
argument_list|)
expr_stmt|;
block|}
else|else
name|wpabuf_put_u8
argument_list|(
name|resp
argument_list|,
name|m
operator|->
name|method
argument_list|)
expr_stmt|;
name|found
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|found
condition|)
name|wpabuf_put_u8
argument_list|(
name|resp
argument_list|,
name|EAP_TYPE_NONE
argument_list|)
expr_stmt|;
name|wpa_hexdump
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: allowed methods"
argument_list|,
name|start
argument_list|,
name|found
argument_list|)
expr_stmt|;
name|eap_update_len
argument_list|(
name|resp
argument_list|)
expr_stmt|;
return|return
name|resp
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|eap_sm_processIdentity
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
specifier|const
name|struct
name|wpabuf
modifier|*
name|req
parameter_list|)
block|{
specifier|const
name|u8
modifier|*
name|pos
decl_stmt|;
name|size_t
name|msg_len
decl_stmt|;
name|wpa_msg
argument_list|(
name|sm
operator|->
name|msg_ctx
argument_list|,
name|MSG_INFO
argument_list|,
name|WPA_EVENT_EAP_STARTED
literal|"EAP authentication started"
argument_list|)
expr_stmt|;
name|eap_notify_status
argument_list|(
name|sm
argument_list|,
literal|"started"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|pos
operator|=
name|eap_hdr_validate
argument_list|(
name|EAP_VENDOR_IETF
argument_list|,
name|EAP_TYPE_IDENTITY
argument_list|,
name|req
argument_list|,
operator|&
name|msg_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|==
name|NULL
condition|)
return|return;
comment|/* 	 * RFC 3748 - 5.1: Identity 	 * Data field may contain a displayable message in UTF-8. If this 	 * includes NUL-character, only the data before that should be 	 * displayed. Some EAP implementasitons may piggy-back additional 	 * options after the NUL. 	 */
comment|/* TODO: could save displayable message so that it can be shown to the 	 * user in case of interaction is required */
name|wpa_hexdump_ascii
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: EAP-Request Identity data"
argument_list|,
name|pos
argument_list|,
name|msg_len
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|PCSC_FUNCS
end_ifdef

begin_comment
comment|/*  * Rules for figuring out MNC length based on IMSI for SIM cards that do not  * include MNC length field.  */
end_comment

begin_function
specifier|static
name|int
name|mnc_len_from_imsi
parameter_list|(
specifier|const
name|char
modifier|*
name|imsi
parameter_list|)
block|{
name|char
name|mcc_str
index|[
literal|4
index|]
decl_stmt|;
name|unsigned
name|int
name|mcc
decl_stmt|;
name|os_memcpy
argument_list|(
name|mcc_str
argument_list|,
name|imsi
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|mcc_str
index|[
literal|3
index|]
operator|=
literal|'\0'
expr_stmt|;
name|mcc
operator|=
name|atoi
argument_list|(
name|mcc_str
argument_list|)
expr_stmt|;
if|if
condition|(
name|mcc
operator|==
literal|228
condition|)
return|return
literal|2
return|;
comment|/* Networks in Switzerland use 2-digit MNC */
if|if
condition|(
name|mcc
operator|==
literal|244
condition|)
return|return
literal|2
return|;
comment|/* Networks in Finland use 2-digit MNC */
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|eap_sm_append_3gpp_realm
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|char
modifier|*
name|imsi
parameter_list|,
name|size_t
name|max_len
parameter_list|,
name|size_t
modifier|*
name|imsi_len
parameter_list|)
block|{
name|int
name|mnc_len
decl_stmt|;
name|char
modifier|*
name|pos
decl_stmt|,
name|mnc
index|[
literal|4
index|]
decl_stmt|;
if|if
condition|(
operator|*
name|imsi_len
operator|+
literal|36
operator|>
name|max_len
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_WARNING
argument_list|,
literal|"No room for realm in IMSI buffer"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* MNC (2 or 3 digits) */
name|mnc_len
operator|=
name|scard_get_mnc_len
argument_list|(
name|sm
operator|->
name|scard_ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|mnc_len
operator|<
literal|0
condition|)
name|mnc_len
operator|=
name|mnc_len_from_imsi
argument_list|(
name|imsi
argument_list|)
expr_stmt|;
if|if
condition|(
name|mnc_len
operator|<
literal|0
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_INFO
argument_list|,
literal|"Failed to get MNC length from (U)SIM "
literal|"assuming 3"
argument_list|)
expr_stmt|;
name|mnc_len
operator|=
literal|3
expr_stmt|;
block|}
if|if
condition|(
name|mnc_len
operator|==
literal|2
condition|)
block|{
name|mnc
index|[
literal|0
index|]
operator|=
literal|'0'
expr_stmt|;
name|mnc
index|[
literal|1
index|]
operator|=
name|imsi
index|[
literal|3
index|]
expr_stmt|;
name|mnc
index|[
literal|2
index|]
operator|=
name|imsi
index|[
literal|4
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mnc_len
operator|==
literal|3
condition|)
block|{
name|mnc
index|[
literal|0
index|]
operator|=
name|imsi
index|[
literal|3
index|]
expr_stmt|;
name|mnc
index|[
literal|1
index|]
operator|=
name|imsi
index|[
literal|4
index|]
expr_stmt|;
name|mnc
index|[
literal|2
index|]
operator|=
name|imsi
index|[
literal|5
index|]
expr_stmt|;
block|}
name|mnc
index|[
literal|3
index|]
operator|=
literal|'\0'
expr_stmt|;
name|pos
operator|=
name|imsi
operator|+
operator|*
name|imsi_len
expr_stmt|;
name|pos
operator|+=
name|os_snprintf
argument_list|(
name|pos
argument_list|,
name|imsi
operator|+
name|max_len
operator|-
name|pos
argument_list|,
literal|"@wlan.mnc%s.mcc%c%c%c.3gppnetwork.org"
argument_list|,
name|mnc
argument_list|,
name|imsi
index|[
literal|0
index|]
argument_list|,
name|imsi
index|[
literal|1
index|]
argument_list|,
name|imsi
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
operator|*
name|imsi_len
operator|=
name|pos
operator|-
name|imsi
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|eap_sm_imsi_identity
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|struct
name|eap_peer_config
modifier|*
name|conf
parameter_list|)
block|{
enum|enum
block|{
name|EAP_SM_SIM
block|,
name|EAP_SM_AKA
block|,
name|EAP_SM_AKA_PRIME
block|}
name|method
init|=
name|EAP_SM_SIM
enum|;
name|char
name|imsi
index|[
literal|100
index|]
decl_stmt|;
name|size_t
name|imsi_len
decl_stmt|;
name|struct
name|eap_method_type
modifier|*
name|m
init|=
name|conf
operator|->
name|eap_methods
decl_stmt|;
name|int
name|i
decl_stmt|;
name|imsi_len
operator|=
sizeof|sizeof
argument_list|(
name|imsi
argument_list|)
expr_stmt|;
if|if
condition|(
name|scard_get_imsi
argument_list|(
name|sm
operator|->
name|scard_ctx
argument_list|,
name|imsi
argument_list|,
operator|&
name|imsi_len
argument_list|)
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_WARNING
argument_list|,
literal|"Failed to get IMSI from SIM"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|wpa_hexdump_ascii
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"IMSI"
argument_list|,
operator|(
name|u8
operator|*
operator|)
name|imsi
argument_list|,
name|imsi_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|imsi_len
operator|<
literal|7
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_WARNING
argument_list|,
literal|"Too short IMSI for SIM identity"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|eap_sm_append_3gpp_realm
argument_list|(
name|sm
argument_list|,
name|imsi
argument_list|,
sizeof|sizeof
argument_list|(
name|imsi
argument_list|)
argument_list|,
operator|&
name|imsi_len
argument_list|)
operator|<
literal|0
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_WARNING
argument_list|,
literal|"Could not add realm to SIM identity"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|wpa_hexdump_ascii
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"IMSI + realm"
argument_list|,
operator|(
name|u8
operator|*
operator|)
name|imsi
argument_list|,
name|imsi_len
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|m
operator|&&
operator|(
name|m
index|[
name|i
index|]
operator|.
name|vendor
operator|!=
name|EAP_VENDOR_IETF
operator|||
name|m
index|[
name|i
index|]
operator|.
name|method
operator|!=
name|EAP_TYPE_NONE
operator|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|m
index|[
name|i
index|]
operator|.
name|vendor
operator|==
name|EAP_VENDOR_IETF
operator|&&
name|m
index|[
name|i
index|]
operator|.
name|method
operator|==
name|EAP_TYPE_AKA_PRIME
condition|)
block|{
name|method
operator|=
name|EAP_SM_AKA_PRIME
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|m
index|[
name|i
index|]
operator|.
name|vendor
operator|==
name|EAP_VENDOR_IETF
operator|&&
name|m
index|[
name|i
index|]
operator|.
name|method
operator|==
name|EAP_TYPE_AKA
condition|)
block|{
name|method
operator|=
name|EAP_SM_AKA
expr_stmt|;
break|break;
block|}
block|}
name|os_free
argument_list|(
name|conf
operator|->
name|identity
argument_list|)
expr_stmt|;
name|conf
operator|->
name|identity
operator|=
name|os_malloc
argument_list|(
literal|1
operator|+
name|imsi_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|conf
operator|->
name|identity
operator|==
name|NULL
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_WARNING
argument_list|,
literal|"Failed to allocate buffer for "
literal|"IMSI-based identity"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
switch|switch
condition|(
name|method
condition|)
block|{
case|case
name|EAP_SM_SIM
case|:
name|conf
operator|->
name|identity
index|[
literal|0
index|]
operator|=
literal|'1'
expr_stmt|;
break|break;
case|case
name|EAP_SM_AKA
case|:
name|conf
operator|->
name|identity
index|[
literal|0
index|]
operator|=
literal|'0'
expr_stmt|;
break|break;
case|case
name|EAP_SM_AKA_PRIME
case|:
name|conf
operator|->
name|identity
index|[
literal|0
index|]
operator|=
literal|'6'
expr_stmt|;
break|break;
block|}
name|os_memcpy
argument_list|(
name|conf
operator|->
name|identity
operator|+
literal|1
argument_list|,
name|imsi
argument_list|,
name|imsi_len
argument_list|)
expr_stmt|;
name|conf
operator|->
name|identity_len
operator|=
literal|1
operator|+
name|imsi_len
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PCSC_FUNCS */
end_comment

begin_function
specifier|static
name|int
name|eap_sm_set_scard_pin
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|struct
name|eap_peer_config
modifier|*
name|conf
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|PCSC_FUNCS
if|if
condition|(
name|scard_set_pin
argument_list|(
name|sm
operator|->
name|scard_ctx
argument_list|,
name|conf
operator|->
name|pin
argument_list|)
condition|)
block|{
comment|/* 		 * Make sure the same PIN is not tried again in order to avoid 		 * blocking SIM. 		 */
name|os_free
argument_list|(
name|conf
operator|->
name|pin
argument_list|)
expr_stmt|;
name|conf
operator|->
name|pin
operator|=
name|NULL
expr_stmt|;
name|wpa_printf
argument_list|(
name|MSG_WARNING
argument_list|,
literal|"PIN validation failed"
argument_list|)
expr_stmt|;
name|eap_sm_request_pin
argument_list|(
name|sm
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
else|#
directive|else
comment|/* PCSC_FUNCS */
return|return
operator|-
literal|1
return|;
endif|#
directive|endif
comment|/* PCSC_FUNCS */
block|}
end_function

begin_function
specifier|static
name|int
name|eap_sm_get_scard_identity
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|struct
name|eap_peer_config
modifier|*
name|conf
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|PCSC_FUNCS
if|if
condition|(
name|eap_sm_set_scard_pin
argument_list|(
name|sm
argument_list|,
name|conf
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|eap_sm_imsi_identity
argument_list|(
name|sm
argument_list|,
name|conf
argument_list|)
return|;
else|#
directive|else
comment|/* PCSC_FUNCS */
return|return
operator|-
literal|1
return|;
endif|#
directive|endif
comment|/* PCSC_FUNCS */
block|}
end_function

begin_comment
comment|/**  * eap_sm_buildIdentity - Build EAP-Identity/Response for the current network  * @sm: Pointer to EAP state machine allocated with eap_peer_sm_init()  * @id: EAP identifier for the packet  * @encrypted: Whether the packet is for encrypted tunnel (EAP phase 2)  * Returns: Pointer to the allocated EAP-Identity/Response packet or %NULL on  * failure  *  * This function allocates and builds an EAP-Identity/Response packet for the  * current network. The caller is responsible for freeing the returned data.  */
end_comment

begin_function
name|struct
name|wpabuf
modifier|*
name|eap_sm_buildIdentity
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|int
name|id
parameter_list|,
name|int
name|encrypted
parameter_list|)
block|{
name|struct
name|eap_peer_config
modifier|*
name|config
init|=
name|eap_get_config
argument_list|(
name|sm
argument_list|)
decl_stmt|;
name|struct
name|wpabuf
modifier|*
name|resp
decl_stmt|;
specifier|const
name|u8
modifier|*
name|identity
decl_stmt|;
name|size_t
name|identity_len
decl_stmt|;
if|if
condition|(
name|config
operator|==
name|NULL
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_WARNING
argument_list|,
literal|"EAP: buildIdentity: configuration "
literal|"was not available"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|sm
operator|->
name|m
operator|&&
name|sm
operator|->
name|m
operator|->
name|get_identity
operator|&&
operator|(
name|identity
operator|=
name|sm
operator|->
name|m
operator|->
name|get_identity
argument_list|(
name|sm
argument_list|,
name|sm
operator|->
name|eap_method_priv
argument_list|,
operator|&
name|identity_len
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|wpa_hexdump_ascii
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: using method re-auth "
literal|"identity"
argument_list|,
name|identity
argument_list|,
name|identity_len
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|encrypted
operator|&&
name|config
operator|->
name|anonymous_identity
condition|)
block|{
name|identity
operator|=
name|config
operator|->
name|anonymous_identity
expr_stmt|;
name|identity_len
operator|=
name|config
operator|->
name|anonymous_identity_len
expr_stmt|;
name|wpa_hexdump_ascii
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: using anonymous identity"
argument_list|,
name|identity
argument_list|,
name|identity_len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|identity
operator|=
name|config
operator|->
name|identity
expr_stmt|;
name|identity_len
operator|=
name|config
operator|->
name|identity_len
expr_stmt|;
name|wpa_hexdump_ascii
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: using real identity"
argument_list|,
name|identity
argument_list|,
name|identity_len
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|identity
operator|==
name|NULL
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_WARNING
argument_list|,
literal|"EAP: buildIdentity: identity "
literal|"configuration was not available"
argument_list|)
expr_stmt|;
if|if
condition|(
name|config
operator|->
name|pcsc
condition|)
block|{
if|if
condition|(
name|eap_sm_get_scard_identity
argument_list|(
name|sm
argument_list|,
name|config
argument_list|)
operator|<
literal|0
condition|)
return|return
name|NULL
return|;
name|identity
operator|=
name|config
operator|->
name|identity
expr_stmt|;
name|identity_len
operator|=
name|config
operator|->
name|identity_len
expr_stmt|;
name|wpa_hexdump_ascii
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"permanent identity from "
literal|"IMSI"
argument_list|,
name|identity
argument_list|,
name|identity_len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|eap_sm_request_identity
argument_list|(
name|sm
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|config
operator|->
name|pcsc
condition|)
block|{
if|if
condition|(
name|eap_sm_set_scard_pin
argument_list|(
name|sm
argument_list|,
name|config
argument_list|)
operator|<
literal|0
condition|)
return|return
name|NULL
return|;
block|}
name|resp
operator|=
name|eap_msg_alloc
argument_list|(
name|EAP_VENDOR_IETF
argument_list|,
name|EAP_TYPE_IDENTITY
argument_list|,
name|identity_len
argument_list|,
name|EAP_CODE_RESPONSE
argument_list|,
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|resp
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|wpabuf_put_data
argument_list|(
name|resp
argument_list|,
name|identity
argument_list|,
name|identity_len
argument_list|)
expr_stmt|;
return|return
name|resp
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|eap_sm_processNotify
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
specifier|const
name|struct
name|wpabuf
modifier|*
name|req
parameter_list|)
block|{
specifier|const
name|u8
modifier|*
name|pos
decl_stmt|;
name|char
modifier|*
name|msg
decl_stmt|;
name|size_t
name|i
decl_stmt|,
name|msg_len
decl_stmt|;
name|pos
operator|=
name|eap_hdr_validate
argument_list|(
name|EAP_VENDOR_IETF
argument_list|,
name|EAP_TYPE_NOTIFICATION
argument_list|,
name|req
argument_list|,
operator|&
name|msg_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|==
name|NULL
condition|)
return|return;
name|wpa_hexdump_ascii
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: EAP-Request Notification data"
argument_list|,
name|pos
argument_list|,
name|msg_len
argument_list|)
expr_stmt|;
name|msg
operator|=
name|os_malloc
argument_list|(
name|msg_len
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
operator|==
name|NULL
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|msg_len
condition|;
name|i
operator|++
control|)
name|msg
index|[
name|i
index|]
operator|=
name|isprint
argument_list|(
name|pos
index|[
name|i
index|]
argument_list|)
condition|?
operator|(
name|char
operator|)
name|pos
index|[
name|i
index|]
else|:
literal|'_'
expr_stmt|;
name|msg
index|[
name|msg_len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|wpa_msg
argument_list|(
name|sm
operator|->
name|msg_ctx
argument_list|,
name|MSG_INFO
argument_list|,
literal|"%s%s"
argument_list|,
name|WPA_EVENT_EAP_NOTIFICATION
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|os_free
argument_list|(
name|msg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|wpabuf
modifier|*
name|eap_sm_buildNotify
parameter_list|(
name|int
name|id
parameter_list|)
block|{
name|struct
name|wpabuf
modifier|*
name|resp
decl_stmt|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: Generating EAP-Response Notification"
argument_list|)
expr_stmt|;
name|resp
operator|=
name|eap_msg_alloc
argument_list|(
name|EAP_VENDOR_IETF
argument_list|,
name|EAP_TYPE_NOTIFICATION
argument_list|,
literal|0
argument_list|,
name|EAP_CODE_RESPONSE
argument_list|,
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|resp
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
return|return
name|resp
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|eap_peer_initiate
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
specifier|const
name|struct
name|eap_hdr
modifier|*
name|hdr
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|CONFIG_ERP
specifier|const
name|u8
modifier|*
name|pos
init|=
operator|(
specifier|const
name|u8
operator|*
operator|)
operator|(
name|hdr
operator|+
literal|1
operator|)
decl_stmt|;
specifier|const
name|u8
modifier|*
name|end
init|=
operator|(
operator|(
specifier|const
name|u8
operator|*
operator|)
name|hdr
operator|)
operator|+
name|len
decl_stmt|;
name|struct
name|erp_tlvs
name|parse
decl_stmt|;
if|if
condition|(
name|len
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
operator|+
literal|1
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: Ignored too short EAP-Initiate"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|*
name|pos
operator|!=
name|EAP_ERP_TYPE_REAUTH_START
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: Ignored unexpected EAP-Initiate Type=%u"
argument_list|,
operator|*
name|pos
argument_list|)
expr_stmt|;
return|return;
block|}
name|pos
operator|++
expr_stmt|;
if|if
condition|(
name|pos
operator|>=
name|end
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: Too short EAP-Initiate/Re-auth-Start"
argument_list|)
expr_stmt|;
return|return;
block|}
name|pos
operator|++
expr_stmt|;
comment|/* Reserved */
name|wpa_hexdump
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: EAP-Initiate/Re-auth-Start TVs/TLVs"
argument_list|,
name|pos
argument_list|,
name|end
operator|-
name|pos
argument_list|)
expr_stmt|;
if|if
condition|(
name|erp_parse_tlvs
argument_list|(
name|pos
argument_list|,
name|end
argument_list|,
operator|&
name|parse
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|invalid
goto|;
if|if
condition|(
name|parse
operator|.
name|domain
condition|)
block|{
name|wpa_hexdump_ascii
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: EAP-Initiate/Re-auth-Start - Domain name"
argument_list|,
name|parse
operator|.
name|domain
argument_list|,
name|parse
operator|.
name|domain_len
argument_list|)
expr_stmt|;
comment|/* TODO: Derivation of domain specific keys for local ER */
block|}
if|if
condition|(
name|eap_peer_erp_reauth_start
argument_list|(
name|sm
argument_list|,
name|hdr
argument_list|,
name|len
argument_list|)
operator|==
literal|0
condition|)
return|return;
name|invalid
label|:
endif|#
directive|endif
comment|/* CONFIG_ERP */
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: EAP-Initiate/Re-auth-Start - No suitable ERP keys available - try to start full EAP authentication"
argument_list|)
expr_stmt|;
name|eapol_set_bool
argument_list|(
name|sm
argument_list|,
name|EAPOL_eapTriggerStart
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|eap_peer_finish
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
specifier|const
name|struct
name|eap_hdr
modifier|*
name|hdr
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|CONFIG_ERP
specifier|const
name|u8
modifier|*
name|pos
init|=
operator|(
specifier|const
name|u8
operator|*
operator|)
operator|(
name|hdr
operator|+
literal|1
operator|)
decl_stmt|;
specifier|const
name|u8
modifier|*
name|end
init|=
operator|(
operator|(
specifier|const
name|u8
operator|*
operator|)
name|hdr
operator|)
operator|+
name|len
decl_stmt|;
specifier|const
name|u8
modifier|*
name|start
decl_stmt|;
name|struct
name|erp_tlvs
name|parse
decl_stmt|;
name|u8
name|flags
decl_stmt|;
name|u16
name|seq
decl_stmt|;
name|u8
name|hash
index|[
name|SHA256_MAC_LEN
index|]
decl_stmt|;
name|size_t
name|hash_len
decl_stmt|;
name|struct
name|eap_erp_key
modifier|*
name|erp
decl_stmt|;
name|int
name|max_len
decl_stmt|;
name|char
name|nai
index|[
literal|254
index|]
decl_stmt|;
name|u8
name|seed
index|[
literal|4
index|]
decl_stmt|;
name|int
name|auth_tag_ok
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|len
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
operator|+
literal|1
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: Ignored too short EAP-Finish"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|*
name|pos
operator|!=
name|EAP_ERP_TYPE_REAUTH
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: Ignored unexpected EAP-Finish Type=%u"
argument_list|,
operator|*
name|pos
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|len
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
operator|+
literal|4
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: Ignored too short EAP-Finish/Re-auth"
argument_list|)
expr_stmt|;
return|return;
block|}
name|pos
operator|++
expr_stmt|;
name|flags
operator|=
operator|*
name|pos
operator|++
expr_stmt|;
name|seq
operator|=
name|WPA_GET_BE16
argument_list|(
name|pos
argument_list|)
expr_stmt|;
name|pos
operator|+=
literal|2
expr_stmt|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: Flags=0x%x SEQ=%u"
argument_list|,
name|flags
argument_list|,
name|seq
argument_list|)
expr_stmt|;
if|if
condition|(
name|seq
operator|!=
name|sm
operator|->
name|erp_seq
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: Unexpected EAP-Finish/Re-auth SEQ=%u"
argument_list|,
name|seq
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Parse TVs/TLVs. Since we do not yet know the length of the 	 * Authentication Tag, stop parsing if an unknown TV/TLV is seen and 	 * just try to find the keyName-NAI first so that we can check the 	 * Authentication Tag. 	 */
if|if
condition|(
name|erp_parse_tlvs
argument_list|(
name|pos
argument_list|,
name|end
argument_list|,
operator|&
name|parse
argument_list|,
literal|1
argument_list|)
operator|<
literal|0
condition|)
return|return;
if|if
condition|(
operator|!
name|parse
operator|.
name|keyname
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: No keyName-NAI in EAP-Finish/Re-auth Packet"
argument_list|)
expr_stmt|;
return|return;
block|}
name|wpa_hexdump_ascii
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: EAP-Finish/Re-auth - keyName-NAI"
argument_list|,
name|parse
operator|.
name|keyname
argument_list|,
name|parse
operator|.
name|keyname_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|parse
operator|.
name|keyname_len
operator|>
literal|253
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: Too long keyName-NAI in EAP-Finish/Re-auth"
argument_list|)
expr_stmt|;
return|return;
block|}
name|os_memcpy
argument_list|(
name|nai
argument_list|,
name|parse
operator|.
name|keyname
argument_list|,
name|parse
operator|.
name|keyname_len
argument_list|)
expr_stmt|;
name|nai
index|[
name|parse
operator|.
name|keyname_len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|erp
operator|=
name|eap_erp_get_key_nai
argument_list|(
name|sm
argument_list|,
name|nai
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|erp
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: No matching ERP key found for %s"
argument_list|,
name|nai
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Is there enough room for Cryptosuite and Authentication Tag? */
name|start
operator|=
name|parse
operator|.
name|keyname
operator|+
name|parse
operator|.
name|keyname_len
expr_stmt|;
name|max_len
operator|=
name|end
operator|-
name|start
expr_stmt|;
name|hash_len
operator|=
literal|16
expr_stmt|;
if|if
condition|(
name|max_len
operator|<
literal|1
operator|+
operator|(
name|int
operator|)
name|hash_len
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: Not enough room for Authentication Tag"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
literal|0x80
condition|)
goto|goto
name|no_auth_tag
goto|;
return|return;
block|}
if|if
condition|(
name|end
index|[
operator|-
literal|17
index|]
operator|!=
name|EAP_ERP_CS_HMAC_SHA256_128
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: Different Cryptosuite used"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
literal|0x80
condition|)
goto|goto
name|no_auth_tag
goto|;
return|return;
block|}
if|if
condition|(
name|hmac_sha256
argument_list|(
name|erp
operator|->
name|rIK
argument_list|,
name|erp
operator|->
name|rIK_len
argument_list|,
operator|(
specifier|const
name|u8
operator|*
operator|)
name|hdr
argument_list|,
name|end
operator|-
operator|(
operator|(
specifier|const
name|u8
operator|*
operator|)
name|hdr
operator|)
operator|-
name|hash_len
argument_list|,
name|hash
argument_list|)
operator|<
literal|0
condition|)
return|return;
if|if
condition|(
name|os_memcmp
argument_list|(
name|end
operator|-
name|hash_len
argument_list|,
name|hash
argument_list|,
name|hash_len
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: Authentication Tag mismatch"
argument_list|)
expr_stmt|;
return|return;
block|}
name|auth_tag_ok
operator|=
literal|1
expr_stmt|;
name|end
operator|-=
literal|1
operator|+
name|hash_len
expr_stmt|;
name|no_auth_tag
label|:
comment|/* 	 * Parse TVs/TLVs again now that we know the exact part of the buffer 	 * that contains them. 	 */
name|wpa_hexdump
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: EAP-Finish/Re-Auth TVs/TLVs"
argument_list|,
name|pos
argument_list|,
name|end
operator|-
name|pos
argument_list|)
expr_stmt|;
if|if
condition|(
name|erp_parse_tlvs
argument_list|(
name|pos
argument_list|,
name|end
argument_list|,
operator|&
name|parse
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
return|return;
if|if
condition|(
name|flags
operator|&
literal|0x80
operator|||
operator|!
name|auth_tag_ok
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: EAP-Finish/Re-auth indicated failure"
argument_list|)
expr_stmt|;
name|eapol_set_bool
argument_list|(
name|sm
argument_list|,
name|EAPOL_eapFail
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|eapol_set_bool
argument_list|(
name|sm
argument_list|,
name|EAPOL_eapReq
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|eapol_set_bool
argument_list|(
name|sm
argument_list|,
name|EAPOL_eapNoResp
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|wpa_msg
argument_list|(
name|sm
operator|->
name|msg_ctx
argument_list|,
name|MSG_INFO
argument_list|,
name|WPA_EVENT_EAP_FAILURE
literal|"EAP authentication failed"
argument_list|)
expr_stmt|;
name|sm
operator|->
name|prev_failure
operator|=
literal|1
expr_stmt|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: Drop ERP key to try full authentication on next attempt"
argument_list|)
expr_stmt|;
name|eap_peer_erp_free_key
argument_list|(
name|erp
argument_list|)
expr_stmt|;
return|return;
block|}
name|eap_sm_free_key
argument_list|(
name|sm
argument_list|)
expr_stmt|;
name|sm
operator|->
name|eapKeyDataLen
operator|=
literal|0
expr_stmt|;
name|sm
operator|->
name|eapKeyData
operator|=
name|os_malloc
argument_list|(
name|erp
operator|->
name|rRK_len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sm
operator|->
name|eapKeyData
condition|)
return|return;
name|sm
operator|->
name|eapKeyDataLen
operator|=
name|erp
operator|->
name|rRK_len
expr_stmt|;
name|WPA_PUT_BE16
argument_list|(
name|seed
argument_list|,
name|seq
argument_list|)
expr_stmt|;
name|WPA_PUT_BE16
argument_list|(
operator|&
name|seed
index|[
literal|2
index|]
argument_list|,
name|erp
operator|->
name|rRK_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|hmac_sha256_kdf
argument_list|(
name|erp
operator|->
name|rRK
argument_list|,
name|erp
operator|->
name|rRK_len
argument_list|,
literal|"Re-authentication Master Session Key@ietf.org"
argument_list|,
name|seed
argument_list|,
sizeof|sizeof
argument_list|(
name|seed
argument_list|)
argument_list|,
name|sm
operator|->
name|eapKeyData
argument_list|,
name|erp
operator|->
name|rRK_len
argument_list|)
operator|<
literal|0
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: Could not derive rMSK for ERP"
argument_list|)
expr_stmt|;
name|eap_sm_free_key
argument_list|(
name|sm
argument_list|)
expr_stmt|;
return|return;
block|}
name|wpa_hexdump_key
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: ERP rMSK"
argument_list|,
name|sm
operator|->
name|eapKeyData
argument_list|,
name|sm
operator|->
name|eapKeyDataLen
argument_list|)
expr_stmt|;
name|sm
operator|->
name|eapKeyAvailable
operator|=
name|TRUE
expr_stmt|;
name|eapol_set_bool
argument_list|(
name|sm
argument_list|,
name|EAPOL_eapSuccess
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|eapol_set_bool
argument_list|(
name|sm
argument_list|,
name|EAPOL_eapReq
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|eapol_set_bool
argument_list|(
name|sm
argument_list|,
name|EAPOL_eapNoResp
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|wpa_msg
argument_list|(
name|sm
operator|->
name|msg_ctx
argument_list|,
name|MSG_INFO
argument_list|,
name|WPA_EVENT_EAP_SUCCESS
literal|"EAP re-authentication completed successfully"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* CONFIG_ERP */
block|}
end_function

begin_function
specifier|static
name|void
name|eap_sm_parseEapReq
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
specifier|const
name|struct
name|wpabuf
modifier|*
name|req
parameter_list|)
block|{
specifier|const
name|struct
name|eap_hdr
modifier|*
name|hdr
decl_stmt|;
name|size_t
name|plen
decl_stmt|;
specifier|const
name|u8
modifier|*
name|pos
decl_stmt|;
name|sm
operator|->
name|rxReq
operator|=
name|sm
operator|->
name|rxResp
operator|=
name|sm
operator|->
name|rxSuccess
operator|=
name|sm
operator|->
name|rxFailure
operator|=
name|FALSE
expr_stmt|;
name|sm
operator|->
name|reqId
operator|=
literal|0
expr_stmt|;
name|sm
operator|->
name|reqMethod
operator|=
name|EAP_TYPE_NONE
expr_stmt|;
name|sm
operator|->
name|reqVendor
operator|=
name|EAP_VENDOR_IETF
expr_stmt|;
name|sm
operator|->
name|reqVendorMethod
operator|=
name|EAP_TYPE_NONE
expr_stmt|;
if|if
condition|(
name|req
operator|==
name|NULL
operator|||
name|wpabuf_len
argument_list|(
name|req
argument_list|)
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
condition|)
return|return;
name|hdr
operator|=
name|wpabuf_head
argument_list|(
name|req
argument_list|)
expr_stmt|;
name|plen
operator|=
name|be_to_host16
argument_list|(
name|hdr
operator|->
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|plen
operator|>
name|wpabuf_len
argument_list|(
name|req
argument_list|)
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: Ignored truncated EAP-Packet "
literal|"(len=%lu plen=%lu)"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|wpabuf_len
argument_list|(
name|req
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|plen
argument_list|)
expr_stmt|;
return|return;
block|}
name|sm
operator|->
name|reqId
operator|=
name|hdr
operator|->
name|identifier
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|workaround
condition|)
block|{
specifier|const
name|u8
modifier|*
name|addr
index|[
literal|1
index|]
decl_stmt|;
name|addr
index|[
literal|0
index|]
operator|=
name|wpabuf_head
argument_list|(
name|req
argument_list|)
expr_stmt|;
name|sha1_vector
argument_list|(
literal|1
argument_list|,
name|addr
argument_list|,
operator|&
name|plen
argument_list|,
name|sm
operator|->
name|req_sha1
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|hdr
operator|->
name|code
condition|)
block|{
case|case
name|EAP_CODE_REQUEST
case|:
if|if
condition|(
name|plen
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
operator|+
literal|1
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: Too short EAP-Request - "
literal|"no Type field"
argument_list|)
expr_stmt|;
return|return;
block|}
name|sm
operator|->
name|rxReq
operator|=
name|TRUE
expr_stmt|;
name|pos
operator|=
operator|(
specifier|const
name|u8
operator|*
operator|)
operator|(
name|hdr
operator|+
literal|1
operator|)
expr_stmt|;
name|sm
operator|->
name|reqMethod
operator|=
operator|*
name|pos
operator|++
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|reqMethod
operator|==
name|EAP_TYPE_EXPANDED
condition|)
block|{
if|if
condition|(
name|plen
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
operator|+
literal|8
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: Ignored truncated "
literal|"expanded EAP-Packet (plen=%lu)"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|plen
argument_list|)
expr_stmt|;
return|return;
block|}
name|sm
operator|->
name|reqVendor
operator|=
name|WPA_GET_BE24
argument_list|(
name|pos
argument_list|)
expr_stmt|;
name|pos
operator|+=
literal|3
expr_stmt|;
name|sm
operator|->
name|reqVendorMethod
operator|=
name|WPA_GET_BE32
argument_list|(
name|pos
argument_list|)
expr_stmt|;
block|}
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: Received EAP-Request id=%d "
literal|"method=%u vendor=%u vendorMethod=%u"
argument_list|,
name|sm
operator|->
name|reqId
argument_list|,
name|sm
operator|->
name|reqMethod
argument_list|,
name|sm
operator|->
name|reqVendor
argument_list|,
name|sm
operator|->
name|reqVendorMethod
argument_list|)
expr_stmt|;
break|break;
case|case
name|EAP_CODE_RESPONSE
case|:
if|if
condition|(
name|sm
operator|->
name|selectedMethod
operator|==
name|EAP_TYPE_LEAP
condition|)
block|{
comment|/* 			 * LEAP differs from RFC 4137 by using reversed roles 			 * for mutual authentication and because of this, we 			 * need to accept EAP-Response frames if LEAP is used. 			 */
if|if
condition|(
name|plen
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
operator|+
literal|1
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: Too short "
literal|"EAP-Response - no Type field"
argument_list|)
expr_stmt|;
return|return;
block|}
name|sm
operator|->
name|rxResp
operator|=
name|TRUE
expr_stmt|;
name|pos
operator|=
operator|(
specifier|const
name|u8
operator|*
operator|)
operator|(
name|hdr
operator|+
literal|1
operator|)
expr_stmt|;
name|sm
operator|->
name|reqMethod
operator|=
operator|*
name|pos
expr_stmt|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: Received EAP-Response for "
literal|"LEAP method=%d id=%d"
argument_list|,
name|sm
operator|->
name|reqMethod
argument_list|,
name|sm
operator|->
name|reqId
argument_list|)
expr_stmt|;
break|break;
block|}
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: Ignored EAP-Response"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EAP_CODE_SUCCESS
case|:
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: Received EAP-Success"
argument_list|)
expr_stmt|;
name|eap_notify_status
argument_list|(
name|sm
argument_list|,
literal|"completion"
argument_list|,
literal|"success"
argument_list|)
expr_stmt|;
name|sm
operator|->
name|rxSuccess
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|EAP_CODE_FAILURE
case|:
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: Received EAP-Failure"
argument_list|)
expr_stmt|;
name|eap_notify_status
argument_list|(
name|sm
argument_list|,
literal|"completion"
argument_list|,
literal|"failure"
argument_list|)
expr_stmt|;
name|sm
operator|->
name|rxFailure
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|EAP_CODE_INITIATE
case|:
name|eap_peer_initiate
argument_list|(
name|sm
argument_list|,
name|hdr
argument_list|,
name|plen
argument_list|)
expr_stmt|;
break|break;
case|case
name|EAP_CODE_FINISH
case|:
name|eap_peer_finish
argument_list|(
name|sm
argument_list|,
name|hdr
argument_list|,
name|plen
argument_list|)
expr_stmt|;
break|break;
default|default:
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: Ignored EAP-Packet with unknown "
literal|"code %d"
argument_list|,
name|hdr
operator|->
name|code
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|eap_peer_sm_tls_event
parameter_list|(
name|void
modifier|*
name|ctx
parameter_list|,
name|enum
name|tls_event
name|ev
parameter_list|,
name|union
name|tls_event_data
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|eap_sm
modifier|*
name|sm
init|=
name|ctx
decl_stmt|;
name|char
modifier|*
name|hash_hex
init|=
name|NULL
decl_stmt|;
switch|switch
condition|(
name|ev
condition|)
block|{
case|case
name|TLS_CERT_CHAIN_SUCCESS
case|:
name|eap_notify_status
argument_list|(
name|sm
argument_list|,
literal|"remote certificate verification"
argument_list|,
literal|"success"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TLS_CERT_CHAIN_FAILURE
case|:
name|wpa_msg
argument_list|(
name|sm
operator|->
name|msg_ctx
argument_list|,
name|MSG_INFO
argument_list|,
name|WPA_EVENT_EAP_TLS_CERT_ERROR
literal|"reason=%d depth=%d subject='%s' err='%s'"
argument_list|,
name|data
operator|->
name|cert_fail
operator|.
name|reason
argument_list|,
name|data
operator|->
name|cert_fail
operator|.
name|depth
argument_list|,
name|data
operator|->
name|cert_fail
operator|.
name|subject
argument_list|,
name|data
operator|->
name|cert_fail
operator|.
name|reason_txt
argument_list|)
expr_stmt|;
name|eap_notify_status
argument_list|(
name|sm
argument_list|,
literal|"remote certificate verification"
argument_list|,
name|data
operator|->
name|cert_fail
operator|.
name|reason_txt
argument_list|)
expr_stmt|;
break|break;
case|case
name|TLS_PEER_CERTIFICATE
case|:
if|if
condition|(
operator|!
name|sm
operator|->
name|eapol_cb
operator|->
name|notify_cert
condition|)
break|break;
if|if
condition|(
name|data
operator|->
name|peer_cert
operator|.
name|hash
condition|)
block|{
name|size_t
name|len
init|=
name|data
operator|->
name|peer_cert
operator|.
name|hash_len
operator|*
literal|2
operator|+
literal|1
decl_stmt|;
name|hash_hex
operator|=
name|os_malloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|hash_hex
condition|)
block|{
name|wpa_snprintf_hex
argument_list|(
name|hash_hex
argument_list|,
name|len
argument_list|,
name|data
operator|->
name|peer_cert
operator|.
name|hash
argument_list|,
name|data
operator|->
name|peer_cert
operator|.
name|hash_len
argument_list|)
expr_stmt|;
block|}
block|}
name|sm
operator|->
name|eapol_cb
operator|->
name|notify_cert
argument_list|(
name|sm
operator|->
name|eapol_ctx
argument_list|,
name|data
operator|->
name|peer_cert
operator|.
name|depth
argument_list|,
name|data
operator|->
name|peer_cert
operator|.
name|subject
argument_list|,
name|data
operator|->
name|peer_cert
operator|.
name|altsubject
argument_list|,
name|data
operator|->
name|peer_cert
operator|.
name|num_altsubject
argument_list|,
name|hash_hex
argument_list|,
name|data
operator|->
name|peer_cert
operator|.
name|cert
argument_list|)
expr_stmt|;
break|break;
case|case
name|TLS_ALERT
case|:
if|if
condition|(
name|data
operator|->
name|alert
operator|.
name|is_local
condition|)
name|eap_notify_status
argument_list|(
name|sm
argument_list|,
literal|"local TLS alert"
argument_list|,
name|data
operator|->
name|alert
operator|.
name|description
argument_list|)
expr_stmt|;
else|else
name|eap_notify_status
argument_list|(
name|sm
argument_list|,
literal|"remote TLS alert"
argument_list|,
name|data
operator|->
name|alert
operator|.
name|description
argument_list|)
expr_stmt|;
break|break;
block|}
name|os_free
argument_list|(
name|hash_hex
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * eap_peer_sm_init - Allocate and initialize EAP peer state machine  * @eapol_ctx: Context data to be used with eapol_cb calls  * @eapol_cb: Pointer to EAPOL callback functions  * @msg_ctx: Context data for wpa_msg() calls  * @conf: EAP configuration  * Returns: Pointer to the allocated EAP state machine or %NULL on failure  *  * This function allocates and initializes an EAP state machine. In addition,  * this initializes TLS library for the new EAP state machine. eapol_cb pointer  * will be in use until eap_peer_sm_deinit() is used to deinitialize this EAP  * state machine. Consequently, the caller must make sure that this data  * structure remains alive while the EAP state machine is active.  */
end_comment

begin_function
name|struct
name|eap_sm
modifier|*
name|eap_peer_sm_init
parameter_list|(
name|void
modifier|*
name|eapol_ctx
parameter_list|,
specifier|const
name|struct
name|eapol_callbacks
modifier|*
name|eapol_cb
parameter_list|,
name|void
modifier|*
name|msg_ctx
parameter_list|,
name|struct
name|eap_config
modifier|*
name|conf
parameter_list|)
block|{
name|struct
name|eap_sm
modifier|*
name|sm
decl_stmt|;
name|struct
name|tls_config
name|tlsconf
decl_stmt|;
name|sm
operator|=
name|os_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|sm
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|sm
operator|->
name|eapol_ctx
operator|=
name|eapol_ctx
expr_stmt|;
name|sm
operator|->
name|eapol_cb
operator|=
name|eapol_cb
expr_stmt|;
name|sm
operator|->
name|msg_ctx
operator|=
name|msg_ctx
expr_stmt|;
name|sm
operator|->
name|ClientTimeout
operator|=
name|EAP_CLIENT_TIMEOUT_DEFAULT
expr_stmt|;
name|sm
operator|->
name|wps
operator|=
name|conf
operator|->
name|wps
expr_stmt|;
name|dl_list_init
argument_list|(
operator|&
name|sm
operator|->
name|erp_keys
argument_list|)
expr_stmt|;
name|os_memset
argument_list|(
operator|&
name|tlsconf
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|tlsconf
argument_list|)
argument_list|)
expr_stmt|;
name|tlsconf
operator|.
name|opensc_engine_path
operator|=
name|conf
operator|->
name|opensc_engine_path
expr_stmt|;
name|tlsconf
operator|.
name|pkcs11_engine_path
operator|=
name|conf
operator|->
name|pkcs11_engine_path
expr_stmt|;
name|tlsconf
operator|.
name|pkcs11_module_path
operator|=
name|conf
operator|->
name|pkcs11_module_path
expr_stmt|;
name|tlsconf
operator|.
name|openssl_ciphers
operator|=
name|conf
operator|->
name|openssl_ciphers
expr_stmt|;
ifdef|#
directive|ifdef
name|CONFIG_FIPS
name|tlsconf
operator|.
name|fips_mode
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* CONFIG_FIPS */
name|tlsconf
operator|.
name|event_cb
operator|=
name|eap_peer_sm_tls_event
expr_stmt|;
name|tlsconf
operator|.
name|cb_ctx
operator|=
name|sm
expr_stmt|;
name|tlsconf
operator|.
name|cert_in_cb
operator|=
name|conf
operator|->
name|cert_in_cb
expr_stmt|;
name|sm
operator|->
name|ssl_ctx
operator|=
name|tls_init
argument_list|(
operator|&
name|tlsconf
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|ssl_ctx
operator|==
name|NULL
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_WARNING
argument_list|,
literal|"SSL: Failed to initialize TLS "
literal|"context."
argument_list|)
expr_stmt|;
name|os_free
argument_list|(
name|sm
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|sm
operator|->
name|ssl_ctx2
operator|=
name|tls_init
argument_list|(
operator|&
name|tlsconf
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|ssl_ctx2
operator|==
name|NULL
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_INFO
argument_list|,
literal|"SSL: Failed to initialize TLS "
literal|"context (2)."
argument_list|)
expr_stmt|;
comment|/* Run without separate TLS context within TLS tunnel */
block|}
return|return
name|sm
return|;
block|}
end_function

begin_comment
comment|/**  * eap_peer_sm_deinit - Deinitialize and free an EAP peer state machine  * @sm: Pointer to EAP state machine allocated with eap_peer_sm_init()  *  * This function deinitializes EAP state machine and frees all allocated  * resources.  */
end_comment

begin_function
name|void
name|eap_peer_sm_deinit
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|)
block|{
if|if
condition|(
name|sm
operator|==
name|NULL
condition|)
return|return;
name|eap_deinit_prev_method
argument_list|(
name|sm
argument_list|,
literal|"EAP deinit"
argument_list|)
expr_stmt|;
name|eap_sm_abort
argument_list|(
name|sm
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|ssl_ctx2
condition|)
name|tls_deinit
argument_list|(
name|sm
operator|->
name|ssl_ctx2
argument_list|)
expr_stmt|;
name|tls_deinit
argument_list|(
name|sm
operator|->
name|ssl_ctx
argument_list|)
expr_stmt|;
name|eap_peer_erp_free_keys
argument_list|(
name|sm
argument_list|)
expr_stmt|;
name|os_free
argument_list|(
name|sm
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * eap_peer_sm_step - Step EAP peer state machine  * @sm: Pointer to EAP state machine allocated with eap_peer_sm_init()  * Returns: 1 if EAP state was changed or 0 if not  *  * This function advances EAP state machine to a new state to match with the  * current variables. This should be called whenever variables used by the EAP  * state machine have changed.  */
end_comment

begin_function
name|int
name|eap_peer_sm_step
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|)
block|{
name|int
name|res
init|=
literal|0
decl_stmt|;
do|do
block|{
name|sm
operator|->
name|changed
operator|=
name|FALSE
expr_stmt|;
name|SM_STEP_RUN
argument_list|(
name|EAP
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|changed
condition|)
name|res
operator|=
literal|1
expr_stmt|;
block|}
do|while
condition|(
name|sm
operator|->
name|changed
condition|)
do|;
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/**  * eap_sm_abort - Abort EAP authentication  * @sm: Pointer to EAP state machine allocated with eap_peer_sm_init()  *  * Release system resources that have been allocated for the authentication  * session without fully deinitializing the EAP state machine.  */
end_comment

begin_function
name|void
name|eap_sm_abort
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|)
block|{
name|wpabuf_free
argument_list|(
name|sm
operator|->
name|lastRespData
argument_list|)
expr_stmt|;
name|sm
operator|->
name|lastRespData
operator|=
name|NULL
expr_stmt|;
name|wpabuf_free
argument_list|(
name|sm
operator|->
name|eapRespData
argument_list|)
expr_stmt|;
name|sm
operator|->
name|eapRespData
operator|=
name|NULL
expr_stmt|;
name|eap_sm_free_key
argument_list|(
name|sm
argument_list|)
expr_stmt|;
name|os_free
argument_list|(
name|sm
operator|->
name|eapSessionId
argument_list|)
expr_stmt|;
name|sm
operator|->
name|eapSessionId
operator|=
name|NULL
expr_stmt|;
comment|/* This is not clearly specified in the EAP statemachines draft, but 	 * it seems necessary to make sure that some of the EAPOL variables get 	 * cleared for the next authentication. */
name|eapol_set_bool
argument_list|(
name|sm
argument_list|,
name|EAPOL_eapSuccess
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|CONFIG_CTRL_IFACE
end_ifdef

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|eap_sm_state_txt
parameter_list|(
name|int
name|state
parameter_list|)
block|{
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|EAP_INITIALIZE
case|:
return|return
literal|"INITIALIZE"
return|;
case|case
name|EAP_DISABLED
case|:
return|return
literal|"DISABLED"
return|;
case|case
name|EAP_IDLE
case|:
return|return
literal|"IDLE"
return|;
case|case
name|EAP_RECEIVED
case|:
return|return
literal|"RECEIVED"
return|;
case|case
name|EAP_GET_METHOD
case|:
return|return
literal|"GET_METHOD"
return|;
case|case
name|EAP_METHOD
case|:
return|return
literal|"METHOD"
return|;
case|case
name|EAP_SEND_RESPONSE
case|:
return|return
literal|"SEND_RESPONSE"
return|;
case|case
name|EAP_DISCARD
case|:
return|return
literal|"DISCARD"
return|;
case|case
name|EAP_IDENTITY
case|:
return|return
literal|"IDENTITY"
return|;
case|case
name|EAP_NOTIFICATION
case|:
return|return
literal|"NOTIFICATION"
return|;
case|case
name|EAP_RETRANSMIT
case|:
return|return
literal|"RETRANSMIT"
return|;
case|case
name|EAP_SUCCESS
case|:
return|return
literal|"SUCCESS"
return|;
case|case
name|EAP_FAILURE
case|:
return|return
literal|"FAILURE"
return|;
default|default:
return|return
literal|"UNKNOWN"
return|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CONFIG_CTRL_IFACE */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|CONFIG_CTRL_IFACE
argument_list|)
operator|||
operator|!
name|defined
argument_list|(
name|CONFIG_NO_STDOUT_DEBUG
argument_list|)
end_if

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|eap_sm_method_state_txt
parameter_list|(
name|EapMethodState
name|state
parameter_list|)
block|{
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|METHOD_NONE
case|:
return|return
literal|"NONE"
return|;
case|case
name|METHOD_INIT
case|:
return|return
literal|"INIT"
return|;
case|case
name|METHOD_CONT
case|:
return|return
literal|"CONT"
return|;
case|case
name|METHOD_MAY_CONT
case|:
return|return
literal|"MAY_CONT"
return|;
case|case
name|METHOD_DONE
case|:
return|return
literal|"DONE"
return|;
default|default:
return|return
literal|"UNKNOWN"
return|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|eap_sm_decision_txt
parameter_list|(
name|EapDecision
name|decision
parameter_list|)
block|{
switch|switch
condition|(
name|decision
condition|)
block|{
case|case
name|DECISION_FAIL
case|:
return|return
literal|"FAIL"
return|;
case|case
name|DECISION_COND_SUCC
case|:
return|return
literal|"COND_SUCC"
return|;
case|case
name|DECISION_UNCOND_SUCC
case|:
return|return
literal|"UNCOND_SUCC"
return|;
default|default:
return|return
literal|"UNKNOWN"
return|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CONFIG_CTRL_IFACE || !CONFIG_NO_STDOUT_DEBUG */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|CONFIG_CTRL_IFACE
end_ifdef

begin_comment
comment|/**  * eap_sm_get_status - Get EAP state machine status  * @sm: Pointer to EAP state machine allocated with eap_peer_sm_init()  * @buf: Buffer for status information  * @buflen: Maximum buffer length  * @verbose: Whether to include verbose status information  * Returns: Number of bytes written to buf.  *  * Query EAP state machine for status information. This function fills in a  * text area with current status information from the EAPOL state machine. If  * the buffer (buf) is not large enough, status information will be truncated  * to fit the buffer.  */
end_comment

begin_function
name|int
name|eap_sm_get_status
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|buflen
parameter_list|,
name|int
name|verbose
parameter_list|)
block|{
name|int
name|len
decl_stmt|,
name|ret
decl_stmt|;
if|if
condition|(
name|sm
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|len
operator|=
name|os_snprintf
argument_list|(
name|buf
argument_list|,
name|buflen
argument_list|,
literal|"EAP state=%s\n"
argument_list|,
name|eap_sm_state_txt
argument_list|(
name|sm
operator|->
name|EAP_state
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|os_snprintf_error
argument_list|(
name|buflen
argument_list|,
name|len
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|sm
operator|->
name|selectedMethod
operator|!=
name|EAP_TYPE_NONE
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
name|sm
operator|->
name|m
condition|)
block|{
name|name
operator|=
name|sm
operator|->
name|m
operator|->
name|name
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|struct
name|eap_method
modifier|*
name|m
init|=
name|eap_peer_get_eap_method
argument_list|(
name|EAP_VENDOR_IETF
argument_list|,
name|sm
operator|->
name|selectedMethod
argument_list|)
decl_stmt|;
if|if
condition|(
name|m
condition|)
name|name
operator|=
name|m
operator|->
name|name
expr_stmt|;
else|else
name|name
operator|=
literal|"?"
expr_stmt|;
block|}
name|ret
operator|=
name|os_snprintf
argument_list|(
name|buf
operator|+
name|len
argument_list|,
name|buflen
operator|-
name|len
argument_list|,
literal|"selectedMethod=%d (EAP-%s)\n"
argument_list|,
name|sm
operator|->
name|selectedMethod
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|os_snprintf_error
argument_list|(
name|buflen
operator|-
name|len
argument_list|,
name|ret
argument_list|)
condition|)
return|return
name|len
return|;
name|len
operator|+=
name|ret
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|m
operator|&&
name|sm
operator|->
name|m
operator|->
name|get_status
condition|)
block|{
name|len
operator|+=
name|sm
operator|->
name|m
operator|->
name|get_status
argument_list|(
name|sm
argument_list|,
name|sm
operator|->
name|eap_method_priv
argument_list|,
name|buf
operator|+
name|len
argument_list|,
name|buflen
operator|-
name|len
argument_list|,
name|verbose
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|verbose
condition|)
block|{
name|ret
operator|=
name|os_snprintf
argument_list|(
name|buf
operator|+
name|len
argument_list|,
name|buflen
operator|-
name|len
argument_list|,
literal|"reqMethod=%d\n"
literal|"methodState=%s\n"
literal|"decision=%s\n"
literal|"ClientTimeout=%d\n"
argument_list|,
name|sm
operator|->
name|reqMethod
argument_list|,
name|eap_sm_method_state_txt
argument_list|(
name|sm
operator|->
name|methodState
argument_list|)
argument_list|,
name|eap_sm_decision_txt
argument_list|(
name|sm
operator|->
name|decision
argument_list|)
argument_list|,
name|sm
operator|->
name|ClientTimeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|os_snprintf_error
argument_list|(
name|buflen
operator|-
name|len
argument_list|,
name|ret
argument_list|)
condition|)
return|return
name|len
return|;
name|len
operator|+=
name|ret
expr_stmt|;
block|}
return|return
name|len
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CONFIG_CTRL_IFACE */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|CONFIG_CTRL_IFACE
argument_list|)
operator|||
operator|!
name|defined
argument_list|(
name|CONFIG_NO_STDOUT_DEBUG
argument_list|)
end_if

begin_function
specifier|static
name|void
name|eap_sm_request
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|enum
name|wpa_ctrl_req_type
name|field
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
name|size_t
name|msglen
parameter_list|)
block|{
name|struct
name|eap_peer_config
modifier|*
name|config
decl_stmt|;
specifier|const
name|char
modifier|*
name|txt
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|tmp
decl_stmt|;
if|if
condition|(
name|sm
operator|==
name|NULL
condition|)
return|return;
name|config
operator|=
name|eap_get_config
argument_list|(
name|sm
argument_list|)
expr_stmt|;
if|if
condition|(
name|config
operator|==
name|NULL
condition|)
return|return;
switch|switch
condition|(
name|field
condition|)
block|{
case|case
name|WPA_CTRL_REQ_EAP_IDENTITY
case|:
name|config
operator|->
name|pending_req_identity
operator|++
expr_stmt|;
break|break;
case|case
name|WPA_CTRL_REQ_EAP_PASSWORD
case|:
name|config
operator|->
name|pending_req_password
operator|++
expr_stmt|;
break|break;
case|case
name|WPA_CTRL_REQ_EAP_NEW_PASSWORD
case|:
name|config
operator|->
name|pending_req_new_password
operator|++
expr_stmt|;
break|break;
case|case
name|WPA_CTRL_REQ_EAP_PIN
case|:
name|config
operator|->
name|pending_req_pin
operator|++
expr_stmt|;
break|break;
case|case
name|WPA_CTRL_REQ_EAP_OTP
case|:
if|if
condition|(
name|msg
condition|)
block|{
name|tmp
operator|=
name|os_malloc
argument_list|(
name|msglen
operator|+
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
name|NULL
condition|)
return|return;
name|tmp
index|[
literal|0
index|]
operator|=
literal|'['
expr_stmt|;
name|os_memcpy
argument_list|(
name|tmp
operator|+
literal|1
argument_list|,
name|msg
argument_list|,
name|msglen
argument_list|)
expr_stmt|;
name|tmp
index|[
name|msglen
operator|+
literal|1
index|]
operator|=
literal|']'
expr_stmt|;
name|tmp
index|[
name|msglen
operator|+
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
name|txt
operator|=
name|tmp
expr_stmt|;
name|os_free
argument_list|(
name|config
operator|->
name|pending_req_otp
argument_list|)
expr_stmt|;
name|config
operator|->
name|pending_req_otp
operator|=
name|tmp
expr_stmt|;
name|config
operator|->
name|pending_req_otp_len
operator|=
name|msglen
operator|+
literal|3
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|config
operator|->
name|pending_req_otp
operator|==
name|NULL
condition|)
return|return;
name|txt
operator|=
name|config
operator|->
name|pending_req_otp
expr_stmt|;
block|}
break|break;
case|case
name|WPA_CTRL_REQ_EAP_PASSPHRASE
case|:
name|config
operator|->
name|pending_req_passphrase
operator|++
expr_stmt|;
break|break;
case|case
name|WPA_CTRL_REQ_SIM
case|:
name|txt
operator|=
name|msg
expr_stmt|;
break|break;
default|default:
return|return;
block|}
if|if
condition|(
name|sm
operator|->
name|eapol_cb
operator|->
name|eap_param_needed
condition|)
name|sm
operator|->
name|eapol_cb
operator|->
name|eap_param_needed
argument_list|(
name|sm
operator|->
name|eapol_ctx
argument_list|,
name|field
argument_list|,
name|txt
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* CONFIG_CTRL_IFACE || !CONFIG_NO_STDOUT_DEBUG */
end_comment

begin_define
define|#
directive|define
name|eap_sm_request
parameter_list|(
name|sm
parameter_list|,
name|type
parameter_list|,
name|msg
parameter_list|,
name|msglen
parameter_list|)
value|do { } while (0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CONFIG_CTRL_IFACE || !CONFIG_NO_STDOUT_DEBUG */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|eap_sm_get_method_name
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|)
block|{
if|if
condition|(
name|sm
operator|->
name|m
operator|==
name|NULL
condition|)
return|return
literal|"UNKNOWN"
return|;
return|return
name|sm
operator|->
name|m
operator|->
name|name
return|;
block|}
end_function

begin_comment
comment|/**  * eap_sm_request_identity - Request identity from user (ctrl_iface)  * @sm: Pointer to EAP state machine allocated with eap_peer_sm_init()  *  * EAP methods can call this function to request identity information for the  * current network. This is normally called when the identity is not included  * in the network configuration. The request will be sent to monitor programs  * through the control interface.  */
end_comment

begin_function
name|void
name|eap_sm_request_identity
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|)
block|{
name|eap_sm_request
argument_list|(
name|sm
argument_list|,
name|WPA_CTRL_REQ_EAP_IDENTITY
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * eap_sm_request_password - Request password from user (ctrl_iface)  * @sm: Pointer to EAP state machine allocated with eap_peer_sm_init()  *  * EAP methods can call this function to request password information for the  * current network. This is normally called when the password is not included  * in the network configuration. The request will be sent to monitor programs  * through the control interface.  */
end_comment

begin_function
name|void
name|eap_sm_request_password
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|)
block|{
name|eap_sm_request
argument_list|(
name|sm
argument_list|,
name|WPA_CTRL_REQ_EAP_PASSWORD
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * eap_sm_request_new_password - Request new password from user (ctrl_iface)  * @sm: Pointer to EAP state machine allocated with eap_peer_sm_init()  *  * EAP methods can call this function to request new password information for  * the current network. This is normally called when the EAP method indicates  * that the current password has expired and password change is required. The  * request will be sent to monitor programs through the control interface.  */
end_comment

begin_function
name|void
name|eap_sm_request_new_password
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|)
block|{
name|eap_sm_request
argument_list|(
name|sm
argument_list|,
name|WPA_CTRL_REQ_EAP_NEW_PASSWORD
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * eap_sm_request_pin - Request SIM or smart card PIN from user (ctrl_iface)  * @sm: Pointer to EAP state machine allocated with eap_peer_sm_init()  *  * EAP methods can call this function to request SIM or smart card PIN  * information for the current network. This is normally called when the PIN is  * not included in the network configuration. The request will be sent to  * monitor programs through the control interface.  */
end_comment

begin_function
name|void
name|eap_sm_request_pin
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|)
block|{
name|eap_sm_request
argument_list|(
name|sm
argument_list|,
name|WPA_CTRL_REQ_EAP_PIN
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * eap_sm_request_otp - Request one time password from user (ctrl_iface)  * @sm: Pointer to EAP state machine allocated with eap_peer_sm_init()  * @msg: Message to be displayed to the user when asking for OTP  * @msg_len: Length of the user displayable message  *  * EAP methods can call this function to request open time password (OTP) for  * the current network. The request will be sent to monitor programs through  * the control interface.  */
end_comment

begin_function
name|void
name|eap_sm_request_otp
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
name|size_t
name|msg_len
parameter_list|)
block|{
name|eap_sm_request
argument_list|(
name|sm
argument_list|,
name|WPA_CTRL_REQ_EAP_OTP
argument_list|,
name|msg
argument_list|,
name|msg_len
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * eap_sm_request_passphrase - Request passphrase from user (ctrl_iface)  * @sm: Pointer to EAP state machine allocated with eap_peer_sm_init()  *  * EAP methods can call this function to request passphrase for a private key  * for the current network. This is normally called when the passphrase is not  * included in the network configuration. The request will be sent to monitor  * programs through the control interface.  */
end_comment

begin_function
name|void
name|eap_sm_request_passphrase
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|)
block|{
name|eap_sm_request
argument_list|(
name|sm
argument_list|,
name|WPA_CTRL_REQ_EAP_PASSPHRASE
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * eap_sm_request_sim - Request external SIM processing  * @sm: Pointer to EAP state machine allocated with eap_peer_sm_init()  * @req: EAP method specific request  */
end_comment

begin_function
name|void
name|eap_sm_request_sim
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
specifier|const
name|char
modifier|*
name|req
parameter_list|)
block|{
name|eap_sm_request
argument_list|(
name|sm
argument_list|,
name|WPA_CTRL_REQ_SIM
argument_list|,
name|req
argument_list|,
name|os_strlen
argument_list|(
name|req
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * eap_sm_notify_ctrl_attached - Notification of attached monitor  * @sm: Pointer to EAP state machine allocated with eap_peer_sm_init()  *  * Notify EAP state machines that a monitor was attached to the control  * interface to trigger re-sending of pending requests for user input.  */
end_comment

begin_function
name|void
name|eap_sm_notify_ctrl_attached
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|)
block|{
name|struct
name|eap_peer_config
modifier|*
name|config
init|=
name|eap_get_config
argument_list|(
name|sm
argument_list|)
decl_stmt|;
if|if
condition|(
name|config
operator|==
name|NULL
condition|)
return|return;
comment|/* Re-send any pending requests for user data since a new control 	 * interface was added. This handles cases where the EAP authentication 	 * starts immediately after system startup when the user interface is 	 * not yet running. */
if|if
condition|(
name|config
operator|->
name|pending_req_identity
condition|)
name|eap_sm_request_identity
argument_list|(
name|sm
argument_list|)
expr_stmt|;
if|if
condition|(
name|config
operator|->
name|pending_req_password
condition|)
name|eap_sm_request_password
argument_list|(
name|sm
argument_list|)
expr_stmt|;
if|if
condition|(
name|config
operator|->
name|pending_req_new_password
condition|)
name|eap_sm_request_new_password
argument_list|(
name|sm
argument_list|)
expr_stmt|;
if|if
condition|(
name|config
operator|->
name|pending_req_otp
condition|)
name|eap_sm_request_otp
argument_list|(
name|sm
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|config
operator|->
name|pending_req_pin
condition|)
name|eap_sm_request_pin
argument_list|(
name|sm
argument_list|)
expr_stmt|;
if|if
condition|(
name|config
operator|->
name|pending_req_passphrase
condition|)
name|eap_sm_request_passphrase
argument_list|(
name|sm
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|eap_allowed_phase2_type
parameter_list|(
name|int
name|vendor
parameter_list|,
name|int
name|type
parameter_list|)
block|{
if|if
condition|(
name|vendor
operator|!=
name|EAP_VENDOR_IETF
condition|)
return|return
literal|0
return|;
return|return
name|type
operator|!=
name|EAP_TYPE_PEAP
operator|&&
name|type
operator|!=
name|EAP_TYPE_TTLS
operator|&&
name|type
operator|!=
name|EAP_TYPE_FAST
return|;
block|}
end_function

begin_comment
comment|/**  * eap_get_phase2_type - Get EAP type for the given EAP phase 2 method name  * @name: EAP method name, e.g., MD5  * @vendor: Buffer for returning EAP Vendor-Id  * Returns: EAP method type or %EAP_TYPE_NONE if not found  *  * This function maps EAP type names into EAP type numbers that are allowed for  * Phase 2, i.e., for tunneled authentication. Phase 2 is used, e.g., with  * EAP-PEAP, EAP-TTLS, and EAP-FAST.  */
end_comment

begin_function
name|u32
name|eap_get_phase2_type
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
modifier|*
name|vendor
parameter_list|)
block|{
name|int
name|v
decl_stmt|;
name|u32
name|type
init|=
name|eap_peer_get_type
argument_list|(
name|name
argument_list|,
operator|&
name|v
argument_list|)
decl_stmt|;
if|if
condition|(
name|eap_allowed_phase2_type
argument_list|(
name|v
argument_list|,
name|type
argument_list|)
condition|)
block|{
operator|*
name|vendor
operator|=
name|v
expr_stmt|;
return|return
name|type
return|;
block|}
operator|*
name|vendor
operator|=
name|EAP_VENDOR_IETF
expr_stmt|;
return|return
name|EAP_TYPE_NONE
return|;
block|}
end_function

begin_comment
comment|/**  * eap_get_phase2_types - Get list of allowed EAP phase 2 types  * @config: Pointer to a network configuration  * @count: Pointer to a variable to be filled with number of returned EAP types  * Returns: Pointer to allocated type list or %NULL on failure  *  * This function generates an array of allowed EAP phase 2 (tunneled) types for  * the given network configuration.  */
end_comment

begin_function
name|struct
name|eap_method_type
modifier|*
name|eap_get_phase2_types
parameter_list|(
name|struct
name|eap_peer_config
modifier|*
name|config
parameter_list|,
name|size_t
modifier|*
name|count
parameter_list|)
block|{
name|struct
name|eap_method_type
modifier|*
name|buf
decl_stmt|;
name|u32
name|method
decl_stmt|;
name|int
name|vendor
decl_stmt|;
name|size_t
name|mcount
decl_stmt|;
specifier|const
name|struct
name|eap_method
modifier|*
name|methods
decl_stmt|,
modifier|*
name|m
decl_stmt|;
name|methods
operator|=
name|eap_peer_get_methods
argument_list|(
operator|&
name|mcount
argument_list|)
expr_stmt|;
if|if
condition|(
name|methods
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
operator|*
name|count
operator|=
literal|0
expr_stmt|;
name|buf
operator|=
name|os_malloc
argument_list|(
name|mcount
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|eap_method_type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
for|for
control|(
name|m
operator|=
name|methods
init|;
name|m
condition|;
name|m
operator|=
name|m
operator|->
name|next
control|)
block|{
name|vendor
operator|=
name|m
operator|->
name|vendor
expr_stmt|;
name|method
operator|=
name|m
operator|->
name|method
expr_stmt|;
if|if
condition|(
name|eap_allowed_phase2_type
argument_list|(
name|vendor
argument_list|,
name|method
argument_list|)
condition|)
block|{
if|if
condition|(
name|vendor
operator|==
name|EAP_VENDOR_IETF
operator|&&
name|method
operator|==
name|EAP_TYPE_TLS
operator|&&
name|config
operator|&&
name|config
operator|->
name|private_key2
operator|==
name|NULL
condition|)
continue|continue;
name|buf
index|[
operator|*
name|count
index|]
operator|.
name|vendor
operator|=
name|vendor
expr_stmt|;
name|buf
index|[
operator|*
name|count
index|]
operator|.
name|method
operator|=
name|method
expr_stmt|;
operator|(
operator|*
name|count
operator|)
operator|++
expr_stmt|;
block|}
block|}
return|return
name|buf
return|;
block|}
end_function

begin_comment
comment|/**  * eap_set_fast_reauth - Update fast_reauth setting  * @sm: Pointer to EAP state machine allocated with eap_peer_sm_init()  * @enabled: 1 = Fast reauthentication is enabled, 0 = Disabled  */
end_comment

begin_function
name|void
name|eap_set_fast_reauth
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|int
name|enabled
parameter_list|)
block|{
name|sm
operator|->
name|fast_reauth
operator|=
name|enabled
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * eap_set_workaround - Update EAP workarounds setting  * @sm: Pointer to EAP state machine allocated with eap_peer_sm_init()  * @workaround: 1 = Enable EAP workarounds, 0 = Disable EAP workarounds  */
end_comment

begin_function
name|void
name|eap_set_workaround
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|unsigned
name|int
name|workaround
parameter_list|)
block|{
name|sm
operator|->
name|workaround
operator|=
name|workaround
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * eap_get_config - Get current network configuration  * @sm: Pointer to EAP state machine allocated with eap_peer_sm_init()  * Returns: Pointer to the current network configuration or %NULL if not found  *  * EAP peer methods should avoid using this function if they can use other  * access functions, like eap_get_config_identity() and  * eap_get_config_password(), that do not require direct access to  * struct eap_peer_config.  */
end_comment

begin_function
name|struct
name|eap_peer_config
modifier|*
name|eap_get_config
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|)
block|{
return|return
name|sm
operator|->
name|eapol_cb
operator|->
name|get_config
argument_list|(
name|sm
operator|->
name|eapol_ctx
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * eap_get_config_identity - Get identity from the network configuration  * @sm: Pointer to EAP state machine allocated with eap_peer_sm_init()  * @len: Buffer for the length of the identity  * Returns: Pointer to the identity or %NULL if not found  */
end_comment

begin_function
specifier|const
name|u8
modifier|*
name|eap_get_config_identity
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|size_t
modifier|*
name|len
parameter_list|)
block|{
name|struct
name|eap_peer_config
modifier|*
name|config
init|=
name|eap_get_config
argument_list|(
name|sm
argument_list|)
decl_stmt|;
if|if
condition|(
name|config
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
operator|*
name|len
operator|=
name|config
operator|->
name|identity_len
expr_stmt|;
return|return
name|config
operator|->
name|identity
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|eap_get_ext_password
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|struct
name|eap_peer_config
modifier|*
name|config
parameter_list|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
name|config
operator|->
name|password
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|name
operator|=
name|os_zalloc
argument_list|(
name|config
operator|->
name|password_len
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|os_memcpy
argument_list|(
name|name
argument_list|,
name|config
operator|->
name|password
argument_list|,
name|config
operator|->
name|password_len
argument_list|)
expr_stmt|;
name|ext_password_free
argument_list|(
name|sm
operator|->
name|ext_pw_buf
argument_list|)
expr_stmt|;
name|sm
operator|->
name|ext_pw_buf
operator|=
name|ext_password_get
argument_list|(
name|sm
operator|->
name|ext_pw
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|os_free
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return
name|sm
operator|->
name|ext_pw_buf
operator|==
name|NULL
condition|?
operator|-
literal|1
else|:
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * eap_get_config_password - Get password from the network configuration  * @sm: Pointer to EAP state machine allocated with eap_peer_sm_init()  * @len: Buffer for the length of the password  * Returns: Pointer to the password or %NULL if not found  */
end_comment

begin_function
specifier|const
name|u8
modifier|*
name|eap_get_config_password
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|size_t
modifier|*
name|len
parameter_list|)
block|{
name|struct
name|eap_peer_config
modifier|*
name|config
init|=
name|eap_get_config
argument_list|(
name|sm
argument_list|)
decl_stmt|;
if|if
condition|(
name|config
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|config
operator|->
name|flags
operator|&
name|EAP_CONFIG_FLAGS_EXT_PASSWORD
condition|)
block|{
if|if
condition|(
name|eap_get_ext_password
argument_list|(
name|sm
argument_list|,
name|config
argument_list|)
operator|<
literal|0
condition|)
return|return
name|NULL
return|;
operator|*
name|len
operator|=
name|wpabuf_len
argument_list|(
name|sm
operator|->
name|ext_pw_buf
argument_list|)
expr_stmt|;
return|return
name|wpabuf_head
argument_list|(
name|sm
operator|->
name|ext_pw_buf
argument_list|)
return|;
block|}
operator|*
name|len
operator|=
name|config
operator|->
name|password_len
expr_stmt|;
return|return
name|config
operator|->
name|password
return|;
block|}
end_function

begin_comment
comment|/**  * eap_get_config_password2 - Get password from the network configuration  * @sm: Pointer to EAP state machine allocated with eap_peer_sm_init()  * @len: Buffer for the length of the password  * @hash: Buffer for returning whether the password is stored as a  * NtPasswordHash instead of plaintext password; can be %NULL if this  * information is not needed  * Returns: Pointer to the password or %NULL if not found  */
end_comment

begin_function
specifier|const
name|u8
modifier|*
name|eap_get_config_password2
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|size_t
modifier|*
name|len
parameter_list|,
name|int
modifier|*
name|hash
parameter_list|)
block|{
name|struct
name|eap_peer_config
modifier|*
name|config
init|=
name|eap_get_config
argument_list|(
name|sm
argument_list|)
decl_stmt|;
if|if
condition|(
name|config
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|config
operator|->
name|flags
operator|&
name|EAP_CONFIG_FLAGS_EXT_PASSWORD
condition|)
block|{
if|if
condition|(
name|eap_get_ext_password
argument_list|(
name|sm
argument_list|,
name|config
argument_list|)
operator|<
literal|0
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|hash
condition|)
operator|*
name|hash
operator|=
literal|0
expr_stmt|;
operator|*
name|len
operator|=
name|wpabuf_len
argument_list|(
name|sm
operator|->
name|ext_pw_buf
argument_list|)
expr_stmt|;
return|return
name|wpabuf_head
argument_list|(
name|sm
operator|->
name|ext_pw_buf
argument_list|)
return|;
block|}
operator|*
name|len
operator|=
name|config
operator|->
name|password_len
expr_stmt|;
if|if
condition|(
name|hash
condition|)
operator|*
name|hash
operator|=
operator|!
operator|!
operator|(
name|config
operator|->
name|flags
operator|&
name|EAP_CONFIG_FLAGS_PASSWORD_NTHASH
operator|)
expr_stmt|;
return|return
name|config
operator|->
name|password
return|;
block|}
end_function

begin_comment
comment|/**  * eap_get_config_new_password - Get new password from network configuration  * @sm: Pointer to EAP state machine allocated with eap_peer_sm_init()  * @len: Buffer for the length of the new password  * Returns: Pointer to the new password or %NULL if not found  */
end_comment

begin_function
specifier|const
name|u8
modifier|*
name|eap_get_config_new_password
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|size_t
modifier|*
name|len
parameter_list|)
block|{
name|struct
name|eap_peer_config
modifier|*
name|config
init|=
name|eap_get_config
argument_list|(
name|sm
argument_list|)
decl_stmt|;
if|if
condition|(
name|config
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
operator|*
name|len
operator|=
name|config
operator|->
name|new_password_len
expr_stmt|;
return|return
name|config
operator|->
name|new_password
return|;
block|}
end_function

begin_comment
comment|/**  * eap_get_config_otp - Get one-time password from the network configuration  * @sm: Pointer to EAP state machine allocated with eap_peer_sm_init()  * @len: Buffer for the length of the one-time password  * Returns: Pointer to the one-time password or %NULL if not found  */
end_comment

begin_function
specifier|const
name|u8
modifier|*
name|eap_get_config_otp
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|size_t
modifier|*
name|len
parameter_list|)
block|{
name|struct
name|eap_peer_config
modifier|*
name|config
init|=
name|eap_get_config
argument_list|(
name|sm
argument_list|)
decl_stmt|;
if|if
condition|(
name|config
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
operator|*
name|len
operator|=
name|config
operator|->
name|otp_len
expr_stmt|;
return|return
name|config
operator|->
name|otp
return|;
block|}
end_function

begin_comment
comment|/**  * eap_clear_config_otp - Clear used one-time password  * @sm: Pointer to EAP state machine allocated with eap_peer_sm_init()  *  * This function clears a used one-time password (OTP) from the current network  * configuration. This should be called when the OTP has been used and is not  * needed anymore.  */
end_comment

begin_function
name|void
name|eap_clear_config_otp
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|)
block|{
name|struct
name|eap_peer_config
modifier|*
name|config
init|=
name|eap_get_config
argument_list|(
name|sm
argument_list|)
decl_stmt|;
if|if
condition|(
name|config
operator|==
name|NULL
condition|)
return|return;
name|os_memset
argument_list|(
name|config
operator|->
name|otp
argument_list|,
literal|0
argument_list|,
name|config
operator|->
name|otp_len
argument_list|)
expr_stmt|;
name|os_free
argument_list|(
name|config
operator|->
name|otp
argument_list|)
expr_stmt|;
name|config
operator|->
name|otp
operator|=
name|NULL
expr_stmt|;
name|config
operator|->
name|otp_len
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * eap_get_config_phase1 - Get phase1 data from the network configuration  * @sm: Pointer to EAP state machine allocated with eap_peer_sm_init()  * Returns: Pointer to the phase1 data or %NULL if not found  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|eap_get_config_phase1
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|)
block|{
name|struct
name|eap_peer_config
modifier|*
name|config
init|=
name|eap_get_config
argument_list|(
name|sm
argument_list|)
decl_stmt|;
if|if
condition|(
name|config
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
return|return
name|config
operator|->
name|phase1
return|;
block|}
end_function

begin_comment
comment|/**  * eap_get_config_phase2 - Get phase2 data from the network configuration  * @sm: Pointer to EAP state machine allocated with eap_peer_sm_init()  * Returns: Pointer to the phase1 data or %NULL if not found  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|eap_get_config_phase2
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|)
block|{
name|struct
name|eap_peer_config
modifier|*
name|config
init|=
name|eap_get_config
argument_list|(
name|sm
argument_list|)
decl_stmt|;
if|if
condition|(
name|config
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
return|return
name|config
operator|->
name|phase2
return|;
block|}
end_function

begin_function
name|int
name|eap_get_config_fragment_size
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|)
block|{
name|struct
name|eap_peer_config
modifier|*
name|config
init|=
name|eap_get_config
argument_list|(
name|sm
argument_list|)
decl_stmt|;
if|if
condition|(
name|config
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|config
operator|->
name|fragment_size
return|;
block|}
end_function

begin_comment
comment|/**  * eap_key_available - Get key availability (eapKeyAvailable variable)  * @sm: Pointer to EAP state machine allocated with eap_peer_sm_init()  * Returns: 1 if EAP keying material is available, 0 if not  */
end_comment

begin_function
name|int
name|eap_key_available
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|)
block|{
return|return
name|sm
condition|?
name|sm
operator|->
name|eapKeyAvailable
else|:
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * eap_notify_success - Notify EAP state machine about external success trigger  * @sm: Pointer to EAP state machine allocated with eap_peer_sm_init()  *  * This function is called when external event, e.g., successful completion of  * WPA-PSK key handshake, is indicating that EAP state machine should move to  * success state. This is mainly used with security modes that do not use EAP  * state machine (e.g., WPA-PSK).  */
end_comment

begin_function
name|void
name|eap_notify_success
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|)
block|{
if|if
condition|(
name|sm
condition|)
block|{
name|sm
operator|->
name|decision
operator|=
name|DECISION_COND_SUCC
expr_stmt|;
name|sm
operator|->
name|EAP_state
operator|=
name|EAP_SUCCESS
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * eap_notify_lower_layer_success - Notification of lower layer success  * @sm: Pointer to EAP state machine allocated with eap_peer_sm_init()  *  * Notify EAP state machines that a lower layer has detected a successful  * authentication. This is used to recover from dropped EAP-Success messages.  */
end_comment

begin_function
name|void
name|eap_notify_lower_layer_success
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|)
block|{
if|if
condition|(
name|sm
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|eapol_get_bool
argument_list|(
name|sm
argument_list|,
name|EAPOL_eapSuccess
argument_list|)
operator|||
name|sm
operator|->
name|decision
operator|==
name|DECISION_FAIL
operator|||
operator|(
name|sm
operator|->
name|methodState
operator|!=
name|METHOD_MAY_CONT
operator|&&
name|sm
operator|->
name|methodState
operator|!=
name|METHOD_DONE
operator|)
condition|)
return|return;
if|if
condition|(
name|sm
operator|->
name|eapKeyData
operator|!=
name|NULL
condition|)
name|sm
operator|->
name|eapKeyAvailable
operator|=
name|TRUE
expr_stmt|;
name|eapol_set_bool
argument_list|(
name|sm
argument_list|,
name|EAPOL_eapSuccess
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|wpa_msg
argument_list|(
name|sm
operator|->
name|msg_ctx
argument_list|,
name|MSG_INFO
argument_list|,
name|WPA_EVENT_EAP_SUCCESS
literal|"EAP authentication completed successfully (based on lower "
literal|"layer success)"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * eap_get_eapSessionId - Get Session-Id from EAP state machine  * @sm: Pointer to EAP state machine allocated with eap_peer_sm_init()  * @len: Pointer to variable that will be set to number of bytes in the session  * Returns: Pointer to the EAP Session-Id or %NULL on failure  *  * Fetch EAP Session-Id from the EAP state machine. The Session-Id is available  * only after a successful authentication. EAP state machine continues to manage  * the Session-Id and the caller must not change or free the returned data.  */
end_comment

begin_function
specifier|const
name|u8
modifier|*
name|eap_get_eapSessionId
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|size_t
modifier|*
name|len
parameter_list|)
block|{
if|if
condition|(
name|sm
operator|==
name|NULL
operator|||
name|sm
operator|->
name|eapSessionId
operator|==
name|NULL
condition|)
block|{
operator|*
name|len
operator|=
literal|0
expr_stmt|;
return|return
name|NULL
return|;
block|}
operator|*
name|len
operator|=
name|sm
operator|->
name|eapSessionIdLen
expr_stmt|;
return|return
name|sm
operator|->
name|eapSessionId
return|;
block|}
end_function

begin_comment
comment|/**  * eap_get_eapKeyData - Get master session key (MSK) from EAP state machine  * @sm: Pointer to EAP state machine allocated with eap_peer_sm_init()  * @len: Pointer to variable that will be set to number of bytes in the key  * Returns: Pointer to the EAP keying data or %NULL on failure  *  * Fetch EAP keying material (MSK, eapKeyData) from the EAP state machine. The  * key is available only after a successful authentication. EAP state machine  * continues to manage the key data and the caller must not change or free the  * returned data.  */
end_comment

begin_function
specifier|const
name|u8
modifier|*
name|eap_get_eapKeyData
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|size_t
modifier|*
name|len
parameter_list|)
block|{
if|if
condition|(
name|sm
operator|==
name|NULL
operator|||
name|sm
operator|->
name|eapKeyData
operator|==
name|NULL
condition|)
block|{
operator|*
name|len
operator|=
literal|0
expr_stmt|;
return|return
name|NULL
return|;
block|}
operator|*
name|len
operator|=
name|sm
operator|->
name|eapKeyDataLen
expr_stmt|;
return|return
name|sm
operator|->
name|eapKeyData
return|;
block|}
end_function

begin_comment
comment|/**  * eap_get_eapKeyData - Get EAP response data  * @sm: Pointer to EAP state machine allocated with eap_peer_sm_init()  * Returns: Pointer to the EAP response (eapRespData) or %NULL on failure  *  * Fetch EAP response (eapRespData) from the EAP state machine. This data is  * available when EAP state machine has processed an incoming EAP request. The  * EAP state machine does not maintain a reference to the response after this  * function is called and the caller is responsible for freeing the data.  */
end_comment

begin_function
name|struct
name|wpabuf
modifier|*
name|eap_get_eapRespData
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|)
block|{
name|struct
name|wpabuf
modifier|*
name|resp
decl_stmt|;
if|if
condition|(
name|sm
operator|==
name|NULL
operator|||
name|sm
operator|->
name|eapRespData
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|resp
operator|=
name|sm
operator|->
name|eapRespData
expr_stmt|;
name|sm
operator|->
name|eapRespData
operator|=
name|NULL
expr_stmt|;
return|return
name|resp
return|;
block|}
end_function

begin_comment
comment|/**  * eap_sm_register_scard_ctx - Notification of smart card context  * @sm: Pointer to EAP state machine allocated with eap_peer_sm_init()  * @ctx: Context data for smart card operations  *  * Notify EAP state machines of context data for smart card operations. This  * context data will be used as a parameter for scard_*() functions.  */
end_comment

begin_function
name|void
name|eap_register_scard_ctx
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|void
modifier|*
name|ctx
parameter_list|)
block|{
if|if
condition|(
name|sm
condition|)
name|sm
operator|->
name|scard_ctx
operator|=
name|ctx
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * eap_set_config_blob - Set or add a named configuration blob  * @sm: Pointer to EAP state machine allocated with eap_peer_sm_init()  * @blob: New value for the blob  *  * Adds a new configuration blob or replaces the current value of an existing  * blob.  */
end_comment

begin_function
name|void
name|eap_set_config_blob
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|struct
name|wpa_config_blob
modifier|*
name|blob
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|CONFIG_NO_CONFIG_BLOBS
name|sm
operator|->
name|eapol_cb
operator|->
name|set_config_blob
argument_list|(
name|sm
operator|->
name|eapol_ctx
argument_list|,
name|blob
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* CONFIG_NO_CONFIG_BLOBS */
block|}
end_function

begin_comment
comment|/**  * eap_get_config_blob - Get a named configuration blob  * @sm: Pointer to EAP state machine allocated with eap_peer_sm_init()  * @name: Name of the blob  * Returns: Pointer to blob data or %NULL if not found  */
end_comment

begin_function
specifier|const
name|struct
name|wpa_config_blob
modifier|*
name|eap_get_config_blob
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|CONFIG_NO_CONFIG_BLOBS
return|return
name|sm
operator|->
name|eapol_cb
operator|->
name|get_config_blob
argument_list|(
name|sm
operator|->
name|eapol_ctx
argument_list|,
name|name
argument_list|)
return|;
else|#
directive|else
comment|/* CONFIG_NO_CONFIG_BLOBS */
return|return
name|NULL
return|;
endif|#
directive|endif
comment|/* CONFIG_NO_CONFIG_BLOBS */
block|}
end_function

begin_comment
comment|/**  * eap_set_force_disabled - Set force_disabled flag  * @sm: Pointer to EAP state machine allocated with eap_peer_sm_init()  * @disabled: 1 = EAP disabled, 0 = EAP enabled  *  * This function is used to force EAP state machine to be disabled when it is  * not in use (e.g., with WPA-PSK or plaintext connections).  */
end_comment

begin_function
name|void
name|eap_set_force_disabled
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|int
name|disabled
parameter_list|)
block|{
name|sm
operator|->
name|force_disabled
operator|=
name|disabled
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * eap_set_external_sim - Set external_sim flag  * @sm: Pointer to EAP state machine allocated with eap_peer_sm_init()  * @external_sim: Whether external SIM/USIM processing is used  */
end_comment

begin_function
name|void
name|eap_set_external_sim
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|int
name|external_sim
parameter_list|)
block|{
name|sm
operator|->
name|external_sim
operator|=
name|external_sim
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * eap_notify_pending - Notify that EAP method is ready to re-process a request  * @sm: Pointer to EAP state machine allocated with eap_peer_sm_init()  *  * An EAP method can perform a pending operation (e.g., to get a response from  * an external process). Once the response is available, this function can be  * used to request EAPOL state machine to retry delivering the previously  * received (and still unanswered) EAP request to EAP state machine.  */
end_comment

begin_function
name|void
name|eap_notify_pending
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|)
block|{
name|sm
operator|->
name|eapol_cb
operator|->
name|notify_pending
argument_list|(
name|sm
operator|->
name|eapol_ctx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * eap_invalidate_cached_session - Mark cached session data invalid  * @sm: Pointer to EAP state machine allocated with eap_peer_sm_init()  */
end_comment

begin_function
name|void
name|eap_invalidate_cached_session
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|)
block|{
if|if
condition|(
name|sm
condition|)
name|eap_deinit_prev_method
argument_list|(
name|sm
argument_list|,
literal|"invalidate"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|eap_is_wps_pbc_enrollee
parameter_list|(
name|struct
name|eap_peer_config
modifier|*
name|conf
parameter_list|)
block|{
if|if
condition|(
name|conf
operator|->
name|identity_len
operator|!=
name|WSC_ID_ENROLLEE_LEN
operator|||
name|os_memcmp
argument_list|(
name|conf
operator|->
name|identity
argument_list|,
name|WSC_ID_ENROLLEE
argument_list|,
name|WSC_ID_ENROLLEE_LEN
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Not a WPS Enrollee */
if|if
condition|(
name|conf
operator|->
name|phase1
operator|==
name|NULL
operator|||
name|os_strstr
argument_list|(
name|conf
operator|->
name|phase1
argument_list|,
literal|"pbc=1"
argument_list|)
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
comment|/* Not using PBC */
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|eap_is_wps_pin_enrollee
parameter_list|(
name|struct
name|eap_peer_config
modifier|*
name|conf
parameter_list|)
block|{
if|if
condition|(
name|conf
operator|->
name|identity_len
operator|!=
name|WSC_ID_ENROLLEE_LEN
operator|||
name|os_memcmp
argument_list|(
name|conf
operator|->
name|identity
argument_list|,
name|WSC_ID_ENROLLEE
argument_list|,
name|WSC_ID_ENROLLEE_LEN
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Not a WPS Enrollee */
if|if
condition|(
name|conf
operator|->
name|phase1
operator|==
name|NULL
operator|||
name|os_strstr
argument_list|(
name|conf
operator|->
name|phase1
argument_list|,
literal|"pin="
argument_list|)
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
comment|/* Not using PIN */
return|return
literal|1
return|;
block|}
end_function

begin_function
name|void
name|eap_sm_set_ext_pw_ctx
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|struct
name|ext_password_data
modifier|*
name|ext
parameter_list|)
block|{
name|ext_password_free
argument_list|(
name|sm
operator|->
name|ext_pw_buf
argument_list|)
expr_stmt|;
name|sm
operator|->
name|ext_pw_buf
operator|=
name|NULL
expr_stmt|;
name|sm
operator|->
name|ext_pw
operator|=
name|ext
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * eap_set_anon_id - Set or add anonymous identity  * @sm: Pointer to EAP state machine allocated with eap_peer_sm_init()  * @id: Anonymous identity (e.g., EAP-SIM pseudonym) or %NULL to clear  * @len: Length of anonymous identity in octets  */
end_comment

begin_function
name|void
name|eap_set_anon_id
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
specifier|const
name|u8
modifier|*
name|id
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
if|if
condition|(
name|sm
operator|->
name|eapol_cb
operator|->
name|set_anon_id
condition|)
name|sm
operator|->
name|eapol_cb
operator|->
name|set_anon_id
argument_list|(
name|sm
operator|->
name|eapol_ctx
argument_list|,
name|id
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|eap_peer_was_failure_expected
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|)
block|{
return|return
name|sm
operator|->
name|expected_failure
return|;
block|}
end_function

end_unit

