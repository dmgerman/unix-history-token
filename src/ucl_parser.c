begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (c) 2013, Vsevolod Stakhov  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are met:  *       * Redistributions of source code must retain the above copyright  *         notice, this list of conditions and the following disclaimer.  *       * Redistributions in binary form must reproduce the above copyright  *         notice, this list of conditions and the following disclaimer in the  *         documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED ''AS IS'' AND ANY  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED. IN NO EVENT SHALL AUTHOR BE LIABLE FOR ANY  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|"ucl.h"
end_include

begin_include
include|#
directive|include
file|"ucl_internal.h"
end_include

begin_include
include|#
directive|include
file|"ucl_chartable.h"
end_include

begin_comment
comment|/**  * @file rcl_parser.c  * The implementation of rcl parser  */
end_comment

begin_struct
struct|struct
name|ucl_parser_saved_state
block|{
name|unsigned
name|int
name|line
decl_stmt|;
name|unsigned
name|int
name|column
decl_stmt|;
name|size_t
name|remain
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|pos
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/**  * Move up to len characters  * @param parser  * @param begin  * @param len  * @return new position in chunk  */
end_comment

begin_define
define|#
directive|define
name|ucl_chunk_skipc
parameter_list|(
name|chunk
parameter_list|,
name|p
parameter_list|)
value|do{					\     if (*(p) == '\n') {										\         (chunk)->line ++;									\         (chunk)->column = 0;								\     }														\     else (chunk)->column ++;								\     (p++);													\     (chunk)->pos ++;										\     (chunk)->remain --;										\     } while (0)
end_define

begin_function
specifier|static
specifier|inline
name|void
name|ucl_set_err
parameter_list|(
name|struct
name|ucl_chunk
modifier|*
name|chunk
parameter_list|,
name|int
name|code
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|UT_string
modifier|*
modifier|*
name|err
parameter_list|)
block|{
if|if
condition|(
name|chunk
operator|->
name|pos
operator|<
name|chunk
operator|->
name|end
condition|)
block|{
if|if
condition|(
name|isgraph
argument_list|(
operator|*
name|chunk
operator|->
name|pos
argument_list|)
condition|)
block|{
name|ucl_create_err
argument_list|(
name|err
argument_list|,
literal|"error on line %d at column %d: '%s', character: '%c'"
argument_list|,
name|chunk
operator|->
name|line
argument_list|,
name|chunk
operator|->
name|column
argument_list|,
name|str
argument_list|,
operator|*
name|chunk
operator|->
name|pos
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ucl_create_err
argument_list|(
name|err
argument_list|,
literal|"error on line %d at column %d: '%s', character: '0x%02x'"
argument_list|,
name|chunk
operator|->
name|line
argument_list|,
name|chunk
operator|->
name|column
argument_list|,
name|str
argument_list|,
operator|(
name|int
operator|)
operator|*
name|chunk
operator|->
name|pos
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|ucl_create_err
argument_list|(
name|err
argument_list|,
literal|"error at the end of chunk: %s"
argument_list|,
name|str
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * Skip all comments from the current pos resolving nested and multiline comments  * @param parser  * @return  */
end_comment

begin_function
specifier|static
name|bool
name|ucl_skip_comments
parameter_list|(
name|struct
name|ucl_parser
modifier|*
name|parser
parameter_list|)
block|{
name|struct
name|ucl_chunk
modifier|*
name|chunk
init|=
name|parser
operator|->
name|chunks
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|comments_nested
init|=
literal|0
decl_stmt|;
name|p
operator|=
name|chunk
operator|->
name|pos
expr_stmt|;
name|start
label|:
if|if
condition|(
operator|*
name|p
operator|==
literal|'#'
condition|)
block|{
if|if
condition|(
name|parser
operator|->
name|state
operator|!=
name|UCL_STATE_SCOMMENT
operator|&&
name|parser
operator|->
name|state
operator|!=
name|UCL_STATE_MCOMMENT
condition|)
block|{
while|while
condition|(
name|p
operator|<
name|chunk
operator|->
name|end
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'\n'
condition|)
block|{
name|ucl_chunk_skipc
argument_list|(
name|chunk
argument_list|,
name|p
argument_list|)
expr_stmt|;
goto|goto
name|start
goto|;
block|}
name|ucl_chunk_skipc
argument_list|(
name|chunk
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'/'
operator|&&
name|chunk
operator|->
name|remain
operator|>=
literal|2
condition|)
block|{
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|'*'
condition|)
block|{
name|ucl_chunk_skipc
argument_list|(
name|chunk
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|comments_nested
operator|++
expr_stmt|;
name|ucl_chunk_skipc
argument_list|(
name|chunk
argument_list|,
name|p
argument_list|)
expr_stmt|;
while|while
condition|(
name|p
operator|<
name|chunk
operator|->
name|end
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'*'
condition|)
block|{
name|ucl_chunk_skipc
argument_list|(
name|chunk
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'/'
condition|)
block|{
name|comments_nested
operator|--
expr_stmt|;
if|if
condition|(
name|comments_nested
operator|==
literal|0
condition|)
block|{
name|ucl_chunk_skipc
argument_list|(
name|chunk
argument_list|,
name|p
argument_list|)
expr_stmt|;
goto|goto
name|start
goto|;
block|}
block|}
name|ucl_chunk_skipc
argument_list|(
name|chunk
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'/'
operator|&&
name|chunk
operator|->
name|remain
operator|>=
literal|2
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'*'
condition|)
block|{
name|comments_nested
operator|++
expr_stmt|;
name|ucl_chunk_skipc
argument_list|(
name|chunk
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|ucl_chunk_skipc
argument_list|(
name|chunk
argument_list|,
name|p
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|ucl_chunk_skipc
argument_list|(
name|chunk
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|comments_nested
operator|!=
literal|0
condition|)
block|{
name|ucl_set_err
argument_list|(
name|chunk
argument_list|,
name|UCL_ENESTED
argument_list|,
literal|"unfinished multiline comment"
argument_list|,
operator|&
name|parser
operator|->
name|err
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/**  * Return multiplier for a character  * @param c multiplier character  * @param is_bytes if true use 1024 multiplier  * @return multiplier  */
end_comment

begin_function
specifier|static
specifier|inline
name|unsigned
name|long
name|ucl_lex_num_multiplier
parameter_list|(
specifier|const
name|unsigned
name|char
name|c
parameter_list|,
name|bool
name|is_bytes
parameter_list|)
block|{
specifier|const
struct|struct
block|{
name|char
name|c
decl_stmt|;
name|long
name|mult_normal
decl_stmt|;
name|long
name|mult_bytes
decl_stmt|;
block|}
name|multipliers
index|[]
init|=
block|{
block|{
literal|'m'
block|,
literal|1000
operator|*
literal|1000
block|,
literal|1024
operator|*
literal|1024
block|}
block|,
block|{
literal|'k'
block|,
literal|1000
block|,
literal|1024
block|}
block|,
block|{
literal|'g'
block|,
literal|1000
operator|*
literal|1000
operator|*
literal|1000
block|,
literal|1024
operator|*
literal|1024
operator|*
literal|1024
block|}
block|}
struct|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|tolower
argument_list|(
name|c
argument_list|)
operator|==
name|multipliers
index|[
name|i
index|]
operator|.
name|c
condition|)
block|{
if|if
condition|(
name|is_bytes
condition|)
block|{
return|return
name|multipliers
index|[
name|i
index|]
operator|.
name|mult_bytes
return|;
block|}
return|return
name|multipliers
index|[
name|i
index|]
operator|.
name|mult_normal
return|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/**  * Return multiplier for time scaling  * @param c  * @return  */
end_comment

begin_function
specifier|static
specifier|inline
name|double
name|ucl_lex_time_multiplier
parameter_list|(
specifier|const
name|unsigned
name|char
name|c
parameter_list|)
block|{
specifier|const
struct|struct
block|{
name|char
name|c
decl_stmt|;
name|double
name|mult
decl_stmt|;
block|}
name|multipliers
index|[]
init|=
block|{
block|{
literal|'m'
block|,
literal|60
block|}
block|,
block|{
literal|'h'
block|,
literal|60
operator|*
literal|60
block|}
block|,
block|{
literal|'d'
block|,
literal|60
operator|*
literal|60
operator|*
literal|24
block|}
block|,
block|{
literal|'w'
block|,
literal|60
operator|*
literal|60
operator|*
literal|24
operator|*
literal|7
block|}
block|,
block|{
literal|'y'
block|,
literal|60
operator|*
literal|60
operator|*
literal|24
operator|*
literal|7
operator|*
literal|365
block|}
block|}
struct|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|5
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|tolower
argument_list|(
name|c
argument_list|)
operator|==
name|multipliers
index|[
name|i
index|]
operator|.
name|c
condition|)
block|{
return|return
name|multipliers
index|[
name|i
index|]
operator|.
name|mult
return|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/**  * Return true if a character is a end of an atom  * @param c  * @return  */
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|ucl_lex_is_atom_end
parameter_list|(
specifier|const
name|unsigned
name|char
name|c
parameter_list|)
block|{
return|return
name|ucl_test_character
argument_list|(
name|c
argument_list|,
name|UCL_CHARACTER_VALUE_END
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|bool
name|ucl_lex_is_comment
parameter_list|(
specifier|const
name|unsigned
name|char
name|c1
parameter_list|,
specifier|const
name|unsigned
name|char
name|c2
parameter_list|)
block|{
if|if
condition|(
name|c1
operator|==
literal|'/'
condition|)
block|{
if|if
condition|(
name|c2
operator|==
literal|'*'
condition|)
block|{
return|return
name|true
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|c1
operator|==
literal|'#'
condition|)
block|{
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/**  * Check variable found  * @param parser  * @param ptr  * @param remain  * @param out_len  * @param strict  * @param found  * @return  */
end_comment

begin_function
specifier|static
specifier|inline
specifier|const
name|char
modifier|*
name|ucl_check_variable_safe
parameter_list|(
name|struct
name|ucl_parser
modifier|*
name|parser
parameter_list|,
specifier|const
name|char
modifier|*
name|ptr
parameter_list|,
name|size_t
name|remain
parameter_list|,
name|size_t
modifier|*
name|out_len
parameter_list|,
name|bool
name|strict
parameter_list|,
name|bool
modifier|*
name|found
parameter_list|)
block|{
name|struct
name|ucl_variable
modifier|*
name|var
decl_stmt|;
name|unsigned
name|char
modifier|*
name|dst
decl_stmt|;
name|size_t
name|dstlen
decl_stmt|;
name|bool
name|need_free
init|=
name|false
decl_stmt|;
name|LL_FOREACH
argument_list|(
argument|parser->variables
argument_list|,
argument|var
argument_list|)
block|{
if|if
condition|(
name|strict
condition|)
block|{
if|if
condition|(
name|remain
operator|==
name|var
operator|->
name|var_len
condition|)
block|{
if|if
condition|(
name|memcmp
argument_list|(
name|ptr
argument_list|,
name|var
operator|->
name|var
argument_list|,
name|var
operator|->
name|var_len
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|out_len
operator|+=
name|var
operator|->
name|value_len
expr_stmt|;
operator|*
name|found
operator|=
name|true
expr_stmt|;
return|return
operator|(
name|ptr
operator|+
name|var
operator|->
name|var_len
operator|)
return|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|remain
operator|>=
name|var
operator|->
name|var_len
condition|)
block|{
if|if
condition|(
name|memcmp
argument_list|(
name|ptr
argument_list|,
name|var
operator|->
name|var
argument_list|,
name|var
operator|->
name|var_len
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|out_len
operator|+=
name|var
operator|->
name|value_len
expr_stmt|;
operator|*
name|found
operator|=
name|true
expr_stmt|;
return|return
operator|(
name|ptr
operator|+
name|var
operator|->
name|var_len
operator|)
return|;
block|}
block|}
block|}
block|}
comment|/* XXX: can only handle ${VAR} */
if|if
condition|(
operator|!
operator|(
operator|*
name|found
operator|)
operator|&&
name|parser
operator|->
name|var_handler
operator|!=
name|NULL
operator|&&
name|strict
condition|)
block|{
comment|/* Call generic handler */
if|if
condition|(
name|parser
operator|->
name|var_handler
argument_list|(
name|ptr
argument_list|,
name|remain
argument_list|,
operator|&
name|dst
argument_list|,
operator|&
name|dstlen
argument_list|,
operator|&
name|need_free
argument_list|,
name|parser
operator|->
name|var_data
argument_list|)
condition|)
block|{
operator|*
name|found
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|need_free
condition|)
block|{
name|free
argument_list|(
name|dst
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ptr
operator|+
name|remain
operator|)
return|;
block|}
block|}
return|return
name|ptr
return|;
block|}
end_function

begin_comment
comment|/**  * Check for a variable in a given string  * @param parser  * @param ptr  * @param remain  * @param out_len  * @param vars_found  * @return  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|ucl_check_variable
parameter_list|(
name|struct
name|ucl_parser
modifier|*
name|parser
parameter_list|,
specifier|const
name|char
modifier|*
name|ptr
parameter_list|,
name|size_t
name|remain
parameter_list|,
name|size_t
modifier|*
name|out_len
parameter_list|,
name|bool
modifier|*
name|vars_found
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|end
decl_stmt|,
modifier|*
name|ret
init|=
name|ptr
decl_stmt|;
name|bool
name|found
init|=
name|false
decl_stmt|;
if|if
condition|(
operator|*
name|ptr
operator|==
literal|'{'
condition|)
block|{
comment|/* We need to match the variable enclosed in braces */
name|p
operator|=
name|ptr
operator|+
literal|1
expr_stmt|;
name|end
operator|=
name|ptr
operator|+
name|remain
expr_stmt|;
while|while
condition|(
name|p
operator|<
name|end
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'}'
condition|)
block|{
name|ret
operator|=
name|ucl_check_variable_safe
argument_list|(
name|parser
argument_list|,
name|ptr
operator|+
literal|1
argument_list|,
name|p
operator|-
name|ptr
operator|-
literal|1
argument_list|,
name|out_len
argument_list|,
name|true
argument_list|,
operator|&
name|found
argument_list|)
expr_stmt|;
if|if
condition|(
name|found
condition|)
block|{
comment|/* {} must be excluded actually */
name|ret
operator|++
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|vars_found
condition|)
block|{
operator|*
name|vars_found
operator|=
name|true
expr_stmt|;
block|}
block|}
else|else
block|{
operator|*
name|out_len
operator|+=
literal|2
expr_stmt|;
block|}
break|break;
block|}
name|p
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|*
name|ptr
operator|!=
literal|'$'
condition|)
block|{
comment|/* Not count escaped dollar sign */
name|ret
operator|=
name|ucl_check_variable_safe
argument_list|(
name|parser
argument_list|,
name|ptr
argument_list|,
name|remain
argument_list|,
name|out_len
argument_list|,
name|false
argument_list|,
operator|&
name|found
argument_list|)
expr_stmt|;
if|if
condition|(
name|found
operator|&&
operator|!
operator|*
name|vars_found
condition|)
block|{
operator|*
name|vars_found
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|found
condition|)
block|{
operator|(
operator|*
name|out_len
operator|)
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
name|ret
operator|++
expr_stmt|;
operator|(
operator|*
name|out_len
operator|)
operator|++
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/**  * Expand a single variable  * @param parser  * @param ptr  * @param remain  * @param dest  * @return  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|ucl_expand_single_variable
parameter_list|(
name|struct
name|ucl_parser
modifier|*
name|parser
parameter_list|,
specifier|const
name|char
modifier|*
name|ptr
parameter_list|,
name|size_t
name|remain
parameter_list|,
name|unsigned
name|char
modifier|*
modifier|*
name|dest
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|d
init|=
operator|*
name|dest
decl_stmt|,
modifier|*
name|dst
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
init|=
name|ptr
operator|+
literal|1
decl_stmt|,
modifier|*
name|ret
decl_stmt|;
name|struct
name|ucl_variable
modifier|*
name|var
decl_stmt|;
name|size_t
name|dstlen
decl_stmt|;
name|bool
name|need_free
init|=
name|false
decl_stmt|;
name|bool
name|found
init|=
name|false
decl_stmt|;
name|bool
name|strict
init|=
name|false
decl_stmt|;
name|ret
operator|=
name|ptr
operator|+
literal|1
expr_stmt|;
name|remain
operator|--
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'$'
condition|)
block|{
operator|*
name|d
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
operator|*
name|dest
operator|=
name|d
expr_stmt|;
return|return
name|p
return|;
block|}
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'{'
condition|)
block|{
name|p
operator|++
expr_stmt|;
name|strict
operator|=
name|true
expr_stmt|;
name|ret
operator|+=
literal|2
expr_stmt|;
name|remain
operator|-=
literal|2
expr_stmt|;
block|}
name|LL_FOREACH
argument_list|(
argument|parser->variables
argument_list|,
argument|var
argument_list|)
block|{
if|if
condition|(
name|remain
operator|>=
name|var
operator|->
name|var_len
condition|)
block|{
if|if
condition|(
name|memcmp
argument_list|(
name|p
argument_list|,
name|var
operator|->
name|var
argument_list|,
name|var
operator|->
name|var_len
argument_list|)
operator|==
literal|0
condition|)
block|{
name|memcpy
argument_list|(
name|d
argument_list|,
name|var
operator|->
name|value
argument_list|,
name|var
operator|->
name|value_len
argument_list|)
expr_stmt|;
name|ret
operator|+=
name|var
operator|->
name|var_len
expr_stmt|;
name|d
operator|+=
name|var
operator|->
name|value_len
expr_stmt|;
name|found
operator|=
name|true
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|found
condition|)
block|{
if|if
condition|(
name|strict
operator|&&
name|parser
operator|->
name|var_handler
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|parser
operator|->
name|var_handler
argument_list|(
name|ptr
argument_list|,
name|remain
argument_list|,
operator|&
name|dst
argument_list|,
operator|&
name|dstlen
argument_list|,
operator|&
name|need_free
argument_list|,
name|parser
operator|->
name|var_data
argument_list|)
condition|)
block|{
name|memcpy
argument_list|(
name|d
argument_list|,
name|dst
argument_list|,
name|dstlen
argument_list|)
expr_stmt|;
name|ret
operator|+=
name|dstlen
expr_stmt|;
name|d
operator|+=
name|remain
expr_stmt|;
name|found
operator|=
name|true
expr_stmt|;
block|}
block|}
comment|/* Leave variable as is */
if|if
condition|(
operator|!
name|found
condition|)
block|{
if|if
condition|(
name|strict
condition|)
block|{
comment|/* Copy '${' */
name|memcpy
argument_list|(
name|d
argument_list|,
name|ptr
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|d
operator|+=
literal|2
expr_stmt|;
name|ret
operator|--
expr_stmt|;
block|}
else|else
block|{
name|memcpy
argument_list|(
name|d
argument_list|,
name|ptr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
block|}
block|}
operator|*
name|dest
operator|=
name|d
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/**  * Expand variables in string  * @param parser  * @param dst  * @param src  * @param in_len  * @return  */
end_comment

begin_function
specifier|static
name|ssize_t
name|ucl_expand_variable
parameter_list|(
name|struct
name|ucl_parser
modifier|*
name|parser
parameter_list|,
name|unsigned
name|char
modifier|*
modifier|*
name|dst
parameter_list|,
specifier|const
name|char
modifier|*
name|src
parameter_list|,
name|size_t
name|in_len
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|end
init|=
name|src
operator|+
name|in_len
decl_stmt|;
name|unsigned
name|char
modifier|*
name|d
decl_stmt|;
name|size_t
name|out_len
init|=
literal|0
decl_stmt|;
name|bool
name|vars_found
init|=
name|false
decl_stmt|;
name|p
operator|=
name|src
expr_stmt|;
while|while
condition|(
name|p
operator|!=
name|end
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'$'
condition|)
block|{
name|p
operator|=
name|ucl_check_variable
argument_list|(
name|parser
argument_list|,
name|p
operator|+
literal|1
argument_list|,
name|end
operator|-
name|p
operator|-
literal|1
argument_list|,
operator|&
name|out_len
argument_list|,
operator|&
name|vars_found
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|p
operator|++
expr_stmt|;
name|out_len
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|vars_found
condition|)
block|{
comment|/* Trivial case */
operator|*
name|dst
operator|=
name|NULL
expr_stmt|;
return|return
name|in_len
return|;
block|}
operator|*
name|dst
operator|=
name|UCL_ALLOC
argument_list|(
name|out_len
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|dst
operator|==
name|NULL
condition|)
block|{
return|return
name|in_len
return|;
block|}
name|d
operator|=
operator|*
name|dst
expr_stmt|;
name|p
operator|=
name|src
expr_stmt|;
while|while
condition|(
name|p
operator|!=
name|end
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'$'
condition|)
block|{
name|p
operator|=
name|ucl_expand_single_variable
argument_list|(
name|parser
argument_list|,
name|p
argument_list|,
name|end
operator|-
name|p
argument_list|,
operator|&
name|d
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|d
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
block|}
block|}
operator|*
name|d
operator|=
literal|'\0'
expr_stmt|;
return|return
name|out_len
return|;
block|}
end_function

begin_comment
comment|/**  * Store or copy pointer to the trash stack  * @param parser parser object  * @param src src string  * @param dst destination buffer (trash stack pointer)  * @param dst_const const destination pointer (e.g. value of object)  * @param in_len input length  * @param need_unescape need to unescape source (and copy it)  * @param need_lowercase need to lowercase value (and copy)  * @param need_expand need to expand variables (and copy as well)  * @return output length (excluding \0 symbol)  */
end_comment

begin_function
specifier|static
specifier|inline
name|ssize_t
name|ucl_copy_or_store_ptr
parameter_list|(
name|struct
name|ucl_parser
modifier|*
name|parser
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|src
parameter_list|,
name|unsigned
name|char
modifier|*
modifier|*
name|dst
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|dst_const
parameter_list|,
name|size_t
name|in_len
parameter_list|,
name|bool
name|need_unescape
parameter_list|,
name|bool
name|need_lowercase
parameter_list|,
name|bool
name|need_expand
parameter_list|)
block|{
name|ssize_t
name|ret
init|=
operator|-
literal|1
decl_stmt|,
name|tret
decl_stmt|;
name|unsigned
name|char
modifier|*
name|tmp
decl_stmt|;
if|if
condition|(
name|need_unescape
operator|||
name|need_lowercase
operator|||
operator|(
name|need_expand
operator|&&
name|parser
operator|->
name|variables
operator|!=
name|NULL
operator|)
operator|||
operator|!
operator|(
name|parser
operator|->
name|flags
operator|&
name|UCL_PARSER_ZEROCOPY
operator|)
condition|)
block|{
comment|/* Copy string */
operator|*
name|dst
operator|=
name|UCL_ALLOC
argument_list|(
name|in_len
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|dst
operator|==
name|NULL
condition|)
block|{
name|ucl_set_err
argument_list|(
name|parser
operator|->
name|chunks
argument_list|,
literal|0
argument_list|,
literal|"cannot allocate memory for a string"
argument_list|,
operator|&
name|parser
operator|->
name|err
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|need_lowercase
condition|)
block|{
name|ret
operator|=
name|ucl_strlcpy_tolower
argument_list|(
operator|*
name|dst
argument_list|,
name|src
argument_list|,
name|in_len
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
name|ucl_strlcpy_unsafe
argument_list|(
operator|*
name|dst
argument_list|,
name|src
argument_list|,
name|in_len
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|need_unescape
condition|)
block|{
name|ret
operator|=
name|ucl_unescape_json_string
argument_list|(
operator|*
name|dst
argument_list|,
name|ret
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|need_expand
condition|)
block|{
name|tmp
operator|=
operator|*
name|dst
expr_stmt|;
name|tret
operator|=
name|ret
expr_stmt|;
name|ret
operator|=
name|ucl_expand_variable
argument_list|(
name|parser
argument_list|,
name|dst
argument_list|,
name|tmp
argument_list|,
name|ret
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|dst
operator|==
name|NULL
condition|)
block|{
comment|/* Nothing to expand */
operator|*
name|dst
operator|=
name|tmp
expr_stmt|;
name|ret
operator|=
name|tret
expr_stmt|;
block|}
block|}
operator|*
name|dst_const
operator|=
operator|*
name|dst
expr_stmt|;
block|}
else|else
block|{
operator|*
name|dst_const
operator|=
name|src
expr_stmt|;
name|ret
operator|=
name|in_len
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/**  * Create and append an object at the specified level  * @param parser  * @param is_array  * @param level  * @return  */
end_comment

begin_function
specifier|static
specifier|inline
name|ucl_object_t
modifier|*
name|ucl_add_parser_stack
parameter_list|(
name|ucl_object_t
modifier|*
name|obj
parameter_list|,
name|struct
name|ucl_parser
modifier|*
name|parser
parameter_list|,
name|bool
name|is_array
parameter_list|,
name|int
name|level
parameter_list|)
block|{
name|struct
name|ucl_stack
modifier|*
name|st
decl_stmt|;
if|if
condition|(
operator|!
name|is_array
condition|)
block|{
if|if
condition|(
name|obj
operator|==
name|NULL
condition|)
block|{
name|obj
operator|=
name|ucl_object_typed_new
argument_list|(
name|UCL_OBJECT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|obj
operator|->
name|type
operator|=
name|UCL_OBJECT
expr_stmt|;
block|}
name|obj
operator|->
name|value
operator|.
name|ov
operator|=
name|ucl_hash_create
argument_list|()
expr_stmt|;
name|parser
operator|->
name|state
operator|=
name|UCL_STATE_KEY
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|obj
operator|==
name|NULL
condition|)
block|{
name|obj
operator|=
name|ucl_object_typed_new
argument_list|(
name|UCL_ARRAY
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|obj
operator|->
name|type
operator|=
name|UCL_ARRAY
expr_stmt|;
block|}
name|parser
operator|->
name|state
operator|=
name|UCL_STATE_VALUE
expr_stmt|;
block|}
name|st
operator|=
name|UCL_ALLOC
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ucl_stack
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|st
operator|==
name|NULL
condition|)
block|{
name|ucl_set_err
argument_list|(
name|parser
operator|->
name|chunks
argument_list|,
literal|0
argument_list|,
literal|"cannot allocate memory for an object"
argument_list|,
operator|&
name|parser
operator|->
name|err
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|st
operator|->
name|obj
operator|=
name|obj
expr_stmt|;
name|st
operator|->
name|level
operator|=
name|level
expr_stmt|;
name|LL_PREPEND
argument_list|(
name|parser
operator|->
name|stack
argument_list|,
name|st
argument_list|)
expr_stmt|;
name|parser
operator|->
name|cur_obj
operator|=
name|obj
expr_stmt|;
return|return
name|obj
return|;
block|}
end_function

begin_function
name|int
name|ucl_maybe_parse_number
parameter_list|(
name|ucl_object_t
modifier|*
name|obj
parameter_list|,
specifier|const
name|char
modifier|*
name|start
parameter_list|,
specifier|const
name|char
modifier|*
name|end
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|pos
parameter_list|,
name|bool
name|allow_double
parameter_list|,
name|bool
name|number_bytes
parameter_list|,
name|bool
name|allow_time
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|p
init|=
name|start
decl_stmt|,
modifier|*
name|c
init|=
name|start
decl_stmt|;
name|char
modifier|*
name|endptr
decl_stmt|;
name|bool
name|got_dot
init|=
name|false
decl_stmt|,
name|got_exp
init|=
name|false
decl_stmt|,
name|need_double
init|=
name|false
decl_stmt|,
name|is_time
init|=
name|false
decl_stmt|,
name|valid_start
init|=
name|false
decl_stmt|,
name|is_hex
init|=
name|false
decl_stmt|,
name|is_neg
init|=
name|false
decl_stmt|;
name|double
name|dv
init|=
literal|0
decl_stmt|;
name|int64_t
name|lv
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'-'
condition|)
block|{
name|is_neg
operator|=
name|true
expr_stmt|;
name|c
operator|++
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
while|while
condition|(
name|p
operator|<
name|end
condition|)
block|{
if|if
condition|(
name|is_hex
operator|&&
name|isxdigit
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
name|p
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
name|valid_start
operator|=
name|true
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|is_hex
operator|&&
operator|(
operator|*
name|p
operator|==
literal|'x'
operator|||
operator|*
name|p
operator|==
literal|'X'
operator|)
condition|)
block|{
name|is_hex
operator|=
name|true
expr_stmt|;
name|allow_double
operator|=
name|false
expr_stmt|;
name|c
operator|=
name|p
operator|+
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|allow_double
condition|)
block|{
if|if
condition|(
name|p
operator|==
name|c
condition|)
block|{
comment|/* Empty digits sequence, not a number */
operator|*
name|pos
operator|=
name|start
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'.'
condition|)
block|{
if|if
condition|(
name|got_dot
condition|)
block|{
comment|/* Double dots, not a number */
operator|*
name|pos
operator|=
name|start
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
else|else
block|{
name|got_dot
operator|=
name|true
expr_stmt|;
name|need_double
operator|=
name|true
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'e'
operator|||
operator|*
name|p
operator|==
literal|'E'
condition|)
block|{
if|if
condition|(
name|got_exp
condition|)
block|{
comment|/* Double exp, not a number */
operator|*
name|pos
operator|=
name|start
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
else|else
block|{
name|got_exp
operator|=
name|true
expr_stmt|;
name|need_double
operator|=
name|true
expr_stmt|;
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|p
operator|>=
name|end
condition|)
block|{
operator|*
name|pos
operator|=
name|start
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
operator|*
name|p
operator|!=
literal|'+'
operator|&&
operator|*
name|p
operator|!=
literal|'-'
condition|)
block|{
comment|/* Wrong exponent sign */
operator|*
name|pos
operator|=
name|start
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
else|else
block|{
name|p
operator|++
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* Got the end of the number, need to check */
break|break;
block|}
block|}
else|else
block|{
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|valid_start
condition|)
block|{
operator|*
name|pos
operator|=
name|start
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|need_double
condition|)
block|{
name|dv
operator|=
name|strtod
argument_list|(
name|c
argument_list|,
operator|&
name|endptr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|is_hex
condition|)
block|{
name|lv
operator|=
name|strtoimax
argument_list|(
name|c
argument_list|,
operator|&
name|endptr
argument_list|,
literal|16
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|lv
operator|=
name|strtoimax
argument_list|(
name|c
argument_list|,
operator|&
name|endptr
argument_list|,
literal|10
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|errno
operator|==
name|ERANGE
condition|)
block|{
operator|*
name|pos
operator|=
name|start
expr_stmt|;
return|return
name|ERANGE
return|;
block|}
comment|/* Now check endptr */
if|if
condition|(
name|endptr
operator|==
name|NULL
operator|||
name|ucl_lex_is_atom_end
argument_list|(
operator|*
name|endptr
argument_list|)
operator|||
operator|*
name|endptr
operator|==
literal|'\0'
operator|||
name|ucl_test_character
argument_list|(
operator|*
name|endptr
argument_list|,
name|UCL_CHARACTER_WHITESPACE_UNSAFE
argument_list|)
condition|)
block|{
name|p
operator|=
name|endptr
expr_stmt|;
goto|goto
name|set_obj
goto|;
block|}
if|if
condition|(
name|endptr
operator|<
name|end
operator|&&
name|endptr
operator|!=
name|start
condition|)
block|{
name|p
operator|=
name|endptr
expr_stmt|;
switch|switch
condition|(
operator|*
name|p
condition|)
block|{
case|case
literal|'m'
case|:
case|case
literal|'M'
case|:
case|case
literal|'g'
case|:
case|case
literal|'G'
case|:
case|case
literal|'k'
case|:
case|case
literal|'K'
case|:
if|if
condition|(
name|end
operator|-
name|p
operator|>=
literal|2
condition|)
block|{
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|'s'
operator|||
name|p
index|[
literal|1
index|]
operator|==
literal|'S'
condition|)
block|{
comment|/* Milliseconds */
if|if
condition|(
operator|!
name|need_double
condition|)
block|{
name|need_double
operator|=
name|true
expr_stmt|;
name|dv
operator|=
name|lv
expr_stmt|;
block|}
name|is_time
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'m'
operator|||
name|p
index|[
literal|0
index|]
operator|==
literal|'M'
condition|)
block|{
name|dv
operator|/=
literal|1000.
expr_stmt|;
block|}
else|else
block|{
name|dv
operator|*=
name|ucl_lex_num_multiplier
argument_list|(
operator|*
name|p
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
name|p
operator|+=
literal|2
expr_stmt|;
goto|goto
name|set_obj
goto|;
block|}
elseif|else
if|if
condition|(
name|number_bytes
operator|||
operator|(
name|p
index|[
literal|1
index|]
operator|==
literal|'b'
operator|||
name|p
index|[
literal|1
index|]
operator|==
literal|'B'
operator|)
condition|)
block|{
comment|/* Bytes */
if|if
condition|(
name|need_double
condition|)
block|{
name|need_double
operator|=
name|false
expr_stmt|;
name|lv
operator|=
name|dv
expr_stmt|;
block|}
name|lv
operator|*=
name|ucl_lex_num_multiplier
argument_list|(
operator|*
name|p
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|2
expr_stmt|;
goto|goto
name|set_obj
goto|;
block|}
elseif|else
if|if
condition|(
name|ucl_lex_is_atom_end
argument_list|(
name|p
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|need_double
condition|)
block|{
name|dv
operator|*=
name|ucl_lex_num_multiplier
argument_list|(
operator|*
name|p
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|lv
operator|*=
name|ucl_lex_num_multiplier
argument_list|(
operator|*
name|p
argument_list|,
name|number_bytes
argument_list|)
expr_stmt|;
block|}
name|p
operator|++
expr_stmt|;
goto|goto
name|set_obj
goto|;
block|}
elseif|else
if|if
condition|(
name|allow_time
operator|&&
name|end
operator|-
name|p
operator|>=
literal|3
condition|)
block|{
if|if
condition|(
name|tolower
argument_list|(
name|p
index|[
literal|0
index|]
argument_list|)
operator|==
literal|'m'
operator|&&
name|tolower
argument_list|(
name|p
index|[
literal|1
index|]
argument_list|)
operator|==
literal|'i'
operator|&&
name|tolower
argument_list|(
name|p
index|[
literal|2
index|]
argument_list|)
operator|==
literal|'n'
condition|)
block|{
comment|/* Minutes */
if|if
condition|(
operator|!
name|need_double
condition|)
block|{
name|need_double
operator|=
name|true
expr_stmt|;
name|dv
operator|=
name|lv
expr_stmt|;
block|}
name|is_time
operator|=
name|true
expr_stmt|;
name|dv
operator|*=
literal|60.
expr_stmt|;
name|p
operator|+=
literal|3
expr_stmt|;
goto|goto
name|set_obj
goto|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|need_double
condition|)
block|{
name|dv
operator|*=
name|ucl_lex_num_multiplier
argument_list|(
operator|*
name|p
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|lv
operator|*=
name|ucl_lex_num_multiplier
argument_list|(
operator|*
name|p
argument_list|,
name|number_bytes
argument_list|)
expr_stmt|;
block|}
name|p
operator|++
expr_stmt|;
goto|goto
name|set_obj
goto|;
block|}
break|break;
case|case
literal|'S'
case|:
case|case
literal|'s'
case|:
if|if
condition|(
name|allow_time
operator|&&
operator|(
name|p
operator|==
name|end
operator|-
literal|1
operator|||
name|ucl_lex_is_atom_end
argument_list|(
name|p
index|[
literal|1
index|]
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|need_double
condition|)
block|{
name|need_double
operator|=
name|true
expr_stmt|;
name|dv
operator|=
name|lv
expr_stmt|;
block|}
name|p
operator|++
expr_stmt|;
name|is_time
operator|=
name|true
expr_stmt|;
goto|goto
name|set_obj
goto|;
block|}
break|break;
case|case
literal|'h'
case|:
case|case
literal|'H'
case|:
case|case
literal|'d'
case|:
case|case
literal|'D'
case|:
case|case
literal|'w'
case|:
case|case
literal|'W'
case|:
case|case
literal|'Y'
case|:
case|case
literal|'y'
case|:
if|if
condition|(
name|allow_time
operator|&&
operator|(
name|p
operator|==
name|end
operator|-
literal|1
operator|||
name|ucl_lex_is_atom_end
argument_list|(
name|p
index|[
literal|1
index|]
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|need_double
condition|)
block|{
name|need_double
operator|=
name|true
expr_stmt|;
name|dv
operator|=
name|lv
expr_stmt|;
block|}
name|is_time
operator|=
name|true
expr_stmt|;
name|dv
operator|*=
name|ucl_lex_time_multiplier
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
name|p
operator|++
expr_stmt|;
goto|goto
name|set_obj
goto|;
block|}
break|break;
block|}
block|}
operator|*
name|pos
operator|=
name|c
expr_stmt|;
return|return
name|EINVAL
return|;
name|set_obj
label|:
if|if
condition|(
name|allow_double
operator|&&
operator|(
name|need_double
operator|||
name|is_time
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|is_time
condition|)
block|{
name|obj
operator|->
name|type
operator|=
name|UCL_FLOAT
expr_stmt|;
block|}
else|else
block|{
name|obj
operator|->
name|type
operator|=
name|UCL_TIME
expr_stmt|;
block|}
name|obj
operator|->
name|value
operator|.
name|dv
operator|=
name|is_neg
condition|?
operator|(
operator|-
name|dv
operator|)
else|:
name|dv
expr_stmt|;
block|}
else|else
block|{
name|obj
operator|->
name|type
operator|=
name|UCL_INT
expr_stmt|;
name|obj
operator|->
name|value
operator|.
name|iv
operator|=
name|is_neg
condition|?
operator|(
operator|-
name|lv
operator|)
else|:
name|lv
expr_stmt|;
block|}
operator|*
name|pos
operator|=
name|p
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * Parse possible number  * @param parser  * @param chunk  * @return true if a number has been parsed  */
end_comment

begin_function
specifier|static
name|bool
name|ucl_lex_number
parameter_list|(
name|struct
name|ucl_parser
modifier|*
name|parser
parameter_list|,
name|struct
name|ucl_chunk
modifier|*
name|chunk
parameter_list|,
name|ucl_object_t
modifier|*
name|obj
parameter_list|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|pos
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|ret
operator|=
name|ucl_maybe_parse_number
argument_list|(
name|obj
argument_list|,
name|chunk
operator|->
name|pos
argument_list|,
name|chunk
operator|->
name|end
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
operator|&
name|pos
argument_list|,
name|true
argument_list|,
name|false
argument_list|,
operator|(
operator|(
name|parser
operator|->
name|flags
operator|&
name|UCL_PARSER_NO_TIME
operator|)
operator|==
literal|0
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
block|{
name|chunk
operator|->
name|remain
operator|-=
name|pos
operator|-
name|chunk
operator|->
name|pos
expr_stmt|;
name|chunk
operator|->
name|column
operator|+=
name|pos
operator|-
name|chunk
operator|->
name|pos
expr_stmt|;
name|chunk
operator|->
name|pos
operator|=
name|pos
expr_stmt|;
return|return
name|true
return|;
block|}
elseif|else
if|if
condition|(
name|ret
operator|==
name|ERANGE
condition|)
block|{
name|ucl_set_err
argument_list|(
name|chunk
argument_list|,
name|ERANGE
argument_list|,
literal|"numeric value out of range"
argument_list|,
operator|&
name|parser
operator|->
name|err
argument_list|)
expr_stmt|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/**  * Parse quoted string with possible escapes  * @param parser  * @param chunk  * @return true if a string has been parsed  */
end_comment

begin_function
specifier|static
name|bool
name|ucl_lex_json_string
parameter_list|(
name|struct
name|ucl_parser
modifier|*
name|parser
parameter_list|,
name|struct
name|ucl_chunk
modifier|*
name|chunk
parameter_list|,
name|bool
modifier|*
name|need_unescape
parameter_list|,
name|bool
modifier|*
name|ucl_escape
parameter_list|,
name|bool
modifier|*
name|var_expand
parameter_list|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|p
init|=
name|chunk
operator|->
name|pos
decl_stmt|;
name|unsigned
name|char
name|c
decl_stmt|;
name|int
name|i
decl_stmt|;
while|while
condition|(
name|p
operator|<
name|chunk
operator|->
name|end
condition|)
block|{
name|c
operator|=
operator|*
name|p
expr_stmt|;
if|if
condition|(
name|c
operator|<
literal|0x1F
condition|)
block|{
comment|/* Unmasked control character */
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
name|ucl_set_err
argument_list|(
name|chunk
argument_list|,
name|UCL_ESYNTAX
argument_list|,
literal|"unexpected newline"
argument_list|,
operator|&
name|parser
operator|->
name|err
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ucl_set_err
argument_list|(
name|chunk
argument_list|,
name|UCL_ESYNTAX
argument_list|,
literal|"unexpected control character"
argument_list|,
operator|&
name|parser
operator|->
name|err
argument_list|)
expr_stmt|;
block|}
return|return
name|false
return|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
name|ucl_chunk_skipc
argument_list|(
name|chunk
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|c
operator|=
operator|*
name|p
expr_stmt|;
if|if
condition|(
name|p
operator|>=
name|chunk
operator|->
name|end
condition|)
block|{
name|ucl_set_err
argument_list|(
name|chunk
argument_list|,
name|UCL_ESYNTAX
argument_list|,
literal|"unfinished escape character"
argument_list|,
operator|&
name|parser
operator|->
name|err
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
elseif|else
if|if
condition|(
name|ucl_test_character
argument_list|(
name|c
argument_list|,
name|UCL_CHARACTER_ESCAPE
argument_list|)
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'u'
condition|)
block|{
name|ucl_chunk_skipc
argument_list|(
name|chunk
argument_list|,
name|p
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
operator|&&
name|p
operator|<
name|chunk
operator|->
name|end
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|isxdigit
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
name|ucl_set_err
argument_list|(
name|chunk
argument_list|,
name|UCL_ESYNTAX
argument_list|,
literal|"invalid utf escape"
argument_list|,
operator|&
name|parser
operator|->
name|err
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|ucl_chunk_skipc
argument_list|(
name|chunk
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|>=
name|chunk
operator|->
name|end
condition|)
block|{
name|ucl_set_err
argument_list|(
name|chunk
argument_list|,
name|UCL_ESYNTAX
argument_list|,
literal|"unfinished escape character"
argument_list|,
operator|&
name|parser
operator|->
name|err
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
else|else
block|{
name|ucl_chunk_skipc
argument_list|(
name|chunk
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
block|}
operator|*
name|need_unescape
operator|=
name|true
expr_stmt|;
operator|*
name|ucl_escape
operator|=
name|true
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'"'
condition|)
block|{
name|ucl_chunk_skipc
argument_list|(
name|chunk
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
elseif|else
if|if
condition|(
name|ucl_test_character
argument_list|(
name|c
argument_list|,
name|UCL_CHARACTER_UCL_UNSAFE
argument_list|)
condition|)
block|{
operator|*
name|ucl_escape
operator|=
name|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'$'
condition|)
block|{
operator|*
name|var_expand
operator|=
name|true
expr_stmt|;
block|}
name|ucl_chunk_skipc
argument_list|(
name|chunk
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
name|ucl_set_err
argument_list|(
name|chunk
argument_list|,
name|UCL_ESYNTAX
argument_list|,
literal|"no quote at the end of json string"
argument_list|,
operator|&
name|parser
operator|->
name|err
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/**  * Parse a key in an object  * @param parser  * @param chunk  * @return true if a key has been parsed  */
end_comment

begin_function
specifier|static
name|bool
name|ucl_parse_key
parameter_list|(
name|struct
name|ucl_parser
modifier|*
name|parser
parameter_list|,
name|struct
name|ucl_chunk
modifier|*
name|chunk
parameter_list|,
name|bool
modifier|*
name|next_key
parameter_list|,
name|bool
modifier|*
name|end_of_object
parameter_list|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|c
init|=
name|NULL
decl_stmt|,
modifier|*
name|end
decl_stmt|,
modifier|*
name|t
decl_stmt|;
specifier|const
name|char
modifier|*
name|key
init|=
name|NULL
decl_stmt|;
name|bool
name|got_quote
init|=
name|false
decl_stmt|,
name|got_eq
init|=
name|false
decl_stmt|,
name|got_semicolon
init|=
name|false
decl_stmt|,
name|need_unescape
init|=
name|false
decl_stmt|,
name|ucl_escape
init|=
name|false
decl_stmt|,
name|var_expand
init|=
name|false
decl_stmt|,
name|got_content
init|=
name|false
decl_stmt|,
name|got_sep
init|=
name|false
decl_stmt|;
name|ucl_object_t
modifier|*
name|nobj
decl_stmt|,
modifier|*
name|tobj
decl_stmt|;
name|ucl_hash_t
modifier|*
name|container
decl_stmt|;
name|ssize_t
name|keylen
decl_stmt|;
name|p
operator|=
name|chunk
operator|->
name|pos
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'.'
condition|)
block|{
comment|/* It is macro actually */
name|ucl_chunk_skipc
argument_list|(
name|chunk
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|parser
operator|->
name|prev_state
operator|=
name|parser
operator|->
name|state
expr_stmt|;
name|parser
operator|->
name|state
operator|=
name|UCL_STATE_MACRO_NAME
expr_stmt|;
return|return
name|true
return|;
block|}
while|while
condition|(
name|p
operator|<
name|chunk
operator|->
name|end
condition|)
block|{
comment|/* 		 * A key must start with alpha, number, '/' or '_' and end with space character 		 */
if|if
condition|(
name|c
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|chunk
operator|->
name|remain
operator|>=
literal|2
operator|&&
name|ucl_lex_is_comment
argument_list|(
name|p
index|[
literal|0
index|]
argument_list|,
name|p
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|ucl_skip_comments
argument_list|(
name|parser
argument_list|)
condition|)
block|{
return|return
name|false
return|;
block|}
name|p
operator|=
name|chunk
operator|->
name|pos
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ucl_test_character
argument_list|(
operator|*
name|p
argument_list|,
name|UCL_CHARACTER_WHITESPACE_UNSAFE
argument_list|)
condition|)
block|{
name|ucl_chunk_skipc
argument_list|(
name|chunk
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ucl_test_character
argument_list|(
operator|*
name|p
argument_list|,
name|UCL_CHARACTER_KEY_START
argument_list|)
condition|)
block|{
comment|/* The first symbol */
name|c
operator|=
name|p
expr_stmt|;
name|ucl_chunk_skipc
argument_list|(
name|chunk
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|got_content
operator|=
name|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'"'
condition|)
block|{
comment|/* JSON style key */
name|c
operator|=
name|p
operator|+
literal|1
expr_stmt|;
name|got_quote
operator|=
name|true
expr_stmt|;
name|got_content
operator|=
name|true
expr_stmt|;
name|ucl_chunk_skipc
argument_list|(
name|chunk
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'}'
condition|)
block|{
comment|/* We have actually end of an object */
operator|*
name|end_of_object
operator|=
name|true
expr_stmt|;
return|return
name|true
return|;
block|}
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'.'
condition|)
block|{
name|ucl_chunk_skipc
argument_list|(
name|chunk
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|parser
operator|->
name|prev_state
operator|=
name|parser
operator|->
name|state
expr_stmt|;
name|parser
operator|->
name|state
operator|=
name|UCL_STATE_MACRO_NAME
expr_stmt|;
return|return
name|true
return|;
block|}
else|else
block|{
comment|/* Invalid identifier */
name|ucl_set_err
argument_list|(
name|chunk
argument_list|,
name|UCL_ESYNTAX
argument_list|,
literal|"key must begin with a letter"
argument_list|,
operator|&
name|parser
operator|->
name|err
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
else|else
block|{
comment|/* Parse the body of a key */
if|if
condition|(
operator|!
name|got_quote
condition|)
block|{
if|if
condition|(
name|ucl_test_character
argument_list|(
operator|*
name|p
argument_list|,
name|UCL_CHARACTER_KEY
argument_list|)
condition|)
block|{
name|got_content
operator|=
name|true
expr_stmt|;
name|ucl_chunk_skipc
argument_list|(
name|chunk
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ucl_test_character
argument_list|(
operator|*
name|p
argument_list|,
name|UCL_CHARACTER_KEY_SEP
argument_list|)
condition|)
block|{
name|end
operator|=
name|p
expr_stmt|;
break|break;
block|}
else|else
block|{
name|ucl_set_err
argument_list|(
name|chunk
argument_list|,
name|UCL_ESYNTAX
argument_list|,
literal|"invalid character in a key"
argument_list|,
operator|&
name|parser
operator|->
name|err
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
else|else
block|{
comment|/* We need to parse json like quoted string */
if|if
condition|(
operator|!
name|ucl_lex_json_string
argument_list|(
name|parser
argument_list|,
name|chunk
argument_list|,
operator|&
name|need_unescape
argument_list|,
operator|&
name|ucl_escape
argument_list|,
operator|&
name|var_expand
argument_list|)
condition|)
block|{
return|return
name|false
return|;
block|}
comment|/* Always escape keys obtained via json */
name|end
operator|=
name|chunk
operator|->
name|pos
operator|-
literal|1
expr_stmt|;
name|p
operator|=
name|chunk
operator|->
name|pos
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|p
operator|>=
name|chunk
operator|->
name|end
operator|&&
name|got_content
condition|)
block|{
name|ucl_set_err
argument_list|(
name|chunk
argument_list|,
name|UCL_ESYNTAX
argument_list|,
literal|"unfinished key"
argument_list|,
operator|&
name|parser
operator|->
name|err
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|got_content
condition|)
block|{
return|return
name|true
return|;
block|}
operator|*
name|end_of_object
operator|=
name|false
expr_stmt|;
comment|/* We are now at the end of the key, need to parse the rest */
while|while
condition|(
name|p
operator|<
name|chunk
operator|->
name|end
condition|)
block|{
if|if
condition|(
name|ucl_test_character
argument_list|(
operator|*
name|p
argument_list|,
name|UCL_CHARACTER_WHITESPACE
argument_list|)
condition|)
block|{
name|ucl_chunk_skipc
argument_list|(
name|chunk
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'='
condition|)
block|{
if|if
condition|(
operator|!
name|got_eq
operator|&&
operator|!
name|got_semicolon
condition|)
block|{
name|ucl_chunk_skipc
argument_list|(
name|chunk
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|got_eq
operator|=
name|true
expr_stmt|;
block|}
else|else
block|{
name|ucl_set_err
argument_list|(
name|chunk
argument_list|,
name|UCL_ESYNTAX
argument_list|,
literal|"unexpected '=' character"
argument_list|,
operator|&
name|parser
operator|->
name|err
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|':'
condition|)
block|{
if|if
condition|(
operator|!
name|got_eq
operator|&&
operator|!
name|got_semicolon
condition|)
block|{
name|ucl_chunk_skipc
argument_list|(
name|chunk
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|got_semicolon
operator|=
name|true
expr_stmt|;
block|}
else|else
block|{
name|ucl_set_err
argument_list|(
name|chunk
argument_list|,
name|UCL_ESYNTAX
argument_list|,
literal|"unexpected ':' character"
argument_list|,
operator|&
name|parser
operator|->
name|err
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|chunk
operator|->
name|remain
operator|>=
literal|2
operator|&&
name|ucl_lex_is_comment
argument_list|(
name|p
index|[
literal|0
index|]
argument_list|,
name|p
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
comment|/* Check for comment */
if|if
condition|(
operator|!
name|ucl_skip_comments
argument_list|(
name|parser
argument_list|)
condition|)
block|{
return|return
name|false
return|;
block|}
name|p
operator|=
name|chunk
operator|->
name|pos
expr_stmt|;
block|}
else|else
block|{
comment|/* Start value */
break|break;
block|}
block|}
if|if
condition|(
name|p
operator|>=
name|chunk
operator|->
name|end
operator|&&
name|got_content
condition|)
block|{
name|ucl_set_err
argument_list|(
name|chunk
argument_list|,
name|UCL_ESYNTAX
argument_list|,
literal|"unfinished key"
argument_list|,
operator|&
name|parser
operator|->
name|err
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|got_sep
operator|=
name|got_semicolon
operator|||
name|got_eq
expr_stmt|;
if|if
condition|(
operator|!
name|got_sep
condition|)
block|{
comment|/* 		 * Maybe we have more keys nested, so search for termination character. 		 * Possible choices: 		 * 1) key1 key2 ... keyN [:=] value<- we treat that as error 		 * 2) key1 ... keyN {} or []<- we treat that as nested objects 		 * 3) key1 value[;,\n]<- we treat that as linear object 		 */
name|t
operator|=
name|p
expr_stmt|;
operator|*
name|next_key
operator|=
name|false
expr_stmt|;
while|while
condition|(
name|ucl_test_character
argument_list|(
operator|*
name|t
argument_list|,
name|UCL_CHARACTER_WHITESPACE
argument_list|)
condition|)
block|{
name|t
operator|++
expr_stmt|;
block|}
comment|/* Check first non-space character after a key */
if|if
condition|(
operator|*
name|t
operator|!=
literal|'{'
operator|&&
operator|*
name|t
operator|!=
literal|'['
condition|)
block|{
while|while
condition|(
name|t
operator|<
name|chunk
operator|->
name|end
condition|)
block|{
if|if
condition|(
operator|*
name|t
operator|==
literal|','
operator|||
operator|*
name|t
operator|==
literal|';'
operator|||
operator|*
name|t
operator|==
literal|'\n'
operator|||
operator|*
name|t
operator|==
literal|'\r'
condition|)
block|{
break|break;
block|}
elseif|else
if|if
condition|(
operator|*
name|t
operator|==
literal|'{'
operator|||
operator|*
name|t
operator|==
literal|'['
condition|)
block|{
operator|*
name|next_key
operator|=
name|true
expr_stmt|;
break|break;
block|}
name|t
operator|++
expr_stmt|;
block|}
block|}
block|}
comment|/* Create a new object */
name|nobj
operator|=
name|ucl_object_new
argument_list|()
expr_stmt|;
name|keylen
operator|=
name|ucl_copy_or_store_ptr
argument_list|(
name|parser
argument_list|,
name|c
argument_list|,
operator|&
name|nobj
operator|->
name|trash_stack
index|[
name|UCL_TRASH_KEY
index|]
argument_list|,
operator|&
name|key
argument_list|,
name|end
operator|-
name|c
argument_list|,
name|need_unescape
argument_list|,
name|parser
operator|->
name|flags
operator|&
name|UCL_PARSER_KEY_LOWERCASE
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|keylen
operator|==
operator|-
literal|1
condition|)
block|{
name|ucl_object_unref
argument_list|(
name|nobj
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
elseif|else
if|if
condition|(
name|keylen
operator|==
literal|0
condition|)
block|{
name|ucl_set_err
argument_list|(
name|chunk
argument_list|,
name|UCL_ESYNTAX
argument_list|,
literal|"empty keys are not allowed"
argument_list|,
operator|&
name|parser
operator|->
name|err
argument_list|)
expr_stmt|;
name|ucl_object_unref
argument_list|(
name|nobj
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|container
operator|=
name|parser
operator|->
name|stack
operator|->
name|obj
operator|->
name|value
operator|.
name|ov
expr_stmt|;
name|nobj
operator|->
name|key
operator|=
name|key
expr_stmt|;
name|nobj
operator|->
name|keylen
operator|=
name|keylen
expr_stmt|;
name|tobj
operator|=
name|__DECONST
argument_list|(
name|ucl_object_t
operator|*
argument_list|,
name|ucl_hash_search_obj
argument_list|(
name|container
argument_list|,
name|nobj
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tobj
operator|==
name|NULL
condition|)
block|{
name|container
operator|=
name|ucl_hash_insert_object
argument_list|(
name|container
argument_list|,
name|nobj
argument_list|)
expr_stmt|;
name|nobj
operator|->
name|prev
operator|=
name|nobj
expr_stmt|;
name|nobj
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|parser
operator|->
name|stack
operator|->
name|obj
operator|->
name|len
operator|++
expr_stmt|;
block|}
else|else
block|{
name|DL_APPEND
argument_list|(
name|tobj
argument_list|,
name|nobj
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ucl_escape
condition|)
block|{
name|nobj
operator|->
name|flags
operator||=
name|UCL_OBJECT_NEED_KEY_ESCAPE
expr_stmt|;
block|}
name|parser
operator|->
name|stack
operator|->
name|obj
operator|->
name|value
operator|.
name|ov
operator|=
name|container
expr_stmt|;
name|parser
operator|->
name|cur_obj
operator|=
name|nobj
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/**  * Parse a cl string  * @param parser  * @param chunk  * @return true if a key has been parsed  */
end_comment

begin_function
specifier|static
name|bool
name|ucl_parse_string_value
parameter_list|(
name|struct
name|ucl_parser
modifier|*
name|parser
parameter_list|,
name|struct
name|ucl_chunk
modifier|*
name|chunk
parameter_list|,
name|bool
modifier|*
name|var_expand
parameter_list|,
name|bool
modifier|*
name|need_unescape
parameter_list|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
enum|enum
block|{
name|UCL_BRACE_ROUND
init|=
literal|0
block|,
name|UCL_BRACE_SQUARE
block|,
name|UCL_BRACE_FIGURE
block|}
enum|;
name|int
name|braces
index|[
literal|3
index|]
index|[
literal|2
index|]
init|=
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
name|p
operator|=
name|chunk
operator|->
name|pos
expr_stmt|;
while|while
condition|(
name|p
operator|<
name|chunk
operator|->
name|end
condition|)
block|{
comment|/* Skip pairs of figure braces */
if|if
condition|(
operator|*
name|p
operator|==
literal|'{'
condition|)
block|{
name|braces
index|[
name|UCL_BRACE_FIGURE
index|]
index|[
literal|0
index|]
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'}'
condition|)
block|{
name|braces
index|[
name|UCL_BRACE_FIGURE
index|]
index|[
literal|1
index|]
operator|++
expr_stmt|;
if|if
condition|(
name|braces
index|[
name|UCL_BRACE_FIGURE
index|]
index|[
literal|1
index|]
operator|<=
name|braces
index|[
name|UCL_BRACE_FIGURE
index|]
index|[
literal|0
index|]
condition|)
block|{
comment|/* This is not a termination symbol, continue */
name|ucl_chunk_skipc
argument_list|(
name|chunk
argument_list|,
name|p
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
comment|/* Skip pairs of square braces */
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'['
condition|)
block|{
name|braces
index|[
name|UCL_BRACE_SQUARE
index|]
index|[
literal|0
index|]
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|']'
condition|)
block|{
name|braces
index|[
name|UCL_BRACE_SQUARE
index|]
index|[
literal|1
index|]
operator|++
expr_stmt|;
if|if
condition|(
name|braces
index|[
name|UCL_BRACE_SQUARE
index|]
index|[
literal|1
index|]
operator|<=
name|braces
index|[
name|UCL_BRACE_SQUARE
index|]
index|[
literal|0
index|]
condition|)
block|{
comment|/* This is not a termination symbol, continue */
name|ucl_chunk_skipc
argument_list|(
name|chunk
argument_list|,
name|p
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'$'
condition|)
block|{
operator|*
name|var_expand
operator|=
name|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'\\'
condition|)
block|{
operator|*
name|need_unescape
operator|=
name|true
expr_stmt|;
name|ucl_chunk_skipc
argument_list|(
name|chunk
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|<
name|chunk
operator|->
name|end
condition|)
block|{
name|ucl_chunk_skipc
argument_list|(
name|chunk
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
if|if
condition|(
name|ucl_lex_is_atom_end
argument_list|(
operator|*
name|p
argument_list|)
operator|||
operator|(
name|chunk
operator|->
name|remain
operator|>=
literal|2
operator|&&
name|ucl_lex_is_comment
argument_list|(
name|p
index|[
literal|0
index|]
argument_list|,
name|p
index|[
literal|1
index|]
argument_list|)
operator|)
condition|)
block|{
break|break;
block|}
name|ucl_chunk_skipc
argument_list|(
name|chunk
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|>=
name|chunk
operator|->
name|end
condition|)
block|{
name|ucl_set_err
argument_list|(
name|chunk
argument_list|,
name|UCL_ESYNTAX
argument_list|,
literal|"unfinished value"
argument_list|,
operator|&
name|parser
operator|->
name|err
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/**  * Parse multiline string ending with \n{term}\n  * @param parser  * @param chunk  * @param term  * @param term_len  * @return size of multiline string or 0 in case of error  */
end_comment

begin_function
specifier|static
name|int
name|ucl_parse_multiline_string
parameter_list|(
name|struct
name|ucl_parser
modifier|*
name|parser
parameter_list|,
name|struct
name|ucl_chunk
modifier|*
name|chunk
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|term
parameter_list|,
name|int
name|term_len
parameter_list|,
name|unsigned
name|char
specifier|const
modifier|*
modifier|*
name|beg
parameter_list|,
name|bool
modifier|*
name|var_expand
parameter_list|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|c
decl_stmt|;
name|bool
name|newline
init|=
name|false
decl_stmt|;
name|int
name|len
init|=
literal|0
decl_stmt|;
name|p
operator|=
name|chunk
operator|->
name|pos
expr_stmt|;
name|c
operator|=
name|p
expr_stmt|;
while|while
condition|(
name|p
operator|<
name|chunk
operator|->
name|end
condition|)
block|{
if|if
condition|(
name|newline
condition|)
block|{
if|if
condition|(
name|chunk
operator|->
name|end
operator|-
name|p
operator|<
name|term_len
condition|)
block|{
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|memcmp
argument_list|(
name|p
argument_list|,
name|term
argument_list|,
name|term_len
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|p
index|[
name|term_len
index|]
operator|==
literal|'\n'
operator|||
name|p
index|[
name|term_len
index|]
operator|==
literal|'\r'
operator|)
condition|)
block|{
name|len
operator|=
name|p
operator|-
name|c
expr_stmt|;
name|chunk
operator|->
name|remain
operator|-=
name|term_len
expr_stmt|;
name|chunk
operator|->
name|pos
operator|=
name|p
operator|+
name|term_len
expr_stmt|;
name|chunk
operator|->
name|column
operator|=
name|term_len
expr_stmt|;
operator|*
name|beg
operator|=
name|c
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|*
name|p
operator|==
literal|'\n'
condition|)
block|{
name|newline
operator|=
name|true
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'$'
condition|)
block|{
operator|*
name|var_expand
operator|=
name|true
expr_stmt|;
block|}
name|newline
operator|=
name|false
expr_stmt|;
block|}
name|ucl_chunk_skipc
argument_list|(
name|chunk
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
return|return
name|len
return|;
block|}
end_function

begin_function
specifier|static
name|ucl_object_t
modifier|*
name|ucl_get_value_object
parameter_list|(
name|struct
name|ucl_parser
modifier|*
name|parser
parameter_list|)
block|{
name|ucl_object_t
modifier|*
name|t
decl_stmt|,
modifier|*
name|obj
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|parser
operator|->
name|stack
operator|->
name|obj
operator|->
name|type
operator|==
name|UCL_ARRAY
condition|)
block|{
comment|/* Object must be allocated */
name|obj
operator|=
name|ucl_object_new
argument_list|()
expr_stmt|;
name|t
operator|=
name|parser
operator|->
name|stack
operator|->
name|obj
operator|->
name|value
operator|.
name|av
expr_stmt|;
name|DL_APPEND
argument_list|(
name|t
argument_list|,
name|obj
argument_list|)
expr_stmt|;
name|parser
operator|->
name|cur_obj
operator|=
name|obj
expr_stmt|;
name|parser
operator|->
name|stack
operator|->
name|obj
operator|->
name|value
operator|.
name|av
operator|=
name|t
expr_stmt|;
name|parser
operator|->
name|stack
operator|->
name|obj
operator|->
name|len
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* Object has been already allocated */
name|obj
operator|=
name|parser
operator|->
name|cur_obj
expr_stmt|;
block|}
return|return
name|obj
return|;
block|}
end_function

begin_comment
comment|/**  * Handle value data  * @param parser  * @param chunk  * @return  */
end_comment

begin_function
specifier|static
name|bool
name|ucl_parse_value
parameter_list|(
name|struct
name|ucl_parser
modifier|*
name|parser
parameter_list|,
name|struct
name|ucl_chunk
modifier|*
name|chunk
parameter_list|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|c
decl_stmt|;
name|ucl_object_t
modifier|*
name|obj
init|=
name|NULL
decl_stmt|;
name|unsigned
name|int
name|stripped_spaces
decl_stmt|;
name|int
name|str_len
decl_stmt|;
name|bool
name|need_unescape
init|=
name|false
decl_stmt|,
name|ucl_escape
init|=
name|false
decl_stmt|,
name|var_expand
init|=
name|false
decl_stmt|;
name|p
operator|=
name|chunk
operator|->
name|pos
expr_stmt|;
comment|/* Skip any spaces and comments */
if|if
condition|(
name|ucl_test_character
argument_list|(
operator|*
name|p
argument_list|,
name|UCL_CHARACTER_WHITESPACE_UNSAFE
argument_list|)
operator|||
operator|(
name|chunk
operator|->
name|remain
operator|>=
literal|2
operator|&&
name|ucl_lex_is_comment
argument_list|(
name|p
index|[
literal|0
index|]
argument_list|,
name|p
index|[
literal|1
index|]
argument_list|)
operator|)
condition|)
block|{
while|while
condition|(
name|p
operator|<
name|chunk
operator|->
name|end
operator|&&
name|ucl_test_character
argument_list|(
operator|*
name|p
argument_list|,
name|UCL_CHARACTER_WHITESPACE_UNSAFE
argument_list|)
condition|)
block|{
name|ucl_chunk_skipc
argument_list|(
name|chunk
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ucl_skip_comments
argument_list|(
name|parser
argument_list|)
condition|)
block|{
return|return
name|false
return|;
block|}
name|p
operator|=
name|chunk
operator|->
name|pos
expr_stmt|;
block|}
while|while
condition|(
name|p
operator|<
name|chunk
operator|->
name|end
condition|)
block|{
name|c
operator|=
name|p
expr_stmt|;
switch|switch
condition|(
operator|*
name|p
condition|)
block|{
case|case
literal|'"'
case|:
name|obj
operator|=
name|ucl_get_value_object
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|ucl_chunk_skipc
argument_list|(
name|chunk
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ucl_lex_json_string
argument_list|(
name|parser
argument_list|,
name|chunk
argument_list|,
operator|&
name|need_unescape
argument_list|,
operator|&
name|ucl_escape
argument_list|,
operator|&
name|var_expand
argument_list|)
condition|)
block|{
return|return
name|false
return|;
block|}
name|str_len
operator|=
name|chunk
operator|->
name|pos
operator|-
name|c
operator|-
literal|2
expr_stmt|;
name|obj
operator|->
name|type
operator|=
name|UCL_STRING
expr_stmt|;
if|if
condition|(
operator|(
name|str_len
operator|=
name|ucl_copy_or_store_ptr
argument_list|(
name|parser
argument_list|,
name|c
operator|+
literal|1
argument_list|,
operator|&
name|obj
operator|->
name|trash_stack
index|[
name|UCL_TRASH_VALUE
index|]
argument_list|,
operator|&
name|obj
operator|->
name|value
operator|.
name|sv
argument_list|,
name|str_len
argument_list|,
name|need_unescape
argument_list|,
name|false
argument_list|,
name|var_expand
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
return|return
name|false
return|;
block|}
name|obj
operator|->
name|len
operator|=
name|str_len
expr_stmt|;
name|parser
operator|->
name|state
operator|=
name|UCL_STATE_AFTER_VALUE
expr_stmt|;
name|p
operator|=
name|chunk
operator|->
name|pos
expr_stmt|;
return|return
name|true
return|;
break|break;
case|case
literal|'{'
case|:
name|obj
operator|=
name|ucl_get_value_object
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* We have a new object */
name|obj
operator|=
name|ucl_add_parser_stack
argument_list|(
name|obj
argument_list|,
name|parser
argument_list|,
name|false
argument_list|,
name|parser
operator|->
name|stack
operator|->
name|level
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj
operator|==
name|NULL
condition|)
block|{
return|return
name|false
return|;
block|}
name|ucl_chunk_skipc
argument_list|(
name|chunk
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
name|true
return|;
break|break;
case|case
literal|'['
case|:
name|obj
operator|=
name|ucl_get_value_object
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* We have a new array */
name|obj
operator|=
name|ucl_add_parser_stack
argument_list|(
name|obj
argument_list|,
name|parser
argument_list|,
name|true
argument_list|,
name|parser
operator|->
name|stack
operator|->
name|level
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj
operator|==
name|NULL
condition|)
block|{
return|return
name|false
return|;
block|}
name|ucl_chunk_skipc
argument_list|(
name|chunk
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
name|true
return|;
break|break;
case|case
literal|']'
case|:
comment|/* We have the array ending */
if|if
condition|(
name|parser
operator|->
name|stack
operator|&&
name|parser
operator|->
name|stack
operator|->
name|obj
operator|->
name|type
operator|==
name|UCL_ARRAY
condition|)
block|{
name|parser
operator|->
name|state
operator|=
name|UCL_STATE_AFTER_VALUE
expr_stmt|;
return|return
name|true
return|;
block|}
else|else
block|{
goto|goto
name|parse_string
goto|;
block|}
break|break;
case|case
literal|'<'
case|:
name|obj
operator|=
name|ucl_get_value_object
argument_list|(
name|parser
argument_list|)
expr_stmt|;
comment|/* We have something like multiline value, which must be<<[A-Z]+\n */
if|if
condition|(
name|chunk
operator|->
name|end
operator|-
name|p
operator|>
literal|3
condition|)
block|{
if|if
condition|(
name|memcmp
argument_list|(
name|p
argument_list|,
literal|"<<"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|p
operator|+=
literal|2
expr_stmt|;
comment|/* We allow only uppercase characters in multiline definitions */
while|while
condition|(
name|p
operator|<
name|chunk
operator|->
name|end
operator|&&
operator|*
name|p
operator|>=
literal|'A'
operator|&&
operator|*
name|p
operator|<=
literal|'Z'
condition|)
block|{
name|p
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|p
operator|==
literal|'\n'
condition|)
block|{
comment|/* Set chunk positions and start multiline parsing */
name|c
operator|+=
literal|2
expr_stmt|;
name|chunk
operator|->
name|remain
operator|-=
name|p
operator|-
name|c
expr_stmt|;
name|chunk
operator|->
name|pos
operator|=
name|p
operator|+
literal|1
expr_stmt|;
name|chunk
operator|->
name|column
operator|=
literal|0
expr_stmt|;
name|chunk
operator|->
name|line
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|str_len
operator|=
name|ucl_parse_multiline_string
argument_list|(
name|parser
argument_list|,
name|chunk
argument_list|,
name|c
argument_list|,
name|p
operator|-
name|c
argument_list|,
operator|&
name|c
argument_list|,
operator|&
name|var_expand
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|ucl_set_err
argument_list|(
name|chunk
argument_list|,
name|UCL_ESYNTAX
argument_list|,
literal|"unterminated multiline value"
argument_list|,
operator|&
name|parser
operator|->
name|err
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|obj
operator|->
name|type
operator|=
name|UCL_STRING
expr_stmt|;
if|if
condition|(
operator|(
name|str_len
operator|=
name|ucl_copy_or_store_ptr
argument_list|(
name|parser
argument_list|,
name|c
argument_list|,
operator|&
name|obj
operator|->
name|trash_stack
index|[
name|UCL_TRASH_VALUE
index|]
argument_list|,
operator|&
name|obj
operator|->
name|value
operator|.
name|sv
argument_list|,
name|str_len
operator|-
literal|1
argument_list|,
name|false
argument_list|,
name|false
argument_list|,
name|var_expand
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
return|return
name|false
return|;
block|}
name|obj
operator|->
name|len
operator|=
name|str_len
expr_stmt|;
name|parser
operator|->
name|state
operator|=
name|UCL_STATE_AFTER_VALUE
expr_stmt|;
return|return
name|true
return|;
block|}
block|}
block|}
comment|/* Fallback to ordinary strings */
default|default:
name|parse_string
label|:
if|if
condition|(
name|obj
operator|==
name|NULL
condition|)
block|{
name|obj
operator|=
name|ucl_get_value_object
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
comment|/* Parse atom */
if|if
condition|(
name|ucl_test_character
argument_list|(
operator|*
name|p
argument_list|,
name|UCL_CHARACTER_VALUE_DIGIT_START
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|ucl_lex_number
argument_list|(
name|parser
argument_list|,
name|chunk
argument_list|,
name|obj
argument_list|)
condition|)
block|{
if|if
condition|(
name|parser
operator|->
name|state
operator|==
name|UCL_STATE_ERROR
condition|)
block|{
return|return
name|false
return|;
block|}
block|}
else|else
block|{
name|parser
operator|->
name|state
operator|=
name|UCL_STATE_AFTER_VALUE
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/* Fallback to normal string */
block|}
if|if
condition|(
operator|!
name|ucl_parse_string_value
argument_list|(
name|parser
argument_list|,
name|chunk
argument_list|,
operator|&
name|var_expand
argument_list|,
operator|&
name|need_unescape
argument_list|)
condition|)
block|{
return|return
name|false
return|;
block|}
comment|/* Cut trailing spaces */
name|stripped_spaces
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|ucl_test_character
argument_list|(
operator|*
operator|(
name|chunk
operator|->
name|pos
operator|-
literal|1
operator|-
name|stripped_spaces
operator|)
argument_list|,
name|UCL_CHARACTER_WHITESPACE
argument_list|)
condition|)
block|{
name|stripped_spaces
operator|++
expr_stmt|;
block|}
name|str_len
operator|=
name|chunk
operator|->
name|pos
operator|-
name|c
operator|-
name|stripped_spaces
expr_stmt|;
if|if
condition|(
name|str_len
operator|<=
literal|0
condition|)
block|{
name|ucl_set_err
argument_list|(
name|chunk
argument_list|,
literal|0
argument_list|,
literal|"string value must not be empty"
argument_list|,
operator|&
name|parser
operator|->
name|err
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
elseif|else
if|if
condition|(
name|str_len
operator|==
literal|4
operator|&&
name|memcmp
argument_list|(
name|c
argument_list|,
literal|"null"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|obj
operator|->
name|len
operator|=
literal|0
expr_stmt|;
name|obj
operator|->
name|type
operator|=
name|UCL_NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|ucl_maybe_parse_boolean
argument_list|(
name|obj
argument_list|,
name|c
argument_list|,
name|str_len
argument_list|)
condition|)
block|{
name|obj
operator|->
name|type
operator|=
name|UCL_STRING
expr_stmt|;
if|if
condition|(
operator|(
name|str_len
operator|=
name|ucl_copy_or_store_ptr
argument_list|(
name|parser
argument_list|,
name|c
argument_list|,
operator|&
name|obj
operator|->
name|trash_stack
index|[
name|UCL_TRASH_VALUE
index|]
argument_list|,
operator|&
name|obj
operator|->
name|value
operator|.
name|sv
argument_list|,
name|str_len
argument_list|,
name|need_unescape
argument_list|,
name|false
argument_list|,
name|var_expand
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
return|return
name|false
return|;
block|}
name|obj
operator|->
name|len
operator|=
name|str_len
expr_stmt|;
block|}
name|parser
operator|->
name|state
operator|=
name|UCL_STATE_AFTER_VALUE
expr_stmt|;
name|p
operator|=
name|chunk
operator|->
name|pos
expr_stmt|;
return|return
name|true
return|;
break|break;
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/**  * Handle after value data  * @param parser  * @param chunk  * @return  */
end_comment

begin_function
specifier|static
name|bool
name|ucl_parse_after_value
parameter_list|(
name|struct
name|ucl_parser
modifier|*
name|parser
parameter_list|,
name|struct
name|ucl_chunk
modifier|*
name|chunk
parameter_list|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|bool
name|got_sep
init|=
name|false
decl_stmt|;
name|struct
name|ucl_stack
modifier|*
name|st
decl_stmt|;
name|p
operator|=
name|chunk
operator|->
name|pos
expr_stmt|;
while|while
condition|(
name|p
operator|<
name|chunk
operator|->
name|end
condition|)
block|{
if|if
condition|(
name|ucl_test_character
argument_list|(
operator|*
name|p
argument_list|,
name|UCL_CHARACTER_WHITESPACE
argument_list|)
condition|)
block|{
comment|/* Skip whitespaces */
name|ucl_chunk_skipc
argument_list|(
name|chunk
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|chunk
operator|->
name|remain
operator|>=
literal|2
operator|&&
name|ucl_lex_is_comment
argument_list|(
name|p
index|[
literal|0
index|]
argument_list|,
name|p
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
comment|/* Skip comment */
if|if
condition|(
operator|!
name|ucl_skip_comments
argument_list|(
name|parser
argument_list|)
condition|)
block|{
return|return
name|false
return|;
block|}
comment|/* Treat comment as a separator */
name|got_sep
operator|=
name|true
expr_stmt|;
name|p
operator|=
name|chunk
operator|->
name|pos
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ucl_test_character
argument_list|(
operator|*
name|p
argument_list|,
name|UCL_CHARACTER_VALUE_END
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'}'
operator|||
operator|*
name|p
operator|==
literal|']'
condition|)
block|{
if|if
condition|(
name|parser
operator|->
name|stack
operator|==
name|NULL
condition|)
block|{
name|ucl_set_err
argument_list|(
name|chunk
argument_list|,
name|UCL_ESYNTAX
argument_list|,
literal|"end of array or object detected without corresponding start"
argument_list|,
operator|&
name|parser
operator|->
name|err
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
operator|(
operator|*
name|p
operator|==
literal|'}'
operator|&&
name|parser
operator|->
name|stack
operator|->
name|obj
operator|->
name|type
operator|==
name|UCL_OBJECT
operator|)
operator|||
operator|(
operator|*
name|p
operator|==
literal|']'
operator|&&
name|parser
operator|->
name|stack
operator|->
name|obj
operator|->
name|type
operator|==
name|UCL_ARRAY
operator|)
condition|)
block|{
comment|/* Pop all nested objects from a stack */
name|st
operator|=
name|parser
operator|->
name|stack
expr_stmt|;
name|parser
operator|->
name|stack
operator|=
name|st
operator|->
name|next
expr_stmt|;
name|UCL_FREE
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ucl_stack
argument_list|)
argument_list|,
name|st
argument_list|)
expr_stmt|;
while|while
condition|(
name|parser
operator|->
name|stack
operator|!=
name|NULL
condition|)
block|{
name|st
operator|=
name|parser
operator|->
name|stack
expr_stmt|;
if|if
condition|(
name|st
operator|->
name|next
operator|==
name|NULL
operator|||
name|st
operator|->
name|next
operator|->
name|level
operator|==
name|st
operator|->
name|level
condition|)
block|{
break|break;
block|}
name|parser
operator|->
name|stack
operator|=
name|st
operator|->
name|next
expr_stmt|;
name|UCL_FREE
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ucl_stack
argument_list|)
argument_list|,
name|st
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|ucl_set_err
argument_list|(
name|chunk
argument_list|,
name|UCL_ESYNTAX
argument_list|,
literal|"unexpected terminating symbol detected"
argument_list|,
operator|&
name|parser
operator|->
name|err
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|parser
operator|->
name|stack
operator|==
name|NULL
condition|)
block|{
comment|/* Ignore everything after a top object */
return|return
name|true
return|;
block|}
else|else
block|{
name|ucl_chunk_skipc
argument_list|(
name|chunk
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
name|got_sep
operator|=
name|true
expr_stmt|;
block|}
else|else
block|{
comment|/* Got a separator */
name|got_sep
operator|=
name|true
expr_stmt|;
name|ucl_chunk_skipc
argument_list|(
name|chunk
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Anything else */
if|if
condition|(
operator|!
name|got_sep
condition|)
block|{
name|ucl_set_err
argument_list|(
name|chunk
argument_list|,
name|UCL_ESYNTAX
argument_list|,
literal|"delimiter is missing"
argument_list|,
operator|&
name|parser
operator|->
name|err
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/**  * Handle macro data  * @param parser  * @param chunk  * @return  */
end_comment

begin_function
specifier|static
name|bool
name|ucl_parse_macro_value
parameter_list|(
name|struct
name|ucl_parser
modifier|*
name|parser
parameter_list|,
name|struct
name|ucl_chunk
modifier|*
name|chunk
parameter_list|,
name|struct
name|ucl_macro
modifier|*
name|macro
parameter_list|,
name|unsigned
name|char
specifier|const
modifier|*
modifier|*
name|macro_start
parameter_list|,
name|size_t
modifier|*
name|macro_len
parameter_list|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|c
decl_stmt|;
name|bool
name|need_unescape
init|=
name|false
decl_stmt|,
name|ucl_escape
init|=
name|false
decl_stmt|,
name|var_expand
init|=
name|false
decl_stmt|;
name|p
operator|=
name|chunk
operator|->
name|pos
expr_stmt|;
switch|switch
condition|(
operator|*
name|p
condition|)
block|{
case|case
literal|'"'
case|:
comment|/* We have macro value encoded in quotes */
name|c
operator|=
name|p
expr_stmt|;
name|ucl_chunk_skipc
argument_list|(
name|chunk
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ucl_lex_json_string
argument_list|(
name|parser
argument_list|,
name|chunk
argument_list|,
operator|&
name|need_unescape
argument_list|,
operator|&
name|ucl_escape
argument_list|,
operator|&
name|var_expand
argument_list|)
condition|)
block|{
return|return
name|false
return|;
block|}
operator|*
name|macro_start
operator|=
name|c
operator|+
literal|1
expr_stmt|;
operator|*
name|macro_len
operator|=
name|chunk
operator|->
name|pos
operator|-
name|c
operator|-
literal|2
expr_stmt|;
name|p
operator|=
name|chunk
operator|->
name|pos
expr_stmt|;
break|break;
case|case
literal|'{'
case|:
comment|/* We got a multiline macro body */
name|ucl_chunk_skipc
argument_list|(
name|chunk
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* Skip spaces at the beginning */
while|while
condition|(
name|p
operator|<
name|chunk
operator|->
name|end
condition|)
block|{
if|if
condition|(
name|ucl_test_character
argument_list|(
operator|*
name|p
argument_list|,
name|UCL_CHARACTER_WHITESPACE_UNSAFE
argument_list|)
condition|)
block|{
name|ucl_chunk_skipc
argument_list|(
name|chunk
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
block|}
name|c
operator|=
name|p
expr_stmt|;
while|while
condition|(
name|p
operator|<
name|chunk
operator|->
name|end
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'}'
condition|)
block|{
break|break;
block|}
name|ucl_chunk_skipc
argument_list|(
name|chunk
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
operator|*
name|macro_start
operator|=
name|c
expr_stmt|;
operator|*
name|macro_len
operator|=
name|p
operator|-
name|c
expr_stmt|;
name|ucl_chunk_skipc
argument_list|(
name|chunk
argument_list|,
name|p
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* Macro is not enclosed in quotes or braces */
name|c
operator|=
name|p
expr_stmt|;
while|while
condition|(
name|p
operator|<
name|chunk
operator|->
name|end
condition|)
block|{
if|if
condition|(
name|ucl_lex_is_atom_end
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
break|break;
block|}
name|ucl_chunk_skipc
argument_list|(
name|chunk
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
operator|*
name|macro_start
operator|=
name|c
expr_stmt|;
operator|*
name|macro_len
operator|=
name|p
operator|-
name|c
expr_stmt|;
break|break;
block|}
comment|/* We are at the end of a macro */
comment|/* Skip ';' and space characters and return to previous state */
while|while
condition|(
name|p
operator|<
name|chunk
operator|->
name|end
condition|)
block|{
if|if
condition|(
operator|!
name|ucl_test_character
argument_list|(
operator|*
name|p
argument_list|,
name|UCL_CHARACTER_WHITESPACE_UNSAFE
argument_list|)
operator|&&
operator|*
name|p
operator|!=
literal|';'
condition|)
block|{
break|break;
block|}
name|ucl_chunk_skipc
argument_list|(
name|chunk
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/**  * Handle the main states of rcl parser  * @param parser parser structure  * @param data the pointer to the beginning of a chunk  * @param len the length of a chunk  * @return true if chunk has been parsed and false in case of error  */
end_comment

begin_function
specifier|static
name|bool
name|ucl_state_machine
parameter_list|(
name|struct
name|ucl_parser
modifier|*
name|parser
parameter_list|)
block|{
name|ucl_object_t
modifier|*
name|obj
decl_stmt|;
name|struct
name|ucl_chunk
modifier|*
name|chunk
init|=
name|parser
operator|->
name|chunks
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|c
init|=
name|NULL
decl_stmt|,
modifier|*
name|macro_start
init|=
name|NULL
decl_stmt|;
name|unsigned
name|char
modifier|*
name|macro_escaped
decl_stmt|;
name|size_t
name|macro_len
init|=
literal|0
decl_stmt|;
name|struct
name|ucl_macro
modifier|*
name|macro
init|=
name|NULL
decl_stmt|;
name|bool
name|next_key
init|=
name|false
decl_stmt|,
name|end_of_object
init|=
name|false
decl_stmt|;
if|if
condition|(
name|parser
operator|->
name|top_obj
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|*
name|chunk
operator|->
name|pos
operator|==
literal|'['
condition|)
block|{
name|obj
operator|=
name|ucl_add_parser_stack
argument_list|(
name|NULL
argument_list|,
name|parser
argument_list|,
name|true
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|obj
operator|=
name|ucl_add_parser_stack
argument_list|(
name|NULL
argument_list|,
name|parser
argument_list|,
name|false
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|obj
operator|==
name|NULL
condition|)
block|{
return|return
name|false
return|;
block|}
name|parser
operator|->
name|top_obj
operator|=
name|obj
expr_stmt|;
name|parser
operator|->
name|cur_obj
operator|=
name|obj
expr_stmt|;
name|parser
operator|->
name|state
operator|=
name|UCL_STATE_INIT
expr_stmt|;
block|}
name|p
operator|=
name|chunk
operator|->
name|pos
expr_stmt|;
while|while
condition|(
name|chunk
operator|->
name|pos
operator|<
name|chunk
operator|->
name|end
condition|)
block|{
switch|switch
condition|(
name|parser
operator|->
name|state
condition|)
block|{
case|case
name|UCL_STATE_INIT
case|:
comment|/* 			 * At the init state we can either go to the parse array or object 			 * if we got [ or { correspondingly or can just treat new data as 			 * a key of newly created object 			 */
name|obj
operator|=
name|parser
operator|->
name|cur_obj
expr_stmt|;
if|if
condition|(
operator|!
name|ucl_skip_comments
argument_list|(
name|parser
argument_list|)
condition|)
block|{
name|parser
operator|->
name|prev_state
operator|=
name|parser
operator|->
name|state
expr_stmt|;
name|parser
operator|->
name|state
operator|=
name|UCL_STATE_ERROR
expr_stmt|;
return|return
name|false
return|;
block|}
else|else
block|{
comment|/* Skip any spaces */
while|while
condition|(
name|p
operator|<
name|chunk
operator|->
name|end
operator|&&
name|ucl_test_character
argument_list|(
operator|*
name|p
argument_list|,
name|UCL_CHARACTER_WHITESPACE_UNSAFE
argument_list|)
condition|)
block|{
name|ucl_chunk_skipc
argument_list|(
name|chunk
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
name|chunk
operator|->
name|pos
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'['
condition|)
block|{
name|parser
operator|->
name|state
operator|=
name|UCL_STATE_VALUE
expr_stmt|;
name|ucl_chunk_skipc
argument_list|(
name|chunk
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|parser
operator|->
name|state
operator|=
name|UCL_STATE_KEY
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'{'
condition|)
block|{
name|ucl_chunk_skipc
argument_list|(
name|chunk
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
block|}
block|}
break|break;
case|case
name|UCL_STATE_KEY
case|:
comment|/* Skip any spaces */
while|while
condition|(
name|p
operator|<
name|chunk
operator|->
name|end
operator|&&
name|ucl_test_character
argument_list|(
operator|*
name|p
argument_list|,
name|UCL_CHARACTER_WHITESPACE_UNSAFE
argument_list|)
condition|)
block|{
name|ucl_chunk_skipc
argument_list|(
name|chunk
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|p
operator|==
literal|'}'
condition|)
block|{
comment|/* We have the end of an object */
name|parser
operator|->
name|state
operator|=
name|UCL_STATE_AFTER_VALUE
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|parser
operator|->
name|stack
operator|==
name|NULL
condition|)
block|{
comment|/* No objects are on stack, but we want to parse a key */
name|ucl_set_err
argument_list|(
name|chunk
argument_list|,
name|UCL_ESYNTAX
argument_list|,
literal|"top object is finished but the parser "
literal|"expects a key"
argument_list|,
operator|&
name|parser
operator|->
name|err
argument_list|)
expr_stmt|;
name|parser
operator|->
name|prev_state
operator|=
name|parser
operator|->
name|state
expr_stmt|;
name|parser
operator|->
name|state
operator|=
name|UCL_STATE_ERROR
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
operator|!
name|ucl_parse_key
argument_list|(
name|parser
argument_list|,
name|chunk
argument_list|,
operator|&
name|next_key
argument_list|,
operator|&
name|end_of_object
argument_list|)
condition|)
block|{
name|parser
operator|->
name|prev_state
operator|=
name|parser
operator|->
name|state
expr_stmt|;
name|parser
operator|->
name|state
operator|=
name|UCL_STATE_ERROR
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|end_of_object
condition|)
block|{
name|p
operator|=
name|chunk
operator|->
name|pos
expr_stmt|;
name|parser
operator|->
name|state
operator|=
name|UCL_STATE_AFTER_VALUE
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|parser
operator|->
name|state
operator|!=
name|UCL_STATE_MACRO_NAME
condition|)
block|{
if|if
condition|(
name|next_key
operator|&&
name|parser
operator|->
name|stack
operator|->
name|obj
operator|->
name|type
operator|==
name|UCL_OBJECT
condition|)
block|{
comment|/* Parse more keys and nest objects accordingly */
name|obj
operator|=
name|ucl_add_parser_stack
argument_list|(
name|parser
operator|->
name|cur_obj
argument_list|,
name|parser
argument_list|,
name|false
argument_list|,
name|parser
operator|->
name|stack
operator|->
name|level
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj
operator|==
name|NULL
condition|)
block|{
return|return
name|false
return|;
block|}
block|}
else|else
block|{
name|parser
operator|->
name|state
operator|=
name|UCL_STATE_VALUE
expr_stmt|;
block|}
block|}
else|else
block|{
name|c
operator|=
name|chunk
operator|->
name|pos
expr_stmt|;
block|}
name|p
operator|=
name|chunk
operator|->
name|pos
expr_stmt|;
break|break;
case|case
name|UCL_STATE_VALUE
case|:
comment|/* We need to check what we do have */
if|if
condition|(
operator|!
name|ucl_parse_value
argument_list|(
name|parser
argument_list|,
name|chunk
argument_list|)
condition|)
block|{
name|parser
operator|->
name|prev_state
operator|=
name|parser
operator|->
name|state
expr_stmt|;
name|parser
operator|->
name|state
operator|=
name|UCL_STATE_ERROR
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* State is set in ucl_parse_value call */
name|p
operator|=
name|chunk
operator|->
name|pos
expr_stmt|;
break|break;
case|case
name|UCL_STATE_AFTER_VALUE
case|:
if|if
condition|(
operator|!
name|ucl_parse_after_value
argument_list|(
name|parser
argument_list|,
name|chunk
argument_list|)
condition|)
block|{
name|parser
operator|->
name|prev_state
operator|=
name|parser
operator|->
name|state
expr_stmt|;
name|parser
operator|->
name|state
operator|=
name|UCL_STATE_ERROR
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|parser
operator|->
name|stack
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|parser
operator|->
name|stack
operator|->
name|obj
operator|->
name|type
operator|==
name|UCL_OBJECT
condition|)
block|{
name|parser
operator|->
name|state
operator|=
name|UCL_STATE_KEY
expr_stmt|;
block|}
else|else
block|{
comment|/* Array */
name|parser
operator|->
name|state
operator|=
name|UCL_STATE_VALUE
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Skip everything at the end */
return|return
name|true
return|;
block|}
name|p
operator|=
name|chunk
operator|->
name|pos
expr_stmt|;
break|break;
case|case
name|UCL_STATE_MACRO_NAME
case|:
if|if
condition|(
operator|!
name|ucl_test_character
argument_list|(
operator|*
name|p
argument_list|,
name|UCL_CHARACTER_WHITESPACE_UNSAFE
argument_list|)
condition|)
block|{
name|ucl_chunk_skipc
argument_list|(
name|chunk
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
operator|-
name|c
operator|>
literal|0
condition|)
block|{
comment|/* We got macro name */
name|macro_len
operator|=
call|(
name|size_t
call|)
argument_list|(
name|p
operator|-
name|c
argument_list|)
expr_stmt|;
name|HASH_FIND
argument_list|(
name|hh
argument_list|,
name|parser
operator|->
name|macroes
argument_list|,
name|c
argument_list|,
name|macro_len
argument_list|,
name|macro
argument_list|)
expr_stmt|;
if|if
condition|(
name|macro
operator|==
name|NULL
condition|)
block|{
name|ucl_create_err
argument_list|(
operator|&
name|parser
operator|->
name|err
argument_list|,
literal|"error on line %d at column %d: "
literal|"unknown macro: '%.*s', character: '%c'"
argument_list|,
name|chunk
operator|->
name|line
argument_list|,
name|chunk
operator|->
name|column
argument_list|,
call|(
name|int
call|)
argument_list|(
name|p
operator|-
name|c
argument_list|)
argument_list|,
name|c
argument_list|,
operator|*
name|chunk
operator|->
name|pos
argument_list|)
expr_stmt|;
name|parser
operator|->
name|state
operator|=
name|UCL_STATE_ERROR
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* Now we need to skip all spaces */
while|while
condition|(
name|p
operator|<
name|chunk
operator|->
name|end
condition|)
block|{
if|if
condition|(
operator|!
name|ucl_test_character
argument_list|(
operator|*
name|p
argument_list|,
name|UCL_CHARACTER_WHITESPACE_UNSAFE
argument_list|)
condition|)
block|{
if|if
condition|(
name|chunk
operator|->
name|remain
operator|>=
literal|2
operator|&&
name|ucl_lex_is_comment
argument_list|(
name|p
index|[
literal|0
index|]
argument_list|,
name|p
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
comment|/* Skip comment */
if|if
condition|(
operator|!
name|ucl_skip_comments
argument_list|(
name|parser
argument_list|)
condition|)
block|{
return|return
name|false
return|;
block|}
name|p
operator|=
name|chunk
operator|->
name|pos
expr_stmt|;
block|}
break|break;
block|}
name|ucl_chunk_skipc
argument_list|(
name|chunk
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
name|parser
operator|->
name|state
operator|=
name|UCL_STATE_MACRO
expr_stmt|;
block|}
break|break;
case|case
name|UCL_STATE_MACRO
case|:
if|if
condition|(
operator|!
name|ucl_parse_macro_value
argument_list|(
name|parser
argument_list|,
name|chunk
argument_list|,
name|macro
argument_list|,
operator|&
name|macro_start
argument_list|,
operator|&
name|macro_len
argument_list|)
condition|)
block|{
name|parser
operator|->
name|prev_state
operator|=
name|parser
operator|->
name|state
expr_stmt|;
name|parser
operator|->
name|state
operator|=
name|UCL_STATE_ERROR
expr_stmt|;
return|return
name|false
return|;
block|}
name|macro_len
operator|=
name|ucl_expand_variable
argument_list|(
name|parser
argument_list|,
operator|&
name|macro_escaped
argument_list|,
name|macro_start
argument_list|,
name|macro_len
argument_list|)
expr_stmt|;
name|parser
operator|->
name|state
operator|=
name|parser
operator|->
name|prev_state
expr_stmt|;
if|if
condition|(
name|macro_escaped
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|macro
operator|->
name|handler
argument_list|(
name|macro_start
argument_list|,
name|macro_len
argument_list|,
name|macro
operator|->
name|ud
argument_list|)
condition|)
block|{
return|return
name|false
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|macro
operator|->
name|handler
argument_list|(
name|macro_escaped
argument_list|,
name|macro_len
argument_list|,
name|macro
operator|->
name|ud
argument_list|)
condition|)
block|{
name|UCL_FREE
argument_list|(
name|macro_len
operator|+
literal|1
argument_list|,
name|macro_escaped
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|UCL_FREE
argument_list|(
name|macro_len
operator|+
literal|1
argument_list|,
name|macro_escaped
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
name|chunk
operator|->
name|pos
expr_stmt|;
break|break;
default|default:
comment|/* TODO: add all states */
name|ucl_set_err
argument_list|(
name|chunk
argument_list|,
name|UCL_EINTERNAL
argument_list|,
literal|"internal error: parser is in an unknown state"
argument_list|,
operator|&
name|parser
operator|->
name|err
argument_list|)
expr_stmt|;
name|parser
operator|->
name|state
operator|=
name|UCL_STATE_ERROR
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_function
name|struct
name|ucl_parser
modifier|*
name|ucl_parser_new
parameter_list|(
name|int
name|flags
parameter_list|)
block|{
name|struct
name|ucl_parser
modifier|*
name|new
decl_stmt|;
name|new
operator|=
name|UCL_ALLOC
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ucl_parser
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|==
name|NULL
condition|)
block|{
return|return
name|NULL
return|;
block|}
name|memset
argument_list|(
name|new
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ucl_parser
argument_list|)
argument_list|)
expr_stmt|;
name|ucl_parser_register_macro
argument_list|(
name|new
argument_list|,
literal|"include"
argument_list|,
name|ucl_include_handler
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|ucl_parser_register_macro
argument_list|(
name|new
argument_list|,
literal|"try_include"
argument_list|,
name|ucl_try_include_handler
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|ucl_parser_register_macro
argument_list|(
name|new
argument_list|,
literal|"includes"
argument_list|,
name|ucl_includes_handler
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|new
operator|->
name|flags
operator|=
name|flags
expr_stmt|;
comment|/* Initial assumption about filevars */
name|ucl_parser_set_filevars
argument_list|(
name|new
argument_list|,
name|NULL
argument_list|,
name|false
argument_list|)
expr_stmt|;
return|return
name|new
return|;
block|}
end_function

begin_function
name|void
name|ucl_parser_register_macro
parameter_list|(
name|struct
name|ucl_parser
modifier|*
name|parser
parameter_list|,
specifier|const
name|char
modifier|*
name|macro
parameter_list|,
name|ucl_macro_handler
name|handler
parameter_list|,
name|void
modifier|*
name|ud
parameter_list|)
block|{
name|struct
name|ucl_macro
modifier|*
name|new
decl_stmt|;
if|if
condition|(
name|macro
operator|==
name|NULL
operator|||
name|handler
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
name|new
operator|=
name|UCL_ALLOC
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ucl_macro
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
name|memset
argument_list|(
name|new
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ucl_macro
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|->
name|handler
operator|=
name|handler
expr_stmt|;
name|new
operator|->
name|name
operator|=
name|strdup
argument_list|(
name|macro
argument_list|)
expr_stmt|;
name|new
operator|->
name|ud
operator|=
name|ud
expr_stmt|;
name|HASH_ADD_KEYPTR
argument_list|(
name|hh
argument_list|,
name|parser
operator|->
name|macroes
argument_list|,
name|new
operator|->
name|name
argument_list|,
name|strlen
argument_list|(
name|new
operator|->
name|name
argument_list|)
argument_list|,
name|new
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ucl_parser_register_variable
parameter_list|(
name|struct
name|ucl_parser
modifier|*
name|parser
parameter_list|,
specifier|const
name|char
modifier|*
name|var
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|)
block|{
name|struct
name|ucl_variable
modifier|*
name|new
init|=
name|NULL
decl_stmt|,
modifier|*
name|cur
decl_stmt|;
if|if
condition|(
name|var
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
comment|/* Find whether a variable already exists */
name|LL_FOREACH
argument_list|(
argument|parser->variables
argument_list|,
argument|cur
argument_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|cur
operator|->
name|var
argument_list|,
name|var
argument_list|)
operator|==
literal|0
condition|)
block|{
name|new
operator|=
name|cur
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|value
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|new
operator|!=
name|NULL
condition|)
block|{
comment|/* Remove variable */
name|LL_DELETE
argument_list|(
name|parser
operator|->
name|variables
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|new
operator|->
name|var
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|new
operator|->
name|value
argument_list|)
expr_stmt|;
name|UCL_FREE
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ucl_variable
argument_list|)
argument_list|,
name|new
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Do nothing */
return|return;
block|}
block|}
else|else
block|{
if|if
condition|(
name|new
operator|==
name|NULL
condition|)
block|{
name|new
operator|=
name|UCL_ALLOC
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ucl_variable
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
name|memset
argument_list|(
name|new
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ucl_variable
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|->
name|var
operator|=
name|strdup
argument_list|(
name|var
argument_list|)
expr_stmt|;
name|new
operator|->
name|var_len
operator|=
name|strlen
argument_list|(
name|var
argument_list|)
expr_stmt|;
name|new
operator|->
name|value
operator|=
name|strdup
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|new
operator|->
name|value_len
operator|=
name|strlen
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|LL_PREPEND
argument_list|(
name|parser
operator|->
name|variables
argument_list|,
name|new
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|free
argument_list|(
name|new
operator|->
name|value
argument_list|)
expr_stmt|;
name|new
operator|->
name|value
operator|=
name|strdup
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|new
operator|->
name|value_len
operator|=
name|strlen
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|ucl_parser_set_variables_handler
parameter_list|(
name|struct
name|ucl_parser
modifier|*
name|parser
parameter_list|,
name|ucl_variable_handler
name|handler
parameter_list|,
name|void
modifier|*
name|ud
parameter_list|)
block|{
name|parser
operator|->
name|var_handler
operator|=
name|handler
expr_stmt|;
name|parser
operator|->
name|var_data
operator|=
name|ud
expr_stmt|;
block|}
end_function

begin_function
name|bool
name|ucl_parser_add_chunk
parameter_list|(
name|struct
name|ucl_parser
modifier|*
name|parser
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|data
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|struct
name|ucl_chunk
modifier|*
name|chunk
decl_stmt|;
if|if
condition|(
name|data
operator|==
name|NULL
operator|||
name|len
operator|==
literal|0
condition|)
block|{
name|ucl_create_err
argument_list|(
operator|&
name|parser
operator|->
name|err
argument_list|,
literal|"invalid chunk added"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|parser
operator|->
name|state
operator|!=
name|UCL_STATE_ERROR
condition|)
block|{
name|chunk
operator|=
name|UCL_ALLOC
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ucl_chunk
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|chunk
operator|==
name|NULL
condition|)
block|{
name|ucl_create_err
argument_list|(
operator|&
name|parser
operator|->
name|err
argument_list|,
literal|"cannot allocate chunk structure"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|chunk
operator|->
name|begin
operator|=
name|data
expr_stmt|;
name|chunk
operator|->
name|remain
operator|=
name|len
expr_stmt|;
name|chunk
operator|->
name|pos
operator|=
name|chunk
operator|->
name|begin
expr_stmt|;
name|chunk
operator|->
name|end
operator|=
name|chunk
operator|->
name|begin
operator|+
name|len
expr_stmt|;
name|chunk
operator|->
name|line
operator|=
literal|1
expr_stmt|;
name|chunk
operator|->
name|column
operator|=
literal|0
expr_stmt|;
name|LL_PREPEND
argument_list|(
name|parser
operator|->
name|chunks
argument_list|,
name|chunk
argument_list|)
expr_stmt|;
name|parser
operator|->
name|recursion
operator|++
expr_stmt|;
if|if
condition|(
name|parser
operator|->
name|recursion
operator|>
name|UCL_MAX_RECURSION
condition|)
block|{
name|ucl_create_err
argument_list|(
operator|&
name|parser
operator|->
name|err
argument_list|,
literal|"maximum include nesting limit is reached: %d"
argument_list|,
name|parser
operator|->
name|recursion
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
return|return
name|ucl_state_machine
argument_list|(
name|parser
argument_list|)
return|;
block|}
name|ucl_create_err
argument_list|(
operator|&
name|parser
operator|->
name|err
argument_list|,
literal|"a parser is in an invalid state"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_function
name|bool
name|ucl_parser_add_string
parameter_list|(
name|struct
name|ucl_parser
modifier|*
name|parser
parameter_list|,
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
if|if
condition|(
name|data
operator|==
name|NULL
condition|)
block|{
name|ucl_create_err
argument_list|(
operator|&
name|parser
operator|->
name|err
argument_list|,
literal|"invalid string added"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
name|len
operator|=
name|strlen
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
return|return
name|ucl_parser_add_chunk
argument_list|(
name|parser
argument_list|,
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|data
argument_list|,
name|len
argument_list|)
return|;
block|}
end_function

end_unit

