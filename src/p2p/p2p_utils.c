begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * P2P - generic helper functions  * Copyright (c) 2009, Atheros Communications  *  * This software may be distributed under the terms of the BSD license.  * See README for more details.  */
end_comment

begin_include
include|#
directive|include
file|"includes.h"
end_include

begin_include
include|#
directive|include
file|"common.h"
end_include

begin_include
include|#
directive|include
file|"common/ieee802_11_common.h"
end_include

begin_include
include|#
directive|include
file|"p2p_i.h"
end_include

begin_comment
comment|/**  * p2p_random - Generate random string for SSID and passphrase  * @buf: Buffer for returning the result  * @len: Number of octets to write to the buffer  * Returns: 0 on success, -1 on failure  *  * This function generates a random string using the following character set:  * 'A'-'Z', 'a'-'z', '0'-'9'.  */
end_comment

begin_function
name|int
name|p2p_random
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|u8
name|val
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|u8
name|letters
init|=
literal|'Z'
operator|-
literal|'A'
operator|+
literal|1
decl_stmt|;
name|u8
name|numbers
init|=
literal|10
decl_stmt|;
if|if
condition|(
name|os_get_random
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|buf
argument_list|,
name|len
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Character set: 'A'-'Z', 'a'-'z', '0'-'9' */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|val
operator|=
name|buf
index|[
name|i
index|]
expr_stmt|;
name|val
operator|%=
literal|2
operator|*
name|letters
operator|+
name|numbers
expr_stmt|;
if|if
condition|(
name|val
operator|<
name|letters
condition|)
name|buf
index|[
name|i
index|]
operator|=
literal|'A'
operator|+
name|val
expr_stmt|;
elseif|else
if|if
condition|(
name|val
operator|<
literal|2
operator|*
name|letters
condition|)
name|buf
index|[
name|i
index|]
operator|=
literal|'a'
operator|+
operator|(
name|val
operator|-
name|letters
operator|)
expr_stmt|;
else|else
name|buf
index|[
name|i
index|]
operator|=
literal|'0'
operator|+
operator|(
name|val
operator|-
literal|2
operator|*
name|letters
operator|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * p2p_channel_to_freq - Convert channel info to frequency  * @op_class: Operating class  * @channel: Channel number  * Returns: Frequency in MHz or -1 if the specified channel is unknown  */
end_comment

begin_function
name|int
name|p2p_channel_to_freq
parameter_list|(
name|int
name|op_class
parameter_list|,
name|int
name|channel
parameter_list|)
block|{
return|return
name|ieee80211_chan_to_freq
argument_list|(
name|NULL
argument_list|,
name|op_class
argument_list|,
name|channel
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * p2p_freq_to_channel - Convert frequency into channel info  * @op_class: Buffer for returning operating class  * @channel: Buffer for returning channel number  * Returns: 0 on success, -1 if the specified frequency is unknown  */
end_comment

begin_function
name|int
name|p2p_freq_to_channel
parameter_list|(
name|unsigned
name|int
name|freq
parameter_list|,
name|u8
modifier|*
name|op_class
parameter_list|,
name|u8
modifier|*
name|channel
parameter_list|)
block|{
comment|/* TODO: more operating classes */
if|if
condition|(
name|freq
operator|>=
literal|2412
operator|&&
name|freq
operator|<=
literal|2472
condition|)
block|{
if|if
condition|(
operator|(
name|freq
operator|-
literal|2407
operator|)
operator|%
literal|5
condition|)
return|return
operator|-
literal|1
return|;
operator|*
name|op_class
operator|=
literal|81
expr_stmt|;
comment|/* 2.407 GHz, channels 1..13 */
operator|*
name|channel
operator|=
operator|(
name|freq
operator|-
literal|2407
operator|)
operator|/
literal|5
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|freq
operator|==
literal|2484
condition|)
block|{
operator|*
name|op_class
operator|=
literal|82
expr_stmt|;
comment|/* channel 14 */
operator|*
name|channel
operator|=
literal|14
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|freq
operator|>=
literal|5180
operator|&&
name|freq
operator|<=
literal|5240
condition|)
block|{
if|if
condition|(
operator|(
name|freq
operator|-
literal|5000
operator|)
operator|%
literal|5
condition|)
return|return
operator|-
literal|1
return|;
operator|*
name|op_class
operator|=
literal|115
expr_stmt|;
comment|/* 5 GHz, channels 36..48 */
operator|*
name|channel
operator|=
operator|(
name|freq
operator|-
literal|5000
operator|)
operator|/
literal|5
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|freq
operator|>=
literal|5745
operator|&&
name|freq
operator|<=
literal|5805
condition|)
block|{
if|if
condition|(
operator|(
name|freq
operator|-
literal|5000
operator|)
operator|%
literal|5
condition|)
return|return
operator|-
literal|1
return|;
operator|*
name|op_class
operator|=
literal|124
expr_stmt|;
comment|/* 5 GHz, channels 149..161 */
operator|*
name|channel
operator|=
operator|(
name|freq
operator|-
literal|5000
operator|)
operator|/
literal|5
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|freq
operator|>=
literal|58320
operator|&&
name|freq
operator|<=
literal|64800
condition|)
block|{
if|if
condition|(
operator|(
name|freq
operator|-
literal|58320
operator|)
operator|%
literal|2160
condition|)
return|return
operator|-
literal|1
return|;
operator|*
name|op_class
operator|=
literal|180
expr_stmt|;
comment|/* 60 GHz, channels 1..4 */
operator|*
name|channel
operator|=
operator|(
name|freq
operator|-
literal|56160
operator|)
operator|/
literal|2160
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|p2p_reg_class_intersect
parameter_list|(
specifier|const
name|struct
name|p2p_reg_class
modifier|*
name|a
parameter_list|,
specifier|const
name|struct
name|p2p_reg_class
modifier|*
name|b
parameter_list|,
name|struct
name|p2p_reg_class
modifier|*
name|res
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|,
name|j
decl_stmt|;
name|res
operator|->
name|reg_class
operator|=
name|a
operator|->
name|reg_class
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|a
operator|->
name|channels
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|b
operator|->
name|channels
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|a
operator|->
name|channel
index|[
name|i
index|]
operator|!=
name|b
operator|->
name|channel
index|[
name|j
index|]
condition|)
continue|continue;
name|res
operator|->
name|channel
index|[
name|res
operator|->
name|channels
index|]
operator|=
name|a
operator|->
name|channel
index|[
name|i
index|]
expr_stmt|;
name|res
operator|->
name|channels
operator|++
expr_stmt|;
if|if
condition|(
name|res
operator|->
name|channels
operator|==
name|P2P_MAX_REG_CLASS_CHANNELS
condition|)
return|return;
block|}
block|}
block|}
end_function

begin_comment
comment|/**  * p2p_channels_intersect - Intersection of supported channel lists  * @a: First set of supported channels  * @b: Second set of supported channels  * @res: Data structure for returning the intersection of support channels  *  * This function can be used to find a common set of supported channels. Both  * input channels sets are assumed to use the same country code. If different  * country codes are used, the regulatory class numbers may not be matched  * correctly and results are undefined.  */
end_comment

begin_function
name|void
name|p2p_channels_intersect
parameter_list|(
specifier|const
name|struct
name|p2p_channels
modifier|*
name|a
parameter_list|,
specifier|const
name|struct
name|p2p_channels
modifier|*
name|b
parameter_list|,
name|struct
name|p2p_channels
modifier|*
name|res
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|,
name|j
decl_stmt|;
name|os_memset
argument_list|(
name|res
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|res
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|a
operator|->
name|reg_classes
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|struct
name|p2p_reg_class
modifier|*
name|a_reg
init|=
operator|&
name|a
operator|->
name|reg_class
index|[
name|i
index|]
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|b
operator|->
name|reg_classes
condition|;
name|j
operator|++
control|)
block|{
specifier|const
name|struct
name|p2p_reg_class
modifier|*
name|b_reg
init|=
operator|&
name|b
operator|->
name|reg_class
index|[
name|j
index|]
decl_stmt|;
if|if
condition|(
name|a_reg
operator|->
name|reg_class
operator|!=
name|b_reg
operator|->
name|reg_class
condition|)
continue|continue;
name|p2p_reg_class_intersect
argument_list|(
name|a_reg
argument_list|,
name|b_reg
argument_list|,
operator|&
name|res
operator|->
name|reg_class
index|[
name|res
operator|->
name|reg_classes
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|->
name|reg_class
index|[
name|res
operator|->
name|reg_classes
index|]
operator|.
name|channels
condition|)
block|{
name|res
operator|->
name|reg_classes
operator|++
expr_stmt|;
if|if
condition|(
name|res
operator|->
name|reg_classes
operator|==
name|P2P_MAX_REG_CLASSES
condition|)
return|return;
block|}
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|p2p_op_class_union
parameter_list|(
name|struct
name|p2p_reg_class
modifier|*
name|cl
parameter_list|,
specifier|const
name|struct
name|p2p_reg_class
modifier|*
name|b_cl
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|b_cl
operator|->
name|channels
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|cl
operator|->
name|channels
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|b_cl
operator|->
name|channel
index|[
name|i
index|]
operator|==
name|cl
operator|->
name|channel
index|[
name|j
index|]
condition|)
break|break;
block|}
if|if
condition|(
name|j
operator|==
name|cl
operator|->
name|channels
condition|)
block|{
if|if
condition|(
name|cl
operator|->
name|channels
operator|==
name|P2P_MAX_REG_CLASS_CHANNELS
condition|)
return|return;
name|cl
operator|->
name|channel
index|[
name|cl
operator|->
name|channels
operator|++
index|]
operator|=
name|b_cl
operator|->
name|channel
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/**  * p2p_channels_union_inplace - Inplace union of channel lists  * @res: Input data and place for returning union of the channel sets  * @b: Second set of channels  */
end_comment

begin_function
name|void
name|p2p_channels_union_inplace
parameter_list|(
name|struct
name|p2p_channels
modifier|*
name|res
parameter_list|,
specifier|const
name|struct
name|p2p_channels
modifier|*
name|b
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|res
operator|->
name|reg_classes
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|p2p_reg_class
modifier|*
name|cl
init|=
operator|&
name|res
operator|->
name|reg_class
index|[
name|i
index|]
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|b
operator|->
name|reg_classes
condition|;
name|j
operator|++
control|)
block|{
specifier|const
name|struct
name|p2p_reg_class
modifier|*
name|b_cl
init|=
operator|&
name|b
operator|->
name|reg_class
index|[
name|j
index|]
decl_stmt|;
if|if
condition|(
name|cl
operator|->
name|reg_class
operator|!=
name|b_cl
operator|->
name|reg_class
condition|)
continue|continue;
name|p2p_op_class_union
argument_list|(
name|cl
argument_list|,
name|b_cl
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|b
operator|->
name|reg_classes
condition|;
name|j
operator|++
control|)
block|{
specifier|const
name|struct
name|p2p_reg_class
modifier|*
name|b_cl
init|=
operator|&
name|b
operator|->
name|reg_class
index|[
name|j
index|]
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|res
operator|->
name|reg_classes
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|p2p_reg_class
modifier|*
name|cl
init|=
operator|&
name|res
operator|->
name|reg_class
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|cl
operator|->
name|reg_class
operator|==
name|b_cl
operator|->
name|reg_class
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|res
operator|->
name|reg_classes
condition|)
block|{
if|if
condition|(
name|res
operator|->
name|reg_classes
operator|==
name|P2P_MAX_REG_CLASSES
condition|)
return|return;
name|os_memcpy
argument_list|(
operator|&
name|res
operator|->
name|reg_class
index|[
name|res
operator|->
name|reg_classes
operator|++
index|]
argument_list|,
name|b_cl
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|p2p_reg_class
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/**  * p2p_channels_union - Union of channel lists  * @a: First set of channels  * @b: Second set of channels  * @res: Data structure for returning the union of channels  */
end_comment

begin_function
name|void
name|p2p_channels_union
parameter_list|(
specifier|const
name|struct
name|p2p_channels
modifier|*
name|a
parameter_list|,
specifier|const
name|struct
name|p2p_channels
modifier|*
name|b
parameter_list|,
name|struct
name|p2p_channels
modifier|*
name|res
parameter_list|)
block|{
name|os_memcpy
argument_list|(
name|res
argument_list|,
name|a
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|res
argument_list|)
argument_list|)
expr_stmt|;
name|p2p_channels_union_inplace
argument_list|(
name|res
argument_list|,
name|b
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|p2p_channels_remove_freqs
parameter_list|(
name|struct
name|p2p_channels
modifier|*
name|chan
parameter_list|,
specifier|const
name|struct
name|wpa_freq_range_list
modifier|*
name|list
parameter_list|)
block|{
name|size_t
name|o
decl_stmt|,
name|c
decl_stmt|;
if|if
condition|(
name|list
operator|==
name|NULL
condition|)
return|return;
name|o
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|o
operator|<
name|chan
operator|->
name|reg_classes
condition|)
block|{
name|struct
name|p2p_reg_class
modifier|*
name|op
init|=
operator|&
name|chan
operator|->
name|reg_class
index|[
name|o
index|]
decl_stmt|;
name|c
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|c
operator|<
name|op
operator|->
name|channels
condition|)
block|{
name|int
name|freq
init|=
name|p2p_channel_to_freq
argument_list|(
name|op
operator|->
name|reg_class
argument_list|,
name|op
operator|->
name|channel
index|[
name|c
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|freq
operator|>
literal|0
operator|&&
name|freq_range_list_includes
argument_list|(
name|list
argument_list|,
name|freq
argument_list|)
condition|)
block|{
name|op
operator|->
name|channels
operator|--
expr_stmt|;
name|os_memmove
argument_list|(
operator|&
name|op
operator|->
name|channel
index|[
name|c
index|]
argument_list|,
operator|&
name|op
operator|->
name|channel
index|[
name|c
operator|+
literal|1
index|]
argument_list|,
name|op
operator|->
name|channels
operator|-
name|c
argument_list|)
expr_stmt|;
block|}
else|else
name|c
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|op
operator|->
name|channels
operator|==
literal|0
condition|)
block|{
name|chan
operator|->
name|reg_classes
operator|--
expr_stmt|;
name|os_memmove
argument_list|(
operator|&
name|chan
operator|->
name|reg_class
index|[
name|o
index|]
argument_list|,
operator|&
name|chan
operator|->
name|reg_class
index|[
name|o
operator|+
literal|1
index|]
argument_list|,
operator|(
name|chan
operator|->
name|reg_classes
operator|-
name|o
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|p2p_reg_class
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|o
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * p2p_channels_includes - Check whether a channel is included in the list  * @channels: List of supported channels  * @reg_class: Regulatory class of the channel to search  * @channel: Channel number of the channel to search  * Returns: 1 if channel was found or 0 if not  */
end_comment

begin_function
name|int
name|p2p_channels_includes
parameter_list|(
specifier|const
name|struct
name|p2p_channels
modifier|*
name|channels
parameter_list|,
name|u8
name|reg_class
parameter_list|,
name|u8
name|channel
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|channels
operator|->
name|reg_classes
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|struct
name|p2p_reg_class
modifier|*
name|reg
init|=
operator|&
name|channels
operator|->
name|reg_class
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|reg
operator|->
name|reg_class
operator|!=
name|reg_class
condition|)
continue|continue;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|reg
operator|->
name|channels
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|reg
operator|->
name|channel
index|[
name|j
index|]
operator|==
name|channel
condition|)
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|p2p_channels_includes_freq
parameter_list|(
specifier|const
name|struct
name|p2p_channels
modifier|*
name|channels
parameter_list|,
name|unsigned
name|int
name|freq
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|channels
operator|->
name|reg_classes
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|struct
name|p2p_reg_class
modifier|*
name|reg
init|=
operator|&
name|channels
operator|->
name|reg_class
index|[
name|i
index|]
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|reg
operator|->
name|channels
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|p2p_channel_to_freq
argument_list|(
name|reg
operator|->
name|reg_class
argument_list|,
name|reg
operator|->
name|channel
index|[
name|j
index|]
argument_list|)
operator|==
operator|(
name|int
operator|)
name|freq
condition|)
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|p2p_supported_freq
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|,
name|unsigned
name|int
name|freq
parameter_list|)
block|{
name|u8
name|op_reg_class
decl_stmt|,
name|op_channel
decl_stmt|;
if|if
condition|(
name|p2p_freq_to_channel
argument_list|(
name|freq
argument_list|,
operator|&
name|op_reg_class
argument_list|,
operator|&
name|op_channel
argument_list|)
operator|<
literal|0
condition|)
return|return
literal|0
return|;
return|return
name|p2p_channels_includes
argument_list|(
operator|&
name|p2p
operator|->
name|cfg
operator|->
name|channels
argument_list|,
name|op_reg_class
argument_list|,
name|op_channel
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|p2p_supported_freq_go
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|,
name|unsigned
name|int
name|freq
parameter_list|)
block|{
name|u8
name|op_reg_class
decl_stmt|,
name|op_channel
decl_stmt|;
if|if
condition|(
name|p2p_freq_to_channel
argument_list|(
name|freq
argument_list|,
operator|&
name|op_reg_class
argument_list|,
operator|&
name|op_channel
argument_list|)
operator|<
literal|0
condition|)
return|return
literal|0
return|;
return|return
name|p2p_channels_includes
argument_list|(
operator|&
name|p2p
operator|->
name|cfg
operator|->
name|channels
argument_list|,
name|op_reg_class
argument_list|,
name|op_channel
argument_list|)
operator|&&
operator|!
name|freq_range_list_includes
argument_list|(
operator|&
name|p2p
operator|->
name|no_go_freq
argument_list|,
name|freq
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|p2p_supported_freq_cli
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|,
name|unsigned
name|int
name|freq
parameter_list|)
block|{
name|u8
name|op_reg_class
decl_stmt|,
name|op_channel
decl_stmt|;
if|if
condition|(
name|p2p_freq_to_channel
argument_list|(
name|freq
argument_list|,
operator|&
name|op_reg_class
argument_list|,
operator|&
name|op_channel
argument_list|)
operator|<
literal|0
condition|)
return|return
literal|0
return|;
return|return
name|p2p_channels_includes
argument_list|(
operator|&
name|p2p
operator|->
name|cfg
operator|->
name|channels
argument_list|,
name|op_reg_class
argument_list|,
name|op_channel
argument_list|)
operator|||
name|p2p_channels_includes
argument_list|(
operator|&
name|p2p
operator|->
name|cfg
operator|->
name|cli_channels
argument_list|,
name|op_reg_class
argument_list|,
name|op_channel
argument_list|)
return|;
block|}
end_function

begin_function
name|unsigned
name|int
name|p2p_get_pref_freq
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|,
specifier|const
name|struct
name|p2p_channels
modifier|*
name|channels
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|int
name|freq
init|=
literal|0
decl_stmt|;
specifier|const
name|struct
name|p2p_channels
modifier|*
name|tmpc
init|=
name|channels
condition|?
name|channels
else|:
operator|&
name|p2p
operator|->
name|cfg
operator|->
name|channels
decl_stmt|;
if|if
condition|(
name|tmpc
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|p2p
operator|->
name|cfg
operator|->
name|pref_chan
operator|&&
name|i
operator|<
name|p2p
operator|->
name|cfg
operator|->
name|num_pref_chan
condition|;
name|i
operator|++
control|)
block|{
name|freq
operator|=
name|p2p_channel_to_freq
argument_list|(
name|p2p
operator|->
name|cfg
operator|->
name|pref_chan
index|[
name|i
index|]
operator|.
name|op_class
argument_list|,
name|p2p
operator|->
name|cfg
operator|->
name|pref_chan
index|[
name|i
index|]
operator|.
name|chan
argument_list|)
expr_stmt|;
if|if
condition|(
name|p2p_channels_includes_freq
argument_list|(
name|tmpc
argument_list|,
name|freq
argument_list|)
condition|)
return|return
name|freq
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|p2p_channels_dump
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|,
specifier|const
name|char
modifier|*
name|title
parameter_list|,
specifier|const
name|struct
name|p2p_channels
modifier|*
name|chan
parameter_list|)
block|{
name|char
name|buf
index|[
literal|500
index|]
decl_stmt|,
modifier|*
name|pos
decl_stmt|,
modifier|*
name|end
decl_stmt|;
name|size_t
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|pos
operator|=
name|buf
expr_stmt|;
name|end
operator|=
name|pos
operator|+
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|chan
operator|->
name|reg_classes
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|struct
name|p2p_reg_class
modifier|*
name|c
decl_stmt|;
name|c
operator|=
operator|&
name|chan
operator|->
name|reg_class
index|[
name|i
index|]
expr_stmt|;
name|ret
operator|=
name|os_snprintf
argument_list|(
name|pos
argument_list|,
name|end
operator|-
name|pos
argument_list|,
literal|" %u:"
argument_list|,
name|c
operator|->
name|reg_class
argument_list|)
expr_stmt|;
if|if
condition|(
name|os_snprintf_error
argument_list|(
name|end
operator|-
name|pos
argument_list|,
name|ret
argument_list|)
condition|)
break|break;
name|pos
operator|+=
name|ret
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|c
operator|->
name|channels
condition|;
name|j
operator|++
control|)
block|{
name|ret
operator|=
name|os_snprintf
argument_list|(
name|pos
argument_list|,
name|end
operator|-
name|pos
argument_list|,
literal|"%s%u"
argument_list|,
name|j
operator|==
literal|0
condition|?
literal|""
else|:
literal|","
argument_list|,
name|c
operator|->
name|channel
index|[
name|j
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|os_snprintf_error
argument_list|(
name|end
operator|-
name|pos
argument_list|,
name|ret
argument_list|)
condition|)
break|break;
name|pos
operator|+=
name|ret
expr_stmt|;
block|}
block|}
operator|*
name|pos
operator|=
literal|'\0'
expr_stmt|;
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"%s:%s"
argument_list|,
name|title
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|u8
name|p2p_channel_pick_random
parameter_list|(
specifier|const
name|u8
modifier|*
name|channels
parameter_list|,
name|unsigned
name|int
name|num_channels
parameter_list|)
block|{
name|unsigned
name|int
name|r
decl_stmt|;
if|if
condition|(
name|os_get_random
argument_list|(
operator|(
name|u8
operator|*
operator|)
operator|&
name|r
argument_list|,
sizeof|sizeof
argument_list|(
name|r
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
name|r
operator|=
literal|0
expr_stmt|;
name|r
operator|%=
name|num_channels
expr_stmt|;
return|return
name|channels
index|[
name|r
index|]
return|;
block|}
end_function

begin_function
name|int
name|p2p_channel_select
parameter_list|(
name|struct
name|p2p_channels
modifier|*
name|chans
parameter_list|,
specifier|const
name|int
modifier|*
name|classes
parameter_list|,
name|u8
modifier|*
name|op_class
parameter_list|,
name|u8
modifier|*
name|op_channel
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|classes
operator|==
name|NULL
operator|||
name|classes
index|[
name|j
index|]
condition|;
name|j
operator|++
control|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|chans
operator|->
name|reg_classes
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|p2p_reg_class
modifier|*
name|c
init|=
operator|&
name|chans
operator|->
name|reg_class
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|c
operator|->
name|channels
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|classes
operator|==
name|NULL
operator|||
name|c
operator|->
name|reg_class
operator|==
name|classes
index|[
name|j
index|]
condition|)
block|{
comment|/* 				 * Pick one of the available channels in the 				 * operating class at random. 				 */
operator|*
name|op_class
operator|=
name|c
operator|->
name|reg_class
expr_stmt|;
operator|*
name|op_channel
operator|=
name|p2p_channel_pick_random
argument_list|(
name|c
operator|->
name|channel
argument_list|,
name|c
operator|->
name|channels
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
if|if
condition|(
name|classes
operator|==
name|NULL
condition|)
break|break;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
name|int
name|p2p_channel_random_social
parameter_list|(
name|struct
name|p2p_channels
modifier|*
name|chans
parameter_list|,
name|u8
modifier|*
name|op_class
parameter_list|,
name|u8
modifier|*
name|op_channel
parameter_list|)
block|{
name|u8
name|chan
index|[
literal|4
index|]
decl_stmt|;
name|unsigned
name|int
name|num_channels
init|=
literal|0
decl_stmt|;
comment|/* Try to find available social channels from 2.4 GHz */
if|if
condition|(
name|p2p_channels_includes
argument_list|(
name|chans
argument_list|,
literal|81
argument_list|,
literal|1
argument_list|)
condition|)
name|chan
index|[
name|num_channels
operator|++
index|]
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|p2p_channels_includes
argument_list|(
name|chans
argument_list|,
literal|81
argument_list|,
literal|6
argument_list|)
condition|)
name|chan
index|[
name|num_channels
operator|++
index|]
operator|=
literal|6
expr_stmt|;
if|if
condition|(
name|p2p_channels_includes
argument_list|(
name|chans
argument_list|,
literal|81
argument_list|,
literal|11
argument_list|)
condition|)
name|chan
index|[
name|num_channels
operator|++
index|]
operator|=
literal|11
expr_stmt|;
comment|/* Try to find available social channels from 60 GHz */
if|if
condition|(
name|p2p_channels_includes
argument_list|(
name|chans
argument_list|,
literal|180
argument_list|,
literal|2
argument_list|)
condition|)
name|chan
index|[
name|num_channels
operator|++
index|]
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|num_channels
operator|==
literal|0
condition|)
return|return
operator|-
literal|1
return|;
operator|*
name|op_channel
operator|=
name|p2p_channel_pick_random
argument_list|(
name|chan
argument_list|,
name|num_channels
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|op_channel
operator|==
literal|2
condition|)
operator|*
name|op_class
operator|=
literal|180
expr_stmt|;
else|else
operator|*
name|op_class
operator|=
literal|81
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|p2p_channels_to_freqs
parameter_list|(
specifier|const
name|struct
name|p2p_channels
modifier|*
name|channels
parameter_list|,
name|int
modifier|*
name|freq_list
parameter_list|,
name|unsigned
name|int
name|max_len
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|,
name|idx
decl_stmt|;
if|if
condition|(
operator|!
name|channels
operator|||
name|max_len
operator|==
literal|0
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|idx
operator|=
literal|0
init|;
name|i
operator|<
name|channels
operator|->
name|reg_classes
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|struct
name|p2p_reg_class
modifier|*
name|c
init|=
operator|&
name|channels
operator|->
name|reg_class
index|[
name|i
index|]
decl_stmt|;
name|unsigned
name|int
name|j
decl_stmt|;
if|if
condition|(
name|idx
operator|+
literal|1
operator|==
name|max_len
condition|)
break|break;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|c
operator|->
name|channels
condition|;
name|j
operator|++
control|)
block|{
name|int
name|freq
decl_stmt|;
if|if
condition|(
name|idx
operator|+
literal|1
operator|==
name|max_len
condition|)
break|break;
name|freq
operator|=
name|p2p_channel_to_freq
argument_list|(
name|c
operator|->
name|reg_class
argument_list|,
name|c
operator|->
name|channel
index|[
name|j
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|freq
operator|<
literal|0
condition|)
continue|continue;
name|freq_list
index|[
name|idx
operator|++
index|]
operator|=
name|freq
expr_stmt|;
block|}
block|}
name|freq_list
index|[
name|idx
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|idx
return|;
block|}
end_function

end_unit

