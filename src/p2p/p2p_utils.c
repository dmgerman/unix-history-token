begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * P2P - generic helper functions  * Copyright (c) 2009, Atheros Communications  *  * This software may be distributed under the terms of the BSD license.  * See README for more details.  */
end_comment

begin_include
include|#
directive|include
file|"includes.h"
end_include

begin_include
include|#
directive|include
file|"common.h"
end_include

begin_include
include|#
directive|include
file|"p2p_i.h"
end_include

begin_comment
comment|/**  * p2p_random - Generate random string for SSID and passphrase  * @buf: Buffer for returning the result  * @len: Number of octets to write to the buffer  * Returns: 0 on success, -1 on failure  *  * This function generates a random string using the following character set:  * 'A'-'Z', 'a'-'z', '0'-'9'.  */
end_comment

begin_function
name|int
name|p2p_random
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|u8
name|val
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|u8
name|letters
init|=
literal|'Z'
operator|-
literal|'A'
operator|+
literal|1
decl_stmt|;
name|u8
name|numbers
init|=
literal|10
decl_stmt|;
if|if
condition|(
name|os_get_random
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|buf
argument_list|,
name|len
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Character set: 'A'-'Z', 'a'-'z', '0'-'9' */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|val
operator|=
name|buf
index|[
name|i
index|]
expr_stmt|;
name|val
operator|%=
literal|2
operator|*
name|letters
operator|+
name|numbers
expr_stmt|;
if|if
condition|(
name|val
operator|<
name|letters
condition|)
name|buf
index|[
name|i
index|]
operator|=
literal|'A'
operator|+
name|val
expr_stmt|;
elseif|else
if|if
condition|(
name|val
operator|<
literal|2
operator|*
name|letters
condition|)
name|buf
index|[
name|i
index|]
operator|=
literal|'a'
operator|+
operator|(
name|val
operator|-
name|letters
operator|)
expr_stmt|;
else|else
name|buf
index|[
name|i
index|]
operator|=
literal|'0'
operator|+
operator|(
name|val
operator|-
literal|2
operator|*
name|letters
operator|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|p2p_channel_to_freq_j4
parameter_list|(
name|int
name|reg_class
parameter_list|,
name|int
name|channel
parameter_list|)
block|{
comment|/* Table J-4 in P802.11REVmb/D4.0 - Global operating classes */
comment|/* TODO: more regulatory classes */
switch|switch
condition|(
name|reg_class
condition|)
block|{
case|case
literal|81
case|:
comment|/* channels 1..13 */
if|if
condition|(
name|channel
operator|<
literal|1
operator|||
name|channel
operator|>
literal|13
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|2407
operator|+
literal|5
operator|*
name|channel
return|;
case|case
literal|82
case|:
comment|/* channel 14 */
if|if
condition|(
name|channel
operator|!=
literal|14
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|2414
operator|+
literal|5
operator|*
name|channel
return|;
case|case
literal|83
case|:
comment|/* channels 1..9; 40 MHz */
case|case
literal|84
case|:
comment|/* channels 5..13; 40 MHz */
if|if
condition|(
name|channel
operator|<
literal|1
operator|||
name|channel
operator|>
literal|13
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|2407
operator|+
literal|5
operator|*
name|channel
return|;
case|case
literal|115
case|:
comment|/* channels 36,40,44,48; indoor only */
case|case
literal|118
case|:
comment|/* channels 52,56,60,64; dfs */
if|if
condition|(
name|channel
operator|<
literal|36
operator|||
name|channel
operator|>
literal|64
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|5000
operator|+
literal|5
operator|*
name|channel
return|;
case|case
literal|124
case|:
comment|/* channels 149,153,157,161 */
case|case
literal|125
case|:
comment|/* channels 149,153,157,161,165,169 */
if|if
condition|(
name|channel
operator|<
literal|149
operator|||
name|channel
operator|>
literal|161
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|5000
operator|+
literal|5
operator|*
name|channel
return|;
case|case
literal|116
case|:
comment|/* channels 36,44; 40 MHz; indoor only */
case|case
literal|117
case|:
comment|/* channels 40,48; 40 MHz; indoor only */
case|case
literal|119
case|:
comment|/* channels 52,60; 40 MHz; dfs */
case|case
literal|120
case|:
comment|/* channels 56,64; 40 MHz; dfs */
if|if
condition|(
name|channel
operator|<
literal|36
operator|||
name|channel
operator|>
literal|64
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|5000
operator|+
literal|5
operator|*
name|channel
return|;
case|case
literal|126
case|:
comment|/* channels 149,157; 40 MHz */
case|case
literal|127
case|:
comment|/* channels 153,161; 40 MHz */
if|if
condition|(
name|channel
operator|<
literal|149
operator|||
name|channel
operator|>
literal|161
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|5000
operator|+
literal|5
operator|*
name|channel
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/**  * p2p_channel_to_freq - Convert channel info to frequency  * @country: Country code  * @reg_class: Regulatory class  * @channel: Channel number  * Returns: Frequency in MHz or -1 if the specified channel is unknown  */
end_comment

begin_function
name|int
name|p2p_channel_to_freq
parameter_list|(
specifier|const
name|char
modifier|*
name|country
parameter_list|,
name|int
name|reg_class
parameter_list|,
name|int
name|channel
parameter_list|)
block|{
if|if
condition|(
name|country
index|[
literal|2
index|]
operator|==
literal|0x04
condition|)
return|return
name|p2p_channel_to_freq_j4
argument_list|(
name|reg_class
argument_list|,
name|channel
argument_list|)
return|;
comment|/* These are mainly for backwards compatibility; to be removed */
switch|switch
condition|(
name|reg_class
condition|)
block|{
case|case
literal|1
case|:
comment|/* US/1, EU/1, JP/1 = 5 GHz, channels 36,40,44,48 */
if|if
condition|(
name|channel
operator|<
literal|36
operator|||
name|channel
operator|>
literal|48
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|5000
operator|+
literal|5
operator|*
name|channel
return|;
case|case
literal|3
case|:
comment|/* US/3 = 5 GHz, channels 149,153,157,161 */
case|case
literal|5
case|:
comment|/* US/5 = 5 GHz, channels 149,153,157,161 */
if|if
condition|(
name|channel
operator|<
literal|149
operator|||
name|channel
operator|>
literal|161
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|5000
operator|+
literal|5
operator|*
name|channel
return|;
case|case
literal|4
case|:
comment|/* EU/4 = 2.407 GHz, channels 1..13 */
case|case
literal|12
case|:
comment|/* US/12 = 2.407 GHz, channels 1..11 */
case|case
literal|30
case|:
comment|/* JP/30 = 2.407 GHz, channels 1..13 */
if|if
condition|(
name|channel
operator|<
literal|1
operator|||
name|channel
operator|>
literal|13
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|2407
operator|+
literal|5
operator|*
name|channel
return|;
case|case
literal|31
case|:
comment|/* JP/31 = 2.414 GHz, channel 14 */
if|if
condition|(
name|channel
operator|!=
literal|14
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|2414
operator|+
literal|5
operator|*
name|channel
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/**  * p2p_freq_to_channel - Convert frequency into channel info  * @country: Country code  * @reg_class: Buffer for returning regulatory class  * @channel: Buffer for returning channel number  * Returns: 0 on success, -1 if the specified frequency is unknown  */
end_comment

begin_function
name|int
name|p2p_freq_to_channel
parameter_list|(
specifier|const
name|char
modifier|*
name|country
parameter_list|,
name|unsigned
name|int
name|freq
parameter_list|,
name|u8
modifier|*
name|reg_class
parameter_list|,
name|u8
modifier|*
name|channel
parameter_list|)
block|{
comment|/* TODO: more operating classes */
if|if
condition|(
name|freq
operator|>=
literal|2412
operator|&&
name|freq
operator|<=
literal|2472
condition|)
block|{
operator|*
name|reg_class
operator|=
literal|81
expr_stmt|;
comment|/* 2.407 GHz, channels 1..13 */
operator|*
name|channel
operator|=
operator|(
name|freq
operator|-
literal|2407
operator|)
operator|/
literal|5
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|freq
operator|==
literal|2484
condition|)
block|{
operator|*
name|reg_class
operator|=
literal|82
expr_stmt|;
comment|/* channel 14 */
operator|*
name|channel
operator|=
literal|14
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|freq
operator|>=
literal|5180
operator|&&
name|freq
operator|<=
literal|5240
condition|)
block|{
operator|*
name|reg_class
operator|=
literal|115
expr_stmt|;
comment|/* 5 GHz, channels 36..48 */
operator|*
name|channel
operator|=
operator|(
name|freq
operator|-
literal|5000
operator|)
operator|/
literal|5
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|freq
operator|>=
literal|5745
operator|&&
name|freq
operator|<=
literal|5805
condition|)
block|{
operator|*
name|reg_class
operator|=
literal|124
expr_stmt|;
comment|/* 5 GHz, channels 149..161 */
operator|*
name|channel
operator|=
operator|(
name|freq
operator|-
literal|5000
operator|)
operator|/
literal|5
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|p2p_reg_class_intersect
parameter_list|(
specifier|const
name|struct
name|p2p_reg_class
modifier|*
name|a
parameter_list|,
specifier|const
name|struct
name|p2p_reg_class
modifier|*
name|b
parameter_list|,
name|struct
name|p2p_reg_class
modifier|*
name|res
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|,
name|j
decl_stmt|;
name|res
operator|->
name|reg_class
operator|=
name|a
operator|->
name|reg_class
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|a
operator|->
name|channels
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|b
operator|->
name|channels
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|a
operator|->
name|channel
index|[
name|i
index|]
operator|!=
name|b
operator|->
name|channel
index|[
name|j
index|]
condition|)
continue|continue;
name|res
operator|->
name|channel
index|[
name|res
operator|->
name|channels
index|]
operator|=
name|a
operator|->
name|channel
index|[
name|i
index|]
expr_stmt|;
name|res
operator|->
name|channels
operator|++
expr_stmt|;
if|if
condition|(
name|res
operator|->
name|channels
operator|==
name|P2P_MAX_REG_CLASS_CHANNELS
condition|)
return|return;
block|}
block|}
block|}
end_function

begin_comment
comment|/**  * p2p_channels_intersect - Intersection of supported channel lists  * @a: First set of supported channels  * @b: Second set of supported channels  * @res: Data structure for returning the intersection of support channels  *  * This function can be used to find a common set of supported channels. Both  * input channels sets are assumed to use the same country code. If different  * country codes are used, the regulatory class numbers may not be matched  * correctly and results are undefined.  */
end_comment

begin_function
name|void
name|p2p_channels_intersect
parameter_list|(
specifier|const
name|struct
name|p2p_channels
modifier|*
name|a
parameter_list|,
specifier|const
name|struct
name|p2p_channels
modifier|*
name|b
parameter_list|,
name|struct
name|p2p_channels
modifier|*
name|res
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|,
name|j
decl_stmt|;
name|os_memset
argument_list|(
name|res
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|res
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|a
operator|->
name|reg_classes
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|struct
name|p2p_reg_class
modifier|*
name|a_reg
init|=
operator|&
name|a
operator|->
name|reg_class
index|[
name|i
index|]
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|b
operator|->
name|reg_classes
condition|;
name|j
operator|++
control|)
block|{
specifier|const
name|struct
name|p2p_reg_class
modifier|*
name|b_reg
init|=
operator|&
name|b
operator|->
name|reg_class
index|[
name|j
index|]
decl_stmt|;
if|if
condition|(
name|a_reg
operator|->
name|reg_class
operator|!=
name|b_reg
operator|->
name|reg_class
condition|)
continue|continue;
name|p2p_reg_class_intersect
argument_list|(
name|a_reg
argument_list|,
name|b_reg
argument_list|,
operator|&
name|res
operator|->
name|reg_class
index|[
name|res
operator|->
name|reg_classes
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|->
name|reg_class
index|[
name|res
operator|->
name|reg_classes
index|]
operator|.
name|channels
condition|)
block|{
name|res
operator|->
name|reg_classes
operator|++
expr_stmt|;
if|if
condition|(
name|res
operator|->
name|reg_classes
operator|==
name|P2P_MAX_REG_CLASSES
condition|)
return|return;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/**  * p2p_channels_includes - Check whether a channel is included in the list  * @channels: List of supported channels  * @reg_class: Regulatory class of the channel to search  * @channel: Channel number of the channel to search  * Returns: 1 if channel was found or 0 if not  */
end_comment

begin_function
name|int
name|p2p_channels_includes
parameter_list|(
specifier|const
name|struct
name|p2p_channels
modifier|*
name|channels
parameter_list|,
name|u8
name|reg_class
parameter_list|,
name|u8
name|channel
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|channels
operator|->
name|reg_classes
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|struct
name|p2p_reg_class
modifier|*
name|reg
init|=
operator|&
name|channels
operator|->
name|reg_class
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|reg
operator|->
name|reg_class
operator|!=
name|reg_class
condition|)
continue|continue;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|reg
operator|->
name|channels
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|reg
operator|->
name|channel
index|[
name|j
index|]
operator|==
name|channel
condition|)
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|p2p_supported_freq
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|,
name|unsigned
name|int
name|freq
parameter_list|)
block|{
name|u8
name|op_reg_class
decl_stmt|,
name|op_channel
decl_stmt|;
if|if
condition|(
name|p2p_freq_to_channel
argument_list|(
name|p2p
operator|->
name|cfg
operator|->
name|country
argument_list|,
name|freq
argument_list|,
operator|&
name|op_reg_class
argument_list|,
operator|&
name|op_channel
argument_list|)
operator|<
literal|0
condition|)
return|return
literal|0
return|;
return|return
name|p2p_channels_includes
argument_list|(
operator|&
name|p2p
operator|->
name|cfg
operator|->
name|channels
argument_list|,
name|op_reg_class
argument_list|,
name|op_channel
argument_list|)
return|;
block|}
end_function

end_unit

