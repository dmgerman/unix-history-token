begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Wi-Fi Direct - P2P module  * Copyright (c) 2009-2010, Atheros Communications  *  * This software may be distributed under the terms of the BSD license.  * See README for more details.  */
end_comment

begin_include
include|#
directive|include
file|"includes.h"
end_include

begin_include
include|#
directive|include
file|"common.h"
end_include

begin_include
include|#
directive|include
file|"eloop.h"
end_include

begin_include
include|#
directive|include
file|"common/ieee802_11_defs.h"
end_include

begin_include
include|#
directive|include
file|"common/ieee802_11_common.h"
end_include

begin_include
include|#
directive|include
file|"common/wpa_ctrl.h"
end_include

begin_include
include|#
directive|include
file|"crypto/sha256.h"
end_include

begin_include
include|#
directive|include
file|"crypto/crypto.h"
end_include

begin_include
include|#
directive|include
file|"wps/wps_i.h"
end_include

begin_include
include|#
directive|include
file|"p2p_i.h"
end_include

begin_include
include|#
directive|include
file|"p2p.h"
end_include

begin_function_decl
specifier|static
name|void
name|p2p_state_timeout
parameter_list|(
name|void
modifier|*
name|eloop_ctx
parameter_list|,
name|void
modifier|*
name|timeout_ctx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|p2p_device_free
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|,
name|struct
name|p2p_device
modifier|*
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|p2p_process_presence_req
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|,
specifier|const
name|u8
modifier|*
name|da
parameter_list|,
specifier|const
name|u8
modifier|*
name|sa
parameter_list|,
specifier|const
name|u8
modifier|*
name|data
parameter_list|,
name|size_t
name|len
parameter_list|,
name|int
name|rx_freq
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|p2p_process_presence_resp
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|,
specifier|const
name|u8
modifier|*
name|da
parameter_list|,
specifier|const
name|u8
modifier|*
name|sa
parameter_list|,
specifier|const
name|u8
modifier|*
name|data
parameter_list|,
name|size_t
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|p2p_ext_listen_timeout
parameter_list|(
name|void
modifier|*
name|eloop_ctx
parameter_list|,
name|void
modifier|*
name|timeout_ctx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|p2p_scan_timeout
parameter_list|(
name|void
modifier|*
name|eloop_ctx
parameter_list|,
name|void
modifier|*
name|timeout_ctx
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * p2p_scan recovery timeout  *  * Many drivers are using 30 second timeout on scan results. Allow a bit larger  * timeout for this to avoid hitting P2P timeout unnecessarily.  */
end_comment

begin_define
define|#
directive|define
name|P2P_SCAN_TIMEOUT
value|35
end_define

begin_comment
comment|/**  * P2P_PEER_EXPIRATION_AGE - Number of seconds after which inactive peer  * entries will be removed  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|P2P_PEER_EXPIRATION_AGE
end_ifndef

begin_define
define|#
directive|define
name|P2P_PEER_EXPIRATION_AGE
value|60
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* P2P_PEER_EXPIRATION_AGE */
end_comment

begin_function
name|void
name|p2p_expire_peers
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|)
block|{
name|struct
name|p2p_device
modifier|*
name|dev
decl_stmt|,
modifier|*
name|n
decl_stmt|;
name|struct
name|os_reltime
name|now
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|os_get_reltime
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
name|dl_list_for_each_safe
argument_list|(
argument|dev
argument_list|,
argument|n
argument_list|,
argument|&p2p->devices
argument_list|,
argument|struct p2p_device
argument_list|,
argument|list
argument_list|)
block|{
if|if
condition|(
name|dev
operator|->
name|last_seen
operator|.
name|sec
operator|+
name|P2P_PEER_EXPIRATION_AGE
operator|>=
name|now
operator|.
name|sec
condition|)
continue|continue;
if|if
condition|(
name|dev
operator|==
name|p2p
operator|->
name|go_neg_peer
condition|)
block|{
comment|/* 			 * GO Negotiation is in progress with the peer, so 			 * don't expire the peer entry until GO Negotiation 			 * fails or times out. 			 */
continue|continue;
block|}
if|if
condition|(
name|p2p
operator|->
name|cfg
operator|->
name|go_connected
operator|&&
name|p2p
operator|->
name|cfg
operator|->
name|go_connected
argument_list|(
name|p2p
operator|->
name|cfg
operator|->
name|cb_ctx
argument_list|,
name|dev
operator|->
name|info
operator|.
name|p2p_device_addr
argument_list|)
condition|)
block|{
comment|/* 			 * We are connected as a client to a group in which the 			 * peer is the GO, so do not expire the peer entry. 			 */
name|os_get_reltime
argument_list|(
operator|&
name|dev
operator|->
name|last_seen
argument_list|)
expr_stmt|;
continue|continue;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p2p
operator|->
name|num_groups
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|p2p_group_is_client_connected
argument_list|(
name|p2p
operator|->
name|groups
index|[
name|i
index|]
argument_list|,
name|dev
operator|->
name|info
operator|.
name|p2p_device_addr
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|<
name|p2p
operator|->
name|num_groups
condition|)
block|{
comment|/* 			 * The peer is connected as a client in a group where 			 * we are the GO, so do not expire the peer entry. 			 */
name|os_get_reltime
argument_list|(
operator|&
name|dev
operator|->
name|last_seen
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Expiring old peer entry "
name|MACSTR
argument_list|,
name|MAC2STR
argument_list|(
name|dev
operator|->
name|info
operator|.
name|p2p_device_addr
argument_list|)
argument_list|)
expr_stmt|;
name|dl_list_del
argument_list|(
operator|&
name|dev
operator|->
name|list
argument_list|)
expr_stmt|;
name|p2p_device_free
argument_list|(
name|p2p
argument_list|,
name|dev
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|p2p_state_txt
parameter_list|(
name|int
name|state
parameter_list|)
block|{
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|P2P_IDLE
case|:
return|return
literal|"IDLE"
return|;
case|case
name|P2P_SEARCH
case|:
return|return
literal|"SEARCH"
return|;
case|case
name|P2P_CONNECT
case|:
return|return
literal|"CONNECT"
return|;
case|case
name|P2P_CONNECT_LISTEN
case|:
return|return
literal|"CONNECT_LISTEN"
return|;
case|case
name|P2P_GO_NEG
case|:
return|return
literal|"GO_NEG"
return|;
case|case
name|P2P_LISTEN_ONLY
case|:
return|return
literal|"LISTEN_ONLY"
return|;
case|case
name|P2P_WAIT_PEER_CONNECT
case|:
return|return
literal|"WAIT_PEER_CONNECT"
return|;
case|case
name|P2P_WAIT_PEER_IDLE
case|:
return|return
literal|"WAIT_PEER_IDLE"
return|;
case|case
name|P2P_SD_DURING_FIND
case|:
return|return
literal|"SD_DURING_FIND"
return|;
case|case
name|P2P_PROVISIONING
case|:
return|return
literal|"PROVISIONING"
return|;
case|case
name|P2P_PD_DURING_FIND
case|:
return|return
literal|"PD_DURING_FIND"
return|;
case|case
name|P2P_INVITE
case|:
return|return
literal|"INVITE"
return|;
case|case
name|P2P_INVITE_LISTEN
case|:
return|return
literal|"INVITE_LISTEN"
return|;
default|default:
return|return
literal|"?"
return|;
block|}
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|p2p_get_state_txt
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|)
block|{
return|return
name|p2p_state_txt
argument_list|(
name|p2p
operator|->
name|state
argument_list|)
return|;
block|}
end_function

begin_function
name|struct
name|p2ps_advertisement
modifier|*
name|p2p_get_p2ps_adv_list
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|)
block|{
return|return
name|p2p
condition|?
name|p2p
operator|->
name|p2ps_adv_list
else|:
name|NULL
return|;
block|}
end_function

begin_function
name|void
name|p2p_set_intended_addr
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|,
specifier|const
name|u8
modifier|*
name|intended_addr
parameter_list|)
block|{
if|if
condition|(
name|p2p
operator|&&
name|intended_addr
condition|)
name|os_memcpy
argument_list|(
name|p2p
operator|->
name|intended_addr
argument_list|,
name|intended_addr
argument_list|,
name|ETH_ALEN
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|u16
name|p2p_get_provisioning_info
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|,
specifier|const
name|u8
modifier|*
name|addr
parameter_list|)
block|{
name|struct
name|p2p_device
modifier|*
name|dev
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
name|addr
operator|||
operator|!
name|p2p
condition|)
return|return
literal|0
return|;
name|dev
operator|=
name|p2p_get_device
argument_list|(
name|p2p
argument_list|,
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
condition|)
return|return
name|dev
operator|->
name|wps_prov_info
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|p2p_clear_provisioning_info
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|,
specifier|const
name|u8
modifier|*
name|addr
parameter_list|)
block|{
name|struct
name|p2p_device
modifier|*
name|dev
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
name|addr
operator|||
operator|!
name|p2p
condition|)
return|return;
name|dev
operator|=
name|p2p_get_device
argument_list|(
name|p2p
argument_list|,
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
condition|)
name|dev
operator|->
name|wps_prov_info
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|p2p_set_state
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|,
name|int
name|new_state
parameter_list|)
block|{
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"State %s -> %s"
argument_list|,
name|p2p_state_txt
argument_list|(
name|p2p
operator|->
name|state
argument_list|)
argument_list|,
name|p2p_state_txt
argument_list|(
name|new_state
argument_list|)
argument_list|)
expr_stmt|;
name|p2p
operator|->
name|state
operator|=
name|new_state
expr_stmt|;
if|if
condition|(
name|new_state
operator|==
name|P2P_IDLE
operator|&&
name|p2p
operator|->
name|pending_channel
condition|)
block|{
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Apply change in listen channel"
argument_list|)
expr_stmt|;
name|p2p
operator|->
name|cfg
operator|->
name|reg_class
operator|=
name|p2p
operator|->
name|pending_reg_class
expr_stmt|;
name|p2p
operator|->
name|cfg
operator|->
name|channel
operator|=
name|p2p
operator|->
name|pending_channel
expr_stmt|;
name|p2p
operator|->
name|pending_reg_class
operator|=
literal|0
expr_stmt|;
name|p2p
operator|->
name|pending_channel
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|p2p_set_timeout
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|,
name|unsigned
name|int
name|sec
parameter_list|,
name|unsigned
name|int
name|usec
parameter_list|)
block|{
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Set timeout (state=%s): %u.%06u sec"
argument_list|,
name|p2p_state_txt
argument_list|(
name|p2p
operator|->
name|state
argument_list|)
argument_list|,
name|sec
argument_list|,
name|usec
argument_list|)
expr_stmt|;
name|eloop_cancel_timeout
argument_list|(
name|p2p_state_timeout
argument_list|,
name|p2p
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|eloop_register_timeout
argument_list|(
name|sec
argument_list|,
name|usec
argument_list|,
name|p2p_state_timeout
argument_list|,
name|p2p
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|p2p_clear_timeout
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|)
block|{
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Clear timeout (state=%s)"
argument_list|,
name|p2p_state_txt
argument_list|(
name|p2p
operator|->
name|state
argument_list|)
argument_list|)
expr_stmt|;
name|eloop_cancel_timeout
argument_list|(
name|p2p_state_timeout
argument_list|,
name|p2p
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|p2p_go_neg_failed
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|,
name|int
name|status
parameter_list|)
block|{
name|struct
name|p2p_go_neg_results
name|res
decl_stmt|;
name|struct
name|p2p_device
modifier|*
name|peer
init|=
name|p2p
operator|->
name|go_neg_peer
decl_stmt|;
if|if
condition|(
operator|!
name|peer
condition|)
return|return;
name|eloop_cancel_timeout
argument_list|(
name|p2p_go_neg_wait_timeout
argument_list|,
name|p2p
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|p2p
operator|->
name|state
operator|!=
name|P2P_SEARCH
condition|)
block|{
comment|/* 		 * Clear timeouts related to GO Negotiation if no new p2p_find 		 * has been started. 		 */
name|p2p_clear_timeout
argument_list|(
name|p2p
argument_list|)
expr_stmt|;
name|p2p_set_state
argument_list|(
name|p2p
argument_list|,
name|P2P_IDLE
argument_list|)
expr_stmt|;
block|}
name|peer
operator|->
name|flags
operator|&=
operator|~
name|P2P_DEV_PEER_WAITING_RESPONSE
expr_stmt|;
name|peer
operator|->
name|wps_method
operator|=
name|WPS_NOT_READY
expr_stmt|;
name|peer
operator|->
name|oob_pw_id
operator|=
literal|0
expr_stmt|;
name|wpabuf_free
argument_list|(
name|peer
operator|->
name|go_neg_conf
argument_list|)
expr_stmt|;
name|peer
operator|->
name|go_neg_conf
operator|=
name|NULL
expr_stmt|;
name|p2p
operator|->
name|go_neg_peer
operator|=
name|NULL
expr_stmt|;
name|os_memset
argument_list|(
operator|&
name|res
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|res
argument_list|)
argument_list|)
expr_stmt|;
name|res
operator|.
name|status
operator|=
name|status
expr_stmt|;
name|os_memcpy
argument_list|(
name|res
operator|.
name|peer_device_addr
argument_list|,
name|peer
operator|->
name|info
operator|.
name|p2p_device_addr
argument_list|,
name|ETH_ALEN
argument_list|)
expr_stmt|;
name|os_memcpy
argument_list|(
name|res
operator|.
name|peer_interface_addr
argument_list|,
name|peer
operator|->
name|intended_addr
argument_list|,
name|ETH_ALEN
argument_list|)
expr_stmt|;
name|p2p
operator|->
name|cfg
operator|->
name|go_neg_completed
argument_list|(
name|p2p
operator|->
name|cfg
operator|->
name|cb_ctx
argument_list|,
operator|&
name|res
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|p2p_listen_in_find
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|,
name|int
name|dev_disc
parameter_list|)
block|{
name|unsigned
name|int
name|r
decl_stmt|,
name|tu
decl_stmt|;
name|int
name|freq
decl_stmt|;
name|struct
name|wpabuf
modifier|*
name|ies
decl_stmt|;
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Starting short listen state (state=%s)"
argument_list|,
name|p2p_state_txt
argument_list|(
name|p2p
operator|->
name|state
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p2p
operator|->
name|pending_listen_freq
condition|)
block|{
comment|/* We have a pending p2p_listen request */
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"p2p_listen command pending already"
argument_list|)
expr_stmt|;
return|return;
block|}
name|freq
operator|=
name|p2p_channel_to_freq
argument_list|(
name|p2p
operator|->
name|cfg
operator|->
name|reg_class
argument_list|,
name|p2p
operator|->
name|cfg
operator|->
name|channel
argument_list|)
expr_stmt|;
if|if
condition|(
name|freq
operator|<
literal|0
condition|)
block|{
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Unknown regulatory class/channel"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|os_get_random
argument_list|(
operator|(
name|u8
operator|*
operator|)
operator|&
name|r
argument_list|,
sizeof|sizeof
argument_list|(
name|r
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
name|r
operator|=
literal|0
expr_stmt|;
name|tu
operator|=
operator|(
name|r
operator|%
operator|(
operator|(
name|p2p
operator|->
name|max_disc_int
operator|-
name|p2p
operator|->
name|min_disc_int
operator|)
operator|+
literal|1
operator|)
operator|+
name|p2p
operator|->
name|min_disc_int
operator|)
operator|*
literal|100
expr_stmt|;
if|if
condition|(
name|p2p
operator|->
name|max_disc_tu
operator|>=
literal|0
operator|&&
name|tu
operator|>
operator|(
name|unsigned
name|int
operator|)
name|p2p
operator|->
name|max_disc_tu
condition|)
name|tu
operator|=
name|p2p
operator|->
name|max_disc_tu
expr_stmt|;
if|if
condition|(
operator|!
name|dev_disc
operator|&&
name|tu
operator|<
literal|100
condition|)
name|tu
operator|=
literal|100
expr_stmt|;
comment|/* Need to wait in non-device discovery use cases */
if|if
condition|(
name|p2p
operator|->
name|cfg
operator|->
name|max_listen
operator|&&
literal|1024
operator|*
name|tu
operator|/
literal|1000
operator|>
name|p2p
operator|->
name|cfg
operator|->
name|max_listen
condition|)
name|tu
operator|=
name|p2p
operator|->
name|cfg
operator|->
name|max_listen
operator|*
literal|1000
operator|/
literal|1024
expr_stmt|;
if|if
condition|(
name|tu
operator|==
literal|0
condition|)
block|{
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Skip listen state since duration was 0 TU"
argument_list|)
expr_stmt|;
name|p2p_set_timeout
argument_list|(
name|p2p
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
name|ies
operator|=
name|p2p_build_probe_resp_ies
argument_list|(
name|p2p
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ies
operator|==
name|NULL
condition|)
return|return;
name|p2p
operator|->
name|pending_listen_freq
operator|=
name|freq
expr_stmt|;
name|p2p
operator|->
name|pending_listen_sec
operator|=
literal|0
expr_stmt|;
name|p2p
operator|->
name|pending_listen_usec
operator|=
literal|1024
operator|*
name|tu
expr_stmt|;
if|if
condition|(
name|p2p
operator|->
name|cfg
operator|->
name|start_listen
argument_list|(
name|p2p
operator|->
name|cfg
operator|->
name|cb_ctx
argument_list|,
name|freq
argument_list|,
literal|1024
operator|*
name|tu
operator|/
literal|1000
argument_list|,
name|ies
argument_list|)
operator|<
literal|0
condition|)
block|{
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Failed to start listen mode"
argument_list|)
expr_stmt|;
name|p2p
operator|->
name|pending_listen_freq
operator|=
literal|0
expr_stmt|;
block|}
name|wpabuf_free
argument_list|(
name|ies
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|p2p_listen
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|,
name|unsigned
name|int
name|timeout
parameter_list|)
block|{
name|int
name|freq
decl_stmt|;
name|struct
name|wpabuf
modifier|*
name|ies
decl_stmt|;
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Going to listen(only) state"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p2p
operator|->
name|pending_listen_freq
condition|)
block|{
comment|/* We have a pending p2p_listen request */
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"p2p_listen command pending already"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|freq
operator|=
name|p2p_channel_to_freq
argument_list|(
name|p2p
operator|->
name|cfg
operator|->
name|reg_class
argument_list|,
name|p2p
operator|->
name|cfg
operator|->
name|channel
argument_list|)
expr_stmt|;
if|if
condition|(
name|freq
operator|<
literal|0
condition|)
block|{
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Unknown regulatory class/channel"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|p2p
operator|->
name|pending_listen_sec
operator|=
name|timeout
operator|/
literal|1000
expr_stmt|;
name|p2p
operator|->
name|pending_listen_usec
operator|=
operator|(
name|timeout
operator|%
literal|1000
operator|)
operator|*
literal|1000
expr_stmt|;
if|if
condition|(
name|p2p
operator|->
name|p2p_scan_running
condition|)
block|{
if|if
condition|(
name|p2p
operator|->
name|start_after_scan
operator|==
name|P2P_AFTER_SCAN_CONNECT
condition|)
block|{
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"p2p_scan running - connect is already pending - skip listen"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"p2p_scan running - delay start of listen state"
argument_list|)
expr_stmt|;
name|p2p
operator|->
name|start_after_scan
operator|=
name|P2P_AFTER_SCAN_LISTEN
expr_stmt|;
return|return
literal|0
return|;
block|}
name|ies
operator|=
name|p2p_build_probe_resp_ies
argument_list|(
name|p2p
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ies
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|p2p
operator|->
name|pending_listen_freq
operator|=
name|freq
expr_stmt|;
if|if
condition|(
name|p2p
operator|->
name|cfg
operator|->
name|start_listen
argument_list|(
name|p2p
operator|->
name|cfg
operator|->
name|cb_ctx
argument_list|,
name|freq
argument_list|,
name|timeout
argument_list|,
name|ies
argument_list|)
operator|<
literal|0
condition|)
block|{
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Failed to start listen mode"
argument_list|)
expr_stmt|;
name|p2p
operator|->
name|pending_listen_freq
operator|=
literal|0
expr_stmt|;
name|wpabuf_free
argument_list|(
name|ies
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|wpabuf_free
argument_list|(
name|ies
argument_list|)
expr_stmt|;
name|p2p_set_state
argument_list|(
name|p2p
argument_list|,
name|P2P_LISTEN_ONLY
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|p2p_device_clear_reported
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|)
block|{
name|struct
name|p2p_device
modifier|*
name|dev
decl_stmt|;
name|dl_list_for_each
argument_list|(
argument|dev
argument_list|,
argument|&p2p->devices
argument_list|,
argument|struct p2p_device
argument_list|,
argument|list
argument_list|)
block|{
name|dev
operator|->
name|flags
operator|&=
operator|~
name|P2P_DEV_REPORTED
expr_stmt|;
name|dev
operator|->
name|sd_reqs
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * p2p_get_device - Fetch a peer entry  * @p2p: P2P module context from p2p_init()  * @addr: P2P Device Address of the peer  * Returns: Pointer to the device entry or %NULL if not found  */
end_comment

begin_function
name|struct
name|p2p_device
modifier|*
name|p2p_get_device
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|,
specifier|const
name|u8
modifier|*
name|addr
parameter_list|)
block|{
name|struct
name|p2p_device
modifier|*
name|dev
decl_stmt|;
name|dl_list_for_each
argument_list|(
argument|dev
argument_list|,
argument|&p2p->devices
argument_list|,
argument|struct p2p_device
argument_list|,
argument|list
argument_list|)
block|{
if|if
condition|(
name|os_memcmp
argument_list|(
name|dev
operator|->
name|info
operator|.
name|p2p_device_addr
argument_list|,
name|addr
argument_list|,
name|ETH_ALEN
argument_list|)
operator|==
literal|0
condition|)
return|return
name|dev
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/**  * p2p_get_device_interface - Fetch a peer entry based on P2P Interface Address  * @p2p: P2P module context from p2p_init()  * @addr: P2P Interface Address of the peer  * Returns: Pointer to the device entry or %NULL if not found  */
end_comment

begin_function
name|struct
name|p2p_device
modifier|*
name|p2p_get_device_interface
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|,
specifier|const
name|u8
modifier|*
name|addr
parameter_list|)
block|{
name|struct
name|p2p_device
modifier|*
name|dev
decl_stmt|;
name|dl_list_for_each
argument_list|(
argument|dev
argument_list|,
argument|&p2p->devices
argument_list|,
argument|struct p2p_device
argument_list|,
argument|list
argument_list|)
block|{
if|if
condition|(
name|os_memcmp
argument_list|(
name|dev
operator|->
name|interface_addr
argument_list|,
name|addr
argument_list|,
name|ETH_ALEN
argument_list|)
operator|==
literal|0
condition|)
return|return
name|dev
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/**  * p2p_create_device - Create a peer entry  * @p2p: P2P module context from p2p_init()  * @addr: P2P Device Address of the peer  * Returns: Pointer to the device entry or %NULL on failure  *  * If there is already an entry for the peer, it will be returned instead of  * creating a new one.  */
end_comment

begin_function
specifier|static
name|struct
name|p2p_device
modifier|*
name|p2p_create_device
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|,
specifier|const
name|u8
modifier|*
name|addr
parameter_list|)
block|{
name|struct
name|p2p_device
modifier|*
name|dev
decl_stmt|,
modifier|*
name|oldest
init|=
name|NULL
decl_stmt|;
name|size_t
name|count
init|=
literal|0
decl_stmt|;
name|dev
operator|=
name|p2p_get_device
argument_list|(
name|p2p
argument_list|,
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
condition|)
return|return
name|dev
return|;
name|dl_list_for_each
argument_list|(
argument|dev
argument_list|,
argument|&p2p->devices
argument_list|,
argument|struct p2p_device
argument_list|,
argument|list
argument_list|)
block|{
name|count
operator|++
expr_stmt|;
if|if
condition|(
name|oldest
operator|==
name|NULL
operator|||
name|os_reltime_before
argument_list|(
operator|&
name|dev
operator|->
name|last_seen
argument_list|,
operator|&
name|oldest
operator|->
name|last_seen
argument_list|)
condition|)
name|oldest
operator|=
name|dev
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|+
literal|1
operator|>
name|p2p
operator|->
name|cfg
operator|->
name|max_peers
operator|&&
name|oldest
condition|)
block|{
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Remove oldest peer entry to make room for a new peer"
argument_list|)
expr_stmt|;
name|dl_list_del
argument_list|(
operator|&
name|oldest
operator|->
name|list
argument_list|)
expr_stmt|;
name|p2p_device_free
argument_list|(
name|p2p
argument_list|,
name|oldest
argument_list|)
expr_stmt|;
block|}
name|dev
operator|=
name|os_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|dev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|dl_list_add
argument_list|(
operator|&
name|p2p
operator|->
name|devices
argument_list|,
operator|&
name|dev
operator|->
name|list
argument_list|)
expr_stmt|;
name|os_memcpy
argument_list|(
name|dev
operator|->
name|info
operator|.
name|p2p_device_addr
argument_list|,
name|addr
argument_list|,
name|ETH_ALEN
argument_list|)
expr_stmt|;
return|return
name|dev
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|p2p_copy_client_info
parameter_list|(
name|struct
name|p2p_device
modifier|*
name|dev
parameter_list|,
name|struct
name|p2p_client_info
modifier|*
name|cli
parameter_list|)
block|{
name|os_memcpy
argument_list|(
name|dev
operator|->
name|info
operator|.
name|device_name
argument_list|,
name|cli
operator|->
name|dev_name
argument_list|,
name|cli
operator|->
name|dev_name_len
argument_list|)
expr_stmt|;
name|dev
operator|->
name|info
operator|.
name|device_name
index|[
name|cli
operator|->
name|dev_name_len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|dev
operator|->
name|info
operator|.
name|dev_capab
operator|=
name|cli
operator|->
name|dev_capab
expr_stmt|;
name|dev
operator|->
name|info
operator|.
name|config_methods
operator|=
name|cli
operator|->
name|config_methods
expr_stmt|;
name|os_memcpy
argument_list|(
name|dev
operator|->
name|info
operator|.
name|pri_dev_type
argument_list|,
name|cli
operator|->
name|pri_dev_type
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|dev
operator|->
name|info
operator|.
name|wps_sec_dev_type_list_len
operator|=
literal|8
operator|*
name|cli
operator|->
name|num_sec_dev_types
expr_stmt|;
name|os_memcpy
argument_list|(
name|dev
operator|->
name|info
operator|.
name|wps_sec_dev_type_list
argument_list|,
name|cli
operator|->
name|sec_dev_types
argument_list|,
name|dev
operator|->
name|info
operator|.
name|wps_sec_dev_type_list_len
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|p2p_add_group_clients
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|,
specifier|const
name|u8
modifier|*
name|go_dev_addr
parameter_list|,
specifier|const
name|u8
modifier|*
name|go_interface_addr
parameter_list|,
name|int
name|freq
parameter_list|,
specifier|const
name|u8
modifier|*
name|gi
parameter_list|,
name|size_t
name|gi_len
parameter_list|,
name|struct
name|os_reltime
modifier|*
name|rx_time
parameter_list|)
block|{
name|struct
name|p2p_group_info
name|info
decl_stmt|;
name|size_t
name|c
decl_stmt|;
name|struct
name|p2p_device
modifier|*
name|dev
decl_stmt|;
if|if
condition|(
name|gi
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|p2p_group_info_parse
argument_list|(
name|gi
argument_list|,
name|gi_len
argument_list|,
operator|&
name|info
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
comment|/* 	 * Clear old data for this group; if the devices are still in the 	 * group, the information will be restored in the loop following this. 	 */
name|dl_list_for_each
argument_list|(
argument|dev
argument_list|,
argument|&p2p->devices
argument_list|,
argument|struct p2p_device
argument_list|,
argument|list
argument_list|)
block|{
if|if
condition|(
name|os_memcmp
argument_list|(
name|dev
operator|->
name|member_in_go_iface
argument_list|,
name|go_interface_addr
argument_list|,
name|ETH_ALEN
argument_list|)
operator|==
literal|0
condition|)
block|{
name|os_memset
argument_list|(
name|dev
operator|->
name|member_in_go_iface
argument_list|,
literal|0
argument_list|,
name|ETH_ALEN
argument_list|)
expr_stmt|;
name|os_memset
argument_list|(
name|dev
operator|->
name|member_in_go_dev
argument_list|,
literal|0
argument_list|,
name|ETH_ALEN
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|info
operator|.
name|num_clients
condition|;
name|c
operator|++
control|)
block|{
name|struct
name|p2p_client_info
modifier|*
name|cli
init|=
operator|&
name|info
operator|.
name|client
index|[
name|c
index|]
decl_stmt|;
if|if
condition|(
name|os_memcmp
argument_list|(
name|cli
operator|->
name|p2p_device_addr
argument_list|,
name|p2p
operator|->
name|cfg
operator|->
name|dev_addr
argument_list|,
name|ETH_ALEN
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
comment|/* ignore our own entry */
name|dev
operator|=
name|p2p_get_device
argument_list|(
name|p2p
argument_list|,
name|cli
operator|->
name|p2p_device_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
condition|)
block|{
if|if
condition|(
name|dev
operator|->
name|flags
operator|&
operator|(
name|P2P_DEV_GROUP_CLIENT_ONLY
operator||
name|P2P_DEV_PROBE_REQ_ONLY
operator|)
condition|)
block|{
comment|/* 				 * Update information since we have not 				 * received this directly from the client. 				 */
name|p2p_copy_client_info
argument_list|(
name|dev
argument_list|,
name|cli
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * Need to update P2P Client Discoverability 				 * flag since it is valid only in P2P Group 				 * Info attribute. 				 */
name|dev
operator|->
name|info
operator|.
name|dev_capab
operator|&=
operator|~
name|P2P_DEV_CAPAB_CLIENT_DISCOVERABILITY
expr_stmt|;
name|dev
operator|->
name|info
operator|.
name|dev_capab
operator||=
name|cli
operator|->
name|dev_capab
operator|&
name|P2P_DEV_CAPAB_CLIENT_DISCOVERABILITY
expr_stmt|;
block|}
if|if
condition|(
name|dev
operator|->
name|flags
operator|&
name|P2P_DEV_PROBE_REQ_ONLY
condition|)
block|{
name|dev
operator|->
name|flags
operator|&=
operator|~
name|P2P_DEV_PROBE_REQ_ONLY
expr_stmt|;
block|}
block|}
else|else
block|{
name|dev
operator|=
name|p2p_create_device
argument_list|(
name|p2p
argument_list|,
name|cli
operator|->
name|p2p_device_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|==
name|NULL
condition|)
continue|continue;
name|dev
operator|->
name|flags
operator||=
name|P2P_DEV_GROUP_CLIENT_ONLY
expr_stmt|;
name|p2p_copy_client_info
argument_list|(
name|dev
argument_list|,
name|cli
argument_list|)
expr_stmt|;
name|dev
operator|->
name|oper_freq
operator|=
name|freq
expr_stmt|;
name|p2p
operator|->
name|cfg
operator|->
name|dev_found
argument_list|(
name|p2p
operator|->
name|cfg
operator|->
name|cb_ctx
argument_list|,
name|dev
operator|->
name|info
operator|.
name|p2p_device_addr
argument_list|,
operator|&
name|dev
operator|->
name|info
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|dev
operator|->
name|flags
operator||=
name|P2P_DEV_REPORTED
operator||
name|P2P_DEV_REPORTED_ONCE
expr_stmt|;
block|}
name|os_memcpy
argument_list|(
name|dev
operator|->
name|interface_addr
argument_list|,
name|cli
operator|->
name|p2p_interface_addr
argument_list|,
name|ETH_ALEN
argument_list|)
expr_stmt|;
name|os_memcpy
argument_list|(
operator|&
name|dev
operator|->
name|last_seen
argument_list|,
name|rx_time
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|os_reltime
argument_list|)
argument_list|)
expr_stmt|;
name|os_memcpy
argument_list|(
name|dev
operator|->
name|member_in_go_dev
argument_list|,
name|go_dev_addr
argument_list|,
name|ETH_ALEN
argument_list|)
expr_stmt|;
name|os_memcpy
argument_list|(
name|dev
operator|->
name|member_in_go_iface
argument_list|,
name|go_interface_addr
argument_list|,
name|ETH_ALEN
argument_list|)
expr_stmt|;
name|dev
operator|->
name|flags
operator||=
name|P2P_DEV_LAST_SEEN_AS_GROUP_CLIENT
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|p2p_copy_wps_info
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|,
name|struct
name|p2p_device
modifier|*
name|dev
parameter_list|,
name|int
name|probe_req
parameter_list|,
specifier|const
name|struct
name|p2p_message
modifier|*
name|msg
parameter_list|)
block|{
name|os_memcpy
argument_list|(
name|dev
operator|->
name|info
operator|.
name|device_name
argument_list|,
name|msg
operator|->
name|device_name
argument_list|,
sizeof|sizeof
argument_list|(
name|dev
operator|->
name|info
operator|.
name|device_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
operator|->
name|manufacturer
operator|&&
name|msg
operator|->
name|manufacturer_len
operator|<
sizeof|sizeof
argument_list|(
name|dev
operator|->
name|info
operator|.
name|manufacturer
argument_list|)
condition|)
block|{
name|os_memset
argument_list|(
name|dev
operator|->
name|info
operator|.
name|manufacturer
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|dev
operator|->
name|info
operator|.
name|manufacturer
argument_list|)
argument_list|)
expr_stmt|;
name|os_memcpy
argument_list|(
name|dev
operator|->
name|info
operator|.
name|manufacturer
argument_list|,
name|msg
operator|->
name|manufacturer
argument_list|,
name|msg
operator|->
name|manufacturer_len
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|msg
operator|->
name|model_name
operator|&&
name|msg
operator|->
name|model_name_len
operator|<
sizeof|sizeof
argument_list|(
name|dev
operator|->
name|info
operator|.
name|model_name
argument_list|)
condition|)
block|{
name|os_memset
argument_list|(
name|dev
operator|->
name|info
operator|.
name|model_name
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|dev
operator|->
name|info
operator|.
name|model_name
argument_list|)
argument_list|)
expr_stmt|;
name|os_memcpy
argument_list|(
name|dev
operator|->
name|info
operator|.
name|model_name
argument_list|,
name|msg
operator|->
name|model_name
argument_list|,
name|msg
operator|->
name|model_name_len
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|msg
operator|->
name|model_number
operator|&&
name|msg
operator|->
name|model_number_len
operator|<
sizeof|sizeof
argument_list|(
name|dev
operator|->
name|info
operator|.
name|model_number
argument_list|)
condition|)
block|{
name|os_memset
argument_list|(
name|dev
operator|->
name|info
operator|.
name|model_number
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|dev
operator|->
name|info
operator|.
name|model_number
argument_list|)
argument_list|)
expr_stmt|;
name|os_memcpy
argument_list|(
name|dev
operator|->
name|info
operator|.
name|model_number
argument_list|,
name|msg
operator|->
name|model_number
argument_list|,
name|msg
operator|->
name|model_number_len
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|msg
operator|->
name|serial_number
operator|&&
name|msg
operator|->
name|serial_number_len
operator|<
sizeof|sizeof
argument_list|(
name|dev
operator|->
name|info
operator|.
name|serial_number
argument_list|)
condition|)
block|{
name|os_memset
argument_list|(
name|dev
operator|->
name|info
operator|.
name|serial_number
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|dev
operator|->
name|info
operator|.
name|serial_number
argument_list|)
argument_list|)
expr_stmt|;
name|os_memcpy
argument_list|(
name|dev
operator|->
name|info
operator|.
name|serial_number
argument_list|,
name|msg
operator|->
name|serial_number
argument_list|,
name|msg
operator|->
name|serial_number_len
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|msg
operator|->
name|pri_dev_type
condition|)
name|os_memcpy
argument_list|(
name|dev
operator|->
name|info
operator|.
name|pri_dev_type
argument_list|,
name|msg
operator|->
name|pri_dev_type
argument_list|,
sizeof|sizeof
argument_list|(
name|dev
operator|->
name|info
operator|.
name|pri_dev_type
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|msg
operator|->
name|wps_pri_dev_type
condition|)
name|os_memcpy
argument_list|(
name|dev
operator|->
name|info
operator|.
name|pri_dev_type
argument_list|,
name|msg
operator|->
name|wps_pri_dev_type
argument_list|,
sizeof|sizeof
argument_list|(
name|dev
operator|->
name|info
operator|.
name|pri_dev_type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
operator|->
name|wps_sec_dev_type_list
condition|)
block|{
name|os_memcpy
argument_list|(
name|dev
operator|->
name|info
operator|.
name|wps_sec_dev_type_list
argument_list|,
name|msg
operator|->
name|wps_sec_dev_type_list
argument_list|,
name|msg
operator|->
name|wps_sec_dev_type_list_len
argument_list|)
expr_stmt|;
name|dev
operator|->
name|info
operator|.
name|wps_sec_dev_type_list_len
operator|=
name|msg
operator|->
name|wps_sec_dev_type_list_len
expr_stmt|;
block|}
if|if
condition|(
name|msg
operator|->
name|capability
condition|)
block|{
comment|/* 		 * P2P Client Discoverability bit is reserved in all frames 		 * that use this function, so do not change its value here. 		 */
name|dev
operator|->
name|info
operator|.
name|dev_capab
operator|&=
name|P2P_DEV_CAPAB_CLIENT_DISCOVERABILITY
expr_stmt|;
name|dev
operator|->
name|info
operator|.
name|dev_capab
operator||=
name|msg
operator|->
name|capability
index|[
literal|0
index|]
operator|&
operator|~
name|P2P_DEV_CAPAB_CLIENT_DISCOVERABILITY
expr_stmt|;
name|dev
operator|->
name|info
operator|.
name|group_capab
operator|=
name|msg
operator|->
name|capability
index|[
literal|1
index|]
expr_stmt|;
block|}
if|if
condition|(
name|msg
operator|->
name|ext_listen_timing
condition|)
block|{
name|dev
operator|->
name|ext_listen_period
operator|=
name|WPA_GET_LE16
argument_list|(
name|msg
operator|->
name|ext_listen_timing
argument_list|)
expr_stmt|;
name|dev
operator|->
name|ext_listen_interval
operator|=
name|WPA_GET_LE16
argument_list|(
name|msg
operator|->
name|ext_listen_timing
operator|+
literal|2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|probe_req
condition|)
block|{
name|u16
name|new_config_methods
decl_stmt|;
name|new_config_methods
operator|=
name|msg
operator|->
name|config_methods
condition|?
name|msg
operator|->
name|config_methods
else|:
name|msg
operator|->
name|wps_config_methods
expr_stmt|;
if|if
condition|(
name|new_config_methods
operator|&&
name|dev
operator|->
name|info
operator|.
name|config_methods
operator|!=
name|new_config_methods
condition|)
block|{
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Update peer "
name|MACSTR
literal|" config_methods 0x%x -> 0x%x"
argument_list|,
name|MAC2STR
argument_list|(
name|dev
operator|->
name|info
operator|.
name|p2p_device_addr
argument_list|)
argument_list|,
name|dev
operator|->
name|info
operator|.
name|config_methods
argument_list|,
name|new_config_methods
argument_list|)
expr_stmt|;
name|dev
operator|->
name|info
operator|.
name|config_methods
operator|=
name|new_config_methods
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|p2p_update_peer_vendor_elems
parameter_list|(
name|struct
name|p2p_device
modifier|*
name|dev
parameter_list|,
specifier|const
name|u8
modifier|*
name|ies
parameter_list|,
name|size_t
name|ies_len
parameter_list|)
block|{
specifier|const
name|u8
modifier|*
name|pos
decl_stmt|,
modifier|*
name|end
decl_stmt|;
name|u8
name|id
decl_stmt|,
name|len
decl_stmt|;
name|wpabuf_free
argument_list|(
name|dev
operator|->
name|info
operator|.
name|vendor_elems
argument_list|)
expr_stmt|;
name|dev
operator|->
name|info
operator|.
name|vendor_elems
operator|=
name|NULL
expr_stmt|;
name|end
operator|=
name|ies
operator|+
name|ies_len
expr_stmt|;
for|for
control|(
name|pos
operator|=
name|ies
init|;
name|pos
operator|+
literal|1
operator|<
name|end
condition|;
name|pos
operator|+=
name|len
control|)
block|{
name|id
operator|=
operator|*
name|pos
operator|++
expr_stmt|;
name|len
operator|=
operator|*
name|pos
operator|++
expr_stmt|;
if|if
condition|(
name|pos
operator|+
name|len
operator|>
name|end
condition|)
break|break;
if|if
condition|(
name|id
operator|!=
name|WLAN_EID_VENDOR_SPECIFIC
operator|||
name|len
operator|<
literal|3
condition|)
continue|continue;
if|if
condition|(
name|len
operator|>=
literal|4
condition|)
block|{
name|u32
name|type
init|=
name|WPA_GET_BE32
argument_list|(
name|pos
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|WPA_IE_VENDOR_TYPE
operator|||
name|type
operator|==
name|WMM_IE_VENDOR_TYPE
operator|||
name|type
operator|==
name|WPS_IE_VENDOR_TYPE
operator|||
name|type
operator|==
name|P2P_IE_VENDOR_TYPE
operator|||
name|type
operator|==
name|WFD_IE_VENDOR_TYPE
condition|)
continue|continue;
block|}
comment|/* Unknown vendor element - make raw IE data available */
if|if
condition|(
name|wpabuf_resize
argument_list|(
operator|&
name|dev
operator|->
name|info
operator|.
name|vendor_elems
argument_list|,
literal|2
operator|+
name|len
argument_list|)
operator|<
literal|0
condition|)
break|break;
name|wpabuf_put_data
argument_list|(
name|dev
operator|->
name|info
operator|.
name|vendor_elems
argument_list|,
name|pos
operator|-
literal|2
argument_list|,
literal|2
operator|+
name|len
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|p2p_compare_wfd_info
parameter_list|(
name|struct
name|p2p_device
modifier|*
name|dev
parameter_list|,
specifier|const
name|struct
name|p2p_message
modifier|*
name|msg
parameter_list|)
block|{
if|if
condition|(
name|dev
operator|->
name|info
operator|.
name|wfd_subelems
operator|&&
name|msg
operator|->
name|wfd_subelems
condition|)
block|{
if|if
condition|(
name|dev
operator|->
name|info
operator|.
name|wfd_subelems
operator|->
name|used
operator|!=
name|msg
operator|->
name|wfd_subelems
operator|->
name|used
condition|)
return|return
literal|1
return|;
return|return
name|os_memcmp
argument_list|(
name|dev
operator|->
name|info
operator|.
name|wfd_subelems
operator|->
name|buf
argument_list|,
name|msg
operator|->
name|wfd_subelems
operator|->
name|buf
argument_list|,
name|dev
operator|->
name|info
operator|.
name|wfd_subelems
operator|->
name|used
argument_list|)
return|;
block|}
if|if
condition|(
name|dev
operator|->
name|info
operator|.
name|wfd_subelems
operator|||
name|msg
operator|->
name|wfd_subelems
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * p2p_add_device - Add peer entries based on scan results or P2P frames  * @p2p: P2P module context from p2p_init()  * @addr: Source address of Beacon or Probe Response frame (may be either  *	P2P Device Address or P2P Interface Address)  * @level: Signal level (signal strength of the received frame from the peer)  * @freq: Frequency on which the Beacon or Probe Response frame was received  * @rx_time: Time when the result was received  * @ies: IEs from the Beacon or Probe Response frame  * @ies_len: Length of ies buffer in octets  * @scan_res: Whether this was based on scan results  * Returns: 0 on success, -1 on failure  *  * If the scan result is for a GO, the clients in the group will also be added  * to the peer table. This function can also be used with some other frames  * like Provision Discovery Request that contains P2P Capability and P2P Device  * Info attributes.  */
end_comment

begin_function
name|int
name|p2p_add_device
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|,
specifier|const
name|u8
modifier|*
name|addr
parameter_list|,
name|int
name|freq
parameter_list|,
name|struct
name|os_reltime
modifier|*
name|rx_time
parameter_list|,
name|int
name|level
parameter_list|,
specifier|const
name|u8
modifier|*
name|ies
parameter_list|,
name|size_t
name|ies_len
parameter_list|,
name|int
name|scan_res
parameter_list|)
block|{
name|struct
name|p2p_device
modifier|*
name|dev
decl_stmt|;
name|struct
name|p2p_message
name|msg
decl_stmt|;
specifier|const
name|u8
modifier|*
name|p2p_dev_addr
decl_stmt|;
name|int
name|wfd_changed
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|os_reltime
name|time_now
decl_stmt|;
name|os_memset
argument_list|(
operator|&
name|msg
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p2p_parse_ies
argument_list|(
name|ies
argument_list|,
name|ies_len
argument_list|,
operator|&
name|msg
argument_list|)
condition|)
block|{
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Failed to parse P2P IE for a device entry"
argument_list|)
expr_stmt|;
name|p2p_parse_free
argument_list|(
operator|&
name|msg
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|msg
operator|.
name|p2p_device_addr
condition|)
name|p2p_dev_addr
operator|=
name|msg
operator|.
name|p2p_device_addr
expr_stmt|;
elseif|else
if|if
condition|(
name|msg
operator|.
name|device_id
condition|)
name|p2p_dev_addr
operator|=
name|msg
operator|.
name|device_id
expr_stmt|;
else|else
block|{
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Ignore scan data without P2P Device Info or P2P Device Id"
argument_list|)
expr_stmt|;
name|p2p_parse_free
argument_list|(
operator|&
name|msg
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
operator|!
name|is_zero_ether_addr
argument_list|(
name|p2p
operator|->
name|peer_filter
argument_list|)
operator|&&
name|os_memcmp
argument_list|(
name|p2p_dev_addr
argument_list|,
name|p2p
operator|->
name|peer_filter
argument_list|,
name|ETH_ALEN
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Do not add peer filter for "
name|MACSTR
literal|" due to peer filter"
argument_list|,
name|MAC2STR
argument_list|(
name|p2p_dev_addr
argument_list|)
argument_list|)
expr_stmt|;
name|p2p_parse_free
argument_list|(
operator|&
name|msg
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|dev
operator|=
name|p2p_create_device
argument_list|(
name|p2p
argument_list|,
name|p2p_dev_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|==
name|NULL
condition|)
block|{
name|p2p_parse_free
argument_list|(
operator|&
name|msg
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|rx_time
operator|==
name|NULL
condition|)
block|{
name|os_get_reltime
argument_list|(
operator|&
name|time_now
argument_list|)
expr_stmt|;
name|rx_time
operator|=
operator|&
name|time_now
expr_stmt|;
block|}
comment|/* 	 * Update the device entry only if the new peer 	 * entry is newer than the one previously stored, or if 	 * the device was previously seen as a P2P Client in a group 	 * and the new entry isn't older than a threshold. 	 */
if|if
condition|(
name|dev
operator|->
name|last_seen
operator|.
name|sec
operator|>
literal|0
operator|&&
name|os_reltime_before
argument_list|(
name|rx_time
argument_list|,
operator|&
name|dev
operator|->
name|last_seen
argument_list|)
operator|&&
operator|(
operator|!
operator|(
name|dev
operator|->
name|flags
operator|&
name|P2P_DEV_LAST_SEEN_AS_GROUP_CLIENT
operator|)
operator|||
name|os_reltime_expired
argument_list|(
operator|&
name|dev
operator|->
name|last_seen
argument_list|,
name|rx_time
argument_list|,
name|P2P_DEV_GROUP_CLIENT_RESP_THRESHOLD
argument_list|)
operator|)
condition|)
block|{
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Do not update peer entry based on old frame (rx_time=%u.%06u last_seen=%u.%06u flags=0x%x)"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|rx_time
operator|->
name|sec
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|rx_time
operator|->
name|usec
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|dev
operator|->
name|last_seen
operator|.
name|sec
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|dev
operator|->
name|last_seen
operator|.
name|usec
argument_list|,
name|dev
operator|->
name|flags
argument_list|)
expr_stmt|;
name|p2p_parse_free
argument_list|(
operator|&
name|msg
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|os_memcpy
argument_list|(
operator|&
name|dev
operator|->
name|last_seen
argument_list|,
name|rx_time
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|os_reltime
argument_list|)
argument_list|)
expr_stmt|;
name|dev
operator|->
name|flags
operator|&=
operator|~
operator|(
name|P2P_DEV_PROBE_REQ_ONLY
operator||
name|P2P_DEV_GROUP_CLIENT_ONLY
operator||
name|P2P_DEV_LAST_SEEN_AS_GROUP_CLIENT
operator|)
expr_stmt|;
if|if
condition|(
name|os_memcmp
argument_list|(
name|addr
argument_list|,
name|p2p_dev_addr
argument_list|,
name|ETH_ALEN
argument_list|)
operator|!=
literal|0
condition|)
name|os_memcpy
argument_list|(
name|dev
operator|->
name|interface_addr
argument_list|,
name|addr
argument_list|,
name|ETH_ALEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
operator|.
name|ssid
operator|&&
name|msg
operator|.
name|ssid
index|[
literal|1
index|]
operator|<=
sizeof|sizeof
argument_list|(
name|dev
operator|->
name|oper_ssid
argument_list|)
operator|&&
operator|(
name|msg
operator|.
name|ssid
index|[
literal|1
index|]
operator|!=
name|P2P_WILDCARD_SSID_LEN
operator|||
name|os_memcmp
argument_list|(
name|msg
operator|.
name|ssid
operator|+
literal|2
argument_list|,
name|P2P_WILDCARD_SSID
argument_list|,
name|P2P_WILDCARD_SSID_LEN
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|os_memcpy
argument_list|(
name|dev
operator|->
name|oper_ssid
argument_list|,
name|msg
operator|.
name|ssid
operator|+
literal|2
argument_list|,
name|msg
operator|.
name|ssid
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|dev
operator|->
name|oper_ssid_len
operator|=
name|msg
operator|.
name|ssid
index|[
literal|1
index|]
expr_stmt|;
block|}
if|if
condition|(
name|msg
operator|.
name|adv_service_instance
operator|&&
name|msg
operator|.
name|adv_service_instance_len
condition|)
block|{
name|wpabuf_free
argument_list|(
name|dev
operator|->
name|info
operator|.
name|p2ps_instance
argument_list|)
expr_stmt|;
name|dev
operator|->
name|info
operator|.
name|p2ps_instance
operator|=
name|wpabuf_alloc_copy
argument_list|(
name|msg
operator|.
name|adv_service_instance
argument_list|,
name|msg
operator|.
name|adv_service_instance_len
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|freq
operator|>=
literal|2412
operator|&&
name|freq
operator|<=
literal|2484
operator|&&
name|msg
operator|.
name|ds_params
operator|&&
operator|*
name|msg
operator|.
name|ds_params
operator|>=
literal|1
operator|&&
operator|*
name|msg
operator|.
name|ds_params
operator|<=
literal|14
condition|)
block|{
name|int
name|ds_freq
decl_stmt|;
if|if
condition|(
operator|*
name|msg
operator|.
name|ds_params
operator|==
literal|14
condition|)
name|ds_freq
operator|=
literal|2484
expr_stmt|;
else|else
name|ds_freq
operator|=
literal|2407
operator|+
operator|*
name|msg
operator|.
name|ds_params
operator|*
literal|5
expr_stmt|;
if|if
condition|(
name|freq
operator|!=
name|ds_freq
condition|)
block|{
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Update Listen frequency based on DS Parameter Set IE: %d -> %d MHz"
argument_list|,
name|freq
argument_list|,
name|ds_freq
argument_list|)
expr_stmt|;
name|freq
operator|=
name|ds_freq
expr_stmt|;
block|}
block|}
if|if
condition|(
name|dev
operator|->
name|listen_freq
operator|&&
name|dev
operator|->
name|listen_freq
operator|!=
name|freq
operator|&&
name|scan_res
condition|)
block|{
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Update Listen frequency based on scan results ("
name|MACSTR
literal|" %d -> %d MHz (DS param %d)"
argument_list|,
name|MAC2STR
argument_list|(
name|dev
operator|->
name|info
operator|.
name|p2p_device_addr
argument_list|)
argument_list|,
name|dev
operator|->
name|listen_freq
argument_list|,
name|freq
argument_list|,
name|msg
operator|.
name|ds_params
condition|?
operator|*
name|msg
operator|.
name|ds_params
else|:
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|scan_res
condition|)
block|{
name|dev
operator|->
name|listen_freq
operator|=
name|freq
expr_stmt|;
if|if
condition|(
name|msg
operator|.
name|group_info
condition|)
name|dev
operator|->
name|oper_freq
operator|=
name|freq
expr_stmt|;
block|}
name|dev
operator|->
name|info
operator|.
name|level
operator|=
name|level
expr_stmt|;
name|p2p_copy_wps_info
argument_list|(
name|p2p
argument_list|,
name|dev
argument_list|,
literal|0
argument_list|,
operator|&
name|msg
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|P2P_MAX_WPS_VENDOR_EXT
condition|;
name|i
operator|++
control|)
block|{
name|wpabuf_free
argument_list|(
name|dev
operator|->
name|info
operator|.
name|wps_vendor_ext
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|dev
operator|->
name|info
operator|.
name|wps_vendor_ext
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|P2P_MAX_WPS_VENDOR_EXT
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|msg
operator|.
name|wps_vendor_ext
index|[
name|i
index|]
operator|==
name|NULL
condition|)
break|break;
name|dev
operator|->
name|info
operator|.
name|wps_vendor_ext
index|[
name|i
index|]
operator|=
name|wpabuf_alloc_copy
argument_list|(
name|msg
operator|.
name|wps_vendor_ext
index|[
name|i
index|]
argument_list|,
name|msg
operator|.
name|wps_vendor_ext_len
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|info
operator|.
name|wps_vendor_ext
index|[
name|i
index|]
operator|==
name|NULL
condition|)
break|break;
block|}
name|wfd_changed
operator|=
name|p2p_compare_wfd_info
argument_list|(
name|dev
argument_list|,
operator|&
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
operator|.
name|wfd_subelems
condition|)
block|{
name|wpabuf_free
argument_list|(
name|dev
operator|->
name|info
operator|.
name|wfd_subelems
argument_list|)
expr_stmt|;
name|dev
operator|->
name|info
operator|.
name|wfd_subelems
operator|=
name|wpabuf_dup
argument_list|(
name|msg
operator|.
name|wfd_subelems
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|scan_res
condition|)
block|{
name|p2p_add_group_clients
argument_list|(
name|p2p
argument_list|,
name|p2p_dev_addr
argument_list|,
name|addr
argument_list|,
name|freq
argument_list|,
name|msg
operator|.
name|group_info
argument_list|,
name|msg
operator|.
name|group_info_len
argument_list|,
name|rx_time
argument_list|)
expr_stmt|;
block|}
name|p2p_parse_free
argument_list|(
operator|&
name|msg
argument_list|)
expr_stmt|;
name|p2p_update_peer_vendor_elems
argument_list|(
name|dev
argument_list|,
name|ies
argument_list|,
name|ies_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|flags
operator|&
name|P2P_DEV_REPORTED
operator|&&
operator|!
name|wfd_changed
operator|&&
operator|(
operator|!
name|msg
operator|.
name|adv_service_instance
operator|||
operator|(
name|dev
operator|->
name|flags
operator|&
name|P2P_DEV_P2PS_REPORTED
operator|)
operator|)
condition|)
return|return
literal|0
return|;
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Peer found with Listen frequency %d MHz (rx_time=%u.%06u)"
argument_list|,
name|freq
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|rx_time
operator|->
name|sec
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|rx_time
operator|->
name|usec
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|flags
operator|&
name|P2P_DEV_USER_REJECTED
condition|)
block|{
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Do not report rejected device"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|dev
operator|->
name|info
operator|.
name|config_methods
operator|==
literal|0
operator|&&
operator|(
name|freq
operator|==
literal|2412
operator|||
name|freq
operator|==
literal|2437
operator|||
name|freq
operator|==
literal|2462
operator|)
condition|)
block|{
comment|/* 		 * If we have only seen a Beacon frame from a GO, we do not yet 		 * know what WPS config methods it supports. Since some 		 * applications use config_methods value from P2P-DEVICE-FOUND 		 * events, postpone reporting this peer until we've fully 		 * discovered its capabilities. 		 * 		 * At least for now, do this only if the peer was detected on 		 * one of the social channels since that peer can be easily be 		 * found again and there are no limitations of having to use 		 * passive scan on this channels, so this can be done through 		 * Probe Response frame that includes the config_methods 		 * information. 		 */
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Do not report peer "
name|MACSTR
literal|" with unknown config methods"
argument_list|,
name|MAC2STR
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|p2p
operator|->
name|cfg
operator|->
name|dev_found
argument_list|(
name|p2p
operator|->
name|cfg
operator|->
name|cb_ctx
argument_list|,
name|addr
argument_list|,
operator|&
name|dev
operator|->
name|info
argument_list|,
operator|!
operator|(
name|dev
operator|->
name|flags
operator|&
name|P2P_DEV_REPORTED_ONCE
operator|)
argument_list|)
expr_stmt|;
name|dev
operator|->
name|flags
operator||=
name|P2P_DEV_REPORTED
operator||
name|P2P_DEV_REPORTED_ONCE
expr_stmt|;
if|if
condition|(
name|msg
operator|.
name|adv_service_instance
condition|)
name|dev
operator|->
name|flags
operator||=
name|P2P_DEV_P2PS_REPORTED
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|p2p_device_free
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|,
name|struct
name|p2p_device
modifier|*
name|dev
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|p2p
operator|->
name|go_neg_peer
operator|==
name|dev
condition|)
block|{
comment|/* 		 * If GO Negotiation is in progress, report that it has failed. 		 */
name|p2p_go_neg_failed
argument_list|(
name|p2p
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p2p
operator|->
name|invite_peer
operator|==
name|dev
condition|)
name|p2p
operator|->
name|invite_peer
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|p2p
operator|->
name|sd_peer
operator|==
name|dev
condition|)
name|p2p
operator|->
name|sd_peer
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|p2p
operator|->
name|pending_client_disc_go
operator|==
name|dev
condition|)
name|p2p
operator|->
name|pending_client_disc_go
operator|=
name|NULL
expr_stmt|;
comment|/* dev_lost() device, but only if it was previously dev_found() */
if|if
condition|(
name|dev
operator|->
name|flags
operator|&
name|P2P_DEV_REPORTED_ONCE
condition|)
name|p2p
operator|->
name|cfg
operator|->
name|dev_lost
argument_list|(
name|p2p
operator|->
name|cfg
operator|->
name|cb_ctx
argument_list|,
name|dev
operator|->
name|info
operator|.
name|p2p_device_addr
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|P2P_MAX_WPS_VENDOR_EXT
condition|;
name|i
operator|++
control|)
block|{
name|wpabuf_free
argument_list|(
name|dev
operator|->
name|info
operator|.
name|wps_vendor_ext
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|dev
operator|->
name|info
operator|.
name|wps_vendor_ext
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
name|wpabuf_free
argument_list|(
name|dev
operator|->
name|info
operator|.
name|wfd_subelems
argument_list|)
expr_stmt|;
name|wpabuf_free
argument_list|(
name|dev
operator|->
name|info
operator|.
name|vendor_elems
argument_list|)
expr_stmt|;
name|wpabuf_free
argument_list|(
name|dev
operator|->
name|go_neg_conf
argument_list|)
expr_stmt|;
name|wpabuf_free
argument_list|(
name|dev
operator|->
name|info
operator|.
name|p2ps_instance
argument_list|)
expr_stmt|;
name|os_free
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|p2p_get_next_prog_freq
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|)
block|{
name|struct
name|p2p_channels
modifier|*
name|c
decl_stmt|;
name|struct
name|p2p_reg_class
modifier|*
name|cla
decl_stmt|;
name|size_t
name|cl
decl_stmt|,
name|ch
decl_stmt|;
name|int
name|found
init|=
literal|0
decl_stmt|;
name|u8
name|reg_class
decl_stmt|;
name|u8
name|channel
decl_stmt|;
name|int
name|freq
decl_stmt|;
name|c
operator|=
operator|&
name|p2p
operator|->
name|cfg
operator|->
name|channels
expr_stmt|;
for|for
control|(
name|cl
operator|=
literal|0
init|;
name|cl
operator|<
name|c
operator|->
name|reg_classes
condition|;
name|cl
operator|++
control|)
block|{
name|cla
operator|=
operator|&
name|c
operator|->
name|reg_class
index|[
name|cl
index|]
expr_stmt|;
if|if
condition|(
name|cla
operator|->
name|reg_class
operator|!=
name|p2p
operator|->
name|last_prog_scan_class
condition|)
continue|continue;
for|for
control|(
name|ch
operator|=
literal|0
init|;
name|ch
operator|<
name|cla
operator|->
name|channels
condition|;
name|ch
operator|++
control|)
block|{
if|if
condition|(
name|cla
operator|->
name|channel
index|[
name|ch
index|]
operator|==
name|p2p
operator|->
name|last_prog_scan_chan
condition|)
block|{
name|found
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|found
condition|)
break|break;
block|}
if|if
condition|(
operator|!
name|found
condition|)
block|{
comment|/* Start from beginning */
name|reg_class
operator|=
name|c
operator|->
name|reg_class
index|[
literal|0
index|]
operator|.
name|reg_class
expr_stmt|;
name|channel
operator|=
name|c
operator|->
name|reg_class
index|[
literal|0
index|]
operator|.
name|channel
index|[
literal|0
index|]
expr_stmt|;
block|}
else|else
block|{
comment|/* Pick the next channel */
name|ch
operator|++
expr_stmt|;
if|if
condition|(
name|ch
operator|==
name|cla
operator|->
name|channels
condition|)
block|{
name|cl
operator|++
expr_stmt|;
if|if
condition|(
name|cl
operator|==
name|c
operator|->
name|reg_classes
condition|)
name|cl
operator|=
literal|0
expr_stmt|;
name|ch
operator|=
literal|0
expr_stmt|;
block|}
name|reg_class
operator|=
name|c
operator|->
name|reg_class
index|[
name|cl
index|]
operator|.
name|reg_class
expr_stmt|;
name|channel
operator|=
name|c
operator|->
name|reg_class
index|[
name|cl
index|]
operator|.
name|channel
index|[
name|ch
index|]
expr_stmt|;
block|}
name|freq
operator|=
name|p2p_channel_to_freq
argument_list|(
name|reg_class
argument_list|,
name|channel
argument_list|)
expr_stmt|;
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Next progressive search channel: reg_class %u channel %u -> %d MHz"
argument_list|,
name|reg_class
argument_list|,
name|channel
argument_list|,
name|freq
argument_list|)
expr_stmt|;
name|p2p
operator|->
name|last_prog_scan_class
operator|=
name|reg_class
expr_stmt|;
name|p2p
operator|->
name|last_prog_scan_chan
operator|=
name|channel
expr_stmt|;
if|if
condition|(
name|freq
operator|==
literal|2412
operator|||
name|freq
operator|==
literal|2437
operator|||
name|freq
operator|==
literal|2462
condition|)
return|return
literal|0
return|;
comment|/* No need to add social channels */
return|return
name|freq
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|p2p_search
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|)
block|{
name|int
name|freq
init|=
literal|0
decl_stmt|;
name|enum
name|p2p_scan_type
name|type
decl_stmt|;
name|u16
name|pw_id
init|=
name|DEV_PW_DEFAULT
decl_stmt|;
name|int
name|res
decl_stmt|;
if|if
condition|(
name|p2p
operator|->
name|drv_in_listen
condition|)
block|{
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Driver is still in Listen state - wait for it to end before continuing"
argument_list|)
expr_stmt|;
return|return;
block|}
name|p2p
operator|->
name|cfg
operator|->
name|stop_listen
argument_list|(
name|p2p
operator|->
name|cfg
operator|->
name|cb_ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|p2p
operator|->
name|find_type
operator|==
name|P2P_FIND_PROGRESSIVE
operator|&&
operator|(
name|freq
operator|=
name|p2p_get_next_prog_freq
argument_list|(
name|p2p
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|type
operator|=
name|P2P_SCAN_SOCIAL_PLUS_ONE
expr_stmt|;
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Starting search (+ freq %u)"
argument_list|,
name|freq
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|type
operator|=
name|P2P_SCAN_SOCIAL
expr_stmt|;
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Starting search"
argument_list|)
expr_stmt|;
block|}
name|res
operator|=
name|p2p
operator|->
name|cfg
operator|->
name|p2p_scan
argument_list|(
name|p2p
operator|->
name|cfg
operator|->
name|cb_ctx
argument_list|,
name|type
argument_list|,
name|freq
argument_list|,
name|p2p
operator|->
name|num_req_dev_types
argument_list|,
name|p2p
operator|->
name|req_dev_types
argument_list|,
name|p2p
operator|->
name|find_dev_id
argument_list|,
name|pw_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|<
literal|0
condition|)
block|{
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Scan request schedule failed"
argument_list|)
expr_stmt|;
name|p2p_continue_find
argument_list|(
name|p2p
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|p2p_find_timeout
parameter_list|(
name|void
modifier|*
name|eloop_ctx
parameter_list|,
name|void
modifier|*
name|timeout_ctx
parameter_list|)
block|{
name|struct
name|p2p_data
modifier|*
name|p2p
init|=
name|eloop_ctx
decl_stmt|;
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Find timeout -> stop"
argument_list|)
expr_stmt|;
name|p2p_stop_find
argument_list|(
name|p2p
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|p2p_notify_scan_trigger_status
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|,
name|int
name|status
parameter_list|)
block|{
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Scan request failed"
argument_list|)
expr_stmt|;
comment|/* Do continue find even for the first p2p_find_scan */
name|p2p_continue_find
argument_list|(
name|p2p
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Running p2p_scan"
argument_list|)
expr_stmt|;
name|p2p
operator|->
name|p2p_scan_running
operator|=
literal|1
expr_stmt|;
name|eloop_cancel_timeout
argument_list|(
name|p2p_scan_timeout
argument_list|,
name|p2p
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|eloop_register_timeout
argument_list|(
name|P2P_SCAN_TIMEOUT
argument_list|,
literal|0
argument_list|,
name|p2p_scan_timeout
argument_list|,
name|p2p
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|p2p_run_after_scan
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|)
block|{
name|struct
name|p2p_device
modifier|*
name|dev
decl_stmt|;
name|enum
name|p2p_after_scan
name|op
decl_stmt|;
if|if
condition|(
name|p2p
operator|->
name|after_scan_tx
condition|)
block|{
name|p2p
operator|->
name|after_scan_tx_in_progress
operator|=
literal|1
expr_stmt|;
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Send pending Action frame at p2p_scan completion"
argument_list|)
expr_stmt|;
name|p2p
operator|->
name|cfg
operator|->
name|send_action
argument_list|(
name|p2p
operator|->
name|cfg
operator|->
name|cb_ctx
argument_list|,
name|p2p
operator|->
name|after_scan_tx
operator|->
name|freq
argument_list|,
name|p2p
operator|->
name|after_scan_tx
operator|->
name|dst
argument_list|,
name|p2p
operator|->
name|after_scan_tx
operator|->
name|src
argument_list|,
name|p2p
operator|->
name|after_scan_tx
operator|->
name|bssid
argument_list|,
operator|(
name|u8
operator|*
operator|)
operator|(
name|p2p
operator|->
name|after_scan_tx
operator|+
literal|1
operator|)
argument_list|,
name|p2p
operator|->
name|after_scan_tx
operator|->
name|len
argument_list|,
name|p2p
operator|->
name|after_scan_tx
operator|->
name|wait_time
argument_list|)
expr_stmt|;
name|os_free
argument_list|(
name|p2p
operator|->
name|after_scan_tx
argument_list|)
expr_stmt|;
name|p2p
operator|->
name|after_scan_tx
operator|=
name|NULL
expr_stmt|;
return|return
literal|1
return|;
block|}
name|op
operator|=
name|p2p
operator|->
name|start_after_scan
expr_stmt|;
name|p2p
operator|->
name|start_after_scan
operator|=
name|P2P_AFTER_SCAN_NOTHING
expr_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|P2P_AFTER_SCAN_NOTHING
case|:
break|break;
case|case
name|P2P_AFTER_SCAN_LISTEN
case|:
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Start previously requested Listen state"
argument_list|)
expr_stmt|;
name|p2p_listen
argument_list|(
name|p2p
argument_list|,
name|p2p
operator|->
name|pending_listen_sec
operator|*
literal|1000
operator|+
name|p2p
operator|->
name|pending_listen_usec
operator|/
literal|1000
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
name|P2P_AFTER_SCAN_CONNECT
case|:
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Start previously requested connect with "
name|MACSTR
argument_list|,
name|MAC2STR
argument_list|(
name|p2p
operator|->
name|after_scan_peer
argument_list|)
argument_list|)
expr_stmt|;
name|dev
operator|=
name|p2p_get_device
argument_list|(
name|p2p
argument_list|,
name|p2p
operator|->
name|after_scan_peer
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|==
name|NULL
condition|)
block|{
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Peer not known anymore"
argument_list|)
expr_stmt|;
break|break;
block|}
name|p2p_connect_send
argument_list|(
name|p2p
argument_list|,
name|dev
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|p2p_scan_timeout
parameter_list|(
name|void
modifier|*
name|eloop_ctx
parameter_list|,
name|void
modifier|*
name|timeout_ctx
parameter_list|)
block|{
name|struct
name|p2p_data
modifier|*
name|p2p
init|=
name|eloop_ctx
decl_stmt|;
name|int
name|running
decl_stmt|;
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"p2p_scan timeout (running=%d)"
argument_list|,
name|p2p
operator|->
name|p2p_scan_running
argument_list|)
expr_stmt|;
name|running
operator|=
name|p2p
operator|->
name|p2p_scan_running
expr_stmt|;
comment|/* Make sure we recover from missed scan results callback */
name|p2p
operator|->
name|p2p_scan_running
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|running
condition|)
name|p2p_run_after_scan
argument_list|(
name|p2p
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|p2p_free_req_dev_types
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|)
block|{
name|p2p
operator|->
name|num_req_dev_types
operator|=
literal|0
expr_stmt|;
name|os_free
argument_list|(
name|p2p
operator|->
name|req_dev_types
argument_list|)
expr_stmt|;
name|p2p
operator|->
name|req_dev_types
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|p2ps_gen_hash
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|u8
modifier|*
name|hash
parameter_list|)
block|{
name|u8
name|buf
index|[
name|SHA256_MAC_LEN
index|]
decl_stmt|;
name|char
name|str_buf
index|[
literal|256
index|]
decl_stmt|;
specifier|const
name|u8
modifier|*
name|adv_array
decl_stmt|;
name|size_t
name|i
decl_stmt|,
name|adv_len
decl_stmt|;
if|if
condition|(
operator|!
name|str
operator|||
operator|!
name|hash
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|str
index|[
literal|0
index|]
condition|)
block|{
name|os_memcpy
argument_list|(
name|hash
argument_list|,
name|p2p
operator|->
name|wild_card_hash
argument_list|,
name|P2PS_HASH_LEN
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|adv_array
operator|=
operator|(
name|u8
operator|*
operator|)
name|str_buf
expr_stmt|;
name|adv_len
operator|=
name|os_strlen
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|adv_len
operator|>=
sizeof|sizeof
argument_list|(
name|str_buf
argument_list|)
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|adv_len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|str
index|[
name|i
index|]
operator|>=
literal|'A'
operator|&&
name|str
index|[
name|i
index|]
operator|<=
literal|'Z'
condition|)
name|str_buf
index|[
name|i
index|]
operator|=
name|str
index|[
name|i
index|]
operator|-
literal|'A'
operator|+
literal|'a'
expr_stmt|;
else|else
name|str_buf
index|[
name|i
index|]
operator|=
name|str
index|[
name|i
index|]
expr_stmt|;
block|}
if|if
condition|(
name|sha256_vector
argument_list|(
literal|1
argument_list|,
operator|&
name|adv_array
argument_list|,
operator|&
name|adv_len
argument_list|,
name|buf
argument_list|)
condition|)
return|return
literal|0
return|;
name|os_memcpy
argument_list|(
name|hash
argument_list|,
name|buf
argument_list|,
name|P2PS_HASH_LEN
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|p2p_find
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|,
name|unsigned
name|int
name|timeout
parameter_list|,
name|enum
name|p2p_discovery_type
name|type
parameter_list|,
name|unsigned
name|int
name|num_req_dev_types
parameter_list|,
specifier|const
name|u8
modifier|*
name|req_dev_types
parameter_list|,
specifier|const
name|u8
modifier|*
name|dev_id
parameter_list|,
name|unsigned
name|int
name|search_delay
parameter_list|,
name|u8
name|seek_count
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|seek
parameter_list|,
name|int
name|freq
parameter_list|)
block|{
name|int
name|res
decl_stmt|;
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Starting find (type=%d)"
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|os_get_reltime
argument_list|(
operator|&
name|p2p
operator|->
name|find_start
argument_list|)
expr_stmt|;
if|if
condition|(
name|p2p
operator|->
name|p2p_scan_running
condition|)
block|{
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"p2p_scan is already running"
argument_list|)
expr_stmt|;
block|}
name|p2p_free_req_dev_types
argument_list|(
name|p2p
argument_list|)
expr_stmt|;
if|if
condition|(
name|req_dev_types
operator|&&
name|num_req_dev_types
condition|)
block|{
name|p2p
operator|->
name|req_dev_types
operator|=
name|os_malloc
argument_list|(
name|num_req_dev_types
operator|*
name|WPS_DEV_TYPE_LEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|p2p
operator|->
name|req_dev_types
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|os_memcpy
argument_list|(
name|p2p
operator|->
name|req_dev_types
argument_list|,
name|req_dev_types
argument_list|,
name|num_req_dev_types
operator|*
name|WPS_DEV_TYPE_LEN
argument_list|)
expr_stmt|;
name|p2p
operator|->
name|num_req_dev_types
operator|=
name|num_req_dev_types
expr_stmt|;
block|}
if|if
condition|(
name|dev_id
condition|)
block|{
name|os_memcpy
argument_list|(
name|p2p
operator|->
name|find_dev_id_buf
argument_list|,
name|dev_id
argument_list|,
name|ETH_ALEN
argument_list|)
expr_stmt|;
name|p2p
operator|->
name|find_dev_id
operator|=
name|p2p
operator|->
name|find_dev_id_buf
expr_stmt|;
block|}
else|else
name|p2p
operator|->
name|find_dev_id
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|seek_count
operator|==
literal|0
operator|||
operator|!
name|seek
condition|)
block|{
comment|/* Not an ASP search */
name|p2p
operator|->
name|p2ps_seek
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|seek_count
operator|==
literal|1
operator|&&
name|seek
operator|&&
operator|(
operator|!
name|seek
index|[
literal|0
index|]
operator|||
operator|!
name|seek
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|)
condition|)
block|{
comment|/* 		 * An empty seek string means no hash values, but still an ASP 		 * search. 		 */
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"ASP search"
argument_list|)
expr_stmt|;
name|p2p
operator|->
name|p2ps_seek_count
operator|=
literal|0
expr_stmt|;
name|p2p
operator|->
name|p2ps_seek
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|seek
operator|&&
name|seek_count
operator|<=
name|P2P_MAX_QUERY_HASH
condition|)
block|{
name|u8
name|buf
index|[
name|P2PS_HASH_LEN
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|count
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|seek_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|p2ps_gen_hash
argument_list|(
name|p2p
argument_list|,
name|seek
index|[
name|i
index|]
argument_list|,
name|buf
argument_list|)
condition|)
continue|continue;
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Seek service %s hash "
name|MACSTR
argument_list|,
name|seek
index|[
name|i
index|]
argument_list|,
name|MAC2STR
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|os_memcpy
argument_list|(
operator|&
name|p2p
operator|->
name|p2ps_seek_hash
index|[
name|count
operator|*
name|P2PS_HASH_LEN
index|]
argument_list|,
name|buf
argument_list|,
name|P2PS_HASH_LEN
argument_list|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
name|p2p
operator|->
name|p2ps_seek_count
operator|=
name|count
expr_stmt|;
name|p2p
operator|->
name|p2ps_seek
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|p2p
operator|->
name|p2ps_seek_count
operator|=
literal|0
expr_stmt|;
name|p2p
operator|->
name|p2ps_seek
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Special case to perform wildcard search */
if|if
condition|(
name|p2p
operator|->
name|p2ps_seek_count
operator|==
literal|0
operator|&&
name|p2p
operator|->
name|p2ps_seek
condition|)
block|{
name|p2p
operator|->
name|p2ps_seek_count
operator|=
literal|1
expr_stmt|;
name|os_memcpy
argument_list|(
operator|&
name|p2p
operator|->
name|p2ps_seek_hash
argument_list|,
name|p2p
operator|->
name|wild_card_hash
argument_list|,
name|P2PS_HASH_LEN
argument_list|)
expr_stmt|;
block|}
name|p2p
operator|->
name|start_after_scan
operator|=
name|P2P_AFTER_SCAN_NOTHING
expr_stmt|;
name|p2p_clear_timeout
argument_list|(
name|p2p
argument_list|)
expr_stmt|;
name|p2p
operator|->
name|cfg
operator|->
name|stop_listen
argument_list|(
name|p2p
operator|->
name|cfg
operator|->
name|cb_ctx
argument_list|)
expr_stmt|;
name|p2p
operator|->
name|find_type
operator|=
name|type
expr_stmt|;
name|p2p_device_clear_reported
argument_list|(
name|p2p
argument_list|)
expr_stmt|;
name|p2p_set_state
argument_list|(
name|p2p
argument_list|,
name|P2P_SEARCH
argument_list|)
expr_stmt|;
name|p2p
operator|->
name|search_delay
operator|=
name|search_delay
expr_stmt|;
name|p2p
operator|->
name|in_search_delay
operator|=
literal|0
expr_stmt|;
name|eloop_cancel_timeout
argument_list|(
name|p2p_find_timeout
argument_list|,
name|p2p
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|p2p
operator|->
name|last_p2p_find_timeout
operator|=
name|timeout
expr_stmt|;
if|if
condition|(
name|timeout
condition|)
name|eloop_register_timeout
argument_list|(
name|timeout
argument_list|,
literal|0
argument_list|,
name|p2p_find_timeout
argument_list|,
name|p2p
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|P2P_FIND_START_WITH_FULL
case|:
if|if
condition|(
name|freq
operator|>
literal|0
condition|)
block|{
comment|/* 			 * Start with the specified channel and then move to 			 * social channels only scans. 			 */
name|res
operator|=
name|p2p
operator|->
name|cfg
operator|->
name|p2p_scan
argument_list|(
name|p2p
operator|->
name|cfg
operator|->
name|cb_ctx
argument_list|,
name|P2P_SCAN_SPECIFIC
argument_list|,
name|freq
argument_list|,
name|p2p
operator|->
name|num_req_dev_types
argument_list|,
name|p2p
operator|->
name|req_dev_types
argument_list|,
name|dev_id
argument_list|,
name|DEV_PW_DEFAULT
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* fall through */
case|case
name|P2P_FIND_PROGRESSIVE
case|:
name|res
operator|=
name|p2p
operator|->
name|cfg
operator|->
name|p2p_scan
argument_list|(
name|p2p
operator|->
name|cfg
operator|->
name|cb_ctx
argument_list|,
name|P2P_SCAN_FULL
argument_list|,
literal|0
argument_list|,
name|p2p
operator|->
name|num_req_dev_types
argument_list|,
name|p2p
operator|->
name|req_dev_types
argument_list|,
name|dev_id
argument_list|,
name|DEV_PW_DEFAULT
argument_list|)
expr_stmt|;
break|break;
case|case
name|P2P_FIND_ONLY_SOCIAL
case|:
name|res
operator|=
name|p2p
operator|->
name|cfg
operator|->
name|p2p_scan
argument_list|(
name|p2p
operator|->
name|cfg
operator|->
name|cb_ctx
argument_list|,
name|P2P_SCAN_SOCIAL
argument_list|,
literal|0
argument_list|,
name|p2p
operator|->
name|num_req_dev_types
argument_list|,
name|p2p
operator|->
name|req_dev_types
argument_list|,
name|dev_id
argument_list|,
name|DEV_PW_DEFAULT
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|res
operator|!=
literal|0
operator|&&
name|p2p
operator|->
name|p2p_scan_running
condition|)
block|{
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Failed to start p2p_scan - another p2p_scan was already running"
argument_list|)
expr_stmt|;
comment|/* wait for the previous p2p_scan to complete */
name|res
operator|=
literal|0
expr_stmt|;
comment|/* do not report failure */
block|}
elseif|else
if|if
condition|(
name|res
operator|!=
literal|0
condition|)
block|{
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Failed to start p2p_scan"
argument_list|)
expr_stmt|;
name|p2p_set_state
argument_list|(
name|p2p
argument_list|,
name|P2P_IDLE
argument_list|)
expr_stmt|;
name|eloop_cancel_timeout
argument_list|(
name|p2p_find_timeout
argument_list|,
name|p2p
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
return|return
name|res
return|;
block|}
end_function

begin_function
name|void
name|p2p_stop_find_for_freq
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|,
name|int
name|freq
parameter_list|)
block|{
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Stopping find"
argument_list|)
expr_stmt|;
name|eloop_cancel_timeout
argument_list|(
name|p2p_find_timeout
argument_list|,
name|p2p
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|p2p_clear_timeout
argument_list|(
name|p2p
argument_list|)
expr_stmt|;
if|if
condition|(
name|p2p
operator|->
name|state
operator|==
name|P2P_SEARCH
operator|||
name|p2p
operator|->
name|state
operator|==
name|P2P_SD_DURING_FIND
condition|)
name|p2p
operator|->
name|cfg
operator|->
name|find_stopped
argument_list|(
name|p2p
operator|->
name|cfg
operator|->
name|cb_ctx
argument_list|)
expr_stmt|;
name|p2p
operator|->
name|p2ps_seek_count
operator|=
literal|0
expr_stmt|;
name|p2p_set_state
argument_list|(
name|p2p
argument_list|,
name|P2P_IDLE
argument_list|)
expr_stmt|;
name|p2p_free_req_dev_types
argument_list|(
name|p2p
argument_list|)
expr_stmt|;
name|p2p
operator|->
name|start_after_scan
operator|=
name|P2P_AFTER_SCAN_NOTHING
expr_stmt|;
if|if
condition|(
name|p2p
operator|->
name|go_neg_peer
condition|)
name|p2p
operator|->
name|go_neg_peer
operator|->
name|flags
operator|&=
operator|~
name|P2P_DEV_PEER_WAITING_RESPONSE
expr_stmt|;
name|p2p
operator|->
name|go_neg_peer
operator|=
name|NULL
expr_stmt|;
name|p2p
operator|->
name|sd_peer
operator|=
name|NULL
expr_stmt|;
name|p2p
operator|->
name|invite_peer
operator|=
name|NULL
expr_stmt|;
name|p2p_stop_listen_for_freq
argument_list|(
name|p2p
argument_list|,
name|freq
argument_list|)
expr_stmt|;
name|p2p
operator|->
name|send_action_in_progress
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|p2p_stop_listen_for_freq
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|,
name|int
name|freq
parameter_list|)
block|{
if|if
condition|(
name|freq
operator|>
literal|0
operator|&&
name|p2p
operator|->
name|drv_in_listen
operator|==
name|freq
operator|&&
name|p2p
operator|->
name|in_listen
condition|)
block|{
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Skip stop_listen since we are on correct channel for response"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|p2p
operator|->
name|in_listen
condition|)
block|{
name|p2p
operator|->
name|in_listen
operator|=
literal|0
expr_stmt|;
name|p2p_clear_timeout
argument_list|(
name|p2p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p2p
operator|->
name|drv_in_listen
condition|)
block|{
comment|/* 		 * The driver may not deliver callback to p2p_listen_end() 		 * when the operation gets canceled, so clear the internal 		 * variable that is tracking driver state. 		 */
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Clear drv_in_listen (%d)"
argument_list|,
name|p2p
operator|->
name|drv_in_listen
argument_list|)
expr_stmt|;
name|p2p
operator|->
name|drv_in_listen
operator|=
literal|0
expr_stmt|;
block|}
name|p2p
operator|->
name|cfg
operator|->
name|stop_listen
argument_list|(
name|p2p
operator|->
name|cfg
operator|->
name|cb_ctx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|p2p_stop_listen
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|)
block|{
if|if
condition|(
name|p2p
operator|->
name|state
operator|!=
name|P2P_LISTEN_ONLY
condition|)
block|{
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Skip stop_listen since not in listen_only state."
argument_list|)
expr_stmt|;
return|return;
block|}
name|p2p_stop_listen_for_freq
argument_list|(
name|p2p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|p2p_set_state
argument_list|(
name|p2p
argument_list|,
name|P2P_IDLE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|p2p_stop_find
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|)
block|{
name|p2p
operator|->
name|pending_listen_freq
operator|=
literal|0
expr_stmt|;
name|p2p_stop_find_for_freq
argument_list|(
name|p2p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|p2p_prepare_channel_pref
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|,
name|unsigned
name|int
name|force_freq
parameter_list|,
name|unsigned
name|int
name|pref_freq
parameter_list|,
name|int
name|go
parameter_list|)
block|{
name|u8
name|op_class
decl_stmt|,
name|op_channel
decl_stmt|;
name|unsigned
name|int
name|freq
init|=
name|force_freq
condition|?
name|force_freq
else|:
name|pref_freq
decl_stmt|;
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Prepare channel pref - force_freq=%u pref_freq=%u go=%d"
argument_list|,
name|force_freq
argument_list|,
name|pref_freq
argument_list|,
name|go
argument_list|)
expr_stmt|;
if|if
condition|(
name|p2p_freq_to_channel
argument_list|(
name|freq
argument_list|,
operator|&
name|op_class
argument_list|,
operator|&
name|op_channel
argument_list|)
operator|<
literal|0
condition|)
block|{
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Unsupported frequency %u MHz"
argument_list|,
name|freq
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
operator|!
name|p2p_channels_includes
argument_list|(
operator|&
name|p2p
operator|->
name|cfg
operator|->
name|channels
argument_list|,
name|op_class
argument_list|,
name|op_channel
argument_list|)
operator|&&
operator|(
name|go
operator|||
operator|!
name|p2p_channels_includes
argument_list|(
operator|&
name|p2p
operator|->
name|cfg
operator|->
name|cli_channels
argument_list|,
name|op_class
argument_list|,
name|op_channel
argument_list|)
operator|)
condition|)
block|{
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Frequency %u MHz (oper_class %u channel %u) not allowed for P2P"
argument_list|,
name|freq
argument_list|,
name|op_class
argument_list|,
name|op_channel
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|p2p
operator|->
name|op_reg_class
operator|=
name|op_class
expr_stmt|;
name|p2p
operator|->
name|op_channel
operator|=
name|op_channel
expr_stmt|;
if|if
condition|(
name|force_freq
condition|)
block|{
name|p2p
operator|->
name|channels
operator|.
name|reg_classes
operator|=
literal|1
expr_stmt|;
name|p2p
operator|->
name|channels
operator|.
name|reg_class
index|[
literal|0
index|]
operator|.
name|channels
operator|=
literal|1
expr_stmt|;
name|p2p
operator|->
name|channels
operator|.
name|reg_class
index|[
literal|0
index|]
operator|.
name|reg_class
operator|=
name|p2p
operator|->
name|op_reg_class
expr_stmt|;
name|p2p
operator|->
name|channels
operator|.
name|reg_class
index|[
literal|0
index|]
operator|.
name|channel
index|[
literal|0
index|]
operator|=
name|p2p
operator|->
name|op_channel
expr_stmt|;
block|}
else|else
block|{
name|os_memcpy
argument_list|(
operator|&
name|p2p
operator|->
name|channels
argument_list|,
operator|&
name|p2p
operator|->
name|cfg
operator|->
name|channels
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|p2p_channels
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|p2p_prepare_channel_best
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|)
block|{
name|u8
name|op_class
decl_stmt|,
name|op_channel
decl_stmt|;
specifier|const
name|int
name|op_classes_5ghz
index|[]
init|=
block|{
literal|124
block|,
literal|125
block|,
literal|115
block|,
literal|0
block|}
decl_stmt|;
specifier|const
name|int
name|op_classes_ht40
index|[]
init|=
block|{
literal|126
block|,
literal|127
block|,
literal|116
block|,
literal|117
block|,
literal|0
block|}
decl_stmt|;
specifier|const
name|int
name|op_classes_vht
index|[]
init|=
block|{
literal|128
block|,
literal|0
block|}
decl_stmt|;
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Prepare channel best"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p2p
operator|->
name|cfg
operator|->
name|cfg_op_channel
operator|&&
name|p2p
operator|->
name|best_freq_overall
operator|>
literal|0
operator|&&
name|p2p_supported_freq
argument_list|(
name|p2p
argument_list|,
name|p2p
operator|->
name|best_freq_overall
argument_list|)
operator|&&
name|p2p_freq_to_channel
argument_list|(
name|p2p
operator|->
name|best_freq_overall
argument_list|,
operator|&
name|op_class
argument_list|,
operator|&
name|op_channel
argument_list|)
operator|==
literal|0
condition|)
block|{
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Select best overall channel as operating channel preference"
argument_list|)
expr_stmt|;
name|p2p
operator|->
name|op_reg_class
operator|=
name|op_class
expr_stmt|;
name|p2p
operator|->
name|op_channel
operator|=
name|op_channel
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|p2p
operator|->
name|cfg
operator|->
name|cfg_op_channel
operator|&&
name|p2p
operator|->
name|best_freq_5
operator|>
literal|0
operator|&&
name|p2p_supported_freq
argument_list|(
name|p2p
argument_list|,
name|p2p
operator|->
name|best_freq_5
argument_list|)
operator|&&
name|p2p_freq_to_channel
argument_list|(
name|p2p
operator|->
name|best_freq_5
argument_list|,
operator|&
name|op_class
argument_list|,
operator|&
name|op_channel
argument_list|)
operator|==
literal|0
condition|)
block|{
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Select best 5 GHz channel as operating channel preference"
argument_list|)
expr_stmt|;
name|p2p
operator|->
name|op_reg_class
operator|=
name|op_class
expr_stmt|;
name|p2p
operator|->
name|op_channel
operator|=
name|op_channel
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|p2p
operator|->
name|cfg
operator|->
name|cfg_op_channel
operator|&&
name|p2p
operator|->
name|best_freq_24
operator|>
literal|0
operator|&&
name|p2p_supported_freq
argument_list|(
name|p2p
argument_list|,
name|p2p
operator|->
name|best_freq_24
argument_list|)
operator|&&
name|p2p_freq_to_channel
argument_list|(
name|p2p
operator|->
name|best_freq_24
argument_list|,
operator|&
name|op_class
argument_list|,
operator|&
name|op_channel
argument_list|)
operator|==
literal|0
condition|)
block|{
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Select best 2.4 GHz channel as operating channel preference"
argument_list|)
expr_stmt|;
name|p2p
operator|->
name|op_reg_class
operator|=
name|op_class
expr_stmt|;
name|p2p
operator|->
name|op_channel
operator|=
name|op_channel
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p2p
operator|->
name|cfg
operator|->
name|num_pref_chan
operator|>
literal|0
operator|&&
name|p2p_channels_includes
argument_list|(
operator|&
name|p2p
operator|->
name|cfg
operator|->
name|channels
argument_list|,
name|p2p
operator|->
name|cfg
operator|->
name|pref_chan
index|[
literal|0
index|]
operator|.
name|op_class
argument_list|,
name|p2p
operator|->
name|cfg
operator|->
name|pref_chan
index|[
literal|0
index|]
operator|.
name|chan
argument_list|)
condition|)
block|{
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Select first pref_chan entry as operating channel preference"
argument_list|)
expr_stmt|;
name|p2p
operator|->
name|op_reg_class
operator|=
name|p2p
operator|->
name|cfg
operator|->
name|pref_chan
index|[
literal|0
index|]
operator|.
name|op_class
expr_stmt|;
name|p2p
operator|->
name|op_channel
operator|=
name|p2p
operator|->
name|cfg
operator|->
name|pref_chan
index|[
literal|0
index|]
operator|.
name|chan
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p2p_channel_select
argument_list|(
operator|&
name|p2p
operator|->
name|cfg
operator|->
name|channels
argument_list|,
name|op_classes_vht
argument_list|,
operator|&
name|p2p
operator|->
name|op_reg_class
argument_list|,
operator|&
name|p2p
operator|->
name|op_channel
argument_list|)
operator|==
literal|0
condition|)
block|{
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Select possible VHT channel (op_class %u channel %u) as operating channel preference"
argument_list|,
name|p2p
operator|->
name|op_reg_class
argument_list|,
name|p2p
operator|->
name|op_channel
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p2p_channel_select
argument_list|(
operator|&
name|p2p
operator|->
name|cfg
operator|->
name|channels
argument_list|,
name|op_classes_ht40
argument_list|,
operator|&
name|p2p
operator|->
name|op_reg_class
argument_list|,
operator|&
name|p2p
operator|->
name|op_channel
argument_list|)
operator|==
literal|0
condition|)
block|{
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Select possible HT40 channel (op_class %u channel %u) as operating channel preference"
argument_list|,
name|p2p
operator|->
name|op_reg_class
argument_list|,
name|p2p
operator|->
name|op_channel
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p2p_channel_select
argument_list|(
operator|&
name|p2p
operator|->
name|cfg
operator|->
name|channels
argument_list|,
name|op_classes_5ghz
argument_list|,
operator|&
name|p2p
operator|->
name|op_reg_class
argument_list|,
operator|&
name|p2p
operator|->
name|op_channel
argument_list|)
operator|==
literal|0
condition|)
block|{
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Select possible 5 GHz channel (op_class %u channel %u) as operating channel preference"
argument_list|,
name|p2p
operator|->
name|op_reg_class
argument_list|,
name|p2p
operator|->
name|op_channel
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p2p_channels_includes
argument_list|(
operator|&
name|p2p
operator|->
name|cfg
operator|->
name|channels
argument_list|,
name|p2p
operator|->
name|cfg
operator|->
name|op_reg_class
argument_list|,
name|p2p
operator|->
name|cfg
operator|->
name|op_channel
argument_list|)
condition|)
block|{
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Select pre-configured channel as operating channel preference"
argument_list|)
expr_stmt|;
name|p2p
operator|->
name|op_reg_class
operator|=
name|p2p
operator|->
name|cfg
operator|->
name|op_reg_class
expr_stmt|;
name|p2p
operator|->
name|op_channel
operator|=
name|p2p
operator|->
name|cfg
operator|->
name|op_channel
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p2p_channel_random_social
argument_list|(
operator|&
name|p2p
operator|->
name|cfg
operator|->
name|channels
argument_list|,
operator|&
name|p2p
operator|->
name|op_reg_class
argument_list|,
operator|&
name|p2p
operator|->
name|op_channel
argument_list|)
operator|==
literal|0
condition|)
block|{
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Select random available social channel (op_class %u channel %u) as operating channel preference"
argument_list|,
name|p2p
operator|->
name|op_reg_class
argument_list|,
name|p2p
operator|->
name|op_channel
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Select any random available channel from the first available 		 * operating class */
name|p2p_channel_select
argument_list|(
operator|&
name|p2p
operator|->
name|cfg
operator|->
name|channels
argument_list|,
name|NULL
argument_list|,
operator|&
name|p2p
operator|->
name|op_reg_class
argument_list|,
operator|&
name|p2p
operator|->
name|op_channel
argument_list|)
expr_stmt|;
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Select random available channel %d from operating class %d as operating channel preference"
argument_list|,
name|p2p
operator|->
name|op_channel
argument_list|,
name|p2p
operator|->
name|op_reg_class
argument_list|)
expr_stmt|;
block|}
name|os_memcpy
argument_list|(
operator|&
name|p2p
operator|->
name|channels
argument_list|,
operator|&
name|p2p
operator|->
name|cfg
operator|->
name|channels
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|p2p_channels
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * p2p_prepare_channel - Select operating channel for GO Negotiation  * @p2p: P2P module context from p2p_init()  * @dev: Selected peer device  * @force_freq: Forced frequency in MHz or 0 if not forced  * @pref_freq: Preferred frequency in MHz or 0 if no preference  * @go: Whether the local end will be forced to be GO  * Returns: 0 on success, -1 on failure (channel not supported for P2P)  *  * This function is used to do initial operating channel selection for GO  * Negotiation prior to having received peer information. The selected channel  * may be further optimized in p2p_reselect_channel() once the peer information  * is available.  */
end_comment

begin_function
name|int
name|p2p_prepare_channel
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|,
name|struct
name|p2p_device
modifier|*
name|dev
parameter_list|,
name|unsigned
name|int
name|force_freq
parameter_list|,
name|unsigned
name|int
name|pref_freq
parameter_list|,
name|int
name|go
parameter_list|)
block|{
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Prepare channel - force_freq=%u pref_freq=%u go=%d"
argument_list|,
name|force_freq
argument_list|,
name|pref_freq
argument_list|,
name|go
argument_list|)
expr_stmt|;
if|if
condition|(
name|force_freq
operator|||
name|pref_freq
condition|)
block|{
if|if
condition|(
name|p2p_prepare_channel_pref
argument_list|(
name|p2p
argument_list|,
name|force_freq
argument_list|,
name|pref_freq
argument_list|,
name|go
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
block|}
else|else
block|{
name|p2p_prepare_channel_best
argument_list|(
name|p2p
argument_list|)
expr_stmt|;
block|}
name|p2p_channels_dump
argument_list|(
name|p2p
argument_list|,
literal|"prepared channels"
argument_list|,
operator|&
name|p2p
operator|->
name|channels
argument_list|)
expr_stmt|;
if|if
condition|(
name|go
condition|)
name|p2p_channels_remove_freqs
argument_list|(
operator|&
name|p2p
operator|->
name|channels
argument_list|,
operator|&
name|p2p
operator|->
name|no_go_freq
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|force_freq
condition|)
name|p2p_channels_union_inplace
argument_list|(
operator|&
name|p2p
operator|->
name|channels
argument_list|,
operator|&
name|p2p
operator|->
name|cfg
operator|->
name|cli_channels
argument_list|)
expr_stmt|;
name|p2p_channels_dump
argument_list|(
name|p2p
argument_list|,
literal|"after go/cli filter/add"
argument_list|,
operator|&
name|p2p
operator|->
name|channels
argument_list|)
expr_stmt|;
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Own preference for operation channel: Operating Class %u Channel %u%s"
argument_list|,
name|p2p
operator|->
name|op_reg_class
argument_list|,
name|p2p
operator|->
name|op_channel
argument_list|,
name|force_freq
condition|?
literal|" (forced)"
else|:
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|force_freq
condition|)
name|dev
operator|->
name|flags
operator||=
name|P2P_DEV_FORCE_FREQ
expr_stmt|;
else|else
name|dev
operator|->
name|flags
operator|&=
operator|~
name|P2P_DEV_FORCE_FREQ
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|p2p_set_dev_persistent
parameter_list|(
name|struct
name|p2p_device
modifier|*
name|dev
parameter_list|,
name|int
name|persistent_group
parameter_list|)
block|{
switch|switch
condition|(
name|persistent_group
condition|)
block|{
case|case
literal|0
case|:
name|dev
operator|->
name|flags
operator|&=
operator|~
operator|(
name|P2P_DEV_PREFER_PERSISTENT_GROUP
operator||
name|P2P_DEV_PREFER_PERSISTENT_RECONN
operator|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|dev
operator|->
name|flags
operator||=
name|P2P_DEV_PREFER_PERSISTENT_GROUP
expr_stmt|;
name|dev
operator|->
name|flags
operator|&=
operator|~
name|P2P_DEV_PREFER_PERSISTENT_RECONN
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|dev
operator|->
name|flags
operator||=
name|P2P_DEV_PREFER_PERSISTENT_GROUP
operator||
name|P2P_DEV_PREFER_PERSISTENT_RECONN
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
name|int
name|p2p_connect
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|,
specifier|const
name|u8
modifier|*
name|peer_addr
parameter_list|,
name|enum
name|p2p_wps_method
name|wps_method
parameter_list|,
name|int
name|go_intent
parameter_list|,
specifier|const
name|u8
modifier|*
name|own_interface_addr
parameter_list|,
name|unsigned
name|int
name|force_freq
parameter_list|,
name|int
name|persistent_group
parameter_list|,
specifier|const
name|u8
modifier|*
name|force_ssid
parameter_list|,
name|size_t
name|force_ssid_len
parameter_list|,
name|int
name|pd_before_go_neg
parameter_list|,
name|unsigned
name|int
name|pref_freq
parameter_list|,
name|u16
name|oob_pw_id
parameter_list|)
block|{
name|struct
name|p2p_device
modifier|*
name|dev
decl_stmt|;
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Request to start group negotiation - peer="
name|MACSTR
literal|"  GO Intent=%d  Intended Interface Address="
name|MACSTR
literal|" wps_method=%d persistent_group=%d pd_before_go_neg=%d "
literal|"oob_pw_id=%u"
argument_list|,
name|MAC2STR
argument_list|(
name|peer_addr
argument_list|)
argument_list|,
name|go_intent
argument_list|,
name|MAC2STR
argument_list|(
name|own_interface_addr
argument_list|)
argument_list|,
name|wps_method
argument_list|,
name|persistent_group
argument_list|,
name|pd_before_go_neg
argument_list|,
name|oob_pw_id
argument_list|)
expr_stmt|;
name|dev
operator|=
name|p2p_get_device
argument_list|(
name|p2p
argument_list|,
name|peer_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|==
name|NULL
operator|||
operator|(
name|dev
operator|->
name|flags
operator|&
name|P2P_DEV_PROBE_REQ_ONLY
operator|)
condition|)
block|{
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Cannot connect to unknown P2P Device "
name|MACSTR
argument_list|,
name|MAC2STR
argument_list|(
name|peer_addr
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|p2p_prepare_channel
argument_list|(
name|p2p
argument_list|,
name|dev
argument_list|,
name|force_freq
argument_list|,
name|pref_freq
argument_list|,
name|go_intent
operator|==
literal|15
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|dev
operator|->
name|flags
operator|&
name|P2P_DEV_GROUP_CLIENT_ONLY
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|dev
operator|->
name|info
operator|.
name|dev_capab
operator|&
name|P2P_DEV_CAPAB_CLIENT_DISCOVERABILITY
operator|)
condition|)
block|{
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Cannot connect to P2P Device "
name|MACSTR
literal|" that is in a group and is not discoverable"
argument_list|,
name|MAC2STR
argument_list|(
name|peer_addr
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|dev
operator|->
name|oper_freq
operator|<=
literal|0
condition|)
block|{
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Cannot connect to P2P Device "
name|MACSTR
literal|" with incomplete information"
argument_list|,
name|MAC2STR
argument_list|(
name|peer_addr
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* 		 * First, try to connect directly. If the peer does not 		 * acknowledge frames, assume it is sleeping and use device 		 * discoverability via the GO at that point. 		 */
block|}
name|p2p
operator|->
name|ssid_set
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|force_ssid
condition|)
block|{
name|wpa_hexdump_ascii
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"P2P: Forced SSID"
argument_list|,
name|force_ssid
argument_list|,
name|force_ssid_len
argument_list|)
expr_stmt|;
name|os_memcpy
argument_list|(
name|p2p
operator|->
name|ssid
argument_list|,
name|force_ssid
argument_list|,
name|force_ssid_len
argument_list|)
expr_stmt|;
name|p2p
operator|->
name|ssid_len
operator|=
name|force_ssid_len
expr_stmt|;
name|p2p
operator|->
name|ssid_set
operator|=
literal|1
expr_stmt|;
block|}
name|dev
operator|->
name|flags
operator|&=
operator|~
name|P2P_DEV_NOT_YET_READY
expr_stmt|;
name|dev
operator|->
name|flags
operator|&=
operator|~
name|P2P_DEV_USER_REJECTED
expr_stmt|;
name|dev
operator|->
name|flags
operator|&=
operator|~
name|P2P_DEV_WAIT_GO_NEG_RESPONSE
expr_stmt|;
name|dev
operator|->
name|flags
operator|&=
operator|~
name|P2P_DEV_WAIT_GO_NEG_CONFIRM
expr_stmt|;
if|if
condition|(
name|pd_before_go_neg
condition|)
name|dev
operator|->
name|flags
operator||=
name|P2P_DEV_PD_BEFORE_GO_NEG
expr_stmt|;
else|else
block|{
name|dev
operator|->
name|flags
operator|&=
operator|~
name|P2P_DEV_PD_BEFORE_GO_NEG
expr_stmt|;
comment|/* 		 * Assign dialog token and tie breaker here to use the same 		 * values in each retry within the same GO Negotiation exchange. 		 */
name|dev
operator|->
name|dialog_token
operator|++
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|dialog_token
operator|==
literal|0
condition|)
name|dev
operator|->
name|dialog_token
operator|=
literal|1
expr_stmt|;
name|dev
operator|->
name|tie_breaker
operator|=
name|p2p
operator|->
name|next_tie_breaker
expr_stmt|;
name|p2p
operator|->
name|next_tie_breaker
operator|=
operator|!
name|p2p
operator|->
name|next_tie_breaker
expr_stmt|;
block|}
name|dev
operator|->
name|connect_reqs
operator|=
literal|0
expr_stmt|;
name|dev
operator|->
name|go_neg_req_sent
operator|=
literal|0
expr_stmt|;
name|dev
operator|->
name|go_state
operator|=
name|UNKNOWN_GO
expr_stmt|;
name|p2p_set_dev_persistent
argument_list|(
name|dev
argument_list|,
name|persistent_group
argument_list|)
expr_stmt|;
name|p2p
operator|->
name|go_intent
operator|=
name|go_intent
expr_stmt|;
name|os_memcpy
argument_list|(
name|p2p
operator|->
name|intended_addr
argument_list|,
name|own_interface_addr
argument_list|,
name|ETH_ALEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|p2p
operator|->
name|state
operator|!=
name|P2P_IDLE
condition|)
name|p2p_stop_find
argument_list|(
name|p2p
argument_list|)
expr_stmt|;
if|if
condition|(
name|p2p
operator|->
name|after_scan_tx
condition|)
block|{
comment|/* 		 * We need to drop the pending frame to avoid issues with the 		 * new GO Negotiation, e.g., when the pending frame was from a 		 * previous attempt at starting a GO Negotiation. 		 */
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Dropped previous pending Action frame TX that was waiting for p2p_scan completion"
argument_list|)
expr_stmt|;
name|os_free
argument_list|(
name|p2p
operator|->
name|after_scan_tx
argument_list|)
expr_stmt|;
name|p2p
operator|->
name|after_scan_tx
operator|=
name|NULL
expr_stmt|;
block|}
name|dev
operator|->
name|wps_method
operator|=
name|wps_method
expr_stmt|;
name|dev
operator|->
name|oob_pw_id
operator|=
name|oob_pw_id
expr_stmt|;
name|dev
operator|->
name|status
operator|=
name|P2P_SC_SUCCESS
expr_stmt|;
if|if
condition|(
name|p2p
operator|->
name|p2p_scan_running
condition|)
block|{
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"p2p_scan running - delay connect send"
argument_list|)
expr_stmt|;
name|p2p
operator|->
name|start_after_scan
operator|=
name|P2P_AFTER_SCAN_CONNECT
expr_stmt|;
name|os_memcpy
argument_list|(
name|p2p
operator|->
name|after_scan_peer
argument_list|,
name|peer_addr
argument_list|,
name|ETH_ALEN
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|p2p
operator|->
name|start_after_scan
operator|=
name|P2P_AFTER_SCAN_NOTHING
expr_stmt|;
return|return
name|p2p_connect_send
argument_list|(
name|p2p
argument_list|,
name|dev
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|p2p_authorize
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|,
specifier|const
name|u8
modifier|*
name|peer_addr
parameter_list|,
name|enum
name|p2p_wps_method
name|wps_method
parameter_list|,
name|int
name|go_intent
parameter_list|,
specifier|const
name|u8
modifier|*
name|own_interface_addr
parameter_list|,
name|unsigned
name|int
name|force_freq
parameter_list|,
name|int
name|persistent_group
parameter_list|,
specifier|const
name|u8
modifier|*
name|force_ssid
parameter_list|,
name|size_t
name|force_ssid_len
parameter_list|,
name|unsigned
name|int
name|pref_freq
parameter_list|,
name|u16
name|oob_pw_id
parameter_list|)
block|{
name|struct
name|p2p_device
modifier|*
name|dev
decl_stmt|;
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Request to authorize group negotiation - peer="
name|MACSTR
literal|"  GO Intent=%d  Intended Interface Address="
name|MACSTR
literal|" wps_method=%d  persistent_group=%d oob_pw_id=%u"
argument_list|,
name|MAC2STR
argument_list|(
name|peer_addr
argument_list|)
argument_list|,
name|go_intent
argument_list|,
name|MAC2STR
argument_list|(
name|own_interface_addr
argument_list|)
argument_list|,
name|wps_method
argument_list|,
name|persistent_group
argument_list|,
name|oob_pw_id
argument_list|)
expr_stmt|;
name|dev
operator|=
name|p2p_get_device
argument_list|(
name|p2p
argument_list|,
name|peer_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|==
name|NULL
condition|)
block|{
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Cannot authorize unknown P2P Device "
name|MACSTR
argument_list|,
name|MAC2STR
argument_list|(
name|peer_addr
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|p2p_prepare_channel
argument_list|(
name|p2p
argument_list|,
name|dev
argument_list|,
name|force_freq
argument_list|,
name|pref_freq
argument_list|,
name|go_intent
operator|==
literal|15
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|p2p
operator|->
name|ssid_set
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|force_ssid
condition|)
block|{
name|wpa_hexdump_ascii
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"P2P: Forced SSID"
argument_list|,
name|force_ssid
argument_list|,
name|force_ssid_len
argument_list|)
expr_stmt|;
name|os_memcpy
argument_list|(
name|p2p
operator|->
name|ssid
argument_list|,
name|force_ssid
argument_list|,
name|force_ssid_len
argument_list|)
expr_stmt|;
name|p2p
operator|->
name|ssid_len
operator|=
name|force_ssid_len
expr_stmt|;
name|p2p
operator|->
name|ssid_set
operator|=
literal|1
expr_stmt|;
block|}
name|dev
operator|->
name|flags
operator|&=
operator|~
name|P2P_DEV_NOT_YET_READY
expr_stmt|;
name|dev
operator|->
name|flags
operator|&=
operator|~
name|P2P_DEV_USER_REJECTED
expr_stmt|;
name|dev
operator|->
name|go_neg_req_sent
operator|=
literal|0
expr_stmt|;
name|dev
operator|->
name|go_state
operator|=
name|UNKNOWN_GO
expr_stmt|;
name|p2p_set_dev_persistent
argument_list|(
name|dev
argument_list|,
name|persistent_group
argument_list|)
expr_stmt|;
name|p2p
operator|->
name|go_intent
operator|=
name|go_intent
expr_stmt|;
name|os_memcpy
argument_list|(
name|p2p
operator|->
name|intended_addr
argument_list|,
name|own_interface_addr
argument_list|,
name|ETH_ALEN
argument_list|)
expr_stmt|;
name|dev
operator|->
name|wps_method
operator|=
name|wps_method
expr_stmt|;
name|dev
operator|->
name|oob_pw_id
operator|=
name|oob_pw_id
expr_stmt|;
name|dev
operator|->
name|status
operator|=
name|P2P_SC_SUCCESS
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|p2p_add_dev_info
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|,
specifier|const
name|u8
modifier|*
name|addr
parameter_list|,
name|struct
name|p2p_device
modifier|*
name|dev
parameter_list|,
name|struct
name|p2p_message
modifier|*
name|msg
parameter_list|)
block|{
name|os_get_reltime
argument_list|(
operator|&
name|dev
operator|->
name|last_seen
argument_list|)
expr_stmt|;
name|p2p_copy_wps_info
argument_list|(
name|p2p
argument_list|,
name|dev
argument_list|,
literal|0
argument_list|,
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
operator|->
name|listen_channel
condition|)
block|{
name|int
name|freq
decl_stmt|;
name|freq
operator|=
name|p2p_channel_to_freq
argument_list|(
name|msg
operator|->
name|listen_channel
index|[
literal|3
index|]
argument_list|,
name|msg
operator|->
name|listen_channel
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|freq
operator|<
literal|0
condition|)
block|{
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Unknown peer Listen channel: "
literal|"country=%c%c(0x%02x) reg_class=%u channel=%u"
argument_list|,
name|msg
operator|->
name|listen_channel
index|[
literal|0
index|]
argument_list|,
name|msg
operator|->
name|listen_channel
index|[
literal|1
index|]
argument_list|,
name|msg
operator|->
name|listen_channel
index|[
literal|2
index|]
argument_list|,
name|msg
operator|->
name|listen_channel
index|[
literal|3
index|]
argument_list|,
name|msg
operator|->
name|listen_channel
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Update peer "
name|MACSTR
literal|" Listen channel: %u -> %u MHz"
argument_list|,
name|MAC2STR
argument_list|(
name|dev
operator|->
name|info
operator|.
name|p2p_device_addr
argument_list|)
argument_list|,
name|dev
operator|->
name|listen_freq
argument_list|,
name|freq
argument_list|)
expr_stmt|;
name|dev
operator|->
name|listen_freq
operator|=
name|freq
expr_stmt|;
block|}
block|}
if|if
condition|(
name|msg
operator|->
name|wfd_subelems
condition|)
block|{
name|wpabuf_free
argument_list|(
name|dev
operator|->
name|info
operator|.
name|wfd_subelems
argument_list|)
expr_stmt|;
name|dev
operator|->
name|info
operator|.
name|wfd_subelems
operator|=
name|wpabuf_dup
argument_list|(
name|msg
operator|->
name|wfd_subelems
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dev
operator|->
name|flags
operator|&
name|P2P_DEV_PROBE_REQ_ONLY
condition|)
block|{
name|dev
operator|->
name|flags
operator|&=
operator|~
name|P2P_DEV_PROBE_REQ_ONLY
expr_stmt|;
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Completed device entry based on data from GO Negotiation Request"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Created device entry based on GO Neg Req: "
name|MACSTR
literal|" dev_capab=0x%x group_capab=0x%x name='%s' "
literal|"listen_freq=%d"
argument_list|,
name|MAC2STR
argument_list|(
name|dev
operator|->
name|info
operator|.
name|p2p_device_addr
argument_list|)
argument_list|,
name|dev
operator|->
name|info
operator|.
name|dev_capab
argument_list|,
name|dev
operator|->
name|info
operator|.
name|group_capab
argument_list|,
name|dev
operator|->
name|info
operator|.
name|device_name
argument_list|,
name|dev
operator|->
name|listen_freq
argument_list|)
expr_stmt|;
block|}
name|dev
operator|->
name|flags
operator|&=
operator|~
name|P2P_DEV_GROUP_CLIENT_ONLY
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|flags
operator|&
name|P2P_DEV_USER_REJECTED
condition|)
block|{
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Do not report rejected device"
argument_list|)
expr_stmt|;
return|return;
block|}
name|p2p
operator|->
name|cfg
operator|->
name|dev_found
argument_list|(
name|p2p
operator|->
name|cfg
operator|->
name|cb_ctx
argument_list|,
name|addr
argument_list|,
operator|&
name|dev
operator|->
name|info
argument_list|,
operator|!
operator|(
name|dev
operator|->
name|flags
operator|&
name|P2P_DEV_REPORTED_ONCE
operator|)
argument_list|)
expr_stmt|;
name|dev
operator|->
name|flags
operator||=
name|P2P_DEV_REPORTED
operator||
name|P2P_DEV_REPORTED_ONCE
expr_stmt|;
block|}
end_function

begin_function
name|void
name|p2p_build_ssid
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|,
name|u8
modifier|*
name|ssid
parameter_list|,
name|size_t
modifier|*
name|ssid_len
parameter_list|)
block|{
name|os_memcpy
argument_list|(
name|ssid
argument_list|,
name|P2P_WILDCARD_SSID
argument_list|,
name|P2P_WILDCARD_SSID_LEN
argument_list|)
expr_stmt|;
name|p2p_random
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|ssid
index|[
name|P2P_WILDCARD_SSID_LEN
index|]
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|os_memcpy
argument_list|(
operator|&
name|ssid
index|[
name|P2P_WILDCARD_SSID_LEN
operator|+
literal|2
index|]
argument_list|,
name|p2p
operator|->
name|cfg
operator|->
name|ssid_postfix
argument_list|,
name|p2p
operator|->
name|cfg
operator|->
name|ssid_postfix_len
argument_list|)
expr_stmt|;
operator|*
name|ssid_len
operator|=
name|P2P_WILDCARD_SSID_LEN
operator|+
literal|2
operator|+
name|p2p
operator|->
name|cfg
operator|->
name|ssid_postfix_len
expr_stmt|;
block|}
end_function

begin_function
name|int
name|p2p_go_params
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|,
name|struct
name|p2p_go_neg_results
modifier|*
name|params
parameter_list|)
block|{
if|if
condition|(
name|p2p
operator|->
name|ssid_set
condition|)
block|{
name|os_memcpy
argument_list|(
name|params
operator|->
name|ssid
argument_list|,
name|p2p
operator|->
name|ssid
argument_list|,
name|p2p
operator|->
name|ssid_len
argument_list|)
expr_stmt|;
name|params
operator|->
name|ssid_len
operator|=
name|p2p
operator|->
name|ssid_len
expr_stmt|;
block|}
else|else
block|{
name|p2p_build_ssid
argument_list|(
name|p2p
argument_list|,
name|params
operator|->
name|ssid
argument_list|,
operator|&
name|params
operator|->
name|ssid_len
argument_list|)
expr_stmt|;
block|}
name|p2p
operator|->
name|ssid_set
operator|=
literal|0
expr_stmt|;
name|p2p_random
argument_list|(
name|params
operator|->
name|passphrase
argument_list|,
name|p2p
operator|->
name|cfg
operator|->
name|passphrase_len
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|p2p_go_complete
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|,
name|struct
name|p2p_device
modifier|*
name|peer
parameter_list|)
block|{
name|struct
name|p2p_go_neg_results
name|res
decl_stmt|;
name|int
name|go
init|=
name|peer
operator|->
name|go_state
operator|==
name|LOCAL_GO
decl_stmt|;
name|struct
name|p2p_channels
name|intersection
decl_stmt|;
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"GO Negotiation with "
name|MACSTR
literal|" completed (%s will be GO)"
argument_list|,
name|MAC2STR
argument_list|(
name|peer
operator|->
name|info
operator|.
name|p2p_device_addr
argument_list|)
argument_list|,
name|go
condition|?
literal|"local end"
else|:
literal|"peer"
argument_list|)
expr_stmt|;
name|os_memset
argument_list|(
operator|&
name|res
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|res
argument_list|)
argument_list|)
expr_stmt|;
name|res
operator|.
name|role_go
operator|=
name|go
expr_stmt|;
name|os_memcpy
argument_list|(
name|res
operator|.
name|peer_device_addr
argument_list|,
name|peer
operator|->
name|info
operator|.
name|p2p_device_addr
argument_list|,
name|ETH_ALEN
argument_list|)
expr_stmt|;
name|os_memcpy
argument_list|(
name|res
operator|.
name|peer_interface_addr
argument_list|,
name|peer
operator|->
name|intended_addr
argument_list|,
name|ETH_ALEN
argument_list|)
expr_stmt|;
name|res
operator|.
name|wps_method
operator|=
name|peer
operator|->
name|wps_method
expr_stmt|;
if|if
condition|(
name|peer
operator|->
name|flags
operator|&
name|P2P_DEV_PREFER_PERSISTENT_GROUP
condition|)
block|{
if|if
condition|(
name|peer
operator|->
name|flags
operator|&
name|P2P_DEV_PREFER_PERSISTENT_RECONN
condition|)
name|res
operator|.
name|persistent_group
operator|=
literal|2
expr_stmt|;
else|else
name|res
operator|.
name|persistent_group
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|go
condition|)
block|{
comment|/* Setup AP mode for WPS provisioning */
name|res
operator|.
name|freq
operator|=
name|p2p_channel_to_freq
argument_list|(
name|p2p
operator|->
name|op_reg_class
argument_list|,
name|p2p
operator|->
name|op_channel
argument_list|)
expr_stmt|;
name|os_memcpy
argument_list|(
name|res
operator|.
name|ssid
argument_list|,
name|p2p
operator|->
name|ssid
argument_list|,
name|p2p
operator|->
name|ssid_len
argument_list|)
expr_stmt|;
name|res
operator|.
name|ssid_len
operator|=
name|p2p
operator|->
name|ssid_len
expr_stmt|;
name|p2p_random
argument_list|(
name|res
operator|.
name|passphrase
argument_list|,
name|p2p
operator|->
name|cfg
operator|->
name|passphrase_len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|res
operator|.
name|freq
operator|=
name|peer
operator|->
name|oper_freq
expr_stmt|;
if|if
condition|(
name|p2p
operator|->
name|ssid_len
condition|)
block|{
name|os_memcpy
argument_list|(
name|res
operator|.
name|ssid
argument_list|,
name|p2p
operator|->
name|ssid
argument_list|,
name|p2p
operator|->
name|ssid_len
argument_list|)
expr_stmt|;
name|res
operator|.
name|ssid_len
operator|=
name|p2p
operator|->
name|ssid_len
expr_stmt|;
block|}
block|}
name|p2p_channels_dump
argument_list|(
name|p2p
argument_list|,
literal|"own channels"
argument_list|,
operator|&
name|p2p
operator|->
name|channels
argument_list|)
expr_stmt|;
name|p2p_channels_dump
argument_list|(
name|p2p
argument_list|,
literal|"peer channels"
argument_list|,
operator|&
name|peer
operator|->
name|channels
argument_list|)
expr_stmt|;
name|p2p_channels_intersect
argument_list|(
operator|&
name|p2p
operator|->
name|channels
argument_list|,
operator|&
name|peer
operator|->
name|channels
argument_list|,
operator|&
name|intersection
argument_list|)
expr_stmt|;
if|if
condition|(
name|go
condition|)
block|{
name|p2p_channels_remove_freqs
argument_list|(
operator|&
name|intersection
argument_list|,
operator|&
name|p2p
operator|->
name|no_go_freq
argument_list|)
expr_stmt|;
name|p2p_channels_dump
argument_list|(
name|p2p
argument_list|,
literal|"intersection after no-GO removal"
argument_list|,
operator|&
name|intersection
argument_list|)
expr_stmt|;
block|}
name|p2p_channels_to_freqs
argument_list|(
operator|&
name|intersection
argument_list|,
name|res
operator|.
name|freq_list
argument_list|,
name|P2P_MAX_CHANNELS
argument_list|)
expr_stmt|;
name|res
operator|.
name|peer_config_timeout
operator|=
name|go
condition|?
name|peer
operator|->
name|client_timeout
else|:
name|peer
operator|->
name|go_timeout
expr_stmt|;
name|p2p_clear_timeout
argument_list|(
name|p2p
argument_list|)
expr_stmt|;
name|p2p
operator|->
name|ssid_set
operator|=
literal|0
expr_stmt|;
name|peer
operator|->
name|go_neg_req_sent
operator|=
literal|0
expr_stmt|;
name|peer
operator|->
name|wps_method
operator|=
name|WPS_NOT_READY
expr_stmt|;
name|peer
operator|->
name|oob_pw_id
operator|=
literal|0
expr_stmt|;
name|wpabuf_free
argument_list|(
name|peer
operator|->
name|go_neg_conf
argument_list|)
expr_stmt|;
name|peer
operator|->
name|go_neg_conf
operator|=
name|NULL
expr_stmt|;
name|p2p_set_state
argument_list|(
name|p2p
argument_list|,
name|P2P_PROVISIONING
argument_list|)
expr_stmt|;
name|p2p
operator|->
name|cfg
operator|->
name|go_neg_completed
argument_list|(
name|p2p
operator|->
name|cfg
operator|->
name|cb_ctx
argument_list|,
operator|&
name|res
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|p2p_rx_p2p_action
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|,
specifier|const
name|u8
modifier|*
name|sa
parameter_list|,
specifier|const
name|u8
modifier|*
name|data
parameter_list|,
name|size_t
name|len
parameter_list|,
name|int
name|rx_freq
parameter_list|)
block|{
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"RX P2P Public Action from "
name|MACSTR
argument_list|,
name|MAC2STR
argument_list|(
name|sa
argument_list|)
argument_list|)
expr_stmt|;
name|wpa_hexdump
argument_list|(
name|MSG_MSGDUMP
argument_list|,
literal|"P2P: P2P Public Action contents"
argument_list|,
name|data
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|1
condition|)
return|return;
switch|switch
condition|(
name|data
index|[
literal|0
index|]
condition|)
block|{
case|case
name|P2P_GO_NEG_REQ
case|:
name|p2p_process_go_neg_req
argument_list|(
name|p2p
argument_list|,
name|sa
argument_list|,
name|data
operator|+
literal|1
argument_list|,
name|len
operator|-
literal|1
argument_list|,
name|rx_freq
argument_list|)
expr_stmt|;
break|break;
case|case
name|P2P_GO_NEG_RESP
case|:
name|p2p_process_go_neg_resp
argument_list|(
name|p2p
argument_list|,
name|sa
argument_list|,
name|data
operator|+
literal|1
argument_list|,
name|len
operator|-
literal|1
argument_list|,
name|rx_freq
argument_list|)
expr_stmt|;
break|break;
case|case
name|P2P_GO_NEG_CONF
case|:
name|p2p_process_go_neg_conf
argument_list|(
name|p2p
argument_list|,
name|sa
argument_list|,
name|data
operator|+
literal|1
argument_list|,
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|P2P_INVITATION_REQ
case|:
name|p2p_process_invitation_req
argument_list|(
name|p2p
argument_list|,
name|sa
argument_list|,
name|data
operator|+
literal|1
argument_list|,
name|len
operator|-
literal|1
argument_list|,
name|rx_freq
argument_list|)
expr_stmt|;
break|break;
case|case
name|P2P_INVITATION_RESP
case|:
name|p2p_process_invitation_resp
argument_list|(
name|p2p
argument_list|,
name|sa
argument_list|,
name|data
operator|+
literal|1
argument_list|,
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|P2P_PROV_DISC_REQ
case|:
name|p2p_process_prov_disc_req
argument_list|(
name|p2p
argument_list|,
name|sa
argument_list|,
name|data
operator|+
literal|1
argument_list|,
name|len
operator|-
literal|1
argument_list|,
name|rx_freq
argument_list|)
expr_stmt|;
break|break;
case|case
name|P2P_PROV_DISC_RESP
case|:
name|p2p_process_prov_disc_resp
argument_list|(
name|p2p
argument_list|,
name|sa
argument_list|,
name|data
operator|+
literal|1
argument_list|,
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|P2P_DEV_DISC_REQ
case|:
name|p2p_process_dev_disc_req
argument_list|(
name|p2p
argument_list|,
name|sa
argument_list|,
name|data
operator|+
literal|1
argument_list|,
name|len
operator|-
literal|1
argument_list|,
name|rx_freq
argument_list|)
expr_stmt|;
break|break;
case|case
name|P2P_DEV_DISC_RESP
case|:
name|p2p_process_dev_disc_resp
argument_list|(
name|p2p
argument_list|,
name|sa
argument_list|,
name|data
operator|+
literal|1
argument_list|,
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
default|default:
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Unsupported P2P Public Action frame type %d"
argument_list|,
name|data
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|p2p_rx_action_public
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|,
specifier|const
name|u8
modifier|*
name|da
parameter_list|,
specifier|const
name|u8
modifier|*
name|sa
parameter_list|,
specifier|const
name|u8
modifier|*
name|bssid
parameter_list|,
specifier|const
name|u8
modifier|*
name|data
parameter_list|,
name|size_t
name|len
parameter_list|,
name|int
name|freq
parameter_list|)
block|{
if|if
condition|(
name|len
operator|<
literal|1
condition|)
return|return;
switch|switch
condition|(
name|data
index|[
literal|0
index|]
condition|)
block|{
case|case
name|WLAN_PA_VENDOR_SPECIFIC
case|:
name|data
operator|++
expr_stmt|;
name|len
operator|--
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|4
condition|)
return|return;
if|if
condition|(
name|WPA_GET_BE32
argument_list|(
name|data
argument_list|)
operator|!=
name|P2P_IE_VENDOR_TYPE
condition|)
return|return;
name|data
operator|+=
literal|4
expr_stmt|;
name|len
operator|-=
literal|4
expr_stmt|;
name|p2p_rx_p2p_action
argument_list|(
name|p2p
argument_list|,
name|sa
argument_list|,
name|data
argument_list|,
name|len
argument_list|,
name|freq
argument_list|)
expr_stmt|;
break|break;
case|case
name|WLAN_PA_GAS_INITIAL_REQ
case|:
name|p2p_rx_gas_initial_req
argument_list|(
name|p2p
argument_list|,
name|sa
argument_list|,
name|data
operator|+
literal|1
argument_list|,
name|len
operator|-
literal|1
argument_list|,
name|freq
argument_list|)
expr_stmt|;
break|break;
case|case
name|WLAN_PA_GAS_INITIAL_RESP
case|:
name|p2p_rx_gas_initial_resp
argument_list|(
name|p2p
argument_list|,
name|sa
argument_list|,
name|data
operator|+
literal|1
argument_list|,
name|len
operator|-
literal|1
argument_list|,
name|freq
argument_list|)
expr_stmt|;
break|break;
case|case
name|WLAN_PA_GAS_COMEBACK_REQ
case|:
name|p2p_rx_gas_comeback_req
argument_list|(
name|p2p
argument_list|,
name|sa
argument_list|,
name|data
operator|+
literal|1
argument_list|,
name|len
operator|-
literal|1
argument_list|,
name|freq
argument_list|)
expr_stmt|;
break|break;
case|case
name|WLAN_PA_GAS_COMEBACK_RESP
case|:
name|p2p_rx_gas_comeback_resp
argument_list|(
name|p2p
argument_list|,
name|sa
argument_list|,
name|data
operator|+
literal|1
argument_list|,
name|len
operator|-
literal|1
argument_list|,
name|freq
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
name|void
name|p2p_rx_action
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|,
specifier|const
name|u8
modifier|*
name|da
parameter_list|,
specifier|const
name|u8
modifier|*
name|sa
parameter_list|,
specifier|const
name|u8
modifier|*
name|bssid
parameter_list|,
name|u8
name|category
parameter_list|,
specifier|const
name|u8
modifier|*
name|data
parameter_list|,
name|size_t
name|len
parameter_list|,
name|int
name|freq
parameter_list|)
block|{
if|if
condition|(
name|category
operator|==
name|WLAN_ACTION_PUBLIC
condition|)
block|{
name|p2p_rx_action_public
argument_list|(
name|p2p
argument_list|,
name|da
argument_list|,
name|sa
argument_list|,
name|bssid
argument_list|,
name|data
argument_list|,
name|len
argument_list|,
name|freq
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|category
operator|!=
name|WLAN_ACTION_VENDOR_SPECIFIC
condition|)
return|return;
if|if
condition|(
name|len
operator|<
literal|4
condition|)
return|return;
if|if
condition|(
name|WPA_GET_BE32
argument_list|(
name|data
argument_list|)
operator|!=
name|P2P_IE_VENDOR_TYPE
condition|)
return|return;
name|data
operator|+=
literal|4
expr_stmt|;
name|len
operator|-=
literal|4
expr_stmt|;
comment|/* P2P action frame */
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"RX P2P Action from "
name|MACSTR
argument_list|,
name|MAC2STR
argument_list|(
name|sa
argument_list|)
argument_list|)
expr_stmt|;
name|wpa_hexdump
argument_list|(
name|MSG_MSGDUMP
argument_list|,
literal|"P2P: P2P Action contents"
argument_list|,
name|data
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|1
condition|)
return|return;
switch|switch
condition|(
name|data
index|[
literal|0
index|]
condition|)
block|{
case|case
name|P2P_NOA
case|:
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Received P2P Action - Notice of Absence"
argument_list|)
expr_stmt|;
comment|/* TODO */
break|break;
case|case
name|P2P_PRESENCE_REQ
case|:
name|p2p_process_presence_req
argument_list|(
name|p2p
argument_list|,
name|da
argument_list|,
name|sa
argument_list|,
name|data
operator|+
literal|1
argument_list|,
name|len
operator|-
literal|1
argument_list|,
name|freq
argument_list|)
expr_stmt|;
break|break;
case|case
name|P2P_PRESENCE_RESP
case|:
name|p2p_process_presence_resp
argument_list|(
name|p2p
argument_list|,
name|da
argument_list|,
name|sa
argument_list|,
name|data
operator|+
literal|1
argument_list|,
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|P2P_GO_DISC_REQ
case|:
name|p2p_process_go_disc_req
argument_list|(
name|p2p
argument_list|,
name|da
argument_list|,
name|sa
argument_list|,
name|data
operator|+
literal|1
argument_list|,
name|len
operator|-
literal|1
argument_list|,
name|freq
argument_list|)
expr_stmt|;
break|break;
default|default:
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Received P2P Action - unknown type %u"
argument_list|,
name|data
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|p2p_go_neg_start
parameter_list|(
name|void
modifier|*
name|eloop_ctx
parameter_list|,
name|void
modifier|*
name|timeout_ctx
parameter_list|)
block|{
name|struct
name|p2p_data
modifier|*
name|p2p
init|=
name|eloop_ctx
decl_stmt|;
if|if
condition|(
name|p2p
operator|->
name|go_neg_peer
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|p2p
operator|->
name|pending_listen_freq
condition|)
block|{
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Clear pending_listen_freq for p2p_go_neg_start"
argument_list|)
expr_stmt|;
name|p2p
operator|->
name|pending_listen_freq
operator|=
literal|0
expr_stmt|;
block|}
name|p2p
operator|->
name|cfg
operator|->
name|stop_listen
argument_list|(
name|p2p
operator|->
name|cfg
operator|->
name|cb_ctx
argument_list|)
expr_stmt|;
name|p2p
operator|->
name|go_neg_peer
operator|->
name|status
operator|=
name|P2P_SC_SUCCESS
expr_stmt|;
comment|/* 	 * Set new timeout to make sure a previously set one does not expire 	 * too quickly while waiting for the GO Negotiation to complete. 	 */
name|p2p_set_timeout
argument_list|(
name|p2p
argument_list|,
literal|0
argument_list|,
literal|500000
argument_list|)
expr_stmt|;
name|p2p_connect_send
argument_list|(
name|p2p
argument_list|,
name|p2p
operator|->
name|go_neg_peer
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|p2p_invite_start
parameter_list|(
name|void
modifier|*
name|eloop_ctx
parameter_list|,
name|void
modifier|*
name|timeout_ctx
parameter_list|)
block|{
name|struct
name|p2p_data
modifier|*
name|p2p
init|=
name|eloop_ctx
decl_stmt|;
if|if
condition|(
name|p2p
operator|->
name|invite_peer
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|p2p
operator|->
name|pending_listen_freq
condition|)
block|{
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Clear pending_listen_freq for p2p_invite_start"
argument_list|)
expr_stmt|;
name|p2p
operator|->
name|pending_listen_freq
operator|=
literal|0
expr_stmt|;
block|}
name|p2p
operator|->
name|cfg
operator|->
name|stop_listen
argument_list|(
name|p2p
operator|->
name|cfg
operator|->
name|cb_ctx
argument_list|)
expr_stmt|;
name|p2p_invite_send
argument_list|(
name|p2p
argument_list|,
name|p2p
operator|->
name|invite_peer
argument_list|,
name|p2p
operator|->
name|invite_go_dev_addr
argument_list|,
name|p2p
operator|->
name|invite_dev_pw_id
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|p2p_add_dev_from_probe_req
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|,
specifier|const
name|u8
modifier|*
name|addr
parameter_list|,
specifier|const
name|u8
modifier|*
name|ie
parameter_list|,
name|size_t
name|ie_len
parameter_list|)
block|{
name|struct
name|p2p_message
name|msg
decl_stmt|;
name|struct
name|p2p_device
modifier|*
name|dev
decl_stmt|;
name|os_memset
argument_list|(
operator|&
name|msg
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p2p_parse_ies
argument_list|(
name|ie
argument_list|,
name|ie_len
argument_list|,
operator|&
name|msg
argument_list|)
operator|<
literal|0
operator|||
name|msg
operator|.
name|p2p_attributes
operator|==
name|NULL
condition|)
block|{
name|p2p_parse_free
argument_list|(
operator|&
name|msg
argument_list|)
expr_stmt|;
return|return;
comment|/* not a P2P probe */
block|}
if|if
condition|(
name|msg
operator|.
name|ssid
operator|==
name|NULL
operator|||
name|msg
operator|.
name|ssid
index|[
literal|1
index|]
operator|!=
name|P2P_WILDCARD_SSID_LEN
operator|||
name|os_memcmp
argument_list|(
name|msg
operator|.
name|ssid
operator|+
literal|2
argument_list|,
name|P2P_WILDCARD_SSID
argument_list|,
name|P2P_WILDCARD_SSID_LEN
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* The Probe Request is not part of P2P Device Discovery. It is 		 * not known whether the source address of the frame is the P2P 		 * Device Address or P2P Interface Address. Do not add a new 		 * peer entry based on this frames. 		 */
name|p2p_parse_free
argument_list|(
operator|&
name|msg
argument_list|)
expr_stmt|;
return|return;
block|}
name|dev
operator|=
name|p2p_get_device
argument_list|(
name|p2p
argument_list|,
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
condition|)
block|{
if|if
condition|(
name|dev
operator|->
name|country
index|[
literal|0
index|]
operator|==
literal|0
operator|&&
name|msg
operator|.
name|listen_channel
condition|)
name|os_memcpy
argument_list|(
name|dev
operator|->
name|country
argument_list|,
name|msg
operator|.
name|listen_channel
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|os_get_reltime
argument_list|(
operator|&
name|dev
operator|->
name|last_seen
argument_list|)
expr_stmt|;
name|p2p_parse_free
argument_list|(
operator|&
name|msg
argument_list|)
expr_stmt|;
return|return;
comment|/* already known */
block|}
name|dev
operator|=
name|p2p_create_device
argument_list|(
name|p2p
argument_list|,
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|==
name|NULL
condition|)
block|{
name|p2p_parse_free
argument_list|(
operator|&
name|msg
argument_list|)
expr_stmt|;
return|return;
block|}
name|os_get_reltime
argument_list|(
operator|&
name|dev
operator|->
name|last_seen
argument_list|)
expr_stmt|;
name|dev
operator|->
name|flags
operator||=
name|P2P_DEV_PROBE_REQ_ONLY
expr_stmt|;
if|if
condition|(
name|msg
operator|.
name|listen_channel
condition|)
block|{
name|os_memcpy
argument_list|(
name|dev
operator|->
name|country
argument_list|,
name|msg
operator|.
name|listen_channel
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|dev
operator|->
name|listen_freq
operator|=
name|p2p_channel_to_freq
argument_list|(
name|msg
operator|.
name|listen_channel
index|[
literal|3
index|]
argument_list|,
name|msg
operator|.
name|listen_channel
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
block|}
name|p2p_copy_wps_info
argument_list|(
name|p2p
argument_list|,
name|dev
argument_list|,
literal|1
argument_list|,
operator|&
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
operator|.
name|wfd_subelems
condition|)
block|{
name|wpabuf_free
argument_list|(
name|dev
operator|->
name|info
operator|.
name|wfd_subelems
argument_list|)
expr_stmt|;
name|dev
operator|->
name|info
operator|.
name|wfd_subelems
operator|=
name|wpabuf_dup
argument_list|(
name|msg
operator|.
name|wfd_subelems
argument_list|)
expr_stmt|;
block|}
name|p2p_parse_free
argument_list|(
operator|&
name|msg
argument_list|)
expr_stmt|;
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Created device entry based on Probe Req: "
name|MACSTR
literal|" dev_capab=0x%x group_capab=0x%x name='%s' listen_freq=%d"
argument_list|,
name|MAC2STR
argument_list|(
name|dev
operator|->
name|info
operator|.
name|p2p_device_addr
argument_list|)
argument_list|,
name|dev
operator|->
name|info
operator|.
name|dev_capab
argument_list|,
name|dev
operator|->
name|info
operator|.
name|group_capab
argument_list|,
name|dev
operator|->
name|info
operator|.
name|device_name
argument_list|,
name|dev
operator|->
name|listen_freq
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|p2p_device
modifier|*
name|p2p_add_dev_from_go_neg_req
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|,
specifier|const
name|u8
modifier|*
name|addr
parameter_list|,
name|struct
name|p2p_message
modifier|*
name|msg
parameter_list|)
block|{
name|struct
name|p2p_device
modifier|*
name|dev
decl_stmt|;
name|dev
operator|=
name|p2p_get_device
argument_list|(
name|p2p
argument_list|,
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
condition|)
block|{
name|os_get_reltime
argument_list|(
operator|&
name|dev
operator|->
name|last_seen
argument_list|)
expr_stmt|;
return|return
name|dev
return|;
comment|/* already known */
block|}
name|dev
operator|=
name|p2p_create_device
argument_list|(
name|p2p
argument_list|,
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|p2p_add_dev_info
argument_list|(
name|p2p
argument_list|,
name|addr
argument_list|,
name|dev
argument_list|,
name|msg
argument_list|)
expr_stmt|;
return|return
name|dev
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dev_type_match
parameter_list|(
specifier|const
name|u8
modifier|*
name|dev_type
parameter_list|,
specifier|const
name|u8
modifier|*
name|req_dev_type
parameter_list|)
block|{
if|if
condition|(
name|os_memcmp
argument_list|(
name|dev_type
argument_list|,
name|req_dev_type
argument_list|,
name|WPS_DEV_TYPE_LEN
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|os_memcmp
argument_list|(
name|dev_type
argument_list|,
name|req_dev_type
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
operator|&&
name|WPA_GET_BE32
argument_list|(
operator|&
name|req_dev_type
index|[
literal|2
index|]
argument_list|)
operator|==
literal|0
operator|&&
name|WPA_GET_BE16
argument_list|(
operator|&
name|req_dev_type
index|[
literal|6
index|]
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
comment|/* Category match with wildcard OUI/sub-category */
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|dev_type_list_match
parameter_list|(
specifier|const
name|u8
modifier|*
name|dev_type
parameter_list|,
specifier|const
name|u8
modifier|*
name|req_dev_type
index|[]
parameter_list|,
name|size_t
name|num_req_dev_type
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_req_dev_type
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|dev_type_match
argument_list|(
name|dev_type
argument_list|,
name|req_dev_type
index|[
name|i
index|]
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * p2p_match_dev_type - Match local device type with requested type  * @p2p: P2P module context from p2p_init()  * @wps: WPS TLVs from Probe Request frame (concatenated WPS IEs)  * Returns: 1 on match, 0 on mismatch  *  * This function can be used to match the Requested Device Type attribute in  * WPS IE with the local device types for deciding whether to reply to a Probe  * Request frame.  */
end_comment

begin_function
name|int
name|p2p_match_dev_type
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|,
name|struct
name|wpabuf
modifier|*
name|wps
parameter_list|)
block|{
name|struct
name|wps_parse_attr
name|attr
decl_stmt|;
name|size_t
name|i
decl_stmt|;
if|if
condition|(
name|wps_parse_msg
argument_list|(
name|wps
argument_list|,
operator|&
name|attr
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* assume no Requested Device Type attributes */
if|if
condition|(
name|attr
operator|.
name|num_req_dev_type
operator|==
literal|0
condition|)
return|return
literal|1
return|;
comment|/* no Requested Device Type attributes -> match */
if|if
condition|(
name|dev_type_list_match
argument_list|(
name|p2p
operator|->
name|cfg
operator|->
name|pri_dev_type
argument_list|,
name|attr
operator|.
name|req_dev_type
argument_list|,
name|attr
operator|.
name|num_req_dev_type
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* Own Primary Device Type matches */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p2p
operator|->
name|cfg
operator|->
name|num_sec_dev_types
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|dev_type_list_match
argument_list|(
name|p2p
operator|->
name|cfg
operator|->
name|sec_dev_type
index|[
name|i
index|]
argument_list|,
name|attr
operator|.
name|req_dev_type
argument_list|,
name|attr
operator|.
name|num_req_dev_type
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* Own Secondary Device Type matches */
block|}
comment|/* No matching device type found */
return|return
literal|0
return|;
block|}
end_function

begin_function
name|struct
name|wpabuf
modifier|*
name|p2p_build_probe_resp_ies
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|,
specifier|const
name|u8
modifier|*
name|query_hash
parameter_list|,
name|u8
name|query_count
parameter_list|)
block|{
name|struct
name|wpabuf
modifier|*
name|buf
decl_stmt|;
name|u8
modifier|*
name|len
decl_stmt|;
name|int
name|pw_id
init|=
operator|-
literal|1
decl_stmt|;
name|size_t
name|extra
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|CONFIG_WIFI_DISPLAY
if|if
condition|(
name|p2p
operator|->
name|wfd_ie_probe_resp
condition|)
name|extra
operator|=
name|wpabuf_len
argument_list|(
name|p2p
operator|->
name|wfd_ie_probe_resp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* CONFIG_WIFI_DISPLAY */
if|if
condition|(
name|p2p
operator|->
name|vendor_elem
operator|&&
name|p2p
operator|->
name|vendor_elem
index|[
name|VENDOR_ELEM_PROBE_RESP_P2P
index|]
condition|)
name|extra
operator|+=
name|wpabuf_len
argument_list|(
name|p2p
operator|->
name|vendor_elem
index|[
name|VENDOR_ELEM_PROBE_RESP_P2P
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|query_count
condition|)
name|extra
operator|+=
name|MAX_SVC_ADV_IE_LEN
expr_stmt|;
name|buf
operator|=
name|wpabuf_alloc
argument_list|(
literal|1000
operator|+
name|extra
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|p2p
operator|->
name|go_neg_peer
condition|)
block|{
comment|/* Advertise immediate availability of WPS credential */
name|pw_id
operator|=
name|p2p_wps_method_pw_id
argument_list|(
name|p2p
operator|->
name|go_neg_peer
operator|->
name|wps_method
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p2p_build_wps_ie
argument_list|(
name|p2p
argument_list|,
name|buf
argument_list|,
name|pw_id
argument_list|,
literal|1
argument_list|)
operator|<
literal|0
condition|)
block|{
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Failed to build WPS IE for Probe Response"
argument_list|)
expr_stmt|;
name|wpabuf_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
ifdef|#
directive|ifdef
name|CONFIG_WIFI_DISPLAY
if|if
condition|(
name|p2p
operator|->
name|wfd_ie_probe_resp
condition|)
name|wpabuf_put_buf
argument_list|(
name|buf
argument_list|,
name|p2p
operator|->
name|wfd_ie_probe_resp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* CONFIG_WIFI_DISPLAY */
if|if
condition|(
name|p2p
operator|->
name|vendor_elem
operator|&&
name|p2p
operator|->
name|vendor_elem
index|[
name|VENDOR_ELEM_PROBE_RESP_P2P
index|]
condition|)
name|wpabuf_put_buf
argument_list|(
name|buf
argument_list|,
name|p2p
operator|->
name|vendor_elem
index|[
name|VENDOR_ELEM_PROBE_RESP_P2P
index|]
argument_list|)
expr_stmt|;
comment|/* P2P IE */
name|len
operator|=
name|p2p_buf_add_ie_hdr
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|p2p_buf_add_capability
argument_list|(
name|buf
argument_list|,
name|p2p
operator|->
name|dev_capab
operator|&
operator|~
name|P2P_DEV_CAPAB_CLIENT_DISCOVERABILITY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|p2p
operator|->
name|ext_listen_interval
condition|)
name|p2p_buf_add_ext_listen_timing
argument_list|(
name|buf
argument_list|,
name|p2p
operator|->
name|ext_listen_period
argument_list|,
name|p2p
operator|->
name|ext_listen_interval
argument_list|)
expr_stmt|;
name|p2p_buf_add_device_info
argument_list|(
name|buf
argument_list|,
name|p2p
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|p2p_buf_update_ie_hdr
argument_list|(
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|query_count
condition|)
block|{
name|p2p_buf_add_service_instance
argument_list|(
name|buf
argument_list|,
name|p2p
argument_list|,
name|query_count
argument_list|,
name|query_hash
argument_list|,
name|p2p
operator|->
name|p2ps_adv_list
argument_list|)
expr_stmt|;
block|}
return|return
name|buf
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|p2p_service_find_asp
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|,
specifier|const
name|u8
modifier|*
name|hash
parameter_list|)
block|{
name|struct
name|p2ps_advertisement
modifier|*
name|adv_data
decl_stmt|;
name|int
name|any_wfa
decl_stmt|;
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"ASP find - ASP list: %p"
argument_list|,
name|p2p
operator|->
name|p2ps_adv_list
argument_list|)
expr_stmt|;
comment|/* Wildcard org.wi-fi.wfds matches any WFA spec defined service */
name|any_wfa
operator|=
name|os_memcmp
argument_list|(
name|hash
argument_list|,
name|p2p
operator|->
name|wild_card_hash
argument_list|,
name|P2PS_HASH_LEN
argument_list|)
operator|==
literal|0
expr_stmt|;
name|adv_data
operator|=
name|p2p
operator|->
name|p2ps_adv_list
expr_stmt|;
while|while
condition|(
name|adv_data
condition|)
block|{
if|if
condition|(
name|os_memcmp
argument_list|(
name|hash
argument_list|,
name|adv_data
operator|->
name|hash
argument_list|,
name|P2PS_HASH_LEN
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
comment|/* exact hash match */
if|if
condition|(
name|any_wfa
operator|&&
name|os_strncmp
argument_list|(
name|adv_data
operator|->
name|svc_name
argument_list|,
name|P2PS_WILD_HASH_STR
argument_list|,
name|os_strlen
argument_list|(
name|P2PS_WILD_HASH_STR
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
comment|/* WFA service match */
name|adv_data
operator|=
name|adv_data
operator|->
name|next
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|p2p_probe_req_status
name|p2p_reply_probe
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|,
specifier|const
name|u8
modifier|*
name|addr
parameter_list|,
specifier|const
name|u8
modifier|*
name|dst
parameter_list|,
specifier|const
name|u8
modifier|*
name|bssid
parameter_list|,
specifier|const
name|u8
modifier|*
name|ie
parameter_list|,
name|size_t
name|ie_len
parameter_list|,
name|unsigned
name|int
name|rx_freq
parameter_list|)
block|{
name|struct
name|ieee802_11_elems
name|elems
decl_stmt|;
name|struct
name|wpabuf
modifier|*
name|buf
decl_stmt|;
name|struct
name|ieee80211_mgmt
modifier|*
name|resp
decl_stmt|;
name|struct
name|p2p_message
name|msg
decl_stmt|;
name|struct
name|wpabuf
modifier|*
name|ies
decl_stmt|;
name|u8
name|channel
decl_stmt|,
name|op_class
decl_stmt|;
if|if
condition|(
name|ieee802_11_parse_elems
argument_list|(
operator|(
name|u8
operator|*
operator|)
name|ie
argument_list|,
name|ie_len
argument_list|,
operator|&
name|elems
argument_list|,
literal|0
argument_list|)
operator|==
name|ParseFailed
condition|)
block|{
comment|/* Ignore invalid Probe Request frames */
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Could not parse Probe Request frame - ignore it"
argument_list|)
expr_stmt|;
return|return
name|P2P_PREQ_MALFORMED
return|;
block|}
if|if
condition|(
name|elems
operator|.
name|p2p
operator|==
name|NULL
condition|)
block|{
comment|/* not a P2P probe - ignore it */
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Not a P2P probe - ignore it"
argument_list|)
expr_stmt|;
return|return
name|P2P_PREQ_NOT_P2P
return|;
block|}
if|if
condition|(
name|dst
operator|&&
operator|!
name|is_broadcast_ether_addr
argument_list|(
name|dst
argument_list|)
operator|&&
name|os_memcmp
argument_list|(
name|dst
argument_list|,
name|p2p
operator|->
name|cfg
operator|->
name|dev_addr
argument_list|,
name|ETH_ALEN
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* Not sent to the broadcast address or our P2P Device Address 		 */
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Probe Req DA "
name|MACSTR
literal|" not ours - ignore it"
argument_list|,
name|MAC2STR
argument_list|(
name|dst
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|P2P_PREQ_NOT_PROCESSED
return|;
block|}
if|if
condition|(
name|bssid
operator|&&
operator|!
name|is_broadcast_ether_addr
argument_list|(
name|bssid
argument_list|)
condition|)
block|{
comment|/* Not sent to the Wildcard BSSID */
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Probe Req BSSID "
name|MACSTR
literal|" not wildcard - ignore it"
argument_list|,
name|MAC2STR
argument_list|(
name|bssid
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|P2P_PREQ_NOT_PROCESSED
return|;
block|}
if|if
condition|(
name|elems
operator|.
name|ssid
operator|==
name|NULL
operator|||
name|elems
operator|.
name|ssid_len
operator|!=
name|P2P_WILDCARD_SSID_LEN
operator|||
name|os_memcmp
argument_list|(
name|elems
operator|.
name|ssid
argument_list|,
name|P2P_WILDCARD_SSID
argument_list|,
name|P2P_WILDCARD_SSID_LEN
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* not using P2P Wildcard SSID - ignore */
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Probe Req not using P2P Wildcard SSID - ignore it"
argument_list|)
expr_stmt|;
return|return
name|P2P_PREQ_NOT_PROCESSED
return|;
block|}
if|if
condition|(
name|supp_rates_11b_only
argument_list|(
operator|&
name|elems
argument_list|)
condition|)
block|{
comment|/* Indicates support for 11b rates only */
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Probe Req with 11b rates only supported - ignore it"
argument_list|)
expr_stmt|;
return|return
name|P2P_PREQ_NOT_P2P
return|;
block|}
name|os_memset
argument_list|(
operator|&
name|msg
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p2p_parse_ies
argument_list|(
name|ie
argument_list|,
name|ie_len
argument_list|,
operator|&
name|msg
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* Could not parse P2P attributes */
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Could not parse P2P attributes in Probe Req - ignore it"
argument_list|)
expr_stmt|;
return|return
name|P2P_PREQ_NOT_P2P
return|;
block|}
if|if
condition|(
name|msg
operator|.
name|service_hash
operator|&&
name|msg
operator|.
name|service_hash_count
condition|)
block|{
specifier|const
name|u8
modifier|*
name|hash
init|=
name|msg
operator|.
name|service_hash
decl_stmt|;
name|u8
name|i
decl_stmt|;
name|int
name|p2ps_svc_found
init|=
literal|0
decl_stmt|;
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"in_listen=%d drv_in_listen=%d when received P2PS Probe Request at %u MHz; own Listen channel %u, pending listen freq %u MHz"
argument_list|,
name|p2p
operator|->
name|in_listen
argument_list|,
name|p2p
operator|->
name|drv_in_listen
argument_list|,
name|rx_freq
argument_list|,
name|p2p
operator|->
name|cfg
operator|->
name|channel
argument_list|,
name|p2p
operator|->
name|pending_listen_freq
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p2p
operator|->
name|in_listen
operator|&&
operator|!
name|p2p
operator|->
name|drv_in_listen
operator|&&
name|p2p
operator|->
name|pending_listen_freq
operator|&&
name|rx_freq
operator|&&
name|rx_freq
operator|!=
name|p2p
operator|->
name|pending_listen_freq
condition|)
block|{
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Do not reply to Probe Request frame that was received on %u MHz while waiting to start Listen state on %u MHz"
argument_list|,
name|rx_freq
argument_list|,
name|p2p
operator|->
name|pending_listen_freq
argument_list|)
expr_stmt|;
name|p2p_parse_free
argument_list|(
operator|&
name|msg
argument_list|)
expr_stmt|;
return|return
name|P2P_PREQ_NOT_LISTEN
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|msg
operator|.
name|service_hash_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|p2p_service_find_asp
argument_list|(
name|p2p
argument_list|,
name|hash
argument_list|)
condition|)
block|{
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Service Hash match found: "
name|MACSTR
argument_list|,
name|MAC2STR
argument_list|(
name|hash
argument_list|)
argument_list|)
expr_stmt|;
name|p2ps_svc_found
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|hash
operator|+=
name|P2PS_HASH_LEN
expr_stmt|;
block|}
comment|/* Probed hash unknown */
if|if
condition|(
operator|!
name|p2ps_svc_found
condition|)
block|{
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"No Service Hash match found"
argument_list|)
expr_stmt|;
name|p2p_parse_free
argument_list|(
operator|&
name|msg
argument_list|)
expr_stmt|;
return|return
name|P2P_PREQ_NOT_PROCESSED
return|;
block|}
block|}
else|else
block|{
comment|/* This is not a P2PS Probe Request */
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"No P2PS Hash in Probe Request"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p2p
operator|->
name|in_listen
operator|||
operator|!
name|p2p
operator|->
name|drv_in_listen
condition|)
block|{
comment|/* not in Listen state - ignore Probe Request */
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Not in Listen state (in_listen=%d drv_in_listen=%d) - ignore Probe Request"
argument_list|,
name|p2p
operator|->
name|in_listen
argument_list|,
name|p2p
operator|->
name|drv_in_listen
argument_list|)
expr_stmt|;
name|p2p_parse_free
argument_list|(
operator|&
name|msg
argument_list|)
expr_stmt|;
return|return
name|P2P_PREQ_NOT_LISTEN
return|;
block|}
block|}
if|if
condition|(
name|msg
operator|.
name|device_id
operator|&&
name|os_memcmp
argument_list|(
name|msg
operator|.
name|device_id
argument_list|,
name|p2p
operator|->
name|cfg
operator|->
name|dev_addr
argument_list|,
name|ETH_ALEN
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* Device ID did not match */
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Probe Req requested Device ID "
name|MACSTR
literal|" did not match - ignore it"
argument_list|,
name|MAC2STR
argument_list|(
name|msg
operator|.
name|device_id
argument_list|)
argument_list|)
expr_stmt|;
name|p2p_parse_free
argument_list|(
operator|&
name|msg
argument_list|)
expr_stmt|;
return|return
name|P2P_PREQ_NOT_PROCESSED
return|;
block|}
comment|/* Check Requested Device Type match */
if|if
condition|(
name|msg
operator|.
name|wps_attributes
operator|&&
operator|!
name|p2p_match_dev_type
argument_list|(
name|p2p
argument_list|,
name|msg
operator|.
name|wps_attributes
argument_list|)
condition|)
block|{
comment|/* No match with Requested Device Type */
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Probe Req requestred Device Type did not match - ignore it"
argument_list|)
expr_stmt|;
name|p2p_parse_free
argument_list|(
operator|&
name|msg
argument_list|)
expr_stmt|;
return|return
name|P2P_PREQ_NOT_PROCESSED
return|;
block|}
if|if
condition|(
operator|!
name|p2p
operator|->
name|cfg
operator|->
name|send_probe_resp
condition|)
block|{
comment|/* Response generated elsewhere */
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Probe Resp generated elsewhere - do not generate additional response"
argument_list|)
expr_stmt|;
name|p2p_parse_free
argument_list|(
operator|&
name|msg
argument_list|)
expr_stmt|;
return|return
name|P2P_PREQ_NOT_PROCESSED
return|;
block|}
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Reply to P2P Probe Request in Listen state"
argument_list|)
expr_stmt|;
comment|/* 	 * We do not really have a specific BSS that this frame is advertising, 	 * so build a frame that has some information in valid format. This is 	 * really only used for discovery purposes, not to learn exact BSS 	 * parameters. 	 */
name|ies
operator|=
name|p2p_build_probe_resp_ies
argument_list|(
name|p2p
argument_list|,
name|msg
operator|.
name|service_hash
argument_list|,
name|msg
operator|.
name|service_hash_count
argument_list|)
expr_stmt|;
name|p2p_parse_free
argument_list|(
operator|&
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|ies
operator|==
name|NULL
condition|)
return|return
name|P2P_PREQ_NOT_PROCESSED
return|;
name|buf
operator|=
name|wpabuf_alloc
argument_list|(
literal|200
operator|+
name|wpabuf_len
argument_list|(
name|ies
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
block|{
name|wpabuf_free
argument_list|(
name|ies
argument_list|)
expr_stmt|;
return|return
name|P2P_PREQ_NOT_PROCESSED
return|;
block|}
name|resp
operator|=
name|wpabuf_put
argument_list|(
name|buf
argument_list|,
name|offsetof
argument_list|(
expr|struct
name|ieee80211_mgmt
argument_list|,
name|u
operator|.
name|probe_resp
operator|.
name|variable
argument_list|)
argument_list|)
expr_stmt|;
name|resp
operator|->
name|frame_control
operator|=
name|host_to_le16
argument_list|(
operator|(
name|WLAN_FC_TYPE_MGMT
operator|<<
literal|2
operator|)
operator||
operator|(
name|WLAN_FC_STYPE_PROBE_RESP
operator|<<
literal|4
operator|)
argument_list|)
expr_stmt|;
name|os_memcpy
argument_list|(
name|resp
operator|->
name|da
argument_list|,
name|addr
argument_list|,
name|ETH_ALEN
argument_list|)
expr_stmt|;
name|os_memcpy
argument_list|(
name|resp
operator|->
name|sa
argument_list|,
name|p2p
operator|->
name|cfg
operator|->
name|dev_addr
argument_list|,
name|ETH_ALEN
argument_list|)
expr_stmt|;
name|os_memcpy
argument_list|(
name|resp
operator|->
name|bssid
argument_list|,
name|p2p
operator|->
name|cfg
operator|->
name|dev_addr
argument_list|,
name|ETH_ALEN
argument_list|)
expr_stmt|;
name|resp
operator|->
name|u
operator|.
name|probe_resp
operator|.
name|beacon_int
operator|=
name|host_to_le16
argument_list|(
literal|100
argument_list|)
expr_stmt|;
comment|/* hardware or low-level driver will setup seq_ctrl and timestamp */
name|resp
operator|->
name|u
operator|.
name|probe_resp
operator|.
name|capab_info
operator|=
name|host_to_le16
argument_list|(
name|WLAN_CAPABILITY_SHORT_PREAMBLE
operator||
name|WLAN_CAPABILITY_PRIVACY
operator||
name|WLAN_CAPABILITY_SHORT_SLOT_TIME
argument_list|)
expr_stmt|;
name|wpabuf_put_u8
argument_list|(
name|buf
argument_list|,
name|WLAN_EID_SSID
argument_list|)
expr_stmt|;
name|wpabuf_put_u8
argument_list|(
name|buf
argument_list|,
name|P2P_WILDCARD_SSID_LEN
argument_list|)
expr_stmt|;
name|wpabuf_put_data
argument_list|(
name|buf
argument_list|,
name|P2P_WILDCARD_SSID
argument_list|,
name|P2P_WILDCARD_SSID_LEN
argument_list|)
expr_stmt|;
name|wpabuf_put_u8
argument_list|(
name|buf
argument_list|,
name|WLAN_EID_SUPP_RATES
argument_list|)
expr_stmt|;
name|wpabuf_put_u8
argument_list|(
name|buf
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|wpabuf_put_u8
argument_list|(
name|buf
argument_list|,
operator|(
literal|60
operator|/
literal|5
operator|)
operator||
literal|0x80
argument_list|)
expr_stmt|;
name|wpabuf_put_u8
argument_list|(
name|buf
argument_list|,
literal|90
operator|/
literal|5
argument_list|)
expr_stmt|;
name|wpabuf_put_u8
argument_list|(
name|buf
argument_list|,
operator|(
literal|120
operator|/
literal|5
operator|)
operator||
literal|0x80
argument_list|)
expr_stmt|;
name|wpabuf_put_u8
argument_list|(
name|buf
argument_list|,
literal|180
operator|/
literal|5
argument_list|)
expr_stmt|;
name|wpabuf_put_u8
argument_list|(
name|buf
argument_list|,
operator|(
literal|240
operator|/
literal|5
operator|)
operator||
literal|0x80
argument_list|)
expr_stmt|;
name|wpabuf_put_u8
argument_list|(
name|buf
argument_list|,
literal|360
operator|/
literal|5
argument_list|)
expr_stmt|;
name|wpabuf_put_u8
argument_list|(
name|buf
argument_list|,
literal|480
operator|/
literal|5
argument_list|)
expr_stmt|;
name|wpabuf_put_u8
argument_list|(
name|buf
argument_list|,
literal|540
operator|/
literal|5
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rx_freq
condition|)
block|{
name|channel
operator|=
name|p2p
operator|->
name|cfg
operator|->
name|channel
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p2p_freq_to_channel
argument_list|(
name|rx_freq
argument_list|,
operator|&
name|op_class
argument_list|,
operator|&
name|channel
argument_list|)
condition|)
block|{
name|wpabuf_free
argument_list|(
name|ies
argument_list|)
expr_stmt|;
name|wpabuf_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|P2P_PREQ_NOT_PROCESSED
return|;
block|}
name|wpabuf_put_u8
argument_list|(
name|buf
argument_list|,
name|WLAN_EID_DS_PARAMS
argument_list|)
expr_stmt|;
name|wpabuf_put_u8
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|wpabuf_put_u8
argument_list|(
name|buf
argument_list|,
name|channel
argument_list|)
expr_stmt|;
name|wpabuf_put_buf
argument_list|(
name|buf
argument_list|,
name|ies
argument_list|)
expr_stmt|;
name|wpabuf_free
argument_list|(
name|ies
argument_list|)
expr_stmt|;
name|p2p
operator|->
name|cfg
operator|->
name|send_probe_resp
argument_list|(
name|p2p
operator|->
name|cfg
operator|->
name|cb_ctx
argument_list|,
name|buf
argument_list|,
name|rx_freq
argument_list|)
expr_stmt|;
name|wpabuf_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|P2P_PREQ_PROCESSED
return|;
block|}
end_function

begin_function
name|enum
name|p2p_probe_req_status
name|p2p_probe_req_rx
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|,
specifier|const
name|u8
modifier|*
name|addr
parameter_list|,
specifier|const
name|u8
modifier|*
name|dst
parameter_list|,
specifier|const
name|u8
modifier|*
name|bssid
parameter_list|,
specifier|const
name|u8
modifier|*
name|ie
parameter_list|,
name|size_t
name|ie_len
parameter_list|,
name|unsigned
name|int
name|rx_freq
parameter_list|)
block|{
name|enum
name|p2p_probe_req_status
name|res
decl_stmt|;
name|p2p_add_dev_from_probe_req
argument_list|(
name|p2p
argument_list|,
name|addr
argument_list|,
name|ie
argument_list|,
name|ie_len
argument_list|)
expr_stmt|;
name|res
operator|=
name|p2p_reply_probe
argument_list|(
name|p2p
argument_list|,
name|addr
argument_list|,
name|dst
argument_list|,
name|bssid
argument_list|,
name|ie
argument_list|,
name|ie_len
argument_list|,
name|rx_freq
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|!=
name|P2P_PREQ_PROCESSED
operator|&&
name|res
operator|!=
name|P2P_PREQ_NOT_PROCESSED
condition|)
return|return
name|res
return|;
comment|/* 	 * Activate a pending GO Negotiation/Invite flow if a received Probe 	 * Request frame is from an expected peer. Some devices may share the 	 * same address for P2P and non-P2P STA running simultaneously. The 	 * P2P_PREQ_PROCESSED and P2P_PREQ_NOT_PROCESSED p2p_reply_probe() 	 * return values verified above ensure we are handling a Probe Request 	 * frame from a P2P peer. 	 */
if|if
condition|(
operator|(
name|p2p
operator|->
name|state
operator|==
name|P2P_CONNECT
operator|||
name|p2p
operator|->
name|state
operator|==
name|P2P_CONNECT_LISTEN
operator|)
operator|&&
name|p2p
operator|->
name|go_neg_peer
operator|&&
name|os_memcmp
argument_list|(
name|addr
argument_list|,
name|p2p
operator|->
name|go_neg_peer
operator|->
name|info
operator|.
name|p2p_device_addr
argument_list|,
name|ETH_ALEN
argument_list|)
operator|==
literal|0
operator|&&
operator|!
operator|(
name|p2p
operator|->
name|go_neg_peer
operator|->
name|flags
operator|&
name|P2P_DEV_WAIT_GO_NEG_CONFIRM
operator|)
condition|)
block|{
comment|/* Received a Probe Request from GO Negotiation peer */
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Found GO Negotiation peer - try to start GO negotiation from timeout"
argument_list|)
expr_stmt|;
name|eloop_cancel_timeout
argument_list|(
name|p2p_go_neg_start
argument_list|,
name|p2p
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|eloop_register_timeout
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|p2p_go_neg_start
argument_list|,
name|p2p
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
if|if
condition|(
operator|(
name|p2p
operator|->
name|state
operator|==
name|P2P_INVITE
operator|||
name|p2p
operator|->
name|state
operator|==
name|P2P_INVITE_LISTEN
operator|)
operator|&&
name|p2p
operator|->
name|invite_peer
operator|&&
operator|(
name|p2p
operator|->
name|invite_peer
operator|->
name|flags
operator|&
name|P2P_DEV_WAIT_INV_REQ_ACK
operator|)
operator|&&
name|os_memcmp
argument_list|(
name|addr
argument_list|,
name|p2p
operator|->
name|invite_peer
operator|->
name|info
operator|.
name|p2p_device_addr
argument_list|,
name|ETH_ALEN
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Received a Probe Request from Invite peer */
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Found Invite peer - try to start Invite from timeout"
argument_list|)
expr_stmt|;
name|eloop_cancel_timeout
argument_list|(
name|p2p_invite_start
argument_list|,
name|p2p
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|eloop_register_timeout
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|p2p_invite_start
argument_list|,
name|p2p
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
return|return
name|res
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|p2p_assoc_req_ie_wlan_ap
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|,
specifier|const
name|u8
modifier|*
name|bssid
parameter_list|,
name|u8
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|,
name|struct
name|wpabuf
modifier|*
name|p2p_ie
parameter_list|)
block|{
name|struct
name|wpabuf
modifier|*
name|tmp
decl_stmt|;
name|u8
modifier|*
name|lpos
decl_stmt|;
name|size_t
name|tmplen
decl_stmt|;
name|int
name|res
decl_stmt|;
name|u8
name|group_capab
decl_stmt|;
name|struct
name|p2p_message
name|msg
decl_stmt|;
if|if
condition|(
name|p2p_ie
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
comment|/* WLAN AP is not a P2P manager */
name|os_memset
argument_list|(
operator|&
name|msg
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p2p_parse_p2p_ie
argument_list|(
name|p2p_ie
argument_list|,
operator|&
name|msg
argument_list|)
operator|<
literal|0
condition|)
return|return
literal|0
return|;
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"BSS P2P manageability %s"
argument_list|,
name|msg
operator|.
name|manageability
condition|?
literal|"enabled"
else|:
literal|"disabled"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|msg
operator|.
name|manageability
condition|)
return|return
literal|0
return|;
comment|/* 	 * (Re)Association Request - P2P IE 	 * P2P Capability attribute (shall be present) 	 * P2P Interface attribute (present if concurrent device and 	 *	P2P Management is enabled) 	 */
name|tmp
operator|=
name|wpabuf_alloc
argument_list|(
literal|200
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|lpos
operator|=
name|p2p_buf_add_ie_hdr
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|group_capab
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|p2p
operator|->
name|num_groups
operator|>
literal|0
condition|)
block|{
name|group_capab
operator||=
name|P2P_GROUP_CAPAB_GROUP_OWNER
expr_stmt|;
if|if
condition|(
operator|(
name|p2p
operator|->
name|dev_capab
operator|&
name|P2P_DEV_CAPAB_CONCURRENT_OPER
operator|)
operator|&&
operator|(
name|p2p
operator|->
name|dev_capab
operator|&
name|P2P_DEV_CAPAB_INFRA_MANAGED
operator|)
operator|&&
name|p2p
operator|->
name|cross_connect
condition|)
name|group_capab
operator||=
name|P2P_GROUP_CAPAB_CROSS_CONN
expr_stmt|;
block|}
name|p2p_buf_add_capability
argument_list|(
name|tmp
argument_list|,
name|p2p
operator|->
name|dev_capab
argument_list|,
name|group_capab
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p2p
operator|->
name|dev_capab
operator|&
name|P2P_DEV_CAPAB_CONCURRENT_OPER
operator|)
operator|&&
operator|(
name|p2p
operator|->
name|dev_capab
operator|&
name|P2P_DEV_CAPAB_INFRA_MANAGED
operator|)
condition|)
name|p2p_buf_add_p2p_interface
argument_list|(
name|tmp
argument_list|,
name|p2p
argument_list|)
expr_stmt|;
name|p2p_buf_update_ie_hdr
argument_list|(
name|tmp
argument_list|,
name|lpos
argument_list|)
expr_stmt|;
name|tmplen
operator|=
name|wpabuf_len
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmplen
operator|>
name|len
condition|)
name|res
operator|=
operator|-
literal|1
expr_stmt|;
else|else
block|{
name|os_memcpy
argument_list|(
name|buf
argument_list|,
name|wpabuf_head
argument_list|(
name|tmp
argument_list|)
argument_list|,
name|tmplen
argument_list|)
expr_stmt|;
name|res
operator|=
name|tmplen
expr_stmt|;
block|}
name|wpabuf_free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_function
name|int
name|p2p_assoc_req_ie
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|,
specifier|const
name|u8
modifier|*
name|bssid
parameter_list|,
name|u8
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|,
name|int
name|p2p_group
parameter_list|,
name|struct
name|wpabuf
modifier|*
name|p2p_ie
parameter_list|)
block|{
name|struct
name|wpabuf
modifier|*
name|tmp
decl_stmt|;
name|u8
modifier|*
name|lpos
decl_stmt|;
name|struct
name|p2p_device
modifier|*
name|peer
decl_stmt|;
name|size_t
name|tmplen
decl_stmt|;
name|int
name|res
decl_stmt|;
name|size_t
name|extra
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|p2p_group
condition|)
return|return
name|p2p_assoc_req_ie_wlan_ap
argument_list|(
name|p2p
argument_list|,
name|bssid
argument_list|,
name|buf
argument_list|,
name|len
argument_list|,
name|p2p_ie
argument_list|)
return|;
ifdef|#
directive|ifdef
name|CONFIG_WIFI_DISPLAY
if|if
condition|(
name|p2p
operator|->
name|wfd_ie_assoc_req
condition|)
name|extra
operator|=
name|wpabuf_len
argument_list|(
name|p2p
operator|->
name|wfd_ie_assoc_req
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* CONFIG_WIFI_DISPLAY */
if|if
condition|(
name|p2p
operator|->
name|vendor_elem
operator|&&
name|p2p
operator|->
name|vendor_elem
index|[
name|VENDOR_ELEM_P2P_ASSOC_REQ
index|]
condition|)
name|extra
operator|+=
name|wpabuf_len
argument_list|(
name|p2p
operator|->
name|vendor_elem
index|[
name|VENDOR_ELEM_P2P_ASSOC_REQ
index|]
argument_list|)
expr_stmt|;
comment|/* 	 * (Re)Association Request - P2P IE 	 * P2P Capability attribute (shall be present) 	 * Extended Listen Timing (may be present) 	 * P2P Device Info attribute (shall be present) 	 */
name|tmp
operator|=
name|wpabuf_alloc
argument_list|(
literal|200
operator|+
name|extra
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
ifdef|#
directive|ifdef
name|CONFIG_WIFI_DISPLAY
if|if
condition|(
name|p2p
operator|->
name|wfd_ie_assoc_req
condition|)
name|wpabuf_put_buf
argument_list|(
name|tmp
argument_list|,
name|p2p
operator|->
name|wfd_ie_assoc_req
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* CONFIG_WIFI_DISPLAY */
if|if
condition|(
name|p2p
operator|->
name|vendor_elem
operator|&&
name|p2p
operator|->
name|vendor_elem
index|[
name|VENDOR_ELEM_P2P_ASSOC_REQ
index|]
condition|)
name|wpabuf_put_buf
argument_list|(
name|tmp
argument_list|,
name|p2p
operator|->
name|vendor_elem
index|[
name|VENDOR_ELEM_P2P_ASSOC_REQ
index|]
argument_list|)
expr_stmt|;
name|peer
operator|=
name|bssid
condition|?
name|p2p_get_device
argument_list|(
name|p2p
argument_list|,
name|bssid
argument_list|)
else|:
name|NULL
expr_stmt|;
name|lpos
operator|=
name|p2p_buf_add_ie_hdr
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|p2p_buf_add_capability
argument_list|(
name|tmp
argument_list|,
name|p2p
operator|->
name|dev_capab
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|p2p
operator|->
name|ext_listen_interval
condition|)
name|p2p_buf_add_ext_listen_timing
argument_list|(
name|tmp
argument_list|,
name|p2p
operator|->
name|ext_listen_period
argument_list|,
name|p2p
operator|->
name|ext_listen_interval
argument_list|)
expr_stmt|;
name|p2p_buf_add_device_info
argument_list|(
name|tmp
argument_list|,
name|p2p
argument_list|,
name|peer
argument_list|)
expr_stmt|;
name|p2p_buf_update_ie_hdr
argument_list|(
name|tmp
argument_list|,
name|lpos
argument_list|)
expr_stmt|;
name|tmplen
operator|=
name|wpabuf_len
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmplen
operator|>
name|len
condition|)
name|res
operator|=
operator|-
literal|1
expr_stmt|;
else|else
block|{
name|os_memcpy
argument_list|(
name|buf
argument_list|,
name|wpabuf_head
argument_list|(
name|tmp
argument_list|)
argument_list|,
name|tmplen
argument_list|)
expr_stmt|;
name|res
operator|=
name|tmplen
expr_stmt|;
block|}
name|wpabuf_free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_function
name|int
name|p2p_scan_result_text
parameter_list|(
specifier|const
name|u8
modifier|*
name|ies
parameter_list|,
name|size_t
name|ies_len
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|char
modifier|*
name|end
parameter_list|)
block|{
name|struct
name|wpabuf
modifier|*
name|p2p_ie
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|p2p_ie
operator|=
name|ieee802_11_vendor_ie_concat
argument_list|(
name|ies
argument_list|,
name|ies_len
argument_list|,
name|P2P_IE_VENDOR_TYPE
argument_list|)
expr_stmt|;
if|if
condition|(
name|p2p_ie
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|ret
operator|=
name|p2p_attr_text
argument_list|(
name|p2p_ie
argument_list|,
name|buf
argument_list|,
name|end
argument_list|)
expr_stmt|;
name|wpabuf_free
argument_list|(
name|p2p_ie
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|struct
name|p2ps_advertisement
modifier|*
name|p2p_service_p2ps_id
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|,
name|u32
name|adv_id
parameter_list|)
block|{
name|struct
name|p2ps_advertisement
modifier|*
name|adv_data
decl_stmt|;
if|if
condition|(
operator|!
name|p2p
condition|)
return|return
name|NULL
return|;
name|adv_data
operator|=
name|p2p
operator|->
name|p2ps_adv_list
expr_stmt|;
while|while
condition|(
name|adv_data
condition|)
block|{
if|if
condition|(
name|adv_data
operator|->
name|id
operator|==
name|adv_id
condition|)
return|return
name|adv_data
return|;
name|adv_data
operator|=
name|adv_data
operator|->
name|next
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|int
name|p2p_service_del_asp
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|,
name|u32
name|adv_id
parameter_list|)
block|{
name|struct
name|p2ps_advertisement
modifier|*
name|adv_data
decl_stmt|;
name|struct
name|p2ps_advertisement
modifier|*
modifier|*
name|prior
decl_stmt|;
if|if
condition|(
operator|!
name|p2p
condition|)
return|return
operator|-
literal|1
return|;
name|adv_data
operator|=
name|p2p
operator|->
name|p2ps_adv_list
expr_stmt|;
name|prior
operator|=
operator|&
name|p2p
operator|->
name|p2ps_adv_list
expr_stmt|;
while|while
condition|(
name|adv_data
condition|)
block|{
if|if
condition|(
name|adv_data
operator|->
name|id
operator|==
name|adv_id
condition|)
block|{
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Delete ASP adv_id=0x%x"
argument_list|,
name|adv_id
argument_list|)
expr_stmt|;
operator|*
name|prior
operator|=
name|adv_data
operator|->
name|next
expr_stmt|;
name|os_free
argument_list|(
name|adv_data
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|prior
operator|=
operator|&
name|adv_data
operator|->
name|next
expr_stmt|;
name|adv_data
operator|=
name|adv_data
operator|->
name|next
expr_stmt|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
name|int
name|p2p_service_add_asp
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|,
name|int
name|auto_accept
parameter_list|,
name|u32
name|adv_id
parameter_list|,
specifier|const
name|char
modifier|*
name|adv_str
parameter_list|,
name|u8
name|svc_state
parameter_list|,
name|u16
name|config_methods
parameter_list|,
specifier|const
name|char
modifier|*
name|svc_info
parameter_list|,
specifier|const
name|u8
modifier|*
name|cpt_priority
parameter_list|)
block|{
name|struct
name|p2ps_advertisement
modifier|*
name|adv_data
decl_stmt|,
modifier|*
name|tmp
decl_stmt|,
modifier|*
modifier|*
name|prev
decl_stmt|;
name|u8
name|buf
index|[
name|P2PS_HASH_LEN
index|]
decl_stmt|;
name|size_t
name|adv_data_len
decl_stmt|,
name|adv_len
decl_stmt|,
name|info_len
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|p2p
operator|||
operator|!
name|adv_str
operator|||
operator|!
name|adv_str
index|[
literal|0
index|]
operator|||
operator|!
name|cpt_priority
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|!
operator|(
name|config_methods
operator|&
name|p2p
operator|->
name|cfg
operator|->
name|config_methods
operator|)
condition|)
block|{
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Config methods not supported svc: 0x%x dev: 0x%x"
argument_list|,
name|config_methods
argument_list|,
name|p2p
operator|->
name|cfg
operator|->
name|config_methods
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
operator|!
name|p2ps_gen_hash
argument_list|(
name|p2p
argument_list|,
name|adv_str
argument_list|,
name|buf
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|svc_info
condition|)
name|info_len
operator|=
name|os_strlen
argument_list|(
name|svc_info
argument_list|)
expr_stmt|;
name|adv_len
operator|=
name|os_strlen
argument_list|(
name|adv_str
argument_list|)
expr_stmt|;
name|adv_data_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|p2ps_advertisement
argument_list|)
operator|+
name|adv_len
operator|+
literal|1
operator|+
name|info_len
operator|+
literal|1
expr_stmt|;
name|adv_data
operator|=
name|os_zalloc
argument_list|(
name|adv_data_len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|adv_data
condition|)
return|return
operator|-
literal|1
return|;
name|os_memcpy
argument_list|(
name|adv_data
operator|->
name|hash
argument_list|,
name|buf
argument_list|,
name|P2PS_HASH_LEN
argument_list|)
expr_stmt|;
name|adv_data
operator|->
name|id
operator|=
name|adv_id
expr_stmt|;
name|adv_data
operator|->
name|state
operator|=
name|svc_state
expr_stmt|;
name|adv_data
operator|->
name|config_methods
operator|=
name|config_methods
operator|&
name|p2p
operator|->
name|cfg
operator|->
name|config_methods
expr_stmt|;
name|adv_data
operator|->
name|auto_accept
operator|=
operator|(
name|u8
operator|)
name|auto_accept
expr_stmt|;
name|os_memcpy
argument_list|(
name|adv_data
operator|->
name|svc_name
argument_list|,
name|adv_str
argument_list|,
name|adv_len
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|cpt_priority
index|[
name|i
index|]
operator|&&
name|i
operator|<
name|P2PS_FEATURE_CAPAB_CPT_MAX
condition|;
name|i
operator|++
control|)
block|{
name|adv_data
operator|->
name|cpt_priority
index|[
name|i
index|]
operator|=
name|cpt_priority
index|[
name|i
index|]
expr_stmt|;
name|adv_data
operator|->
name|cpt_mask
operator||=
name|cpt_priority
index|[
name|i
index|]
expr_stmt|;
block|}
if|if
condition|(
name|svc_info
operator|&&
name|info_len
condition|)
block|{
name|adv_data
operator|->
name|svc_info
operator|=
operator|&
name|adv_data
operator|->
name|svc_name
index|[
name|adv_len
operator|+
literal|1
index|]
expr_stmt|;
name|os_memcpy
argument_list|(
name|adv_data
operator|->
name|svc_info
argument_list|,
name|svc_info
argument_list|,
name|info_len
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Group Advertisements by service string. They do not need to be 	 * sorted, but groups allow easier Probe Response instance grouping 	 */
name|tmp
operator|=
name|p2p
operator|->
name|p2ps_adv_list
expr_stmt|;
name|prev
operator|=
operator|&
name|p2p
operator|->
name|p2ps_adv_list
expr_stmt|;
while|while
condition|(
name|tmp
condition|)
block|{
if|if
condition|(
name|tmp
operator|->
name|id
operator|==
name|adv_data
operator|->
name|id
condition|)
block|{
if|if
condition|(
name|os_strcmp
argument_list|(
name|tmp
operator|->
name|svc_name
argument_list|,
name|adv_data
operator|->
name|svc_name
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|os_free
argument_list|(
name|adv_data
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|adv_data
operator|->
name|next
operator|=
name|tmp
operator|->
name|next
expr_stmt|;
operator|*
name|prev
operator|=
name|adv_data
expr_stmt|;
name|os_free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
goto|goto
name|inserted
goto|;
block|}
else|else
block|{
if|if
condition|(
name|os_strcmp
argument_list|(
name|tmp
operator|->
name|svc_name
argument_list|,
name|adv_data
operator|->
name|svc_name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|adv_data
operator|->
name|next
operator|=
name|tmp
operator|->
name|next
expr_stmt|;
name|tmp
operator|->
name|next
operator|=
name|adv_data
expr_stmt|;
goto|goto
name|inserted
goto|;
block|}
block|}
name|prev
operator|=
operator|&
name|tmp
operator|->
name|next
expr_stmt|;
name|tmp
operator|=
name|tmp
operator|->
name|next
expr_stmt|;
block|}
comment|/* No svc_name match found */
name|adv_data
operator|->
name|next
operator|=
name|p2p
operator|->
name|p2ps_adv_list
expr_stmt|;
name|p2p
operator|->
name|p2ps_adv_list
operator|=
name|adv_data
expr_stmt|;
name|inserted
label|:
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Added ASP advertisement adv_id=0x%x config_methods=0x%x svc_state=0x%x adv_str='%s' cpt_mask=0x%x"
argument_list|,
name|adv_id
argument_list|,
name|adv_data
operator|->
name|config_methods
argument_list|,
name|svc_state
argument_list|,
name|adv_str
argument_list|,
name|adv_data
operator|->
name|cpt_mask
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|p2p_service_flush_asp
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|)
block|{
name|struct
name|p2ps_advertisement
modifier|*
name|adv
decl_stmt|,
modifier|*
name|prev
decl_stmt|;
if|if
condition|(
operator|!
name|p2p
condition|)
return|return;
name|adv
operator|=
name|p2p
operator|->
name|p2ps_adv_list
expr_stmt|;
while|while
condition|(
name|adv
condition|)
block|{
name|prev
operator|=
name|adv
expr_stmt|;
name|adv
operator|=
name|adv
operator|->
name|next
expr_stmt|;
name|os_free
argument_list|(
name|prev
argument_list|)
expr_stmt|;
block|}
name|p2p
operator|->
name|p2ps_adv_list
operator|=
name|NULL
expr_stmt|;
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"All ASP advertisements flushed"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|p2p_parse_dev_addr_in_p2p_ie
parameter_list|(
name|struct
name|wpabuf
modifier|*
name|p2p_ie
parameter_list|,
name|u8
modifier|*
name|dev_addr
parameter_list|)
block|{
name|struct
name|p2p_message
name|msg
decl_stmt|;
name|os_memset
argument_list|(
operator|&
name|msg
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p2p_parse_p2p_ie
argument_list|(
name|p2p_ie
argument_list|,
operator|&
name|msg
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|msg
operator|.
name|p2p_device_addr
condition|)
block|{
name|os_memcpy
argument_list|(
name|dev_addr
argument_list|,
name|msg
operator|.
name|p2p_device_addr
argument_list|,
name|ETH_ALEN
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|msg
operator|.
name|device_id
condition|)
block|{
name|os_memcpy
argument_list|(
name|dev_addr
argument_list|,
name|msg
operator|.
name|device_id
argument_list|,
name|ETH_ALEN
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
name|int
name|p2p_parse_dev_addr
parameter_list|(
specifier|const
name|u8
modifier|*
name|ies
parameter_list|,
name|size_t
name|ies_len
parameter_list|,
name|u8
modifier|*
name|dev_addr
parameter_list|)
block|{
name|struct
name|wpabuf
modifier|*
name|p2p_ie
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|p2p_ie
operator|=
name|ieee802_11_vendor_ie_concat
argument_list|(
name|ies
argument_list|,
name|ies_len
argument_list|,
name|P2P_IE_VENDOR_TYPE
argument_list|)
expr_stmt|;
if|if
condition|(
name|p2p_ie
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|ret
operator|=
name|p2p_parse_dev_addr_in_p2p_ie
argument_list|(
name|p2p_ie
argument_list|,
name|dev_addr
argument_list|)
expr_stmt|;
name|wpabuf_free
argument_list|(
name|p2p_ie
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|p2p_clear_go_neg
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|)
block|{
name|p2p
operator|->
name|go_neg_peer
operator|=
name|NULL
expr_stmt|;
name|p2p_clear_timeout
argument_list|(
name|p2p
argument_list|)
expr_stmt|;
name|p2p_set_state
argument_list|(
name|p2p
argument_list|,
name|P2P_IDLE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|p2p_wps_success_cb
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|,
specifier|const
name|u8
modifier|*
name|mac_addr
parameter_list|)
block|{
if|if
condition|(
name|p2p
operator|->
name|go_neg_peer
operator|==
name|NULL
condition|)
block|{
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"No pending Group Formation - ignore WPS registration success notification"
argument_list|)
expr_stmt|;
return|return;
comment|/* No pending Group Formation */
block|}
if|if
condition|(
name|os_memcmp
argument_list|(
name|mac_addr
argument_list|,
name|p2p
operator|->
name|go_neg_peer
operator|->
name|intended_addr
argument_list|,
name|ETH_ALEN
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Ignore WPS registration success notification for "
name|MACSTR
literal|" (GO Negotiation peer "
name|MACSTR
literal|")"
argument_list|,
name|MAC2STR
argument_list|(
name|mac_addr
argument_list|)
argument_list|,
name|MAC2STR
argument_list|(
name|p2p
operator|->
name|go_neg_peer
operator|->
name|intended_addr
argument_list|)
argument_list|)
expr_stmt|;
return|return;
comment|/* Ignore unexpected peer address */
block|}
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Group Formation completed successfully with "
name|MACSTR
argument_list|,
name|MAC2STR
argument_list|(
name|mac_addr
argument_list|)
argument_list|)
expr_stmt|;
name|p2p_clear_go_neg
argument_list|(
name|p2p
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|p2p_group_formation_failed
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|)
block|{
if|if
condition|(
name|p2p
operator|->
name|go_neg_peer
operator|==
name|NULL
condition|)
block|{
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"No pending Group Formation - ignore group formation failure notification"
argument_list|)
expr_stmt|;
return|return;
comment|/* No pending Group Formation */
block|}
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Group Formation failed with "
name|MACSTR
argument_list|,
name|MAC2STR
argument_list|(
name|p2p
operator|->
name|go_neg_peer
operator|->
name|intended_addr
argument_list|)
argument_list|)
expr_stmt|;
name|p2p_clear_go_neg
argument_list|(
name|p2p
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|p2p_data
modifier|*
name|p2p_init
parameter_list|(
specifier|const
name|struct
name|p2p_config
modifier|*
name|cfg
parameter_list|)
block|{
name|struct
name|p2p_data
modifier|*
name|p2p
decl_stmt|;
if|if
condition|(
name|cfg
operator|->
name|max_peers
operator|<
literal|1
operator|||
name|cfg
operator|->
name|passphrase_len
operator|<
literal|8
operator|||
name|cfg
operator|->
name|passphrase_len
operator|>
literal|63
condition|)
return|return
name|NULL
return|;
name|p2p
operator|=
name|os_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|p2p
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|cfg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p2p
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|p2p
operator|->
name|cfg
operator|=
operator|(
expr|struct
name|p2p_config
operator|*
operator|)
operator|(
name|p2p
operator|+
literal|1
operator|)
expr_stmt|;
name|os_memcpy
argument_list|(
name|p2p
operator|->
name|cfg
argument_list|,
name|cfg
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|cfg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfg
operator|->
name|dev_name
condition|)
name|p2p
operator|->
name|cfg
operator|->
name|dev_name
operator|=
name|os_strdup
argument_list|(
name|cfg
operator|->
name|dev_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfg
operator|->
name|manufacturer
condition|)
name|p2p
operator|->
name|cfg
operator|->
name|manufacturer
operator|=
name|os_strdup
argument_list|(
name|cfg
operator|->
name|manufacturer
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfg
operator|->
name|model_name
condition|)
name|p2p
operator|->
name|cfg
operator|->
name|model_name
operator|=
name|os_strdup
argument_list|(
name|cfg
operator|->
name|model_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfg
operator|->
name|model_number
condition|)
name|p2p
operator|->
name|cfg
operator|->
name|model_number
operator|=
name|os_strdup
argument_list|(
name|cfg
operator|->
name|model_number
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfg
operator|->
name|serial_number
condition|)
name|p2p
operator|->
name|cfg
operator|->
name|serial_number
operator|=
name|os_strdup
argument_list|(
name|cfg
operator|->
name|serial_number
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfg
operator|->
name|pref_chan
condition|)
block|{
name|p2p
operator|->
name|cfg
operator|->
name|pref_chan
operator|=
name|os_malloc
argument_list|(
name|cfg
operator|->
name|num_pref_chan
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|p2p_channel
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p2p
operator|->
name|cfg
operator|->
name|pref_chan
condition|)
block|{
name|os_memcpy
argument_list|(
name|p2p
operator|->
name|cfg
operator|->
name|pref_chan
argument_list|,
name|cfg
operator|->
name|pref_chan
argument_list|,
name|cfg
operator|->
name|num_pref_chan
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|p2p_channel
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|p2p
operator|->
name|cfg
operator|->
name|num_pref_chan
operator|=
literal|0
expr_stmt|;
block|}
name|p2ps_gen_hash
argument_list|(
name|p2p
argument_list|,
name|P2PS_WILD_HASH_STR
argument_list|,
name|p2p
operator|->
name|wild_card_hash
argument_list|)
expr_stmt|;
name|p2p
operator|->
name|min_disc_int
operator|=
literal|1
expr_stmt|;
name|p2p
operator|->
name|max_disc_int
operator|=
literal|3
expr_stmt|;
name|p2p
operator|->
name|max_disc_tu
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|os_get_random
argument_list|(
operator|&
name|p2p
operator|->
name|next_tie_breaker
argument_list|,
literal|1
argument_list|)
operator|<
literal|0
condition|)
name|p2p
operator|->
name|next_tie_breaker
operator|=
literal|0
expr_stmt|;
name|p2p
operator|->
name|next_tie_breaker
operator|&=
literal|0x01
expr_stmt|;
if|if
condition|(
name|cfg
operator|->
name|sd_request
condition|)
name|p2p
operator|->
name|dev_capab
operator||=
name|P2P_DEV_CAPAB_SERVICE_DISCOVERY
expr_stmt|;
name|p2p
operator|->
name|dev_capab
operator||=
name|P2P_DEV_CAPAB_INVITATION_PROCEDURE
expr_stmt|;
if|if
condition|(
name|cfg
operator|->
name|concurrent_operations
condition|)
name|p2p
operator|->
name|dev_capab
operator||=
name|P2P_DEV_CAPAB_CONCURRENT_OPER
expr_stmt|;
name|p2p
operator|->
name|dev_capab
operator||=
name|P2P_DEV_CAPAB_CLIENT_DISCOVERABILITY
expr_stmt|;
name|dl_list_init
argument_list|(
operator|&
name|p2p
operator|->
name|devices
argument_list|)
expr_stmt|;
name|p2p
operator|->
name|go_timeout
operator|=
literal|100
expr_stmt|;
name|p2p
operator|->
name|client_timeout
operator|=
literal|20
expr_stmt|;
name|p2p
operator|->
name|num_p2p_sd_queries
operator|=
literal|0
expr_stmt|;
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"initialized"
argument_list|)
expr_stmt|;
name|p2p_channels_dump
argument_list|(
name|p2p
argument_list|,
literal|"channels"
argument_list|,
operator|&
name|p2p
operator|->
name|cfg
operator|->
name|channels
argument_list|)
expr_stmt|;
name|p2p_channels_dump
argument_list|(
name|p2p
argument_list|,
literal|"cli_channels"
argument_list|,
operator|&
name|p2p
operator|->
name|cfg
operator|->
name|cli_channels
argument_list|)
expr_stmt|;
return|return
name|p2p
return|;
block|}
end_function

begin_function
name|void
name|p2p_deinit
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|CONFIG_WIFI_DISPLAY
name|wpabuf_free
argument_list|(
name|p2p
operator|->
name|wfd_ie_beacon
argument_list|)
expr_stmt|;
name|wpabuf_free
argument_list|(
name|p2p
operator|->
name|wfd_ie_probe_req
argument_list|)
expr_stmt|;
name|wpabuf_free
argument_list|(
name|p2p
operator|->
name|wfd_ie_probe_resp
argument_list|)
expr_stmt|;
name|wpabuf_free
argument_list|(
name|p2p
operator|->
name|wfd_ie_assoc_req
argument_list|)
expr_stmt|;
name|wpabuf_free
argument_list|(
name|p2p
operator|->
name|wfd_ie_invitation
argument_list|)
expr_stmt|;
name|wpabuf_free
argument_list|(
name|p2p
operator|->
name|wfd_ie_prov_disc_req
argument_list|)
expr_stmt|;
name|wpabuf_free
argument_list|(
name|p2p
operator|->
name|wfd_ie_prov_disc_resp
argument_list|)
expr_stmt|;
name|wpabuf_free
argument_list|(
name|p2p
operator|->
name|wfd_ie_go_neg
argument_list|)
expr_stmt|;
name|wpabuf_free
argument_list|(
name|p2p
operator|->
name|wfd_dev_info
argument_list|)
expr_stmt|;
name|wpabuf_free
argument_list|(
name|p2p
operator|->
name|wfd_assoc_bssid
argument_list|)
expr_stmt|;
name|wpabuf_free
argument_list|(
name|p2p
operator|->
name|wfd_coupled_sink_info
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* CONFIG_WIFI_DISPLAY */
name|eloop_cancel_timeout
argument_list|(
name|p2p_ext_listen_timeout
argument_list|,
name|p2p
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|eloop_cancel_timeout
argument_list|(
name|p2p_scan_timeout
argument_list|,
name|p2p
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|eloop_cancel_timeout
argument_list|(
name|p2p_go_neg_start
argument_list|,
name|p2p
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|eloop_cancel_timeout
argument_list|(
name|p2p_go_neg_wait_timeout
argument_list|,
name|p2p
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|p2p_flush
argument_list|(
name|p2p
argument_list|)
expr_stmt|;
name|p2p_free_req_dev_types
argument_list|(
name|p2p
argument_list|)
expr_stmt|;
name|os_free
argument_list|(
name|p2p
operator|->
name|cfg
operator|->
name|dev_name
argument_list|)
expr_stmt|;
name|os_free
argument_list|(
name|p2p
operator|->
name|cfg
operator|->
name|manufacturer
argument_list|)
expr_stmt|;
name|os_free
argument_list|(
name|p2p
operator|->
name|cfg
operator|->
name|model_name
argument_list|)
expr_stmt|;
name|os_free
argument_list|(
name|p2p
operator|->
name|cfg
operator|->
name|model_number
argument_list|)
expr_stmt|;
name|os_free
argument_list|(
name|p2p
operator|->
name|cfg
operator|->
name|serial_number
argument_list|)
expr_stmt|;
name|os_free
argument_list|(
name|p2p
operator|->
name|cfg
operator|->
name|pref_chan
argument_list|)
expr_stmt|;
name|os_free
argument_list|(
name|p2p
operator|->
name|groups
argument_list|)
expr_stmt|;
name|p2ps_prov_free
argument_list|(
name|p2p
argument_list|)
expr_stmt|;
name|wpabuf_free
argument_list|(
name|p2p
operator|->
name|sd_resp
argument_list|)
expr_stmt|;
name|os_free
argument_list|(
name|p2p
operator|->
name|after_scan_tx
argument_list|)
expr_stmt|;
name|p2p_remove_wps_vendor_extensions
argument_list|(
name|p2p
argument_list|)
expr_stmt|;
name|os_free
argument_list|(
name|p2p
operator|->
name|no_go_freq
operator|.
name|range
argument_list|)
expr_stmt|;
name|p2p_service_flush_asp
argument_list|(
name|p2p
argument_list|)
expr_stmt|;
name|os_free
argument_list|(
name|p2p
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|p2p_flush
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|)
block|{
name|struct
name|p2p_device
modifier|*
name|dev
decl_stmt|,
modifier|*
name|prev
decl_stmt|;
name|p2p_stop_find
argument_list|(
name|p2p
argument_list|)
expr_stmt|;
name|dl_list_for_each_safe
argument_list|(
argument|dev
argument_list|,
argument|prev
argument_list|,
argument|&p2p->devices
argument_list|,
argument|struct p2p_device
argument_list|,
argument|list
argument_list|)
block|{
name|dl_list_del
argument_list|(
operator|&
name|dev
operator|->
name|list
argument_list|)
expr_stmt|;
name|p2p_device_free
argument_list|(
name|p2p
argument_list|,
name|dev
argument_list|)
expr_stmt|;
block|}
name|p2p_free_sd_queries
argument_list|(
name|p2p
argument_list|)
expr_stmt|;
name|os_free
argument_list|(
name|p2p
operator|->
name|after_scan_tx
argument_list|)
expr_stmt|;
name|p2p
operator|->
name|after_scan_tx
operator|=
name|NULL
expr_stmt|;
name|p2p
operator|->
name|ssid_set
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|int
name|p2p_unauthorize
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|,
specifier|const
name|u8
modifier|*
name|addr
parameter_list|)
block|{
name|struct
name|p2p_device
modifier|*
name|dev
decl_stmt|;
name|dev
operator|=
name|p2p_get_device
argument_list|(
name|p2p
argument_list|,
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Unauthorizing "
name|MACSTR
argument_list|,
name|MAC2STR
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p2p
operator|->
name|go_neg_peer
operator|==
name|dev
condition|)
block|{
name|eloop_cancel_timeout
argument_list|(
name|p2p_go_neg_wait_timeout
argument_list|,
name|p2p
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|p2p
operator|->
name|go_neg_peer
operator|=
name|NULL
expr_stmt|;
block|}
name|dev
operator|->
name|wps_method
operator|=
name|WPS_NOT_READY
expr_stmt|;
name|dev
operator|->
name|oob_pw_id
operator|=
literal|0
expr_stmt|;
name|dev
operator|->
name|flags
operator|&=
operator|~
name|P2P_DEV_WAIT_GO_NEG_RESPONSE
expr_stmt|;
name|dev
operator|->
name|flags
operator|&=
operator|~
name|P2P_DEV_WAIT_GO_NEG_CONFIRM
expr_stmt|;
comment|/* Check if after_scan_tx is for this peer. If so free it */
if|if
condition|(
name|p2p
operator|->
name|after_scan_tx
operator|&&
name|os_memcmp
argument_list|(
name|addr
argument_list|,
name|p2p
operator|->
name|after_scan_tx
operator|->
name|dst
argument_list|,
name|ETH_ALEN
argument_list|)
operator|==
literal|0
condition|)
block|{
name|os_free
argument_list|(
name|p2p
operator|->
name|after_scan_tx
argument_list|)
expr_stmt|;
name|p2p
operator|->
name|after_scan_tx
operator|=
name|NULL
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|p2p_set_dev_name
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|,
specifier|const
name|char
modifier|*
name|dev_name
parameter_list|)
block|{
name|os_free
argument_list|(
name|p2p
operator|->
name|cfg
operator|->
name|dev_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev_name
condition|)
block|{
name|p2p
operator|->
name|cfg
operator|->
name|dev_name
operator|=
name|os_strdup
argument_list|(
name|dev_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|p2p
operator|->
name|cfg
operator|->
name|dev_name
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
block|}
else|else
name|p2p
operator|->
name|cfg
operator|->
name|dev_name
operator|=
name|NULL
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|p2p_set_manufacturer
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|,
specifier|const
name|char
modifier|*
name|manufacturer
parameter_list|)
block|{
name|os_free
argument_list|(
name|p2p
operator|->
name|cfg
operator|->
name|manufacturer
argument_list|)
expr_stmt|;
name|p2p
operator|->
name|cfg
operator|->
name|manufacturer
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|manufacturer
condition|)
block|{
name|p2p
operator|->
name|cfg
operator|->
name|manufacturer
operator|=
name|os_strdup
argument_list|(
name|manufacturer
argument_list|)
expr_stmt|;
if|if
condition|(
name|p2p
operator|->
name|cfg
operator|->
name|manufacturer
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|p2p_set_model_name
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|,
specifier|const
name|char
modifier|*
name|model_name
parameter_list|)
block|{
name|os_free
argument_list|(
name|p2p
operator|->
name|cfg
operator|->
name|model_name
argument_list|)
expr_stmt|;
name|p2p
operator|->
name|cfg
operator|->
name|model_name
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|model_name
condition|)
block|{
name|p2p
operator|->
name|cfg
operator|->
name|model_name
operator|=
name|os_strdup
argument_list|(
name|model_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|p2p
operator|->
name|cfg
operator|->
name|model_name
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|p2p_set_model_number
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|,
specifier|const
name|char
modifier|*
name|model_number
parameter_list|)
block|{
name|os_free
argument_list|(
name|p2p
operator|->
name|cfg
operator|->
name|model_number
argument_list|)
expr_stmt|;
name|p2p
operator|->
name|cfg
operator|->
name|model_number
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|model_number
condition|)
block|{
name|p2p
operator|->
name|cfg
operator|->
name|model_number
operator|=
name|os_strdup
argument_list|(
name|model_number
argument_list|)
expr_stmt|;
if|if
condition|(
name|p2p
operator|->
name|cfg
operator|->
name|model_number
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|p2p_set_serial_number
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|,
specifier|const
name|char
modifier|*
name|serial_number
parameter_list|)
block|{
name|os_free
argument_list|(
name|p2p
operator|->
name|cfg
operator|->
name|serial_number
argument_list|)
expr_stmt|;
name|p2p
operator|->
name|cfg
operator|->
name|serial_number
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|serial_number
condition|)
block|{
name|p2p
operator|->
name|cfg
operator|->
name|serial_number
operator|=
name|os_strdup
argument_list|(
name|serial_number
argument_list|)
expr_stmt|;
if|if
condition|(
name|p2p
operator|->
name|cfg
operator|->
name|serial_number
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|p2p_set_config_methods
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|,
name|u16
name|config_methods
parameter_list|)
block|{
name|p2p
operator|->
name|cfg
operator|->
name|config_methods
operator|=
name|config_methods
expr_stmt|;
block|}
end_function

begin_function
name|void
name|p2p_set_uuid
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|,
specifier|const
name|u8
modifier|*
name|uuid
parameter_list|)
block|{
name|os_memcpy
argument_list|(
name|p2p
operator|->
name|cfg
operator|->
name|uuid
argument_list|,
name|uuid
argument_list|,
literal|16
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|p2p_set_pri_dev_type
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|,
specifier|const
name|u8
modifier|*
name|pri_dev_type
parameter_list|)
block|{
name|os_memcpy
argument_list|(
name|p2p
operator|->
name|cfg
operator|->
name|pri_dev_type
argument_list|,
name|pri_dev_type
argument_list|,
literal|8
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|p2p_set_sec_dev_types
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|,
specifier|const
name|u8
name|dev_types
index|[]
index|[
literal|8
index|]
parameter_list|,
name|size_t
name|num_dev_types
parameter_list|)
block|{
if|if
condition|(
name|num_dev_types
operator|>
name|P2P_SEC_DEVICE_TYPES
condition|)
name|num_dev_types
operator|=
name|P2P_SEC_DEVICE_TYPES
expr_stmt|;
name|p2p
operator|->
name|cfg
operator|->
name|num_sec_dev_types
operator|=
name|num_dev_types
expr_stmt|;
name|os_memcpy
argument_list|(
name|p2p
operator|->
name|cfg
operator|->
name|sec_dev_type
argument_list|,
name|dev_types
argument_list|,
name|num_dev_types
operator|*
literal|8
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|p2p_remove_wps_vendor_extensions
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|P2P_MAX_WPS_VENDOR_EXT
condition|;
name|i
operator|++
control|)
block|{
name|wpabuf_free
argument_list|(
name|p2p
operator|->
name|wps_vendor_ext
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|p2p
operator|->
name|wps_vendor_ext
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|p2p_add_wps_vendor_extension
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|,
specifier|const
name|struct
name|wpabuf
modifier|*
name|vendor_ext
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|vendor_ext
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|P2P_MAX_WPS_VENDOR_EXT
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|p2p
operator|->
name|wps_vendor_ext
index|[
name|i
index|]
operator|==
name|NULL
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|>=
name|P2P_MAX_WPS_VENDOR_EXT
condition|)
return|return
operator|-
literal|1
return|;
name|p2p
operator|->
name|wps_vendor_ext
index|[
name|i
index|]
operator|=
name|wpabuf_dup
argument_list|(
name|vendor_ext
argument_list|)
expr_stmt|;
if|if
condition|(
name|p2p
operator|->
name|wps_vendor_ext
index|[
name|i
index|]
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|p2p_set_country
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|,
specifier|const
name|char
modifier|*
name|country
parameter_list|)
block|{
name|os_memcpy
argument_list|(
name|p2p
operator|->
name|cfg
operator|->
name|country
argument_list|,
name|country
argument_list|,
literal|3
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|p2p_pre_find_operation
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|,
name|struct
name|p2p_device
modifier|*
name|dev
parameter_list|)
block|{
if|if
condition|(
name|dev
operator|->
name|sd_pending_bcast_queries
operator|==
literal|0
condition|)
block|{
comment|/* Initialize with total number of registered broadcast 		 * SD queries. */
name|dev
operator|->
name|sd_pending_bcast_queries
operator|=
name|p2p
operator|->
name|num_p2p_sd_queries
expr_stmt|;
block|}
if|if
condition|(
name|p2p_start_sd
argument_list|(
name|p2p
argument_list|,
name|dev
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|dev
operator|->
name|req_config_methods
operator|&&
operator|!
operator|(
name|dev
operator|->
name|flags
operator|&
name|P2P_DEV_PD_FOR_JOIN
operator|)
condition|)
block|{
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Send pending Provision Discovery Request to "
name|MACSTR
literal|" (config methods 0x%x)"
argument_list|,
name|MAC2STR
argument_list|(
name|dev
operator|->
name|info
operator|.
name|p2p_device_addr
argument_list|)
argument_list|,
name|dev
operator|->
name|req_config_methods
argument_list|)
expr_stmt|;
if|if
condition|(
name|p2p_send_prov_disc_req
argument_list|(
name|p2p
argument_list|,
name|dev
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|p2p_continue_find
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|)
block|{
name|struct
name|p2p_device
modifier|*
name|dev
decl_stmt|;
name|int
name|found
decl_stmt|;
name|p2p_set_state
argument_list|(
name|p2p
argument_list|,
name|P2P_SEARCH
argument_list|)
expr_stmt|;
comment|/* Continue from the device following the last iteration */
name|found
operator|=
literal|0
expr_stmt|;
name|dl_list_for_each
argument_list|(
argument|dev
argument_list|,
argument|&p2p->devices
argument_list|,
argument|struct p2p_device
argument_list|,
argument|list
argument_list|)
block|{
if|if
condition|(
name|dev
operator|==
name|p2p
operator|->
name|last_p2p_find_oper
condition|)
block|{
name|found
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|found
condition|)
continue|continue;
if|if
condition|(
name|p2p_pre_find_operation
argument_list|(
name|p2p
argument_list|,
name|dev
argument_list|)
operator|>
literal|0
condition|)
block|{
name|p2p
operator|->
name|last_p2p_find_oper
operator|=
name|dev
expr_stmt|;
return|return;
block|}
block|}
comment|/* 	 * Wrap around to the beginning of the list and continue until the last 	 * iteration device. 	 */
name|dl_list_for_each
argument_list|(
argument|dev
argument_list|,
argument|&p2p->devices
argument_list|,
argument|struct p2p_device
argument_list|,
argument|list
argument_list|)
block|{
if|if
condition|(
name|p2p_pre_find_operation
argument_list|(
name|p2p
argument_list|,
name|dev
argument_list|)
operator|>
literal|0
condition|)
block|{
name|p2p
operator|->
name|last_p2p_find_oper
operator|=
name|dev
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|dev
operator|==
name|p2p
operator|->
name|last_p2p_find_oper
condition|)
break|break;
block|}
name|p2p_listen_in_find
argument_list|(
name|p2p
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|p2p_sd_cb
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|,
name|int
name|success
parameter_list|)
block|{
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Service Discovery Query TX callback: success=%d"
argument_list|,
name|success
argument_list|)
expr_stmt|;
name|p2p
operator|->
name|pending_action_state
operator|=
name|P2P_NO_PENDING_ACTION
expr_stmt|;
if|if
condition|(
operator|!
name|success
condition|)
block|{
if|if
condition|(
name|p2p
operator|->
name|sd_peer
condition|)
name|p2p
operator|->
name|cfg
operator|->
name|send_action_done
argument_list|(
name|p2p
operator|->
name|cfg
operator|->
name|cb_ctx
argument_list|)
expr_stmt|;
name|p2p
operator|->
name|sd_peer
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|p2p
operator|->
name|state
operator|!=
name|P2P_IDLE
condition|)
name|p2p_continue_find
argument_list|(
name|p2p
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|p2p
operator|->
name|sd_peer
operator|==
name|NULL
condition|)
block|{
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"No SD peer entry known"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p2p
operator|->
name|state
operator|!=
name|P2P_IDLE
condition|)
name|p2p_continue_find
argument_list|(
name|p2p
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|p2p
operator|->
name|sd_query
operator|&&
name|p2p
operator|->
name|sd_query
operator|->
name|for_all_peers
condition|)
block|{
comment|/* Update the pending broadcast SD query count for this device 		 */
name|p2p
operator|->
name|sd_peer
operator|->
name|sd_pending_bcast_queries
operator|--
expr_stmt|;
comment|/* 		 * If there are no pending broadcast queries for this device, 		 * mark it as done (-1). 		 */
if|if
condition|(
name|p2p
operator|->
name|sd_peer
operator|->
name|sd_pending_bcast_queries
operator|==
literal|0
condition|)
name|p2p
operator|->
name|sd_peer
operator|->
name|sd_pending_bcast_queries
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/* Wait for response from the peer */
name|p2p_set_state
argument_list|(
name|p2p
argument_list|,
name|P2P_SD_DURING_FIND
argument_list|)
expr_stmt|;
name|p2p_set_timeout
argument_list|(
name|p2p
argument_list|,
literal|0
argument_list|,
literal|200000
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * p2p_retry_pd - Retry any pending provision disc requests in IDLE state  * @p2p: P2P module context from p2p_init()  */
end_comment

begin_function
specifier|static
name|void
name|p2p_retry_pd
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|)
block|{
name|struct
name|p2p_device
modifier|*
name|dev
decl_stmt|;
comment|/* 	 * Retry the prov disc req attempt only for the peer that the user had 	 * requested. 	 */
name|dl_list_for_each
argument_list|(
argument|dev
argument_list|,
argument|&p2p->devices
argument_list|,
argument|struct p2p_device
argument_list|,
argument|list
argument_list|)
block|{
if|if
condition|(
name|os_memcmp
argument_list|(
name|p2p
operator|->
name|pending_pd_devaddr
argument_list|,
name|dev
operator|->
name|info
operator|.
name|p2p_device_addr
argument_list|,
name|ETH_ALEN
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|!
name|dev
operator|->
name|req_config_methods
condition|)
continue|continue;
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Send pending Provision Discovery Request to "
name|MACSTR
literal|" (config methods 0x%x)"
argument_list|,
name|MAC2STR
argument_list|(
name|dev
operator|->
name|info
operator|.
name|p2p_device_addr
argument_list|)
argument_list|,
name|dev
operator|->
name|req_config_methods
argument_list|)
expr_stmt|;
name|p2p_send_prov_disc_req
argument_list|(
name|p2p
argument_list|,
name|dev
argument_list|,
name|dev
operator|->
name|flags
operator|&
name|P2P_DEV_PD_FOR_JOIN
argument_list|,
name|p2p
operator|->
name|pd_force_freq
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|p2p_prov_disc_cb
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|,
name|int
name|success
parameter_list|)
block|{
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Provision Discovery Request TX callback: success=%d"
argument_list|,
name|success
argument_list|)
expr_stmt|;
comment|/* 	 * Postpone resetting the pending action state till after we actually 	 * time out. This allows us to take some action like notifying any 	 * interested parties about no response to the request. 	 * 	 * When the timer (below) goes off we check in IDLE, SEARCH, or 	 * LISTEN_ONLY state, which are the only allowed states to issue a PD 	 * requests in, if this was still pending and then raise notification. 	 */
if|if
condition|(
operator|!
name|success
condition|)
block|{
name|p2p
operator|->
name|pending_action_state
operator|=
name|P2P_NO_PENDING_ACTION
expr_stmt|;
if|if
condition|(
name|p2p
operator|->
name|user_initiated_pd
operator|&&
operator|(
name|p2p
operator|->
name|state
operator|==
name|P2P_SEARCH
operator|||
name|p2p
operator|->
name|state
operator|==
name|P2P_LISTEN_ONLY
operator|)
condition|)
block|{
comment|/* Retry request from timeout to avoid busy loops */
name|p2p
operator|->
name|pending_action_state
operator|=
name|P2P_PENDING_PD
expr_stmt|;
name|p2p_set_timeout
argument_list|(
name|p2p
argument_list|,
literal|0
argument_list|,
literal|50000
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p2p
operator|->
name|state
operator|!=
name|P2P_IDLE
condition|)
name|p2p_continue_find
argument_list|(
name|p2p
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|p2p
operator|->
name|user_initiated_pd
condition|)
block|{
name|p2p
operator|->
name|pending_action_state
operator|=
name|P2P_PENDING_PD
expr_stmt|;
name|p2p_set_timeout
argument_list|(
name|p2p
argument_list|,
literal|0
argument_list|,
literal|300000
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
comment|/* 	 * This postponing, of resetting pending_action_state, needs to be 	 * done only for user initiated PD requests and not internal ones. 	 */
if|if
condition|(
name|p2p
operator|->
name|user_initiated_pd
condition|)
name|p2p
operator|->
name|pending_action_state
operator|=
name|P2P_PENDING_PD
expr_stmt|;
else|else
name|p2p
operator|->
name|pending_action_state
operator|=
name|P2P_NO_PENDING_ACTION
expr_stmt|;
comment|/* Wait for response from the peer */
if|if
condition|(
name|p2p
operator|->
name|state
operator|==
name|P2P_SEARCH
condition|)
name|p2p_set_state
argument_list|(
name|p2p
argument_list|,
name|P2P_PD_DURING_FIND
argument_list|)
expr_stmt|;
name|p2p_set_timeout
argument_list|(
name|p2p
argument_list|,
literal|0
argument_list|,
literal|200000
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|p2p_check_after_scan_tx_continuation
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|)
block|{
if|if
condition|(
name|p2p
operator|->
name|after_scan_tx_in_progress
condition|)
block|{
name|p2p
operator|->
name|after_scan_tx_in_progress
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|p2p
operator|->
name|start_after_scan
operator|!=
name|P2P_AFTER_SCAN_NOTHING
operator|&&
name|p2p_run_after_scan
argument_list|(
name|p2p
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|p2p
operator|->
name|state
operator|==
name|P2P_SEARCH
condition|)
block|{
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Continue find after after_scan_tx completion"
argument_list|)
expr_stmt|;
name|p2p_continue_find
argument_list|(
name|p2p
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|p2p_prov_disc_resp_cb
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|,
name|int
name|success
parameter_list|)
block|{
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Provision Discovery Response TX callback: success=%d"
argument_list|,
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
name|p2p
operator|->
name|send_action_in_progress
condition|)
block|{
name|p2p
operator|->
name|send_action_in_progress
operator|=
literal|0
expr_stmt|;
name|p2p
operator|->
name|cfg
operator|->
name|send_action_done
argument_list|(
name|p2p
operator|->
name|cfg
operator|->
name|cb_ctx
argument_list|)
expr_stmt|;
block|}
name|p2p
operator|->
name|pending_action_state
operator|=
name|P2P_NO_PENDING_ACTION
expr_stmt|;
if|if
condition|(
operator|!
name|success
condition|)
goto|goto
name|continue_search
goto|;
if|if
condition|(
operator|!
name|p2p
operator|->
name|cfg
operator|->
name|prov_disc_resp_cb
operator|||
name|p2p
operator|->
name|cfg
operator|->
name|prov_disc_resp_cb
argument_list|(
name|p2p
operator|->
name|cfg
operator|->
name|cb_ctx
argument_list|)
operator|<
literal|1
condition|)
goto|goto
name|continue_search
goto|;
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Post-Provision Discovery operations started - do not try to continue other P2P operations"
argument_list|)
expr_stmt|;
return|return;
name|continue_search
label|:
name|p2p_check_after_scan_tx_continuation
argument_list|(
name|p2p
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|p2p_scan_res_handler
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|,
specifier|const
name|u8
modifier|*
name|bssid
parameter_list|,
name|int
name|freq
parameter_list|,
name|struct
name|os_reltime
modifier|*
name|rx_time
parameter_list|,
name|int
name|level
parameter_list|,
specifier|const
name|u8
modifier|*
name|ies
parameter_list|,
name|size_t
name|ies_len
parameter_list|)
block|{
if|if
condition|(
name|os_reltime_before
argument_list|(
name|rx_time
argument_list|,
operator|&
name|p2p
operator|->
name|find_start
argument_list|)
condition|)
block|{
comment|/* 		 * The driver may have cached (e.g., in cfg80211 BSS table) the 		 * scan results for relatively long time. To avoid reporting 		 * stale information, update P2P peers only based on results 		 * that have based on frames received after the last p2p_find 		 * operation was started. 		 */
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Ignore old scan result for "
name|MACSTR
literal|" (rx_time=%u.%06u)"
argument_list|,
name|MAC2STR
argument_list|(
name|bssid
argument_list|)
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|rx_time
operator|->
name|sec
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|rx_time
operator|->
name|usec
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|p2p_add_device
argument_list|(
name|p2p
argument_list|,
name|bssid
argument_list|,
name|freq
argument_list|,
name|rx_time
argument_list|,
name|level
argument_list|,
name|ies
argument_list|,
name|ies_len
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|p2p_scan_res_handled
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|)
block|{
if|if
condition|(
operator|!
name|p2p
operator|->
name|p2p_scan_running
condition|)
block|{
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"p2p_scan was not running, but scan results received"
argument_list|)
expr_stmt|;
block|}
name|p2p
operator|->
name|p2p_scan_running
operator|=
literal|0
expr_stmt|;
name|eloop_cancel_timeout
argument_list|(
name|p2p_scan_timeout
argument_list|,
name|p2p
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|p2p_run_after_scan
argument_list|(
name|p2p
argument_list|)
condition|)
return|return;
if|if
condition|(
name|p2p
operator|->
name|state
operator|==
name|P2P_SEARCH
condition|)
name|p2p_continue_find
argument_list|(
name|p2p
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|p2p_scan_ie
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|,
name|struct
name|wpabuf
modifier|*
name|ies
parameter_list|,
specifier|const
name|u8
modifier|*
name|dev_id
parameter_list|)
block|{
name|u8
name|dev_capab
decl_stmt|;
name|u8
modifier|*
name|len
decl_stmt|;
ifdef|#
directive|ifdef
name|CONFIG_WIFI_DISPLAY
if|if
condition|(
name|p2p
operator|->
name|wfd_ie_probe_req
condition|)
name|wpabuf_put_buf
argument_list|(
name|ies
argument_list|,
name|p2p
operator|->
name|wfd_ie_probe_req
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* CONFIG_WIFI_DISPLAY */
if|if
condition|(
name|p2p
operator|->
name|vendor_elem
operator|&&
name|p2p
operator|->
name|vendor_elem
index|[
name|VENDOR_ELEM_PROBE_REQ_P2P
index|]
condition|)
name|wpabuf_put_buf
argument_list|(
name|ies
argument_list|,
name|p2p
operator|->
name|vendor_elem
index|[
name|VENDOR_ELEM_PROBE_REQ_P2P
index|]
argument_list|)
expr_stmt|;
name|len
operator|=
name|p2p_buf_add_ie_hdr
argument_list|(
name|ies
argument_list|)
expr_stmt|;
name|dev_capab
operator|=
name|p2p
operator|->
name|dev_capab
operator|&
operator|~
name|P2P_DEV_CAPAB_CLIENT_DISCOVERABILITY
expr_stmt|;
comment|/* P2PS requires Probe Request frames to include SD bit */
if|if
condition|(
name|p2p
operator|->
name|p2ps_seek
operator|&&
name|p2p
operator|->
name|p2ps_seek_count
condition|)
name|dev_capab
operator||=
name|P2P_DEV_CAPAB_SERVICE_DISCOVERY
expr_stmt|;
name|p2p_buf_add_capability
argument_list|(
name|ies
argument_list|,
name|dev_capab
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev_id
condition|)
name|p2p_buf_add_device_id
argument_list|(
name|ies
argument_list|,
name|dev_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|p2p
operator|->
name|cfg
operator|->
name|reg_class
operator|&&
name|p2p
operator|->
name|cfg
operator|->
name|channel
condition|)
name|p2p_buf_add_listen_channel
argument_list|(
name|ies
argument_list|,
name|p2p
operator|->
name|cfg
operator|->
name|country
argument_list|,
name|p2p
operator|->
name|cfg
operator|->
name|reg_class
argument_list|,
name|p2p
operator|->
name|cfg
operator|->
name|channel
argument_list|)
expr_stmt|;
if|if
condition|(
name|p2p
operator|->
name|ext_listen_interval
condition|)
name|p2p_buf_add_ext_listen_timing
argument_list|(
name|ies
argument_list|,
name|p2p
operator|->
name|ext_listen_period
argument_list|,
name|p2p
operator|->
name|ext_listen_interval
argument_list|)
expr_stmt|;
if|if
condition|(
name|p2p
operator|->
name|p2ps_seek
operator|&&
name|p2p
operator|->
name|p2ps_seek_count
condition|)
name|p2p_buf_add_service_hash
argument_list|(
name|ies
argument_list|,
name|p2p
argument_list|)
expr_stmt|;
comment|/* TODO: p2p_buf_add_operating_channel() if GO */
name|p2p_buf_update_ie_hdr
argument_list|(
name|ies
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|size_t
name|p2p_scan_ie_buf_len
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|)
block|{
name|size_t
name|len
init|=
literal|100
decl_stmt|;
ifdef|#
directive|ifdef
name|CONFIG_WIFI_DISPLAY
if|if
condition|(
name|p2p
operator|&&
name|p2p
operator|->
name|wfd_ie_probe_req
condition|)
name|len
operator|+=
name|wpabuf_len
argument_list|(
name|p2p
operator|->
name|wfd_ie_probe_req
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* CONFIG_WIFI_DISPLAY */
if|if
condition|(
name|p2p
operator|&&
name|p2p
operator|->
name|vendor_elem
operator|&&
name|p2p
operator|->
name|vendor_elem
index|[
name|VENDOR_ELEM_PROBE_REQ_P2P
index|]
condition|)
name|len
operator|+=
name|wpabuf_len
argument_list|(
name|p2p
operator|->
name|vendor_elem
index|[
name|VENDOR_ELEM_PROBE_REQ_P2P
index|]
argument_list|)
expr_stmt|;
return|return
name|len
return|;
block|}
end_function

begin_function
name|int
name|p2p_ie_text
parameter_list|(
name|struct
name|wpabuf
modifier|*
name|p2p_ie
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|char
modifier|*
name|end
parameter_list|)
block|{
return|return
name|p2p_attr_text
argument_list|(
name|p2p_ie
argument_list|,
name|buf
argument_list|,
name|end
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|p2p_go_neg_req_cb
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|,
name|int
name|success
parameter_list|)
block|{
name|struct
name|p2p_device
modifier|*
name|dev
init|=
name|p2p
operator|->
name|go_neg_peer
decl_stmt|;
name|int
name|timeout
decl_stmt|;
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"GO Negotiation Request TX callback: success=%d"
argument_list|,
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|==
name|NULL
condition|)
block|{
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"No pending GO Negotiation"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|success
condition|)
block|{
if|if
condition|(
name|dev
operator|->
name|flags
operator|&
name|P2P_DEV_USER_REJECTED
condition|)
block|{
name|p2p_set_state
argument_list|(
name|p2p
argument_list|,
name|P2P_IDLE
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
elseif|else
if|if
condition|(
name|dev
operator|->
name|go_neg_req_sent
condition|)
block|{
comment|/* Cancel the increment from p2p_connect_send() on failure */
name|dev
operator|->
name|go_neg_req_sent
operator|--
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|success
operator|&&
operator|(
name|dev
operator|->
name|info
operator|.
name|dev_capab
operator|&
name|P2P_DEV_CAPAB_CLIENT_DISCOVERABILITY
operator|)
operator|&&
operator|!
name|is_zero_ether_addr
argument_list|(
name|dev
operator|->
name|member_in_go_dev
argument_list|)
condition|)
block|{
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Peer "
name|MACSTR
literal|" did not acknowledge request - try to use device discoverability through its GO"
argument_list|,
name|MAC2STR
argument_list|(
name|dev
operator|->
name|info
operator|.
name|p2p_device_addr
argument_list|)
argument_list|)
expr_stmt|;
name|p2p
operator|->
name|cfg
operator|->
name|send_action_done
argument_list|(
name|p2p
operator|->
name|cfg
operator|->
name|cb_ctx
argument_list|)
expr_stmt|;
name|p2p_send_dev_disc_req
argument_list|(
name|p2p
argument_list|,
name|dev
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Use P2P find, if needed, to find the other device from its listen 	 * channel. 	 */
name|p2p_set_state
argument_list|(
name|p2p
argument_list|,
name|P2P_CONNECT
argument_list|)
expr_stmt|;
name|timeout
operator|=
name|success
condition|?
literal|500000
else|:
literal|100000
expr_stmt|;
if|if
condition|(
operator|!
name|success
operator|&&
name|p2p
operator|->
name|go_neg_peer
operator|&&
operator|(
name|p2p
operator|->
name|go_neg_peer
operator|->
name|flags
operator|&
name|P2P_DEV_PEER_WAITING_RESPONSE
operator|)
condition|)
block|{
name|unsigned
name|int
name|r
decl_stmt|;
comment|/* 		 * Peer is expected to wait our response and we will skip the 		 * listen phase. Add some randomness to the wait time here to 		 * make it less likely to hit cases where we could end up in 		 * sync with peer not listening. 		 */
if|if
condition|(
name|os_get_random
argument_list|(
operator|(
name|u8
operator|*
operator|)
operator|&
name|r
argument_list|,
sizeof|sizeof
argument_list|(
name|r
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
name|r
operator|=
literal|0
expr_stmt|;
name|timeout
operator|+=
name|r
operator|%
literal|100000
expr_stmt|;
block|}
name|p2p_set_timeout
argument_list|(
name|p2p
argument_list|,
literal|0
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|p2p_go_neg_resp_cb
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|,
name|int
name|success
parameter_list|)
block|{
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"GO Negotiation Response TX callback: success=%d"
argument_list|,
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p2p
operator|->
name|go_neg_peer
operator|&&
name|p2p
operator|->
name|state
operator|==
name|P2P_PROVISIONING
condition|)
block|{
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Ignore TX callback event - GO Negotiation is not running anymore"
argument_list|)
expr_stmt|;
return|return;
block|}
name|p2p_set_state
argument_list|(
name|p2p
argument_list|,
name|P2P_CONNECT
argument_list|)
expr_stmt|;
name|p2p_set_timeout
argument_list|(
name|p2p
argument_list|,
literal|0
argument_list|,
literal|500000
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|p2p_go_neg_resp_failure_cb
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|,
name|int
name|success
parameter_list|,
specifier|const
name|u8
modifier|*
name|addr
parameter_list|)
block|{
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"GO Negotiation Response (failure) TX callback: success=%d"
argument_list|,
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
name|p2p
operator|->
name|go_neg_peer
operator|&&
name|p2p
operator|->
name|go_neg_peer
operator|->
name|status
operator|!=
name|P2P_SC_SUCCESS
condition|)
block|{
name|p2p_go_neg_failed
argument_list|(
name|p2p
argument_list|,
name|p2p
operator|->
name|go_neg_peer
operator|->
name|status
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|success
condition|)
block|{
name|struct
name|p2p_device
modifier|*
name|dev
decl_stmt|;
name|dev
operator|=
name|p2p_get_device
argument_list|(
name|p2p
argument_list|,
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|&&
name|dev
operator|->
name|status
operator|==
name|P2P_SC_FAIL_INFO_CURRENTLY_UNAVAILABLE
condition|)
name|dev
operator|->
name|flags
operator||=
name|P2P_DEV_PEER_WAITING_RESPONSE
expr_stmt|;
block|}
if|if
condition|(
name|p2p
operator|->
name|state
operator|==
name|P2P_SEARCH
operator|||
name|p2p
operator|->
name|state
operator|==
name|P2P_SD_DURING_FIND
condition|)
name|p2p_continue_find
argument_list|(
name|p2p
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|p2p_go_neg_conf_cb
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|,
name|enum
name|p2p_send_action_result
name|result
parameter_list|)
block|{
name|struct
name|p2p_device
modifier|*
name|dev
decl_stmt|;
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"GO Negotiation Confirm TX callback: result=%d"
argument_list|,
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|P2P_SEND_ACTION_FAILED
condition|)
block|{
name|p2p
operator|->
name|cfg
operator|->
name|send_action_done
argument_list|(
name|p2p
operator|->
name|cfg
operator|->
name|cb_ctx
argument_list|)
expr_stmt|;
name|p2p_go_neg_failed
argument_list|(
name|p2p
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
name|dev
operator|=
name|p2p
operator|->
name|go_neg_peer
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|P2P_SEND_ACTION_NO_ACK
condition|)
block|{
comment|/* 		 * Retry GO Negotiation Confirmation 		 * P2P_GO_NEG_CNF_MAX_RETRY_COUNT times if we did not receive 		 * ACK for confirmation. 		 */
if|if
condition|(
name|dev
operator|&&
name|dev
operator|->
name|go_neg_conf
operator|&&
name|dev
operator|->
name|go_neg_conf_sent
operator|<=
name|P2P_GO_NEG_CNF_MAX_RETRY_COUNT
condition|)
block|{
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"GO Negotiation Confirm retry %d"
argument_list|,
name|dev
operator|->
name|go_neg_conf_sent
argument_list|)
expr_stmt|;
name|p2p
operator|->
name|pending_action_state
operator|=
name|P2P_PENDING_GO_NEG_CONFIRM
expr_stmt|;
if|if
condition|(
name|p2p_send_action
argument_list|(
name|p2p
argument_list|,
name|dev
operator|->
name|go_neg_conf_freq
argument_list|,
name|dev
operator|->
name|info
operator|.
name|p2p_device_addr
argument_list|,
name|p2p
operator|->
name|cfg
operator|->
name|dev_addr
argument_list|,
name|dev
operator|->
name|info
operator|.
name|p2p_device_addr
argument_list|,
name|wpabuf_head
argument_list|(
name|dev
operator|->
name|go_neg_conf
argument_list|)
argument_list|,
name|wpabuf_len
argument_list|(
name|dev
operator|->
name|go_neg_conf
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|dev
operator|->
name|go_neg_conf_sent
operator|++
expr_stmt|;
return|return;
block|}
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Failed to re-send Action frame"
argument_list|)
expr_stmt|;
comment|/* 			 * Continue with the assumption that the first attempt 			 * went through and just the ACK frame was lost. 			 */
block|}
comment|/* 		 * It looks like the TX status for GO Negotiation Confirm is 		 * often showing failure even when the peer has actually 		 * received the frame. Since the peer may change channels 		 * immediately after having received the frame, we may not see 		 * an Ack for retries, so just dropping a single frame may 		 * trigger this. To allow the group formation to succeed if the 		 * peer did indeed receive the frame, continue regardless of 		 * the TX status. 		 */
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Assume GO Negotiation Confirm TX was actually received by the peer even though Ack was not reported"
argument_list|)
expr_stmt|;
block|}
name|p2p
operator|->
name|cfg
operator|->
name|send_action_done
argument_list|(
name|p2p
operator|->
name|cfg
operator|->
name|cb_ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|==
name|NULL
condition|)
return|return;
name|p2p_go_complete
argument_list|(
name|p2p
argument_list|,
name|dev
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|p2p_send_action_cb
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|,
name|unsigned
name|int
name|freq
parameter_list|,
specifier|const
name|u8
modifier|*
name|dst
parameter_list|,
specifier|const
name|u8
modifier|*
name|src
parameter_list|,
specifier|const
name|u8
modifier|*
name|bssid
parameter_list|,
name|enum
name|p2p_send_action_result
name|result
parameter_list|)
block|{
name|enum
name|p2p_pending_action_state
name|state
decl_stmt|;
name|int
name|success
decl_stmt|;
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Action frame TX callback (state=%d freq=%u dst="
name|MACSTR
literal|" src="
name|MACSTR
literal|" bssid="
name|MACSTR
literal|" result=%d p2p_state=%s)"
argument_list|,
name|p2p
operator|->
name|pending_action_state
argument_list|,
name|freq
argument_list|,
name|MAC2STR
argument_list|(
name|dst
argument_list|)
argument_list|,
name|MAC2STR
argument_list|(
name|src
argument_list|)
argument_list|,
name|MAC2STR
argument_list|(
name|bssid
argument_list|)
argument_list|,
name|result
argument_list|,
name|p2p_state_txt
argument_list|(
name|p2p
operator|->
name|state
argument_list|)
argument_list|)
expr_stmt|;
name|success
operator|=
name|result
operator|==
name|P2P_SEND_ACTION_SUCCESS
expr_stmt|;
name|state
operator|=
name|p2p
operator|->
name|pending_action_state
expr_stmt|;
name|p2p
operator|->
name|pending_action_state
operator|=
name|P2P_NO_PENDING_ACTION
expr_stmt|;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|P2P_NO_PENDING_ACTION
case|:
if|if
condition|(
name|p2p
operator|->
name|send_action_in_progress
condition|)
block|{
name|p2p
operator|->
name|send_action_in_progress
operator|=
literal|0
expr_stmt|;
name|p2p
operator|->
name|cfg
operator|->
name|send_action_done
argument_list|(
name|p2p
operator|->
name|cfg
operator|->
name|cb_ctx
argument_list|)
expr_stmt|;
block|}
name|p2p_check_after_scan_tx_continuation
argument_list|(
name|p2p
argument_list|)
expr_stmt|;
break|break;
case|case
name|P2P_PENDING_GO_NEG_REQUEST
case|:
name|p2p_go_neg_req_cb
argument_list|(
name|p2p
argument_list|,
name|success
argument_list|)
expr_stmt|;
break|break;
case|case
name|P2P_PENDING_GO_NEG_RESPONSE
case|:
name|p2p_go_neg_resp_cb
argument_list|(
name|p2p
argument_list|,
name|success
argument_list|)
expr_stmt|;
break|break;
case|case
name|P2P_PENDING_GO_NEG_RESPONSE_FAILURE
case|:
name|p2p_go_neg_resp_failure_cb
argument_list|(
name|p2p
argument_list|,
name|success
argument_list|,
name|dst
argument_list|)
expr_stmt|;
break|break;
case|case
name|P2P_PENDING_GO_NEG_CONFIRM
case|:
name|p2p_go_neg_conf_cb
argument_list|(
name|p2p
argument_list|,
name|result
argument_list|)
expr_stmt|;
break|break;
case|case
name|P2P_PENDING_SD
case|:
name|p2p_sd_cb
argument_list|(
name|p2p
argument_list|,
name|success
argument_list|)
expr_stmt|;
break|break;
case|case
name|P2P_PENDING_PD
case|:
name|p2p_prov_disc_cb
argument_list|(
name|p2p
argument_list|,
name|success
argument_list|)
expr_stmt|;
break|break;
case|case
name|P2P_PENDING_PD_RESPONSE
case|:
name|p2p_prov_disc_resp_cb
argument_list|(
name|p2p
argument_list|,
name|success
argument_list|)
expr_stmt|;
break|break;
case|case
name|P2P_PENDING_INVITATION_REQUEST
case|:
name|p2p_invitation_req_cb
argument_list|(
name|p2p
argument_list|,
name|success
argument_list|)
expr_stmt|;
break|break;
case|case
name|P2P_PENDING_INVITATION_RESPONSE
case|:
name|p2p_invitation_resp_cb
argument_list|(
name|p2p
argument_list|,
name|success
argument_list|)
expr_stmt|;
break|break;
case|case
name|P2P_PENDING_DEV_DISC_REQUEST
case|:
name|p2p_dev_disc_req_cb
argument_list|(
name|p2p
argument_list|,
name|success
argument_list|)
expr_stmt|;
break|break;
case|case
name|P2P_PENDING_DEV_DISC_RESPONSE
case|:
name|p2p_dev_disc_resp_cb
argument_list|(
name|p2p
argument_list|,
name|success
argument_list|)
expr_stmt|;
break|break;
case|case
name|P2P_PENDING_GO_DISC_REQ
case|:
name|p2p_go_disc_req_cb
argument_list|(
name|p2p
argument_list|,
name|success
argument_list|)
expr_stmt|;
break|break;
block|}
name|p2p
operator|->
name|after_scan_tx_in_progress
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|p2p_listen_cb
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|,
name|unsigned
name|int
name|freq
parameter_list|,
name|unsigned
name|int
name|duration
parameter_list|)
block|{
if|if
condition|(
name|freq
operator|==
name|p2p
operator|->
name|pending_client_disc_freq
condition|)
block|{
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Client discoverability remain-awake completed"
argument_list|)
expr_stmt|;
name|p2p
operator|->
name|pending_client_disc_freq
operator|=
literal|0
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|freq
operator|!=
name|p2p
operator|->
name|pending_listen_freq
condition|)
block|{
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Unexpected listen callback for freq=%u duration=%u (pending_listen_freq=%u)"
argument_list|,
name|freq
argument_list|,
name|duration
argument_list|,
name|p2p
operator|->
name|pending_listen_freq
argument_list|)
expr_stmt|;
return|return;
block|}
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Starting Listen timeout(%u,%u) on freq=%u based on callback"
argument_list|,
name|p2p
operator|->
name|pending_listen_sec
argument_list|,
name|p2p
operator|->
name|pending_listen_usec
argument_list|,
name|p2p
operator|->
name|pending_listen_freq
argument_list|)
expr_stmt|;
name|p2p
operator|->
name|in_listen
operator|=
literal|1
expr_stmt|;
name|p2p
operator|->
name|drv_in_listen
operator|=
name|freq
expr_stmt|;
if|if
condition|(
name|p2p
operator|->
name|pending_listen_sec
operator|||
name|p2p
operator|->
name|pending_listen_usec
condition|)
block|{
comment|/* 		 * Add 20 msec extra wait to avoid race condition with driver 		 * remain-on-channel end event, i.e., give driver more time to 		 * complete the operation before our timeout expires. 		 */
name|p2p_set_timeout
argument_list|(
name|p2p
argument_list|,
name|p2p
operator|->
name|pending_listen_sec
argument_list|,
name|p2p
operator|->
name|pending_listen_usec
operator|+
literal|20000
argument_list|)
expr_stmt|;
block|}
name|p2p
operator|->
name|pending_listen_freq
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|int
name|p2p_listen_end
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|,
name|unsigned
name|int
name|freq
parameter_list|)
block|{
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Driver ended Listen state (freq=%u)"
argument_list|,
name|freq
argument_list|)
expr_stmt|;
name|p2p
operator|->
name|drv_in_listen
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|p2p
operator|->
name|in_listen
condition|)
return|return
literal|0
return|;
comment|/* Internal timeout will trigger the next step */
if|if
condition|(
name|p2p
operator|->
name|state
operator|==
name|P2P_CONNECT_LISTEN
operator|&&
name|p2p
operator|->
name|go_neg_peer
condition|)
block|{
if|if
condition|(
name|p2p
operator|->
name|go_neg_peer
operator|->
name|connect_reqs
operator|>=
literal|120
condition|)
block|{
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Timeout on sending GO Negotiation Request without getting response"
argument_list|)
expr_stmt|;
name|p2p_go_neg_failed
argument_list|(
name|p2p
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|p2p_set_state
argument_list|(
name|p2p
argument_list|,
name|P2P_CONNECT
argument_list|)
expr_stmt|;
name|p2p_connect_send
argument_list|(
name|p2p
argument_list|,
name|p2p
operator|->
name|go_neg_peer
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|p2p
operator|->
name|state
operator|==
name|P2P_SEARCH
condition|)
block|{
if|if
condition|(
name|p2p
operator|->
name|p2p_scan_running
condition|)
block|{
comment|/* 			  * Search is already in progress. This can happen if 			  * an Action frame RX is reported immediately after 			  * the end of a remain-on-channel operation and the 			  * response frame to that is sent using an offchannel 			  * operation while in p2p_find. Avoid an attempt to 			  * restart a scan here. 			  */
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"p2p_scan already in progress - do not try to start a new one"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|p2p
operator|->
name|pending_listen_freq
condition|)
block|{
comment|/* 			 * Better wait a bit if the driver is unable to start 			 * offchannel operation for some reason. p2p_search() 			 * will be started from internal timeout. 			 */
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Listen operation did not seem to start - delay search phase to avoid busy loop"
argument_list|)
expr_stmt|;
name|p2p_set_timeout
argument_list|(
name|p2p
argument_list|,
literal|0
argument_list|,
literal|100000
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|p2p
operator|->
name|search_delay
condition|)
block|{
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Delay search operation by %u ms"
argument_list|,
name|p2p
operator|->
name|search_delay
argument_list|)
expr_stmt|;
name|p2p_set_timeout
argument_list|(
name|p2p
argument_list|,
name|p2p
operator|->
name|search_delay
operator|/
literal|1000
argument_list|,
operator|(
name|p2p
operator|->
name|search_delay
operator|%
literal|1000
operator|)
operator|*
literal|1000
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|p2p_search
argument_list|(
name|p2p
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|p2p_timeout_connect
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|)
block|{
name|p2p
operator|->
name|cfg
operator|->
name|send_action_done
argument_list|(
name|p2p
operator|->
name|cfg
operator|->
name|cb_ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|p2p
operator|->
name|go_neg_peer
operator|&&
operator|(
name|p2p
operator|->
name|go_neg_peer
operator|->
name|flags
operator|&
name|P2P_DEV_WAIT_GO_NEG_CONFIRM
operator|)
condition|)
block|{
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Wait for GO Negotiation Confirm timed out - assume GO Negotiation failed"
argument_list|)
expr_stmt|;
name|p2p_go_neg_failed
argument_list|(
name|p2p
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|p2p
operator|->
name|go_neg_peer
operator|&&
operator|(
name|p2p
operator|->
name|go_neg_peer
operator|->
name|flags
operator|&
name|P2P_DEV_PEER_WAITING_RESPONSE
operator|)
operator|&&
name|p2p
operator|->
name|go_neg_peer
operator|->
name|connect_reqs
operator|<
literal|120
condition|)
block|{
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Peer expected to wait our response - skip listen"
argument_list|)
expr_stmt|;
name|p2p_connect_send
argument_list|(
name|p2p
argument_list|,
name|p2p
operator|->
name|go_neg_peer
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|p2p
operator|->
name|go_neg_peer
operator|&&
name|p2p
operator|->
name|go_neg_peer
operator|->
name|oob_go_neg_freq
operator|>
literal|0
condition|)
block|{
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Skip connect-listen since GO Neg channel known (OOB)"
argument_list|)
expr_stmt|;
name|p2p_set_state
argument_list|(
name|p2p
argument_list|,
name|P2P_CONNECT_LISTEN
argument_list|)
expr_stmt|;
name|p2p_set_timeout
argument_list|(
name|p2p
argument_list|,
literal|0
argument_list|,
literal|30000
argument_list|)
expr_stmt|;
return|return;
block|}
name|p2p_set_state
argument_list|(
name|p2p
argument_list|,
name|P2P_CONNECT_LISTEN
argument_list|)
expr_stmt|;
name|p2p_listen_in_find
argument_list|(
name|p2p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|p2p_timeout_connect_listen
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|)
block|{
if|if
condition|(
name|p2p
operator|->
name|go_neg_peer
condition|)
block|{
if|if
condition|(
name|p2p
operator|->
name|drv_in_listen
condition|)
block|{
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Driver is still in Listen state; wait for it to complete"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|p2p
operator|->
name|go_neg_peer
operator|->
name|connect_reqs
operator|>=
literal|120
condition|)
block|{
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Timeout on sending GO Negotiation Request without getting response"
argument_list|)
expr_stmt|;
name|p2p_go_neg_failed
argument_list|(
name|p2p
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
name|p2p_set_state
argument_list|(
name|p2p
argument_list|,
name|P2P_CONNECT
argument_list|)
expr_stmt|;
name|p2p_connect_send
argument_list|(
name|p2p
argument_list|,
name|p2p
operator|->
name|go_neg_peer
argument_list|)
expr_stmt|;
block|}
else|else
name|p2p_set_state
argument_list|(
name|p2p
argument_list|,
name|P2P_IDLE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|p2p_timeout_wait_peer_connect
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|)
block|{
name|p2p_set_state
argument_list|(
name|p2p
argument_list|,
name|P2P_WAIT_PEER_IDLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|p2p
operator|->
name|cfg
operator|->
name|is_concurrent_session_active
operator|&&
name|p2p
operator|->
name|cfg
operator|->
name|is_concurrent_session_active
argument_list|(
name|p2p
operator|->
name|cfg
operator|->
name|cb_ctx
argument_list|)
condition|)
name|p2p_set_timeout
argument_list|(
name|p2p
argument_list|,
literal|0
argument_list|,
literal|500000
argument_list|)
expr_stmt|;
else|else
name|p2p_set_timeout
argument_list|(
name|p2p
argument_list|,
literal|0
argument_list|,
literal|200000
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|p2p_timeout_wait_peer_idle
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|)
block|{
name|struct
name|p2p_device
modifier|*
name|dev
init|=
name|p2p
operator|->
name|go_neg_peer
decl_stmt|;
if|if
condition|(
name|dev
operator|==
name|NULL
condition|)
block|{
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Unknown GO Neg peer - stop GO Neg wait"
argument_list|)
expr_stmt|;
return|return;
block|}
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Go to Listen state while waiting for the peer to become ready for GO Negotiation"
argument_list|)
expr_stmt|;
name|p2p_set_state
argument_list|(
name|p2p
argument_list|,
name|P2P_WAIT_PEER_CONNECT
argument_list|)
expr_stmt|;
name|p2p_listen_in_find
argument_list|(
name|p2p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|p2p_timeout_sd_during_find
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|)
block|{
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Service Discovery Query timeout"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p2p
operator|->
name|sd_peer
condition|)
block|{
name|p2p
operator|->
name|cfg
operator|->
name|send_action_done
argument_list|(
name|p2p
operator|->
name|cfg
operator|->
name|cb_ctx
argument_list|)
expr_stmt|;
name|p2p
operator|->
name|sd_peer
operator|=
name|NULL
expr_stmt|;
block|}
name|p2p_continue_find
argument_list|(
name|p2p
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|p2p_timeout_prov_disc_during_find
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|)
block|{
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Provision Discovery Request timeout"
argument_list|)
expr_stmt|;
name|p2p
operator|->
name|cfg
operator|->
name|send_action_done
argument_list|(
name|p2p
operator|->
name|cfg
operator|->
name|cb_ctx
argument_list|)
expr_stmt|;
name|p2p_continue_find
argument_list|(
name|p2p
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|p2p_timeout_prov_disc_req
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|)
block|{
name|u32
name|adv_id
init|=
literal|0
decl_stmt|;
name|u8
modifier|*
name|adv_mac
init|=
name|NULL
decl_stmt|;
name|p2p
operator|->
name|pending_action_state
operator|=
name|P2P_NO_PENDING_ACTION
expr_stmt|;
comment|/* 	 * For user initiated PD requests that we have not gotten any responses 	 * for while in IDLE state, we retry them a couple of times before 	 * giving up. 	 */
if|if
condition|(
operator|!
name|p2p
operator|->
name|user_initiated_pd
condition|)
return|return;
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"User initiated Provision Discovery Request timeout"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p2p
operator|->
name|pd_retries
condition|)
block|{
name|p2p
operator|->
name|pd_retries
operator|--
expr_stmt|;
name|p2p_retry_pd
argument_list|(
name|p2p
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|p2p_device
modifier|*
name|dev
decl_stmt|;
name|int
name|for_join
init|=
literal|0
decl_stmt|;
name|dl_list_for_each
argument_list|(
argument|dev
argument_list|,
argument|&p2p->devices
argument_list|,
argument|struct p2p_device
argument_list|,
argument|list
argument_list|)
block|{
if|if
condition|(
name|os_memcmp
argument_list|(
name|p2p
operator|->
name|pending_pd_devaddr
argument_list|,
name|dev
operator|->
name|info
operator|.
name|p2p_device_addr
argument_list|,
name|ETH_ALEN
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
if|if
condition|(
name|dev
operator|->
name|req_config_methods
operator|&&
operator|(
name|dev
operator|->
name|flags
operator|&
name|P2P_DEV_PD_FOR_JOIN
operator|)
condition|)
name|for_join
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|p2p
operator|->
name|p2ps_prov
condition|)
block|{
name|adv_id
operator|=
name|p2p
operator|->
name|p2ps_prov
operator|->
name|adv_id
expr_stmt|;
name|adv_mac
operator|=
name|p2p
operator|->
name|p2ps_prov
operator|->
name|adv_mac
expr_stmt|;
block|}
if|if
condition|(
name|p2p
operator|->
name|cfg
operator|->
name|prov_disc_fail
condition|)
name|p2p
operator|->
name|cfg
operator|->
name|prov_disc_fail
argument_list|(
name|p2p
operator|->
name|cfg
operator|->
name|cb_ctx
argument_list|,
name|p2p
operator|->
name|pending_pd_devaddr
argument_list|,
name|for_join
condition|?
name|P2P_PROV_DISC_TIMEOUT_JOIN
else|:
name|P2P_PROV_DISC_TIMEOUT
argument_list|,
name|adv_id
argument_list|,
name|adv_mac
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|p2p_reset_pending_pd
argument_list|(
name|p2p
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|p2p_timeout_invite
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|)
block|{
name|p2p
operator|->
name|cfg
operator|->
name|send_action_done
argument_list|(
name|p2p
operator|->
name|cfg
operator|->
name|cb_ctx
argument_list|)
expr_stmt|;
name|p2p_set_state
argument_list|(
name|p2p
argument_list|,
name|P2P_INVITE_LISTEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|p2p
operator|->
name|inv_role
operator|==
name|P2P_INVITE_ROLE_ACTIVE_GO
condition|)
block|{
comment|/* 		 * Better remain on operating channel instead of listen channel 		 * when running a group. 		 */
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Inviting in active GO role - wait on operating channel"
argument_list|)
expr_stmt|;
name|p2p_set_timeout
argument_list|(
name|p2p
argument_list|,
literal|0
argument_list|,
literal|100000
argument_list|)
expr_stmt|;
return|return;
block|}
name|p2p_listen_in_find
argument_list|(
name|p2p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|p2p_timeout_invite_listen
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|)
block|{
if|if
condition|(
name|p2p
operator|->
name|invite_peer
operator|&&
name|p2p
operator|->
name|invite_peer
operator|->
name|invitation_reqs
operator|<
literal|100
condition|)
block|{
name|p2p_set_state
argument_list|(
name|p2p
argument_list|,
name|P2P_INVITE
argument_list|)
expr_stmt|;
name|p2p_invite_send
argument_list|(
name|p2p
argument_list|,
name|p2p
operator|->
name|invite_peer
argument_list|,
name|p2p
operator|->
name|invite_go_dev_addr
argument_list|,
name|p2p
operator|->
name|invite_dev_pw_id
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|p2p
operator|->
name|invite_peer
condition|)
block|{
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Invitation Request retry limit reached"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p2p
operator|->
name|cfg
operator|->
name|invitation_result
condition|)
name|p2p
operator|->
name|cfg
operator|->
name|invitation_result
argument_list|(
name|p2p
operator|->
name|cfg
operator|->
name|cb_ctx
argument_list|,
operator|-
literal|1
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|p2p
operator|->
name|invite_peer
operator|->
name|info
operator|.
name|p2p_device_addr
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|p2p_set_state
argument_list|(
name|p2p
argument_list|,
name|P2P_IDLE
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|p2p_state_timeout
parameter_list|(
name|void
modifier|*
name|eloop_ctx
parameter_list|,
name|void
modifier|*
name|timeout_ctx
parameter_list|)
block|{
name|struct
name|p2p_data
modifier|*
name|p2p
init|=
name|eloop_ctx
decl_stmt|;
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Timeout (state=%s)"
argument_list|,
name|p2p_state_txt
argument_list|(
name|p2p
operator|->
name|state
argument_list|)
argument_list|)
expr_stmt|;
name|p2p
operator|->
name|in_listen
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|p2p
operator|->
name|drv_in_listen
condition|)
block|{
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Driver is still in listen state - stop it"
argument_list|)
expr_stmt|;
name|p2p
operator|->
name|cfg
operator|->
name|stop_listen
argument_list|(
name|p2p
operator|->
name|cfg
operator|->
name|cb_ctx
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|p2p
operator|->
name|state
condition|)
block|{
case|case
name|P2P_IDLE
case|:
comment|/* Check if we timed out waiting for PD req */
if|if
condition|(
name|p2p
operator|->
name|pending_action_state
operator|==
name|P2P_PENDING_PD
condition|)
name|p2p_timeout_prov_disc_req
argument_list|(
name|p2p
argument_list|)
expr_stmt|;
break|break;
case|case
name|P2P_SEARCH
case|:
comment|/* Check if we timed out waiting for PD req */
if|if
condition|(
name|p2p
operator|->
name|pending_action_state
operator|==
name|P2P_PENDING_PD
condition|)
name|p2p_timeout_prov_disc_req
argument_list|(
name|p2p
argument_list|)
expr_stmt|;
if|if
condition|(
name|p2p
operator|->
name|search_delay
operator|&&
operator|!
name|p2p
operator|->
name|in_search_delay
condition|)
block|{
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Delay search operation by %u ms"
argument_list|,
name|p2p
operator|->
name|search_delay
argument_list|)
expr_stmt|;
name|p2p
operator|->
name|in_search_delay
operator|=
literal|1
expr_stmt|;
name|p2p_set_timeout
argument_list|(
name|p2p
argument_list|,
name|p2p
operator|->
name|search_delay
operator|/
literal|1000
argument_list|,
operator|(
name|p2p
operator|->
name|search_delay
operator|%
literal|1000
operator|)
operator|*
literal|1000
argument_list|)
expr_stmt|;
break|break;
block|}
name|p2p
operator|->
name|in_search_delay
operator|=
literal|0
expr_stmt|;
name|p2p_search
argument_list|(
name|p2p
argument_list|)
expr_stmt|;
break|break;
case|case
name|P2P_CONNECT
case|:
name|p2p_timeout_connect
argument_list|(
name|p2p
argument_list|)
expr_stmt|;
break|break;
case|case
name|P2P_CONNECT_LISTEN
case|:
name|p2p_timeout_connect_listen
argument_list|(
name|p2p
argument_list|)
expr_stmt|;
break|break;
case|case
name|P2P_GO_NEG
case|:
break|break;
case|case
name|P2P_LISTEN_ONLY
case|:
comment|/* Check if we timed out waiting for PD req */
if|if
condition|(
name|p2p
operator|->
name|pending_action_state
operator|==
name|P2P_PENDING_PD
condition|)
name|p2p_timeout_prov_disc_req
argument_list|(
name|p2p
argument_list|)
expr_stmt|;
if|if
condition|(
name|p2p
operator|->
name|ext_listen_only
condition|)
block|{
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Extended Listen Timing - Listen State completed"
argument_list|)
expr_stmt|;
name|p2p
operator|->
name|ext_listen_only
operator|=
literal|0
expr_stmt|;
name|p2p_set_state
argument_list|(
name|p2p
argument_list|,
name|P2P_IDLE
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|P2P_WAIT_PEER_CONNECT
case|:
name|p2p_timeout_wait_peer_connect
argument_list|(
name|p2p
argument_list|)
expr_stmt|;
break|break;
case|case
name|P2P_WAIT_PEER_IDLE
case|:
name|p2p_timeout_wait_peer_idle
argument_list|(
name|p2p
argument_list|)
expr_stmt|;
break|break;
case|case
name|P2P_SD_DURING_FIND
case|:
name|p2p_timeout_sd_during_find
argument_list|(
name|p2p
argument_list|)
expr_stmt|;
break|break;
case|case
name|P2P_PROVISIONING
case|:
break|break;
case|case
name|P2P_PD_DURING_FIND
case|:
name|p2p_timeout_prov_disc_during_find
argument_list|(
name|p2p
argument_list|)
expr_stmt|;
break|break;
case|case
name|P2P_INVITE
case|:
name|p2p_timeout_invite
argument_list|(
name|p2p
argument_list|)
expr_stmt|;
break|break;
case|case
name|P2P_INVITE_LISTEN
case|:
name|p2p_timeout_invite_listen
argument_list|(
name|p2p
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
name|int
name|p2p_reject
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|,
specifier|const
name|u8
modifier|*
name|peer_addr
parameter_list|)
block|{
name|struct
name|p2p_device
modifier|*
name|dev
decl_stmt|;
name|dev
operator|=
name|p2p_get_device
argument_list|(
name|p2p
argument_list|,
name|peer_addr
argument_list|)
expr_stmt|;
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Local request to reject connection attempts by peer "
name|MACSTR
argument_list|,
name|MAC2STR
argument_list|(
name|peer_addr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|==
name|NULL
condition|)
block|{
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Peer "
name|MACSTR
literal|" unknown"
argument_list|,
name|MAC2STR
argument_list|(
name|peer_addr
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|dev
operator|->
name|status
operator|=
name|P2P_SC_FAIL_REJECTED_BY_USER
expr_stmt|;
name|dev
operator|->
name|flags
operator||=
name|P2P_DEV_USER_REJECTED
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|p2p_wps_method_text
parameter_list|(
name|enum
name|p2p_wps_method
name|method
parameter_list|)
block|{
switch|switch
condition|(
name|method
condition|)
block|{
case|case
name|WPS_NOT_READY
case|:
return|return
literal|"not-ready"
return|;
case|case
name|WPS_PIN_DISPLAY
case|:
return|return
literal|"Display"
return|;
case|case
name|WPS_PIN_KEYPAD
case|:
return|return
literal|"Keypad"
return|;
case|case
name|WPS_PBC
case|:
return|return
literal|"PBC"
return|;
case|case
name|WPS_NFC
case|:
return|return
literal|"NFC"
return|;
case|case
name|WPS_P2PS
case|:
return|return
literal|"P2PS"
return|;
block|}
return|return
literal|"??"
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|p2p_go_state_text
parameter_list|(
name|enum
name|p2p_go_state
name|go_state
parameter_list|)
block|{
switch|switch
condition|(
name|go_state
condition|)
block|{
case|case
name|UNKNOWN_GO
case|:
return|return
literal|"unknown"
return|;
case|case
name|LOCAL_GO
case|:
return|return
literal|"local"
return|;
case|case
name|REMOTE_GO
case|:
return|return
literal|"remote"
return|;
block|}
return|return
literal|"??"
return|;
block|}
end_function

begin_function
specifier|const
name|struct
name|p2p_peer_info
modifier|*
name|p2p_get_peer_info
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|,
specifier|const
name|u8
modifier|*
name|addr
parameter_list|,
name|int
name|next
parameter_list|)
block|{
name|struct
name|p2p_device
modifier|*
name|dev
decl_stmt|;
if|if
condition|(
name|addr
condition|)
name|dev
operator|=
name|p2p_get_device
argument_list|(
name|p2p
argument_list|,
name|addr
argument_list|)
expr_stmt|;
else|else
name|dev
operator|=
name|dl_list_first
argument_list|(
operator|&
name|p2p
operator|->
name|devices
argument_list|,
expr|struct
name|p2p_device
argument_list|,
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|&&
name|next
condition|)
block|{
name|dev
operator|=
name|dl_list_first
argument_list|(
operator|&
name|dev
operator|->
name|list
argument_list|,
expr|struct
name|p2p_device
argument_list|,
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
operator|&
name|dev
operator|->
name|list
operator|==
operator|&
name|p2p
operator|->
name|devices
condition|)
name|dev
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|dev
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
return|return
operator|&
name|dev
operator|->
name|info
return|;
block|}
end_function

begin_function
name|int
name|p2p_get_peer_info_txt
parameter_list|(
specifier|const
name|struct
name|p2p_peer_info
modifier|*
name|info
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|buflen
parameter_list|)
block|{
name|struct
name|p2p_device
modifier|*
name|dev
decl_stmt|;
name|int
name|res
decl_stmt|;
name|char
modifier|*
name|pos
decl_stmt|,
modifier|*
name|end
decl_stmt|;
name|struct
name|os_reltime
name|now
decl_stmt|;
if|if
condition|(
name|info
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|dev
operator|=
operator|(
expr|struct
name|p2p_device
operator|*
operator|)
operator|(
operator|(
operator|(
name|u8
operator|*
operator|)
name|info
operator|)
operator|-
name|offsetof
argument_list|(
expr|struct
name|p2p_device
argument_list|,
name|info
argument_list|)
operator|)
expr_stmt|;
name|pos
operator|=
name|buf
expr_stmt|;
name|end
operator|=
name|buf
operator|+
name|buflen
expr_stmt|;
name|os_get_reltime
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
name|res
operator|=
name|os_snprintf
argument_list|(
name|pos
argument_list|,
name|end
operator|-
name|pos
argument_list|,
literal|"age=%d\n"
literal|"listen_freq=%d\n"
literal|"wps_method=%s\n"
literal|"interface_addr="
name|MACSTR
literal|"\n"
literal|"member_in_go_dev="
name|MACSTR
literal|"\n"
literal|"member_in_go_iface="
name|MACSTR
literal|"\n"
literal|"go_neg_req_sent=%d\n"
literal|"go_state=%s\n"
literal|"dialog_token=%u\n"
literal|"intended_addr="
name|MACSTR
literal|"\n"
literal|"country=%c%c\n"
literal|"oper_freq=%d\n"
literal|"req_config_methods=0x%x\n"
literal|"flags=%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s\n"
literal|"status=%d\n"
literal|"invitation_reqs=%u\n"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|now
operator|.
name|sec
operator|-
name|dev
operator|->
name|last_seen
operator|.
name|sec
argument_list|)
argument_list|,
name|dev
operator|->
name|listen_freq
argument_list|,
name|p2p_wps_method_text
argument_list|(
name|dev
operator|->
name|wps_method
argument_list|)
argument_list|,
name|MAC2STR
argument_list|(
name|dev
operator|->
name|interface_addr
argument_list|)
argument_list|,
name|MAC2STR
argument_list|(
name|dev
operator|->
name|member_in_go_dev
argument_list|)
argument_list|,
name|MAC2STR
argument_list|(
name|dev
operator|->
name|member_in_go_iface
argument_list|)
argument_list|,
name|dev
operator|->
name|go_neg_req_sent
argument_list|,
name|p2p_go_state_text
argument_list|(
name|dev
operator|->
name|go_state
argument_list|)
argument_list|,
name|dev
operator|->
name|dialog_token
argument_list|,
name|MAC2STR
argument_list|(
name|dev
operator|->
name|intended_addr
argument_list|)
argument_list|,
name|dev
operator|->
name|country
index|[
literal|0
index|]
condition|?
name|dev
operator|->
name|country
index|[
literal|0
index|]
else|:
literal|'_'
argument_list|,
name|dev
operator|->
name|country
index|[
literal|1
index|]
condition|?
name|dev
operator|->
name|country
index|[
literal|1
index|]
else|:
literal|'_'
argument_list|,
name|dev
operator|->
name|oper_freq
argument_list|,
name|dev
operator|->
name|req_config_methods
argument_list|,
name|dev
operator|->
name|flags
operator|&
name|P2P_DEV_PROBE_REQ_ONLY
condition|?
literal|"[PROBE_REQ_ONLY]"
else|:
literal|""
argument_list|,
name|dev
operator|->
name|flags
operator|&
name|P2P_DEV_REPORTED
condition|?
literal|"[REPORTED]"
else|:
literal|""
argument_list|,
name|dev
operator|->
name|flags
operator|&
name|P2P_DEV_NOT_YET_READY
condition|?
literal|"[NOT_YET_READY]"
else|:
literal|""
argument_list|,
name|dev
operator|->
name|flags
operator|&
name|P2P_DEV_PD_PEER_DISPLAY
condition|?
literal|"[PD_PEER_DISPLAY]"
else|:
literal|""
argument_list|,
name|dev
operator|->
name|flags
operator|&
name|P2P_DEV_PD_PEER_KEYPAD
condition|?
literal|"[PD_PEER_KEYPAD]"
else|:
literal|""
argument_list|,
name|dev
operator|->
name|flags
operator|&
name|P2P_DEV_PD_PEER_P2PS
condition|?
literal|"[PD_PEER_P2PS]"
else|:
literal|""
argument_list|,
name|dev
operator|->
name|flags
operator|&
name|P2P_DEV_USER_REJECTED
condition|?
literal|"[USER_REJECTED]"
else|:
literal|""
argument_list|,
name|dev
operator|->
name|flags
operator|&
name|P2P_DEV_PEER_WAITING_RESPONSE
condition|?
literal|"[PEER_WAITING_RESPONSE]"
else|:
literal|""
argument_list|,
name|dev
operator|->
name|flags
operator|&
name|P2P_DEV_PREFER_PERSISTENT_GROUP
condition|?
literal|"[PREFER_PERSISTENT_GROUP]"
else|:
literal|""
argument_list|,
name|dev
operator|->
name|flags
operator|&
name|P2P_DEV_WAIT_GO_NEG_RESPONSE
condition|?
literal|"[WAIT_GO_NEG_RESPONSE]"
else|:
literal|""
argument_list|,
name|dev
operator|->
name|flags
operator|&
name|P2P_DEV_WAIT_GO_NEG_CONFIRM
condition|?
literal|"[WAIT_GO_NEG_CONFIRM]"
else|:
literal|""
argument_list|,
name|dev
operator|->
name|flags
operator|&
name|P2P_DEV_GROUP_CLIENT_ONLY
condition|?
literal|"[GROUP_CLIENT_ONLY]"
else|:
literal|""
argument_list|,
name|dev
operator|->
name|flags
operator|&
name|P2P_DEV_FORCE_FREQ
condition|?
literal|"[FORCE_FREQ]"
else|:
literal|""
argument_list|,
name|dev
operator|->
name|flags
operator|&
name|P2P_DEV_PD_FOR_JOIN
condition|?
literal|"[PD_FOR_JOIN]"
else|:
literal|""
argument_list|,
name|dev
operator|->
name|flags
operator|&
name|P2P_DEV_LAST_SEEN_AS_GROUP_CLIENT
condition|?
literal|"[LAST_SEEN_AS_GROUP_CLIENT]"
else|:
literal|""
argument_list|,
name|dev
operator|->
name|status
argument_list|,
name|dev
operator|->
name|invitation_reqs
argument_list|)
expr_stmt|;
if|if
condition|(
name|os_snprintf_error
argument_list|(
name|end
operator|-
name|pos
argument_list|,
name|res
argument_list|)
condition|)
return|return
name|pos
operator|-
name|buf
return|;
name|pos
operator|+=
name|res
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|ext_listen_period
condition|)
block|{
name|res
operator|=
name|os_snprintf
argument_list|(
name|pos
argument_list|,
name|end
operator|-
name|pos
argument_list|,
literal|"ext_listen_period=%u\n"
literal|"ext_listen_interval=%u\n"
argument_list|,
name|dev
operator|->
name|ext_listen_period
argument_list|,
name|dev
operator|->
name|ext_listen_interval
argument_list|)
expr_stmt|;
if|if
condition|(
name|os_snprintf_error
argument_list|(
name|end
operator|-
name|pos
argument_list|,
name|res
argument_list|)
condition|)
return|return
name|pos
operator|-
name|buf
return|;
name|pos
operator|+=
name|res
expr_stmt|;
block|}
if|if
condition|(
name|dev
operator|->
name|oper_ssid_len
condition|)
block|{
name|res
operator|=
name|os_snprintf
argument_list|(
name|pos
argument_list|,
name|end
operator|-
name|pos
argument_list|,
literal|"oper_ssid=%s\n"
argument_list|,
name|wpa_ssid_txt
argument_list|(
name|dev
operator|->
name|oper_ssid
argument_list|,
name|dev
operator|->
name|oper_ssid_len
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|os_snprintf_error
argument_list|(
name|end
operator|-
name|pos
argument_list|,
name|res
argument_list|)
condition|)
return|return
name|pos
operator|-
name|buf
return|;
name|pos
operator|+=
name|res
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|CONFIG_WIFI_DISPLAY
if|if
condition|(
name|dev
operator|->
name|info
operator|.
name|wfd_subelems
condition|)
block|{
name|res
operator|=
name|os_snprintf
argument_list|(
name|pos
argument_list|,
name|end
operator|-
name|pos
argument_list|,
literal|"wfd_subelems="
argument_list|)
expr_stmt|;
if|if
condition|(
name|os_snprintf_error
argument_list|(
name|end
operator|-
name|pos
argument_list|,
name|res
argument_list|)
condition|)
return|return
name|pos
operator|-
name|buf
return|;
name|pos
operator|+=
name|res
expr_stmt|;
name|pos
operator|+=
name|wpa_snprintf_hex
argument_list|(
name|pos
argument_list|,
name|end
operator|-
name|pos
argument_list|,
name|wpabuf_head
argument_list|(
name|dev
operator|->
name|info
operator|.
name|wfd_subelems
argument_list|)
argument_list|,
name|wpabuf_len
argument_list|(
name|dev
operator|->
name|info
operator|.
name|wfd_subelems
argument_list|)
argument_list|)
expr_stmt|;
name|res
operator|=
name|os_snprintf
argument_list|(
name|pos
argument_list|,
name|end
operator|-
name|pos
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|os_snprintf_error
argument_list|(
name|end
operator|-
name|pos
argument_list|,
name|res
argument_list|)
condition|)
return|return
name|pos
operator|-
name|buf
return|;
name|pos
operator|+=
name|res
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* CONFIG_WIFI_DISPLAY */
return|return
name|pos
operator|-
name|buf
return|;
block|}
end_function

begin_function
name|int
name|p2p_peer_known
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|,
specifier|const
name|u8
modifier|*
name|addr
parameter_list|)
block|{
return|return
name|p2p_get_device
argument_list|(
name|p2p
argument_list|,
name|addr
argument_list|)
operator|!=
name|NULL
return|;
block|}
end_function

begin_function
name|void
name|p2p_set_client_discoverability
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|,
name|int
name|enabled
parameter_list|)
block|{
if|if
condition|(
name|enabled
condition|)
block|{
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Client discoverability enabled"
argument_list|)
expr_stmt|;
name|p2p
operator|->
name|dev_capab
operator||=
name|P2P_DEV_CAPAB_CLIENT_DISCOVERABILITY
expr_stmt|;
block|}
else|else
block|{
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Client discoverability disabled"
argument_list|)
expr_stmt|;
name|p2p
operator|->
name|dev_capab
operator|&=
operator|~
name|P2P_DEV_CAPAB_CLIENT_DISCOVERABILITY
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|struct
name|wpabuf
modifier|*
name|p2p_build_presence_req
parameter_list|(
name|u32
name|duration1
parameter_list|,
name|u32
name|interval1
parameter_list|,
name|u32
name|duration2
parameter_list|,
name|u32
name|interval2
parameter_list|)
block|{
name|struct
name|wpabuf
modifier|*
name|req
decl_stmt|;
name|struct
name|p2p_noa_desc
name|desc1
decl_stmt|,
name|desc2
decl_stmt|,
modifier|*
name|ptr1
init|=
name|NULL
decl_stmt|,
modifier|*
name|ptr2
init|=
name|NULL
decl_stmt|;
name|u8
modifier|*
name|len
decl_stmt|;
name|req
operator|=
name|wpabuf_alloc
argument_list|(
literal|100
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|duration1
operator|||
name|interval1
condition|)
block|{
name|os_memset
argument_list|(
operator|&
name|desc1
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|desc1
argument_list|)
argument_list|)
expr_stmt|;
name|desc1
operator|.
name|count_type
operator|=
literal|1
expr_stmt|;
name|desc1
operator|.
name|duration
operator|=
name|duration1
expr_stmt|;
name|desc1
operator|.
name|interval
operator|=
name|interval1
expr_stmt|;
name|ptr1
operator|=
operator|&
name|desc1
expr_stmt|;
if|if
condition|(
name|duration2
operator|||
name|interval2
condition|)
block|{
name|os_memset
argument_list|(
operator|&
name|desc2
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|desc2
argument_list|)
argument_list|)
expr_stmt|;
name|desc2
operator|.
name|count_type
operator|=
literal|2
expr_stmt|;
name|desc2
operator|.
name|duration
operator|=
name|duration2
expr_stmt|;
name|desc2
operator|.
name|interval
operator|=
name|interval2
expr_stmt|;
name|ptr2
operator|=
operator|&
name|desc2
expr_stmt|;
block|}
block|}
name|p2p_buf_add_action_hdr
argument_list|(
name|req
argument_list|,
name|P2P_PRESENCE_REQ
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|len
operator|=
name|p2p_buf_add_ie_hdr
argument_list|(
name|req
argument_list|)
expr_stmt|;
name|p2p_buf_add_noa
argument_list|(
name|req
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|ptr1
argument_list|,
name|ptr2
argument_list|)
expr_stmt|;
name|p2p_buf_update_ie_hdr
argument_list|(
name|req
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
name|req
return|;
block|}
end_function

begin_function
name|int
name|p2p_presence_req
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|,
specifier|const
name|u8
modifier|*
name|go_interface_addr
parameter_list|,
specifier|const
name|u8
modifier|*
name|own_interface_addr
parameter_list|,
name|unsigned
name|int
name|freq
parameter_list|,
name|u32
name|duration1
parameter_list|,
name|u32
name|interval1
parameter_list|,
name|u32
name|duration2
parameter_list|,
name|u32
name|interval2
parameter_list|)
block|{
name|struct
name|wpabuf
modifier|*
name|req
decl_stmt|;
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Send Presence Request to GO "
name|MACSTR
literal|" (own interface "
name|MACSTR
literal|") freq=%u dur1=%u int1=%u "
literal|"dur2=%u int2=%u"
argument_list|,
name|MAC2STR
argument_list|(
name|go_interface_addr
argument_list|)
argument_list|,
name|MAC2STR
argument_list|(
name|own_interface_addr
argument_list|)
argument_list|,
name|freq
argument_list|,
name|duration1
argument_list|,
name|interval1
argument_list|,
name|duration2
argument_list|,
name|interval2
argument_list|)
expr_stmt|;
name|req
operator|=
name|p2p_build_presence_req
argument_list|(
name|duration1
argument_list|,
name|interval1
argument_list|,
name|duration2
argument_list|,
name|interval2
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|p2p
operator|->
name|pending_action_state
operator|=
name|P2P_NO_PENDING_ACTION
expr_stmt|;
if|if
condition|(
name|p2p_send_action
argument_list|(
name|p2p
argument_list|,
name|freq
argument_list|,
name|go_interface_addr
argument_list|,
name|own_interface_addr
argument_list|,
name|go_interface_addr
argument_list|,
name|wpabuf_head
argument_list|(
name|req
argument_list|)
argument_list|,
name|wpabuf_len
argument_list|(
name|req
argument_list|)
argument_list|,
literal|200
argument_list|)
operator|<
literal|0
condition|)
block|{
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Failed to send Action frame"
argument_list|)
expr_stmt|;
block|}
name|wpabuf_free
argument_list|(
name|req
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|wpabuf
modifier|*
name|p2p_build_presence_resp
parameter_list|(
name|u8
name|status
parameter_list|,
specifier|const
name|u8
modifier|*
name|noa
parameter_list|,
name|size_t
name|noa_len
parameter_list|,
name|u8
name|dialog_token
parameter_list|)
block|{
name|struct
name|wpabuf
modifier|*
name|resp
decl_stmt|;
name|u8
modifier|*
name|len
decl_stmt|;
name|resp
operator|=
name|wpabuf_alloc
argument_list|(
literal|100
operator|+
name|noa_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|resp
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|p2p_buf_add_action_hdr
argument_list|(
name|resp
argument_list|,
name|P2P_PRESENCE_RESP
argument_list|,
name|dialog_token
argument_list|)
expr_stmt|;
name|len
operator|=
name|p2p_buf_add_ie_hdr
argument_list|(
name|resp
argument_list|)
expr_stmt|;
name|p2p_buf_add_status
argument_list|(
name|resp
argument_list|,
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|noa
condition|)
block|{
name|wpabuf_put_u8
argument_list|(
name|resp
argument_list|,
name|P2P_ATTR_NOTICE_OF_ABSENCE
argument_list|)
expr_stmt|;
name|wpabuf_put_le16
argument_list|(
name|resp
argument_list|,
name|noa_len
argument_list|)
expr_stmt|;
name|wpabuf_put_data
argument_list|(
name|resp
argument_list|,
name|noa
argument_list|,
name|noa_len
argument_list|)
expr_stmt|;
block|}
else|else
name|p2p_buf_add_noa
argument_list|(
name|resp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|p2p_buf_update_ie_hdr
argument_list|(
name|resp
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
name|resp
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|p2p_process_presence_req
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|,
specifier|const
name|u8
modifier|*
name|da
parameter_list|,
specifier|const
name|u8
modifier|*
name|sa
parameter_list|,
specifier|const
name|u8
modifier|*
name|data
parameter_list|,
name|size_t
name|len
parameter_list|,
name|int
name|rx_freq
parameter_list|)
block|{
name|struct
name|p2p_message
name|msg
decl_stmt|;
name|u8
name|status
decl_stmt|;
name|struct
name|wpabuf
modifier|*
name|resp
decl_stmt|;
name|size_t
name|g
decl_stmt|;
name|struct
name|p2p_group
modifier|*
name|group
init|=
name|NULL
decl_stmt|;
name|int
name|parsed
init|=
literal|0
decl_stmt|;
name|u8
name|noa
index|[
literal|50
index|]
decl_stmt|;
name|int
name|noa_len
decl_stmt|;
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Received P2P Action - P2P Presence Request"
argument_list|)
expr_stmt|;
for|for
control|(
name|g
operator|=
literal|0
init|;
name|g
operator|<
name|p2p
operator|->
name|num_groups
condition|;
name|g
operator|++
control|)
block|{
if|if
condition|(
name|os_memcmp
argument_list|(
name|da
argument_list|,
name|p2p_group_get_interface_addr
argument_list|(
name|p2p
operator|->
name|groups
index|[
name|g
index|]
argument_list|)
argument_list|,
name|ETH_ALEN
argument_list|)
operator|==
literal|0
condition|)
block|{
name|group
operator|=
name|p2p
operator|->
name|groups
index|[
name|g
index|]
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|group
operator|==
name|NULL
condition|)
block|{
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Ignore P2P Presence Request for unknown group "
name|MACSTR
argument_list|,
name|MAC2STR
argument_list|(
name|da
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|p2p_parse
argument_list|(
name|data
argument_list|,
name|len
argument_list|,
operator|&
name|msg
argument_list|)
operator|<
literal|0
condition|)
block|{
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Failed to parse P2P Presence Request"
argument_list|)
expr_stmt|;
name|status
operator|=
name|P2P_SC_FAIL_INVALID_PARAMS
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|parsed
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|msg
operator|.
name|noa
operator|==
name|NULL
condition|)
block|{
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"No NoA attribute in P2P Presence Request"
argument_list|)
expr_stmt|;
name|status
operator|=
name|P2P_SC_FAIL_INVALID_PARAMS
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|status
operator|=
name|p2p_group_presence_req
argument_list|(
name|group
argument_list|,
name|sa
argument_list|,
name|msg
operator|.
name|noa
argument_list|,
name|msg
operator|.
name|noa_len
argument_list|)
expr_stmt|;
name|fail
label|:
if|if
condition|(
name|p2p
operator|->
name|cfg
operator|->
name|get_noa
condition|)
name|noa_len
operator|=
name|p2p
operator|->
name|cfg
operator|->
name|get_noa
argument_list|(
name|p2p
operator|->
name|cfg
operator|->
name|cb_ctx
argument_list|,
name|da
argument_list|,
name|noa
argument_list|,
sizeof|sizeof
argument_list|(
name|noa
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|noa_len
operator|=
operator|-
literal|1
expr_stmt|;
name|resp
operator|=
name|p2p_build_presence_resp
argument_list|(
name|status
argument_list|,
name|noa_len
operator|>
literal|0
condition|?
name|noa
else|:
name|NULL
argument_list|,
name|noa_len
operator|>
literal|0
condition|?
name|noa_len
else|:
literal|0
argument_list|,
name|msg
operator|.
name|dialog_token
argument_list|)
expr_stmt|;
if|if
condition|(
name|parsed
condition|)
name|p2p_parse_free
argument_list|(
operator|&
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|resp
operator|==
name|NULL
condition|)
return|return;
name|p2p
operator|->
name|pending_action_state
operator|=
name|P2P_NO_PENDING_ACTION
expr_stmt|;
if|if
condition|(
name|p2p_send_action
argument_list|(
name|p2p
argument_list|,
name|rx_freq
argument_list|,
name|sa
argument_list|,
name|da
argument_list|,
name|da
argument_list|,
name|wpabuf_head
argument_list|(
name|resp
argument_list|)
argument_list|,
name|wpabuf_len
argument_list|(
name|resp
argument_list|)
argument_list|,
literal|200
argument_list|)
operator|<
literal|0
condition|)
block|{
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Failed to send Action frame"
argument_list|)
expr_stmt|;
block|}
name|wpabuf_free
argument_list|(
name|resp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|p2p_process_presence_resp
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|,
specifier|const
name|u8
modifier|*
name|da
parameter_list|,
specifier|const
name|u8
modifier|*
name|sa
parameter_list|,
specifier|const
name|u8
modifier|*
name|data
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|struct
name|p2p_message
name|msg
decl_stmt|;
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Received P2P Action - P2P Presence Response"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p2p_parse
argument_list|(
name|data
argument_list|,
name|len
argument_list|,
operator|&
name|msg
argument_list|)
operator|<
literal|0
condition|)
block|{
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Failed to parse P2P Presence Response"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|msg
operator|.
name|status
operator|==
name|NULL
operator|||
name|msg
operator|.
name|noa
operator|==
name|NULL
condition|)
block|{
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"No Status or NoA attribute in P2P Presence Response"
argument_list|)
expr_stmt|;
name|p2p_parse_free
argument_list|(
operator|&
name|msg
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|p2p
operator|->
name|cfg
operator|->
name|presence_resp
condition|)
block|{
name|p2p
operator|->
name|cfg
operator|->
name|presence_resp
argument_list|(
name|p2p
operator|->
name|cfg
operator|->
name|cb_ctx
argument_list|,
name|sa
argument_list|,
operator|*
name|msg
operator|.
name|status
argument_list|,
name|msg
operator|.
name|noa
argument_list|,
name|msg
operator|.
name|noa_len
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|msg
operator|.
name|status
condition|)
block|{
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"P2P Presence Request was rejected: status %u"
argument_list|,
operator|*
name|msg
operator|.
name|status
argument_list|)
expr_stmt|;
name|p2p_parse_free
argument_list|(
operator|&
name|msg
argument_list|)
expr_stmt|;
return|return;
block|}
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"P2P Presence Request was accepted"
argument_list|)
expr_stmt|;
name|wpa_hexdump
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"P2P: P2P Presence Response - NoA"
argument_list|,
name|msg
operator|.
name|noa
argument_list|,
name|msg
operator|.
name|noa_len
argument_list|)
expr_stmt|;
comment|/* TODO: process NoA */
name|p2p_parse_free
argument_list|(
operator|&
name|msg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|p2p_ext_listen_timeout
parameter_list|(
name|void
modifier|*
name|eloop_ctx
parameter_list|,
name|void
modifier|*
name|timeout_ctx
parameter_list|)
block|{
name|struct
name|p2p_data
modifier|*
name|p2p
init|=
name|eloop_ctx
decl_stmt|;
if|if
condition|(
name|p2p
operator|->
name|ext_listen_interval
condition|)
block|{
comment|/* Schedule next extended listen timeout */
name|eloop_register_timeout
argument_list|(
name|p2p
operator|->
name|ext_listen_interval_sec
argument_list|,
name|p2p
operator|->
name|ext_listen_interval_usec
argument_list|,
name|p2p_ext_listen_timeout
argument_list|,
name|p2p
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|p2p
operator|->
name|cfg
operator|->
name|is_p2p_in_progress
operator|&&
name|p2p
operator|->
name|cfg
operator|->
name|is_p2p_in_progress
argument_list|(
name|p2p
operator|->
name|cfg
operator|->
name|cb_ctx
argument_list|)
operator|)
operator|||
operator|(
name|p2p
operator|->
name|pending_action_state
operator|==
name|P2P_PENDING_PD
operator|&&
name|p2p
operator|->
name|pd_retries
operator|>
literal|0
operator|)
condition|)
block|{
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Operation in progress - skip Extended Listen timeout (%s)"
argument_list|,
name|p2p_state_txt
argument_list|(
name|p2p
operator|->
name|state
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|p2p
operator|->
name|state
operator|==
name|P2P_LISTEN_ONLY
operator|&&
name|p2p
operator|->
name|ext_listen_only
condition|)
block|{
comment|/* 		 * This should not really happen, but it looks like the Listen 		 * command may fail is something else (e.g., a scan) was 		 * running at an inconvenient time. As a workaround, allow new 		 * Extended Listen operation to be started. 		 */
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Previous Extended Listen operation had not been completed - try again"
argument_list|)
expr_stmt|;
name|p2p
operator|->
name|ext_listen_only
operator|=
literal|0
expr_stmt|;
name|p2p_set_state
argument_list|(
name|p2p
argument_list|,
name|P2P_IDLE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p2p
operator|->
name|state
operator|!=
name|P2P_IDLE
condition|)
block|{
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Skip Extended Listen timeout in active state (%s)"
argument_list|,
name|p2p_state_txt
argument_list|(
name|p2p
operator|->
name|state
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Extended Listen timeout"
argument_list|)
expr_stmt|;
name|p2p
operator|->
name|ext_listen_only
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|p2p_listen
argument_list|(
name|p2p
argument_list|,
name|p2p
operator|->
name|ext_listen_period
argument_list|)
operator|<
literal|0
condition|)
block|{
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Failed to start Listen state for Extended Listen Timing"
argument_list|)
expr_stmt|;
name|p2p
operator|->
name|ext_listen_only
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|p2p_ext_listen
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|,
name|unsigned
name|int
name|period
parameter_list|,
name|unsigned
name|int
name|interval
parameter_list|)
block|{
if|if
condition|(
name|period
operator|>
literal|65535
operator|||
name|interval
operator|>
literal|65535
operator|||
name|period
operator|>
name|interval
operator|||
operator|(
name|period
operator|==
literal|0
operator|&&
name|interval
operator|>
literal|0
operator|)
operator|||
operator|(
name|period
operator|>
literal|0
operator|&&
name|interval
operator|==
literal|0
operator|)
condition|)
block|{
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Invalid Extended Listen Timing request: period=%u interval=%u"
argument_list|,
name|period
argument_list|,
name|interval
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|eloop_cancel_timeout
argument_list|(
name|p2p_ext_listen_timeout
argument_list|,
name|p2p
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|interval
operator|==
literal|0
condition|)
block|{
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Disabling Extended Listen Timing"
argument_list|)
expr_stmt|;
name|p2p
operator|->
name|ext_listen_period
operator|=
literal|0
expr_stmt|;
name|p2p
operator|->
name|ext_listen_interval
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Enabling Extended Listen Timing: period %u msec, interval %u msec"
argument_list|,
name|period
argument_list|,
name|interval
argument_list|)
expr_stmt|;
name|p2p
operator|->
name|ext_listen_period
operator|=
name|period
expr_stmt|;
name|p2p
operator|->
name|ext_listen_interval
operator|=
name|interval
expr_stmt|;
name|p2p
operator|->
name|ext_listen_interval_sec
operator|=
name|interval
operator|/
literal|1000
expr_stmt|;
name|p2p
operator|->
name|ext_listen_interval_usec
operator|=
operator|(
name|interval
operator|%
literal|1000
operator|)
operator|*
literal|1000
expr_stmt|;
name|eloop_register_timeout
argument_list|(
name|p2p
operator|->
name|ext_listen_interval_sec
argument_list|,
name|p2p
operator|->
name|ext_listen_interval_usec
argument_list|,
name|p2p_ext_listen_timeout
argument_list|,
name|p2p
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|p2p_deauth_notif
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|,
specifier|const
name|u8
modifier|*
name|bssid
parameter_list|,
name|u16
name|reason_code
parameter_list|,
specifier|const
name|u8
modifier|*
name|ie
parameter_list|,
name|size_t
name|ie_len
parameter_list|)
block|{
name|struct
name|p2p_message
name|msg
decl_stmt|;
if|if
condition|(
name|bssid
operator|==
name|NULL
operator|||
name|ie
operator|==
name|NULL
condition|)
return|return;
name|os_memset
argument_list|(
operator|&
name|msg
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p2p_parse_ies
argument_list|(
name|ie
argument_list|,
name|ie_len
argument_list|,
operator|&
name|msg
argument_list|)
condition|)
return|return;
if|if
condition|(
name|msg
operator|.
name|minor_reason_code
operator|==
name|NULL
condition|)
block|{
name|p2p_parse_free
argument_list|(
operator|&
name|msg
argument_list|)
expr_stmt|;
return|return;
block|}
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Deauthentication notification BSSID "
name|MACSTR
literal|" reason_code=%u minor_reason_code=%u"
argument_list|,
name|MAC2STR
argument_list|(
name|bssid
argument_list|)
argument_list|,
name|reason_code
argument_list|,
operator|*
name|msg
operator|.
name|minor_reason_code
argument_list|)
expr_stmt|;
name|p2p_parse_free
argument_list|(
operator|&
name|msg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|p2p_disassoc_notif
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|,
specifier|const
name|u8
modifier|*
name|bssid
parameter_list|,
name|u16
name|reason_code
parameter_list|,
specifier|const
name|u8
modifier|*
name|ie
parameter_list|,
name|size_t
name|ie_len
parameter_list|)
block|{
name|struct
name|p2p_message
name|msg
decl_stmt|;
if|if
condition|(
name|bssid
operator|==
name|NULL
operator|||
name|ie
operator|==
name|NULL
condition|)
return|return;
name|os_memset
argument_list|(
operator|&
name|msg
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p2p_parse_ies
argument_list|(
name|ie
argument_list|,
name|ie_len
argument_list|,
operator|&
name|msg
argument_list|)
condition|)
return|return;
if|if
condition|(
name|msg
operator|.
name|minor_reason_code
operator|==
name|NULL
condition|)
block|{
name|p2p_parse_free
argument_list|(
operator|&
name|msg
argument_list|)
expr_stmt|;
return|return;
block|}
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Disassociation notification BSSID "
name|MACSTR
literal|" reason_code=%u minor_reason_code=%u"
argument_list|,
name|MAC2STR
argument_list|(
name|bssid
argument_list|)
argument_list|,
name|reason_code
argument_list|,
operator|*
name|msg
operator|.
name|minor_reason_code
argument_list|)
expr_stmt|;
name|p2p_parse_free
argument_list|(
operator|&
name|msg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|p2p_set_managed_oper
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|,
name|int
name|enabled
parameter_list|)
block|{
if|if
condition|(
name|enabled
condition|)
block|{
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Managed P2P Device operations enabled"
argument_list|)
expr_stmt|;
name|p2p
operator|->
name|dev_capab
operator||=
name|P2P_DEV_CAPAB_INFRA_MANAGED
expr_stmt|;
block|}
else|else
block|{
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Managed P2P Device operations disabled"
argument_list|)
expr_stmt|;
name|p2p
operator|->
name|dev_capab
operator|&=
operator|~
name|P2P_DEV_CAPAB_INFRA_MANAGED
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|p2p_config_get_random_social
parameter_list|(
name|struct
name|p2p_config
modifier|*
name|p2p
parameter_list|,
name|u8
modifier|*
name|op_class
parameter_list|,
name|u8
modifier|*
name|op_channel
parameter_list|)
block|{
return|return
name|p2p_channel_random_social
argument_list|(
operator|&
name|p2p
operator|->
name|channels
argument_list|,
name|op_class
argument_list|,
name|op_channel
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|p2p_set_listen_channel
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|,
name|u8
name|reg_class
parameter_list|,
name|u8
name|channel
parameter_list|,
name|u8
name|forced
parameter_list|)
block|{
if|if
condition|(
name|p2p_channel_to_freq
argument_list|(
name|reg_class
argument_list|,
name|channel
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
comment|/* 	 * Listen channel was set in configuration or set by control interface; 	 * cannot override it. 	 */
if|if
condition|(
name|p2p
operator|->
name|cfg
operator|->
name|channel_forced
operator|&&
name|forced
operator|==
literal|0
condition|)
block|{
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Listen channel was previously configured - do not override based on optimization"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Set Listen channel: reg_class %u channel %u"
argument_list|,
name|reg_class
argument_list|,
name|channel
argument_list|)
expr_stmt|;
if|if
condition|(
name|p2p
operator|->
name|state
operator|==
name|P2P_IDLE
condition|)
block|{
name|p2p
operator|->
name|cfg
operator|->
name|reg_class
operator|=
name|reg_class
expr_stmt|;
name|p2p
operator|->
name|cfg
operator|->
name|channel
operator|=
name|channel
expr_stmt|;
name|p2p
operator|->
name|cfg
operator|->
name|channel_forced
operator|=
name|forced
expr_stmt|;
block|}
else|else
block|{
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Defer setting listen channel"
argument_list|)
expr_stmt|;
name|p2p
operator|->
name|pending_reg_class
operator|=
name|reg_class
expr_stmt|;
name|p2p
operator|->
name|pending_channel
operator|=
name|channel
expr_stmt|;
name|p2p
operator|->
name|pending_channel_forced
operator|=
name|forced
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|u8
name|p2p_get_listen_channel
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|)
block|{
return|return
name|p2p
operator|->
name|cfg
operator|->
name|channel
return|;
block|}
end_function

begin_function
name|int
name|p2p_set_ssid_postfix
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|,
specifier|const
name|u8
modifier|*
name|postfix
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"New SSID postfix: %s"
argument_list|,
name|wpa_ssid_txt
argument_list|(
name|postfix
argument_list|,
name|len
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|postfix
operator|==
name|NULL
condition|)
block|{
name|p2p
operator|->
name|cfg
operator|->
name|ssid_postfix_len
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|len
operator|>
sizeof|sizeof
argument_list|(
name|p2p
operator|->
name|cfg
operator|->
name|ssid_postfix
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|os_memcpy
argument_list|(
name|p2p
operator|->
name|cfg
operator|->
name|ssid_postfix
argument_list|,
name|postfix
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|p2p
operator|->
name|cfg
operator|->
name|ssid_postfix_len
operator|=
name|len
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|p2p_set_oper_channel
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|,
name|u8
name|op_reg_class
parameter_list|,
name|u8
name|op_channel
parameter_list|,
name|int
name|cfg_op_channel
parameter_list|)
block|{
if|if
condition|(
name|p2p_channel_to_freq
argument_list|(
name|op_reg_class
argument_list|,
name|op_channel
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Set Operating channel: reg_class %u channel %u"
argument_list|,
name|op_reg_class
argument_list|,
name|op_channel
argument_list|)
expr_stmt|;
name|p2p
operator|->
name|cfg
operator|->
name|op_reg_class
operator|=
name|op_reg_class
expr_stmt|;
name|p2p
operator|->
name|cfg
operator|->
name|op_channel
operator|=
name|op_channel
expr_stmt|;
name|p2p
operator|->
name|cfg
operator|->
name|cfg_op_channel
operator|=
name|cfg_op_channel
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|p2p_set_pref_chan
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|,
name|unsigned
name|int
name|num_pref_chan
parameter_list|,
specifier|const
name|struct
name|p2p_channel
modifier|*
name|pref_chan
parameter_list|)
block|{
name|struct
name|p2p_channel
modifier|*
name|n
decl_stmt|;
if|if
condition|(
name|pref_chan
condition|)
block|{
name|n
operator|=
name|os_malloc
argument_list|(
name|num_pref_chan
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|p2p_channel
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|os_memcpy
argument_list|(
name|n
argument_list|,
name|pref_chan
argument_list|,
name|num_pref_chan
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|p2p_channel
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|n
operator|=
name|NULL
expr_stmt|;
name|os_free
argument_list|(
name|p2p
operator|->
name|cfg
operator|->
name|pref_chan
argument_list|)
expr_stmt|;
name|p2p
operator|->
name|cfg
operator|->
name|pref_chan
operator|=
name|n
expr_stmt|;
name|p2p
operator|->
name|cfg
operator|->
name|num_pref_chan
operator|=
name|num_pref_chan
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|p2p_set_no_go_freq
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|,
specifier|const
name|struct
name|wpa_freq_range_list
modifier|*
name|list
parameter_list|)
block|{
name|struct
name|wpa_freq_range
modifier|*
name|tmp
decl_stmt|;
if|if
condition|(
name|list
operator|==
name|NULL
operator|||
name|list
operator|->
name|num
operator|==
literal|0
condition|)
block|{
name|os_free
argument_list|(
name|p2p
operator|->
name|no_go_freq
operator|.
name|range
argument_list|)
expr_stmt|;
name|p2p
operator|->
name|no_go_freq
operator|.
name|range
operator|=
name|NULL
expr_stmt|;
name|p2p
operator|->
name|no_go_freq
operator|.
name|num
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
name|tmp
operator|=
name|os_calloc
argument_list|(
name|list
operator|->
name|num
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|wpa_freq_range
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|os_memcpy
argument_list|(
name|tmp
argument_list|,
name|list
operator|->
name|range
argument_list|,
name|list
operator|->
name|num
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|wpa_freq_range
argument_list|)
argument_list|)
expr_stmt|;
name|os_free
argument_list|(
name|p2p
operator|->
name|no_go_freq
operator|.
name|range
argument_list|)
expr_stmt|;
name|p2p
operator|->
name|no_go_freq
operator|.
name|range
operator|=
name|tmp
expr_stmt|;
name|p2p
operator|->
name|no_go_freq
operator|.
name|num
operator|=
name|list
operator|->
name|num
expr_stmt|;
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Updated no GO chan list"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|p2p_get_interface_addr
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|,
specifier|const
name|u8
modifier|*
name|dev_addr
parameter_list|,
name|u8
modifier|*
name|iface_addr
parameter_list|)
block|{
name|struct
name|p2p_device
modifier|*
name|dev
init|=
name|p2p_get_device
argument_list|(
name|p2p
argument_list|,
name|dev_addr
argument_list|)
decl_stmt|;
if|if
condition|(
name|dev
operator|==
name|NULL
operator|||
name|is_zero_ether_addr
argument_list|(
name|dev
operator|->
name|interface_addr
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|os_memcpy
argument_list|(
name|iface_addr
argument_list|,
name|dev
operator|->
name|interface_addr
argument_list|,
name|ETH_ALEN
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|p2p_get_dev_addr
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|,
specifier|const
name|u8
modifier|*
name|iface_addr
parameter_list|,
name|u8
modifier|*
name|dev_addr
parameter_list|)
block|{
name|struct
name|p2p_device
modifier|*
name|dev
init|=
name|p2p_get_device_interface
argument_list|(
name|p2p
argument_list|,
name|iface_addr
argument_list|)
decl_stmt|;
if|if
condition|(
name|dev
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|os_memcpy
argument_list|(
name|dev_addr
argument_list|,
name|dev
operator|->
name|info
operator|.
name|p2p_device_addr
argument_list|,
name|ETH_ALEN
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|p2p_set_peer_filter
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|,
specifier|const
name|u8
modifier|*
name|addr
parameter_list|)
block|{
name|os_memcpy
argument_list|(
name|p2p
operator|->
name|peer_filter
argument_list|,
name|addr
argument_list|,
name|ETH_ALEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_zero_ether_addr
argument_list|(
name|p2p
operator|->
name|peer_filter
argument_list|)
condition|)
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Disable peer filter"
argument_list|)
expr_stmt|;
else|else
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Enable peer filter for "
name|MACSTR
argument_list|,
name|MAC2STR
argument_list|(
name|p2p
operator|->
name|peer_filter
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|p2p_set_cross_connect
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|,
name|int
name|enabled
parameter_list|)
block|{
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Cross connection %s"
argument_list|,
name|enabled
condition|?
literal|"enabled"
else|:
literal|"disabled"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p2p
operator|->
name|cross_connect
operator|==
name|enabled
condition|)
return|return;
name|p2p
operator|->
name|cross_connect
operator|=
name|enabled
expr_stmt|;
comment|/* TODO: may need to tear down any action group where we are GO(?) */
block|}
end_function

begin_function
name|int
name|p2p_get_oper_freq
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|,
specifier|const
name|u8
modifier|*
name|iface_addr
parameter_list|)
block|{
name|struct
name|p2p_device
modifier|*
name|dev
init|=
name|p2p_get_device_interface
argument_list|(
name|p2p
argument_list|,
name|iface_addr
argument_list|)
decl_stmt|;
if|if
condition|(
name|dev
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|dev
operator|->
name|oper_freq
operator|<=
literal|0
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|dev
operator|->
name|oper_freq
return|;
block|}
end_function

begin_function
name|void
name|p2p_set_intra_bss_dist
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|,
name|int
name|enabled
parameter_list|)
block|{
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Intra BSS distribution %s"
argument_list|,
name|enabled
condition|?
literal|"enabled"
else|:
literal|"disabled"
argument_list|)
expr_stmt|;
name|p2p
operator|->
name|cfg
operator|->
name|p2p_intra_bss
operator|=
name|enabled
expr_stmt|;
block|}
end_function

begin_function
name|void
name|p2p_update_channel_list
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|,
specifier|const
name|struct
name|p2p_channels
modifier|*
name|chan
parameter_list|,
specifier|const
name|struct
name|p2p_channels
modifier|*
name|cli_chan
parameter_list|)
block|{
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Update channel list"
argument_list|)
expr_stmt|;
name|os_memcpy
argument_list|(
operator|&
name|p2p
operator|->
name|cfg
operator|->
name|channels
argument_list|,
name|chan
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|p2p_channels
argument_list|)
argument_list|)
expr_stmt|;
name|p2p_channels_dump
argument_list|(
name|p2p
argument_list|,
literal|"channels"
argument_list|,
operator|&
name|p2p
operator|->
name|cfg
operator|->
name|channels
argument_list|)
expr_stmt|;
name|os_memcpy
argument_list|(
operator|&
name|p2p
operator|->
name|cfg
operator|->
name|cli_channels
argument_list|,
name|cli_chan
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|p2p_channels
argument_list|)
argument_list|)
expr_stmt|;
name|p2p_channels_dump
argument_list|(
name|p2p
argument_list|,
literal|"cli_channels"
argument_list|,
operator|&
name|p2p
operator|->
name|cfg
operator|->
name|cli_channels
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|p2p_send_action
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|,
name|unsigned
name|int
name|freq
parameter_list|,
specifier|const
name|u8
modifier|*
name|dst
parameter_list|,
specifier|const
name|u8
modifier|*
name|src
parameter_list|,
specifier|const
name|u8
modifier|*
name|bssid
parameter_list|,
specifier|const
name|u8
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|,
name|unsigned
name|int
name|wait_time
parameter_list|)
block|{
if|if
condition|(
name|p2p
operator|->
name|p2p_scan_running
condition|)
block|{
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Delay Action frame TX until p2p_scan completes"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p2p
operator|->
name|after_scan_tx
condition|)
block|{
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Dropped previous pending Action frame TX"
argument_list|)
expr_stmt|;
name|os_free
argument_list|(
name|p2p
operator|->
name|after_scan_tx
argument_list|)
expr_stmt|;
block|}
name|p2p
operator|->
name|after_scan_tx
operator|=
name|os_malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|p2p
operator|->
name|after_scan_tx
argument_list|)
operator|+
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|p2p
operator|->
name|after_scan_tx
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|p2p
operator|->
name|after_scan_tx
operator|->
name|freq
operator|=
name|freq
expr_stmt|;
name|os_memcpy
argument_list|(
name|p2p
operator|->
name|after_scan_tx
operator|->
name|dst
argument_list|,
name|dst
argument_list|,
name|ETH_ALEN
argument_list|)
expr_stmt|;
name|os_memcpy
argument_list|(
name|p2p
operator|->
name|after_scan_tx
operator|->
name|src
argument_list|,
name|src
argument_list|,
name|ETH_ALEN
argument_list|)
expr_stmt|;
name|os_memcpy
argument_list|(
name|p2p
operator|->
name|after_scan_tx
operator|->
name|bssid
argument_list|,
name|bssid
argument_list|,
name|ETH_ALEN
argument_list|)
expr_stmt|;
name|p2p
operator|->
name|after_scan_tx
operator|->
name|len
operator|=
name|len
expr_stmt|;
name|p2p
operator|->
name|after_scan_tx
operator|->
name|wait_time
operator|=
name|wait_time
expr_stmt|;
name|os_memcpy
argument_list|(
name|p2p
operator|->
name|after_scan_tx
operator|+
literal|1
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|p2p
operator|->
name|cfg
operator|->
name|send_action
argument_list|(
name|p2p
operator|->
name|cfg
operator|->
name|cb_ctx
argument_list|,
name|freq
argument_list|,
name|dst
argument_list|,
name|src
argument_list|,
name|bssid
argument_list|,
name|buf
argument_list|,
name|len
argument_list|,
name|wait_time
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|p2p_set_best_channels
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|,
name|int
name|freq_24
parameter_list|,
name|int
name|freq_5
parameter_list|,
name|int
name|freq_overall
parameter_list|)
block|{
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Best channel: 2.4 GHz: %d,  5 GHz: %d,  overall: %d"
argument_list|,
name|freq_24
argument_list|,
name|freq_5
argument_list|,
name|freq_overall
argument_list|)
expr_stmt|;
name|p2p
operator|->
name|best_freq_24
operator|=
name|freq_24
expr_stmt|;
name|p2p
operator|->
name|best_freq_5
operator|=
name|freq_5
expr_stmt|;
name|p2p
operator|->
name|best_freq_overall
operator|=
name|freq_overall
expr_stmt|;
block|}
end_function

begin_function
name|void
name|p2p_set_own_freq_preference
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|,
name|int
name|freq
parameter_list|)
block|{
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Own frequency preference: %d MHz"
argument_list|,
name|freq
argument_list|)
expr_stmt|;
name|p2p
operator|->
name|own_freq_preference
operator|=
name|freq
expr_stmt|;
block|}
end_function

begin_function
specifier|const
name|u8
modifier|*
name|p2p_get_go_neg_peer
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|)
block|{
if|if
condition|(
name|p2p
operator|==
name|NULL
operator|||
name|p2p
operator|->
name|go_neg_peer
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
return|return
name|p2p
operator|->
name|go_neg_peer
operator|->
name|info
operator|.
name|p2p_device_addr
return|;
block|}
end_function

begin_function
specifier|const
name|struct
name|p2p_peer_info
modifier|*
name|p2p_get_peer_found
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|,
specifier|const
name|u8
modifier|*
name|addr
parameter_list|,
name|int
name|next
parameter_list|)
block|{
name|struct
name|p2p_device
modifier|*
name|dev
decl_stmt|;
if|if
condition|(
name|addr
condition|)
block|{
name|dev
operator|=
name|p2p_get_device
argument_list|(
name|p2p
argument_list|,
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dev
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
name|next
condition|)
block|{
if|if
condition|(
name|dev
operator|->
name|flags
operator|&
name|P2P_DEV_PROBE_REQ_ONLY
condition|)
return|return
name|NULL
return|;
return|return
operator|&
name|dev
operator|->
name|info
return|;
block|}
else|else
block|{
do|do
block|{
name|dev
operator|=
name|dl_list_first
argument_list|(
operator|&
name|dev
operator|->
name|list
argument_list|,
expr|struct
name|p2p_device
argument_list|,
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dev
operator|||
operator|&
name|dev
operator|->
name|list
operator|==
operator|&
name|p2p
operator|->
name|devices
condition|)
return|return
name|NULL
return|;
block|}
do|while
condition|(
name|dev
operator|->
name|flags
operator|&
name|P2P_DEV_PROBE_REQ_ONLY
condition|)
do|;
block|}
block|}
else|else
block|{
name|dev
operator|=
name|dl_list_first
argument_list|(
operator|&
name|p2p
operator|->
name|devices
argument_list|,
expr|struct
name|p2p_device
argument_list|,
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dev
condition|)
return|return
name|NULL
return|;
while|while
condition|(
name|dev
operator|->
name|flags
operator|&
name|P2P_DEV_PROBE_REQ_ONLY
condition|)
block|{
name|dev
operator|=
name|dl_list_first
argument_list|(
operator|&
name|dev
operator|->
name|list
argument_list|,
expr|struct
name|p2p_device
argument_list|,
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dev
operator|||
operator|&
name|dev
operator|->
name|list
operator|==
operator|&
name|p2p
operator|->
name|devices
condition|)
return|return
name|NULL
return|;
block|}
block|}
return|return
operator|&
name|dev
operator|->
name|info
return|;
block|}
end_function

begin_function
name|int
name|p2p_in_progress
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|)
block|{
if|if
condition|(
name|p2p
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|p2p
operator|->
name|state
operator|==
name|P2P_SEARCH
condition|)
return|return
literal|2
return|;
return|return
name|p2p
operator|->
name|state
operator|!=
name|P2P_IDLE
operator|&&
name|p2p
operator|->
name|state
operator|!=
name|P2P_PROVISIONING
return|;
block|}
end_function

begin_function
name|void
name|p2p_set_config_timeout
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|,
name|u8
name|go_timeout
parameter_list|,
name|u8
name|client_timeout
parameter_list|)
block|{
if|if
condition|(
name|p2p
condition|)
block|{
name|p2p
operator|->
name|go_timeout
operator|=
name|go_timeout
expr_stmt|;
name|p2p
operator|->
name|client_timeout
operator|=
name|client_timeout
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|CONFIG_WIFI_DISPLAY
end_ifdef

begin_function
specifier|static
name|void
name|p2p_update_wfd_ie_groups
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|)
block|{
name|size_t
name|g
decl_stmt|;
name|struct
name|p2p_group
modifier|*
name|group
decl_stmt|;
for|for
control|(
name|g
operator|=
literal|0
init|;
name|g
operator|<
name|p2p
operator|->
name|num_groups
condition|;
name|g
operator|++
control|)
block|{
name|group
operator|=
name|p2p
operator|->
name|groups
index|[
name|g
index|]
expr_stmt|;
name|p2p_group_force_beacon_update_ies
argument_list|(
name|group
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|p2p_set_wfd_ie_beacon
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|,
name|struct
name|wpabuf
modifier|*
name|ie
parameter_list|)
block|{
name|wpabuf_free
argument_list|(
name|p2p
operator|->
name|wfd_ie_beacon
argument_list|)
expr_stmt|;
name|p2p
operator|->
name|wfd_ie_beacon
operator|=
name|ie
expr_stmt|;
name|p2p_update_wfd_ie_groups
argument_list|(
name|p2p
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|p2p_set_wfd_ie_probe_req
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|,
name|struct
name|wpabuf
modifier|*
name|ie
parameter_list|)
block|{
name|wpabuf_free
argument_list|(
name|p2p
operator|->
name|wfd_ie_probe_req
argument_list|)
expr_stmt|;
name|p2p
operator|->
name|wfd_ie_probe_req
operator|=
name|ie
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|p2p_set_wfd_ie_probe_resp
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|,
name|struct
name|wpabuf
modifier|*
name|ie
parameter_list|)
block|{
name|wpabuf_free
argument_list|(
name|p2p
operator|->
name|wfd_ie_probe_resp
argument_list|)
expr_stmt|;
name|p2p
operator|->
name|wfd_ie_probe_resp
operator|=
name|ie
expr_stmt|;
name|p2p_update_wfd_ie_groups
argument_list|(
name|p2p
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|p2p_set_wfd_ie_assoc_req
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|,
name|struct
name|wpabuf
modifier|*
name|ie
parameter_list|)
block|{
name|wpabuf_free
argument_list|(
name|p2p
operator|->
name|wfd_ie_assoc_req
argument_list|)
expr_stmt|;
name|p2p
operator|->
name|wfd_ie_assoc_req
operator|=
name|ie
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|p2p_set_wfd_ie_invitation
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|,
name|struct
name|wpabuf
modifier|*
name|ie
parameter_list|)
block|{
name|wpabuf_free
argument_list|(
name|p2p
operator|->
name|wfd_ie_invitation
argument_list|)
expr_stmt|;
name|p2p
operator|->
name|wfd_ie_invitation
operator|=
name|ie
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|p2p_set_wfd_ie_prov_disc_req
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|,
name|struct
name|wpabuf
modifier|*
name|ie
parameter_list|)
block|{
name|wpabuf_free
argument_list|(
name|p2p
operator|->
name|wfd_ie_prov_disc_req
argument_list|)
expr_stmt|;
name|p2p
operator|->
name|wfd_ie_prov_disc_req
operator|=
name|ie
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|p2p_set_wfd_ie_prov_disc_resp
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|,
name|struct
name|wpabuf
modifier|*
name|ie
parameter_list|)
block|{
name|wpabuf_free
argument_list|(
name|p2p
operator|->
name|wfd_ie_prov_disc_resp
argument_list|)
expr_stmt|;
name|p2p
operator|->
name|wfd_ie_prov_disc_resp
operator|=
name|ie
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|p2p_set_wfd_ie_go_neg
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|,
name|struct
name|wpabuf
modifier|*
name|ie
parameter_list|)
block|{
name|wpabuf_free
argument_list|(
name|p2p
operator|->
name|wfd_ie_go_neg
argument_list|)
expr_stmt|;
name|p2p
operator|->
name|wfd_ie_go_neg
operator|=
name|ie
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|p2p_set_wfd_dev_info
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|,
specifier|const
name|struct
name|wpabuf
modifier|*
name|elem
parameter_list|)
block|{
name|wpabuf_free
argument_list|(
name|p2p
operator|->
name|wfd_dev_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|elem
condition|)
block|{
name|p2p
operator|->
name|wfd_dev_info
operator|=
name|wpabuf_dup
argument_list|(
name|elem
argument_list|)
expr_stmt|;
if|if
condition|(
name|p2p
operator|->
name|wfd_dev_info
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
block|}
else|else
name|p2p
operator|->
name|wfd_dev_info
operator|=
name|NULL
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|p2p_set_wfd_assoc_bssid
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|,
specifier|const
name|struct
name|wpabuf
modifier|*
name|elem
parameter_list|)
block|{
name|wpabuf_free
argument_list|(
name|p2p
operator|->
name|wfd_assoc_bssid
argument_list|)
expr_stmt|;
if|if
condition|(
name|elem
condition|)
block|{
name|p2p
operator|->
name|wfd_assoc_bssid
operator|=
name|wpabuf_dup
argument_list|(
name|elem
argument_list|)
expr_stmt|;
if|if
condition|(
name|p2p
operator|->
name|wfd_assoc_bssid
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
block|}
else|else
name|p2p
operator|->
name|wfd_assoc_bssid
operator|=
name|NULL
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|p2p_set_wfd_coupled_sink_info
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|,
specifier|const
name|struct
name|wpabuf
modifier|*
name|elem
parameter_list|)
block|{
name|wpabuf_free
argument_list|(
name|p2p
operator|->
name|wfd_coupled_sink_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|elem
condition|)
block|{
name|p2p
operator|->
name|wfd_coupled_sink_info
operator|=
name|wpabuf_dup
argument_list|(
name|elem
argument_list|)
expr_stmt|;
if|if
condition|(
name|p2p
operator|->
name|wfd_coupled_sink_info
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
block|}
else|else
name|p2p
operator|->
name|wfd_coupled_sink_info
operator|=
name|NULL
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CONFIG_WIFI_DISPLAY */
end_comment

begin_function
name|int
name|p2p_set_disc_int
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|,
name|int
name|min_disc_int
parameter_list|,
name|int
name|max_disc_int
parameter_list|,
name|int
name|max_disc_tu
parameter_list|)
block|{
if|if
condition|(
name|min_disc_int
operator|>
name|max_disc_int
operator|||
name|min_disc_int
operator|<
literal|0
operator|||
name|max_disc_int
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|p2p
operator|->
name|min_disc_int
operator|=
name|min_disc_int
expr_stmt|;
name|p2p
operator|->
name|max_disc_int
operator|=
name|max_disc_int
expr_stmt|;
name|p2p
operator|->
name|max_disc_tu
operator|=
name|max_disc_tu
expr_stmt|;
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Set discoverable interval: min=%d max=%d max_tu=%d"
argument_list|,
name|min_disc_int
argument_list|,
name|max_disc_int
argument_list|,
name|max_disc_tu
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|p2p_dbg
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|char
name|buf
index|[
literal|500
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|p2p
operator|->
name|cfg
operator|->
name|debug_print
condition|)
return|return;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|vsnprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|buf
index|[
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|p2p
operator|->
name|cfg
operator|->
name|debug_print
argument_list|(
name|p2p
operator|->
name|cfg
operator|->
name|cb_ctx
argument_list|,
name|MSG_DEBUG
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|p2p_info
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|char
name|buf
index|[
literal|500
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|p2p
operator|->
name|cfg
operator|->
name|debug_print
condition|)
return|return;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|vsnprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|buf
index|[
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|p2p
operator|->
name|cfg
operator|->
name|debug_print
argument_list|(
name|p2p
operator|->
name|cfg
operator|->
name|cb_ctx
argument_list|,
name|MSG_INFO
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|p2p_err
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|char
name|buf
index|[
literal|500
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|p2p
operator|->
name|cfg
operator|->
name|debug_print
condition|)
return|return;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|vsnprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|buf
index|[
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|p2p
operator|->
name|cfg
operator|->
name|debug_print
argument_list|(
name|p2p
operator|->
name|cfg
operator|->
name|cb_ctx
argument_list|,
name|MSG_ERROR
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|p2p_loop_on_known_peers
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|,
name|void
function_decl|(
modifier|*
name|peer_callback
function_decl|)
parameter_list|(
name|struct
name|p2p_peer_info
modifier|*
name|peer
parameter_list|,
name|void
modifier|*
name|user_data
parameter_list|)
parameter_list|,
name|void
modifier|*
name|user_data
parameter_list|)
block|{
name|struct
name|p2p_device
modifier|*
name|dev
decl_stmt|,
modifier|*
name|n
decl_stmt|;
name|dl_list_for_each_safe
argument_list|(
argument|dev
argument_list|,
argument|n
argument_list|,
argument|&p2p->devices
argument_list|,
argument|struct p2p_device
argument_list|,
argument|list
argument_list|)
block|{
name|peer_callback
argument_list|(
operator|&
name|dev
operator|->
name|info
argument_list|,
name|user_data
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|CONFIG_WPS_NFC
end_ifdef

begin_function
specifier|static
name|struct
name|wpabuf
modifier|*
name|p2p_build_nfc_handover
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|,
name|int
name|client_freq
parameter_list|,
specifier|const
name|u8
modifier|*
name|go_dev_addr
parameter_list|,
specifier|const
name|u8
modifier|*
name|ssid
parameter_list|,
name|size_t
name|ssid_len
parameter_list|)
block|{
name|struct
name|wpabuf
modifier|*
name|buf
decl_stmt|;
name|u8
name|op_class
decl_stmt|,
name|channel
decl_stmt|;
name|enum
name|p2p_role_indication
name|role
init|=
name|P2P_DEVICE_NOT_IN_GROUP
decl_stmt|;
name|buf
operator|=
name|wpabuf_alloc
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|op_class
operator|=
name|p2p
operator|->
name|cfg
operator|->
name|reg_class
expr_stmt|;
name|channel
operator|=
name|p2p
operator|->
name|cfg
operator|->
name|channel
expr_stmt|;
name|p2p_buf_add_capability
argument_list|(
name|buf
argument_list|,
name|p2p
operator|->
name|dev_capab
operator|&
operator|~
name|P2P_DEV_CAPAB_CLIENT_DISCOVERABILITY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|p2p_buf_add_device_info
argument_list|(
name|buf
argument_list|,
name|p2p
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|p2p
operator|->
name|num_groups
operator|>
literal|0
condition|)
block|{
name|int
name|freq
init|=
name|p2p_group_get_freq
argument_list|(
name|p2p
operator|->
name|groups
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|role
operator|=
name|P2P_GO_IN_A_GROUP
expr_stmt|;
if|if
condition|(
name|p2p_freq_to_channel
argument_list|(
name|freq
argument_list|,
operator|&
name|op_class
argument_list|,
operator|&
name|channel
argument_list|)
operator|<
literal|0
condition|)
block|{
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Unknown GO operating frequency %d MHz for NFC handover"
argument_list|,
name|freq
argument_list|)
expr_stmt|;
name|wpabuf_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|client_freq
operator|>
literal|0
condition|)
block|{
name|role
operator|=
name|P2P_CLIENT_IN_A_GROUP
expr_stmt|;
if|if
condition|(
name|p2p_freq_to_channel
argument_list|(
name|client_freq
argument_list|,
operator|&
name|op_class
argument_list|,
operator|&
name|channel
argument_list|)
operator|<
literal|0
condition|)
block|{
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Unknown client operating frequency %d MHz for NFC handover"
argument_list|,
name|client_freq
argument_list|)
expr_stmt|;
name|wpabuf_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
name|p2p_buf_add_oob_go_neg_channel
argument_list|(
name|buf
argument_list|,
name|p2p
operator|->
name|cfg
operator|->
name|country
argument_list|,
name|op_class
argument_list|,
name|channel
argument_list|,
name|role
argument_list|)
expr_stmt|;
if|if
condition|(
name|p2p
operator|->
name|num_groups
operator|>
literal|0
condition|)
block|{
comment|/* Limit number of clients to avoid very long message */
name|p2p_buf_add_group_info
argument_list|(
name|p2p
operator|->
name|groups
index|[
literal|0
index|]
argument_list|,
name|buf
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|p2p_group_buf_add_id
argument_list|(
name|p2p
operator|->
name|groups
index|[
literal|0
index|]
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|client_freq
operator|>
literal|0
operator|&&
name|go_dev_addr
operator|&&
operator|!
name|is_zero_ether_addr
argument_list|(
name|go_dev_addr
argument_list|)
operator|&&
name|ssid
operator|&&
name|ssid_len
operator|>
literal|0
condition|)
block|{
comment|/* 		 * Add the optional P2P Group ID to indicate in which group this 		 * device is a P2P Client. 		 */
name|p2p_buf_add_group_id
argument_list|(
name|buf
argument_list|,
name|go_dev_addr
argument_list|,
name|ssid
argument_list|,
name|ssid_len
argument_list|)
expr_stmt|;
block|}
return|return
name|buf
return|;
block|}
end_function

begin_function
name|struct
name|wpabuf
modifier|*
name|p2p_build_nfc_handover_req
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|,
name|int
name|client_freq
parameter_list|,
specifier|const
name|u8
modifier|*
name|go_dev_addr
parameter_list|,
specifier|const
name|u8
modifier|*
name|ssid
parameter_list|,
name|size_t
name|ssid_len
parameter_list|)
block|{
return|return
name|p2p_build_nfc_handover
argument_list|(
name|p2p
argument_list|,
name|client_freq
argument_list|,
name|go_dev_addr
argument_list|,
name|ssid
argument_list|,
name|ssid_len
argument_list|)
return|;
block|}
end_function

begin_function
name|struct
name|wpabuf
modifier|*
name|p2p_build_nfc_handover_sel
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|,
name|int
name|client_freq
parameter_list|,
specifier|const
name|u8
modifier|*
name|go_dev_addr
parameter_list|,
specifier|const
name|u8
modifier|*
name|ssid
parameter_list|,
name|size_t
name|ssid_len
parameter_list|)
block|{
return|return
name|p2p_build_nfc_handover
argument_list|(
name|p2p
argument_list|,
name|client_freq
argument_list|,
name|go_dev_addr
argument_list|,
name|ssid
argument_list|,
name|ssid_len
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|p2p_process_nfc_connection_handover
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|,
name|struct
name|p2p_nfc_params
modifier|*
name|params
parameter_list|)
block|{
name|struct
name|p2p_message
name|msg
decl_stmt|;
name|struct
name|p2p_device
modifier|*
name|dev
decl_stmt|;
specifier|const
name|u8
modifier|*
name|p2p_dev_addr
decl_stmt|;
name|int
name|freq
decl_stmt|;
name|enum
name|p2p_role_indication
name|role
decl_stmt|;
name|params
operator|->
name|next_step
operator|=
name|NO_ACTION
expr_stmt|;
if|if
condition|(
name|p2p_parse_ies_separate
argument_list|(
name|params
operator|->
name|wsc_attr
argument_list|,
name|params
operator|->
name|wsc_len
argument_list|,
name|params
operator|->
name|p2p_attr
argument_list|,
name|params
operator|->
name|p2p_len
argument_list|,
operator|&
name|msg
argument_list|)
condition|)
block|{
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Failed to parse WSC/P2P attributes from NFC"
argument_list|)
expr_stmt|;
name|p2p_parse_free
argument_list|(
operator|&
name|msg
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|msg
operator|.
name|p2p_device_addr
condition|)
name|p2p_dev_addr
operator|=
name|msg
operator|.
name|p2p_device_addr
expr_stmt|;
elseif|else
if|if
condition|(
name|msg
operator|.
name|device_id
condition|)
name|p2p_dev_addr
operator|=
name|msg
operator|.
name|device_id
expr_stmt|;
else|else
block|{
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Ignore scan data without P2P Device Info or P2P Device Id"
argument_list|)
expr_stmt|;
name|p2p_parse_free
argument_list|(
operator|&
name|msg
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|msg
operator|.
name|oob_dev_password
condition|)
block|{
name|os_memcpy
argument_list|(
name|params
operator|->
name|oob_dev_pw
argument_list|,
name|msg
operator|.
name|oob_dev_password
argument_list|,
name|msg
operator|.
name|oob_dev_password_len
argument_list|)
expr_stmt|;
name|params
operator|->
name|oob_dev_pw_len
operator|=
name|msg
operator|.
name|oob_dev_password_len
expr_stmt|;
block|}
name|dev
operator|=
name|p2p_create_device
argument_list|(
name|p2p
argument_list|,
name|p2p_dev_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|==
name|NULL
condition|)
block|{
name|p2p_parse_free
argument_list|(
operator|&
name|msg
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|params
operator|->
name|peer
operator|=
operator|&
name|dev
operator|->
name|info
expr_stmt|;
name|os_get_reltime
argument_list|(
operator|&
name|dev
operator|->
name|last_seen
argument_list|)
expr_stmt|;
name|dev
operator|->
name|flags
operator|&=
operator|~
operator|(
name|P2P_DEV_PROBE_REQ_ONLY
operator||
name|P2P_DEV_GROUP_CLIENT_ONLY
operator|)
expr_stmt|;
name|p2p_copy_wps_info
argument_list|(
name|p2p
argument_list|,
name|dev
argument_list|,
literal|0
argument_list|,
operator|&
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|msg
operator|.
name|oob_go_neg_channel
condition|)
block|{
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"OOB GO Negotiation Channel attribute not included"
argument_list|)
expr_stmt|;
name|p2p_parse_free
argument_list|(
operator|&
name|msg
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|msg
operator|.
name|oob_go_neg_channel
index|[
literal|3
index|]
operator|==
literal|0
operator|&&
name|msg
operator|.
name|oob_go_neg_channel
index|[
literal|4
index|]
operator|==
literal|0
condition|)
name|freq
operator|=
literal|0
expr_stmt|;
else|else
name|freq
operator|=
name|p2p_channel_to_freq
argument_list|(
name|msg
operator|.
name|oob_go_neg_channel
index|[
literal|3
index|]
argument_list|,
name|msg
operator|.
name|oob_go_neg_channel
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|freq
operator|<
literal|0
condition|)
block|{
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Unknown peer OOB GO Neg channel"
argument_list|)
expr_stmt|;
name|p2p_parse_free
argument_list|(
operator|&
name|msg
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|role
operator|=
name|msg
operator|.
name|oob_go_neg_channel
index|[
literal|5
index|]
expr_stmt|;
if|if
condition|(
name|role
operator|==
name|P2P_GO_IN_A_GROUP
condition|)
block|{
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Peer OOB GO operating channel: %u MHz"
argument_list|,
name|freq
argument_list|)
expr_stmt|;
name|params
operator|->
name|go_freq
operator|=
name|freq
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|role
operator|==
name|P2P_CLIENT_IN_A_GROUP
condition|)
block|{
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Peer (client) OOB GO operating channel: %u MHz"
argument_list|,
name|freq
argument_list|)
expr_stmt|;
name|params
operator|->
name|go_freq
operator|=
name|freq
expr_stmt|;
block|}
else|else
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Peer OOB GO Neg channel: %u MHz"
argument_list|,
name|freq
argument_list|)
expr_stmt|;
name|dev
operator|->
name|oob_go_neg_freq
operator|=
name|freq
expr_stmt|;
if|if
condition|(
operator|!
name|params
operator|->
name|sel
operator|&&
name|role
operator|!=
name|P2P_GO_IN_A_GROUP
condition|)
block|{
name|freq
operator|=
name|p2p_channel_to_freq
argument_list|(
name|p2p
operator|->
name|cfg
operator|->
name|reg_class
argument_list|,
name|p2p
operator|->
name|cfg
operator|->
name|channel
argument_list|)
expr_stmt|;
if|if
condition|(
name|freq
operator|<
literal|0
condition|)
block|{
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Own listen channel not known"
argument_list|)
expr_stmt|;
name|p2p_parse_free
argument_list|(
operator|&
name|msg
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Use own Listen channel as OOB GO Neg channel: %u MHz"
argument_list|,
name|freq
argument_list|)
expr_stmt|;
name|dev
operator|->
name|oob_go_neg_freq
operator|=
name|freq
expr_stmt|;
block|}
if|if
condition|(
name|msg
operator|.
name|group_id
condition|)
block|{
name|os_memcpy
argument_list|(
name|params
operator|->
name|go_dev_addr
argument_list|,
name|msg
operator|.
name|group_id
argument_list|,
name|ETH_ALEN
argument_list|)
expr_stmt|;
name|params
operator|->
name|go_ssid_len
operator|=
name|msg
operator|.
name|group_id_len
operator|-
name|ETH_ALEN
expr_stmt|;
name|os_memcpy
argument_list|(
name|params
operator|->
name|go_ssid
argument_list|,
name|msg
operator|.
name|group_id
operator|+
name|ETH_ALEN
argument_list|,
name|params
operator|->
name|go_ssid_len
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dev
operator|->
name|flags
operator|&
name|P2P_DEV_USER_REJECTED
condition|)
block|{
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Do not report rejected device"
argument_list|)
expr_stmt|;
name|p2p_parse_free
argument_list|(
operator|&
name|msg
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|dev
operator|->
name|flags
operator|&
name|P2P_DEV_REPORTED
operator|)
condition|)
block|{
name|p2p
operator|->
name|cfg
operator|->
name|dev_found
argument_list|(
name|p2p
operator|->
name|cfg
operator|->
name|cb_ctx
argument_list|,
name|p2p_dev_addr
argument_list|,
operator|&
name|dev
operator|->
name|info
argument_list|,
operator|!
operator|(
name|dev
operator|->
name|flags
operator|&
name|P2P_DEV_REPORTED_ONCE
operator|)
argument_list|)
expr_stmt|;
name|dev
operator|->
name|flags
operator||=
name|P2P_DEV_REPORTED
operator||
name|P2P_DEV_REPORTED_ONCE
expr_stmt|;
block|}
name|p2p_parse_free
argument_list|(
operator|&
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|role
operator|==
name|P2P_GO_IN_A_GROUP
operator|&&
name|p2p
operator|->
name|num_groups
operator|>
literal|0
condition|)
name|params
operator|->
name|next_step
operator|=
name|BOTH_GO
expr_stmt|;
elseif|else
if|if
condition|(
name|role
operator|==
name|P2P_GO_IN_A_GROUP
condition|)
name|params
operator|->
name|next_step
operator|=
name|JOIN_GROUP
expr_stmt|;
elseif|else
if|if
condition|(
name|role
operator|==
name|P2P_CLIENT_IN_A_GROUP
condition|)
block|{
name|dev
operator|->
name|flags
operator||=
name|P2P_DEV_GROUP_CLIENT_ONLY
expr_stmt|;
name|params
operator|->
name|next_step
operator|=
name|PEER_CLIENT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p2p
operator|->
name|num_groups
operator|>
literal|0
condition|)
name|params
operator|->
name|next_step
operator|=
name|AUTH_JOIN
expr_stmt|;
elseif|else
if|if
condition|(
name|params
operator|->
name|sel
condition|)
name|params
operator|->
name|next_step
operator|=
name|INIT_GO_NEG
expr_stmt|;
else|else
name|params
operator|->
name|next_step
operator|=
name|RESP_GO_NEG
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|p2p_set_authorized_oob_dev_pw_id
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|,
name|u16
name|dev_pw_id
parameter_list|,
name|int
name|go_intent
parameter_list|,
specifier|const
name|u8
modifier|*
name|own_interface_addr
parameter_list|)
block|{
name|p2p
operator|->
name|authorized_oob_dev_pw_id
operator|=
name|dev_pw_id
expr_stmt|;
if|if
condition|(
name|dev_pw_id
operator|==
literal|0
condition|)
block|{
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"NFC OOB Password unauthorized for static handover"
argument_list|)
expr_stmt|;
return|return;
block|}
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"NFC OOB Password (id=%u) authorized for static handover"
argument_list|,
name|dev_pw_id
argument_list|)
expr_stmt|;
name|p2p
operator|->
name|go_intent
operator|=
name|go_intent
expr_stmt|;
name|os_memcpy
argument_list|(
name|p2p
operator|->
name|intended_addr
argument_list|,
name|own_interface_addr
argument_list|,
name|ETH_ALEN
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CONFIG_WPS_NFC */
end_comment

begin_function
name|int
name|p2p_set_passphrase_len
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|,
name|unsigned
name|int
name|len
parameter_list|)
block|{
if|if
condition|(
name|len
operator|<
literal|8
operator|||
name|len
operator|>
literal|63
condition|)
return|return
operator|-
literal|1
return|;
name|p2p
operator|->
name|cfg
operator|->
name|passphrase_len
operator|=
name|len
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|p2p_set_vendor_elems
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|,
name|struct
name|wpabuf
modifier|*
modifier|*
name|vendor_elem
parameter_list|)
block|{
name|p2p
operator|->
name|vendor_elem
operator|=
name|vendor_elem
expr_stmt|;
block|}
end_function

begin_function
name|void
name|p2p_go_neg_wait_timeout
parameter_list|(
name|void
modifier|*
name|eloop_ctx
parameter_list|,
name|void
modifier|*
name|timeout_ctx
parameter_list|)
block|{
name|struct
name|p2p_data
modifier|*
name|p2p
init|=
name|eloop_ctx
decl_stmt|;
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Timeout on waiting peer to become ready for GO Negotiation"
argument_list|)
expr_stmt|;
name|p2p_go_neg_failed
argument_list|(
name|p2p
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|p2p_set_own_pref_freq_list
parameter_list|(
name|struct
name|p2p_data
modifier|*
name|p2p
parameter_list|,
specifier|const
name|unsigned
name|int
modifier|*
name|pref_freq_list
parameter_list|,
name|unsigned
name|int
name|size
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
if|if
condition|(
name|size
operator|>
name|P2P_MAX_PREF_CHANNELS
condition|)
name|size
operator|=
name|P2P_MAX_PREF_CHANNELS
expr_stmt|;
name|p2p
operator|->
name|num_pref_freq
operator|=
name|size
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
name|p2p
operator|->
name|pref_freq_list
index|[
name|i
index|]
operator|=
name|pref_freq_list
index|[
name|i
index|]
expr_stmt|;
name|p2p_dbg
argument_list|(
name|p2p
argument_list|,
literal|"Own preferred frequency list[%u]=%u MHz"
argument_list|,
name|i
argument_list|,
name|p2p
operator|->
name|pref_freq_list
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

