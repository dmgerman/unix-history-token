begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|///////////////////////////////////////////////////////////////////////////////
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|/// \file       file_io.c
end_comment

begin_comment
comment|/// \brief      File opening, unlinking, and closing
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//  Author:     Lasse Collin
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//  This file has been put into the public domain.
end_comment

begin_comment
comment|//  You can do whatever you want with this file.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|///////////////////////////////////////////////////////////////////////////////
end_comment

begin_include
include|#
directive|include
file|"private.h"
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|TUKLIB_DOSLIKE
end_ifdef

begin_include
include|#
directive|include
file|<io.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<poll.h>
end_include

begin_decl_stmt
specifier|static
name|bool
name|warn_fchown
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_FUTIMES
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_FUTIMESAT
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_UTIMES
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|HAVE_UTIME
argument_list|)
end_elif

begin_include
include|#
directive|include
file|<utime.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"tuklib_open_stdxxx.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|O_BINARY
end_ifndef

begin_define
define|#
directive|define
name|O_BINARY
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|O_NOCTTY
end_ifndef

begin_define
define|#
directive|define
name|O_NOCTTY
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_typedef
typedef|typedef
enum|enum
block|{
name|IO_WAIT_MORE
block|,
comment|// Reading or writing is possible.
name|IO_WAIT_ERROR
block|,
comment|// Error or user_abort
name|IO_WAIT_TIMEOUT
block|,
comment|// poll() timed out
block|}
name|io_wait_ret
typedef|;
end_typedef

begin_comment
comment|/// If true, try to create sparse files when decompressing.
end_comment

begin_decl_stmt
specifier|static
name|bool
name|try_sparse
init|=
name|true
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|TUKLIB_DOSLIKE
end_ifndef

begin_comment
comment|/// File status flags of standard input. This is used by io_open_src()
end_comment

begin_comment
comment|/// and io_close_src().
end_comment

begin_decl_stmt
specifier|static
name|int
name|stdin_flags
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|restore_stdin_flags
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_comment
comment|/// Original file status flags of standard output. This is used by
end_comment

begin_comment
comment|/// io_open_dest() and io_close_dest() to save and restore the flags.
end_comment

begin_decl_stmt
specifier|static
name|int
name|stdout_flags
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|restore_stdout_flags
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_comment
comment|/// Self-pipe used together with the user_abort variable to avoid
end_comment

begin_comment
comment|/// race conditions with signal handling.
end_comment

begin_decl_stmt
specifier|static
name|int
name|user_abort_pipe
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|bool
name|io_write_buf
parameter_list|(
name|file_pair
modifier|*
name|pair
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|extern
name|void
name|io_init
parameter_list|(
name|void
parameter_list|)
block|{
comment|// Make sure that stdin, stdout, and stderr are connected to
comment|// a valid file descriptor. Exit immediately with exit code ERROR
comment|// if we cannot make the file descriptors valid. Maybe we should
comment|// print an error message, but our stderr could be screwed anyway.
name|tuklib_open_stdxxx
argument_list|(
name|E_ERROR
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|TUKLIB_DOSLIKE
comment|// If fchown() fails setting the owner, we warn about it only if
comment|// we are root.
name|warn_fchown
operator|=
name|geteuid
argument_list|()
operator|==
literal|0
expr_stmt|;
if|if
condition|(
name|pipe
argument_list|(
name|user_abort_pipe
argument_list|)
operator|||
name|fcntl
argument_list|(
name|user_abort_pipe
index|[
literal|0
index|]
argument_list|,
name|F_SETFL
argument_list|,
name|O_NONBLOCK
argument_list|)
operator|==
operator|-
literal|1
operator|||
name|fcntl
argument_list|(
name|user_abort_pipe
index|[
literal|1
index|]
argument_list|,
name|F_SETFL
argument_list|,
name|O_NONBLOCK
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|message_fatal
argument_list|(
name|_
argument_list|(
literal|"Error creating a pipe: %s"
argument_list|)
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|__DJGPP__
comment|// Avoid doing useless things when statting files.
comment|// This isn't important but doesn't hurt.
name|_djstat_flags
operator|=
name|_STAT_EXEC_EXT
operator||
name|_STAT_EXEC_MAGIC
operator||
name|_STAT_DIRSIZE
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|TUKLIB_DOSLIKE
end_ifndef

begin_function
specifier|extern
name|void
name|io_write_to_user_abort_pipe
parameter_list|(
name|void
parameter_list|)
block|{
comment|// If the write() fails, it's probably due to the pipe being full.
comment|// Failing in that case is fine. If the reason is something else,
comment|// there's not much we can do since this is called in a signal
comment|// handler. So ignore the errors and try to avoid warnings with
comment|// GCC and glibc when _FORTIFY_SOURCE=2 is used.
name|uint8_t
name|b
init|=
literal|'\0'
decl_stmt|;
specifier|const
name|int
name|ret
init|=
name|write
argument_list|(
name|user_abort_pipe
index|[
literal|1
index|]
argument_list|,
operator|&
name|b
argument_list|,
literal|1
argument_list|)
decl_stmt|;
operator|(
name|void
operator|)
name|ret
expr_stmt|;
return|return;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|extern
name|void
name|io_no_sparse
parameter_list|(
name|void
parameter_list|)
block|{
name|try_sparse
operator|=
name|false
expr_stmt|;
return|return;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|TUKLIB_DOSLIKE
end_ifndef

begin_comment
comment|/// \brief      Waits for input or output to become available or for a signal
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// This uses the self-pipe trick to avoid a race condition that can occur
end_comment

begin_comment
comment|/// if a signal is caught after user_abort has been checked but before e.g.
end_comment

begin_comment
comment|/// read() has been called. In that situation read() could block unless
end_comment

begin_comment
comment|/// non-blocking I/O is used. With non-blocking I/O something like select()
end_comment

begin_comment
comment|/// or poll() is needed to avoid a busy-wait loop, and the same race condition
end_comment

begin_comment
comment|/// pops up again. There are pselect() (POSIX-1.2001) and ppoll() (not in
end_comment

begin_comment
comment|/// POSIX) but neither is portable enough in 2013. The self-pipe trick is
end_comment

begin_comment
comment|/// old and very portable.
end_comment

begin_function
specifier|static
name|io_wait_ret
name|io_wait
parameter_list|(
name|file_pair
modifier|*
name|pair
parameter_list|,
name|int
name|timeout
parameter_list|,
name|bool
name|is_reading
parameter_list|)
block|{
name|struct
name|pollfd
name|pfd
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
name|is_reading
condition|)
block|{
name|pfd
index|[
literal|0
index|]
operator|.
name|fd
operator|=
name|pair
operator|->
name|src_fd
expr_stmt|;
name|pfd
index|[
literal|0
index|]
operator|.
name|events
operator|=
name|POLLIN
expr_stmt|;
block|}
else|else
block|{
name|pfd
index|[
literal|0
index|]
operator|.
name|fd
operator|=
name|pair
operator|->
name|dest_fd
expr_stmt|;
name|pfd
index|[
literal|0
index|]
operator|.
name|events
operator|=
name|POLLOUT
expr_stmt|;
block|}
name|pfd
index|[
literal|1
index|]
operator|.
name|fd
operator|=
name|user_abort_pipe
index|[
literal|0
index|]
expr_stmt|;
name|pfd
index|[
literal|1
index|]
operator|.
name|events
operator|=
name|POLLIN
expr_stmt|;
while|while
condition|(
name|true
condition|)
block|{
specifier|const
name|int
name|ret
init|=
name|poll
argument_list|(
name|pfd
argument_list|,
literal|2
argument_list|,
name|timeout
argument_list|)
decl_stmt|;
if|if
condition|(
name|user_abort
condition|)
return|return
name|IO_WAIT_ERROR
return|;
if|if
condition|(
name|ret
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EINTR
operator|||
name|errno
operator|==
name|EAGAIN
condition|)
continue|continue;
name|message_error
argument_list|(
name|_
argument_list|(
literal|"%s: poll() failed: %s"
argument_list|)
argument_list|,
name|is_reading
condition|?
name|pair
operator|->
name|src_name
else|:
name|pair
operator|->
name|dest_name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|IO_WAIT_ERROR
return|;
block|}
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
block|{
name|assert
argument_list|(
name|opt_flush_timeout
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|flush_needed
operator|=
name|true
expr_stmt|;
return|return
name|IO_WAIT_TIMEOUT
return|;
block|}
if|if
condition|(
name|pfd
index|[
literal|0
index|]
operator|.
name|revents
operator|!=
literal|0
condition|)
return|return
name|IO_WAIT_MORE
return|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/// \brief      Unlink a file
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// This tries to verify that the file being unlinked really is the file that
end_comment

begin_comment
comment|/// we want to unlink by verifying device and inode numbers. There's still
end_comment

begin_comment
comment|/// a small unavoidable race, but this is much better than nothing (the file
end_comment

begin_comment
comment|/// could have been moved/replaced even hours earlier).
end_comment

begin_function
specifier|static
name|void
name|io_unlink
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|struct
name|stat
modifier|*
name|known_st
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|TUKLIB_DOSLIKE
argument_list|)
comment|// On DOS-like systems, st_ino is meaningless, so don't bother
comment|// testing it. Just silence a compiler warning.
operator|(
name|void
operator|)
name|known_st
expr_stmt|;
else|#
directive|else
name|struct
name|stat
name|new_st
decl_stmt|;
comment|// If --force was used, use stat() instead of lstat(). This way
comment|// (de)compressing symlinks works correctly. However, it also means
comment|// that xz cannot detect if a regular file foo is renamed to bar
comment|// and then a symlink foo -> bar is created. Because of stat()
comment|// instead of lstat(), xz will think that foo hasn't been replaced
comment|// with another file. Thus, xz will remove foo even though it no
comment|// longer is the same file that xz used when it started compressing.
comment|// Probably it's not too bad though, so this doesn't need a more
comment|// complex fix.
specifier|const
name|int
name|stat_ret
init|=
name|opt_force
condition|?
name|stat
argument_list|(
name|name
argument_list|,
operator|&
name|new_st
argument_list|)
else|:
name|lstat
argument_list|(
name|name
argument_list|,
operator|&
name|new_st
argument_list|)
decl_stmt|;
if|if
condition|(
name|stat_ret
ifdef|#
directive|ifdef
name|__VMS
comment|// st_ino is an array, and we don't want to
comment|// compare st_dev at all.
operator|||
name|memcmp
argument_list|(
operator|&
name|new_st
operator|.
name|st_ino
argument_list|,
operator|&
name|known_st
operator|->
name|st_ino
argument_list|,
sizeof|sizeof
argument_list|(
name|new_st
operator|.
name|st_ino
argument_list|)
argument_list|)
operator|!=
literal|0
else|#
directive|else
comment|// Typical POSIX-like system
operator|||
name|new_st
operator|.
name|st_dev
operator|!=
name|known_st
operator|->
name|st_dev
operator|||
name|new_st
operator|.
name|st_ino
operator|!=
name|known_st
operator|->
name|st_ino
endif|#
directive|endif
condition|)
comment|// TRANSLATORS: When compression or decompression finishes,
comment|// and xz is going to remove the source file, xz first checks
comment|// if the source file still exists, and if it does, does its
comment|// device and inode numbers match what xz saw when it opened
comment|// the source file. If these checks fail, this message is
comment|// shown, %s being the filename, and the file is not deleted.
comment|// The check for device and inode numbers is there, because
comment|// it is possible that the user has put a new file in place
comment|// of the original file, and in that case it obviously
comment|// shouldn't be removed.
name|message_error
argument_list|(
name|_
argument_list|(
literal|"%s: File seems to have been moved, "
literal|"not removing"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
elseif|else
endif|#
directive|endif
comment|// There's a race condition between lstat() and unlink()
comment|// but at least we have tried to avoid removing wrong file.
if|if
condition|(
name|unlink
argument_list|(
name|name
argument_list|)
condition|)
name|message_error
argument_list|(
name|_
argument_list|(
literal|"%s: Cannot remove: %s"
argument_list|)
argument_list|,
name|name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/// \brief      Copies owner/group and permissions
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// \todo       ACL and EA support
end_comment

begin_comment
comment|///
end_comment

begin_function
specifier|static
name|void
name|io_copy_attrs
parameter_list|(
specifier|const
name|file_pair
modifier|*
name|pair
parameter_list|)
block|{
comment|// Skip chown and chmod on Windows.
ifndef|#
directive|ifndef
name|TUKLIB_DOSLIKE
comment|// This function is more tricky than you may think at first.
comment|// Blindly copying permissions may permit users to access the
comment|// destination file who didn't have permission to access the
comment|// source file.
comment|// Try changing the owner of the file. If we aren't root or the owner
comment|// isn't already us, fchown() probably doesn't succeed. We warn
comment|// about failing fchown() only if we are root.
if|if
condition|(
name|fchown
argument_list|(
name|pair
operator|->
name|dest_fd
argument_list|,
name|pair
operator|->
name|src_st
operator|.
name|st_uid
argument_list|,
operator|-
literal|1
argument_list|)
operator|&&
name|warn_fchown
condition|)
name|message_warning
argument_list|(
name|_
argument_list|(
literal|"%s: Cannot set the file owner: %s"
argument_list|)
argument_list|,
name|pair
operator|->
name|dest_name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|mode_t
name|mode
decl_stmt|;
if|if
condition|(
name|fchown
argument_list|(
name|pair
operator|->
name|dest_fd
argument_list|,
operator|-
literal|1
argument_list|,
name|pair
operator|->
name|src_st
operator|.
name|st_gid
argument_list|)
condition|)
block|{
name|message_warning
argument_list|(
name|_
argument_list|(
literal|"%s: Cannot set the file group: %s"
argument_list|)
argument_list|,
name|pair
operator|->
name|dest_name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
comment|// We can still safely copy some additional permissions:
comment|// `group' must be at least as strict as `other' and
comment|// also vice versa.
comment|//
comment|// NOTE: After this, the owner of the source file may
comment|// get additional permissions. This shouldn't be too bad,
comment|// because the owner would have had permission to chmod
comment|// the original file anyway.
name|mode
operator|=
operator|(
operator|(
name|pair
operator|->
name|src_st
operator|.
name|st_mode
operator|&
literal|0070
operator|)
operator|>>
literal|3
operator|)
operator|&
operator|(
name|pair
operator|->
name|src_st
operator|.
name|st_mode
operator|&
literal|0007
operator|)
expr_stmt|;
name|mode
operator|=
operator|(
name|pair
operator|->
name|src_st
operator|.
name|st_mode
operator|&
literal|0700
operator|)
operator||
operator|(
name|mode
operator|<<
literal|3
operator|)
operator||
name|mode
expr_stmt|;
block|}
else|else
block|{
comment|// Drop the setuid, setgid, and sticky bits.
name|mode
operator|=
name|pair
operator|->
name|src_st
operator|.
name|st_mode
operator|&
literal|0777
expr_stmt|;
block|}
if|if
condition|(
name|fchmod
argument_list|(
name|pair
operator|->
name|dest_fd
argument_list|,
name|mode
argument_list|)
condition|)
name|message_warning
argument_list|(
name|_
argument_list|(
literal|"%s: Cannot set the file permissions: %s"
argument_list|)
argument_list|,
name|pair
operator|->
name|dest_name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|// Copy the timestamps. We have several possible ways to do this, of
comment|// which some are better in both security and precision.
comment|//
comment|// First, get the nanosecond part of the timestamps. As of writing,
comment|// it's not standardized by POSIX, and there are several names for
comment|// the same thing in struct stat.
name|long
name|atime_nsec
decl_stmt|;
name|long
name|mtime_nsec
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_STRUCT_STAT_ST_ATIM_TV_NSEC
argument_list|)
comment|// GNU and Solaris
name|atime_nsec
operator|=
name|pair
operator|->
name|src_st
operator|.
name|st_atim
operator|.
name|tv_nsec
expr_stmt|;
name|mtime_nsec
operator|=
name|pair
operator|->
name|src_st
operator|.
name|st_mtim
operator|.
name|tv_nsec
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|HAVE_STRUCT_STAT_ST_ATIMESPEC_TV_NSEC
argument_list|)
comment|// BSD
name|atime_nsec
operator|=
name|pair
operator|->
name|src_st
operator|.
name|st_atimespec
operator|.
name|tv_nsec
expr_stmt|;
name|mtime_nsec
operator|=
name|pair
operator|->
name|src_st
operator|.
name|st_mtimespec
operator|.
name|tv_nsec
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|HAVE_STRUCT_STAT_ST_ATIMENSEC
argument_list|)
comment|// GNU and BSD without extensions
name|atime_nsec
operator|=
name|pair
operator|->
name|src_st
operator|.
name|st_atimensec
expr_stmt|;
name|mtime_nsec
operator|=
name|pair
operator|->
name|src_st
operator|.
name|st_mtimensec
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|HAVE_STRUCT_STAT_ST_UATIME
argument_list|)
comment|// Tru64
name|atime_nsec
operator|=
name|pair
operator|->
name|src_st
operator|.
name|st_uatime
operator|*
literal|1000
expr_stmt|;
name|mtime_nsec
operator|=
name|pair
operator|->
name|src_st
operator|.
name|st_umtime
operator|*
literal|1000
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|HAVE_STRUCT_STAT_ST_ATIM_ST__TIM_TV_NSEC
argument_list|)
comment|// UnixWare
name|atime_nsec
operator|=
name|pair
operator|->
name|src_st
operator|.
name|st_atim
operator|.
name|st__tim
operator|.
name|tv_nsec
expr_stmt|;
name|mtime_nsec
operator|=
name|pair
operator|->
name|src_st
operator|.
name|st_mtim
operator|.
name|st__tim
operator|.
name|tv_nsec
expr_stmt|;
else|#
directive|else
comment|// Safe fallback
name|atime_nsec
operator|=
literal|0
expr_stmt|;
name|mtime_nsec
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|// Construct a structure to hold the timestamps and call appropriate
comment|// function to set the timestamps.
if|#
directive|if
name|defined
argument_list|(
name|HAVE_FUTIMENS
argument_list|)
comment|// Use nanosecond precision.
name|struct
name|timespec
name|tv
index|[
literal|2
index|]
decl_stmt|;
name|tv
index|[
literal|0
index|]
operator|.
name|tv_sec
operator|=
name|pair
operator|->
name|src_st
operator|.
name|st_atime
expr_stmt|;
name|tv
index|[
literal|0
index|]
operator|.
name|tv_nsec
operator|=
name|atime_nsec
expr_stmt|;
name|tv
index|[
literal|1
index|]
operator|.
name|tv_sec
operator|=
name|pair
operator|->
name|src_st
operator|.
name|st_mtime
expr_stmt|;
name|tv
index|[
literal|1
index|]
operator|.
name|tv_nsec
operator|=
name|mtime_nsec
expr_stmt|;
operator|(
name|void
operator|)
name|futimens
argument_list|(
name|pair
operator|->
name|dest_fd
argument_list|,
name|tv
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|HAVE_FUTIMES
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_FUTIMESAT
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_UTIMES
argument_list|)
comment|// Use microsecond precision.
name|struct
name|timeval
name|tv
index|[
literal|2
index|]
decl_stmt|;
name|tv
index|[
literal|0
index|]
operator|.
name|tv_sec
operator|=
name|pair
operator|->
name|src_st
operator|.
name|st_atime
expr_stmt|;
name|tv
index|[
literal|0
index|]
operator|.
name|tv_usec
operator|=
name|atime_nsec
operator|/
literal|1000
expr_stmt|;
name|tv
index|[
literal|1
index|]
operator|.
name|tv_sec
operator|=
name|pair
operator|->
name|src_st
operator|.
name|st_mtime
expr_stmt|;
name|tv
index|[
literal|1
index|]
operator|.
name|tv_usec
operator|=
name|mtime_nsec
operator|/
literal|1000
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_FUTIMES
argument_list|)
operator|(
name|void
operator|)
name|futimes
argument_list|(
name|pair
operator|->
name|dest_fd
argument_list|,
name|tv
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|HAVE_FUTIMESAT
argument_list|)
operator|(
name|void
operator|)
name|futimesat
argument_list|(
name|pair
operator|->
name|dest_fd
argument_list|,
name|NULL
argument_list|,
name|tv
argument_list|)
expr_stmt|;
else|#
directive|else
comment|// Argh, no function to use a file descriptor to set the timestamp.
operator|(
name|void
operator|)
name|utimes
argument_list|(
name|pair
operator|->
name|dest_name
argument_list|,
name|tv
argument_list|)
expr_stmt|;
endif|#
directive|endif
elif|#
directive|elif
name|defined
argument_list|(
name|HAVE_UTIME
argument_list|)
comment|// Use one-second precision. utime() doesn't support using file
comment|// descriptor either. Some systems have broken utime() prototype
comment|// so don't make this const.
name|struct
name|utimbuf
name|buf
init|=
block|{
operator|.
name|actime
operator|=
name|pair
operator|->
name|src_st
operator|.
name|st_atime
block|,
operator|.
name|modtime
operator|=
name|pair
operator|->
name|src_st
operator|.
name|st_mtime
block|, 	}
decl_stmt|;
comment|// Avoid warnings.
operator|(
name|void
operator|)
name|atime_nsec
expr_stmt|;
operator|(
name|void
operator|)
name|mtime_nsec
expr_stmt|;
operator|(
name|void
operator|)
name|utime
argument_list|(
name|pair
operator|->
name|dest_name
argument_list|,
operator|&
name|buf
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
end_function

begin_comment
comment|/// Opens the source file. Returns false on success, true on error.
end_comment

begin_function
specifier|static
name|bool
name|io_open_src_real
parameter_list|(
name|file_pair
modifier|*
name|pair
parameter_list|)
block|{
comment|// There's nothing to open when reading from stdin.
if|if
condition|(
name|pair
operator|->
name|src_name
operator|==
name|stdin_filename
condition|)
block|{
name|pair
operator|->
name|src_fd
operator|=
name|STDIN_FILENO
expr_stmt|;
ifdef|#
directive|ifdef
name|TUKLIB_DOSLIKE
name|setmode
argument_list|(
name|STDIN_FILENO
argument_list|,
name|O_BINARY
argument_list|)
expr_stmt|;
else|#
directive|else
comment|// Enable O_NONBLOCK for stdin.
name|stdin_flags
operator|=
name|fcntl
argument_list|(
name|STDIN_FILENO
argument_list|,
name|F_GETFL
argument_list|)
expr_stmt|;
if|if
condition|(
name|stdin_flags
operator|==
operator|-
literal|1
condition|)
block|{
name|message_error
argument_list|(
name|_
argument_list|(
literal|"Error getting the file status flags "
literal|"from standard input: %s"
argument_list|)
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
if|if
condition|(
operator|(
name|stdin_flags
operator|&
name|O_NONBLOCK
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|fcntl
argument_list|(
name|STDIN_FILENO
argument_list|,
name|F_SETFL
argument_list|,
name|stdin_flags
operator||
name|O_NONBLOCK
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|message_error
argument_list|(
name|_
argument_list|(
literal|"Error setting O_NONBLOCK "
literal|"on standard input: %s"
argument_list|)
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
name|restore_stdin_flags
operator|=
name|true
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_POSIX_FADVISE
comment|// It will fail if stdin is a pipe and that's fine.
operator|(
name|void
operator|)
name|posix_fadvise
argument_list|(
name|STDIN_FILENO
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|POSIX_FADV_SEQUENTIAL
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|false
return|;
block|}
comment|// Symlinks are not followed unless writing to stdout or --force
comment|// was used.
specifier|const
name|bool
name|follow_symlinks
init|=
name|opt_stdout
operator|||
name|opt_force
decl_stmt|;
comment|// We accept only regular files if we are writing the output
comment|// to disk too. bzip2 allows overriding this with --force but
comment|// gzip and xz don't.
specifier|const
name|bool
name|reg_files_only
init|=
operator|!
name|opt_stdout
decl_stmt|;
comment|// Flags for open()
name|int
name|flags
init|=
name|O_RDONLY
operator||
name|O_BINARY
operator||
name|O_NOCTTY
decl_stmt|;
ifndef|#
directive|ifndef
name|TUKLIB_DOSLIKE
comment|// Use non-blocking I/O:
comment|//   - It prevents blocking when opening FIFOs and some other
comment|//     special files, which is good if we want to accept only
comment|//     regular files.
comment|//   - It can help avoiding some race conditions with signal handling.
name|flags
operator||=
name|O_NONBLOCK
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|O_NOFOLLOW
argument_list|)
if|if
condition|(
operator|!
name|follow_symlinks
condition|)
name|flags
operator||=
name|O_NOFOLLOW
expr_stmt|;
elif|#
directive|elif
operator|!
name|defined
argument_list|(
name|TUKLIB_DOSLIKE
argument_list|)
comment|// Some POSIX-like systems lack O_NOFOLLOW (it's not required
comment|// by POSIX). Check for symlinks with a separate lstat() on
comment|// these systems.
if|if
condition|(
operator|!
name|follow_symlinks
condition|)
block|{
name|struct
name|stat
name|st
decl_stmt|;
if|if
condition|(
name|lstat
argument_list|(
name|pair
operator|->
name|src_name
argument_list|,
operator|&
name|st
argument_list|)
condition|)
block|{
name|message_error
argument_list|(
literal|"%s: %s"
argument_list|,
name|pair
operator|->
name|src_name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
elseif|else
if|if
condition|(
name|S_ISLNK
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|message_warning
argument_list|(
name|_
argument_list|(
literal|"%s: Is a symbolic link, "
literal|"skipping"
argument_list|)
argument_list|,
name|pair
operator|->
name|src_name
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
block|}
else|#
directive|else
comment|// Avoid warnings.
operator|(
name|void
operator|)
name|follow_symlinks
expr_stmt|;
endif|#
directive|endif
comment|// Try to open the file. Signals have been blocked so EINTR shouldn't
comment|// be possible.
name|pair
operator|->
name|src_fd
operator|=
name|open
argument_list|(
name|pair
operator|->
name|src_name
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|pair
operator|->
name|src_fd
operator|==
operator|-
literal|1
condition|)
block|{
comment|// Signals (that have a signal handler) have been blocked.
name|assert
argument_list|(
name|errno
operator|!=
name|EINTR
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|O_NOFOLLOW
comment|// Give an understandable error message if the reason
comment|// for failing was that the file was a symbolic link.
comment|//
comment|// Note that at least Linux, OpenBSD, Solaris, and Darwin
comment|// use ELOOP to indicate that O_NOFOLLOW was the reason
comment|// that open() failed. Because there may be
comment|// directories in the pathname, ELOOP may occur also
comment|// because of a symlink loop in the directory part.
comment|// So ELOOP doesn't tell us what actually went wrong,
comment|// and this stupidity went into POSIX-1.2008 too.
comment|//
comment|// FreeBSD associates EMLINK with O_NOFOLLOW and
comment|// Tru64 uses ENOTSUP. We use these directly here
comment|// and skip the lstat() call and the associated race.
comment|// I want to hear if there are other kernels that
comment|// fail with something else than ELOOP with O_NOFOLLOW.
name|bool
name|was_symlink
init|=
name|false
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__DragonFly__
argument_list|)
if|if
condition|(
name|errno
operator|==
name|EMLINK
condition|)
name|was_symlink
operator|=
name|true
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|__digital__
argument_list|)
operator|&&
name|defined
argument_list|(
name|__unix__
argument_list|)
if|if
condition|(
name|errno
operator|==
name|ENOTSUP
condition|)
name|was_symlink
operator|=
name|true
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
if|if
condition|(
name|errno
operator|==
name|EFTYPE
condition|)
name|was_symlink
operator|=
name|true
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|errno
operator|==
name|ELOOP
operator|&&
operator|!
name|follow_symlinks
condition|)
block|{
specifier|const
name|int
name|saved_errno
init|=
name|errno
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
if|if
condition|(
name|lstat
argument_list|(
name|pair
operator|->
name|src_name
argument_list|,
operator|&
name|st
argument_list|)
operator|==
literal|0
operator|&&
name|S_ISLNK
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
condition|)
name|was_symlink
operator|=
name|true
expr_stmt|;
name|errno
operator|=
name|saved_errno
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|was_symlink
condition|)
name|message_warning
argument_list|(
name|_
argument_list|(
literal|"%s: Is a symbolic link, "
literal|"skipping"
argument_list|)
argument_list|,
name|pair
operator|->
name|src_name
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
comment|// Something else than O_NOFOLLOW failing
comment|// (assuming that the race conditions didn't
comment|// confuse us).
name|message_error
argument_list|(
literal|"%s: %s"
argument_list|,
name|pair
operator|->
name|src_name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
comment|// Stat the source file. We need the result also when we copy
comment|// the permissions, and when unlinking.
comment|//
comment|// NOTE: Use stat() instead of fstat() with DJGPP, because
comment|// then we have a better chance to get st_ino value that can
comment|// be used in io_open_dest_real() to prevent overwriting the
comment|// source file.
ifdef|#
directive|ifdef
name|__DJGPP__
if|if
condition|(
name|stat
argument_list|(
name|pair
operator|->
name|src_name
argument_list|,
operator|&
name|pair
operator|->
name|src_st
argument_list|)
condition|)
goto|goto
name|error_msg
goto|;
else|#
directive|else
if|if
condition|(
name|fstat
argument_list|(
name|pair
operator|->
name|src_fd
argument_list|,
operator|&
name|pair
operator|->
name|src_st
argument_list|)
condition|)
goto|goto
name|error_msg
goto|;
endif|#
directive|endif
if|if
condition|(
name|S_ISDIR
argument_list|(
name|pair
operator|->
name|src_st
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|message_warning
argument_list|(
name|_
argument_list|(
literal|"%s: Is a directory, skipping"
argument_list|)
argument_list|,
name|pair
operator|->
name|src_name
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
if|if
condition|(
name|reg_files_only
operator|&&
operator|!
name|S_ISREG
argument_list|(
name|pair
operator|->
name|src_st
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|message_warning
argument_list|(
name|_
argument_list|(
literal|"%s: Not a regular file, skipping"
argument_list|)
argument_list|,
name|pair
operator|->
name|src_name
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
ifndef|#
directive|ifndef
name|TUKLIB_DOSLIKE
if|if
condition|(
name|reg_files_only
operator|&&
operator|!
name|opt_force
condition|)
block|{
if|if
condition|(
name|pair
operator|->
name|src_st
operator|.
name|st_mode
operator|&
operator|(
name|S_ISUID
operator||
name|S_ISGID
operator|)
condition|)
block|{
comment|// gzip rejects setuid and setgid files even
comment|// when --force was used. bzip2 doesn't check
comment|// for them, but calls fchown() after fchmod(),
comment|// and many systems automatically drop setuid
comment|// and setgid bits there.
comment|//
comment|// We accept setuid and setgid files if
comment|// --force was used. We drop these bits
comment|// explicitly in io_copy_attr().
name|message_warning
argument_list|(
name|_
argument_list|(
literal|"%s: File has setuid or "
literal|"setgid bit set, skipping"
argument_list|)
argument_list|,
name|pair
operator|->
name|src_name
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
if|if
condition|(
name|pair
operator|->
name|src_st
operator|.
name|st_mode
operator|&
name|S_ISVTX
condition|)
block|{
name|message_warning
argument_list|(
name|_
argument_list|(
literal|"%s: File has sticky bit "
literal|"set, skipping"
argument_list|)
argument_list|,
name|pair
operator|->
name|src_name
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
if|if
condition|(
name|pair
operator|->
name|src_st
operator|.
name|st_nlink
operator|>
literal|1
condition|)
block|{
name|message_warning
argument_list|(
name|_
argument_list|(
literal|"%s: Input file has more "
literal|"than one hard link, "
literal|"skipping"
argument_list|)
argument_list|,
name|pair
operator|->
name|src_name
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
block|}
comment|// If it is something else than a regular file, wait until
comment|// there is input available. This way reading from FIFOs
comment|// will work when open() is used with O_NONBLOCK.
if|if
condition|(
operator|!
name|S_ISREG
argument_list|(
name|pair
operator|->
name|src_st
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|signals_unblock
argument_list|()
expr_stmt|;
specifier|const
name|io_wait_ret
name|ret
init|=
name|io_wait
argument_list|(
name|pair
argument_list|,
operator|-
literal|1
argument_list|,
name|true
argument_list|)
decl_stmt|;
name|signals_block
argument_list|()
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|IO_WAIT_MORE
condition|)
goto|goto
name|error
goto|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_POSIX_FADVISE
comment|// It will fail with some special files like FIFOs but that is fine.
operator|(
name|void
operator|)
name|posix_fadvise
argument_list|(
name|pair
operator|->
name|src_fd
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|POSIX_FADV_SEQUENTIAL
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|false
return|;
name|error_msg
label|:
name|message_error
argument_list|(
literal|"%s: %s"
argument_list|,
name|pair
operator|->
name|src_name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|error
label|:
operator|(
name|void
operator|)
name|close
argument_list|(
name|pair
operator|->
name|src_fd
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|extern
name|file_pair
modifier|*
name|io_open_src
parameter_list|(
specifier|const
name|char
modifier|*
name|src_name
parameter_list|)
block|{
if|if
condition|(
name|is_empty_filename
argument_list|(
name|src_name
argument_list|)
condition|)
return|return
name|NULL
return|;
comment|// Since we have only one file open at a time, we can use
comment|// a statically allocated structure.
specifier|static
name|file_pair
name|pair
decl_stmt|;
name|pair
operator|=
operator|(
name|file_pair
operator|)
block|{
operator|.
name|src_name
operator|=
name|src_name
block|,
operator|.
name|dest_name
operator|=
name|NULL
block|,
operator|.
name|src_fd
operator|=
operator|-
literal|1
block|,
operator|.
name|dest_fd
operator|=
operator|-
literal|1
block|,
operator|.
name|src_eof
operator|=
name|false
block|,
operator|.
name|dest_try_sparse
operator|=
name|false
block|,
operator|.
name|dest_pending_sparse
operator|=
literal|0
block|, 	}
expr_stmt|;
comment|// Block the signals, for which we have a custom signal handler, so
comment|// that we don't need to worry about EINTR.
name|signals_block
argument_list|()
expr_stmt|;
specifier|const
name|bool
name|error
init|=
name|io_open_src_real
argument_list|(
operator|&
name|pair
argument_list|)
decl_stmt|;
name|signals_unblock
argument_list|()
expr_stmt|;
return|return
name|error
condition|?
name|NULL
else|:
operator|&
name|pair
return|;
block|}
end_function

begin_comment
comment|/// \brief      Closes source file of the file_pair structure
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// \param      pair    File whose src_fd should be closed
end_comment

begin_comment
comment|/// \param      success If true, the file will be removed from the disk if
end_comment

begin_comment
comment|///                     closing succeeds and --keep hasn't been used.
end_comment

begin_function
specifier|static
name|void
name|io_close_src
parameter_list|(
name|file_pair
modifier|*
name|pair
parameter_list|,
name|bool
name|success
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|TUKLIB_DOSLIKE
if|if
condition|(
name|restore_stdin_flags
condition|)
block|{
name|assert
argument_list|(
name|pair
operator|->
name|src_fd
operator|==
name|STDIN_FILENO
argument_list|)
expr_stmt|;
name|restore_stdin_flags
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|fcntl
argument_list|(
name|STDIN_FILENO
argument_list|,
name|F_SETFL
argument_list|,
name|stdin_flags
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|message_error
argument_list|(
name|_
argument_list|(
literal|"Error restoring the status flags "
literal|"to standard input: %s"
argument_list|)
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|pair
operator|->
name|src_fd
operator|!=
name|STDIN_FILENO
operator|&&
name|pair
operator|->
name|src_fd
operator|!=
operator|-
literal|1
condition|)
block|{
ifdef|#
directive|ifdef
name|TUKLIB_DOSLIKE
operator|(
name|void
operator|)
name|close
argument_list|(
name|pair
operator|->
name|src_fd
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|// If we are going to unlink(), do it before closing the file.
comment|// This way there's no risk that someone replaces the file and
comment|// happens to get same inode number, which would make us
comment|// unlink() wrong file.
comment|//
comment|// NOTE: DOS-like systems are an exception to this, because
comment|// they don't allow unlinking files that are open. *sigh*
if|if
condition|(
name|success
operator|&&
operator|!
name|opt_keep_original
condition|)
name|io_unlink
argument_list|(
name|pair
operator|->
name|src_name
argument_list|,
operator|&
name|pair
operator|->
name|src_st
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|TUKLIB_DOSLIKE
operator|(
name|void
operator|)
name|close
argument_list|(
name|pair
operator|->
name|src_fd
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
return|return;
block|}
end_function

begin_function
specifier|static
name|bool
name|io_open_dest_real
parameter_list|(
name|file_pair
modifier|*
name|pair
parameter_list|)
block|{
if|if
condition|(
name|opt_stdout
operator|||
name|pair
operator|->
name|src_fd
operator|==
name|STDIN_FILENO
condition|)
block|{
comment|// We don't modify or free() this.
name|pair
operator|->
name|dest_name
operator|=
operator|(
name|char
operator|*
operator|)
literal|"(stdout)"
expr_stmt|;
name|pair
operator|->
name|dest_fd
operator|=
name|STDOUT_FILENO
expr_stmt|;
ifdef|#
directive|ifdef
name|TUKLIB_DOSLIKE
name|setmode
argument_list|(
name|STDOUT_FILENO
argument_list|,
name|O_BINARY
argument_list|)
expr_stmt|;
else|#
directive|else
comment|// Set O_NONBLOCK if it isn't already set.
comment|//
comment|// NOTE: O_APPEND may be unset later in this function
comment|// and it relies on stdout_flags being set here.
name|stdout_flags
operator|=
name|fcntl
argument_list|(
name|STDOUT_FILENO
argument_list|,
name|F_GETFL
argument_list|)
expr_stmt|;
if|if
condition|(
name|stdout_flags
operator|==
operator|-
literal|1
condition|)
block|{
name|message_error
argument_list|(
name|_
argument_list|(
literal|"Error getting the file status flags "
literal|"from standard output: %s"
argument_list|)
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
if|if
condition|(
operator|(
name|stdout_flags
operator|&
name|O_NONBLOCK
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|fcntl
argument_list|(
name|STDOUT_FILENO
argument_list|,
name|F_SETFL
argument_list|,
name|stdout_flags
operator||
name|O_NONBLOCK
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|message_error
argument_list|(
name|_
argument_list|(
literal|"Error setting O_NONBLOCK "
literal|"on standard output: %s"
argument_list|)
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
name|restore_stdout_flags
operator|=
name|true
expr_stmt|;
block|}
endif|#
directive|endif
block|}
else|else
block|{
name|pair
operator|->
name|dest_name
operator|=
name|suffix_get_dest_name
argument_list|(
name|pair
operator|->
name|src_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|pair
operator|->
name|dest_name
operator|==
name|NULL
condition|)
return|return
name|true
return|;
ifdef|#
directive|ifdef
name|__DJGPP__
name|struct
name|stat
name|st
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|pair
operator|->
name|dest_name
argument_list|,
operator|&
name|st
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|// Check that it isn't a special file like "prn".
if|if
condition|(
name|st
operator|.
name|st_dev
operator|==
operator|-
literal|1
condition|)
block|{
name|message_error
argument_list|(
literal|"%s: Refusing to write to "
literal|"a DOS special file"
argument_list|,
name|pair
operator|->
name|dest_name
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
comment|// Check that we aren't overwriting the source file.
if|if
condition|(
name|st
operator|.
name|st_dev
operator|==
name|pair
operator|->
name|src_st
operator|.
name|st_dev
operator|&&
name|st
operator|.
name|st_ino
operator|==
name|pair
operator|->
name|src_st
operator|.
name|st_ino
condition|)
block|{
name|message_error
argument_list|(
literal|"%s: Output file is the same "
literal|"as the input file"
argument_list|,
name|pair
operator|->
name|dest_name
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
block|}
endif|#
directive|endif
comment|// If --force was used, unlink the target file first.
if|if
condition|(
name|opt_force
operator|&&
name|unlink
argument_list|(
name|pair
operator|->
name|dest_name
argument_list|)
operator|&&
name|errno
operator|!=
name|ENOENT
condition|)
block|{
name|message_error
argument_list|(
name|_
argument_list|(
literal|"%s: Cannot remove: %s"
argument_list|)
argument_list|,
name|pair
operator|->
name|dest_name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pair
operator|->
name|dest_name
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
comment|// Open the file.
name|int
name|flags
init|=
name|O_WRONLY
operator||
name|O_BINARY
operator||
name|O_NOCTTY
operator||
name|O_CREAT
operator||
name|O_EXCL
decl_stmt|;
ifndef|#
directive|ifndef
name|TUKLIB_DOSLIKE
name|flags
operator||=
name|O_NONBLOCK
expr_stmt|;
endif|#
directive|endif
specifier|const
name|mode_t
name|mode
init|=
name|S_IRUSR
operator||
name|S_IWUSR
decl_stmt|;
name|pair
operator|->
name|dest_fd
operator|=
name|open
argument_list|(
name|pair
operator|->
name|dest_name
argument_list|,
name|flags
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|pair
operator|->
name|dest_fd
operator|==
operator|-
literal|1
condition|)
block|{
name|message_error
argument_list|(
literal|"%s: %s"
argument_list|,
name|pair
operator|->
name|dest_name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pair
operator|->
name|dest_name
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
block|}
ifndef|#
directive|ifndef
name|TUKLIB_DOSLIKE
comment|// dest_st isn't used on DOS-like systems except as a dummy
comment|// argument to io_unlink(), so don't fstat() on such systems.
if|if
condition|(
name|fstat
argument_list|(
name|pair
operator|->
name|dest_fd
argument_list|,
operator|&
name|pair
operator|->
name|dest_st
argument_list|)
condition|)
block|{
comment|// If fstat() really fails, we have a safe fallback here.
if|#
directive|if
name|defined
argument_list|(
name|__VMS
argument_list|)
name|pair
operator|->
name|dest_st
operator|.
name|st_ino
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|pair
operator|->
name|dest_st
operator|.
name|st_ino
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|pair
operator|->
name|dest_st
operator|.
name|st_ino
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
else|#
directive|else
name|pair
operator|->
name|dest_st
operator|.
name|st_dev
operator|=
literal|0
expr_stmt|;
name|pair
operator|->
name|dest_st
operator|.
name|st_ino
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|try_sparse
operator|&&
name|opt_mode
operator|==
name|MODE_DECOMPRESS
condition|)
block|{
comment|// When writing to standard output, we need to be extra
comment|// careful:
comment|//  - It may be connected to something else than
comment|//    a regular file.
comment|//  - We aren't necessarily writing to a new empty file
comment|//    or to the end of an existing file.
comment|//  - O_APPEND may be active.
comment|//
comment|// TODO: I'm keeping this disabled for DOS-like systems
comment|// for now. FAT doesn't support sparse files, but NTFS
comment|// does, so maybe this should be enabled on Windows after
comment|// some testing.
if|if
condition|(
name|pair
operator|->
name|dest_fd
operator|==
name|STDOUT_FILENO
condition|)
block|{
if|if
condition|(
operator|!
name|S_ISREG
argument_list|(
name|pair
operator|->
name|dest_st
operator|.
name|st_mode
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|stdout_flags
operator|&
name|O_APPEND
condition|)
block|{
comment|// Creating a sparse file is not possible
comment|// when O_APPEND is active (it's used by
comment|// shell's>> redirection). As I understand
comment|// it, it is safe to temporarily disable
comment|// O_APPEND in xz, because if someone
comment|// happened to write to the same file at the
comment|// same time, results would be bad anyway
comment|// (users shouldn't assume that xz uses any
comment|// specific block size when writing data).
comment|//
comment|// The write position may be something else
comment|// than the end of the file, so we must fix
comment|// it to start writing at the end of the file
comment|// to imitate O_APPEND.
if|if
condition|(
name|lseek
argument_list|(
name|STDOUT_FILENO
argument_list|,
literal|0
argument_list|,
name|SEEK_END
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
name|false
return|;
comment|// O_NONBLOCK was set earlier in this function
comment|// so it must be kept here too. If this
comment|// fcntl() call fails, we continue but won't
comment|// try to create sparse output. The original
comment|// flags will still be restored if needed (to
comment|// unset O_NONBLOCK) when the file is finished.
if|if
condition|(
name|fcntl
argument_list|(
name|STDOUT_FILENO
argument_list|,
name|F_SETFL
argument_list|,
operator|(
name|stdout_flags
operator||
name|O_NONBLOCK
operator|)
operator|&
operator|~
name|O_APPEND
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
name|false
return|;
comment|// Disabling O_APPEND succeeded. Mark
comment|// that the flags should be restored
comment|// in io_close_dest(). This quite likely was
comment|// already set when enabling O_NONBLOCK but
comment|// just in case O_NONBLOCK was already set,
comment|// set this again here.
name|restore_stdout_flags
operator|=
name|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lseek
argument_list|(
name|STDOUT_FILENO
argument_list|,
literal|0
argument_list|,
name|SEEK_CUR
argument_list|)
operator|!=
name|pair
operator|->
name|dest_st
operator|.
name|st_size
condition|)
block|{
comment|// Writing won't start exactly at the end
comment|// of the file. We cannot use sparse output,
comment|// because it would probably corrupt the file.
return|return
name|false
return|;
block|}
block|}
name|pair
operator|->
name|dest_try_sparse
operator|=
name|true
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|false
return|;
block|}
end_function

begin_function
specifier|extern
name|bool
name|io_open_dest
parameter_list|(
name|file_pair
modifier|*
name|pair
parameter_list|)
block|{
name|signals_block
argument_list|()
expr_stmt|;
specifier|const
name|bool
name|ret
init|=
name|io_open_dest_real
argument_list|(
name|pair
argument_list|)
decl_stmt|;
name|signals_unblock
argument_list|()
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/// \brief      Closes destination file of the file_pair structure
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// \param      pair    File whose dest_fd should be closed
end_comment

begin_comment
comment|/// \param      success If false, the file will be removed from the disk.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// \return     Zero if closing succeeds. On error, -1 is returned and
end_comment

begin_comment
comment|///             error message printed.
end_comment

begin_function
specifier|static
name|bool
name|io_close_dest
parameter_list|(
name|file_pair
modifier|*
name|pair
parameter_list|,
name|bool
name|success
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|TUKLIB_DOSLIKE
comment|// If io_open_dest() has disabled O_APPEND, restore it here.
if|if
condition|(
name|restore_stdout_flags
condition|)
block|{
name|assert
argument_list|(
name|pair
operator|->
name|dest_fd
operator|==
name|STDOUT_FILENO
argument_list|)
expr_stmt|;
name|restore_stdout_flags
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|fcntl
argument_list|(
name|STDOUT_FILENO
argument_list|,
name|F_SETFL
argument_list|,
name|stdout_flags
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|message_error
argument_list|(
name|_
argument_list|(
literal|"Error restoring the O_APPEND flag "
literal|"to standard output: %s"
argument_list|)
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
name|pair
operator|->
name|dest_fd
operator|==
operator|-
literal|1
operator|||
name|pair
operator|->
name|dest_fd
operator|==
name|STDOUT_FILENO
condition|)
return|return
name|false
return|;
if|if
condition|(
name|close
argument_list|(
name|pair
operator|->
name|dest_fd
argument_list|)
condition|)
block|{
name|message_error
argument_list|(
name|_
argument_list|(
literal|"%s: Closing the file failed: %s"
argument_list|)
argument_list|,
name|pair
operator|->
name|dest_name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
comment|// Closing destination file failed, so we cannot trust its
comment|// contents. Get rid of junk:
name|io_unlink
argument_list|(
name|pair
operator|->
name|dest_name
argument_list|,
operator|&
name|pair
operator|->
name|dest_st
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pair
operator|->
name|dest_name
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
comment|// If the operation using this file wasn't successful, we git rid
comment|// of the junk file.
if|if
condition|(
operator|!
name|success
condition|)
name|io_unlink
argument_list|(
name|pair
operator|->
name|dest_name
argument_list|,
operator|&
name|pair
operator|->
name|dest_st
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pair
operator|->
name|dest_name
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_function
specifier|extern
name|void
name|io_close
parameter_list|(
name|file_pair
modifier|*
name|pair
parameter_list|,
name|bool
name|success
parameter_list|)
block|{
comment|// Take care of sparseness at the end of the output file.
if|if
condition|(
name|success
operator|&&
name|pair
operator|->
name|dest_try_sparse
operator|&&
name|pair
operator|->
name|dest_pending_sparse
operator|>
literal|0
condition|)
block|{
comment|// Seek forward one byte less than the size of the pending
comment|// hole, then write one zero-byte. This way the file grows
comment|// to its correct size. An alternative would be to use
comment|// ftruncate() but that isn't portable enough (e.g. it
comment|// doesn't work with FAT on Linux; FAT isn't that important
comment|// since it doesn't support sparse files anyway, but we don't
comment|// want to create corrupt files on it).
if|if
condition|(
name|lseek
argument_list|(
name|pair
operator|->
name|dest_fd
argument_list|,
name|pair
operator|->
name|dest_pending_sparse
operator|-
literal|1
argument_list|,
name|SEEK_CUR
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|message_error
argument_list|(
name|_
argument_list|(
literal|"%s: Seeking failed when trying "
literal|"to create a sparse file: %s"
argument_list|)
argument_list|,
name|pair
operator|->
name|dest_name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|success
operator|=
name|false
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|uint8_t
name|zero
index|[
literal|1
index|]
init|=
block|{
literal|'\0'
block|}
decl_stmt|;
if|if
condition|(
name|io_write_buf
argument_list|(
name|pair
argument_list|,
name|zero
argument_list|,
literal|1
argument_list|)
condition|)
name|success
operator|=
name|false
expr_stmt|;
block|}
block|}
name|signals_block
argument_list|()
expr_stmt|;
comment|// Copy the file attributes. We need to skip this if destination
comment|// file isn't open or it is standard output.
if|if
condition|(
name|success
operator|&&
name|pair
operator|->
name|dest_fd
operator|!=
operator|-
literal|1
operator|&&
name|pair
operator|->
name|dest_fd
operator|!=
name|STDOUT_FILENO
condition|)
name|io_copy_attrs
argument_list|(
name|pair
argument_list|)
expr_stmt|;
comment|// Close the destination first. If it fails, we must not remove
comment|// the source file!
if|if
condition|(
name|io_close_dest
argument_list|(
name|pair
argument_list|,
name|success
argument_list|)
condition|)
name|success
operator|=
name|false
expr_stmt|;
comment|// Close the source file, and unlink it if the operation using this
comment|// file pair was successful and we haven't requested to keep the
comment|// source file.
name|io_close_src
argument_list|(
name|pair
argument_list|,
name|success
argument_list|)
expr_stmt|;
name|signals_unblock
argument_list|()
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|extern
name|void
name|io_fix_src_pos
parameter_list|(
name|file_pair
modifier|*
name|pair
parameter_list|,
name|size_t
name|rewind_size
parameter_list|)
block|{
name|assert
argument_list|(
name|rewind_size
operator|<=
name|IO_BUFFER_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|rewind_size
operator|>
literal|0
condition|)
block|{
comment|// This doesn't need to work on unseekable file descriptors,
comment|// so just ignore possible errors.
operator|(
name|void
operator|)
name|lseek
argument_list|(
name|pair
operator|->
name|src_fd
argument_list|,
operator|-
call|(
name|off_t
call|)
argument_list|(
name|rewind_size
argument_list|)
argument_list|,
name|SEEK_CUR
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
specifier|extern
name|size_t
name|io_read
parameter_list|(
name|file_pair
modifier|*
name|pair
parameter_list|,
name|io_buf
modifier|*
name|buf_union
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
comment|// We use small buffers here.
name|assert
argument_list|(
name|size
operator|<
name|SSIZE_MAX
argument_list|)
expr_stmt|;
name|uint8_t
modifier|*
name|buf
init|=
name|buf_union
operator|->
name|u8
decl_stmt|;
name|size_t
name|left
init|=
name|size
decl_stmt|;
while|while
condition|(
name|left
operator|>
literal|0
condition|)
block|{
specifier|const
name|ssize_t
name|amount
init|=
name|read
argument_list|(
name|pair
operator|->
name|src_fd
argument_list|,
name|buf
argument_list|,
name|left
argument_list|)
decl_stmt|;
if|if
condition|(
name|amount
operator|==
literal|0
condition|)
block|{
name|pair
operator|->
name|src_eof
operator|=
name|true
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|amount
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EINTR
condition|)
block|{
if|if
condition|(
name|user_abort
condition|)
return|return
name|SIZE_MAX
return|;
continue|continue;
block|}
ifndef|#
directive|ifndef
name|TUKLIB_DOSLIKE
if|if
condition|(
name|errno
operator|==
name|EAGAIN
operator|||
name|errno
operator|==
name|EWOULDBLOCK
condition|)
block|{
specifier|const
name|io_wait_ret
name|ret
init|=
name|io_wait
argument_list|(
name|pair
argument_list|,
name|mytime_get_flush_timeout
argument_list|()
argument_list|,
name|true
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|ret
condition|)
block|{
case|case
name|IO_WAIT_MORE
case|:
continue|continue;
case|case
name|IO_WAIT_ERROR
case|:
return|return
name|SIZE_MAX
return|;
case|case
name|IO_WAIT_TIMEOUT
case|:
return|return
name|size
operator|-
name|left
return|;
default|default:
name|message_bug
argument_list|()
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|message_error
argument_list|(
name|_
argument_list|(
literal|"%s: Read error: %s"
argument_list|)
argument_list|,
name|pair
operator|->
name|src_name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SIZE_MAX
return|;
block|}
name|buf
operator|+=
call|(
name|size_t
call|)
argument_list|(
name|amount
argument_list|)
expr_stmt|;
name|left
operator|-=
call|(
name|size_t
call|)
argument_list|(
name|amount
argument_list|)
expr_stmt|;
block|}
return|return
name|size
operator|-
name|left
return|;
block|}
end_function

begin_function
specifier|extern
name|bool
name|io_pread
parameter_list|(
name|file_pair
modifier|*
name|pair
parameter_list|,
name|io_buf
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|,
name|off_t
name|pos
parameter_list|)
block|{
comment|// Using lseek() and read() is more portable than pread() and
comment|// for us it is as good as real pread().
if|if
condition|(
name|lseek
argument_list|(
name|pair
operator|->
name|src_fd
argument_list|,
name|pos
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
name|pos
condition|)
block|{
name|message_error
argument_list|(
name|_
argument_list|(
literal|"%s: Error seeking the file: %s"
argument_list|)
argument_list|,
name|pair
operator|->
name|src_name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
specifier|const
name|size_t
name|amount
init|=
name|io_read
argument_list|(
name|pair
argument_list|,
name|buf
argument_list|,
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
name|amount
operator|==
name|SIZE_MAX
condition|)
return|return
name|true
return|;
if|if
condition|(
name|amount
operator|!=
name|size
condition|)
block|{
name|message_error
argument_list|(
name|_
argument_list|(
literal|"%s: Unexpected end of file"
argument_list|)
argument_list|,
name|pair
operator|->
name|src_name
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|is_sparse
parameter_list|(
specifier|const
name|io_buf
modifier|*
name|buf
parameter_list|)
block|{
name|assert
argument_list|(
name|IO_BUFFER_SIZE
operator|%
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|buf
operator|->
name|u64
argument_list|)
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|buf
operator|->
name|u64
index|[
name|i
index|]
operator|!=
literal|0
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|io_write_buf
parameter_list|(
name|file_pair
modifier|*
name|pair
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|assert
argument_list|(
name|size
operator|<
name|SSIZE_MAX
argument_list|)
expr_stmt|;
while|while
condition|(
name|size
operator|>
literal|0
condition|)
block|{
specifier|const
name|ssize_t
name|amount
init|=
name|write
argument_list|(
name|pair
operator|->
name|dest_fd
argument_list|,
name|buf
argument_list|,
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
name|amount
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EINTR
condition|)
block|{
if|if
condition|(
name|user_abort
condition|)
return|return
name|true
return|;
continue|continue;
block|}
ifndef|#
directive|ifndef
name|TUKLIB_DOSLIKE
if|if
condition|(
name|errno
operator|==
name|EAGAIN
operator|||
name|errno
operator|==
name|EWOULDBLOCK
condition|)
block|{
if|if
condition|(
name|io_wait
argument_list|(
name|pair
argument_list|,
operator|-
literal|1
argument_list|,
name|false
argument_list|)
operator|==
name|IO_WAIT_MORE
condition|)
continue|continue;
return|return
name|true
return|;
block|}
endif|#
directive|endif
comment|// Handle broken pipe specially. gzip and bzip2
comment|// don't print anything on SIGPIPE. In addition,
comment|// gzip --quiet uses exit status 2 (warning) on
comment|// broken pipe instead of whatever raise(SIGPIPE)
comment|// would make it return. It is there to hide "Broken
comment|// pipe" message on some old shells (probably old
comment|// GNU bash).
comment|//
comment|// We don't do anything special with --quiet, which
comment|// is what bzip2 does too. If we get SIGPIPE, we
comment|// will handle it like other signals by setting
comment|// user_abort, and get EPIPE here.
if|if
condition|(
name|errno
operator|!=
name|EPIPE
condition|)
name|message_error
argument_list|(
name|_
argument_list|(
literal|"%s: Write error: %s"
argument_list|)
argument_list|,
name|pair
operator|->
name|dest_name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
name|buf
operator|+=
call|(
name|size_t
call|)
argument_list|(
name|amount
argument_list|)
expr_stmt|;
name|size
operator|-=
call|(
name|size_t
call|)
argument_list|(
name|amount
argument_list|)
expr_stmt|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_function
specifier|extern
name|bool
name|io_write
parameter_list|(
name|file_pair
modifier|*
name|pair
parameter_list|,
specifier|const
name|io_buf
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|assert
argument_list|(
name|size
operator|<=
name|IO_BUFFER_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|pair
operator|->
name|dest_try_sparse
condition|)
block|{
comment|// Check if the block is sparse (contains only zeros). If it
comment|// sparse, we just store the amount and return. We will take
comment|// care of actually skipping over the hole when we hit the
comment|// next data block or close the file.
comment|//
comment|// Since io_close() requires that dest_pending_sparse> 0
comment|// if the file ends with sparse block, we must also return
comment|// if size == 0 to avoid doing the lseek().
if|if
condition|(
name|size
operator|==
name|IO_BUFFER_SIZE
condition|)
block|{
if|if
condition|(
name|is_sparse
argument_list|(
name|buf
argument_list|)
condition|)
block|{
name|pair
operator|->
name|dest_pending_sparse
operator|+=
name|size
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|size
operator|==
literal|0
condition|)
block|{
return|return
name|false
return|;
block|}
comment|// This is not a sparse block. If we have a pending hole,
comment|// skip it now.
if|if
condition|(
name|pair
operator|->
name|dest_pending_sparse
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|lseek
argument_list|(
name|pair
operator|->
name|dest_fd
argument_list|,
name|pair
operator|->
name|dest_pending_sparse
argument_list|,
name|SEEK_CUR
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|message_error
argument_list|(
name|_
argument_list|(
literal|"%s: Seeking failed when "
literal|"trying to create a sparse "
literal|"file: %s"
argument_list|)
argument_list|,
name|pair
operator|->
name|dest_name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
name|pair
operator|->
name|dest_pending_sparse
operator|=
literal|0
expr_stmt|;
block|}
block|}
return|return
name|io_write_buf
argument_list|(
name|pair
argument_list|,
name|buf
operator|->
name|u8
argument_list|,
name|size
argument_list|)
return|;
block|}
end_function

end_unit

