begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|///////////////////////////////////////////////////////////////////////////////
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|/// \file       list.c
end_comment

begin_comment
comment|/// \brief      Listing information about .xz files
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//  Author:     Lasse Collin
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//  This file has been put into the public domain.
end_comment

begin_comment
comment|//  You can do whatever you want with this file.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|///////////////////////////////////////////////////////////////////////////////
end_comment

begin_include
include|#
directive|include
file|"private.h"
end_include

begin_include
include|#
directive|include
file|"tuklib_integer.h"
end_include

begin_comment
comment|/// Information about a .xz file
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
comment|/// Combined Index of all Streams in the file
name|lzma_index
modifier|*
name|idx
decl_stmt|;
comment|/// Total amount of Stream Padding
name|uint64_t
name|stream_padding
decl_stmt|;
comment|/// Highest memory usage so far
name|uint64_t
name|memusage_max
decl_stmt|;
comment|/// True if all Blocks so far have Compressed Size and
comment|/// Uncompressed Size fields
name|bool
name|all_have_sizes
decl_stmt|;
block|}
name|xz_file_info
typedef|;
end_typedef

begin_define
define|#
directive|define
name|XZ_FILE_INFO_INIT
value|{ NULL, 0, 0, true }
end_define

begin_comment
comment|/// Information about a .xz Block
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
comment|/// Size of the Block Header
name|uint32_t
name|header_size
decl_stmt|;
comment|/// A few of the Block Flags as a string
name|char
name|flags
index|[
literal|3
index|]
decl_stmt|;
comment|/// Size of the Compressed Data field in the Block
name|lzma_vli
name|compressed_size
decl_stmt|;
comment|/// Decoder memory usage for this Block
name|uint64_t
name|memusage
decl_stmt|;
comment|/// The filter chain of this Block in human-readable form
name|char
name|filter_chain
index|[
name|FILTERS_STR_SIZE
index|]
decl_stmt|;
block|}
name|block_header_info
typedef|;
end_typedef

begin_comment
comment|/// Check ID to string mapping
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
name|check_names
index|[
name|LZMA_CHECK_ID_MAX
operator|+
literal|1
index|]
index|[
literal|12
index|]
init|=
block|{
comment|// TRANSLATORS: Indicates that there is no integrity check.
comment|// This string is used in tables, so the width must not
comment|// exceed ten columns with a fixed-width font.
name|N_
argument_list|(
literal|"None"
argument_list|)
block|,
literal|"CRC32"
block|,
comment|// TRANSLATORS: Indicates that integrity check name is not known,
comment|// but the Check ID is known (here 2). This and other "Unknown-N"
comment|// strings are used in tables, so the width must not exceed ten
comment|// columns with a fixed-width font. It's OK to omit the dash if
comment|// you need space for one extra letter, but don't use spaces.
name|N_
argument_list|(
literal|"Unknown-2"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Unknown-3"
argument_list|)
block|,
literal|"CRC64"
block|,
name|N_
argument_list|(
literal|"Unknown-5"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Unknown-6"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Unknown-7"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Unknown-8"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Unknown-9"
argument_list|)
block|,
literal|"SHA-256"
block|,
name|N_
argument_list|(
literal|"Unknown-11"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Unknown-12"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Unknown-13"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Unknown-14"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Unknown-15"
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/// Buffer size for get_check_names(). This may be a bit ridiculous,
end_comment

begin_comment
comment|/// but at least it's enough if some language needs many multibyte chars.
end_comment

begin_define
define|#
directive|define
name|CHECKS_STR_SIZE
value|1024
end_define

begin_comment
comment|/// Value of the Check field as hexadecimal string.
end_comment

begin_comment
comment|/// This is set by parse_check_value().
end_comment

begin_decl_stmt
specifier|static
name|char
name|check_value
index|[
literal|2
operator|*
name|LZMA_CHECK_SIZE_MAX
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/// Totals that are displayed if there was more than one file.
end_comment

begin_comment
comment|/// The "files" counter is also used in print_info_adv() to show
end_comment

begin_comment
comment|/// the file number.
end_comment

begin_struct
specifier|static
struct|struct
block|{
name|uint64_t
name|files
decl_stmt|;
name|uint64_t
name|streams
decl_stmt|;
name|uint64_t
name|blocks
decl_stmt|;
name|uint64_t
name|compressed_size
decl_stmt|;
name|uint64_t
name|uncompressed_size
decl_stmt|;
name|uint64_t
name|stream_padding
decl_stmt|;
name|uint64_t
name|memusage_max
decl_stmt|;
name|uint32_t
name|checks
decl_stmt|;
name|bool
name|all_have_sizes
decl_stmt|;
block|}
name|totals
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|true
block|}
struct|;
end_struct

begin_comment
comment|/// \brief      Parse the Index(es) from the given .xz file
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// \param      xfi     Pointer to structure where the decoded information
end_comment

begin_comment
comment|///                     is stored.
end_comment

begin_comment
comment|/// \param      pair    Input file
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// \return     On success, false is returned. On error, true is returned.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|// TODO: This function is pretty big. liblzma should have a function that
end_comment

begin_comment
comment|// takes a callback function to parse the Index(es) from a .xz file to make
end_comment

begin_comment
comment|// it easy for applications.
end_comment

begin_function
specifier|static
name|bool
name|parse_indexes
parameter_list|(
name|xz_file_info
modifier|*
name|xfi
parameter_list|,
name|file_pair
modifier|*
name|pair
parameter_list|)
block|{
if|if
condition|(
name|pair
operator|->
name|src_st
operator|.
name|st_size
operator|<=
literal|0
condition|)
block|{
name|message_error
argument_list|(
name|_
argument_list|(
literal|"%s: File is empty"
argument_list|)
argument_list|,
name|pair
operator|->
name|src_name
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
if|if
condition|(
name|pair
operator|->
name|src_st
operator|.
name|st_size
operator|<
literal|2
operator|*
name|LZMA_STREAM_HEADER_SIZE
condition|)
block|{
name|message_error
argument_list|(
name|_
argument_list|(
literal|"%s: Too small to be a valid .xz file"
argument_list|)
argument_list|,
name|pair
operator|->
name|src_name
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
name|io_buf
name|buf
decl_stmt|;
name|lzma_stream_flags
name|header_flags
decl_stmt|;
name|lzma_stream_flags
name|footer_flags
decl_stmt|;
name|lzma_ret
name|ret
decl_stmt|;
comment|// lzma_stream for the Index decoder
name|lzma_stream
name|strm
init|=
name|LZMA_STREAM_INIT
decl_stmt|;
comment|// All Indexes decoded so far
name|lzma_index
modifier|*
name|combined_index
init|=
name|NULL
decl_stmt|;
comment|// The Index currently being decoded
name|lzma_index
modifier|*
name|this_index
init|=
name|NULL
decl_stmt|;
comment|// Current position in the file. We parse the file backwards so
comment|// initialize it to point to the end of the file.
name|off_t
name|pos
init|=
name|pair
operator|->
name|src_st
operator|.
name|st_size
decl_stmt|;
comment|// Each loop iteration decodes one Index.
do|do
block|{
comment|// Check that there is enough data left to contain at least
comment|// the Stream Header and Stream Footer. This check cannot
comment|// fail in the first pass of this loop.
if|if
condition|(
name|pos
operator|<
literal|2
operator|*
name|LZMA_STREAM_HEADER_SIZE
condition|)
block|{
name|message_error
argument_list|(
literal|"%s: %s"
argument_list|,
name|pair
operator|->
name|src_name
argument_list|,
name|message_strm
argument_list|(
name|LZMA_DATA_ERROR
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|pos
operator|-=
name|LZMA_STREAM_HEADER_SIZE
expr_stmt|;
name|lzma_vli
name|stream_padding
init|=
literal|0
decl_stmt|;
comment|// Locate the Stream Footer. There may be Stream Padding which
comment|// we must skip when reading backwards.
while|while
condition|(
name|true
condition|)
block|{
if|if
condition|(
name|pos
operator|<
name|LZMA_STREAM_HEADER_SIZE
condition|)
block|{
name|message_error
argument_list|(
literal|"%s: %s"
argument_list|,
name|pair
operator|->
name|src_name
argument_list|,
name|message_strm
argument_list|(
name|LZMA_DATA_ERROR
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
if|if
condition|(
name|io_pread
argument_list|(
name|pair
argument_list|,
operator|&
name|buf
argument_list|,
name|LZMA_STREAM_HEADER_SIZE
argument_list|,
name|pos
argument_list|)
condition|)
goto|goto
name|error
goto|;
comment|// Stream Padding is always a multiple of four bytes.
name|int
name|i
init|=
literal|2
decl_stmt|;
if|if
condition|(
name|buf
operator|.
name|u32
index|[
name|i
index|]
operator|!=
literal|0
condition|)
break|break;
comment|// To avoid calling io_pread() for every four bytes
comment|// of Stream Padding, take advantage that we read
comment|// 12 bytes (LZMA_STREAM_HEADER_SIZE) already and
comment|// check them too before calling io_pread() again.
do|do
block|{
name|stream_padding
operator|+=
literal|4
expr_stmt|;
name|pos
operator|-=
literal|4
expr_stmt|;
operator|--
name|i
expr_stmt|;
block|}
do|while
condition|(
name|i
operator|>=
literal|0
operator|&&
name|buf
operator|.
name|u32
index|[
name|i
index|]
operator|==
literal|0
condition|)
do|;
block|}
comment|// Decode the Stream Footer.
name|ret
operator|=
name|lzma_stream_footer_decode
argument_list|(
operator|&
name|footer_flags
argument_list|,
name|buf
operator|.
name|u8
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|LZMA_OK
condition|)
block|{
name|message_error
argument_list|(
literal|"%s: %s"
argument_list|,
name|pair
operator|->
name|src_name
argument_list|,
name|message_strm
argument_list|(
name|ret
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
comment|// Check that the Stream Footer doesn't specify something
comment|// that we don't support. This can only happen if the xz
comment|// version is older than liblzma and liblzma supports
comment|// something new.
comment|//
comment|// It is enough to check Stream Footer. Stream Header must
comment|// match when it is compared against Stream Footer with
comment|// lzma_stream_flags_compare().
if|if
condition|(
name|footer_flags
operator|.
name|version
operator|!=
literal|0
condition|)
block|{
name|message_error
argument_list|(
literal|"%s: %s"
argument_list|,
name|pair
operator|->
name|src_name
argument_list|,
name|message_strm
argument_list|(
name|LZMA_OPTIONS_ERROR
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
comment|// Check that the size of the Index field looks sane.
name|lzma_vli
name|index_size
init|=
name|footer_flags
operator|.
name|backward_size
decl_stmt|;
if|if
condition|(
call|(
name|lzma_vli
call|)
argument_list|(
name|pos
argument_list|)
operator|<
name|index_size
operator|+
name|LZMA_STREAM_HEADER_SIZE
condition|)
block|{
name|message_error
argument_list|(
literal|"%s: %s"
argument_list|,
name|pair
operator|->
name|src_name
argument_list|,
name|message_strm
argument_list|(
name|LZMA_DATA_ERROR
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
comment|// Set pos to the beginning of the Index.
name|pos
operator|-=
name|index_size
expr_stmt|;
comment|// See how much memory we can use for decoding this Index.
name|uint64_t
name|memlimit
init|=
name|hardware_memlimit_get
argument_list|(
name|MODE_LIST
argument_list|)
decl_stmt|;
name|uint64_t
name|memused
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|combined_index
operator|!=
name|NULL
condition|)
block|{
name|memused
operator|=
name|lzma_index_memused
argument_list|(
name|combined_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|memused
operator|>
name|memlimit
condition|)
name|message_bug
argument_list|()
expr_stmt|;
name|memlimit
operator|-=
name|memused
expr_stmt|;
block|}
comment|// Decode the Index.
name|ret
operator|=
name|lzma_index_decoder
argument_list|(
operator|&
name|strm
argument_list|,
operator|&
name|this_index
argument_list|,
name|memlimit
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|LZMA_OK
condition|)
block|{
name|message_error
argument_list|(
literal|"%s: %s"
argument_list|,
name|pair
operator|->
name|src_name
argument_list|,
name|message_strm
argument_list|(
name|ret
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
do|do
block|{
comment|// Don't give the decoder more input than the
comment|// Index size.
name|strm
operator|.
name|avail_in
operator|=
name|my_min
argument_list|(
name|IO_BUFFER_SIZE
argument_list|,
name|index_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|io_pread
argument_list|(
name|pair
argument_list|,
operator|&
name|buf
argument_list|,
name|strm
operator|.
name|avail_in
argument_list|,
name|pos
argument_list|)
condition|)
goto|goto
name|error
goto|;
name|pos
operator|+=
name|strm
operator|.
name|avail_in
expr_stmt|;
name|index_size
operator|-=
name|strm
operator|.
name|avail_in
expr_stmt|;
name|strm
operator|.
name|next_in
operator|=
name|buf
operator|.
name|u8
expr_stmt|;
name|ret
operator|=
name|lzma_code
argument_list|(
operator|&
name|strm
argument_list|,
name|LZMA_RUN
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|ret
operator|==
name|LZMA_OK
condition|)
do|;
comment|// If the decoding seems to be successful, check also that
comment|// the Index decoder consumed as much input as indicated
comment|// by the Backward Size field.
if|if
condition|(
name|ret
operator|==
name|LZMA_STREAM_END
condition|)
if|if
condition|(
name|index_size
operator|!=
literal|0
operator|||
name|strm
operator|.
name|avail_in
operator|!=
literal|0
condition|)
name|ret
operator|=
name|LZMA_DATA_ERROR
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|LZMA_STREAM_END
condition|)
block|{
comment|// LZMA_BUFFER_ERROR means that the Index decoder
comment|// would have liked more input than what the Index
comment|// size should be according to Stream Footer.
comment|// The message for LZMA_DATA_ERROR makes more
comment|// sense in that case.
if|if
condition|(
name|ret
operator|==
name|LZMA_BUF_ERROR
condition|)
name|ret
operator|=
name|LZMA_DATA_ERROR
expr_stmt|;
name|message_error
argument_list|(
literal|"%s: %s"
argument_list|,
name|pair
operator|->
name|src_name
argument_list|,
name|message_strm
argument_list|(
name|ret
argument_list|)
argument_list|)
expr_stmt|;
comment|// If the error was too low memory usage limit,
comment|// show also how much memory would have been needed.
if|if
condition|(
name|ret
operator|==
name|LZMA_MEMLIMIT_ERROR
condition|)
block|{
name|uint64_t
name|needed
init|=
name|lzma_memusage
argument_list|(
operator|&
name|strm
argument_list|)
decl_stmt|;
if|if
condition|(
name|UINT64_MAX
operator|-
name|needed
operator|<
name|memused
condition|)
name|needed
operator|=
name|UINT64_MAX
expr_stmt|;
else|else
name|needed
operator|+=
name|memused
expr_stmt|;
name|message_mem_needed
argument_list|(
name|V_ERROR
argument_list|,
name|needed
argument_list|)
expr_stmt|;
block|}
goto|goto
name|error
goto|;
block|}
comment|// Decode the Stream Header and check that its Stream Flags
comment|// match the Stream Footer.
name|pos
operator|-=
name|footer_flags
operator|.
name|backward_size
operator|+
name|LZMA_STREAM_HEADER_SIZE
expr_stmt|;
if|if
condition|(
call|(
name|lzma_vli
call|)
argument_list|(
name|pos
argument_list|)
operator|<
name|lzma_index_total_size
argument_list|(
name|this_index
argument_list|)
condition|)
block|{
name|message_error
argument_list|(
literal|"%s: %s"
argument_list|,
name|pair
operator|->
name|src_name
argument_list|,
name|message_strm
argument_list|(
name|LZMA_DATA_ERROR
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|pos
operator|-=
name|lzma_index_total_size
argument_list|(
name|this_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|io_pread
argument_list|(
name|pair
argument_list|,
operator|&
name|buf
argument_list|,
name|LZMA_STREAM_HEADER_SIZE
argument_list|,
name|pos
argument_list|)
condition|)
goto|goto
name|error
goto|;
name|ret
operator|=
name|lzma_stream_header_decode
argument_list|(
operator|&
name|header_flags
argument_list|,
name|buf
operator|.
name|u8
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|LZMA_OK
condition|)
block|{
name|message_error
argument_list|(
literal|"%s: %s"
argument_list|,
name|pair
operator|->
name|src_name
argument_list|,
name|message_strm
argument_list|(
name|ret
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|ret
operator|=
name|lzma_stream_flags_compare
argument_list|(
operator|&
name|header_flags
argument_list|,
operator|&
name|footer_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|LZMA_OK
condition|)
block|{
name|message_error
argument_list|(
literal|"%s: %s"
argument_list|,
name|pair
operator|->
name|src_name
argument_list|,
name|message_strm
argument_list|(
name|ret
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
comment|// Store the decoded Stream Flags into this_index. This is
comment|// needed so that we can print which Check is used in each
comment|// Stream.
name|ret
operator|=
name|lzma_index_stream_flags
argument_list|(
name|this_index
argument_list|,
operator|&
name|footer_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|LZMA_OK
condition|)
name|message_bug
argument_list|()
expr_stmt|;
comment|// Store also the size of the Stream Padding field. It is
comment|// needed to show the offsets of the Streams correctly.
name|ret
operator|=
name|lzma_index_stream_padding
argument_list|(
name|this_index
argument_list|,
name|stream_padding
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|LZMA_OK
condition|)
name|message_bug
argument_list|()
expr_stmt|;
if|if
condition|(
name|combined_index
operator|!=
name|NULL
condition|)
block|{
comment|// Append the earlier decoded Indexes
comment|// after this_index.
name|ret
operator|=
name|lzma_index_cat
argument_list|(
name|this_index
argument_list|,
name|combined_index
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|LZMA_OK
condition|)
block|{
name|message_error
argument_list|(
literal|"%s: %s"
argument_list|,
name|pair
operator|->
name|src_name
argument_list|,
name|message_strm
argument_list|(
name|ret
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
block|}
name|combined_index
operator|=
name|this_index
expr_stmt|;
name|this_index
operator|=
name|NULL
expr_stmt|;
name|xfi
operator|->
name|stream_padding
operator|+=
name|stream_padding
expr_stmt|;
block|}
do|while
condition|(
name|pos
operator|>
literal|0
condition|)
do|;
name|lzma_end
argument_list|(
operator|&
name|strm
argument_list|)
expr_stmt|;
comment|// All OK. Make combined_index available to the caller.
name|xfi
operator|->
name|idx
operator|=
name|combined_index
expr_stmt|;
return|return
name|false
return|;
name|error
label|:
comment|// Something went wrong, free the allocated memory.
name|lzma_end
argument_list|(
operator|&
name|strm
argument_list|)
expr_stmt|;
name|lzma_index_end
argument_list|(
name|combined_index
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|lzma_index_end
argument_list|(
name|this_index
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/// \brief      Parse the Block Header
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// The result is stored into *bhi. The caller takes care of initializing it.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// \return     False on success, true on error.
end_comment

begin_function
specifier|static
name|bool
name|parse_block_header
parameter_list|(
name|file_pair
modifier|*
name|pair
parameter_list|,
specifier|const
name|lzma_index_iter
modifier|*
name|iter
parameter_list|,
name|block_header_info
modifier|*
name|bhi
parameter_list|,
name|xz_file_info
modifier|*
name|xfi
parameter_list|)
block|{
if|#
directive|if
name|IO_BUFFER_SIZE
operator|<
name|LZMA_BLOCK_HEADER_SIZE_MAX
error|#
directive|error
error|IO_BUFFER_SIZE< LZMA_BLOCK_HEADER_SIZE_MAX
endif|#
directive|endif
comment|// Get the whole Block Header with one read, but don't read past
comment|// the end of the Block (or even its Check field).
specifier|const
name|uint32_t
name|size
init|=
name|my_min
argument_list|(
name|iter
operator|->
name|block
operator|.
name|total_size
operator|-
name|lzma_check_size
argument_list|(
name|iter
operator|->
name|stream
operator|.
name|flags
operator|->
name|check
argument_list|)
argument_list|,
name|LZMA_BLOCK_HEADER_SIZE_MAX
argument_list|)
decl_stmt|;
name|io_buf
name|buf
decl_stmt|;
if|if
condition|(
name|io_pread
argument_list|(
name|pair
argument_list|,
operator|&
name|buf
argument_list|,
name|size
argument_list|,
name|iter
operator|->
name|block
operator|.
name|compressed_file_offset
argument_list|)
condition|)
return|return
name|true
return|;
comment|// Zero would mean Index Indicator and thus not a valid Block.
if|if
condition|(
name|buf
operator|.
name|u8
index|[
literal|0
index|]
operator|==
literal|0
condition|)
goto|goto
name|data_error
goto|;
comment|// Initialize the block structure and decode Block Header Size.
name|lzma_filter
name|filters
index|[
name|LZMA_FILTERS_MAX
operator|+
literal|1
index|]
decl_stmt|;
name|lzma_block
name|block
decl_stmt|;
name|block
operator|.
name|version
operator|=
literal|0
expr_stmt|;
name|block
operator|.
name|check
operator|=
name|iter
operator|->
name|stream
operator|.
name|flags
operator|->
name|check
expr_stmt|;
name|block
operator|.
name|filters
operator|=
name|filters
expr_stmt|;
name|block
operator|.
name|header_size
operator|=
name|lzma_block_header_size_decode
argument_list|(
name|buf
operator|.
name|u8
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|block
operator|.
name|header_size
operator|>
name|size
condition|)
goto|goto
name|data_error
goto|;
comment|// Decode the Block Header.
switch|switch
condition|(
name|lzma_block_header_decode
argument_list|(
operator|&
name|block
argument_list|,
name|NULL
argument_list|,
name|buf
operator|.
name|u8
argument_list|)
condition|)
block|{
case|case
name|LZMA_OK
case|:
break|break;
case|case
name|LZMA_OPTIONS_ERROR
case|:
name|message_error
argument_list|(
literal|"%s: %s"
argument_list|,
name|pair
operator|->
name|src_name
argument_list|,
name|message_strm
argument_list|(
name|LZMA_OPTIONS_ERROR
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|true
return|;
case|case
name|LZMA_DATA_ERROR
case|:
goto|goto
name|data_error
goto|;
default|default:
name|message_bug
argument_list|()
expr_stmt|;
block|}
comment|// Check the Block Flags. These must be done before calling
comment|// lzma_block_compressed_size(), because it overwrites
comment|// block.compressed_size.
name|bhi
operator|->
name|flags
index|[
literal|0
index|]
operator|=
name|block
operator|.
name|compressed_size
operator|!=
name|LZMA_VLI_UNKNOWN
condition|?
literal|'c'
else|:
literal|'-'
expr_stmt|;
name|bhi
operator|->
name|flags
index|[
literal|1
index|]
operator|=
name|block
operator|.
name|uncompressed_size
operator|!=
name|LZMA_VLI_UNKNOWN
condition|?
literal|'u'
else|:
literal|'-'
expr_stmt|;
name|bhi
operator|->
name|flags
index|[
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|// Collect information if all Blocks have both Compressed Size
comment|// and Uncompressed Size fields. They can be useful e.g. for
comment|// multi-threaded decompression so it can be useful to know it.
name|xfi
operator|->
name|all_have_sizes
operator|&=
name|block
operator|.
name|compressed_size
operator|!=
name|LZMA_VLI_UNKNOWN
operator|&&
name|block
operator|.
name|uncompressed_size
operator|!=
name|LZMA_VLI_UNKNOWN
expr_stmt|;
comment|// Validate or set block.compressed_size.
switch|switch
condition|(
name|lzma_block_compressed_size
argument_list|(
operator|&
name|block
argument_list|,
name|iter
operator|->
name|block
operator|.
name|unpadded_size
argument_list|)
condition|)
block|{
case|case
name|LZMA_OK
case|:
comment|// Validate also block.uncompressed_size if it is present.
comment|// If it isn't present, there's no need to set it since
comment|// we aren't going to actually decompress the Block; if
comment|// we were decompressing, then we should set it so that
comment|// the Block decoder could validate the Uncompressed Size
comment|// that was stored in the Index.
if|if
condition|(
name|block
operator|.
name|uncompressed_size
operator|==
name|LZMA_VLI_UNKNOWN
operator|||
name|block
operator|.
name|uncompressed_size
operator|==
name|iter
operator|->
name|block
operator|.
name|uncompressed_size
condition|)
break|break;
comment|// If the above fails, the file is corrupt so
comment|// LZMA_DATA_ERROR is a good error code.
case|case
name|LZMA_DATA_ERROR
case|:
comment|// Free the memory allocated by lzma_block_header_decode().
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|filters
index|[
name|i
index|]
operator|.
name|id
operator|!=
name|LZMA_VLI_UNKNOWN
condition|;
operator|++
name|i
control|)
name|free
argument_list|(
name|filters
index|[
name|i
index|]
operator|.
name|options
argument_list|)
expr_stmt|;
goto|goto
name|data_error
goto|;
default|default:
name|message_bug
argument_list|()
expr_stmt|;
block|}
comment|// Copy the known sizes.
name|bhi
operator|->
name|header_size
operator|=
name|block
operator|.
name|header_size
expr_stmt|;
name|bhi
operator|->
name|compressed_size
operator|=
name|block
operator|.
name|compressed_size
expr_stmt|;
comment|// Calculate the decoder memory usage and update the maximum
comment|// memory usage of this Block.
name|bhi
operator|->
name|memusage
operator|=
name|lzma_raw_decoder_memusage
argument_list|(
name|filters
argument_list|)
expr_stmt|;
if|if
condition|(
name|xfi
operator|->
name|memusage_max
operator|<
name|bhi
operator|->
name|memusage
condition|)
name|xfi
operator|->
name|memusage_max
operator|=
name|bhi
operator|->
name|memusage
expr_stmt|;
comment|// Convert the filter chain to human readable form.
name|message_filters_to_str
argument_list|(
name|bhi
operator|->
name|filter_chain
argument_list|,
name|filters
argument_list|,
name|false
argument_list|)
expr_stmt|;
comment|// Free the memory allocated by lzma_block_header_decode().
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|filters
index|[
name|i
index|]
operator|.
name|id
operator|!=
name|LZMA_VLI_UNKNOWN
condition|;
operator|++
name|i
control|)
name|free
argument_list|(
name|filters
index|[
name|i
index|]
operator|.
name|options
argument_list|)
expr_stmt|;
return|return
name|false
return|;
name|data_error
label|:
comment|// Show the error message.
name|message_error
argument_list|(
literal|"%s: %s"
argument_list|,
name|pair
operator|->
name|src_name
argument_list|,
name|message_strm
argument_list|(
name|LZMA_DATA_ERROR
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/// \brief      Parse the Check field and put it into check_value[]
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// \return     False on success, true on error.
end_comment

begin_function
specifier|static
name|bool
name|parse_check_value
parameter_list|(
name|file_pair
modifier|*
name|pair
parameter_list|,
specifier|const
name|lzma_index_iter
modifier|*
name|iter
parameter_list|)
block|{
comment|// Don't read anything from the file if there is no integrity Check.
if|if
condition|(
name|iter
operator|->
name|stream
operator|.
name|flags
operator|->
name|check
operator|==
name|LZMA_CHECK_NONE
condition|)
block|{
name|snprintf
argument_list|(
name|check_value
argument_list|,
sizeof|sizeof
argument_list|(
name|check_value
argument_list|)
argument_list|,
literal|"---"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
comment|// Locate and read the Check field.
specifier|const
name|uint32_t
name|size
init|=
name|lzma_check_size
argument_list|(
name|iter
operator|->
name|stream
operator|.
name|flags
operator|->
name|check
argument_list|)
decl_stmt|;
specifier|const
name|off_t
name|offset
init|=
name|iter
operator|->
name|block
operator|.
name|compressed_file_offset
operator|+
name|iter
operator|->
name|block
operator|.
name|total_size
operator|-
name|size
decl_stmt|;
name|io_buf
name|buf
decl_stmt|;
if|if
condition|(
name|io_pread
argument_list|(
name|pair
argument_list|,
operator|&
name|buf
argument_list|,
name|size
argument_list|,
name|offset
argument_list|)
condition|)
return|return
name|true
return|;
comment|// CRC32 and CRC64 are in little endian. Guess that all the future
comment|// 32-bit and 64-bit Check values are little endian too. It shouldn't
comment|// be a too big problem if this guess is wrong.
if|if
condition|(
name|size
operator|==
literal|4
condition|)
name|snprintf
argument_list|(
name|check_value
argument_list|,
sizeof|sizeof
argument_list|(
name|check_value
argument_list|)
argument_list|,
literal|"%08"
name|PRIx32
argument_list|,
name|conv32le
argument_list|(
name|buf
operator|.
name|u32
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|size
operator|==
literal|8
condition|)
name|snprintf
argument_list|(
name|check_value
argument_list|,
sizeof|sizeof
argument_list|(
name|check_value
argument_list|)
argument_list|,
literal|"%016"
name|PRIx64
argument_list|,
name|conv64le
argument_list|(
name|buf
operator|.
name|u64
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
else|else
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
operator|++
name|i
control|)
name|snprintf
argument_list|(
name|check_value
operator|+
name|i
operator|*
literal|2
argument_list|,
literal|3
argument_list|,
literal|"%02x"
argument_list|,
name|buf
operator|.
name|u8
index|[
name|i
index|]
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/// \brief      Parse detailed information about a Block
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// Since this requires seek(s), listing information about all Blocks can
end_comment

begin_comment
comment|/// be slow.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// \param      pair    Input file
end_comment

begin_comment
comment|/// \param      iter    Location of the Block whose Check value should
end_comment

begin_comment
comment|///                     be printed.
end_comment

begin_comment
comment|/// \param      bhi     Pointer to structure where to store the information
end_comment

begin_comment
comment|///                     about the Block Header field.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// \return     False on success, true on error. If an error occurs,
end_comment

begin_comment
comment|///             the error message is printed too so the caller doesn't
end_comment

begin_comment
comment|///             need to worry about that.
end_comment

begin_function
specifier|static
name|bool
name|parse_details
parameter_list|(
name|file_pair
modifier|*
name|pair
parameter_list|,
specifier|const
name|lzma_index_iter
modifier|*
name|iter
parameter_list|,
name|block_header_info
modifier|*
name|bhi
parameter_list|,
name|xz_file_info
modifier|*
name|xfi
parameter_list|)
block|{
if|if
condition|(
name|parse_block_header
argument_list|(
name|pair
argument_list|,
name|iter
argument_list|,
name|bhi
argument_list|,
name|xfi
argument_list|)
condition|)
return|return
name|true
return|;
if|if
condition|(
name|parse_check_value
argument_list|(
name|pair
argument_list|,
name|iter
argument_list|)
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/// \brief      Get the compression ratio
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// This has slightly different format than that is used in message.c.
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|get_ratio
parameter_list|(
name|uint64_t
name|compressed_size
parameter_list|,
name|uint64_t
name|uncompressed_size
parameter_list|)
block|{
if|if
condition|(
name|uncompressed_size
operator|==
literal|0
condition|)
return|return
literal|"---"
return|;
specifier|const
name|double
name|ratio
init|=
call|(
name|double
call|)
argument_list|(
name|compressed_size
argument_list|)
operator|/
call|(
name|double
call|)
argument_list|(
name|uncompressed_size
argument_list|)
decl_stmt|;
if|if
condition|(
name|ratio
operator|>
literal|9.999
condition|)
return|return
literal|"---"
return|;
specifier|static
name|char
name|buf
index|[
literal|16
index|]
decl_stmt|;
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%.3f"
argument_list|,
name|ratio
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_comment
comment|/// \brief      Get a comma-separated list of Check names
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// The check names are translated with gettext except when in robot mode.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// \param      buf     Buffer to hold the resulting string
end_comment

begin_comment
comment|/// \param      checks  Bit mask of Checks to print
end_comment

begin_comment
comment|/// \param      space_after_comma
end_comment

begin_comment
comment|///                     It's better to not use spaces in table-like listings,
end_comment

begin_comment
comment|///                     but in more verbose formats a space after a comma
end_comment

begin_comment
comment|///                     is good for readability.
end_comment

begin_function
specifier|static
name|void
name|get_check_names
parameter_list|(
name|char
name|buf
index|[
name|CHECKS_STR_SIZE
index|]
parameter_list|,
name|uint32_t
name|checks
parameter_list|,
name|bool
name|space_after_comma
parameter_list|)
block|{
name|assert
argument_list|(
name|checks
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|char
modifier|*
name|pos
init|=
name|buf
decl_stmt|;
name|size_t
name|left
init|=
name|CHECKS_STR_SIZE
decl_stmt|;
specifier|const
name|char
modifier|*
name|sep
init|=
name|space_after_comma
condition|?
literal|", "
else|:
literal|","
decl_stmt|;
name|bool
name|comma
init|=
name|false
decl_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<=
name|LZMA_CHECK_ID_MAX
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|checks
operator|&
operator|(
name|UINT32_C
argument_list|(
literal|1
argument_list|)
operator|<<
name|i
operator|)
condition|)
block|{
name|my_snprintf
argument_list|(
operator|&
name|pos
argument_list|,
operator|&
name|left
argument_list|,
literal|"%s%s"
argument_list|,
name|comma
condition|?
name|sep
else|:
literal|""
argument_list|,
name|opt_robot
condition|?
name|check_names
index|[
name|i
index|]
else|:
name|_
argument_list|(
name|check_names
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|comma
operator|=
name|true
expr_stmt|;
block|}
block|}
return|return;
block|}
end_function

begin_function
specifier|static
name|bool
name|print_info_basic
parameter_list|(
specifier|const
name|xz_file_info
modifier|*
name|xfi
parameter_list|,
name|file_pair
modifier|*
name|pair
parameter_list|)
block|{
specifier|static
name|bool
name|headings_displayed
init|=
name|false
decl_stmt|;
if|if
condition|(
operator|!
name|headings_displayed
condition|)
block|{
name|headings_displayed
operator|=
name|true
expr_stmt|;
comment|// TRANSLATORS: These are column headings. From Strms (Streams)
comment|// to Ratio, the columns are right aligned. Check and Filename
comment|// are left aligned. If you need longer words, it's OK to
comment|// use two lines here. Test with "xz -l foo.xz".
name|puts
argument_list|(
name|_
argument_list|(
literal|"Strms  Blocks   Compressed Uncompressed  Ratio  "
literal|"Check   Filename"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|char
name|checks
index|[
name|CHECKS_STR_SIZE
index|]
decl_stmt|;
name|get_check_names
argument_list|(
name|checks
argument_list|,
name|lzma_index_checks
argument_list|(
name|xfi
operator|->
name|idx
argument_list|)
argument_list|,
name|false
argument_list|)
expr_stmt|;
specifier|const
name|char
modifier|*
name|cols
index|[
literal|7
index|]
init|=
block|{
name|uint64_to_str
argument_list|(
name|lzma_index_stream_count
argument_list|(
name|xfi
operator|->
name|idx
argument_list|)
argument_list|,
literal|0
argument_list|)
block|,
name|uint64_to_str
argument_list|(
name|lzma_index_block_count
argument_list|(
name|xfi
operator|->
name|idx
argument_list|)
argument_list|,
literal|1
argument_list|)
block|,
name|uint64_to_nicestr
argument_list|(
name|lzma_index_file_size
argument_list|(
name|xfi
operator|->
name|idx
argument_list|)
argument_list|,
name|NICESTR_B
argument_list|,
name|NICESTR_TIB
argument_list|,
name|false
argument_list|,
literal|2
argument_list|)
block|,
name|uint64_to_nicestr
argument_list|(
name|lzma_index_uncompressed_size
argument_list|(
name|xfi
operator|->
name|idx
argument_list|)
argument_list|,
name|NICESTR_B
argument_list|,
name|NICESTR_TIB
argument_list|,
name|false
argument_list|,
literal|3
argument_list|)
block|,
name|get_ratio
argument_list|(
name|lzma_index_file_size
argument_list|(
name|xfi
operator|->
name|idx
argument_list|)
argument_list|,
name|lzma_index_uncompressed_size
argument_list|(
name|xfi
operator|->
name|idx
argument_list|)
argument_list|)
block|,
name|checks
block|,
name|pair
operator|->
name|src_name
block|, 	}
decl_stmt|;
name|printf
argument_list|(
literal|"%*s %*s  %*s  %*s  %*s  %-*s %s\n"
argument_list|,
name|tuklib_mbstr_fw
argument_list|(
name|cols
index|[
literal|0
index|]
argument_list|,
literal|5
argument_list|)
argument_list|,
name|cols
index|[
literal|0
index|]
argument_list|,
name|tuklib_mbstr_fw
argument_list|(
name|cols
index|[
literal|1
index|]
argument_list|,
literal|7
argument_list|)
argument_list|,
name|cols
index|[
literal|1
index|]
argument_list|,
name|tuklib_mbstr_fw
argument_list|(
name|cols
index|[
literal|2
index|]
argument_list|,
literal|11
argument_list|)
argument_list|,
name|cols
index|[
literal|2
index|]
argument_list|,
name|tuklib_mbstr_fw
argument_list|(
name|cols
index|[
literal|3
index|]
argument_list|,
literal|11
argument_list|)
argument_list|,
name|cols
index|[
literal|3
index|]
argument_list|,
name|tuklib_mbstr_fw
argument_list|(
name|cols
index|[
literal|4
index|]
argument_list|,
literal|5
argument_list|)
argument_list|,
name|cols
index|[
literal|4
index|]
argument_list|,
name|tuklib_mbstr_fw
argument_list|(
name|cols
index|[
literal|5
index|]
argument_list|,
literal|7
argument_list|)
argument_list|,
name|cols
index|[
literal|5
index|]
argument_list|,
name|cols
index|[
literal|6
index|]
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_adv_helper
parameter_list|(
name|uint64_t
name|stream_count
parameter_list|,
name|uint64_t
name|block_count
parameter_list|,
name|uint64_t
name|compressed_size
parameter_list|,
name|uint64_t
name|uncompressed_size
parameter_list|,
name|uint32_t
name|checks
parameter_list|,
name|uint64_t
name|stream_padding
parameter_list|)
block|{
name|char
name|checks_str
index|[
name|CHECKS_STR_SIZE
index|]
decl_stmt|;
name|get_check_names
argument_list|(
name|checks_str
argument_list|,
name|checks
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Streams:            %s\n"
argument_list|)
argument_list|,
name|uint64_to_str
argument_list|(
name|stream_count
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Blocks:             %s\n"
argument_list|)
argument_list|,
name|uint64_to_str
argument_list|(
name|block_count
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Compressed size:    %s\n"
argument_list|)
argument_list|,
name|uint64_to_nicestr
argument_list|(
name|compressed_size
argument_list|,
name|NICESTR_B
argument_list|,
name|NICESTR_TIB
argument_list|,
name|true
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Uncompressed size:  %s\n"
argument_list|)
argument_list|,
name|uint64_to_nicestr
argument_list|(
name|uncompressed_size
argument_list|,
name|NICESTR_B
argument_list|,
name|NICESTR_TIB
argument_list|,
name|true
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Ratio:              %s\n"
argument_list|)
argument_list|,
name|get_ratio
argument_list|(
name|compressed_size
argument_list|,
name|uncompressed_size
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Check:              %s\n"
argument_list|)
argument_list|,
name|checks_str
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Stream padding:     %s\n"
argument_list|)
argument_list|,
name|uint64_to_nicestr
argument_list|(
name|stream_padding
argument_list|,
name|NICESTR_B
argument_list|,
name|NICESTR_TIB
argument_list|,
name|true
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|bool
name|print_info_adv
parameter_list|(
name|xz_file_info
modifier|*
name|xfi
parameter_list|,
name|file_pair
modifier|*
name|pair
parameter_list|)
block|{
comment|// Print the overall information.
name|print_adv_helper
argument_list|(
name|lzma_index_stream_count
argument_list|(
name|xfi
operator|->
name|idx
argument_list|)
argument_list|,
name|lzma_index_block_count
argument_list|(
name|xfi
operator|->
name|idx
argument_list|)
argument_list|,
name|lzma_index_file_size
argument_list|(
name|xfi
operator|->
name|idx
argument_list|)
argument_list|,
name|lzma_index_uncompressed_size
argument_list|(
name|xfi
operator|->
name|idx
argument_list|)
argument_list|,
name|lzma_index_checks
argument_list|(
name|xfi
operator|->
name|idx
argument_list|)
argument_list|,
name|xfi
operator|->
name|stream_padding
argument_list|)
expr_stmt|;
comment|// Size of the biggest Check. This is used to calculate the width
comment|// of the CheckVal field. The table would get insanely wide if
comment|// we always reserved space for 64-byte Check (128 chars as hex).
name|uint32_t
name|check_max
init|=
literal|0
decl_stmt|;
comment|// Print information about the Streams.
comment|//
comment|// TRANSLATORS: The second line is column headings. All except
comment|// Check are right aligned; Check is left aligned. Test with
comment|// "xz -lv foo.xz".
name|puts
argument_list|(
name|_
argument_list|(
literal|"  Streams:\n    Stream    Blocks"
literal|"      CompOffset    UncompOffset"
literal|"        CompSize      UncompSize  Ratio"
literal|"  Check      Padding"
argument_list|)
argument_list|)
expr_stmt|;
name|lzma_index_iter
name|iter
decl_stmt|;
name|lzma_index_iter_init
argument_list|(
operator|&
name|iter
argument_list|,
name|xfi
operator|->
name|idx
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|lzma_index_iter_next
argument_list|(
operator|&
name|iter
argument_list|,
name|LZMA_INDEX_ITER_STREAM
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|cols1
index|[
literal|4
index|]
init|=
block|{
name|uint64_to_str
argument_list|(
name|iter
operator|.
name|stream
operator|.
name|number
argument_list|,
literal|0
argument_list|)
block|,
name|uint64_to_str
argument_list|(
name|iter
operator|.
name|stream
operator|.
name|block_count
argument_list|,
literal|1
argument_list|)
block|,
name|uint64_to_str
argument_list|(
name|iter
operator|.
name|stream
operator|.
name|compressed_offset
argument_list|,
literal|2
argument_list|)
block|,
name|uint64_to_str
argument_list|(
name|iter
operator|.
name|stream
operator|.
name|uncompressed_offset
argument_list|,
literal|3
argument_list|)
block|, 		}
decl_stmt|;
name|printf
argument_list|(
literal|"    %*s %*s %*s %*s "
argument_list|,
name|tuklib_mbstr_fw
argument_list|(
name|cols1
index|[
literal|0
index|]
argument_list|,
literal|6
argument_list|)
argument_list|,
name|cols1
index|[
literal|0
index|]
argument_list|,
name|tuklib_mbstr_fw
argument_list|(
name|cols1
index|[
literal|1
index|]
argument_list|,
literal|9
argument_list|)
argument_list|,
name|cols1
index|[
literal|1
index|]
argument_list|,
name|tuklib_mbstr_fw
argument_list|(
name|cols1
index|[
literal|2
index|]
argument_list|,
literal|15
argument_list|)
argument_list|,
name|cols1
index|[
literal|2
index|]
argument_list|,
name|tuklib_mbstr_fw
argument_list|(
name|cols1
index|[
literal|3
index|]
argument_list|,
literal|15
argument_list|)
argument_list|,
name|cols1
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
specifier|const
name|char
modifier|*
name|cols2
index|[
literal|5
index|]
init|=
block|{
name|uint64_to_str
argument_list|(
name|iter
operator|.
name|stream
operator|.
name|compressed_size
argument_list|,
literal|0
argument_list|)
block|,
name|uint64_to_str
argument_list|(
name|iter
operator|.
name|stream
operator|.
name|uncompressed_size
argument_list|,
literal|1
argument_list|)
block|,
name|get_ratio
argument_list|(
name|iter
operator|.
name|stream
operator|.
name|compressed_size
argument_list|,
name|iter
operator|.
name|stream
operator|.
name|uncompressed_size
argument_list|)
block|,
name|_
argument_list|(
name|check_names
index|[
name|iter
operator|.
name|stream
operator|.
name|flags
operator|->
name|check
index|]
argument_list|)
block|,
name|uint64_to_str
argument_list|(
name|iter
operator|.
name|stream
operator|.
name|padding
argument_list|,
literal|2
argument_list|)
block|, 		}
decl_stmt|;
name|printf
argument_list|(
literal|"%*s %*s  %*s  %-*s %*s\n"
argument_list|,
name|tuklib_mbstr_fw
argument_list|(
name|cols2
index|[
literal|0
index|]
argument_list|,
literal|15
argument_list|)
argument_list|,
name|cols2
index|[
literal|0
index|]
argument_list|,
name|tuklib_mbstr_fw
argument_list|(
name|cols2
index|[
literal|1
index|]
argument_list|,
literal|15
argument_list|)
argument_list|,
name|cols2
index|[
literal|1
index|]
argument_list|,
name|tuklib_mbstr_fw
argument_list|(
name|cols2
index|[
literal|2
index|]
argument_list|,
literal|5
argument_list|)
argument_list|,
name|cols2
index|[
literal|2
index|]
argument_list|,
name|tuklib_mbstr_fw
argument_list|(
name|cols2
index|[
literal|3
index|]
argument_list|,
literal|10
argument_list|)
argument_list|,
name|cols2
index|[
literal|3
index|]
argument_list|,
name|tuklib_mbstr_fw
argument_list|(
name|cols2
index|[
literal|4
index|]
argument_list|,
literal|7
argument_list|)
argument_list|,
name|cols2
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
comment|// Update the maximum Check size.
if|if
condition|(
name|lzma_check_size
argument_list|(
name|iter
operator|.
name|stream
operator|.
name|flags
operator|->
name|check
argument_list|)
operator|>
name|check_max
condition|)
name|check_max
operator|=
name|lzma_check_size
argument_list|(
name|iter
operator|.
name|stream
operator|.
name|flags
operator|->
name|check
argument_list|)
expr_stmt|;
block|}
comment|// Cache the verbosity level to a local variable.
specifier|const
name|bool
name|detailed
init|=
name|message_verbosity_get
argument_list|()
operator|>=
name|V_DEBUG
decl_stmt|;
comment|// Information collected from Block Headers
name|block_header_info
name|bhi
decl_stmt|;
comment|// Print information about the Blocks but only if there is
comment|// at least one Block.
if|if
condition|(
name|lzma_index_block_count
argument_list|(
name|xfi
operator|->
name|idx
argument_list|)
operator|>
literal|0
condition|)
block|{
comment|// Calculate the width of the CheckVal field.
specifier|const
name|int
name|checkval_width
init|=
name|my_max
argument_list|(
literal|8
argument_list|,
literal|2
operator|*
name|check_max
argument_list|)
decl_stmt|;
comment|// TRANSLATORS: The second line is column headings. All
comment|// except Check are right aligned; Check is left aligned.
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Blocks:\n    Stream     Block"
literal|"      CompOffset    UncompOffset"
literal|"       TotalSize      UncompSize  Ratio  Check"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|detailed
condition|)
block|{
comment|// TRANSLATORS: These are additional column headings
comment|// for the most verbose listing mode. CheckVal
comment|// (Check value), Flags, and Filters are left aligned.
comment|// Header (Block Header Size), CompSize, and MemUsage
comment|// are right aligned. %*s is replaced with 0-120
comment|// spaces to make the CheckVal column wide enough.
comment|// Test with "xz -lvv foo.xz".
name|printf
argument_list|(
name|_
argument_list|(
literal|"      CheckVal %*s Header  Flags        "
literal|"CompSize    MemUsage  Filters"
argument_list|)
argument_list|,
name|checkval_width
operator|-
literal|8
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|lzma_index_iter_init
argument_list|(
operator|&
name|iter
argument_list|,
name|xfi
operator|->
name|idx
argument_list|)
expr_stmt|;
comment|// Iterate over the Blocks.
while|while
condition|(
operator|!
name|lzma_index_iter_next
argument_list|(
operator|&
name|iter
argument_list|,
name|LZMA_INDEX_ITER_BLOCK
argument_list|)
condition|)
block|{
if|if
condition|(
name|detailed
operator|&&
name|parse_details
argument_list|(
name|pair
argument_list|,
operator|&
name|iter
argument_list|,
operator|&
name|bhi
argument_list|,
name|xfi
argument_list|)
condition|)
return|return
name|true
return|;
specifier|const
name|char
modifier|*
name|cols1
index|[
literal|4
index|]
init|=
block|{
name|uint64_to_str
argument_list|(
name|iter
operator|.
name|stream
operator|.
name|number
argument_list|,
literal|0
argument_list|)
block|,
name|uint64_to_str
argument_list|(
name|iter
operator|.
name|block
operator|.
name|number_in_stream
argument_list|,
literal|1
argument_list|)
block|,
name|uint64_to_str
argument_list|(
name|iter
operator|.
name|block
operator|.
name|compressed_file_offset
argument_list|,
literal|2
argument_list|)
block|,
name|uint64_to_str
argument_list|(
argument|iter.block.uncompressed_file_offset
argument_list|,
literal|3
argument_list|)
block|}
decl_stmt|;
name|printf
argument_list|(
literal|"    %*s %*s %*s %*s "
argument_list|,
name|tuklib_mbstr_fw
argument_list|(
name|cols1
index|[
literal|0
index|]
argument_list|,
literal|6
argument_list|)
argument_list|,
name|cols1
index|[
literal|0
index|]
argument_list|,
name|tuklib_mbstr_fw
argument_list|(
name|cols1
index|[
literal|1
index|]
argument_list|,
literal|9
argument_list|)
argument_list|,
name|cols1
index|[
literal|1
index|]
argument_list|,
name|tuklib_mbstr_fw
argument_list|(
name|cols1
index|[
literal|2
index|]
argument_list|,
literal|15
argument_list|)
argument_list|,
name|cols1
index|[
literal|2
index|]
argument_list|,
name|tuklib_mbstr_fw
argument_list|(
name|cols1
index|[
literal|3
index|]
argument_list|,
literal|15
argument_list|)
argument_list|,
name|cols1
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
specifier|const
name|char
modifier|*
name|cols2
index|[
literal|4
index|]
init|=
block|{
name|uint64_to_str
argument_list|(
name|iter
operator|.
name|block
operator|.
name|total_size
argument_list|,
literal|0
argument_list|)
block|,
name|uint64_to_str
argument_list|(
name|iter
operator|.
name|block
operator|.
name|uncompressed_size
argument_list|,
literal|1
argument_list|)
block|,
name|get_ratio
argument_list|(
name|iter
operator|.
name|block
operator|.
name|total_size
argument_list|,
name|iter
operator|.
name|block
operator|.
name|uncompressed_size
argument_list|)
block|,
name|_
argument_list|(
argument|check_names[iter.stream.flags->check]
argument_list|)
block|}
decl_stmt|;
name|printf
argument_list|(
literal|"%*s %*s  %*s  %-*s"
argument_list|,
name|tuklib_mbstr_fw
argument_list|(
name|cols2
index|[
literal|0
index|]
argument_list|,
literal|15
argument_list|)
argument_list|,
name|cols2
index|[
literal|0
index|]
argument_list|,
name|tuklib_mbstr_fw
argument_list|(
name|cols2
index|[
literal|1
index|]
argument_list|,
literal|15
argument_list|)
argument_list|,
name|cols2
index|[
literal|1
index|]
argument_list|,
name|tuklib_mbstr_fw
argument_list|(
name|cols2
index|[
literal|2
index|]
argument_list|,
literal|5
argument_list|)
argument_list|,
name|cols2
index|[
literal|2
index|]
argument_list|,
name|tuklib_mbstr_fw
argument_list|(
name|cols2
index|[
literal|3
index|]
argument_list|,
name|detailed
condition|?
literal|11
else|:
literal|1
argument_list|)
argument_list|,
name|cols2
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|detailed
condition|)
block|{
specifier|const
name|lzma_vli
name|compressed_size
init|=
name|iter
operator|.
name|block
operator|.
name|unpadded_size
operator|-
name|bhi
operator|.
name|header_size
operator|-
name|lzma_check_size
argument_list|(
name|iter
operator|.
name|stream
operator|.
name|flags
operator|->
name|check
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|cols3
index|[
literal|6
index|]
init|=
block|{
name|check_value
block|,
name|uint64_to_str
argument_list|(
name|bhi
operator|.
name|header_size
argument_list|,
literal|0
argument_list|)
block|,
name|bhi
operator|.
name|flags
block|,
name|uint64_to_str
argument_list|(
name|compressed_size
argument_list|,
literal|1
argument_list|)
block|,
name|uint64_to_str
argument_list|(
name|round_up_to_mib
argument_list|(
name|bhi
operator|.
name|memusage
argument_list|)
argument_list|,
literal|2
argument_list|)
block|,
name|bhi
operator|.
name|filter_chain
block|}
decl_stmt|;
comment|// Show MiB for memory usage, because it
comment|// is the only size which is not in bytes.
name|printf
argument_list|(
literal|"%-*s  %*s  %-5s %*s %*s MiB  %s"
argument_list|,
name|checkval_width
argument_list|,
name|cols3
index|[
literal|0
index|]
argument_list|,
name|tuklib_mbstr_fw
argument_list|(
name|cols3
index|[
literal|1
index|]
argument_list|,
literal|6
argument_list|)
argument_list|,
name|cols3
index|[
literal|1
index|]
argument_list|,
name|cols3
index|[
literal|2
index|]
argument_list|,
name|tuklib_mbstr_fw
argument_list|(
name|cols3
index|[
literal|3
index|]
argument_list|,
literal|15
argument_list|)
argument_list|,
name|cols3
index|[
literal|3
index|]
argument_list|,
name|tuklib_mbstr_fw
argument_list|(
name|cols3
index|[
literal|4
index|]
argument_list|,
literal|7
argument_list|)
argument_list|,
name|cols3
index|[
literal|4
index|]
argument_list|,
name|cols3
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
block|}
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|detailed
condition|)
block|{
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Memory needed:      %s MiB\n"
argument_list|)
argument_list|,
name|uint64_to_str
argument_list|(
name|round_up_to_mib
argument_list|(
name|xfi
operator|->
name|memusage_max
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Sizes in headers:   %s\n"
argument_list|)
argument_list|,
name|xfi
operator|->
name|all_have_sizes
condition|?
name|_
argument_list|(
literal|"Yes"
argument_list|)
else|:
name|_
argument_list|(
literal|"No"
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|print_info_robot
parameter_list|(
name|xz_file_info
modifier|*
name|xfi
parameter_list|,
name|file_pair
modifier|*
name|pair
parameter_list|)
block|{
name|char
name|checks
index|[
name|CHECKS_STR_SIZE
index|]
decl_stmt|;
name|get_check_names
argument_list|(
name|checks
argument_list|,
name|lzma_index_checks
argument_list|(
name|xfi
operator|->
name|idx
argument_list|)
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"name\t%s\n"
argument_list|,
name|pair
operator|->
name|src_name
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"file\t%"
name|PRIu64
literal|"\t%"
name|PRIu64
literal|"\t%"
name|PRIu64
literal|"\t%"
name|PRIu64
literal|"\t%s\t%s\t%"
name|PRIu64
literal|"\n"
argument_list|,
name|lzma_index_stream_count
argument_list|(
name|xfi
operator|->
name|idx
argument_list|)
argument_list|,
name|lzma_index_block_count
argument_list|(
name|xfi
operator|->
name|idx
argument_list|)
argument_list|,
name|lzma_index_file_size
argument_list|(
name|xfi
operator|->
name|idx
argument_list|)
argument_list|,
name|lzma_index_uncompressed_size
argument_list|(
name|xfi
operator|->
name|idx
argument_list|)
argument_list|,
name|get_ratio
argument_list|(
name|lzma_index_file_size
argument_list|(
name|xfi
operator|->
name|idx
argument_list|)
argument_list|,
name|lzma_index_uncompressed_size
argument_list|(
name|xfi
operator|->
name|idx
argument_list|)
argument_list|)
argument_list|,
name|checks
argument_list|,
name|xfi
operator|->
name|stream_padding
argument_list|)
expr_stmt|;
if|if
condition|(
name|message_verbosity_get
argument_list|()
operator|>=
name|V_VERBOSE
condition|)
block|{
name|lzma_index_iter
name|iter
decl_stmt|;
name|lzma_index_iter_init
argument_list|(
operator|&
name|iter
argument_list|,
name|xfi
operator|->
name|idx
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|lzma_index_iter_next
argument_list|(
operator|&
name|iter
argument_list|,
name|LZMA_INDEX_ITER_STREAM
argument_list|)
condition|)
name|printf
argument_list|(
literal|"stream\t%"
name|PRIu64
literal|"\t%"
name|PRIu64
literal|"\t%"
name|PRIu64
literal|"\t%"
name|PRIu64
literal|"\t%"
name|PRIu64
literal|"\t%"
name|PRIu64
literal|"\t%s\t%s\t%"
name|PRIu64
literal|"\n"
argument_list|,
name|iter
operator|.
name|stream
operator|.
name|number
argument_list|,
name|iter
operator|.
name|stream
operator|.
name|block_count
argument_list|,
name|iter
operator|.
name|stream
operator|.
name|compressed_offset
argument_list|,
name|iter
operator|.
name|stream
operator|.
name|uncompressed_offset
argument_list|,
name|iter
operator|.
name|stream
operator|.
name|compressed_size
argument_list|,
name|iter
operator|.
name|stream
operator|.
name|uncompressed_size
argument_list|,
name|get_ratio
argument_list|(
name|iter
operator|.
name|stream
operator|.
name|compressed_size
argument_list|,
name|iter
operator|.
name|stream
operator|.
name|uncompressed_size
argument_list|)
argument_list|,
name|check_names
index|[
name|iter
operator|.
name|stream
operator|.
name|flags
operator|->
name|check
index|]
argument_list|,
name|iter
operator|.
name|stream
operator|.
name|padding
argument_list|)
expr_stmt|;
name|lzma_index_iter_rewind
argument_list|(
operator|&
name|iter
argument_list|)
expr_stmt|;
name|block_header_info
name|bhi
decl_stmt|;
while|while
condition|(
operator|!
name|lzma_index_iter_next
argument_list|(
operator|&
name|iter
argument_list|,
name|LZMA_INDEX_ITER_BLOCK
argument_list|)
condition|)
block|{
if|if
condition|(
name|message_verbosity_get
argument_list|()
operator|>=
name|V_DEBUG
operator|&&
name|parse_details
argument_list|(
name|pair
argument_list|,
operator|&
name|iter
argument_list|,
operator|&
name|bhi
argument_list|,
name|xfi
argument_list|)
condition|)
return|return
name|true
return|;
name|printf
argument_list|(
literal|"block\t%"
name|PRIu64
literal|"\t%"
name|PRIu64
literal|"\t%"
name|PRIu64
literal|"\t%"
name|PRIu64
literal|"\t%"
name|PRIu64
literal|"\t%"
name|PRIu64
literal|"\t%"
name|PRIu64
literal|"\t%s\t%s"
argument_list|,
name|iter
operator|.
name|stream
operator|.
name|number
argument_list|,
name|iter
operator|.
name|block
operator|.
name|number_in_stream
argument_list|,
name|iter
operator|.
name|block
operator|.
name|number_in_file
argument_list|,
name|iter
operator|.
name|block
operator|.
name|compressed_file_offset
argument_list|,
name|iter
operator|.
name|block
operator|.
name|uncompressed_file_offset
argument_list|,
name|iter
operator|.
name|block
operator|.
name|total_size
argument_list|,
name|iter
operator|.
name|block
operator|.
name|uncompressed_size
argument_list|,
name|get_ratio
argument_list|(
name|iter
operator|.
name|block
operator|.
name|total_size
argument_list|,
name|iter
operator|.
name|block
operator|.
name|uncompressed_size
argument_list|)
argument_list|,
name|check_names
index|[
name|iter
operator|.
name|stream
operator|.
name|flags
operator|->
name|check
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|message_verbosity_get
argument_list|()
operator|>=
name|V_DEBUG
condition|)
name|printf
argument_list|(
literal|"\t%s\t%"
name|PRIu32
literal|"\t%s\t%"
name|PRIu64
literal|"\t%"
name|PRIu64
literal|"\t%s"
argument_list|,
name|check_value
argument_list|,
name|bhi
operator|.
name|header_size
argument_list|,
name|bhi
operator|.
name|flags
argument_list|,
name|bhi
operator|.
name|compressed_size
argument_list|,
name|bhi
operator|.
name|memusage
argument_list|,
name|bhi
operator|.
name|filter_chain
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|message_verbosity_get
argument_list|()
operator|>=
name|V_DEBUG
condition|)
name|printf
argument_list|(
literal|"summary\t%"
name|PRIu64
literal|"\t%s\n"
argument_list|,
name|xfi
operator|->
name|memusage_max
argument_list|,
name|xfi
operator|->
name|all_have_sizes
condition|?
literal|"yes"
else|:
literal|"no"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|update_totals
parameter_list|(
specifier|const
name|xz_file_info
modifier|*
name|xfi
parameter_list|)
block|{
comment|// TODO: Integer overflow checks
operator|++
name|totals
operator|.
name|files
expr_stmt|;
name|totals
operator|.
name|streams
operator|+=
name|lzma_index_stream_count
argument_list|(
name|xfi
operator|->
name|idx
argument_list|)
expr_stmt|;
name|totals
operator|.
name|blocks
operator|+=
name|lzma_index_block_count
argument_list|(
name|xfi
operator|->
name|idx
argument_list|)
expr_stmt|;
name|totals
operator|.
name|compressed_size
operator|+=
name|lzma_index_file_size
argument_list|(
name|xfi
operator|->
name|idx
argument_list|)
expr_stmt|;
name|totals
operator|.
name|uncompressed_size
operator|+=
name|lzma_index_uncompressed_size
argument_list|(
name|xfi
operator|->
name|idx
argument_list|)
expr_stmt|;
name|totals
operator|.
name|stream_padding
operator|+=
name|xfi
operator|->
name|stream_padding
expr_stmt|;
name|totals
operator|.
name|checks
operator||=
name|lzma_index_checks
argument_list|(
name|xfi
operator|->
name|idx
argument_list|)
expr_stmt|;
if|if
condition|(
name|totals
operator|.
name|memusage_max
operator|<
name|xfi
operator|->
name|memusage_max
condition|)
name|totals
operator|.
name|memusage_max
operator|=
name|xfi
operator|->
name|memusage_max
expr_stmt|;
name|totals
operator|.
name|all_have_sizes
operator|&=
name|xfi
operator|->
name|all_have_sizes
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|print_totals_basic
parameter_list|(
name|void
parameter_list|)
block|{
comment|// Print a separator line.
name|char
name|line
index|[
literal|80
index|]
decl_stmt|;
name|memset
argument_list|(
name|line
argument_list|,
literal|'-'
argument_list|,
sizeof|sizeof
argument_list|(
name|line
argument_list|)
argument_list|)
expr_stmt|;
name|line
index|[
sizeof|sizeof
argument_list|(
name|line
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|puts
argument_list|(
name|line
argument_list|)
expr_stmt|;
comment|// Get the check names.
name|char
name|checks
index|[
name|CHECKS_STR_SIZE
index|]
decl_stmt|;
name|get_check_names
argument_list|(
name|checks
argument_list|,
name|totals
operator|.
name|checks
argument_list|,
name|false
argument_list|)
expr_stmt|;
comment|// Print the totals except the file count, which needs
comment|// special handling.
name|printf
argument_list|(
literal|"%5s %7s  %11s  %11s  %5s  %-7s "
argument_list|,
name|uint64_to_str
argument_list|(
name|totals
operator|.
name|streams
argument_list|,
literal|0
argument_list|)
argument_list|,
name|uint64_to_str
argument_list|(
name|totals
operator|.
name|blocks
argument_list|,
literal|1
argument_list|)
argument_list|,
name|uint64_to_nicestr
argument_list|(
name|totals
operator|.
name|compressed_size
argument_list|,
name|NICESTR_B
argument_list|,
name|NICESTR_TIB
argument_list|,
name|false
argument_list|,
literal|2
argument_list|)
argument_list|,
name|uint64_to_nicestr
argument_list|(
name|totals
operator|.
name|uncompressed_size
argument_list|,
name|NICESTR_B
argument_list|,
name|NICESTR_TIB
argument_list|,
name|false
argument_list|,
literal|3
argument_list|)
argument_list|,
name|get_ratio
argument_list|(
name|totals
operator|.
name|compressed_size
argument_list|,
name|totals
operator|.
name|uncompressed_size
argument_list|)
argument_list|,
name|checks
argument_list|)
expr_stmt|;
comment|// Since we print totals only when there are at least two files,
comment|// the English message will always use "%s files". But some other
comment|// languages need different forms for different plurals so we
comment|// have to translate this with ngettext().
comment|//
comment|// TRANSLATORS: %s is an integer. Only the plural form of this
comment|// message is used (e.g. "2 files"). Test with "xz -l foo.xz bar.xz".
name|printf
argument_list|(
name|ngettext
argument_list|(
literal|"%s file\n"
argument_list|,
literal|"%s files\n"
argument_list|,
name|totals
operator|.
name|files
operator|<=
name|ULONG_MAX
condition|?
name|totals
operator|.
name|files
else|:
operator|(
name|totals
operator|.
name|files
operator|%
literal|1000000
operator|)
operator|+
literal|1000000
argument_list|)
argument_list|,
name|uint64_to_str
argument_list|(
name|totals
operator|.
name|files
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|print_totals_adv
parameter_list|(
name|void
parameter_list|)
block|{
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|puts
argument_list|(
name|_
argument_list|(
literal|"Totals:"
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Number of files:    %s\n"
argument_list|)
argument_list|,
name|uint64_to_str
argument_list|(
name|totals
operator|.
name|files
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|print_adv_helper
argument_list|(
name|totals
operator|.
name|streams
argument_list|,
name|totals
operator|.
name|blocks
argument_list|,
name|totals
operator|.
name|compressed_size
argument_list|,
name|totals
operator|.
name|uncompressed_size
argument_list|,
name|totals
operator|.
name|checks
argument_list|,
name|totals
operator|.
name|stream_padding
argument_list|)
expr_stmt|;
if|if
condition|(
name|message_verbosity_get
argument_list|()
operator|>=
name|V_DEBUG
condition|)
block|{
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Memory needed:      %s MiB\n"
argument_list|)
argument_list|,
name|uint64_to_str
argument_list|(
name|round_up_to_mib
argument_list|(
name|totals
operator|.
name|memusage_max
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"  Sizes in headers:   %s\n"
argument_list|)
argument_list|,
name|totals
operator|.
name|all_have_sizes
condition|?
name|_
argument_list|(
literal|"Yes"
argument_list|)
else|:
name|_
argument_list|(
literal|"No"
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|print_totals_robot
parameter_list|(
name|void
parameter_list|)
block|{
name|char
name|checks
index|[
name|CHECKS_STR_SIZE
index|]
decl_stmt|;
name|get_check_names
argument_list|(
name|checks
argument_list|,
name|totals
operator|.
name|checks
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"totals\t%"
name|PRIu64
literal|"\t%"
name|PRIu64
literal|"\t%"
name|PRIu64
literal|"\t%"
name|PRIu64
literal|"\t%s\t%s\t%"
name|PRIu64
literal|"\t%"
name|PRIu64
argument_list|,
name|totals
operator|.
name|streams
argument_list|,
name|totals
operator|.
name|blocks
argument_list|,
name|totals
operator|.
name|compressed_size
argument_list|,
name|totals
operator|.
name|uncompressed_size
argument_list|,
name|get_ratio
argument_list|(
name|totals
operator|.
name|compressed_size
argument_list|,
name|totals
operator|.
name|uncompressed_size
argument_list|)
argument_list|,
name|checks
argument_list|,
name|totals
operator|.
name|stream_padding
argument_list|,
name|totals
operator|.
name|files
argument_list|)
expr_stmt|;
if|if
condition|(
name|message_verbosity_get
argument_list|()
operator|>=
name|V_DEBUG
condition|)
name|printf
argument_list|(
literal|"\t%"
name|PRIu64
literal|"\t%s"
argument_list|,
name|totals
operator|.
name|memusage_max
argument_list|,
name|totals
operator|.
name|all_have_sizes
condition|?
literal|"yes"
else|:
literal|"no"
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|extern
name|void
name|list_totals
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|opt_robot
condition|)
block|{
comment|// Always print totals in --robot mode. It can be convenient
comment|// in some cases and doesn't complicate usage of the
comment|// single-file case much.
name|print_totals_robot
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|totals
operator|.
name|files
operator|>
literal|1
condition|)
block|{
comment|// For non-robot mode, totals are printed only if there
comment|// is more than one file.
if|if
condition|(
name|message_verbosity_get
argument_list|()
operator|<=
name|V_WARNING
condition|)
name|print_totals_basic
argument_list|()
expr_stmt|;
else|else
name|print_totals_adv
argument_list|()
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
specifier|extern
name|void
name|list_file
parameter_list|(
specifier|const
name|char
modifier|*
name|filename
parameter_list|)
block|{
if|if
condition|(
name|opt_format
operator|!=
name|FORMAT_XZ
operator|&&
name|opt_format
operator|!=
name|FORMAT_AUTO
condition|)
name|message_fatal
argument_list|(
name|_
argument_list|(
literal|"--list works only on .xz files "
literal|"(--format=xz or --format=auto)"
argument_list|)
argument_list|)
expr_stmt|;
name|message_filename
argument_list|(
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|filename
operator|==
name|stdin_filename
condition|)
block|{
name|message_error
argument_list|(
name|_
argument_list|(
literal|"--list does not support reading from "
literal|"standard input"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// Unset opt_stdout so that io_open_src() won't accept special files.
comment|// Set opt_force so that io_open_src() will follow symlinks.
name|opt_stdout
operator|=
name|false
expr_stmt|;
name|opt_force
operator|=
name|true
expr_stmt|;
name|file_pair
modifier|*
name|pair
init|=
name|io_open_src
argument_list|(
name|filename
argument_list|)
decl_stmt|;
if|if
condition|(
name|pair
operator|==
name|NULL
condition|)
return|return;
name|xz_file_info
name|xfi
init|=
name|XZ_FILE_INFO_INIT
decl_stmt|;
if|if
condition|(
operator|!
name|parse_indexes
argument_list|(
operator|&
name|xfi
argument_list|,
name|pair
argument_list|)
condition|)
block|{
name|bool
name|fail
decl_stmt|;
comment|// We have three main modes:
comment|//  - --robot, which has submodes if --verbose is specified
comment|//    once or twice
comment|//  - Normal --list without --verbose
comment|//  - --list with one or two --verbose
if|if
condition|(
name|opt_robot
condition|)
name|fail
operator|=
name|print_info_robot
argument_list|(
operator|&
name|xfi
argument_list|,
name|pair
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|message_verbosity_get
argument_list|()
operator|<=
name|V_WARNING
condition|)
name|fail
operator|=
name|print_info_basic
argument_list|(
operator|&
name|xfi
argument_list|,
name|pair
argument_list|)
expr_stmt|;
else|else
name|fail
operator|=
name|print_info_adv
argument_list|(
operator|&
name|xfi
argument_list|,
name|pair
argument_list|)
expr_stmt|;
comment|// Update the totals that are displayed after all
comment|// the individual files have been listed. Don't count
comment|// broken files.
if|if
condition|(
operator|!
name|fail
condition|)
name|update_totals
argument_list|(
operator|&
name|xfi
argument_list|)
expr_stmt|;
name|lzma_index_end
argument_list|(
name|xfi
operator|.
name|idx
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|io_close
argument_list|(
name|pair
argument_list|,
name|false
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

end_unit

