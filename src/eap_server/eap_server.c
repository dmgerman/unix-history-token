begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * hostapd / EAP Full Authenticator state machine (RFC 4137)  * Copyright (c) 2004-2007, Jouni Malinen<j@w1.fi>  *  * This software may be distributed under the terms of the BSD license.  * See README for more details.  *  * This state machine is based on the full authenticator state machine defined  * in RFC 4137. However, to support backend authentication in RADIUS  * authentication server functionality, parts of backend authenticator (also  * from RFC 4137) are mixed in. This functionality is enabled by setting  * backend_auth configuration variable to TRUE.  */
end_comment

begin_include
include|#
directive|include
file|"includes.h"
end_include

begin_include
include|#
directive|include
file|"common.h"
end_include

begin_include
include|#
directive|include
file|"eap_i.h"
end_include

begin_include
include|#
directive|include
file|"state_machine.h"
end_include

begin_include
include|#
directive|include
file|"common/wpa_ctrl.h"
end_include

begin_define
define|#
directive|define
name|STATE_MACHINE_DATA
value|struct eap_sm
end_define

begin_define
define|#
directive|define
name|STATE_MACHINE_DEBUG_PREFIX
value|"EAP"
end_define

begin_define
define|#
directive|define
name|EAP_MAX_AUTH_ROUNDS
value|50
end_define

begin_function_decl
specifier|static
name|void
name|eap_user_free
parameter_list|(
name|struct
name|eap_user
modifier|*
name|user
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* EAP state machines are described in RFC 4137 */
end_comment

begin_function_decl
specifier|static
name|int
name|eap_sm_calculateTimeout
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|int
name|retransCount
parameter_list|,
name|int
name|eapSRTT
parameter_list|,
name|int
name|eapRTTVAR
parameter_list|,
name|int
name|methodTimeout
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|eap_sm_parseEapResp
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
specifier|const
name|struct
name|wpabuf
modifier|*
name|resp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|eap_sm_getId
parameter_list|(
specifier|const
name|struct
name|wpabuf
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|wpabuf
modifier|*
name|eap_sm_buildSuccess
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|u8
name|id
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|wpabuf
modifier|*
name|eap_sm_buildFailure
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|u8
name|id
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|eap_sm_nextId
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|int
name|id
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|eap_sm_Policy_update
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
specifier|const
name|u8
modifier|*
name|nak_list
parameter_list|,
name|size_t
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|EapType
name|eap_sm_Policy_getNextMethod
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|int
modifier|*
name|vendor
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|eap_sm_Policy_getDecision
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|Boolean
name|eap_sm_Policy_doPickUp
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|EapType
name|method
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|int
name|eap_copy_buf
parameter_list|(
name|struct
name|wpabuf
modifier|*
modifier|*
name|dst
parameter_list|,
specifier|const
name|struct
name|wpabuf
modifier|*
name|src
parameter_list|)
block|{
if|if
condition|(
name|src
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|wpabuf_free
argument_list|(
operator|*
name|dst
argument_list|)
expr_stmt|;
operator|*
name|dst
operator|=
name|wpabuf_dup
argument_list|(
name|src
argument_list|)
expr_stmt|;
return|return
operator|*
name|dst
condition|?
literal|0
else|:
operator|-
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|eap_copy_data
parameter_list|(
name|u8
modifier|*
modifier|*
name|dst
parameter_list|,
name|size_t
modifier|*
name|dst_len
parameter_list|,
specifier|const
name|u8
modifier|*
name|src
parameter_list|,
name|size_t
name|src_len
parameter_list|)
block|{
if|if
condition|(
name|src
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|os_free
argument_list|(
operator|*
name|dst
argument_list|)
expr_stmt|;
operator|*
name|dst
operator|=
name|os_malloc
argument_list|(
name|src_len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|dst
condition|)
block|{
name|os_memcpy
argument_list|(
operator|*
name|dst
argument_list|,
name|src
argument_list|,
name|src_len
argument_list|)
expr_stmt|;
operator|*
name|dst_len
operator|=
name|src_len
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
operator|*
name|dst_len
operator|=
literal|0
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|EAP_COPY
parameter_list|(
name|dst
parameter_list|,
name|src
parameter_list|)
define|\
value|eap_copy_data((dst), (dst ## Len), (src), (src ## Len))
end_define

begin_comment
comment|/**  * eap_user_get - Fetch user information from the database  * @sm: Pointer to EAP state machine allocated with eap_server_sm_init()  * @identity: Identity (User-Name) of the user  * @identity_len: Length of identity in bytes  * @phase2: 0 = EAP phase1 user, 1 = EAP phase2 (tunneled) user  * Returns: 0 on success, or -1 on failure  *  * This function is used to fetch user information for EAP. The user will be  * selected based on the specified identity. sm->user and  * sm->user_eap_method_index are updated for the new user when a matching user  * is found. sm->user can be used to get user information (e.g., password).  */
end_comment

begin_function
name|int
name|eap_user_get
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
specifier|const
name|u8
modifier|*
name|identity
parameter_list|,
name|size_t
name|identity_len
parameter_list|,
name|int
name|phase2
parameter_list|)
block|{
name|struct
name|eap_user
modifier|*
name|user
decl_stmt|;
if|if
condition|(
name|sm
operator|==
name|NULL
operator|||
name|sm
operator|->
name|eapol_cb
operator|==
name|NULL
operator|||
name|sm
operator|->
name|eapol_cb
operator|->
name|get_eap_user
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|eap_user_free
argument_list|(
name|sm
operator|->
name|user
argument_list|)
expr_stmt|;
name|sm
operator|->
name|user
operator|=
name|NULL
expr_stmt|;
name|user
operator|=
name|os_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|user
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|user
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|sm
operator|->
name|eapol_cb
operator|->
name|get_eap_user
argument_list|(
name|sm
operator|->
name|eapol_ctx
argument_list|,
name|identity
argument_list|,
name|identity_len
argument_list|,
name|phase2
argument_list|,
name|user
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|eap_user_free
argument_list|(
name|user
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|sm
operator|->
name|user
operator|=
name|user
expr_stmt|;
name|sm
operator|->
name|user_eap_method_index
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_macro
name|SM_STATE
argument_list|(
argument|EAP
argument_list|,
argument|DISABLED
argument_list|)
end_macro

begin_block
block|{
name|SM_ENTRY
argument_list|(
name|EAP
argument_list|,
name|DISABLED
argument_list|)
expr_stmt|;
name|sm
operator|->
name|num_rounds
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_macro
name|SM_STATE
argument_list|(
argument|EAP
argument_list|,
argument|INITIALIZE
argument_list|)
end_macro

begin_block
block|{
name|SM_ENTRY
argument_list|(
name|EAP
argument_list|,
name|INITIALIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|eap_if
operator|.
name|eapRestart
operator|&&
operator|!
name|sm
operator|->
name|eap_server
operator|&&
name|sm
operator|->
name|identity
condition|)
block|{
comment|/* 		 * Need to allow internal Identity method to be used instead 		 * of passthrough at the beginning of reauthentication. 		 */
name|eap_server_clear_identity
argument_list|(
name|sm
argument_list|)
expr_stmt|;
block|}
name|sm
operator|->
name|currentId
operator|=
operator|-
literal|1
expr_stmt|;
name|sm
operator|->
name|eap_if
operator|.
name|eapSuccess
operator|=
name|FALSE
expr_stmt|;
name|sm
operator|->
name|eap_if
operator|.
name|eapFail
operator|=
name|FALSE
expr_stmt|;
name|sm
operator|->
name|eap_if
operator|.
name|eapTimeout
operator|=
name|FALSE
expr_stmt|;
name|os_free
argument_list|(
name|sm
operator|->
name|eap_if
operator|.
name|eapKeyData
argument_list|)
expr_stmt|;
name|sm
operator|->
name|eap_if
operator|.
name|eapKeyData
operator|=
name|NULL
expr_stmt|;
name|sm
operator|->
name|eap_if
operator|.
name|eapKeyDataLen
operator|=
literal|0
expr_stmt|;
name|sm
operator|->
name|eap_if
operator|.
name|eapKeyAvailable
operator|=
name|FALSE
expr_stmt|;
name|sm
operator|->
name|eap_if
operator|.
name|eapRestart
operator|=
name|FALSE
expr_stmt|;
comment|/* 	 * This is not defined in RFC 4137, but method state needs to be 	 * reseted here so that it does not remain in success state when 	 * re-authentication starts. 	 */
if|if
condition|(
name|sm
operator|->
name|m
operator|&&
name|sm
operator|->
name|eap_method_priv
condition|)
block|{
name|sm
operator|->
name|m
operator|->
name|reset
argument_list|(
name|sm
argument_list|,
name|sm
operator|->
name|eap_method_priv
argument_list|)
expr_stmt|;
name|sm
operator|->
name|eap_method_priv
operator|=
name|NULL
expr_stmt|;
block|}
name|sm
operator|->
name|m
operator|=
name|NULL
expr_stmt|;
name|sm
operator|->
name|user_eap_method_index
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|backend_auth
condition|)
block|{
name|sm
operator|->
name|currentMethod
operator|=
name|EAP_TYPE_NONE
expr_stmt|;
comment|/* parse rxResp, respId, respMethod */
name|eap_sm_parseEapResp
argument_list|(
name|sm
argument_list|,
name|sm
operator|->
name|eap_if
operator|.
name|eapRespData
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|rxResp
condition|)
block|{
name|sm
operator|->
name|currentId
operator|=
name|sm
operator|->
name|respId
expr_stmt|;
block|}
block|}
name|sm
operator|->
name|num_rounds
operator|=
literal|0
expr_stmt|;
name|sm
operator|->
name|method_pending
operator|=
name|METHOD_PENDING_NONE
expr_stmt|;
name|wpa_msg
argument_list|(
argument|sm->msg_ctx
argument_list|,
argument|MSG_INFO
argument_list|,
argument|WPA_EVENT_EAP_STARTED 		MACSTR
argument_list|,
argument|MAC2STR(sm->peer_addr)
argument_list|)
empty_stmt|;
block|}
end_block

begin_macro
name|SM_STATE
argument_list|(
argument|EAP
argument_list|,
argument|PICK_UP_METHOD
argument_list|)
end_macro

begin_block
block|{
name|SM_ENTRY
argument_list|(
name|EAP
argument_list|,
name|PICK_UP_METHOD
argument_list|)
expr_stmt|;
if|if
condition|(
name|eap_sm_Policy_doPickUp
argument_list|(
name|sm
argument_list|,
name|sm
operator|->
name|respMethod
argument_list|)
condition|)
block|{
name|sm
operator|->
name|currentMethod
operator|=
name|sm
operator|->
name|respMethod
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|m
operator|&&
name|sm
operator|->
name|eap_method_priv
condition|)
block|{
name|sm
operator|->
name|m
operator|->
name|reset
argument_list|(
name|sm
argument_list|,
name|sm
operator|->
name|eap_method_priv
argument_list|)
expr_stmt|;
name|sm
operator|->
name|eap_method_priv
operator|=
name|NULL
expr_stmt|;
block|}
name|sm
operator|->
name|m
operator|=
name|eap_server_get_eap_method
argument_list|(
name|EAP_VENDOR_IETF
argument_list|,
name|sm
operator|->
name|currentMethod
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|m
operator|&&
name|sm
operator|->
name|m
operator|->
name|initPickUp
condition|)
block|{
name|sm
operator|->
name|eap_method_priv
operator|=
name|sm
operator|->
name|m
operator|->
name|initPickUp
argument_list|(
name|sm
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|eap_method_priv
operator|==
name|NULL
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: Failed to "
literal|"initialize EAP method %d"
argument_list|,
name|sm
operator|->
name|currentMethod
argument_list|)
expr_stmt|;
name|sm
operator|->
name|m
operator|=
name|NULL
expr_stmt|;
name|sm
operator|->
name|currentMethod
operator|=
name|EAP_TYPE_NONE
expr_stmt|;
block|}
block|}
else|else
block|{
name|sm
operator|->
name|m
operator|=
name|NULL
expr_stmt|;
name|sm
operator|->
name|currentMethod
operator|=
name|EAP_TYPE_NONE
expr_stmt|;
block|}
block|}
name|wpa_msg
argument_list|(
name|sm
operator|->
name|msg_ctx
argument_list|,
name|MSG_INFO
argument_list|,
name|WPA_EVENT_EAP_PROPOSED_METHOD
literal|"method=%u"
argument_list|,
name|sm
operator|->
name|currentMethod
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|SM_STATE
argument_list|(
argument|EAP
argument_list|,
argument|IDLE
argument_list|)
end_macro

begin_block
block|{
name|SM_ENTRY
argument_list|(
name|EAP
argument_list|,
name|IDLE
argument_list|)
expr_stmt|;
name|sm
operator|->
name|eap_if
operator|.
name|retransWhile
operator|=
name|eap_sm_calculateTimeout
argument_list|(
name|sm
argument_list|,
name|sm
operator|->
name|retransCount
argument_list|,
name|sm
operator|->
name|eap_if
operator|.
name|eapSRTT
argument_list|,
name|sm
operator|->
name|eap_if
operator|.
name|eapRTTVAR
argument_list|,
name|sm
operator|->
name|methodTimeout
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|SM_STATE
argument_list|(
argument|EAP
argument_list|,
argument|RETRANSMIT
argument_list|)
end_macro

begin_block
block|{
name|SM_ENTRY
argument_list|(
name|EAP
argument_list|,
name|RETRANSMIT
argument_list|)
expr_stmt|;
name|sm
operator|->
name|retransCount
operator|++
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|retransCount
operator|<=
name|sm
operator|->
name|MaxRetrans
operator|&&
name|sm
operator|->
name|lastReqData
condition|)
block|{
if|if
condition|(
name|eap_copy_buf
argument_list|(
operator|&
name|sm
operator|->
name|eap_if
operator|.
name|eapReqData
argument_list|,
name|sm
operator|->
name|lastReqData
argument_list|)
operator|==
literal|0
condition|)
name|sm
operator|->
name|eap_if
operator|.
name|eapReq
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|SM_STATE
argument_list|(
argument|EAP
argument_list|,
argument|RECEIVED
argument_list|)
end_macro

begin_block
block|{
name|SM_ENTRY
argument_list|(
name|EAP
argument_list|,
name|RECEIVED
argument_list|)
expr_stmt|;
comment|/* parse rxResp, respId, respMethod */
name|eap_sm_parseEapResp
argument_list|(
name|sm
argument_list|,
name|sm
operator|->
name|eap_if
operator|.
name|eapRespData
argument_list|)
expr_stmt|;
name|sm
operator|->
name|num_rounds
operator|++
expr_stmt|;
block|}
end_block

begin_macro
name|SM_STATE
argument_list|(
argument|EAP
argument_list|,
argument|DISCARD
argument_list|)
end_macro

begin_block
block|{
name|SM_ENTRY
argument_list|(
name|EAP
argument_list|,
name|DISCARD
argument_list|)
expr_stmt|;
name|sm
operator|->
name|eap_if
operator|.
name|eapResp
operator|=
name|FALSE
expr_stmt|;
name|sm
operator|->
name|eap_if
operator|.
name|eapNoReq
operator|=
name|TRUE
expr_stmt|;
block|}
end_block

begin_macro
name|SM_STATE
argument_list|(
argument|EAP
argument_list|,
argument|SEND_REQUEST
argument_list|)
end_macro

begin_block
block|{
name|SM_ENTRY
argument_list|(
name|EAP
argument_list|,
name|SEND_REQUEST
argument_list|)
expr_stmt|;
name|sm
operator|->
name|retransCount
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|eap_if
operator|.
name|eapReqData
condition|)
block|{
if|if
condition|(
name|eap_copy_buf
argument_list|(
operator|&
name|sm
operator|->
name|lastReqData
argument_list|,
name|sm
operator|->
name|eap_if
operator|.
name|eapReqData
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sm
operator|->
name|eap_if
operator|.
name|eapResp
operator|=
name|FALSE
expr_stmt|;
name|sm
operator|->
name|eap_if
operator|.
name|eapReq
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|sm
operator|->
name|eap_if
operator|.
name|eapResp
operator|=
name|FALSE
expr_stmt|;
name|sm
operator|->
name|eap_if
operator|.
name|eapReq
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
else|else
block|{
name|wpa_printf
argument_list|(
name|MSG_INFO
argument_list|,
literal|"EAP: SEND_REQUEST - no eapReqData"
argument_list|)
expr_stmt|;
name|sm
operator|->
name|eap_if
operator|.
name|eapResp
operator|=
name|FALSE
expr_stmt|;
name|sm
operator|->
name|eap_if
operator|.
name|eapReq
operator|=
name|FALSE
expr_stmt|;
name|sm
operator|->
name|eap_if
operator|.
name|eapNoReq
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|SM_STATE
argument_list|(
argument|EAP
argument_list|,
argument|INTEGRITY_CHECK
argument_list|)
end_macro

begin_block
block|{
name|SM_ENTRY
argument_list|(
name|EAP
argument_list|,
name|INTEGRITY_CHECK
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|eap_hdr_len_valid
argument_list|(
name|sm
operator|->
name|eap_if
operator|.
name|eapRespData
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|sm
operator|->
name|ignore
operator|=
name|TRUE
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|sm
operator|->
name|m
operator|->
name|check
condition|)
block|{
name|sm
operator|->
name|ignore
operator|=
name|sm
operator|->
name|m
operator|->
name|check
argument_list|(
name|sm
argument_list|,
name|sm
operator|->
name|eap_method_priv
argument_list|,
name|sm
operator|->
name|eap_if
operator|.
name|eapRespData
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|SM_STATE
argument_list|(
argument|EAP
argument_list|,
argument|METHOD_REQUEST
argument_list|)
end_macro

begin_block
block|{
name|SM_ENTRY
argument_list|(
name|EAP
argument_list|,
name|METHOD_REQUEST
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|m
operator|==
name|NULL
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: method not initialized"
argument_list|)
expr_stmt|;
return|return;
block|}
name|sm
operator|->
name|currentId
operator|=
name|eap_sm_nextId
argument_list|(
name|sm
argument_list|,
name|sm
operator|->
name|currentId
argument_list|)
expr_stmt|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: building EAP-Request: Identifier %d"
argument_list|,
name|sm
operator|->
name|currentId
argument_list|)
expr_stmt|;
name|sm
operator|->
name|lastId
operator|=
name|sm
operator|->
name|currentId
expr_stmt|;
name|wpabuf_free
argument_list|(
name|sm
operator|->
name|eap_if
operator|.
name|eapReqData
argument_list|)
expr_stmt|;
name|sm
operator|->
name|eap_if
operator|.
name|eapReqData
operator|=
name|sm
operator|->
name|m
operator|->
name|buildReq
argument_list|(
name|sm
argument_list|,
name|sm
operator|->
name|eap_method_priv
argument_list|,
name|sm
operator|->
name|currentId
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|m
operator|->
name|getTimeout
condition|)
name|sm
operator|->
name|methodTimeout
operator|=
name|sm
operator|->
name|m
operator|->
name|getTimeout
argument_list|(
name|sm
argument_list|,
name|sm
operator|->
name|eap_method_priv
argument_list|)
expr_stmt|;
else|else
name|sm
operator|->
name|methodTimeout
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_macro
name|SM_STATE
argument_list|(
argument|EAP
argument_list|,
argument|METHOD_RESPONSE
argument_list|)
end_macro

begin_block
block|{
name|SM_ENTRY
argument_list|(
name|EAP
argument_list|,
name|METHOD_RESPONSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|eap_hdr_len_valid
argument_list|(
name|sm
operator|->
name|eap_if
operator|.
name|eapRespData
argument_list|,
literal|1
argument_list|)
condition|)
return|return;
name|sm
operator|->
name|m
operator|->
name|process
argument_list|(
name|sm
argument_list|,
name|sm
operator|->
name|eap_method_priv
argument_list|,
name|sm
operator|->
name|eap_if
operator|.
name|eapRespData
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|m
operator|->
name|isDone
argument_list|(
name|sm
argument_list|,
name|sm
operator|->
name|eap_method_priv
argument_list|)
condition|)
block|{
name|eap_sm_Policy_update
argument_list|(
name|sm
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|os_free
argument_list|(
name|sm
operator|->
name|eap_if
operator|.
name|eapKeyData
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|m
operator|->
name|getKey
condition|)
block|{
name|sm
operator|->
name|eap_if
operator|.
name|eapKeyData
operator|=
name|sm
operator|->
name|m
operator|->
name|getKey
argument_list|(
name|sm
argument_list|,
name|sm
operator|->
name|eap_method_priv
argument_list|,
operator|&
name|sm
operator|->
name|eap_if
operator|.
name|eapKeyDataLen
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sm
operator|->
name|eap_if
operator|.
name|eapKeyData
operator|=
name|NULL
expr_stmt|;
name|sm
operator|->
name|eap_if
operator|.
name|eapKeyDataLen
operator|=
literal|0
expr_stmt|;
block|}
name|sm
operator|->
name|methodState
operator|=
name|METHOD_END
expr_stmt|;
block|}
else|else
block|{
name|sm
operator|->
name|methodState
operator|=
name|METHOD_CONTINUE
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|SM_STATE
argument_list|(
argument|EAP
argument_list|,
argument|PROPOSE_METHOD
argument_list|)
end_macro

begin_block
block|{
name|int
name|vendor
decl_stmt|;
name|EapType
name|type
decl_stmt|;
name|SM_ENTRY
argument_list|(
name|EAP
argument_list|,
name|PROPOSE_METHOD
argument_list|)
expr_stmt|;
name|type
operator|=
name|eap_sm_Policy_getNextMethod
argument_list|(
name|sm
argument_list|,
operator|&
name|vendor
argument_list|)
expr_stmt|;
if|if
condition|(
name|vendor
operator|==
name|EAP_VENDOR_IETF
condition|)
name|sm
operator|->
name|currentMethod
operator|=
name|type
expr_stmt|;
else|else
name|sm
operator|->
name|currentMethod
operator|=
name|EAP_TYPE_EXPANDED
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|m
operator|&&
name|sm
operator|->
name|eap_method_priv
condition|)
block|{
name|sm
operator|->
name|m
operator|->
name|reset
argument_list|(
name|sm
argument_list|,
name|sm
operator|->
name|eap_method_priv
argument_list|)
expr_stmt|;
name|sm
operator|->
name|eap_method_priv
operator|=
name|NULL
expr_stmt|;
block|}
name|sm
operator|->
name|m
operator|=
name|eap_server_get_eap_method
argument_list|(
name|vendor
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|m
condition|)
block|{
name|sm
operator|->
name|eap_method_priv
operator|=
name|sm
operator|->
name|m
operator|->
name|init
argument_list|(
name|sm
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|eap_method_priv
operator|==
name|NULL
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: Failed to initialize EAP "
literal|"method %d"
argument_list|,
name|sm
operator|->
name|currentMethod
argument_list|)
expr_stmt|;
name|sm
operator|->
name|m
operator|=
name|NULL
expr_stmt|;
name|sm
operator|->
name|currentMethod
operator|=
name|EAP_TYPE_NONE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sm
operator|->
name|currentMethod
operator|==
name|EAP_TYPE_IDENTITY
operator|||
name|sm
operator|->
name|currentMethod
operator|==
name|EAP_TYPE_NOTIFICATION
condition|)
name|sm
operator|->
name|methodState
operator|=
name|METHOD_CONTINUE
expr_stmt|;
else|else
name|sm
operator|->
name|methodState
operator|=
name|METHOD_PROPOSED
expr_stmt|;
name|wpa_msg
argument_list|(
name|sm
operator|->
name|msg_ctx
argument_list|,
name|MSG_INFO
argument_list|,
name|WPA_EVENT_EAP_PROPOSED_METHOD
literal|"vendor=%u method=%u"
argument_list|,
name|vendor
argument_list|,
name|sm
operator|->
name|currentMethod
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|SM_STATE
argument_list|(
argument|EAP
argument_list|,
argument|NAK
argument_list|)
end_macro

begin_block
block|{
specifier|const
name|struct
name|eap_hdr
modifier|*
name|nak
decl_stmt|;
name|size_t
name|len
init|=
literal|0
decl_stmt|;
specifier|const
name|u8
modifier|*
name|pos
decl_stmt|;
specifier|const
name|u8
modifier|*
name|nak_list
init|=
name|NULL
decl_stmt|;
name|SM_ENTRY
argument_list|(
name|EAP
argument_list|,
name|NAK
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|eap_method_priv
condition|)
block|{
name|sm
operator|->
name|m
operator|->
name|reset
argument_list|(
name|sm
argument_list|,
name|sm
operator|->
name|eap_method_priv
argument_list|)
expr_stmt|;
name|sm
operator|->
name|eap_method_priv
operator|=
name|NULL
expr_stmt|;
block|}
name|sm
operator|->
name|m
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|eap_hdr_len_valid
argument_list|(
name|sm
operator|->
name|eap_if
operator|.
name|eapRespData
argument_list|,
literal|1
argument_list|)
condition|)
return|return;
name|nak
operator|=
name|wpabuf_head
argument_list|(
name|sm
operator|->
name|eap_if
operator|.
name|eapRespData
argument_list|)
expr_stmt|;
if|if
condition|(
name|nak
operator|&&
name|wpabuf_len
argument_list|(
name|sm
operator|->
name|eap_if
operator|.
name|eapRespData
argument_list|)
operator|>
sizeof|sizeof
argument_list|(
operator|*
name|nak
argument_list|)
condition|)
block|{
name|len
operator|=
name|be_to_host16
argument_list|(
name|nak
operator|->
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|wpabuf_len
argument_list|(
name|sm
operator|->
name|eap_if
operator|.
name|eapRespData
argument_list|)
condition|)
name|len
operator|=
name|wpabuf_len
argument_list|(
name|sm
operator|->
name|eap_if
operator|.
name|eapRespData
argument_list|)
expr_stmt|;
name|pos
operator|=
operator|(
specifier|const
name|u8
operator|*
operator|)
operator|(
name|nak
operator|+
literal|1
operator|)
expr_stmt|;
name|len
operator|-=
sizeof|sizeof
argument_list|(
operator|*
name|nak
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|pos
operator|==
name|EAP_TYPE_NAK
condition|)
block|{
name|pos
operator|++
expr_stmt|;
name|len
operator|--
expr_stmt|;
name|nak_list
operator|=
name|pos
expr_stmt|;
block|}
block|}
name|eap_sm_Policy_update
argument_list|(
name|sm
argument_list|,
name|nak_list
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|SM_STATE
argument_list|(
argument|EAP
argument_list|,
argument|SELECT_ACTION
argument_list|)
end_macro

begin_block
block|{
name|SM_ENTRY
argument_list|(
name|EAP
argument_list|,
name|SELECT_ACTION
argument_list|)
expr_stmt|;
name|sm
operator|->
name|decision
operator|=
name|eap_sm_Policy_getDecision
argument_list|(
name|sm
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|SM_STATE
argument_list|(
argument|EAP
argument_list|,
argument|TIMEOUT_FAILURE
argument_list|)
end_macro

begin_block
block|{
name|SM_ENTRY
argument_list|(
name|EAP
argument_list|,
name|TIMEOUT_FAILURE
argument_list|)
expr_stmt|;
name|sm
operator|->
name|eap_if
operator|.
name|eapTimeout
operator|=
name|TRUE
expr_stmt|;
block|}
end_block

begin_macro
name|SM_STATE
argument_list|(
argument|EAP
argument_list|,
argument|FAILURE
argument_list|)
end_macro

begin_block
block|{
name|SM_ENTRY
argument_list|(
name|EAP
argument_list|,
name|FAILURE
argument_list|)
expr_stmt|;
name|wpabuf_free
argument_list|(
name|sm
operator|->
name|eap_if
operator|.
name|eapReqData
argument_list|)
expr_stmt|;
name|sm
operator|->
name|eap_if
operator|.
name|eapReqData
operator|=
name|eap_sm_buildFailure
argument_list|(
name|sm
argument_list|,
name|sm
operator|->
name|currentId
argument_list|)
expr_stmt|;
name|wpabuf_free
argument_list|(
name|sm
operator|->
name|lastReqData
argument_list|)
expr_stmt|;
name|sm
operator|->
name|lastReqData
operator|=
name|NULL
expr_stmt|;
name|sm
operator|->
name|eap_if
operator|.
name|eapFail
operator|=
name|TRUE
expr_stmt|;
name|wpa_msg
argument_list|(
argument|sm->msg_ctx
argument_list|,
argument|MSG_INFO
argument_list|,
argument|WPA_EVENT_EAP_FAILURE 		MACSTR
argument_list|,
argument|MAC2STR(sm->peer_addr)
argument_list|)
empty_stmt|;
block|}
end_block

begin_macro
name|SM_STATE
argument_list|(
argument|EAP
argument_list|,
argument|SUCCESS
argument_list|)
end_macro

begin_block
block|{
name|SM_ENTRY
argument_list|(
name|EAP
argument_list|,
name|SUCCESS
argument_list|)
expr_stmt|;
name|wpabuf_free
argument_list|(
name|sm
operator|->
name|eap_if
operator|.
name|eapReqData
argument_list|)
expr_stmt|;
name|sm
operator|->
name|eap_if
operator|.
name|eapReqData
operator|=
name|eap_sm_buildSuccess
argument_list|(
name|sm
argument_list|,
name|sm
operator|->
name|currentId
argument_list|)
expr_stmt|;
name|wpabuf_free
argument_list|(
name|sm
operator|->
name|lastReqData
argument_list|)
expr_stmt|;
name|sm
operator|->
name|lastReqData
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|eap_if
operator|.
name|eapKeyData
condition|)
name|sm
operator|->
name|eap_if
operator|.
name|eapKeyAvailable
operator|=
name|TRUE
expr_stmt|;
name|sm
operator|->
name|eap_if
operator|.
name|eapSuccess
operator|=
name|TRUE
expr_stmt|;
name|wpa_msg
argument_list|(
argument|sm->msg_ctx
argument_list|,
argument|MSG_INFO
argument_list|,
argument|WPA_EVENT_EAP_SUCCESS 		MACSTR
argument_list|,
argument|MAC2STR(sm->peer_addr)
argument_list|)
empty_stmt|;
block|}
end_block

begin_macro
name|SM_STATE
argument_list|(
argument|EAP
argument_list|,
argument|INITIALIZE_PASSTHROUGH
argument_list|)
end_macro

begin_block
block|{
name|SM_ENTRY
argument_list|(
name|EAP
argument_list|,
name|INITIALIZE_PASSTHROUGH
argument_list|)
expr_stmt|;
name|wpabuf_free
argument_list|(
name|sm
operator|->
name|eap_if
operator|.
name|aaaEapRespData
argument_list|)
expr_stmt|;
name|sm
operator|->
name|eap_if
operator|.
name|aaaEapRespData
operator|=
name|NULL
expr_stmt|;
block|}
end_block

begin_macro
name|SM_STATE
argument_list|(
argument|EAP
argument_list|,
argument|IDLE2
argument_list|)
end_macro

begin_block
block|{
name|SM_ENTRY
argument_list|(
name|EAP
argument_list|,
name|IDLE2
argument_list|)
expr_stmt|;
name|sm
operator|->
name|eap_if
operator|.
name|retransWhile
operator|=
name|eap_sm_calculateTimeout
argument_list|(
name|sm
argument_list|,
name|sm
operator|->
name|retransCount
argument_list|,
name|sm
operator|->
name|eap_if
operator|.
name|eapSRTT
argument_list|,
name|sm
operator|->
name|eap_if
operator|.
name|eapRTTVAR
argument_list|,
name|sm
operator|->
name|methodTimeout
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|SM_STATE
argument_list|(
argument|EAP
argument_list|,
argument|RETRANSMIT2
argument_list|)
end_macro

begin_block
block|{
name|SM_ENTRY
argument_list|(
name|EAP
argument_list|,
name|RETRANSMIT2
argument_list|)
expr_stmt|;
name|sm
operator|->
name|retransCount
operator|++
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|retransCount
operator|<=
name|sm
operator|->
name|MaxRetrans
operator|&&
name|sm
operator|->
name|lastReqData
condition|)
block|{
if|if
condition|(
name|eap_copy_buf
argument_list|(
operator|&
name|sm
operator|->
name|eap_if
operator|.
name|eapReqData
argument_list|,
name|sm
operator|->
name|lastReqData
argument_list|)
operator|==
literal|0
condition|)
name|sm
operator|->
name|eap_if
operator|.
name|eapReq
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|SM_STATE
argument_list|(
argument|EAP
argument_list|,
argument|RECEIVED2
argument_list|)
end_macro

begin_block
block|{
name|SM_ENTRY
argument_list|(
name|EAP
argument_list|,
name|RECEIVED2
argument_list|)
expr_stmt|;
comment|/* parse rxResp, respId, respMethod */
name|eap_sm_parseEapResp
argument_list|(
name|sm
argument_list|,
name|sm
operator|->
name|eap_if
operator|.
name|eapRespData
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|SM_STATE
argument_list|(
argument|EAP
argument_list|,
argument|DISCARD2
argument_list|)
end_macro

begin_block
block|{
name|SM_ENTRY
argument_list|(
name|EAP
argument_list|,
name|DISCARD2
argument_list|)
expr_stmt|;
name|sm
operator|->
name|eap_if
operator|.
name|eapResp
operator|=
name|FALSE
expr_stmt|;
name|sm
operator|->
name|eap_if
operator|.
name|eapNoReq
operator|=
name|TRUE
expr_stmt|;
block|}
end_block

begin_macro
name|SM_STATE
argument_list|(
argument|EAP
argument_list|,
argument|SEND_REQUEST2
argument_list|)
end_macro

begin_block
block|{
name|SM_ENTRY
argument_list|(
name|EAP
argument_list|,
name|SEND_REQUEST2
argument_list|)
expr_stmt|;
name|sm
operator|->
name|retransCount
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|eap_if
operator|.
name|eapReqData
condition|)
block|{
if|if
condition|(
name|eap_copy_buf
argument_list|(
operator|&
name|sm
operator|->
name|lastReqData
argument_list|,
name|sm
operator|->
name|eap_if
operator|.
name|eapReqData
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sm
operator|->
name|eap_if
operator|.
name|eapResp
operator|=
name|FALSE
expr_stmt|;
name|sm
operator|->
name|eap_if
operator|.
name|eapReq
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|sm
operator|->
name|eap_if
operator|.
name|eapResp
operator|=
name|FALSE
expr_stmt|;
name|sm
operator|->
name|eap_if
operator|.
name|eapReq
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
else|else
block|{
name|wpa_printf
argument_list|(
name|MSG_INFO
argument_list|,
literal|"EAP: SEND_REQUEST2 - no eapReqData"
argument_list|)
expr_stmt|;
name|sm
operator|->
name|eap_if
operator|.
name|eapResp
operator|=
name|FALSE
expr_stmt|;
name|sm
operator|->
name|eap_if
operator|.
name|eapReq
operator|=
name|FALSE
expr_stmt|;
name|sm
operator|->
name|eap_if
operator|.
name|eapNoReq
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|SM_STATE
argument_list|(
argument|EAP
argument_list|,
argument|AAA_REQUEST
argument_list|)
end_macro

begin_block
block|{
name|SM_ENTRY
argument_list|(
name|EAP
argument_list|,
name|AAA_REQUEST
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|eap_if
operator|.
name|eapRespData
operator|==
name|NULL
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_INFO
argument_list|,
literal|"EAP: AAA_REQUEST - no eapRespData"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * if (respMethod == IDENTITY) 	 *	aaaIdentity = eapRespData 	 * This is already taken care of by the EAP-Identity method which 	 * stores the identity into sm->identity. 	 */
name|eap_copy_buf
argument_list|(
operator|&
name|sm
operator|->
name|eap_if
operator|.
name|aaaEapRespData
argument_list|,
name|sm
operator|->
name|eap_if
operator|.
name|eapRespData
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|SM_STATE
argument_list|(
argument|EAP
argument_list|,
argument|AAA_RESPONSE
argument_list|)
end_macro

begin_block
block|{
name|SM_ENTRY
argument_list|(
name|EAP
argument_list|,
name|AAA_RESPONSE
argument_list|)
expr_stmt|;
name|eap_copy_buf
argument_list|(
operator|&
name|sm
operator|->
name|eap_if
operator|.
name|eapReqData
argument_list|,
name|sm
operator|->
name|eap_if
operator|.
name|aaaEapReqData
argument_list|)
expr_stmt|;
name|sm
operator|->
name|currentId
operator|=
name|eap_sm_getId
argument_list|(
name|sm
operator|->
name|eap_if
operator|.
name|eapReqData
argument_list|)
expr_stmt|;
name|sm
operator|->
name|methodTimeout
operator|=
name|sm
operator|->
name|eap_if
operator|.
name|aaaMethodTimeout
expr_stmt|;
block|}
end_block

begin_macro
name|SM_STATE
argument_list|(
argument|EAP
argument_list|,
argument|AAA_IDLE
argument_list|)
end_macro

begin_block
block|{
name|SM_ENTRY
argument_list|(
name|EAP
argument_list|,
name|AAA_IDLE
argument_list|)
expr_stmt|;
name|sm
operator|->
name|eap_if
operator|.
name|aaaFail
operator|=
name|FALSE
expr_stmt|;
name|sm
operator|->
name|eap_if
operator|.
name|aaaSuccess
operator|=
name|FALSE
expr_stmt|;
name|sm
operator|->
name|eap_if
operator|.
name|aaaEapReq
operator|=
name|FALSE
expr_stmt|;
name|sm
operator|->
name|eap_if
operator|.
name|aaaEapNoReq
operator|=
name|FALSE
expr_stmt|;
name|sm
operator|->
name|eap_if
operator|.
name|aaaEapResp
operator|=
name|TRUE
expr_stmt|;
block|}
end_block

begin_macro
name|SM_STATE
argument_list|(
argument|EAP
argument_list|,
argument|TIMEOUT_FAILURE2
argument_list|)
end_macro

begin_block
block|{
name|SM_ENTRY
argument_list|(
name|EAP
argument_list|,
name|TIMEOUT_FAILURE2
argument_list|)
expr_stmt|;
name|sm
operator|->
name|eap_if
operator|.
name|eapTimeout
operator|=
name|TRUE
expr_stmt|;
block|}
end_block

begin_macro
name|SM_STATE
argument_list|(
argument|EAP
argument_list|,
argument|FAILURE2
argument_list|)
end_macro

begin_block
block|{
name|SM_ENTRY
argument_list|(
name|EAP
argument_list|,
name|FAILURE2
argument_list|)
expr_stmt|;
name|eap_copy_buf
argument_list|(
operator|&
name|sm
operator|->
name|eap_if
operator|.
name|eapReqData
argument_list|,
name|sm
operator|->
name|eap_if
operator|.
name|aaaEapReqData
argument_list|)
expr_stmt|;
name|sm
operator|->
name|eap_if
operator|.
name|eapFail
operator|=
name|TRUE
expr_stmt|;
block|}
end_block

begin_macro
name|SM_STATE
argument_list|(
argument|EAP
argument_list|,
argument|SUCCESS2
argument_list|)
end_macro

begin_block
block|{
name|SM_ENTRY
argument_list|(
name|EAP
argument_list|,
name|SUCCESS2
argument_list|)
expr_stmt|;
name|eap_copy_buf
argument_list|(
operator|&
name|sm
operator|->
name|eap_if
operator|.
name|eapReqData
argument_list|,
name|sm
operator|->
name|eap_if
operator|.
name|aaaEapReqData
argument_list|)
expr_stmt|;
name|sm
operator|->
name|eap_if
operator|.
name|eapKeyAvailable
operator|=
name|sm
operator|->
name|eap_if
operator|.
name|aaaEapKeyAvailable
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|eap_if
operator|.
name|aaaEapKeyAvailable
condition|)
block|{
name|EAP_COPY
argument_list|(
operator|&
name|sm
operator|->
name|eap_if
operator|.
name|eapKeyData
argument_list|,
name|sm
operator|->
name|eap_if
operator|.
name|aaaEapKeyData
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|os_free
argument_list|(
name|sm
operator|->
name|eap_if
operator|.
name|eapKeyData
argument_list|)
expr_stmt|;
name|sm
operator|->
name|eap_if
operator|.
name|eapKeyData
operator|=
name|NULL
expr_stmt|;
name|sm
operator|->
name|eap_if
operator|.
name|eapKeyDataLen
operator|=
literal|0
expr_stmt|;
block|}
name|sm
operator|->
name|eap_if
operator|.
name|eapSuccess
operator|=
name|TRUE
expr_stmt|;
comment|/* 	 * Start reauthentication with identity request even though we know the 	 * previously used identity. This is needed to get reauthentication 	 * started properly. 	 */
name|sm
operator|->
name|start_reauth
operator|=
name|TRUE
expr_stmt|;
block|}
end_block

begin_macro
name|SM_STEP
argument_list|(
argument|EAP
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
name|sm
operator|->
name|eap_if
operator|.
name|eapRestart
operator|&&
name|sm
operator|->
name|eap_if
operator|.
name|portEnabled
condition|)
name|SM_ENTER_GLOBAL
argument_list|(
name|EAP
argument_list|,
name|INITIALIZE
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|sm
operator|->
name|eap_if
operator|.
name|portEnabled
condition|)
name|SM_ENTER_GLOBAL
argument_list|(
name|EAP
argument_list|,
name|DISABLED
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sm
operator|->
name|num_rounds
operator|>
name|EAP_MAX_AUTH_ROUNDS
condition|)
block|{
if|if
condition|(
name|sm
operator|->
name|num_rounds
operator|==
name|EAP_MAX_AUTH_ROUNDS
operator|+
literal|1
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: more than %d "
literal|"authentication rounds - abort"
argument_list|,
name|EAP_MAX_AUTH_ROUNDS
argument_list|)
expr_stmt|;
name|sm
operator|->
name|num_rounds
operator|++
expr_stmt|;
name|SM_ENTER_GLOBAL
argument_list|(
name|EAP
argument_list|,
name|FAILURE
argument_list|)
expr_stmt|;
block|}
block|}
else|else
switch|switch
condition|(
name|sm
operator|->
name|EAP_state
condition|)
block|{
case|case
name|EAP_INITIALIZE
case|:
if|if
condition|(
name|sm
operator|->
name|backend_auth
condition|)
block|{
if|if
condition|(
operator|!
name|sm
operator|->
name|rxResp
condition|)
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|SELECT_ACTION
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sm
operator|->
name|rxResp
operator|&&
operator|(
name|sm
operator|->
name|respMethod
operator|==
name|EAP_TYPE_NAK
operator|||
operator|(
name|sm
operator|->
name|respMethod
operator|==
name|EAP_TYPE_EXPANDED
operator|&&
name|sm
operator|->
name|respVendor
operator|==
name|EAP_VENDOR_IETF
operator|&&
name|sm
operator|->
name|respVendorMethod
operator|==
name|EAP_TYPE_NAK
operator|)
operator|)
condition|)
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|NAK
argument_list|)
expr_stmt|;
else|else
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|PICK_UP_METHOD
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|SELECT_ACTION
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|EAP_PICK_UP_METHOD
case|:
if|if
condition|(
name|sm
operator|->
name|currentMethod
operator|==
name|EAP_TYPE_NONE
condition|)
block|{
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|SELECT_ACTION
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|METHOD_RESPONSE
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|EAP_DISABLED
case|:
if|if
condition|(
name|sm
operator|->
name|eap_if
operator|.
name|portEnabled
condition|)
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|INITIALIZE
argument_list|)
expr_stmt|;
break|break;
case|case
name|EAP_IDLE
case|:
if|if
condition|(
name|sm
operator|->
name|eap_if
operator|.
name|retransWhile
operator|==
literal|0
condition|)
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|RETRANSMIT
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sm
operator|->
name|eap_if
operator|.
name|eapResp
condition|)
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|RECEIVED
argument_list|)
expr_stmt|;
break|break;
case|case
name|EAP_RETRANSMIT
case|:
if|if
condition|(
name|sm
operator|->
name|retransCount
operator|>
name|sm
operator|->
name|MaxRetrans
condition|)
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|TIMEOUT_FAILURE
argument_list|)
expr_stmt|;
else|else
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|IDLE
argument_list|)
expr_stmt|;
break|break;
case|case
name|EAP_RECEIVED
case|:
if|if
condition|(
name|sm
operator|->
name|rxResp
operator|&&
operator|(
name|sm
operator|->
name|respId
operator|==
name|sm
operator|->
name|currentId
operator|)
operator|&&
operator|(
name|sm
operator|->
name|respMethod
operator|==
name|EAP_TYPE_NAK
operator|||
operator|(
name|sm
operator|->
name|respMethod
operator|==
name|EAP_TYPE_EXPANDED
operator|&&
name|sm
operator|->
name|respVendor
operator|==
name|EAP_VENDOR_IETF
operator|&&
name|sm
operator|->
name|respVendorMethod
operator|==
name|EAP_TYPE_NAK
operator|)
operator|)
operator|&&
operator|(
name|sm
operator|->
name|methodState
operator|==
name|METHOD_PROPOSED
operator|)
condition|)
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|NAK
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sm
operator|->
name|rxResp
operator|&&
operator|(
name|sm
operator|->
name|respId
operator|==
name|sm
operator|->
name|currentId
operator|)
operator|&&
operator|(
operator|(
name|sm
operator|->
name|respMethod
operator|==
name|sm
operator|->
name|currentMethod
operator|)
operator|||
operator|(
name|sm
operator|->
name|respMethod
operator|==
name|EAP_TYPE_EXPANDED
operator|&&
name|sm
operator|->
name|respVendor
operator|==
name|EAP_VENDOR_IETF
operator|&&
name|sm
operator|->
name|respVendorMethod
operator|==
name|sm
operator|->
name|currentMethod
operator|)
operator|)
condition|)
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|INTEGRITY_CHECK
argument_list|)
expr_stmt|;
else|else
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: RECEIVED->DISCARD: "
literal|"rxResp=%d respId=%d currentId=%d "
literal|"respMethod=%d currentMethod=%d"
argument_list|,
name|sm
operator|->
name|rxResp
argument_list|,
name|sm
operator|->
name|respId
argument_list|,
name|sm
operator|->
name|currentId
argument_list|,
name|sm
operator|->
name|respMethod
argument_list|,
name|sm
operator|->
name|currentMethod
argument_list|)
expr_stmt|;
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|DISCARD
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|EAP_DISCARD
case|:
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|IDLE
argument_list|)
expr_stmt|;
break|break;
case|case
name|EAP_SEND_REQUEST
case|:
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|IDLE
argument_list|)
expr_stmt|;
break|break;
case|case
name|EAP_INTEGRITY_CHECK
case|:
if|if
condition|(
name|sm
operator|->
name|ignore
condition|)
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|DISCARD
argument_list|)
expr_stmt|;
else|else
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|METHOD_RESPONSE
argument_list|)
expr_stmt|;
break|break;
case|case
name|EAP_METHOD_REQUEST
case|:
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|SEND_REQUEST
argument_list|)
expr_stmt|;
break|break;
case|case
name|EAP_METHOD_RESPONSE
case|:
comment|/* 		 * Note: Mechanism to allow EAP methods to wait while going 		 * through pending processing is an extension to RFC 4137 		 * which only defines the transits to SELECT_ACTION and 		 * METHOD_REQUEST from this METHOD_RESPONSE state. 		 */
if|if
condition|(
name|sm
operator|->
name|methodState
operator|==
name|METHOD_END
condition|)
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|SELECT_ACTION
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sm
operator|->
name|method_pending
operator|==
name|METHOD_PENDING_WAIT
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: Method has pending "
literal|"processing - wait before proceeding to "
literal|"METHOD_REQUEST state"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sm
operator|->
name|method_pending
operator|==
name|METHOD_PENDING_CONT
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: Method has completed "
literal|"pending processing - reprocess pending "
literal|"EAP message"
argument_list|)
expr_stmt|;
name|sm
operator|->
name|method_pending
operator|=
name|METHOD_PENDING_NONE
expr_stmt|;
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|METHOD_RESPONSE
argument_list|)
expr_stmt|;
block|}
else|else
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|METHOD_REQUEST
argument_list|)
expr_stmt|;
break|break;
case|case
name|EAP_PROPOSE_METHOD
case|:
comment|/* 		 * Note: Mechanism to allow EAP methods to wait while going 		 * through pending processing is an extension to RFC 4137 		 * which only defines the transit to METHOD_REQUEST from this 		 * PROPOSE_METHOD state. 		 */
if|if
condition|(
name|sm
operator|->
name|method_pending
operator|==
name|METHOD_PENDING_WAIT
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: Method has pending "
literal|"processing - wait before proceeding to "
literal|"METHOD_REQUEST state"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|user_eap_method_index
operator|>
literal|0
condition|)
name|sm
operator|->
name|user_eap_method_index
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sm
operator|->
name|method_pending
operator|==
name|METHOD_PENDING_CONT
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: Method has completed "
literal|"pending processing - reprocess pending "
literal|"EAP message"
argument_list|)
expr_stmt|;
name|sm
operator|->
name|method_pending
operator|=
name|METHOD_PENDING_NONE
expr_stmt|;
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|PROPOSE_METHOD
argument_list|)
expr_stmt|;
block|}
else|else
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|METHOD_REQUEST
argument_list|)
expr_stmt|;
break|break;
case|case
name|EAP_NAK
case|:
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|SELECT_ACTION
argument_list|)
expr_stmt|;
break|break;
case|case
name|EAP_SELECT_ACTION
case|:
if|if
condition|(
name|sm
operator|->
name|decision
operator|==
name|DECISION_FAILURE
condition|)
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|FAILURE
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sm
operator|->
name|decision
operator|==
name|DECISION_SUCCESS
condition|)
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|SUCCESS
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sm
operator|->
name|decision
operator|==
name|DECISION_PASSTHROUGH
condition|)
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|INITIALIZE_PASSTHROUGH
argument_list|)
expr_stmt|;
else|else
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|PROPOSE_METHOD
argument_list|)
expr_stmt|;
break|break;
case|case
name|EAP_TIMEOUT_FAILURE
case|:
break|break;
case|case
name|EAP_FAILURE
case|:
break|break;
case|case
name|EAP_SUCCESS
case|:
break|break;
case|case
name|EAP_INITIALIZE_PASSTHROUGH
case|:
if|if
condition|(
name|sm
operator|->
name|currentId
operator|==
operator|-
literal|1
condition|)
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|AAA_IDLE
argument_list|)
expr_stmt|;
else|else
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|AAA_REQUEST
argument_list|)
expr_stmt|;
break|break;
case|case
name|EAP_IDLE2
case|:
if|if
condition|(
name|sm
operator|->
name|eap_if
operator|.
name|eapResp
condition|)
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|RECEIVED2
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sm
operator|->
name|eap_if
operator|.
name|retransWhile
operator|==
literal|0
condition|)
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|RETRANSMIT2
argument_list|)
expr_stmt|;
break|break;
case|case
name|EAP_RETRANSMIT2
case|:
if|if
condition|(
name|sm
operator|->
name|retransCount
operator|>
name|sm
operator|->
name|MaxRetrans
condition|)
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|TIMEOUT_FAILURE2
argument_list|)
expr_stmt|;
else|else
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|IDLE2
argument_list|)
expr_stmt|;
break|break;
case|case
name|EAP_RECEIVED2
case|:
if|if
condition|(
name|sm
operator|->
name|rxResp
operator|&&
operator|(
name|sm
operator|->
name|respId
operator|==
name|sm
operator|->
name|currentId
operator|)
condition|)
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|AAA_REQUEST
argument_list|)
expr_stmt|;
else|else
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|DISCARD2
argument_list|)
expr_stmt|;
break|break;
case|case
name|EAP_DISCARD2
case|:
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|IDLE2
argument_list|)
expr_stmt|;
break|break;
case|case
name|EAP_SEND_REQUEST2
case|:
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|IDLE2
argument_list|)
expr_stmt|;
break|break;
case|case
name|EAP_AAA_REQUEST
case|:
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|AAA_IDLE
argument_list|)
expr_stmt|;
break|break;
case|case
name|EAP_AAA_RESPONSE
case|:
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|SEND_REQUEST2
argument_list|)
expr_stmt|;
break|break;
case|case
name|EAP_AAA_IDLE
case|:
if|if
condition|(
name|sm
operator|->
name|eap_if
operator|.
name|aaaFail
condition|)
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|FAILURE2
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sm
operator|->
name|eap_if
operator|.
name|aaaSuccess
condition|)
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|SUCCESS2
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sm
operator|->
name|eap_if
operator|.
name|aaaEapReq
condition|)
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|AAA_RESPONSE
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sm
operator|->
name|eap_if
operator|.
name|aaaTimeout
condition|)
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|TIMEOUT_FAILURE2
argument_list|)
expr_stmt|;
break|break;
case|case
name|EAP_TIMEOUT_FAILURE2
case|:
break|break;
case|case
name|EAP_FAILURE2
case|:
break|break;
case|case
name|EAP_SUCCESS2
case|:
break|break;
block|}
block|}
end_block

begin_function
specifier|static
name|int
name|eap_sm_calculateTimeout
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|int
name|retransCount
parameter_list|,
name|int
name|eapSRTT
parameter_list|,
name|int
name|eapRTTVAR
parameter_list|,
name|int
name|methodTimeout
parameter_list|)
block|{
name|int
name|rto
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
name|methodTimeout
condition|)
block|{
comment|/* 		 * EAP method (either internal or through AAA server, provided 		 * timeout hint. Use that as-is as a timeout for retransmitting 		 * the EAP request if no response is received. 		 */
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: retransmit timeout %d seconds "
literal|"(from EAP method hint)"
argument_list|,
name|methodTimeout
argument_list|)
expr_stmt|;
return|return
name|methodTimeout
return|;
block|}
comment|/* 	 * RFC 3748 recommends algorithms described in RFC 2988 for estimation 	 * of the retransmission timeout. This should be implemented once 	 * round-trip time measurements are available. For nowm a simple 	 * backoff mechanism is used instead if there are no EAP method 	 * specific hints. 	 * 	 * SRTT = smoothed round-trip time 	 * RTTVAR = round-trip time variation 	 * RTO = retransmission timeout 	 */
comment|/* 	 * RFC 2988, 2.1: before RTT measurement, set RTO to 3 seconds for 	 * initial retransmission and then double the RTO to provide back off 	 * per 5.5. Limit the maximum RTO to 20 seconds per RFC 3748, 4.3 	 * modified RTOmax. 	 */
name|rto
operator|=
literal|3
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|retransCount
condition|;
name|i
operator|++
control|)
block|{
name|rto
operator|*=
literal|2
expr_stmt|;
if|if
condition|(
name|rto
operator|>=
literal|20
condition|)
block|{
name|rto
operator|=
literal|20
expr_stmt|;
break|break;
block|}
block|}
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: retransmit timeout %d seconds "
literal|"(from dynamic back off; retransCount=%d)"
argument_list|,
name|rto
argument_list|,
name|retransCount
argument_list|)
expr_stmt|;
return|return
name|rto
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|eap_sm_parseEapResp
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
specifier|const
name|struct
name|wpabuf
modifier|*
name|resp
parameter_list|)
block|{
specifier|const
name|struct
name|eap_hdr
modifier|*
name|hdr
decl_stmt|;
name|size_t
name|plen
decl_stmt|;
comment|/* parse rxResp, respId, respMethod */
name|sm
operator|->
name|rxResp
operator|=
name|FALSE
expr_stmt|;
name|sm
operator|->
name|respId
operator|=
operator|-
literal|1
expr_stmt|;
name|sm
operator|->
name|respMethod
operator|=
name|EAP_TYPE_NONE
expr_stmt|;
name|sm
operator|->
name|respVendor
operator|=
name|EAP_VENDOR_IETF
expr_stmt|;
name|sm
operator|->
name|respVendorMethod
operator|=
name|EAP_TYPE_NONE
expr_stmt|;
if|if
condition|(
name|resp
operator|==
name|NULL
operator|||
name|wpabuf_len
argument_list|(
name|resp
argument_list|)
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: parseEapResp: invalid resp=%p "
literal|"len=%lu"
argument_list|,
name|resp
argument_list|,
name|resp
condition|?
operator|(
name|unsigned
name|long
operator|)
name|wpabuf_len
argument_list|(
name|resp
argument_list|)
else|:
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
name|hdr
operator|=
name|wpabuf_head
argument_list|(
name|resp
argument_list|)
expr_stmt|;
name|plen
operator|=
name|be_to_host16
argument_list|(
name|hdr
operator|->
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|plen
operator|>
name|wpabuf_len
argument_list|(
name|resp
argument_list|)
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: Ignored truncated EAP-Packet "
literal|"(len=%lu plen=%lu)"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|wpabuf_len
argument_list|(
name|resp
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|plen
argument_list|)
expr_stmt|;
return|return;
block|}
name|sm
operator|->
name|respId
operator|=
name|hdr
operator|->
name|identifier
expr_stmt|;
if|if
condition|(
name|hdr
operator|->
name|code
operator|==
name|EAP_CODE_RESPONSE
condition|)
name|sm
operator|->
name|rxResp
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|plen
operator|>
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
condition|)
block|{
name|u8
modifier|*
name|pos
init|=
operator|(
name|u8
operator|*
operator|)
operator|(
name|hdr
operator|+
literal|1
operator|)
decl_stmt|;
name|sm
operator|->
name|respMethod
operator|=
operator|*
name|pos
operator|++
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|respMethod
operator|==
name|EAP_TYPE_EXPANDED
condition|)
block|{
if|if
condition|(
name|plen
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
operator|+
literal|8
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: Ignored truncated "
literal|"expanded EAP-Packet (plen=%lu)"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|plen
argument_list|)
expr_stmt|;
return|return;
block|}
name|sm
operator|->
name|respVendor
operator|=
name|WPA_GET_BE24
argument_list|(
name|pos
argument_list|)
expr_stmt|;
name|pos
operator|+=
literal|3
expr_stmt|;
name|sm
operator|->
name|respVendorMethod
operator|=
name|WPA_GET_BE32
argument_list|(
name|pos
argument_list|)
expr_stmt|;
block|}
block|}
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: parseEapResp: rxResp=%d respId=%d "
literal|"respMethod=%u respVendor=%u respVendorMethod=%u"
argument_list|,
name|sm
operator|->
name|rxResp
argument_list|,
name|sm
operator|->
name|respId
argument_list|,
name|sm
operator|->
name|respMethod
argument_list|,
name|sm
operator|->
name|respVendor
argument_list|,
name|sm
operator|->
name|respVendorMethod
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|eap_sm_getId
parameter_list|(
specifier|const
name|struct
name|wpabuf
modifier|*
name|data
parameter_list|)
block|{
specifier|const
name|struct
name|eap_hdr
modifier|*
name|hdr
decl_stmt|;
if|if
condition|(
name|data
operator|==
name|NULL
operator|||
name|wpabuf_len
argument_list|(
name|data
argument_list|)
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|hdr
operator|=
name|wpabuf_head
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: getId: id=%d"
argument_list|,
name|hdr
operator|->
name|identifier
argument_list|)
expr_stmt|;
return|return
name|hdr
operator|->
name|identifier
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|wpabuf
modifier|*
name|eap_sm_buildSuccess
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|u8
name|id
parameter_list|)
block|{
name|struct
name|wpabuf
modifier|*
name|msg
decl_stmt|;
name|struct
name|eap_hdr
modifier|*
name|resp
decl_stmt|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: Building EAP-Success (id=%d)"
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|msg
operator|=
name|wpabuf_alloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|resp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|resp
operator|=
name|wpabuf_put
argument_list|(
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|resp
argument_list|)
argument_list|)
expr_stmt|;
name|resp
operator|->
name|code
operator|=
name|EAP_CODE_SUCCESS
expr_stmt|;
name|resp
operator|->
name|identifier
operator|=
name|id
expr_stmt|;
name|resp
operator|->
name|length
operator|=
name|host_to_be16
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|resp
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|msg
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|wpabuf
modifier|*
name|eap_sm_buildFailure
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|u8
name|id
parameter_list|)
block|{
name|struct
name|wpabuf
modifier|*
name|msg
decl_stmt|;
name|struct
name|eap_hdr
modifier|*
name|resp
decl_stmt|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: Building EAP-Failure (id=%d)"
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|msg
operator|=
name|wpabuf_alloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|resp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|resp
operator|=
name|wpabuf_put
argument_list|(
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|resp
argument_list|)
argument_list|)
expr_stmt|;
name|resp
operator|->
name|code
operator|=
name|EAP_CODE_FAILURE
expr_stmt|;
name|resp
operator|->
name|identifier
operator|=
name|id
expr_stmt|;
name|resp
operator|->
name|length
operator|=
name|host_to_be16
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|resp
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|msg
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|eap_sm_nextId
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|int
name|id
parameter_list|)
block|{
if|if
condition|(
name|id
operator|<
literal|0
condition|)
block|{
comment|/* RFC 3748 Ch 4.1: recommended to initialize Identifier with a 		 * random number */
name|id
operator|=
name|rand
argument_list|()
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
name|id
operator|!=
name|sm
operator|->
name|lastId
condition|)
return|return
name|id
return|;
block|}
return|return
operator|(
name|id
operator|+
literal|1
operator|)
operator|&
literal|0xff
return|;
block|}
end_function

begin_comment
comment|/**  * eap_sm_process_nak - Process EAP-Response/Nak  * @sm: Pointer to EAP state machine allocated with eap_server_sm_init()  * @nak_list: Nak list (allowed methods) from the supplicant  * @len: Length of nak_list in bytes  *  * This function is called when EAP-Response/Nak is received from the  * supplicant. This can happen for both phase 1 and phase 2 authentications.  */
end_comment

begin_function
name|void
name|eap_sm_process_nak
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
specifier|const
name|u8
modifier|*
name|nak_list
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|size_t
name|j
decl_stmt|;
if|if
condition|(
name|sm
operator|->
name|user
operator|==
name|NULL
condition|)
return|return;
name|wpa_printf
argument_list|(
name|MSG_MSGDUMP
argument_list|,
literal|"EAP: processing NAK (current EAP method "
literal|"index %d)"
argument_list|,
name|sm
operator|->
name|user_eap_method_index
argument_list|)
expr_stmt|;
name|wpa_hexdump
argument_list|(
name|MSG_MSGDUMP
argument_list|,
literal|"EAP: configured methods"
argument_list|,
operator|(
name|u8
operator|*
operator|)
name|sm
operator|->
name|user
operator|->
name|methods
argument_list|,
name|EAP_MAX_METHODS
operator|*
sizeof|sizeof
argument_list|(
name|sm
operator|->
name|user
operator|->
name|methods
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|wpa_hexdump
argument_list|(
name|MSG_MSGDUMP
argument_list|,
literal|"EAP: list of methods supported by the peer"
argument_list|,
name|nak_list
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|i
operator|=
name|sm
operator|->
name|user_eap_method_index
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|EAP_MAX_METHODS
operator|&&
operator|(
name|sm
operator|->
name|user
operator|->
name|methods
index|[
name|i
index|]
operator|.
name|vendor
operator|!=
name|EAP_VENDOR_IETF
operator|||
name|sm
operator|->
name|user
operator|->
name|methods
index|[
name|i
index|]
operator|.
name|method
operator|!=
name|EAP_TYPE_NONE
operator|)
condition|)
block|{
if|if
condition|(
name|sm
operator|->
name|user
operator|->
name|methods
index|[
name|i
index|]
operator|.
name|vendor
operator|!=
name|EAP_VENDOR_IETF
condition|)
goto|goto
name|not_found
goto|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|len
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|nak_list
index|[
name|j
index|]
operator|==
name|sm
operator|->
name|user
operator|->
name|methods
index|[
name|i
index|]
operator|.
name|method
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|j
operator|<
name|len
condition|)
block|{
comment|/* found */
name|i
operator|++
expr_stmt|;
continue|continue;
block|}
name|not_found
label|:
comment|/* not found - remove from the list */
if|if
condition|(
name|i
operator|+
literal|1
operator|<
name|EAP_MAX_METHODS
condition|)
block|{
name|os_memmove
argument_list|(
operator|&
name|sm
operator|->
name|user
operator|->
name|methods
index|[
name|i
index|]
argument_list|,
operator|&
name|sm
operator|->
name|user
operator|->
name|methods
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
operator|(
name|EAP_MAX_METHODS
operator|-
name|i
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|sm
operator|->
name|user
operator|->
name|methods
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|sm
operator|->
name|user
operator|->
name|methods
index|[
name|EAP_MAX_METHODS
operator|-
literal|1
index|]
operator|.
name|vendor
operator|=
name|EAP_VENDOR_IETF
expr_stmt|;
name|sm
operator|->
name|user
operator|->
name|methods
index|[
name|EAP_MAX_METHODS
operator|-
literal|1
index|]
operator|.
name|method
operator|=
name|EAP_TYPE_NONE
expr_stmt|;
block|}
name|wpa_hexdump
argument_list|(
name|MSG_MSGDUMP
argument_list|,
literal|"EAP: new list of configured methods"
argument_list|,
operator|(
name|u8
operator|*
operator|)
name|sm
operator|->
name|user
operator|->
name|methods
argument_list|,
name|EAP_MAX_METHODS
operator|*
sizeof|sizeof
argument_list|(
name|sm
operator|->
name|user
operator|->
name|methods
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|eap_sm_Policy_update
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
specifier|const
name|u8
modifier|*
name|nak_list
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
if|if
condition|(
name|nak_list
operator|==
name|NULL
operator|||
name|sm
operator|==
name|NULL
operator|||
name|sm
operator|->
name|user
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|sm
operator|->
name|user
operator|->
name|phase2
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: EAP-Nak received after Phase2 user"
literal|" info was selected - reject"
argument_list|)
expr_stmt|;
name|sm
operator|->
name|decision
operator|=
name|DECISION_FAILURE
expr_stmt|;
return|return;
block|}
name|eap_sm_process_nak
argument_list|(
name|sm
argument_list|,
name|nak_list
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|EapType
name|eap_sm_Policy_getNextMethod
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|int
modifier|*
name|vendor
parameter_list|)
block|{
name|EapType
name|next
decl_stmt|;
name|int
name|idx
init|=
name|sm
operator|->
name|user_eap_method_index
decl_stmt|;
comment|/* In theory, there should be no problems with starting 	 * re-authentication with something else than EAP-Request/Identity and 	 * this does indeed work with wpa_supplicant. However, at least Funk 	 * Supplicant seemed to ignore re-auth if it skipped 	 * EAP-Request/Identity. 	 * Re-auth sets currentId == -1, so that can be used here to select 	 * whether Identity needs to be requested again. */
if|if
condition|(
name|sm
operator|->
name|identity
operator|==
name|NULL
operator|||
name|sm
operator|->
name|currentId
operator|==
operator|-
literal|1
condition|)
block|{
operator|*
name|vendor
operator|=
name|EAP_VENDOR_IETF
expr_stmt|;
name|next
operator|=
name|EAP_TYPE_IDENTITY
expr_stmt|;
name|sm
operator|->
name|update_user
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sm
operator|->
name|user
operator|&&
name|idx
operator|<
name|EAP_MAX_METHODS
operator|&&
operator|(
name|sm
operator|->
name|user
operator|->
name|methods
index|[
name|idx
index|]
operator|.
name|vendor
operator|!=
name|EAP_VENDOR_IETF
operator|||
name|sm
operator|->
name|user
operator|->
name|methods
index|[
name|idx
index|]
operator|.
name|method
operator|!=
name|EAP_TYPE_NONE
operator|)
condition|)
block|{
operator|*
name|vendor
operator|=
name|sm
operator|->
name|user
operator|->
name|methods
index|[
name|idx
index|]
operator|.
name|vendor
expr_stmt|;
name|next
operator|=
name|sm
operator|->
name|user
operator|->
name|methods
index|[
name|idx
index|]
operator|.
name|method
expr_stmt|;
name|sm
operator|->
name|user_eap_method_index
operator|++
expr_stmt|;
block|}
else|else
block|{
operator|*
name|vendor
operator|=
name|EAP_VENDOR_IETF
expr_stmt|;
name|next
operator|=
name|EAP_TYPE_NONE
expr_stmt|;
block|}
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: getNextMethod: vendor %d type %d"
argument_list|,
operator|*
name|vendor
argument_list|,
name|next
argument_list|)
expr_stmt|;
return|return
name|next
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|eap_sm_Policy_getDecision
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|)
block|{
if|if
condition|(
operator|!
name|sm
operator|->
name|eap_server
operator|&&
name|sm
operator|->
name|identity
operator|&&
operator|!
name|sm
operator|->
name|start_reauth
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: getDecision: -> PASSTHROUGH"
argument_list|)
expr_stmt|;
return|return
name|DECISION_PASSTHROUGH
return|;
block|}
if|if
condition|(
name|sm
operator|->
name|m
operator|&&
name|sm
operator|->
name|currentMethod
operator|!=
name|EAP_TYPE_IDENTITY
operator|&&
name|sm
operator|->
name|m
operator|->
name|isSuccess
argument_list|(
name|sm
argument_list|,
name|sm
operator|->
name|eap_method_priv
argument_list|)
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: getDecision: method succeeded -> "
literal|"SUCCESS"
argument_list|)
expr_stmt|;
name|sm
operator|->
name|update_user
operator|=
name|TRUE
expr_stmt|;
return|return
name|DECISION_SUCCESS
return|;
block|}
if|if
condition|(
name|sm
operator|->
name|m
operator|&&
name|sm
operator|->
name|m
operator|->
name|isDone
argument_list|(
name|sm
argument_list|,
name|sm
operator|->
name|eap_method_priv
argument_list|)
operator|&&
operator|!
name|sm
operator|->
name|m
operator|->
name|isSuccess
argument_list|(
name|sm
argument_list|,
name|sm
operator|->
name|eap_method_priv
argument_list|)
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: getDecision: method failed -> "
literal|"FAILURE"
argument_list|)
expr_stmt|;
name|sm
operator|->
name|update_user
operator|=
name|TRUE
expr_stmt|;
return|return
name|DECISION_FAILURE
return|;
block|}
if|if
condition|(
operator|(
name|sm
operator|->
name|user
operator|==
name|NULL
operator|||
name|sm
operator|->
name|update_user
operator|)
operator|&&
name|sm
operator|->
name|identity
operator|&&
operator|!
name|sm
operator|->
name|start_reauth
condition|)
block|{
comment|/* 		 * Allow Identity method to be started once to allow identity 		 * selection hint to be sent from the authentication server, 		 * but prevent a loop of Identity requests by only allowing 		 * this to happen once. 		 */
name|int
name|id_req
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|sm
operator|->
name|user
operator|&&
name|sm
operator|->
name|currentMethod
operator|==
name|EAP_TYPE_IDENTITY
operator|&&
name|sm
operator|->
name|user
operator|->
name|methods
index|[
literal|0
index|]
operator|.
name|vendor
operator|==
name|EAP_VENDOR_IETF
operator|&&
name|sm
operator|->
name|user
operator|->
name|methods
index|[
literal|0
index|]
operator|.
name|method
operator|==
name|EAP_TYPE_IDENTITY
condition|)
name|id_req
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|eap_user_get
argument_list|(
name|sm
argument_list|,
name|sm
operator|->
name|identity
argument_list|,
name|sm
operator|->
name|identity_len
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: getDecision: user not "
literal|"found from database -> FAILURE"
argument_list|)
expr_stmt|;
return|return
name|DECISION_FAILURE
return|;
block|}
if|if
condition|(
name|id_req
operator|&&
name|sm
operator|->
name|user
operator|&&
name|sm
operator|->
name|user
operator|->
name|methods
index|[
literal|0
index|]
operator|.
name|vendor
operator|==
name|EAP_VENDOR_IETF
operator|&&
name|sm
operator|->
name|user
operator|->
name|methods
index|[
literal|0
index|]
operator|.
name|method
operator|==
name|EAP_TYPE_IDENTITY
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: getDecision: stop "
literal|"identity request loop -> FAILURE"
argument_list|)
expr_stmt|;
name|sm
operator|->
name|update_user
operator|=
name|TRUE
expr_stmt|;
return|return
name|DECISION_FAILURE
return|;
block|}
name|sm
operator|->
name|update_user
operator|=
name|FALSE
expr_stmt|;
block|}
name|sm
operator|->
name|start_reauth
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|user
operator|&&
name|sm
operator|->
name|user_eap_method_index
operator|<
name|EAP_MAX_METHODS
operator|&&
operator|(
name|sm
operator|->
name|user
operator|->
name|methods
index|[
name|sm
operator|->
name|user_eap_method_index
index|]
operator|.
name|vendor
operator|!=
name|EAP_VENDOR_IETF
operator|||
name|sm
operator|->
name|user
operator|->
name|methods
index|[
name|sm
operator|->
name|user_eap_method_index
index|]
operator|.
name|method
operator|!=
name|EAP_TYPE_NONE
operator|)
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: getDecision: another method "
literal|"available -> CONTINUE"
argument_list|)
expr_stmt|;
return|return
name|DECISION_CONTINUE
return|;
block|}
if|if
condition|(
name|sm
operator|->
name|identity
operator|==
name|NULL
operator|||
name|sm
operator|->
name|currentId
operator|==
operator|-
literal|1
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: getDecision: no identity known "
literal|"yet -> CONTINUE"
argument_list|)
expr_stmt|;
return|return
name|DECISION_CONTINUE
return|;
block|}
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: getDecision: no more methods available -> "
literal|"FAILURE"
argument_list|)
expr_stmt|;
return|return
name|DECISION_FAILURE
return|;
block|}
end_function

begin_function
specifier|static
name|Boolean
name|eap_sm_Policy_doPickUp
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|EapType
name|method
parameter_list|)
block|{
return|return
name|method
operator|==
name|EAP_TYPE_IDENTITY
condition|?
name|TRUE
else|:
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/**  * eap_server_sm_step - Step EAP server state machine  * @sm: Pointer to EAP state machine allocated with eap_server_sm_init()  * Returns: 1 if EAP state was changed or 0 if not  *  * This function advances EAP state machine to a new state to match with the  * current variables. This should be called whenever variables used by the EAP  * state machine have changed.  */
end_comment

begin_function
name|int
name|eap_server_sm_step
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|)
block|{
name|int
name|res
init|=
literal|0
decl_stmt|;
do|do
block|{
name|sm
operator|->
name|changed
operator|=
name|FALSE
expr_stmt|;
name|SM_STEP_RUN
argument_list|(
name|EAP
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|changed
condition|)
name|res
operator|=
literal|1
expr_stmt|;
block|}
do|while
condition|(
name|sm
operator|->
name|changed
condition|)
do|;
return|return
name|res
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|eap_user_free
parameter_list|(
name|struct
name|eap_user
modifier|*
name|user
parameter_list|)
block|{
if|if
condition|(
name|user
operator|==
name|NULL
condition|)
return|return;
name|os_free
argument_list|(
name|user
operator|->
name|password
argument_list|)
expr_stmt|;
name|user
operator|->
name|password
operator|=
name|NULL
expr_stmt|;
name|os_free
argument_list|(
name|user
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * eap_server_sm_init - Allocate and initialize EAP server state machine  * @eapol_ctx: Context data to be used with eapol_cb calls  * @eapol_cb: Pointer to EAPOL callback functions  * @conf: EAP configuration  * Returns: Pointer to the allocated EAP state machine or %NULL on failure  *  * This function allocates and initializes an EAP state machine.  */
end_comment

begin_function
name|struct
name|eap_sm
modifier|*
name|eap_server_sm_init
parameter_list|(
name|void
modifier|*
name|eapol_ctx
parameter_list|,
name|struct
name|eapol_callbacks
modifier|*
name|eapol_cb
parameter_list|,
name|struct
name|eap_config
modifier|*
name|conf
parameter_list|)
block|{
name|struct
name|eap_sm
modifier|*
name|sm
decl_stmt|;
name|sm
operator|=
name|os_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|sm
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|sm
operator|->
name|eapol_ctx
operator|=
name|eapol_ctx
expr_stmt|;
name|sm
operator|->
name|eapol_cb
operator|=
name|eapol_cb
expr_stmt|;
name|sm
operator|->
name|MaxRetrans
operator|=
literal|5
expr_stmt|;
comment|/* RFC 3748: max 3-5 retransmissions suggested */
name|sm
operator|->
name|ssl_ctx
operator|=
name|conf
operator|->
name|ssl_ctx
expr_stmt|;
name|sm
operator|->
name|msg_ctx
operator|=
name|conf
operator|->
name|msg_ctx
expr_stmt|;
name|sm
operator|->
name|eap_sim_db_priv
operator|=
name|conf
operator|->
name|eap_sim_db_priv
expr_stmt|;
name|sm
operator|->
name|backend_auth
operator|=
name|conf
operator|->
name|backend_auth
expr_stmt|;
name|sm
operator|->
name|eap_server
operator|=
name|conf
operator|->
name|eap_server
expr_stmt|;
if|if
condition|(
name|conf
operator|->
name|pac_opaque_encr_key
condition|)
block|{
name|sm
operator|->
name|pac_opaque_encr_key
operator|=
name|os_malloc
argument_list|(
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|pac_opaque_encr_key
condition|)
block|{
name|os_memcpy
argument_list|(
name|sm
operator|->
name|pac_opaque_encr_key
argument_list|,
name|conf
operator|->
name|pac_opaque_encr_key
argument_list|,
literal|16
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|conf
operator|->
name|eap_fast_a_id
condition|)
block|{
name|sm
operator|->
name|eap_fast_a_id
operator|=
name|os_malloc
argument_list|(
name|conf
operator|->
name|eap_fast_a_id_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|eap_fast_a_id
condition|)
block|{
name|os_memcpy
argument_list|(
name|sm
operator|->
name|eap_fast_a_id
argument_list|,
name|conf
operator|->
name|eap_fast_a_id
argument_list|,
name|conf
operator|->
name|eap_fast_a_id_len
argument_list|)
expr_stmt|;
name|sm
operator|->
name|eap_fast_a_id_len
operator|=
name|conf
operator|->
name|eap_fast_a_id_len
expr_stmt|;
block|}
block|}
if|if
condition|(
name|conf
operator|->
name|eap_fast_a_id_info
condition|)
name|sm
operator|->
name|eap_fast_a_id_info
operator|=
name|os_strdup
argument_list|(
name|conf
operator|->
name|eap_fast_a_id_info
argument_list|)
expr_stmt|;
name|sm
operator|->
name|eap_fast_prov
operator|=
name|conf
operator|->
name|eap_fast_prov
expr_stmt|;
name|sm
operator|->
name|pac_key_lifetime
operator|=
name|conf
operator|->
name|pac_key_lifetime
expr_stmt|;
name|sm
operator|->
name|pac_key_refresh_time
operator|=
name|conf
operator|->
name|pac_key_refresh_time
expr_stmt|;
name|sm
operator|->
name|eap_sim_aka_result_ind
operator|=
name|conf
operator|->
name|eap_sim_aka_result_ind
expr_stmt|;
name|sm
operator|->
name|tnc
operator|=
name|conf
operator|->
name|tnc
expr_stmt|;
name|sm
operator|->
name|wps
operator|=
name|conf
operator|->
name|wps
expr_stmt|;
if|if
condition|(
name|conf
operator|->
name|assoc_wps_ie
condition|)
name|sm
operator|->
name|assoc_wps_ie
operator|=
name|wpabuf_dup
argument_list|(
name|conf
operator|->
name|assoc_wps_ie
argument_list|)
expr_stmt|;
if|if
condition|(
name|conf
operator|->
name|assoc_p2p_ie
condition|)
name|sm
operator|->
name|assoc_p2p_ie
operator|=
name|wpabuf_dup
argument_list|(
name|conf
operator|->
name|assoc_p2p_ie
argument_list|)
expr_stmt|;
if|if
condition|(
name|conf
operator|->
name|peer_addr
condition|)
name|os_memcpy
argument_list|(
name|sm
operator|->
name|peer_addr
argument_list|,
name|conf
operator|->
name|peer_addr
argument_list|,
name|ETH_ALEN
argument_list|)
expr_stmt|;
name|sm
operator|->
name|fragment_size
operator|=
name|conf
operator|->
name|fragment_size
expr_stmt|;
name|sm
operator|->
name|pwd_group
operator|=
name|conf
operator|->
name|pwd_group
expr_stmt|;
name|sm
operator|->
name|pbc_in_m1
operator|=
name|conf
operator|->
name|pbc_in_m1
expr_stmt|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: Server state machine created"
argument_list|)
expr_stmt|;
return|return
name|sm
return|;
block|}
end_function

begin_comment
comment|/**  * eap_server_sm_deinit - Deinitialize and free an EAP server state machine  * @sm: Pointer to EAP state machine allocated with eap_server_sm_init()  *  * This function deinitializes EAP state machine and frees all allocated  * resources.  */
end_comment

begin_function
name|void
name|eap_server_sm_deinit
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|)
block|{
if|if
condition|(
name|sm
operator|==
name|NULL
condition|)
return|return;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: Server state machine removed"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|m
operator|&&
name|sm
operator|->
name|eap_method_priv
condition|)
name|sm
operator|->
name|m
operator|->
name|reset
argument_list|(
name|sm
argument_list|,
name|sm
operator|->
name|eap_method_priv
argument_list|)
expr_stmt|;
name|wpabuf_free
argument_list|(
name|sm
operator|->
name|eap_if
operator|.
name|eapReqData
argument_list|)
expr_stmt|;
name|os_free
argument_list|(
name|sm
operator|->
name|eap_if
operator|.
name|eapKeyData
argument_list|)
expr_stmt|;
name|wpabuf_free
argument_list|(
name|sm
operator|->
name|lastReqData
argument_list|)
expr_stmt|;
name|wpabuf_free
argument_list|(
name|sm
operator|->
name|eap_if
operator|.
name|eapRespData
argument_list|)
expr_stmt|;
name|os_free
argument_list|(
name|sm
operator|->
name|identity
argument_list|)
expr_stmt|;
name|os_free
argument_list|(
name|sm
operator|->
name|pac_opaque_encr_key
argument_list|)
expr_stmt|;
name|os_free
argument_list|(
name|sm
operator|->
name|eap_fast_a_id
argument_list|)
expr_stmt|;
name|os_free
argument_list|(
name|sm
operator|->
name|eap_fast_a_id_info
argument_list|)
expr_stmt|;
name|wpabuf_free
argument_list|(
name|sm
operator|->
name|eap_if
operator|.
name|aaaEapReqData
argument_list|)
expr_stmt|;
name|wpabuf_free
argument_list|(
name|sm
operator|->
name|eap_if
operator|.
name|aaaEapRespData
argument_list|)
expr_stmt|;
name|os_free
argument_list|(
name|sm
operator|->
name|eap_if
operator|.
name|aaaEapKeyData
argument_list|)
expr_stmt|;
name|eap_user_free
argument_list|(
name|sm
operator|->
name|user
argument_list|)
expr_stmt|;
name|wpabuf_free
argument_list|(
name|sm
operator|->
name|assoc_wps_ie
argument_list|)
expr_stmt|;
name|wpabuf_free
argument_list|(
name|sm
operator|->
name|assoc_p2p_ie
argument_list|)
expr_stmt|;
name|os_free
argument_list|(
name|sm
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * eap_sm_notify_cached - Notify EAP state machine of cached PMK  * @sm: Pointer to EAP state machine allocated with eap_server_sm_init()  *  * This function is called when PMKSA caching is used to skip EAP  * authentication.  */
end_comment

begin_function
name|void
name|eap_sm_notify_cached
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|)
block|{
if|if
condition|(
name|sm
operator|==
name|NULL
condition|)
return|return;
name|sm
operator|->
name|EAP_state
operator|=
name|EAP_SUCCESS
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * eap_sm_pending_cb - EAP state machine callback for a pending EAP request  * @sm: Pointer to EAP state machine allocated with eap_server_sm_init()  *  * This function is called when data for a pending EAP-Request is received.  */
end_comment

begin_function
name|void
name|eap_sm_pending_cb
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|)
block|{
if|if
condition|(
name|sm
operator|==
name|NULL
condition|)
return|return;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: Callback for pending request received"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|method_pending
operator|==
name|METHOD_PENDING_WAIT
condition|)
name|sm
operator|->
name|method_pending
operator|=
name|METHOD_PENDING_CONT
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * eap_sm_method_pending - Query whether EAP method is waiting for pending data  * @sm: Pointer to EAP state machine allocated with eap_server_sm_init()  * Returns: 1 if method is waiting for pending data or 0 if not  */
end_comment

begin_function
name|int
name|eap_sm_method_pending
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|)
block|{
if|if
condition|(
name|sm
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
return|return
name|sm
operator|->
name|method_pending
operator|==
name|METHOD_PENDING_WAIT
return|;
block|}
end_function

begin_comment
comment|/**  * eap_get_identity - Get the user identity (from EAP-Response/Identity)  * @sm: Pointer to EAP state machine allocated with eap_server_sm_init()  * @len: Buffer for returning identity length  * Returns: Pointer to the user identity or %NULL if not available  */
end_comment

begin_function
specifier|const
name|u8
modifier|*
name|eap_get_identity
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|size_t
modifier|*
name|len
parameter_list|)
block|{
operator|*
name|len
operator|=
name|sm
operator|->
name|identity_len
expr_stmt|;
return|return
name|sm
operator|->
name|identity
return|;
block|}
end_function

begin_comment
comment|/**  * eap_get_interface - Get pointer to EAP-EAPOL interface data  * @sm: Pointer to EAP state machine allocated with eap_server_sm_init()  * Returns: Pointer to the EAP-EAPOL interface data  */
end_comment

begin_function
name|struct
name|eap_eapol_interface
modifier|*
name|eap_get_interface
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|)
block|{
return|return
operator|&
name|sm
operator|->
name|eap_if
return|;
block|}
end_function

begin_comment
comment|/**  * eap_server_clear_identity - Clear EAP identity information  * @sm: Pointer to EAP state machine allocated with eap_server_sm_init()  *  * This function can be used to clear the EAP identity information in the EAP  * server context. This allows the EAP/Identity method to be used again after  * EAPOL-Start or EAPOL-Logoff.  */
end_comment

begin_function
name|void
name|eap_server_clear_identity
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|)
block|{
name|os_free
argument_list|(
name|sm
operator|->
name|identity
argument_list|)
expr_stmt|;
name|sm
operator|->
name|identity
operator|=
name|NULL
expr_stmt|;
block|}
end_function

end_unit

