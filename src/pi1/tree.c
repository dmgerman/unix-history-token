begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (c) 1979 Regents of the University of California */
end_comment

begin_empty
empty|#
end_empty

begin_comment
comment|/*  * pi - Pascal interpreter code translator  *  * Charles Haley, Bill Joy UCB  */
end_comment

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"0.h"
end_include

begin_comment
comment|/*  * TREE SPACE DECLARATIONS  */
end_comment

begin_struct
struct|struct
name|tr
block|{
name|int
modifier|*
name|tr_low
decl_stmt|;
name|int
modifier|*
name|tr_high
decl_stmt|;
block|}
name|ttab
index|[
name|MAXTREE
index|]
struct|,
modifier|*
name|tract
struct|;
end_struct

begin_decl_stmt
specifier|static
name|int
modifier|*
name|ltsnt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The variable space is the  * absolute base of the tree segments.  * (exactly the same as ttab[0].tr_low)  * Spacep is maintained to point at the  * beginning of the next tree slot to  * be allocated for use by the grammar.  * Spacep is used "extern" by the semantic  * actions in pas.y.  * The variable tract is maintained to point  * at the tree segment out of which we are  * allocating (the active segment).  */
end_comment

begin_decl_stmt
name|int
modifier|*
name|space
decl_stmt|,
modifier|*
name|spacep
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * TREENMAX is the maximum width  * in words that any tree node   * due to the way in which the parser uses  * the pointer spacep.  */
end_comment

begin_define
define|#
directive|define
name|TREENMAX
value|6
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|PI0
end_ifndef

begin_decl_stmt
name|int
name|trspace
index|[
name|ITREE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|space
name|trspace
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|spacep
name|trspace
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|struct
name|tr
modifier|*
name|tract
name|ttab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|treemax
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Inittree allocates the first tree slot  * and sets up the first segment descriptor.  * A lot of this work is actually done statically  * above.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|PI0
end_ifndef

begin_macro
name|inittree
argument_list|()
end_macro

begin_else
else|#
directive|else
end_else

begin_macro
name|inittree
argument_list|(
argument|trspace
argument_list|)
end_macro

begin_decl_stmt
name|int
modifier|*
name|trspace
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
ifdef|#
directive|ifdef
name|PI0
name|space
operator|=
name|spacep
operator|=
name|trspace
expr_stmt|;
endif|#
directive|endif
name|ttab
index|[
literal|0
index|]
operator|.
name|tr_low
operator|=
name|space
expr_stmt|;
name|ttab
index|[
literal|0
index|]
operator|.
name|tr_high
operator|=
operator|&
name|space
index|[
name|ITREE
operator|-
literal|1
index|]
expr_stmt|;
ifndef|#
directive|ifndef
name|PI1
name|ltsnt
operator|=
name|space
expr_stmt|;
endif|#
directive|endif
name|treemax
operator|=
name|ITREE
expr_stmt|;
operator|*
name|spacep
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_ifndef
ifndef|#
directive|ifndef
name|PI1
end_ifndef

begin_comment
comment|/*  * Tree builds the nodes in the  * parse tree. It is rarely called  * directly, rather calls are made  * to tree[12345] which supplies the  * first argument to save space in  * the code. Tree also guarantees  * that spacep points to the beginning  * of the next slot it will return,  * a property required by the parser  * which was always true before we  * segmented the tree space.  */
end_comment

begin_function
name|int
modifier|*
name|tree
parameter_list|(
name|cnt
parameter_list|,
name|a
parameter_list|)
name|int
name|cnt
decl_stmt|;
block|{
specifier|register
name|int
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|i
operator|=
name|cnt
expr_stmt|;
name|p
operator|=
name|spacep
expr_stmt|;
name|q
operator|=
operator|&
name|a
expr_stmt|;
do|do
operator|*
name|p
operator|++
operator|=
operator|*
name|q
operator|++
expr_stmt|;
do|while
condition|(
operator|--
name|i
condition|)
do|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
name|q
operator|=
name|spacep
expr_stmt|;
name|spacep
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|p
operator|+
name|TREENMAX
operator|>=
name|tract
operator|->
name|tr_high
condition|)
comment|/* 		 * this peek-ahead should 		 * save a great number of calls 		 * to tralloc. 		 */
name|tralloc
argument_list|(
name|TREENMAX
argument_list|)
expr_stmt|;
return|return
operator|(
name|q
operator|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_expr_stmt
name|treev
argument_list|(
name|i
argument_list|,
name|q
argument_list|)
specifier|register
name|int
name|i
operator|,
operator|*
name|q
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|spacep
expr_stmt|;
do|do
operator|*
name|p
operator|++
operator|=
operator|*
name|q
operator|++
expr_stmt|;
do|while
condition|(
operator|--
name|i
condition|)
do|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
name|q
operator|=
name|spacep
expr_stmt|;
name|spacep
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|p
operator|+
name|TREENMAX
operator|>=
name|tract
operator|->
name|tr_high
condition|)
name|tralloc
argument_list|(
name|TREENMAX
argument_list|)
expr_stmt|;
return|return
operator|(
name|q
operator|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Tralloc preallocates enough  * space in the tree to allow  * the grammar to use the variable  * spacep, as it did before the  * tree was segmented.  */
end_comment

begin_macro
name|tralloc
argument_list|(
argument|howmuch
argument_list|)
end_macro

begin_block
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|i
expr_stmt|;
if|if
condition|(
name|spacep
operator|+
name|howmuch
operator|>=
name|tract
operator|->
name|tr_high
condition|)
block|{
name|talloc
argument_list|(
operator|++
name|tract
argument_list|)
expr_stmt|;
name|spacep
operator|=
name|tract
operator|->
name|tr_low
expr_stmt|;
operator|*
name|spacep
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_block

begin_expr_stmt
name|talloc
argument_list|(
name|tp
argument_list|)
specifier|register
expr|struct
name|tr
operator|*
name|tp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|tp
operator|>=
operator|&
name|ttab
index|[
name|MAXTREE
index|]
condition|)
block|{
name|yerror
argument_list|(
literal|"Ran out of tree tables"
argument_list|)
expr_stmt|;
name|pexit
argument_list|(
name|DIED
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tp
operator|->
name|tr_low
operator|!=
name|NIL
condition|)
return|return;
name|cp
operator|=
name|alloc
argument_list|(
name|TRINC
operator|*
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
operator|-
literal|1
condition|)
block|{
name|yerror
argument_list|(
literal|"Ran out of memory (talloc)"
argument_list|)
expr_stmt|;
name|pexit
argument_list|(
name|DIED
argument_list|)
expr_stmt|;
block|}
name|tp
operator|->
name|tr_low
operator|=
name|cp
expr_stmt|;
name|tp
operator|->
name|tr_high
operator|=
name|tp
operator|->
name|tr_low
operator|+
operator|(
name|TRINC
operator|-
literal|1
operator|)
expr_stmt|;
name|i
operator|=
operator|(
name|tp
operator|-
name|ttab
operator|+
literal|1
operator|)
operator|*
name|TRINC
expr_stmt|;
if|if
condition|(
name|i
operator|>
name|treemax
condition|)
name|treemax
operator|=
name|i
expr_stmt|;
block|}
end_block

begin_ifndef
ifndef|#
directive|ifndef
name|PI1
end_ifndef

begin_decl_stmt
specifier|extern
name|int
name|yylacnt
decl_stmt|;
end_decl_stmt

begin_extern
extern|extern	bottled;
end_extern

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Free up the tree segments  * at the end of a block.  * If there is scanner lookahead,  * i.e. if yylacnt != 0 or there is bottled output, then we  * cannot free the tree space.  * This happens only when errors  * occur and the forward move extends  * across "units".  */
end_comment

begin_macro
name|trfree
argument_list|()
end_macro

begin_block
block|{
ifndef|#
directive|ifndef
name|PI1
if|if
condition|(
name|yylacnt
operator|!=
literal|0
operator|||
name|bottled
operator|!=
name|NIL
condition|)
return|return;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|PI1
name|send
argument_list|(
name|RTRFREE
argument_list|)
expr_stmt|;
name|ltsnt
operator|=
name|space
expr_stmt|;
endif|#
directive|endif
name|spacep
operator|=
name|space
expr_stmt|;
while|while
condition|(
name|tract
operator|->
name|tr_low
operator|>
name|spacep
operator|||
name|tract
operator|->
name|tr_high
operator|<=
name|spacep
condition|)
block|{
name|free
argument_list|(
name|tract
operator|->
name|tr_low
argument_list|)
expr_stmt|;
name|tract
operator|->
name|tr_low
operator|=
name|NIL
expr_stmt|;
name|tract
operator|->
name|tr_high
operator|=
name|NIL
expr_stmt|;
name|tract
operator|--
expr_stmt|;
if|if
condition|(
name|tract
operator|<
name|ttab
condition|)
name|panic
argument_list|(
literal|"ttab"
argument_list|)
expr_stmt|;
block|}
name|treemax
operator|=
name|ITREE
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Copystr copies a token from  * the "token" buffer into the  * tree space.  */
end_comment

begin_expr_stmt
name|copystr
argument_list|(
name|token
argument_list|)
specifier|register
name|char
operator|*
name|token
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|i
operator|=
operator|(
name|strlen
argument_list|(
name|token
argument_list|)
operator|+
literal|4
operator|)
operator|&
operator|~
literal|1
expr_stmt|;
name|tralloc
argument_list|(
name|i
operator|>>
literal|1
argument_list|)
expr_stmt|;
operator|*
name|spacep
operator|++
operator|=
name|T_COPSTR
expr_stmt|;
name|i
operator|=
operator|-
literal|2
expr_stmt|;
name|strcpy
argument_list|(
name|spacep
argument_list|,
name|token
argument_list|)
expr_stmt|;
name|cp
operator|=
name|spacep
expr_stmt|;
name|spacep
operator|=
name|cp
operator|+
name|i
expr_stmt|;
operator|*
name|spacep
operator|=
literal|0
expr_stmt|;
name|tralloc
argument_list|(
name|TREENMAX
argument_list|)
expr_stmt|;
return|return
operator|(
name|cp
operator|)
return|;
block|}
end_block

begin_comment
comment|/* actually needed in PI1 only if DEBUG... */
end_comment

begin_expr_stmt
name|toffset
argument_list|(
name|ap
argument_list|)
specifier|register
name|int
operator|*
name|ap
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|tr
modifier|*
name|tp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|ap
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|i
operator|=
name|TRINC
expr_stmt|;
for|for
control|(
name|tp
operator|=
name|ttab
init|;
name|tp
operator|->
name|tr_low
operator|!=
name|NIL
operator|&&
name|tp
operator|<
operator|&
name|ttab
index|[
name|MAXTREE
index|]
condition|;
name|tp
operator|++
control|)
block|{
if|if
condition|(
name|ap
operator|>=
name|tp
operator|->
name|tr_low
operator|&&
name|ap
operator|<
name|tp
operator|->
name|tr_high
condition|)
return|return
operator|(
name|i
operator|+
operator|(
name|ap
operator|-
name|tp
operator|->
name|tr_low
operator|)
operator|)
return|;
name|i
operator|=
operator|+
name|TRINC
expr_stmt|;
block|}
return|return
operator|(
operator|-
name|soffset
argument_list|(
name|ap
argument_list|)
operator|)
return|;
block|}
end_block

begin_ifndef
ifndef|#
directive|ifndef
name|PI1
end_ifndef

begin_macro
name|tsend
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|tr
modifier|*
name|trp
decl_stmt|;
specifier|register
name|int
modifier|*
name|ap
decl_stmt|;
name|ap
operator|=
name|ltsnt
expr_stmt|;
for|for
control|(
name|trp
operator|=
operator|&
name|ttab
index|[
operator|(
name|toffset
argument_list|(
name|ltsnt
argument_list|)
operator|/
name|TRINC
operator|)
operator|-
literal|1
index|]
init|;
name|trp
operator|<=
name|tract
condition|;
name|trp
operator|++
control|)
block|{
while|while
condition|(
name|ap
operator|<
name|trp
operator|->
name|tr_high
operator|&&
operator|*
name|ap
condition|)
name|ap
operator|=
name|send
argument_list|(
name|RTREE
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|ltsnt
operator|=
name|ap
expr_stmt|;
name|ap
operator|=
name|trp
index|[
literal|1
index|]
operator|.
name|tr_low
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
name|send
argument_list|(
name|RTRCHK
argument_list|,
name|toffset
argument_list|(
name|ltsnt
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|PI1
end_ifdef

begin_expr_stmt
name|treloc
argument_list|(
name|i
argument_list|)
specifier|register
name|int
name|i
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|i
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|i
operator|<
name|TRINC
condition|)
return|return
operator|(
name|sreloc
argument_list|(
operator|-
name|i
argument_list|)
operator|)
return|;
name|i
operator|=
operator|-
name|TRINC
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|treemax
condition|)
name|trmax
argument_list|(
name|i
argument_list|)
expr_stmt|;
return|return
operator|(
name|ttab
index|[
name|i
operator|/
name|TRINC
index|]
operator|.
name|tr_low
operator|+
name|i
operator|%
name|TRINC
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|trmax
argument_list|(
name|i
argument_list|)
specifier|register
name|int
name|i
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|tr
modifier|*
name|tp
decl_stmt|;
name|i
operator|=
operator|(
name|i
operator|+
name|TRINC
operator|)
operator|/
name|TRINC
expr_stmt|;
for|for
control|(
name|tp
operator|=
name|ttab
init|;
name|i
operator|>
literal|0
condition|;
name|tp
operator|++
operator|,
name|i
operator|--
control|)
name|talloc
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

end_unit

