begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * UPnP WPS Device  * Copyright (c) 2000-2003 Intel Corporation  * Copyright (c) 2006-2007 Sony Corporation  * Copyright (c) 2008-2009 Atheros Communications  * Copyright (c) 2009, Jouni Malinen<j@w1.fi>  *  * See below for more details on licensing and code history.  */
end_comment

begin_comment
comment|/*  * This has been greatly stripped down from the original file  * (upnp_wps_device.c) by Ted Merrill, Atheros Communications  * in order to eliminate use of the bulky libupnp library etc.  *  * History:  * upnp_wps_device.c is/was a shim layer between wps_opt_upnp.c and  * the libupnp library.  * The layering (by Sony) was well done; only a very minor modification  * to API of upnp_wps_device.c was required.  * libupnp was found to be undesirable because:  * -- It consumed too much code and data space  * -- It uses multiple threads, making debugging more difficult  *      and possibly reducing reliability.  * -- It uses static variables and only supports one instance.  * The shim and libupnp are here replaced by special code written  * specifically for the needs of hostapd.  * Various shortcuts can and are taken to keep the code size small.  * Generally, execution time is not as crucial.  *  * BUGS:  * -- UPnP requires that we be able to resolve domain names.  * While uncommon, if we have to do it then it will stall the entire  * hostapd program, which is bad.  * This is because we use the standard linux getaddrinfo() function  * which is syncronous.  * An asyncronous solution would be to use the free "ares" library.  * -- Does not have a robust output buffering scheme.  Uses a single  * fixed size output buffer per TCP/HTTP connection, with possible (although  * unlikely) possibility of overflow and likely excessive use of RAM.  * A better solution would be to write the HTTP output as a buffered stream,  * using chunking: (handle header specially, then) generate data with  * a printf-like function into a buffer, catching buffer full condition,  * then send it out surrounded by http chunking.  * -- There is some code that could be separated out into the common  * library to be shared with wpa_supplicant.  * -- Needs renaming with module prefix to avoid polluting the debugger  * namespace and causing possible collisions with other static fncs  * and structure declarations when using the debugger.  * -- Just what should be in the first event message sent after subscription  * for the WLANEvent field? If i pass it empty, Vista replies with OK  * but apparently barfs on the message.  * -- The http error code generation is pretty bogus, hopefully noone cares.  *  * Author: Ted Merrill, Atheros Communications, based upon earlier work  * as explained above and below.  *  * Copyright:  * Copyright 2008 Atheros Communications.  *  * The original header (of upnp_wps_device.c) reads:  *  *  Copyright (c) 2006-2007 Sony Corporation. All Rights Reserved.  *  *  File Name: upnp_wps_device.c  *  Description: EAP-WPS UPnP device source  *  *   Redistribution and use in source and binary forms, with or without  *   modification, are permitted provided that the following conditions  *   are met:  *  *     * Redistributions of source code must retain the above copyright  *       notice, this list of conditions and the following disclaimer.  *     * Redistributions in binary form must reproduce the above copyright  *       notice, this list of conditions and the following disclaimer in  *       the documentation and/or other materials provided with the  *       distribution.  *     * Neither the name of Sony Corporation nor the names of its  *       contributors may be used to endorse or promote products derived  *       from this software without specific prior written permission.  *  *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  *   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  *   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  *   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  *   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  *   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  *   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  *   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE  *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * Portions from Intel libupnp files, e.g. genlib/net/http/httpreadwrite.c  * typical header:  *  * Copyright (c) 2000-2003 Intel Corporation  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are met:  *  * * Redistributions of source code must retain the above copyright notice,  * this list of conditions and the following disclaimer.  * * Redistributions in binary form must reproduce the above copyright notice,  * this list of conditions and the following disclaimer in the documentation  * and/or other materials provided with the distribution.  * * Neither name of Intel Corporation nor the names of its contributors  * may be used to endorse or promote products derived from this software  * without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */
end_comment

begin_comment
comment|/*  * Overview of WPS over UPnP:  *  * UPnP is a protocol that allows devices to discover each other and control  * each other. In UPnP terminology, a device is either a "device" (a server  * that provides information about itself and allows itself to be controlled)  * or a "control point" (a client that controls "devices") or possibly both.  * This file implements a UPnP "device".  *  * For us, we use mostly basic UPnP discovery, but the control part of interest  * is WPS carried via UPnP messages. There is quite a bit of basic UPnP  * discovery to do before we can get to WPS, however.  *  * UPnP discovery begins with "devices" send out multicast UDP packets to a  * certain fixed multicast IP address and port, and "control points" sending  * out other such UDP packets.  *  * The packets sent by devices are NOTIFY packets (not to be confused with TCP  * NOTIFY packets that are used later) and those sent by control points are  * M-SEARCH packets. These packets contain a simple HTTP style header. The  * packets are sent redundantly to get around packet loss. Devices respond to  * M-SEARCH packets with HTTP-like UDP packets containing HTTP/1.1 200 OK  * messages, which give similar information as the UDP NOTIFY packets.  *  * The above UDP packets advertise the (arbitrary) TCP ports that the  * respective parties will listen to. The control point can then do a HTTP  * SUBSCRIBE (something like an HTTP PUT) after which the device can do a  * separate HTTP NOTIFY (also like an HTTP PUT) to do event messaging.  *  * The control point will also do HTTP GET of the "device file" listed in the  * original UDP information from the device (see UPNP_WPS_DEVICE_XML_FILE  * data), and based on this will do additional GETs... HTTP POSTs are done to  * cause an action.  *  * Beyond some basic information in HTTP headers, additional information is in  * the HTTP bodies, in a format set by the SOAP and XML standards, a markup  * language related to HTML used for web pages. This language is intended to  * provide the ultimate in self-documentation by providing a universal  * namespace based on pseudo-URLs called URIs. Note that although a URI looks  * like a URL (a web address), they are never accessed as such but are used  * only as identifiers.  *  * The POST of a GetDeviceInfo gets information similar to what might be  * obtained from a probe request or response on Wi-Fi. WPS messages M1-M8  * are passed via a POST of a PutMessage; the M1-M8 WPS messages are converted  * to a bin64 ascii representation for encapsulation. When proxying messages,  * WLANEvent and PutWLANResponse are used.  *  * This of course glosses over a lot of details.  */
end_comment

begin_include
include|#
directive|include
file|"includes.h"
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|"common.h"
end_include

begin_include
include|#
directive|include
file|"uuid.h"
end_include

begin_include
include|#
directive|include
file|"base64.h"
end_include

begin_include
include|#
directive|include
file|"wps.h"
end_include

begin_include
include|#
directive|include
file|"wps_i.h"
end_include

begin_include
include|#
directive|include
file|"wps_upnp.h"
end_include

begin_include
include|#
directive|include
file|"wps_upnp_i.h"
end_include

begin_comment
comment|/*  * UPnP allows a client ("control point") to send a server like us ("device")  * a domain name for registration, and we are supposed to resolve it. This is  * bad because, using the standard Linux library, we will stall the entire  * hostapd waiting for resolution.  *  * The "correct" solution would be to use an event driven library for domain  * name resolution such as "ares". However, this would increase code size  * further. Since it is unlikely that we'll actually see such domain names, we  * can just refuse to accept them.  */
end_comment

begin_define
define|#
directive|define
name|NO_DOMAIN_NAME_RESOLUTION
value|1
end_define

begin_comment
comment|/* 1 to allow only dotted ip addresses */
end_comment

begin_comment
comment|/*  * UPnP does not scale well. If we were in a room with thousands of control  * points then potentially we could be expected to handle subscriptions for  * each of them, which would exhaust our memory. So we must set a limit. In  * practice we are unlikely to see more than one or two.  */
end_comment

begin_define
define|#
directive|define
name|MAX_SUBSCRIPTIONS
value|4
end_define

begin_comment
comment|/* how many subscribing clients we handle */
end_comment

begin_define
define|#
directive|define
name|MAX_ADDR_PER_SUBSCRIPTION
value|8
end_define

begin_comment
comment|/* Write the current date/time per RFC */
end_comment

begin_function
name|void
name|format_date
parameter_list|(
name|struct
name|wpabuf
modifier|*
name|buf
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|weekday_str
init|=
literal|"Sun\0Mon\0Tue\0Wed\0Thu\0Fri\0Sat"
decl_stmt|;
specifier|const
name|char
modifier|*
name|month_str
init|=
literal|"Jan\0Feb\0Mar\0Apr\0May\0Jun\0"
literal|"Jul\0Aug\0Sep\0Oct\0Nov\0Dec"
decl_stmt|;
name|struct
name|tm
modifier|*
name|date
decl_stmt|;
name|time_t
name|t
decl_stmt|;
name|t
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|date
operator|=
name|gmtime
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
name|wpabuf_printf
argument_list|(
name|buf
argument_list|,
literal|"%s, %02d %s %d %02d:%02d:%02d GMT"
argument_list|,
operator|&
name|weekday_str
index|[
name|date
operator|->
name|tm_wday
operator|*
literal|4
index|]
argument_list|,
name|date
operator|->
name|tm_mday
argument_list|,
operator|&
name|month_str
index|[
name|date
operator|->
name|tm_mon
operator|*
literal|4
index|]
argument_list|,
name|date
operator|->
name|tm_year
operator|+
literal|1900
argument_list|,
name|date
operator|->
name|tm_hour
argument_list|,
name|date
operator|->
name|tm_min
argument_list|,
name|date
operator|->
name|tm_sec
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/***************************************************************************  * UUIDs (unique identifiers)  *  * These are supposed to be unique in all the world.  * Sometimes permanent ones are used, sometimes temporary ones  * based on random numbers... there are different rules for valid content  * of different types.  * Each uuid is 16 bytes long.  **************************************************************************/
end_comment

begin_comment
comment|/* uuid_make -- construct a random UUID  * The UPnP documents don't seem to offer any guidelines as to which method to  * use for constructing UUIDs for subscriptions. Presumably any method from  * rfc4122 is good enough; I've chosen random number method.  */
end_comment

begin_function
specifier|static
name|void
name|uuid_make
parameter_list|(
name|u8
name|uuid
index|[
name|UUID_LEN
index|]
parameter_list|)
block|{
name|os_get_random
argument_list|(
name|uuid
argument_list|,
name|UUID_LEN
argument_list|)
expr_stmt|;
comment|/* Replace certain bits as specified in rfc4122 or X.667 */
name|uuid
index|[
literal|6
index|]
operator|&=
literal|0x0f
expr_stmt|;
name|uuid
index|[
literal|6
index|]
operator||=
operator|(
literal|4
operator|<<
literal|4
operator|)
expr_stmt|;
comment|/* version 4 == random gen */
name|uuid
index|[
literal|8
index|]
operator|&=
literal|0x3f
expr_stmt|;
name|uuid
index|[
literal|8
index|]
operator||=
literal|0x80
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Subscriber address handling.  * Since a subscriber may have an arbitrary number of addresses, we have to  * add a bunch of code to handle them.  *  * Addresses are passed in text, and MAY be domain names instead of the (usual  * and expected) dotted IP addresses. Resolving domain names consumes a lot of  * resources. Worse, we are currently using the standard Linux getaddrinfo()  * which will block the entire program until complete or timeout! The proper  * solution would be to use the "ares" library or similar with more state  * machine steps etc. or just disable domain name resolution by setting  * NO_DOMAIN_NAME_RESOLUTION to 1 at top of this file.  */
end_comment

begin_comment
comment|/* subscr_addr_delete -- delete single unlinked subscriber address  * (be sure to unlink first if need be)  */
end_comment

begin_function
specifier|static
name|void
name|subscr_addr_delete
parameter_list|(
name|struct
name|subscr_addr
modifier|*
name|a
parameter_list|)
block|{
comment|/* 	 * Note: do NOT free domain_and_port or path because they point to 	 * memory within the allocation of "a". 	 */
name|os_free
argument_list|(
name|a
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* subscr_addr_unlink -- unlink subscriber address from linked list */
end_comment

begin_function
specifier|static
name|void
name|subscr_addr_unlink
parameter_list|(
name|struct
name|subscription
modifier|*
name|s
parameter_list|,
name|struct
name|subscr_addr
modifier|*
name|a
parameter_list|)
block|{
name|struct
name|subscr_addr
modifier|*
modifier|*
name|listp
init|=
operator|&
name|s
operator|->
name|addr_list
decl_stmt|;
name|s
operator|->
name|n_addr
operator|--
expr_stmt|;
name|a
operator|->
name|next
operator|->
name|prev
operator|=
name|a
operator|->
name|prev
expr_stmt|;
name|a
operator|->
name|prev
operator|->
name|next
operator|=
name|a
operator|->
name|next
expr_stmt|;
if|if
condition|(
operator|*
name|listp
operator|==
name|a
condition|)
block|{
if|if
condition|(
name|a
operator|==
name|a
operator|->
name|next
condition|)
block|{
comment|/* last in queue */
operator|*
name|listp
operator|=
name|NULL
expr_stmt|;
name|assert
argument_list|(
name|s
operator|->
name|n_addr
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|listp
operator|=
name|a
operator|->
name|next
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* subscr_addr_free_all -- unlink and delete list of subscriber addresses. */
end_comment

begin_function
specifier|static
name|void
name|subscr_addr_free_all
parameter_list|(
name|struct
name|subscription
modifier|*
name|s
parameter_list|)
block|{
name|struct
name|subscr_addr
modifier|*
modifier|*
name|listp
init|=
operator|&
name|s
operator|->
name|addr_list
decl_stmt|;
name|struct
name|subscr_addr
modifier|*
name|a
decl_stmt|;
while|while
condition|(
operator|(
name|a
operator|=
operator|*
name|listp
operator|)
operator|!=
name|NULL
condition|)
block|{
name|subscr_addr_unlink
argument_list|(
name|s
argument_list|,
name|a
argument_list|)
expr_stmt|;
name|subscr_addr_delete
argument_list|(
name|a
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* subscr_addr_link -- add subscriber address to list of addresses */
end_comment

begin_function
specifier|static
name|void
name|subscr_addr_link
parameter_list|(
name|struct
name|subscription
modifier|*
name|s
parameter_list|,
name|struct
name|subscr_addr
modifier|*
name|a
parameter_list|)
block|{
name|struct
name|subscr_addr
modifier|*
modifier|*
name|listp
init|=
operator|&
name|s
operator|->
name|addr_list
decl_stmt|;
name|s
operator|->
name|n_addr
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|listp
operator|==
name|NULL
condition|)
block|{
operator|*
name|listp
operator|=
name|a
operator|->
name|next
operator|=
name|a
operator|->
name|prev
operator|=
name|a
expr_stmt|;
block|}
else|else
block|{
name|a
operator|->
name|next
operator|=
operator|*
name|listp
expr_stmt|;
name|a
operator|->
name|prev
operator|=
operator|(
operator|*
name|listp
operator|)
operator|->
name|prev
expr_stmt|;
name|a
operator|->
name|prev
operator|->
name|next
operator|=
name|a
expr_stmt|;
name|a
operator|->
name|next
operator|->
name|prev
operator|=
name|a
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* subscr_addr_add_url -- add address(es) for one url to subscription */
end_comment

begin_function
specifier|static
name|void
name|subscr_addr_add_url
parameter_list|(
name|struct
name|subscription
modifier|*
name|s
parameter_list|,
specifier|const
name|char
modifier|*
name|url
parameter_list|)
block|{
name|int
name|alloc_len
decl_stmt|;
name|char
modifier|*
name|scratch_mem
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|mem
decl_stmt|;
name|char
modifier|*
name|domain_and_port
decl_stmt|;
name|char
modifier|*
name|delim
decl_stmt|;
name|char
modifier|*
name|path
decl_stmt|;
name|char
modifier|*
name|domain
decl_stmt|;
name|int
name|port
init|=
literal|80
decl_stmt|;
comment|/* port to send to (default is port 80) */
name|struct
name|addrinfo
name|hints
decl_stmt|;
name|struct
name|addrinfo
modifier|*
name|result
init|=
name|NULL
decl_stmt|;
name|struct
name|addrinfo
modifier|*
name|rp
decl_stmt|;
name|int
name|rerr
decl_stmt|;
name|struct
name|subscr_addr
modifier|*
name|a
init|=
name|NULL
decl_stmt|;
comment|/* url MUST begin with http: */
if|if
condition|(
name|os_strncasecmp
argument_list|(
name|url
argument_list|,
literal|"http://"
argument_list|,
literal|7
argument_list|)
condition|)
goto|goto
name|fail
goto|;
name|url
operator|+=
literal|7
expr_stmt|;
comment|/* allocate memory for the extra stuff we need */
name|alloc_len
operator|=
operator|(
literal|2
operator|*
operator|(
name|os_strlen
argument_list|(
name|url
argument_list|)
operator|+
literal|1
operator|)
operator|)
expr_stmt|;
name|scratch_mem
operator|=
name|os_zalloc
argument_list|(
name|alloc_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|scratch_mem
operator|==
name|NULL
condition|)
goto|goto
name|fail
goto|;
name|mem
operator|=
name|scratch_mem
expr_stmt|;
name|strcpy
argument_list|(
name|mem
argument_list|,
name|url
argument_list|)
expr_stmt|;
name|domain_and_port
operator|=
name|mem
expr_stmt|;
name|mem
operator|+=
literal|1
operator|+
name|os_strlen
argument_list|(
name|mem
argument_list|)
expr_stmt|;
name|delim
operator|=
name|os_strchr
argument_list|(
name|domain_and_port
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|delim
condition|)
block|{
operator|*
name|delim
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* null terminate domain and port */
name|path
operator|=
name|delim
expr_stmt|;
block|}
else|else
block|{
name|path
operator|=
name|domain_and_port
operator|+
name|os_strlen
argument_list|(
name|domain_and_port
argument_list|)
expr_stmt|;
block|}
name|domain
operator|=
name|mem
expr_stmt|;
name|strcpy
argument_list|(
name|domain
argument_list|,
name|domain_and_port
argument_list|)
expr_stmt|;
name|delim
operator|=
name|strchr
argument_list|(
name|domain
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|delim
condition|)
block|{
operator|*
name|delim
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* null terminate domain */
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|delim
argument_list|)
condition|)
name|port
operator|=
name|atol
argument_list|(
name|delim
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * getaddrinfo does the right thing with dotted decimal notations, or 	 * will resolve domain names. Resolving domain names will unfortunately 	 * hang the entire program until it is resolved or it times out 	 * internal to getaddrinfo; fortunately we think that the use of actual 	 * domain names (vs. dotted decimal notations) should be uncommon. 	 */
name|os_memset
argument_list|(
operator|&
name|hints
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|addrinfo
argument_list|)
argument_list|)
expr_stmt|;
name|hints
operator|.
name|ai_family
operator|=
name|AF_INET
expr_stmt|;
comment|/* IPv4 */
name|hints
operator|.
name|ai_socktype
operator|=
name|SOCK_STREAM
expr_stmt|;
if|#
directive|if
name|NO_DOMAIN_NAME_RESOLUTION
comment|/* Suppress domain name resolutions that would halt 	 * the program for periods of time 	 */
name|hints
operator|.
name|ai_flags
operator|=
name|AI_NUMERICHOST
expr_stmt|;
else|#
directive|else
comment|/* Allow domain name resolution. */
name|hints
operator|.
name|ai_flags
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|hints
operator|.
name|ai_protocol
operator|=
literal|0
expr_stmt|;
comment|/* Any protocol? */
name|rerr
operator|=
name|getaddrinfo
argument_list|(
name|domain
argument_list|,
name|NULL
comment|/* fill in port ourselves */
argument_list|,
operator|&
name|hints
argument_list|,
operator|&
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|rerr
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_INFO
argument_list|,
literal|"WPS UPnP: Resolve error %d (%s) on: %s"
argument_list|,
name|rerr
argument_list|,
name|gai_strerror
argument_list|(
name|rerr
argument_list|)
argument_list|,
name|domain
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
for|for
control|(
name|rp
operator|=
name|result
init|;
name|rp
condition|;
name|rp
operator|=
name|rp
operator|->
name|ai_next
control|)
block|{
comment|/* Limit no. of address to avoid denial of service attack */
if|if
condition|(
name|s
operator|->
name|n_addr
operator|>=
name|MAX_ADDR_PER_SUBSCRIPTION
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_INFO
argument_list|,
literal|"WPS UPnP: subscr_addr_add_url: "
literal|"Ignoring excessive addresses"
argument_list|)
expr_stmt|;
break|break;
block|}
name|a
operator|=
name|os_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|a
argument_list|)
operator|+
name|alloc_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|==
name|NULL
condition|)
continue|continue;
name|a
operator|->
name|s
operator|=
name|s
expr_stmt|;
name|mem
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|a
operator|+
literal|1
operator|)
expr_stmt|;
name|a
operator|->
name|domain_and_port
operator|=
name|mem
expr_stmt|;
name|strcpy
argument_list|(
name|mem
argument_list|,
name|domain_and_port
argument_list|)
expr_stmt|;
name|mem
operator|+=
literal|1
operator|+
name|strlen
argument_list|(
name|mem
argument_list|)
expr_stmt|;
name|a
operator|->
name|path
operator|=
name|mem
expr_stmt|;
if|if
condition|(
name|path
index|[
literal|0
index|]
operator|!=
literal|'/'
condition|)
operator|*
name|mem
operator|++
operator|=
literal|'/'
expr_stmt|;
name|strcpy
argument_list|(
name|mem
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|mem
operator|+=
literal|1
operator|+
name|strlen
argument_list|(
name|mem
argument_list|)
expr_stmt|;
name|os_memcpy
argument_list|(
operator|&
name|a
operator|->
name|saddr
argument_list|,
name|rp
operator|->
name|ai_addr
argument_list|,
sizeof|sizeof
argument_list|(
name|a
operator|->
name|saddr
argument_list|)
argument_list|)
expr_stmt|;
name|a
operator|->
name|saddr
operator|.
name|sin_port
operator|=
name|htons
argument_list|(
name|port
argument_list|)
expr_stmt|;
name|subscr_addr_link
argument_list|(
name|s
argument_list|,
name|a
argument_list|)
expr_stmt|;
name|a
operator|=
name|NULL
expr_stmt|;
comment|/* don't free it below */
block|}
name|fail
label|:
if|if
condition|(
name|result
condition|)
name|freeaddrinfo
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|os_free
argument_list|(
name|scratch_mem
argument_list|)
expr_stmt|;
name|os_free
argument_list|(
name|a
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* subscr_addr_list_create -- create list from urls in string.  *      Each url is enclosed by angle brackets.  */
end_comment

begin_function
specifier|static
name|void
name|subscr_addr_list_create
parameter_list|(
name|struct
name|subscription
modifier|*
name|s
parameter_list|,
specifier|const
name|char
modifier|*
name|url_list
parameter_list|)
block|{
name|char
modifier|*
name|end
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
while|while
condition|(
operator|*
name|url_list
operator|==
literal|' '
operator|||
operator|*
name|url_list
operator|==
literal|'\t'
condition|)
name|url_list
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|url_list
operator|!=
literal|'<'
condition|)
break|break;
name|url_list
operator|++
expr_stmt|;
name|end
operator|=
name|os_strchr
argument_list|(
name|url_list
argument_list|,
literal|'>'
argument_list|)
expr_stmt|;
if|if
condition|(
name|end
operator|==
name|NULL
condition|)
break|break;
operator|*
name|end
operator|++
operator|=
literal|0
expr_stmt|;
name|subscr_addr_add_url
argument_list|(
name|s
argument_list|,
name|url_list
argument_list|)
expr_stmt|;
name|url_list
operator|=
name|end
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|send_wpabuf
parameter_list|(
name|int
name|fd
parameter_list|,
name|struct
name|wpabuf
modifier|*
name|buf
parameter_list|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"WPS UPnP: Send %lu byte message"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|wpabuf_len
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|fd
argument_list|,
name|wpabuf_head
argument_list|(
name|buf
argument_list|)
argument_list|,
name|wpabuf_len
argument_list|(
name|buf
argument_list|)
argument_list|)
operator|!=
operator|(
name|int
operator|)
name|wpabuf_len
argument_list|(
name|buf
argument_list|)
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_ERROR
argument_list|,
literal|"WPS UPnP: Failed to send buffer: "
literal|"errno=%d (%s)"
argument_list|,
name|errno
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|wpabuf_put_property
parameter_list|(
name|struct
name|wpabuf
modifier|*
name|buf
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|)
block|{
name|wpabuf_put_str
argument_list|(
name|buf
argument_list|,
literal|"<e:property>"
argument_list|)
expr_stmt|;
name|wpabuf_printf
argument_list|(
name|buf
argument_list|,
literal|"<%s>"
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
condition|)
name|wpabuf_put_str
argument_list|(
name|buf
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|wpabuf_printf
argument_list|(
name|buf
argument_list|,
literal|"</%s>"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|wpabuf_put_str
argument_list|(
name|buf
argument_list|,
literal|"</e:property>\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * upnp_wps_device_send_event - Queue event messages for subscribers  * @sm: WPS UPnP state machine from upnp_wps_device_init()  *  * This function queues the last WLANEvent to be sent for all currently  * subscribed UPnP control points. sm->wlanevent must have been set with the  * encoded data before calling this function.  */
end_comment

begin_function
specifier|static
name|void
name|upnp_wps_device_send_event
parameter_list|(
name|struct
name|upnp_wps_device_sm
modifier|*
name|sm
parameter_list|)
block|{
comment|/* Enqueue event message for all subscribers */
name|struct
name|wpabuf
modifier|*
name|buf
decl_stmt|;
comment|/* holds event message */
name|int
name|buf_size
init|=
literal|0
decl_stmt|;
name|struct
name|subscription
modifier|*
name|s
decl_stmt|;
comment|/* Actually, utf-8 is the default, but it doesn't hurt to specify it */
specifier|const
name|char
modifier|*
name|format_head
init|=
literal|"<?xml version=\"1.0\" encoding=\"utf-8\"?>\n"
literal|"<e:propertyset xmlns:e=\"urn:schemas-upnp-org:event-1-0\">\n"
decl_stmt|;
specifier|const
name|char
modifier|*
name|format_tail
init|=
literal|"</e:propertyset>\n"
decl_stmt|;
if|if
condition|(
name|sm
operator|->
name|subscriptions
operator|==
name|NULL
condition|)
block|{
comment|/* optimize */
return|return;
block|}
comment|/* Determine buffer size needed first */
name|buf_size
operator|+=
name|os_strlen
argument_list|(
name|format_head
argument_list|)
expr_stmt|;
name|buf_size
operator|+=
literal|50
operator|+
literal|2
operator|*
name|os_strlen
argument_list|(
literal|"WLANEvent"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|wlanevent
condition|)
name|buf_size
operator|+=
name|os_strlen
argument_list|(
name|sm
operator|->
name|wlanevent
argument_list|)
expr_stmt|;
name|buf_size
operator|+=
name|os_strlen
argument_list|(
name|format_tail
argument_list|)
expr_stmt|;
name|buf
operator|=
name|wpabuf_alloc
argument_list|(
name|buf_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
return|return;
name|wpabuf_put_str
argument_list|(
name|buf
argument_list|,
name|format_head
argument_list|)
expr_stmt|;
name|wpabuf_put_property
argument_list|(
name|buf
argument_list|,
literal|"WLANEvent"
argument_list|,
name|sm
operator|->
name|wlanevent
argument_list|)
expr_stmt|;
name|wpabuf_put_str
argument_list|(
name|buf
argument_list|,
name|format_tail
argument_list|)
expr_stmt|;
name|wpa_printf
argument_list|(
name|MSG_MSGDUMP
argument_list|,
literal|"WPS UPnP: WLANEvent message:\n%s"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|wpabuf_head
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|=
name|sm
operator|->
name|subscriptions
expr_stmt|;
do|do
block|{
if|if
condition|(
name|event_add
argument_list|(
name|s
argument_list|,
name|buf
argument_list|)
condition|)
block|{
name|struct
name|subscription
modifier|*
name|s_old
init|=
name|s
decl_stmt|;
name|wpa_printf
argument_list|(
name|MSG_INFO
argument_list|,
literal|"WPS UPnP: Dropping "
literal|"subscriber due to event backlog"
argument_list|)
expr_stmt|;
name|s
operator|=
name|s_old
operator|->
name|next
expr_stmt|;
name|subscription_unlink
argument_list|(
name|s_old
argument_list|)
expr_stmt|;
name|subscription_destroy
argument_list|(
name|s_old
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|s
operator|=
name|s
operator|->
name|next
expr_stmt|;
block|}
block|}
do|while
condition|(
name|s
operator|!=
name|sm
operator|->
name|subscriptions
condition|)
do|;
name|wpabuf_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Event subscription (subscriber machines register with us to receive event  * messages).  * This is the result of an incoming HTTP over TCP SUBSCRIBE request.  */
end_comment

begin_comment
comment|/* subscription_unlink -- remove from the active list */
end_comment

begin_function
name|void
name|subscription_unlink
parameter_list|(
name|struct
name|subscription
modifier|*
name|s
parameter_list|)
block|{
name|struct
name|upnp_wps_device_sm
modifier|*
name|sm
init|=
name|s
operator|->
name|sm
decl_stmt|;
if|if
condition|(
name|s
operator|->
name|next
operator|==
name|s
condition|)
block|{
comment|/* only one? */
name|sm
operator|->
name|subscriptions
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|sm
operator|->
name|subscriptions
operator|==
name|s
condition|)
name|sm
operator|->
name|subscriptions
operator|=
name|s
operator|->
name|next
expr_stmt|;
name|s
operator|->
name|next
operator|->
name|prev
operator|=
name|s
operator|->
name|prev
expr_stmt|;
name|s
operator|->
name|prev
operator|->
name|next
operator|=
name|s
operator|->
name|next
expr_stmt|;
block|}
name|sm
operator|->
name|n_subscriptions
operator|--
expr_stmt|;
block|}
end_function

begin_comment
comment|/* subscription_link_to_end -- link to end of active list  * (should have high expiry time!)  */
end_comment

begin_function
specifier|static
name|void
name|subscription_link_to_end
parameter_list|(
name|struct
name|subscription
modifier|*
name|s
parameter_list|)
block|{
name|struct
name|upnp_wps_device_sm
modifier|*
name|sm
init|=
name|s
operator|->
name|sm
decl_stmt|;
if|if
condition|(
name|sm
operator|->
name|subscriptions
condition|)
block|{
name|s
operator|->
name|next
operator|=
name|sm
operator|->
name|subscriptions
expr_stmt|;
name|s
operator|->
name|prev
operator|=
name|s
operator|->
name|next
operator|->
name|prev
expr_stmt|;
name|s
operator|->
name|prev
operator|->
name|next
operator|=
name|s
expr_stmt|;
name|s
operator|->
name|next
operator|->
name|prev
operator|=
name|s
expr_stmt|;
block|}
else|else
block|{
name|sm
operator|->
name|subscriptions
operator|=
name|s
operator|->
name|next
operator|=
name|s
operator|->
name|prev
operator|=
name|s
expr_stmt|;
block|}
name|sm
operator|->
name|n_subscriptions
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* subscription_destroy -- destroy an unlinked subscription  * Be sure to unlink first if necessary.  */
end_comment

begin_function
name|void
name|subscription_destroy
parameter_list|(
name|struct
name|subscription
modifier|*
name|s
parameter_list|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"WPS UPnP: Destroy subscription %p"
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|addr_list
condition|)
name|subscr_addr_free_all
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|event_delete_all
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|os_free
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* subscription_list_age -- remove expired subscriptions */
end_comment

begin_function
specifier|static
name|void
name|subscription_list_age
parameter_list|(
name|struct
name|upnp_wps_device_sm
modifier|*
name|sm
parameter_list|,
name|time_t
name|now
parameter_list|)
block|{
name|struct
name|subscription
modifier|*
name|s
decl_stmt|;
while|while
condition|(
operator|(
name|s
operator|=
name|sm
operator|->
name|subscriptions
operator|)
operator|!=
name|NULL
operator|&&
name|s
operator|->
name|timeout_time
operator|<
name|now
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"WPS UPnP: Removing aged subscription"
argument_list|)
expr_stmt|;
name|subscription_unlink
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|subscription_destroy
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* subscription_find -- return existing subscription matching uuid, if any  * returns NULL if not found  */
end_comment

begin_function
name|struct
name|subscription
modifier|*
name|subscription_find
parameter_list|(
name|struct
name|upnp_wps_device_sm
modifier|*
name|sm
parameter_list|,
specifier|const
name|u8
name|uuid
index|[
name|UUID_LEN
index|]
parameter_list|)
block|{
name|struct
name|subscription
modifier|*
name|s0
init|=
name|sm
operator|->
name|subscriptions
decl_stmt|;
name|struct
name|subscription
modifier|*
name|s
init|=
name|s0
decl_stmt|;
if|if
condition|(
name|s0
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
do|do
block|{
if|if
condition|(
name|os_memcmp
argument_list|(
name|s
operator|->
name|uuid
argument_list|,
name|uuid
argument_list|,
name|UUID_LEN
argument_list|)
operator|==
literal|0
condition|)
return|return
name|s
return|;
comment|/* Found match */
name|s
operator|=
name|s
operator|->
name|next
expr_stmt|;
block|}
do|while
condition|(
name|s
operator|!=
name|s0
condition|)
do|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* subscription_first_event -- send format/queue event that is automatically  * sent on a new subscription.  */
end_comment

begin_function
specifier|static
name|int
name|subscription_first_event
parameter_list|(
name|struct
name|subscription
modifier|*
name|s
parameter_list|)
block|{
comment|/* 	 * Actually, utf-8 is the default, but it doesn't hurt to specify it. 	 * 	 * APStatus is apparently a bit set, 	 * 0x1 = configuration change (but is always set?) 	 * 0x10 = ap is locked 	 * 	 * Per UPnP spec, we send out the last value of each variable, even 	 * for WLANEvent, whatever it was. 	 */
name|char
modifier|*
name|wlan_event
decl_stmt|;
name|struct
name|wpabuf
modifier|*
name|buf
decl_stmt|;
name|int
name|ap_status
init|=
literal|1
decl_stmt|;
comment|/* TODO: add 0x10 if access point is locked */
specifier|const
name|char
modifier|*
name|head
init|=
literal|"<?xml version=\"1.0\" encoding=\"utf-8\"?>\n"
literal|"<e:propertyset xmlns:e=\"urn:schemas-upnp-org:event-1-0\">\n"
decl_stmt|;
specifier|const
name|char
modifier|*
name|tail
init|=
literal|"</e:propertyset>\n"
decl_stmt|;
name|char
name|txt
index|[
literal|10
index|]
decl_stmt|;
name|wlan_event
operator|=
name|s
operator|->
name|sm
operator|->
name|wlanevent
expr_stmt|;
if|if
condition|(
name|wlan_event
operator|==
name|NULL
operator|||
operator|*
name|wlan_event
operator|==
literal|'\0'
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"WPS UPnP: WLANEvent not known for "
literal|"initial event message"
argument_list|)
expr_stmt|;
name|wlan_event
operator|=
literal|""
expr_stmt|;
block|}
name|buf
operator|=
name|wpabuf_alloc
argument_list|(
literal|500
operator|+
name|os_strlen
argument_list|(
name|wlan_event
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
return|return
literal|1
return|;
name|wpabuf_put_str
argument_list|(
name|buf
argument_list|,
name|head
argument_list|)
expr_stmt|;
name|wpabuf_put_property
argument_list|(
name|buf
argument_list|,
literal|"STAStatus"
argument_list|,
literal|"1"
argument_list|)
expr_stmt|;
name|os_snprintf
argument_list|(
name|txt
argument_list|,
sizeof|sizeof
argument_list|(
name|txt
argument_list|)
argument_list|,
literal|"%d"
argument_list|,
name|ap_status
argument_list|)
expr_stmt|;
name|wpabuf_put_property
argument_list|(
name|buf
argument_list|,
literal|"APStatus"
argument_list|,
name|txt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|wlan_event
condition|)
name|wpabuf_put_property
argument_list|(
name|buf
argument_list|,
literal|"WLANEvent"
argument_list|,
name|wlan_event
argument_list|)
expr_stmt|;
name|wpabuf_put_str
argument_list|(
name|buf
argument_list|,
name|tail
argument_list|)
expr_stmt|;
if|if
condition|(
name|event_add
argument_list|(
name|s
argument_list|,
name|buf
argument_list|)
condition|)
block|{
name|wpabuf_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|wpabuf_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * subscription_start - Rremember a UPnP control point to send events to.  * @sm: WPS UPnP state machine from upnp_wps_device_init()  * @callback_urls: malloc' mem given to the subscription  * Returns: %NULL on error, or pointer to new subscription structure.  */
end_comment

begin_function
name|struct
name|subscription
modifier|*
name|subscription_start
parameter_list|(
name|struct
name|upnp_wps_device_sm
modifier|*
name|sm
parameter_list|,
name|char
modifier|*
name|callback_urls
parameter_list|)
block|{
name|struct
name|subscription
modifier|*
name|s
decl_stmt|;
name|time_t
name|now
init|=
name|time
argument_list|(
name|NULL
argument_list|)
decl_stmt|;
name|time_t
name|expire
init|=
name|now
operator|+
name|UPNP_SUBSCRIBE_SEC
decl_stmt|;
comment|/* Get rid of expired subscriptions so we have room */
name|subscription_list_age
argument_list|(
name|sm
argument_list|,
name|now
argument_list|)
expr_stmt|;
comment|/* If too many subscriptions, remove oldest */
if|if
condition|(
name|sm
operator|->
name|n_subscriptions
operator|>=
name|MAX_SUBSCRIPTIONS
condition|)
block|{
name|s
operator|=
name|sm
operator|->
name|subscriptions
expr_stmt|;
name|wpa_printf
argument_list|(
name|MSG_INFO
argument_list|,
literal|"WPS UPnP: Too many subscriptions, "
literal|"trashing oldest"
argument_list|)
expr_stmt|;
name|subscription_unlink
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|subscription_destroy
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
name|s
operator|=
name|os_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|s
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|s
operator|->
name|sm
operator|=
name|sm
expr_stmt|;
name|s
operator|->
name|timeout_time
operator|=
name|expire
expr_stmt|;
name|uuid_make
argument_list|(
name|s
operator|->
name|uuid
argument_list|)
expr_stmt|;
name|subscr_addr_list_create
argument_list|(
name|s
argument_list|,
name|callback_urls
argument_list|)
expr_stmt|;
comment|/* Add to end of list, since it has the highest expiration time */
name|subscription_link_to_end
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* Queue up immediate event message (our last event) 	 * as required by UPnP spec. 	 */
if|if
condition|(
name|subscription_first_event
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_INFO
argument_list|,
literal|"WPS UPnP: Dropping subscriber due to "
literal|"event backlog"
argument_list|)
expr_stmt|;
name|subscription_unlink
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|subscription_destroy
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"WPS UPnP: Subscription %p started with %s"
argument_list|,
name|s
argument_list|,
name|callback_urls
argument_list|)
expr_stmt|;
name|os_free
argument_list|(
name|callback_urls
argument_list|)
expr_stmt|;
comment|/* Schedule sending this */
name|event_send_all_later
argument_list|(
name|sm
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_comment
comment|/* subscription_renew -- find subscription and reset timeout */
end_comment

begin_function
name|struct
name|subscription
modifier|*
name|subscription_renew
parameter_list|(
name|struct
name|upnp_wps_device_sm
modifier|*
name|sm
parameter_list|,
specifier|const
name|u8
name|uuid
index|[
name|UUID_LEN
index|]
parameter_list|)
block|{
name|time_t
name|now
init|=
name|time
argument_list|(
name|NULL
argument_list|)
decl_stmt|;
name|time_t
name|expire
init|=
name|now
operator|+
name|UPNP_SUBSCRIBE_SEC
decl_stmt|;
name|struct
name|subscription
modifier|*
name|s
init|=
name|subscription_find
argument_list|(
name|sm
argument_list|,
name|uuid
argument_list|)
decl_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"WPS UPnP: Subscription renewed"
argument_list|)
expr_stmt|;
name|subscription_unlink
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|s
operator|->
name|timeout_time
operator|=
name|expire
expr_stmt|;
comment|/* add back to end of list, since it now has highest expiry */
name|subscription_link_to_end
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_comment
comment|/**  * upnp_wps_device_send_wlan_event - Event notification  * @sm: WPS UPnP state machine from upnp_wps_device_init()  * @from_mac_addr: Source (Enrollee) MAC address for the event  * @ev_type: Event type  * @msg: Event data  * Returns: 0 on success, -1 on failure  *  * Tell external Registrars (UPnP control points) that something happened. In  * particular, events include WPS messages from clients that are proxied to  * external Registrars.  */
end_comment

begin_function
name|int
name|upnp_wps_device_send_wlan_event
parameter_list|(
name|struct
name|upnp_wps_device_sm
modifier|*
name|sm
parameter_list|,
specifier|const
name|u8
name|from_mac_addr
index|[
name|ETH_ALEN
index|]
parameter_list|,
name|enum
name|upnp_wps_wlanevent_type
name|ev_type
parameter_list|,
specifier|const
name|struct
name|wpabuf
modifier|*
name|msg
parameter_list|)
block|{
name|int
name|ret
init|=
operator|-
literal|1
decl_stmt|;
name|char
name|type
index|[
literal|2
index|]
decl_stmt|;
specifier|const
name|u8
modifier|*
name|mac
init|=
name|from_mac_addr
decl_stmt|;
name|char
name|mac_text
index|[
literal|18
index|]
decl_stmt|;
name|u8
modifier|*
name|raw
init|=
name|NULL
decl_stmt|;
name|size_t
name|raw_len
decl_stmt|;
name|char
modifier|*
name|val
decl_stmt|;
name|size_t
name|val_len
decl_stmt|;
name|int
name|pos
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|sm
condition|)
goto|goto
name|fail
goto|;
name|os_snprintf
argument_list|(
name|type
argument_list|,
sizeof|sizeof
argument_list|(
name|type
argument_list|)
argument_list|,
literal|"%1u"
argument_list|,
name|ev_type
argument_list|)
expr_stmt|;
name|raw_len
operator|=
literal|1
operator|+
literal|17
operator|+
operator|(
name|msg
condition|?
name|wpabuf_len
argument_list|(
name|msg
argument_list|)
else|:
literal|0
operator|)
expr_stmt|;
name|raw
operator|=
name|os_zalloc
argument_list|(
name|raw_len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|raw
condition|)
goto|goto
name|fail
goto|;
operator|*
operator|(
name|raw
operator|+
name|pos
operator|)
operator|=
operator|(
name|u8
operator|)
name|ev_type
expr_stmt|;
name|pos
operator|+=
literal|1
expr_stmt|;
name|os_snprintf
argument_list|(
name|mac_text
argument_list|,
sizeof|sizeof
argument_list|(
name|mac_text
argument_list|)
argument_list|,
name|MACSTR
argument_list|,
name|MAC2STR
argument_list|(
name|mac
argument_list|)
argument_list|)
expr_stmt|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"WPS UPnP: Proxying WLANEvent from %s"
argument_list|,
name|mac_text
argument_list|)
expr_stmt|;
name|os_memcpy
argument_list|(
name|raw
operator|+
name|pos
argument_list|,
name|mac_text
argument_list|,
literal|17
argument_list|)
expr_stmt|;
name|pos
operator|+=
literal|17
expr_stmt|;
if|if
condition|(
name|msg
condition|)
block|{
name|os_memcpy
argument_list|(
name|raw
operator|+
name|pos
argument_list|,
name|wpabuf_head
argument_list|(
name|msg
argument_list|)
argument_list|,
name|wpabuf_len
argument_list|(
name|msg
argument_list|)
argument_list|)
expr_stmt|;
name|pos
operator|+=
name|wpabuf_len
argument_list|(
name|msg
argument_list|)
expr_stmt|;
block|}
name|raw_len
operator|=
name|pos
expr_stmt|;
name|val
operator|=
operator|(
name|char
operator|*
operator|)
name|base64_encode
argument_list|(
name|raw
argument_list|,
name|raw_len
argument_list|,
operator|&
name|val_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
name|NULL
condition|)
goto|goto
name|fail
goto|;
name|os_free
argument_list|(
name|sm
operator|->
name|wlanevent
argument_list|)
expr_stmt|;
name|sm
operator|->
name|wlanevent
operator|=
name|val
expr_stmt|;
name|upnp_wps_device_send_event
argument_list|(
name|sm
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
name|fail
label|:
name|os_free
argument_list|(
name|raw
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/**  * get_netif_info - Get hw and IP addresses for network device  * @net_if: Selected network interface name  * @ip_addr: Buffer for returning IP address in network byte order  * @ip_addr_text: Buffer for returning a pointer to allocated IP address text  * @mac: Buffer for returning MAC address  * @mac_addr_text: Buffer for returning allocated MAC address text  * Returns: 0 on success, -1 on failure  */
end_comment

begin_function
specifier|static
name|int
name|get_netif_info
parameter_list|(
specifier|const
name|char
modifier|*
name|net_if
parameter_list|,
name|unsigned
modifier|*
name|ip_addr
parameter_list|,
name|char
modifier|*
modifier|*
name|ip_addr_text
parameter_list|,
name|u8
name|mac
index|[
name|ETH_ALEN
index|]
parameter_list|,
name|char
modifier|*
modifier|*
name|mac_addr_text
parameter_list|)
block|{
name|struct
name|ifreq
name|req
decl_stmt|;
name|int
name|sock
init|=
operator|-
literal|1
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|addr
decl_stmt|;
name|struct
name|in_addr
name|in_addr
decl_stmt|;
operator|*
name|ip_addr_text
operator|=
name|os_zalloc
argument_list|(
literal|16
argument_list|)
expr_stmt|;
operator|*
name|mac_addr_text
operator|=
name|os_zalloc
argument_list|(
literal|18
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ip_addr_text
operator|==
name|NULL
operator|||
operator|*
name|mac_addr_text
operator|==
name|NULL
condition|)
goto|goto
name|fail
goto|;
name|sock
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sock
operator|<
literal|0
condition|)
goto|goto
name|fail
goto|;
name|os_strlcpy
argument_list|(
name|req
operator|.
name|ifr_name
argument_list|,
name|net_if
argument_list|,
sizeof|sizeof
argument_list|(
name|req
operator|.
name|ifr_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|sock
argument_list|,
name|SIOCGIFADDR
argument_list|,
operator|&
name|req
argument_list|)
operator|<
literal|0
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_ERROR
argument_list|,
literal|"WPS UPnP: SIOCGIFADDR failed: %d (%s)"
argument_list|,
name|errno
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|addr
operator|=
operator|(
name|void
operator|*
operator|)
operator|&
name|req
operator|.
name|ifr_addr
expr_stmt|;
operator|*
name|ip_addr
operator|=
name|addr
operator|->
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
name|in_addr
operator|.
name|s_addr
operator|=
operator|*
name|ip_addr
expr_stmt|;
name|os_snprintf
argument_list|(
operator|*
name|ip_addr_text
argument_list|,
literal|16
argument_list|,
literal|"%s"
argument_list|,
name|inet_ntoa
argument_list|(
name|in_addr
argument_list|)
argument_list|)
expr_stmt|;
name|os_strlcpy
argument_list|(
name|req
operator|.
name|ifr_name
argument_list|,
name|net_if
argument_list|,
sizeof|sizeof
argument_list|(
name|req
operator|.
name|ifr_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|sock
argument_list|,
name|SIOCGIFHWADDR
argument_list|,
operator|&
name|req
argument_list|)
operator|<
literal|0
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_ERROR
argument_list|,
literal|"WPS UPnP: SIOCGIFHWADDR failed: "
literal|"%d (%s)"
argument_list|,
name|errno
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|os_memcpy
argument_list|(
name|mac
argument_list|,
name|req
operator|.
name|ifr_addr
operator|.
name|sa_data
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|os_snprintf
argument_list|(
operator|*
name|mac_addr_text
argument_list|,
literal|18
argument_list|,
name|MACSTR
argument_list|,
name|MAC2STR
argument_list|(
name|req
operator|.
name|ifr_addr
operator|.
name|sa_data
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|sock
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|fail
label|:
if|if
condition|(
name|sock
operator|>=
literal|0
condition|)
name|close
argument_list|(
name|sock
argument_list|)
expr_stmt|;
name|os_free
argument_list|(
operator|*
name|ip_addr_text
argument_list|)
expr_stmt|;
operator|*
name|ip_addr_text
operator|=
name|NULL
expr_stmt|;
name|os_free
argument_list|(
operator|*
name|mac_addr_text
argument_list|)
expr_stmt|;
operator|*
name|mac_addr_text
operator|=
name|NULL
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/**  * upnp_wps_device_stop - Stop WPS UPnP operations on an interface  * @sm: WPS UPnP state machine from upnp_wps_device_init()  */
end_comment

begin_function
name|void
name|upnp_wps_device_stop
parameter_list|(
name|struct
name|upnp_wps_device_sm
modifier|*
name|sm
parameter_list|)
block|{
if|if
condition|(
operator|!
name|sm
operator|||
operator|!
name|sm
operator|->
name|started
condition|)
return|return;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"WPS UPnP: Stop device"
argument_list|)
expr_stmt|;
name|web_listener_stop
argument_list|(
name|sm
argument_list|)
expr_stmt|;
while|while
condition|(
name|sm
operator|->
name|web_connections
condition|)
name|web_connection_stop
argument_list|(
name|sm
operator|->
name|web_connections
argument_list|)
expr_stmt|;
while|while
condition|(
name|sm
operator|->
name|msearch_replies
condition|)
name|msearchreply_state_machine_stop
argument_list|(
name|sm
operator|->
name|msearch_replies
argument_list|)
expr_stmt|;
while|while
condition|(
name|sm
operator|->
name|subscriptions
condition|)
block|{
name|struct
name|subscription
modifier|*
name|s
init|=
name|sm
operator|->
name|subscriptions
decl_stmt|;
name|subscription_unlink
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|subscription_destroy
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
name|advertisement_state_machine_stop
argument_list|(
name|sm
argument_list|)
expr_stmt|;
comment|/* TODO: send byebye notifications */
name|event_send_stop_all
argument_list|(
name|sm
argument_list|)
expr_stmt|;
name|os_free
argument_list|(
name|sm
operator|->
name|wlanevent
argument_list|)
expr_stmt|;
name|sm
operator|->
name|wlanevent
operator|=
name|NULL
expr_stmt|;
name|os_free
argument_list|(
name|sm
operator|->
name|net_if
argument_list|)
expr_stmt|;
name|sm
operator|->
name|net_if
operator|=
name|NULL
expr_stmt|;
name|os_free
argument_list|(
name|sm
operator|->
name|mac_addr_text
argument_list|)
expr_stmt|;
name|sm
operator|->
name|mac_addr_text
operator|=
name|NULL
expr_stmt|;
name|os_free
argument_list|(
name|sm
operator|->
name|ip_addr_text
argument_list|)
expr_stmt|;
name|sm
operator|->
name|ip_addr_text
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|multicast_sd
operator|>=
literal|0
condition|)
name|close
argument_list|(
name|sm
operator|->
name|multicast_sd
argument_list|)
expr_stmt|;
name|sm
operator|->
name|multicast_sd
operator|=
operator|-
literal|1
expr_stmt|;
name|ssdp_listener_stop
argument_list|(
name|sm
argument_list|)
expr_stmt|;
name|sm
operator|->
name|started
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * upnp_wps_device_start - Start WPS UPnP operations on an interface  * @sm: WPS UPnP state machine from upnp_wps_device_init()  * @net_if: Selected network interface name  * Returns: 0 on success, -1 on failure  */
end_comment

begin_function
name|int
name|upnp_wps_device_start
parameter_list|(
name|struct
name|upnp_wps_device_sm
modifier|*
name|sm
parameter_list|,
name|char
modifier|*
name|net_if
parameter_list|)
block|{
if|if
condition|(
operator|!
name|sm
operator|||
operator|!
name|net_if
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|sm
operator|->
name|started
condition|)
name|upnp_wps_device_stop
argument_list|(
name|sm
argument_list|)
expr_stmt|;
name|sm
operator|->
name|net_if
operator|=
name|strdup
argument_list|(
name|net_if
argument_list|)
expr_stmt|;
name|sm
operator|->
name|multicast_sd
operator|=
operator|-
literal|1
expr_stmt|;
name|sm
operator|->
name|ssdp_sd
operator|=
operator|-
literal|1
expr_stmt|;
name|sm
operator|->
name|started
operator|=
literal|1
expr_stmt|;
name|sm
operator|->
name|advertise_count
operator|=
literal|0
expr_stmt|;
comment|/* Fix up linux multicast handling */
if|if
condition|(
name|add_ssdp_network
argument_list|(
name|net_if
argument_list|)
condition|)
goto|goto
name|fail
goto|;
comment|/* Determine which IP and mac address we're using */
if|if
condition|(
name|get_netif_info
argument_list|(
name|net_if
argument_list|,
operator|&
name|sm
operator|->
name|ip_addr
argument_list|,
operator|&
name|sm
operator|->
name|ip_addr_text
argument_list|,
name|sm
operator|->
name|mac_addr
argument_list|,
operator|&
name|sm
operator|->
name|mac_addr_text
argument_list|)
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_INFO
argument_list|,
literal|"WPS UPnP: Could not get IP/MAC address "
literal|"for %s. Does it have IP address?"
argument_list|,
name|net_if
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* Listen for incoming TCP connections so that others 	 * can fetch our "xml files" from us. 	 */
if|if
condition|(
name|web_listener_start
argument_list|(
name|sm
argument_list|)
condition|)
goto|goto
name|fail
goto|;
comment|/* Set up for receiving discovery (UDP) packets */
if|if
condition|(
name|ssdp_listener_start
argument_list|(
name|sm
argument_list|)
condition|)
goto|goto
name|fail
goto|;
comment|/* Set up for sending multicast */
if|if
condition|(
name|ssdp_open_multicast
argument_list|(
name|sm
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|fail
goto|;
comment|/* 	 * Broadcast NOTIFY messages to let the world know we exist. 	 * This is done via a state machine since the messages should not be 	 * all sent out at once. 	 */
if|if
condition|(
name|advertisement_state_machine_start
argument_list|(
name|sm
argument_list|)
condition|)
goto|goto
name|fail
goto|;
return|return
literal|0
return|;
name|fail
label|:
name|upnp_wps_device_stop
argument_list|(
name|sm
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/**  * upnp_wps_device_deinit - Deinitialize WPS UPnP  * @sm: WPS UPnP state machine from upnp_wps_device_init()  */
end_comment

begin_function
name|void
name|upnp_wps_device_deinit
parameter_list|(
name|struct
name|upnp_wps_device_sm
modifier|*
name|sm
parameter_list|)
block|{
if|if
condition|(
operator|!
name|sm
condition|)
return|return;
name|upnp_wps_device_stop
argument_list|(
name|sm
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|peer
operator|.
name|wps
condition|)
name|wps_deinit
argument_list|(
name|sm
operator|->
name|peer
operator|.
name|wps
argument_list|)
expr_stmt|;
name|os_free
argument_list|(
name|sm
operator|->
name|root_dir
argument_list|)
expr_stmt|;
name|os_free
argument_list|(
name|sm
operator|->
name|desc_url
argument_list|)
expr_stmt|;
name|os_free
argument_list|(
name|sm
operator|->
name|ctx
argument_list|)
expr_stmt|;
name|os_free
argument_list|(
name|sm
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * upnp_wps_device_init - Initialize WPS UPnP  * @ctx: callback table; we must eventually free it  * @wps: Pointer to longterm WPS context  * @priv: External context data that will be used in callbacks  * Returns: WPS UPnP state or %NULL on failure  */
end_comment

begin_function
name|struct
name|upnp_wps_device_sm
modifier|*
name|upnp_wps_device_init
parameter_list|(
name|struct
name|upnp_wps_device_ctx
modifier|*
name|ctx
parameter_list|,
name|struct
name|wps_context
modifier|*
name|wps
parameter_list|,
name|void
modifier|*
name|priv
parameter_list|)
block|{
name|struct
name|upnp_wps_device_sm
modifier|*
name|sm
decl_stmt|;
name|sm
operator|=
name|os_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|sm
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sm
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_ERROR
argument_list|,
literal|"WPS UPnP: upnp_wps_device_init failed"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|sm
operator|->
name|ctx
operator|=
name|ctx
expr_stmt|;
name|sm
operator|->
name|wps
operator|=
name|wps
expr_stmt|;
name|sm
operator|->
name|priv
operator|=
name|priv
expr_stmt|;
return|return
name|sm
return|;
block|}
end_function

begin_comment
comment|/**  * upnp_wps_subscribers - Check whether there are any event subscribers  * @sm: WPS UPnP state machine from upnp_wps_device_init()  * Returns: 0 if no subscribers, 1 if subscribers  */
end_comment

begin_function
name|int
name|upnp_wps_subscribers
parameter_list|(
name|struct
name|upnp_wps_device_sm
modifier|*
name|sm
parameter_list|)
block|{
return|return
name|sm
operator|->
name|subscriptions
operator|!=
name|NULL
return|;
block|}
end_function

end_unit

