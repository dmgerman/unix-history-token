begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * UPnP WPS Device - Event processing  * Copyright (c) 2000-2003 Intel Corporation  * Copyright (c) 2006-2007 Sony Corporation  * Copyright (c) 2008-2009 Atheros Communications  * Copyright (c) 2009-2010, Jouni Malinen<j@w1.fi>  *  * See wps_upnp.c for more details on licensing and code history.  */
end_comment

begin_include
include|#
directive|include
file|"includes.h"
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|"common.h"
end_include

begin_include
include|#
directive|include
file|"eloop.h"
end_include

begin_include
include|#
directive|include
file|"uuid.h"
end_include

begin_include
include|#
directive|include
file|"http_client.h"
end_include

begin_include
include|#
directive|include
file|"wps_defs.h"
end_include

begin_include
include|#
directive|include
file|"wps_upnp.h"
end_include

begin_include
include|#
directive|include
file|"wps_upnp_i.h"
end_include

begin_comment
comment|/*  * Event message generation (to subscribers)  *  * We make a separate copy for each message for each subscriber. This memory  * wasted could be limited (adding code complexity) by sharing copies, keeping  * a usage count and freeing when zero.  *  * Sending a message requires using a HTTP over TCP NOTIFY  * (like a PUT) which requires a number of states..  */
end_comment

begin_define
define|#
directive|define
name|MAX_EVENTS_QUEUED
value|20
end_define

begin_comment
comment|/* How far behind queued events */
end_comment

begin_define
define|#
directive|define
name|MAX_FAILURES
value|10
end_define

begin_comment
comment|/* Drop subscription after this many failures */
end_comment

begin_comment
comment|/* How long to wait before sending event */
end_comment

begin_define
define|#
directive|define
name|EVENT_DELAY_SECONDS
value|0
end_define

begin_define
define|#
directive|define
name|EVENT_DELAY_MSEC
value|0
end_define

begin_comment
comment|/*  * Event information that we send to each subscriber is remembered in this  * struct. The event cannot be sent by simple UDP; it has to be sent by a HTTP  * over TCP transaction which requires various states.. It may also need to be  * retried at a different address (if more than one is available).  *  * TODO: As an optimization we could share data between subscribers.  */
end_comment

begin_struct
struct|struct
name|wps_event_
block|{
name|struct
name|dl_list
name|list
decl_stmt|;
name|struct
name|subscription
modifier|*
name|s
decl_stmt|;
comment|/* parent */
name|unsigned
name|subscriber_sequence
decl_stmt|;
comment|/* which event for this subscription*/
name|unsigned
name|int
name|retry
decl_stmt|;
comment|/* which retry */
name|struct
name|subscr_addr
modifier|*
name|addr
decl_stmt|;
comment|/* address to connect to */
name|struct
name|wpabuf
modifier|*
name|data
decl_stmt|;
comment|/* event data to send */
name|struct
name|http_client
modifier|*
name|http_event
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* event_clean -- clean sockets etc. of event  * Leaves data, retry count etc. alone.  */
end_comment

begin_function
specifier|static
name|void
name|event_clean
parameter_list|(
name|struct
name|wps_event_
modifier|*
name|e
parameter_list|)
block|{
if|if
condition|(
name|e
operator|->
name|s
operator|->
name|current_event
operator|==
name|e
condition|)
name|e
operator|->
name|s
operator|->
name|current_event
operator|=
name|NULL
expr_stmt|;
name|http_client_free
argument_list|(
name|e
operator|->
name|http_event
argument_list|)
expr_stmt|;
name|e
operator|->
name|http_event
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* event_delete -- delete single unqueued event  * (be sure to dequeue first if need be)  */
end_comment

begin_function
specifier|static
name|void
name|event_delete
parameter_list|(
name|struct
name|wps_event_
modifier|*
name|e
parameter_list|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"WPS UPnP: Delete event %p"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|event_clean
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|wpabuf_free
argument_list|(
name|e
operator|->
name|data
argument_list|)
expr_stmt|;
name|os_free
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* event_dequeue -- get next event from the queue  * Returns NULL if empty.  */
end_comment

begin_function
specifier|static
name|struct
name|wps_event_
modifier|*
name|event_dequeue
parameter_list|(
name|struct
name|subscription
modifier|*
name|s
parameter_list|)
block|{
name|struct
name|wps_event_
modifier|*
name|e
decl_stmt|;
name|e
operator|=
name|dl_list_first
argument_list|(
operator|&
name|s
operator|->
name|event_queue
argument_list|,
expr|struct
name|wps_event_
argument_list|,
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"WPS UPnP: Dequeue event %p for "
literal|"subscription %p"
argument_list|,
name|e
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|dl_list_del
argument_list|(
operator|&
name|e
operator|->
name|list
argument_list|)
expr_stmt|;
block|}
return|return
name|e
return|;
block|}
end_function

begin_comment
comment|/* event_delete_all -- delete entire event queue and current event */
end_comment

begin_function
name|void
name|event_delete_all
parameter_list|(
name|struct
name|subscription
modifier|*
name|s
parameter_list|)
block|{
name|struct
name|wps_event_
modifier|*
name|e
decl_stmt|;
while|while
condition|(
operator|(
name|e
operator|=
name|event_dequeue
argument_list|(
name|s
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|event_delete
argument_list|(
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|current_event
condition|)
block|{
name|event_delete
argument_list|(
name|s
operator|->
name|current_event
argument_list|)
expr_stmt|;
comment|/* will set: s->current_event = NULL;  */
block|}
block|}
end_function

begin_comment
comment|/**  * event_retry - Called when we had a failure delivering event msg  * @e: Event  * @do_next_address: skip address e.g. on connect fail  */
end_comment

begin_function
specifier|static
name|void
name|event_retry
parameter_list|(
name|struct
name|wps_event_
modifier|*
name|e
parameter_list|,
name|int
name|do_next_address
parameter_list|)
block|{
name|struct
name|subscription
modifier|*
name|s
init|=
name|e
operator|->
name|s
decl_stmt|;
name|struct
name|upnp_wps_device_sm
modifier|*
name|sm
init|=
name|s
operator|->
name|sm
decl_stmt|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"WPS UPnP: Retry event %p for subscription %p"
argument_list|,
name|e
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|event_clean
argument_list|(
name|e
argument_list|)
expr_stmt|;
comment|/* will set: s->current_event = NULL; */
if|if
condition|(
name|do_next_address
condition|)
block|{
name|e
operator|->
name|retry
operator|++
expr_stmt|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"WPS UPnP: Try address %d"
argument_list|,
name|e
operator|->
name|retry
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|e
operator|->
name|retry
operator|>=
name|dl_list_len
argument_list|(
operator|&
name|s
operator|->
name|addr_list
argument_list|)
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"WPS UPnP: Giving up on sending event "
literal|"for %s"
argument_list|,
name|e
operator|->
name|addr
operator|->
name|domain_and_port
argument_list|)
expr_stmt|;
name|event_delete
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|s
operator|->
name|last_event_failed
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|dl_list_empty
argument_list|(
operator|&
name|s
operator|->
name|event_queue
argument_list|)
condition|)
name|event_send_all_later
argument_list|(
name|s
operator|->
name|sm
argument_list|)
expr_stmt|;
return|return;
block|}
name|dl_list_add
argument_list|(
operator|&
name|s
operator|->
name|event_queue
argument_list|,
operator|&
name|e
operator|->
name|list
argument_list|)
expr_stmt|;
name|event_send_all_later
argument_list|(
name|sm
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|wpabuf
modifier|*
name|event_build_message
parameter_list|(
name|struct
name|wps_event_
modifier|*
name|e
parameter_list|)
block|{
name|struct
name|wpabuf
modifier|*
name|buf
decl_stmt|;
name|char
modifier|*
name|b
decl_stmt|;
name|buf
operator|=
name|wpabuf_alloc
argument_list|(
literal|1000
operator|+
name|wpabuf_len
argument_list|(
name|e
operator|->
name|data
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|wpabuf_printf
argument_list|(
name|buf
argument_list|,
literal|"NOTIFY %s HTTP/1.1\r\n"
argument_list|,
name|e
operator|->
name|addr
operator|->
name|path
argument_list|)
expr_stmt|;
name|wpabuf_put_str
argument_list|(
name|buf
argument_list|,
literal|"SERVER: Unspecified, UPnP/1.0, Unspecified\r\n"
argument_list|)
expr_stmt|;
name|wpabuf_printf
argument_list|(
name|buf
argument_list|,
literal|"HOST: %s\r\n"
argument_list|,
name|e
operator|->
name|addr
operator|->
name|domain_and_port
argument_list|)
expr_stmt|;
name|wpabuf_put_str
argument_list|(
name|buf
argument_list|,
literal|"CONTENT-TYPE: text/xml; charset=\"utf-8\"\r\n"
literal|"NT: upnp:event\r\n"
literal|"NTS: upnp:propchange\r\n"
argument_list|)
expr_stmt|;
name|wpabuf_put_str
argument_list|(
name|buf
argument_list|,
literal|"SID: uuid:"
argument_list|)
expr_stmt|;
name|b
operator|=
name|wpabuf_put
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|uuid_bin2str
argument_list|(
name|e
operator|->
name|s
operator|->
name|uuid
argument_list|,
name|b
argument_list|,
literal|80
argument_list|)
expr_stmt|;
name|wpabuf_put
argument_list|(
name|buf
argument_list|,
name|os_strlen
argument_list|(
name|b
argument_list|)
argument_list|)
expr_stmt|;
name|wpabuf_put_str
argument_list|(
name|buf
argument_list|,
literal|"\r\n"
argument_list|)
expr_stmt|;
name|wpabuf_printf
argument_list|(
name|buf
argument_list|,
literal|"SEQ: %u\r\n"
argument_list|,
name|e
operator|->
name|subscriber_sequence
argument_list|)
expr_stmt|;
name|wpabuf_printf
argument_list|(
name|buf
argument_list|,
literal|"CONTENT-LENGTH: %d\r\n"
argument_list|,
operator|(
name|int
operator|)
name|wpabuf_len
argument_list|(
name|e
operator|->
name|data
argument_list|)
argument_list|)
expr_stmt|;
name|wpabuf_put_str
argument_list|(
name|buf
argument_list|,
literal|"\r\n"
argument_list|)
expr_stmt|;
comment|/* terminating empty line */
name|wpabuf_put_buf
argument_list|(
name|buf
argument_list|,
name|e
operator|->
name|data
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|event_addr_failure
parameter_list|(
name|struct
name|wps_event_
modifier|*
name|e
parameter_list|)
block|{
name|struct
name|subscription
modifier|*
name|s
init|=
name|e
operator|->
name|s
decl_stmt|;
name|e
operator|->
name|addr
operator|->
name|num_failures
operator|++
expr_stmt|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"WPS UPnP: Failed to send event %p to %s "
literal|"(num_failures=%u)"
argument_list|,
name|e
argument_list|,
name|e
operator|->
name|addr
operator|->
name|domain_and_port
argument_list|,
name|e
operator|->
name|addr
operator|->
name|num_failures
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|addr
operator|->
name|num_failures
operator|<
name|MAX_FAILURES
condition|)
block|{
comment|/* Try other addresses, if available */
name|event_retry
argument_list|(
name|e
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * If other side doesn't like what we say, forget about them. 	 * (There is no way to tell other side that we are dropping them...). 	 */
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"WPS UPnP: Deleting subscription %p "
literal|"address %s due to errors"
argument_list|,
name|s
argument_list|,
name|e
operator|->
name|addr
operator|->
name|domain_and_port
argument_list|)
expr_stmt|;
name|dl_list_del
argument_list|(
operator|&
name|e
operator|->
name|addr
operator|->
name|list
argument_list|)
expr_stmt|;
name|subscr_addr_delete
argument_list|(
name|e
operator|->
name|addr
argument_list|)
expr_stmt|;
name|e
operator|->
name|addr
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|dl_list_empty
argument_list|(
operator|&
name|s
operator|->
name|addr_list
argument_list|)
condition|)
block|{
comment|/* if we've given up on all addresses */
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"WPS UPnP: Removing subscription %p "
literal|"with no addresses"
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|dl_list_del
argument_list|(
operator|&
name|s
operator|->
name|list
argument_list|)
expr_stmt|;
name|subscription_destroy
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Try other addresses, if available */
name|event_retry
argument_list|(
name|e
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|event_http_cb
parameter_list|(
name|void
modifier|*
name|ctx
parameter_list|,
name|struct
name|http_client
modifier|*
name|c
parameter_list|,
name|enum
name|http_client_event
name|event
parameter_list|)
block|{
name|struct
name|wps_event_
modifier|*
name|e
init|=
name|ctx
decl_stmt|;
name|struct
name|subscription
modifier|*
name|s
init|=
name|e
operator|->
name|s
decl_stmt|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"WPS UPnP: HTTP client callback: e=%p c=%p "
literal|"event=%d"
argument_list|,
name|e
argument_list|,
name|c
argument_list|,
name|event
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|event
condition|)
block|{
case|case
name|HTTP_CLIENT_OK
case|:
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"WPS UPnP: Got event %p reply OK from %s"
argument_list|,
name|e
argument_list|,
name|e
operator|->
name|addr
operator|->
name|domain_and_port
argument_list|)
expr_stmt|;
name|e
operator|->
name|addr
operator|->
name|num_failures
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|last_event_failed
operator|=
literal|0
expr_stmt|;
name|event_delete
argument_list|(
name|e
argument_list|)
expr_stmt|;
comment|/* Schedule sending more if there is more to send */
if|if
condition|(
operator|!
name|dl_list_empty
argument_list|(
operator|&
name|s
operator|->
name|event_queue
argument_list|)
condition|)
name|event_send_all_later
argument_list|(
name|s
operator|->
name|sm
argument_list|)
expr_stmt|;
break|break;
case|case
name|HTTP_CLIENT_FAILED
case|:
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"WPS UPnP: Event send failure"
argument_list|)
expr_stmt|;
name|event_addr_failure
argument_list|(
name|e
argument_list|)
expr_stmt|;
break|break;
case|case
name|HTTP_CLIENT_INVALID_REPLY
case|:
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"WPS UPnP: Invalid reply"
argument_list|)
expr_stmt|;
name|event_addr_failure
argument_list|(
name|e
argument_list|)
expr_stmt|;
break|break;
case|case
name|HTTP_CLIENT_TIMEOUT
case|:
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"WPS UPnP: Event send timeout"
argument_list|)
expr_stmt|;
name|event_addr_failure
argument_list|(
name|e
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* event_send_start -- prepare to send a event message to subscriber  *  * This gets complicated because:  * -- The message is sent via TCP and we have to keep the stream open  *      for 30 seconds to get a response... then close it.  * -- But we might have other event happen in the meantime...  *      we have to queue them, if we lose them then the subscriber will  *      be forced to unsubscribe and subscribe again.  * -- If multiple URLs are provided then we are supposed to try successive  *      ones after 30 second timeout.  * -- The URLs might use domain names instead of dotted decimal addresses,  *      and resolution of those may cause unwanted sleeping.  * -- Doing the initial TCP connect can take a while, so we have to come  *      back after connection and then send the data.  *  * Returns nonzero on error;  *  * Prerequisite: No current event send (s->current_event == NULL)  *      and non-empty queue.  */
end_comment

begin_function
specifier|static
name|int
name|event_send_start
parameter_list|(
name|struct
name|subscription
modifier|*
name|s
parameter_list|)
block|{
name|struct
name|wps_event_
modifier|*
name|e
decl_stmt|;
name|unsigned
name|int
name|itry
decl_stmt|;
name|struct
name|wpabuf
modifier|*
name|buf
decl_stmt|;
comment|/* 	 * Assume we are called ONLY with no current event and ONLY with 	 * nonempty event queue and ONLY with at least one address to send to. 	 */
if|if
condition|(
name|dl_list_empty
argument_list|(
operator|&
name|s
operator|->
name|addr_list
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|s
operator|->
name|current_event
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|dl_list_empty
argument_list|(
operator|&
name|s
operator|->
name|event_queue
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|s
operator|->
name|current_event
operator|=
name|e
operator|=
name|event_dequeue
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* Use address according to number of retries */
name|itry
operator|=
literal|0
expr_stmt|;
name|dl_list_for_each
argument_list|(
argument|e->addr
argument_list|,
argument|&s->addr_list
argument_list|,
argument|struct subscr_addr
argument_list|,
argument|list
argument_list|)
if|if
condition|(
name|itry
operator|++
operator|==
name|e
operator|->
name|retry
condition|)
break|break;
if|if
condition|(
name|itry
operator|<
name|e
operator|->
name|retry
condition|)
return|return
operator|-
literal|1
return|;
name|buf
operator|=
name|event_build_message
argument_list|(
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
block|{
name|event_retry
argument_list|(
name|e
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|e
operator|->
name|http_event
operator|=
name|http_client_addr
argument_list|(
operator|&
name|e
operator|->
name|addr
operator|->
name|saddr
argument_list|,
name|buf
argument_list|,
literal|0
argument_list|,
name|event_http_cb
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|http_event
operator|==
name|NULL
condition|)
block|{
name|wpabuf_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|event_retry
argument_list|(
name|e
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* event_send_all_later_handler -- actually send events as needed */
end_comment

begin_function
specifier|static
name|void
name|event_send_all_later_handler
parameter_list|(
name|void
modifier|*
name|eloop_data
parameter_list|,
name|void
modifier|*
name|user_ctx
parameter_list|)
block|{
name|struct
name|upnp_wps_device_sm
modifier|*
name|sm
init|=
name|user_ctx
decl_stmt|;
name|struct
name|subscription
modifier|*
name|s
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
name|int
name|nerrors
init|=
literal|0
decl_stmt|;
name|sm
operator|->
name|event_send_all_queued
operator|=
literal|0
expr_stmt|;
name|dl_list_for_each_safe
argument_list|(
argument|s
argument_list|,
argument|tmp
argument_list|,
argument|&sm->subscriptions
argument_list|,
argument|struct subscription
argument_list|,
argument|list
argument_list|)
block|{
if|if
condition|(
name|s
operator|->
name|current_event
operator|==
name|NULL
comment|/* not busy */
operator|&&
operator|!
name|dl_list_empty
argument_list|(
operator|&
name|s
operator|->
name|event_queue
argument_list|)
comment|/* more to do */
condition|)
block|{
if|if
condition|(
name|event_send_start
argument_list|(
name|s
argument_list|)
condition|)
name|nerrors
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|nerrors
condition|)
block|{
comment|/* Try again later */
name|event_send_all_later
argument_list|(
name|sm
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* event_send_all_later -- schedule sending events to all subscribers  * that need it.  * This avoids two problems:  * -- After getting a subscription, we should not send the first event  *      until after our reply is fully queued to be sent back,  * -- Possible stack depth or infinite recursion issues.  */
end_comment

begin_function
name|void
name|event_send_all_later
parameter_list|(
name|struct
name|upnp_wps_device_sm
modifier|*
name|sm
parameter_list|)
block|{
comment|/* 	 * The exact time in the future isn't too important. Waiting a bit 	 * might let us do several together. 	 */
if|if
condition|(
name|sm
operator|->
name|event_send_all_queued
condition|)
return|return;
name|sm
operator|->
name|event_send_all_queued
operator|=
literal|1
expr_stmt|;
name|eloop_register_timeout
argument_list|(
name|EVENT_DELAY_SECONDS
argument_list|,
name|EVENT_DELAY_MSEC
argument_list|,
name|event_send_all_later_handler
argument_list|,
name|NULL
argument_list|,
name|sm
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* event_send_stop_all -- cleanup */
end_comment

begin_function
name|void
name|event_send_stop_all
parameter_list|(
name|struct
name|upnp_wps_device_sm
modifier|*
name|sm
parameter_list|)
block|{
if|if
condition|(
name|sm
operator|->
name|event_send_all_queued
condition|)
name|eloop_cancel_timeout
argument_list|(
name|event_send_all_later_handler
argument_list|,
name|NULL
argument_list|,
name|sm
argument_list|)
expr_stmt|;
name|sm
operator|->
name|event_send_all_queued
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * event_add - Add a new event to a queue  * @s: Subscription  * @data: Event data (is copied; caller retains ownership)  * @probereq: Whether this is a Probe Request event  * Returns: 0 on success, -1 on error, 1 on max event queue limit reached  */
end_comment

begin_function
name|int
name|event_add
parameter_list|(
name|struct
name|subscription
modifier|*
name|s
parameter_list|,
specifier|const
name|struct
name|wpabuf
modifier|*
name|data
parameter_list|,
name|int
name|probereq
parameter_list|)
block|{
name|struct
name|wps_event_
modifier|*
name|e
decl_stmt|;
name|unsigned
name|int
name|len
decl_stmt|;
name|len
operator|=
name|dl_list_len
argument_list|(
operator|&
name|s
operator|->
name|event_queue
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>=
name|MAX_EVENTS_QUEUED
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"WPS UPnP: Too many events queued for "
literal|"subscriber %p"
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|probereq
condition|)
return|return
literal|1
return|;
comment|/* Drop oldest entry to allow EAP event to be stored. */
name|e
operator|=
name|event_dequeue
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|e
condition|)
return|return
literal|1
return|;
name|event_delete
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|->
name|last_event_failed
operator|&&
name|probereq
operator|&&
name|len
operator|>
literal|0
condition|)
block|{
comment|/* 		 * Avoid queuing frames for subscribers that may have left 		 * without unsubscribing. 		 */
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"WPS UPnP: Do not queue more Probe "
literal|"Request frames for subscription %p since last "
literal|"delivery failed"
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|e
operator|=
name|os_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|e
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|dl_list_init
argument_list|(
operator|&
name|e
operator|->
name|list
argument_list|)
expr_stmt|;
name|e
operator|->
name|s
operator|=
name|s
expr_stmt|;
name|e
operator|->
name|data
operator|=
name|wpabuf_dup
argument_list|(
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|data
operator|==
name|NULL
condition|)
block|{
name|os_free
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|e
operator|->
name|subscriber_sequence
operator|=
name|s
operator|->
name|next_subscriber_sequence
operator|++
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|next_subscriber_sequence
operator|==
literal|0
condition|)
name|s
operator|->
name|next_subscriber_sequence
operator|++
expr_stmt|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"WPS UPnP: Queue event %p for subscriber %p "
literal|"(queue len %u)"
argument_list|,
name|e
argument_list|,
name|s
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|dl_list_add_tail
argument_list|(
operator|&
name|s
operator|->
name|event_queue
argument_list|,
operator|&
name|e
operator|->
name|list
argument_list|)
expr_stmt|;
name|event_send_all_later
argument_list|(
name|s
operator|->
name|sm
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

end_unit

