begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Driver interaction with Linux nl80211/cfg80211 - Capabilities  * Copyright (c) 2002-2015, Jouni Malinen<j@w1.fi>  * Copyright (c) 2007, Johannes Berg<johannes@sipsolutions.net>  * Copyright (c) 2009-2010, Atheros Communications  *  * This software may be distributed under the terms of the BSD license.  * See README for more details.  */
end_comment

begin_include
include|#
directive|include
file|"includes.h"
end_include

begin_include
include|#
directive|include
file|<netlink/genl/genl.h>
end_include

begin_include
include|#
directive|include
file|"utils/common.h"
end_include

begin_include
include|#
directive|include
file|"common/ieee802_11_defs.h"
end_include

begin_include
include|#
directive|include
file|"common/ieee802_11_common.h"
end_include

begin_include
include|#
directive|include
file|"common/qca-vendor.h"
end_include

begin_include
include|#
directive|include
file|"common/qca-vendor-attr.h"
end_include

begin_include
include|#
directive|include
file|"driver_nl80211.h"
end_include

begin_function
specifier|static
name|int
name|protocol_feature_handler
parameter_list|(
name|struct
name|nl_msg
modifier|*
name|msg
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|u32
modifier|*
name|feat
init|=
name|arg
decl_stmt|;
name|struct
name|nlattr
modifier|*
name|tb_msg
index|[
name|NL80211_ATTR_MAX
operator|+
literal|1
index|]
decl_stmt|;
name|struct
name|genlmsghdr
modifier|*
name|gnlh
init|=
name|nlmsg_data
argument_list|(
name|nlmsg_hdr
argument_list|(
name|msg
argument_list|)
argument_list|)
decl_stmt|;
name|nla_parse
argument_list|(
name|tb_msg
argument_list|,
name|NL80211_ATTR_MAX
argument_list|,
name|genlmsg_attrdata
argument_list|(
name|gnlh
argument_list|,
literal|0
argument_list|)
argument_list|,
name|genlmsg_attrlen
argument_list|(
name|gnlh
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|tb_msg
index|[
name|NL80211_ATTR_PROTOCOL_FEATURES
index|]
condition|)
operator|*
name|feat
operator|=
name|nla_get_u32
argument_list|(
name|tb_msg
index|[
name|NL80211_ATTR_PROTOCOL_FEATURES
index|]
argument_list|)
expr_stmt|;
return|return
name|NL_SKIP
return|;
block|}
end_function

begin_function
specifier|static
name|u32
name|get_nl80211_protocol_features
parameter_list|(
name|struct
name|wpa_driver_nl80211_data
modifier|*
name|drv
parameter_list|)
block|{
name|u32
name|feat
init|=
literal|0
decl_stmt|;
name|struct
name|nl_msg
modifier|*
name|msg
decl_stmt|;
name|msg
operator|=
name|nlmsg_alloc
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|msg
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|nl80211_cmd
argument_list|(
name|drv
argument_list|,
name|msg
argument_list|,
literal|0
argument_list|,
name|NL80211_CMD_GET_PROTOCOL_FEATURES
argument_list|)
condition|)
block|{
name|nlmsg_free
argument_list|(
name|msg
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|send_and_recv_msgs
argument_list|(
name|drv
argument_list|,
name|msg
argument_list|,
name|protocol_feature_handler
argument_list|,
operator|&
name|feat
argument_list|)
operator|==
literal|0
condition|)
return|return
name|feat
return|;
return|return
literal|0
return|;
block|}
end_function

begin_struct
struct|struct
name|wiphy_info_data
block|{
name|struct
name|wpa_driver_nl80211_data
modifier|*
name|drv
decl_stmt|;
name|struct
name|wpa_driver_capa
modifier|*
name|capa
decl_stmt|;
name|unsigned
name|int
name|num_multichan_concurrent
decl_stmt|;
name|unsigned
name|int
name|error
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|device_ap_sme
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|poll_command_supported
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|data_tx_status
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|monitor_supported
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|auth_supported
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|connect_supported
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|p2p_go_supported
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|p2p_client_supported
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|p2p_go_ctwindow_supported
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|p2p_concurrent
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|channel_switch_supported
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|set_qos_map_supported
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|have_low_prio_scan
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|wmm_ac_supported
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|mac_addr_rand_scan_supported
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|mac_addr_rand_sched_scan_supported
range|:
literal|1
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|unsigned
name|int
name|probe_resp_offload_support
parameter_list|(
name|int
name|supp_protocols
parameter_list|)
block|{
name|unsigned
name|int
name|prot
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|supp_protocols
operator|&
name|NL80211_PROBE_RESP_OFFLOAD_SUPPORT_WPS
condition|)
name|prot
operator||=
name|WPA_DRIVER_PROBE_RESP_OFFLOAD_WPS
expr_stmt|;
if|if
condition|(
name|supp_protocols
operator|&
name|NL80211_PROBE_RESP_OFFLOAD_SUPPORT_WPS2
condition|)
name|prot
operator||=
name|WPA_DRIVER_PROBE_RESP_OFFLOAD_WPS2
expr_stmt|;
if|if
condition|(
name|supp_protocols
operator|&
name|NL80211_PROBE_RESP_OFFLOAD_SUPPORT_P2P
condition|)
name|prot
operator||=
name|WPA_DRIVER_PROBE_RESP_OFFLOAD_P2P
expr_stmt|;
if|if
condition|(
name|supp_protocols
operator|&
name|NL80211_PROBE_RESP_OFFLOAD_SUPPORT_80211U
condition|)
name|prot
operator||=
name|WPA_DRIVER_PROBE_RESP_OFFLOAD_INTERWORKING
expr_stmt|;
return|return
name|prot
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|wiphy_info_supported_iftypes
parameter_list|(
name|struct
name|wiphy_info_data
modifier|*
name|info
parameter_list|,
name|struct
name|nlattr
modifier|*
name|tb
parameter_list|)
block|{
name|struct
name|nlattr
modifier|*
name|nl_mode
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|tb
operator|==
name|NULL
condition|)
return|return;
name|nla_for_each_nested
argument_list|(
argument|nl_mode
argument_list|,
argument|tb
argument_list|,
argument|i
argument_list|)
block|{
switch|switch
condition|(
name|nla_type
argument_list|(
name|nl_mode
argument_list|)
condition|)
block|{
case|case
name|NL80211_IFTYPE_AP
case|:
name|info
operator|->
name|capa
operator|->
name|flags
operator||=
name|WPA_DRIVER_FLAGS_AP
expr_stmt|;
break|break;
case|case
name|NL80211_IFTYPE_MESH_POINT
case|:
name|info
operator|->
name|capa
operator|->
name|flags
operator||=
name|WPA_DRIVER_FLAGS_MESH
expr_stmt|;
break|break;
case|case
name|NL80211_IFTYPE_ADHOC
case|:
name|info
operator|->
name|capa
operator|->
name|flags
operator||=
name|WPA_DRIVER_FLAGS_IBSS
expr_stmt|;
break|break;
case|case
name|NL80211_IFTYPE_P2P_DEVICE
case|:
name|info
operator|->
name|capa
operator|->
name|flags
operator||=
name|WPA_DRIVER_FLAGS_DEDICATED_P2P_DEVICE
expr_stmt|;
break|break;
case|case
name|NL80211_IFTYPE_P2P_GO
case|:
name|info
operator|->
name|p2p_go_supported
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|NL80211_IFTYPE_P2P_CLIENT
case|:
name|info
operator|->
name|p2p_client_supported
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|NL80211_IFTYPE_MONITOR
case|:
name|info
operator|->
name|monitor_supported
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|wiphy_info_iface_comb_process
parameter_list|(
name|struct
name|wiphy_info_data
modifier|*
name|info
parameter_list|,
name|struct
name|nlattr
modifier|*
name|nl_combi
parameter_list|)
block|{
name|struct
name|nlattr
modifier|*
name|tb_comb
index|[
name|NUM_NL80211_IFACE_COMB
index|]
decl_stmt|;
name|struct
name|nlattr
modifier|*
name|tb_limit
index|[
name|NUM_NL80211_IFACE_LIMIT
index|]
decl_stmt|;
name|struct
name|nlattr
modifier|*
name|nl_limit
decl_stmt|,
modifier|*
name|nl_mode
decl_stmt|;
name|int
name|err
decl_stmt|,
name|rem_limit
decl_stmt|,
name|rem_mode
decl_stmt|;
name|int
name|combination_has_p2p
init|=
literal|0
decl_stmt|,
name|combination_has_mgd
init|=
literal|0
decl_stmt|;
specifier|static
name|struct
name|nla_policy
name|iface_combination_policy
index|[
name|NUM_NL80211_IFACE_COMB
index|]
init|=
block|{
index|[
name|NL80211_IFACE_COMB_LIMITS
index|]
operator|=
block|{
operator|.
name|type
operator|=
name|NLA_NESTED
block|}
block|,
index|[
name|NL80211_IFACE_COMB_MAXNUM
index|]
operator|=
block|{
operator|.
name|type
operator|=
name|NLA_U32
block|}
block|,
index|[
name|NL80211_IFACE_COMB_STA_AP_BI_MATCH
index|]
operator|=
block|{
operator|.
name|type
operator|=
name|NLA_FLAG
block|}
block|,
index|[
name|NL80211_IFACE_COMB_NUM_CHANNELS
index|]
operator|=
block|{
operator|.
name|type
operator|=
name|NLA_U32
block|}
block|,
index|[
name|NL80211_IFACE_COMB_RADAR_DETECT_WIDTHS
index|]
operator|=
block|{
operator|.
name|type
operator|=
name|NLA_U32
block|}
block|, 	}
decl_stmt|,
name|iface_limit_policy
index|[
name|NUM_NL80211_IFACE_LIMIT
index|]
init|=
block|{
index|[
name|NL80211_IFACE_LIMIT_TYPES
index|]
operator|=
block|{
operator|.
name|type
operator|=
name|NLA_NESTED
block|}
block|,
index|[
name|NL80211_IFACE_LIMIT_MAX
index|]
operator|=
block|{
operator|.
name|type
operator|=
name|NLA_U32
block|}
block|, 	}
decl_stmt|;
name|err
operator|=
name|nla_parse_nested
argument_list|(
name|tb_comb
argument_list|,
name|MAX_NL80211_IFACE_COMB
argument_list|,
name|nl_combi
argument_list|,
name|iface_combination_policy
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|||
operator|!
name|tb_comb
index|[
name|NL80211_IFACE_COMB_LIMITS
index|]
operator|||
operator|!
name|tb_comb
index|[
name|NL80211_IFACE_COMB_MAXNUM
index|]
operator|||
operator|!
name|tb_comb
index|[
name|NL80211_IFACE_COMB_NUM_CHANNELS
index|]
condition|)
return|return
literal|0
return|;
comment|/* broken combination */
if|if
condition|(
name|tb_comb
index|[
name|NL80211_IFACE_COMB_RADAR_DETECT_WIDTHS
index|]
condition|)
name|info
operator|->
name|capa
operator|->
name|flags
operator||=
name|WPA_DRIVER_FLAGS_RADAR
expr_stmt|;
name|nla_for_each_nested
argument_list|(
argument|nl_limit
argument_list|,
argument|tb_comb[NL80211_IFACE_COMB_LIMITS]
argument_list|,
argument|rem_limit
argument_list|)
block|{
name|err
operator|=
name|nla_parse_nested
argument_list|(
name|tb_limit
argument_list|,
name|MAX_NL80211_IFACE_LIMIT
argument_list|,
name|nl_limit
argument_list|,
name|iface_limit_policy
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|||
operator|!
name|tb_limit
index|[
name|NL80211_IFACE_LIMIT_TYPES
index|]
condition|)
return|return
literal|0
return|;
comment|/* broken combination */
name|nla_for_each_nested
argument_list|(
argument|nl_mode
argument_list|,
argument|tb_limit[NL80211_IFACE_LIMIT_TYPES]
argument_list|,
argument|rem_mode
argument_list|)
block|{
name|int
name|ift
init|=
name|nla_type
argument_list|(
name|nl_mode
argument_list|)
decl_stmt|;
if|if
condition|(
name|ift
operator|==
name|NL80211_IFTYPE_P2P_GO
operator|||
name|ift
operator|==
name|NL80211_IFTYPE_P2P_CLIENT
condition|)
name|combination_has_p2p
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|ift
operator|==
name|NL80211_IFTYPE_STATION
condition|)
name|combination_has_mgd
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|combination_has_p2p
operator|&&
name|combination_has_mgd
condition|)
break|break;
block|}
if|if
condition|(
name|combination_has_p2p
operator|&&
name|combination_has_mgd
condition|)
block|{
name|unsigned
name|int
name|num_channels
init|=
name|nla_get_u32
argument_list|(
name|tb_comb
index|[
name|NL80211_IFACE_COMB_NUM_CHANNELS
index|]
argument_list|)
decl_stmt|;
name|info
operator|->
name|p2p_concurrent
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|num_multichan_concurrent
operator|<
name|num_channels
condition|)
name|info
operator|->
name|num_multichan_concurrent
operator|=
name|num_channels
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|wiphy_info_iface_comb
parameter_list|(
name|struct
name|wiphy_info_data
modifier|*
name|info
parameter_list|,
name|struct
name|nlattr
modifier|*
name|tb
parameter_list|)
block|{
name|struct
name|nlattr
modifier|*
name|nl_combi
decl_stmt|;
name|int
name|rem_combi
decl_stmt|;
if|if
condition|(
name|tb
operator|==
name|NULL
condition|)
return|return;
name|nla_for_each_nested
argument_list|(
argument|nl_combi
argument_list|,
argument|tb
argument_list|,
argument|rem_combi
argument_list|)
block|{
if|if
condition|(
name|wiphy_info_iface_comb_process
argument_list|(
name|info
argument_list|,
name|nl_combi
argument_list|)
operator|>
literal|0
condition|)
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|wiphy_info_supp_cmds
parameter_list|(
name|struct
name|wiphy_info_data
modifier|*
name|info
parameter_list|,
name|struct
name|nlattr
modifier|*
name|tb
parameter_list|)
block|{
name|struct
name|nlattr
modifier|*
name|nl_cmd
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|tb
operator|==
name|NULL
condition|)
return|return;
name|nla_for_each_nested
argument_list|(
argument|nl_cmd
argument_list|,
argument|tb
argument_list|,
argument|i
argument_list|)
block|{
switch|switch
condition|(
name|nla_get_u32
argument_list|(
name|nl_cmd
argument_list|)
condition|)
block|{
case|case
name|NL80211_CMD_AUTHENTICATE
case|:
name|info
operator|->
name|auth_supported
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|NL80211_CMD_CONNECT
case|:
name|info
operator|->
name|connect_supported
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|NL80211_CMD_START_SCHED_SCAN
case|:
name|info
operator|->
name|capa
operator|->
name|sched_scan_supported
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|NL80211_CMD_PROBE_CLIENT
case|:
name|info
operator|->
name|poll_command_supported
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|NL80211_CMD_CHANNEL_SWITCH
case|:
name|info
operator|->
name|channel_switch_supported
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|NL80211_CMD_SET_QOS_MAP
case|:
name|info
operator|->
name|set_qos_map_supported
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|wiphy_info_cipher_suites
parameter_list|(
name|struct
name|wiphy_info_data
modifier|*
name|info
parameter_list|,
name|struct
name|nlattr
modifier|*
name|tb
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|num
decl_stmt|;
name|u32
modifier|*
name|ciphers
decl_stmt|;
if|if
condition|(
name|tb
operator|==
name|NULL
condition|)
return|return;
name|num
operator|=
name|nla_len
argument_list|(
name|tb
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
expr_stmt|;
name|ciphers
operator|=
name|nla_data
argument_list|(
name|tb
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
block|{
name|u32
name|c
init|=
name|ciphers
index|[
name|i
index|]
decl_stmt|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"nl80211: Supported cipher %02x-%02x-%02x:%d"
argument_list|,
name|c
operator|>>
literal|24
argument_list|,
operator|(
name|c
operator|>>
literal|16
operator|)
operator|&
literal|0xff
argument_list|,
operator|(
name|c
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|,
name|c
operator|&
literal|0xff
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|WLAN_CIPHER_SUITE_CCMP_256
case|:
name|info
operator|->
name|capa
operator|->
name|enc
operator||=
name|WPA_DRIVER_CAPA_ENC_CCMP_256
expr_stmt|;
break|break;
case|case
name|WLAN_CIPHER_SUITE_GCMP_256
case|:
name|info
operator|->
name|capa
operator|->
name|enc
operator||=
name|WPA_DRIVER_CAPA_ENC_GCMP_256
expr_stmt|;
break|break;
case|case
name|WLAN_CIPHER_SUITE_CCMP
case|:
name|info
operator|->
name|capa
operator|->
name|enc
operator||=
name|WPA_DRIVER_CAPA_ENC_CCMP
expr_stmt|;
break|break;
case|case
name|WLAN_CIPHER_SUITE_GCMP
case|:
name|info
operator|->
name|capa
operator|->
name|enc
operator||=
name|WPA_DRIVER_CAPA_ENC_GCMP
expr_stmt|;
break|break;
case|case
name|WLAN_CIPHER_SUITE_TKIP
case|:
name|info
operator|->
name|capa
operator|->
name|enc
operator||=
name|WPA_DRIVER_CAPA_ENC_TKIP
expr_stmt|;
break|break;
case|case
name|WLAN_CIPHER_SUITE_WEP104
case|:
name|info
operator|->
name|capa
operator|->
name|enc
operator||=
name|WPA_DRIVER_CAPA_ENC_WEP104
expr_stmt|;
break|break;
case|case
name|WLAN_CIPHER_SUITE_WEP40
case|:
name|info
operator|->
name|capa
operator|->
name|enc
operator||=
name|WPA_DRIVER_CAPA_ENC_WEP40
expr_stmt|;
break|break;
case|case
name|WLAN_CIPHER_SUITE_AES_CMAC
case|:
name|info
operator|->
name|capa
operator|->
name|enc
operator||=
name|WPA_DRIVER_CAPA_ENC_BIP
expr_stmt|;
break|break;
case|case
name|WLAN_CIPHER_SUITE_BIP_GMAC_128
case|:
name|info
operator|->
name|capa
operator|->
name|enc
operator||=
name|WPA_DRIVER_CAPA_ENC_BIP_GMAC_128
expr_stmt|;
break|break;
case|case
name|WLAN_CIPHER_SUITE_BIP_GMAC_256
case|:
name|info
operator|->
name|capa
operator|->
name|enc
operator||=
name|WPA_DRIVER_CAPA_ENC_BIP_GMAC_256
expr_stmt|;
break|break;
case|case
name|WLAN_CIPHER_SUITE_BIP_CMAC_256
case|:
name|info
operator|->
name|capa
operator|->
name|enc
operator||=
name|WPA_DRIVER_CAPA_ENC_BIP_CMAC_256
expr_stmt|;
break|break;
case|case
name|WLAN_CIPHER_SUITE_NO_GROUP_ADDR
case|:
name|info
operator|->
name|capa
operator|->
name|enc
operator||=
name|WPA_DRIVER_CAPA_ENC_GTK_NOT_USED
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|wiphy_info_max_roc
parameter_list|(
name|struct
name|wpa_driver_capa
modifier|*
name|capa
parameter_list|,
name|struct
name|nlattr
modifier|*
name|tb
parameter_list|)
block|{
if|if
condition|(
name|tb
condition|)
name|capa
operator|->
name|max_remain_on_chan
operator|=
name|nla_get_u32
argument_list|(
name|tb
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|wiphy_info_tdls
parameter_list|(
name|struct
name|wpa_driver_capa
modifier|*
name|capa
parameter_list|,
name|struct
name|nlattr
modifier|*
name|tdls
parameter_list|,
name|struct
name|nlattr
modifier|*
name|ext_setup
parameter_list|)
block|{
if|if
condition|(
name|tdls
operator|==
name|NULL
condition|)
return|return;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"nl80211: TDLS supported"
argument_list|)
expr_stmt|;
name|capa
operator|->
name|flags
operator||=
name|WPA_DRIVER_FLAGS_TDLS_SUPPORT
expr_stmt|;
if|if
condition|(
name|ext_setup
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"nl80211: TDLS external setup"
argument_list|)
expr_stmt|;
name|capa
operator|->
name|flags
operator||=
name|WPA_DRIVER_FLAGS_TDLS_EXTERNAL_SETUP
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|ext_feature_isset
parameter_list|(
specifier|const
name|u8
modifier|*
name|ext_features
parameter_list|,
name|int
name|ext_features_len
parameter_list|,
name|enum
name|nl80211_ext_feature_index
name|ftidx
parameter_list|)
block|{
name|u8
name|ft_byte
decl_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|ftidx
operator|/
literal|8
operator|>=
name|ext_features_len
condition|)
return|return
literal|0
return|;
name|ft_byte
operator|=
name|ext_features
index|[
name|ftidx
operator|/
literal|8
index|]
expr_stmt|;
return|return
operator|(
name|ft_byte
operator|&
name|BIT
argument_list|(
name|ftidx
operator|%
literal|8
argument_list|)
operator|)
operator|!=
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|wiphy_info_ext_feature_flags
parameter_list|(
name|struct
name|wiphy_info_data
modifier|*
name|info
parameter_list|,
name|struct
name|nlattr
modifier|*
name|tb
parameter_list|)
block|{
name|struct
name|wpa_driver_capa
modifier|*
name|capa
init|=
name|info
operator|->
name|capa
decl_stmt|;
if|if
condition|(
name|tb
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|ext_feature_isset
argument_list|(
name|nla_data
argument_list|(
name|tb
argument_list|)
argument_list|,
name|nla_len
argument_list|(
name|tb
argument_list|)
argument_list|,
name|NL80211_EXT_FEATURE_VHT_IBSS
argument_list|)
condition|)
name|capa
operator|->
name|flags
operator||=
name|WPA_DRIVER_FLAGS_VHT_IBSS
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|wiphy_info_feature_flags
parameter_list|(
name|struct
name|wiphy_info_data
modifier|*
name|info
parameter_list|,
name|struct
name|nlattr
modifier|*
name|tb
parameter_list|)
block|{
name|u32
name|flags
decl_stmt|;
name|struct
name|wpa_driver_capa
modifier|*
name|capa
init|=
name|info
operator|->
name|capa
decl_stmt|;
if|if
condition|(
name|tb
operator|==
name|NULL
condition|)
return|return;
name|flags
operator|=
name|nla_get_u32
argument_list|(
name|tb
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|NL80211_FEATURE_SK_TX_STATUS
condition|)
name|info
operator|->
name|data_tx_status
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|NL80211_FEATURE_INACTIVITY_TIMER
condition|)
name|capa
operator|->
name|flags
operator||=
name|WPA_DRIVER_FLAGS_INACTIVITY_TIMER
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|NL80211_FEATURE_SAE
condition|)
name|capa
operator|->
name|flags
operator||=
name|WPA_DRIVER_FLAGS_SAE
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|NL80211_FEATURE_NEED_OBSS_SCAN
condition|)
name|capa
operator|->
name|flags
operator||=
name|WPA_DRIVER_FLAGS_OBSS_SCAN
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|NL80211_FEATURE_AP_MODE_CHAN_WIDTH_CHANGE
condition|)
name|capa
operator|->
name|flags
operator||=
name|WPA_DRIVER_FLAGS_HT_2040_COEX
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|NL80211_FEATURE_TDLS_CHANNEL_SWITCH
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"nl80211: TDLS channel switch"
argument_list|)
expr_stmt|;
name|capa
operator|->
name|flags
operator||=
name|WPA_DRIVER_FLAGS_TDLS_CHANNEL_SWITCH
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|NL80211_FEATURE_P2P_GO_CTWIN
condition|)
name|info
operator|->
name|p2p_go_ctwindow_supported
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|NL80211_FEATURE_LOW_PRIORITY_SCAN
condition|)
name|info
operator|->
name|have_low_prio_scan
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|NL80211_FEATURE_SCAN_RANDOM_MAC_ADDR
condition|)
name|info
operator|->
name|mac_addr_rand_scan_supported
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|NL80211_FEATURE_SCHED_SCAN_RANDOM_MAC_ADDR
condition|)
name|info
operator|->
name|mac_addr_rand_sched_scan_supported
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|NL80211_FEATURE_STATIC_SMPS
condition|)
name|capa
operator|->
name|smps_modes
operator||=
name|WPA_DRIVER_SMPS_MODE_STATIC
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|NL80211_FEATURE_DYNAMIC_SMPS
condition|)
name|capa
operator|->
name|smps_modes
operator||=
name|WPA_DRIVER_SMPS_MODE_DYNAMIC
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|NL80211_FEATURE_SUPPORTS_WMM_ADMISSION
condition|)
name|info
operator|->
name|wmm_ac_supported
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|NL80211_FEATURE_DS_PARAM_SET_IE_IN_PROBES
condition|)
name|capa
operator|->
name|rrm_flags
operator||=
name|WPA_DRIVER_FLAGS_DS_PARAM_SET_IE_IN_PROBES
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|NL80211_FEATURE_WFA_TPC_IE_IN_PROBES
condition|)
name|capa
operator|->
name|rrm_flags
operator||=
name|WPA_DRIVER_FLAGS_WFA_TPC_IE_IN_PROBES
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|NL80211_FEATURE_QUIET
condition|)
name|capa
operator|->
name|rrm_flags
operator||=
name|WPA_DRIVER_FLAGS_QUIET
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|NL80211_FEATURE_TX_POWER_INSERTION
condition|)
name|capa
operator|->
name|rrm_flags
operator||=
name|WPA_DRIVER_FLAGS_TX_POWER_INSERTION
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|NL80211_FEATURE_HT_IBSS
condition|)
name|capa
operator|->
name|flags
operator||=
name|WPA_DRIVER_FLAGS_HT_IBSS
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|wiphy_info_probe_resp_offload
parameter_list|(
name|struct
name|wpa_driver_capa
modifier|*
name|capa
parameter_list|,
name|struct
name|nlattr
modifier|*
name|tb
parameter_list|)
block|{
name|u32
name|protocols
decl_stmt|;
if|if
condition|(
name|tb
operator|==
name|NULL
condition|)
return|return;
name|protocols
operator|=
name|nla_get_u32
argument_list|(
name|tb
argument_list|)
expr_stmt|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"nl80211: Supports Probe Response offload in AP "
literal|"mode"
argument_list|)
expr_stmt|;
name|capa
operator|->
name|flags
operator||=
name|WPA_DRIVER_FLAGS_PROBE_RESP_OFFLOAD
expr_stmt|;
name|capa
operator|->
name|probe_resp_offloads
operator|=
name|probe_resp_offload_support
argument_list|(
name|protocols
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|wiphy_info_wowlan_triggers
parameter_list|(
name|struct
name|wpa_driver_capa
modifier|*
name|capa
parameter_list|,
name|struct
name|nlattr
modifier|*
name|tb
parameter_list|)
block|{
name|struct
name|nlattr
modifier|*
name|triggers
index|[
name|MAX_NL80211_WOWLAN_TRIG
operator|+
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|tb
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|nla_parse_nested
argument_list|(
name|triggers
argument_list|,
name|MAX_NL80211_WOWLAN_TRIG
argument_list|,
name|tb
argument_list|,
name|NULL
argument_list|)
condition|)
return|return;
if|if
condition|(
name|triggers
index|[
name|NL80211_WOWLAN_TRIG_ANY
index|]
condition|)
name|capa
operator|->
name|wowlan_triggers
operator|.
name|any
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|triggers
index|[
name|NL80211_WOWLAN_TRIG_DISCONNECT
index|]
condition|)
name|capa
operator|->
name|wowlan_triggers
operator|.
name|disconnect
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|triggers
index|[
name|NL80211_WOWLAN_TRIG_MAGIC_PKT
index|]
condition|)
name|capa
operator|->
name|wowlan_triggers
operator|.
name|magic_pkt
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|triggers
index|[
name|NL80211_WOWLAN_TRIG_GTK_REKEY_FAILURE
index|]
condition|)
name|capa
operator|->
name|wowlan_triggers
operator|.
name|gtk_rekey_failure
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|triggers
index|[
name|NL80211_WOWLAN_TRIG_EAP_IDENT_REQUEST
index|]
condition|)
name|capa
operator|->
name|wowlan_triggers
operator|.
name|eap_identity_req
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|triggers
index|[
name|NL80211_WOWLAN_TRIG_4WAY_HANDSHAKE
index|]
condition|)
name|capa
operator|->
name|wowlan_triggers
operator|.
name|four_way_handshake
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|triggers
index|[
name|NL80211_WOWLAN_TRIG_RFKILL_RELEASE
index|]
condition|)
name|capa
operator|->
name|wowlan_triggers
operator|.
name|rfkill_release
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|wiphy_info_handler
parameter_list|(
name|struct
name|nl_msg
modifier|*
name|msg
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|nlattr
modifier|*
name|tb
index|[
name|NL80211_ATTR_MAX
operator|+
literal|1
index|]
decl_stmt|;
name|struct
name|genlmsghdr
modifier|*
name|gnlh
init|=
name|nlmsg_data
argument_list|(
name|nlmsg_hdr
argument_list|(
name|msg
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|wiphy_info_data
modifier|*
name|info
init|=
name|arg
decl_stmt|;
name|struct
name|wpa_driver_capa
modifier|*
name|capa
init|=
name|info
operator|->
name|capa
decl_stmt|;
name|struct
name|wpa_driver_nl80211_data
modifier|*
name|drv
init|=
name|info
operator|->
name|drv
decl_stmt|;
name|nla_parse
argument_list|(
name|tb
argument_list|,
name|NL80211_ATTR_MAX
argument_list|,
name|genlmsg_attrdata
argument_list|(
name|gnlh
argument_list|,
literal|0
argument_list|)
argument_list|,
name|genlmsg_attrlen
argument_list|(
name|gnlh
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|tb
index|[
name|NL80211_ATTR_WIPHY_NAME
index|]
condition|)
name|os_strlcpy
argument_list|(
name|drv
operator|->
name|phyname
argument_list|,
name|nla_get_string
argument_list|(
name|tb
index|[
name|NL80211_ATTR_WIPHY_NAME
index|]
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|drv
operator|->
name|phyname
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tb
index|[
name|NL80211_ATTR_MAX_NUM_SCAN_SSIDS
index|]
condition|)
name|capa
operator|->
name|max_scan_ssids
operator|=
name|nla_get_u8
argument_list|(
name|tb
index|[
name|NL80211_ATTR_MAX_NUM_SCAN_SSIDS
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|tb
index|[
name|NL80211_ATTR_MAX_NUM_SCHED_SCAN_SSIDS
index|]
condition|)
name|capa
operator|->
name|max_sched_scan_ssids
operator|=
name|nla_get_u8
argument_list|(
name|tb
index|[
name|NL80211_ATTR_MAX_NUM_SCHED_SCAN_SSIDS
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|tb
index|[
name|NL80211_ATTR_MAX_MATCH_SETS
index|]
condition|)
name|capa
operator|->
name|max_match_sets
operator|=
name|nla_get_u8
argument_list|(
name|tb
index|[
name|NL80211_ATTR_MAX_MATCH_SETS
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|tb
index|[
name|NL80211_ATTR_MAC_ACL_MAX
index|]
condition|)
name|capa
operator|->
name|max_acl_mac_addrs
operator|=
name|nla_get_u8
argument_list|(
name|tb
index|[
name|NL80211_ATTR_MAC_ACL_MAX
index|]
argument_list|)
expr_stmt|;
name|wiphy_info_supported_iftypes
argument_list|(
name|info
argument_list|,
name|tb
index|[
name|NL80211_ATTR_SUPPORTED_IFTYPES
index|]
argument_list|)
expr_stmt|;
name|wiphy_info_iface_comb
argument_list|(
name|info
argument_list|,
name|tb
index|[
name|NL80211_ATTR_INTERFACE_COMBINATIONS
index|]
argument_list|)
expr_stmt|;
name|wiphy_info_supp_cmds
argument_list|(
name|info
argument_list|,
name|tb
index|[
name|NL80211_ATTR_SUPPORTED_COMMANDS
index|]
argument_list|)
expr_stmt|;
name|wiphy_info_cipher_suites
argument_list|(
name|info
argument_list|,
name|tb
index|[
name|NL80211_ATTR_CIPHER_SUITES
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|tb
index|[
name|NL80211_ATTR_OFFCHANNEL_TX_OK
index|]
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"nl80211: Using driver-based "
literal|"off-channel TX"
argument_list|)
expr_stmt|;
name|capa
operator|->
name|flags
operator||=
name|WPA_DRIVER_FLAGS_OFFCHANNEL_TX
expr_stmt|;
block|}
if|if
condition|(
name|tb
index|[
name|NL80211_ATTR_ROAM_SUPPORT
index|]
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"nl80211: Using driver-based roaming"
argument_list|)
expr_stmt|;
name|capa
operator|->
name|flags
operator||=
name|WPA_DRIVER_FLAGS_BSS_SELECTION
expr_stmt|;
block|}
name|wiphy_info_max_roc
argument_list|(
name|capa
argument_list|,
name|tb
index|[
name|NL80211_ATTR_MAX_REMAIN_ON_CHANNEL_DURATION
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|tb
index|[
name|NL80211_ATTR_SUPPORT_AP_UAPSD
index|]
condition|)
name|capa
operator|->
name|flags
operator||=
name|WPA_DRIVER_FLAGS_AP_UAPSD
expr_stmt|;
name|wiphy_info_tdls
argument_list|(
name|capa
argument_list|,
name|tb
index|[
name|NL80211_ATTR_TDLS_SUPPORT
index|]
argument_list|,
name|tb
index|[
name|NL80211_ATTR_TDLS_EXTERNAL_SETUP
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|tb
index|[
name|NL80211_ATTR_DEVICE_AP_SME
index|]
condition|)
name|info
operator|->
name|device_ap_sme
operator|=
literal|1
expr_stmt|;
name|wiphy_info_feature_flags
argument_list|(
name|info
argument_list|,
name|tb
index|[
name|NL80211_ATTR_FEATURE_FLAGS
index|]
argument_list|)
expr_stmt|;
name|wiphy_info_ext_feature_flags
argument_list|(
name|info
argument_list|,
name|tb
index|[
name|NL80211_ATTR_EXT_FEATURES
index|]
argument_list|)
expr_stmt|;
name|wiphy_info_probe_resp_offload
argument_list|(
name|capa
argument_list|,
name|tb
index|[
name|NL80211_ATTR_PROBE_RESP_OFFLOAD
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|tb
index|[
name|NL80211_ATTR_EXT_CAPA
index|]
operator|&&
name|tb
index|[
name|NL80211_ATTR_EXT_CAPA_MASK
index|]
operator|&&
name|drv
operator|->
name|extended_capa
operator|==
name|NULL
condition|)
block|{
name|drv
operator|->
name|extended_capa
operator|=
name|os_malloc
argument_list|(
name|nla_len
argument_list|(
name|tb
index|[
name|NL80211_ATTR_EXT_CAPA
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|drv
operator|->
name|extended_capa
condition|)
block|{
name|os_memcpy
argument_list|(
name|drv
operator|->
name|extended_capa
argument_list|,
name|nla_data
argument_list|(
name|tb
index|[
name|NL80211_ATTR_EXT_CAPA
index|]
argument_list|)
argument_list|,
name|nla_len
argument_list|(
name|tb
index|[
name|NL80211_ATTR_EXT_CAPA
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|drv
operator|->
name|extended_capa_len
operator|=
name|nla_len
argument_list|(
name|tb
index|[
name|NL80211_ATTR_EXT_CAPA
index|]
argument_list|)
expr_stmt|;
block|}
name|drv
operator|->
name|extended_capa_mask
operator|=
name|os_malloc
argument_list|(
name|nla_len
argument_list|(
name|tb
index|[
name|NL80211_ATTR_EXT_CAPA_MASK
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|drv
operator|->
name|extended_capa_mask
condition|)
block|{
name|os_memcpy
argument_list|(
name|drv
operator|->
name|extended_capa_mask
argument_list|,
name|nla_data
argument_list|(
name|tb
index|[
name|NL80211_ATTR_EXT_CAPA_MASK
index|]
argument_list|)
argument_list|,
name|nla_len
argument_list|(
name|tb
index|[
name|NL80211_ATTR_EXT_CAPA_MASK
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|os_free
argument_list|(
name|drv
operator|->
name|extended_capa
argument_list|)
expr_stmt|;
name|drv
operator|->
name|extended_capa
operator|=
name|NULL
expr_stmt|;
name|drv
operator|->
name|extended_capa_len
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|tb
index|[
name|NL80211_ATTR_VENDOR_DATA
index|]
condition|)
block|{
name|struct
name|nlattr
modifier|*
name|nl
decl_stmt|;
name|int
name|rem
decl_stmt|;
name|nla_for_each_nested
argument_list|(
argument|nl
argument_list|,
argument|tb[NL80211_ATTR_VENDOR_DATA]
argument_list|,
argument|rem
argument_list|)
block|{
name|struct
name|nl80211_vendor_cmd_info
modifier|*
name|vinfo
decl_stmt|;
if|if
condition|(
name|nla_len
argument_list|(
name|nl
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
operator|*
name|vinfo
argument_list|)
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"nl80211: Unexpected vendor data info"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|vinfo
operator|=
name|nla_data
argument_list|(
name|nl
argument_list|)
expr_stmt|;
if|if
condition|(
name|vinfo
operator|->
name|vendor_id
operator|==
name|OUI_QCA
condition|)
block|{
switch|switch
condition|(
name|vinfo
operator|->
name|subcmd
condition|)
block|{
case|case
name|QCA_NL80211_VENDOR_SUBCMD_TEST
case|:
name|drv
operator|->
name|vendor_cmd_test_avail
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|QCA_NL80211_VENDOR_SUBCMD_ROAMING
case|:
name|drv
operator|->
name|roaming_vendor_cmd_avail
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|QCA_NL80211_VENDOR_SUBCMD_DFS_CAPABILITY
case|:
name|drv
operator|->
name|dfs_vendor_cmd_avail
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|QCA_NL80211_VENDOR_SUBCMD_GET_FEATURES
case|:
name|drv
operator|->
name|get_features_vendor_cmd_avail
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|QCA_NL80211_VENDOR_SUBCMD_GET_PREFERRED_FREQ_LIST
case|:
name|drv
operator|->
name|get_pref_freq_list
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|QCA_NL80211_VENDOR_SUBCMD_SET_PROBABLE_OPER_CHANNEL
case|:
name|drv
operator|->
name|set_prob_oper_freq
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|QCA_NL80211_VENDOR_SUBCMD_DO_ACS
case|:
name|drv
operator|->
name|capa
operator|.
name|flags
operator||=
name|WPA_DRIVER_FLAGS_ACS_OFFLOAD
expr_stmt|;
break|break;
case|case
name|QCA_NL80211_VENDOR_SUBCMD_SETBAND
case|:
name|drv
operator|->
name|setband_vendor_cmd_avail
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"nl80211: Supported vendor command: vendor_id=0x%x subcmd=%u"
argument_list|,
name|vinfo
operator|->
name|vendor_id
argument_list|,
name|vinfo
operator|->
name|subcmd
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|tb
index|[
name|NL80211_ATTR_VENDOR_EVENTS
index|]
condition|)
block|{
name|struct
name|nlattr
modifier|*
name|nl
decl_stmt|;
name|int
name|rem
decl_stmt|;
name|nla_for_each_nested
argument_list|(
argument|nl
argument_list|,
argument|tb[NL80211_ATTR_VENDOR_EVENTS]
argument_list|,
argument|rem
argument_list|)
block|{
name|struct
name|nl80211_vendor_cmd_info
modifier|*
name|vinfo
decl_stmt|;
if|if
condition|(
name|nla_len
argument_list|(
name|nl
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
operator|*
name|vinfo
argument_list|)
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"nl80211: Unexpected vendor data info"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|vinfo
operator|=
name|nla_data
argument_list|(
name|nl
argument_list|)
expr_stmt|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"nl80211: Supported vendor event: vendor_id=0x%x subcmd=%u"
argument_list|,
name|vinfo
operator|->
name|vendor_id
argument_list|,
name|vinfo
operator|->
name|subcmd
argument_list|)
expr_stmt|;
block|}
block|}
name|wiphy_info_wowlan_triggers
argument_list|(
name|capa
argument_list|,
name|tb
index|[
name|NL80211_ATTR_WOWLAN_TRIGGERS_SUPPORTED
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|tb
index|[
name|NL80211_ATTR_MAX_AP_ASSOC_STA
index|]
condition|)
name|capa
operator|->
name|max_stations
operator|=
name|nla_get_u32
argument_list|(
name|tb
index|[
name|NL80211_ATTR_MAX_AP_ASSOC_STA
index|]
argument_list|)
expr_stmt|;
return|return
name|NL_SKIP
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|wpa_driver_nl80211_get_info
parameter_list|(
name|struct
name|wpa_driver_nl80211_data
modifier|*
name|drv
parameter_list|,
name|struct
name|wiphy_info_data
modifier|*
name|info
parameter_list|)
block|{
name|u32
name|feat
decl_stmt|;
name|struct
name|nl_msg
modifier|*
name|msg
decl_stmt|;
name|int
name|flags
init|=
literal|0
decl_stmt|;
name|os_memset
argument_list|(
name|info
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|info
argument_list|)
argument_list|)
expr_stmt|;
name|info
operator|->
name|capa
operator|=
operator|&
name|drv
operator|->
name|capa
expr_stmt|;
name|info
operator|->
name|drv
operator|=
name|drv
expr_stmt|;
name|feat
operator|=
name|get_nl80211_protocol_features
argument_list|(
name|drv
argument_list|)
expr_stmt|;
if|if
condition|(
name|feat
operator|&
name|NL80211_PROTOCOL_FEATURE_SPLIT_WIPHY_DUMP
condition|)
name|flags
operator|=
name|NLM_F_DUMP
expr_stmt|;
name|msg
operator|=
name|nl80211_cmd_msg
argument_list|(
name|drv
operator|->
name|first_bss
argument_list|,
name|flags
argument_list|,
name|NL80211_CMD_GET_WIPHY
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|msg
operator|||
name|nla_put_flag
argument_list|(
name|msg
argument_list|,
name|NL80211_ATTR_SPLIT_WIPHY_DUMP
argument_list|)
condition|)
block|{
name|nlmsg_free
argument_list|(
name|msg
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|send_and_recv_msgs
argument_list|(
name|drv
argument_list|,
name|msg
argument_list|,
name|wiphy_info_handler
argument_list|,
name|info
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|info
operator|->
name|auth_supported
condition|)
name|drv
operator|->
name|capa
operator|.
name|flags
operator||=
name|WPA_DRIVER_FLAGS_SME
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|info
operator|->
name|connect_supported
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_INFO
argument_list|,
literal|"nl80211: Driver does not support "
literal|"authentication/association or connect commands"
argument_list|)
expr_stmt|;
name|info
operator|->
name|error
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|info
operator|->
name|p2p_go_supported
operator|&&
name|info
operator|->
name|p2p_client_supported
condition|)
name|drv
operator|->
name|capa
operator|.
name|flags
operator||=
name|WPA_DRIVER_FLAGS_P2P_CAPABLE
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|p2p_concurrent
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"nl80211: Use separate P2P group "
literal|"interface (driver advertised support)"
argument_list|)
expr_stmt|;
name|drv
operator|->
name|capa
operator|.
name|flags
operator||=
name|WPA_DRIVER_FLAGS_P2P_CONCURRENT
expr_stmt|;
name|drv
operator|->
name|capa
operator|.
name|flags
operator||=
name|WPA_DRIVER_FLAGS_P2P_MGMT_AND_NON_P2P
expr_stmt|;
block|}
if|if
condition|(
name|info
operator|->
name|num_multichan_concurrent
operator|>
literal|1
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"nl80211: Enable multi-channel "
literal|"concurrent (driver advertised support)"
argument_list|)
expr_stmt|;
name|drv
operator|->
name|capa
operator|.
name|num_multichan_concurrent
operator|=
name|info
operator|->
name|num_multichan_concurrent
expr_stmt|;
block|}
if|if
condition|(
name|drv
operator|->
name|capa
operator|.
name|flags
operator|&
name|WPA_DRIVER_FLAGS_DEDICATED_P2P_DEVICE
condition|)
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"nl80211: use P2P_DEVICE support"
argument_list|)
expr_stmt|;
comment|/* default to 5000 since early versions of mac80211 don't set it */
if|if
condition|(
operator|!
name|drv
operator|->
name|capa
operator|.
name|max_remain_on_chan
condition|)
name|drv
operator|->
name|capa
operator|.
name|max_remain_on_chan
operator|=
literal|5000
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|channel_switch_supported
condition|)
name|drv
operator|->
name|capa
operator|.
name|flags
operator||=
name|WPA_DRIVER_FLAGS_AP_CSA
expr_stmt|;
name|drv
operator|->
name|capa
operator|.
name|wmm_ac_supported
operator|=
name|info
operator|->
name|wmm_ac_supported
expr_stmt|;
name|drv
operator|->
name|capa
operator|.
name|mac_addr_rand_sched_scan_supported
operator|=
name|info
operator|->
name|mac_addr_rand_sched_scan_supported
expr_stmt|;
name|drv
operator|->
name|capa
operator|.
name|mac_addr_rand_scan_supported
operator|=
name|info
operator|->
name|mac_addr_rand_scan_supported
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dfs_info_handler
parameter_list|(
name|struct
name|nl_msg
modifier|*
name|msg
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|nlattr
modifier|*
name|tb
index|[
name|NL80211_ATTR_MAX
operator|+
literal|1
index|]
decl_stmt|;
name|struct
name|genlmsghdr
modifier|*
name|gnlh
init|=
name|nlmsg_data
argument_list|(
name|nlmsg_hdr
argument_list|(
name|msg
argument_list|)
argument_list|)
decl_stmt|;
name|int
modifier|*
name|dfs_capability_ptr
init|=
name|arg
decl_stmt|;
name|nla_parse
argument_list|(
name|tb
argument_list|,
name|NL80211_ATTR_MAX
argument_list|,
name|genlmsg_attrdata
argument_list|(
name|gnlh
argument_list|,
literal|0
argument_list|)
argument_list|,
name|genlmsg_attrlen
argument_list|(
name|gnlh
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|tb
index|[
name|NL80211_ATTR_VENDOR_DATA
index|]
condition|)
block|{
name|struct
name|nlattr
modifier|*
name|nl_vend
init|=
name|tb
index|[
name|NL80211_ATTR_VENDOR_DATA
index|]
decl_stmt|;
name|struct
name|nlattr
modifier|*
name|tb_vendor
index|[
name|QCA_WLAN_VENDOR_ATTR_MAX
operator|+
literal|1
index|]
decl_stmt|;
name|nla_parse
argument_list|(
name|tb_vendor
argument_list|,
name|QCA_WLAN_VENDOR_ATTR_MAX
argument_list|,
name|nla_data
argument_list|(
name|nl_vend
argument_list|)
argument_list|,
name|nla_len
argument_list|(
name|nl_vend
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|tb_vendor
index|[
name|QCA_WLAN_VENDOR_ATTR_DFS
index|]
condition|)
block|{
name|u32
name|val
decl_stmt|;
name|val
operator|=
name|nla_get_u32
argument_list|(
name|tb_vendor
index|[
name|QCA_WLAN_VENDOR_ATTR_DFS
index|]
argument_list|)
expr_stmt|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"nl80211: DFS offload capability: %u"
argument_list|,
name|val
argument_list|)
expr_stmt|;
operator|*
name|dfs_capability_ptr
operator|=
name|val
expr_stmt|;
block|}
block|}
return|return
name|NL_SKIP
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|qca_nl80211_check_dfs_capa
parameter_list|(
name|struct
name|wpa_driver_nl80211_data
modifier|*
name|drv
parameter_list|)
block|{
name|struct
name|nl_msg
modifier|*
name|msg
decl_stmt|;
name|int
name|dfs_capability
init|=
literal|0
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
operator|!
name|drv
operator|->
name|dfs_vendor_cmd_avail
condition|)
return|return;
if|if
condition|(
operator|!
operator|(
name|msg
operator|=
name|nl80211_drv_msg
argument_list|(
name|drv
argument_list|,
literal|0
argument_list|,
name|NL80211_CMD_VENDOR
argument_list|)
operator|)
operator|||
name|nla_put_u32
argument_list|(
name|msg
argument_list|,
name|NL80211_ATTR_VENDOR_ID
argument_list|,
name|OUI_QCA
argument_list|)
operator|||
name|nla_put_u32
argument_list|(
name|msg
argument_list|,
name|NL80211_ATTR_VENDOR_SUBCMD
argument_list|,
name|QCA_NL80211_VENDOR_SUBCMD_DFS_CAPABILITY
argument_list|)
condition|)
block|{
name|nlmsg_free
argument_list|(
name|msg
argument_list|)
expr_stmt|;
return|return;
block|}
name|ret
operator|=
name|send_and_recv_msgs
argument_list|(
name|drv
argument_list|,
name|msg
argument_list|,
name|dfs_info_handler
argument_list|,
operator|&
name|dfs_capability
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
operator|&&
name|dfs_capability
condition|)
name|drv
operator|->
name|capa
operator|.
name|flags
operator||=
name|WPA_DRIVER_FLAGS_DFS_OFFLOAD
expr_stmt|;
block|}
end_function

begin_struct
struct|struct
name|features_info
block|{
name|u8
modifier|*
name|flags
decl_stmt|;
name|size_t
name|flags_len
decl_stmt|;
name|struct
name|wpa_driver_capa
modifier|*
name|capa
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|features_info_handler
parameter_list|(
name|struct
name|nl_msg
modifier|*
name|msg
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|nlattr
modifier|*
name|tb
index|[
name|NL80211_ATTR_MAX
operator|+
literal|1
index|]
decl_stmt|;
name|struct
name|genlmsghdr
modifier|*
name|gnlh
init|=
name|nlmsg_data
argument_list|(
name|nlmsg_hdr
argument_list|(
name|msg
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|features_info
modifier|*
name|info
init|=
name|arg
decl_stmt|;
name|struct
name|nlattr
modifier|*
name|nl_vend
decl_stmt|,
modifier|*
name|attr
decl_stmt|;
name|nla_parse
argument_list|(
name|tb
argument_list|,
name|NL80211_ATTR_MAX
argument_list|,
name|genlmsg_attrdata
argument_list|(
name|gnlh
argument_list|,
literal|0
argument_list|)
argument_list|,
name|genlmsg_attrlen
argument_list|(
name|gnlh
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|nl_vend
operator|=
name|tb
index|[
name|NL80211_ATTR_VENDOR_DATA
index|]
expr_stmt|;
if|if
condition|(
name|nl_vend
condition|)
block|{
name|struct
name|nlattr
modifier|*
name|tb_vendor
index|[
name|QCA_WLAN_VENDOR_ATTR_MAX
operator|+
literal|1
index|]
decl_stmt|;
name|nla_parse
argument_list|(
name|tb_vendor
argument_list|,
name|QCA_WLAN_VENDOR_ATTR_MAX
argument_list|,
name|nla_data
argument_list|(
name|nl_vend
argument_list|)
argument_list|,
name|nla_len
argument_list|(
name|nl_vend
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|attr
operator|=
name|tb_vendor
index|[
name|QCA_WLAN_VENDOR_ATTR_FEATURE_FLAGS
index|]
expr_stmt|;
if|if
condition|(
name|attr
condition|)
block|{
name|info
operator|->
name|flags
operator|=
name|nla_data
argument_list|(
name|attr
argument_list|)
expr_stmt|;
name|info
operator|->
name|flags_len
operator|=
name|nla_len
argument_list|(
name|attr
argument_list|)
expr_stmt|;
block|}
name|attr
operator|=
name|tb_vendor
index|[
name|QCA_WLAN_VENDOR_ATTR_CONCURRENCY_CAPA
index|]
expr_stmt|;
if|if
condition|(
name|attr
condition|)
name|info
operator|->
name|capa
operator|->
name|conc_capab
operator|=
name|nla_get_u32
argument_list|(
name|attr
argument_list|)
expr_stmt|;
name|attr
operator|=
name|tb_vendor
index|[
name|QCA_WLAN_VENDOR_ATTR_MAX_CONCURRENT_CHANNELS_2_4_BAND
index|]
expr_stmt|;
if|if
condition|(
name|attr
condition|)
name|info
operator|->
name|capa
operator|->
name|max_conc_chan_2_4
operator|=
name|nla_get_u32
argument_list|(
name|attr
argument_list|)
expr_stmt|;
name|attr
operator|=
name|tb_vendor
index|[
name|QCA_WLAN_VENDOR_ATTR_MAX_CONCURRENT_CHANNELS_5_0_BAND
index|]
expr_stmt|;
if|if
condition|(
name|attr
condition|)
name|info
operator|->
name|capa
operator|->
name|max_conc_chan_5_0
operator|=
name|nla_get_u32
argument_list|(
name|attr
argument_list|)
expr_stmt|;
block|}
return|return
name|NL_SKIP
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|check_feature
parameter_list|(
name|enum
name|qca_wlan_vendor_features
name|feature
parameter_list|,
name|struct
name|features_info
modifier|*
name|info
parameter_list|)
block|{
name|size_t
name|idx
init|=
name|feature
operator|/
literal|8
decl_stmt|;
return|return
operator|(
name|idx
operator|<
name|info
operator|->
name|flags_len
operator|)
operator|&&
operator|(
name|info
operator|->
name|flags
index|[
name|idx
index|]
operator|&
name|BIT
argument_list|(
name|feature
operator|%
literal|8
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|qca_nl80211_get_features
parameter_list|(
name|struct
name|wpa_driver_nl80211_data
modifier|*
name|drv
parameter_list|)
block|{
name|struct
name|nl_msg
modifier|*
name|msg
decl_stmt|;
name|struct
name|features_info
name|info
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
operator|!
name|drv
operator|->
name|get_features_vendor_cmd_avail
condition|)
return|return;
if|if
condition|(
operator|!
operator|(
name|msg
operator|=
name|nl80211_drv_msg
argument_list|(
name|drv
argument_list|,
literal|0
argument_list|,
name|NL80211_CMD_VENDOR
argument_list|)
operator|)
operator|||
name|nla_put_u32
argument_list|(
name|msg
argument_list|,
name|NL80211_ATTR_VENDOR_ID
argument_list|,
name|OUI_QCA
argument_list|)
operator|||
name|nla_put_u32
argument_list|(
name|msg
argument_list|,
name|NL80211_ATTR_VENDOR_SUBCMD
argument_list|,
name|QCA_NL80211_VENDOR_SUBCMD_GET_FEATURES
argument_list|)
condition|)
block|{
name|nlmsg_free
argument_list|(
name|msg
argument_list|)
expr_stmt|;
return|return;
block|}
name|os_memset
argument_list|(
operator|&
name|info
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|info
argument_list|)
argument_list|)
expr_stmt|;
name|info
operator|.
name|capa
operator|=
operator|&
name|drv
operator|->
name|capa
expr_stmt|;
name|ret
operator|=
name|send_and_recv_msgs
argument_list|(
name|drv
argument_list|,
name|msg
argument_list|,
name|features_info_handler
argument_list|,
operator|&
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|||
operator|!
name|info
operator|.
name|flags
condition|)
return|return;
if|if
condition|(
name|check_feature
argument_list|(
name|QCA_WLAN_VENDOR_FEATURE_KEY_MGMT_OFFLOAD
argument_list|,
operator|&
name|info
argument_list|)
condition|)
name|drv
operator|->
name|capa
operator|.
name|flags
operator||=
name|WPA_DRIVER_FLAGS_KEY_MGMT_OFFLOAD
expr_stmt|;
if|if
condition|(
name|check_feature
argument_list|(
name|QCA_WLAN_VENDOR_FEATURE_SUPPORT_HW_MODE_ANY
argument_list|,
operator|&
name|info
argument_list|)
condition|)
name|drv
operator|->
name|capa
operator|.
name|flags
operator||=
name|WPA_DRIVER_FLAGS_SUPPORT_HW_MODE_ANY
expr_stmt|;
block|}
end_function

begin_function
name|int
name|wpa_driver_nl80211_capa
parameter_list|(
name|struct
name|wpa_driver_nl80211_data
modifier|*
name|drv
parameter_list|)
block|{
name|struct
name|wiphy_info_data
name|info
decl_stmt|;
if|if
condition|(
name|wpa_driver_nl80211_get_info
argument_list|(
name|drv
argument_list|,
operator|&
name|info
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|info
operator|.
name|error
condition|)
return|return
operator|-
literal|1
return|;
name|drv
operator|->
name|has_capability
operator|=
literal|1
expr_stmt|;
name|drv
operator|->
name|capa
operator|.
name|key_mgmt
operator|=
name|WPA_DRIVER_CAPA_KEY_MGMT_WPA
operator||
name|WPA_DRIVER_CAPA_KEY_MGMT_WPA_PSK
operator||
name|WPA_DRIVER_CAPA_KEY_MGMT_WPA2
operator||
name|WPA_DRIVER_CAPA_KEY_MGMT_WPA2_PSK
operator||
name|WPA_DRIVER_CAPA_KEY_MGMT_SUITE_B
operator||
name|WPA_DRIVER_CAPA_KEY_MGMT_SUITE_B_192
expr_stmt|;
name|drv
operator|->
name|capa
operator|.
name|auth
operator|=
name|WPA_DRIVER_AUTH_OPEN
operator||
name|WPA_DRIVER_AUTH_SHARED
operator||
name|WPA_DRIVER_AUTH_LEAP
expr_stmt|;
name|drv
operator|->
name|capa
operator|.
name|flags
operator||=
name|WPA_DRIVER_FLAGS_SANE_ERROR_CODES
expr_stmt|;
name|drv
operator|->
name|capa
operator|.
name|flags
operator||=
name|WPA_DRIVER_FLAGS_SET_KEYS_AFTER_ASSOC_DONE
expr_stmt|;
name|drv
operator|->
name|capa
operator|.
name|flags
operator||=
name|WPA_DRIVER_FLAGS_EAPOL_TX_STATUS
expr_stmt|;
comment|/* 	 * As all cfg80211 drivers must support cases where the AP interface is 	 * removed without the knowledge of wpa_supplicant/hostapd, e.g., in 	 * case that the user space daemon has crashed, they must be able to 	 * cleanup all stations and key entries in the AP tear down flow. Thus, 	 * this flag can/should always be set for cfg80211 drivers. 	 */
name|drv
operator|->
name|capa
operator|.
name|flags
operator||=
name|WPA_DRIVER_FLAGS_AP_TEARDOWN_SUPPORT
expr_stmt|;
if|if
condition|(
operator|!
name|info
operator|.
name|device_ap_sme
condition|)
block|{
name|drv
operator|->
name|capa
operator|.
name|flags
operator||=
name|WPA_DRIVER_FLAGS_DEAUTH_TX_STATUS
expr_stmt|;
comment|/* 		 * No AP SME is currently assumed to also indicate no AP MLME 		 * in the driver/firmware. 		 */
name|drv
operator|->
name|capa
operator|.
name|flags
operator||=
name|WPA_DRIVER_FLAGS_AP_MLME
expr_stmt|;
block|}
name|drv
operator|->
name|device_ap_sme
operator|=
name|info
operator|.
name|device_ap_sme
expr_stmt|;
name|drv
operator|->
name|poll_command_supported
operator|=
name|info
operator|.
name|poll_command_supported
expr_stmt|;
name|drv
operator|->
name|data_tx_status
operator|=
name|info
operator|.
name|data_tx_status
expr_stmt|;
name|drv
operator|->
name|p2p_go_ctwindow_supported
operator|=
name|info
operator|.
name|p2p_go_ctwindow_supported
expr_stmt|;
if|if
condition|(
name|info
operator|.
name|set_qos_map_supported
condition|)
name|drv
operator|->
name|capa
operator|.
name|flags
operator||=
name|WPA_DRIVER_FLAGS_QOS_MAPPING
expr_stmt|;
name|drv
operator|->
name|have_low_prio_scan
operator|=
name|info
operator|.
name|have_low_prio_scan
expr_stmt|;
comment|/* 	 * If poll command and tx status are supported, mac80211 is new enough 	 * to have everything we need to not need monitor interfaces. 	 */
name|drv
operator|->
name|use_monitor
operator|=
operator|!
name|info
operator|.
name|poll_command_supported
operator|||
operator|!
name|info
operator|.
name|data_tx_status
expr_stmt|;
if|if
condition|(
name|drv
operator|->
name|device_ap_sme
operator|&&
name|drv
operator|->
name|use_monitor
condition|)
block|{
comment|/* 		 * Non-mac80211 drivers may not support monitor interface. 		 * Make sure we do not get stuck with incorrect capability here 		 * by explicitly testing this. 		 */
if|if
condition|(
operator|!
name|info
operator|.
name|monitor_supported
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"nl80211: Disable use_monitor "
literal|"with device_ap_sme since no monitor mode "
literal|"support detected"
argument_list|)
expr_stmt|;
name|drv
operator|->
name|use_monitor
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* 	 * If we aren't going to use monitor interfaces, but the 	 * driver doesn't support data TX status, we won't get TX 	 * status for EAPOL frames. 	 */
if|if
condition|(
operator|!
name|drv
operator|->
name|use_monitor
operator|&&
operator|!
name|info
operator|.
name|data_tx_status
condition|)
name|drv
operator|->
name|capa
operator|.
name|flags
operator|&=
operator|~
name|WPA_DRIVER_FLAGS_EAPOL_TX_STATUS
expr_stmt|;
name|qca_nl80211_check_dfs_capa
argument_list|(
name|drv
argument_list|)
expr_stmt|;
name|qca_nl80211_get_features
argument_list|(
name|drv
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_struct
struct|struct
name|phy_info_arg
block|{
name|u16
modifier|*
name|num_modes
decl_stmt|;
name|struct
name|hostapd_hw_modes
modifier|*
name|modes
decl_stmt|;
name|int
name|last_mode
decl_stmt|,
name|last_chan_idx
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|phy_info_ht_capa
parameter_list|(
name|struct
name|hostapd_hw_modes
modifier|*
name|mode
parameter_list|,
name|struct
name|nlattr
modifier|*
name|capa
parameter_list|,
name|struct
name|nlattr
modifier|*
name|ampdu_factor
parameter_list|,
name|struct
name|nlattr
modifier|*
name|ampdu_density
parameter_list|,
name|struct
name|nlattr
modifier|*
name|mcs_set
parameter_list|)
block|{
if|if
condition|(
name|capa
condition|)
name|mode
operator|->
name|ht_capab
operator|=
name|nla_get_u16
argument_list|(
name|capa
argument_list|)
expr_stmt|;
if|if
condition|(
name|ampdu_factor
condition|)
name|mode
operator|->
name|a_mpdu_params
operator||=
name|nla_get_u8
argument_list|(
name|ampdu_factor
argument_list|)
operator|&
literal|0x03
expr_stmt|;
if|if
condition|(
name|ampdu_density
condition|)
name|mode
operator|->
name|a_mpdu_params
operator||=
name|nla_get_u8
argument_list|(
name|ampdu_density
argument_list|)
operator|<<
literal|2
expr_stmt|;
if|if
condition|(
name|mcs_set
operator|&&
name|nla_len
argument_list|(
name|mcs_set
argument_list|)
operator|>=
literal|16
condition|)
block|{
name|u8
modifier|*
name|mcs
decl_stmt|;
name|mcs
operator|=
name|nla_data
argument_list|(
name|mcs_set
argument_list|)
expr_stmt|;
name|os_memcpy
argument_list|(
name|mode
operator|->
name|mcs_set
argument_list|,
name|mcs
argument_list|,
literal|16
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|phy_info_vht_capa
parameter_list|(
name|struct
name|hostapd_hw_modes
modifier|*
name|mode
parameter_list|,
name|struct
name|nlattr
modifier|*
name|capa
parameter_list|,
name|struct
name|nlattr
modifier|*
name|mcs_set
parameter_list|)
block|{
if|if
condition|(
name|capa
condition|)
name|mode
operator|->
name|vht_capab
operator|=
name|nla_get_u32
argument_list|(
name|capa
argument_list|)
expr_stmt|;
if|if
condition|(
name|mcs_set
operator|&&
name|nla_len
argument_list|(
name|mcs_set
argument_list|)
operator|>=
literal|8
condition|)
block|{
name|u8
modifier|*
name|mcs
decl_stmt|;
name|mcs
operator|=
name|nla_data
argument_list|(
name|mcs_set
argument_list|)
expr_stmt|;
name|os_memcpy
argument_list|(
name|mode
operator|->
name|vht_mcs_set
argument_list|,
name|mcs
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|phy_info_freq
parameter_list|(
name|struct
name|hostapd_hw_modes
modifier|*
name|mode
parameter_list|,
name|struct
name|hostapd_channel_data
modifier|*
name|chan
parameter_list|,
name|struct
name|nlattr
modifier|*
name|tb_freq
index|[]
parameter_list|)
block|{
name|u8
name|channel
decl_stmt|;
name|chan
operator|->
name|freq
operator|=
name|nla_get_u32
argument_list|(
name|tb_freq
index|[
name|NL80211_FREQUENCY_ATTR_FREQ
index|]
argument_list|)
expr_stmt|;
name|chan
operator|->
name|flag
operator|=
literal|0
expr_stmt|;
name|chan
operator|->
name|dfs_cac_ms
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ieee80211_freq_to_chan
argument_list|(
name|chan
operator|->
name|freq
argument_list|,
operator|&
name|channel
argument_list|)
operator|!=
name|NUM_HOSTAPD_MODES
condition|)
name|chan
operator|->
name|chan
operator|=
name|channel
expr_stmt|;
if|if
condition|(
name|tb_freq
index|[
name|NL80211_FREQUENCY_ATTR_DISABLED
index|]
condition|)
name|chan
operator|->
name|flag
operator||=
name|HOSTAPD_CHAN_DISABLED
expr_stmt|;
if|if
condition|(
name|tb_freq
index|[
name|NL80211_FREQUENCY_ATTR_NO_IR
index|]
condition|)
name|chan
operator|->
name|flag
operator||=
name|HOSTAPD_CHAN_NO_IR
expr_stmt|;
if|if
condition|(
name|tb_freq
index|[
name|NL80211_FREQUENCY_ATTR_RADAR
index|]
condition|)
name|chan
operator|->
name|flag
operator||=
name|HOSTAPD_CHAN_RADAR
expr_stmt|;
if|if
condition|(
name|tb_freq
index|[
name|NL80211_FREQUENCY_ATTR_INDOOR_ONLY
index|]
condition|)
name|chan
operator|->
name|flag
operator||=
name|HOSTAPD_CHAN_INDOOR_ONLY
expr_stmt|;
if|if
condition|(
name|tb_freq
index|[
name|NL80211_FREQUENCY_ATTR_GO_CONCURRENT
index|]
condition|)
name|chan
operator|->
name|flag
operator||=
name|HOSTAPD_CHAN_GO_CONCURRENT
expr_stmt|;
if|if
condition|(
name|tb_freq
index|[
name|NL80211_FREQUENCY_ATTR_DFS_STATE
index|]
condition|)
block|{
name|enum
name|nl80211_dfs_state
name|state
init|=
name|nla_get_u32
argument_list|(
name|tb_freq
index|[
name|NL80211_FREQUENCY_ATTR_DFS_STATE
index|]
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|NL80211_DFS_USABLE
case|:
name|chan
operator|->
name|flag
operator||=
name|HOSTAPD_CHAN_DFS_USABLE
expr_stmt|;
break|break;
case|case
name|NL80211_DFS_AVAILABLE
case|:
name|chan
operator|->
name|flag
operator||=
name|HOSTAPD_CHAN_DFS_AVAILABLE
expr_stmt|;
break|break;
case|case
name|NL80211_DFS_UNAVAILABLE
case|:
name|chan
operator|->
name|flag
operator||=
name|HOSTAPD_CHAN_DFS_UNAVAILABLE
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|tb_freq
index|[
name|NL80211_FREQUENCY_ATTR_DFS_CAC_TIME
index|]
condition|)
block|{
name|chan
operator|->
name|dfs_cac_ms
operator|=
name|nla_get_u32
argument_list|(
name|tb_freq
index|[
name|NL80211_FREQUENCY_ATTR_DFS_CAC_TIME
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|phy_info_freqs
parameter_list|(
name|struct
name|phy_info_arg
modifier|*
name|phy_info
parameter_list|,
name|struct
name|hostapd_hw_modes
modifier|*
name|mode
parameter_list|,
name|struct
name|nlattr
modifier|*
name|tb
parameter_list|)
block|{
specifier|static
name|struct
name|nla_policy
name|freq_policy
index|[
name|NL80211_FREQUENCY_ATTR_MAX
operator|+
literal|1
index|]
init|=
block|{
index|[
name|NL80211_FREQUENCY_ATTR_FREQ
index|]
operator|=
block|{
operator|.
name|type
operator|=
name|NLA_U32
block|}
block|,
index|[
name|NL80211_FREQUENCY_ATTR_DISABLED
index|]
operator|=
block|{
operator|.
name|type
operator|=
name|NLA_FLAG
block|}
block|,
index|[
name|NL80211_FREQUENCY_ATTR_NO_IR
index|]
operator|=
block|{
operator|.
name|type
operator|=
name|NLA_FLAG
block|}
block|,
index|[
name|NL80211_FREQUENCY_ATTR_RADAR
index|]
operator|=
block|{
operator|.
name|type
operator|=
name|NLA_FLAG
block|}
block|,
index|[
name|NL80211_FREQUENCY_ATTR_MAX_TX_POWER
index|]
operator|=
block|{
operator|.
name|type
operator|=
name|NLA_U32
block|}
block|,
index|[
name|NL80211_FREQUENCY_ATTR_DFS_STATE
index|]
operator|=
block|{
operator|.
name|type
operator|=
name|NLA_U32
block|}
block|, 	}
decl_stmt|;
name|int
name|new_channels
init|=
literal|0
decl_stmt|;
name|struct
name|hostapd_channel_data
modifier|*
name|channel
decl_stmt|;
name|struct
name|nlattr
modifier|*
name|tb_freq
index|[
name|NL80211_FREQUENCY_ATTR_MAX
operator|+
literal|1
index|]
decl_stmt|;
name|struct
name|nlattr
modifier|*
name|nl_freq
decl_stmt|;
name|int
name|rem_freq
decl_stmt|,
name|idx
decl_stmt|;
if|if
condition|(
name|tb
operator|==
name|NULL
condition|)
return|return
name|NL_OK
return|;
name|nla_for_each_nested
argument_list|(
argument|nl_freq
argument_list|,
argument|tb
argument_list|,
argument|rem_freq
argument_list|)
block|{
name|nla_parse
argument_list|(
name|tb_freq
argument_list|,
name|NL80211_FREQUENCY_ATTR_MAX
argument_list|,
name|nla_data
argument_list|(
name|nl_freq
argument_list|)
argument_list|,
name|nla_len
argument_list|(
name|nl_freq
argument_list|)
argument_list|,
name|freq_policy
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tb_freq
index|[
name|NL80211_FREQUENCY_ATTR_FREQ
index|]
condition|)
continue|continue;
name|new_channels
operator|++
expr_stmt|;
block|}
name|channel
operator|=
name|os_realloc_array
argument_list|(
name|mode
operator|->
name|channels
argument_list|,
name|mode
operator|->
name|num_channels
operator|+
name|new_channels
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|hostapd_channel_data
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|channel
condition|)
return|return
name|NL_SKIP
return|;
name|mode
operator|->
name|channels
operator|=
name|channel
expr_stmt|;
name|mode
operator|->
name|num_channels
operator|+=
name|new_channels
expr_stmt|;
name|idx
operator|=
name|phy_info
operator|->
name|last_chan_idx
expr_stmt|;
name|nla_for_each_nested
argument_list|(
argument|nl_freq
argument_list|,
argument|tb
argument_list|,
argument|rem_freq
argument_list|)
block|{
name|nla_parse
argument_list|(
name|tb_freq
argument_list|,
name|NL80211_FREQUENCY_ATTR_MAX
argument_list|,
name|nla_data
argument_list|(
name|nl_freq
argument_list|)
argument_list|,
name|nla_len
argument_list|(
name|nl_freq
argument_list|)
argument_list|,
name|freq_policy
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tb_freq
index|[
name|NL80211_FREQUENCY_ATTR_FREQ
index|]
condition|)
continue|continue;
name|phy_info_freq
argument_list|(
name|mode
argument_list|,
operator|&
name|mode
operator|->
name|channels
index|[
name|idx
index|]
argument_list|,
name|tb_freq
argument_list|)
expr_stmt|;
name|idx
operator|++
expr_stmt|;
block|}
name|phy_info
operator|->
name|last_chan_idx
operator|=
name|idx
expr_stmt|;
return|return
name|NL_OK
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|phy_info_rates
parameter_list|(
name|struct
name|hostapd_hw_modes
modifier|*
name|mode
parameter_list|,
name|struct
name|nlattr
modifier|*
name|tb
parameter_list|)
block|{
specifier|static
name|struct
name|nla_policy
name|rate_policy
index|[
name|NL80211_BITRATE_ATTR_MAX
operator|+
literal|1
index|]
init|=
block|{
index|[
name|NL80211_BITRATE_ATTR_RATE
index|]
operator|=
block|{
operator|.
name|type
operator|=
name|NLA_U32
block|}
block|,
index|[
name|NL80211_BITRATE_ATTR_2GHZ_SHORTPREAMBLE
index|]
operator|=
block|{
operator|.
name|type
operator|=
name|NLA_FLAG
block|}
block|, 	}
decl_stmt|;
name|struct
name|nlattr
modifier|*
name|tb_rate
index|[
name|NL80211_BITRATE_ATTR_MAX
operator|+
literal|1
index|]
decl_stmt|;
name|struct
name|nlattr
modifier|*
name|nl_rate
decl_stmt|;
name|int
name|rem_rate
decl_stmt|,
name|idx
decl_stmt|;
if|if
condition|(
name|tb
operator|==
name|NULL
condition|)
return|return
name|NL_OK
return|;
name|nla_for_each_nested
argument_list|(
argument|nl_rate
argument_list|,
argument|tb
argument_list|,
argument|rem_rate
argument_list|)
block|{
name|nla_parse
argument_list|(
name|tb_rate
argument_list|,
name|NL80211_BITRATE_ATTR_MAX
argument_list|,
name|nla_data
argument_list|(
name|nl_rate
argument_list|)
argument_list|,
name|nla_len
argument_list|(
name|nl_rate
argument_list|)
argument_list|,
name|rate_policy
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tb_rate
index|[
name|NL80211_BITRATE_ATTR_RATE
index|]
condition|)
continue|continue;
name|mode
operator|->
name|num_rates
operator|++
expr_stmt|;
block|}
name|mode
operator|->
name|rates
operator|=
name|os_calloc
argument_list|(
name|mode
operator|->
name|num_rates
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mode
operator|->
name|rates
condition|)
return|return
name|NL_SKIP
return|;
name|idx
operator|=
literal|0
expr_stmt|;
name|nla_for_each_nested
argument_list|(
argument|nl_rate
argument_list|,
argument|tb
argument_list|,
argument|rem_rate
argument_list|)
block|{
name|nla_parse
argument_list|(
name|tb_rate
argument_list|,
name|NL80211_BITRATE_ATTR_MAX
argument_list|,
name|nla_data
argument_list|(
name|nl_rate
argument_list|)
argument_list|,
name|nla_len
argument_list|(
name|nl_rate
argument_list|)
argument_list|,
name|rate_policy
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tb_rate
index|[
name|NL80211_BITRATE_ATTR_RATE
index|]
condition|)
continue|continue;
name|mode
operator|->
name|rates
index|[
name|idx
index|]
operator|=
name|nla_get_u32
argument_list|(
name|tb_rate
index|[
name|NL80211_BITRATE_ATTR_RATE
index|]
argument_list|)
expr_stmt|;
name|idx
operator|++
expr_stmt|;
block|}
return|return
name|NL_OK
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|phy_info_band
parameter_list|(
name|struct
name|phy_info_arg
modifier|*
name|phy_info
parameter_list|,
name|struct
name|nlattr
modifier|*
name|nl_band
parameter_list|)
block|{
name|struct
name|nlattr
modifier|*
name|tb_band
index|[
name|NL80211_BAND_ATTR_MAX
operator|+
literal|1
index|]
decl_stmt|;
name|struct
name|hostapd_hw_modes
modifier|*
name|mode
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|phy_info
operator|->
name|last_mode
operator|!=
name|nl_band
operator|->
name|nla_type
condition|)
block|{
name|mode
operator|=
name|os_realloc_array
argument_list|(
name|phy_info
operator|->
name|modes
argument_list|,
operator|*
name|phy_info
operator|->
name|num_modes
operator|+
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|mode
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mode
condition|)
return|return
name|NL_SKIP
return|;
name|phy_info
operator|->
name|modes
operator|=
name|mode
expr_stmt|;
name|mode
operator|=
operator|&
name|phy_info
operator|->
name|modes
index|[
operator|*
operator|(
name|phy_info
operator|->
name|num_modes
operator|)
index|]
expr_stmt|;
name|os_memset
argument_list|(
name|mode
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|mode
argument_list|)
argument_list|)
expr_stmt|;
name|mode
operator|->
name|mode
operator|=
name|NUM_HOSTAPD_MODES
expr_stmt|;
name|mode
operator|->
name|flags
operator|=
name|HOSTAPD_MODE_FLAG_HT_INFO_KNOWN
operator||
name|HOSTAPD_MODE_FLAG_VHT_INFO_KNOWN
expr_stmt|;
comment|/* 		 * Unsupported VHT MCS stream is defined as value 3, so the VHT 		 * MCS RX/TX map must be initialized with 0xffff to mark all 8 		 * possible streams as unsupported. This will be overridden if 		 * driver advertises VHT support. 		 */
name|mode
operator|->
name|vht_mcs_set
index|[
literal|0
index|]
operator|=
literal|0xff
expr_stmt|;
name|mode
operator|->
name|vht_mcs_set
index|[
literal|1
index|]
operator|=
literal|0xff
expr_stmt|;
name|mode
operator|->
name|vht_mcs_set
index|[
literal|4
index|]
operator|=
literal|0xff
expr_stmt|;
name|mode
operator|->
name|vht_mcs_set
index|[
literal|5
index|]
operator|=
literal|0xff
expr_stmt|;
operator|*
operator|(
name|phy_info
operator|->
name|num_modes
operator|)
operator|+=
literal|1
expr_stmt|;
name|phy_info
operator|->
name|last_mode
operator|=
name|nl_band
operator|->
name|nla_type
expr_stmt|;
name|phy_info
operator|->
name|last_chan_idx
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|mode
operator|=
operator|&
name|phy_info
operator|->
name|modes
index|[
operator|*
operator|(
name|phy_info
operator|->
name|num_modes
operator|)
operator|-
literal|1
index|]
expr_stmt|;
name|nla_parse
argument_list|(
name|tb_band
argument_list|,
name|NL80211_BAND_ATTR_MAX
argument_list|,
name|nla_data
argument_list|(
name|nl_band
argument_list|)
argument_list|,
name|nla_len
argument_list|(
name|nl_band
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|phy_info_ht_capa
argument_list|(
name|mode
argument_list|,
name|tb_band
index|[
name|NL80211_BAND_ATTR_HT_CAPA
index|]
argument_list|,
name|tb_band
index|[
name|NL80211_BAND_ATTR_HT_AMPDU_FACTOR
index|]
argument_list|,
name|tb_band
index|[
name|NL80211_BAND_ATTR_HT_AMPDU_DENSITY
index|]
argument_list|,
name|tb_band
index|[
name|NL80211_BAND_ATTR_HT_MCS_SET
index|]
argument_list|)
expr_stmt|;
name|phy_info_vht_capa
argument_list|(
name|mode
argument_list|,
name|tb_band
index|[
name|NL80211_BAND_ATTR_VHT_CAPA
index|]
argument_list|,
name|tb_band
index|[
name|NL80211_BAND_ATTR_VHT_MCS_SET
index|]
argument_list|)
expr_stmt|;
name|ret
operator|=
name|phy_info_freqs
argument_list|(
name|phy_info
argument_list|,
name|mode
argument_list|,
name|tb_band
index|[
name|NL80211_BAND_ATTR_FREQS
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|NL_OK
condition|)
return|return
name|ret
return|;
name|ret
operator|=
name|phy_info_rates
argument_list|(
name|mode
argument_list|,
name|tb_band
index|[
name|NL80211_BAND_ATTR_RATES
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|NL_OK
condition|)
return|return
name|ret
return|;
return|return
name|NL_OK
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|phy_info_handler
parameter_list|(
name|struct
name|nl_msg
modifier|*
name|msg
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|nlattr
modifier|*
name|tb_msg
index|[
name|NL80211_ATTR_MAX
operator|+
literal|1
index|]
decl_stmt|;
name|struct
name|genlmsghdr
modifier|*
name|gnlh
init|=
name|nlmsg_data
argument_list|(
name|nlmsg_hdr
argument_list|(
name|msg
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|phy_info_arg
modifier|*
name|phy_info
init|=
name|arg
decl_stmt|;
name|struct
name|nlattr
modifier|*
name|nl_band
decl_stmt|;
name|int
name|rem_band
decl_stmt|;
name|nla_parse
argument_list|(
name|tb_msg
argument_list|,
name|NL80211_ATTR_MAX
argument_list|,
name|genlmsg_attrdata
argument_list|(
name|gnlh
argument_list|,
literal|0
argument_list|)
argument_list|,
name|genlmsg_attrlen
argument_list|(
name|gnlh
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tb_msg
index|[
name|NL80211_ATTR_WIPHY_BANDS
index|]
condition|)
return|return
name|NL_SKIP
return|;
name|nla_for_each_nested
argument_list|(
argument|nl_band
argument_list|,
argument|tb_msg[NL80211_ATTR_WIPHY_BANDS]
argument_list|,
argument|rem_band
argument_list|)
block|{
name|int
name|res
init|=
name|phy_info_band
argument_list|(
name|phy_info
argument_list|,
name|nl_band
argument_list|)
decl_stmt|;
if|if
condition|(
name|res
operator|!=
name|NL_OK
condition|)
return|return
name|res
return|;
block|}
return|return
name|NL_SKIP
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|hostapd_hw_modes
modifier|*
name|wpa_driver_nl80211_postprocess_modes
parameter_list|(
name|struct
name|hostapd_hw_modes
modifier|*
name|modes
parameter_list|,
name|u16
modifier|*
name|num_modes
parameter_list|)
block|{
name|u16
name|m
decl_stmt|;
name|struct
name|hostapd_hw_modes
modifier|*
name|mode11g
init|=
name|NULL
decl_stmt|,
modifier|*
name|nmodes
decl_stmt|,
modifier|*
name|mode
decl_stmt|;
name|int
name|i
decl_stmt|,
name|mode11g_idx
init|=
operator|-
literal|1
decl_stmt|;
comment|/* heuristic to set up modes */
for|for
control|(
name|m
operator|=
literal|0
init|;
name|m
operator|<
operator|*
name|num_modes
condition|;
name|m
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|modes
index|[
name|m
index|]
operator|.
name|num_channels
condition|)
continue|continue;
if|if
condition|(
name|modes
index|[
name|m
index|]
operator|.
name|channels
index|[
literal|0
index|]
operator|.
name|freq
operator|<
literal|4000
condition|)
block|{
name|modes
index|[
name|m
index|]
operator|.
name|mode
operator|=
name|HOSTAPD_MODE_IEEE80211B
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|modes
index|[
name|m
index|]
operator|.
name|num_rates
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|modes
index|[
name|m
index|]
operator|.
name|rates
index|[
name|i
index|]
operator|>
literal|200
condition|)
block|{
name|modes
index|[
name|m
index|]
operator|.
name|mode
operator|=
name|HOSTAPD_MODE_IEEE80211G
expr_stmt|;
break|break;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|modes
index|[
name|m
index|]
operator|.
name|channels
index|[
literal|0
index|]
operator|.
name|freq
operator|>
literal|50000
condition|)
name|modes
index|[
name|m
index|]
operator|.
name|mode
operator|=
name|HOSTAPD_MODE_IEEE80211AD
expr_stmt|;
else|else
name|modes
index|[
name|m
index|]
operator|.
name|mode
operator|=
name|HOSTAPD_MODE_IEEE80211A
expr_stmt|;
block|}
comment|/* If only 802.11g mode is included, use it to construct matching 	 * 802.11b mode data. */
for|for
control|(
name|m
operator|=
literal|0
init|;
name|m
operator|<
operator|*
name|num_modes
condition|;
name|m
operator|++
control|)
block|{
if|if
condition|(
name|modes
index|[
name|m
index|]
operator|.
name|mode
operator|==
name|HOSTAPD_MODE_IEEE80211B
condition|)
return|return
name|modes
return|;
comment|/* 802.11b already included */
if|if
condition|(
name|modes
index|[
name|m
index|]
operator|.
name|mode
operator|==
name|HOSTAPD_MODE_IEEE80211G
condition|)
name|mode11g_idx
operator|=
name|m
expr_stmt|;
block|}
if|if
condition|(
name|mode11g_idx
operator|<
literal|0
condition|)
return|return
name|modes
return|;
comment|/* 2.4 GHz band not supported at all */
name|nmodes
operator|=
name|os_realloc_array
argument_list|(
name|modes
argument_list|,
operator|*
name|num_modes
operator|+
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|nmodes
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nmodes
operator|==
name|NULL
condition|)
return|return
name|modes
return|;
comment|/* Could not add 802.11b mode */
name|mode
operator|=
operator|&
name|nmodes
index|[
operator|*
name|num_modes
index|]
expr_stmt|;
name|os_memset
argument_list|(
name|mode
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|mode
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|num_modes
operator|)
operator|++
expr_stmt|;
name|modes
operator|=
name|nmodes
expr_stmt|;
name|mode
operator|->
name|mode
operator|=
name|HOSTAPD_MODE_IEEE80211B
expr_stmt|;
name|mode11g
operator|=
operator|&
name|modes
index|[
name|mode11g_idx
index|]
expr_stmt|;
name|mode
operator|->
name|num_channels
operator|=
name|mode11g
operator|->
name|num_channels
expr_stmt|;
name|mode
operator|->
name|channels
operator|=
name|os_malloc
argument_list|(
name|mode11g
operator|->
name|num_channels
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|hostapd_channel_data
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|->
name|channels
operator|==
name|NULL
condition|)
block|{
operator|(
operator|*
name|num_modes
operator|)
operator|--
expr_stmt|;
return|return
name|modes
return|;
comment|/* Could not add 802.11b mode */
block|}
name|os_memcpy
argument_list|(
name|mode
operator|->
name|channels
argument_list|,
name|mode11g
operator|->
name|channels
argument_list|,
name|mode11g
operator|->
name|num_channels
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|hostapd_channel_data
argument_list|)
argument_list|)
expr_stmt|;
name|mode
operator|->
name|num_rates
operator|=
literal|0
expr_stmt|;
name|mode
operator|->
name|rates
operator|=
name|os_malloc
argument_list|(
literal|4
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|->
name|rates
operator|==
name|NULL
condition|)
block|{
name|os_free
argument_list|(
name|mode
operator|->
name|channels
argument_list|)
expr_stmt|;
operator|(
operator|*
name|num_modes
operator|)
operator|--
expr_stmt|;
return|return
name|modes
return|;
comment|/* Could not add 802.11b mode */
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mode11g
operator|->
name|num_rates
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|mode11g
operator|->
name|rates
index|[
name|i
index|]
operator|!=
literal|10
operator|&&
name|mode11g
operator|->
name|rates
index|[
name|i
index|]
operator|!=
literal|20
operator|&&
name|mode11g
operator|->
name|rates
index|[
name|i
index|]
operator|!=
literal|55
operator|&&
name|mode11g
operator|->
name|rates
index|[
name|i
index|]
operator|!=
literal|110
condition|)
continue|continue;
name|mode
operator|->
name|rates
index|[
name|mode
operator|->
name|num_rates
index|]
operator|=
name|mode11g
operator|->
name|rates
index|[
name|i
index|]
expr_stmt|;
name|mode
operator|->
name|num_rates
operator|++
expr_stmt|;
if|if
condition|(
name|mode
operator|->
name|num_rates
operator|==
literal|4
condition|)
break|break;
block|}
if|if
condition|(
name|mode
operator|->
name|num_rates
operator|==
literal|0
condition|)
block|{
name|os_free
argument_list|(
name|mode
operator|->
name|channels
argument_list|)
expr_stmt|;
name|os_free
argument_list|(
name|mode
operator|->
name|rates
argument_list|)
expr_stmt|;
operator|(
operator|*
name|num_modes
operator|)
operator|--
expr_stmt|;
return|return
name|modes
return|;
comment|/* No 802.11b rates */
block|}
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"nl80211: Added 802.11b mode based on 802.11g "
literal|"information"
argument_list|)
expr_stmt|;
return|return
name|modes
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|nl80211_set_ht40_mode
parameter_list|(
name|struct
name|hostapd_hw_modes
modifier|*
name|mode
parameter_list|,
name|int
name|start
parameter_list|,
name|int
name|end
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|mode
operator|->
name|num_channels
condition|;
name|c
operator|++
control|)
block|{
name|struct
name|hostapd_channel_data
modifier|*
name|chan
init|=
operator|&
name|mode
operator|->
name|channels
index|[
name|c
index|]
decl_stmt|;
if|if
condition|(
name|chan
operator|->
name|freq
operator|-
literal|10
operator|>=
name|start
operator|&&
name|chan
operator|->
name|freq
operator|+
literal|10
operator|<=
name|end
condition|)
name|chan
operator|->
name|flag
operator||=
name|HOSTAPD_CHAN_HT40
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|nl80211_set_ht40_mode_sec
parameter_list|(
name|struct
name|hostapd_hw_modes
modifier|*
name|mode
parameter_list|,
name|int
name|start
parameter_list|,
name|int
name|end
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|mode
operator|->
name|num_channels
condition|;
name|c
operator|++
control|)
block|{
name|struct
name|hostapd_channel_data
modifier|*
name|chan
init|=
operator|&
name|mode
operator|->
name|channels
index|[
name|c
index|]
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|chan
operator|->
name|flag
operator|&
name|HOSTAPD_CHAN_HT40
operator|)
condition|)
continue|continue;
if|if
condition|(
name|chan
operator|->
name|freq
operator|-
literal|30
operator|>=
name|start
operator|&&
name|chan
operator|->
name|freq
operator|-
literal|10
operator|<=
name|end
condition|)
name|chan
operator|->
name|flag
operator||=
name|HOSTAPD_CHAN_HT40MINUS
expr_stmt|;
if|if
condition|(
name|chan
operator|->
name|freq
operator|+
literal|10
operator|>=
name|start
operator|&&
name|chan
operator|->
name|freq
operator|+
literal|30
operator|<=
name|end
condition|)
name|chan
operator|->
name|flag
operator||=
name|HOSTAPD_CHAN_HT40PLUS
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|nl80211_reg_rule_max_eirp
parameter_list|(
name|u32
name|start
parameter_list|,
name|u32
name|end
parameter_list|,
name|u32
name|max_eirp
parameter_list|,
name|struct
name|phy_info_arg
modifier|*
name|results
parameter_list|)
block|{
name|u16
name|m
decl_stmt|;
for|for
control|(
name|m
operator|=
literal|0
init|;
name|m
operator|<
operator|*
name|results
operator|->
name|num_modes
condition|;
name|m
operator|++
control|)
block|{
name|int
name|c
decl_stmt|;
name|struct
name|hostapd_hw_modes
modifier|*
name|mode
init|=
operator|&
name|results
operator|->
name|modes
index|[
name|m
index|]
decl_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|mode
operator|->
name|num_channels
condition|;
name|c
operator|++
control|)
block|{
name|struct
name|hostapd_channel_data
modifier|*
name|chan
init|=
operator|&
name|mode
operator|->
name|channels
index|[
name|c
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|u32
operator|)
name|chan
operator|->
name|freq
operator|-
literal|10
operator|>=
name|start
operator|&&
operator|(
name|u32
operator|)
name|chan
operator|->
name|freq
operator|+
literal|10
operator|<=
name|end
condition|)
name|chan
operator|->
name|max_tx_power
operator|=
name|max_eirp
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|nl80211_reg_rule_ht40
parameter_list|(
name|u32
name|start
parameter_list|,
name|u32
name|end
parameter_list|,
name|struct
name|phy_info_arg
modifier|*
name|results
parameter_list|)
block|{
name|u16
name|m
decl_stmt|;
for|for
control|(
name|m
operator|=
literal|0
init|;
name|m
operator|<
operator|*
name|results
operator|->
name|num_modes
condition|;
name|m
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|results
operator|->
name|modes
index|[
name|m
index|]
operator|.
name|ht_capab
operator|&
name|HT_CAP_INFO_SUPP_CHANNEL_WIDTH_SET
operator|)
condition|)
continue|continue;
name|nl80211_set_ht40_mode
argument_list|(
operator|&
name|results
operator|->
name|modes
index|[
name|m
index|]
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|nl80211_reg_rule_sec
parameter_list|(
name|struct
name|nlattr
modifier|*
name|tb
index|[]
parameter_list|,
name|struct
name|phy_info_arg
modifier|*
name|results
parameter_list|)
block|{
name|u32
name|start
decl_stmt|,
name|end
decl_stmt|,
name|max_bw
decl_stmt|;
name|u16
name|m
decl_stmt|;
if|if
condition|(
name|tb
index|[
name|NL80211_ATTR_FREQ_RANGE_START
index|]
operator|==
name|NULL
operator|||
name|tb
index|[
name|NL80211_ATTR_FREQ_RANGE_END
index|]
operator|==
name|NULL
operator|||
name|tb
index|[
name|NL80211_ATTR_FREQ_RANGE_MAX_BW
index|]
operator|==
name|NULL
condition|)
return|return;
name|start
operator|=
name|nla_get_u32
argument_list|(
name|tb
index|[
name|NL80211_ATTR_FREQ_RANGE_START
index|]
argument_list|)
operator|/
literal|1000
expr_stmt|;
name|end
operator|=
name|nla_get_u32
argument_list|(
name|tb
index|[
name|NL80211_ATTR_FREQ_RANGE_END
index|]
argument_list|)
operator|/
literal|1000
expr_stmt|;
name|max_bw
operator|=
name|nla_get_u32
argument_list|(
name|tb
index|[
name|NL80211_ATTR_FREQ_RANGE_MAX_BW
index|]
argument_list|)
operator|/
literal|1000
expr_stmt|;
if|if
condition|(
name|max_bw
operator|<
literal|20
condition|)
return|return;
for|for
control|(
name|m
operator|=
literal|0
init|;
name|m
operator|<
operator|*
name|results
operator|->
name|num_modes
condition|;
name|m
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|results
operator|->
name|modes
index|[
name|m
index|]
operator|.
name|ht_capab
operator|&
name|HT_CAP_INFO_SUPP_CHANNEL_WIDTH_SET
operator|)
condition|)
continue|continue;
name|nl80211_set_ht40_mode_sec
argument_list|(
operator|&
name|results
operator|->
name|modes
index|[
name|m
index|]
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|nl80211_set_vht_mode
parameter_list|(
name|struct
name|hostapd_hw_modes
modifier|*
name|mode
parameter_list|,
name|int
name|start
parameter_list|,
name|int
name|end
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|mode
operator|->
name|num_channels
condition|;
name|c
operator|++
control|)
block|{
name|struct
name|hostapd_channel_data
modifier|*
name|chan
init|=
operator|&
name|mode
operator|->
name|channels
index|[
name|c
index|]
decl_stmt|;
if|if
condition|(
name|chan
operator|->
name|freq
operator|-
literal|10
operator|>=
name|start
operator|&&
name|chan
operator|->
name|freq
operator|+
literal|70
operator|<=
name|end
condition|)
name|chan
operator|->
name|flag
operator||=
name|HOSTAPD_CHAN_VHT_10_70
expr_stmt|;
if|if
condition|(
name|chan
operator|->
name|freq
operator|-
literal|30
operator|>=
name|start
operator|&&
name|chan
operator|->
name|freq
operator|+
literal|50
operator|<=
name|end
condition|)
name|chan
operator|->
name|flag
operator||=
name|HOSTAPD_CHAN_VHT_30_50
expr_stmt|;
if|if
condition|(
name|chan
operator|->
name|freq
operator|-
literal|50
operator|>=
name|start
operator|&&
name|chan
operator|->
name|freq
operator|+
literal|30
operator|<=
name|end
condition|)
name|chan
operator|->
name|flag
operator||=
name|HOSTAPD_CHAN_VHT_50_30
expr_stmt|;
if|if
condition|(
name|chan
operator|->
name|freq
operator|-
literal|70
operator|>=
name|start
operator|&&
name|chan
operator|->
name|freq
operator|+
literal|10
operator|<=
name|end
condition|)
name|chan
operator|->
name|flag
operator||=
name|HOSTAPD_CHAN_VHT_70_10
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|nl80211_reg_rule_vht
parameter_list|(
name|struct
name|nlattr
modifier|*
name|tb
index|[]
parameter_list|,
name|struct
name|phy_info_arg
modifier|*
name|results
parameter_list|)
block|{
name|u32
name|start
decl_stmt|,
name|end
decl_stmt|,
name|max_bw
decl_stmt|;
name|u16
name|m
decl_stmt|;
if|if
condition|(
name|tb
index|[
name|NL80211_ATTR_FREQ_RANGE_START
index|]
operator|==
name|NULL
operator|||
name|tb
index|[
name|NL80211_ATTR_FREQ_RANGE_END
index|]
operator|==
name|NULL
operator|||
name|tb
index|[
name|NL80211_ATTR_FREQ_RANGE_MAX_BW
index|]
operator|==
name|NULL
condition|)
return|return;
name|start
operator|=
name|nla_get_u32
argument_list|(
name|tb
index|[
name|NL80211_ATTR_FREQ_RANGE_START
index|]
argument_list|)
operator|/
literal|1000
expr_stmt|;
name|end
operator|=
name|nla_get_u32
argument_list|(
name|tb
index|[
name|NL80211_ATTR_FREQ_RANGE_END
index|]
argument_list|)
operator|/
literal|1000
expr_stmt|;
name|max_bw
operator|=
name|nla_get_u32
argument_list|(
name|tb
index|[
name|NL80211_ATTR_FREQ_RANGE_MAX_BW
index|]
argument_list|)
operator|/
literal|1000
expr_stmt|;
if|if
condition|(
name|max_bw
operator|<
literal|80
condition|)
return|return;
for|for
control|(
name|m
operator|=
literal|0
init|;
name|m
operator|<
operator|*
name|results
operator|->
name|num_modes
condition|;
name|m
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|results
operator|->
name|modes
index|[
name|m
index|]
operator|.
name|ht_capab
operator|&
name|HT_CAP_INFO_SUPP_CHANNEL_WIDTH_SET
operator|)
condition|)
continue|continue;
comment|/* TODO: use a real VHT support indication */
if|if
condition|(
operator|!
name|results
operator|->
name|modes
index|[
name|m
index|]
operator|.
name|vht_capab
condition|)
continue|continue;
name|nl80211_set_vht_mode
argument_list|(
operator|&
name|results
operator|->
name|modes
index|[
name|m
index|]
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|dfs_domain_name
parameter_list|(
name|enum
name|nl80211_dfs_regions
name|region
parameter_list|)
block|{
switch|switch
condition|(
name|region
condition|)
block|{
case|case
name|NL80211_DFS_UNSET
case|:
return|return
literal|"DFS-UNSET"
return|;
case|case
name|NL80211_DFS_FCC
case|:
return|return
literal|"DFS-FCC"
return|;
case|case
name|NL80211_DFS_ETSI
case|:
return|return
literal|"DFS-ETSI"
return|;
case|case
name|NL80211_DFS_JP
case|:
return|return
literal|"DFS-JP"
return|;
default|default:
return|return
literal|"DFS-invalid"
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|nl80211_get_reg
parameter_list|(
name|struct
name|nl_msg
modifier|*
name|msg
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|phy_info_arg
modifier|*
name|results
init|=
name|arg
decl_stmt|;
name|struct
name|nlattr
modifier|*
name|tb_msg
index|[
name|NL80211_ATTR_MAX
operator|+
literal|1
index|]
decl_stmt|;
name|struct
name|genlmsghdr
modifier|*
name|gnlh
init|=
name|nlmsg_data
argument_list|(
name|nlmsg_hdr
argument_list|(
name|msg
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|nlattr
modifier|*
name|nl_rule
decl_stmt|;
name|struct
name|nlattr
modifier|*
name|tb_rule
index|[
name|NL80211_FREQUENCY_ATTR_MAX
operator|+
literal|1
index|]
decl_stmt|;
name|int
name|rem_rule
decl_stmt|;
specifier|static
name|struct
name|nla_policy
name|reg_policy
index|[
name|NL80211_FREQUENCY_ATTR_MAX
operator|+
literal|1
index|]
init|=
block|{
index|[
name|NL80211_ATTR_REG_RULE_FLAGS
index|]
operator|=
block|{
operator|.
name|type
operator|=
name|NLA_U32
block|}
block|,
index|[
name|NL80211_ATTR_FREQ_RANGE_START
index|]
operator|=
block|{
operator|.
name|type
operator|=
name|NLA_U32
block|}
block|,
index|[
name|NL80211_ATTR_FREQ_RANGE_END
index|]
operator|=
block|{
operator|.
name|type
operator|=
name|NLA_U32
block|}
block|,
index|[
name|NL80211_ATTR_FREQ_RANGE_MAX_BW
index|]
operator|=
block|{
operator|.
name|type
operator|=
name|NLA_U32
block|}
block|,
index|[
name|NL80211_ATTR_POWER_RULE_MAX_ANT_GAIN
index|]
operator|=
block|{
operator|.
name|type
operator|=
name|NLA_U32
block|}
block|,
index|[
name|NL80211_ATTR_POWER_RULE_MAX_EIRP
index|]
operator|=
block|{
operator|.
name|type
operator|=
name|NLA_U32
block|}
block|, 	}
decl_stmt|;
name|nla_parse
argument_list|(
name|tb_msg
argument_list|,
name|NL80211_ATTR_MAX
argument_list|,
name|genlmsg_attrdata
argument_list|(
name|gnlh
argument_list|,
literal|0
argument_list|)
argument_list|,
name|genlmsg_attrlen
argument_list|(
name|gnlh
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tb_msg
index|[
name|NL80211_ATTR_REG_ALPHA2
index|]
operator|||
operator|!
name|tb_msg
index|[
name|NL80211_ATTR_REG_RULES
index|]
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"nl80211: No regulatory information "
literal|"available"
argument_list|)
expr_stmt|;
return|return
name|NL_SKIP
return|;
block|}
if|if
condition|(
name|tb_msg
index|[
name|NL80211_ATTR_DFS_REGION
index|]
condition|)
block|{
name|enum
name|nl80211_dfs_regions
name|dfs_domain
decl_stmt|;
name|dfs_domain
operator|=
name|nla_get_u8
argument_list|(
name|tb_msg
index|[
name|NL80211_ATTR_DFS_REGION
index|]
argument_list|)
expr_stmt|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"nl80211: Regulatory information - country=%s (%s)"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|nla_data
argument_list|(
name|tb_msg
index|[
name|NL80211_ATTR_REG_ALPHA2
index|]
argument_list|)
argument_list|,
name|dfs_domain_name
argument_list|(
name|dfs_domain
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"nl80211: Regulatory information - country=%s"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|nla_data
argument_list|(
name|tb_msg
index|[
name|NL80211_ATTR_REG_ALPHA2
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|nla_for_each_nested
argument_list|(
argument|nl_rule
argument_list|,
argument|tb_msg[NL80211_ATTR_REG_RULES]
argument_list|,
argument|rem_rule
argument_list|)
block|{
name|u32
name|start
decl_stmt|,
name|end
decl_stmt|,
name|max_eirp
init|=
literal|0
decl_stmt|,
name|max_bw
init|=
literal|0
decl_stmt|,
name|flags
init|=
literal|0
decl_stmt|;
name|nla_parse
argument_list|(
name|tb_rule
argument_list|,
name|NL80211_FREQUENCY_ATTR_MAX
argument_list|,
name|nla_data
argument_list|(
name|nl_rule
argument_list|)
argument_list|,
name|nla_len
argument_list|(
name|nl_rule
argument_list|)
argument_list|,
name|reg_policy
argument_list|)
expr_stmt|;
if|if
condition|(
name|tb_rule
index|[
name|NL80211_ATTR_FREQ_RANGE_START
index|]
operator|==
name|NULL
operator|||
name|tb_rule
index|[
name|NL80211_ATTR_FREQ_RANGE_END
index|]
operator|==
name|NULL
condition|)
continue|continue;
name|start
operator|=
name|nla_get_u32
argument_list|(
name|tb_rule
index|[
name|NL80211_ATTR_FREQ_RANGE_START
index|]
argument_list|)
operator|/
literal|1000
expr_stmt|;
name|end
operator|=
name|nla_get_u32
argument_list|(
name|tb_rule
index|[
name|NL80211_ATTR_FREQ_RANGE_END
index|]
argument_list|)
operator|/
literal|1000
expr_stmt|;
if|if
condition|(
name|tb_rule
index|[
name|NL80211_ATTR_POWER_RULE_MAX_EIRP
index|]
condition|)
name|max_eirp
operator|=
name|nla_get_u32
argument_list|(
name|tb_rule
index|[
name|NL80211_ATTR_POWER_RULE_MAX_EIRP
index|]
argument_list|)
operator|/
literal|100
expr_stmt|;
if|if
condition|(
name|tb_rule
index|[
name|NL80211_ATTR_FREQ_RANGE_MAX_BW
index|]
condition|)
name|max_bw
operator|=
name|nla_get_u32
argument_list|(
name|tb_rule
index|[
name|NL80211_ATTR_FREQ_RANGE_MAX_BW
index|]
argument_list|)
operator|/
literal|1000
expr_stmt|;
if|if
condition|(
name|tb_rule
index|[
name|NL80211_ATTR_REG_RULE_FLAGS
index|]
condition|)
name|flags
operator|=
name|nla_get_u32
argument_list|(
name|tb_rule
index|[
name|NL80211_ATTR_REG_RULE_FLAGS
index|]
argument_list|)
expr_stmt|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"nl80211: %u-%u @ %u MHz %u mBm%s%s%s%s%s%s%s%s"
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|max_bw
argument_list|,
name|max_eirp
argument_list|,
name|flags
operator|&
name|NL80211_RRF_NO_OFDM
condition|?
literal|" (no OFDM)"
else|:
literal|""
argument_list|,
name|flags
operator|&
name|NL80211_RRF_NO_CCK
condition|?
literal|" (no CCK)"
else|:
literal|""
argument_list|,
name|flags
operator|&
name|NL80211_RRF_NO_INDOOR
condition|?
literal|" (no indoor)"
else|:
literal|""
argument_list|,
name|flags
operator|&
name|NL80211_RRF_NO_OUTDOOR
condition|?
literal|" (no outdoor)"
else|:
literal|""
argument_list|,
name|flags
operator|&
name|NL80211_RRF_DFS
condition|?
literal|" (DFS)"
else|:
literal|""
argument_list|,
name|flags
operator|&
name|NL80211_RRF_PTP_ONLY
condition|?
literal|" (PTP only)"
else|:
literal|""
argument_list|,
name|flags
operator|&
name|NL80211_RRF_PTMP_ONLY
condition|?
literal|" (PTMP only)"
else|:
literal|""
argument_list|,
name|flags
operator|&
name|NL80211_RRF_NO_IR
condition|?
literal|" (no IR)"
else|:
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|max_bw
operator|>=
literal|40
condition|)
name|nl80211_reg_rule_ht40
argument_list|(
name|start
argument_list|,
name|end
argument_list|,
name|results
argument_list|)
expr_stmt|;
if|if
condition|(
name|tb_rule
index|[
name|NL80211_ATTR_POWER_RULE_MAX_EIRP
index|]
condition|)
name|nl80211_reg_rule_max_eirp
argument_list|(
name|start
argument_list|,
name|end
argument_list|,
name|max_eirp
argument_list|,
name|results
argument_list|)
expr_stmt|;
block|}
name|nla_for_each_nested
argument_list|(
argument|nl_rule
argument_list|,
argument|tb_msg[NL80211_ATTR_REG_RULES]
argument_list|,
argument|rem_rule
argument_list|)
block|{
name|nla_parse
argument_list|(
name|tb_rule
argument_list|,
name|NL80211_FREQUENCY_ATTR_MAX
argument_list|,
name|nla_data
argument_list|(
name|nl_rule
argument_list|)
argument_list|,
name|nla_len
argument_list|(
name|nl_rule
argument_list|)
argument_list|,
name|reg_policy
argument_list|)
expr_stmt|;
name|nl80211_reg_rule_sec
argument_list|(
name|tb_rule
argument_list|,
name|results
argument_list|)
expr_stmt|;
block|}
name|nla_for_each_nested
argument_list|(
argument|nl_rule
argument_list|,
argument|tb_msg[NL80211_ATTR_REG_RULES]
argument_list|,
argument|rem_rule
argument_list|)
block|{
name|nla_parse
argument_list|(
name|tb_rule
argument_list|,
name|NL80211_FREQUENCY_ATTR_MAX
argument_list|,
name|nla_data
argument_list|(
name|nl_rule
argument_list|)
argument_list|,
name|nla_len
argument_list|(
name|nl_rule
argument_list|)
argument_list|,
name|reg_policy
argument_list|)
expr_stmt|;
name|nl80211_reg_rule_vht
argument_list|(
name|tb_rule
argument_list|,
name|results
argument_list|)
expr_stmt|;
block|}
return|return
name|NL_SKIP
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|nl80211_set_regulatory_flags
parameter_list|(
name|struct
name|wpa_driver_nl80211_data
modifier|*
name|drv
parameter_list|,
name|struct
name|phy_info_arg
modifier|*
name|results
parameter_list|)
block|{
name|struct
name|nl_msg
modifier|*
name|msg
decl_stmt|;
name|msg
operator|=
name|nlmsg_alloc
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|msg
condition|)
return|return
operator|-
name|ENOMEM
return|;
name|nl80211_cmd
argument_list|(
name|drv
argument_list|,
name|msg
argument_list|,
literal|0
argument_list|,
name|NL80211_CMD_GET_REG
argument_list|)
expr_stmt|;
return|return
name|send_and_recv_msgs
argument_list|(
name|drv
argument_list|,
name|msg
argument_list|,
name|nl80211_get_reg
argument_list|,
name|results
argument_list|)
return|;
block|}
end_function

begin_function
name|struct
name|hostapd_hw_modes
modifier|*
name|nl80211_get_hw_feature_data
parameter_list|(
name|void
modifier|*
name|priv
parameter_list|,
name|u16
modifier|*
name|num_modes
parameter_list|,
name|u16
modifier|*
name|flags
parameter_list|)
block|{
name|u32
name|feat
decl_stmt|;
name|struct
name|i802_bss
modifier|*
name|bss
init|=
name|priv
decl_stmt|;
name|struct
name|wpa_driver_nl80211_data
modifier|*
name|drv
init|=
name|bss
operator|->
name|drv
decl_stmt|;
name|int
name|nl_flags
init|=
literal|0
decl_stmt|;
name|struct
name|nl_msg
modifier|*
name|msg
decl_stmt|;
name|struct
name|phy_info_arg
name|result
init|=
block|{
operator|.
name|num_modes
operator|=
name|num_modes
block|,
operator|.
name|modes
operator|=
name|NULL
block|,
operator|.
name|last_mode
operator|=
operator|-
literal|1
block|, 	}
decl_stmt|;
operator|*
name|num_modes
operator|=
literal|0
expr_stmt|;
operator|*
name|flags
operator|=
literal|0
expr_stmt|;
name|feat
operator|=
name|get_nl80211_protocol_features
argument_list|(
name|drv
argument_list|)
expr_stmt|;
if|if
condition|(
name|feat
operator|&
name|NL80211_PROTOCOL_FEATURE_SPLIT_WIPHY_DUMP
condition|)
name|nl_flags
operator|=
name|NLM_F_DUMP
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|msg
operator|=
name|nl80211_cmd_msg
argument_list|(
name|bss
argument_list|,
name|nl_flags
argument_list|,
name|NL80211_CMD_GET_WIPHY
argument_list|)
operator|)
operator|||
name|nla_put_flag
argument_list|(
name|msg
argument_list|,
name|NL80211_ATTR_SPLIT_WIPHY_DUMP
argument_list|)
condition|)
block|{
name|nlmsg_free
argument_list|(
name|msg
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|send_and_recv_msgs
argument_list|(
name|drv
argument_list|,
name|msg
argument_list|,
name|phy_info_handler
argument_list|,
operator|&
name|result
argument_list|)
operator|==
literal|0
condition|)
block|{
name|nl80211_set_regulatory_flags
argument_list|(
name|drv
argument_list|,
operator|&
name|result
argument_list|)
expr_stmt|;
return|return
name|wpa_driver_nl80211_postprocess_modes
argument_list|(
name|result
operator|.
name|modes
argument_list|,
name|num_modes
argument_list|)
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

end_unit

