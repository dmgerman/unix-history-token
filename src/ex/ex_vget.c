begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (c) 1979 Regents of the University of California */
end_comment

begin_include
include|#
directive|include
file|"ex.h"
end_include

begin_include
include|#
directive|include
file|"ex_tty.h"
end_include

begin_include
include|#
directive|include
file|"ex_vis.h"
end_include

begin_comment
comment|/*  * Input routines for open/visual.  * We handle upper case only terminals in visual and reading from the  * echo area here as well as notification on large changes  * which appears in the echo area.  */
end_comment

begin_comment
comment|/*  * Return the key.  */
end_comment

begin_macro
name|ungetkey
argument_list|(
argument|c
argument_list|)
end_macro

begin_decl_stmt
name|char
name|c
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|Peekkey
operator|!=
name|ATTN
condition|)
name|Peekkey
operator|=
name|c
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Return a keystroke, but never a ^@.  */
end_comment

begin_macro
name|getkey
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|char
name|c
decl_stmt|;
do|do
name|c
operator|=
name|getbr
argument_list|()
expr_stmt|;
do|while
condition|(
name|c
operator|==
literal|0
condition|)
do|;
return|return
operator|(
name|c
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Tell whether next keystroke would be a ^@.  */
end_comment

begin_macro
name|peekbr
argument_list|()
end_macro

begin_block
block|{
name|Peekkey
operator|=
name|getbr
argument_list|()
expr_stmt|;
return|return
operator|(
name|Peekkey
operator|==
literal|0
operator|)
return|;
block|}
end_block

begin_decl_stmt
name|short
name|precbksl
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Get a keystroke, including a ^@.  * If an key was returned with ungetkey, that  * comes back first.  Next comes unread input (e.g.  * from repeating commands with .), and finally new  * keystrokes.  *  * The hard work here is in mapping of \ escaped  * characters on upper case only terminals.  */
end_comment

begin_macro
name|getbr
argument_list|()
end_macro

begin_block
block|{
name|char
name|ch
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|,
name|d
decl_stmt|;
specifier|register
name|char
modifier|*
name|colp
decl_stmt|;
name|getATTN
label|:
if|if
condition|(
name|Peekkey
condition|)
block|{
name|c
operator|=
name|Peekkey
expr_stmt|;
name|Peekkey
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|c
operator|)
return|;
block|}
if|if
condition|(
name|vglobp
condition|)
block|{
if|if
condition|(
operator|*
name|vglobp
condition|)
return|return
operator|(
operator|*
name|vglobp
operator|++
operator|)
return|;
return|return
operator|(
name|ESCAPE
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|TRACE
if|if
condition|(
name|trace
condition|)
name|fflush
argument_list|(
name|trace
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|flusho
argument_list|()
expr_stmt|;
name|again
label|:
if|if
condition|(
name|read
argument_list|(
literal|0
argument_list|,
operator|&
name|ch
argument_list|,
literal|1
argument_list|)
operator|!=
literal|1
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EINTR
condition|)
goto|goto
name|getATTN
goto|;
name|error
argument_list|(
literal|"Input read error"
argument_list|)
expr_stmt|;
block|}
name|c
operator|=
name|ch
operator|&
name|TRIM
expr_stmt|;
ifdef|#
directive|ifdef
name|UCVISUAL
comment|/* 	 * The algorithm here is that of the UNIX kernel. 	 * See the description in the programmers manual. 	 */
if|if
condition|(
name|UPPERCASE
condition|)
block|{
if|if
condition|(
name|isupper
argument_list|(
name|c
argument_list|)
condition|)
name|c
operator|=
name|tolower
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
if|if
condition|(
name|precbksl
operator|<
literal|2
condition|)
name|precbksl
operator|++
expr_stmt|;
if|if
condition|(
name|precbksl
operator|==
literal|1
condition|)
goto|goto
name|again
goto|;
block|}
elseif|else
if|if
condition|(
name|precbksl
condition|)
block|{
name|d
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|islower
argument_list|(
name|c
argument_list|)
condition|)
name|d
operator|=
name|toupper
argument_list|(
name|c
argument_list|)
expr_stmt|;
else|else
block|{
name|colp
operator|=
literal|"({)}!|^~'~"
expr_stmt|;
while|while
condition|(
name|d
operator|=
operator|*
name|colp
operator|++
condition|)
if|if
condition|(
name|d
operator|==
name|c
condition|)
block|{
name|d
operator|=
operator|*
name|colp
operator|++
expr_stmt|;
break|break;
block|}
else|else
name|colp
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|precbksl
operator|==
literal|2
condition|)
block|{
if|if
condition|(
operator|!
name|d
condition|)
block|{
name|Peekkey
operator|=
name|c
expr_stmt|;
name|precbksl
operator|=
literal|0
expr_stmt|;
name|c
operator|=
literal|'\\'
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|d
condition|)
name|c
operator|=
name|d
expr_stmt|;
else|else
block|{
name|Peekkey
operator|=
name|c
expr_stmt|;
name|precbksl
operator|=
literal|0
expr_stmt|;
name|c
operator|=
literal|'\\'
expr_stmt|;
block|}
block|}
if|if
condition|(
name|c
operator|!=
literal|'\\'
condition|)
name|precbksl
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TRACE
if|if
condition|(
name|trace
condition|)
block|{
if|if
condition|(
operator|!
name|techoin
condition|)
block|{
name|tfixnl
argument_list|()
expr_stmt|;
name|techoin
operator|=
literal|1
expr_stmt|;
name|fprintf
argument_list|(
name|trace
argument_list|,
literal|"*** Input: "
argument_list|)
expr_stmt|;
block|}
name|tracec
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
operator|(
name|c
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Get a key, but if a delete, quit or attention  * is typed return 0 so we will abort a partial command.  */
end_comment

begin_macro
name|getesc
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|c
decl_stmt|;
name|c
operator|=
name|getkey
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|ATTN
case|:
case|case
name|QUIT
case|:
name|ungetkey
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|ESCAPE
case|:
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|c
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Peek at the next keystroke.  */
end_comment

begin_macro
name|peekkey
argument_list|()
end_macro

begin_block
block|{
name|Peekkey
operator|=
name|getkey
argument_list|()
expr_stmt|;
return|return
operator|(
name|Peekkey
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Read a line from the echo area, with single character prompt c.  * A return value of 1 means the user blewit or blewit away.  */
end_comment

begin_macro
name|readecho
argument_list|(
argument|c
argument_list|)
end_macro

begin_decl_stmt
name|char
name|c
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|sc
init|=
name|cursor
decl_stmt|;
name|int
function_decl|(
modifier|*
name|OP
function_decl|)
parameter_list|()
function_decl|;
name|bool
name|waste
decl_stmt|;
if|if
condition|(
name|WBOT
operator|==
name|WECHO
condition|)
name|vclean
argument_list|()
expr_stmt|;
else|else
name|vclrech
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|splitw
operator|++
expr_stmt|;
name|vgoto
argument_list|(
name|WECHO
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|vclreol
argument_list|()
expr_stmt|;
name|vgoto
argument_list|(
name|WECHO
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cursor
operator|=
name|linebuf
expr_stmt|;
name|linebuf
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|genbuf
index|[
literal|0
index|]
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|peekbr
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|INS
index|[
literal|0
index|]
operator|||
operator|(
name|INS
index|[
literal|0
index|]
operator|&
operator|(
name|QUOTE
operator||
name|TRIM
operator|)
operator|)
operator|==
name|OVERBUF
condition|)
goto|goto
name|blewit
goto|;
name|vglobp
operator|=
name|INS
expr_stmt|;
block|}
name|OP
operator|=
name|Pline
expr_stmt|;
name|Pline
operator|=
name|normline
expr_stmt|;
name|ignore
argument_list|(
name|vgetline
argument_list|(
literal|0
argument_list|,
name|genbuf
operator|+
literal|1
argument_list|,
operator|&
name|waste
argument_list|)
argument_list|)
expr_stmt|;
name|vscrap
argument_list|()
expr_stmt|;
name|Pline
operator|=
name|OP
expr_stmt|;
if|if
condition|(
name|Peekkey
operator|!=
name|ATTN
operator|&&
name|Peekkey
operator|!=
name|QUIT
condition|)
block|{
name|cursor
operator|=
name|sc
expr_stmt|;
name|vclreol
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|blewit
label|:
name|splitw
operator|=
literal|0
expr_stmt|;
name|vclean
argument_list|()
expr_stmt|;
name|vshow
argument_list|(
name|dot
argument_list|,
name|NOLINE
argument_list|)
expr_stmt|;
name|vnline
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * A complete command has been defined for  * the purposes of repeat, so copy it from  * the working to the previous command buffer.  */
end_comment

begin_macro
name|setLAST
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|vglobp
condition|)
return|return;
name|lastreg
operator|=
name|vreg
expr_stmt|;
name|lasthad
operator|=
name|Xhadcnt
expr_stmt|;
name|lastcnt
operator|=
name|Xcnt
expr_stmt|;
operator|*
name|lastcp
operator|=
literal|0
expr_stmt|;
name|CP
argument_list|(
name|lastcmd
argument_list|,
name|workcmd
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Gather up some more text from an insert.  * If the insertion buffer oveflows, then destroy  * the repeatability of the insert.  */
end_comment

begin_macro
name|addtext
argument_list|(
argument|cp
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|cp
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|vglobp
condition|)
return|return;
name|addto
argument_list|(
name|INS
argument_list|,
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|INS
index|[
literal|0
index|]
operator|&
operator|(
name|QUOTE
operator||
name|TRIM
operator|)
operator|)
operator|==
name|OVERBUF
condition|)
name|lastcmd
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_macro
name|setDEL
argument_list|()
end_macro

begin_block
block|{
name|setBUF
argument_list|(
name|DEL
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Put text from cursor upto wcursor in BUF.  */
end_comment

begin_expr_stmt
name|setBUF
argument_list|(
name|BUF
argument_list|)
specifier|register
name|char
operator|*
name|BUF
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|char
modifier|*
name|wp
init|=
name|wcursor
decl_stmt|;
name|c
operator|=
operator|*
name|wp
expr_stmt|;
operator|*
name|wp
operator|=
literal|0
expr_stmt|;
name|BUF
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|addto
argument_list|(
name|BUF
argument_list|,
name|cursor
argument_list|)
expr_stmt|;
operator|*
name|wp
operator|=
name|c
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|addto
argument_list|(
name|buf
argument_list|,
name|str
argument_list|)
specifier|register
name|char
operator|*
name|buf
operator|,
operator|*
name|str
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
operator|(
name|buf
index|[
literal|0
index|]
operator|&
operator|(
name|QUOTE
operator||
name|TRIM
operator|)
operator|)
operator|==
name|OVERBUF
condition|)
return|return;
if|if
condition|(
name|strlen
argument_list|(
name|buf
argument_list|)
operator|+
name|strlen
argument_list|(
name|str
argument_list|)
operator|+
literal|1
operator|>=
name|VBSIZE
condition|)
block|{
name|buf
index|[
literal|0
index|]
operator|=
name|OVERBUF
expr_stmt|;
return|return;
block|}
name|ignore
argument_list|(
name|strcat
argument_list|(
name|buf
argument_list|,
name|str
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Note a change affecting a lot of lines, or non-visible  * lines.  If the parameter must is set, then we only want  * to do this for open modes now; return and save for later  * notification in visual.  */
end_comment

begin_macro
name|noteit
argument_list|(
argument|must
argument_list|)
end_macro

begin_decl_stmt
name|bool
name|must
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|sdl
init|=
name|destline
decl_stmt|,
name|sdc
init|=
name|destcol
decl_stmt|;
if|if
condition|(
name|notecnt
operator|<
literal|2
operator|||
operator|!
name|must
operator|&&
name|state
operator|==
name|VISUAL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|splitw
operator|++
expr_stmt|;
if|if
condition|(
name|WBOT
operator|==
name|WECHO
condition|)
name|vmoveitup
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|vigoto
argument_list|(
name|WECHO
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%d %sline"
argument_list|,
name|notecnt
argument_list|,
name|notesgn
argument_list|)
expr_stmt|;
if|if
condition|(
name|notecnt
operator|>
literal|1
condition|)
name|putchar
argument_list|(
literal|'s'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|notenam
condition|)
block|{
name|printf
argument_list|(
literal|" %s"
argument_list|,
name|notenam
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|strend
argument_list|(
name|notenam
argument_list|)
operator|-
literal|1
operator|)
operator|!=
literal|'e'
condition|)
name|putchar
argument_list|(
literal|'e'
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'d'
argument_list|)
expr_stmt|;
block|}
name|vclreol
argument_list|()
expr_stmt|;
name|notecnt
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|state
operator|!=
name|VISUAL
condition|)
name|vcnt
operator|=
name|vcline
operator|=
literal|0
expr_stmt|;
name|splitw
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|state
operator|==
name|ONEOPEN
operator|||
name|state
operator|==
name|CRTOPEN
condition|)
name|vup1
argument_list|()
expr_stmt|;
name|destline
operator|=
name|sdl
expr_stmt|;
name|destcol
operator|=
name|sdc
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Rrrrringgggggg.  * If possible, use flash (VB).  */
end_comment

begin_macro
name|beep
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|VB
condition|)
name|vputp
argument_list|(
name|VB
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|vputc
argument_list|(
name|CTRL
argument_list|(
name|g
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Map the command input character c,  * for keypads and labelled keys which do cursor  * motions.  I.e. on an adm3a we might map ^K to ^P.  * DM1520 for example has a lot of mappable characters.  */
end_comment

begin_expr_stmt
name|map
argument_list|(
name|c
argument_list|)
specifier|register
name|int
name|c
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|d
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
init|=
name|MA
decl_stmt|;
if|if
condition|(
name|cp
operator|==
literal|0
condition|)
return|return
operator|(
name|c
operator|)
return|;
while|while
condition|(
name|d
operator|=
operator|*
name|cp
operator|++
condition|)
block|{
if|if
condition|(
name|c
operator|==
name|d
condition|)
return|return
operator|(
operator|*
name|cp
operator|)
return|;
if|if
condition|(
operator|*
name|cp
operator|++
operator|==
literal|0
condition|)
return|return
operator|(
name|c
operator|)
return|;
block|}
return|return
operator|(
name|c
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Get a count from the keyed input stream.  * A zero count is indistinguishable from no count.  */
end_comment

begin_macro
name|vgetcnt
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|c
decl_stmt|,
name|cnt
decl_stmt|;
name|cnt
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|c
operator|=
name|getkey
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|isdigit
argument_list|(
name|c
argument_list|)
condition|)
break|break;
name|cnt
operator|*=
literal|10
operator|,
name|cnt
operator|+=
name|c
operator|-
literal|'0'
expr_stmt|;
block|}
name|ungetkey
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|Xhadcnt
operator|=
literal|1
expr_stmt|;
name|Xcnt
operator|=
name|cnt
expr_stmt|;
return|return
operator|(
name|cnt
operator|)
return|;
block|}
end_block

end_unit

