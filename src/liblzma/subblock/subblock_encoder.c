begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|///////////////////////////////////////////////////////////////////////////////
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|/// \file       subblock_encoder.c
end_comment

begin_comment
comment|/// \brief      Encoder of the Subblock filter
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//  Author:     Lasse Collin
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//  This file has been put into the public domain.
end_comment

begin_comment
comment|//  You can do whatever you want with this file.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|///////////////////////////////////////////////////////////////////////////////
end_comment

begin_include
include|#
directive|include
file|"subblock_encoder.h"
end_include

begin_include
include|#
directive|include
file|"filter_encoder.h"
end_include

begin_comment
comment|/// Maximum number of repeats that a single Repeating Data can indicate.
end_comment

begin_comment
comment|/// This is directly from the file format specification.
end_comment

begin_define
define|#
directive|define
name|REPEAT_COUNT_MAX
value|(1U<< 28)
end_define

begin_comment
comment|/// Number of bytes the data chunk (not including the header part) must be
end_comment

begin_comment
comment|/// before we care about alignment. This is somewhat arbitrary. It just
end_comment

begin_comment
comment|/// doesn't make sense to waste bytes for alignment when the data chunk
end_comment

begin_comment
comment|/// is very small.
end_comment

begin_define
define|#
directive|define
name|MIN_CHUNK_SIZE_FOR_ALIGN
value|4
end_define

begin_comment
comment|/// Number of bytes of the header part of Subblock Type `Data'. This is
end_comment

begin_comment
comment|/// used as the `skew' argument for subblock_align().
end_comment

begin_define
define|#
directive|define
name|ALIGN_SKEW_DATA
value|4
end_define

begin_comment
comment|/// Like above but for Repeating Data.
end_comment

begin_define
define|#
directive|define
name|ALIGN_SKEW_REPEATING_DATA
value|5
end_define

begin_comment
comment|/// Writes one byte to output buffer and updates the alignment counter.
end_comment

begin_define
define|#
directive|define
name|write_byte
parameter_list|(
name|b
parameter_list|)
define|\
value|do { \ 	assert(*out_pos< out_size); \ 	out[*out_pos] = b; \ 	++*out_pos; \ 	++coder->alignment.out_pos; \ } while (0)
end_define

begin_struct
struct|struct
name|lzma_coder_s
block|{
name|lzma_next_coder
name|next
decl_stmt|;
name|bool
name|next_finished
decl_stmt|;
enum|enum
block|{
name|SEQ_FILL
block|,
name|SEQ_FLUSH
block|,
name|SEQ_RLE_COUNT_0
block|,
name|SEQ_RLE_COUNT_1
block|,
name|SEQ_RLE_COUNT_2
block|,
name|SEQ_RLE_COUNT_3
block|,
name|SEQ_RLE_SIZE
block|,
name|SEQ_RLE_DATA
block|,
name|SEQ_DATA_SIZE_0
block|,
name|SEQ_DATA_SIZE_1
block|,
name|SEQ_DATA_SIZE_2
block|,
name|SEQ_DATA_SIZE_3
block|,
name|SEQ_DATA
block|,
name|SEQ_SUBFILTER_INIT
block|,
name|SEQ_SUBFILTER_FLAGS
block|, 	}
name|sequence
enum|;
comment|/// Pointer to the options given by the application. This is used
comment|/// for two-way communication with the application.
name|lzma_options_subblock
modifier|*
name|options
decl_stmt|;
comment|/// Position in various arrays.
name|size_t
name|pos
decl_stmt|;
comment|/// Holds subblock.size - 1 or rle.size - 1 when encoding size
comment|/// of Data or Repeat Count.
name|uint32_t
name|tmp
decl_stmt|;
struct|struct
block|{
comment|/// This is a copy of options->alignment, or
comment|/// LZMA_SUBBLOCK_ALIGNMENT_DEFAULT if options is NULL.
name|uint32_t
name|multiple
decl_stmt|;
comment|/// Number of input bytes which we have processed and started
comment|/// writing out. 32-bit integer is enough since we care only
comment|/// about the lowest bits when fixing alignment.
name|uint32_t
name|in_pos
decl_stmt|;
comment|/// Number of bytes written out.
name|uint32_t
name|out_pos
decl_stmt|;
block|}
name|alignment
struct|;
struct|struct
block|{
comment|/// Pointer to allocated buffer holding the Data field
comment|/// of Subblock Type "Data".
name|uint8_t
modifier|*
name|data
decl_stmt|;
comment|/// Number of bytes in the buffer.
name|size_t
name|size
decl_stmt|;
comment|/// Allocated size of the buffer.
name|size_t
name|limit
decl_stmt|;
comment|/// Number of input bytes that we have already read but
comment|/// not yet started writing out. This can be different
comment|/// to `size' when using Subfilter. That's why we track
comment|/// in_pending separately for RLE (see below).
name|uint32_t
name|in_pending
decl_stmt|;
block|}
name|subblock
struct|;
struct|struct
block|{
comment|/// Buffer to hold the data that may be coded with
comment|/// Subblock Type `Repeating Data'.
name|uint8_t
name|buffer
index|[
name|LZMA_SUBBLOCK_RLE_MAX
index|]
decl_stmt|;
comment|/// Number of bytes in buffer[].
name|size_t
name|size
decl_stmt|;
comment|/// Number of times the first `size' bytes of buffer[]
comment|/// will be repeated.
name|uint64_t
name|count
decl_stmt|;
comment|/// Like subblock.in_pending above, but for RLE.
name|uint32_t
name|in_pending
decl_stmt|;
block|}
name|rle
struct|;
struct|struct
block|{
enum|enum
block|{
name|SUB_NONE
block|,
name|SUB_SET
block|,
name|SUB_RUN
block|,
name|SUB_FLUSH
block|,
name|SUB_FINISH
block|,
name|SUB_END_MARKER
block|, 		}
name|mode
enum|;
comment|/// This is a copy of options->allow_subfilters. We use
comment|/// this to verify that the application doesn't change
comment|/// the value of allow_subfilters.
name|bool
name|allow
decl_stmt|;
comment|/// When this is true, application is not allowed to modify
comment|/// options->subblock_mode. We may still modify it here.
name|bool
name|mode_locked
decl_stmt|;
comment|/// True if we have encoded at least one byte of data with
comment|/// the Subfilter.
name|bool
name|got_input
decl_stmt|;
comment|/// Track the amount of input available once
comment|/// LZMA_SUBFILTER_FINISH has been enabled.
comment|/// This is needed for sanity checking (kind
comment|/// of duplicating what common/code.c does).
name|size_t
name|in_avail
decl_stmt|;
comment|/// Buffer for the Filter Flags field written after
comment|/// the `Set Subfilter' indicator.
name|uint8_t
modifier|*
name|flags
decl_stmt|;
comment|/// Size of Filter Flags field.
name|uint32_t
name|flags_size
decl_stmt|;
comment|/// Pointers to Subfilter.
name|lzma_next_coder
name|subcoder
decl_stmt|;
block|}
name|subfilter
struct|;
comment|/// Temporary buffer used when we are not the last filter in the chain.
struct|struct
block|{
name|size_t
name|pos
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|uint8_t
name|buffer
index|[
name|LZMA_BUFFER_SIZE
index|]
decl_stmt|;
block|}
name|temp
struct|;
block|}
struct|;
end_struct

begin_comment
comment|/// \brief      Aligns the output buffer
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// Aligns the output buffer so that after skew bytes the output position is
end_comment

begin_comment
comment|/// a multiple of coder->alignment.multiple.
end_comment

begin_function
specifier|static
name|bool
name|subblock_align
parameter_list|(
name|lzma_coder
modifier|*
name|coder
parameter_list|,
name|uint8_t
modifier|*
specifier|restrict
name|out
parameter_list|,
name|size_t
modifier|*
specifier|restrict
name|out_pos
parameter_list|,
name|size_t
name|out_size
parameter_list|,
name|size_t
name|chunk_size
parameter_list|,
name|uint32_t
name|skew
parameter_list|)
block|{
name|assert
argument_list|(
operator|*
name|out_pos
operator|<
name|out_size
argument_list|)
expr_stmt|;
comment|// Fix the alignment only if it makes sense at least a little.
if|if
condition|(
name|chunk_size
operator|>=
name|MIN_CHUNK_SIZE_FOR_ALIGN
condition|)
block|{
specifier|const
name|uint32_t
name|target
init|=
name|coder
operator|->
name|alignment
operator|.
name|in_pos
operator|%
name|coder
operator|->
name|alignment
operator|.
name|multiple
decl_stmt|;
while|while
condition|(
operator|(
name|coder
operator|->
name|alignment
operator|.
name|out_pos
operator|+
name|skew
operator|)
operator|%
name|coder
operator|->
name|alignment
operator|.
name|multiple
operator|!=
name|target
condition|)
block|{
comment|// Zero indicates padding.
name|write_byte
argument_list|(
literal|0x00
argument_list|)
expr_stmt|;
comment|// Check if output buffer got full and indicate it to
comment|// the caller.
if|if
condition|(
operator|*
name|out_pos
operator|==
name|out_size
condition|)
return|return
name|true
return|;
block|}
block|}
comment|// Output buffer is not full.
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/// \brief      Checks if buffer contains repeated data
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// \param      needle      Buffer containing a single repeat chunk
end_comment

begin_comment
comment|/// \param      needle_size Size of needle in bytes
end_comment

begin_comment
comment|/// \param      buf         Buffer to search for repeated needles
end_comment

begin_comment
comment|/// \param      buf_chunks  Buffer size is buf_chunks * needle_size.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// \return     True if the whole buf is filled with repeated needles.
end_comment

begin_comment
comment|///
end_comment

begin_function
specifier|static
name|bool
name|is_repeating
parameter_list|(
specifier|const
name|uint8_t
modifier|*
specifier|restrict
name|needle
parameter_list|,
name|size_t
name|needle_size
parameter_list|,
specifier|const
name|uint8_t
modifier|*
specifier|restrict
name|buf
parameter_list|,
name|size_t
name|buf_chunks
parameter_list|)
block|{
while|while
condition|(
name|buf_chunks
operator|--
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|memcmp
argument_list|(
name|buf
argument_list|,
name|needle
argument_list|,
name|needle_size
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|false
return|;
name|buf
operator|+=
name|needle_size
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/// \brief      Optimizes the repeating style and updates coder->sequence
end_comment

begin_function
specifier|static
name|void
name|subblock_rle_flush
parameter_list|(
name|lzma_coder
modifier|*
name|coder
parameter_list|)
block|{
comment|// The Subblock decoder can use memset() when the size of the data
comment|// being repeated is one byte, so we check if the RLE buffer is
comment|// filled with a single repeating byte.
if|if
condition|(
name|coder
operator|->
name|rle
operator|.
name|size
operator|>
literal|1
condition|)
block|{
specifier|const
name|uint8_t
name|b
init|=
name|coder
operator|->
name|rle
operator|.
name|buffer
index|[
literal|0
index|]
decl_stmt|;
name|size_t
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|true
condition|)
block|{
if|if
condition|(
name|coder
operator|->
name|rle
operator|.
name|buffer
index|[
name|i
index|]
operator|!=
name|b
condition|)
break|break;
if|if
condition|(
operator|++
name|i
operator|==
name|coder
operator|->
name|rle
operator|.
name|size
condition|)
block|{
comment|// TODO Integer overflow check maybe,
comment|// although this needs at least 2**63 bytes
comment|// of input until it gets triggered...
name|coder
operator|->
name|rle
operator|.
name|count
operator|*=
name|coder
operator|->
name|rle
operator|.
name|size
expr_stmt|;
name|coder
operator|->
name|rle
operator|.
name|size
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|coder
operator|->
name|rle
operator|.
name|count
operator|==
literal|1
condition|)
block|{
comment|// The buffer should be repeated only once. It is
comment|// waste of space to use Repeating Data. Instead,
comment|// write a regular Data Subblock. See SEQ_RLE_COUNT_0
comment|// in subblock_buffer() for more info.
name|coder
operator|->
name|tmp
operator|=
name|coder
operator|->
name|rle
operator|.
name|size
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|coder
operator|->
name|rle
operator|.
name|count
operator|>
name|REPEAT_COUNT_MAX
condition|)
block|{
comment|// There's so much to repeat that it doesn't fit into
comment|// 28-bit integer. We will write two or more Subblocks
comment|// of type Repeating Data.
name|coder
operator|->
name|tmp
operator|=
name|REPEAT_COUNT_MAX
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|coder
operator|->
name|tmp
operator|=
name|coder
operator|->
name|rle
operator|.
name|count
operator|-
literal|1
expr_stmt|;
block|}
name|coder
operator|->
name|sequence
operator|=
name|SEQ_RLE_COUNT_0
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/// \brief      Resizes coder->subblock.data for a new size limit
end_comment

begin_function
specifier|static
name|lzma_ret
name|subblock_data_size
parameter_list|(
name|lzma_coder
modifier|*
name|coder
parameter_list|,
name|lzma_allocator
modifier|*
name|allocator
parameter_list|,
name|size_t
name|new_limit
parameter_list|)
block|{
comment|// Verify that the new limit is valid.
if|if
condition|(
name|new_limit
operator|<
name|LZMA_SUBBLOCK_DATA_SIZE_MIN
operator|||
name|new_limit
operator|>
name|LZMA_SUBBLOCK_DATA_SIZE_MAX
condition|)
return|return
name|LZMA_OPTIONS_ERROR
return|;
comment|// Ff the new limit is different than the previous one, we need
comment|// to reallocate the data buffer.
if|if
condition|(
name|new_limit
operator|!=
name|coder
operator|->
name|subblock
operator|.
name|limit
condition|)
block|{
name|lzma_free
argument_list|(
name|coder
operator|->
name|subblock
operator|.
name|data
argument_list|,
name|allocator
argument_list|)
expr_stmt|;
name|coder
operator|->
name|subblock
operator|.
name|data
operator|=
name|lzma_alloc
argument_list|(
name|new_limit
argument_list|,
name|allocator
argument_list|)
expr_stmt|;
if|if
condition|(
name|coder
operator|->
name|subblock
operator|.
name|data
operator|==
name|NULL
condition|)
return|return
name|LZMA_MEM_ERROR
return|;
block|}
name|coder
operator|->
name|subblock
operator|.
name|limit
operator|=
name|new_limit
expr_stmt|;
return|return
name|LZMA_OK
return|;
block|}
end_function

begin_function
specifier|static
name|lzma_ret
name|subblock_buffer
parameter_list|(
name|lzma_coder
modifier|*
name|coder
parameter_list|,
name|lzma_allocator
modifier|*
name|allocator
parameter_list|,
specifier|const
name|uint8_t
modifier|*
specifier|restrict
name|in
parameter_list|,
name|size_t
modifier|*
specifier|restrict
name|in_pos
parameter_list|,
name|size_t
name|in_size
parameter_list|,
name|uint8_t
modifier|*
specifier|restrict
name|out
parameter_list|,
name|size_t
modifier|*
specifier|restrict
name|out_pos
parameter_list|,
name|size_t
name|out_size
parameter_list|,
name|lzma_action
name|action
parameter_list|)
block|{
comment|// Changing allow_subfilter is not allowed.
if|if
condition|(
name|coder
operator|->
name|options
operator|!=
name|NULL
operator|&&
name|coder
operator|->
name|subfilter
operator|.
name|allow
operator|!=
name|coder
operator|->
name|options
operator|->
name|allow_subfilters
condition|)
return|return
name|LZMA_PROG_ERROR
return|;
comment|// Check if we need to do something special with the Subfilter.
if|if
condition|(
name|coder
operator|->
name|subfilter
operator|.
name|allow
condition|)
block|{
name|assert
argument_list|(
name|coder
operator|->
name|options
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|// See if subfilter_mode has been changed.
switch|switch
condition|(
name|coder
operator|->
name|options
operator|->
name|subfilter_mode
condition|)
block|{
case|case
name|LZMA_SUBFILTER_NONE
case|:
if|if
condition|(
name|coder
operator|->
name|subfilter
operator|.
name|mode
operator|!=
name|SUB_NONE
condition|)
return|return
name|LZMA_PROG_ERROR
return|;
break|break;
case|case
name|LZMA_SUBFILTER_SET
case|:
if|if
condition|(
name|coder
operator|->
name|subfilter
operator|.
name|mode_locked
operator|||
name|coder
operator|->
name|subfilter
operator|.
name|mode
operator|!=
name|SUB_NONE
condition|)
return|return
name|LZMA_PROG_ERROR
return|;
name|coder
operator|->
name|subfilter
operator|.
name|mode
operator|=
name|SUB_SET
expr_stmt|;
name|coder
operator|->
name|subfilter
operator|.
name|got_input
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|coder
operator|->
name|sequence
operator|==
name|SEQ_FILL
condition|)
name|coder
operator|->
name|sequence
operator|=
name|SEQ_FLUSH
expr_stmt|;
break|break;
case|case
name|LZMA_SUBFILTER_RUN
case|:
if|if
condition|(
name|coder
operator|->
name|subfilter
operator|.
name|mode
operator|!=
name|SUB_RUN
condition|)
return|return
name|LZMA_PROG_ERROR
return|;
break|break;
case|case
name|LZMA_SUBFILTER_FINISH
case|:
block|{
specifier|const
name|size_t
name|in_avail
init|=
name|in_size
operator|-
operator|*
name|in_pos
decl_stmt|;
if|if
condition|(
name|coder
operator|->
name|subfilter
operator|.
name|mode
operator|==
name|SUB_RUN
condition|)
block|{
if|if
condition|(
name|coder
operator|->
name|subfilter
operator|.
name|mode_locked
condition|)
return|return
name|LZMA_PROG_ERROR
return|;
name|coder
operator|->
name|subfilter
operator|.
name|mode
operator|=
name|SUB_FINISH
expr_stmt|;
name|coder
operator|->
name|subfilter
operator|.
name|in_avail
operator|=
name|in_avail
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|coder
operator|->
name|subfilter
operator|.
name|mode
operator|!=
name|SUB_FINISH
operator|||
name|coder
operator|->
name|subfilter
operator|.
name|in_avail
operator|!=
name|in_avail
condition|)
block|{
return|return
name|LZMA_PROG_ERROR
return|;
block|}
break|break;
block|}
default|default:
return|return
name|LZMA_OPTIONS_ERROR
return|;
block|}
comment|// If we are sync-flushing or finishing, the application may
comment|// no longer change subfilter_mode. Note that this check is
comment|// done after checking the new subfilter_mode above; this
comment|// way the application may e.g. set LZMA_SUBFILTER_SET and
comment|// LZMA_SYNC_FLUSH at the same time, but it cannot modify
comment|// subfilter_mode on the later lzma_code() calls before
comment|// we have returned LZMA_STREAM_END.
if|if
condition|(
name|action
operator|!=
name|LZMA_RUN
condition|)
name|coder
operator|->
name|subfilter
operator|.
name|mode_locked
operator|=
name|true
expr_stmt|;
block|}
comment|// Main loop
while|while
condition|(
operator|*
name|out_pos
operator|<
name|out_size
condition|)
switch|switch
condition|(
name|coder
operator|->
name|sequence
condition|)
block|{
case|case
name|SEQ_FILL
case|:
comment|// Grab the new Subblock Data Size and reallocate the buffer.
if|if
condition|(
name|coder
operator|->
name|subblock
operator|.
name|size
operator|==
literal|0
operator|&&
name|coder
operator|->
name|options
operator|!=
name|NULL
operator|&&
name|coder
operator|->
name|options
operator|->
name|subblock_data_size
operator|!=
name|coder
operator|->
name|subblock
operator|.
name|limit
condition|)
name|return_if_error
argument_list|(
name|subblock_data_size
argument_list|(
name|coder
argument_list|,
name|allocator
argument_list|,
name|coder
operator|->
name|options
operator|->
name|subblock_data_size
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|coder
operator|->
name|subfilter
operator|.
name|mode
operator|==
name|SUB_NONE
condition|)
block|{
name|assert
argument_list|(
name|coder
operator|->
name|subfilter
operator|.
name|subcoder
operator|.
name|code
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|// No Subfilter is enabled, just copy the data as is.
name|coder
operator|->
name|subblock
operator|.
name|in_pending
operator|+=
name|lzma_bufcpy
argument_list|(
name|in
argument_list|,
name|in_pos
argument_list|,
name|in_size
argument_list|,
name|coder
operator|->
name|subblock
operator|.
name|data
argument_list|,
operator|&
name|coder
operator|->
name|subblock
operator|.
name|size
argument_list|,
name|coder
operator|->
name|subblock
operator|.
name|limit
argument_list|)
expr_stmt|;
comment|// If we ran out of input before the whole buffer
comment|// was filled, return to application.
if|if
condition|(
name|coder
operator|->
name|subblock
operator|.
name|size
operator|<
name|coder
operator|->
name|subblock
operator|.
name|limit
operator|&&
name|action
operator|==
name|LZMA_RUN
condition|)
return|return
name|LZMA_OK
return|;
block|}
else|else
block|{
name|assert
argument_list|(
name|coder
operator|->
name|options
operator|->
name|subfilter_mode
operator|!=
name|LZMA_SUBFILTER_SET
argument_list|)
expr_stmt|;
comment|// Using LZMA_FINISH automatically toggles
comment|// LZMA_SUBFILTER_FINISH.
comment|//
comment|// NOTE: It is possible that application had set
comment|// LZMA_SUBFILTER_SET and LZMA_FINISH at the same
comment|// time. In that case it is possible that we will
comment|// cycle to LZMA_SUBFILTER_RUN, LZMA_SUBFILTER_FINISH,
comment|// and back to LZMA_SUBFILTER_NONE in a single
comment|// Subblock encoder function call.
if|if
condition|(
name|action
operator|==
name|LZMA_FINISH
condition|)
block|{
name|coder
operator|->
name|options
operator|->
name|subfilter_mode
operator|=
name|LZMA_SUBFILTER_FINISH
expr_stmt|;
name|coder
operator|->
name|subfilter
operator|.
name|mode
operator|=
name|SUB_FINISH
expr_stmt|;
block|}
specifier|const
name|size_t
name|in_start
init|=
operator|*
name|in_pos
decl_stmt|;
specifier|const
name|lzma_ret
name|ret
init|=
name|coder
operator|->
name|subfilter
operator|.
name|subcoder
operator|.
name|code
argument_list|(
name|coder
operator|->
name|subfilter
operator|.
name|subcoder
operator|.
name|coder
argument_list|,
name|allocator
argument_list|,
name|in
argument_list|,
name|in_pos
argument_list|,
name|in_size
argument_list|,
name|coder
operator|->
name|subblock
operator|.
name|data
argument_list|,
operator|&
name|coder
operator|->
name|subblock
operator|.
name|size
argument_list|,
name|coder
operator|->
name|subblock
operator|.
name|limit
argument_list|,
name|coder
operator|->
name|subfilter
operator|.
name|mode
operator|==
name|SUB_FINISH
condition|?
name|LZMA_FINISH
else|:
name|action
argument_list|)
decl_stmt|;
specifier|const
name|size_t
name|in_used
init|=
operator|*
name|in_pos
operator|-
name|in_start
decl_stmt|;
name|coder
operator|->
name|subblock
operator|.
name|in_pending
operator|+=
name|in_used
expr_stmt|;
if|if
condition|(
name|in_used
operator|>
literal|0
condition|)
name|coder
operator|->
name|subfilter
operator|.
name|got_input
operator|=
name|true
expr_stmt|;
name|coder
operator|->
name|subfilter
operator|.
name|in_avail
operator|=
name|in_size
operator|-
operator|*
name|in_pos
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|LZMA_STREAM_END
condition|)
block|{
comment|// All currently available input must have
comment|// been processed.
name|assert
argument_list|(
operator|*
name|in_pos
operator|==
name|in_size
argument_list|)
expr_stmt|;
comment|// Flush now. Even if coder->subblock.size
comment|// happened to be zero, we still need to go
comment|// to SEQ_FLUSH to possibly finish RLE or
comment|// write the Subfilter Unset indicator.
name|coder
operator|->
name|sequence
operator|=
name|SEQ_FLUSH
expr_stmt|;
if|if
condition|(
name|coder
operator|->
name|subfilter
operator|.
name|mode
operator|==
name|SUB_RUN
condition|)
block|{
comment|// Flushing with Subfilter enabled.
name|assert
argument_list|(
name|action
operator|==
name|LZMA_SYNC_FLUSH
argument_list|)
expr_stmt|;
name|coder
operator|->
name|subfilter
operator|.
name|mode
operator|=
name|SUB_FLUSH
expr_stmt|;
break|break;
block|}
comment|// Subfilter finished its job.
name|assert
argument_list|(
name|coder
operator|->
name|subfilter
operator|.
name|mode
operator|==
name|SUB_FINISH
operator|||
name|action
operator|==
name|LZMA_FINISH
argument_list|)
expr_stmt|;
comment|// At least one byte of input must have been
comment|// encoded with the Subfilter. This is
comment|// required by the file format specification.
if|if
condition|(
operator|!
name|coder
operator|->
name|subfilter
operator|.
name|got_input
condition|)
return|return
name|LZMA_PROG_ERROR
return|;
comment|// We don't strictly need to do this, but
comment|// doing it sounds like a good idea, because
comment|// otherwise the Subfilter's memory could be
comment|// left allocated for long time, and would
comment|// just waste memory.
name|lzma_next_end
argument_list|(
operator|&
name|coder
operator|->
name|subfilter
operator|.
name|subcoder
argument_list|,
name|allocator
argument_list|)
expr_stmt|;
comment|// We need to flush the currently buffered
comment|// data and write Unset Subfilter marker.
comment|// Note that we cannot set
comment|// coder->options->subfilter_mode to
comment|// LZMA_SUBFILTER_NONE yet, because we
comment|// haven't written the Unset Subfilter
comment|// marker yet.
name|coder
operator|->
name|subfilter
operator|.
name|mode
operator|=
name|SUB_END_MARKER
expr_stmt|;
name|coder
operator|->
name|sequence
operator|=
name|SEQ_FLUSH
expr_stmt|;
break|break;
block|}
comment|// Return if we couldn't fill the buffer or
comment|// if an error occurred.
if|if
condition|(
name|coder
operator|->
name|subblock
operator|.
name|size
operator|<
name|coder
operator|->
name|subblock
operator|.
name|limit
operator|||
name|ret
operator|!=
name|LZMA_OK
condition|)
return|return
name|ret
return|;
block|}
name|coder
operator|->
name|sequence
operator|=
name|SEQ_FLUSH
expr_stmt|;
comment|// SEQ_FILL doesn't produce any output so falling through
comment|// to SEQ_FLUSH is safe.
name|assert
argument_list|(
operator|*
name|out_pos
operator|<
name|out_size
argument_list|)
expr_stmt|;
comment|// Fall through
case|case
name|SEQ_FLUSH
case|:
if|if
condition|(
name|coder
operator|->
name|options
operator|!=
name|NULL
condition|)
block|{
comment|// Update the alignment variable.
name|coder
operator|->
name|alignment
operator|.
name|multiple
operator|=
name|coder
operator|->
name|options
operator|->
name|alignment
expr_stmt|;
if|if
condition|(
name|coder
operator|->
name|alignment
operator|.
name|multiple
operator|<
name|LZMA_SUBBLOCK_ALIGNMENT_MIN
operator|||
name|coder
operator|->
name|alignment
operator|.
name|multiple
operator|>
name|LZMA_SUBBLOCK_ALIGNMENT_MAX
condition|)
return|return
name|LZMA_OPTIONS_ERROR
return|;
comment|// Run-length encoder
comment|//
comment|// First check if there is some data pending and we
comment|// have an obvious need to flush it immediately.
if|if
condition|(
name|coder
operator|->
name|rle
operator|.
name|count
operator|>
literal|0
operator|&&
operator|(
name|coder
operator|->
name|rle
operator|.
name|size
operator|!=
name|coder
operator|->
name|options
operator|->
name|rle
operator|||
name|coder
operator|->
name|subblock
operator|.
name|size
operator|%
name|coder
operator|->
name|rle
operator|.
name|size
operator|)
condition|)
block|{
name|subblock_rle_flush
argument_list|(
name|coder
argument_list|)
expr_stmt|;
break|break;
block|}
comment|// Grab the (possibly new) RLE chunk size and
comment|// validate it.
name|coder
operator|->
name|rle
operator|.
name|size
operator|=
name|coder
operator|->
name|options
operator|->
name|rle
expr_stmt|;
if|if
condition|(
name|coder
operator|->
name|rle
operator|.
name|size
operator|>
name|LZMA_SUBBLOCK_RLE_MAX
condition|)
return|return
name|LZMA_OPTIONS_ERROR
return|;
if|if
condition|(
name|coder
operator|->
name|subblock
operator|.
name|size
operator|!=
literal|0
operator|&&
name|coder
operator|->
name|rle
operator|.
name|size
operator|!=
name|LZMA_SUBBLOCK_RLE_OFF
operator|&&
name|coder
operator|->
name|subblock
operator|.
name|size
operator|%
name|coder
operator|->
name|rle
operator|.
name|size
operator|==
literal|0
condition|)
block|{
comment|// Initialize coder->rle.buffer if we don't
comment|// have RLE already running.
if|if
condition|(
name|coder
operator|->
name|rle
operator|.
name|count
operator|==
literal|0
condition|)
name|memcpy
argument_list|(
name|coder
operator|->
name|rle
operator|.
name|buffer
argument_list|,
name|coder
operator|->
name|subblock
operator|.
name|data
argument_list|,
name|coder
operator|->
name|rle
operator|.
name|size
argument_list|)
expr_stmt|;
comment|// Test if coder->subblock.data is repeating.
comment|// If coder->rle.count would overflow, we
comment|// force flushing. Forced flushing shouldn't
comment|// really happen in real-world situations.
specifier|const
name|size_t
name|count
init|=
name|coder
operator|->
name|subblock
operator|.
name|size
operator|/
name|coder
operator|->
name|rle
operator|.
name|size
decl_stmt|;
if|if
condition|(
name|UINT64_MAX
operator|-
name|count
operator|>
name|coder
operator|->
name|rle
operator|.
name|count
operator|&&
name|is_repeating
argument_list|(
name|coder
operator|->
name|rle
operator|.
name|buffer
argument_list|,
name|coder
operator|->
name|rle
operator|.
name|size
argument_list|,
name|coder
operator|->
name|subblock
operator|.
name|data
argument_list|,
name|count
argument_list|)
condition|)
block|{
name|coder
operator|->
name|rle
operator|.
name|count
operator|+=
name|count
expr_stmt|;
name|coder
operator|->
name|rle
operator|.
name|in_pending
operator|+=
name|coder
operator|->
name|subblock
operator|.
name|in_pending
expr_stmt|;
name|coder
operator|->
name|subblock
operator|.
name|in_pending
operator|=
literal|0
expr_stmt|;
name|coder
operator|->
name|subblock
operator|.
name|size
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|coder
operator|->
name|rle
operator|.
name|count
operator|>
literal|0
condition|)
block|{
comment|// It's not repeating or at least not
comment|// with the same byte sequence as the
comment|// earlier Subblock Data buffers. We
comment|// have some data pending in the RLE
comment|// buffer already, so do a flush.
comment|// Once flushed, we will check again
comment|// if the Subblock Data happens to
comment|// contain a different repeating
comment|// sequence.
name|subblock_rle_flush
argument_list|(
name|coder
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|// If we now have some data left in coder->subblock, the RLE
comment|// buffer is empty and we must write a regular Subblock Data.
if|if
condition|(
name|coder
operator|->
name|subblock
operator|.
name|size
operator|>
literal|0
condition|)
block|{
name|assert
argument_list|(
name|coder
operator|->
name|rle
operator|.
name|count
operator|==
literal|0
argument_list|)
expr_stmt|;
name|coder
operator|->
name|tmp
operator|=
name|coder
operator|->
name|subblock
operator|.
name|size
operator|-
literal|1
expr_stmt|;
name|coder
operator|->
name|sequence
operator|=
name|SEQ_DATA_SIZE_0
expr_stmt|;
break|break;
block|}
comment|// Check if we should enable Subfilter.
if|if
condition|(
name|coder
operator|->
name|subfilter
operator|.
name|mode
operator|==
name|SUB_SET
condition|)
block|{
if|if
condition|(
name|coder
operator|->
name|rle
operator|.
name|count
operator|>
literal|0
condition|)
name|subblock_rle_flush
argument_list|(
name|coder
argument_list|)
expr_stmt|;
else|else
name|coder
operator|->
name|sequence
operator|=
name|SEQ_SUBFILTER_INIT
expr_stmt|;
break|break;
block|}
comment|// Check if we have just finished Subfiltering.
if|if
condition|(
name|coder
operator|->
name|subfilter
operator|.
name|mode
operator|==
name|SUB_END_MARKER
condition|)
block|{
if|if
condition|(
name|coder
operator|->
name|rle
operator|.
name|count
operator|>
literal|0
condition|)
block|{
name|subblock_rle_flush
argument_list|(
name|coder
argument_list|)
expr_stmt|;
break|break;
block|}
name|coder
operator|->
name|options
operator|->
name|subfilter_mode
operator|=
name|LZMA_SUBFILTER_NONE
expr_stmt|;
name|coder
operator|->
name|subfilter
operator|.
name|mode
operator|=
name|SUB_NONE
expr_stmt|;
name|write_byte
argument_list|(
literal|0x50
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|out_pos
operator|==
name|out_size
condition|)
return|return
name|LZMA_OK
return|;
block|}
comment|// Check if we have already written everything.
if|if
condition|(
name|action
operator|!=
name|LZMA_RUN
operator|&&
operator|*
name|in_pos
operator|==
name|in_size
operator|&&
operator|(
name|coder
operator|->
name|subfilter
operator|.
name|mode
operator|==
name|SUB_NONE
operator|||
name|coder
operator|->
name|subfilter
operator|.
name|mode
operator|==
name|SUB_FLUSH
operator|)
condition|)
block|{
if|if
condition|(
name|coder
operator|->
name|rle
operator|.
name|count
operator|>
literal|0
condition|)
block|{
name|subblock_rle_flush
argument_list|(
name|coder
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|action
operator|==
name|LZMA_SYNC_FLUSH
condition|)
block|{
if|if
condition|(
name|coder
operator|->
name|subfilter
operator|.
name|mode
operator|==
name|SUB_FLUSH
condition|)
name|coder
operator|->
name|subfilter
operator|.
name|mode
operator|=
name|SUB_RUN
expr_stmt|;
name|coder
operator|->
name|subfilter
operator|.
name|mode_locked
operator|=
name|false
expr_stmt|;
name|coder
operator|->
name|sequence
operator|=
name|SEQ_FILL
expr_stmt|;
block|}
else|else
block|{
name|assert
argument_list|(
name|action
operator|==
name|LZMA_FINISH
argument_list|)
expr_stmt|;
comment|// Write EOPM.
comment|// NOTE: No need to use write_byte() here
comment|// since we are finishing.
name|out
index|[
operator|*
name|out_pos
index|]
operator|=
literal|0x10
expr_stmt|;
operator|++
operator|*
name|out_pos
expr_stmt|;
block|}
return|return
name|LZMA_STREAM_END
return|;
block|}
comment|// Otherwise we have more work to do.
name|coder
operator|->
name|sequence
operator|=
name|SEQ_FILL
expr_stmt|;
break|break;
case|case
name|SEQ_RLE_COUNT_0
case|:
name|assert
argument_list|(
name|coder
operator|->
name|rle
operator|.
name|count
operator|>
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|coder
operator|->
name|rle
operator|.
name|count
operator|==
literal|1
condition|)
block|{
comment|// The buffer should be repeated only once. Fix
comment|// the alignment and write the first byte of
comment|// Subblock Type `Data'.
if|if
condition|(
name|subblock_align
argument_list|(
name|coder
argument_list|,
name|out
argument_list|,
name|out_pos
argument_list|,
name|out_size
argument_list|,
name|coder
operator|->
name|rle
operator|.
name|size
argument_list|,
name|ALIGN_SKEW_DATA
argument_list|)
condition|)
return|return
name|LZMA_OK
return|;
name|write_byte
argument_list|(
literal|0x20
operator||
operator|(
name|coder
operator|->
name|tmp
operator|&
literal|0x0F
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// We have something to actually repeat, which should
comment|// mean that it takes less space with run-length
comment|// encoding.
if|if
condition|(
name|subblock_align
argument_list|(
name|coder
argument_list|,
name|out
argument_list|,
name|out_pos
argument_list|,
name|out_size
argument_list|,
name|coder
operator|->
name|rle
operator|.
name|size
argument_list|,
name|ALIGN_SKEW_REPEATING_DATA
argument_list|)
condition|)
return|return
name|LZMA_OK
return|;
name|write_byte
argument_list|(
literal|0x30
operator||
operator|(
name|coder
operator|->
name|tmp
operator|&
literal|0x0F
operator|)
argument_list|)
expr_stmt|;
block|}
comment|// NOTE: If we have to write more than one Repeating Data
comment|// due to rle.count> REPEAT_COUNT_MAX, the subsequent
comment|// Repeating Data Subblocks may get wrong alignment, because
comment|// we add rle.in_pending to alignment.in_pos at once instead
comment|// of adding only as much as this particular Repeating Data
comment|// consumed input data. Correct alignment is always restored
comment|// after all the required Repeating Data Subblocks have been
comment|// written. This problem occurs in such a weird cases that
comment|// it's not worth fixing.
name|coder
operator|->
name|alignment
operator|.
name|out_pos
operator|+=
name|coder
operator|->
name|rle
operator|.
name|size
expr_stmt|;
name|coder
operator|->
name|alignment
operator|.
name|in_pos
operator|+=
name|coder
operator|->
name|rle
operator|.
name|in_pending
expr_stmt|;
name|coder
operator|->
name|rle
operator|.
name|in_pending
operator|=
literal|0
expr_stmt|;
name|coder
operator|->
name|sequence
operator|=
name|SEQ_RLE_COUNT_1
expr_stmt|;
break|break;
case|case
name|SEQ_RLE_COUNT_1
case|:
name|write_byte
argument_list|(
name|coder
operator|->
name|tmp
operator|>>
literal|4
argument_list|)
expr_stmt|;
name|coder
operator|->
name|sequence
operator|=
name|SEQ_RLE_COUNT_2
expr_stmt|;
break|break;
case|case
name|SEQ_RLE_COUNT_2
case|:
name|write_byte
argument_list|(
name|coder
operator|->
name|tmp
operator|>>
literal|12
argument_list|)
expr_stmt|;
name|coder
operator|->
name|sequence
operator|=
name|SEQ_RLE_COUNT_3
expr_stmt|;
break|break;
case|case
name|SEQ_RLE_COUNT_3
case|:
name|write_byte
argument_list|(
name|coder
operator|->
name|tmp
operator|>>
literal|20
argument_list|)
expr_stmt|;
comment|// Again, see if we are writing regular Data or Repeating Data.
comment|// In the former case, we skip SEQ_RLE_SIZE.
if|if
condition|(
name|coder
operator|->
name|rle
operator|.
name|count
operator|==
literal|1
condition|)
name|coder
operator|->
name|sequence
operator|=
name|SEQ_RLE_DATA
expr_stmt|;
else|else
name|coder
operator|->
name|sequence
operator|=
name|SEQ_RLE_SIZE
expr_stmt|;
if|if
condition|(
name|coder
operator|->
name|rle
operator|.
name|count
operator|>
name|REPEAT_COUNT_MAX
condition|)
name|coder
operator|->
name|rle
operator|.
name|count
operator|-=
name|REPEAT_COUNT_MAX
expr_stmt|;
else|else
name|coder
operator|->
name|rle
operator|.
name|count
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SEQ_RLE_SIZE
case|:
name|assert
argument_list|(
name|coder
operator|->
name|rle
operator|.
name|size
operator|>=
name|LZMA_SUBBLOCK_RLE_MIN
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|coder
operator|->
name|rle
operator|.
name|size
operator|<=
name|LZMA_SUBBLOCK_RLE_MAX
argument_list|)
expr_stmt|;
name|write_byte
argument_list|(
name|coder
operator|->
name|rle
operator|.
name|size
operator|-
literal|1
argument_list|)
expr_stmt|;
name|coder
operator|->
name|sequence
operator|=
name|SEQ_RLE_DATA
expr_stmt|;
break|break;
case|case
name|SEQ_RLE_DATA
case|:
name|lzma_bufcpy
argument_list|(
name|coder
operator|->
name|rle
operator|.
name|buffer
argument_list|,
operator|&
name|coder
operator|->
name|pos
argument_list|,
name|coder
operator|->
name|rle
operator|.
name|size
argument_list|,
name|out
argument_list|,
name|out_pos
argument_list|,
name|out_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|coder
operator|->
name|pos
operator|<
name|coder
operator|->
name|rle
operator|.
name|size
condition|)
return|return
name|LZMA_OK
return|;
name|coder
operator|->
name|pos
operator|=
literal|0
expr_stmt|;
name|coder
operator|->
name|sequence
operator|=
name|SEQ_FLUSH
expr_stmt|;
break|break;
case|case
name|SEQ_DATA_SIZE_0
case|:
comment|// We need four bytes for the Size field.
if|if
condition|(
name|subblock_align
argument_list|(
name|coder
argument_list|,
name|out
argument_list|,
name|out_pos
argument_list|,
name|out_size
argument_list|,
name|coder
operator|->
name|subblock
operator|.
name|size
argument_list|,
name|ALIGN_SKEW_DATA
argument_list|)
condition|)
return|return
name|LZMA_OK
return|;
name|coder
operator|->
name|alignment
operator|.
name|out_pos
operator|+=
name|coder
operator|->
name|subblock
operator|.
name|size
expr_stmt|;
name|coder
operator|->
name|alignment
operator|.
name|in_pos
operator|+=
name|coder
operator|->
name|subblock
operator|.
name|in_pending
expr_stmt|;
name|coder
operator|->
name|subblock
operator|.
name|in_pending
operator|=
literal|0
expr_stmt|;
name|write_byte
argument_list|(
literal|0x20
operator||
operator|(
name|coder
operator|->
name|tmp
operator|&
literal|0x0F
operator|)
argument_list|)
expr_stmt|;
name|coder
operator|->
name|sequence
operator|=
name|SEQ_DATA_SIZE_1
expr_stmt|;
break|break;
case|case
name|SEQ_DATA_SIZE_1
case|:
name|write_byte
argument_list|(
name|coder
operator|->
name|tmp
operator|>>
literal|4
argument_list|)
expr_stmt|;
name|coder
operator|->
name|sequence
operator|=
name|SEQ_DATA_SIZE_2
expr_stmt|;
break|break;
case|case
name|SEQ_DATA_SIZE_2
case|:
name|write_byte
argument_list|(
name|coder
operator|->
name|tmp
operator|>>
literal|12
argument_list|)
expr_stmt|;
name|coder
operator|->
name|sequence
operator|=
name|SEQ_DATA_SIZE_3
expr_stmt|;
break|break;
case|case
name|SEQ_DATA_SIZE_3
case|:
name|write_byte
argument_list|(
name|coder
operator|->
name|tmp
operator|>>
literal|20
argument_list|)
expr_stmt|;
name|coder
operator|->
name|sequence
operator|=
name|SEQ_DATA
expr_stmt|;
break|break;
case|case
name|SEQ_DATA
case|:
name|lzma_bufcpy
argument_list|(
name|coder
operator|->
name|subblock
operator|.
name|data
argument_list|,
operator|&
name|coder
operator|->
name|pos
argument_list|,
name|coder
operator|->
name|subblock
operator|.
name|size
argument_list|,
name|out
argument_list|,
name|out_pos
argument_list|,
name|out_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|coder
operator|->
name|pos
operator|<
name|coder
operator|->
name|subblock
operator|.
name|size
condition|)
return|return
name|LZMA_OK
return|;
name|coder
operator|->
name|subblock
operator|.
name|size
operator|=
literal|0
expr_stmt|;
name|coder
operator|->
name|pos
operator|=
literal|0
expr_stmt|;
name|coder
operator|->
name|sequence
operator|=
name|SEQ_FLUSH
expr_stmt|;
break|break;
case|case
name|SEQ_SUBFILTER_INIT
case|:
block|{
name|assert
argument_list|(
name|coder
operator|->
name|subblock
operator|.
name|size
operator|==
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|coder
operator|->
name|subblock
operator|.
name|in_pending
operator|==
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|coder
operator|->
name|rle
operator|.
name|count
operator|==
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|coder
operator|->
name|rle
operator|.
name|in_pending
operator|==
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|coder
operator|->
name|subfilter
operator|.
name|mode
operator|==
name|SUB_SET
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|coder
operator|->
name|options
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|// There must be a filter specified.
if|if
condition|(
name|coder
operator|->
name|options
operator|->
name|subfilter_options
operator|.
name|id
operator|==
name|LZMA_VLI_UNKNOWN
condition|)
return|return
name|LZMA_OPTIONS_ERROR
return|;
comment|// Initialize a raw encoder to work as a Subfilter.
name|lzma_filter
name|options
index|[
literal|2
index|]
decl_stmt|;
name|options
index|[
literal|0
index|]
operator|=
name|coder
operator|->
name|options
operator|->
name|subfilter_options
expr_stmt|;
name|options
index|[
literal|1
index|]
operator|.
name|id
operator|=
name|LZMA_VLI_UNKNOWN
expr_stmt|;
name|return_if_error
argument_list|(
name|lzma_raw_encoder_init
argument_list|(
operator|&
name|coder
operator|->
name|subfilter
operator|.
name|subcoder
argument_list|,
name|allocator
argument_list|,
name|options
argument_list|)
argument_list|)
expr_stmt|;
comment|// Encode the Filter Flags field into a buffer. This should
comment|// never fail since we have already successfully initialized
comment|// the Subfilter itself. Check it still, and return
comment|// LZMA_PROG_ERROR instead of whatever the ret would say.
name|lzma_ret
name|ret
init|=
name|lzma_filter_flags_size
argument_list|(
operator|&
name|coder
operator|->
name|subfilter
operator|.
name|flags_size
argument_list|,
name|options
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|ret
operator|==
name|LZMA_OK
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|LZMA_OK
condition|)
return|return
name|LZMA_PROG_ERROR
return|;
name|coder
operator|->
name|subfilter
operator|.
name|flags
operator|=
name|lzma_alloc
argument_list|(
name|coder
operator|->
name|subfilter
operator|.
name|flags_size
argument_list|,
name|allocator
argument_list|)
expr_stmt|;
if|if
condition|(
name|coder
operator|->
name|subfilter
operator|.
name|flags
operator|==
name|NULL
condition|)
return|return
name|LZMA_MEM_ERROR
return|;
comment|// Now we have a big-enough buffer. Encode the Filter Flags.
comment|// Like above, this should never fail.
name|size_t
name|dummy
init|=
literal|0
decl_stmt|;
name|ret
operator|=
name|lzma_filter_flags_encode
argument_list|(
name|options
argument_list|,
name|coder
operator|->
name|subfilter
operator|.
name|flags
argument_list|,
operator|&
name|dummy
argument_list|,
name|coder
operator|->
name|subfilter
operator|.
name|flags_size
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ret
operator|==
name|LZMA_OK
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|dummy
operator|==
name|coder
operator|->
name|subfilter
operator|.
name|flags_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|LZMA_OK
operator|||
name|dummy
operator|!=
name|coder
operator|->
name|subfilter
operator|.
name|flags_size
condition|)
return|return
name|LZMA_PROG_ERROR
return|;
comment|// Write a Subblock indicating a new Subfilter.
name|write_byte
argument_list|(
literal|0x40
argument_list|)
expr_stmt|;
name|coder
operator|->
name|options
operator|->
name|subfilter_mode
operator|=
name|LZMA_SUBFILTER_RUN
expr_stmt|;
name|coder
operator|->
name|subfilter
operator|.
name|mode
operator|=
name|SUB_RUN
expr_stmt|;
name|coder
operator|->
name|alignment
operator|.
name|out_pos
operator|+=
name|coder
operator|->
name|subfilter
operator|.
name|flags_size
expr_stmt|;
name|coder
operator|->
name|sequence
operator|=
name|SEQ_SUBFILTER_FLAGS
expr_stmt|;
comment|// It is safe to fall through because SEQ_SUBFILTER_FLAGS
comment|// uses lzma_bufcpy() which doesn't write unless there is
comment|// output space.
block|}
comment|// Fall through
case|case
name|SEQ_SUBFILTER_FLAGS
case|:
comment|// Copy the Filter Flags to the output stream.
name|lzma_bufcpy
argument_list|(
name|coder
operator|->
name|subfilter
operator|.
name|flags
argument_list|,
operator|&
name|coder
operator|->
name|pos
argument_list|,
name|coder
operator|->
name|subfilter
operator|.
name|flags_size
argument_list|,
name|out
argument_list|,
name|out_pos
argument_list|,
name|out_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|coder
operator|->
name|pos
operator|<
name|coder
operator|->
name|subfilter
operator|.
name|flags_size
condition|)
return|return
name|LZMA_OK
return|;
name|lzma_free
argument_list|(
name|coder
operator|->
name|subfilter
operator|.
name|flags
argument_list|,
name|allocator
argument_list|)
expr_stmt|;
name|coder
operator|->
name|subfilter
operator|.
name|flags
operator|=
name|NULL
expr_stmt|;
name|coder
operator|->
name|pos
operator|=
literal|0
expr_stmt|;
name|coder
operator|->
name|sequence
operator|=
name|SEQ_FILL
expr_stmt|;
break|break;
default|default:
return|return
name|LZMA_PROG_ERROR
return|;
block|}
return|return
name|LZMA_OK
return|;
block|}
end_function

begin_function
specifier|static
name|lzma_ret
name|subblock_encode
parameter_list|(
name|lzma_coder
modifier|*
name|coder
parameter_list|,
name|lzma_allocator
modifier|*
name|allocator
parameter_list|,
specifier|const
name|uint8_t
modifier|*
specifier|restrict
name|in
parameter_list|,
name|size_t
modifier|*
specifier|restrict
name|in_pos
parameter_list|,
name|size_t
name|in_size
parameter_list|,
name|uint8_t
modifier|*
specifier|restrict
name|out
parameter_list|,
name|size_t
modifier|*
specifier|restrict
name|out_pos
parameter_list|,
name|size_t
name|out_size
parameter_list|,
name|lzma_action
name|action
parameter_list|)
block|{
if|if
condition|(
name|coder
operator|->
name|next
operator|.
name|code
operator|==
name|NULL
condition|)
return|return
name|subblock_buffer
argument_list|(
name|coder
argument_list|,
name|allocator
argument_list|,
name|in
argument_list|,
name|in_pos
argument_list|,
name|in_size
argument_list|,
name|out
argument_list|,
name|out_pos
argument_list|,
name|out_size
argument_list|,
name|action
argument_list|)
return|;
while|while
condition|(
operator|*
name|out_pos
operator|<
name|out_size
operator|&&
operator|(
operator|*
name|in_pos
operator|<
name|in_size
operator|||
name|action
operator|!=
name|LZMA_RUN
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|coder
operator|->
name|next_finished
operator|&&
name|coder
operator|->
name|temp
operator|.
name|pos
operator|==
name|coder
operator|->
name|temp
operator|.
name|size
condition|)
block|{
name|coder
operator|->
name|temp
operator|.
name|pos
operator|=
literal|0
expr_stmt|;
name|coder
operator|->
name|temp
operator|.
name|size
operator|=
literal|0
expr_stmt|;
specifier|const
name|lzma_ret
name|ret
init|=
name|coder
operator|->
name|next
operator|.
name|code
argument_list|(
name|coder
operator|->
name|next
operator|.
name|coder
argument_list|,
name|allocator
argument_list|,
name|in
argument_list|,
name|in_pos
argument_list|,
name|in_size
argument_list|,
name|coder
operator|->
name|temp
operator|.
name|buffer
argument_list|,
operator|&
name|coder
operator|->
name|temp
operator|.
name|size
argument_list|,
name|LZMA_BUFFER_SIZE
argument_list|,
name|action
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
operator|==
name|LZMA_STREAM_END
condition|)
block|{
name|assert
argument_list|(
name|action
operator|!=
name|LZMA_RUN
argument_list|)
expr_stmt|;
name|coder
operator|->
name|next_finished
operator|=
name|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|coder
operator|->
name|temp
operator|.
name|size
operator|==
literal|0
operator|||
name|ret
operator|!=
name|LZMA_OK
condition|)
block|{
return|return
name|ret
return|;
block|}
block|}
specifier|const
name|lzma_ret
name|ret
init|=
name|subblock_buffer
argument_list|(
name|coder
argument_list|,
name|allocator
argument_list|,
name|coder
operator|->
name|temp
operator|.
name|buffer
argument_list|,
operator|&
name|coder
operator|->
name|temp
operator|.
name|pos
argument_list|,
name|coder
operator|->
name|temp
operator|.
name|size
argument_list|,
name|out
argument_list|,
name|out_pos
argument_list|,
name|out_size
argument_list|,
name|coder
operator|->
name|next_finished
condition|?
name|LZMA_FINISH
else|:
name|LZMA_RUN
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
operator|==
name|LZMA_STREAM_END
condition|)
block|{
name|assert
argument_list|(
name|action
operator|!=
name|LZMA_RUN
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|coder
operator|->
name|next_finished
argument_list|)
expr_stmt|;
return|return
name|LZMA_STREAM_END
return|;
block|}
if|if
condition|(
name|ret
operator|!=
name|LZMA_OK
condition|)
return|return
name|ret
return|;
block|}
return|return
name|LZMA_OK
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|subblock_encoder_end
parameter_list|(
name|lzma_coder
modifier|*
name|coder
parameter_list|,
name|lzma_allocator
modifier|*
name|allocator
parameter_list|)
block|{
name|lzma_next_end
argument_list|(
operator|&
name|coder
operator|->
name|next
argument_list|,
name|allocator
argument_list|)
expr_stmt|;
name|lzma_next_end
argument_list|(
operator|&
name|coder
operator|->
name|subfilter
operator|.
name|subcoder
argument_list|,
name|allocator
argument_list|)
expr_stmt|;
name|lzma_free
argument_list|(
name|coder
operator|->
name|subblock
operator|.
name|data
argument_list|,
name|allocator
argument_list|)
expr_stmt|;
name|lzma_free
argument_list|(
name|coder
operator|->
name|subfilter
operator|.
name|flags
argument_list|,
name|allocator
argument_list|)
expr_stmt|;
name|lzma_free
argument_list|(
name|coder
argument_list|,
name|allocator
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|extern
name|lzma_ret
name|lzma_subblock_encoder_init
parameter_list|(
name|lzma_next_coder
modifier|*
name|next
parameter_list|,
name|lzma_allocator
modifier|*
name|allocator
parameter_list|,
specifier|const
name|lzma_filter_info
modifier|*
name|filters
parameter_list|)
block|{
if|if
condition|(
name|next
operator|->
name|coder
operator|==
name|NULL
condition|)
block|{
name|next
operator|->
name|coder
operator|=
name|lzma_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|lzma_coder
argument_list|)
argument_list|,
name|allocator
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
operator|->
name|coder
operator|==
name|NULL
condition|)
return|return
name|LZMA_MEM_ERROR
return|;
name|next
operator|->
name|code
operator|=
operator|&
name|subblock_encode
expr_stmt|;
name|next
operator|->
name|end
operator|=
operator|&
name|subblock_encoder_end
expr_stmt|;
name|next
operator|->
name|coder
operator|->
name|next
operator|=
name|LZMA_NEXT_CODER_INIT
expr_stmt|;
name|next
operator|->
name|coder
operator|->
name|subblock
operator|.
name|data
operator|=
name|NULL
expr_stmt|;
name|next
operator|->
name|coder
operator|->
name|subblock
operator|.
name|limit
operator|=
literal|0
expr_stmt|;
name|next
operator|->
name|coder
operator|->
name|subfilter
operator|.
name|subcoder
operator|=
name|LZMA_NEXT_CODER_INIT
expr_stmt|;
block|}
else|else
block|{
name|lzma_next_end
argument_list|(
operator|&
name|next
operator|->
name|coder
operator|->
name|subfilter
operator|.
name|subcoder
argument_list|,
name|allocator
argument_list|)
expr_stmt|;
name|lzma_free
argument_list|(
name|next
operator|->
name|coder
operator|->
name|subfilter
operator|.
name|flags
argument_list|,
name|allocator
argument_list|)
expr_stmt|;
block|}
name|next
operator|->
name|coder
operator|->
name|subfilter
operator|.
name|flags
operator|=
name|NULL
expr_stmt|;
name|next
operator|->
name|coder
operator|->
name|next_finished
operator|=
name|false
expr_stmt|;
name|next
operator|->
name|coder
operator|->
name|sequence
operator|=
name|SEQ_FILL
expr_stmt|;
name|next
operator|->
name|coder
operator|->
name|options
operator|=
name|filters
index|[
literal|0
index|]
operator|.
name|options
expr_stmt|;
name|next
operator|->
name|coder
operator|->
name|pos
operator|=
literal|0
expr_stmt|;
name|next
operator|->
name|coder
operator|->
name|alignment
operator|.
name|in_pos
operator|=
literal|0
expr_stmt|;
name|next
operator|->
name|coder
operator|->
name|alignment
operator|.
name|out_pos
operator|=
literal|0
expr_stmt|;
name|next
operator|->
name|coder
operator|->
name|subblock
operator|.
name|size
operator|=
literal|0
expr_stmt|;
name|next
operator|->
name|coder
operator|->
name|subblock
operator|.
name|in_pending
operator|=
literal|0
expr_stmt|;
name|next
operator|->
name|coder
operator|->
name|rle
operator|.
name|count
operator|=
literal|0
expr_stmt|;
name|next
operator|->
name|coder
operator|->
name|rle
operator|.
name|in_pending
operator|=
literal|0
expr_stmt|;
name|next
operator|->
name|coder
operator|->
name|subfilter
operator|.
name|mode
operator|=
name|SUB_NONE
expr_stmt|;
name|next
operator|->
name|coder
operator|->
name|subfilter
operator|.
name|mode_locked
operator|=
name|false
expr_stmt|;
name|next
operator|->
name|coder
operator|->
name|temp
operator|.
name|pos
operator|=
literal|0
expr_stmt|;
name|next
operator|->
name|coder
operator|->
name|temp
operator|.
name|size
operator|=
literal|0
expr_stmt|;
comment|// Grab some values from the options structure if it is available.
name|size_t
name|subblock_size_limit
decl_stmt|;
if|if
condition|(
name|next
operator|->
name|coder
operator|->
name|options
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|next
operator|->
name|coder
operator|->
name|options
operator|->
name|alignment
operator|<
name|LZMA_SUBBLOCK_ALIGNMENT_MIN
operator|||
name|next
operator|->
name|coder
operator|->
name|options
operator|->
name|alignment
operator|>
name|LZMA_SUBBLOCK_ALIGNMENT_MAX
condition|)
block|{
name|subblock_encoder_end
argument_list|(
name|next
operator|->
name|coder
argument_list|,
name|allocator
argument_list|)
expr_stmt|;
return|return
name|LZMA_OPTIONS_ERROR
return|;
block|}
name|next
operator|->
name|coder
operator|->
name|alignment
operator|.
name|multiple
operator|=
name|next
operator|->
name|coder
operator|->
name|options
operator|->
name|alignment
expr_stmt|;
name|next
operator|->
name|coder
operator|->
name|subfilter
operator|.
name|allow
operator|=
name|next
operator|->
name|coder
operator|->
name|options
operator|->
name|allow_subfilters
expr_stmt|;
name|subblock_size_limit
operator|=
name|next
operator|->
name|coder
operator|->
name|options
operator|->
name|subblock_data_size
expr_stmt|;
block|}
else|else
block|{
name|next
operator|->
name|coder
operator|->
name|alignment
operator|.
name|multiple
operator|=
name|LZMA_SUBBLOCK_ALIGNMENT_DEFAULT
expr_stmt|;
name|next
operator|->
name|coder
operator|->
name|subfilter
operator|.
name|allow
operator|=
name|false
expr_stmt|;
name|subblock_size_limit
operator|=
name|LZMA_SUBBLOCK_DATA_SIZE_DEFAULT
expr_stmt|;
block|}
name|return_if_error
argument_list|(
name|subblock_data_size
argument_list|(
name|next
operator|->
name|coder
argument_list|,
name|allocator
argument_list|,
name|subblock_size_limit
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|lzma_next_filter_init
argument_list|(
operator|&
name|next
operator|->
name|coder
operator|->
name|next
argument_list|,
name|allocator
argument_list|,
name|filters
operator|+
literal|1
argument_list|)
return|;
block|}
end_function

end_unit

