begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|///////////////////////////////////////////////////////////////////////////////
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|/// \file       auto_decoder.c
end_comment

begin_comment
comment|/// \brief      Autodetect between .xz Stream and .lzma (LZMA_Alone) formats
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//  Author:     Lasse Collin
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//  This file has been put into the public domain.
end_comment

begin_comment
comment|//  You can do whatever you want with this file.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|///////////////////////////////////////////////////////////////////////////////
end_comment

begin_include
include|#
directive|include
file|"stream_decoder.h"
end_include

begin_include
include|#
directive|include
file|"alone_decoder.h"
end_include

begin_struct
struct|struct
name|lzma_coder_s
block|{
comment|/// Stream decoder or LZMA_Alone decoder
name|lzma_next_coder
name|next
decl_stmt|;
name|uint64_t
name|memlimit
decl_stmt|;
name|uint32_t
name|flags
decl_stmt|;
enum|enum
block|{
name|SEQ_INIT
block|,
name|SEQ_CODE
block|,
name|SEQ_FINISH
block|, 	}
name|sequence
enum|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|lzma_ret
name|auto_decode
parameter_list|(
name|lzma_coder
modifier|*
name|coder
parameter_list|,
name|lzma_allocator
modifier|*
name|allocator
parameter_list|,
specifier|const
name|uint8_t
modifier|*
specifier|restrict
name|in
parameter_list|,
name|size_t
modifier|*
specifier|restrict
name|in_pos
parameter_list|,
name|size_t
name|in_size
parameter_list|,
name|uint8_t
modifier|*
specifier|restrict
name|out
parameter_list|,
name|size_t
modifier|*
specifier|restrict
name|out_pos
parameter_list|,
name|size_t
name|out_size
parameter_list|,
name|lzma_action
name|action
parameter_list|)
block|{
switch|switch
condition|(
name|coder
operator|->
name|sequence
condition|)
block|{
case|case
name|SEQ_INIT
case|:
if|if
condition|(
operator|*
name|in_pos
operator|>=
name|in_size
condition|)
return|return
name|LZMA_OK
return|;
comment|// Update the sequence now, because we want to continue from
comment|// SEQ_CODE even if we return some LZMA_*_CHECK.
name|coder
operator|->
name|sequence
operator|=
name|SEQ_CODE
expr_stmt|;
comment|// Detect the file format. For now this is simple, since if
comment|// it doesn't start with 0xFD (the first magic byte of the
comment|// new format), it has to be LZMA_Alone, or something that
comment|// we don't support at all.
if|if
condition|(
name|in
index|[
operator|*
name|in_pos
index|]
operator|==
literal|0xFD
condition|)
block|{
name|return_if_error
argument_list|(
name|lzma_stream_decoder_init
argument_list|(
operator|&
name|coder
operator|->
name|next
argument_list|,
name|allocator
argument_list|,
name|coder
operator|->
name|memlimit
argument_list|,
name|coder
operator|->
name|flags
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|return_if_error
argument_list|(
name|lzma_alone_decoder_init
argument_list|(
operator|&
name|coder
operator|->
name|next
argument_list|,
name|allocator
argument_list|,
name|coder
operator|->
name|memlimit
argument_list|,
name|true
argument_list|)
argument_list|)
expr_stmt|;
comment|// If the application wants to know about missing
comment|// integrity check or about the check in general, we
comment|// need to handle it here, because LZMA_Alone decoder
comment|// doesn't accept any flags.
if|if
condition|(
name|coder
operator|->
name|flags
operator|&
name|LZMA_TELL_NO_CHECK
condition|)
return|return
name|LZMA_NO_CHECK
return|;
if|if
condition|(
name|coder
operator|->
name|flags
operator|&
name|LZMA_TELL_ANY_CHECK
condition|)
return|return
name|LZMA_GET_CHECK
return|;
block|}
comment|// Fall through
case|case
name|SEQ_CODE
case|:
block|{
specifier|const
name|lzma_ret
name|ret
init|=
name|coder
operator|->
name|next
operator|.
name|code
argument_list|(
name|coder
operator|->
name|next
operator|.
name|coder
argument_list|,
name|allocator
argument_list|,
name|in
argument_list|,
name|in_pos
argument_list|,
name|in_size
argument_list|,
name|out
argument_list|,
name|out_pos
argument_list|,
name|out_size
argument_list|,
name|action
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
operator|!=
name|LZMA_STREAM_END
operator|||
operator|(
name|coder
operator|->
name|flags
operator|&
name|LZMA_CONCATENATED
operator|)
operator|==
literal|0
condition|)
return|return
name|ret
return|;
name|coder
operator|->
name|sequence
operator|=
name|SEQ_FINISH
expr_stmt|;
block|}
comment|// Fall through
case|case
name|SEQ_FINISH
case|:
comment|// When LZMA_DECODE_CONCATENATED was used and we were decoding
comment|// LZMA_Alone file, we need to check check that there is no
comment|// trailing garbage and wait for LZMA_FINISH.
if|if
condition|(
operator|*
name|in_pos
operator|<
name|in_size
condition|)
return|return
name|LZMA_DATA_ERROR
return|;
return|return
name|action
operator|==
name|LZMA_FINISH
condition|?
name|LZMA_STREAM_END
else|:
name|LZMA_OK
return|;
default|default:
name|assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|LZMA_PROG_ERROR
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|auto_decoder_end
parameter_list|(
name|lzma_coder
modifier|*
name|coder
parameter_list|,
name|lzma_allocator
modifier|*
name|allocator
parameter_list|)
block|{
name|lzma_next_end
argument_list|(
operator|&
name|coder
operator|->
name|next
argument_list|,
name|allocator
argument_list|)
expr_stmt|;
name|lzma_free
argument_list|(
name|coder
argument_list|,
name|allocator
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|lzma_check
name|auto_decoder_get_check
parameter_list|(
specifier|const
name|lzma_coder
modifier|*
name|coder
parameter_list|)
block|{
comment|// It is LZMA_Alone if get_check is NULL.
return|return
name|coder
operator|->
name|next
operator|.
name|get_check
operator|==
name|NULL
condition|?
name|LZMA_CHECK_NONE
else|:
name|coder
operator|->
name|next
operator|.
name|get_check
argument_list|(
name|coder
operator|->
name|next
operator|.
name|coder
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|lzma_ret
name|auto_decoder_memconfig
parameter_list|(
name|lzma_coder
modifier|*
name|coder
parameter_list|,
name|uint64_t
modifier|*
name|memusage
parameter_list|,
name|uint64_t
modifier|*
name|old_memlimit
parameter_list|,
name|uint64_t
name|new_memlimit
parameter_list|)
block|{
name|lzma_ret
name|ret
decl_stmt|;
if|if
condition|(
name|coder
operator|->
name|next
operator|.
name|memconfig
operator|!=
name|NULL
condition|)
block|{
name|ret
operator|=
name|coder
operator|->
name|next
operator|.
name|memconfig
argument_list|(
name|coder
operator|->
name|next
operator|.
name|coder
argument_list|,
name|memusage
argument_list|,
name|old_memlimit
argument_list|,
name|new_memlimit
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|*
name|old_memlimit
operator|==
name|coder
operator|->
name|memlimit
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// No coder is configured yet. Use the base value as
comment|// the current memory usage.
operator|*
name|memusage
operator|=
name|LZMA_MEMUSAGE_BASE
expr_stmt|;
operator|*
name|old_memlimit
operator|=
name|coder
operator|->
name|memlimit
expr_stmt|;
name|ret
operator|=
name|LZMA_OK
expr_stmt|;
block|}
if|if
condition|(
name|ret
operator|==
name|LZMA_OK
operator|&&
name|new_memlimit
operator|!=
literal|0
condition|)
name|coder
operator|->
name|memlimit
operator|=
name|new_memlimit
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|lzma_ret
name|auto_decoder_init
parameter_list|(
name|lzma_next_coder
modifier|*
name|next
parameter_list|,
name|lzma_allocator
modifier|*
name|allocator
parameter_list|,
name|uint64_t
name|memlimit
parameter_list|,
name|uint32_t
name|flags
parameter_list|)
block|{
name|lzma_next_coder_init
argument_list|(
operator|&
name|auto_decoder_init
argument_list|,
name|next
argument_list|,
name|allocator
argument_list|)
expr_stmt|;
if|if
condition|(
name|memlimit
operator|==
literal|0
condition|)
return|return
name|LZMA_PROG_ERROR
return|;
if|if
condition|(
name|flags
operator|&
operator|~
name|LZMA_SUPPORTED_FLAGS
condition|)
return|return
name|LZMA_OPTIONS_ERROR
return|;
if|if
condition|(
name|next
operator|->
name|coder
operator|==
name|NULL
condition|)
block|{
name|next
operator|->
name|coder
operator|=
name|lzma_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|lzma_coder
argument_list|)
argument_list|,
name|allocator
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
operator|->
name|coder
operator|==
name|NULL
condition|)
return|return
name|LZMA_MEM_ERROR
return|;
name|next
operator|->
name|code
operator|=
operator|&
name|auto_decode
expr_stmt|;
name|next
operator|->
name|end
operator|=
operator|&
name|auto_decoder_end
expr_stmt|;
name|next
operator|->
name|get_check
operator|=
operator|&
name|auto_decoder_get_check
expr_stmt|;
name|next
operator|->
name|memconfig
operator|=
operator|&
name|auto_decoder_memconfig
expr_stmt|;
name|next
operator|->
name|coder
operator|->
name|next
operator|=
name|LZMA_NEXT_CODER_INIT
expr_stmt|;
block|}
name|next
operator|->
name|coder
operator|->
name|memlimit
operator|=
name|memlimit
expr_stmt|;
name|next
operator|->
name|coder
operator|->
name|flags
operator|=
name|flags
expr_stmt|;
name|next
operator|->
name|coder
operator|->
name|sequence
operator|=
name|SEQ_INIT
expr_stmt|;
return|return
name|LZMA_OK
return|;
block|}
end_function

begin_extern
extern|extern LZMA_API(lzma_ret
end_extern

begin_macro
unit|)
name|lzma_auto_decoder
argument_list|(
argument|lzma_stream *strm
argument_list|,
argument|uint64_t memlimit
argument_list|,
argument|uint32_t flags
argument_list|)
end_macro

begin_block
block|{
name|lzma_next_strm_init
argument_list|(
name|auto_decoder_init
argument_list|,
name|strm
argument_list|,
name|memlimit
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|strm
operator|->
name|internal
operator|->
name|supported_actions
index|[
name|LZMA_RUN
index|]
operator|=
name|true
expr_stmt|;
name|strm
operator|->
name|internal
operator|->
name|supported_actions
index|[
name|LZMA_FINISH
index|]
operator|=
name|true
expr_stmt|;
return|return
name|LZMA_OK
return|;
block|}
end_block

end_unit

