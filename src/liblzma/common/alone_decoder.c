begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|///////////////////////////////////////////////////////////////////////////////
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|/// \file       alone_decoder.c
end_comment

begin_comment
comment|/// \brief      Decoder for LZMA_Alone files
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//  Author:     Lasse Collin
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//  This file has been put into the public domain.
end_comment

begin_comment
comment|//  You can do whatever you want with this file.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|///////////////////////////////////////////////////////////////////////////////
end_comment

begin_include
include|#
directive|include
file|"alone_decoder.h"
end_include

begin_include
include|#
directive|include
file|"lzma_decoder.h"
end_include

begin_include
include|#
directive|include
file|"lz_decoder.h"
end_include

begin_struct
struct|struct
name|lzma_coder_s
block|{
name|lzma_next_coder
name|next
decl_stmt|;
enum|enum
block|{
name|SEQ_PROPERTIES
block|,
name|SEQ_DICTIONARY_SIZE
block|,
name|SEQ_UNCOMPRESSED_SIZE
block|,
name|SEQ_CODER_INIT
block|,
name|SEQ_CODE
block|, 	}
name|sequence
enum|;
comment|/// If true, reject files that are unlikely to be .lzma files.
comment|/// If false, more non-.lzma files get accepted and will give
comment|/// LZMA_DATA_ERROR either immediately or after a few output bytes.
name|bool
name|picky
decl_stmt|;
comment|/// Position in the header fields
name|size_t
name|pos
decl_stmt|;
comment|/// Uncompressed size decoded from the header
name|lzma_vli
name|uncompressed_size
decl_stmt|;
comment|/// Memory usage limit
name|uint64_t
name|memlimit
decl_stmt|;
comment|/// Amount of memory actually needed (only an estimate)
name|uint64_t
name|memusage
decl_stmt|;
comment|/// Options decoded from the header needed to initialize
comment|/// the LZMA decoder
name|lzma_options_lzma
name|options
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|lzma_ret
name|alone_decode
argument_list|(
name|lzma_coder
operator|*
name|coder
argument_list|,
name|lzma_allocator
operator|*
name|allocator
name|lzma_attribute
argument_list|(
operator|(
name|__unused__
operator|)
argument_list|)
argument_list|,
specifier|const
name|uint8_t
operator|*
specifier|restrict
name|in
argument_list|,
name|size_t
operator|*
specifier|restrict
name|in_pos
argument_list|,
name|size_t
name|in_size
argument_list|,
name|uint8_t
operator|*
specifier|restrict
name|out
argument_list|,
name|size_t
operator|*
specifier|restrict
name|out_pos
argument_list|,
name|size_t
name|out_size
argument_list|,
name|lzma_action
name|action
argument_list|)
block|{
while|while
condition|(
operator|*
name|out_pos
operator|<
name|out_size
operator|&&
operator|(
name|coder
operator|->
name|sequence
operator|==
name|SEQ_CODE
operator|||
operator|*
name|in_pos
operator|<
name|in_size
operator|)
condition|)
switch|switch
condition|(
name|coder
operator|->
name|sequence
condition|)
block|{
case|case
name|SEQ_PROPERTIES
case|:
if|if
condition|(
name|lzma_lzma_lclppb_decode
argument_list|(
operator|&
name|coder
operator|->
name|options
argument_list|,
name|in
index|[
operator|*
name|in_pos
index|]
argument_list|)
condition|)
return|return
name|LZMA_FORMAT_ERROR
return|;
name|coder
operator|->
name|sequence
operator|=
name|SEQ_DICTIONARY_SIZE
expr_stmt|;
operator|++
operator|*
name|in_pos
expr_stmt|;
break|break;
case|case
name|SEQ_DICTIONARY_SIZE
case|:
name|coder
operator|->
name|options
operator|.
name|dict_size
operator||=
call|(
name|size_t
call|)
argument_list|(
name|in
index|[
operator|*
name|in_pos
index|]
argument_list|)
operator|<<
operator|(
name|coder
operator|->
name|pos
operator|*
literal|8
operator|)
expr_stmt|;
if|if
condition|(
operator|++
name|coder
operator|->
name|pos
operator|==
literal|4
condition|)
block|{
if|if
condition|(
name|coder
operator|->
name|picky
operator|&&
name|coder
operator|->
name|options
operator|.
name|dict_size
operator|!=
name|UINT32_MAX
condition|)
block|{
comment|// A hack to ditch tons of false positives:
comment|// We allow only dictionary sizes that are
comment|// 2^n or 2^n + 2^(n-1). LZMA_Alone created
comment|// only files with 2^n, but accepts any
comment|// dictionary size.
name|uint32_t
name|d
init|=
name|coder
operator|->
name|options
operator|.
name|dict_size
operator|-
literal|1
decl_stmt|;
name|d
operator||=
name|d
operator|>>
literal|2
expr_stmt|;
name|d
operator||=
name|d
operator|>>
literal|3
expr_stmt|;
name|d
operator||=
name|d
operator|>>
literal|4
expr_stmt|;
name|d
operator||=
name|d
operator|>>
literal|8
expr_stmt|;
name|d
operator||=
name|d
operator|>>
literal|16
expr_stmt|;
operator|++
name|d
expr_stmt|;
if|if
condition|(
name|d
operator|!=
name|coder
operator|->
name|options
operator|.
name|dict_size
condition|)
return|return
name|LZMA_FORMAT_ERROR
return|;
block|}
name|coder
operator|->
name|pos
operator|=
literal|0
expr_stmt|;
name|coder
operator|->
name|sequence
operator|=
name|SEQ_UNCOMPRESSED_SIZE
expr_stmt|;
block|}
operator|++
operator|*
name|in_pos
expr_stmt|;
break|break;
case|case
name|SEQ_UNCOMPRESSED_SIZE
case|:
name|coder
operator|->
name|uncompressed_size
operator||=
call|(
name|lzma_vli
call|)
argument_list|(
name|in
index|[
operator|*
name|in_pos
index|]
argument_list|)
operator|<<
operator|(
name|coder
operator|->
name|pos
operator|*
literal|8
operator|)
expr_stmt|;
operator|++
operator|*
name|in_pos
expr_stmt|;
if|if
condition|(
operator|++
name|coder
operator|->
name|pos
operator|<
literal|8
condition|)
break|break;
comment|// Another hack to ditch false positives: Assume that
comment|// if the uncompressed size is known, it must be less
comment|// than 256 GiB.
if|if
condition|(
name|coder
operator|->
name|picky
operator|&&
name|coder
operator|->
name|uncompressed_size
operator|!=
name|LZMA_VLI_UNKNOWN
operator|&&
name|coder
operator|->
name|uncompressed_size
operator|>=
operator|(
name|LZMA_VLI_C
argument_list|(
literal|1
argument_list|)
operator|<<
literal|38
operator|)
condition|)
return|return
name|LZMA_FORMAT_ERROR
return|;
comment|// Calculate the memory usage so that it is ready
comment|// for SEQ_CODER_INIT.
name|coder
operator|->
name|memusage
operator|=
name|lzma_lzma_decoder_memusage
argument_list|(
operator|&
name|coder
operator|->
name|options
argument_list|)
operator|+
name|LZMA_MEMUSAGE_BASE
expr_stmt|;
name|coder
operator|->
name|pos
operator|=
literal|0
expr_stmt|;
name|coder
operator|->
name|sequence
operator|=
name|SEQ_CODER_INIT
expr_stmt|;
comment|// Fall through
case|case
name|SEQ_CODER_INIT
case|:
block|{
if|if
condition|(
name|coder
operator|->
name|memusage
operator|>
name|coder
operator|->
name|memlimit
condition|)
return|return
name|LZMA_MEMLIMIT_ERROR
return|;
name|lzma_filter_info
name|filters
index|[
literal|2
index|]
init|=
block|{
block|{
operator|.
name|init
operator|=
operator|&
name|lzma_lzma_decoder_init
block|,
operator|.
name|options
operator|=
operator|&
name|coder
operator|->
name|options
block|, 			}
block|,
block|{
operator|.
name|init
operator|=
name|NULL
block|, 			}
block|}
decl_stmt|;
specifier|const
name|lzma_ret
name|ret
init|=
name|lzma_next_filter_init
argument_list|(
operator|&
name|coder
operator|->
name|next
argument_list|,
name|allocator
argument_list|,
name|filters
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
operator|!=
name|LZMA_OK
condition|)
return|return
name|ret
return|;
comment|// Use a hack to set the uncompressed size.
name|lzma_lz_decoder_uncompressed
argument_list|(
name|coder
operator|->
name|next
operator|.
name|coder
argument_list|,
name|coder
operator|->
name|uncompressed_size
argument_list|)
expr_stmt|;
name|coder
operator|->
name|sequence
operator|=
name|SEQ_CODE
expr_stmt|;
break|break;
block|}
case|case
name|SEQ_CODE
case|:
block|{
return|return
name|coder
operator|->
name|next
operator|.
name|code
argument_list|(
name|coder
operator|->
name|next
operator|.
name|coder
argument_list|,
name|allocator
argument_list|,
name|in
argument_list|,
name|in_pos
argument_list|,
name|in_size
argument_list|,
name|out
argument_list|,
name|out_pos
argument_list|,
name|out_size
argument_list|,
name|action
argument_list|)
return|;
block|}
default|default:
return|return
name|LZMA_PROG_ERROR
return|;
block|}
return|return
name|LZMA_OK
return|;
block|}
end_decl_stmt

begin_function
specifier|static
name|void
name|alone_decoder_end
parameter_list|(
name|lzma_coder
modifier|*
name|coder
parameter_list|,
name|lzma_allocator
modifier|*
name|allocator
parameter_list|)
block|{
name|lzma_next_end
argument_list|(
operator|&
name|coder
operator|->
name|next
argument_list|,
name|allocator
argument_list|)
expr_stmt|;
name|lzma_free
argument_list|(
name|coder
argument_list|,
name|allocator
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|lzma_ret
name|alone_decoder_memconfig
parameter_list|(
name|lzma_coder
modifier|*
name|coder
parameter_list|,
name|uint64_t
modifier|*
name|memusage
parameter_list|,
name|uint64_t
modifier|*
name|old_memlimit
parameter_list|,
name|uint64_t
name|new_memlimit
parameter_list|)
block|{
operator|*
name|memusage
operator|=
name|coder
operator|->
name|memusage
expr_stmt|;
operator|*
name|old_memlimit
operator|=
name|coder
operator|->
name|memlimit
expr_stmt|;
if|if
condition|(
name|new_memlimit
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|new_memlimit
operator|<
name|coder
operator|->
name|memusage
condition|)
return|return
name|LZMA_MEMLIMIT_ERROR
return|;
name|coder
operator|->
name|memlimit
operator|=
name|new_memlimit
expr_stmt|;
block|}
return|return
name|LZMA_OK
return|;
block|}
end_function

begin_function
specifier|extern
name|lzma_ret
name|lzma_alone_decoder_init
parameter_list|(
name|lzma_next_coder
modifier|*
name|next
parameter_list|,
name|lzma_allocator
modifier|*
name|allocator
parameter_list|,
name|uint64_t
name|memlimit
parameter_list|,
name|bool
name|picky
parameter_list|)
block|{
name|lzma_next_coder_init
argument_list|(
operator|&
name|lzma_alone_decoder_init
argument_list|,
name|next
argument_list|,
name|allocator
argument_list|)
expr_stmt|;
if|if
condition|(
name|memlimit
operator|==
literal|0
condition|)
return|return
name|LZMA_PROG_ERROR
return|;
if|if
condition|(
name|next
operator|->
name|coder
operator|==
name|NULL
condition|)
block|{
name|next
operator|->
name|coder
operator|=
name|lzma_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|lzma_coder
argument_list|)
argument_list|,
name|allocator
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
operator|->
name|coder
operator|==
name|NULL
condition|)
return|return
name|LZMA_MEM_ERROR
return|;
name|next
operator|->
name|code
operator|=
operator|&
name|alone_decode
expr_stmt|;
name|next
operator|->
name|end
operator|=
operator|&
name|alone_decoder_end
expr_stmt|;
name|next
operator|->
name|memconfig
operator|=
operator|&
name|alone_decoder_memconfig
expr_stmt|;
name|next
operator|->
name|coder
operator|->
name|next
operator|=
name|LZMA_NEXT_CODER_INIT
expr_stmt|;
block|}
name|next
operator|->
name|coder
operator|->
name|sequence
operator|=
name|SEQ_PROPERTIES
expr_stmt|;
name|next
operator|->
name|coder
operator|->
name|picky
operator|=
name|picky
expr_stmt|;
name|next
operator|->
name|coder
operator|->
name|pos
operator|=
literal|0
expr_stmt|;
name|next
operator|->
name|coder
operator|->
name|options
operator|.
name|dict_size
operator|=
literal|0
expr_stmt|;
name|next
operator|->
name|coder
operator|->
name|options
operator|.
name|preset_dict
operator|=
name|NULL
expr_stmt|;
name|next
operator|->
name|coder
operator|->
name|options
operator|.
name|preset_dict_size
operator|=
literal|0
expr_stmt|;
name|next
operator|->
name|coder
operator|->
name|uncompressed_size
operator|=
literal|0
expr_stmt|;
name|next
operator|->
name|coder
operator|->
name|memlimit
operator|=
name|memlimit
expr_stmt|;
name|next
operator|->
name|coder
operator|->
name|memusage
operator|=
name|LZMA_MEMUSAGE_BASE
expr_stmt|;
return|return
name|LZMA_OK
return|;
block|}
end_function

begin_extern
extern|extern LZMA_API(lzma_ret
end_extern

begin_macro
unit|)
name|lzma_alone_decoder
argument_list|(
argument|lzma_stream *strm
argument_list|,
argument|uint64_t memlimit
argument_list|)
end_macro

begin_block
block|{
name|lzma_next_strm_init
argument_list|(
name|lzma_alone_decoder_init
argument_list|,
name|strm
argument_list|,
name|memlimit
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|strm
operator|->
name|internal
operator|->
name|supported_actions
index|[
name|LZMA_RUN
index|]
operator|=
name|true
expr_stmt|;
name|strm
operator|->
name|internal
operator|->
name|supported_actions
index|[
name|LZMA_FINISH
index|]
operator|=
name|true
expr_stmt|;
return|return
name|LZMA_OK
return|;
block|}
end_block

end_unit

