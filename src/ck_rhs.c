begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright 2014-2015 Olivier Houchard.  * Copyright 2012-2015 Samy Al Bahra.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<ck_cc.h>
end_include

begin_include
include|#
directive|include
file|<ck_rhs.h>
end_include

begin_include
include|#
directive|include
file|<ck_limits.h>
end_include

begin_include
include|#
directive|include
file|<ck_md.h>
end_include

begin_include
include|#
directive|include
file|<ck_pr.h>
end_include

begin_include
include|#
directive|include
file|<ck_stdint.h>
end_include

begin_include
include|#
directive|include
file|<ck_stdbool.h>
end_include

begin_include
include|#
directive|include
file|<ck_string.h>
end_include

begin_include
include|#
directive|include
file|"ck_internal.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|CK_RHS_PROBE_L1_SHIFT
end_ifndef

begin_define
define|#
directive|define
name|CK_RHS_PROBE_L1_SHIFT
value|3ULL
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CK_RHS_PROBE_L1_SHIFT */
end_comment

begin_define
define|#
directive|define
name|CK_RHS_PROBE_L1
value|(1<< CK_RHS_PROBE_L1_SHIFT)
end_define

begin_define
define|#
directive|define
name|CK_RHS_PROBE_L1_MASK
value|(CK_RHS_PROBE_L1 - 1)
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|CK_RHS_PROBE_L1_DEFAULT
end_ifndef

begin_define
define|#
directive|define
name|CK_RHS_PROBE_L1_DEFAULT
value|CK_MD_CACHELINE
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|CK_RHS_VMA_MASK
value|((uintptr_t)((1ULL<< CK_MD_VMA_BITS) - 1))
end_define

begin_define
define|#
directive|define
name|CK_RHS_VMA
parameter_list|(
name|x
parameter_list|)
define|\
value|((void *)((uintptr_t)(x)& CK_RHS_VMA_MASK))
end_define

begin_define
define|#
directive|define
name|CK_RHS_EMPTY
value|NULL
end_define

begin_define
define|#
directive|define
name|CK_RHS_G
value|(1024)
end_define

begin_define
define|#
directive|define
name|CK_RHS_G_MASK
value|(CK_RHS_G - 1)
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|CK_F_PR_LOAD_8
argument_list|)
operator|&&
name|defined
argument_list|(
name|CK_F_PR_STORE_8
argument_list|)
end_if

begin_define
define|#
directive|define
name|CK_RHS_WORD
value|uint8_t
end_define

begin_define
define|#
directive|define
name|CK_RHS_WORD_MAX
value|UINT8_MAX
end_define

begin_define
define|#
directive|define
name|CK_RHS_STORE
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|ck_pr_store_8(x, y)
end_define

begin_define
define|#
directive|define
name|CK_RHS_LOAD
parameter_list|(
name|x
parameter_list|)
value|ck_pr_load_8(x)
end_define

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|CK_F_PR_LOAD_16
argument_list|)
operator|&&
name|defined
argument_list|(
name|CK_F_PR_STORE_16
argument_list|)
end_elif

begin_define
define|#
directive|define
name|CK_RHS_WORD
value|uint16_t
end_define

begin_define
define|#
directive|define
name|CK_RHS_WORD_MAX
value|UINT16_MAX
end_define

begin_define
define|#
directive|define
name|CK_RHS_STORE
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|ck_pr_store_16(x, y)
end_define

begin_define
define|#
directive|define
name|CK_RHS_LOAD
parameter_list|(
name|x
parameter_list|)
value|ck_pr_load_16(x)
end_define

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|CK_F_PR_LOAD_32
argument_list|)
operator|&&
name|defined
argument_list|(
name|CK_F_PR_STORE_32
argument_list|)
end_elif

begin_define
define|#
directive|define
name|CK_RHS_WORD
value|uint32_t
end_define

begin_define
define|#
directive|define
name|CK_RHS_WORD_MAX
value|UINT32_MAX
end_define

begin_define
define|#
directive|define
name|CK_RHS_STORE
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|ck_pr_store_32(x, y)
end_define

begin_define
define|#
directive|define
name|CK_RHS_LOAD
parameter_list|(
name|x
parameter_list|)
value|ck_pr_load_32(x)
end_define

begin_else
else|#
directive|else
end_else

begin_error
error|#
directive|error
literal|"ck_rhs is not supported on your platform."
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|CK_RHS_MAX_WANTED
value|0xffff
end_define

begin_enum
enum|enum
name|ck_rhs_probe_behavior
block|{
name|CK_RHS_PROBE
init|=
literal|0
block|,
comment|/* Default behavior. */
name|CK_RHS_PROBE_RH
block|,
comment|/* Short-circuit if RH slot found. */
name|CK_RHS_PROBE_INSERT
block|,
comment|/* Short-circuit on probe bound if tombstone found. */
name|CK_RHS_PROBE_ROBIN_HOOD
block|,
comment|/* Look for the first slot available for the entry we are about to replace, only used to internally implement Robin Hood */
name|CK_RHS_PROBE_NO_RH
block|,
comment|/* Don't do the RH dance */
block|}
enum|;
end_enum

begin_struct
struct|struct
name|ck_rhs_entry_desc
block|{
name|unsigned
name|int
name|probes
decl_stmt|;
name|unsigned
name|short
name|wanted
decl_stmt|;
name|CK_RHS_WORD
name|probe_bound
decl_stmt|;
name|bool
name|in_rh
decl_stmt|;
specifier|const
name|void
modifier|*
name|entry
decl_stmt|;
block|}
name|CK_CC_ALIGN
argument_list|(
literal|16
argument_list|)
struct|;
end_struct

begin_struct
struct|struct
name|ck_rhs_no_entry_desc
block|{
name|unsigned
name|int
name|probes
decl_stmt|;
name|unsigned
name|short
name|wanted
decl_stmt|;
name|CK_RHS_WORD
name|probe_bound
decl_stmt|;
name|bool
name|in_rh
decl_stmt|;
block|}
name|CK_CC_ALIGN
argument_list|(
literal|8
argument_list|)
struct|;
end_struct

begin_typedef
typedef|typedef
name|long
name|ck_rhs_probe_cb_t
parameter_list|(
name|struct
name|ck_rhs
modifier|*
name|hs
parameter_list|,
name|struct
name|ck_rhs_map
modifier|*
name|map
parameter_list|,
name|unsigned
name|long
modifier|*
name|n_probes
parameter_list|,
name|long
modifier|*
name|priority
parameter_list|,
name|unsigned
name|long
name|h
parameter_list|,
specifier|const
name|void
modifier|*
name|key
parameter_list|,
specifier|const
name|void
modifier|*
modifier|*
name|object
parameter_list|,
name|unsigned
name|long
name|probe_limit
parameter_list|,
name|enum
name|ck_rhs_probe_behavior
name|behavior
parameter_list|)
function_decl|;
end_typedef

begin_struct
struct|struct
name|ck_rhs_map
block|{
name|unsigned
name|int
name|generation
index|[
name|CK_RHS_G
index|]
decl_stmt|;
name|unsigned
name|int
name|probe_maximum
decl_stmt|;
name|unsigned
name|long
name|mask
decl_stmt|;
name|unsigned
name|long
name|step
decl_stmt|;
name|unsigned
name|int
name|probe_limit
decl_stmt|;
name|unsigned
name|long
name|n_entries
decl_stmt|;
name|unsigned
name|long
name|capacity
decl_stmt|;
name|unsigned
name|long
name|size
decl_stmt|;
name|unsigned
name|long
name|max_entries
decl_stmt|;
name|char
name|offset_mask
decl_stmt|;
union|union
block|{
name|struct
name|ck_rhs_entry_desc
modifier|*
name|descs
decl_stmt|;
struct|struct
name|ck_rhs_no_entry
block|{
specifier|const
name|void
modifier|*
modifier|*
name|entries
decl_stmt|;
name|struct
name|ck_rhs_no_entry_desc
modifier|*
name|descs
decl_stmt|;
block|}
name|no_entries
struct|;
block|}
name|entries
union|;
name|bool
name|read_mostly
decl_stmt|;
name|ck_rhs_probe_cb_t
modifier|*
name|probe_func
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|CK_CC_INLINE
specifier|const
name|void
modifier|*
name|ck_rhs_entry
parameter_list|(
name|struct
name|ck_rhs_map
modifier|*
name|map
parameter_list|,
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
name|map
operator|->
name|read_mostly
condition|)
return|return
operator|(
name|map
operator|->
name|entries
operator|.
name|no_entries
operator|.
name|entries
index|[
name|offset
index|]
operator|)
return|;
else|else
return|return
operator|(
name|map
operator|->
name|entries
operator|.
name|descs
index|[
name|offset
index|]
operator|.
name|entry
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|CK_CC_INLINE
specifier|const
name|void
modifier|*
modifier|*
name|ck_rhs_entry_addr
parameter_list|(
name|struct
name|ck_rhs_map
modifier|*
name|map
parameter_list|,
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
name|map
operator|->
name|read_mostly
condition|)
return|return
operator|(
operator|&
name|map
operator|->
name|entries
operator|.
name|no_entries
operator|.
name|entries
index|[
name|offset
index|]
operator|)
return|;
else|else
return|return
operator|(
operator|&
name|map
operator|->
name|entries
operator|.
name|descs
index|[
name|offset
index|]
operator|.
name|entry
operator|)
return|;
block|}
end_function

begin_expr_stmt
specifier|static
name|CK_CC_INLINE
expr|struct
name|ck_rhs_entry_desc
operator|*
name|ck_rhs_desc
argument_list|(
argument|struct ck_rhs_map *map
argument_list|,
argument|long offset
argument_list|)
block|{
if|if
condition|(
name|CK_CC_UNLIKELY
argument_list|(
name|map
operator|->
name|read_mostly
argument_list|)
condition|)
return|return
operator|(
operator|(
expr|struct
name|ck_rhs_entry_desc
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
operator|&
name|map
operator|->
name|entries
operator|.
name|no_entries
operator|.
name|descs
index|[
name|offset
index|]
operator|)
return|;
else|else
return|return
operator|(
operator|&
name|map
operator|->
name|entries
operator|.
name|descs
index|[
name|offset
index|]
operator|)
return|;
block|}
end_expr_stmt

begin_function
specifier|static
name|CK_CC_INLINE
name|void
name|ck_rhs_wanted_inc
parameter_list|(
name|struct
name|ck_rhs_map
modifier|*
name|map
parameter_list|,
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
name|CK_CC_UNLIKELY
argument_list|(
name|map
operator|->
name|read_mostly
argument_list|)
condition|)
name|map
operator|->
name|entries
operator|.
name|no_entries
operator|.
name|descs
index|[
name|offset
index|]
operator|.
name|wanted
operator|++
expr_stmt|;
else|else
name|map
operator|->
name|entries
operator|.
name|descs
index|[
name|offset
index|]
operator|.
name|wanted
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|CK_CC_INLINE
name|unsigned
name|int
name|ck_rhs_probes
parameter_list|(
name|struct
name|ck_rhs_map
modifier|*
name|map
parameter_list|,
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
name|CK_CC_UNLIKELY
argument_list|(
name|map
operator|->
name|read_mostly
argument_list|)
condition|)
return|return
operator|(
name|map
operator|->
name|entries
operator|.
name|no_entries
operator|.
name|descs
index|[
name|offset
index|]
operator|.
name|probes
operator|)
return|;
else|else
return|return
operator|(
name|map
operator|->
name|entries
operator|.
name|descs
index|[
name|offset
index|]
operator|.
name|probes
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|CK_CC_INLINE
name|void
name|ck_rhs_set_probes
parameter_list|(
name|struct
name|ck_rhs_map
modifier|*
name|map
parameter_list|,
name|long
name|offset
parameter_list|,
name|unsigned
name|int
name|value
parameter_list|)
block|{
if|if
condition|(
name|CK_CC_UNLIKELY
argument_list|(
name|map
operator|->
name|read_mostly
argument_list|)
condition|)
name|map
operator|->
name|entries
operator|.
name|no_entries
operator|.
name|descs
index|[
name|offset
index|]
operator|.
name|probes
operator|=
name|value
expr_stmt|;
else|else
name|map
operator|->
name|entries
operator|.
name|descs
index|[
name|offset
index|]
operator|.
name|probes
operator|=
name|value
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|CK_CC_INLINE
name|CK_RHS_WORD
name|ck_rhs_probe_bound
parameter_list|(
name|struct
name|ck_rhs_map
modifier|*
name|map
parameter_list|,
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
name|CK_CC_UNLIKELY
argument_list|(
name|map
operator|->
name|read_mostly
argument_list|)
condition|)
return|return
operator|(
name|map
operator|->
name|entries
operator|.
name|no_entries
operator|.
name|descs
index|[
name|offset
index|]
operator|.
name|probe_bound
operator|)
return|;
else|else
return|return
operator|(
name|map
operator|->
name|entries
operator|.
name|descs
index|[
name|offset
index|]
operator|.
name|probe_bound
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|CK_CC_INLINE
name|CK_RHS_WORD
modifier|*
name|ck_rhs_probe_bound_addr
parameter_list|(
name|struct
name|ck_rhs_map
modifier|*
name|map
parameter_list|,
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
name|CK_CC_UNLIKELY
argument_list|(
name|map
operator|->
name|read_mostly
argument_list|)
condition|)
return|return
operator|(
operator|&
name|map
operator|->
name|entries
operator|.
name|no_entries
operator|.
name|descs
index|[
name|offset
index|]
operator|.
name|probe_bound
operator|)
return|;
else|else
return|return
operator|(
operator|&
name|map
operator|->
name|entries
operator|.
name|descs
index|[
name|offset
index|]
operator|.
name|probe_bound
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|CK_CC_INLINE
name|bool
name|ck_rhs_in_rh
parameter_list|(
name|struct
name|ck_rhs_map
modifier|*
name|map
parameter_list|,
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
name|CK_CC_UNLIKELY
argument_list|(
name|map
operator|->
name|read_mostly
argument_list|)
condition|)
return|return
operator|(
name|map
operator|->
name|entries
operator|.
name|no_entries
operator|.
name|descs
index|[
name|offset
index|]
operator|.
name|in_rh
operator|)
return|;
else|else
return|return
operator|(
name|map
operator|->
name|entries
operator|.
name|descs
index|[
name|offset
index|]
operator|.
name|in_rh
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|CK_CC_INLINE
name|void
name|ck_rhs_set_rh
parameter_list|(
name|struct
name|ck_rhs_map
modifier|*
name|map
parameter_list|,
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
name|CK_CC_UNLIKELY
argument_list|(
name|map
operator|->
name|read_mostly
argument_list|)
condition|)
name|map
operator|->
name|entries
operator|.
name|no_entries
operator|.
name|descs
index|[
name|offset
index|]
operator|.
name|in_rh
operator|=
name|true
expr_stmt|;
else|else
name|map
operator|->
name|entries
operator|.
name|descs
index|[
name|offset
index|]
operator|.
name|in_rh
operator|=
name|true
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|CK_CC_INLINE
name|void
name|ck_rhs_unset_rh
parameter_list|(
name|struct
name|ck_rhs_map
modifier|*
name|map
parameter_list|,
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
name|CK_CC_UNLIKELY
argument_list|(
name|map
operator|->
name|read_mostly
argument_list|)
condition|)
name|map
operator|->
name|entries
operator|.
name|no_entries
operator|.
name|descs
index|[
name|offset
index|]
operator|.
name|in_rh
operator|=
name|false
expr_stmt|;
else|else
name|map
operator|->
name|entries
operator|.
name|descs
index|[
name|offset
index|]
operator|.
name|in_rh
operator|=
name|false
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|CK_RHS_DEFAULT_LOAD_FACTOR
value|50
end_define

begin_decl_stmt
specifier|static
name|ck_rhs_probe_cb_t
name|ck_rhs_map_probe
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ck_rhs_probe_cb_t
name|ck_rhs_map_probe_rm
decl_stmt|;
end_decl_stmt

begin_function
name|bool
name|ck_rhs_set_load_factor
parameter_list|(
name|struct
name|ck_rhs
modifier|*
name|hs
parameter_list|,
name|unsigned
name|int
name|load_factor
parameter_list|)
block|{
name|struct
name|ck_rhs_map
modifier|*
name|map
init|=
name|hs
operator|->
name|map
decl_stmt|;
if|if
condition|(
name|load_factor
operator|==
literal|0
operator|||
name|load_factor
operator|>
literal|100
condition|)
return|return
name|false
return|;
name|hs
operator|->
name|load_factor
operator|=
name|load_factor
expr_stmt|;
name|map
operator|->
name|max_entries
operator|=
operator|(
name|map
operator|->
name|capacity
operator|*
operator|(
name|unsigned
name|long
operator|)
name|hs
operator|->
name|load_factor
operator|)
operator|/
literal|100
expr_stmt|;
while|while
condition|(
name|map
operator|->
name|n_entries
operator|>
name|map
operator|->
name|max_entries
condition|)
block|{
if|if
condition|(
name|ck_rhs_grow
argument_list|(
name|hs
argument_list|,
name|map
operator|->
name|capacity
operator|<<
literal|1
argument_list|)
operator|==
name|false
condition|)
return|return
name|false
return|;
name|map
operator|=
name|hs
operator|->
name|map
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_function
name|void
name|ck_rhs_iterator_init
parameter_list|(
name|struct
name|ck_rhs_iterator
modifier|*
name|iterator
parameter_list|)
block|{
name|iterator
operator|->
name|cursor
operator|=
name|NULL
expr_stmt|;
name|iterator
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|bool
name|ck_rhs_next
parameter_list|(
name|struct
name|ck_rhs
modifier|*
name|hs
parameter_list|,
name|struct
name|ck_rhs_iterator
modifier|*
name|i
parameter_list|,
name|void
modifier|*
modifier|*
name|key
parameter_list|)
block|{
name|struct
name|ck_rhs_map
modifier|*
name|map
init|=
name|hs
operator|->
name|map
decl_stmt|;
name|void
modifier|*
name|value
decl_stmt|;
if|if
condition|(
name|i
operator|->
name|offset
operator|>=
name|map
operator|->
name|capacity
condition|)
return|return
name|false
return|;
do|do
block|{
name|value
operator|=
name|CK_CC_DECONST_PTR
argument_list|(
name|ck_rhs_entry
argument_list|(
name|map
argument_list|,
name|i
operator|->
name|offset
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|!=
name|CK_RHS_EMPTY
condition|)
block|{
ifdef|#
directive|ifdef
name|CK_RHS_PP
if|if
condition|(
name|hs
operator|->
name|mode
operator|&
name|CK_RHS_MODE_OBJECT
condition|)
name|value
operator|=
name|CK_RHS_VMA
argument_list|(
name|value
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|i
operator|->
name|offset
operator|++
expr_stmt|;
operator|*
name|key
operator|=
name|value
expr_stmt|;
return|return
name|true
return|;
block|}
block|}
do|while
condition|(
operator|++
name|i
operator|->
name|offset
operator|<
name|map
operator|->
name|capacity
condition|)
do|;
return|return
name|false
return|;
block|}
end_function

begin_function
name|void
name|ck_rhs_stat
parameter_list|(
name|struct
name|ck_rhs
modifier|*
name|hs
parameter_list|,
name|struct
name|ck_rhs_stat
modifier|*
name|st
parameter_list|)
block|{
name|struct
name|ck_rhs_map
modifier|*
name|map
init|=
name|hs
operator|->
name|map
decl_stmt|;
name|st
operator|->
name|n_entries
operator|=
name|map
operator|->
name|n_entries
expr_stmt|;
name|st
operator|->
name|probe_maximum
operator|=
name|map
operator|->
name|probe_maximum
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|unsigned
name|long
name|ck_rhs_count
parameter_list|(
name|struct
name|ck_rhs
modifier|*
name|hs
parameter_list|)
block|{
return|return
name|hs
operator|->
name|map
operator|->
name|n_entries
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ck_rhs_map_destroy
parameter_list|(
name|struct
name|ck_malloc
modifier|*
name|m
parameter_list|,
name|struct
name|ck_rhs_map
modifier|*
name|map
parameter_list|,
name|bool
name|defer
parameter_list|)
block|{
name|m
operator|->
name|free
argument_list|(
name|map
argument_list|,
name|map
operator|->
name|size
argument_list|,
name|defer
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|ck_rhs_destroy
parameter_list|(
name|struct
name|ck_rhs
modifier|*
name|hs
parameter_list|)
block|{
name|ck_rhs_map_destroy
argument_list|(
name|hs
operator|->
name|m
argument_list|,
name|hs
operator|->
name|map
argument_list|,
name|false
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|struct
name|ck_rhs_map
modifier|*
name|ck_rhs_map_create
parameter_list|(
name|struct
name|ck_rhs
modifier|*
name|hs
parameter_list|,
name|unsigned
name|long
name|entries
parameter_list|)
block|{
name|struct
name|ck_rhs_map
modifier|*
name|map
decl_stmt|;
name|unsigned
name|long
name|size
decl_stmt|,
name|n_entries
decl_stmt|,
name|limit
decl_stmt|;
name|n_entries
operator|=
name|ck_internal_power_2
argument_list|(
name|entries
argument_list|)
expr_stmt|;
if|if
condition|(
name|n_entries
operator|<
name|CK_RHS_PROBE_L1
condition|)
name|n_entries
operator|=
name|CK_RHS_PROBE_L1
expr_stmt|;
if|if
condition|(
name|hs
operator|->
name|mode
operator|&
name|CK_RHS_MODE_READ_MOSTLY
condition|)
name|size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ck_rhs_map
argument_list|)
operator|+
operator|(
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
operator|*
name|n_entries
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ck_rhs_no_entry_desc
argument_list|)
operator|*
name|n_entries
operator|+
literal|2
operator|*
name|CK_MD_CACHELINE
operator|-
literal|1
operator|)
expr_stmt|;
else|else
name|size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ck_rhs_map
argument_list|)
operator|+
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|ck_rhs_entry_desc
argument_list|)
operator|*
name|n_entries
operator|+
name|CK_MD_CACHELINE
operator|-
literal|1
operator|)
expr_stmt|;
name|map
operator|=
name|hs
operator|->
name|m
operator|->
name|malloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|map
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|map
operator|->
name|read_mostly
operator|=
operator|!
operator|!
operator|(
name|hs
operator|->
name|mode
operator|&
name|CK_RHS_MODE_READ_MOSTLY
operator|)
expr_stmt|;
name|map
operator|->
name|size
operator|=
name|size
expr_stmt|;
comment|/* We should probably use a more intelligent heuristic for default probe length. */
name|limit
operator|=
name|ck_internal_max
argument_list|(
name|n_entries
operator|>>
operator|(
name|CK_RHS_PROBE_L1_SHIFT
operator|+
literal|2
operator|)
argument_list|,
name|CK_RHS_PROBE_L1_DEFAULT
argument_list|)
expr_stmt|;
if|if
condition|(
name|limit
operator|>
name|UINT_MAX
condition|)
name|limit
operator|=
name|UINT_MAX
expr_stmt|;
name|map
operator|->
name|probe_limit
operator|=
operator|(
name|unsigned
name|int
operator|)
name|limit
expr_stmt|;
name|map
operator|->
name|probe_maximum
operator|=
literal|0
expr_stmt|;
name|map
operator|->
name|capacity
operator|=
name|n_entries
expr_stmt|;
name|map
operator|->
name|step
operator|=
name|ck_internal_bsf
argument_list|(
name|n_entries
argument_list|)
expr_stmt|;
name|map
operator|->
name|mask
operator|=
name|n_entries
operator|-
literal|1
expr_stmt|;
name|map
operator|->
name|n_entries
operator|=
literal|0
expr_stmt|;
name|map
operator|->
name|max_entries
operator|=
operator|(
name|map
operator|->
name|capacity
operator|*
operator|(
name|unsigned
name|long
operator|)
name|hs
operator|->
name|load_factor
operator|)
operator|/
literal|100
expr_stmt|;
comment|/* Align map allocation to cache line. */
if|if
condition|(
name|map
operator|->
name|read_mostly
condition|)
block|{
name|map
operator|->
name|entries
operator|.
name|no_entries
operator|.
name|entries
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
operator|(
name|uintptr_t
operator|)
operator|&
name|map
index|[
literal|1
index|]
operator|+
name|CK_MD_CACHELINE
operator|-
literal|1
operator|)
operator|&
operator|~
operator|(
name|CK_MD_CACHELINE
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
name|map
operator|->
name|entries
operator|.
name|no_entries
operator|.
name|descs
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
operator|(
name|uintptr_t
operator|)
name|map
operator|->
name|entries
operator|.
name|no_entries
operator|.
name|entries
operator|+
operator|(
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
operator|*
name|n_entries
operator|)
operator|+
name|CK_MD_CACHELINE
operator|-
literal|1
operator|)
operator|&
operator|~
operator|(
name|CK_MD_CACHELINE
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
name|memset
argument_list|(
name|map
operator|->
name|entries
operator|.
name|no_entries
operator|.
name|entries
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
operator|*
name|n_entries
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|map
operator|->
name|entries
operator|.
name|no_entries
operator|.
name|descs
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ck_rhs_no_entry_desc
argument_list|)
operator|*
name|n_entries
argument_list|)
expr_stmt|;
name|map
operator|->
name|offset_mask
operator|=
operator|(
name|CK_MD_CACHELINE
operator|/
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
operator|)
operator|-
literal|1
expr_stmt|;
name|map
operator|->
name|probe_func
operator|=
name|ck_rhs_map_probe_rm
expr_stmt|;
block|}
else|else
block|{
name|map
operator|->
name|entries
operator|.
name|descs
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
operator|(
name|uintptr_t
operator|)
operator|&
name|map
index|[
literal|1
index|]
operator|+
name|CK_MD_CACHELINE
operator|-
literal|1
operator|)
operator|&
operator|~
operator|(
name|CK_MD_CACHELINE
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
name|memset
argument_list|(
name|map
operator|->
name|entries
operator|.
name|descs
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ck_rhs_entry_desc
argument_list|)
operator|*
name|n_entries
argument_list|)
expr_stmt|;
name|map
operator|->
name|offset_mask
operator|=
operator|(
name|CK_MD_CACHELINE
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|ck_rhs_entry_desc
argument_list|)
operator|)
operator|-
literal|1
expr_stmt|;
name|map
operator|->
name|probe_func
operator|=
name|ck_rhs_map_probe
expr_stmt|;
block|}
name|memset
argument_list|(
name|map
operator|->
name|generation
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|map
operator|->
name|generation
argument_list|)
expr_stmt|;
comment|/* Commit entries purge with respect to map publication. */
name|ck_pr_fence_store
argument_list|()
expr_stmt|;
return|return
name|map
return|;
block|}
end_function

begin_function
name|bool
name|ck_rhs_reset_size
parameter_list|(
name|struct
name|ck_rhs
modifier|*
name|hs
parameter_list|,
name|unsigned
name|long
name|capacity
parameter_list|)
block|{
name|struct
name|ck_rhs_map
modifier|*
name|map
decl_stmt|,
modifier|*
name|previous
decl_stmt|;
name|previous
operator|=
name|hs
operator|->
name|map
expr_stmt|;
name|map
operator|=
name|ck_rhs_map_create
argument_list|(
name|hs
argument_list|,
name|capacity
argument_list|)
expr_stmt|;
if|if
condition|(
name|map
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|ck_pr_store_ptr
argument_list|(
operator|&
name|hs
operator|->
name|map
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|ck_rhs_map_destroy
argument_list|(
name|hs
operator|->
name|m
argument_list|,
name|previous
argument_list|,
name|true
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_function
name|bool
name|ck_rhs_reset
parameter_list|(
name|struct
name|ck_rhs
modifier|*
name|hs
parameter_list|)
block|{
name|struct
name|ck_rhs_map
modifier|*
name|previous
decl_stmt|;
name|previous
operator|=
name|hs
operator|->
name|map
expr_stmt|;
return|return
name|ck_rhs_reset_size
argument_list|(
name|hs
argument_list|,
name|previous
operator|->
name|capacity
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|unsigned
name|long
name|ck_rhs_map_probe_next
parameter_list|(
name|struct
name|ck_rhs_map
modifier|*
name|map
parameter_list|,
name|unsigned
name|long
name|offset
parameter_list|,
name|unsigned
name|long
name|probes
parameter_list|)
block|{
if|if
condition|(
name|probes
operator|&
name|map
operator|->
name|offset_mask
condition|)
block|{
name|offset
operator|=
operator|(
name|offset
operator|&
operator|~
name|map
operator|->
name|offset_mask
operator|)
operator|+
operator|(
operator|(
name|offset
operator|+
literal|1
operator|)
operator|&
name|map
operator|->
name|offset_mask
operator|)
expr_stmt|;
return|return
name|offset
return|;
block|}
else|else
return|return
operator|(
name|offset
operator|+
name|probes
operator|)
operator|&
name|map
operator|->
name|mask
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|unsigned
name|long
name|ck_rhs_map_probe_prev
parameter_list|(
name|struct
name|ck_rhs_map
modifier|*
name|map
parameter_list|,
name|unsigned
name|long
name|offset
parameter_list|,
name|unsigned
name|long
name|probes
parameter_list|)
block|{
if|if
condition|(
name|probes
operator|&
name|map
operator|->
name|offset_mask
condition|)
block|{
name|offset
operator|=
operator|(
name|offset
operator|&
operator|~
name|map
operator|->
name|offset_mask
operator|)
operator|+
operator|(
operator|(
name|offset
operator|-
literal|1
operator|)
operator|&
name|map
operator|->
name|offset_mask
operator|)
expr_stmt|;
return|return
name|offset
return|;
block|}
else|else
return|return
operator|(
operator|(
name|offset
operator|-
name|probes
operator|)
operator|&
name|map
operator|->
name|mask
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|ck_rhs_map_bound_set
parameter_list|(
name|struct
name|ck_rhs_map
modifier|*
name|m
parameter_list|,
name|unsigned
name|long
name|h
parameter_list|,
name|unsigned
name|long
name|n_probes
parameter_list|)
block|{
name|unsigned
name|long
name|offset
init|=
name|h
operator|&
name|m
operator|->
name|mask
decl_stmt|;
name|struct
name|ck_rhs_entry_desc
modifier|*
name|desc
decl_stmt|;
if|if
condition|(
name|n_probes
operator|>
name|m
operator|->
name|probe_maximum
condition|)
name|ck_pr_store_uint
argument_list|(
operator|&
name|m
operator|->
name|probe_maximum
argument_list|,
name|n_probes
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|m
operator|->
name|read_mostly
operator|)
condition|)
block|{
name|desc
operator|=
operator|&
name|m
operator|->
name|entries
operator|.
name|descs
index|[
name|offset
index|]
expr_stmt|;
if|if
condition|(
name|desc
operator|->
name|probe_bound
operator|<
name|n_probes
condition|)
block|{
if|if
condition|(
name|n_probes
operator|>
name|CK_RHS_WORD_MAX
condition|)
name|n_probes
operator|=
name|CK_RHS_WORD_MAX
expr_stmt|;
name|CK_RHS_STORE
argument_list|(
operator|&
name|desc
operator|->
name|probe_bound
argument_list|,
name|n_probes
argument_list|)
expr_stmt|;
name|ck_pr_fence_store
argument_list|()
expr_stmt|;
block|}
block|}
return|return;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|unsigned
name|int
name|ck_rhs_map_bound_get
parameter_list|(
name|struct
name|ck_rhs_map
modifier|*
name|m
parameter_list|,
name|unsigned
name|long
name|h
parameter_list|)
block|{
name|unsigned
name|long
name|offset
init|=
name|h
operator|&
name|m
operator|->
name|mask
decl_stmt|;
name|unsigned
name|int
name|r
init|=
name|CK_RHS_WORD_MAX
decl_stmt|;
if|if
condition|(
name|m
operator|->
name|read_mostly
condition|)
name|r
operator|=
name|ck_pr_load_uint
argument_list|(
operator|&
name|m
operator|->
name|probe_maximum
argument_list|)
expr_stmt|;
else|else
block|{
name|r
operator|=
name|CK_RHS_LOAD
argument_list|(
operator|&
name|m
operator|->
name|entries
operator|.
name|descs
index|[
name|offset
index|]
operator|.
name|probe_bound
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|CK_RHS_WORD_MAX
condition|)
name|r
operator|=
name|ck_pr_load_uint
argument_list|(
operator|&
name|m
operator|->
name|probe_maximum
argument_list|)
expr_stmt|;
block|}
return|return
name|r
return|;
block|}
end_function

begin_function
name|bool
name|ck_rhs_grow
parameter_list|(
name|struct
name|ck_rhs
modifier|*
name|hs
parameter_list|,
name|unsigned
name|long
name|capacity
parameter_list|)
block|{
name|struct
name|ck_rhs_map
modifier|*
name|map
decl_stmt|,
modifier|*
name|update
decl_stmt|;
specifier|const
name|void
modifier|*
name|previous
decl_stmt|,
modifier|*
name|prev_saved
decl_stmt|;
name|unsigned
name|long
name|k
decl_stmt|,
name|offset
decl_stmt|,
name|probes
decl_stmt|;
name|restart
label|:
name|map
operator|=
name|hs
operator|->
name|map
expr_stmt|;
if|if
condition|(
name|map
operator|->
name|capacity
operator|>
name|capacity
condition|)
return|return
name|false
return|;
name|update
operator|=
name|ck_rhs_map_create
argument_list|(
name|hs
argument_list|,
name|capacity
argument_list|)
expr_stmt|;
if|if
condition|(
name|update
operator|==
name|NULL
condition|)
return|return
name|false
return|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|map
operator|->
name|capacity
condition|;
name|k
operator|++
control|)
block|{
name|unsigned
name|long
name|h
decl_stmt|;
name|prev_saved
operator|=
name|previous
operator|=
name|ck_rhs_entry
argument_list|(
name|map
argument_list|,
name|k
argument_list|)
expr_stmt|;
if|if
condition|(
name|previous
operator|==
name|CK_RHS_EMPTY
condition|)
continue|continue;
ifdef|#
directive|ifdef
name|CK_RHS_PP
if|if
condition|(
name|hs
operator|->
name|mode
operator|&
name|CK_RHS_MODE_OBJECT
condition|)
name|previous
operator|=
name|CK_RHS_VMA
argument_list|(
name|previous
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|h
operator|=
name|hs
operator|->
name|hf
argument_list|(
name|previous
argument_list|,
name|hs
operator|->
name|seed
argument_list|)
expr_stmt|;
name|offset
operator|=
name|h
operator|&
name|update
operator|->
name|mask
expr_stmt|;
name|probes
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
specifier|const
name|void
modifier|*
modifier|*
name|cursor
init|=
name|ck_rhs_entry_addr
argument_list|(
name|update
argument_list|,
name|offset
argument_list|)
decl_stmt|;
if|if
condition|(
name|probes
operator|++
operator|==
name|update
operator|->
name|probe_limit
condition|)
block|{
comment|/* 				 * We have hit the probe limit, map needs to be even larger. 				 */
name|ck_rhs_map_destroy
argument_list|(
name|hs
operator|->
name|m
argument_list|,
name|update
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|capacity
operator|<<=
literal|1
expr_stmt|;
goto|goto
name|restart
goto|;
block|}
if|if
condition|(
name|CK_CC_LIKELY
argument_list|(
operator|*
name|cursor
operator|==
name|CK_RHS_EMPTY
argument_list|)
condition|)
block|{
operator|*
name|cursor
operator|=
name|prev_saved
expr_stmt|;
name|update
operator|->
name|n_entries
operator|++
expr_stmt|;
name|ck_rhs_set_probes
argument_list|(
name|update
argument_list|,
name|offset
argument_list|,
name|probes
argument_list|)
expr_stmt|;
name|ck_rhs_map_bound_set
argument_list|(
name|update
argument_list|,
name|h
argument_list|,
name|probes
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|ck_rhs_probes
argument_list|(
name|update
argument_list|,
name|offset
argument_list|)
operator|<
name|probes
condition|)
block|{
specifier|const
name|void
modifier|*
name|tmp
init|=
name|prev_saved
decl_stmt|;
name|unsigned
name|int
name|old_probes
decl_stmt|;
name|prev_saved
operator|=
name|previous
operator|=
operator|*
name|cursor
expr_stmt|;
ifdef|#
directive|ifdef
name|CK_RHS_PP
if|if
condition|(
name|hs
operator|->
name|mode
operator|&
name|CK_RHS_MODE_OBJECT
condition|)
name|previous
operator|=
name|CK_RHS_VMA
argument_list|(
name|previous
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|*
name|cursor
operator|=
name|tmp
expr_stmt|;
name|ck_rhs_map_bound_set
argument_list|(
name|update
argument_list|,
name|h
argument_list|,
name|probes
argument_list|)
expr_stmt|;
name|h
operator|=
name|hs
operator|->
name|hf
argument_list|(
name|previous
argument_list|,
name|hs
operator|->
name|seed
argument_list|)
expr_stmt|;
name|old_probes
operator|=
name|ck_rhs_probes
argument_list|(
name|update
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|ck_rhs_set_probes
argument_list|(
name|update
argument_list|,
name|offset
argument_list|,
name|probes
argument_list|)
expr_stmt|;
name|probes
operator|=
name|old_probes
operator|-
literal|1
expr_stmt|;
continue|continue;
block|}
name|ck_rhs_wanted_inc
argument_list|(
name|update
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|offset
operator|=
name|ck_rhs_map_probe_next
argument_list|(
name|update
argument_list|,
name|offset
argument_list|,
name|probes
argument_list|)
expr_stmt|;
block|}
block|}
name|ck_pr_fence_store
argument_list|()
expr_stmt|;
name|ck_pr_store_ptr
argument_list|(
operator|&
name|hs
operator|->
name|map
argument_list|,
name|update
argument_list|)
expr_stmt|;
name|ck_rhs_map_destroy
argument_list|(
name|hs
operator|->
name|m
argument_list|,
name|map
argument_list|,
name|true
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_function
name|bool
name|ck_rhs_rebuild
parameter_list|(
name|struct
name|ck_rhs
modifier|*
name|hs
parameter_list|)
block|{
return|return
name|ck_rhs_grow
argument_list|(
name|hs
argument_list|,
name|hs
operator|->
name|map
operator|->
name|capacity
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|long
name|ck_rhs_map_probe_rm
parameter_list|(
name|struct
name|ck_rhs
modifier|*
name|hs
parameter_list|,
name|struct
name|ck_rhs_map
modifier|*
name|map
parameter_list|,
name|unsigned
name|long
modifier|*
name|n_probes
parameter_list|,
name|long
modifier|*
name|priority
parameter_list|,
name|unsigned
name|long
name|h
parameter_list|,
specifier|const
name|void
modifier|*
name|key
parameter_list|,
specifier|const
name|void
modifier|*
modifier|*
name|object
parameter_list|,
name|unsigned
name|long
name|probe_limit
parameter_list|,
name|enum
name|ck_rhs_probe_behavior
name|behavior
parameter_list|)
block|{
specifier|const
name|void
modifier|*
name|k
decl_stmt|;
specifier|const
name|void
modifier|*
name|compare
decl_stmt|;
name|long
name|pr
init|=
operator|-
literal|1
decl_stmt|;
name|unsigned
name|long
name|offset
decl_stmt|,
name|probes
decl_stmt|,
name|opl
decl_stmt|;
ifdef|#
directive|ifdef
name|CK_RHS_PP
comment|/* If we are storing object pointers, then we may leverage pointer packing. */
name|unsigned
name|long
name|hv
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|hs
operator|->
name|mode
operator|&
name|CK_RHS_MODE_OBJECT
condition|)
block|{
name|hv
operator|=
operator|(
name|h
operator|>>
literal|25
operator|)
operator|&
name|CK_RHS_KEY_MASK
expr_stmt|;
name|compare
operator|=
name|CK_RHS_VMA
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|compare
operator|=
name|key
expr_stmt|;
block|}
else|#
directive|else
name|compare
operator|=
name|key
expr_stmt|;
endif|#
directive|endif
operator|*
name|object
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|behavior
operator|!=
name|CK_RHS_PROBE_ROBIN_HOOD
condition|)
block|{
name|probes
operator|=
literal|0
expr_stmt|;
name|offset
operator|=
name|h
operator|&
name|map
operator|->
name|mask
expr_stmt|;
block|}
else|else
block|{
comment|/* Restart from the bucket we were previously in */
name|probes
operator|=
operator|*
name|n_probes
expr_stmt|;
name|offset
operator|=
name|ck_rhs_map_probe_next
argument_list|(
name|map
argument_list|,
operator|*
name|priority
argument_list|,
name|probes
argument_list|)
expr_stmt|;
block|}
name|opl
operator|=
name|probe_limit
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|probes
operator|++
operator|==
name|probe_limit
condition|)
block|{
if|if
condition|(
name|probe_limit
operator|==
name|opl
operator|||
name|pr
operator|!=
operator|-
literal|1
condition|)
block|{
name|k
operator|=
name|CK_RHS_EMPTY
expr_stmt|;
goto|goto
name|leave
goto|;
block|}
comment|/* 			 * If no eligible slot has been found yet, continue probe 			 * sequence with original probe limit. 			 */
name|probe_limit
operator|=
name|opl
expr_stmt|;
block|}
name|k
operator|=
name|ck_pr_load_ptr
argument_list|(
operator|&
name|map
operator|->
name|entries
operator|.
name|no_entries
operator|.
name|entries
index|[
name|offset
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|==
name|CK_RHS_EMPTY
condition|)
goto|goto
name|leave
goto|;
if|if
condition|(
name|behavior
operator|!=
name|CK_RHS_PROBE_NO_RH
condition|)
block|{
name|struct
name|ck_rhs_entry_desc
modifier|*
name|desc
init|=
operator|(
name|void
operator|*
operator|)
operator|&
name|map
operator|->
name|entries
operator|.
name|no_entries
operator|.
name|descs
index|[
name|offset
index|]
decl_stmt|;
if|if
condition|(
name|pr
operator|==
operator|-
literal|1
operator|&&
name|desc
operator|->
name|in_rh
operator|==
name|false
operator|&&
name|desc
operator|->
name|probes
operator|<
name|probes
condition|)
block|{
name|pr
operator|=
name|offset
expr_stmt|;
operator|*
name|n_probes
operator|=
name|probes
expr_stmt|;
if|if
condition|(
name|behavior
operator|==
name|CK_RHS_PROBE_RH
operator|||
name|behavior
operator|==
name|CK_RHS_PROBE_ROBIN_HOOD
condition|)
block|{
name|k
operator|=
name|CK_RHS_EMPTY
expr_stmt|;
goto|goto
name|leave
goto|;
block|}
block|}
block|}
if|if
condition|(
name|behavior
operator|!=
name|CK_RHS_PROBE_ROBIN_HOOD
condition|)
block|{
ifdef|#
directive|ifdef
name|CK_RHS_PP
if|if
condition|(
name|hs
operator|->
name|mode
operator|&
name|CK_RHS_MODE_OBJECT
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|uintptr_t
operator|)
name|k
operator|>>
name|CK_MD_VMA_BITS
operator|)
operator|!=
name|hv
condition|)
block|{
name|offset
operator|=
name|ck_rhs_map_probe_next
argument_list|(
name|map
argument_list|,
name|offset
argument_list|,
name|probes
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|k
operator|=
name|CK_RHS_VMA
argument_list|(
name|k
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|k
operator|==
name|compare
condition|)
goto|goto
name|leave
goto|;
if|if
condition|(
name|hs
operator|->
name|compare
operator|==
name|NULL
condition|)
block|{
name|offset
operator|=
name|ck_rhs_map_probe_next
argument_list|(
name|map
argument_list|,
name|offset
argument_list|,
name|probes
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|hs
operator|->
name|compare
argument_list|(
name|k
argument_list|,
name|key
argument_list|)
operator|==
name|true
condition|)
goto|goto
name|leave
goto|;
block|}
name|offset
operator|=
name|ck_rhs_map_probe_next
argument_list|(
name|map
argument_list|,
name|offset
argument_list|,
name|probes
argument_list|)
expr_stmt|;
block|}
name|leave
label|:
if|if
condition|(
name|probes
operator|>
name|probe_limit
condition|)
block|{
name|offset
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
operator|*
name|object
operator|=
name|k
expr_stmt|;
block|}
if|if
condition|(
name|pr
operator|==
operator|-
literal|1
condition|)
operator|*
name|n_probes
operator|=
name|probes
expr_stmt|;
operator|*
name|priority
operator|=
name|pr
expr_stmt|;
return|return
name|offset
return|;
block|}
end_function

begin_function
specifier|static
name|long
name|ck_rhs_map_probe
parameter_list|(
name|struct
name|ck_rhs
modifier|*
name|hs
parameter_list|,
name|struct
name|ck_rhs_map
modifier|*
name|map
parameter_list|,
name|unsigned
name|long
modifier|*
name|n_probes
parameter_list|,
name|long
modifier|*
name|priority
parameter_list|,
name|unsigned
name|long
name|h
parameter_list|,
specifier|const
name|void
modifier|*
name|key
parameter_list|,
specifier|const
name|void
modifier|*
modifier|*
name|object
parameter_list|,
name|unsigned
name|long
name|probe_limit
parameter_list|,
name|enum
name|ck_rhs_probe_behavior
name|behavior
parameter_list|)
block|{
specifier|const
name|void
modifier|*
name|k
decl_stmt|;
specifier|const
name|void
modifier|*
name|compare
decl_stmt|;
name|long
name|pr
init|=
operator|-
literal|1
decl_stmt|;
name|unsigned
name|long
name|offset
decl_stmt|,
name|probes
decl_stmt|,
name|opl
decl_stmt|;
ifdef|#
directive|ifdef
name|CK_RHS_PP
comment|/* If we are storing object pointers, then we may leverage pointer packing. */
name|unsigned
name|long
name|hv
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|hs
operator|->
name|mode
operator|&
name|CK_RHS_MODE_OBJECT
condition|)
block|{
name|hv
operator|=
operator|(
name|h
operator|>>
literal|25
operator|)
operator|&
name|CK_RHS_KEY_MASK
expr_stmt|;
name|compare
operator|=
name|CK_RHS_VMA
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|compare
operator|=
name|key
expr_stmt|;
block|}
else|#
directive|else
name|compare
operator|=
name|key
expr_stmt|;
endif|#
directive|endif
operator|*
name|object
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|behavior
operator|!=
name|CK_RHS_PROBE_ROBIN_HOOD
condition|)
block|{
name|probes
operator|=
literal|0
expr_stmt|;
name|offset
operator|=
name|h
operator|&
name|map
operator|->
name|mask
expr_stmt|;
block|}
else|else
block|{
comment|/* Restart from the bucket we were previously in */
name|probes
operator|=
operator|*
name|n_probes
expr_stmt|;
name|offset
operator|=
name|ck_rhs_map_probe_next
argument_list|(
name|map
argument_list|,
operator|*
name|priority
argument_list|,
name|probes
argument_list|)
expr_stmt|;
block|}
name|opl
operator|=
name|probe_limit
expr_stmt|;
if|if
condition|(
name|behavior
operator|==
name|CK_RHS_PROBE_INSERT
condition|)
name|probe_limit
operator|=
name|ck_rhs_map_bound_get
argument_list|(
name|map
argument_list|,
name|h
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|probes
operator|++
operator|==
name|probe_limit
condition|)
block|{
if|if
condition|(
name|probe_limit
operator|==
name|opl
operator|||
name|pr
operator|!=
operator|-
literal|1
condition|)
block|{
name|k
operator|=
name|CK_RHS_EMPTY
expr_stmt|;
goto|goto
name|leave
goto|;
block|}
comment|/* 			 * If no eligible slot has been found yet, continue probe 			 * sequence with original probe limit. 			 */
name|probe_limit
operator|=
name|opl
expr_stmt|;
block|}
name|k
operator|=
name|ck_pr_load_ptr
argument_list|(
operator|&
name|map
operator|->
name|entries
operator|.
name|descs
index|[
name|offset
index|]
operator|.
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|==
name|CK_RHS_EMPTY
condition|)
goto|goto
name|leave
goto|;
if|if
condition|(
operator|(
name|behavior
operator|!=
name|CK_RHS_PROBE_NO_RH
operator|)
condition|)
block|{
name|struct
name|ck_rhs_entry_desc
modifier|*
name|desc
init|=
operator|&
name|map
operator|->
name|entries
operator|.
name|descs
index|[
name|offset
index|]
decl_stmt|;
if|if
condition|(
name|pr
operator|==
operator|-
literal|1
operator|&&
name|desc
operator|->
name|in_rh
operator|==
name|false
operator|&&
name|desc
operator|->
name|probes
operator|<
name|probes
condition|)
block|{
name|pr
operator|=
name|offset
expr_stmt|;
operator|*
name|n_probes
operator|=
name|probes
expr_stmt|;
if|if
condition|(
name|behavior
operator|==
name|CK_RHS_PROBE_RH
operator|||
name|behavior
operator|==
name|CK_RHS_PROBE_ROBIN_HOOD
condition|)
block|{
name|k
operator|=
name|CK_RHS_EMPTY
expr_stmt|;
goto|goto
name|leave
goto|;
block|}
block|}
block|}
if|if
condition|(
name|behavior
operator|!=
name|CK_RHS_PROBE_ROBIN_HOOD
condition|)
block|{
ifdef|#
directive|ifdef
name|CK_RHS_PP
if|if
condition|(
name|hs
operator|->
name|mode
operator|&
name|CK_RHS_MODE_OBJECT
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|uintptr_t
operator|)
name|k
operator|>>
name|CK_MD_VMA_BITS
operator|)
operator|!=
name|hv
condition|)
block|{
name|offset
operator|=
name|ck_rhs_map_probe_next
argument_list|(
name|map
argument_list|,
name|offset
argument_list|,
name|probes
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|k
operator|=
name|CK_RHS_VMA
argument_list|(
name|k
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|k
operator|==
name|compare
condition|)
goto|goto
name|leave
goto|;
if|if
condition|(
name|hs
operator|->
name|compare
operator|==
name|NULL
condition|)
block|{
name|offset
operator|=
name|ck_rhs_map_probe_next
argument_list|(
name|map
argument_list|,
name|offset
argument_list|,
name|probes
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|hs
operator|->
name|compare
argument_list|(
name|k
argument_list|,
name|key
argument_list|)
operator|==
name|true
condition|)
goto|goto
name|leave
goto|;
block|}
name|offset
operator|=
name|ck_rhs_map_probe_next
argument_list|(
name|map
argument_list|,
name|offset
argument_list|,
name|probes
argument_list|)
expr_stmt|;
block|}
name|leave
label|:
if|if
condition|(
name|probes
operator|>
name|probe_limit
condition|)
block|{
name|offset
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
operator|*
name|object
operator|=
name|k
expr_stmt|;
block|}
if|if
condition|(
name|pr
operator|==
operator|-
literal|1
condition|)
operator|*
name|n_probes
operator|=
name|probes
expr_stmt|;
operator|*
name|priority
operator|=
name|pr
expr_stmt|;
return|return
name|offset
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
specifier|const
name|void
modifier|*
name|ck_rhs_marshal
parameter_list|(
name|unsigned
name|int
name|mode
parameter_list|,
specifier|const
name|void
modifier|*
name|key
parameter_list|,
name|unsigned
name|long
name|h
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|CK_RHS_PP
specifier|const
name|void
modifier|*
name|insert
decl_stmt|;
if|if
condition|(
name|mode
operator|&
name|CK_RHS_MODE_OBJECT
condition|)
block|{
name|insert
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|CK_RHS_VMA
argument_list|(
name|key
argument_list|)
operator||
operator|(
operator|(
name|h
operator|>>
literal|25
operator|)
operator|<<
name|CK_MD_VMA_BITS
operator|)
operator|)
expr_stmt|;
block|}
else|else
block|{
name|insert
operator|=
name|key
expr_stmt|;
block|}
return|return
name|insert
return|;
else|#
directive|else
operator|(
name|void
operator|)
name|mode
expr_stmt|;
operator|(
name|void
operator|)
name|h
expr_stmt|;
return|return
name|key
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|bool
name|ck_rhs_gc
parameter_list|(
name|struct
name|ck_rhs
modifier|*
name|hs
parameter_list|)
block|{
name|unsigned
name|long
name|i
decl_stmt|;
name|struct
name|ck_rhs_map
modifier|*
name|map
init|=
name|hs
operator|->
name|map
decl_stmt|;
name|unsigned
name|int
name|max_probes
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|map
operator|->
name|capacity
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ck_rhs_probes
argument_list|(
name|map
argument_list|,
name|i
argument_list|)
operator|>
name|max_probes
condition|)
name|max_probes
operator|=
name|ck_rhs_probes
argument_list|(
name|map
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|map
operator|->
name|probe_maximum
operator|=
name|max_probes
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ck_rhs_add_wanted
parameter_list|(
name|struct
name|ck_rhs
modifier|*
name|hs
parameter_list|,
name|long
name|end_offset
parameter_list|,
name|long
name|old_slot
parameter_list|,
name|unsigned
name|long
name|h
parameter_list|)
block|{
name|struct
name|ck_rhs_map
modifier|*
name|map
init|=
name|hs
operator|->
name|map
decl_stmt|;
name|long
name|offset
decl_stmt|;
name|unsigned
name|int
name|probes
init|=
literal|1
decl_stmt|;
name|bool
name|found_slot
init|=
name|false
decl_stmt|;
name|struct
name|ck_rhs_entry_desc
modifier|*
name|desc
decl_stmt|;
name|offset
operator|=
name|h
operator|&
name|map
operator|->
name|mask
expr_stmt|;
if|if
condition|(
name|old_slot
operator|==
operator|-
literal|1
condition|)
name|found_slot
operator|=
name|true
expr_stmt|;
while|while
condition|(
name|offset
operator|!=
name|end_offset
condition|)
block|{
if|if
condition|(
name|offset
operator|==
name|old_slot
condition|)
name|found_slot
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|found_slot
condition|)
block|{
name|desc
operator|=
name|ck_rhs_desc
argument_list|(
name|map
argument_list|,
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|desc
operator|->
name|wanted
operator|<
name|CK_RHS_MAX_WANTED
condition|)
name|desc
operator|->
name|wanted
operator|++
expr_stmt|;
block|}
name|offset
operator|=
name|ck_rhs_map_probe_next
argument_list|(
name|map
argument_list|,
name|offset
argument_list|,
name|probes
argument_list|)
expr_stmt|;
name|probes
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|unsigned
name|long
name|ck_rhs_remove_wanted
parameter_list|(
name|struct
name|ck_rhs
modifier|*
name|hs
parameter_list|,
name|long
name|offset
parameter_list|,
name|long
name|limit
parameter_list|)
block|{
name|struct
name|ck_rhs_map
modifier|*
name|map
init|=
name|hs
operator|->
name|map
decl_stmt|;
name|int
name|probes
init|=
name|ck_rhs_probes
argument_list|(
name|map
argument_list|,
name|offset
argument_list|)
decl_stmt|;
name|bool
name|do_remove
init|=
name|true
decl_stmt|;
name|struct
name|ck_rhs_entry_desc
modifier|*
name|desc
decl_stmt|;
while|while
condition|(
name|probes
operator|>
literal|1
condition|)
block|{
name|probes
operator|--
expr_stmt|;
name|offset
operator|=
name|ck_rhs_map_probe_prev
argument_list|(
name|map
argument_list|,
name|offset
argument_list|,
name|probes
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|==
name|limit
condition|)
name|do_remove
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|do_remove
condition|)
block|{
name|desc
operator|=
name|ck_rhs_desc
argument_list|(
name|map
argument_list|,
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|desc
operator|->
name|wanted
operator|!=
name|CK_RHS_MAX_WANTED
condition|)
name|desc
operator|->
name|wanted
operator|--
expr_stmt|;
block|}
block|}
return|return
name|offset
return|;
block|}
end_function

begin_function
specifier|static
name|long
name|ck_rhs_get_first_offset
parameter_list|(
name|struct
name|ck_rhs_map
modifier|*
name|map
parameter_list|,
name|unsigned
name|long
name|offset
parameter_list|,
name|unsigned
name|int
name|probes
parameter_list|)
block|{
while|while
condition|(
name|probes
operator|>
operator|(
name|unsigned
name|long
operator|)
name|map
operator|->
name|offset_mask
operator|+
literal|1
condition|)
block|{
name|offset
operator|-=
operator|(
operator|(
name|probes
operator|-
literal|1
operator|)
operator|&
operator|~
name|map
operator|->
name|offset_mask
operator|)
expr_stmt|;
name|offset
operator|&=
name|map
operator|->
name|mask
expr_stmt|;
name|offset
operator|=
operator|(
name|offset
operator|&
operator|~
name|map
operator|->
name|offset_mask
operator|)
operator|+
operator|(
operator|(
name|offset
operator|-
name|map
operator|->
name|offset_mask
operator|)
operator|&
name|map
operator|->
name|offset_mask
operator|)
expr_stmt|;
name|probes
operator|-=
name|map
operator|->
name|offset_mask
operator|+
literal|1
expr_stmt|;
block|}
return|return
operator|(
operator|(
name|offset
operator|&
operator|~
name|map
operator|->
name|offset_mask
operator|)
operator|+
operator|(
operator|(
name|offset
operator|-
operator|(
name|probes
operator|-
literal|1
operator|)
operator|)
operator|&
name|map
operator|->
name|offset_mask
operator|)
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|CK_RHS_MAX_RH
value|512
end_define

begin_function
specifier|static
name|int
name|ck_rhs_put_robin_hood
parameter_list|(
name|struct
name|ck_rhs
modifier|*
name|hs
parameter_list|,
name|long
name|orig_slot
parameter_list|,
name|struct
name|ck_rhs_entry_desc
modifier|*
name|desc
parameter_list|)
block|{
name|long
name|slot
decl_stmt|,
name|first
decl_stmt|;
specifier|const
name|void
modifier|*
name|object
decl_stmt|,
modifier|*
name|insert
decl_stmt|;
name|unsigned
name|long
name|n_probes
decl_stmt|;
name|struct
name|ck_rhs_map
modifier|*
name|map
decl_stmt|;
name|unsigned
name|long
name|h
init|=
literal|0
decl_stmt|;
name|long
name|prev
decl_stmt|;
name|void
modifier|*
name|key
decl_stmt|;
name|long
name|prevs
index|[
name|CK_RHS_MAX_RH
index|]
decl_stmt|;
name|unsigned
name|int
name|prevs_nb
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|map
operator|=
name|hs
operator|->
name|map
expr_stmt|;
name|first
operator|=
name|orig_slot
expr_stmt|;
name|n_probes
operator|=
name|desc
operator|->
name|probes
expr_stmt|;
name|restart
label|:
name|key
operator|=
name|CK_CC_DECONST_PTR
argument_list|(
name|ck_rhs_entry
argument_list|(
name|map
argument_list|,
name|first
argument_list|)
argument_list|)
expr_stmt|;
name|insert
operator|=
name|key
expr_stmt|;
ifdef|#
directive|ifdef
name|CK_RHS_PP
if|if
condition|(
name|hs
operator|->
name|mode
operator|&
name|CK_RHS_MODE_OBJECT
condition|)
name|key
operator|=
name|CK_RHS_VMA
argument_list|(
name|key
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|orig_slot
operator|=
name|first
expr_stmt|;
name|ck_rhs_set_rh
argument_list|(
name|map
argument_list|,
name|orig_slot
argument_list|)
expr_stmt|;
name|slot
operator|=
name|map
operator|->
name|probe_func
argument_list|(
name|hs
argument_list|,
name|map
argument_list|,
operator|&
name|n_probes
argument_list|,
operator|&
name|first
argument_list|,
name|h
argument_list|,
name|key
argument_list|,
operator|&
name|object
argument_list|,
name|map
operator|->
name|probe_limit
argument_list|,
name|prevs_nb
operator|==
name|CK_RHS_MAX_RH
condition|?
name|CK_RHS_PROBE_NO_RH
else|:
name|CK_RHS_PROBE_ROBIN_HOOD
argument_list|)
expr_stmt|;
if|if
condition|(
name|slot
operator|==
operator|-
literal|1
operator|&&
name|first
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|ck_rhs_grow
argument_list|(
name|hs
argument_list|,
name|map
operator|->
name|capacity
operator|<<
literal|1
argument_list|)
operator|==
name|false
condition|)
block|{
name|desc
operator|->
name|in_rh
operator|=
name|false
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|prevs_nb
condition|;
name|i
operator|++
control|)
name|ck_rhs_unset_rh
argument_list|(
name|map
argument_list|,
name|prevs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|1
return|;
block|}
if|if
condition|(
name|first
operator|!=
operator|-
literal|1
condition|)
block|{
name|desc
operator|=
name|ck_rhs_desc
argument_list|(
name|map
argument_list|,
name|first
argument_list|)
expr_stmt|;
name|int
name|old_probes
init|=
name|desc
operator|->
name|probes
decl_stmt|;
name|desc
operator|->
name|probes
operator|=
name|n_probes
expr_stmt|;
name|h
operator|=
name|ck_rhs_get_first_offset
argument_list|(
name|map
argument_list|,
name|first
argument_list|,
name|n_probes
argument_list|)
expr_stmt|;
name|ck_rhs_map_bound_set
argument_list|(
name|map
argument_list|,
name|h
argument_list|,
name|n_probes
argument_list|)
expr_stmt|;
name|prev
operator|=
name|orig_slot
expr_stmt|;
name|prevs
index|[
name|prevs_nb
operator|++
index|]
operator|=
name|prev
expr_stmt|;
name|n_probes
operator|=
name|old_probes
expr_stmt|;
goto|goto
name|restart
goto|;
block|}
else|else
block|{
comment|/* An empty slot was found. */
name|h
operator|=
name|ck_rhs_get_first_offset
argument_list|(
name|map
argument_list|,
name|slot
argument_list|,
name|n_probes
argument_list|)
expr_stmt|;
name|ck_rhs_map_bound_set
argument_list|(
name|map
argument_list|,
name|h
argument_list|,
name|n_probes
argument_list|)
expr_stmt|;
name|ck_pr_store_ptr
argument_list|(
name|ck_rhs_entry_addr
argument_list|(
name|map
argument_list|,
name|slot
argument_list|)
argument_list|,
name|insert
argument_list|)
expr_stmt|;
name|ck_pr_inc_uint
argument_list|(
operator|&
name|map
operator|->
name|generation
index|[
name|h
operator|&
name|CK_RHS_G_MASK
index|]
argument_list|)
expr_stmt|;
name|ck_pr_fence_atomic_store
argument_list|()
expr_stmt|;
name|ck_rhs_set_probes
argument_list|(
name|map
argument_list|,
name|slot
argument_list|,
name|n_probes
argument_list|)
expr_stmt|;
name|desc
operator|->
name|in_rh
operator|=
literal|0
expr_stmt|;
name|ck_rhs_add_wanted
argument_list|(
name|hs
argument_list|,
name|slot
argument_list|,
name|orig_slot
argument_list|,
name|h
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|prevs_nb
operator|>
literal|0
condition|)
block|{
name|prev
operator|=
name|prevs
index|[
operator|--
name|prevs_nb
index|]
expr_stmt|;
name|ck_pr_store_ptr
argument_list|(
name|ck_rhs_entry_addr
argument_list|(
name|map
argument_list|,
name|orig_slot
argument_list|)
argument_list|,
name|ck_rhs_entry
argument_list|(
name|map
argument_list|,
name|prev
argument_list|)
argument_list|)
expr_stmt|;
name|h
operator|=
name|ck_rhs_get_first_offset
argument_list|(
name|map
argument_list|,
name|orig_slot
argument_list|,
name|desc
operator|->
name|probes
argument_list|)
expr_stmt|;
name|ck_rhs_add_wanted
argument_list|(
name|hs
argument_list|,
name|orig_slot
argument_list|,
name|prev
argument_list|,
name|h
argument_list|)
expr_stmt|;
name|ck_pr_inc_uint
argument_list|(
operator|&
name|map
operator|->
name|generation
index|[
name|h
operator|&
name|CK_RHS_G_MASK
index|]
argument_list|)
expr_stmt|;
name|ck_pr_fence_atomic_store
argument_list|()
expr_stmt|;
name|orig_slot
operator|=
name|prev
expr_stmt|;
name|desc
operator|->
name|in_rh
operator|=
name|false
expr_stmt|;
name|desc
operator|=
name|ck_rhs_desc
argument_list|(
name|map
argument_list|,
name|orig_slot
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ck_rhs_do_backward_shift_delete
parameter_list|(
name|struct
name|ck_rhs
modifier|*
name|hs
parameter_list|,
name|long
name|slot
parameter_list|)
block|{
name|struct
name|ck_rhs_map
modifier|*
name|map
init|=
name|hs
operator|->
name|map
decl_stmt|;
name|struct
name|ck_rhs_entry_desc
modifier|*
name|desc
decl_stmt|,
modifier|*
name|new_desc
init|=
name|NULL
decl_stmt|;
name|unsigned
name|long
name|h
decl_stmt|;
name|desc
operator|=
name|ck_rhs_desc
argument_list|(
name|map
argument_list|,
name|slot
argument_list|)
expr_stmt|;
name|h
operator|=
name|ck_rhs_remove_wanted
argument_list|(
name|hs
argument_list|,
name|slot
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
name|desc
operator|->
name|wanted
operator|>
literal|0
condition|)
block|{
name|unsigned
name|long
name|offset
init|=
literal|0
decl_stmt|,
name|tmp_offset
decl_stmt|;
name|unsigned
name|long
name|wanted_probes
init|=
literal|1
decl_stmt|;
name|unsigned
name|int
name|probe
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|max_probes
decl_stmt|;
comment|/* Find a successor */
while|while
condition|(
name|wanted_probes
operator|<
name|map
operator|->
name|probe_maximum
condition|)
block|{
name|probe
operator|=
name|wanted_probes
expr_stmt|;
name|offset
operator|=
name|ck_rhs_map_probe_next
argument_list|(
name|map
argument_list|,
name|slot
argument_list|,
name|probe
argument_list|)
expr_stmt|;
while|while
condition|(
name|probe
operator|<
name|map
operator|->
name|probe_maximum
condition|)
block|{
name|new_desc
operator|=
name|ck_rhs_desc
argument_list|(
name|map
argument_list|,
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_desc
operator|->
name|probes
operator|==
name|probe
operator|+
literal|1
condition|)
break|break;
name|probe
operator|++
expr_stmt|;
name|offset
operator|=
name|ck_rhs_map_probe_next
argument_list|(
name|map
argument_list|,
name|offset
argument_list|,
name|probe
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|probe
operator|<
name|map
operator|->
name|probe_maximum
condition|)
break|break;
name|wanted_probes
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|wanted_probes
operator|<
name|map
operator|->
name|probe_maximum
operator|)
condition|)
block|{
name|desc
operator|->
name|wanted
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|desc
operator|->
name|probes
operator|=
name|wanted_probes
expr_stmt|;
name|h
operator|=
name|ck_rhs_remove_wanted
argument_list|(
name|hs
argument_list|,
name|offset
argument_list|,
name|slot
argument_list|)
expr_stmt|;
name|ck_pr_store_ptr
argument_list|(
name|ck_rhs_entry_addr
argument_list|(
name|map
argument_list|,
name|slot
argument_list|)
argument_list|,
name|ck_rhs_entry
argument_list|(
name|map
argument_list|,
name|offset
argument_list|)
argument_list|)
expr_stmt|;
name|ck_pr_inc_uint
argument_list|(
operator|&
name|map
operator|->
name|generation
index|[
name|h
operator|&
name|CK_RHS_G_MASK
index|]
argument_list|)
expr_stmt|;
name|ck_pr_fence_atomic_store
argument_list|()
expr_stmt|;
if|if
condition|(
name|wanted_probes
operator|<
name|CK_RHS_WORD_MAX
condition|)
block|{
name|struct
name|ck_rhs_entry_desc
modifier|*
name|hdesc
init|=
name|ck_rhs_desc
argument_list|(
name|map
argument_list|,
name|h
argument_list|)
decl_stmt|;
if|if
condition|(
name|hdesc
operator|->
name|wanted
operator|==
literal|1
condition|)
name|CK_RHS_STORE
argument_list|(
operator|&
name|hdesc
operator|->
name|probe_bound
argument_list|,
name|wanted_probes
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|hdesc
operator|->
name|probe_bound
operator|==
name|CK_RHS_WORD_MAX
operator|||
name|hdesc
operator|->
name|probe_bound
operator|==
name|new_desc
operator|->
name|probes
condition|)
block|{
name|probe
operator|++
expr_stmt|;
if|if
condition|(
name|hdesc
operator|->
name|probe_bound
operator|==
name|CK_RHS_WORD_MAX
condition|)
name|max_probes
operator|=
name|map
operator|->
name|probe_maximum
expr_stmt|;
else|else
block|{
name|max_probes
operator|=
name|hdesc
operator|->
name|probe_bound
expr_stmt|;
name|max_probes
operator|--
expr_stmt|;
block|}
name|tmp_offset
operator|=
name|ck_rhs_map_probe_next
argument_list|(
name|map
argument_list|,
name|offset
argument_list|,
name|probe
argument_list|)
expr_stmt|;
while|while
condition|(
name|probe
operator|<
name|max_probes
condition|)
block|{
if|if
condition|(
name|h
operator|==
operator|(
name|unsigned
name|long
operator|)
name|ck_rhs_get_first_offset
argument_list|(
name|map
argument_list|,
name|tmp_offset
argument_list|,
name|probe
argument_list|)
condition|)
break|break;
name|probe
operator|++
expr_stmt|;
name|tmp_offset
operator|=
name|ck_rhs_map_probe_next
argument_list|(
name|map
argument_list|,
name|tmp_offset
argument_list|,
name|probe
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|probe
operator|==
name|max_probes
condition|)
name|CK_RHS_STORE
argument_list|(
operator|&
name|hdesc
operator|->
name|probe_bound
argument_list|,
name|wanted_probes
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|desc
operator|->
name|wanted
operator|<
name|CK_RHS_MAX_WANTED
condition|)
name|desc
operator|->
name|wanted
operator|--
expr_stmt|;
name|slot
operator|=
name|offset
expr_stmt|;
name|desc
operator|=
name|new_desc
expr_stmt|;
block|}
name|ck_pr_store_ptr
argument_list|(
name|ck_rhs_entry_addr
argument_list|(
name|map
argument_list|,
name|slot
argument_list|)
argument_list|,
name|CK_RHS_EMPTY
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|desc
operator|->
name|probes
operator|-
literal|1
operator|)
operator|<
name|CK_RHS_WORD_MAX
condition|)
name|CK_RHS_STORE
argument_list|(
name|ck_rhs_probe_bound_addr
argument_list|(
name|map
argument_list|,
name|h
argument_list|)
argument_list|,
name|desc
operator|->
name|probes
operator|-
literal|1
argument_list|)
expr_stmt|;
name|desc
operator|->
name|probes
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|bool
name|ck_rhs_fas
parameter_list|(
name|struct
name|ck_rhs
modifier|*
name|hs
parameter_list|,
name|unsigned
name|long
name|h
parameter_list|,
specifier|const
name|void
modifier|*
name|key
parameter_list|,
name|void
modifier|*
modifier|*
name|previous
parameter_list|)
block|{
name|long
name|slot
decl_stmt|,
name|first
decl_stmt|;
specifier|const
name|void
modifier|*
name|object
decl_stmt|;
specifier|const
name|void
modifier|*
name|insert
decl_stmt|;
name|unsigned
name|long
name|n_probes
decl_stmt|;
name|struct
name|ck_rhs_map
modifier|*
name|map
init|=
name|hs
operator|->
name|map
decl_stmt|;
name|struct
name|ck_rhs_entry_desc
modifier|*
name|desc
decl_stmt|,
modifier|*
name|desc2
decl_stmt|;
operator|*
name|previous
operator|=
name|NULL
expr_stmt|;
name|restart
label|:
name|slot
operator|=
name|map
operator|->
name|probe_func
argument_list|(
name|hs
argument_list|,
name|map
argument_list|,
operator|&
name|n_probes
argument_list|,
operator|&
name|first
argument_list|,
name|h
argument_list|,
name|key
argument_list|,
operator|&
name|object
argument_list|,
name|ck_rhs_map_bound_get
argument_list|(
name|map
argument_list|,
name|h
argument_list|)
argument_list|,
name|CK_RHS_PROBE
argument_list|)
expr_stmt|;
comment|/* Replacement semantics presume existence. */
if|if
condition|(
name|object
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|insert
operator|=
name|ck_rhs_marshal
argument_list|(
name|hs
operator|->
name|mode
argument_list|,
name|key
argument_list|,
name|h
argument_list|)
expr_stmt|;
if|if
condition|(
name|first
operator|!=
operator|-
literal|1
condition|)
block|{
name|int
name|ret
decl_stmt|;
name|desc
operator|=
name|ck_rhs_desc
argument_list|(
name|map
argument_list|,
name|slot
argument_list|)
expr_stmt|;
name|desc2
operator|=
name|ck_rhs_desc
argument_list|(
name|map
argument_list|,
name|first
argument_list|)
expr_stmt|;
name|desc
operator|->
name|in_rh
operator|=
name|true
expr_stmt|;
name|ret
operator|=
name|ck_rhs_put_robin_hood
argument_list|(
name|hs
argument_list|,
name|first
argument_list|,
name|desc2
argument_list|)
expr_stmt|;
name|desc
operator|->
name|in_rh
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|CK_CC_UNLIKELY
argument_list|(
name|ret
operator|==
literal|1
argument_list|)
condition|)
goto|goto
name|restart
goto|;
elseif|else
if|if
condition|(
name|CK_CC_UNLIKELY
argument_list|(
name|ret
operator|!=
literal|0
argument_list|)
condition|)
return|return
name|false
return|;
name|ck_pr_store_ptr
argument_list|(
name|ck_rhs_entry_addr
argument_list|(
name|map
argument_list|,
name|first
argument_list|)
argument_list|,
name|insert
argument_list|)
expr_stmt|;
name|ck_pr_inc_uint
argument_list|(
operator|&
name|map
operator|->
name|generation
index|[
name|h
operator|&
name|CK_RHS_G_MASK
index|]
argument_list|)
expr_stmt|;
name|ck_pr_fence_atomic_store
argument_list|()
expr_stmt|;
name|desc2
operator|->
name|probes
operator|=
name|n_probes
expr_stmt|;
name|ck_rhs_add_wanted
argument_list|(
name|hs
argument_list|,
name|first
argument_list|,
operator|-
literal|1
argument_list|,
name|h
argument_list|)
expr_stmt|;
name|ck_rhs_do_backward_shift_delete
argument_list|(
name|hs
argument_list|,
name|slot
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ck_pr_store_ptr
argument_list|(
name|ck_rhs_entry_addr
argument_list|(
name|map
argument_list|,
name|slot
argument_list|)
argument_list|,
name|insert
argument_list|)
expr_stmt|;
name|ck_rhs_set_probes
argument_list|(
name|map
argument_list|,
name|slot
argument_list|,
name|n_probes
argument_list|)
expr_stmt|;
block|}
operator|*
name|previous
operator|=
name|CK_CC_DECONST_PTR
argument_list|(
name|object
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/*  * An apply function takes two arguments. The first argument is a pointer to a  * pre-existing object. The second argument is a pointer to the fifth argument  * passed to ck_hs_apply. If a non-NULL pointer is passed to the first argument  * and the return value of the apply function is NULL, then the pre-existing  * value is deleted. If the return pointer is the same as the one passed to the  * apply function then no changes are made to the hash table.  If the first  * argument is non-NULL and the return pointer is different than that passed to  * the apply function, then the pre-existing value is replaced. For  * replacement, it is required that the value itself is identical to the  * previous value.  */
end_comment

begin_function
name|bool
name|ck_rhs_apply
parameter_list|(
name|struct
name|ck_rhs
modifier|*
name|hs
parameter_list|,
name|unsigned
name|long
name|h
parameter_list|,
specifier|const
name|void
modifier|*
name|key
parameter_list|,
name|ck_rhs_apply_fn_t
modifier|*
name|fn
parameter_list|,
name|void
modifier|*
name|cl
parameter_list|)
block|{
specifier|const
name|void
modifier|*
name|insert
decl_stmt|;
specifier|const
name|void
modifier|*
name|object
decl_stmt|,
modifier|*
name|delta
init|=
name|false
decl_stmt|;
name|unsigned
name|long
name|n_probes
decl_stmt|;
name|long
name|slot
decl_stmt|,
name|first
decl_stmt|;
name|struct
name|ck_rhs_map
modifier|*
name|map
decl_stmt|;
name|bool
name|delta_set
init|=
name|false
decl_stmt|;
name|restart
label|:
name|map
operator|=
name|hs
operator|->
name|map
expr_stmt|;
name|slot
operator|=
name|map
operator|->
name|probe_func
argument_list|(
name|hs
argument_list|,
name|map
argument_list|,
operator|&
name|n_probes
argument_list|,
operator|&
name|first
argument_list|,
name|h
argument_list|,
name|key
argument_list|,
operator|&
name|object
argument_list|,
name|map
operator|->
name|probe_limit
argument_list|,
name|CK_RHS_PROBE_INSERT
argument_list|)
expr_stmt|;
if|if
condition|(
name|slot
operator|==
operator|-
literal|1
operator|&&
name|first
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|ck_rhs_grow
argument_list|(
name|hs
argument_list|,
name|map
operator|->
name|capacity
operator|<<
literal|1
argument_list|)
operator|==
name|false
condition|)
return|return
name|false
return|;
goto|goto
name|restart
goto|;
block|}
if|if
condition|(
operator|!
name|delta_set
condition|)
block|{
name|delta
operator|=
name|fn
argument_list|(
name|CK_CC_DECONST_PTR
argument_list|(
name|object
argument_list|)
argument_list|,
name|cl
argument_list|)
expr_stmt|;
name|delta_set
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
name|delta
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * The apply function has requested deletion. If the object doesn't exist, 		 * then exit early. 		 */
if|if
condition|(
name|CK_CC_UNLIKELY
argument_list|(
name|object
operator|==
name|NULL
argument_list|)
condition|)
return|return
name|true
return|;
comment|/* Otherwise, delete it. */
name|ck_rhs_do_backward_shift_delete
argument_list|(
name|hs
argument_list|,
name|slot
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/* The apply function has not requested hash set modification so exit early. */
if|if
condition|(
name|delta
operator|==
name|object
condition|)
return|return
name|true
return|;
comment|/* A modification or insertion has been requested. */
name|ck_rhs_map_bound_set
argument_list|(
name|map
argument_list|,
name|h
argument_list|,
name|n_probes
argument_list|)
expr_stmt|;
name|insert
operator|=
name|ck_rhs_marshal
argument_list|(
name|hs
operator|->
name|mode
argument_list|,
name|delta
argument_list|,
name|h
argument_list|)
expr_stmt|;
if|if
condition|(
name|first
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* 		 * This follows the same semantics as ck_hs_set, please refer to that 		 * function for documentation. 		 */
name|struct
name|ck_rhs_entry_desc
modifier|*
name|desc
init|=
name|NULL
decl_stmt|,
modifier|*
name|desc2
decl_stmt|;
if|if
condition|(
name|slot
operator|!=
operator|-
literal|1
condition|)
block|{
name|desc
operator|=
name|ck_rhs_desc
argument_list|(
name|map
argument_list|,
name|slot
argument_list|)
expr_stmt|;
name|desc
operator|->
name|in_rh
operator|=
name|true
expr_stmt|;
block|}
name|desc2
operator|=
name|ck_rhs_desc
argument_list|(
name|map
argument_list|,
name|first
argument_list|)
expr_stmt|;
name|int
name|ret
init|=
name|ck_rhs_put_robin_hood
argument_list|(
name|hs
argument_list|,
name|first
argument_list|,
name|desc2
argument_list|)
decl_stmt|;
if|if
condition|(
name|slot
operator|!=
operator|-
literal|1
condition|)
name|desc
operator|->
name|in_rh
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|CK_CC_UNLIKELY
argument_list|(
name|ret
operator|==
literal|1
argument_list|)
condition|)
goto|goto
name|restart
goto|;
if|if
condition|(
name|CK_CC_UNLIKELY
argument_list|(
name|ret
operator|==
operator|-
literal|1
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* If an earlier bucket was found, then store entry there. */
name|ck_pr_store_ptr
argument_list|(
name|ck_rhs_entry_addr
argument_list|(
name|map
argument_list|,
name|first
argument_list|)
argument_list|,
name|insert
argument_list|)
expr_stmt|;
name|desc2
operator|->
name|probes
operator|=
name|n_probes
expr_stmt|;
comment|/* 		 * If a duplicate key was found, then delete it after 		 * signaling concurrent probes to restart. Optionally, 		 * it is possible to install tombstone after grace 		 * period if we can guarantee earlier position of 		 * duplicate key. 		 */
name|ck_rhs_add_wanted
argument_list|(
name|hs
argument_list|,
name|first
argument_list|,
operator|-
literal|1
argument_list|,
name|h
argument_list|)
expr_stmt|;
if|if
condition|(
name|object
operator|!=
name|NULL
condition|)
block|{
name|ck_pr_inc_uint
argument_list|(
operator|&
name|map
operator|->
name|generation
index|[
name|h
operator|&
name|CK_RHS_G_MASK
index|]
argument_list|)
expr_stmt|;
name|ck_pr_fence_atomic_store
argument_list|()
expr_stmt|;
name|ck_rhs_do_backward_shift_delete
argument_list|(
name|hs
argument_list|,
name|slot
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 		 * If we are storing into same slot, then atomic store is sufficient 		 * for replacement. 		 */
name|ck_pr_store_ptr
argument_list|(
name|ck_rhs_entry_addr
argument_list|(
name|map
argument_list|,
name|slot
argument_list|)
argument_list|,
name|insert
argument_list|)
expr_stmt|;
name|ck_rhs_set_probes
argument_list|(
name|map
argument_list|,
name|slot
argument_list|,
name|n_probes
argument_list|)
expr_stmt|;
if|if
condition|(
name|object
operator|==
name|NULL
condition|)
name|ck_rhs_add_wanted
argument_list|(
name|hs
argument_list|,
name|slot
argument_list|,
operator|-
literal|1
argument_list|,
name|h
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|object
operator|==
name|NULL
condition|)
block|{
name|map
operator|->
name|n_entries
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|map
operator|->
name|n_entries
operator|)
operator|>
name|map
operator|->
name|max_entries
condition|)
name|ck_rhs_grow
argument_list|(
name|hs
argument_list|,
name|map
operator|->
name|capacity
operator|<<
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_function
name|bool
name|ck_rhs_set
parameter_list|(
name|struct
name|ck_rhs
modifier|*
name|hs
parameter_list|,
name|unsigned
name|long
name|h
parameter_list|,
specifier|const
name|void
modifier|*
name|key
parameter_list|,
name|void
modifier|*
modifier|*
name|previous
parameter_list|)
block|{
name|long
name|slot
decl_stmt|,
name|first
decl_stmt|;
specifier|const
name|void
modifier|*
name|object
decl_stmt|;
specifier|const
name|void
modifier|*
name|insert
decl_stmt|;
name|unsigned
name|long
name|n_probes
decl_stmt|;
name|struct
name|ck_rhs_map
modifier|*
name|map
decl_stmt|;
operator|*
name|previous
operator|=
name|NULL
expr_stmt|;
name|restart
label|:
name|map
operator|=
name|hs
operator|->
name|map
expr_stmt|;
name|slot
operator|=
name|map
operator|->
name|probe_func
argument_list|(
name|hs
argument_list|,
name|map
argument_list|,
operator|&
name|n_probes
argument_list|,
operator|&
name|first
argument_list|,
name|h
argument_list|,
name|key
argument_list|,
operator|&
name|object
argument_list|,
name|map
operator|->
name|probe_limit
argument_list|,
name|CK_RHS_PROBE_INSERT
argument_list|)
expr_stmt|;
if|if
condition|(
name|slot
operator|==
operator|-
literal|1
operator|&&
name|first
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|ck_rhs_grow
argument_list|(
name|hs
argument_list|,
name|map
operator|->
name|capacity
operator|<<
literal|1
argument_list|)
operator|==
name|false
condition|)
return|return
name|false
return|;
goto|goto
name|restart
goto|;
block|}
name|ck_rhs_map_bound_set
argument_list|(
name|map
argument_list|,
name|h
argument_list|,
name|n_probes
argument_list|)
expr_stmt|;
name|insert
operator|=
name|ck_rhs_marshal
argument_list|(
name|hs
operator|->
name|mode
argument_list|,
name|key
argument_list|,
name|h
argument_list|)
expr_stmt|;
if|if
condition|(
name|first
operator|!=
operator|-
literal|1
condition|)
block|{
name|struct
name|ck_rhs_entry_desc
modifier|*
name|desc
init|=
name|NULL
decl_stmt|,
modifier|*
name|desc2
decl_stmt|;
if|if
condition|(
name|slot
operator|!=
operator|-
literal|1
condition|)
block|{
name|desc
operator|=
name|ck_rhs_desc
argument_list|(
name|map
argument_list|,
name|slot
argument_list|)
expr_stmt|;
name|desc
operator|->
name|in_rh
operator|=
name|true
expr_stmt|;
block|}
name|desc2
operator|=
name|ck_rhs_desc
argument_list|(
name|map
argument_list|,
name|first
argument_list|)
expr_stmt|;
name|int
name|ret
init|=
name|ck_rhs_put_robin_hood
argument_list|(
name|hs
argument_list|,
name|first
argument_list|,
name|desc2
argument_list|)
decl_stmt|;
if|if
condition|(
name|slot
operator|!=
operator|-
literal|1
condition|)
name|desc
operator|->
name|in_rh
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|CK_CC_UNLIKELY
argument_list|(
name|ret
operator|==
literal|1
argument_list|)
condition|)
goto|goto
name|restart
goto|;
if|if
condition|(
name|CK_CC_UNLIKELY
argument_list|(
name|ret
operator|==
operator|-
literal|1
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* If an earlier bucket was found, then store entry there. */
name|ck_pr_store_ptr
argument_list|(
name|ck_rhs_entry_addr
argument_list|(
name|map
argument_list|,
name|first
argument_list|)
argument_list|,
name|insert
argument_list|)
expr_stmt|;
name|desc2
operator|->
name|probes
operator|=
name|n_probes
expr_stmt|;
comment|/* 		 * If a duplicate key was found, then delete it after 		 * signaling concurrent probes to restart. Optionally, 		 * it is possible to install tombstone after grace 		 * period if we can guarantee earlier position of 		 * duplicate key. 		 */
name|ck_rhs_add_wanted
argument_list|(
name|hs
argument_list|,
name|first
argument_list|,
operator|-
literal|1
argument_list|,
name|h
argument_list|)
expr_stmt|;
if|if
condition|(
name|object
operator|!=
name|NULL
condition|)
block|{
name|ck_pr_inc_uint
argument_list|(
operator|&
name|map
operator|->
name|generation
index|[
name|h
operator|&
name|CK_RHS_G_MASK
index|]
argument_list|)
expr_stmt|;
name|ck_pr_fence_atomic_store
argument_list|()
expr_stmt|;
name|ck_rhs_do_backward_shift_delete
argument_list|(
name|hs
argument_list|,
name|slot
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 		 * If we are storing into same slot, then atomic store is sufficient 		 * for replacement. 		 */
name|ck_pr_store_ptr
argument_list|(
name|ck_rhs_entry_addr
argument_list|(
name|map
argument_list|,
name|slot
argument_list|)
argument_list|,
name|insert
argument_list|)
expr_stmt|;
name|ck_rhs_set_probes
argument_list|(
name|map
argument_list|,
name|slot
argument_list|,
name|n_probes
argument_list|)
expr_stmt|;
if|if
condition|(
name|object
operator|==
name|NULL
condition|)
name|ck_rhs_add_wanted
argument_list|(
name|hs
argument_list|,
name|slot
argument_list|,
operator|-
literal|1
argument_list|,
name|h
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|object
operator|==
name|NULL
condition|)
block|{
name|map
operator|->
name|n_entries
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|map
operator|->
name|n_entries
operator|)
operator|>
name|map
operator|->
name|max_entries
condition|)
name|ck_rhs_grow
argument_list|(
name|hs
argument_list|,
name|map
operator|->
name|capacity
operator|<<
literal|1
argument_list|)
expr_stmt|;
block|}
operator|*
name|previous
operator|=
name|CK_CC_DECONST_PTR
argument_list|(
name|object
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|ck_rhs_put_internal
parameter_list|(
name|struct
name|ck_rhs
modifier|*
name|hs
parameter_list|,
name|unsigned
name|long
name|h
parameter_list|,
specifier|const
name|void
modifier|*
name|key
parameter_list|,
name|enum
name|ck_rhs_probe_behavior
name|behavior
parameter_list|)
block|{
name|long
name|slot
decl_stmt|,
name|first
decl_stmt|;
specifier|const
name|void
modifier|*
name|object
decl_stmt|;
specifier|const
name|void
modifier|*
name|insert
decl_stmt|;
name|unsigned
name|long
name|n_probes
decl_stmt|;
name|struct
name|ck_rhs_map
modifier|*
name|map
decl_stmt|;
name|restart
label|:
name|map
operator|=
name|hs
operator|->
name|map
expr_stmt|;
name|slot
operator|=
name|map
operator|->
name|probe_func
argument_list|(
name|hs
argument_list|,
name|map
argument_list|,
operator|&
name|n_probes
argument_list|,
operator|&
name|first
argument_list|,
name|h
argument_list|,
name|key
argument_list|,
operator|&
name|object
argument_list|,
name|map
operator|->
name|probe_limit
argument_list|,
name|behavior
argument_list|)
expr_stmt|;
if|if
condition|(
name|slot
operator|==
operator|-
literal|1
operator|&&
name|first
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|ck_rhs_grow
argument_list|(
name|hs
argument_list|,
name|map
operator|->
name|capacity
operator|<<
literal|1
argument_list|)
operator|==
name|false
condition|)
return|return
name|false
return|;
goto|goto
name|restart
goto|;
block|}
comment|/* Fail operation if a match was found. */
if|if
condition|(
name|object
operator|!=
name|NULL
condition|)
return|return
name|false
return|;
name|ck_rhs_map_bound_set
argument_list|(
name|map
argument_list|,
name|h
argument_list|,
name|n_probes
argument_list|)
expr_stmt|;
name|insert
operator|=
name|ck_rhs_marshal
argument_list|(
name|hs
operator|->
name|mode
argument_list|,
name|key
argument_list|,
name|h
argument_list|)
expr_stmt|;
if|if
condition|(
name|first
operator|!=
operator|-
literal|1
condition|)
block|{
name|struct
name|ck_rhs_entry_desc
modifier|*
name|desc
init|=
name|ck_rhs_desc
argument_list|(
name|map
argument_list|,
name|first
argument_list|)
decl_stmt|;
name|int
name|ret
init|=
name|ck_rhs_put_robin_hood
argument_list|(
name|hs
argument_list|,
name|first
argument_list|,
name|desc
argument_list|)
decl_stmt|;
if|if
condition|(
name|CK_CC_UNLIKELY
argument_list|(
name|ret
operator|==
literal|1
argument_list|)
condition|)
return|return
name|ck_rhs_put_internal
argument_list|(
name|hs
argument_list|,
name|h
argument_list|,
name|key
argument_list|,
name|behavior
argument_list|)
return|;
elseif|else
if|if
condition|(
name|CK_CC_UNLIKELY
argument_list|(
name|ret
operator|==
operator|-
literal|1
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Insert key into first bucket in probe sequence. */
name|ck_pr_store_ptr
argument_list|(
name|ck_rhs_entry_addr
argument_list|(
name|map
argument_list|,
name|first
argument_list|)
argument_list|,
name|insert
argument_list|)
expr_stmt|;
name|desc
operator|->
name|probes
operator|=
name|n_probes
expr_stmt|;
name|ck_rhs_add_wanted
argument_list|(
name|hs
argument_list|,
name|first
argument_list|,
operator|-
literal|1
argument_list|,
name|h
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* An empty slot was found. */
name|ck_pr_store_ptr
argument_list|(
name|ck_rhs_entry_addr
argument_list|(
name|map
argument_list|,
name|slot
argument_list|)
argument_list|,
name|insert
argument_list|)
expr_stmt|;
name|ck_rhs_set_probes
argument_list|(
name|map
argument_list|,
name|slot
argument_list|,
name|n_probes
argument_list|)
expr_stmt|;
name|ck_rhs_add_wanted
argument_list|(
name|hs
argument_list|,
name|slot
argument_list|,
operator|-
literal|1
argument_list|,
name|h
argument_list|)
expr_stmt|;
block|}
name|map
operator|->
name|n_entries
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|map
operator|->
name|n_entries
operator|)
operator|>
name|map
operator|->
name|max_entries
condition|)
name|ck_rhs_grow
argument_list|(
name|hs
argument_list|,
name|map
operator|->
name|capacity
operator|<<
literal|1
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_function
name|bool
name|ck_rhs_put
parameter_list|(
name|struct
name|ck_rhs
modifier|*
name|hs
parameter_list|,
name|unsigned
name|long
name|h
parameter_list|,
specifier|const
name|void
modifier|*
name|key
parameter_list|)
block|{
return|return
name|ck_rhs_put_internal
argument_list|(
name|hs
argument_list|,
name|h
argument_list|,
name|key
argument_list|,
name|CK_RHS_PROBE_INSERT
argument_list|)
return|;
block|}
end_function

begin_function
name|bool
name|ck_rhs_put_unique
parameter_list|(
name|struct
name|ck_rhs
modifier|*
name|hs
parameter_list|,
name|unsigned
name|long
name|h
parameter_list|,
specifier|const
name|void
modifier|*
name|key
parameter_list|)
block|{
return|return
name|ck_rhs_put_internal
argument_list|(
name|hs
argument_list|,
name|h
argument_list|,
name|key
argument_list|,
name|CK_RHS_PROBE_RH
argument_list|)
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|ck_rhs_get
parameter_list|(
name|struct
name|ck_rhs
modifier|*
name|hs
parameter_list|,
name|unsigned
name|long
name|h
parameter_list|,
specifier|const
name|void
modifier|*
name|key
parameter_list|)
block|{
name|long
name|first
decl_stmt|;
specifier|const
name|void
modifier|*
name|object
decl_stmt|;
name|struct
name|ck_rhs_map
modifier|*
name|map
decl_stmt|;
name|unsigned
name|long
name|n_probes
decl_stmt|;
name|unsigned
name|int
name|g
decl_stmt|,
name|g_p
decl_stmt|,
name|probe
decl_stmt|;
name|unsigned
name|int
modifier|*
name|generation
decl_stmt|;
do|do
block|{
name|map
operator|=
name|ck_pr_load_ptr
argument_list|(
operator|&
name|hs
operator|->
name|map
argument_list|)
expr_stmt|;
name|generation
operator|=
operator|&
name|map
operator|->
name|generation
index|[
name|h
operator|&
name|CK_RHS_G_MASK
index|]
expr_stmt|;
name|g
operator|=
name|ck_pr_load_uint
argument_list|(
name|generation
argument_list|)
expr_stmt|;
name|probe
operator|=
name|ck_rhs_map_bound_get
argument_list|(
name|map
argument_list|,
name|h
argument_list|)
expr_stmt|;
name|ck_pr_fence_load
argument_list|()
expr_stmt|;
name|first
operator|=
operator|-
literal|1
expr_stmt|;
name|map
operator|->
name|probe_func
argument_list|(
name|hs
argument_list|,
name|map
argument_list|,
operator|&
name|n_probes
argument_list|,
operator|&
name|first
argument_list|,
name|h
argument_list|,
name|key
argument_list|,
operator|&
name|object
argument_list|,
name|probe
argument_list|,
name|CK_RHS_PROBE_NO_RH
argument_list|)
expr_stmt|;
name|ck_pr_fence_load
argument_list|()
expr_stmt|;
name|g_p
operator|=
name|ck_pr_load_uint
argument_list|(
name|generation
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|g
operator|!=
name|g_p
condition|)
do|;
return|return
name|CK_CC_DECONST_PTR
argument_list|(
name|object
argument_list|)
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|ck_rhs_remove
parameter_list|(
name|struct
name|ck_rhs
modifier|*
name|hs
parameter_list|,
name|unsigned
name|long
name|h
parameter_list|,
specifier|const
name|void
modifier|*
name|key
parameter_list|)
block|{
name|long
name|slot
decl_stmt|,
name|first
decl_stmt|;
specifier|const
name|void
modifier|*
name|object
decl_stmt|;
name|struct
name|ck_rhs_map
modifier|*
name|map
init|=
name|hs
operator|->
name|map
decl_stmt|;
name|unsigned
name|long
name|n_probes
decl_stmt|;
name|slot
operator|=
name|map
operator|->
name|probe_func
argument_list|(
name|hs
argument_list|,
name|map
argument_list|,
operator|&
name|n_probes
argument_list|,
operator|&
name|first
argument_list|,
name|h
argument_list|,
name|key
argument_list|,
operator|&
name|object
argument_list|,
name|ck_rhs_map_bound_get
argument_list|(
name|map
argument_list|,
name|h
argument_list|)
argument_list|,
name|CK_RHS_PROBE_NO_RH
argument_list|)
expr_stmt|;
if|if
condition|(
name|object
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|map
operator|->
name|n_entries
operator|--
expr_stmt|;
name|ck_rhs_do_backward_shift_delete
argument_list|(
name|hs
argument_list|,
name|slot
argument_list|)
expr_stmt|;
return|return
name|CK_CC_DECONST_PTR
argument_list|(
name|object
argument_list|)
return|;
block|}
end_function

begin_function
name|bool
name|ck_rhs_move
parameter_list|(
name|struct
name|ck_rhs
modifier|*
name|hs
parameter_list|,
name|struct
name|ck_rhs
modifier|*
name|source
parameter_list|,
name|ck_rhs_hash_cb_t
modifier|*
name|hf
parameter_list|,
name|ck_rhs_compare_cb_t
modifier|*
name|compare
parameter_list|,
name|struct
name|ck_malloc
modifier|*
name|m
parameter_list|)
block|{
if|if
condition|(
name|m
operator|==
name|NULL
operator|||
name|m
operator|->
name|malloc
operator|==
name|NULL
operator|||
name|m
operator|->
name|free
operator|==
name|NULL
operator|||
name|hf
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|hs
operator|->
name|mode
operator|=
name|source
operator|->
name|mode
expr_stmt|;
name|hs
operator|->
name|seed
operator|=
name|source
operator|->
name|seed
expr_stmt|;
name|hs
operator|->
name|map
operator|=
name|source
operator|->
name|map
expr_stmt|;
name|hs
operator|->
name|load_factor
operator|=
name|source
operator|->
name|load_factor
expr_stmt|;
name|hs
operator|->
name|m
operator|=
name|m
expr_stmt|;
name|hs
operator|->
name|hf
operator|=
name|hf
expr_stmt|;
name|hs
operator|->
name|compare
operator|=
name|compare
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_function
name|bool
name|ck_rhs_init
parameter_list|(
name|struct
name|ck_rhs
modifier|*
name|hs
parameter_list|,
name|unsigned
name|int
name|mode
parameter_list|,
name|ck_rhs_hash_cb_t
modifier|*
name|hf
parameter_list|,
name|ck_rhs_compare_cb_t
modifier|*
name|compare
parameter_list|,
name|struct
name|ck_malloc
modifier|*
name|m
parameter_list|,
name|unsigned
name|long
name|n_entries
parameter_list|,
name|unsigned
name|long
name|seed
parameter_list|)
block|{
if|if
condition|(
name|m
operator|==
name|NULL
operator|||
name|m
operator|->
name|malloc
operator|==
name|NULL
operator|||
name|m
operator|->
name|free
operator|==
name|NULL
operator|||
name|hf
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|hs
operator|->
name|m
operator|=
name|m
expr_stmt|;
name|hs
operator|->
name|mode
operator|=
name|mode
expr_stmt|;
name|hs
operator|->
name|seed
operator|=
name|seed
expr_stmt|;
name|hs
operator|->
name|hf
operator|=
name|hf
expr_stmt|;
name|hs
operator|->
name|compare
operator|=
name|compare
expr_stmt|;
name|hs
operator|->
name|load_factor
operator|=
name|CK_RHS_DEFAULT_LOAD_FACTOR
expr_stmt|;
name|hs
operator|->
name|map
operator|=
name|ck_rhs_map_create
argument_list|(
name|hs
argument_list|,
name|n_entries
argument_list|)
expr_stmt|;
return|return
name|hs
operator|->
name|map
operator|!=
name|NULL
return|;
block|}
end_function

end_unit

