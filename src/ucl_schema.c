begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2014, Vsevolod Stakhov  *  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are met:  *	 * Redistributions of source code must retain the above copyright  *	   notice, this list of conditions and the following disclaimer.  *	 * Redistributions in binary form must reproduce the above copyright  *	   notice, this list of conditions and the following disclaimer in the  *	   documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY AUTHOR ''AS IS'' AND ANY  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED. IN NO EVENT SHALL AUTHOR BE LIABLE FOR ANY  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|"ucl.h"
end_include

begin_include
include|#
directive|include
file|"ucl_internal.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"utlist.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_STDARG_H
end_ifdef

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_STDIO_H
end_ifdef

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_REGEX_H
end_ifdef

begin_include
include|#
directive|include
file|<regex.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_MATH_H
end_ifdef

begin_include
include|#
directive|include
file|<math.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|bool
name|ucl_schema_validate
parameter_list|(
specifier|const
name|ucl_object_t
modifier|*
name|schema
parameter_list|,
specifier|const
name|ucl_object_t
modifier|*
name|obj
parameter_list|,
name|bool
name|try_array
parameter_list|,
name|struct
name|ucl_schema_error
modifier|*
name|err
parameter_list|,
specifier|const
name|ucl_object_t
modifier|*
name|root
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|bool
name|ucl_string_to_type
parameter_list|(
specifier|const
name|char
modifier|*
name|input
parameter_list|,
name|ucl_type_t
modifier|*
name|res
parameter_list|)
block|{
if|if
condition|(
name|strcasecmp
argument_list|(
name|input
argument_list|,
literal|"object"
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|res
operator|=
name|UCL_OBJECT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|input
argument_list|,
literal|"array"
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|res
operator|=
name|UCL_ARRAY
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|input
argument_list|,
literal|"integer"
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|res
operator|=
name|UCL_INT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|input
argument_list|,
literal|"number"
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|res
operator|=
name|UCL_FLOAT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|input
argument_list|,
literal|"string"
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|res
operator|=
name|UCL_STRING
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|input
argument_list|,
literal|"boolean"
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|res
operator|=
name|UCL_BOOLEAN
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|input
argument_list|,
literal|"null"
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|res
operator|=
name|UCL_NULL
expr_stmt|;
block|}
else|else
block|{
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|ucl_object_type_to_string
parameter_list|(
name|ucl_type_t
name|type
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|res
init|=
literal|"unknown"
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|UCL_OBJECT
case|:
name|res
operator|=
literal|"object"
expr_stmt|;
break|break;
case|case
name|UCL_ARRAY
case|:
name|res
operator|=
literal|"array"
expr_stmt|;
break|break;
case|case
name|UCL_INT
case|:
name|res
operator|=
literal|"integer"
expr_stmt|;
break|break;
case|case
name|UCL_FLOAT
case|:
case|case
name|UCL_TIME
case|:
name|res
operator|=
literal|"number"
expr_stmt|;
break|break;
case|case
name|UCL_STRING
case|:
name|res
operator|=
literal|"string"
expr_stmt|;
break|break;
case|case
name|UCL_BOOLEAN
case|:
name|res
operator|=
literal|"boolean"
expr_stmt|;
break|break;
case|case
name|UCL_NULL
case|:
case|case
name|UCL_USERDATA
case|:
name|res
operator|=
literal|"null"
expr_stmt|;
break|break;
block|}
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/*  * Create validation error  */
end_comment

begin_function
specifier|static
name|void
name|ucl_schema_create_error
parameter_list|(
name|struct
name|ucl_schema_error
modifier|*
name|err
parameter_list|,
name|enum
name|ucl_schema_error_code
name|code
parameter_list|,
specifier|const
name|ucl_object_t
modifier|*
name|obj
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|va
decl_stmt|;
if|if
condition|(
name|err
operator|!=
name|NULL
condition|)
block|{
name|err
operator|->
name|code
operator|=
name|code
expr_stmt|;
name|err
operator|->
name|obj
operator|=
name|obj
expr_stmt|;
name|va_start
argument_list|(
name|va
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|vsnprintf
argument_list|(
name|err
operator|->
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|err
operator|->
name|msg
argument_list|)
argument_list|,
name|fmt
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|va
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Check whether we have a pattern specified  */
end_comment

begin_function
specifier|static
specifier|const
name|ucl_object_t
modifier|*
name|ucl_schema_test_pattern
parameter_list|(
specifier|const
name|ucl_object_t
modifier|*
name|obj
parameter_list|,
specifier|const
name|char
modifier|*
name|pattern
parameter_list|)
block|{
specifier|const
name|ucl_object_t
modifier|*
name|res
init|=
name|NULL
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_REGEX_H
name|regex_t
name|reg
decl_stmt|;
specifier|const
name|ucl_object_t
modifier|*
name|elt
decl_stmt|;
name|ucl_object_iter_t
name|iter
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|regcomp
argument_list|(
operator|&
name|reg
argument_list|,
name|pattern
argument_list|,
name|REG_EXTENDED
operator||
name|REG_NOSUB
argument_list|)
operator|==
literal|0
condition|)
block|{
while|while
condition|(
operator|(
name|elt
operator|=
name|ucl_iterate_object
argument_list|(
name|obj
argument_list|,
operator|&
name|iter
argument_list|,
name|true
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|regexec
argument_list|(
operator|&
name|reg
argument_list|,
name|ucl_object_key
argument_list|(
name|elt
argument_list|)
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
block|{
name|res
operator|=
name|elt
expr_stmt|;
break|break;
block|}
block|}
name|regfree
argument_list|(
operator|&
name|reg
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/*  * Check dependencies for an object  */
end_comment

begin_function
specifier|static
name|bool
name|ucl_schema_validate_dependencies
parameter_list|(
specifier|const
name|ucl_object_t
modifier|*
name|deps
parameter_list|,
specifier|const
name|ucl_object_t
modifier|*
name|obj
parameter_list|,
name|struct
name|ucl_schema_error
modifier|*
name|err
parameter_list|,
specifier|const
name|ucl_object_t
modifier|*
name|root
parameter_list|)
block|{
specifier|const
name|ucl_object_t
modifier|*
name|elt
decl_stmt|,
modifier|*
name|cur
decl_stmt|,
modifier|*
name|cur_dep
decl_stmt|;
name|ucl_object_iter_t
name|iter
init|=
name|NULL
decl_stmt|,
name|piter
decl_stmt|;
name|bool
name|ret
init|=
name|true
decl_stmt|;
while|while
condition|(
name|ret
operator|&&
operator|(
name|cur
operator|=
name|ucl_iterate_object
argument_list|(
name|deps
argument_list|,
operator|&
name|iter
argument_list|,
name|true
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|elt
operator|=
name|ucl_object_find_key
argument_list|(
name|obj
argument_list|,
name|ucl_object_key
argument_list|(
name|cur
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|elt
operator|!=
name|NULL
condition|)
block|{
comment|/* Need to check dependencies */
if|if
condition|(
name|cur
operator|->
name|type
operator|==
name|UCL_ARRAY
condition|)
block|{
name|piter
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|ret
operator|&&
operator|(
name|cur_dep
operator|=
name|ucl_iterate_object
argument_list|(
name|cur
argument_list|,
operator|&
name|piter
argument_list|,
name|true
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ucl_object_find_key
argument_list|(
name|obj
argument_list|,
name|ucl_object_tostring
argument_list|(
name|cur_dep
argument_list|)
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|ucl_schema_create_error
argument_list|(
name|err
argument_list|,
name|UCL_SCHEMA_MISSING_DEPENDENCY
argument_list|,
name|elt
argument_list|,
literal|"dependency %s is missing for key %s"
argument_list|,
name|ucl_object_tostring
argument_list|(
name|cur_dep
argument_list|)
argument_list|,
name|ucl_object_key
argument_list|(
name|cur
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|false
expr_stmt|;
break|break;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|cur
operator|->
name|type
operator|==
name|UCL_OBJECT
condition|)
block|{
name|ret
operator|=
name|ucl_schema_validate
argument_list|(
name|cur
argument_list|,
name|obj
argument_list|,
name|true
argument_list|,
name|err
argument_list|,
name|root
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * Validate object  */
end_comment

begin_function
specifier|static
name|bool
name|ucl_schema_validate_object
parameter_list|(
specifier|const
name|ucl_object_t
modifier|*
name|schema
parameter_list|,
specifier|const
name|ucl_object_t
modifier|*
name|obj
parameter_list|,
name|struct
name|ucl_schema_error
modifier|*
name|err
parameter_list|,
specifier|const
name|ucl_object_t
modifier|*
name|root
parameter_list|)
block|{
specifier|const
name|ucl_object_t
modifier|*
name|elt
decl_stmt|,
modifier|*
name|prop
decl_stmt|,
modifier|*
name|found
decl_stmt|,
modifier|*
name|additional_schema
init|=
name|NULL
decl_stmt|,
modifier|*
name|required
init|=
name|NULL
decl_stmt|,
modifier|*
name|pat
decl_stmt|,
modifier|*
name|pelt
decl_stmt|;
name|ucl_object_iter_t
name|iter
init|=
name|NULL
decl_stmt|,
name|piter
init|=
name|NULL
decl_stmt|;
name|bool
name|ret
init|=
name|true
decl_stmt|,
name|allow_additional
init|=
name|true
decl_stmt|;
name|int64_t
name|minmax
decl_stmt|;
while|while
condition|(
name|ret
operator|&&
operator|(
name|elt
operator|=
name|ucl_iterate_object
argument_list|(
name|schema
argument_list|,
operator|&
name|iter
argument_list|,
name|true
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|elt
operator|->
name|type
operator|==
name|UCL_OBJECT
operator|&&
name|strcmp
argument_list|(
name|ucl_object_key
argument_list|(
name|elt
argument_list|)
argument_list|,
literal|"properties"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|piter
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|ret
operator|&&
operator|(
name|prop
operator|=
name|ucl_iterate_object
argument_list|(
name|elt
argument_list|,
operator|&
name|piter
argument_list|,
name|true
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|found
operator|=
name|ucl_object_find_key
argument_list|(
name|obj
argument_list|,
name|ucl_object_key
argument_list|(
name|prop
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|found
condition|)
block|{
name|ret
operator|=
name|ucl_schema_validate
argument_list|(
name|prop
argument_list|,
name|found
argument_list|,
name|true
argument_list|,
name|err
argument_list|,
name|root
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|ucl_object_key
argument_list|(
name|elt
argument_list|)
argument_list|,
literal|"additionalProperties"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|elt
operator|->
name|type
operator|==
name|UCL_BOOLEAN
condition|)
block|{
if|if
condition|(
operator|!
name|ucl_object_toboolean
argument_list|(
name|elt
argument_list|)
condition|)
block|{
comment|/* Deny additional fields completely */
name|allow_additional
operator|=
name|false
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|elt
operator|->
name|type
operator|==
name|UCL_OBJECT
condition|)
block|{
comment|/* Define validator for additional fields */
name|additional_schema
operator|=
name|elt
expr_stmt|;
block|}
else|else
block|{
name|ucl_schema_create_error
argument_list|(
name|err
argument_list|,
name|UCL_SCHEMA_INVALID_SCHEMA
argument_list|,
name|elt
argument_list|,
literal|"additionalProperties attribute is invalid in schema"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|false
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|ucl_object_key
argument_list|(
name|elt
argument_list|)
argument_list|,
literal|"required"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|elt
operator|->
name|type
operator|==
name|UCL_ARRAY
condition|)
block|{
name|required
operator|=
name|elt
expr_stmt|;
block|}
else|else
block|{
name|ucl_schema_create_error
argument_list|(
name|err
argument_list|,
name|UCL_SCHEMA_INVALID_SCHEMA
argument_list|,
name|elt
argument_list|,
literal|"required attribute is invalid in schema"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|false
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|ucl_object_key
argument_list|(
name|elt
argument_list|)
argument_list|,
literal|"minProperties"
argument_list|)
operator|==
literal|0
operator|&&
name|ucl_object_toint_safe
argument_list|(
name|elt
argument_list|,
operator|&
name|minmax
argument_list|)
condition|)
block|{
if|if
condition|(
name|obj
operator|->
name|len
operator|<
name|minmax
condition|)
block|{
name|ucl_schema_create_error
argument_list|(
name|err
argument_list|,
name|UCL_SCHEMA_CONSTRAINT
argument_list|,
name|obj
argument_list|,
literal|"object has not enough properties: %u, minimum is: %u"
argument_list|,
name|obj
operator|->
name|len
argument_list|,
operator|(
name|unsigned
operator|)
name|minmax
argument_list|)
expr_stmt|;
name|ret
operator|=
name|false
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|ucl_object_key
argument_list|(
name|elt
argument_list|)
argument_list|,
literal|"maxProperties"
argument_list|)
operator|==
literal|0
operator|&&
name|ucl_object_toint_safe
argument_list|(
name|elt
argument_list|,
operator|&
name|minmax
argument_list|)
condition|)
block|{
if|if
condition|(
name|obj
operator|->
name|len
operator|>
name|minmax
condition|)
block|{
name|ucl_schema_create_error
argument_list|(
name|err
argument_list|,
name|UCL_SCHEMA_CONSTRAINT
argument_list|,
name|obj
argument_list|,
literal|"object has too many properties: %u, maximum is: %u"
argument_list|,
name|obj
operator|->
name|len
argument_list|,
operator|(
name|unsigned
operator|)
name|minmax
argument_list|)
expr_stmt|;
name|ret
operator|=
name|false
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|ucl_object_key
argument_list|(
name|elt
argument_list|)
argument_list|,
literal|"patternProperties"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|piter
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|ret
operator|&&
operator|(
name|prop
operator|=
name|ucl_iterate_object
argument_list|(
name|elt
argument_list|,
operator|&
name|piter
argument_list|,
name|true
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|found
operator|=
name|ucl_schema_test_pattern
argument_list|(
name|obj
argument_list|,
name|ucl_object_key
argument_list|(
name|prop
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|found
condition|)
block|{
name|ret
operator|=
name|ucl_schema_validate
argument_list|(
name|prop
argument_list|,
name|found
argument_list|,
name|true
argument_list|,
name|err
argument_list|,
name|root
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|elt
operator|->
name|type
operator|==
name|UCL_OBJECT
operator|&&
name|strcmp
argument_list|(
name|ucl_object_key
argument_list|(
name|elt
argument_list|)
argument_list|,
literal|"dependencies"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ret
operator|=
name|ucl_schema_validate_dependencies
argument_list|(
name|elt
argument_list|,
name|obj
argument_list|,
name|err
argument_list|,
name|root
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ret
condition|)
block|{
comment|/* Additional properties */
if|if
condition|(
operator|!
name|allow_additional
operator|||
name|additional_schema
operator|!=
name|NULL
condition|)
block|{
comment|/* Check if we have exactly the same properties in schema and object */
name|iter
operator|=
name|NULL
expr_stmt|;
name|prop
operator|=
name|ucl_object_find_key
argument_list|(
name|schema
argument_list|,
literal|"properties"
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|elt
operator|=
name|ucl_iterate_object
argument_list|(
name|obj
argument_list|,
operator|&
name|iter
argument_list|,
name|true
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|found
operator|=
name|ucl_object_find_key
argument_list|(
name|prop
argument_list|,
name|ucl_object_key
argument_list|(
name|elt
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|found
operator|==
name|NULL
condition|)
block|{
comment|/* Try patternProperties */
name|piter
operator|=
name|NULL
expr_stmt|;
name|pat
operator|=
name|ucl_object_find_key
argument_list|(
name|schema
argument_list|,
literal|"patternProperties"
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|pelt
operator|=
name|ucl_iterate_object
argument_list|(
name|pat
argument_list|,
operator|&
name|piter
argument_list|,
name|true
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|found
operator|=
name|ucl_schema_test_pattern
argument_list|(
name|obj
argument_list|,
name|ucl_object_key
argument_list|(
name|pelt
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|found
operator|!=
name|NULL
condition|)
block|{
break|break;
block|}
block|}
block|}
if|if
condition|(
name|found
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|allow_additional
condition|)
block|{
name|ucl_schema_create_error
argument_list|(
name|err
argument_list|,
name|UCL_SCHEMA_CONSTRAINT
argument_list|,
name|obj
argument_list|,
literal|"object has non-allowed property %s"
argument_list|,
name|ucl_object_key
argument_list|(
name|elt
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|false
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|additional_schema
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|ucl_schema_validate
argument_list|(
name|additional_schema
argument_list|,
name|elt
argument_list|,
name|true
argument_list|,
name|err
argument_list|,
name|root
argument_list|)
condition|)
block|{
name|ret
operator|=
name|false
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
block|}
comment|/* Required properties */
if|if
condition|(
name|required
operator|!=
name|NULL
condition|)
block|{
name|iter
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|(
name|elt
operator|=
name|ucl_iterate_object
argument_list|(
name|required
argument_list|,
operator|&
name|iter
argument_list|,
name|true
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ucl_object_find_key
argument_list|(
name|obj
argument_list|,
name|ucl_object_tostring
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|ucl_schema_create_error
argument_list|(
name|err
argument_list|,
name|UCL_SCHEMA_MISSING_PROPERTY
argument_list|,
name|obj
argument_list|,
literal|"object has missing property %s"
argument_list|,
name|ucl_object_tostring
argument_list|(
name|elt
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|false
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|ucl_schema_validate_number
parameter_list|(
specifier|const
name|ucl_object_t
modifier|*
name|schema
parameter_list|,
specifier|const
name|ucl_object_t
modifier|*
name|obj
parameter_list|,
name|struct
name|ucl_schema_error
modifier|*
name|err
parameter_list|)
block|{
specifier|const
name|ucl_object_t
modifier|*
name|elt
decl_stmt|,
modifier|*
name|test
decl_stmt|;
name|ucl_object_iter_t
name|iter
init|=
name|NULL
decl_stmt|;
name|bool
name|ret
init|=
name|true
decl_stmt|,
name|exclusive
init|=
name|false
decl_stmt|;
name|double
name|constraint
decl_stmt|,
name|val
decl_stmt|;
specifier|const
name|double
name|alpha
init|=
literal|1e-16
decl_stmt|;
while|while
condition|(
name|ret
operator|&&
operator|(
name|elt
operator|=
name|ucl_iterate_object
argument_list|(
name|schema
argument_list|,
operator|&
name|iter
argument_list|,
name|true
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|elt
operator|->
name|type
operator|==
name|UCL_FLOAT
operator|||
name|elt
operator|->
name|type
operator|==
name|UCL_INT
operator|)
operator|&&
name|strcmp
argument_list|(
name|ucl_object_key
argument_list|(
name|elt
argument_list|)
argument_list|,
literal|"multipleOf"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|constraint
operator|=
name|ucl_object_todouble
argument_list|(
name|elt
argument_list|)
expr_stmt|;
if|if
condition|(
name|constraint
operator|<=
literal|0
condition|)
block|{
name|ucl_schema_create_error
argument_list|(
name|err
argument_list|,
name|UCL_SCHEMA_INVALID_SCHEMA
argument_list|,
name|elt
argument_list|,
literal|"multipleOf must be greater than zero"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|false
expr_stmt|;
break|break;
block|}
name|val
operator|=
name|ucl_object_todouble
argument_list|(
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|fabs
argument_list|(
name|remainder
argument_list|(
name|val
argument_list|,
name|constraint
argument_list|)
argument_list|)
operator|>
name|alpha
condition|)
block|{
name|ucl_schema_create_error
argument_list|(
name|err
argument_list|,
name|UCL_SCHEMA_CONSTRAINT
argument_list|,
name|obj
argument_list|,
literal|"number %.4f is not multiple of %.4f, remainder is %.7f"
argument_list|,
name|val
argument_list|,
name|constraint
argument_list|)
expr_stmt|;
name|ret
operator|=
name|false
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|elt
operator|->
name|type
operator|==
name|UCL_FLOAT
operator|||
name|elt
operator|->
name|type
operator|==
name|UCL_INT
operator|)
operator|&&
name|strcmp
argument_list|(
name|ucl_object_key
argument_list|(
name|elt
argument_list|)
argument_list|,
literal|"maximum"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|constraint
operator|=
name|ucl_object_todouble
argument_list|(
name|elt
argument_list|)
expr_stmt|;
name|test
operator|=
name|ucl_object_find_key
argument_list|(
name|schema
argument_list|,
literal|"exclusiveMaximum"
argument_list|)
expr_stmt|;
if|if
condition|(
name|test
operator|&&
name|test
operator|->
name|type
operator|==
name|UCL_BOOLEAN
condition|)
block|{
name|exclusive
operator|=
name|ucl_object_toboolean
argument_list|(
name|test
argument_list|)
expr_stmt|;
block|}
name|val
operator|=
name|ucl_object_todouble
argument_list|(
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|>
name|constraint
operator|||
operator|(
name|exclusive
operator|&&
name|val
operator|>=
name|constraint
operator|)
condition|)
block|{
name|ucl_schema_create_error
argument_list|(
name|err
argument_list|,
name|UCL_SCHEMA_CONSTRAINT
argument_list|,
name|obj
argument_list|,
literal|"number is too big: %.3f, maximum is: %.3f"
argument_list|,
name|val
argument_list|,
name|constraint
argument_list|)
expr_stmt|;
name|ret
operator|=
name|false
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|elt
operator|->
name|type
operator|==
name|UCL_FLOAT
operator|||
name|elt
operator|->
name|type
operator|==
name|UCL_INT
operator|)
operator|&&
name|strcmp
argument_list|(
name|ucl_object_key
argument_list|(
name|elt
argument_list|)
argument_list|,
literal|"minimum"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|constraint
operator|=
name|ucl_object_todouble
argument_list|(
name|elt
argument_list|)
expr_stmt|;
name|test
operator|=
name|ucl_object_find_key
argument_list|(
name|schema
argument_list|,
literal|"exclusiveMinimum"
argument_list|)
expr_stmt|;
if|if
condition|(
name|test
operator|&&
name|test
operator|->
name|type
operator|==
name|UCL_BOOLEAN
condition|)
block|{
name|exclusive
operator|=
name|ucl_object_toboolean
argument_list|(
name|test
argument_list|)
expr_stmt|;
block|}
name|val
operator|=
name|ucl_object_todouble
argument_list|(
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|<
name|constraint
operator|||
operator|(
name|exclusive
operator|&&
name|val
operator|<=
name|constraint
operator|)
condition|)
block|{
name|ucl_schema_create_error
argument_list|(
name|err
argument_list|,
name|UCL_SCHEMA_CONSTRAINT
argument_list|,
name|obj
argument_list|,
literal|"number is too small: %.3f, minimum is: %.3f"
argument_list|,
name|val
argument_list|,
name|constraint
argument_list|)
expr_stmt|;
name|ret
operator|=
name|false
expr_stmt|;
break|break;
block|}
block|}
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|ucl_schema_validate_string
parameter_list|(
specifier|const
name|ucl_object_t
modifier|*
name|schema
parameter_list|,
specifier|const
name|ucl_object_t
modifier|*
name|obj
parameter_list|,
name|struct
name|ucl_schema_error
modifier|*
name|err
parameter_list|)
block|{
specifier|const
name|ucl_object_t
modifier|*
name|elt
decl_stmt|;
name|ucl_object_iter_t
name|iter
init|=
name|NULL
decl_stmt|;
name|bool
name|ret
init|=
name|true
decl_stmt|;
name|int64_t
name|constraint
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_REGEX_H
name|regex_t
name|re
decl_stmt|;
endif|#
directive|endif
while|while
condition|(
name|ret
operator|&&
operator|(
name|elt
operator|=
name|ucl_iterate_object
argument_list|(
name|schema
argument_list|,
operator|&
name|iter
argument_list|,
name|true
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|elt
operator|->
name|type
operator|==
name|UCL_INT
operator|&&
name|strcmp
argument_list|(
name|ucl_object_key
argument_list|(
name|elt
argument_list|)
argument_list|,
literal|"maxLength"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|constraint
operator|=
name|ucl_object_toint
argument_list|(
name|elt
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj
operator|->
name|len
operator|>
name|constraint
condition|)
block|{
name|ucl_schema_create_error
argument_list|(
name|err
argument_list|,
name|UCL_SCHEMA_CONSTRAINT
argument_list|,
name|obj
argument_list|,
literal|"string is too big: %.3f, maximum is: %.3f"
argument_list|,
name|obj
operator|->
name|len
argument_list|,
name|constraint
argument_list|)
expr_stmt|;
name|ret
operator|=
name|false
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|elt
operator|->
name|type
operator|==
name|UCL_INT
operator|&&
name|strcmp
argument_list|(
name|ucl_object_key
argument_list|(
name|elt
argument_list|)
argument_list|,
literal|"minLength"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|constraint
operator|=
name|ucl_object_toint
argument_list|(
name|elt
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj
operator|->
name|len
operator|<
name|constraint
condition|)
block|{
name|ucl_schema_create_error
argument_list|(
name|err
argument_list|,
name|UCL_SCHEMA_CONSTRAINT
argument_list|,
name|obj
argument_list|,
literal|"string is too short: %.3f, minimum is: %.3f"
argument_list|,
name|obj
operator|->
name|len
argument_list|,
name|constraint
argument_list|)
expr_stmt|;
name|ret
operator|=
name|false
expr_stmt|;
break|break;
block|}
block|}
ifdef|#
directive|ifdef
name|HAVE_REGEX_H
elseif|else
if|if
condition|(
name|elt
operator|->
name|type
operator|==
name|UCL_STRING
operator|&&
name|strcmp
argument_list|(
name|ucl_object_key
argument_list|(
name|elt
argument_list|)
argument_list|,
literal|"pattern"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|regcomp
argument_list|(
operator|&
name|re
argument_list|,
name|ucl_object_tostring
argument_list|(
name|elt
argument_list|)
argument_list|,
name|REG_EXTENDED
operator||
name|REG_NOSUB
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ucl_schema_create_error
argument_list|(
name|err
argument_list|,
name|UCL_SCHEMA_INVALID_SCHEMA
argument_list|,
name|elt
argument_list|,
literal|"cannot compile pattern %s"
argument_list|,
name|ucl_object_tostring
argument_list|(
name|elt
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|false
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|regexec
argument_list|(
operator|&
name|re
argument_list|,
name|ucl_object_tostring
argument_list|(
name|obj
argument_list|)
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ucl_schema_create_error
argument_list|(
name|err
argument_list|,
name|UCL_SCHEMA_CONSTRAINT
argument_list|,
name|obj
argument_list|,
literal|"string doesn't match regexp %s"
argument_list|,
name|ucl_object_tostring
argument_list|(
name|elt
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|false
expr_stmt|;
block|}
name|regfree
argument_list|(
operator|&
name|re
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
return|return
name|ret
return|;
block|}
end_function

begin_struct
struct|struct
name|ucl_compare_node
block|{
specifier|const
name|ucl_object_t
modifier|*
name|obj
decl_stmt|;
name|TREE_ENTRY
argument_list|(
argument|ucl_compare_node
argument_list|)
name|link
expr_stmt|;
name|struct
name|ucl_compare_node
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|TREE_HEAD
argument_list|(
argument|_tree
argument_list|,
argument|ucl_compare_node
argument_list|)
name|ucl_compare_tree_t
expr_stmt|;
end_typedef

begin_macro
name|TREE_DEFINE
argument_list|(
argument|ucl_compare_node
argument_list|,
argument|link
argument_list|)
end_macro

begin_function
specifier|static
name|int
name|ucl_schema_elt_compare
parameter_list|(
name|struct
name|ucl_compare_node
modifier|*
name|n1
parameter_list|,
name|struct
name|ucl_compare_node
modifier|*
name|n2
parameter_list|)
block|{
specifier|const
name|ucl_object_t
modifier|*
name|o1
init|=
name|n1
operator|->
name|obj
decl_stmt|,
modifier|*
name|o2
init|=
name|n2
operator|->
name|obj
decl_stmt|;
return|return
name|ucl_object_compare
argument_list|(
name|o1
argument_list|,
name|o2
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|ucl_schema_array_is_unique
parameter_list|(
specifier|const
name|ucl_object_t
modifier|*
name|obj
parameter_list|,
name|struct
name|ucl_schema_error
modifier|*
name|err
parameter_list|)
block|{
name|ucl_compare_tree_t
name|tree
init|=
name|TREE_INITIALIZER
argument_list|(
name|ucl_schema_elt_compare
argument_list|)
decl_stmt|;
name|ucl_object_iter_t
name|iter
init|=
name|NULL
decl_stmt|;
specifier|const
name|ucl_object_t
modifier|*
name|elt
decl_stmt|;
name|struct
name|ucl_compare_node
modifier|*
name|node
decl_stmt|,
name|test
decl_stmt|,
modifier|*
name|nodes
init|=
name|NULL
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
name|bool
name|ret
init|=
name|true
decl_stmt|;
while|while
condition|(
operator|(
name|elt
operator|=
name|ucl_iterate_object
argument_list|(
name|obj
argument_list|,
operator|&
name|iter
argument_list|,
name|true
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|test
operator|.
name|obj
operator|=
name|elt
expr_stmt|;
name|node
operator|=
name|TREE_FIND
argument_list|(
operator|&
name|tree
argument_list|,
name|ucl_compare_node
argument_list|,
name|link
argument_list|,
operator|&
name|test
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|!=
name|NULL
condition|)
block|{
name|ucl_schema_create_error
argument_list|(
name|err
argument_list|,
name|UCL_SCHEMA_CONSTRAINT
argument_list|,
name|elt
argument_list|,
literal|"duplicate values detected while uniqueItems is true"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|false
expr_stmt|;
break|break;
block|}
name|node
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|node
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|==
name|NULL
condition|)
block|{
name|ucl_schema_create_error
argument_list|(
name|err
argument_list|,
name|UCL_SCHEMA_UNKNOWN
argument_list|,
name|elt
argument_list|,
literal|"cannot allocate tree node"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|false
expr_stmt|;
break|break;
block|}
name|node
operator|->
name|obj
operator|=
name|elt
expr_stmt|;
name|TREE_INSERT
argument_list|(
operator|&
name|tree
argument_list|,
name|ucl_compare_node
argument_list|,
name|link
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|LL_PREPEND
argument_list|(
name|nodes
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
name|LL_FOREACH_SAFE
argument_list|(
argument|nodes
argument_list|,
argument|node
argument_list|,
argument|tmp
argument_list|)
block|{
name|free
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|ucl_schema_validate_array
parameter_list|(
specifier|const
name|ucl_object_t
modifier|*
name|schema
parameter_list|,
specifier|const
name|ucl_object_t
modifier|*
name|obj
parameter_list|,
name|struct
name|ucl_schema_error
modifier|*
name|err
parameter_list|,
specifier|const
name|ucl_object_t
modifier|*
name|root
parameter_list|)
block|{
specifier|const
name|ucl_object_t
modifier|*
name|elt
decl_stmt|,
modifier|*
name|it
decl_stmt|,
modifier|*
name|found
decl_stmt|,
modifier|*
name|additional_schema
init|=
name|NULL
decl_stmt|,
modifier|*
name|first_unvalidated
init|=
name|NULL
decl_stmt|;
name|ucl_object_iter_t
name|iter
init|=
name|NULL
decl_stmt|,
name|piter
init|=
name|NULL
decl_stmt|;
name|bool
name|ret
init|=
name|true
decl_stmt|,
name|allow_additional
init|=
name|true
decl_stmt|,
name|need_unique
init|=
name|false
decl_stmt|;
name|int64_t
name|minmax
decl_stmt|;
while|while
condition|(
name|ret
operator|&&
operator|(
name|elt
operator|=
name|ucl_iterate_object
argument_list|(
name|schema
argument_list|,
operator|&
name|iter
argument_list|,
name|true
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|ucl_object_key
argument_list|(
name|elt
argument_list|)
argument_list|,
literal|"items"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|elt
operator|->
name|type
operator|==
name|UCL_ARRAY
condition|)
block|{
name|found
operator|=
name|obj
operator|->
name|value
operator|.
name|av
expr_stmt|;
while|while
condition|(
name|ret
operator|&&
operator|(
name|it
operator|=
name|ucl_iterate_object
argument_list|(
name|elt
argument_list|,
operator|&
name|piter
argument_list|,
name|true
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|found
condition|)
block|{
name|ret
operator|=
name|ucl_schema_validate
argument_list|(
name|it
argument_list|,
name|found
argument_list|,
name|false
argument_list|,
name|err
argument_list|,
name|root
argument_list|)
expr_stmt|;
name|found
operator|=
name|found
operator|->
name|next
expr_stmt|;
block|}
block|}
if|if
condition|(
name|found
operator|!=
name|NULL
condition|)
block|{
comment|/* The first element that is not validated */
name|first_unvalidated
operator|=
name|found
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|elt
operator|->
name|type
operator|==
name|UCL_OBJECT
condition|)
block|{
comment|/* Validate all items using the specified schema */
while|while
condition|(
name|ret
operator|&&
operator|(
name|it
operator|=
name|ucl_iterate_object
argument_list|(
name|obj
argument_list|,
operator|&
name|piter
argument_list|,
name|true
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|ret
operator|=
name|ucl_schema_validate
argument_list|(
name|elt
argument_list|,
name|it
argument_list|,
name|false
argument_list|,
name|err
argument_list|,
name|root
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|ucl_schema_create_error
argument_list|(
name|err
argument_list|,
name|UCL_SCHEMA_INVALID_SCHEMA
argument_list|,
name|elt
argument_list|,
literal|"items attribute is invalid in schema"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|false
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|ucl_object_key
argument_list|(
name|elt
argument_list|)
argument_list|,
literal|"additionalItems"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|elt
operator|->
name|type
operator|==
name|UCL_BOOLEAN
condition|)
block|{
if|if
condition|(
operator|!
name|ucl_object_toboolean
argument_list|(
name|elt
argument_list|)
condition|)
block|{
comment|/* Deny additional fields completely */
name|allow_additional
operator|=
name|false
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|elt
operator|->
name|type
operator|==
name|UCL_OBJECT
condition|)
block|{
comment|/* Define validator for additional fields */
name|additional_schema
operator|=
name|elt
expr_stmt|;
block|}
else|else
block|{
name|ucl_schema_create_error
argument_list|(
name|err
argument_list|,
name|UCL_SCHEMA_INVALID_SCHEMA
argument_list|,
name|elt
argument_list|,
literal|"additionalItems attribute is invalid in schema"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|false
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|elt
operator|->
name|type
operator|==
name|UCL_BOOLEAN
operator|&&
name|strcmp
argument_list|(
name|ucl_object_key
argument_list|(
name|elt
argument_list|)
argument_list|,
literal|"uniqueItems"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|need_unique
operator|=
name|ucl_object_toboolean
argument_list|(
name|elt
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|ucl_object_key
argument_list|(
name|elt
argument_list|)
argument_list|,
literal|"minItems"
argument_list|)
operator|==
literal|0
operator|&&
name|ucl_object_toint_safe
argument_list|(
name|elt
argument_list|,
operator|&
name|minmax
argument_list|)
condition|)
block|{
if|if
condition|(
name|obj
operator|->
name|len
operator|<
name|minmax
condition|)
block|{
name|ucl_schema_create_error
argument_list|(
name|err
argument_list|,
name|UCL_SCHEMA_CONSTRAINT
argument_list|,
name|obj
argument_list|,
literal|"array has not enough items: %u, minimum is: %u"
argument_list|,
name|obj
operator|->
name|len
argument_list|,
operator|(
name|unsigned
operator|)
name|minmax
argument_list|)
expr_stmt|;
name|ret
operator|=
name|false
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|ucl_object_key
argument_list|(
name|elt
argument_list|)
argument_list|,
literal|"maxItems"
argument_list|)
operator|==
literal|0
operator|&&
name|ucl_object_toint_safe
argument_list|(
name|elt
argument_list|,
operator|&
name|minmax
argument_list|)
condition|)
block|{
if|if
condition|(
name|obj
operator|->
name|len
operator|>
name|minmax
condition|)
block|{
name|ucl_schema_create_error
argument_list|(
name|err
argument_list|,
name|UCL_SCHEMA_CONSTRAINT
argument_list|,
name|obj
argument_list|,
literal|"array has too many items: %u, maximum is: %u"
argument_list|,
name|obj
operator|->
name|len
argument_list|,
operator|(
name|unsigned
operator|)
name|minmax
argument_list|)
expr_stmt|;
name|ret
operator|=
name|false
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|ret
condition|)
block|{
comment|/* Additional properties */
if|if
condition|(
operator|!
name|allow_additional
operator|||
name|additional_schema
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|first_unvalidated
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|allow_additional
condition|)
block|{
name|ucl_schema_create_error
argument_list|(
name|err
argument_list|,
name|UCL_SCHEMA_CONSTRAINT
argument_list|,
name|obj
argument_list|,
literal|"array has undefined item"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|additional_schema
operator|!=
name|NULL
condition|)
block|{
name|elt
operator|=
name|first_unvalidated
expr_stmt|;
while|while
condition|(
name|elt
condition|)
block|{
if|if
condition|(
operator|!
name|ucl_schema_validate
argument_list|(
name|additional_schema
argument_list|,
name|elt
argument_list|,
name|false
argument_list|,
name|err
argument_list|,
name|root
argument_list|)
condition|)
block|{
name|ret
operator|=
name|false
expr_stmt|;
break|break;
block|}
name|elt
operator|=
name|elt
operator|->
name|next
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* Required properties */
if|if
condition|(
name|ret
operator|&&
name|need_unique
condition|)
block|{
name|ret
operator|=
name|ucl_schema_array_is_unique
argument_list|(
name|obj
argument_list|,
name|err
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * Returns whether this object is allowed for this type  */
end_comment

begin_function
specifier|static
name|bool
name|ucl_schema_type_is_allowed
parameter_list|(
specifier|const
name|ucl_object_t
modifier|*
name|type
parameter_list|,
specifier|const
name|ucl_object_t
modifier|*
name|obj
parameter_list|,
name|struct
name|ucl_schema_error
modifier|*
name|err
parameter_list|)
block|{
name|ucl_object_iter_t
name|iter
init|=
name|NULL
decl_stmt|;
specifier|const
name|ucl_object_t
modifier|*
name|elt
decl_stmt|;
specifier|const
name|char
modifier|*
name|type_str
decl_stmt|;
name|ucl_type_t
name|t
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|NULL
condition|)
block|{
comment|/* Any type is allowed */
return|return
name|true
return|;
block|}
if|if
condition|(
name|type
operator|->
name|type
operator|==
name|UCL_ARRAY
condition|)
block|{
comment|/* One of allowed types */
while|while
condition|(
operator|(
name|elt
operator|=
name|ucl_iterate_object
argument_list|(
name|type
argument_list|,
operator|&
name|iter
argument_list|,
name|true
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ucl_schema_type_is_allowed
argument_list|(
name|elt
argument_list|,
name|obj
argument_list|,
name|err
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|type
operator|->
name|type
operator|==
name|UCL_STRING
condition|)
block|{
name|type_str
operator|=
name|ucl_object_tostring
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ucl_string_to_type
argument_list|(
name|type_str
argument_list|,
operator|&
name|t
argument_list|)
condition|)
block|{
name|ucl_schema_create_error
argument_list|(
name|err
argument_list|,
name|UCL_SCHEMA_INVALID_SCHEMA
argument_list|,
name|type
argument_list|,
literal|"Type attribute is invalid in schema"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|obj
operator|->
name|type
operator|!=
name|t
condition|)
block|{
comment|/* Some types are actually compatible */
if|if
condition|(
name|obj
operator|->
name|type
operator|==
name|UCL_TIME
operator|&&
name|t
operator|==
name|UCL_FLOAT
condition|)
block|{
return|return
name|true
return|;
block|}
elseif|else
if|if
condition|(
name|obj
operator|->
name|type
operator|==
name|UCL_INT
operator|&&
name|t
operator|==
name|UCL_FLOAT
condition|)
block|{
return|return
name|true
return|;
block|}
else|else
block|{
name|ucl_schema_create_error
argument_list|(
name|err
argument_list|,
name|UCL_SCHEMA_TYPE_MISMATCH
argument_list|,
name|obj
argument_list|,
literal|"Invalid type of %s, expected %s"
argument_list|,
name|ucl_object_type_to_string
argument_list|(
name|obj
operator|->
name|type
argument_list|)
argument_list|,
name|ucl_object_type_to_string
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Types are equal */
return|return
name|true
return|;
block|}
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/*  * Check if object is equal to one of elements of enum  */
end_comment

begin_function
specifier|static
name|bool
name|ucl_schema_validate_enum
parameter_list|(
specifier|const
name|ucl_object_t
modifier|*
name|en
parameter_list|,
specifier|const
name|ucl_object_t
modifier|*
name|obj
parameter_list|,
name|struct
name|ucl_schema_error
modifier|*
name|err
parameter_list|)
block|{
name|ucl_object_iter_t
name|iter
init|=
name|NULL
decl_stmt|;
specifier|const
name|ucl_object_t
modifier|*
name|elt
decl_stmt|;
name|bool
name|ret
init|=
name|false
decl_stmt|;
while|while
condition|(
operator|(
name|elt
operator|=
name|ucl_iterate_object
argument_list|(
name|en
argument_list|,
operator|&
name|iter
argument_list|,
name|true
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ucl_object_compare
argument_list|(
name|elt
argument_list|,
name|obj
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ret
operator|=
name|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|ret
condition|)
block|{
name|ucl_schema_create_error
argument_list|(
name|err
argument_list|,
name|UCL_SCHEMA_CONSTRAINT
argument_list|,
name|obj
argument_list|,
literal|"object is not one of enumerated patterns"
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * Check a single ref component  */
end_comment

begin_function
specifier|static
specifier|const
name|ucl_object_t
modifier|*
name|ucl_schema_resolve_ref_component
parameter_list|(
specifier|const
name|ucl_object_t
modifier|*
name|cur
parameter_list|,
specifier|const
name|char
modifier|*
name|refc
parameter_list|,
name|int
name|len
parameter_list|,
name|struct
name|ucl_schema_error
modifier|*
name|err
parameter_list|)
block|{
specifier|const
name|ucl_object_t
modifier|*
name|res
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|err_str
decl_stmt|;
name|int
name|num
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
name|cur
operator|->
name|type
operator|==
name|UCL_OBJECT
condition|)
block|{
comment|/* Find a key inside an object */
name|res
operator|=
name|ucl_object_find_keyl
argument_list|(
name|cur
argument_list|,
name|refc
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
name|NULL
condition|)
block|{
name|ucl_schema_create_error
argument_list|(
name|err
argument_list|,
name|UCL_SCHEMA_INVALID_SCHEMA
argument_list|,
name|cur
argument_list|,
literal|"reference %s is invalid, missing path component"
argument_list|,
name|refc
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|cur
operator|->
name|type
operator|==
name|UCL_ARRAY
condition|)
block|{
comment|/* We must figure out a number inside array */
name|num
operator|=
name|strtoul
argument_list|(
name|refc
argument_list|,
operator|&
name|err_str
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|err_str
operator|!=
name|NULL
operator|&&
operator|*
name|err_str
operator|!=
literal|'/'
operator|&&
operator|*
name|err_str
operator|!=
literal|'\0'
condition|)
block|{
name|ucl_schema_create_error
argument_list|(
name|err
argument_list|,
name|UCL_SCHEMA_INVALID_SCHEMA
argument_list|,
name|cur
argument_list|,
literal|"reference %s is invalid, invalid item number"
argument_list|,
name|refc
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|res
operator|=
name|cur
operator|->
name|value
operator|.
name|av
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|res
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|i
operator|==
name|num
condition|)
block|{
break|break;
block|}
name|res
operator|=
name|res
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|res
operator|==
name|NULL
condition|)
block|{
name|ucl_schema_create_error
argument_list|(
name|err
argument_list|,
name|UCL_SCHEMA_INVALID_SCHEMA
argument_list|,
name|cur
argument_list|,
literal|"reference %s is invalid, item number %d does not exist"
argument_list|,
name|refc
argument_list|,
name|num
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
else|else
block|{
name|ucl_schema_create_error
argument_list|(
name|err
argument_list|,
name|UCL_SCHEMA_INVALID_SCHEMA
argument_list|,
name|res
argument_list|,
literal|"reference %s is invalid, contains primitive object in the path"
argument_list|,
name|refc
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/*  * Find reference schema  */
end_comment

begin_function
specifier|static
specifier|const
name|ucl_object_t
modifier|*
name|ucl_schema_resolve_ref
parameter_list|(
specifier|const
name|ucl_object_t
modifier|*
name|root
parameter_list|,
specifier|const
name|char
modifier|*
name|ref
parameter_list|,
name|struct
name|ucl_schema_error
modifier|*
name|err
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|c
decl_stmt|;
specifier|const
name|ucl_object_t
modifier|*
name|res
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|ref
index|[
literal|0
index|]
operator|!=
literal|'#'
condition|)
block|{
name|ucl_schema_create_error
argument_list|(
name|err
argument_list|,
name|UCL_SCHEMA_INVALID_SCHEMA
argument_list|,
name|root
argument_list|,
literal|"reference %s is invalid, not started with #"
argument_list|,
name|ref
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|ref
index|[
literal|1
index|]
operator|==
literal|'/'
condition|)
block|{
name|p
operator|=
operator|&
name|ref
index|[
literal|2
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ref
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
block|{
return|return
name|root
return|;
block|}
else|else
block|{
name|ucl_schema_create_error
argument_list|(
name|err
argument_list|,
name|UCL_SCHEMA_INVALID_SCHEMA
argument_list|,
name|root
argument_list|,
literal|"reference %s is invalid, not started with #/"
argument_list|,
name|ref
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|c
operator|=
name|p
expr_stmt|;
name|res
operator|=
name|root
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'/'
condition|)
block|{
if|if
condition|(
name|p
operator|-
name|c
operator|==
literal|0
condition|)
block|{
name|ucl_schema_create_error
argument_list|(
name|err
argument_list|,
name|UCL_SCHEMA_INVALID_SCHEMA
argument_list|,
name|res
argument_list|,
literal|"reference %s is invalid, empty path component"
argument_list|,
name|ref
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Now we have some url part, so we need to figure out where we are */
name|res
operator|=
name|ucl_schema_resolve_ref_component
argument_list|(
name|res
argument_list|,
name|c
argument_list|,
name|p
operator|-
name|c
argument_list|,
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
name|NULL
condition|)
block|{
return|return
name|NULL
return|;
block|}
name|c
operator|=
name|p
operator|+
literal|1
expr_stmt|;
block|}
name|p
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|-
name|c
operator|!=
literal|0
condition|)
block|{
name|res
operator|=
name|ucl_schema_resolve_ref_component
argument_list|(
name|res
argument_list|,
name|c
argument_list|,
name|p
operator|-
name|c
argument_list|,
name|err
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|res
operator|==
name|NULL
operator|||
name|res
operator|->
name|type
operator|!=
name|UCL_OBJECT
condition|)
block|{
name|ucl_schema_create_error
argument_list|(
name|err
argument_list|,
name|UCL_SCHEMA_INVALID_SCHEMA
argument_list|,
name|res
argument_list|,
literal|"reference %s is invalid, cannot find specified object"
argument_list|,
name|ref
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|res
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|ucl_schema_validate_values
parameter_list|(
specifier|const
name|ucl_object_t
modifier|*
name|schema
parameter_list|,
specifier|const
name|ucl_object_t
modifier|*
name|obj
parameter_list|,
name|struct
name|ucl_schema_error
modifier|*
name|err
parameter_list|)
block|{
specifier|const
name|ucl_object_t
modifier|*
name|elt
decl_stmt|,
modifier|*
name|cur
decl_stmt|;
name|int64_t
name|constraint
decl_stmt|,
name|i
decl_stmt|;
name|elt
operator|=
name|ucl_object_find_key
argument_list|(
name|schema
argument_list|,
literal|"maxValues"
argument_list|)
expr_stmt|;
if|if
condition|(
name|elt
operator|!=
name|NULL
operator|&&
name|elt
operator|->
name|type
operator|==
name|UCL_INT
condition|)
block|{
name|constraint
operator|=
name|ucl_object_toint
argument_list|(
name|elt
argument_list|)
expr_stmt|;
name|cur
operator|=
name|obj
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|cur
condition|)
block|{
if|if
condition|(
name|i
operator|>
name|constraint
condition|)
block|{
name|ucl_schema_create_error
argument_list|(
name|err
argument_list|,
name|UCL_SCHEMA_CONSTRAINT
argument_list|,
name|obj
argument_list|,
literal|"object has more values than defined: %ld"
argument_list|,
operator|(
name|long
name|int
operator|)
name|constraint
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|i
operator|++
expr_stmt|;
name|cur
operator|=
name|cur
operator|->
name|next
expr_stmt|;
block|}
block|}
name|elt
operator|=
name|ucl_object_find_key
argument_list|(
name|schema
argument_list|,
literal|"minValues"
argument_list|)
expr_stmt|;
if|if
condition|(
name|elt
operator|!=
name|NULL
operator|&&
name|elt
operator|->
name|type
operator|==
name|UCL_INT
condition|)
block|{
name|constraint
operator|=
name|ucl_object_toint
argument_list|(
name|elt
argument_list|)
expr_stmt|;
name|cur
operator|=
name|obj
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|cur
condition|)
block|{
if|if
condition|(
name|i
operator|>=
name|constraint
condition|)
block|{
break|break;
block|}
name|i
operator|++
expr_stmt|;
name|cur
operator|=
name|cur
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|<
name|constraint
condition|)
block|{
name|ucl_schema_create_error
argument_list|(
name|err
argument_list|,
name|UCL_SCHEMA_CONSTRAINT
argument_list|,
name|obj
argument_list|,
literal|"object has less values than defined: %ld"
argument_list|,
operator|(
name|long
name|int
operator|)
name|constraint
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|ucl_schema_validate
parameter_list|(
specifier|const
name|ucl_object_t
modifier|*
name|schema
parameter_list|,
specifier|const
name|ucl_object_t
modifier|*
name|obj
parameter_list|,
name|bool
name|try_array
parameter_list|,
name|struct
name|ucl_schema_error
modifier|*
name|err
parameter_list|,
specifier|const
name|ucl_object_t
modifier|*
name|root
parameter_list|)
block|{
specifier|const
name|ucl_object_t
modifier|*
name|elt
decl_stmt|,
modifier|*
name|cur
decl_stmt|;
name|ucl_object_iter_t
name|iter
init|=
name|NULL
decl_stmt|;
name|bool
name|ret
decl_stmt|;
if|if
condition|(
name|schema
operator|->
name|type
operator|!=
name|UCL_OBJECT
condition|)
block|{
name|ucl_schema_create_error
argument_list|(
name|err
argument_list|,
name|UCL_SCHEMA_INVALID_SCHEMA
argument_list|,
name|schema
argument_list|,
literal|"schema is %s instead of object"
argument_list|,
name|ucl_object_type_to_string
argument_list|(
name|schema
operator|->
name|type
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|try_array
condition|)
block|{
comment|/* 		 * Special case for multiple values 		 */
if|if
condition|(
operator|!
name|ucl_schema_validate_values
argument_list|(
name|schema
argument_list|,
name|obj
argument_list|,
name|err
argument_list|)
condition|)
block|{
return|return
name|false
return|;
block|}
name|LL_FOREACH
argument_list|(
argument|obj
argument_list|,
argument|cur
argument_list|)
block|{
if|if
condition|(
operator|!
name|ucl_schema_validate
argument_list|(
name|schema
argument_list|,
name|cur
argument_list|,
name|false
argument_list|,
name|err
argument_list|,
name|root
argument_list|)
condition|)
block|{
return|return
name|false
return|;
block|}
block|}
return|return
name|true
return|;
block|}
name|elt
operator|=
name|ucl_object_find_key
argument_list|(
name|schema
argument_list|,
literal|"enum"
argument_list|)
expr_stmt|;
if|if
condition|(
name|elt
operator|!=
name|NULL
operator|&&
name|elt
operator|->
name|type
operator|==
name|UCL_ARRAY
condition|)
block|{
if|if
condition|(
operator|!
name|ucl_schema_validate_enum
argument_list|(
name|elt
argument_list|,
name|obj
argument_list|,
name|err
argument_list|)
condition|)
block|{
return|return
name|false
return|;
block|}
block|}
name|elt
operator|=
name|ucl_object_find_key
argument_list|(
name|schema
argument_list|,
literal|"allOf"
argument_list|)
expr_stmt|;
if|if
condition|(
name|elt
operator|!=
name|NULL
operator|&&
name|elt
operator|->
name|type
operator|==
name|UCL_ARRAY
condition|)
block|{
name|iter
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|(
name|cur
operator|=
name|ucl_iterate_object
argument_list|(
name|elt
argument_list|,
operator|&
name|iter
argument_list|,
name|true
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|ret
operator|=
name|ucl_schema_validate
argument_list|(
name|cur
argument_list|,
name|obj
argument_list|,
name|true
argument_list|,
name|err
argument_list|,
name|root
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
block|{
return|return
name|false
return|;
block|}
block|}
block|}
name|elt
operator|=
name|ucl_object_find_key
argument_list|(
name|schema
argument_list|,
literal|"anyOf"
argument_list|)
expr_stmt|;
if|if
condition|(
name|elt
operator|!=
name|NULL
operator|&&
name|elt
operator|->
name|type
operator|==
name|UCL_ARRAY
condition|)
block|{
name|iter
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|(
name|cur
operator|=
name|ucl_iterate_object
argument_list|(
name|elt
argument_list|,
operator|&
name|iter
argument_list|,
name|true
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|ret
operator|=
name|ucl_schema_validate
argument_list|(
name|cur
argument_list|,
name|obj
argument_list|,
name|true
argument_list|,
name|err
argument_list|,
name|root
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|ret
condition|)
block|{
return|return
name|false
return|;
block|}
else|else
block|{
comment|/* Reset error */
name|err
operator|->
name|code
operator|=
name|UCL_SCHEMA_OK
expr_stmt|;
block|}
block|}
name|elt
operator|=
name|ucl_object_find_key
argument_list|(
name|schema
argument_list|,
literal|"oneOf"
argument_list|)
expr_stmt|;
if|if
condition|(
name|elt
operator|!=
name|NULL
operator|&&
name|elt
operator|->
name|type
operator|==
name|UCL_ARRAY
condition|)
block|{
name|iter
operator|=
name|NULL
expr_stmt|;
name|ret
operator|=
name|false
expr_stmt|;
while|while
condition|(
operator|(
name|cur
operator|=
name|ucl_iterate_object
argument_list|(
name|elt
argument_list|,
operator|&
name|iter
argument_list|,
name|true
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|ret
condition|)
block|{
name|ret
operator|=
name|ucl_schema_validate
argument_list|(
name|cur
argument_list|,
name|obj
argument_list|,
name|true
argument_list|,
name|err
argument_list|,
name|root
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ucl_schema_validate
argument_list|(
name|cur
argument_list|,
name|obj
argument_list|,
name|true
argument_list|,
name|err
argument_list|,
name|root
argument_list|)
condition|)
block|{
name|ret
operator|=
name|false
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|ret
condition|)
block|{
return|return
name|false
return|;
block|}
block|}
name|elt
operator|=
name|ucl_object_find_key
argument_list|(
name|schema
argument_list|,
literal|"not"
argument_list|)
expr_stmt|;
if|if
condition|(
name|elt
operator|!=
name|NULL
operator|&&
name|elt
operator|->
name|type
operator|==
name|UCL_OBJECT
condition|)
block|{
if|if
condition|(
name|ucl_schema_validate
argument_list|(
name|elt
argument_list|,
name|obj
argument_list|,
name|true
argument_list|,
name|err
argument_list|,
name|root
argument_list|)
condition|)
block|{
return|return
name|false
return|;
block|}
else|else
block|{
comment|/* Reset error */
name|err
operator|->
name|code
operator|=
name|UCL_SCHEMA_OK
expr_stmt|;
block|}
block|}
name|elt
operator|=
name|ucl_object_find_key
argument_list|(
name|schema
argument_list|,
literal|"$ref"
argument_list|)
expr_stmt|;
if|if
condition|(
name|elt
operator|!=
name|NULL
condition|)
block|{
name|cur
operator|=
name|ucl_schema_resolve_ref
argument_list|(
name|root
argument_list|,
name|ucl_object_tostring
argument_list|(
name|elt
argument_list|)
argument_list|,
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|cur
operator|==
name|NULL
condition|)
block|{
return|return
name|false
return|;
block|}
if|if
condition|(
operator|!
name|ucl_schema_validate
argument_list|(
name|cur
argument_list|,
name|obj
argument_list|,
name|try_array
argument_list|,
name|err
argument_list|,
name|root
argument_list|)
condition|)
block|{
return|return
name|false
return|;
block|}
block|}
name|elt
operator|=
name|ucl_object_find_key
argument_list|(
name|schema
argument_list|,
literal|"type"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ucl_schema_type_is_allowed
argument_list|(
name|elt
argument_list|,
name|obj
argument_list|,
name|err
argument_list|)
condition|)
block|{
return|return
name|false
return|;
block|}
switch|switch
condition|(
name|obj
operator|->
name|type
condition|)
block|{
case|case
name|UCL_OBJECT
case|:
return|return
name|ucl_schema_validate_object
argument_list|(
name|schema
argument_list|,
name|obj
argument_list|,
name|err
argument_list|,
name|root
argument_list|)
return|;
break|break;
case|case
name|UCL_ARRAY
case|:
return|return
name|ucl_schema_validate_array
argument_list|(
name|schema
argument_list|,
name|obj
argument_list|,
name|err
argument_list|,
name|root
argument_list|)
return|;
break|break;
case|case
name|UCL_INT
case|:
case|case
name|UCL_FLOAT
case|:
return|return
name|ucl_schema_validate_number
argument_list|(
name|schema
argument_list|,
name|obj
argument_list|,
name|err
argument_list|)
return|;
break|break;
case|case
name|UCL_STRING
case|:
return|return
name|ucl_schema_validate_string
argument_list|(
name|schema
argument_list|,
name|obj
argument_list|,
name|err
argument_list|)
return|;
break|break;
default|default:
break|break;
block|}
return|return
name|true
return|;
block|}
end_function

begin_function
name|bool
name|ucl_object_validate
parameter_list|(
specifier|const
name|ucl_object_t
modifier|*
name|schema
parameter_list|,
specifier|const
name|ucl_object_t
modifier|*
name|obj
parameter_list|,
name|struct
name|ucl_schema_error
modifier|*
name|err
parameter_list|)
block|{
return|return
name|ucl_schema_validate
argument_list|(
name|schema
argument_list|,
name|obj
argument_list|,
name|true
argument_list|,
name|err
argument_list|,
name|schema
argument_list|)
return|;
block|}
end_function

end_unit

