begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* xxHash - Fast Hash algorithm Copyright (C) 2012-2014, Yann Collet. BSD 2-Clause License (http://www.opensource.org/licenses/bsd-license.php)  Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:  * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  You can contact the author at : - xxHash source repository : http://code.google.com/p/xxhash/ - public discussion board : https://groups.google.com/forum/#!forum/lz4c */
end_comment

begin_comment
comment|//**************************************
end_comment

begin_comment
comment|// Tuning parameters
end_comment

begin_comment
comment|//**************************************
end_comment

begin_comment
comment|// Unaligned memory access is automatically enabled for "common" CPU, such as x86.
end_comment

begin_comment
comment|// For others CPU, the compiler will be more cautious, and insert extra code to ensure aligned access is respected.
end_comment

begin_comment
comment|// If you know your target CPU supports unaligned memory access, you want to force this option manually to improve performance.
end_comment

begin_comment
comment|// You can also enable this parameter if you know your input data will always be aligned (boundaries of 4, for U32).
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__ARM_FEATURE_UNALIGNED
argument_list|)
operator|||
name|defined
argument_list|(
name|__i386
argument_list|)
operator|||
name|defined
argument_list|(
name|_M_IX86
argument_list|)
operator|||
name|defined
argument_list|(
name|__x86_64__
argument_list|)
operator|||
name|defined
argument_list|(
name|_M_X64
argument_list|)
end_if

begin_define
define|#
directive|define
name|XXH_USE_UNALIGNED_ACCESS
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// XXH_ACCEPT_NULL_INPUT_POINTER :
end_comment

begin_comment
comment|// If the input pointer is a null pointer, xxHash default behavior is to trigger a memory access error, since it is a bad pointer.
end_comment

begin_comment
comment|// When this option is enabled, xxHash output for null input pointers will be the same as a null-length input.
end_comment

begin_comment
comment|// This option has a very small performance cost (only measurable on small inputs).
end_comment

begin_comment
comment|// By default, this option is disabled. To enable it, uncomment below define :
end_comment

begin_comment
comment|// #define XXH_ACCEPT_NULL_INPUT_POINTER 1
end_comment

begin_comment
comment|// XXH_FORCE_NATIVE_FORMAT :
end_comment

begin_comment
comment|// By default, xxHash library provides endian-independant Hash values, based on little-endian convention.
end_comment

begin_comment
comment|// Results are therefore identical for little-endian and big-endian CPU.
end_comment

begin_comment
comment|// This comes at a performance cost for big-endian CPU, since some swapping is required to emulate little-endian format.
end_comment

begin_comment
comment|// Should endian-independance be of no importance for your application, you may set the #define below to 1.
end_comment

begin_comment
comment|// It will improve speed for Big-endian CPU.
end_comment

begin_comment
comment|// This option has no impact on Little_Endian CPU.
end_comment

begin_define
define|#
directive|define
name|XXH_FORCE_NATIVE_FORMAT
value|0
end_define

begin_comment
comment|//**************************************
end_comment

begin_comment
comment|// Compiler Specific Options
end_comment

begin_comment
comment|//**************************************
end_comment

begin_comment
comment|// Disable some Visual warning messages
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|_MSC_VER
end_ifdef

begin_comment
comment|// Visual Studio
end_comment

begin_pragma
pragma|#
directive|pragma
name|warning
name|(
name|disable
name|:
name|4127
name|)
end_pragma

begin_comment
comment|// disable: C4127: conditional expression is constant
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|_MSC_VER
end_ifdef

begin_comment
comment|// Visual Studio
end_comment

begin_define
define|#
directive|define
name|FORCE_INLINE
value|static __forceinline
end_define

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|__GNUC__
end_ifdef

begin_define
define|#
directive|define
name|FORCE_INLINE
value|static inline __attribute__((always_inline))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|FORCE_INLINE
value|static inline
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|//**************************************
end_comment

begin_comment
comment|// Includes& Memory related functions
end_comment

begin_comment
comment|//**************************************
end_comment

begin_include
include|#
directive|include
file|"xxhash.h"
end_include

begin_comment
comment|// Modify the local functions below should you wish to use some other memory routines
end_comment

begin_comment
comment|// for malloc(), free()
end_comment

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_function
specifier|static
name|void
modifier|*
name|XXH_malloc
parameter_list|(
name|size_t
name|s
parameter_list|)
block|{
return|return
name|malloc
argument_list|(
name|s
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|XXH_free
parameter_list|(
name|void
modifier|*
name|p
parameter_list|)
block|{
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|// for memcpy()
end_comment

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_function
specifier|static
name|void
modifier|*
name|XXH_memcpy
parameter_list|(
name|void
modifier|*
name|dest
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
return|return
name|memcpy
argument_list|(
name|dest
argument_list|,
name|src
argument_list|,
name|size
argument_list|)
return|;
block|}
end_function

begin_comment
comment|//**************************************
end_comment

begin_comment
comment|// Basic Types
end_comment

begin_comment
comment|//**************************************
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__STDC_VERSION__
argument_list|)
operator|&&
name|__STDC_VERSION__
operator|>=
literal|199901L
end_if

begin_comment
comment|// C99
end_comment

begin_include
include|#
directive|include
file|<stdint.h>
end_include

begin_typedef
typedef|typedef
name|uint8_t
name|BYTE
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|uint16_t
name|U16
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|uint32_t
name|U32
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|int32_t
name|S32
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|uint64_t
name|U64
typedef|;
end_typedef

begin_else
else|#
directive|else
end_else

begin_typedef
typedef|typedef
name|unsigned
name|char
name|BYTE
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|unsigned
name|short
name|U16
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|unsigned
name|int
name|U32
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|signed
name|int
name|S32
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|uint64_t
name|U64
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__GNUC__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|XXH_USE_UNALIGNED_ACCESS
argument_list|)
end_if

begin_define
define|#
directive|define
name|_PACKED
value|__attribute__ ((packed))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|_PACKED
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|XXH_USE_UNALIGNED_ACCESS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__GNUC__
argument_list|)
end_if

begin_ifdef
ifdef|#
directive|ifdef
name|__IBMC__
end_ifdef

begin_pragma
pragma|#
directive|pragma
name|pack
name|(
name|1
name|)
end_pragma

begin_else
else|#
directive|else
end_else

begin_pragma
pragma|#
directive|pragma
name|pack
name|(
name|push
name|,
name|1
name|)
end_pragma

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_typedef
typedef|typedef
struct|struct
name|_U32_S
block|{
name|U32
name|v
decl_stmt|;
block|}
name|_PACKED
name|U32_S
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|_U64_S
block|{
name|U64
name|v
decl_stmt|;
block|}
name|_PACKED
name|U64_S
typedef|;
end_typedef

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|XXH_USE_UNALIGNED_ACCESS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__GNUC__
argument_list|)
end_if

begin_pragma
pragma|#
directive|pragma
name|pack
name|(
name|pop
name|)
end_pragma

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|A32
parameter_list|(
name|x
parameter_list|)
value|(((U32_S *)(x))->v)
end_define

begin_define
define|#
directive|define
name|A64
parameter_list|(
name|x
parameter_list|)
value|(((U64_S *)(x))->v)
end_define

begin_comment
comment|//***************************************
end_comment

begin_comment
comment|// Compiler-specific Functions and Macros
end_comment

begin_comment
comment|//***************************************
end_comment

begin_define
define|#
directive|define
name|GCC_VERSION
value|(__GNUC__ * 100 + __GNUC_MINOR__)
end_define

begin_comment
comment|// Note : although _rotl exists for minGW (GCC under windows), performance seems poor
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
end_if

begin_define
define|#
directive|define
name|XXH_rotl32
parameter_list|(
name|x
parameter_list|,
name|r
parameter_list|)
value|_rotl(x,r)
end_define

begin_define
define|#
directive|define
name|XXH_rotl64
parameter_list|(
name|x
parameter_list|,
name|r
parameter_list|)
value|_rotl64(x,r)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|XXH_rotl32
parameter_list|(
name|x
parameter_list|,
name|r
parameter_list|)
value|((x<< r) | (x>> (32 - r)))
end_define

begin_define
define|#
directive|define
name|XXH_rotl64
parameter_list|(
name|x
parameter_list|,
name|r
parameter_list|)
value|((x<< r) | (x>> (64 - r)))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
end_if

begin_comment
comment|// Visual Studio
end_comment

begin_define
define|#
directive|define
name|XXH_swap32
value|_byteswap_ulong
end_define

begin_define
define|#
directive|define
name|XXH_swap64
value|_byteswap_uint64
end_define

begin_elif
elif|#
directive|elif
name|GCC_VERSION
operator|>=
literal|403
operator|||
name|defined
argument_list|(
name|__clang__
argument_list|)
end_elif

begin_define
define|#
directive|define
name|XXH_swap32
value|__builtin_bswap32
end_define

begin_define
define|#
directive|define
name|XXH_swap64
value|__builtin_bswap64
end_define

begin_else
else|#
directive|else
end_else

begin_function
specifier|static
specifier|inline
name|U32
name|XXH_swap32
parameter_list|(
name|U32
name|x
parameter_list|)
block|{
return|return
operator|(
operator|(
name|x
operator|<<
literal|24
operator|)
operator|&
literal|0xff000000
operator|)
operator||
operator|(
operator|(
name|x
operator|<<
literal|8
operator|)
operator|&
literal|0x00ff0000
operator|)
operator||
operator|(
operator|(
name|x
operator|>>
literal|8
operator|)
operator|&
literal|0x0000ff00
operator|)
operator||
operator|(
operator|(
name|x
operator|>>
literal|24
operator|)
operator|&
literal|0x000000ff
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|U64
name|XXH_swap64
parameter_list|(
name|U64
name|x
parameter_list|)
block|{
return|return
operator|(
operator|(
name|x
operator|<<
literal|56
operator|)
operator|&
literal|0xff00000000000000ULL
operator|)
operator||
operator|(
operator|(
name|x
operator|<<
literal|40
operator|)
operator|&
literal|0x00ff000000000000ULL
operator|)
operator||
operator|(
operator|(
name|x
operator|<<
literal|24
operator|)
operator|&
literal|0x0000ff0000000000ULL
operator|)
operator||
operator|(
operator|(
name|x
operator|<<
literal|8
operator|)
operator|&
literal|0x000000ff00000000ULL
operator|)
operator||
operator|(
operator|(
name|x
operator|>>
literal|8
operator|)
operator|&
literal|0x00000000ff000000ULL
operator|)
operator||
operator|(
operator|(
name|x
operator|>>
literal|24
operator|)
operator|&
literal|0x0000000000ff0000ULL
operator|)
operator||
operator|(
operator|(
name|x
operator|>>
literal|40
operator|)
operator|&
literal|0x000000000000ff00ULL
operator|)
operator||
operator|(
operator|(
name|x
operator|>>
literal|56
operator|)
operator|&
literal|0x00000000000000ffULL
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|//**************************************
end_comment

begin_comment
comment|// Constants
end_comment

begin_comment
comment|//**************************************
end_comment

begin_define
define|#
directive|define
name|PRIME32_1
value|2654435761U
end_define

begin_define
define|#
directive|define
name|PRIME32_2
value|2246822519U
end_define

begin_define
define|#
directive|define
name|PRIME32_3
value|3266489917U
end_define

begin_define
define|#
directive|define
name|PRIME32_4
value|668265263U
end_define

begin_define
define|#
directive|define
name|PRIME32_5
value|374761393U
end_define

begin_define
define|#
directive|define
name|PRIME64_1
value|11400714785074694791ULL
end_define

begin_define
define|#
directive|define
name|PRIME64_2
value|14029467366897019727ULL
end_define

begin_define
define|#
directive|define
name|PRIME64_3
value|1609587929392839161ULL
end_define

begin_define
define|#
directive|define
name|PRIME64_4
value|9650029242287828579ULL
end_define

begin_define
define|#
directive|define
name|PRIME64_5
value|2870177450012600261ULL
end_define

begin_comment
comment|//**************************************
end_comment

begin_comment
comment|// Architecture Macros
end_comment

begin_comment
comment|//**************************************
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|XXH_bigEndian
init|=
literal|0
block|,
name|XXH_littleEndian
init|=
literal|1
block|}
name|XXH_endianess
typedef|;
end_typedef

begin_ifndef
ifndef|#
directive|ifndef
name|XXH_CPU_LITTLE_ENDIAN
end_ifndef

begin_comment
comment|// It is possible to define XXH_CPU_LITTLE_ENDIAN externally, for example using a compiler switch
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|int
name|one
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|XXH_CPU_LITTLE_ENDIAN
value|(*(char*)(&one))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|//**************************************
end_comment

begin_comment
comment|// Macros
end_comment

begin_comment
comment|//**************************************
end_comment

begin_define
define|#
directive|define
name|XXH_STATIC_ASSERT
parameter_list|(
name|c
parameter_list|)
value|{ enum { XXH_static_assert = 1/(!!(c)) }; }
end_define

begin_comment
comment|// use only *after* variable declarations
end_comment

begin_comment
comment|//****************************
end_comment

begin_comment
comment|// Memory reads
end_comment

begin_comment
comment|//****************************
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|XXH_aligned
block|,
name|XXH_unaligned
block|}
name|XXH_alignment
typedef|;
end_typedef

begin_function
name|FORCE_INLINE
name|U32
name|XXH_readLE32_align
parameter_list|(
specifier|const
name|void
modifier|*
name|ptr
parameter_list|,
name|XXH_endianess
name|endian
parameter_list|,
name|XXH_alignment
name|align
parameter_list|)
block|{
if|if
condition|(
name|align
operator|==
name|XXH_unaligned
condition|)
return|return
name|endian
operator|==
name|XXH_littleEndian
condition|?
name|A32
argument_list|(
name|ptr
argument_list|)
else|:
name|XXH_swap32
argument_list|(
name|A32
argument_list|(
name|ptr
argument_list|)
argument_list|)
return|;
else|else
return|return
name|endian
operator|==
name|XXH_littleEndian
condition|?
operator|*
operator|(
name|U32
operator|*
operator|)
name|ptr
else|:
name|XXH_swap32
argument_list|(
operator|*
operator|(
name|U32
operator|*
operator|)
name|ptr
argument_list|)
return|;
block|}
end_function

begin_function
name|FORCE_INLINE
name|U32
name|XXH_readLE32
parameter_list|(
specifier|const
name|void
modifier|*
name|ptr
parameter_list|,
name|XXH_endianess
name|endian
parameter_list|)
block|{
return|return
name|XXH_readLE32_align
argument_list|(
name|ptr
argument_list|,
name|endian
argument_list|,
name|XXH_unaligned
argument_list|)
return|;
block|}
end_function

begin_function
name|FORCE_INLINE
name|U64
name|XXH_readLE64_align
parameter_list|(
specifier|const
name|void
modifier|*
name|ptr
parameter_list|,
name|XXH_endianess
name|endian
parameter_list|,
name|XXH_alignment
name|align
parameter_list|)
block|{
if|if
condition|(
name|align
operator|==
name|XXH_unaligned
condition|)
return|return
name|endian
operator|==
name|XXH_littleEndian
condition|?
name|A64
argument_list|(
name|ptr
argument_list|)
else|:
name|XXH_swap64
argument_list|(
name|A64
argument_list|(
name|ptr
argument_list|)
argument_list|)
return|;
else|else
return|return
name|endian
operator|==
name|XXH_littleEndian
condition|?
operator|*
operator|(
name|U64
operator|*
operator|)
name|ptr
else|:
name|XXH_swap64
argument_list|(
operator|*
operator|(
name|U64
operator|*
operator|)
name|ptr
argument_list|)
return|;
block|}
end_function

begin_function
name|FORCE_INLINE
name|U64
name|XXH_readLE64
parameter_list|(
specifier|const
name|void
modifier|*
name|ptr
parameter_list|,
name|XXH_endianess
name|endian
parameter_list|)
block|{
return|return
name|XXH_readLE64_align
argument_list|(
name|ptr
argument_list|,
name|endian
argument_list|,
name|XXH_unaligned
argument_list|)
return|;
block|}
end_function

begin_comment
comment|//****************************
end_comment

begin_comment
comment|// Simple Hash Functions
end_comment

begin_comment
comment|//****************************
end_comment

begin_function
name|FORCE_INLINE
name|U32
name|XXH32_endian_align
parameter_list|(
specifier|const
name|void
modifier|*
name|input
parameter_list|,
name|size_t
name|len
parameter_list|,
name|U32
name|seed
parameter_list|,
name|XXH_endianess
name|endian
parameter_list|,
name|XXH_alignment
name|align
parameter_list|)
block|{
specifier|const
name|BYTE
modifier|*
name|p
init|=
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|input
decl_stmt|;
specifier|const
name|BYTE
modifier|*
name|bEnd
init|=
name|p
operator|+
name|len
decl_stmt|;
name|U32
name|h32
decl_stmt|;
define|#
directive|define
name|XXH_get32bits
parameter_list|(
name|p
parameter_list|)
value|XXH_readLE32_align(p, endian, align)
ifdef|#
directive|ifdef
name|XXH_ACCEPT_NULL_INPUT_POINTER
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|len
operator|=
literal|0
expr_stmt|;
name|bEnd
operator|=
name|p
operator|=
operator|(
specifier|const
name|BYTE
operator|*
operator|)
operator|(
name|size_t
operator|)
literal|16
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|len
operator|>=
literal|16
condition|)
block|{
specifier|const
name|BYTE
modifier|*
specifier|const
name|limit
init|=
name|bEnd
operator|-
literal|16
decl_stmt|;
name|U32
name|v1
init|=
name|seed
operator|+
name|PRIME32_1
operator|+
name|PRIME32_2
decl_stmt|;
name|U32
name|v2
init|=
name|seed
operator|+
name|PRIME32_2
decl_stmt|;
name|U32
name|v3
init|=
name|seed
operator|+
literal|0
decl_stmt|;
name|U32
name|v4
init|=
name|seed
operator|-
name|PRIME32_1
decl_stmt|;
do|do
block|{
name|v1
operator|+=
name|XXH_get32bits
argument_list|(
name|p
argument_list|)
operator|*
name|PRIME32_2
expr_stmt|;
name|v1
operator|=
name|XXH_rotl32
argument_list|(
name|v1
argument_list|,
literal|13
argument_list|)
expr_stmt|;
name|v1
operator|*=
name|PRIME32_1
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
name|v2
operator|+=
name|XXH_get32bits
argument_list|(
name|p
argument_list|)
operator|*
name|PRIME32_2
expr_stmt|;
name|v2
operator|=
name|XXH_rotl32
argument_list|(
name|v2
argument_list|,
literal|13
argument_list|)
expr_stmt|;
name|v2
operator|*=
name|PRIME32_1
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
name|v3
operator|+=
name|XXH_get32bits
argument_list|(
name|p
argument_list|)
operator|*
name|PRIME32_2
expr_stmt|;
name|v3
operator|=
name|XXH_rotl32
argument_list|(
name|v3
argument_list|,
literal|13
argument_list|)
expr_stmt|;
name|v3
operator|*=
name|PRIME32_1
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
name|v4
operator|+=
name|XXH_get32bits
argument_list|(
name|p
argument_list|)
operator|*
name|PRIME32_2
expr_stmt|;
name|v4
operator|=
name|XXH_rotl32
argument_list|(
name|v4
argument_list|,
literal|13
argument_list|)
expr_stmt|;
name|v4
operator|*=
name|PRIME32_1
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
block|}
do|while
condition|(
name|p
operator|<=
name|limit
condition|)
do|;
name|h32
operator|=
name|XXH_rotl32
argument_list|(
name|v1
argument_list|,
literal|1
argument_list|)
operator|+
name|XXH_rotl32
argument_list|(
name|v2
argument_list|,
literal|7
argument_list|)
operator|+
name|XXH_rotl32
argument_list|(
name|v3
argument_list|,
literal|12
argument_list|)
operator|+
name|XXH_rotl32
argument_list|(
name|v4
argument_list|,
literal|18
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|h32
operator|=
name|seed
operator|+
name|PRIME32_5
expr_stmt|;
block|}
name|h32
operator|+=
operator|(
name|U32
operator|)
name|len
expr_stmt|;
while|while
condition|(
name|p
operator|+
literal|4
operator|<=
name|bEnd
condition|)
block|{
name|h32
operator|+=
name|XXH_get32bits
argument_list|(
name|p
argument_list|)
operator|*
name|PRIME32_3
expr_stmt|;
name|h32
operator|=
name|XXH_rotl32
argument_list|(
name|h32
argument_list|,
literal|17
argument_list|)
operator|*
name|PRIME32_4
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
block|}
while|while
condition|(
name|p
operator|<
name|bEnd
condition|)
block|{
name|h32
operator|+=
operator|(
operator|*
name|p
operator|)
operator|*
name|PRIME32_5
expr_stmt|;
name|h32
operator|=
name|XXH_rotl32
argument_list|(
name|h32
argument_list|,
literal|11
argument_list|)
operator|*
name|PRIME32_1
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
name|h32
operator|^=
name|h32
operator|>>
literal|15
expr_stmt|;
name|h32
operator|*=
name|PRIME32_2
expr_stmt|;
name|h32
operator|^=
name|h32
operator|>>
literal|13
expr_stmt|;
name|h32
operator|*=
name|PRIME32_3
expr_stmt|;
name|h32
operator|^=
name|h32
operator|>>
literal|16
expr_stmt|;
return|return
name|h32
return|;
block|}
end_function

begin_function
name|unsigned
name|int
name|XXH32
parameter_list|(
specifier|const
name|void
modifier|*
name|input
parameter_list|,
name|size_t
name|len
parameter_list|,
name|unsigned
name|seed
parameter_list|)
block|{
if|#
directive|if
literal|0
comment|// Simple version, good for code maintenance, but unfortunately slow for small inputs
block|XXH32_state_t state;     XXH32_reset(&state, seed);     XXH32_update(&state, input, len);     return XXH32_digest(&state);
else|#
directive|else
name|XXH_endianess
name|endian_detected
init|=
operator|(
name|XXH_endianess
operator|)
name|XXH_CPU_LITTLE_ENDIAN
decl_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|XXH_USE_UNALIGNED_ACCESS
argument_list|)
if|if
condition|(
operator|(
operator|(
operator|(
name|size_t
operator|)
name|input
operator|)
operator|&
literal|3
operator|)
operator|==
literal|0
condition|)
comment|// Input is aligned, let's leverage the speed advantage
block|{
if|if
condition|(
operator|(
name|endian_detected
operator|==
name|XXH_littleEndian
operator|)
operator|||
name|XXH_FORCE_NATIVE_FORMAT
condition|)
return|return
name|XXH32_endian_align
argument_list|(
name|input
argument_list|,
name|len
argument_list|,
name|seed
argument_list|,
name|XXH_littleEndian
argument_list|,
name|XXH_aligned
argument_list|)
return|;
else|else
return|return
name|XXH32_endian_align
argument_list|(
name|input
argument_list|,
name|len
argument_list|,
name|seed
argument_list|,
name|XXH_bigEndian
argument_list|,
name|XXH_aligned
argument_list|)
return|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|(
name|endian_detected
operator|==
name|XXH_littleEndian
operator|)
operator|||
name|XXH_FORCE_NATIVE_FORMAT
condition|)
return|return
name|XXH32_endian_align
argument_list|(
name|input
argument_list|,
name|len
argument_list|,
name|seed
argument_list|,
name|XXH_littleEndian
argument_list|,
name|XXH_unaligned
argument_list|)
return|;
else|else
return|return
name|XXH32_endian_align
argument_list|(
name|input
argument_list|,
name|len
argument_list|,
name|seed
argument_list|,
name|XXH_bigEndian
argument_list|,
name|XXH_unaligned
argument_list|)
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|FORCE_INLINE
name|U64
name|XXH64_endian_align
parameter_list|(
specifier|const
name|void
modifier|*
name|input
parameter_list|,
name|size_t
name|len
parameter_list|,
name|U64
name|seed
parameter_list|,
name|XXH_endianess
name|endian
parameter_list|,
name|XXH_alignment
name|align
parameter_list|)
block|{
specifier|const
name|BYTE
modifier|*
name|p
init|=
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|input
decl_stmt|;
specifier|const
name|BYTE
modifier|*
name|bEnd
init|=
name|p
operator|+
name|len
decl_stmt|;
name|U64
name|h64
decl_stmt|;
define|#
directive|define
name|XXH_get64bits
parameter_list|(
name|p
parameter_list|)
value|XXH_readLE64_align(p, endian, align)
ifdef|#
directive|ifdef
name|XXH_ACCEPT_NULL_INPUT_POINTER
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|len
operator|=
literal|0
expr_stmt|;
name|bEnd
operator|=
name|p
operator|=
operator|(
specifier|const
name|BYTE
operator|*
operator|)
operator|(
name|size_t
operator|)
literal|32
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|len
operator|>=
literal|32
condition|)
block|{
specifier|const
name|BYTE
modifier|*
specifier|const
name|limit
init|=
name|bEnd
operator|-
literal|32
decl_stmt|;
name|U64
name|v1
init|=
name|seed
operator|+
name|PRIME64_1
operator|+
name|PRIME64_2
decl_stmt|;
name|U64
name|v2
init|=
name|seed
operator|+
name|PRIME64_2
decl_stmt|;
name|U64
name|v3
init|=
name|seed
operator|+
literal|0
decl_stmt|;
name|U64
name|v4
init|=
name|seed
operator|-
name|PRIME64_1
decl_stmt|;
do|do
block|{
name|v1
operator|+=
name|XXH_get64bits
argument_list|(
name|p
argument_list|)
operator|*
name|PRIME64_2
expr_stmt|;
name|p
operator|+=
literal|8
expr_stmt|;
name|v1
operator|=
name|XXH_rotl64
argument_list|(
name|v1
argument_list|,
literal|31
argument_list|)
expr_stmt|;
name|v1
operator|*=
name|PRIME64_1
expr_stmt|;
name|v2
operator|+=
name|XXH_get64bits
argument_list|(
name|p
argument_list|)
operator|*
name|PRIME64_2
expr_stmt|;
name|p
operator|+=
literal|8
expr_stmt|;
name|v2
operator|=
name|XXH_rotl64
argument_list|(
name|v2
argument_list|,
literal|31
argument_list|)
expr_stmt|;
name|v2
operator|*=
name|PRIME64_1
expr_stmt|;
name|v3
operator|+=
name|XXH_get64bits
argument_list|(
name|p
argument_list|)
operator|*
name|PRIME64_2
expr_stmt|;
name|p
operator|+=
literal|8
expr_stmt|;
name|v3
operator|=
name|XXH_rotl64
argument_list|(
name|v3
argument_list|,
literal|31
argument_list|)
expr_stmt|;
name|v3
operator|*=
name|PRIME64_1
expr_stmt|;
name|v4
operator|+=
name|XXH_get64bits
argument_list|(
name|p
argument_list|)
operator|*
name|PRIME64_2
expr_stmt|;
name|p
operator|+=
literal|8
expr_stmt|;
name|v4
operator|=
name|XXH_rotl64
argument_list|(
name|v4
argument_list|,
literal|31
argument_list|)
expr_stmt|;
name|v4
operator|*=
name|PRIME64_1
expr_stmt|;
block|}
do|while
condition|(
name|p
operator|<=
name|limit
condition|)
do|;
name|h64
operator|=
name|XXH_rotl64
argument_list|(
name|v1
argument_list|,
literal|1
argument_list|)
operator|+
name|XXH_rotl64
argument_list|(
name|v2
argument_list|,
literal|7
argument_list|)
operator|+
name|XXH_rotl64
argument_list|(
name|v3
argument_list|,
literal|12
argument_list|)
operator|+
name|XXH_rotl64
argument_list|(
name|v4
argument_list|,
literal|18
argument_list|)
expr_stmt|;
name|v1
operator|*=
name|PRIME64_2
expr_stmt|;
name|v1
operator|=
name|XXH_rotl64
argument_list|(
name|v1
argument_list|,
literal|31
argument_list|)
expr_stmt|;
name|v1
operator|*=
name|PRIME64_1
expr_stmt|;
name|h64
operator|^=
name|v1
expr_stmt|;
name|h64
operator|=
name|h64
operator|*
name|PRIME64_1
operator|+
name|PRIME64_4
expr_stmt|;
name|v2
operator|*=
name|PRIME64_2
expr_stmt|;
name|v2
operator|=
name|XXH_rotl64
argument_list|(
name|v2
argument_list|,
literal|31
argument_list|)
expr_stmt|;
name|v2
operator|*=
name|PRIME64_1
expr_stmt|;
name|h64
operator|^=
name|v2
expr_stmt|;
name|h64
operator|=
name|h64
operator|*
name|PRIME64_1
operator|+
name|PRIME64_4
expr_stmt|;
name|v3
operator|*=
name|PRIME64_2
expr_stmt|;
name|v3
operator|=
name|XXH_rotl64
argument_list|(
name|v3
argument_list|,
literal|31
argument_list|)
expr_stmt|;
name|v3
operator|*=
name|PRIME64_1
expr_stmt|;
name|h64
operator|^=
name|v3
expr_stmt|;
name|h64
operator|=
name|h64
operator|*
name|PRIME64_1
operator|+
name|PRIME64_4
expr_stmt|;
name|v4
operator|*=
name|PRIME64_2
expr_stmt|;
name|v4
operator|=
name|XXH_rotl64
argument_list|(
name|v4
argument_list|,
literal|31
argument_list|)
expr_stmt|;
name|v4
operator|*=
name|PRIME64_1
expr_stmt|;
name|h64
operator|^=
name|v4
expr_stmt|;
name|h64
operator|=
name|h64
operator|*
name|PRIME64_1
operator|+
name|PRIME64_4
expr_stmt|;
block|}
else|else
block|{
name|h64
operator|=
name|seed
operator|+
name|PRIME64_5
expr_stmt|;
block|}
name|h64
operator|+=
operator|(
name|U64
operator|)
name|len
expr_stmt|;
while|while
condition|(
name|p
operator|+
literal|8
operator|<=
name|bEnd
condition|)
block|{
name|U64
name|k1
init|=
name|XXH_get64bits
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|k1
operator|*=
name|PRIME64_2
expr_stmt|;
name|k1
operator|=
name|XXH_rotl64
argument_list|(
name|k1
argument_list|,
literal|31
argument_list|)
expr_stmt|;
name|k1
operator|*=
name|PRIME64_1
expr_stmt|;
name|h64
operator|^=
name|k1
expr_stmt|;
name|h64
operator|=
name|XXH_rotl64
argument_list|(
name|h64
argument_list|,
literal|27
argument_list|)
operator|*
name|PRIME64_1
operator|+
name|PRIME64_4
expr_stmt|;
name|p
operator|+=
literal|8
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|+
literal|4
operator|<=
name|bEnd
condition|)
block|{
name|h64
operator|^=
call|(
name|U64
call|)
argument_list|(
name|XXH_get32bits
argument_list|(
name|p
argument_list|)
argument_list|)
operator|*
name|PRIME64_1
expr_stmt|;
name|h64
operator|=
name|XXH_rotl64
argument_list|(
name|h64
argument_list|,
literal|23
argument_list|)
operator|*
name|PRIME64_2
operator|+
name|PRIME64_3
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
block|}
while|while
condition|(
name|p
operator|<
name|bEnd
condition|)
block|{
name|h64
operator|^=
operator|(
operator|*
name|p
operator|)
operator|*
name|PRIME64_5
expr_stmt|;
name|h64
operator|=
name|XXH_rotl64
argument_list|(
name|h64
argument_list|,
literal|11
argument_list|)
operator|*
name|PRIME64_1
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
name|h64
operator|^=
name|h64
operator|>>
literal|33
expr_stmt|;
name|h64
operator|*=
name|PRIME64_2
expr_stmt|;
name|h64
operator|^=
name|h64
operator|>>
literal|29
expr_stmt|;
name|h64
operator|*=
name|PRIME64_3
expr_stmt|;
name|h64
operator|^=
name|h64
operator|>>
literal|32
expr_stmt|;
return|return
name|h64
return|;
block|}
end_function

begin_function
name|uint64_t
name|XXH64
parameter_list|(
specifier|const
name|void
modifier|*
name|input
parameter_list|,
name|size_t
name|len
parameter_list|,
name|uint64_t
name|seed
parameter_list|)
block|{
if|#
directive|if
literal|0
comment|// Simple version, good for code maintenance, but unfortunately slow for small inputs
block|XXH64_state_t state;     XXH64_reset(&state, seed);     XXH64_update(&state, input, len);     return XXH64_digest(&state);
else|#
directive|else
name|XXH_endianess
name|endian_detected
init|=
operator|(
name|XXH_endianess
operator|)
name|XXH_CPU_LITTLE_ENDIAN
decl_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|XXH_USE_UNALIGNED_ACCESS
argument_list|)
if|if
condition|(
operator|(
operator|(
operator|(
name|size_t
operator|)
name|input
operator|)
operator|&
literal|7
operator|)
operator|==
literal|0
condition|)
comment|// Input is aligned, let's leverage the speed advantage
block|{
if|if
condition|(
operator|(
name|endian_detected
operator|==
name|XXH_littleEndian
operator|)
operator|||
name|XXH_FORCE_NATIVE_FORMAT
condition|)
return|return
name|XXH64_endian_align
argument_list|(
name|input
argument_list|,
name|len
argument_list|,
name|seed
argument_list|,
name|XXH_littleEndian
argument_list|,
name|XXH_aligned
argument_list|)
return|;
else|else
return|return
name|XXH64_endian_align
argument_list|(
name|input
argument_list|,
name|len
argument_list|,
name|seed
argument_list|,
name|XXH_bigEndian
argument_list|,
name|XXH_aligned
argument_list|)
return|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|(
name|endian_detected
operator|==
name|XXH_littleEndian
operator|)
operator|||
name|XXH_FORCE_NATIVE_FORMAT
condition|)
return|return
name|XXH64_endian_align
argument_list|(
name|input
argument_list|,
name|len
argument_list|,
name|seed
argument_list|,
name|XXH_littleEndian
argument_list|,
name|XXH_unaligned
argument_list|)
return|;
else|else
return|return
name|XXH64_endian_align
argument_list|(
name|input
argument_list|,
name|len
argument_list|,
name|seed
argument_list|,
name|XXH_bigEndian
argument_list|,
name|XXH_unaligned
argument_list|)
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/****************************************************  *  Advanced Hash Functions ****************************************************/
end_comment

begin_comment
comment|/*** Allocation ***/
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|U64
name|total_len
decl_stmt|;
name|U32
name|seed
decl_stmt|;
name|U32
name|v1
decl_stmt|;
name|U32
name|v2
decl_stmt|;
name|U32
name|v3
decl_stmt|;
name|U32
name|v4
decl_stmt|;
name|U32
name|mem32
index|[
literal|4
index|]
decl_stmt|;
comment|/* defined as U32 for alignment */
name|U32
name|memsize
decl_stmt|;
block|}
name|XXH_istate32_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|U64
name|total_len
decl_stmt|;
name|U64
name|seed
decl_stmt|;
name|U64
name|v1
decl_stmt|;
name|U64
name|v2
decl_stmt|;
name|U64
name|v3
decl_stmt|;
name|U64
name|v4
decl_stmt|;
name|U64
name|mem64
index|[
literal|4
index|]
decl_stmt|;
comment|/* defined as U64 for alignment */
name|U32
name|memsize
decl_stmt|;
block|}
name|XXH_istate64_t
typedef|;
end_typedef

begin_function
name|XXH32_state_t
modifier|*
name|XXH32_createState
parameter_list|(
name|void
parameter_list|)
block|{
name|XXH_STATIC_ASSERT
argument_list|(
sizeof|sizeof
argument_list|(
name|XXH32_state_t
argument_list|)
operator|>=
sizeof|sizeof
argument_list|(
name|XXH_istate32_t
argument_list|)
argument_list|)
expr_stmt|;
comment|// A compilation error here means XXH32_state_t is not large enough
return|return
operator|(
name|XXH32_state_t
operator|*
operator|)
name|XXH_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|XXH32_state_t
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|XXH32_init
parameter_list|(
name|unsigned
name|seed
parameter_list|)
block|{
name|XXH32_state_t
modifier|*
name|st
init|=
name|XXH32_createState
argument_list|()
decl_stmt|;
name|XXH32_reset
argument_list|(
name|st
argument_list|,
name|seed
argument_list|)
expr_stmt|;
return|return
name|st
return|;
block|}
end_function

begin_function
name|XXH_errorcode
name|XXH32_freeState
parameter_list|(
name|XXH32_state_t
modifier|*
name|statePtr
parameter_list|)
block|{
name|XXH_free
argument_list|(
name|statePtr
argument_list|)
expr_stmt|;
return|return
name|XXH_OK
return|;
block|}
end_function

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_function
name|XXH64_state_t
modifier|*
name|XXH64_createState
parameter_list|(
name|void
parameter_list|)
block|{
name|XXH_STATIC_ASSERT
argument_list|(
sizeof|sizeof
argument_list|(
name|XXH64_state_t
argument_list|)
operator|>=
sizeof|sizeof
argument_list|(
name|XXH_istate64_t
argument_list|)
argument_list|)
expr_stmt|;
comment|// A compilation error here means XXH64_state_t is not large enough
return|return
operator|(
name|XXH64_state_t
operator|*
operator|)
name|XXH_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|XXH64_state_t
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|XXH_errorcode
name|XXH64_freeState
parameter_list|(
name|XXH64_state_t
modifier|*
name|statePtr
parameter_list|)
block|{
name|XXH_free
argument_list|(
name|statePtr
argument_list|)
expr_stmt|;
return|return
name|XXH_OK
return|;
block|}
end_function

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/*** Hash feed ***/
end_comment

begin_function
name|XXH_errorcode
name|XXH32_reset
parameter_list|(
name|XXH32_state_t
modifier|*
name|state_in
parameter_list|,
name|U32
name|seed
parameter_list|)
block|{
name|XXH_istate32_t
modifier|*
name|state
init|=
operator|(
name|XXH_istate32_t
operator|*
operator|)
name|state_in
decl_stmt|;
name|state
operator|->
name|seed
operator|=
name|seed
expr_stmt|;
name|state
operator|->
name|v1
operator|=
name|seed
operator|+
name|PRIME32_1
operator|+
name|PRIME32_2
expr_stmt|;
name|state
operator|->
name|v2
operator|=
name|seed
operator|+
name|PRIME32_2
expr_stmt|;
name|state
operator|->
name|v3
operator|=
name|seed
operator|+
literal|0
expr_stmt|;
name|state
operator|->
name|v4
operator|=
name|seed
operator|-
name|PRIME32_1
expr_stmt|;
name|state
operator|->
name|total_len
operator|=
literal|0
expr_stmt|;
name|state
operator|->
name|memsize
operator|=
literal|0
expr_stmt|;
return|return
name|XXH_OK
return|;
block|}
end_function

begin_function
name|XXH_errorcode
name|XXH64_reset
parameter_list|(
name|XXH64_state_t
modifier|*
name|state_in
parameter_list|,
name|uint64_t
name|seed
parameter_list|)
block|{
name|XXH_istate64_t
modifier|*
name|state
init|=
operator|(
name|XXH_istate64_t
operator|*
operator|)
name|state_in
decl_stmt|;
name|state
operator|->
name|seed
operator|=
name|seed
expr_stmt|;
name|state
operator|->
name|v1
operator|=
name|seed
operator|+
name|PRIME64_1
operator|+
name|PRIME64_2
expr_stmt|;
name|state
operator|->
name|v2
operator|=
name|seed
operator|+
name|PRIME64_2
expr_stmt|;
name|state
operator|->
name|v3
operator|=
name|seed
operator|+
literal|0
expr_stmt|;
name|state
operator|->
name|v4
operator|=
name|seed
operator|-
name|PRIME64_1
expr_stmt|;
name|state
operator|->
name|total_len
operator|=
literal|0
expr_stmt|;
name|state
operator|->
name|memsize
operator|=
literal|0
expr_stmt|;
return|return
name|XXH_OK
return|;
block|}
end_function

begin_function
name|FORCE_INLINE
name|XXH_errorcode
name|XXH32_update_endian
parameter_list|(
name|XXH32_state_t
modifier|*
name|state_in
parameter_list|,
specifier|const
name|void
modifier|*
name|input
parameter_list|,
name|size_t
name|len
parameter_list|,
name|XXH_endianess
name|endian
parameter_list|)
block|{
name|XXH_istate32_t
modifier|*
name|state
init|=
operator|(
name|XXH_istate32_t
operator|*
operator|)
name|state_in
decl_stmt|;
specifier|const
name|BYTE
modifier|*
name|p
init|=
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|input
decl_stmt|;
specifier|const
name|BYTE
modifier|*
specifier|const
name|bEnd
init|=
name|p
operator|+
name|len
decl_stmt|;
ifdef|#
directive|ifdef
name|XXH_ACCEPT_NULL_INPUT_POINTER
if|if
condition|(
name|input
operator|==
name|NULL
condition|)
return|return
name|XXH_ERROR
return|;
endif|#
directive|endif
name|state
operator|->
name|total_len
operator|+=
name|len
expr_stmt|;
if|if
condition|(
name|state
operator|->
name|memsize
operator|+
name|len
operator|<
literal|16
condition|)
comment|// fill in tmp buffer
block|{
name|XXH_memcpy
argument_list|(
operator|(
name|BYTE
operator|*
operator|)
operator|(
name|state
operator|->
name|mem32
operator|)
operator|+
name|state
operator|->
name|memsize
argument_list|,
name|input
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|state
operator|->
name|memsize
operator|+=
operator|(
name|U32
operator|)
name|len
expr_stmt|;
return|return
name|XXH_OK
return|;
block|}
if|if
condition|(
name|state
operator|->
name|memsize
condition|)
comment|// some data left from previous update
block|{
name|XXH_memcpy
argument_list|(
operator|(
name|BYTE
operator|*
operator|)
operator|(
name|state
operator|->
name|mem32
operator|)
operator|+
name|state
operator|->
name|memsize
argument_list|,
name|input
argument_list|,
literal|16
operator|-
name|state
operator|->
name|memsize
argument_list|)
expr_stmt|;
block|{
specifier|const
name|U32
modifier|*
name|p32
init|=
name|state
operator|->
name|mem32
decl_stmt|;
name|state
operator|->
name|v1
operator|+=
name|XXH_readLE32
argument_list|(
name|p32
argument_list|,
name|endian
argument_list|)
operator|*
name|PRIME32_2
expr_stmt|;
name|state
operator|->
name|v1
operator|=
name|XXH_rotl32
argument_list|(
name|state
operator|->
name|v1
argument_list|,
literal|13
argument_list|)
expr_stmt|;
name|state
operator|->
name|v1
operator|*=
name|PRIME32_1
expr_stmt|;
name|p32
operator|++
expr_stmt|;
name|state
operator|->
name|v2
operator|+=
name|XXH_readLE32
argument_list|(
name|p32
argument_list|,
name|endian
argument_list|)
operator|*
name|PRIME32_2
expr_stmt|;
name|state
operator|->
name|v2
operator|=
name|XXH_rotl32
argument_list|(
name|state
operator|->
name|v2
argument_list|,
literal|13
argument_list|)
expr_stmt|;
name|state
operator|->
name|v2
operator|*=
name|PRIME32_1
expr_stmt|;
name|p32
operator|++
expr_stmt|;
name|state
operator|->
name|v3
operator|+=
name|XXH_readLE32
argument_list|(
name|p32
argument_list|,
name|endian
argument_list|)
operator|*
name|PRIME32_2
expr_stmt|;
name|state
operator|->
name|v3
operator|=
name|XXH_rotl32
argument_list|(
name|state
operator|->
name|v3
argument_list|,
literal|13
argument_list|)
expr_stmt|;
name|state
operator|->
name|v3
operator|*=
name|PRIME32_1
expr_stmt|;
name|p32
operator|++
expr_stmt|;
name|state
operator|->
name|v4
operator|+=
name|XXH_readLE32
argument_list|(
name|p32
argument_list|,
name|endian
argument_list|)
operator|*
name|PRIME32_2
expr_stmt|;
name|state
operator|->
name|v4
operator|=
name|XXH_rotl32
argument_list|(
name|state
operator|->
name|v4
argument_list|,
literal|13
argument_list|)
expr_stmt|;
name|state
operator|->
name|v4
operator|*=
name|PRIME32_1
expr_stmt|;
name|p32
operator|++
expr_stmt|;
block|}
name|p
operator|+=
literal|16
operator|-
name|state
operator|->
name|memsize
expr_stmt|;
name|state
operator|->
name|memsize
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|<=
name|bEnd
operator|-
literal|16
condition|)
block|{
specifier|const
name|BYTE
modifier|*
specifier|const
name|limit
init|=
name|bEnd
operator|-
literal|16
decl_stmt|;
name|U32
name|v1
init|=
name|state
operator|->
name|v1
decl_stmt|;
name|U32
name|v2
init|=
name|state
operator|->
name|v2
decl_stmt|;
name|U32
name|v3
init|=
name|state
operator|->
name|v3
decl_stmt|;
name|U32
name|v4
init|=
name|state
operator|->
name|v4
decl_stmt|;
do|do
block|{
name|v1
operator|+=
name|XXH_readLE32
argument_list|(
name|p
argument_list|,
name|endian
argument_list|)
operator|*
name|PRIME32_2
expr_stmt|;
name|v1
operator|=
name|XXH_rotl32
argument_list|(
name|v1
argument_list|,
literal|13
argument_list|)
expr_stmt|;
name|v1
operator|*=
name|PRIME32_1
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
name|v2
operator|+=
name|XXH_readLE32
argument_list|(
name|p
argument_list|,
name|endian
argument_list|)
operator|*
name|PRIME32_2
expr_stmt|;
name|v2
operator|=
name|XXH_rotl32
argument_list|(
name|v2
argument_list|,
literal|13
argument_list|)
expr_stmt|;
name|v2
operator|*=
name|PRIME32_1
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
name|v3
operator|+=
name|XXH_readLE32
argument_list|(
name|p
argument_list|,
name|endian
argument_list|)
operator|*
name|PRIME32_2
expr_stmt|;
name|v3
operator|=
name|XXH_rotl32
argument_list|(
name|v3
argument_list|,
literal|13
argument_list|)
expr_stmt|;
name|v3
operator|*=
name|PRIME32_1
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
name|v4
operator|+=
name|XXH_readLE32
argument_list|(
name|p
argument_list|,
name|endian
argument_list|)
operator|*
name|PRIME32_2
expr_stmt|;
name|v4
operator|=
name|XXH_rotl32
argument_list|(
name|v4
argument_list|,
literal|13
argument_list|)
expr_stmt|;
name|v4
operator|*=
name|PRIME32_1
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
block|}
do|while
condition|(
name|p
operator|<=
name|limit
condition|)
do|;
name|state
operator|->
name|v1
operator|=
name|v1
expr_stmt|;
name|state
operator|->
name|v2
operator|=
name|v2
expr_stmt|;
name|state
operator|->
name|v3
operator|=
name|v3
expr_stmt|;
name|state
operator|->
name|v4
operator|=
name|v4
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|<
name|bEnd
condition|)
block|{
name|XXH_memcpy
argument_list|(
name|state
operator|->
name|mem32
argument_list|,
name|p
argument_list|,
name|bEnd
operator|-
name|p
argument_list|)
expr_stmt|;
name|state
operator|->
name|memsize
operator|=
call|(
name|int
call|)
argument_list|(
name|bEnd
operator|-
name|p
argument_list|)
expr_stmt|;
block|}
return|return
name|XXH_OK
return|;
block|}
end_function

begin_function
name|XXH_errorcode
name|XXH32_update
parameter_list|(
name|XXH32_state_t
modifier|*
name|state_in
parameter_list|,
specifier|const
name|void
modifier|*
name|input
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|XXH_endianess
name|endian_detected
init|=
operator|(
name|XXH_endianess
operator|)
name|XXH_CPU_LITTLE_ENDIAN
decl_stmt|;
if|if
condition|(
operator|(
name|endian_detected
operator|==
name|XXH_littleEndian
operator|)
operator|||
name|XXH_FORCE_NATIVE_FORMAT
condition|)
return|return
name|XXH32_update_endian
argument_list|(
name|state_in
argument_list|,
name|input
argument_list|,
name|len
argument_list|,
name|XXH_littleEndian
argument_list|)
return|;
else|else
return|return
name|XXH32_update_endian
argument_list|(
name|state_in
argument_list|,
name|input
argument_list|,
name|len
argument_list|,
name|XXH_bigEndian
argument_list|)
return|;
block|}
end_function

begin_function
name|FORCE_INLINE
name|U32
name|XXH32_digest_endian
parameter_list|(
specifier|const
name|XXH32_state_t
modifier|*
name|state_in
parameter_list|,
name|XXH_endianess
name|endian
parameter_list|)
block|{
name|XXH_istate32_t
modifier|*
name|state
init|=
operator|(
name|XXH_istate32_t
operator|*
operator|)
name|state_in
decl_stmt|;
specifier|const
name|BYTE
modifier|*
name|p
init|=
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|state
operator|->
name|mem32
decl_stmt|;
name|BYTE
modifier|*
name|bEnd
init|=
operator|(
name|BYTE
operator|*
operator|)
operator|(
name|state
operator|->
name|mem32
operator|)
operator|+
name|state
operator|->
name|memsize
decl_stmt|;
name|U32
name|h32
decl_stmt|;
if|if
condition|(
name|state
operator|->
name|total_len
operator|>=
literal|16
condition|)
block|{
name|h32
operator|=
name|XXH_rotl32
argument_list|(
name|state
operator|->
name|v1
argument_list|,
literal|1
argument_list|)
operator|+
name|XXH_rotl32
argument_list|(
name|state
operator|->
name|v2
argument_list|,
literal|7
argument_list|)
operator|+
name|XXH_rotl32
argument_list|(
name|state
operator|->
name|v3
argument_list|,
literal|12
argument_list|)
operator|+
name|XXH_rotl32
argument_list|(
name|state
operator|->
name|v4
argument_list|,
literal|18
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|h32
operator|=
name|state
operator|->
name|seed
operator|+
name|PRIME32_5
expr_stmt|;
block|}
name|h32
operator|+=
operator|(
name|U32
operator|)
name|state
operator|->
name|total_len
expr_stmt|;
while|while
condition|(
name|p
operator|+
literal|4
operator|<=
name|bEnd
condition|)
block|{
name|h32
operator|+=
name|XXH_readLE32
argument_list|(
name|p
argument_list|,
name|endian
argument_list|)
operator|*
name|PRIME32_3
expr_stmt|;
name|h32
operator|=
name|XXH_rotl32
argument_list|(
name|h32
argument_list|,
literal|17
argument_list|)
operator|*
name|PRIME32_4
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
block|}
while|while
condition|(
name|p
operator|<
name|bEnd
condition|)
block|{
name|h32
operator|+=
operator|(
operator|*
name|p
operator|)
operator|*
name|PRIME32_5
expr_stmt|;
name|h32
operator|=
name|XXH_rotl32
argument_list|(
name|h32
argument_list|,
literal|11
argument_list|)
operator|*
name|PRIME32_1
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
name|h32
operator|^=
name|h32
operator|>>
literal|15
expr_stmt|;
name|h32
operator|*=
name|PRIME32_2
expr_stmt|;
name|h32
operator|^=
name|h32
operator|>>
literal|13
expr_stmt|;
name|h32
operator|*=
name|PRIME32_3
expr_stmt|;
name|h32
operator|^=
name|h32
operator|>>
literal|16
expr_stmt|;
if|#
directive|if
literal|0
block|XXH32_freeState((XXH32_state_t *)state_in);
endif|#
directive|endif
return|return
name|h32
return|;
block|}
end_function

begin_function
name|U32
name|XXH32_digest
parameter_list|(
specifier|const
name|XXH32_state_t
modifier|*
name|state_in
parameter_list|)
block|{
name|XXH_endianess
name|endian_detected
init|=
operator|(
name|XXH_endianess
operator|)
name|XXH_CPU_LITTLE_ENDIAN
decl_stmt|;
if|if
condition|(
operator|(
name|endian_detected
operator|==
name|XXH_littleEndian
operator|)
operator|||
name|XXH_FORCE_NATIVE_FORMAT
condition|)
return|return
name|XXH32_digest_endian
argument_list|(
name|state_in
argument_list|,
name|XXH_littleEndian
argument_list|)
return|;
else|else
return|return
name|XXH32_digest_endian
argument_list|(
name|state_in
argument_list|,
name|XXH_bigEndian
argument_list|)
return|;
block|}
end_function

begin_function
name|FORCE_INLINE
name|XXH_errorcode
name|XXH64_update_endian
parameter_list|(
name|XXH64_state_t
modifier|*
name|state_in
parameter_list|,
specifier|const
name|void
modifier|*
name|input
parameter_list|,
name|size_t
name|len
parameter_list|,
name|XXH_endianess
name|endian
parameter_list|)
block|{
name|XXH_istate64_t
modifier|*
name|state
init|=
operator|(
name|XXH_istate64_t
operator|*
operator|)
name|state_in
decl_stmt|;
specifier|const
name|BYTE
modifier|*
name|p
init|=
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|input
decl_stmt|;
specifier|const
name|BYTE
modifier|*
specifier|const
name|bEnd
init|=
name|p
operator|+
name|len
decl_stmt|;
ifdef|#
directive|ifdef
name|XXH_ACCEPT_NULL_INPUT_POINTER
if|if
condition|(
name|input
operator|==
name|NULL
condition|)
return|return
name|XXH_ERROR
return|;
endif|#
directive|endif
name|state
operator|->
name|total_len
operator|+=
name|len
expr_stmt|;
if|if
condition|(
name|state
operator|->
name|memsize
operator|+
name|len
operator|<
literal|32
condition|)
comment|// fill in tmp buffer
block|{
name|XXH_memcpy
argument_list|(
operator|(
operator|(
name|BYTE
operator|*
operator|)
name|state
operator|->
name|mem64
operator|)
operator|+
name|state
operator|->
name|memsize
argument_list|,
name|input
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|state
operator|->
name|memsize
operator|+=
operator|(
name|U32
operator|)
name|len
expr_stmt|;
return|return
name|XXH_OK
return|;
block|}
if|if
condition|(
name|state
operator|->
name|memsize
condition|)
comment|// some data left from previous update
block|{
name|XXH_memcpy
argument_list|(
operator|(
operator|(
name|BYTE
operator|*
operator|)
name|state
operator|->
name|mem64
operator|)
operator|+
name|state
operator|->
name|memsize
argument_list|,
name|input
argument_list|,
literal|32
operator|-
name|state
operator|->
name|memsize
argument_list|)
expr_stmt|;
block|{
specifier|const
name|U64
modifier|*
name|p64
init|=
name|state
operator|->
name|mem64
decl_stmt|;
name|state
operator|->
name|v1
operator|+=
name|XXH_readLE64
argument_list|(
name|p64
argument_list|,
name|endian
argument_list|)
operator|*
name|PRIME64_2
expr_stmt|;
name|state
operator|->
name|v1
operator|=
name|XXH_rotl64
argument_list|(
name|state
operator|->
name|v1
argument_list|,
literal|31
argument_list|)
expr_stmt|;
name|state
operator|->
name|v1
operator|*=
name|PRIME64_1
expr_stmt|;
name|p64
operator|++
expr_stmt|;
name|state
operator|->
name|v2
operator|+=
name|XXH_readLE64
argument_list|(
name|p64
argument_list|,
name|endian
argument_list|)
operator|*
name|PRIME64_2
expr_stmt|;
name|state
operator|->
name|v2
operator|=
name|XXH_rotl64
argument_list|(
name|state
operator|->
name|v2
argument_list|,
literal|31
argument_list|)
expr_stmt|;
name|state
operator|->
name|v2
operator|*=
name|PRIME64_1
expr_stmt|;
name|p64
operator|++
expr_stmt|;
name|state
operator|->
name|v3
operator|+=
name|XXH_readLE64
argument_list|(
name|p64
argument_list|,
name|endian
argument_list|)
operator|*
name|PRIME64_2
expr_stmt|;
name|state
operator|->
name|v3
operator|=
name|XXH_rotl64
argument_list|(
name|state
operator|->
name|v3
argument_list|,
literal|31
argument_list|)
expr_stmt|;
name|state
operator|->
name|v3
operator|*=
name|PRIME64_1
expr_stmt|;
name|p64
operator|++
expr_stmt|;
name|state
operator|->
name|v4
operator|+=
name|XXH_readLE64
argument_list|(
name|p64
argument_list|,
name|endian
argument_list|)
operator|*
name|PRIME64_2
expr_stmt|;
name|state
operator|->
name|v4
operator|=
name|XXH_rotl64
argument_list|(
name|state
operator|->
name|v4
argument_list|,
literal|31
argument_list|)
expr_stmt|;
name|state
operator|->
name|v4
operator|*=
name|PRIME64_1
expr_stmt|;
name|p64
operator|++
expr_stmt|;
block|}
name|p
operator|+=
literal|32
operator|-
name|state
operator|->
name|memsize
expr_stmt|;
name|state
operator|->
name|memsize
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|+
literal|32
operator|<=
name|bEnd
condition|)
block|{
specifier|const
name|BYTE
modifier|*
specifier|const
name|limit
init|=
name|bEnd
operator|-
literal|32
decl_stmt|;
name|U64
name|v1
init|=
name|state
operator|->
name|v1
decl_stmt|;
name|U64
name|v2
init|=
name|state
operator|->
name|v2
decl_stmt|;
name|U64
name|v3
init|=
name|state
operator|->
name|v3
decl_stmt|;
name|U64
name|v4
init|=
name|state
operator|->
name|v4
decl_stmt|;
do|do
block|{
name|v1
operator|+=
name|XXH_readLE64
argument_list|(
name|p
argument_list|,
name|endian
argument_list|)
operator|*
name|PRIME64_2
expr_stmt|;
name|v1
operator|=
name|XXH_rotl64
argument_list|(
name|v1
argument_list|,
literal|31
argument_list|)
expr_stmt|;
name|v1
operator|*=
name|PRIME64_1
expr_stmt|;
name|p
operator|+=
literal|8
expr_stmt|;
name|v2
operator|+=
name|XXH_readLE64
argument_list|(
name|p
argument_list|,
name|endian
argument_list|)
operator|*
name|PRIME64_2
expr_stmt|;
name|v2
operator|=
name|XXH_rotl64
argument_list|(
name|v2
argument_list|,
literal|31
argument_list|)
expr_stmt|;
name|v2
operator|*=
name|PRIME64_1
expr_stmt|;
name|p
operator|+=
literal|8
expr_stmt|;
name|v3
operator|+=
name|XXH_readLE64
argument_list|(
name|p
argument_list|,
name|endian
argument_list|)
operator|*
name|PRIME64_2
expr_stmt|;
name|v3
operator|=
name|XXH_rotl64
argument_list|(
name|v3
argument_list|,
literal|31
argument_list|)
expr_stmt|;
name|v3
operator|*=
name|PRIME64_1
expr_stmt|;
name|p
operator|+=
literal|8
expr_stmt|;
name|v4
operator|+=
name|XXH_readLE64
argument_list|(
name|p
argument_list|,
name|endian
argument_list|)
operator|*
name|PRIME64_2
expr_stmt|;
name|v4
operator|=
name|XXH_rotl64
argument_list|(
name|v4
argument_list|,
literal|31
argument_list|)
expr_stmt|;
name|v4
operator|*=
name|PRIME64_1
expr_stmt|;
name|p
operator|+=
literal|8
expr_stmt|;
block|}
do|while
condition|(
name|p
operator|<=
name|limit
condition|)
do|;
name|state
operator|->
name|v1
operator|=
name|v1
expr_stmt|;
name|state
operator|->
name|v2
operator|=
name|v2
expr_stmt|;
name|state
operator|->
name|v3
operator|=
name|v3
expr_stmt|;
name|state
operator|->
name|v4
operator|=
name|v4
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|<
name|bEnd
condition|)
block|{
name|XXH_memcpy
argument_list|(
name|state
operator|->
name|mem64
argument_list|,
name|p
argument_list|,
name|bEnd
operator|-
name|p
argument_list|)
expr_stmt|;
name|state
operator|->
name|memsize
operator|=
call|(
name|int
call|)
argument_list|(
name|bEnd
operator|-
name|p
argument_list|)
expr_stmt|;
block|}
return|return
name|XXH_OK
return|;
block|}
end_function

begin_function
name|XXH_errorcode
name|XXH64_update
parameter_list|(
name|XXH64_state_t
modifier|*
name|state_in
parameter_list|,
specifier|const
name|void
modifier|*
name|input
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|XXH_endianess
name|endian_detected
init|=
operator|(
name|XXH_endianess
operator|)
name|XXH_CPU_LITTLE_ENDIAN
decl_stmt|;
if|if
condition|(
operator|(
name|endian_detected
operator|==
name|XXH_littleEndian
operator|)
operator|||
name|XXH_FORCE_NATIVE_FORMAT
condition|)
return|return
name|XXH64_update_endian
argument_list|(
name|state_in
argument_list|,
name|input
argument_list|,
name|len
argument_list|,
name|XXH_littleEndian
argument_list|)
return|;
else|else
return|return
name|XXH64_update_endian
argument_list|(
name|state_in
argument_list|,
name|input
argument_list|,
name|len
argument_list|,
name|XXH_bigEndian
argument_list|)
return|;
block|}
end_function

begin_function
name|FORCE_INLINE
name|U64
name|XXH64_digest_endian
parameter_list|(
specifier|const
name|XXH64_state_t
modifier|*
name|state_in
parameter_list|,
name|XXH_endianess
name|endian
parameter_list|)
block|{
name|XXH_istate64_t
modifier|*
name|state
init|=
operator|(
name|XXH_istate64_t
operator|*
operator|)
name|state_in
decl_stmt|;
specifier|const
name|BYTE
modifier|*
name|p
init|=
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|state
operator|->
name|mem64
decl_stmt|;
name|BYTE
modifier|*
name|bEnd
init|=
operator|(
name|BYTE
operator|*
operator|)
name|state
operator|->
name|mem64
operator|+
name|state
operator|->
name|memsize
decl_stmt|;
name|U64
name|h64
decl_stmt|;
if|if
condition|(
name|state
operator|->
name|total_len
operator|>=
literal|32
condition|)
block|{
name|U64
name|v1
init|=
name|state
operator|->
name|v1
decl_stmt|;
name|U64
name|v2
init|=
name|state
operator|->
name|v2
decl_stmt|;
name|U64
name|v3
init|=
name|state
operator|->
name|v3
decl_stmt|;
name|U64
name|v4
init|=
name|state
operator|->
name|v4
decl_stmt|;
name|h64
operator|=
name|XXH_rotl64
argument_list|(
name|v1
argument_list|,
literal|1
argument_list|)
operator|+
name|XXH_rotl64
argument_list|(
name|v2
argument_list|,
literal|7
argument_list|)
operator|+
name|XXH_rotl64
argument_list|(
name|v3
argument_list|,
literal|12
argument_list|)
operator|+
name|XXH_rotl64
argument_list|(
name|v4
argument_list|,
literal|18
argument_list|)
expr_stmt|;
name|v1
operator|*=
name|PRIME64_2
expr_stmt|;
name|v1
operator|=
name|XXH_rotl64
argument_list|(
name|v1
argument_list|,
literal|31
argument_list|)
expr_stmt|;
name|v1
operator|*=
name|PRIME64_1
expr_stmt|;
name|h64
operator|^=
name|v1
expr_stmt|;
name|h64
operator|=
name|h64
operator|*
name|PRIME64_1
operator|+
name|PRIME64_4
expr_stmt|;
name|v2
operator|*=
name|PRIME64_2
expr_stmt|;
name|v2
operator|=
name|XXH_rotl64
argument_list|(
name|v2
argument_list|,
literal|31
argument_list|)
expr_stmt|;
name|v2
operator|*=
name|PRIME64_1
expr_stmt|;
name|h64
operator|^=
name|v2
expr_stmt|;
name|h64
operator|=
name|h64
operator|*
name|PRIME64_1
operator|+
name|PRIME64_4
expr_stmt|;
name|v3
operator|*=
name|PRIME64_2
expr_stmt|;
name|v3
operator|=
name|XXH_rotl64
argument_list|(
name|v3
argument_list|,
literal|31
argument_list|)
expr_stmt|;
name|v3
operator|*=
name|PRIME64_1
expr_stmt|;
name|h64
operator|^=
name|v3
expr_stmt|;
name|h64
operator|=
name|h64
operator|*
name|PRIME64_1
operator|+
name|PRIME64_4
expr_stmt|;
name|v4
operator|*=
name|PRIME64_2
expr_stmt|;
name|v4
operator|=
name|XXH_rotl64
argument_list|(
name|v4
argument_list|,
literal|31
argument_list|)
expr_stmt|;
name|v4
operator|*=
name|PRIME64_1
expr_stmt|;
name|h64
operator|^=
name|v4
expr_stmt|;
name|h64
operator|=
name|h64
operator|*
name|PRIME64_1
operator|+
name|PRIME64_4
expr_stmt|;
block|}
else|else
block|{
name|h64
operator|=
name|state
operator|->
name|seed
operator|+
name|PRIME64_5
expr_stmt|;
block|}
name|h64
operator|+=
operator|(
name|U64
operator|)
name|state
operator|->
name|total_len
expr_stmt|;
while|while
condition|(
name|p
operator|+
literal|8
operator|<=
name|bEnd
condition|)
block|{
name|U64
name|k1
init|=
name|XXH_readLE64
argument_list|(
name|p
argument_list|,
name|endian
argument_list|)
decl_stmt|;
name|k1
operator|*=
name|PRIME64_2
expr_stmt|;
name|k1
operator|=
name|XXH_rotl64
argument_list|(
name|k1
argument_list|,
literal|31
argument_list|)
expr_stmt|;
name|k1
operator|*=
name|PRIME64_1
expr_stmt|;
name|h64
operator|^=
name|k1
expr_stmt|;
name|h64
operator|=
name|XXH_rotl64
argument_list|(
name|h64
argument_list|,
literal|27
argument_list|)
operator|*
name|PRIME64_1
operator|+
name|PRIME64_4
expr_stmt|;
name|p
operator|+=
literal|8
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|+
literal|4
operator|<=
name|bEnd
condition|)
block|{
name|h64
operator|^=
call|(
name|U64
call|)
argument_list|(
name|XXH_readLE32
argument_list|(
name|p
argument_list|,
name|endian
argument_list|)
argument_list|)
operator|*
name|PRIME64_1
expr_stmt|;
name|h64
operator|=
name|XXH_rotl64
argument_list|(
name|h64
argument_list|,
literal|23
argument_list|)
operator|*
name|PRIME64_2
operator|+
name|PRIME64_3
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
block|}
while|while
condition|(
name|p
operator|<
name|bEnd
condition|)
block|{
name|h64
operator|^=
operator|(
operator|*
name|p
operator|)
operator|*
name|PRIME64_5
expr_stmt|;
name|h64
operator|=
name|XXH_rotl64
argument_list|(
name|h64
argument_list|,
literal|11
argument_list|)
operator|*
name|PRIME64_1
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
name|h64
operator|^=
name|h64
operator|>>
literal|33
expr_stmt|;
name|h64
operator|*=
name|PRIME64_2
expr_stmt|;
name|h64
operator|^=
name|h64
operator|>>
literal|29
expr_stmt|;
name|h64
operator|*=
name|PRIME64_3
expr_stmt|;
name|h64
operator|^=
name|h64
operator|>>
literal|32
expr_stmt|;
if|#
directive|if
literal|0
block|XXH64_freeState((XXH64_state_t *)state_in);
endif|#
directive|endif
return|return
name|h64
return|;
block|}
end_function

begin_function
name|uint64_t
name|XXH64_digest
parameter_list|(
specifier|const
name|XXH64_state_t
modifier|*
name|state_in
parameter_list|)
block|{
name|XXH_endianess
name|endian_detected
init|=
operator|(
name|XXH_endianess
operator|)
name|XXH_CPU_LITTLE_ENDIAN
decl_stmt|;
if|if
condition|(
operator|(
name|endian_detected
operator|==
name|XXH_littleEndian
operator|)
operator|||
name|XXH_FORCE_NATIVE_FORMAT
condition|)
return|return
name|XXH64_digest_endian
argument_list|(
name|state_in
argument_list|,
name|XXH_littleEndian
argument_list|)
return|;
else|else
return|return
name|XXH64_digest_endian
argument_list|(
name|state_in
argument_list|,
name|XXH_bigEndian
argument_list|)
return|;
block|}
end_function

end_unit

