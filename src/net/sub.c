begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (c) 1979 Regents of the University of California */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_decl_stmt
name|char
name|netcmd
index|[]
init|=
name|NETCMD
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|resfile
index|[]
init|=
name|RESFILE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|senddir
index|[]
init|=
name|SENDDIR
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|logfile
index|[]
init|=
name|LOGFILE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|Bsh
index|[]
init|=
name|BINSH
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|mailcmd
index|[]
init|=
name|MMAILCMD
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|writecmd
index|[]
init|=
name|MWRITECMD
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|debugflg
init|=
name|DBV
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* debug flag */
end_comment

begin_decl_stmt
name|int
name|datasize
init|=
name|SIZE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* best if mult of 512 */
end_comment

begin_decl_stmt
name|char
name|tokval
index|[
name|BFS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|cfile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|vaxtovax
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 	speeds baud setting 	300	7 	1200	9 	9600	13 	*/
end_comment

begin_decl_stmt
name|int
name|linkspeed
init|=
name|LINKS
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|local
init|=
name|LOCAL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|tokstruct
name|toktab
index|[]
init|=
block|{
literal|"machine"
block|,
name|MACHINE
block|,
literal|"login"
block|,
name|LOGIN
block|,
literal|"password"
block|,
name|PASSWORD
block|,
literal|"notify"
block|,
name|NOTIFY
block|,
literal|"command"
block|,
name|COMMAND
block|,
literal|"yes"
block|,
name|YES
block|,
literal|"y"
block|,
name|YES
block|,
literal|"no"
block|,
name|NO
block|,
literal|"n"
block|,
name|NO
block|,
literal|"default"
block|,
name|DEFAULT
block|,
literal|"write"
block|,
name|WRITE
block|,
literal|"force"
block|,
name|FORCE
block|,
literal|"local"
block|,
name|LOCALTOK
block|,
literal|"speed"
block|,
name|SPEED
block|,
literal|"link"
block|,
name|LINK
block|,
literal|"vaxtovax"
block|,
name|VAXTOVAX
block|,
literal|"length"
block|,
name|LENGTH
block|,
literal|"debug"
block|,
name|DEBUGTOK
block|,
literal|"time"
block|,
name|ALTIME
block|,
literal|"count"
block|,
name|ALCOUNT
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_macro
name|passwdent
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|char
modifier|*
name|u
decl_stmt|;
specifier|register
name|struct
name|passwd
modifier|*
name|pwd
decl_stmt|;
name|pwd
operator|=
name|getpwuid
argument_list|(
name|getuid
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|pwd
operator|==
name|NULL
condition|)
block|{
name|err
argument_list|(
literal|"Bad uid\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|strcpy
argument_list|(
name|status
operator|.
name|localname
argument_list|,
name|pwd
operator|->
name|pw_name
argument_list|)
expr_stmt|;
name|status
operator|.
name|muid
operator|=
name|guid
argument_list|(
name|pwd
operator|->
name|pw_uid
argument_list|,
name|pwd
operator|->
name|pw_gid
argument_list|)
expr_stmt|;
name|status
operator|.
name|mgid
operator|=
name|pwd
operator|->
name|pw_gid
expr_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
name|pwd
operator|->
name|pw_gecos
index|[
literal|0
index|]
argument_list|)
condition|)
name|status
operator|.
name|jobno
operator|=
name|atoi
argument_list|(
name|pwd
operator|->
name|pw_gecos
argument_list|)
expr_stmt|;
else|else
name|status
operator|.
name|jobno
operator|=
literal|32767
expr_stmt|;
name|strcpy
argument_list|(
name|status
operator|.
name|dir
argument_list|,
name|pwd
operator|->
name|pw_dir
argument_list|)
expr_stmt|;
name|u
operator|=
name|pwd
operator|->
name|pw_shell
expr_stmt|;
if|if
condition|(
name|u
index|[
literal|0
index|]
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
literal|"sh"
argument_list|,
name|u
operator|+
name|strlen
argument_list|(
name|u
argument_list|)
operator|-
literal|2
argument_list|)
operator|!=
literal|0
condition|)
name|u
operator|=
name|Bsh
expr_stmt|;
name|strcpy
argument_list|(
name|status
operator|.
name|loginshell
argument_list|,
name|u
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|promptlogin
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|char
name|buf
index|[
name|BFS
index|]
decl_stmt|;
name|FILE
modifier|*
name|wf
decl_stmt|;
name|int
name|c
decl_stmt|;
name|struct
name|sgttyb
name|stt
decl_stmt|;
name|int
name|oflag
decl_stmt|;
if|if
condition|(
name|status
operator|.
name|mpasswd
index|[
literal|0
index|]
operator|==
literal|0
operator|||
name|status
operator|.
name|login
index|[
literal|0
index|]
operator|==
literal|0
operator|||
name|status
operator|.
name|force
condition|)
block|{
name|wf
operator|=
name|fopen
argument_list|(
literal|"/dev/tty"
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|wf
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|status
operator|.
name|login
index|[
literal|0
index|]
operator|==
literal|0
operator|||
name|status
operator|.
name|force
condition|)
block|{
name|printf
argument_list|(
literal|"Name (%s): "
argument_list|,
name|status
operator|.
name|localname
argument_list|)
expr_stmt|;
if|if
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
name|BFS
argument_list|,
name|wf
argument_list|)
operator|!=
name|buf
condition|)
block|{
name|perror
argument_list|(
literal|"fgets"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|c
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|buf
index|[
name|c
operator|>
literal|0
condition|?
name|c
operator|-
literal|1
else|:
literal|0
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|c
operator|>
literal|10
condition|)
block|{
name|err
argument_list|(
literal|"Login name too long.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|member
argument_list|(
name|buf
argument_list|,
literal|' '
argument_list|)
condition|)
block|{
name|err
argument_list|(
literal|"Login names don't have blanks in them.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|0
condition|)
name|strcpy
argument_list|(
name|buf
argument_list|,
name|status
operator|.
name|localname
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|status
operator|.
name|login
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|status
operator|.
name|login
argument_list|,
literal|"network"
argument_list|)
operator|!=
literal|0
operator|&&
operator|(
name|status
operator|.
name|mpasswd
index|[
literal|0
index|]
operator|==
literal|0
operator|||
name|status
operator|.
name|force
operator|)
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"Password (%s):"
argument_list|,
name|status
operator|.
name|login
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|status
operator|.
name|mpasswd
argument_list|,
name|getpass
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|wf
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|status
operator|.
name|login
index|[
literal|0
index|]
operator|==
literal|0
condition|)
name|strcpy
argument_list|(
name|status
operator|.
name|login
argument_list|,
name|status
operator|.
name|localname
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|.
name|mpasswd
index|[
literal|0
index|]
operator|==
literal|0
condition|)
name|strcpy
argument_list|(
name|status
operator|.
name|mpasswd
argument_list|,
literal|"\"\""
argument_list|)
expr_stmt|;
name|status
operator|.
name|force
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_comment
comment|/* 	called in netdaemon and debugging software, 	handles parameter lists to setup 	remote machine and pipes */
end_comment

begin_macro
name|setupdaemon
argument_list|(
argument|argc
argument_list|,
argument|argv
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|remote
operator|=
name|argc
operator|>
literal|1
condition|?
name|lookup
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
else|:
name|getremote
argument_list|(
name|local
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|==
literal|4
condition|)
block|{
comment|/* simulate using pipes */
name|readfd
operator|=
name|atoi
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|writefd
operator|=
name|atoi
argument_list|(
name|argv
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|pipesim
operator|++
expr_stmt|;
block|}
name|initdaemon
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|setup
argument_list|(
argument|str
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|str
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|sgttyb
name|stt
decl_stmt|;
specifier|static
name|char
name|readbuf
index|[
name|BUFSIZ
index|]
decl_stmt|,
name|writebuf
index|[
name|BUFSIZ
index|]
decl_stmt|;
if|if
condition|(
name|str
operator|==
literal|0
operator|||
name|str
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
name|err
argument_list|(
literal|"invalid net device\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|masterseqno
operator|=
literal|1
expr_stmt|;
name|readtty
operator|=
name|pipesim
condition|?
name|fdopen
argument_list|(
name|readfd
argument_list|,
literal|"r"
argument_list|)
else|:
name|fopen
argument_list|(
name|str
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|readtty
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|writetty
operator|=
name|pipesim
condition|?
name|fdopen
argument_list|(
name|writefd
argument_list|,
literal|"w"
argument_list|)
else|:
name|fopen
argument_list|(
name|str
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|writetty
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|pipesim
condition|)
block|{
comment|/* set exclusive use for line */
if|if
condition|(
name|ioctl
argument_list|(
name|fileno
argument_list|(
name|readtty
argument_list|)
argument_list|,
name|TIOCEXCL
argument_list|,
operator|&
name|stt
argument_list|)
operator|!=
literal|0
operator|||
name|gtty
argument_list|(
name|fileno
argument_list|(
name|readtty
argument_list|)
argument_list|,
operator|&
name|stt
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|stt
operator|.
name|sg_ispeed
operator|=
name|stt
operator|.
name|sg_ospeed
operator|=
name|linkspeed
expr_stmt|;
comment|/* user-set baud */
name|stt
operator|.
name|sg_erase
operator|=
name|stt
operator|.
name|sg_kill
operator|=
literal|0
expr_stmt|;
comment|/* erase and kill off */
name|stt
operator|.
name|sg_flags
operator|=
name|ANYP
expr_stmt|;
comment|/* even and odd parity, off everything else */
if|if
condition|(
name|stty
argument_list|(
name|fileno
argument_list|(
name|readtty
argument_list|)
argument_list|,
operator|&
name|stt
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|setbuf
argument_list|(
name|readtty
argument_list|,
name|readbuf
argument_list|)
expr_stmt|;
name|setbuf
argument_list|(
name|writetty
argument_list|,
name|writebuf
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* passwords work as follows:    passwd = "\n" means no password    */
end_comment

begin_comment
comment|/* table of netrc options 	option			default 	------			------- 	default			default machine 	login string		current login 	password string		- 	notify yes/no		yes 	write yes/no		yes 	command string		- 	force yes/no		no */
end_comment

begin_comment
comment|/* 	Fabry has suggested that machine names be more general: 	that you be able to say: 	cory:	fabry on Cory 	caf:	caf on Cory 	c:	fabry on C  	so the formulation would look like:  	default key 	key: machine login passwd ... 	key: ....  	and so on  	Gould has suggested the format be:  	pseudo cory 	real Cory 	login fabry 	pseudo caf 	real Cory 	login caf 	pseudo c 	real C 		login fabry */
end_comment

begin_comment
comment|/* init file format local C remote A 	default A 	machine A    local C link /dev/net-A    speed 9 	machine Cory local C link /dev/net-Cory speed 9 	 	if remote == 0, default is A 	also options: 		vaxtovax, length, debug 	*/
end_comment

begin_macro
name|initdaemon
argument_list|()
end_macro

begin_block
block|{
name|long
name|timev
decl_stmt|;
name|int
name|timei
decl_stmt|;
name|cfile
operator|=
name|fopen
argument_list|(
name|INITFILE
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|getfile
argument_list|()
expr_stmt|;
name|err
argument_list|(
literal|"remote %c local %c link %s speed %d vtov %d length %d\n"
argument_list|,
name|remote
argument_list|,
name|local
argument_list|,
name|device
argument_list|,
name|linkspeed
argument_list|,
name|vaxtovax
argument_list|,
name|datasize
argument_list|)
expr_stmt|;
name|err
argument_list|(
literal|"debug %d time %d count %d\n"
argument_list|,
name|debugflg
argument_list|,
name|atime
argument_list|,
name|maxbread
argument_list|)
expr_stmt|;
name|setup
argument_list|(
name|device
argument_list|)
expr_stmt|;
name|timev
operator|=
name|gettime
argument_list|()
expr_stmt|;
name|timei
operator|=
name|timev
operator|>>
literal|16
expr_stmt|;
name|srand
argument_list|(
name|timei
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|VAX
if|if
condition|(
name|machtype
index|[
name|local
operator|-
literal|'a'
index|]
operator|!=
name|M_VAX
condition|)
endif|#
directive|endif
ifdef|#
directive|ifdef
name|CORY
if|if
condition|(
name|machtype
index|[
name|local
operator|-
literal|'a'
index|]
operator|!=
name|M_CORY
condition|)
endif|#
directive|endif
ifdef|#
directive|ifdef
name|CC
if|if
condition|(
name|machtype
index|[
name|local
operator|-
literal|'a'
index|]
operator|!=
name|M_CC
operator|&&
name|machtype
index|[
name|local
operator|-
literal|'a'
index|]
operator|!=
name|M_SRC
condition|)
endif|#
directive|endif
name|err
argument_list|(
literal|"Machine type disagrees with local machine\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|commandfile
argument_list|()
end_macro

begin_block
block|{
name|char
modifier|*
name|hdir
decl_stmt|,
name|buf
index|[
name|BFS
operator|*
literal|2
index|]
decl_stmt|;
name|hdir
operator|=
name|getenv
argument_list|(
literal|"HOME"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hdir
operator|==
literal|0
condition|)
name|hdir
operator|=
literal|"."
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|hdir
argument_list|,
literal|"/"
argument_list|)
operator|==
literal|0
condition|)
return|return;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s/.netrc"
argument_list|,
name|hdir
argument_list|)
expr_stmt|;
comment|/* 	debug("file %s",buf); */
name|cfile
operator|=
name|fopen
argument_list|(
name|buf
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|getfile
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|getfile
argument_list|()
end_macro

begin_block
block|{
name|int
name|t
decl_stmt|;
if|if
condition|(
name|cfile
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|fstat
argument_list|(
name|fileno
argument_list|(
name|cfile
argument_list|)
argument_list|,
operator|&
name|statbuf
argument_list|)
operator|<
literal|0
operator|||
operator|(
name|statbuf
operator|.
name|st_mode
operator|&
literal|0444
operator|)
operator|==
literal|0
condition|)
return|return;
while|while
condition|(
operator|(
name|t
operator|=
name|token
argument_list|()
operator|)
condition|)
block|{
switch|switch
condition|(
name|t
condition|)
block|{
case|case
name|DEFAULT
case|:
if|if
condition|(
name|token
argument_list|()
operator|==
name|ID
operator|&&
name|remote
operator|==
literal|0
condition|)
name|remote
operator|=
name|lookup
argument_list|(
name|tokval
argument_list|)
expr_stmt|;
comment|/* 			debug("rem %c\n",remote); 			*/
break|break;
case|case
name|MACHINE
case|:
if|if
condition|(
name|remote
operator|==
literal|0
condition|)
name|remote
operator|=
name|getremote
argument_list|(
name|local
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
argument_list|()
operator|!=
name|ID
condition|)
continue|continue;
if|if
condition|(
name|remote
operator|!=
name|lookup
argument_list|(
name|tokval
argument_list|)
condition|)
continue|continue;
comment|/* this is the entry for the remote mach we want */
name|getnetline
argument_list|()
expr_stmt|;
goto|goto
name|out
goto|;
break|break;
block|}
block|}
name|out
label|:
name|fclose
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
return|return;
block|}
end_block

begin_macro
name|getnetline
argument_list|()
end_macro

begin_block
block|{
name|int
name|t
decl_stmt|;
while|while
condition|(
operator|(
name|t
operator|=
name|token
argument_list|()
operator|)
condition|)
block|{
switch|switch
condition|(
name|t
condition|)
block|{
case|case
name|MACHINE
case|:
return|return;
case|case
name|LOGIN
case|:
if|if
condition|(
name|token
argument_list|()
operator|&&
name|status
operator|.
name|login
index|[
literal|0
index|]
operator|==
literal|0
condition|)
name|strcpy
argument_list|(
name|status
operator|.
name|login
argument_list|,
name|tokval
argument_list|)
expr_stmt|;
break|break;
case|case
name|PASSWORD
case|:
if|if
condition|(
name|fstat
argument_list|(
name|fileno
argument_list|(
name|cfile
argument_list|)
argument_list|,
operator|&
name|statbuf
argument_list|)
operator|>=
literal|0
operator|&&
operator|(
name|statbuf
operator|.
name|st_mode
operator|&
literal|077
operator|)
operator|!=
literal|0
condition|)
block|{
name|err
argument_list|(
literal|"Error - .netrc file not correct mode.\n"
argument_list|)
expr_stmt|;
name|err
argument_list|(
literal|"Remove password or correct mode.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|token
argument_list|()
operator|&&
name|status
operator|.
name|mpasswd
index|[
literal|0
index|]
operator|==
literal|0
condition|)
name|strcpy
argument_list|(
name|status
operator|.
name|mpasswd
argument_list|,
name|tokval
argument_list|)
expr_stmt|;
comment|/* 			debug("mp:%s:%s\n",status.mpasswd,tokval); 			*/
break|break;
case|case
name|NOTIFY
case|:
name|status
operator|.
name|nonotify
operator|=
name|token
argument_list|()
operator|==
name|NO
expr_stmt|;
break|break;
case|case
name|WRITE
case|:
name|status
operator|.
name|nowrite
operator|=
name|token
argument_list|()
operator|==
name|NO
expr_stmt|;
break|break;
case|case
name|COMMAND
case|:
if|if
condition|(
name|status
operator|.
name|defcmd
index|[
literal|0
index|]
operator|==
literal|0
operator|&&
name|token
argument_list|()
condition|)
name|strcpy
argument_list|(
name|status
operator|.
name|defcmd
argument_list|,
name|tokval
argument_list|)
expr_stmt|;
break|break;
case|case
name|FORCE
case|:
name|status
operator|.
name|force
operator|=
name|token
argument_list|()
operator|==
name|YES
expr_stmt|;
break|break;
case|case
name|LOCALTOK
case|:
if|if
condition|(
name|token
argument_list|()
condition|)
name|local
operator|=
name|lookup
argument_list|(
name|tokval
argument_list|)
expr_stmt|;
break|break;
case|case
name|LINK
case|:
if|if
condition|(
name|token
argument_list|()
condition|)
name|strcpy
argument_list|(
name|device
argument_list|,
name|tokval
argument_list|)
expr_stmt|;
break|break;
case|case
name|SPEED
case|:
if|if
condition|(
name|token
argument_list|()
condition|)
name|linkspeed
operator|=
name|atoi
argument_list|(
name|tokval
argument_list|)
expr_stmt|;
break|break;
case|case
name|VAXTOVAX
case|:
name|vaxtovax
operator|++
expr_stmt|;
break|break;
case|case
name|LENGTH
case|:
if|if
condition|(
name|token
argument_list|()
condition|)
name|datasize
operator|=
name|atoi
argument_list|(
name|tokval
argument_list|)
expr_stmt|;
break|break;
case|case
name|DEBUGTOK
case|:
name|debugflg
operator|++
expr_stmt|;
break|break;
case|case
name|ALTIME
case|:
if|if
condition|(
name|token
argument_list|()
condition|)
name|atime
operator|=
name|atoi
argument_list|(
name|tokval
argument_list|)
expr_stmt|;
break|break;
case|case
name|ALCOUNT
case|:
if|if
condition|(
name|token
argument_list|()
condition|)
name|maxbread
operator|=
name|atoi
argument_list|(
name|tokval
argument_list|)
expr_stmt|;
break|break;
default|default:
name|err
argument_list|(
literal|"Unknown .netrc option %s\n"
argument_list|,
name|tokval
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_block

begin_macro
name|token
argument_list|()
end_macro

begin_block
block|{
comment|/* returns next token in cfile, 0 on EOF */
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|c
decl_stmt|;
if|if
condition|(
name|feof
argument_list|(
name|cfile
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|cfile
argument_list|)
operator|)
operator|!=
name|EOF
operator|&&
operator|(
name|c
operator|==
literal|'\n'
operator|||
name|c
operator|==
literal|'\t'
operator|||
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|','
operator|)
condition|)
empty_stmt|;
comment|/* next char begins token */
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|p
operator|=
name|tokval
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'"'
condition|)
block|{
comment|/* process quoted string */
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|cfile
argument_list|)
operator|)
operator|!=
name|EOF
operator|&&
name|c
operator|!=
literal|'"'
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
name|c
operator|=
name|getc
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
block|}
block|}
else|else
block|{
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|cfile
argument_list|)
operator|)
operator|!=
name|EOF
operator|&&
name|c
operator|!=
literal|'\n'
operator|&&
name|c
operator|!=
literal|'\t'
operator|&&
name|c
operator|!=
literal|' '
operator|&&
name|c
operator|!=
literal|','
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
name|c
operator|=
name|getc
argument_list|(
name|cfile
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
block|}
block|}
operator|*
name|p
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tokval
index|[
literal|0
index|]
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	debug("tok %s",tokval); */
return|return
operator|(
name|tlookup
argument_list|(
name|tokval
argument_list|)
operator|)
return|;
block|}
end_block

begin_macro
name|tlookup
argument_list|(
argument|str
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|str
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|tokstruct
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|toktab
init|;
name|p
operator|->
name|tokstr
condition|;
name|p
operator|++
control|)
if|if
condition|(
name|streql
argument_list|(
name|p
operator|->
name|tokstr
argument_list|,
name|str
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
operator|(
name|p
operator|->
name|tval
operator|)
return|;
block|}
return|return
operator|(
name|ID
operator|)
return|;
block|}
end_block

begin_comment
comment|/* just like strcmp except upper- and lower-case are ignored */
end_comment

begin_macro
name|streql
argument_list|(
argument|s1
argument_list|,
argument|s2
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s1
decl_stmt|,
modifier|*
name|s2
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|a
decl_stmt|,
name|b
decl_stmt|;
while|while
condition|(
operator|*
name|s1
operator|&&
operator|*
name|s2
condition|)
block|{
name|a
operator|=
name|isupper
argument_list|(
operator|*
name|s1
argument_list|)
condition|?
name|tolower
argument_list|(
operator|*
name|s1
argument_list|)
else|:
operator|*
name|s1
expr_stmt|;
name|b
operator|=
name|isupper
argument_list|(
operator|*
name|s2
argument_list|)
condition|?
name|tolower
argument_list|(
operator|*
name|s2
argument_list|)
else|:
operator|*
name|s2
expr_stmt|;
if|if
condition|(
name|a
operator|<
name|b
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|a
operator|>
name|b
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|s1
operator|++
operator|,
name|s2
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|s2
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
operator|*
name|s1
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/* determine through machine */
end_comment

begin_macro
name|gothru
argument_list|(
argument|from
argument_list|,
argument|to
argument_list|)
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
switch|switch
condition|(
name|from
condition|)
block|{
case|case
literal|'a'
case|:
name|i
operator|=
name|configA
index|[
name|to
operator|-
literal|'a'
index|]
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|i
operator|=
name|configB
index|[
name|to
operator|-
literal|'a'
index|]
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|i
operator|=
name|configC
index|[
name|to
operator|-
literal|'a'
index|]
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|i
operator|=
name|configD
index|[
name|to
operator|-
literal|'a'
index|]
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|i
operator|=
name|configE
index|[
name|to
operator|-
literal|'a'
index|]
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|i
operator|=
name|configI
index|[
name|to
operator|-
literal|'a'
index|]
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
name|i
operator|=
name|configQ
index|[
name|to
operator|-
literal|'a'
index|]
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|i
operator|=
name|configS
index|[
name|to
operator|-
literal|'a'
index|]
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|i
operator|=
name|configV
index|[
name|to
operator|-
literal|'a'
index|]
expr_stmt|;
break|break;
case|case
literal|'y'
case|:
name|i
operator|=
name|configY
index|[
name|to
operator|-
literal|'a'
index|]
expr_stmt|;
break|break;
default|default:
name|i
operator|=
literal|0
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|i
operator|)
return|;
block|}
end_block

begin_comment
comment|/* note the pointers to returned values */
end_comment

begin_macro
name|harg
argument_list|(
argument|ans
argument_list|,
argument|pargc
argument_list|,
argument|pargv
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|ans
decl_stmt|,
modifier|*
name|pargc
decl_stmt|,
modifier|*
modifier|*
modifier|*
name|pargv
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
operator|(
operator|*
name|pargv
operator|)
index|[
literal|0
index|]
index|[
literal|2
index|]
condition|)
comment|/* no space */
name|strcpy
argument_list|(
name|ans
argument_list|,
operator|(
operator|*
name|pargv
operator|)
index|[
literal|0
index|]
operator|+
literal|2
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* space, get next arg */
name|strcpy
argument_list|(
name|ans
argument_list|,
operator|(
operator|*
name|pargv
operator|)
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
operator|(
operator|*
name|pargc
operator|)
operator|--
expr_stmt|;
operator|(
operator|*
name|pargv
operator|)
operator|++
expr_stmt|;
block|}
block|}
end_block

begin_decl_stmt
specifier|static
name|struct
name|stat
name|x
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|direct
name|y
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|off
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* these three routines gwd, cat, ckroot and     data structures x, y, off, do a pwd to string name */
end_comment

begin_expr_stmt
name|gwd
argument_list|(
name|name
argument_list|)
specifier|register
name|char
operator|*
name|name
expr_stmt|;
end_expr_stmt

begin_block
block|{
operator|*
name|name
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|stat
argument_list|(
literal|"."
argument_list|,
operator|&
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|file
operator|=
name|fopen
argument_list|(
literal|".."
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
break|break;
do|do
block|{
if|if
condition|(
name|fread
argument_list|(
operator|&
name|y
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
name|y
argument_list|,
name|file
argument_list|)
operator|!=
sizeof|sizeof
name|y
condition|)
break|break;
block|}
do|while
condition|(
name|y
operator|.
name|d_ino
operator|!=
name|x
operator|.
name|st_ino
condition|)
do|;
name|fclose
argument_list|(
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|y
operator|.
name|d_ino
operator|==
name|ROOTINO
condition|)
block|{
name|ckroot
argument_list|(
name|name
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|cat
argument_list|(
name|name
argument_list|)
condition|)
break|break;
name|chdir
argument_list|(
literal|".."
argument_list|)
expr_stmt|;
block|}
name|chdir
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|cat
argument_list|(
name|name
argument_list|)
specifier|register
name|char
operator|*
name|name
expr_stmt|;
end_expr_stmt

begin_block
block|{
comment|/* return 1 to exit */
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|i
operator|=
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|y
operator|.
name|d_name
index|[
operator|++
name|i
index|]
operator|!=
literal|0
condition|)
empty_stmt|;
if|if
condition|(
operator|(
name|off
operator|+
name|i
operator|+
literal|2
operator|)
operator|>
literal|511
condition|)
return|return
operator|(
literal|1
operator|)
return|;
for|for
control|(
name|j
operator|=
name|off
operator|+
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
operator|--
name|j
control|)
name|name
index|[
name|j
operator|+
name|i
operator|+
literal|1
index|]
operator|=
name|name
index|[
name|j
index|]
expr_stmt|;
name|off
operator|=
name|i
operator|+
name|off
operator|+
literal|1
expr_stmt|;
name|name
index|[
name|i
index|]
operator|=
literal|'/'
expr_stmt|;
for|for
control|(
operator|--
name|i
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
name|name
index|[
name|i
index|]
operator|=
name|y
operator|.
name|d_name
index|[
name|i
index|]
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|ckroot
argument_list|(
argument|name
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|y
operator|.
name|d_name
argument_list|,
operator|&
name|x
argument_list|)
operator|<
literal|0
condition|)
return|return;
name|i
operator|=
name|x
operator|.
name|st_dev
expr_stmt|;
if|if
condition|(
name|chdir
argument_list|(
literal|"/"
argument_list|)
operator|<
literal|0
condition|)
return|return;
if|if
condition|(
operator|(
name|file
operator|=
name|fopen
argument_list|(
literal|"/"
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return;
do|do
block|{
if|if
condition|(
name|fread
argument_list|(
operator|&
name|y
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
name|y
argument_list|,
name|file
argument_list|)
operator|!=
sizeof|sizeof
name|y
condition|)
return|return;
if|if
condition|(
name|y
operator|.
name|d_ino
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|stat
argument_list|(
name|y
operator|.
name|d_name
argument_list|,
operator|&
name|x
argument_list|)
operator|<
literal|0
condition|)
return|return;
block|}
do|while
condition|(
name|x
operator|.
name|st_dev
operator|!=
name|i
operator|||
operator|(
name|x
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|!=
name|S_IFDIR
condition|)
do|;
if|if
condition|(
name|strcmp
argument_list|(
name|y
operator|.
name|d_name
argument_list|,
literal|"."
argument_list|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|y
operator|.
name|d_name
argument_list|,
literal|".."
argument_list|)
operator|!=
literal|0
condition|)
if|if
condition|(
name|cat
argument_list|(
name|name
argument_list|)
condition|)
return|return;
name|i
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|name
index|[
name|i
operator|+
literal|1
index|]
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|--
name|i
operator|>=
literal|0
condition|)
name|name
index|[
name|i
operator|+
literal|1
index|]
operator|=
name|name
index|[
name|i
index|]
expr_stmt|;
name|name
index|[
literal|0
index|]
operator|=
literal|'/'
expr_stmt|;
return|return;
block|}
end_block

begin_comment
comment|/* prints out commands before executing them */
end_comment

begin_comment
comment|/*VARARGS0*/
end_comment

begin_macro
name|mexecl
argument_list|(
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
modifier|*
name|p
init|=
operator|(
name|int
operator|*
operator|)
operator|&
name|s
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|debugflg
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|p
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
name|err
argument_list|(
literal|"%s "
argument_list|,
name|p
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
name|execl
argument_list|(
name|p
index|[
literal|0
index|]
argument_list|,
name|p
index|[
literal|1
index|]
argument_list|,
name|p
index|[
literal|2
index|]
argument_list|,
name|p
index|[
literal|3
index|]
argument_list|,
name|p
index|[
literal|4
index|]
argument_list|,
name|p
index|[
literal|5
index|]
argument_list|,
name|p
index|[
literal|6
index|]
argument_list|,
name|p
index|[
literal|7
index|]
argument_list|,
name|p
index|[
literal|8
index|]
argument_list|,
name|p
index|[
literal|9
index|]
argument_list|,
name|p
index|[
literal|10
index|]
argument_list|,
name|p
index|[
literal|11
index|]
argument_list|,
name|p
index|[
literal|12
index|]
argument_list|,
name|p
index|[
literal|13
index|]
argument_list|,
name|p
index|[
literal|14
index|]
argument_list|,
name|p
index|[
literal|15
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|perror
argument_list|(
name|p
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* prints out commands before executing them */
end_comment

begin_expr_stmt
name|mexecv
argument_list|(
name|s
argument_list|,
name|p
argument_list|)
specifier|register
name|char
operator|*
name|s
operator|,
operator|*
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|debugflg
condition|)
block|{
name|err
argument_list|(
literal|"%s "
argument_list|,
name|s
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|p
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
name|err
argument_list|(
literal|"%s "
argument_list|,
name|p
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
name|execv
argument_list|(
name|s
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|perror
argument_list|(
literal|"execv"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*VARARGS0*/
end_comment

begin_comment
comment|/* fills in -l - -p from commands like rcp */
end_comment

begin_comment
comment|/* must be called with at least two arguments */
end_comment

begin_macro
name|kexecl
argument_list|(
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|a
index|[
literal|20
index|]
decl_stmt|,
name|i
init|=
literal|2
decl_stmt|,
name|j
init|=
literal|2
decl_stmt|;
name|char
modifier|*
modifier|*
name|p
init|=
operator|(
name|char
operator|*
operator|*
operator|)
operator|&
name|s
decl_stmt|;
name|a
index|[
literal|0
index|]
operator|=
name|p
index|[
literal|0
index|]
expr_stmt|;
name|a
index|[
literal|1
index|]
operator|=
name|p
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|status
operator|.
name|login
index|[
literal|0
index|]
condition|)
block|{
name|a
index|[
name|i
operator|++
index|]
operator|=
literal|"-l"
expr_stmt|;
name|a
index|[
name|i
operator|++
index|]
operator|=
name|status
operator|.
name|login
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|.
name|mpasswd
index|[
literal|0
index|]
condition|)
block|{
name|a
index|[
name|i
operator|++
index|]
operator|=
literal|"-p"
expr_stmt|;
name|a
index|[
name|i
operator|++
index|]
operator|=
name|status
operator|.
name|mpasswd
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|.
name|nonotify
condition|)
name|a
index|[
name|i
operator|++
index|]
operator|=
literal|"-n"
expr_stmt|;
if|if
condition|(
name|status
operator|.
name|force
condition|)
name|a
index|[
name|i
operator|++
index|]
operator|=
literal|"-f"
expr_stmt|;
while|while
condition|(
name|p
index|[
name|j
index|]
condition|)
name|a
index|[
name|i
operator|++
index|]
operator|=
name|p
index|[
name|j
operator|++
index|]
expr_stmt|;
name|a
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|mexecl
argument_list|(
name|a
index|[
literal|0
index|]
argument_list|,
name|a
index|[
literal|1
index|]
argument_list|,
name|a
index|[
literal|2
index|]
argument_list|,
name|a
index|[
literal|3
index|]
argument_list|,
name|a
index|[
literal|4
index|]
argument_list|,
name|a
index|[
literal|5
index|]
argument_list|,
name|a
index|[
literal|6
index|]
argument_list|,
name|a
index|[
literal|7
index|]
argument_list|,
name|a
index|[
literal|8
index|]
argument_list|,
name|a
index|[
literal|9
index|]
argument_list|,
name|a
index|[
literal|10
index|]
argument_list|,
name|a
index|[
literal|11
index|]
argument_list|,
name|a
index|[
literal|12
index|]
argument_list|,
name|a
index|[
literal|13
index|]
argument_list|,
name|a
index|[
literal|14
index|]
argument_list|,
name|a
index|[
literal|15
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|analyze
argument_list|(
argument|S
argument_list|,
argument|f
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|S
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|fd
modifier|*
name|f
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|file
decl_stmt|;
name|char
name|work
index|[
name|FNS
index|]
decl_stmt|,
modifier|*
name|s
decl_stmt|,
name|c0
decl_stmt|,
name|c1
decl_stmt|,
name|c2
decl_stmt|,
name|c3
decl_stmt|;
name|s
operator|=
name|work
expr_stmt|;
name|strcpy
argument_list|(
name|s
argument_list|,
name|S
argument_list|)
expr_stmt|;
name|f
operator|->
name|mach
operator|=
name|local
expr_stmt|;
name|file
operator|=
name|s
expr_stmt|;
if|if
condition|(
name|member
argument_list|(
name|s
argument_list|,
literal|':'
argument_list|)
condition|)
block|{
comment|/* name specified */
while|while
condition|(
operator|*
name|s
operator|&&
operator|*
name|s
operator|!=
literal|':'
condition|)
name|s
operator|++
expr_stmt|;
operator|*
name|s
operator|=
literal|0
expr_stmt|;
name|f
operator|->
name|mach
operator|=
name|lookup
argument_list|(
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|->
name|mach
operator|==
literal|0
condition|)
block|{
name|err
argument_list|(
literal|"Unknown machine %s"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|*
operator|++
name|s
operator|&&
operator|*
name|s
operator|==
literal|':'
condition|)
empty_stmt|;
name|file
operator|=
name|s
expr_stmt|;
block|}
else|else
block|{
name|c0
operator|=
operator|*
name|s
operator|++
expr_stmt|;
name|c1
operator|=
operator|*
name|s
operator|++
expr_stmt|;
name|c2
operator|=
operator|*
name|s
operator|++
expr_stmt|;
name|c3
operator|=
operator|*
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|c0
operator|==
literal|'/'
operator|&&
name|c1
operator|!=
literal|'/'
operator|&&
name|islower
argument_list|(
name|c1
argument_list|)
condition|)
if|if
condition|(
name|c2
operator|==
literal|'/'
condition|)
name|f
operator|->
name|mach
operator|=
literal|'y'
expr_stmt|;
comment|/* Cory name */
elseif|else
if|if
condition|(
name|c3
operator|==
literal|'/'
condition|)
name|f
operator|->
name|mach
operator|=
name|c1
expr_stmt|;
comment|/* CC name */
block|}
name|f
operator|->
name|fn
operator|=
name|calloc
argument_list|(
name|strlen
argument_list|(
name|file
argument_list|)
operator|+
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|f
operator|->
name|fn
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* returns a single character for machine S */
end_comment

begin_expr_stmt
name|lookup
argument_list|(
name|s
argument_list|)
specifier|register
name|char
operator|*
name|s
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|tt
modifier|*
name|t
decl_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|s
argument_list|)
operator|==
literal|1
condition|)
return|return
operator|(
name|isupper
argument_list|(
operator|*
name|s
argument_list|)
condition|?
name|tolower
argument_list|(
operator|*
name|s
argument_list|)
else|:
operator|*
name|s
operator|)
return|;
for|for
control|(
name|t
operator|=
name|table
init|;
name|t
operator|->
name|bigname
condition|;
name|t
operator|++
control|)
if|if
condition|(
name|streql
argument_list|(
name|s
argument_list|,
name|t
operator|->
name|bigname
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|t
operator|->
name|lname
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/* returns a long name (string) for single character machine c */
end_comment

begin_function
name|char
modifier|*
name|longname
parameter_list|(
name|c
parameter_list|)
specifier|register
name|char
name|c
decl_stmt|;
block|{
specifier|register
name|struct
name|tt
modifier|*
name|t
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
return|return
operator|(
literal|"UNKNOWN"
operator|)
return|;
for|for
control|(
name|t
operator|=
name|table
init|;
name|t
operator|->
name|bigname
condition|;
name|t
operator|++
control|)
if|if
condition|(
name|c
operator|==
name|t
operator|->
name|lname
condition|)
return|return
operator|(
name|t
operator|->
name|bigname
operator|)
return|;
return|return
operator|(
literal|"UNKNOWN"
operator|)
return|;
block|}
end_function

begin_comment
comment|/*VARARGS0*/
end_comment

begin_macro
name|error
argument_list|(
argument|s
argument_list|,
argument|a
argument_list|,
argument|b
argument_list|,
argument|c
argument_list|,
argument|d
argument_list|,
argument|e
argument_list|,
argument|f
argument_list|,
argument|g
argument_list|,
argument|h
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|buf
index|[
literal|10
index|]
decl_stmt|;
if|if
condition|(
name|remote
operator|!=
literal|0
condition|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s"
argument_list|,
name|longname
argument_list|(
name|remote
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|buf
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|debugflg
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|s
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|,
name|e
argument_list|,
name|f
argument_list|,
name|g
argument_list|,
name|h
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
name|addtolog
argument_list|(
name|remote
argument_list|,
literal|"Err %s: "
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|addtolog
argument_list|(
name|remote
argument_list|,
name|s
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|,
name|e
argument_list|,
name|f
argument_list|,
name|g
argument_list|,
name|h
argument_list|)
expr_stmt|;
name|addtolog
argument_list|(
name|remote
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*VARARGS0*/
end_comment

begin_macro
name|debug
argument_list|(
argument|s
argument_list|,
argument|a
argument_list|,
argument|b
argument_list|,
argument|c
argument_list|,
argument|d
argument_list|,
argument|e
argument_list|,
argument|f
argument_list|,
argument|g
argument_list|,
argument|h
argument_list|,
argument|i
argument_list|,
argument|j
argument_list|,
argument|k
argument_list|,
argument|l
argument_list|,
argument|m
argument_list|,
argument|n
argument_list|,
argument|o
argument_list|,
argument|p
argument_list|,
argument|q
argument_list|,
argument|r
argument_list|,
argument|t
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|debugflg
condition|)
block|{
name|printf
argument_list|(
name|s
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|,
name|e
argument_list|,
name|f
argument_list|,
name|g
argument_list|,
name|h
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|l
argument_list|,
name|m
argument_list|,
name|n
argument_list|,
name|o
argument_list|,
name|p
argument_list|,
name|q
argument_list|,
name|r
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_expr_stmt
name|member
argument_list|(
name|s
argument_list|,
name|c
argument_list|)
specifier|register
name|char
operator|*
name|s
operator|,
name|c
expr_stmt|;
end_expr_stmt

begin_block
block|{
while|while
condition|(
operator|*
name|s
condition|)
if|if
condition|(
operator|*
name|s
operator|++
operator|==
name|c
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/* this is really not right - we should use the rcslog format */
end_comment

begin_comment
comment|/* also, the user must be able to write on the    public logfile to get error messages such as    directory not found after he has    setuid'd from root */
end_comment

begin_comment
comment|/*VARARGS0*/
end_comment

begin_macro
name|addtolog
argument_list|(
argument|mach
argument_list|,
argument|s
argument_list|,
argument|a
argument_list|,
argument|b
argument_list|,
argument|c
argument_list|,
argument|d
argument_list|,
argument|e
argument_list|,
argument|f
argument_list|,
argument|g
argument_list|,
argument|h
argument_list|,
argument|i
argument_list|,
argument|j
argument_list|,
argument|k
argument_list|,
argument|l
argument_list|,
argument|m
argument_list|,
argument|n
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|static
name|FILE
modifier|*
name|log
init|=
name|NULL
decl_stmt|;
name|logfile
index|[
name|strlen
argument_list|(
name|logfile
argument_list|)
operator|-
literal|1
index|]
operator|=
name|mach
expr_stmt|;
if|if
condition|(
name|log
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|stat
argument_list|(
name|logfile
argument_list|,
operator|&
name|statbuf
argument_list|)
operator|<
literal|0
condition|)
return|return;
name|log
operator|=
name|fopen
argument_list|(
name|logfile
argument_list|,
literal|"a"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|log
operator|==
name|NULL
condition|)
return|return;
name|fseek
argument_list|(
name|log
argument_list|,
literal|0L
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|log
argument_list|,
name|s
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|,
name|e
argument_list|,
name|f
argument_list|,
name|g
argument_list|,
name|h
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|l
argument_list|,
name|m
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|log
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* return a static string with the form "X hrs X mins X secs" */
end_comment

begin_comment
comment|/* t is # of secs */
end_comment

begin_function
name|char
modifier|*
name|comptime
parameter_list|(
name|t
parameter_list|)
name|long
name|t
decl_stmt|;
block|{
specifier|static
name|char
name|str
index|[
literal|30
index|]
decl_stmt|;
name|char
name|buf
index|[
literal|20
index|]
decl_stmt|;
name|long
name|w
decl_stmt|;
name|str
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|w
operator|=
name|t
operator|/
literal|3600L
expr_stmt|;
if|if
condition|(
name|w
operator|>
literal|0L
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%ld hr "
argument_list|,
name|w
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|str
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
name|t
operator|=
name|t
operator|%
literal|3600L
expr_stmt|;
name|w
operator|=
name|t
operator|/
literal|60L
expr_stmt|;
if|if
condition|(
name|w
operator|>
literal|0L
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%ld min "
argument_list|,
name|w
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|str
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
name|t
operator|=
name|t
operator|%
literal|60L
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%ld sec"
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|str
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|str
operator|)
return|;
block|}
end_function

begin_comment
comment|/* VARARGS0 */
end_comment

begin_expr_stmt
specifier|static
name|err
argument_list|(
argument|s
argument_list|,
argument|a
argument_list|,
argument|b
argument_list|,
argument|c
argument_list|,
argument|d
argument_list|,
argument|e
argument_list|,
argument|f
argument_list|,
argument|g
argument_list|,
argument|h
argument_list|,
argument|i
argument_list|,
argument|j
argument_list|,
argument|k
argument_list|,
argument|l
argument_list|,
argument|m
argument_list|,
argument|n
argument_list|,
argument|o
argument_list|,
argument|p
argument_list|,
argument|q
argument_list|,
argument|r
argument_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|s
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|,
name|e
argument_list|,
name|f
argument_list|,
name|g
argument_list|,
name|h
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|l
argument_list|,
name|m
argument_list|,
name|n
argument_list|,
name|o
argument_list|,
name|p
argument_list|,
name|q
argument_list|,
name|r
argument_list|)
block|; 	}
end_expr_stmt

end_unit

