begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright 2010-2015 Samy Al Bahra.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * (c) Copyright 2008, IBM Corporation.  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_comment
comment|/*  * This is an implementation of hazard pointers as detailed in:  *   http://www.research.ibm.com/people/m/michael/ieeetpds-2004.pdf  *  * This API provides a publishing mechanism that defers destruction of  * hazard pointers until it is safe to do so. Preventing arbitrary re-use  * protects against the ABA problem and provides safe memory reclamation.  * The implementation was derived from the Hazard Pointers implementation  * from the Amino CBBS project. It has been heavily modified for Concurrency  * Kit.  */
end_comment

begin_include
include|#
directive|include
file|<ck_backoff.h>
end_include

begin_include
include|#
directive|include
file|<ck_cc.h>
end_include

begin_include
include|#
directive|include
file|<ck_hp.h>
end_include

begin_include
include|#
directive|include
file|<ck_pr.h>
end_include

begin_include
include|#
directive|include
file|<ck_stack.h>
end_include

begin_include
include|#
directive|include
file|<ck_stdbool.h>
end_include

begin_include
include|#
directive|include
file|<ck_stddef.h>
end_include

begin_include
include|#
directive|include
file|<ck_stdlib.h>
end_include

begin_include
include|#
directive|include
file|<ck_string.h>
end_include

begin_macro
name|CK_STACK_CONTAINER
argument_list|(
argument|struct ck_hp_record
argument_list|,
argument|global_entry
argument_list|,
argument|ck_hp_record_container
argument_list|)
end_macro

begin_macro
name|CK_STACK_CONTAINER
argument_list|(
argument|struct ck_hp_hazard
argument_list|,
argument|pending_entry
argument_list|,
argument|ck_hp_hazard_container
argument_list|)
end_macro

begin_function
name|void
name|ck_hp_init
parameter_list|(
name|struct
name|ck_hp
modifier|*
name|state
parameter_list|,
name|unsigned
name|int
name|degree
parameter_list|,
name|unsigned
name|int
name|threshold
parameter_list|,
name|ck_hp_destructor_t
name|destroy
parameter_list|)
block|{
name|state
operator|->
name|threshold
operator|=
name|threshold
expr_stmt|;
name|state
operator|->
name|degree
operator|=
name|degree
expr_stmt|;
name|state
operator|->
name|destroy
operator|=
name|destroy
expr_stmt|;
name|state
operator|->
name|n_subscribers
operator|=
literal|0
expr_stmt|;
name|state
operator|->
name|n_free
operator|=
literal|0
expr_stmt|;
name|ck_stack_init
argument_list|(
operator|&
name|state
operator|->
name|subscribers
argument_list|)
expr_stmt|;
name|ck_pr_fence_store
argument_list|()
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|ck_hp_set_threshold
parameter_list|(
name|struct
name|ck_hp
modifier|*
name|state
parameter_list|,
name|unsigned
name|int
name|threshold
parameter_list|)
block|{
name|ck_pr_store_uint
argument_list|(
operator|&
name|state
operator|->
name|threshold
argument_list|,
name|threshold
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|struct
name|ck_hp_record
modifier|*
name|ck_hp_recycle
parameter_list|(
name|struct
name|ck_hp
modifier|*
name|global
parameter_list|)
block|{
name|struct
name|ck_hp_record
modifier|*
name|record
decl_stmt|;
name|ck_stack_entry_t
modifier|*
name|entry
decl_stmt|;
name|int
name|state
decl_stmt|;
if|if
condition|(
name|ck_pr_load_uint
argument_list|(
operator|&
name|global
operator|->
name|n_free
argument_list|)
operator|==
literal|0
condition|)
return|return
name|NULL
return|;
name|CK_STACK_FOREACH
argument_list|(
argument|&global->subscribers
argument_list|,
argument|entry
argument_list|)
block|{
name|record
operator|=
name|ck_hp_record_container
argument_list|(
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|ck_pr_load_int
argument_list|(
operator|&
name|record
operator|->
name|state
argument_list|)
operator|==
name|CK_HP_FREE
condition|)
block|{
name|ck_pr_fence_load
argument_list|()
expr_stmt|;
name|state
operator|=
name|ck_pr_fas_int
argument_list|(
operator|&
name|record
operator|->
name|state
argument_list|,
name|CK_HP_USED
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|==
name|CK_HP_FREE
condition|)
block|{
name|ck_pr_dec_uint
argument_list|(
operator|&
name|global
operator|->
name|n_free
argument_list|)
expr_stmt|;
return|return
name|record
return|;
block|}
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|void
name|ck_hp_unregister
parameter_list|(
name|struct
name|ck_hp_record
modifier|*
name|entry
parameter_list|)
block|{
name|entry
operator|->
name|n_pending
operator|=
literal|0
expr_stmt|;
name|entry
operator|->
name|n_peak
operator|=
literal|0
expr_stmt|;
name|entry
operator|->
name|n_reclamations
operator|=
literal|0
expr_stmt|;
name|ck_stack_init
argument_list|(
operator|&
name|entry
operator|->
name|pending
argument_list|)
expr_stmt|;
name|ck_pr_fence_store
argument_list|()
expr_stmt|;
name|ck_pr_store_int
argument_list|(
operator|&
name|entry
operator|->
name|state
argument_list|,
name|CK_HP_FREE
argument_list|)
expr_stmt|;
name|ck_pr_inc_uint
argument_list|(
operator|&
name|entry
operator|->
name|global
operator|->
name|n_free
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|ck_hp_register
parameter_list|(
name|struct
name|ck_hp
modifier|*
name|state
parameter_list|,
name|struct
name|ck_hp_record
modifier|*
name|entry
parameter_list|,
name|void
modifier|*
modifier|*
name|pointers
parameter_list|)
block|{
name|entry
operator|->
name|state
operator|=
name|CK_HP_USED
expr_stmt|;
name|entry
operator|->
name|global
operator|=
name|state
expr_stmt|;
name|entry
operator|->
name|pointers
operator|=
name|pointers
expr_stmt|;
name|entry
operator|->
name|n_pending
operator|=
literal|0
expr_stmt|;
name|entry
operator|->
name|n_peak
operator|=
literal|0
expr_stmt|;
name|entry
operator|->
name|n_reclamations
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
name|pointers
argument_list|,
literal|0
argument_list|,
name|state
operator|->
name|degree
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|ck_stack_init
argument_list|(
operator|&
name|entry
operator|->
name|pending
argument_list|)
expr_stmt|;
name|ck_pr_fence_store
argument_list|()
expr_stmt|;
name|ck_stack_push_upmc
argument_list|(
operator|&
name|state
operator|->
name|subscribers
argument_list|,
operator|&
name|entry
operator|->
name|global_entry
argument_list|)
expr_stmt|;
name|ck_pr_inc_uint
argument_list|(
operator|&
name|state
operator|->
name|n_subscribers
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|int
name|hazard_compare
parameter_list|(
specifier|const
name|void
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|b
parameter_list|)
block|{
name|void
modifier|*
specifier|const
modifier|*
name|x
decl_stmt|;
name|void
modifier|*
specifier|const
modifier|*
name|y
decl_stmt|;
name|x
operator|=
name|a
expr_stmt|;
name|y
operator|=
name|b
expr_stmt|;
return|return
operator|(
operator|(
operator|*
name|x
operator|>
operator|*
name|y
operator|)
operator|-
operator|(
operator|*
name|x
operator|<
operator|*
name|y
operator|)
operator|)
return|;
block|}
end_function

begin_function
name|CK_CC_INLINE
specifier|static
name|bool
name|ck_hp_member_scan
parameter_list|(
name|ck_stack_entry_t
modifier|*
name|entry
parameter_list|,
name|unsigned
name|int
name|degree
parameter_list|,
name|void
modifier|*
name|pointer
parameter_list|)
block|{
name|struct
name|ck_hp_record
modifier|*
name|record
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|void
modifier|*
name|hazard
decl_stmt|;
do|do
block|{
name|record
operator|=
name|ck_hp_record_container
argument_list|(
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|ck_pr_load_int
argument_list|(
operator|&
name|record
operator|->
name|state
argument_list|)
operator|==
name|CK_HP_FREE
condition|)
continue|continue;
if|if
condition|(
name|ck_pr_load_ptr
argument_list|(
operator|&
name|record
operator|->
name|pointers
argument_list|)
operator|==
name|NULL
condition|)
continue|continue;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|degree
condition|;
name|i
operator|++
control|)
block|{
name|hazard
operator|=
name|ck_pr_load_ptr
argument_list|(
operator|&
name|record
operator|->
name|pointers
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|hazard
operator|==
name|pointer
condition|)
return|return
operator|(
name|true
operator|)
return|;
block|}
block|}
do|while
condition|(
operator|(
name|entry
operator|=
name|CK_STACK_NEXT
argument_list|(
name|entry
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
do|;
return|return
operator|(
name|false
operator|)
return|;
block|}
end_function

begin_function
name|CK_CC_INLINE
specifier|static
name|void
modifier|*
name|ck_hp_member_cache
parameter_list|(
name|struct
name|ck_hp
modifier|*
name|global
parameter_list|,
name|void
modifier|*
modifier|*
name|cache
parameter_list|,
name|unsigned
name|int
modifier|*
name|n_hazards
parameter_list|)
block|{
name|struct
name|ck_hp_record
modifier|*
name|record
decl_stmt|;
name|ck_stack_entry_t
modifier|*
name|entry
decl_stmt|;
name|unsigned
name|int
name|hazards
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|void
modifier|*
name|pointer
decl_stmt|;
name|CK_STACK_FOREACH
argument_list|(
argument|&global->subscribers
argument_list|,
argument|entry
argument_list|)
block|{
name|record
operator|=
name|ck_hp_record_container
argument_list|(
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|ck_pr_load_int
argument_list|(
operator|&
name|record
operator|->
name|state
argument_list|)
operator|==
name|CK_HP_FREE
condition|)
continue|continue;
if|if
condition|(
name|ck_pr_load_ptr
argument_list|(
operator|&
name|record
operator|->
name|pointers
argument_list|)
operator|==
name|NULL
condition|)
continue|continue;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|global
operator|->
name|degree
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|hazards
operator|>
name|CK_HP_CACHE
condition|)
break|break;
name|pointer
operator|=
name|ck_pr_load_ptr
argument_list|(
operator|&
name|record
operator|->
name|pointers
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|pointer
operator|!=
name|NULL
condition|)
name|cache
index|[
name|hazards
operator|++
index|]
operator|=
name|pointer
expr_stmt|;
block|}
block|}
operator|*
name|n_hazards
operator|=
name|hazards
expr_stmt|;
return|return
operator|(
name|entry
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ck_hp_reclaim
parameter_list|(
name|struct
name|ck_hp_record
modifier|*
name|thread
parameter_list|)
block|{
name|struct
name|ck_hp_hazard
modifier|*
name|hazard
decl_stmt|;
name|struct
name|ck_hp
modifier|*
name|global
init|=
name|thread
operator|->
name|global
decl_stmt|;
name|unsigned
name|int
name|n_hazards
decl_stmt|;
name|void
modifier|*
modifier|*
name|cache
decl_stmt|,
modifier|*
name|marker
decl_stmt|,
modifier|*
name|match
decl_stmt|;
name|ck_stack_entry_t
modifier|*
name|previous
decl_stmt|,
modifier|*
name|entry
decl_stmt|,
modifier|*
name|next
decl_stmt|;
comment|/* Store as many entries as possible in local array. */
name|cache
operator|=
name|thread
operator|->
name|cache
expr_stmt|;
name|marker
operator|=
name|ck_hp_member_cache
argument_list|(
name|global
argument_list|,
name|cache
argument_list|,
operator|&
name|n_hazards
argument_list|)
expr_stmt|;
comment|/* 	 * In theory, there is an n such that (n * (log n) ** 2)< np. 	 */
name|qsort
argument_list|(
name|cache
argument_list|,
name|n_hazards
argument_list|,
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|,
name|hazard_compare
argument_list|)
expr_stmt|;
name|previous
operator|=
name|NULL
expr_stmt|;
name|CK_STACK_FOREACH_SAFE
argument_list|(
argument|&thread->pending
argument_list|,
argument|entry
argument_list|,
argument|next
argument_list|)
block|{
name|hazard
operator|=
name|ck_hp_hazard_container
argument_list|(
name|entry
argument_list|)
expr_stmt|;
name|match
operator|=
name|bsearch
argument_list|(
operator|&
name|hazard
operator|->
name|pointer
argument_list|,
name|cache
argument_list|,
name|n_hazards
argument_list|,
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|,
name|hazard_compare
argument_list|)
expr_stmt|;
if|if
condition|(
name|match
operator|!=
name|NULL
condition|)
block|{
name|previous
operator|=
name|entry
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|marker
operator|!=
name|NULL
operator|&&
name|ck_hp_member_scan
argument_list|(
name|marker
argument_list|,
name|global
operator|->
name|degree
argument_list|,
name|hazard
operator|->
name|pointer
argument_list|)
condition|)
block|{
name|previous
operator|=
name|entry
expr_stmt|;
continue|continue;
block|}
name|thread
operator|->
name|n_pending
operator|-=
literal|1
expr_stmt|;
comment|/* Remove from the pending stack. */
if|if
condition|(
name|previous
condition|)
name|CK_STACK_NEXT
argument_list|(
name|previous
argument_list|)
operator|=
name|CK_STACK_NEXT
argument_list|(
name|entry
argument_list|)
expr_stmt|;
else|else
name|CK_STACK_FIRST
argument_list|(
operator|&
name|thread
operator|->
name|pending
argument_list|)
operator|=
name|CK_STACK_NEXT
argument_list|(
name|entry
argument_list|)
expr_stmt|;
comment|/* The entry is now safe to destroy. */
name|global
operator|->
name|destroy
argument_list|(
name|hazard
operator|->
name|data
argument_list|)
expr_stmt|;
name|thread
operator|->
name|n_reclamations
operator|++
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
name|void
name|ck_hp_retire
parameter_list|(
name|struct
name|ck_hp_record
modifier|*
name|thread
parameter_list|,
name|struct
name|ck_hp_hazard
modifier|*
name|hazard
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|void
modifier|*
name|pointer
parameter_list|)
block|{
name|ck_pr_store_ptr
argument_list|(
operator|&
name|hazard
operator|->
name|pointer
argument_list|,
name|pointer
argument_list|)
expr_stmt|;
name|ck_pr_store_ptr
argument_list|(
operator|&
name|hazard
operator|->
name|data
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|ck_stack_push_spnc
argument_list|(
operator|&
name|thread
operator|->
name|pending
argument_list|,
operator|&
name|hazard
operator|->
name|pending_entry
argument_list|)
expr_stmt|;
name|thread
operator|->
name|n_pending
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|thread
operator|->
name|n_pending
operator|>
name|thread
operator|->
name|n_peak
condition|)
name|thread
operator|->
name|n_peak
operator|=
name|thread
operator|->
name|n_pending
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|ck_hp_free
parameter_list|(
name|struct
name|ck_hp_record
modifier|*
name|thread
parameter_list|,
name|struct
name|ck_hp_hazard
modifier|*
name|hazard
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|void
modifier|*
name|pointer
parameter_list|)
block|{
name|struct
name|ck_hp
modifier|*
name|global
decl_stmt|;
name|global
operator|=
name|ck_pr_load_ptr
argument_list|(
operator|&
name|thread
operator|->
name|global
argument_list|)
expr_stmt|;
name|ck_pr_store_ptr
argument_list|(
operator|&
name|hazard
operator|->
name|data
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|ck_pr_store_ptr
argument_list|(
operator|&
name|hazard
operator|->
name|pointer
argument_list|,
name|pointer
argument_list|)
expr_stmt|;
name|ck_stack_push_spnc
argument_list|(
operator|&
name|thread
operator|->
name|pending
argument_list|,
operator|&
name|hazard
operator|->
name|pending_entry
argument_list|)
expr_stmt|;
name|thread
operator|->
name|n_pending
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|thread
operator|->
name|n_pending
operator|>
name|thread
operator|->
name|n_peak
condition|)
name|thread
operator|->
name|n_peak
operator|=
name|thread
operator|->
name|n_pending
expr_stmt|;
if|if
condition|(
name|thread
operator|->
name|n_pending
operator|>=
name|global
operator|->
name|threshold
condition|)
name|ck_hp_reclaim
argument_list|(
name|thread
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|ck_hp_purge
parameter_list|(
name|struct
name|ck_hp_record
modifier|*
name|thread
parameter_list|)
block|{
name|ck_backoff_t
name|backoff
init|=
name|CK_BACKOFF_INITIALIZER
decl_stmt|;
while|while
condition|(
name|thread
operator|->
name|n_pending
operator|>
literal|0
condition|)
block|{
name|ck_hp_reclaim
argument_list|(
name|thread
argument_list|)
expr_stmt|;
if|if
condition|(
name|thread
operator|->
name|n_pending
operator|>
literal|0
condition|)
name|ck_backoff_eb
argument_list|(
operator|&
name|backoff
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

end_unit

