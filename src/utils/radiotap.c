begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Radiotap parser  *  * Copyright 2007		Andy Green<andy@warmcat.com>  * Copyright 2009		Johannes Berg<johannes@sipsolutions.net>  *  * This program is free software; you can redistribute it and/or modify  * it under the terms of the GNU General Public License version 2 as  * published by the Free Software Foundation.  *  * Alternatively, this software may be distributed under the terms of BSD  * license.  *  * See COPYING for more details.  */
end_comment

begin_include
include|#
directive|include
file|"radiotap_iter.h"
end_include

begin_include
include|#
directive|include
file|"platform.h"
end_include

begin_comment
comment|/* function prototypes and related defs are in radiotap_iter.h */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|radiotap_align_size
name|rtap_namespace_sizes
index|[]
init|=
block|{
index|[
name|IEEE80211_RADIOTAP_TSFT
index|]
operator|=
block|{
operator|.
name|align
operator|=
literal|8
block|,
operator|.
name|size
operator|=
literal|8
block|, }
block|,
index|[
name|IEEE80211_RADIOTAP_FLAGS
index|]
operator|=
block|{
operator|.
name|align
operator|=
literal|1
block|,
operator|.
name|size
operator|=
literal|1
block|, }
block|,
index|[
name|IEEE80211_RADIOTAP_RATE
index|]
operator|=
block|{
operator|.
name|align
operator|=
literal|1
block|,
operator|.
name|size
operator|=
literal|1
block|, }
block|,
index|[
name|IEEE80211_RADIOTAP_CHANNEL
index|]
operator|=
block|{
operator|.
name|align
operator|=
literal|2
block|,
operator|.
name|size
operator|=
literal|4
block|, }
block|,
index|[
name|IEEE80211_RADIOTAP_FHSS
index|]
operator|=
block|{
operator|.
name|align
operator|=
literal|2
block|,
operator|.
name|size
operator|=
literal|2
block|, }
block|,
index|[
name|IEEE80211_RADIOTAP_DBM_ANTSIGNAL
index|]
operator|=
block|{
operator|.
name|align
operator|=
literal|1
block|,
operator|.
name|size
operator|=
literal|1
block|, }
block|,
index|[
name|IEEE80211_RADIOTAP_DBM_ANTNOISE
index|]
operator|=
block|{
operator|.
name|align
operator|=
literal|1
block|,
operator|.
name|size
operator|=
literal|1
block|, }
block|,
index|[
name|IEEE80211_RADIOTAP_LOCK_QUALITY
index|]
operator|=
block|{
operator|.
name|align
operator|=
literal|2
block|,
operator|.
name|size
operator|=
literal|2
block|, }
block|,
index|[
name|IEEE80211_RADIOTAP_TX_ATTENUATION
index|]
operator|=
block|{
operator|.
name|align
operator|=
literal|2
block|,
operator|.
name|size
operator|=
literal|2
block|, }
block|,
index|[
name|IEEE80211_RADIOTAP_DB_TX_ATTENUATION
index|]
operator|=
block|{
operator|.
name|align
operator|=
literal|2
block|,
operator|.
name|size
operator|=
literal|2
block|, }
block|,
index|[
name|IEEE80211_RADIOTAP_DBM_TX_POWER
index|]
operator|=
block|{
operator|.
name|align
operator|=
literal|1
block|,
operator|.
name|size
operator|=
literal|1
block|, }
block|,
index|[
name|IEEE80211_RADIOTAP_ANTENNA
index|]
operator|=
block|{
operator|.
name|align
operator|=
literal|1
block|,
operator|.
name|size
operator|=
literal|1
block|, }
block|,
index|[
name|IEEE80211_RADIOTAP_DB_ANTSIGNAL
index|]
operator|=
block|{
operator|.
name|align
operator|=
literal|1
block|,
operator|.
name|size
operator|=
literal|1
block|, }
block|,
index|[
name|IEEE80211_RADIOTAP_DB_ANTNOISE
index|]
operator|=
block|{
operator|.
name|align
operator|=
literal|1
block|,
operator|.
name|size
operator|=
literal|1
block|, }
block|,
index|[
name|IEEE80211_RADIOTAP_RX_FLAGS
index|]
operator|=
block|{
operator|.
name|align
operator|=
literal|2
block|,
operator|.
name|size
operator|=
literal|2
block|, }
block|,
index|[
name|IEEE80211_RADIOTAP_TX_FLAGS
index|]
operator|=
block|{
operator|.
name|align
operator|=
literal|2
block|,
operator|.
name|size
operator|=
literal|2
block|, }
block|,
index|[
name|IEEE80211_RADIOTAP_RTS_RETRIES
index|]
operator|=
block|{
operator|.
name|align
operator|=
literal|1
block|,
operator|.
name|size
operator|=
literal|1
block|, }
block|,
index|[
name|IEEE80211_RADIOTAP_DATA_RETRIES
index|]
operator|=
block|{
operator|.
name|align
operator|=
literal|1
block|,
operator|.
name|size
operator|=
literal|1
block|, }
block|,
index|[
name|IEEE80211_RADIOTAP_MCS
index|]
operator|=
block|{
operator|.
name|align
operator|=
literal|1
block|,
operator|.
name|size
operator|=
literal|3
block|, }
block|,
index|[
name|IEEE80211_RADIOTAP_AMPDU_STATUS
index|]
operator|=
block|{
operator|.
name|align
operator|=
literal|4
block|,
operator|.
name|size
operator|=
literal|8
block|, }
block|,
comment|/* 	 * add more here as they are defined in radiotap.h 	 */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ieee80211_radiotap_namespace
name|radiotap_ns
init|=
block|{
operator|.
name|n_bits
operator|=
sizeof|sizeof
argument_list|(
name|rtap_namespace_sizes
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|rtap_namespace_sizes
index|[
literal|0
index|]
argument_list|)
block|,
operator|.
name|align_size
operator|=
name|rtap_namespace_sizes
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**  * ieee80211_radiotap_iterator_init - radiotap parser iterator initialization  * @iterator: radiotap_iterator to initialize  * @radiotap_header: radiotap header to parse  * @max_length: total length we can parse into (eg, whole packet length)  *  * Returns: 0 or a negative error code if there is a problem.  *  * This function initializes an opaque iterator struct which can then  * be passed to ieee80211_radiotap_iterator_next() to visit every radiotap  * argument which is present in the header.  It knows about extended  * present headers and handles them.  *  * How to use:  * call __ieee80211_radiotap_iterator_init() to init a semi-opaque iterator  * struct ieee80211_radiotap_iterator (no need to init the struct beforehand)  * checking for a good 0 return code.  Then loop calling  * __ieee80211_radiotap_iterator_next()... it returns either 0,  * -ENOENT if there are no more args to parse, or -EINVAL if there is a problem.  * The iterator's @this_arg member points to the start of the argument  * associated with the current argument index that is present, which can be  * found in the iterator's @this_arg_index member.  This arg index corresponds  * to the IEEE80211_RADIOTAP_... defines.  *  * Radiotap header length:  * You can find the CPU-endian total radiotap header length in  * iterator->max_length after executing ieee80211_radiotap_iterator_init()  * successfully.  *  * Alignment Gotcha:  * You must take care when dereferencing iterator.this_arg  * for multibyte types... the pointer is not aligned.  Use  * get_unaligned((type *)iterator.this_arg) to dereference  * iterator.this_arg for type "type" safely on all arches.  *  * Example code: parse.c  */
end_comment

begin_function
name|int
name|ieee80211_radiotap_iterator_init
parameter_list|(
name|struct
name|ieee80211_radiotap_iterator
modifier|*
name|iterator
parameter_list|,
name|struct
name|ieee80211_radiotap_header
modifier|*
name|radiotap_header
parameter_list|,
name|int
name|max_length
parameter_list|,
specifier|const
name|struct
name|ieee80211_radiotap_vendor_namespaces
modifier|*
name|vns
parameter_list|)
block|{
comment|/* must at least have the radiotap header */
if|if
condition|(
name|max_length
operator|<
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_radiotap_header
argument_list|)
condition|)
return|return
operator|-
name|EINVAL
return|;
comment|/* Linux only supports version 0 radiotap format */
if|if
condition|(
name|radiotap_header
operator|->
name|it_version
condition|)
return|return
operator|-
name|EINVAL
return|;
comment|/* sanity check for allowed length and radiotap length field */
if|if
condition|(
name|max_length
operator|<
name|get_unaligned_le16
argument_list|(
operator|&
name|radiotap_header
operator|->
name|it_len
argument_list|)
condition|)
return|return
operator|-
name|EINVAL
return|;
name|iterator
operator|->
name|_rtheader
operator|=
name|radiotap_header
expr_stmt|;
name|iterator
operator|->
name|_max_length
operator|=
name|get_unaligned_le16
argument_list|(
operator|&
name|radiotap_header
operator|->
name|it_len
argument_list|)
expr_stmt|;
name|iterator
operator|->
name|_arg_index
operator|=
literal|0
expr_stmt|;
name|iterator
operator|->
name|_bitmap_shifter
operator|=
name|get_unaligned_le32
argument_list|(
operator|&
name|radiotap_header
operator|->
name|it_present
argument_list|)
expr_stmt|;
name|iterator
operator|->
name|_arg
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|radiotap_header
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|radiotap_header
argument_list|)
expr_stmt|;
name|iterator
operator|->
name|_next_ns_data
operator|=
name|NULL
expr_stmt|;
name|iterator
operator|->
name|_reset_on_ext
operator|=
literal|0
expr_stmt|;
name|iterator
operator|->
name|_next_bitmap
operator|=
operator|&
name|radiotap_header
operator|->
name|it_present
expr_stmt|;
name|iterator
operator|->
name|_next_bitmap
operator|++
expr_stmt|;
name|iterator
operator|->
name|_vns
operator|=
name|vns
expr_stmt|;
name|iterator
operator|->
name|current_namespace
operator|=
operator|&
name|radiotap_ns
expr_stmt|;
name|iterator
operator|->
name|is_radiotap_ns
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|RADIOTAP_SUPPORT_OVERRIDES
name|iterator
operator|->
name|n_overrides
operator|=
literal|0
expr_stmt|;
name|iterator
operator|->
name|overrides
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
comment|/* find payload start allowing for extended bitmap(s) */
if|if
condition|(
name|iterator
operator|->
name|_bitmap_shifter
operator|&
operator|(
literal|1
operator|<<
name|IEEE80211_RADIOTAP_EXT
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|unsigned
name|long
operator|)
name|iterator
operator|->
name|_arg
operator|-
operator|(
name|unsigned
name|long
operator|)
name|iterator
operator|->
name|_rtheader
operator|+
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|>
operator|(
name|unsigned
name|long
operator|)
name|iterator
operator|->
name|_max_length
condition|)
return|return
operator|-
name|EINVAL
return|;
while|while
condition|(
name|get_unaligned_le32
argument_list|(
name|iterator
operator|->
name|_arg
argument_list|)
operator|&
operator|(
literal|1
operator|<<
name|IEEE80211_RADIOTAP_EXT
operator|)
condition|)
block|{
name|iterator
operator|->
name|_arg
operator|+=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
comment|/* 			 * check for insanity where the present bitmaps 			 * keep claiming to extend up to or even beyond the 			 * stated radiotap header length 			 */
if|if
condition|(
operator|(
name|unsigned
name|long
operator|)
name|iterator
operator|->
name|_arg
operator|-
operator|(
name|unsigned
name|long
operator|)
name|iterator
operator|->
name|_rtheader
operator|+
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|>
operator|(
name|unsigned
name|long
operator|)
name|iterator
operator|->
name|_max_length
condition|)
return|return
operator|-
name|EINVAL
return|;
block|}
name|iterator
operator|->
name|_arg
operator|+=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
comment|/* 		 * no need to check again for blowing past stated radiotap 		 * header length, because ieee80211_radiotap_iterator_next 		 * checks it before it is dereferenced 		 */
block|}
name|iterator
operator|->
name|this_arg
operator|=
name|iterator
operator|->
name|_arg
expr_stmt|;
name|iterator
operator|->
name|this_arg_index
operator|=
literal|0
expr_stmt|;
name|iterator
operator|->
name|this_arg_size
operator|=
literal|0
expr_stmt|;
comment|/* we are all initialized happily */
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|find_ns
parameter_list|(
name|struct
name|ieee80211_radiotap_iterator
modifier|*
name|iterator
parameter_list|,
name|uint32_t
name|oui
parameter_list|,
name|uint8_t
name|subns
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|iterator
operator|->
name|current_namespace
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|iterator
operator|->
name|_vns
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|iterator
operator|->
name|_vns
operator|->
name|n_ns
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|iterator
operator|->
name|_vns
operator|->
name|ns
index|[
name|i
index|]
operator|.
name|oui
operator|!=
name|oui
condition|)
continue|continue;
if|if
condition|(
name|iterator
operator|->
name|_vns
operator|->
name|ns
index|[
name|i
index|]
operator|.
name|subns
operator|!=
name|subns
condition|)
continue|continue;
name|iterator
operator|->
name|current_namespace
operator|=
operator|&
name|iterator
operator|->
name|_vns
operator|->
name|ns
index|[
name|i
index|]
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|RADIOTAP_SUPPORT_OVERRIDES
end_ifdef

begin_function
specifier|static
name|int
name|find_override
parameter_list|(
name|struct
name|ieee80211_radiotap_iterator
modifier|*
name|iterator
parameter_list|,
name|int
modifier|*
name|align
parameter_list|,
name|int
modifier|*
name|size
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|iterator
operator|->
name|overrides
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|iterator
operator|->
name|n_overrides
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|iterator
operator|->
name|_arg_index
operator|==
name|iterator
operator|->
name|overrides
index|[
name|i
index|]
operator|.
name|field
condition|)
block|{
operator|*
name|align
operator|=
name|iterator
operator|->
name|overrides
index|[
name|i
index|]
operator|.
name|align
expr_stmt|;
operator|*
name|size
operator|=
name|iterator
operator|->
name|overrides
index|[
name|i
index|]
operator|.
name|size
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|align
condition|)
comment|/* erroneous override */
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  * ieee80211_radiotap_iterator_next - return next radiotap parser iterator arg  * @iterator: radiotap_iterator to move to next arg (if any)  *  * Returns: 0 if there is an argument to handle,  * -ENOENT if there are no more args or -EINVAL  * if there is something else wrong.  *  * This function provides the next radiotap arg index (IEEE80211_RADIOTAP_*)  * in @this_arg_index and sets @this_arg to point to the  * payload for the field.  It takes care of alignment handling and extended  * present fields.  @this_arg can be changed by the caller (eg,  * incremented to move inside a compound argument like  * IEEE80211_RADIOTAP_CHANNEL).  The args pointed to are in  * little-endian format whatever the endianess of your CPU.  *  * Alignment Gotcha:  * You must take care when dereferencing iterator.this_arg  * for multibyte types... the pointer is not aligned.  Use  * get_unaligned((type *)iterator.this_arg) to dereference  * iterator.this_arg for type "type" safely on all arches.  */
end_comment

begin_function
name|int
name|ieee80211_radiotap_iterator_next
parameter_list|(
name|struct
name|ieee80211_radiotap_iterator
modifier|*
name|iterator
parameter_list|)
block|{
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|hit
init|=
literal|0
decl_stmt|;
name|int
name|pad
decl_stmt|,
name|align
decl_stmt|,
name|size
decl_stmt|,
name|subns
decl_stmt|;
name|uint32_t
name|oui
decl_stmt|;
comment|/* if no more EXT bits, that's it */
if|if
condition|(
operator|(
name|iterator
operator|->
name|_arg_index
operator|%
literal|32
operator|)
operator|==
name|IEEE80211_RADIOTAP_EXT
operator|&&
operator|!
operator|(
name|iterator
operator|->
name|_bitmap_shifter
operator|&
literal|1
operator|)
condition|)
return|return
operator|-
name|ENOENT
return|;
if|if
condition|(
operator|!
operator|(
name|iterator
operator|->
name|_bitmap_shifter
operator|&
literal|1
operator|)
condition|)
goto|goto
name|next_entry
goto|;
comment|/* arg not present */
comment|/* get alignment/size of data */
switch|switch
condition|(
name|iterator
operator|->
name|_arg_index
operator|%
literal|32
condition|)
block|{
case|case
name|IEEE80211_RADIOTAP_RADIOTAP_NAMESPACE
case|:
case|case
name|IEEE80211_RADIOTAP_EXT
case|:
name|align
operator|=
literal|1
expr_stmt|;
name|size
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|IEEE80211_RADIOTAP_VENDOR_NAMESPACE
case|:
name|align
operator|=
literal|2
expr_stmt|;
name|size
operator|=
literal|6
expr_stmt|;
break|break;
default|default:
ifdef|#
directive|ifdef
name|RADIOTAP_SUPPORT_OVERRIDES
if|if
condition|(
name|find_override
argument_list|(
name|iterator
argument_list|,
operator|&
name|align
argument_list|,
operator|&
name|size
argument_list|)
condition|)
block|{
comment|/* all set */
block|}
elseif|else
endif|#
directive|endif
if|if
condition|(
operator|!
name|iterator
operator|->
name|current_namespace
operator|||
name|iterator
operator|->
name|_arg_index
operator|>=
name|iterator
operator|->
name|current_namespace
operator|->
name|n_bits
condition|)
block|{
if|if
condition|(
name|iterator
operator|->
name|current_namespace
operator|==
operator|&
name|radiotap_ns
condition|)
return|return
operator|-
name|ENOENT
return|;
name|align
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|align
operator|=
name|iterator
operator|->
name|current_namespace
operator|->
name|align_size
index|[
name|iterator
operator|->
name|_arg_index
index|]
operator|.
name|align
expr_stmt|;
name|size
operator|=
name|iterator
operator|->
name|current_namespace
operator|->
name|align_size
index|[
name|iterator
operator|->
name|_arg_index
index|]
operator|.
name|size
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|align
condition|)
block|{
comment|/* skip all subsequent data */
name|iterator
operator|->
name|_arg
operator|=
name|iterator
operator|->
name|_next_ns_data
expr_stmt|;
comment|/* give up on this namespace */
name|iterator
operator|->
name|current_namespace
operator|=
name|NULL
expr_stmt|;
goto|goto
name|next_entry
goto|;
block|}
break|break;
block|}
comment|/* 		 * arg is present, account for alignment padding 		 * 		 * Note that these alignments are relative to the start 		 * of the radiotap header.  There is no guarantee 		 * that the radiotap header itself is aligned on any 		 * kind of boundary. 		 * 		 * The above is why get_unaligned() is used to dereference 		 * multibyte elements from the radiotap area. 		 */
name|pad
operator|=
operator|(
operator|(
name|unsigned
name|long
operator|)
name|iterator
operator|->
name|_arg
operator|-
operator|(
name|unsigned
name|long
operator|)
name|iterator
operator|->
name|_rtheader
operator|)
operator|&
operator|(
name|align
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|pad
condition|)
name|iterator
operator|->
name|_arg
operator|+=
name|align
operator|-
name|pad
expr_stmt|;
if|if
condition|(
name|iterator
operator|->
name|_arg_index
operator|%
literal|32
operator|==
name|IEEE80211_RADIOTAP_VENDOR_NAMESPACE
condition|)
block|{
name|int
name|vnslen
decl_stmt|;
if|if
condition|(
operator|(
name|unsigned
name|long
operator|)
name|iterator
operator|->
name|_arg
operator|+
name|size
operator|-
operator|(
name|unsigned
name|long
operator|)
name|iterator
operator|->
name|_rtheader
operator|>
operator|(
name|unsigned
name|long
operator|)
name|iterator
operator|->
name|_max_length
condition|)
return|return
operator|-
name|EINVAL
return|;
name|oui
operator|=
operator|(
operator|*
name|iterator
operator|->
name|_arg
operator|<<
literal|16
operator|)
operator||
operator|(
operator|*
operator|(
name|iterator
operator|->
name|_arg
operator|+
literal|1
operator|)
operator|<<
literal|8
operator|)
operator||
operator|*
operator|(
name|iterator
operator|->
name|_arg
operator|+
literal|2
operator|)
expr_stmt|;
name|subns
operator|=
operator|*
operator|(
name|iterator
operator|->
name|_arg
operator|+
literal|3
operator|)
expr_stmt|;
name|find_ns
argument_list|(
name|iterator
argument_list|,
name|oui
argument_list|,
name|subns
argument_list|)
expr_stmt|;
name|vnslen
operator|=
name|get_unaligned_le16
argument_list|(
name|iterator
operator|->
name|_arg
operator|+
literal|4
argument_list|)
expr_stmt|;
name|iterator
operator|->
name|_next_ns_data
operator|=
name|iterator
operator|->
name|_arg
operator|+
name|size
operator|+
name|vnslen
expr_stmt|;
if|if
condition|(
operator|!
name|iterator
operator|->
name|current_namespace
condition|)
name|size
operator|+=
name|vnslen
expr_stmt|;
block|}
comment|/* 		 * this is what we will return to user, but we need to 		 * move on first so next call has something fresh to test 		 */
name|iterator
operator|->
name|this_arg_index
operator|=
name|iterator
operator|->
name|_arg_index
expr_stmt|;
name|iterator
operator|->
name|this_arg
operator|=
name|iterator
operator|->
name|_arg
expr_stmt|;
name|iterator
operator|->
name|this_arg_size
operator|=
name|size
expr_stmt|;
comment|/* internally move on the size of this arg */
name|iterator
operator|->
name|_arg
operator|+=
name|size
expr_stmt|;
comment|/* 		 * check for insanity where we are given a bitmap that 		 * claims to have more arg content than the length of the 		 * radiotap section.  We will normally end up equalling this 		 * max_length on the last arg, never exceeding it. 		 */
if|if
condition|(
operator|(
name|unsigned
name|long
operator|)
name|iterator
operator|->
name|_arg
operator|-
operator|(
name|unsigned
name|long
operator|)
name|iterator
operator|->
name|_rtheader
operator|>
operator|(
name|unsigned
name|long
operator|)
name|iterator
operator|->
name|_max_length
condition|)
return|return
operator|-
name|EINVAL
return|;
comment|/* these special ones are valid in each bitmap word */
switch|switch
condition|(
name|iterator
operator|->
name|_arg_index
operator|%
literal|32
condition|)
block|{
case|case
name|IEEE80211_RADIOTAP_VENDOR_NAMESPACE
case|:
name|iterator
operator|->
name|_reset_on_ext
operator|=
literal|1
expr_stmt|;
name|iterator
operator|->
name|is_radiotap_ns
operator|=
literal|0
expr_stmt|;
comment|/* 			 * If parser didn't register this vendor 			 * namespace with us, allow it to show it 			 * as 'raw. Do do that, set argument index 			 * to vendor namespace. 			 */
name|iterator
operator|->
name|this_arg_index
operator|=
name|IEEE80211_RADIOTAP_VENDOR_NAMESPACE
expr_stmt|;
if|if
condition|(
operator|!
name|iterator
operator|->
name|current_namespace
condition|)
name|hit
operator|=
literal|1
expr_stmt|;
goto|goto
name|next_entry
goto|;
case|case
name|IEEE80211_RADIOTAP_RADIOTAP_NAMESPACE
case|:
name|iterator
operator|->
name|_reset_on_ext
operator|=
literal|1
expr_stmt|;
name|iterator
operator|->
name|current_namespace
operator|=
operator|&
name|radiotap_ns
expr_stmt|;
name|iterator
operator|->
name|is_radiotap_ns
operator|=
literal|1
expr_stmt|;
goto|goto
name|next_entry
goto|;
case|case
name|IEEE80211_RADIOTAP_EXT
case|:
comment|/* 			 * bit 31 was set, there is more 			 * -- move to next u32 bitmap 			 */
name|iterator
operator|->
name|_bitmap_shifter
operator|=
name|get_unaligned_le32
argument_list|(
name|iterator
operator|->
name|_next_bitmap
argument_list|)
expr_stmt|;
name|iterator
operator|->
name|_next_bitmap
operator|++
expr_stmt|;
if|if
condition|(
name|iterator
operator|->
name|_reset_on_ext
condition|)
name|iterator
operator|->
name|_arg_index
operator|=
literal|0
expr_stmt|;
else|else
name|iterator
operator|->
name|_arg_index
operator|++
expr_stmt|;
name|iterator
operator|->
name|_reset_on_ext
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
comment|/* we've got a hit! */
name|hit
operator|=
literal|1
expr_stmt|;
name|next_entry
label|:
name|iterator
operator|->
name|_bitmap_shifter
operator|>>=
literal|1
expr_stmt|;
name|iterator
operator|->
name|_arg_index
operator|++
expr_stmt|;
block|}
comment|/* if we found a valid arg earlier, return it now */
if|if
condition|(
name|hit
condition|)
return|return
literal|0
return|;
block|}
block|}
end_function

end_unit

