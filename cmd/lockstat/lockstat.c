begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright 2008 Sun Microsystems, Inc.  All rights reserved.  * Use is subject to license terms.  */
end_comment

begin_pragma
pragma|#
directive|pragma
name|ident
literal|"%Z%%M%	%I%	%E% SMI"
end_pragma

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/modctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_include
include|#
directive|include
file|<dtrace.h>
end_include

begin_include
include|#
directive|include
file|<sys/lockstat.h>
end_include

begin_include
include|#
directive|include
file|<alloca.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_define
define|#
directive|define
name|LOCKSTAT_OPTSTR
value|"x:bths:n:d:i:l:f:e:ckwWgCHEATID:RpPo:V"
end_define

begin_define
define|#
directive|define
name|LS_MAX_STACK_DEPTH
value|50
end_define

begin_define
define|#
directive|define
name|LS_MAX_EVENTS
value|64
end_define

begin_typedef
typedef|typedef
struct|struct
name|lsrec
block|{
name|struct
name|lsrec
modifier|*
name|ls_next
decl_stmt|;
comment|/* next in hash chain */
name|uintptr_t
name|ls_lock
decl_stmt|;
comment|/* lock address */
name|uintptr_t
name|ls_caller
decl_stmt|;
comment|/* caller address */
name|uint32_t
name|ls_count
decl_stmt|;
comment|/* cumulative event count */
name|uint32_t
name|ls_event
decl_stmt|;
comment|/* type of event */
name|uintptr_t
name|ls_refcnt
decl_stmt|;
comment|/* cumulative reference count */
name|uint64_t
name|ls_time
decl_stmt|;
comment|/* cumulative event duration */
name|uint32_t
name|ls_hist
index|[
literal|64
index|]
decl_stmt|;
comment|/* log2(duration) histogram */
name|uintptr_t
name|ls_stack
index|[
name|LS_MAX_STACK_DEPTH
index|]
decl_stmt|;
block|}
name|lsrec_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|lsdata
block|{
name|struct
name|lsrec
modifier|*
name|lsd_next
decl_stmt|;
comment|/* next available */
name|int
name|lsd_count
decl_stmt|;
comment|/* number of records */
block|}
name|lsdata_t
typedef|;
end_typedef

begin_comment
comment|/*  * Definitions for the types of experiments which can be run.  They are  * listed in increasing order of memory cost and processing time cost.  * The numerical value of each type is the number of bytes needed per record.  */
end_comment

begin_define
define|#
directive|define
name|LS_BASIC
value|offsetof(lsrec_t, ls_time)
end_define

begin_define
define|#
directive|define
name|LS_TIME
value|offsetof(lsrec_t, ls_hist[0])
end_define

begin_define
define|#
directive|define
name|LS_HIST
value|offsetof(lsrec_t, ls_stack[0])
end_define

begin_define
define|#
directive|define
name|LS_STACK
parameter_list|(
name|depth
parameter_list|)
value|offsetof(lsrec_t, ls_stack[depth])
end_define

begin_function_decl
specifier|static
name|void
name|report_stats
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|lsrec_t
modifier|*
modifier|*
parameter_list|,
name|size_t
parameter_list|,
name|uint64_t
parameter_list|,
name|uint64_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|report_trace
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|lsrec_t
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|symtab_init
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|addr_to_sym
parameter_list|(
name|uintptr_t
parameter_list|,
name|uintptr_t
modifier|*
parameter_list|,
name|size_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|uintptr_t
name|sym_to_addr
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|size_t
name|sym_size
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|strtok_r
parameter_list|(
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|DEFAULT_NRECS
value|10000
end_define

begin_define
define|#
directive|define
name|DEFAULT_HZ
value|97
end_define

begin_define
define|#
directive|define
name|MAX_HZ
value|1000
end_define

begin_define
define|#
directive|define
name|MIN_AGGSIZE
value|(16 * 1024)
end_define

begin_define
define|#
directive|define
name|MAX_AGGSIZE
value|(32 * 1024 * 1024)
end_define

begin_decl_stmt
specifier|static
name|int
name|g_stkdepth
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|g_topn
init|=
name|INT_MAX
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|hrtime_t
name|g_elapsed
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|g_rates
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|g_pflag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|g_Pflag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|g_wflag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|g_Wflag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|g_cflag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|g_kflag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|g_gflag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|g_Vflag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|g_tracing
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|size_t
name|g_recsize
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|size_t
name|g_nrecs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|g_nrecs_used
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uchar_t
name|g_enabled
index|[
name|LS_MAX_EVENTS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|hrtime_t
name|g_min_duration
index|[
name|LS_MAX_EVENTS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|dtrace_hdl_t
modifier|*
name|g_dtp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|g_predicate
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|g_ipredicate
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|g_prog
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|g_proglen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|g_dropped
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
struct|struct
name|ls_event_info
block|{
name|char
name|ev_type
decl_stmt|;
name|char
name|ev_lhdr
index|[
literal|20
index|]
decl_stmt|;
name|char
name|ev_desc
index|[
literal|80
index|]
decl_stmt|;
name|char
name|ev_units
index|[
literal|10
index|]
decl_stmt|;
name|char
name|ev_name
index|[
name|DTRACE_NAMELEN
index|]
decl_stmt|;
name|char
modifier|*
name|ev_predicate
decl_stmt|;
name|char
modifier|*
name|ev_acquire
decl_stmt|;
block|}
name|ls_event_info_t
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|ls_event_info_t
name|g_event_info
index|[
name|LS_MAX_EVENTS
index|]
init|=
block|{
block|{
literal|'C'
block|,
literal|"Lock"
block|,
literal|"Adaptive mutex spin"
block|,
literal|"nsec"
block|,
literal|"lockstat:::adaptive-spin"
block|}
block|,
block|{
literal|'C'
block|,
literal|"Lock"
block|,
literal|"Adaptive mutex block"
block|,
literal|"nsec"
block|,
literal|"lockstat:::adaptive-block"
block|}
block|,
block|{
literal|'C'
block|,
literal|"Lock"
block|,
literal|"Spin lock spin"
block|,
literal|"nsec"
block|,
literal|"lockstat:::spin-spin"
block|}
block|,
block|{
literal|'C'
block|,
literal|"Lock"
block|,
literal|"Thread lock spin"
block|,
literal|"nsec"
block|,
literal|"lockstat:::thread-spin"
block|}
block|,
block|{
literal|'C'
block|,
literal|"Lock"
block|,
literal|"R/W writer blocked by writer"
block|,
literal|"nsec"
block|,
literal|"lockstat:::rw-block"
block|,
literal|"arg2 == 0&& arg3 == 1"
block|}
block|,
block|{
literal|'C'
block|,
literal|"Lock"
block|,
literal|"R/W writer blocked by readers"
block|,
literal|"nsec"
block|,
literal|"lockstat:::rw-block"
block|,
literal|"arg2 == 0&& arg3 == 0&& arg4"
block|}
block|,
block|{
literal|'C'
block|,
literal|"Lock"
block|,
literal|"R/W reader blocked by writer"
block|,
literal|"nsec"
block|,
literal|"lockstat:::rw-block"
block|,
literal|"arg2 != 0&& arg3 == 1"
block|}
block|,
block|{
literal|'C'
block|,
literal|"Lock"
block|,
literal|"R/W reader blocked by write wanted"
block|,
literal|"nsec"
block|,
literal|"lockstat:::rw-block"
block|,
literal|"arg2 != 0&& arg3 == 0&& arg4"
block|}
block|,
block|{
literal|'C'
block|,
literal|"Lock"
block|,
literal|"Unknown event (type 8)"
block|,
literal|"units"
block|}
block|,
block|{
literal|'C'
block|,
literal|"Lock"
block|,
literal|"Unknown event (type 9)"
block|,
literal|"units"
block|}
block|,
block|{
literal|'C'
block|,
literal|"Lock"
block|,
literal|"Unknown event (type 10)"
block|,
literal|"units"
block|}
block|,
block|{
literal|'C'
block|,
literal|"Lock"
block|,
literal|"Unknown event (type 11)"
block|,
literal|"units"
block|}
block|,
block|{
literal|'C'
block|,
literal|"Lock"
block|,
literal|"Unknown event (type 12)"
block|,
literal|"units"
block|}
block|,
block|{
literal|'C'
block|,
literal|"Lock"
block|,
literal|"Unknown event (type 13)"
block|,
literal|"units"
block|}
block|,
block|{
literal|'C'
block|,
literal|"Lock"
block|,
literal|"Unknown event (type 14)"
block|,
literal|"units"
block|}
block|,
block|{
literal|'C'
block|,
literal|"Lock"
block|,
literal|"Unknown event (type 15)"
block|,
literal|"units"
block|}
block|,
block|{
literal|'C'
block|,
literal|"Lock"
block|,
literal|"Unknown event (type 16)"
block|,
literal|"units"
block|}
block|,
block|{
literal|'C'
block|,
literal|"Lock"
block|,
literal|"Unknown event (type 17)"
block|,
literal|"units"
block|}
block|,
block|{
literal|'C'
block|,
literal|"Lock"
block|,
literal|"Unknown event (type 18)"
block|,
literal|"units"
block|}
block|,
block|{
literal|'C'
block|,
literal|"Lock"
block|,
literal|"Unknown event (type 19)"
block|,
literal|"units"
block|}
block|,
block|{
literal|'C'
block|,
literal|"Lock"
block|,
literal|"Unknown event (type 20)"
block|,
literal|"units"
block|}
block|,
block|{
literal|'C'
block|,
literal|"Lock"
block|,
literal|"Unknown event (type 21)"
block|,
literal|"units"
block|}
block|,
block|{
literal|'C'
block|,
literal|"Lock"
block|,
literal|"Unknown event (type 22)"
block|,
literal|"units"
block|}
block|,
block|{
literal|'C'
block|,
literal|"Lock"
block|,
literal|"Unknown event (type 23)"
block|,
literal|"units"
block|}
block|,
block|{
literal|'C'
block|,
literal|"Lock"
block|,
literal|"Unknown event (type 24)"
block|,
literal|"units"
block|}
block|,
block|{
literal|'C'
block|,
literal|"Lock"
block|,
literal|"Unknown event (type 25)"
block|,
literal|"units"
block|}
block|,
block|{
literal|'C'
block|,
literal|"Lock"
block|,
literal|"Unknown event (type 26)"
block|,
literal|"units"
block|}
block|,
block|{
literal|'C'
block|,
literal|"Lock"
block|,
literal|"Unknown event (type 27)"
block|,
literal|"units"
block|}
block|,
block|{
literal|'C'
block|,
literal|"Lock"
block|,
literal|"Unknown event (type 28)"
block|,
literal|"units"
block|}
block|,
block|{
literal|'C'
block|,
literal|"Lock"
block|,
literal|"Unknown event (type 29)"
block|,
literal|"units"
block|}
block|,
block|{
literal|'C'
block|,
literal|"Lock"
block|,
literal|"Unknown event (type 30)"
block|,
literal|"units"
block|}
block|,
block|{
literal|'C'
block|,
literal|"Lock"
block|,
literal|"Unknown event (type 31)"
block|,
literal|"units"
block|}
block|,
block|{
literal|'H'
block|,
literal|"Lock"
block|,
literal|"Adaptive mutex hold"
block|,
literal|"nsec"
block|,
literal|"lockstat:::adaptive-release"
block|,
name|NULL
block|,
literal|"lockstat:::adaptive-acquire"
block|}
block|,
block|{
literal|'H'
block|,
literal|"Lock"
block|,
literal|"Spin lock hold"
block|,
literal|"nsec"
block|,
literal|"lockstat:::spin-release"
block|,
name|NULL
block|,
literal|"lockstat:::spin-acquire"
block|}
block|,
block|{
literal|'H'
block|,
literal|"Lock"
block|,
literal|"R/W writer hold"
block|,
literal|"nsec"
block|,
literal|"lockstat:::rw-release"
block|,
literal|"arg1 == 0"
block|,
literal|"lockstat:::rw-acquire"
block|}
block|,
block|{
literal|'H'
block|,
literal|"Lock"
block|,
literal|"R/W reader hold"
block|,
literal|"nsec"
block|,
literal|"lockstat:::rw-release"
block|,
literal|"arg1 != 0"
block|,
literal|"lockstat:::rw-acquire"
block|}
block|,
block|{
literal|'H'
block|,
literal|"Lock"
block|,
literal|"Unknown event (type 36)"
block|,
literal|"units"
block|}
block|,
block|{
literal|'H'
block|,
literal|"Lock"
block|,
literal|"Unknown event (type 37)"
block|,
literal|"units"
block|}
block|,
block|{
literal|'H'
block|,
literal|"Lock"
block|,
literal|"Unknown event (type 38)"
block|,
literal|"units"
block|}
block|,
block|{
literal|'H'
block|,
literal|"Lock"
block|,
literal|"Unknown event (type 39)"
block|,
literal|"units"
block|}
block|,
block|{
literal|'H'
block|,
literal|"Lock"
block|,
literal|"Unknown event (type 40)"
block|,
literal|"units"
block|}
block|,
block|{
literal|'H'
block|,
literal|"Lock"
block|,
literal|"Unknown event (type 41)"
block|,
literal|"units"
block|}
block|,
block|{
literal|'H'
block|,
literal|"Lock"
block|,
literal|"Unknown event (type 42)"
block|,
literal|"units"
block|}
block|,
block|{
literal|'H'
block|,
literal|"Lock"
block|,
literal|"Unknown event (type 43)"
block|,
literal|"units"
block|}
block|,
block|{
literal|'H'
block|,
literal|"Lock"
block|,
literal|"Unknown event (type 44)"
block|,
literal|"units"
block|}
block|,
block|{
literal|'H'
block|,
literal|"Lock"
block|,
literal|"Unknown event (type 45)"
block|,
literal|"units"
block|}
block|,
block|{
literal|'H'
block|,
literal|"Lock"
block|,
literal|"Unknown event (type 46)"
block|,
literal|"units"
block|}
block|,
block|{
literal|'H'
block|,
literal|"Lock"
block|,
literal|"Unknown event (type 47)"
block|,
literal|"units"
block|}
block|,
block|{
literal|'H'
block|,
literal|"Lock"
block|,
literal|"Unknown event (type 48)"
block|,
literal|"units"
block|}
block|,
block|{
literal|'H'
block|,
literal|"Lock"
block|,
literal|"Unknown event (type 49)"
block|,
literal|"units"
block|}
block|,
block|{
literal|'H'
block|,
literal|"Lock"
block|,
literal|"Unknown event (type 50)"
block|,
literal|"units"
block|}
block|,
block|{
literal|'H'
block|,
literal|"Lock"
block|,
literal|"Unknown event (type 51)"
block|,
literal|"units"
block|}
block|,
block|{
literal|'H'
block|,
literal|"Lock"
block|,
literal|"Unknown event (type 52)"
block|,
literal|"units"
block|}
block|,
block|{
literal|'H'
block|,
literal|"Lock"
block|,
literal|"Unknown event (type 53)"
block|,
literal|"units"
block|}
block|,
block|{
literal|'H'
block|,
literal|"Lock"
block|,
literal|"Unknown event (type 54)"
block|,
literal|"units"
block|}
block|,
block|{
literal|'H'
block|,
literal|"Lock"
block|,
literal|"Unknown event (type 55)"
block|,
literal|"units"
block|}
block|,
block|{
literal|'I'
block|,
literal|"CPU+PIL"
block|,
literal|"Profiling interrupt"
block|,
literal|"nsec"
block|,
literal|"profile:::profile-97"
block|,
name|NULL
block|}
block|,
block|{
literal|'I'
block|,
literal|"Lock"
block|,
literal|"Unknown event (type 57)"
block|,
literal|"units"
block|}
block|,
block|{
literal|'I'
block|,
literal|"Lock"
block|,
literal|"Unknown event (type 58)"
block|,
literal|"units"
block|}
block|,
block|{
literal|'I'
block|,
literal|"Lock"
block|,
literal|"Unknown event (type 59)"
block|,
literal|"units"
block|}
block|,
block|{
literal|'E'
block|,
literal|"Lock"
block|,
literal|"Recursive lock entry detected"
block|,
literal|"(N/A)"
block|,
literal|"lockstat:::rw-release"
block|,
name|NULL
block|,
literal|"lockstat:::rw-acquire"
block|}
block|,
block|{
literal|'E'
block|,
literal|"Lock"
block|,
literal|"Lockstat enter failure"
block|,
literal|"(N/A)"
block|}
block|,
block|{
literal|'E'
block|,
literal|"Lock"
block|,
literal|"Lockstat exit failure"
block|,
literal|"nsec"
block|}
block|,
block|{
literal|'E'
block|,
literal|"Lock"
block|,
literal|"Lockstat record failure"
block|,
literal|"(N/A)"
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|fail
parameter_list|(
name|int
name|do_perror
parameter_list|,
specifier|const
name|char
modifier|*
name|message
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|args
decl_stmt|;
name|int
name|save_errno
init|=
name|errno
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|message
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"lockstat: "
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|message
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_perror
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|": %s"
argument_list|,
name|strerror
argument_list|(
name|save_errno
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dfail
parameter_list|(
specifier|const
name|char
modifier|*
name|message
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|args
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|message
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"lockstat: "
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|message
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|": %s\n"
argument_list|,
name|dtrace_errmsg
argument_list|(
name|g_dtp
argument_list|,
name|dtrace_errno
argument_list|(
name|g_dtp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|show_events
parameter_list|(
name|char
name|event_type
parameter_list|,
name|char
modifier|*
name|desc
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|first
init|=
operator|-
literal|1
decl_stmt|,
name|last
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|LS_MAX_EVENTS
condition|;
name|i
operator|++
control|)
block|{
name|ls_event_info_t
modifier|*
name|evp
init|=
operator|&
name|g_event_info
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|evp
operator|->
name|ev_type
operator|!=
name|event_type
operator|||
name|strncmp
argument_list|(
name|evp
operator|->
name|ev_desc
argument_list|,
literal|"Unknown event"
argument_list|,
literal|13
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|first
operator|==
operator|-
literal|1
condition|)
name|first
operator|=
name|i
expr_stmt|;
name|last
operator|=
name|i
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n%s events (lockstat -%c or lockstat -e %d-%d):\n\n"
argument_list|,
name|desc
argument_list|,
name|event_type
argument_list|,
name|first
argument_list|,
name|last
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|first
init|;
name|i
operator|<=
name|last
condition|;
name|i
operator|++
control|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%4d = %s\n"
argument_list|,
name|i
argument_list|,
name|g_event_info
index|[
name|i
index|]
operator|.
name|ev_desc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: lockstat [options] command [args]\n"
literal|"\nEvent selection options:\n\n"
literal|"  -C              watch contention events [on by default]\n"
literal|"  -E              watch error events [off by default]\n"
literal|"  -H              watch hold events [off by default]\n"
literal|"  -I              watch interrupt events [off by default]\n"
literal|"  -A              watch all lock events [equivalent to -CH]\n"
literal|"  -e event_list   only watch the specified events (shown below);\n"
literal|"<event_list> is a comma-separated list of\n"
literal|"                  events or ranges of events, e.g. 1,4-7,35\n"
literal|"  -i rate         interrupt rate for -I [default: %d Hz]\n"
literal|"\nData gathering options:\n\n"
literal|"  -b              basic statistics (lock, caller, event count)\n"
literal|"  -t              timing for all events [default]\n"
literal|"  -h              histograms for event times\n"
literal|"  -s depth        stack traces<depth> deep\n"
literal|"  -x opt[=val]    enable or modify DTrace options\n"
literal|"\nData filtering options:\n\n"
literal|"  -n nrecords     maximum number of data records [default: %d]\n"
literal|"  -l lock[,size]  only watch<lock>, which can be specified as a\n"
literal|"                  symbolic name or hex address;<size> defaults\n"
literal|"                  to the ELF symbol size if available, 1 if not\n"
literal|"  -f func[,size]  only watch events generated by<func>\n"
literal|"  -d duration     only watch events longer than<duration>\n"
literal|"  -T              trace (rather than sample) events\n"
literal|"\nData reporting options:\n\n"
literal|"  -c              coalesce lock data for arrays like pse_mutex[]\n"
literal|"  -k              coalesce PCs within functions\n"
literal|"  -g              show total events generated by function\n"
literal|"  -w              wherever: don't distinguish events by caller\n"
literal|"  -W              whichever: don't distinguish events by lock\n"
literal|"  -R              display rates rather than counts\n"
literal|"  -p              parsable output format (awk(1)-friendly)\n"
literal|"  -P              sort lock data by (count * avg_time) product\n"
literal|"  -D n            only display top<n> events of each type\n"
literal|"  -o filename     send output to<filename>\n"
argument_list|,
name|DEFAULT_HZ
argument_list|,
name|DEFAULT_NRECS
argument_list|)
expr_stmt|;
name|show_events
argument_list|(
literal|'C'
argument_list|,
literal|"Contention"
argument_list|)
expr_stmt|;
name|show_events
argument_list|(
literal|'H'
argument_list|,
literal|"Hold-time"
argument_list|)
expr_stmt|;
name|show_events
argument_list|(
literal|'I'
argument_list|,
literal|"Interrupt"
argument_list|)
expr_stmt|;
name|show_events
argument_list|(
literal|'E'
argument_list|,
literal|"Error"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|lockcmp
parameter_list|(
name|lsrec_t
modifier|*
name|a
parameter_list|,
name|lsrec_t
modifier|*
name|b
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|a
operator|->
name|ls_event
operator|<
name|b
operator|->
name|ls_event
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|a
operator|->
name|ls_event
operator|>
name|b
operator|->
name|ls_event
condition|)
return|return
operator|(
literal|1
operator|)
return|;
for|for
control|(
name|i
operator|=
name|g_stkdepth
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|a
operator|->
name|ls_stack
index|[
name|i
index|]
operator|<
name|b
operator|->
name|ls_stack
index|[
name|i
index|]
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|a
operator|->
name|ls_stack
index|[
name|i
index|]
operator|>
name|b
operator|->
name|ls_stack
index|[
name|i
index|]
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|a
operator|->
name|ls_caller
operator|<
name|b
operator|->
name|ls_caller
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|a
operator|->
name|ls_caller
operator|>
name|b
operator|->
name|ls_caller
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|a
operator|->
name|ls_lock
operator|<
name|b
operator|->
name|ls_lock
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|a
operator|->
name|ls_lock
operator|>
name|b
operator|->
name|ls_lock
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|countcmp
parameter_list|(
name|lsrec_t
modifier|*
name|a
parameter_list|,
name|lsrec_t
modifier|*
name|b
parameter_list|)
block|{
if|if
condition|(
name|a
operator|->
name|ls_event
operator|<
name|b
operator|->
name|ls_event
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|a
operator|->
name|ls_event
operator|>
name|b
operator|->
name|ls_event
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
name|b
operator|->
name|ls_count
operator|-
name|a
operator|->
name|ls_count
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|timecmp
parameter_list|(
name|lsrec_t
modifier|*
name|a
parameter_list|,
name|lsrec_t
modifier|*
name|b
parameter_list|)
block|{
if|if
condition|(
name|a
operator|->
name|ls_event
operator|<
name|b
operator|->
name|ls_event
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|a
operator|->
name|ls_event
operator|>
name|b
operator|->
name|ls_event
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|a
operator|->
name|ls_time
operator|<
name|b
operator|->
name|ls_time
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|a
operator|->
name|ls_time
operator|>
name|b
operator|->
name|ls_time
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|lockcmp_anywhere
parameter_list|(
name|lsrec_t
modifier|*
name|a
parameter_list|,
name|lsrec_t
modifier|*
name|b
parameter_list|)
block|{
if|if
condition|(
name|a
operator|->
name|ls_event
operator|<
name|b
operator|->
name|ls_event
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|a
operator|->
name|ls_event
operator|>
name|b
operator|->
name|ls_event
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|a
operator|->
name|ls_lock
operator|<
name|b
operator|->
name|ls_lock
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|a
operator|->
name|ls_lock
operator|>
name|b
operator|->
name|ls_lock
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|lock_and_count_cmp_anywhere
parameter_list|(
name|lsrec_t
modifier|*
name|a
parameter_list|,
name|lsrec_t
modifier|*
name|b
parameter_list|)
block|{
if|if
condition|(
name|a
operator|->
name|ls_event
operator|<
name|b
operator|->
name|ls_event
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|a
operator|->
name|ls_event
operator|>
name|b
operator|->
name|ls_event
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|a
operator|->
name|ls_lock
operator|<
name|b
operator|->
name|ls_lock
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|a
operator|->
name|ls_lock
operator|>
name|b
operator|->
name|ls_lock
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
name|b
operator|->
name|ls_count
operator|-
name|a
operator|->
name|ls_count
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sitecmp_anylock
parameter_list|(
name|lsrec_t
modifier|*
name|a
parameter_list|,
name|lsrec_t
modifier|*
name|b
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|a
operator|->
name|ls_event
operator|<
name|b
operator|->
name|ls_event
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|a
operator|->
name|ls_event
operator|>
name|b
operator|->
name|ls_event
condition|)
return|return
operator|(
literal|1
operator|)
return|;
for|for
control|(
name|i
operator|=
name|g_stkdepth
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|a
operator|->
name|ls_stack
index|[
name|i
index|]
operator|<
name|b
operator|->
name|ls_stack
index|[
name|i
index|]
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|a
operator|->
name|ls_stack
index|[
name|i
index|]
operator|>
name|b
operator|->
name|ls_stack
index|[
name|i
index|]
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|a
operator|->
name|ls_caller
operator|<
name|b
operator|->
name|ls_caller
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|a
operator|->
name|ls_caller
operator|>
name|b
operator|->
name|ls_caller
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|site_and_count_cmp_anylock
parameter_list|(
name|lsrec_t
modifier|*
name|a
parameter_list|,
name|lsrec_t
modifier|*
name|b
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|a
operator|->
name|ls_event
operator|<
name|b
operator|->
name|ls_event
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|a
operator|->
name|ls_event
operator|>
name|b
operator|->
name|ls_event
condition|)
return|return
operator|(
literal|1
operator|)
return|;
for|for
control|(
name|i
operator|=
name|g_stkdepth
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|a
operator|->
name|ls_stack
index|[
name|i
index|]
operator|<
name|b
operator|->
name|ls_stack
index|[
name|i
index|]
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|a
operator|->
name|ls_stack
index|[
name|i
index|]
operator|>
name|b
operator|->
name|ls_stack
index|[
name|i
index|]
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|a
operator|->
name|ls_caller
operator|<
name|b
operator|->
name|ls_caller
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|a
operator|->
name|ls_caller
operator|>
name|b
operator|->
name|ls_caller
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
name|b
operator|->
name|ls_count
operator|-
name|a
operator|->
name|ls_count
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mergesort
parameter_list|(
name|int
function_decl|(
modifier|*
name|cmp
function_decl|)
parameter_list|(
name|lsrec_t
modifier|*
parameter_list|,
name|lsrec_t
modifier|*
parameter_list|)
parameter_list|,
name|lsrec_t
modifier|*
modifier|*
name|a
parameter_list|,
name|lsrec_t
modifier|*
modifier|*
name|b
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|int
name|m
init|=
name|n
operator|/
literal|2
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
name|m
operator|>
literal|1
condition|)
name|mergesort
argument_list|(
name|cmp
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|-
name|m
operator|>
literal|1
condition|)
name|mergesort
argument_list|(
name|cmp
argument_list|,
name|a
operator|+
name|m
argument_list|,
name|b
operator|+
name|m
argument_list|,
name|n
operator|-
name|m
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|m
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
name|b
index|[
name|i
operator|-
literal|1
index|]
operator|=
name|a
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
for|for
control|(
name|j
operator|=
name|m
operator|-
literal|1
init|;
name|j
operator|<
name|n
operator|-
literal|1
condition|;
name|j
operator|++
control|)
name|b
index|[
name|n
operator|+
name|m
operator|-
name|j
operator|-
literal|2
index|]
operator|=
name|a
index|[
name|j
operator|+
literal|1
index|]
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|j
condition|)
operator|*
name|a
operator|++
operator|=
name|cmp
argument_list|(
name|b
index|[
name|i
index|]
argument_list|,
name|b
index|[
name|j
index|]
argument_list|)
operator|<
literal|0
condition|?
name|b
index|[
name|i
operator|++
index|]
else|:
name|b
index|[
name|j
operator|--
index|]
expr_stmt|;
operator|*
name|a
operator|=
name|b
index|[
name|i
index|]
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|coalesce
parameter_list|(
name|int
function_decl|(
modifier|*
name|cmp
function_decl|)
parameter_list|(
name|lsrec_t
modifier|*
parameter_list|,
name|lsrec_t
modifier|*
parameter_list|)
parameter_list|,
name|lsrec_t
modifier|*
modifier|*
name|lock
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|lsrec_t
modifier|*
name|target
decl_stmt|,
modifier|*
name|current
decl_stmt|;
name|target
operator|=
name|lock
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|current
operator|=
name|lock
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|cmp
argument_list|(
name|current
argument_list|,
name|target
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|target
operator|=
name|current
expr_stmt|;
continue|continue;
block|}
name|current
operator|->
name|ls_event
operator|=
name|LS_MAX_EVENTS
expr_stmt|;
name|target
operator|->
name|ls_count
operator|+=
name|current
operator|->
name|ls_count
expr_stmt|;
name|target
operator|->
name|ls_refcnt
operator|+=
name|current
operator|->
name|ls_refcnt
expr_stmt|;
if|if
condition|(
name|g_recsize
operator|<
name|LS_TIME
condition|)
continue|continue;
name|target
operator|->
name|ls_time
operator|+=
name|current
operator|->
name|ls_time
expr_stmt|;
if|if
condition|(
name|g_recsize
operator|<
name|LS_HIST
condition|)
continue|continue;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|64
condition|;
name|j
operator|++
control|)
name|target
operator|->
name|ls_hist
index|[
name|j
index|]
operator|+=
name|current
operator|->
name|ls_hist
index|[
name|j
index|]
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|coalesce_symbol
parameter_list|(
name|uintptr_t
modifier|*
name|addrp
parameter_list|)
block|{
name|uintptr_t
name|symoff
decl_stmt|;
name|size_t
name|symsize
decl_stmt|;
if|if
condition|(
name|addr_to_sym
argument_list|(
operator|*
name|addrp
argument_list|,
operator|&
name|symoff
argument_list|,
operator|&
name|symsize
argument_list|)
operator|!=
name|NULL
operator|&&
name|symoff
operator|<
name|symsize
condition|)
operator|*
name|addrp
operator|-=
name|symoff
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|predicate_add
parameter_list|(
name|char
modifier|*
modifier|*
name|pred
parameter_list|,
name|char
modifier|*
name|what
parameter_list|,
name|char
modifier|*
name|cmp
parameter_list|,
name|uintptr_t
name|value
parameter_list|)
block|{
name|char
modifier|*
name|new
decl_stmt|;
name|int
name|len
decl_stmt|,
name|newlen
decl_stmt|;
if|if
condition|(
name|what
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
operator|*
name|pred
operator|==
name|NULL
condition|)
block|{
operator|*
name|pred
operator|=
name|malloc
argument_list|(
literal|1
argument_list|)
expr_stmt|;
operator|*
name|pred
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
name|len
operator|=
name|strlen
argument_list|(
operator|*
name|pred
argument_list|)
expr_stmt|;
name|newlen
operator|=
name|len
operator|+
name|strlen
argument_list|(
name|what
argument_list|)
operator|+
literal|32
operator|+
name|strlen
argument_list|(
literal|"(&& )"
argument_list|)
expr_stmt|;
name|new
operator|=
name|malloc
argument_list|(
name|newlen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|pred
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|cmp
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|new
argument_list|,
literal|"(%s)&& (%s %s 0x%p)"
argument_list|,
operator|*
name|pred
argument_list|,
name|what
argument_list|,
name|cmp
argument_list|,
operator|(
name|void
operator|*
operator|)
name|value
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|new
argument_list|,
literal|"(%s)&& (%s)"
argument_list|,
operator|*
name|pred
argument_list|,
name|what
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|cmp
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|new
argument_list|,
literal|"%s %s 0x%p"
argument_list|,
name|what
argument_list|,
name|cmp
argument_list|,
operator|(
name|void
operator|*
operator|)
name|value
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|new
argument_list|,
literal|"%s"
argument_list|,
name|what
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
operator|*
name|pred
argument_list|)
expr_stmt|;
operator|*
name|pred
operator|=
name|new
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|predicate_destroy
parameter_list|(
name|char
modifier|*
modifier|*
name|pred
parameter_list|)
block|{
name|free
argument_list|(
operator|*
name|pred
argument_list|)
expr_stmt|;
operator|*
name|pred
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|filter_add
parameter_list|(
name|char
modifier|*
modifier|*
name|filt
parameter_list|,
name|char
modifier|*
name|what
parameter_list|,
name|uintptr_t
name|base
parameter_list|,
name|uintptr_t
name|size
parameter_list|)
block|{
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|,
modifier|*
name|c
init|=
name|buf
decl_stmt|,
modifier|*
name|new
decl_stmt|;
name|int
name|len
decl_stmt|,
name|newlen
decl_stmt|;
if|if
condition|(
operator|*
name|filt
operator|==
name|NULL
condition|)
block|{
operator|*
name|filt
operator|=
name|malloc
argument_list|(
literal|1
argument_list|)
expr_stmt|;
operator|*
name|filt
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|c
argument_list|,
literal|"%s(%s>= 0x%p&& %s< 0x%p)"
argument_list|,
operator|*
name|filt
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|?
literal|" || "
else|:
literal|""
argument_list|,
name|what
argument_list|,
operator|(
name|void
operator|*
operator|)
name|base
argument_list|,
name|what
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|base
operator|+
name|size
operator|)
argument_list|)
expr_stmt|;
name|newlen
operator|=
operator|(
name|len
operator|=
name|strlen
argument_list|(
operator|*
name|filt
argument_list|)
operator|+
literal|1
operator|)
operator|+
name|strlen
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|new
operator|=
name|malloc
argument_list|(
name|newlen
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|*
name|filt
argument_list|,
name|new
argument_list|,
name|len
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|new
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|*
name|filt
argument_list|)
expr_stmt|;
operator|*
name|filt
operator|=
name|new
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|filter_destroy
parameter_list|(
name|char
modifier|*
modifier|*
name|filt
parameter_list|)
block|{
name|free
argument_list|(
operator|*
name|filt
argument_list|)
expr_stmt|;
operator|*
name|filt
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dprog_add
parameter_list|(
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|args
decl_stmt|;
name|int
name|size
decl_stmt|,
name|offs
decl_stmt|;
name|char
name|c
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|size
operator|=
name|vsnprintf
argument_list|(
operator|&
name|c
argument_list|,
literal|1
argument_list|,
name|fmt
argument_list|,
name|args
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|g_proglen
operator|==
literal|0
condition|)
block|{
name|offs
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|offs
operator|=
name|g_proglen
operator|-
literal|1
expr_stmt|;
block|}
name|g_proglen
operator|=
name|offs
operator|+
name|size
expr_stmt|;
if|if
condition|(
operator|(
name|g_prog
operator|=
name|realloc
argument_list|(
name|g_prog
argument_list|,
name|g_proglen
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|fail
argument_list|(
literal|1
argument_list|,
literal|"failed to reallocate program text"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|vsnprintf
argument_list|(
operator|&
name|g_prog
index|[
name|offs
index|]
argument_list|,
name|size
argument_list|,
name|fmt
argument_list|,
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This function may read like an open sewer, but keep in mind that programs  * that generate other programs are rarely pretty.  If one has the unenviable  * task of maintaining or -- worse -- extending this code, use the -V option  * to examine the D program as generated by this function.  */
end_comment

begin_function
specifier|static
name|void
name|dprog_addevent
parameter_list|(
name|int
name|event
parameter_list|)
block|{
name|ls_event_info_t
modifier|*
name|info
init|=
operator|&
name|g_event_info
index|[
name|event
index|]
decl_stmt|;
name|char
modifier|*
name|pred
init|=
name|NULL
decl_stmt|;
name|char
name|stack
index|[
literal|20
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|arg0
decl_stmt|,
modifier|*
name|caller
decl_stmt|;
name|char
modifier|*
name|arg1
init|=
literal|"arg1"
decl_stmt|;
name|char
name|buf
index|[
literal|80
index|]
decl_stmt|;
name|hrtime_t
name|dur
decl_stmt|;
name|int
name|depth
decl_stmt|;
if|if
condition|(
name|info
operator|->
name|ev_name
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
return|return;
if|if
condition|(
name|info
operator|->
name|ev_type
operator|==
literal|'I'
condition|)
block|{
comment|/* 		 * For interrupt events, arg0 (normally the lock pointer) is 		 * the CPU address plus the current pil, and arg1 (normally 		 * the number of nanoseconds) is the number of nanoseconds 		 * late -- and it's stored in arg2. 		 */
name|arg0
operator|=
literal|"(uintptr_t)curthread->t_cpu + \n"
literal|"\t    curthread->t_cpu->cpu_profile_pil"
expr_stmt|;
name|caller
operator|=
literal|"(uintptr_t)arg0"
expr_stmt|;
name|arg1
operator|=
literal|"arg2"
expr_stmt|;
block|}
else|else
block|{
name|arg0
operator|=
literal|"(uintptr_t)arg0"
expr_stmt|;
name|caller
operator|=
literal|"caller"
expr_stmt|;
block|}
if|if
condition|(
name|g_recsize
operator|>
name|LS_HIST
condition|)
block|{
for|for
control|(
name|depth
operator|=
literal|0
init|;
name|g_recsize
operator|>
name|LS_STACK
argument_list|(
name|depth
argument_list|)
condition|;
name|depth
operator|++
control|)
continue|continue;
if|if
condition|(
name|g_tracing
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|stack
argument_list|,
literal|"\tstack(%d);\n"
argument_list|,
name|depth
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|stack
argument_list|,
literal|", stack(%d)"
argument_list|,
name|depth
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|stack
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|info
operator|->
name|ev_acquire
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * If this is a hold event, we need to generate an additional 		 * clause for the acquire; the clause for the release will be 		 * generated with the aggregating statement, below. 		 */
name|dprog_add
argument_list|(
literal|"%s\n"
argument_list|,
name|info
operator|->
name|ev_acquire
argument_list|)
expr_stmt|;
name|predicate_add
argument_list|(
operator|&
name|pred
argument_list|,
name|info
operator|->
name|ev_predicate
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|predicate_add
argument_list|(
operator|&
name|pred
argument_list|,
name|g_predicate
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|pred
operator|!=
name|NULL
condition|)
name|dprog_add
argument_list|(
literal|"/%s/\n"
argument_list|,
name|pred
argument_list|)
expr_stmt|;
name|dprog_add
argument_list|(
literal|"{\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"self->ev%d[(uintptr_t)arg0]"
argument_list|,
name|event
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|ev_type
operator|==
literal|'H'
condition|)
block|{
name|dprog_add
argument_list|(
literal|"\t%s = timestamp;\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * If this isn't a hold event, it's the recursive 			 * error event.  For this, we simply bump the 			 * thread-local, per-lock count. 			 */
name|dprog_add
argument_list|(
literal|"\t%s++;\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
name|dprog_add
argument_list|(
literal|"}\n\n"
argument_list|)
expr_stmt|;
name|predicate_destroy
argument_list|(
operator|&
name|pred
argument_list|)
expr_stmt|;
name|pred
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|ev_type
operator|==
literal|'E'
condition|)
block|{
comment|/* 			 * If this is the recursive lock error event, we need 			 * to generate an additional clause to decrement the 			 * thread-local, per-lock count.  This assures that we 			 * only execute the aggregating clause if we have 			 * recursive entry. 			 */
name|dprog_add
argument_list|(
literal|"%s\n"
argument_list|,
name|info
operator|->
name|ev_name
argument_list|)
expr_stmt|;
name|dprog_add
argument_list|(
literal|"/%s/\n{\n\t%s--;\n}\n\n"
argument_list|,
name|buf
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
name|predicate_add
argument_list|(
operator|&
name|pred
argument_list|,
name|buf
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|ev_type
operator|==
literal|'H'
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"timestamp -\n\t    "
literal|"self->ev%d[(uintptr_t)arg0]"
argument_list|,
name|event
argument_list|)
expr_stmt|;
block|}
name|arg1
operator|=
name|buf
expr_stmt|;
block|}
else|else
block|{
name|predicate_add
argument_list|(
operator|&
name|pred
argument_list|,
name|info
operator|->
name|ev_predicate
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|ev_type
operator|!=
literal|'I'
condition|)
name|predicate_add
argument_list|(
operator|&
name|pred
argument_list|,
name|g_predicate
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|predicate_add
argument_list|(
operator|&
name|pred
argument_list|,
name|g_ipredicate
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|dur
operator|=
name|g_min_duration
index|[
name|event
index|]
operator|)
operator|!=
literal|0
condition|)
name|predicate_add
argument_list|(
operator|&
name|pred
argument_list|,
name|arg1
argument_list|,
literal|">="
argument_list|,
name|dur
argument_list|)
expr_stmt|;
name|dprog_add
argument_list|(
literal|"%s\n"
argument_list|,
name|info
operator|->
name|ev_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|pred
operator|!=
name|NULL
condition|)
name|dprog_add
argument_list|(
literal|"/%s/\n"
argument_list|,
name|pred
argument_list|)
expr_stmt|;
name|predicate_destroy
argument_list|(
operator|&
name|pred
argument_list|)
expr_stmt|;
name|dprog_add
argument_list|(
literal|"{\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|g_tracing
condition|)
block|{
name|dprog_add
argument_list|(
literal|"\ttrace(%dULL);\n"
argument_list|,
name|event
argument_list|)
expr_stmt|;
name|dprog_add
argument_list|(
literal|"\ttrace(%s);\n"
argument_list|,
name|arg0
argument_list|)
expr_stmt|;
name|dprog_add
argument_list|(
literal|"\ttrace(%s);\n"
argument_list|,
name|caller
argument_list|)
expr_stmt|;
name|dprog_add
argument_list|(
name|stack
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * The ordering here is important:  when we process the 		 * aggregate, we count on the fact that @avg appears before 		 * @hist in program order to assure that @avg is assigned the 		 * first aggregation variable ID and @hist assigned the 		 * second; see the comment in process_aggregate() for details. 		 */
name|dprog_add
argument_list|(
literal|"\t@avg[%dULL, %s, %s%s] = avg(%s);\n"
argument_list|,
name|event
argument_list|,
name|arg0
argument_list|,
name|caller
argument_list|,
name|stack
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
if|if
condition|(
name|g_recsize
operator|>=
name|LS_HIST
condition|)
block|{
name|dprog_add
argument_list|(
literal|"\t@hist[%dULL, %s, %s%s] = quantize"
literal|"(%s);\n"
argument_list|,
name|event
argument_list|,
name|arg0
argument_list|,
name|caller
argument_list|,
name|stack
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|info
operator|->
name|ev_acquire
operator|!=
name|NULL
condition|)
name|dprog_add
argument_list|(
literal|"\tself->ev%d[arg0] = 0;\n"
argument_list|,
name|event
argument_list|)
expr_stmt|;
name|dprog_add
argument_list|(
literal|"}\n\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dprog_compile
parameter_list|()
block|{
name|dtrace_prog_t
modifier|*
name|prog
decl_stmt|;
name|dtrace_proginfo_t
name|info
decl_stmt|;
if|if
condition|(
name|g_Vflag
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"lockstat: vvvv D program vvvv\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fputs
argument_list|(
name|g_prog
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"lockstat: ^^^^ D program ^^^^\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|prog
operator|=
name|dtrace_program_strcompile
argument_list|(
name|g_dtp
argument_list|,
name|g_prog
argument_list|,
name|DTRACE_PROBESPEC_NAME
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|dfail
argument_list|(
literal|"failed to compile program"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dtrace_program_exec
argument_list|(
name|g_dtp
argument_list|,
name|prog
argument_list|,
operator|&
name|info
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|dfail
argument_list|(
literal|"failed to enable probes"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dtrace_go
argument_list|(
name|g_dtp
argument_list|)
operator|!=
literal|0
condition|)
name|dfail
argument_list|(
literal|"couldn't start tracing"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|status_fire
parameter_list|(
name|void
parameter_list|)
block|{}
end_function

begin_function
specifier|static
name|void
name|status_init
parameter_list|(
name|void
parameter_list|)
block|{
name|dtrace_optval_t
name|val
decl_stmt|,
name|status
decl_stmt|,
name|agg
decl_stmt|;
name|struct
name|sigaction
name|act
decl_stmt|;
name|struct
name|itimerspec
name|ts
decl_stmt|;
name|struct
name|sigevent
name|ev
decl_stmt|;
name|timer_t
name|tid
decl_stmt|;
if|if
condition|(
name|dtrace_getopt
argument_list|(
name|g_dtp
argument_list|,
literal|"statusrate"
argument_list|,
operator|&
name|status
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|dfail
argument_list|(
literal|"failed to get 'statusrate'"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dtrace_getopt
argument_list|(
name|g_dtp
argument_list|,
literal|"aggrate"
argument_list|,
operator|&
name|agg
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|dfail
argument_list|(
literal|"failed to get 'statusrate'"
argument_list|)
expr_stmt|;
comment|/* 	 * We would want to awaken at a rate that is the GCD of the statusrate 	 * and the aggrate -- but that seems a bit absurd.  Instead, we'll 	 * simply awaken at a rate that is the more frequent of the two, which 	 * assures that we're never later than the interval implied by the 	 * more frequent rate. 	 */
name|val
operator|=
name|status
operator|<
name|agg
condition|?
name|status
else|:
name|agg
expr_stmt|;
operator|(
name|void
operator|)
name|sigemptyset
argument_list|(
operator|&
name|act
operator|.
name|sa_mask
argument_list|)
expr_stmt|;
name|act
operator|.
name|sa_flags
operator|=
literal|0
expr_stmt|;
name|act
operator|.
name|sa_handler
operator|=
name|status_fire
expr_stmt|;
operator|(
name|void
operator|)
name|sigaction
argument_list|(
name|SIGUSR1
argument_list|,
operator|&
name|act
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ev
operator|.
name|sigev_notify
operator|=
name|SIGEV_SIGNAL
expr_stmt|;
name|ev
operator|.
name|sigev_signo
operator|=
name|SIGUSR1
expr_stmt|;
if|if
condition|(
name|timer_create
argument_list|(
name|CLOCK_REALTIME
argument_list|,
operator|&
name|ev
argument_list|,
operator|&
name|tid
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|dfail
argument_list|(
literal|"cannot create CLOCK_REALTIME timer"
argument_list|)
expr_stmt|;
name|ts
operator|.
name|it_value
operator|.
name|tv_sec
operator|=
name|val
operator|/
name|NANOSEC
expr_stmt|;
name|ts
operator|.
name|it_value
operator|.
name|tv_nsec
operator|=
name|val
operator|%
name|NANOSEC
expr_stmt|;
name|ts
operator|.
name|it_interval
operator|=
name|ts
operator|.
name|it_value
expr_stmt|;
if|if
condition|(
name|timer_settime
argument_list|(
name|tid
argument_list|,
name|TIMER_RELTIME
argument_list|,
operator|&
name|ts
argument_list|,
name|NULL
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|dfail
argument_list|(
literal|"cannot set time on CLOCK_REALTIME timer"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|status_check
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|g_tracing
operator|&&
name|dtrace_aggregate_snap
argument_list|(
name|g_dtp
argument_list|)
operator|!=
literal|0
condition|)
name|dfail
argument_list|(
literal|"failed to snap aggregate"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dtrace_status
argument_list|(
name|g_dtp
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|dfail
argument_list|(
literal|"dtrace_status()"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|lsrec_fill
parameter_list|(
name|lsrec_t
modifier|*
name|lsrec
parameter_list|,
specifier|const
name|dtrace_recdesc_t
modifier|*
name|rec
parameter_list|,
name|int
name|nrecs
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|bzero
argument_list|(
name|lsrec
argument_list|,
name|g_recsize
argument_list|)
expr_stmt|;
name|lsrec
operator|->
name|ls_count
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|g_recsize
operator|>
name|LS_HIST
operator|&&
name|nrecs
operator|<
literal|4
operator|)
operator|||
operator|(
name|nrecs
operator|<
literal|3
operator|)
condition|)
name|fail
argument_list|(
literal|0
argument_list|,
literal|"truncated DTrace record"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rec
operator|->
name|dtrd_size
operator|!=
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
condition|)
name|fail
argument_list|(
literal|0
argument_list|,
literal|"bad event size in first record"
argument_list|)
expr_stmt|;
comment|/* LINTED - alignment */
name|lsrec
operator|->
name|ls_event
operator|=
operator|(
name|uint32_t
operator|)
operator|*
operator|(
operator|(
name|uint64_t
operator|*
operator|)
operator|(
name|data
operator|+
name|rec
operator|->
name|dtrd_offset
operator|)
operator|)
expr_stmt|;
name|rec
operator|++
expr_stmt|;
if|if
condition|(
name|rec
operator|->
name|dtrd_size
operator|!=
sizeof|sizeof
argument_list|(
name|uintptr_t
argument_list|)
condition|)
name|fail
argument_list|(
literal|0
argument_list|,
literal|"bad lock address size in second record"
argument_list|)
expr_stmt|;
comment|/* LINTED - alignment */
name|lsrec
operator|->
name|ls_lock
operator|=
operator|*
operator|(
operator|(
name|uintptr_t
operator|*
operator|)
operator|(
name|data
operator|+
name|rec
operator|->
name|dtrd_offset
operator|)
operator|)
expr_stmt|;
name|rec
operator|++
expr_stmt|;
if|if
condition|(
name|rec
operator|->
name|dtrd_size
operator|!=
sizeof|sizeof
argument_list|(
name|uintptr_t
argument_list|)
condition|)
name|fail
argument_list|(
literal|0
argument_list|,
literal|"bad caller size in third record"
argument_list|)
expr_stmt|;
comment|/* LINTED - alignment */
name|lsrec
operator|->
name|ls_caller
operator|=
operator|*
operator|(
operator|(
name|uintptr_t
operator|*
operator|)
operator|(
name|data
operator|+
name|rec
operator|->
name|dtrd_offset
operator|)
operator|)
expr_stmt|;
name|rec
operator|++
expr_stmt|;
if|if
condition|(
name|g_recsize
operator|>
name|LS_HIST
condition|)
block|{
name|int
name|frames
decl_stmt|,
name|i
decl_stmt|;
name|pc_t
modifier|*
name|stack
decl_stmt|;
name|frames
operator|=
name|rec
operator|->
name|dtrd_size
operator|/
sizeof|sizeof
argument_list|(
name|pc_t
argument_list|)
expr_stmt|;
comment|/* LINTED - alignment */
name|stack
operator|=
operator|(
name|pc_t
operator|*
operator|)
operator|(
name|data
operator|+
name|rec
operator|->
name|dtrd_offset
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|frames
condition|;
name|i
operator|++
control|)
name|lsrec
operator|->
name|ls_stack
index|[
name|i
operator|-
literal|1
index|]
operator|=
name|stack
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|count_aggregate
parameter_list|(
specifier|const
name|dtrace_aggdata_t
modifier|*
name|agg
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
operator|*
operator|(
operator|(
name|size_t
operator|*
operator|)
name|arg
operator|)
operator|+=
literal|1
expr_stmt|;
return|return
operator|(
name|DTRACE_AGGWALK_NEXT
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|process_aggregate
parameter_list|(
specifier|const
name|dtrace_aggdata_t
modifier|*
name|agg
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
specifier|const
name|dtrace_aggdesc_t
modifier|*
name|aggdesc
init|=
name|agg
operator|->
name|dtada_desc
decl_stmt|;
name|caddr_t
name|data
init|=
name|agg
operator|->
name|dtada_data
decl_stmt|;
name|lsdata_t
modifier|*
name|lsdata
init|=
name|arg
decl_stmt|;
name|lsrec_t
modifier|*
name|lsrec
init|=
name|lsdata
operator|->
name|lsd_next
decl_stmt|;
specifier|const
name|dtrace_recdesc_t
modifier|*
name|rec
decl_stmt|;
name|uint64_t
modifier|*
name|avg
decl_stmt|,
modifier|*
name|quantized
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|assert
argument_list|(
name|lsdata
operator|->
name|lsd_count
operator|<
name|g_nrecs
argument_list|)
expr_stmt|;
comment|/* 	 * Aggregation variable IDs are guaranteed to be generated in program 	 * order, and they are guaranteed to start from DTRACE_AGGVARIDNONE 	 * plus one.  As "avg" appears before "hist" in program order, we know 	 * that "avg" will be allocated the first aggregation variable ID, and 	 * "hist" will be allocated the second aggregation variable ID -- and 	 * we therefore use the aggregation variable ID to differentiate the 	 * cases. 	 */
if|if
condition|(
name|aggdesc
operator|->
name|dtagd_varid
operator|>
name|DTRACE_AGGVARIDNONE
operator|+
literal|1
condition|)
block|{
comment|/* 		 * If this is the histogram entry.  We'll copy the quantized 		 * data into lc_hist, and jump over the rest. 		 */
name|rec
operator|=
operator|&
name|aggdesc
operator|->
name|dtagd_rec
index|[
name|aggdesc
operator|->
name|dtagd_nrecs
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|aggdesc
operator|->
name|dtagd_varid
operator|!=
name|DTRACE_AGGVARIDNONE
operator|+
literal|2
condition|)
name|fail
argument_list|(
literal|0
argument_list|,
literal|"bad variable ID in aggregation record"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rec
operator|->
name|dtrd_size
operator|!=
name|DTRACE_QUANTIZE_NBUCKETS
operator|*
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
condition|)
name|fail
argument_list|(
literal|0
argument_list|,
literal|"bad quantize size in aggregation record"
argument_list|)
expr_stmt|;
comment|/* LINTED - alignment */
name|quantized
operator|=
operator|(
name|uint64_t
operator|*
operator|)
operator|(
name|data
operator|+
name|rec
operator|->
name|dtrd_offset
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|DTRACE_QUANTIZE_ZEROBUCKET
operator|,
name|j
operator|=
literal|0
init|;
name|i
operator|<
name|DTRACE_QUANTIZE_NBUCKETS
condition|;
name|i
operator|++
operator|,
name|j
operator|++
control|)
name|lsrec
operator|->
name|ls_hist
index|[
name|j
index|]
operator|=
name|quantized
index|[
name|i
index|]
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|lsrec_fill
argument_list|(
name|lsrec
argument_list|,
operator|&
name|aggdesc
operator|->
name|dtagd_rec
index|[
literal|1
index|]
argument_list|,
name|aggdesc
operator|->
name|dtagd_nrecs
operator|-
literal|1
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|rec
operator|=
operator|&
name|aggdesc
operator|->
name|dtagd_rec
index|[
name|aggdesc
operator|->
name|dtagd_nrecs
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|rec
operator|->
name|dtrd_size
operator|!=
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
condition|)
name|fail
argument_list|(
literal|0
argument_list|,
literal|"bad avg size in aggregation record"
argument_list|)
expr_stmt|;
comment|/* LINTED - alignment */
name|avg
operator|=
operator|(
name|uint64_t
operator|*
operator|)
operator|(
name|data
operator|+
name|rec
operator|->
name|dtrd_offset
operator|)
expr_stmt|;
name|lsrec
operator|->
name|ls_count
operator|=
operator|(
name|uint32_t
operator|)
name|avg
index|[
literal|0
index|]
expr_stmt|;
name|lsrec
operator|->
name|ls_time
operator|=
operator|(
name|uintptr_t
operator|)
name|avg
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|g_recsize
operator|>=
name|LS_HIST
condition|)
return|return
operator|(
name|DTRACE_AGGWALK_NEXT
operator|)
return|;
name|out
label|:
name|lsdata
operator|->
name|lsd_next
operator|=
operator|(
name|lsrec_t
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|lsrec
operator|+
name|g_recsize
operator|)
expr_stmt|;
name|lsdata
operator|->
name|lsd_count
operator|++
expr_stmt|;
return|return
operator|(
name|DTRACE_AGGWALK_NEXT
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|process_trace
parameter_list|(
specifier|const
name|dtrace_probedata_t
modifier|*
name|pdata
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|lsdata_t
modifier|*
name|lsdata
init|=
name|arg
decl_stmt|;
name|lsrec_t
modifier|*
name|lsrec
init|=
name|lsdata
operator|->
name|lsd_next
decl_stmt|;
name|dtrace_eprobedesc_t
modifier|*
name|edesc
init|=
name|pdata
operator|->
name|dtpda_edesc
decl_stmt|;
name|caddr_t
name|data
init|=
name|pdata
operator|->
name|dtpda_data
decl_stmt|;
if|if
condition|(
name|lsdata
operator|->
name|lsd_count
operator|>=
name|g_nrecs
condition|)
return|return
operator|(
name|DTRACE_CONSUME_NEXT
operator|)
return|;
name|lsrec_fill
argument_list|(
name|lsrec
argument_list|,
name|edesc
operator|->
name|dtepd_rec
argument_list|,
name|edesc
operator|->
name|dtepd_nrecs
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|lsdata
operator|->
name|lsd_next
operator|=
operator|(
name|lsrec_t
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|lsrec
operator|+
name|g_recsize
operator|)
expr_stmt|;
name|lsdata
operator|->
name|lsd_count
operator|++
expr_stmt|;
return|return
operator|(
name|DTRACE_CONSUME_NEXT
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|process_data
parameter_list|(
name|FILE
modifier|*
name|out
parameter_list|,
name|char
modifier|*
name|data
parameter_list|)
block|{
name|lsdata_t
name|lsdata
decl_stmt|;
comment|/* LINTED - alignment */
name|lsdata
operator|.
name|lsd_next
operator|=
operator|(
name|lsrec_t
operator|*
operator|)
name|data
expr_stmt|;
name|lsdata
operator|.
name|lsd_count
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|g_tracing
condition|)
block|{
if|if
condition|(
name|dtrace_consume
argument_list|(
name|g_dtp
argument_list|,
name|out
argument_list|,
name|process_trace
argument_list|,
name|NULL
argument_list|,
operator|&
name|lsdata
argument_list|)
operator|!=
literal|0
condition|)
name|dfail
argument_list|(
literal|"failed to consume buffer"
argument_list|)
expr_stmt|;
return|return
operator|(
name|lsdata
operator|.
name|lsd_count
operator|)
return|;
block|}
if|if
condition|(
name|dtrace_aggregate_walk_keyvarsorted
argument_list|(
name|g_dtp
argument_list|,
name|process_aggregate
argument_list|,
operator|&
name|lsdata
argument_list|)
operator|!=
literal|0
condition|)
name|dfail
argument_list|(
literal|"failed to walk aggregate"
argument_list|)
expr_stmt|;
return|return
operator|(
name|lsdata
operator|.
name|lsd_count
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|drophandler
parameter_list|(
specifier|const
name|dtrace_dropdata_t
modifier|*
name|data
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|g_dropped
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"lockstat: warning: %s"
argument_list|,
name|data
operator|->
name|dtdda_msg
argument_list|)
expr_stmt|;
return|return
operator|(
name|DTRACE_HANDLE_OK
operator|)
return|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|char
modifier|*
name|data_buf
decl_stmt|;
name|lsrec_t
modifier|*
name|lsp
decl_stmt|,
modifier|*
modifier|*
name|current
decl_stmt|,
modifier|*
modifier|*
name|first
decl_stmt|,
modifier|*
modifier|*
name|sort_buf
decl_stmt|,
modifier|*
modifier|*
name|merge_buf
decl_stmt|;
name|FILE
modifier|*
name|out
init|=
name|stdout
decl_stmt|;
name|char
name|c
decl_stmt|;
name|pid_t
name|child
decl_stmt|;
name|int
name|status
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|hrtime_t
name|duration
decl_stmt|;
name|char
modifier|*
name|addrp
decl_stmt|,
modifier|*
name|offp
decl_stmt|,
modifier|*
name|sizep
decl_stmt|,
modifier|*
name|evp
decl_stmt|,
modifier|*
name|lastp
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|uintptr_t
name|addr
decl_stmt|;
name|size_t
name|size
decl_stmt|,
name|off
decl_stmt|;
name|int
name|events_specified
init|=
literal|0
decl_stmt|;
name|int
name|exec_errno
init|=
literal|0
decl_stmt|;
name|uint32_t
name|event
decl_stmt|;
name|char
modifier|*
name|filt
init|=
name|NULL
decl_stmt|,
modifier|*
name|ifilt
init|=
name|NULL
decl_stmt|;
specifier|static
name|uint64_t
name|ev_count
index|[
name|LS_MAX_EVENTS
operator|+
literal|1
index|]
decl_stmt|;
specifier|static
name|uint64_t
name|ev_time
index|[
name|LS_MAX_EVENTS
operator|+
literal|1
index|]
decl_stmt|;
name|dtrace_optval_t
name|aggsize
decl_stmt|;
name|char
name|aggstr
index|[
literal|10
index|]
decl_stmt|;
name|long
name|ncpus
decl_stmt|;
name|int
name|dynvar
init|=
literal|0
decl_stmt|;
name|int
name|err
decl_stmt|;
if|if
condition|(
operator|(
name|g_dtp
operator|=
name|dtrace_open
argument_list|(
name|DTRACE_VERSION
argument_list|,
literal|0
argument_list|,
operator|&
name|err
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fail
argument_list|(
literal|0
argument_list|,
literal|"cannot open dtrace library: %s"
argument_list|,
name|dtrace_errmsg
argument_list|(
name|NULL
argument_list|,
name|err
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dtrace_handle_drop
argument_list|(
name|g_dtp
argument_list|,
operator|&
name|drophandler
argument_list|,
name|NULL
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|dfail
argument_list|(
literal|"couldn't establish drop handler"
argument_list|)
expr_stmt|;
if|if
condition|(
name|symtab_init
argument_list|()
operator|==
operator|-
literal|1
condition|)
name|fail
argument_list|(
literal|1
argument_list|,
literal|"can't load kernel symbols"
argument_list|)
expr_stmt|;
name|g_nrecs
operator|=
name|DEFAULT_NRECS
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|LOCKSTAT_OPTSTR
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'b'
case|:
name|g_recsize
operator|=
name|LS_BASIC
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|g_recsize
operator|=
name|LS_TIME
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
name|g_recsize
operator|=
name|LS_HIST
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
if|if
condition|(
operator|!
name|isdigit
argument_list|(
name|optarg
index|[
literal|0
index|]
argument_list|)
condition|)
name|usage
argument_list|()
expr_stmt|;
name|g_stkdepth
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|g_stkdepth
operator|>
name|LS_MAX_STACK_DEPTH
condition|)
name|fail
argument_list|(
literal|0
argument_list|,
literal|"max stack depth is %d"
argument_list|,
name|LS_MAX_STACK_DEPTH
argument_list|)
expr_stmt|;
name|g_recsize
operator|=
name|LS_STACK
argument_list|(
name|g_stkdepth
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
if|if
condition|(
operator|!
name|isdigit
argument_list|(
name|optarg
index|[
literal|0
index|]
argument_list|)
condition|)
name|usage
argument_list|()
expr_stmt|;
name|g_nrecs
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
if|if
condition|(
operator|!
name|isdigit
argument_list|(
name|optarg
index|[
literal|0
index|]
argument_list|)
condition|)
name|usage
argument_list|()
expr_stmt|;
name|duration
operator|=
name|atoll
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
comment|/* 			 * XXX -- durations really should be per event 			 * since the units are different, but it's hard 			 * to express this nicely in the interface. 			 * Not clear yet what the cleanest solution is. 			 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|LS_MAX_EVENTS
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|g_event_info
index|[
name|i
index|]
operator|.
name|ev_type
operator|!=
literal|'E'
condition|)
name|g_min_duration
index|[
name|i
index|]
operator|=
name|duration
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
if|if
condition|(
operator|!
name|isdigit
argument_list|(
name|optarg
index|[
literal|0
index|]
argument_list|)
condition|)
name|usage
argument_list|()
expr_stmt|;
name|i
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<=
literal|0
condition|)
name|usage
argument_list|()
expr_stmt|;
if|if
condition|(
name|i
operator|>
name|MAX_HZ
condition|)
name|fail
argument_list|(
literal|0
argument_list|,
literal|"max interrupt rate is %d Hz"
argument_list|,
name|MAX_HZ
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|LS_MAX_EVENTS
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|g_event_info
index|[
name|j
index|]
operator|.
name|ev_desc
argument_list|,
literal|"Profiling interrupt"
argument_list|)
operator|==
literal|0
condition|)
break|break;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|g_event_info
index|[
name|j
index|]
operator|.
name|ev_name
argument_list|,
literal|"profile:::profile-%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
case|case
literal|'f'
case|:
name|addrp
operator|=
name|strtok
argument_list|(
name|optarg
argument_list|,
literal|","
argument_list|)
expr_stmt|;
name|sizep
operator|=
name|strtok
argument_list|(
name|NULL
argument_list|,
literal|","
argument_list|)
expr_stmt|;
name|addrp
operator|=
name|strtok
argument_list|(
name|optarg
argument_list|,
literal|",+"
argument_list|)
expr_stmt|;
name|offp
operator|=
name|strtok
argument_list|(
name|NULL
argument_list|,
literal|","
argument_list|)
expr_stmt|;
name|size
operator|=
name|sizep
condition|?
name|strtoul
argument_list|(
name|sizep
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
else|:
literal|1
expr_stmt|;
name|off
operator|=
name|offp
condition|?
name|strtoul
argument_list|(
name|offp
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|addrp
index|[
literal|0
index|]
operator|==
literal|'0'
condition|)
block|{
name|addr
operator|=
name|strtoul
argument_list|(
name|addrp
argument_list|,
name|NULL
argument_list|,
literal|16
argument_list|)
operator|+
name|off
expr_stmt|;
block|}
else|else
block|{
name|addr
operator|=
name|sym_to_addr
argument_list|(
name|addrp
argument_list|)
operator|+
name|off
expr_stmt|;
if|if
condition|(
name|sizep
operator|==
name|NULL
condition|)
name|size
operator|=
name|sym_size
argument_list|(
name|addrp
argument_list|)
operator|-
name|off
expr_stmt|;
if|if
condition|(
name|addr
operator|-
name|off
operator|==
literal|0
condition|)
name|fail
argument_list|(
literal|0
argument_list|,
literal|"symbol '%s' not found"
argument_list|,
name|addrp
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
name|size
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
literal|'l'
condition|)
block|{
name|filter_add
argument_list|(
operator|&
name|filt
argument_list|,
literal|"arg0"
argument_list|,
name|addr
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|filter_add
argument_list|(
operator|&
name|filt
argument_list|,
literal|"caller"
argument_list|,
name|addr
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|filter_add
argument_list|(
operator|&
name|ifilt
argument_list|,
literal|"arg0"
argument_list|,
name|addr
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'e'
case|:
name|evp
operator|=
name|strtok_r
argument_list|(
name|optarg
argument_list|,
literal|","
argument_list|,
operator|&
name|lastp
argument_list|)
expr_stmt|;
while|while
condition|(
name|evp
condition|)
block|{
name|int
name|ev1
decl_stmt|,
name|ev2
decl_stmt|;
name|char
modifier|*
name|evp2
decl_stmt|;
operator|(
name|void
operator|)
name|strtok
argument_list|(
name|evp
argument_list|,
literal|"-"
argument_list|)
expr_stmt|;
name|evp2
operator|=
name|strtok
argument_list|(
name|NULL
argument_list|,
literal|"-"
argument_list|)
expr_stmt|;
name|ev1
operator|=
name|atoi
argument_list|(
name|evp
argument_list|)
expr_stmt|;
name|ev2
operator|=
name|evp2
condition|?
name|atoi
argument_list|(
name|evp2
argument_list|)
else|:
name|ev1
expr_stmt|;
if|if
condition|(
operator|(
name|uint_t
operator|)
name|ev1
operator|>=
name|LS_MAX_EVENTS
operator|||
operator|(
name|uint_t
operator|)
name|ev2
operator|>=
name|LS_MAX_EVENTS
operator|||
name|ev1
operator|>
name|ev2
condition|)
name|fail
argument_list|(
literal|0
argument_list|,
literal|"-e events out of range"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|ev1
init|;
name|i
operator|<=
name|ev2
condition|;
name|i
operator|++
control|)
name|g_enabled
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
name|evp
operator|=
name|strtok_r
argument_list|(
name|NULL
argument_list|,
literal|","
argument_list|,
operator|&
name|lastp
argument_list|)
expr_stmt|;
block|}
name|events_specified
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|g_cflag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'k'
case|:
name|g_kflag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|g_wflag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'W'
case|:
name|g_Wflag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
name|g_gflag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
case|case
literal|'E'
case|:
case|case
literal|'H'
case|:
case|case
literal|'I'
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|LS_MAX_EVENTS
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|g_event_info
index|[
name|i
index|]
operator|.
name|ev_type
operator|==
name|c
condition|)
name|g_enabled
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
name|events_specified
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'A'
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|LS_MAX_EVENTS
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strchr
argument_list|(
literal|"CH"
argument_list|,
name|g_event_info
index|[
name|i
index|]
operator|.
name|ev_type
argument_list|)
condition|)
name|g_enabled
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
name|events_specified
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
name|g_tracing
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
if|if
condition|(
operator|!
name|isdigit
argument_list|(
name|optarg
index|[
literal|0
index|]
argument_list|)
condition|)
name|usage
argument_list|()
expr_stmt|;
name|g_topn
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
name|g_rates
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|g_pflag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
name|g_Pflag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
if|if
condition|(
operator|(
name|out
operator|=
name|fopen
argument_list|(
name|optarg
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|fail
argument_list|(
literal|1
argument_list|,
literal|"error opening file"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
name|g_Vflag
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|strchr
argument_list|(
name|LOCKSTAT_OPTSTR
argument_list|,
name|c
argument_list|)
operator|==
name|NULL
condition|)
name|usage
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|filt
operator|!=
name|NULL
condition|)
block|{
name|predicate_add
argument_list|(
operator|&
name|g_predicate
argument_list|,
name|filt
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|filter_destroy
argument_list|(
operator|&
name|filt
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ifilt
operator|!=
name|NULL
condition|)
block|{
name|predicate_add
argument_list|(
operator|&
name|g_ipredicate
argument_list|,
name|ifilt
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|filter_destroy
argument_list|(
operator|&
name|ifilt
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|g_recsize
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|g_gflag
condition|)
block|{
name|g_stkdepth
operator|=
name|LS_MAX_STACK_DEPTH
expr_stmt|;
name|g_recsize
operator|=
name|LS_STACK
argument_list|(
name|g_stkdepth
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|g_recsize
operator|=
name|LS_TIME
expr_stmt|;
block|}
block|}
if|if
condition|(
name|g_gflag
operator|&&
name|g_recsize
operator|<=
name|LS_STACK
argument_list|(
literal|0
argument_list|)
condition|)
name|fail
argument_list|(
literal|0
argument_list|,
literal|"'-g' requires at least '-s 1' data gathering"
argument_list|)
expr_stmt|;
comment|/* 	 * Make sure the alignment is reasonable 	 */
name|g_recsize
operator|=
operator|-
operator|(
operator|-
name|g_recsize
operator|&
operator|-
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|LS_MAX_EVENTS
condition|;
name|i
operator|++
control|)
block|{
comment|/* 		 * If no events were specified, enable -C. 		 */
if|if
condition|(
operator|!
name|events_specified
operator|&&
name|g_event_info
index|[
name|i
index|]
operator|.
name|ev_type
operator|==
literal|'C'
condition|)
name|g_enabled
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|LS_MAX_EVENTS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|g_enabled
index|[
name|i
index|]
condition|)
continue|continue;
if|if
condition|(
name|g_event_info
index|[
name|i
index|]
operator|.
name|ev_acquire
operator|!=
name|NULL
condition|)
block|{
comment|/* 			 * If we've enabled a hold event, we must explicitly 			 * allocate dynamic variable space. 			 */
name|dynvar
operator|=
literal|1
expr_stmt|;
block|}
name|dprog_addevent
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Make sure there are remaining arguments to specify a child command 	 * to execute. 	 */
if|if
condition|(
name|argc
operator|<=
name|optind
condition|)
name|usage
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|ncpus
operator|=
name|sysconf
argument_list|(
name|_SC_NPROCESSORS_ONLN
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
name|dfail
argument_list|(
literal|"couldn't determine number of online CPUs"
argument_list|)
expr_stmt|;
comment|/* 	 * By default, we set our data buffer size to be the number of records 	 * multiplied by the size of the record, doubled to account for some 	 * DTrace slop and divided by the number of CPUs.  We silently clamp 	 * the aggregation size at both a minimum and a maximum to prevent 	 * absurdly low or high values. 	 */
if|if
condition|(
operator|(
name|aggsize
operator|=
operator|(
name|g_nrecs
operator|*
name|g_recsize
operator|*
literal|2
operator|)
operator|/
name|ncpus
operator|)
operator|<
name|MIN_AGGSIZE
condition|)
name|aggsize
operator|=
name|MIN_AGGSIZE
expr_stmt|;
if|if
condition|(
name|aggsize
operator|>
name|MAX_AGGSIZE
condition|)
name|aggsize
operator|=
name|MAX_AGGSIZE
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|aggstr
argument_list|,
literal|"%lld"
argument_list|,
operator|(
name|long
name|long
operator|)
name|aggsize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|g_tracing
condition|)
block|{
if|if
condition|(
name|dtrace_setopt
argument_list|(
name|g_dtp
argument_list|,
literal|"bufsize"
argument_list|,
literal|"4k"
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|dfail
argument_list|(
literal|"failed to set 'bufsize'"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dtrace_setopt
argument_list|(
name|g_dtp
argument_list|,
literal|"aggsize"
argument_list|,
name|aggstr
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|dfail
argument_list|(
literal|"failed to set 'aggsize'"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dynvar
condition|)
block|{
comment|/* 			 * If we're using dynamic variables, we set our 			 * dynamic variable size to be one megabyte per CPU, 			 * with a hard-limit of 32 megabytes.  This may still 			 * be too small in some cases, but it can be tuned 			 * manually via -x if need be. 			 */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|aggstr
argument_list|,
literal|"%ldm"
argument_list|,
name|ncpus
operator|<
literal|32
condition|?
name|ncpus
else|:
literal|32
argument_list|)
expr_stmt|;
if|if
condition|(
name|dtrace_setopt
argument_list|(
name|g_dtp
argument_list|,
literal|"dynvarsize"
argument_list|,
name|aggstr
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|dfail
argument_list|(
literal|"failed to set 'dynvarsize'"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|dtrace_setopt
argument_list|(
name|g_dtp
argument_list|,
literal|"bufsize"
argument_list|,
name|aggstr
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|dfail
argument_list|(
literal|"failed to set 'bufsize'"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dtrace_setopt
argument_list|(
name|g_dtp
argument_list|,
literal|"statusrate"
argument_list|,
literal|"10sec"
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|dfail
argument_list|(
literal|"failed to set 'statusrate'"
argument_list|)
expr_stmt|;
name|optind
operator|=
literal|1
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|LOCKSTAT_OPTSTR
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'x'
case|:
if|if
condition|(
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|optarg
argument_list|,
literal|'='
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|dtrace_setopt
argument_list|(
name|g_dtp
argument_list|,
name|optarg
argument_list|,
name|p
argument_list|)
operator|!=
literal|0
condition|)
name|dfail
argument_list|(
literal|"failed to set -x %s"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
name|dprog_compile
argument_list|()
expr_stmt|;
name|status_init
argument_list|()
expr_stmt|;
name|g_elapsed
operator|=
operator|-
name|gethrtime
argument_list|()
expr_stmt|;
comment|/* 	 * Spawn the specified command and wait for it to complete. 	 */
name|child
operator|=
name|fork
argument_list|()
expr_stmt|;
if|if
condition|(
name|child
operator|==
operator|-
literal|1
condition|)
name|fail
argument_list|(
literal|1
argument_list|,
literal|"cannot fork"
argument_list|)
expr_stmt|;
if|if
condition|(
name|child
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|dtrace_close
argument_list|(
name|g_dtp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|execvp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
operator|&
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|exec_errno
operator|=
name|errno
expr_stmt|;
name|exit
argument_list|(
literal|127
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|waitpid
argument_list|(
name|child
argument_list|,
operator|&
name|status
argument_list|,
name|WEXITED
argument_list|)
operator|!=
name|child
condition|)
name|status_check
argument_list|()
expr_stmt|;
name|g_elapsed
operator|+=
name|gethrtime
argument_list|()
expr_stmt|;
if|if
condition|(
name|WIFEXITED
argument_list|(
name|status
argument_list|)
condition|)
block|{
if|if
condition|(
name|WEXITSTATUS
argument_list|(
name|status
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|exec_errno
operator|!=
literal|0
condition|)
block|{
name|errno
operator|=
name|exec_errno
expr_stmt|;
name|fail
argument_list|(
literal|1
argument_list|,
literal|"could not execute %s"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"lockstat: warning: %s exited with code %d\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|WEXITSTATUS
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"lockstat: warning: %s died on signal %d\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|WTERMSIG
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dtrace_stop
argument_list|(
name|g_dtp
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|dfail
argument_list|(
literal|"failed to stop dtrace"
argument_list|)
expr_stmt|;
comment|/* 	 * Before we read out the results, we need to allocate our buffer. 	 * If we're tracing, then we'll just use the precalculated size.  If 	 * we're not, then we'll take a snapshot of the aggregate, and walk 	 * it to count the number of records. 	 */
if|if
condition|(
operator|!
name|g_tracing
condition|)
block|{
if|if
condition|(
name|dtrace_aggregate_snap
argument_list|(
name|g_dtp
argument_list|)
operator|!=
literal|0
condition|)
name|dfail
argument_list|(
literal|"failed to snap aggregate"
argument_list|)
expr_stmt|;
name|g_nrecs
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dtrace_aggregate_walk
argument_list|(
name|g_dtp
argument_list|,
name|count_aggregate
argument_list|,
operator|&
name|g_nrecs
argument_list|)
operator|!=
literal|0
condition|)
name|dfail
argument_list|(
literal|"failed to walk aggregate"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|data_buf
operator|=
name|memalign
argument_list|(
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
operator|(
name|g_nrecs
operator|+
literal|1
operator|)
operator|*
name|g_recsize
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|fail
argument_list|(
literal|1
argument_list|,
literal|"Memory allocation failed"
argument_list|)
expr_stmt|;
comment|/* 	 * Read out the DTrace data. 	 */
name|g_nrecs_used
operator|=
name|process_data
argument_list|(
name|out
argument_list|,
name|data_buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|g_nrecs_used
operator|>
name|g_nrecs
operator|||
name|g_dropped
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"lockstat: warning: "
literal|"ran out of data records (use -n for more)\n"
argument_list|)
expr_stmt|;
comment|/* LINTED - alignment */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|lsp
operator|=
operator|(
name|lsrec_t
operator|*
operator|)
name|data_buf
init|;
name|i
operator|<
name|g_nrecs_used
condition|;
name|i
operator|++
operator|,
comment|/* LINTED - alignment */
name|lsp
operator|=
operator|(
name|lsrec_t
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|lsp
operator|+
name|g_recsize
operator|)
control|)
block|{
name|ev_count
index|[
name|lsp
operator|->
name|ls_event
index|]
operator|+=
name|lsp
operator|->
name|ls_count
expr_stmt|;
name|ev_time
index|[
name|lsp
operator|->
name|ls_event
index|]
operator|+=
name|lsp
operator|->
name|ls_time
expr_stmt|;
block|}
comment|/* 	 * If -g was specified, convert stacks into individual records. 	 */
if|if
condition|(
name|g_gflag
condition|)
block|{
name|lsrec_t
modifier|*
name|newlsp
decl_stmt|,
modifier|*
name|oldlsp
decl_stmt|;
name|newlsp
operator|=
name|memalign
argument_list|(
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
name|g_nrecs_used
operator|*
name|LS_TIME
operator|*
operator|(
name|g_stkdepth
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|newlsp
operator|==
name|NULL
condition|)
name|fail
argument_list|(
literal|1
argument_list|,
literal|"Cannot allocate space for -g processing"
argument_list|)
expr_stmt|;
name|lsp
operator|=
name|newlsp
expr_stmt|;
comment|/* LINTED - alignment */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|oldlsp
operator|=
operator|(
name|lsrec_t
operator|*
operator|)
name|data_buf
init|;
name|i
operator|<
name|g_nrecs_used
condition|;
name|i
operator|++
operator|,
comment|/* LINTED - alignment */
name|oldlsp
operator|=
operator|(
name|lsrec_t
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|oldlsp
operator|+
name|g_recsize
operator|)
control|)
block|{
name|int
name|fr
decl_stmt|;
name|int
name|caller_in_stack
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|oldlsp
operator|->
name|ls_count
operator|==
literal|0
condition|)
continue|continue;
for|for
control|(
name|fr
operator|=
literal|0
init|;
name|fr
operator|<
name|g_stkdepth
condition|;
name|fr
operator|++
control|)
block|{
if|if
condition|(
name|oldlsp
operator|->
name|ls_stack
index|[
name|fr
index|]
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|oldlsp
operator|->
name|ls_stack
index|[
name|fr
index|]
operator|==
name|oldlsp
operator|->
name|ls_caller
condition|)
name|caller_in_stack
operator|=
literal|1
expr_stmt|;
name|bcopy
argument_list|(
name|oldlsp
argument_list|,
name|lsp
argument_list|,
name|LS_TIME
argument_list|)
expr_stmt|;
name|lsp
operator|->
name|ls_caller
operator|=
name|oldlsp
operator|->
name|ls_stack
index|[
name|fr
index|]
expr_stmt|;
comment|/* LINTED - alignment */
name|lsp
operator|=
operator|(
name|lsrec_t
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|lsp
operator|+
name|LS_TIME
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|caller_in_stack
condition|)
block|{
name|bcopy
argument_list|(
name|oldlsp
argument_list|,
name|lsp
argument_list|,
name|LS_TIME
argument_list|)
expr_stmt|;
comment|/* LINTED - alignment */
name|lsp
operator|=
operator|(
name|lsrec_t
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|lsp
operator|+
name|LS_TIME
operator|)
expr_stmt|;
block|}
block|}
name|g_nrecs
operator|=
name|g_nrecs_used
operator|=
operator|(
operator|(
name|uintptr_t
operator|)
name|lsp
operator|-
operator|(
name|uintptr_t
operator|)
name|newlsp
operator|)
operator|/
name|LS_TIME
expr_stmt|;
name|g_recsize
operator|=
name|LS_TIME
expr_stmt|;
name|g_stkdepth
operator|=
literal|0
expr_stmt|;
name|free
argument_list|(
name|data_buf
argument_list|)
expr_stmt|;
name|data_buf
operator|=
operator|(
name|char
operator|*
operator|)
name|newlsp
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|sort_buf
operator|=
name|calloc
argument_list|(
literal|2
operator|*
operator|(
name|g_nrecs
operator|+
literal|1
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|fail
argument_list|(
literal|1
argument_list|,
literal|"Sort buffer allocation failed"
argument_list|)
expr_stmt|;
name|merge_buf
operator|=
name|sort_buf
operator|+
operator|(
name|g_nrecs
operator|+
literal|1
operator|)
expr_stmt|;
comment|/* 	 * Build the sort buffer, discarding zero-count records along the way. 	 */
comment|/* LINTED - alignment */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|lsp
operator|=
operator|(
name|lsrec_t
operator|*
operator|)
name|data_buf
init|;
name|i
operator|<
name|g_nrecs_used
condition|;
name|i
operator|++
operator|,
comment|/* LINTED - alignment */
name|lsp
operator|=
operator|(
name|lsrec_t
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|lsp
operator|+
name|g_recsize
operator|)
control|)
block|{
if|if
condition|(
name|lsp
operator|->
name|ls_count
operator|==
literal|0
condition|)
name|lsp
operator|->
name|ls_event
operator|=
name|LS_MAX_EVENTS
expr_stmt|;
name|sort_buf
index|[
name|i
index|]
operator|=
name|lsp
expr_stmt|;
block|}
if|if
condition|(
name|g_nrecs_used
operator|==
literal|0
condition|)
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Add a sentinel after the last record 	 */
name|sort_buf
index|[
name|i
index|]
operator|=
name|lsp
expr_stmt|;
name|lsp
operator|->
name|ls_event
operator|=
name|LS_MAX_EVENTS
expr_stmt|;
if|if
condition|(
name|g_tracing
condition|)
block|{
name|report_trace
argument_list|(
name|out
argument_list|,
name|sort_buf
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Application of -g may have resulted in multiple records 	 * with the same signature; coalesce them. 	 */
if|if
condition|(
name|g_gflag
condition|)
block|{
name|mergesort
argument_list|(
name|lockcmp
argument_list|,
name|sort_buf
argument_list|,
name|merge_buf
argument_list|,
name|g_nrecs_used
argument_list|)
expr_stmt|;
name|coalesce
argument_list|(
name|lockcmp
argument_list|,
name|sort_buf
argument_list|,
name|g_nrecs_used
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Coalesce locks within the same symbol if -c option specified. 	 * Coalesce PCs within the same function if -k option specified. 	 */
if|if
condition|(
name|g_cflag
operator|||
name|g_kflag
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|g_nrecs_used
condition|;
name|i
operator|++
control|)
block|{
name|int
name|fr
decl_stmt|;
name|lsp
operator|=
name|sort_buf
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|g_cflag
condition|)
name|coalesce_symbol
argument_list|(
operator|&
name|lsp
operator|->
name|ls_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|g_kflag
condition|)
block|{
for|for
control|(
name|fr
operator|=
literal|0
init|;
name|fr
operator|<
name|g_stkdepth
condition|;
name|fr
operator|++
control|)
name|coalesce_symbol
argument_list|(
operator|&
name|lsp
operator|->
name|ls_stack
index|[
name|fr
index|]
argument_list|)
expr_stmt|;
name|coalesce_symbol
argument_list|(
operator|&
name|lsp
operator|->
name|ls_caller
argument_list|)
expr_stmt|;
block|}
block|}
name|mergesort
argument_list|(
name|lockcmp
argument_list|,
name|sort_buf
argument_list|,
name|merge_buf
argument_list|,
name|g_nrecs_used
argument_list|)
expr_stmt|;
name|coalesce
argument_list|(
name|lockcmp
argument_list|,
name|sort_buf
argument_list|,
name|g_nrecs_used
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Coalesce callers if -w option specified 	 */
if|if
condition|(
name|g_wflag
condition|)
block|{
name|mergesort
argument_list|(
name|lock_and_count_cmp_anywhere
argument_list|,
name|sort_buf
argument_list|,
name|merge_buf
argument_list|,
name|g_nrecs_used
argument_list|)
expr_stmt|;
name|coalesce
argument_list|(
name|lockcmp_anywhere
argument_list|,
name|sort_buf
argument_list|,
name|g_nrecs_used
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Coalesce locks if -W option specified 	 */
if|if
condition|(
name|g_Wflag
condition|)
block|{
name|mergesort
argument_list|(
name|site_and_count_cmp_anylock
argument_list|,
name|sort_buf
argument_list|,
name|merge_buf
argument_list|,
name|g_nrecs_used
argument_list|)
expr_stmt|;
name|coalesce
argument_list|(
name|sitecmp_anylock
argument_list|,
name|sort_buf
argument_list|,
name|g_nrecs_used
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Sort data by contention count (ls_count) or total time (ls_time), 	 * depending on g_Pflag.  Override g_Pflag if time wasn't measured. 	 */
if|if
condition|(
name|g_recsize
operator|<
name|LS_TIME
condition|)
name|g_Pflag
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|g_Pflag
condition|)
name|mergesort
argument_list|(
name|timecmp
argument_list|,
name|sort_buf
argument_list|,
name|merge_buf
argument_list|,
name|g_nrecs_used
argument_list|)
expr_stmt|;
else|else
name|mergesort
argument_list|(
name|countcmp
argument_list|,
name|sort_buf
argument_list|,
name|merge_buf
argument_list|,
name|g_nrecs_used
argument_list|)
expr_stmt|;
comment|/* 	 * Display data by event type 	 */
name|first
operator|=
operator|&
name|sort_buf
index|[
literal|0
index|]
expr_stmt|;
while|while
condition|(
operator|(
name|event
operator|=
operator|(
operator|*
name|first
operator|)
operator|->
name|ls_event
operator|)
operator|<
name|LS_MAX_EVENTS
condition|)
block|{
name|current
operator|=
name|first
expr_stmt|;
while|while
condition|(
operator|(
name|lsp
operator|=
operator|*
name|current
operator|)
operator|->
name|ls_event
operator|==
name|event
condition|)
name|current
operator|++
expr_stmt|;
name|report_stats
argument_list|(
name|out
argument_list|,
name|first
argument_list|,
name|current
operator|-
name|first
argument_list|,
name|ev_count
index|[
name|event
index|]
argument_list|,
name|ev_time
index|[
name|event
index|]
argument_list|)
expr_stmt|;
name|first
operator|=
name|current
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|format_symbol
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|uintptr_t
name|addr
parameter_list|,
name|int
name|show_size
parameter_list|)
block|{
name|uintptr_t
name|symoff
decl_stmt|;
name|char
modifier|*
name|symname
decl_stmt|;
name|size_t
name|symsize
decl_stmt|;
name|symname
operator|=
name|addr_to_sym
argument_list|(
name|addr
argument_list|,
operator|&
name|symoff
argument_list|,
operator|&
name|symsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|show_size
operator|&&
name|symoff
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s[%ld]"
argument_list|,
name|symname
argument_list|,
operator|(
name|long
operator|)
name|symsize
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|symoff
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s"
argument_list|,
name|symname
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|symoff
operator|<
literal|16
operator|&&
name|bcmp
argument_list|(
name|symname
argument_list|,
literal|"cpu["
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
comment|/* CPU+PIL */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s+%ld"
argument_list|,
name|symname
argument_list|,
operator|(
name|long
operator|)
name|symoff
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|symoff
operator|<=
name|symsize
operator|||
operator|(
name|symoff
operator|<
literal|256
operator|&&
name|addr
operator|!=
name|symoff
operator|)
condition|)
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s+0x%llx"
argument_list|,
name|symname
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|symoff
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"0x%llx"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|addr
argument_list|)
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|report_stats
parameter_list|(
name|FILE
modifier|*
name|out
parameter_list|,
name|lsrec_t
modifier|*
modifier|*
name|sort_buf
parameter_list|,
name|size_t
name|nrecs
parameter_list|,
name|uint64_t
name|total_count
parameter_list|,
name|uint64_t
name|total_time
parameter_list|)
block|{
name|uint32_t
name|event
init|=
name|sort_buf
index|[
literal|0
index|]
operator|->
name|ls_event
decl_stmt|;
name|lsrec_t
modifier|*
name|lsp
decl_stmt|;
name|double
name|ptotal
init|=
literal|0.0
decl_stmt|;
name|double
name|percent
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|fr
decl_stmt|;
name|int
name|displayed
decl_stmt|;
name|int
name|first_bin
decl_stmt|,
name|last_bin
decl_stmt|,
name|max_bin_count
decl_stmt|,
name|total_bin_count
decl_stmt|;
name|int
name|rectype
decl_stmt|;
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
name|char
name|lhdr
index|[
literal|80
index|]
decl_stmt|,
name|chdr
index|[
literal|80
index|]
decl_stmt|;
name|rectype
operator|=
name|g_recsize
expr_stmt|;
if|if
condition|(
name|g_topn
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"%20llu %s\n"
argument_list|,
name|g_rates
operator|==
literal|0
condition|?
name|total_count
else|:
operator|(
operator|(
name|unsigned
name|long
name|long
operator|)
name|total_count
operator|*
name|NANOSEC
operator|)
operator|/
name|g_elapsed
argument_list|,
name|g_event_info
index|[
name|event
index|]
operator|.
name|ev_desc
argument_list|)
expr_stmt|;
return|return;
block|}
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|lhdr
argument_list|,
literal|"%s%s"
argument_list|,
name|g_Wflag
condition|?
literal|"Hottest "
else|:
literal|""
argument_list|,
name|g_event_info
index|[
name|event
index|]
operator|.
name|ev_lhdr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|chdr
argument_list|,
literal|"%s%s"
argument_list|,
name|g_wflag
condition|?
literal|"Hottest "
else|:
literal|""
argument_list|,
literal|"Caller"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|g_pflag
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\n%s: %.0f events in %.3f seconds (%.0f events/sec)\n\n"
argument_list|,
name|g_event_info
index|[
name|event
index|]
operator|.
name|ev_desc
argument_list|,
operator|(
name|double
operator|)
name|total_count
argument_list|,
operator|(
name|double
operator|)
name|g_elapsed
operator|/
name|NANOSEC
argument_list|,
operator|(
name|double
operator|)
name|total_count
operator|*
name|NANOSEC
operator|/
name|g_elapsed
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|g_pflag
operator|&&
name|rectype
operator|<
name|LS_HIST
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s"
argument_list|,
name|g_event_info
index|[
name|event
index|]
operator|.
name|ev_units
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"%5s %4s %4s %4s %8s %-22s %-24s\n"
argument_list|,
name|g_rates
condition|?
literal|"ops/s"
else|:
literal|"Count"
argument_list|,
name|g_gflag
condition|?
literal|"genr"
else|:
literal|"indv"
argument_list|,
literal|"cuml"
argument_list|,
literal|"rcnt"
argument_list|,
name|rectype
operator|>=
name|LS_TIME
condition|?
name|buf
else|:
literal|""
argument_list|,
name|lhdr
argument_list|,
name|chdr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"---------------------------------"
literal|"----------------------------------------------\n"
argument_list|)
expr_stmt|;
block|}
name|displayed
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nrecs
condition|;
name|i
operator|++
control|)
block|{
name|lsp
operator|=
name|sort_buf
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|displayed
operator|++
operator|>=
name|g_topn
condition|)
break|break;
if|if
condition|(
name|g_pflag
condition|)
block|{
name|int
name|j
decl_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"%u %u"
argument_list|,
name|lsp
operator|->
name|ls_event
argument_list|,
name|lsp
operator|->
name|ls_count
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|" %s"
argument_list|,
name|format_symbol
argument_list|(
name|buf
argument_list|,
name|lsp
operator|->
name|ls_lock
argument_list|,
name|g_cflag
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|" %s"
argument_list|,
name|format_symbol
argument_list|(
name|buf
argument_list|,
name|lsp
operator|->
name|ls_caller
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|" %f"
argument_list|,
operator|(
name|double
operator|)
name|lsp
operator|->
name|ls_refcnt
operator|/
name|lsp
operator|->
name|ls_count
argument_list|)
expr_stmt|;
if|if
condition|(
name|rectype
operator|>=
name|LS_TIME
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|" %llu"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|lsp
operator|->
name|ls_time
argument_list|)
expr_stmt|;
if|if
condition|(
name|rectype
operator|>=
name|LS_HIST
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|64
condition|;
name|j
operator|++
control|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|" %u"
argument_list|,
name|lsp
operator|->
name|ls_hist
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|LS_MAX_STACK_DEPTH
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|rectype
operator|<=
name|LS_STACK
argument_list|(
name|j
argument_list|)
operator|||
name|lsp
operator|->
name|ls_stack
index|[
name|j
index|]
operator|==
literal|0
condition|)
break|break;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|" %s"
argument_list|,
name|format_symbol
argument_list|(
name|buf
argument_list|,
name|lsp
operator|->
name|ls_stack
index|[
name|j
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|rectype
operator|>=
name|LS_HIST
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"---------------------------------"
literal|"----------------------------------------------\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s"
argument_list|,
name|g_event_info
index|[
name|event
index|]
operator|.
name|ev_units
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"%5s %4s %4s %4s %8s %-22s %-24s\n"
argument_list|,
name|g_rates
condition|?
literal|"ops/s"
else|:
literal|"Count"
argument_list|,
name|g_gflag
condition|?
literal|"genr"
else|:
literal|"indv"
argument_list|,
literal|"cuml"
argument_list|,
literal|"rcnt"
argument_list|,
name|buf
argument_list|,
name|lhdr
argument_list|,
name|chdr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|g_Pflag
operator|&&
name|total_time
operator|!=
literal|0
condition|)
name|percent
operator|=
operator|(
name|lsp
operator|->
name|ls_time
operator|*
literal|100.00
operator|)
operator|/
name|total_time
expr_stmt|;
else|else
name|percent
operator|=
operator|(
name|lsp
operator|->
name|ls_count
operator|*
literal|100.00
operator|)
operator|/
name|total_count
expr_stmt|;
name|ptotal
operator|+=
name|percent
expr_stmt|;
if|if
condition|(
name|rectype
operator|>=
name|LS_TIME
condition|)
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%llu"
argument_list|,
call|(
name|unsigned
name|long
name|long
call|)
argument_list|(
name|lsp
operator|->
name|ls_time
operator|/
name|lsp
operator|->
name|ls_count
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|buf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"%5llu "
argument_list|,
name|g_rates
operator|==
literal|0
condition|?
name|lsp
operator|->
name|ls_count
else|:
operator|(
operator|(
name|uint64_t
operator|)
name|lsp
operator|->
name|ls_count
operator|*
name|NANOSEC
operator|)
operator|/
name|g_elapsed
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"%3.0f%% "
argument_list|,
name|percent
argument_list|)
expr_stmt|;
if|if
condition|(
name|g_gflag
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"---- "
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"%3.0f%% "
argument_list|,
name|ptotal
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"%4.2f %8s "
argument_list|,
operator|(
name|double
operator|)
name|lsp
operator|->
name|ls_refcnt
operator|/
name|lsp
operator|->
name|ls_count
argument_list|,
name|buf
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"%-22s "
argument_list|,
name|format_symbol
argument_list|(
name|buf
argument_list|,
name|lsp
operator|->
name|ls_lock
argument_list|,
name|g_cflag
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"%-24s\n"
argument_list|,
name|format_symbol
argument_list|(
name|buf
argument_list|,
name|lsp
operator|->
name|ls_caller
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rectype
operator|<
name|LS_HIST
condition|)
continue|continue;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"%10s %31s %-9s %-24s\n"
argument_list|,
name|g_event_info
index|[
name|event
index|]
operator|.
name|ev_units
argument_list|,
literal|"------ Time Distribution ------"
argument_list|,
name|g_rates
condition|?
literal|"ops/s"
else|:
literal|"count"
argument_list|,
name|rectype
operator|>
name|LS_STACK
argument_list|(
literal|0
argument_list|)
condition|?
literal|"Stack"
else|:
literal|""
argument_list|)
expr_stmt|;
name|first_bin
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|lsp
operator|->
name|ls_hist
index|[
name|first_bin
index|]
operator|==
literal|0
condition|)
name|first_bin
operator|++
expr_stmt|;
name|last_bin
operator|=
literal|63
expr_stmt|;
while|while
condition|(
name|lsp
operator|->
name|ls_hist
index|[
name|last_bin
index|]
operator|==
literal|0
condition|)
name|last_bin
operator|--
expr_stmt|;
name|max_bin_count
operator|=
literal|0
expr_stmt|;
name|total_bin_count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
name|first_bin
init|;
name|j
operator|<=
name|last_bin
condition|;
name|j
operator|++
control|)
block|{
name|total_bin_count
operator|+=
name|lsp
operator|->
name|ls_hist
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
name|lsp
operator|->
name|ls_hist
index|[
name|j
index|]
operator|>
name|max_bin_count
condition|)
name|max_bin_count
operator|=
name|lsp
operator|->
name|ls_hist
index|[
name|j
index|]
expr_stmt|;
block|}
comment|/* 		 * If we went a few frames below the caller, ignore them 		 */
for|for
control|(
name|fr
operator|=
literal|3
init|;
name|fr
operator|>
literal|0
condition|;
name|fr
operator|--
control|)
if|if
condition|(
name|lsp
operator|->
name|ls_stack
index|[
name|fr
index|]
operator|==
name|lsp
operator|->
name|ls_caller
condition|)
break|break;
for|for
control|(
name|j
operator|=
name|first_bin
init|;
name|j
operator|<=
name|last_bin
condition|;
name|j
operator|++
control|)
block|{
name|uint_t
name|depth
init|=
operator|(
name|lsp
operator|->
name|ls_hist
index|[
name|j
index|]
operator|*
literal|30
operator|)
operator|/
name|total_bin_count
decl_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"%10llu |%s%s %-9u "
argument_list|,
literal|1ULL
operator|<<
name|j
argument_list|,
literal|"@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@"
operator|+
literal|30
operator|-
name|depth
argument_list|,
literal|"                              "
operator|+
name|depth
argument_list|,
name|g_rates
operator|==
literal|0
condition|?
name|lsp
operator|->
name|ls_hist
index|[
name|j
index|]
else|:
call|(
name|uint_t
call|)
argument_list|(
operator|(
operator|(
name|uint64_t
operator|)
name|lsp
operator|->
name|ls_hist
index|[
name|j
index|]
operator|*
name|NANOSEC
operator|)
operator|/
name|g_elapsed
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rectype
operator|<=
name|LS_STACK
argument_list|(
name|fr
argument_list|)
operator|||
name|lsp
operator|->
name|ls_stack
index|[
name|fr
index|]
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"%-24s\n"
argument_list|,
name|format_symbol
argument_list|(
name|buf
argument_list|,
name|lsp
operator|->
name|ls_stack
index|[
name|fr
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|fr
operator|++
expr_stmt|;
block|}
while|while
condition|(
name|rectype
operator|>
name|LS_STACK
argument_list|(
name|fr
argument_list|)
operator|&&
name|lsp
operator|->
name|ls_stack
index|[
name|fr
index|]
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"%15s %-36s %-24s\n"
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
name|format_symbol
argument_list|(
name|buf
argument_list|,
name|lsp
operator|->
name|ls_stack
index|[
name|fr
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|fr
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|g_pflag
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"---------------------------------"
literal|"----------------------------------------------\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|out
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|report_trace
parameter_list|(
name|FILE
modifier|*
name|out
parameter_list|,
name|lsrec_t
modifier|*
modifier|*
name|sort_buf
parameter_list|)
block|{
name|lsrec_t
modifier|*
name|lsp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|fr
decl_stmt|;
name|int
name|rectype
decl_stmt|;
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|,
name|buf2
index|[
literal|256
index|]
decl_stmt|;
name|rectype
operator|=
name|g_recsize
expr_stmt|;
if|if
condition|(
operator|!
name|g_pflag
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"%5s  %7s  %11s  %-24s  %-24s\n"
argument_list|,
literal|"Event"
argument_list|,
literal|"Time"
argument_list|,
literal|"Owner"
argument_list|,
literal|"Lock"
argument_list|,
literal|"Caller"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"---------------------------------"
literal|"----------------------------------------------\n"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|g_nrecs_used
condition|;
name|i
operator|++
control|)
block|{
name|lsp
operator|=
name|sort_buf
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|lsp
operator|->
name|ls_event
operator|>=
name|LS_MAX_EVENTS
operator|||
name|lsp
operator|->
name|ls_count
operator|==
literal|0
condition|)
continue|continue;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"%2d  %10llu  %11p  %-24s  %-24s\n"
argument_list|,
name|lsp
operator|->
name|ls_event
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|lsp
operator|->
name|ls_time
argument_list|,
operator|(
name|void
operator|*
operator|)
name|lsp
operator|->
name|ls_next
argument_list|,
name|format_symbol
argument_list|(
name|buf
argument_list|,
name|lsp
operator|->
name|ls_lock
argument_list|,
literal|0
argument_list|)
argument_list|,
name|format_symbol
argument_list|(
name|buf2
argument_list|,
name|lsp
operator|->
name|ls_caller
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rectype
operator|<=
name|LS_STACK
argument_list|(
literal|0
argument_list|)
condition|)
continue|continue;
comment|/* 		 * If we went a few frames below the caller, ignore them 		 */
for|for
control|(
name|fr
operator|=
literal|3
init|;
name|fr
operator|>
literal|0
condition|;
name|fr
operator|--
control|)
if|if
condition|(
name|lsp
operator|->
name|ls_stack
index|[
name|fr
index|]
operator|==
name|lsp
operator|->
name|ls_caller
condition|)
break|break;
while|while
condition|(
name|rectype
operator|>
name|LS_STACK
argument_list|(
name|fr
argument_list|)
operator|&&
name|lsp
operator|->
name|ls_stack
index|[
name|fr
index|]
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"%53s  %-24s\n"
argument_list|,
literal|""
argument_list|,
name|format_symbol
argument_list|(
name|buf
argument_list|,
name|lsp
operator|->
name|ls_stack
index|[
name|fr
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|fr
operator|++
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|out
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

